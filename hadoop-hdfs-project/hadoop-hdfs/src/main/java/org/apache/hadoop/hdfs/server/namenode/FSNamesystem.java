begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdfs.server.namenode
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|crypto
operator|.
name|key
operator|.
name|KeyProviderCryptoExtension
operator|.
name|EncryptedKeyVersion
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|CommonConfigurationKeysPublic
operator|.
name|FS_TRASH_INTERVAL_DEFAULT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|CommonConfigurationKeysPublic
operator|.
name|FS_TRASH_INTERVAL_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|CommonConfigurationKeysPublic
operator|.
name|IO_FILE_BUFFER_SIZE_DEFAULT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|CommonConfigurationKeysPublic
operator|.
name|IO_FILE_BUFFER_SIZE_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_BLOCK_SIZE_DEFAULT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_BLOCK_SIZE_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_BYTES_PER_CHECKSUM_DEFAULT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_BYTES_PER_CHECKSUM_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_CHECKSUM_TYPE_DEFAULT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_CHECKSUM_TYPE_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_CLIENT_WRITE_PACKET_SIZE_DEFAULT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_CLIENT_WRITE_PACKET_SIZE_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_ENCRYPT_DATA_TRANSFER_DEFAULT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_ENCRYPT_DATA_TRANSFER_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_HA_STANDBY_CHECKPOINTS_DEFAULT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_HA_STANDBY_CHECKPOINTS_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_ACCESSTIME_PRECISION_DEFAULT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_ACCESSTIME_PRECISION_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_AUDIT_LOGGERS_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_AUDIT_LOG_ASYNC_DEFAULT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_AUDIT_LOG_ASYNC_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_AUDIT_LOG_TOKEN_TRACKING_ID_DEFAULT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_AUDIT_LOG_TOKEN_TRACKING_ID_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_CHECKPOINT_TXNS_DEFAULT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_CHECKPOINT_TXNS_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_DEFAULT_AUDIT_LOGGER_NAME
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_DELEGATION_KEY_UPDATE_INTERVAL_DEFAULT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_DELEGATION_KEY_UPDATE_INTERVAL_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_DELEGATION_TOKEN_ALWAYS_USE_DEFAULT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_DELEGATION_TOKEN_ALWAYS_USE_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_DELEGATION_TOKEN_MAX_LIFETIME_DEFAULT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_DELEGATION_TOKEN_MAX_LIFETIME_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_DELEGATION_TOKEN_RENEW_INTERVAL_DEFAULT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_DELEGATION_TOKEN_RENEW_INTERVAL_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_EDITS_DIR_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_EDITS_DIR_REQUIRED_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_EDIT_LOG_AUTOROLL_CHECK_INTERVAL_MS
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_EDIT_LOG_AUTOROLL_CHECK_INTERVAL_MS_DEFAULT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_EDIT_LOG_AUTOROLL_MULTIPLIER_THRESHOLD
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_EDIT_LOG_AUTOROLL_MULTIPLIER_THRESHOLD_DEFAULT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_ENABLE_RETRY_CACHE_DEFAULT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_ENABLE_RETRY_CACHE_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_LAZY_PERSIST_FILE_SCRUB_INTERVAL_SEC
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_LAZY_PERSIST_FILE_SCRUB_INTERVAL_SEC_DEFAULT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_INODE_ATTRIBUTES_PROVIDER_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_MAX_OBJECTS_DEFAULT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_MAX_OBJECTS_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_NAME_DIR_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_REPLICATION_MIN_DEFAULT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_REPLICATION_MIN_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_REPL_QUEUE_THRESHOLD_PCT_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_RESOURCE_CHECK_INTERVAL_DEFAULT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_RESOURCE_CHECK_INTERVAL_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_RETRY_CACHE_EXPIRYTIME_MILLIS_DEFAULT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_RETRY_CACHE_EXPIRYTIME_MILLIS_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_RETRY_CACHE_HEAP_PERCENT_DEFAULT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_RETRY_CACHE_HEAP_PERCENT_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_SAFEMODE_EXTENSION_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_SAFEMODE_MIN_DATANODES_DEFAULT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_SAFEMODE_MIN_DATANODES_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_SAFEMODE_THRESHOLD_PCT_DEFAULT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_SAFEMODE_THRESHOLD_PCT_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_SHARED_EDITS_DIR_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_PERMISSIONS_ENABLED_DEFAULT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_PERMISSIONS_ENABLED_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_PERMISSIONS_SUPERUSERGROUP_DEFAULT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_PERMISSIONS_SUPERUSERGROUP_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_REPLICATION_DEFAULT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_REPLICATION_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|HdfsServerConstants
operator|.
name|SECURITY_XATTR_UNREADABLE_BY_SUPERUSER
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Time
operator|.
name|now
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Time
operator|.
name|monotonicNow
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|BufferedWriter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataInput
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileNotFoundException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStreamWriter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|PrintWriter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|StringWriter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|management
operator|.
name|ManagementFactory
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|InetAddress
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URI
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|GeneralSecurityException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Date
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|EnumSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|Condition
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|ReentrantLock
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|ReentrantReadWriteLock
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|management
operator|.
name|NotCompliantMBeanException
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|management
operator|.
name|ObjectName
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|management
operator|.
name|StandardMBean
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|impl
operator|.
name|Log4JLogger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|HadoopIllegalArgumentException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|crypto
operator|.
name|CipherSuite
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|crypto
operator|.
name|CryptoProtocolVersion
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|crypto
operator|.
name|key
operator|.
name|KeyProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|crypto
operator|.
name|key
operator|.
name|KeyProviderCryptoExtension
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|BatchedRemoteIterator
operator|.
name|BatchedListEntries
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|CacheFlag
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|ContentSummary
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|CreateFlag
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileAlreadyExistsException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileEncryptionInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FsServerDefaults
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|InvalidPathException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Options
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|ParentNotDirectoryException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|UnresolvedLinkException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|XAttr
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|XAttrSetFlag
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|permission
operator|.
name|AclEntry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|permission
operator|.
name|AclStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|permission
operator|.
name|FsAction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|permission
operator|.
name|FsPermission
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|permission
operator|.
name|PermissionStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|StorageType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ha
operator|.
name|HAServiceProtocol
operator|.
name|HAServiceState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ha
operator|.
name|ServiceFailedException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|BlockStoragePolicy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|HAUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|HdfsConfiguration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|UnknownCryptoProtocolVersionException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|XAttrHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|AlreadyBeingCreatedException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|Block
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|CacheDirectiveEntry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|CacheDirectiveInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|CachePoolEntry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|CachePoolInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|ClientProtocol
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|DatanodeID
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|DatanodeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|DirectoryListing
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|EncryptionZone
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|ExtendedBlock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|HdfsConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|HdfsConstantsClient
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|LastBlockWithStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|HdfsConstants
operator|.
name|DatanodeReportType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|HdfsConstants
operator|.
name|SafeModeAction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|HdfsFileStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|LocatedBlock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|LocatedBlocks
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|QuotaExceededException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|RecoveryInProgressException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|RollingUpgradeException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|RollingUpgradeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|SnapshotAccessControlException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|SnapshotDiffReport
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|SnapshottableDirectoryStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|datatransfer
operator|.
name|ReplaceDatanodeOnFailure
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|security
operator|.
name|token
operator|.
name|block
operator|.
name|BlockTokenIdentifier
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|security
operator|.
name|token
operator|.
name|delegation
operator|.
name|DelegationTokenIdentifier
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|security
operator|.
name|token
operator|.
name|delegation
operator|.
name|DelegationTokenSecretManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|security
operator|.
name|token
operator|.
name|delegation
operator|.
name|DelegationTokenSecretManager
operator|.
name|SecretManagerState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|blockmanagement
operator|.
name|BlockCollection
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|blockmanagement
operator|.
name|BlockIdManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|blockmanagement
operator|.
name|BlockInfoContiguous
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|blockmanagement
operator|.
name|BlockInfoContiguousUnderConstruction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|blockmanagement
operator|.
name|BlockManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|blockmanagement
operator|.
name|DatanodeDescriptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|blockmanagement
operator|.
name|DatanodeManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|blockmanagement
operator|.
name|DatanodeStatistics
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|blockmanagement
operator|.
name|DatanodeStorageInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|HdfsServerConstants
operator|.
name|BlockUCState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|HdfsServerConstants
operator|.
name|NamenodeRole
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|HdfsServerConstants
operator|.
name|RollingUpgradeStartupOption
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|HdfsServerConstants
operator|.
name|StartupOption
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|Storage
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|Storage
operator|.
name|StorageDirType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|Storage
operator|.
name|StorageDirectory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|Util
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|FsImageProto
operator|.
name|SecretManagerSection
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|INode
operator|.
name|BlocksMapUpdateInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|JournalSet
operator|.
name|JournalAndStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|LeaseManager
operator|.
name|Lease
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|NNStorage
operator|.
name|NameNodeFile
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|NameNode
operator|.
name|OperationCategory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|ha
operator|.
name|EditLogTailer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|ha
operator|.
name|HAContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|ha
operator|.
name|StandbyCheckpointer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|metrics
operator|.
name|FSNamesystemMBean
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|metrics
operator|.
name|NameNodeMetrics
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|snapshot
operator|.
name|Snapshot
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|snapshot
operator|.
name|SnapshotManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|startupprogress
operator|.
name|Phase
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|startupprogress
operator|.
name|StartupProgress
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|startupprogress
operator|.
name|StartupProgress
operator|.
name|Counter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|startupprogress
operator|.
name|Status
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|startupprogress
operator|.
name|Step
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|startupprogress
operator|.
name|StepType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|top
operator|.
name|TopAuditLogger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|top
operator|.
name|TopConf
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|top
operator|.
name|metrics
operator|.
name|TopMetrics
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|top
operator|.
name|window
operator|.
name|RollingWindowManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|web
operator|.
name|resources
operator|.
name|NamenodeWebHdfsMethods
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|DatanodeCommand
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|DatanodeRegistration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|DatanodeStorageReport
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|HeartbeatResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|NNHAStatusHeartbeat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|NamenodeCommand
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|NamenodeRegistration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|NamespaceInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|StorageReceivedDeletedBlocks
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|StorageReport
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|VolumeFailureSummary
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|EnumSetWritable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|Text
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|RetriableException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|RetryCache
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|Server
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|StandbyException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|metrics2
operator|.
name|annotation
operator|.
name|Metric
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|metrics2
operator|.
name|annotation
operator|.
name|Metrics
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|metrics2
operator|.
name|lib
operator|.
name|DefaultMetricsSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|metrics2
operator|.
name|util
operator|.
name|MBeans
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|net
operator|.
name|NetworkTopology
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|net
operator|.
name|Node
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|net
operator|.
name|NodeBase
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|AccessControlException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|UserGroupInformation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|UserGroupInformation
operator|.
name|AuthenticationMethod
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|token
operator|.
name|SecretManager
operator|.
name|InvalidToken
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|token
operator|.
name|Token
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|token
operator|.
name|TokenIdentifier
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|token
operator|.
name|delegation
operator|.
name|DelegationKey
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|ChunkedArrayList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Daemon
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|DataChecksum
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|ReflectionUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|VersionInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|log4j
operator|.
name|Appender
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|log4j
operator|.
name|AsyncAppender
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|log4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|codehaus
operator|.
name|jackson
operator|.
name|map
operator|.
name|ObjectMapper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|mortbay
operator|.
name|util
operator|.
name|ajax
operator|.
name|JSON
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Charsets
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableMap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_comment
comment|/**  * FSNamesystem is a container of both transient  * and persisted name-space state, and does all the book-keeping  * work on a NameNode.  *  * Its roles are briefly described below:  *  * 1) Is the container for BlockManager, DatanodeManager,  *    DelegationTokens, LeaseManager, etc. services.  * 2) RPC calls that modify or inspect the name-space  *    should get delegated here.  * 3) Anything that touches only blocks (eg. block reports),  *    it delegates to BlockManager.  * 4) Anything that touches only file information (eg. permissions, mkdirs),  *    it delegates to FSDirectory.  * 5) Anything that crosses two of the above components should be  *    coordinated here.  * 6) Logs mutations to FSEditLog.  *  * This class and its contents keep:  *  * 1)  Valid fsname --> blocklist  (kept on disk, logged)  * 2)  Set of all valid blocks (inverted #1)  * 3)  block --> machinelist (kept in memory, rebuilt dynamically from reports)  * 4)  machine --> blocklist (inverted #2)  * 5)  LRU cache of updated-heartbeat machines  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
annotation|@
name|Metrics
argument_list|(
name|context
operator|=
literal|"dfs"
argument_list|)
DECL|class|FSNamesystem
specifier|public
class|class
name|FSNamesystem
implements|implements
name|Namesystem
implements|,
name|FSNamesystemMBean
implements|,
name|NameNodeMXBean
block|{
DECL|field|LOG
specifier|public
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|FSNamesystem
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|auditBuffer
specifier|private
specifier|static
specifier|final
name|ThreadLocal
argument_list|<
name|StringBuilder
argument_list|>
name|auditBuffer
init|=
operator|new
name|ThreadLocal
argument_list|<
name|StringBuilder
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|protected
name|StringBuilder
name|initialValue
parameter_list|()
block|{
return|return
operator|new
name|StringBuilder
argument_list|()
return|;
block|}
block|}
decl_stmt|;
DECL|field|blockIdManager
specifier|private
specifier|final
name|BlockIdManager
name|blockIdManager
decl_stmt|;
annotation|@
name|VisibleForTesting
DECL|method|isAuditEnabled ()
specifier|public
name|boolean
name|isAuditEnabled
parameter_list|()
block|{
return|return
operator|!
name|isDefaultAuditLogger
operator|||
name|auditLog
operator|.
name|isInfoEnabled
argument_list|()
return|;
block|}
DECL|method|logAuditEvent (boolean succeeded, String cmd, String src)
specifier|private
name|void
name|logAuditEvent
parameter_list|(
name|boolean
name|succeeded
parameter_list|,
name|String
name|cmd
parameter_list|,
name|String
name|src
parameter_list|)
throws|throws
name|IOException
block|{
name|logAuditEvent
argument_list|(
name|succeeded
argument_list|,
name|cmd
argument_list|,
name|src
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
DECL|method|logAuditEvent (boolean succeeded, String cmd, String src, String dst, HdfsFileStatus stat)
specifier|private
name|void
name|logAuditEvent
parameter_list|(
name|boolean
name|succeeded
parameter_list|,
name|String
name|cmd
parameter_list|,
name|String
name|src
parameter_list|,
name|String
name|dst
parameter_list|,
name|HdfsFileStatus
name|stat
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|isAuditEnabled
argument_list|()
operator|&&
name|isExternalInvocation
argument_list|()
condition|)
block|{
name|logAuditEvent
argument_list|(
name|succeeded
argument_list|,
name|getRemoteUser
argument_list|()
argument_list|,
name|getRemoteIp
argument_list|()
argument_list|,
name|cmd
argument_list|,
name|src
argument_list|,
name|dst
argument_list|,
name|stat
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|logAuditEvent (boolean succeeded, UserGroupInformation ugi, InetAddress addr, String cmd, String src, String dst, HdfsFileStatus stat)
specifier|private
name|void
name|logAuditEvent
parameter_list|(
name|boolean
name|succeeded
parameter_list|,
name|UserGroupInformation
name|ugi
parameter_list|,
name|InetAddress
name|addr
parameter_list|,
name|String
name|cmd
parameter_list|,
name|String
name|src
parameter_list|,
name|String
name|dst
parameter_list|,
name|HdfsFileStatus
name|stat
parameter_list|)
block|{
name|FileStatus
name|status
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|stat
operator|!=
literal|null
condition|)
block|{
name|Path
name|symlink
init|=
name|stat
operator|.
name|isSymlink
argument_list|()
condition|?
operator|new
name|Path
argument_list|(
name|stat
operator|.
name|getSymlink
argument_list|()
argument_list|)
else|:
literal|null
decl_stmt|;
name|Path
name|path
init|=
name|dst
operator|!=
literal|null
condition|?
operator|new
name|Path
argument_list|(
name|dst
argument_list|)
else|:
operator|new
name|Path
argument_list|(
name|src
argument_list|)
decl_stmt|;
name|status
operator|=
operator|new
name|FileStatus
argument_list|(
name|stat
operator|.
name|getLen
argument_list|()
argument_list|,
name|stat
operator|.
name|isDir
argument_list|()
argument_list|,
name|stat
operator|.
name|getReplication
argument_list|()
argument_list|,
name|stat
operator|.
name|getBlockSize
argument_list|()
argument_list|,
name|stat
operator|.
name|getModificationTime
argument_list|()
argument_list|,
name|stat
operator|.
name|getAccessTime
argument_list|()
argument_list|,
name|stat
operator|.
name|getPermission
argument_list|()
argument_list|,
name|stat
operator|.
name|getOwner
argument_list|()
argument_list|,
name|stat
operator|.
name|getGroup
argument_list|()
argument_list|,
name|symlink
argument_list|,
name|path
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|AuditLogger
name|logger
range|:
name|auditLoggers
control|)
block|{
if|if
condition|(
name|logger
operator|instanceof
name|HdfsAuditLogger
condition|)
block|{
name|HdfsAuditLogger
name|hdfsLogger
init|=
operator|(
name|HdfsAuditLogger
operator|)
name|logger
decl_stmt|;
name|hdfsLogger
operator|.
name|logAuditEvent
argument_list|(
name|succeeded
argument_list|,
name|ugi
operator|.
name|toString
argument_list|()
argument_list|,
name|addr
argument_list|,
name|cmd
argument_list|,
name|src
argument_list|,
name|dst
argument_list|,
name|status
argument_list|,
name|ugi
argument_list|,
name|dtSecretManager
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|logger
operator|.
name|logAuditEvent
argument_list|(
name|succeeded
argument_list|,
name|ugi
operator|.
name|toString
argument_list|()
argument_list|,
name|addr
argument_list|,
name|cmd
argument_list|,
name|src
argument_list|,
name|dst
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Logger for audit events, noting successful FSNamesystem operations. Emits    * to FSNamesystem.audit at INFO. Each event causes a set of tab-separated    *<code>key=value</code> pairs to be written for the following properties:    *<code>    * ugi=&lt;ugi in RPC&gt;    * ip=&lt;remote IP&gt;    * cmd=&lt;command&gt;    * src=&lt;src path&gt;    * dst=&lt;dst path (optional)&gt;    * perm=&lt;permissions (optional)&gt;    *</code>    */
DECL|field|auditLog
specifier|public
specifier|static
specifier|final
name|Log
name|auditLog
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|FSNamesystem
operator|.
name|class
operator|.
name|getName
argument_list|()
operator|+
literal|".audit"
argument_list|)
decl_stmt|;
DECL|field|DEFAULT_MAX_CORRUPT_FILEBLOCKS_RETURNED
specifier|static
specifier|final
name|int
name|DEFAULT_MAX_CORRUPT_FILEBLOCKS_RETURNED
init|=
literal|100
decl_stmt|;
DECL|field|BLOCK_DELETION_INCREMENT
specifier|static
name|int
name|BLOCK_DELETION_INCREMENT
init|=
literal|1000
decl_stmt|;
DECL|field|isPermissionEnabled
specifier|private
specifier|final
name|boolean
name|isPermissionEnabled
decl_stmt|;
DECL|field|fsOwner
specifier|private
specifier|final
name|UserGroupInformation
name|fsOwner
decl_stmt|;
DECL|field|supergroup
specifier|private
specifier|final
name|String
name|supergroup
decl_stmt|;
DECL|field|standbyShouldCheckpoint
specifier|private
specifier|final
name|boolean
name|standbyShouldCheckpoint
decl_stmt|;
comment|// Scan interval is not configurable.
DECL|field|DELEGATION_TOKEN_REMOVER_SCAN_INTERVAL
specifier|private
specifier|static
specifier|final
name|long
name|DELEGATION_TOKEN_REMOVER_SCAN_INTERVAL
init|=
name|TimeUnit
operator|.
name|MILLISECONDS
operator|.
name|convert
argument_list|(
literal|1
argument_list|,
name|TimeUnit
operator|.
name|HOURS
argument_list|)
decl_stmt|;
DECL|field|dtSecretManager
specifier|final
name|DelegationTokenSecretManager
name|dtSecretManager
decl_stmt|;
DECL|field|alwaysUseDelegationTokensForTests
specifier|private
specifier|final
name|boolean
name|alwaysUseDelegationTokensForTests
decl_stmt|;
DECL|field|STEP_AWAITING_REPORTED_BLOCKS
specifier|private
specifier|static
specifier|final
name|Step
name|STEP_AWAITING_REPORTED_BLOCKS
init|=
operator|new
name|Step
argument_list|(
name|StepType
operator|.
name|AWAITING_REPORTED_BLOCKS
argument_list|)
decl_stmt|;
comment|// Tracks whether the default audit logger is the only configured audit
comment|// logger; this allows isAuditEnabled() to return false in case the
comment|// underlying logger is disabled, and avoid some unnecessary work.
DECL|field|isDefaultAuditLogger
specifier|private
specifier|final
name|boolean
name|isDefaultAuditLogger
decl_stmt|;
DECL|field|auditLoggers
specifier|private
specifier|final
name|List
argument_list|<
name|AuditLogger
argument_list|>
name|auditLoggers
decl_stmt|;
comment|/** The namespace tree. */
DECL|field|dir
name|FSDirectory
name|dir
decl_stmt|;
DECL|field|blockManager
specifier|private
specifier|final
name|BlockManager
name|blockManager
decl_stmt|;
DECL|field|snapshotManager
specifier|private
specifier|final
name|SnapshotManager
name|snapshotManager
decl_stmt|;
DECL|field|cacheManager
specifier|private
specifier|final
name|CacheManager
name|cacheManager
decl_stmt|;
DECL|field|datanodeStatistics
specifier|private
specifier|final
name|DatanodeStatistics
name|datanodeStatistics
decl_stmt|;
DECL|field|nameserviceId
specifier|private
name|String
name|nameserviceId
decl_stmt|;
DECL|field|rollingUpgradeInfo
specifier|private
specifier|volatile
name|RollingUpgradeInfo
name|rollingUpgradeInfo
init|=
literal|null
decl_stmt|;
comment|/**    * A flag that indicates whether the checkpointer should checkpoint a rollback    * fsimage. The edit log tailer sets this flag. The checkpoint will create a    * rollback fsimage if the flag is true, and then change the flag to false.    */
DECL|field|needRollbackFsImage
specifier|private
specifier|volatile
name|boolean
name|needRollbackFsImage
decl_stmt|;
comment|// Block pool ID used by this namenode
DECL|field|blockPoolId
specifier|private
name|String
name|blockPoolId
decl_stmt|;
DECL|field|leaseManager
specifier|final
name|LeaseManager
name|leaseManager
init|=
operator|new
name|LeaseManager
argument_list|(
name|this
argument_list|)
decl_stmt|;
DECL|field|smmthread
specifier|volatile
name|Daemon
name|smmthread
init|=
literal|null
decl_stmt|;
comment|// SafeModeMonitor thread
DECL|field|nnrmthread
name|Daemon
name|nnrmthread
init|=
literal|null
decl_stmt|;
comment|// NamenodeResourceMonitor thread
DECL|field|nnEditLogRoller
name|Daemon
name|nnEditLogRoller
init|=
literal|null
decl_stmt|;
comment|// NameNodeEditLogRoller thread
comment|// A daemon to periodically clean up corrupt lazyPersist files
comment|// from the name space.
DECL|field|lazyPersistFileScrubber
name|Daemon
name|lazyPersistFileScrubber
init|=
literal|null
decl_stmt|;
comment|/**    * When an active namenode will roll its own edit log, in # edits    */
DECL|field|editLogRollerThreshold
specifier|private
specifier|final
name|long
name|editLogRollerThreshold
decl_stmt|;
comment|/**    * Check interval of an active namenode's edit log roller thread     */
DECL|field|editLogRollerInterval
specifier|private
specifier|final
name|int
name|editLogRollerInterval
decl_stmt|;
comment|/**    * How frequently we scan and unlink corrupt lazyPersist files.    * (In seconds)    */
DECL|field|lazyPersistFileScrubIntervalSec
specifier|private
specifier|final
name|int
name|lazyPersistFileScrubIntervalSec
decl_stmt|;
DECL|field|hasResourcesAvailable
specifier|private
specifier|volatile
name|boolean
name|hasResourcesAvailable
init|=
literal|false
decl_stmt|;
DECL|field|fsRunning
specifier|private
specifier|volatile
name|boolean
name|fsRunning
init|=
literal|true
decl_stmt|;
comment|/** The start time of the namesystem. */
DECL|field|startTime
specifier|private
specifier|final
name|long
name|startTime
init|=
name|now
argument_list|()
decl_stmt|;
comment|/** The interval of namenode checking for the disk space availability */
DECL|field|resourceRecheckInterval
specifier|private
specifier|final
name|long
name|resourceRecheckInterval
decl_stmt|;
comment|// The actual resource checker instance.
DECL|field|nnResourceChecker
name|NameNodeResourceChecker
name|nnResourceChecker
decl_stmt|;
DECL|field|serverDefaults
specifier|private
specifier|final
name|FsServerDefaults
name|serverDefaults
decl_stmt|;
DECL|field|dtpReplaceDatanodeOnFailure
specifier|private
specifier|final
name|ReplaceDatanodeOnFailure
name|dtpReplaceDatanodeOnFailure
decl_stmt|;
DECL|field|safeMode
specifier|private
specifier|volatile
name|SafeModeInfo
name|safeMode
decl_stmt|;
comment|// safe mode information
DECL|field|maxFsObjects
specifier|private
specifier|final
name|long
name|maxFsObjects
decl_stmt|;
comment|// maximum number of fs objects
DECL|field|minBlockSize
specifier|private
specifier|final
name|long
name|minBlockSize
decl_stmt|;
comment|// minimum block size
DECL|field|maxBlocksPerFile
specifier|private
specifier|final
name|long
name|maxBlocksPerFile
decl_stmt|;
comment|// maximum # of blocks per file
comment|// precision of access times.
DECL|field|accessTimePrecision
specifier|private
specifier|final
name|long
name|accessTimePrecision
decl_stmt|;
comment|/** Lock to protect FSNamesystem. */
DECL|field|fsLock
specifier|private
specifier|final
name|FSNamesystemLock
name|fsLock
decl_stmt|;
comment|/**     * Checkpoint lock to protect FSNamesystem modification on standby NNs.    * Unlike fsLock, it does not affect block updates. On active NNs, this lock    * does not provide proper protection, because there are operations that    * modify both block and name system state.  Even on standby, fsLock is     * used when block state changes need to be blocked.    */
DECL|field|cpLock
specifier|private
specifier|final
name|ReentrantLock
name|cpLock
decl_stmt|;
comment|/**    * Used when this NN is in standby state to read from the shared edit log.    */
DECL|field|editLogTailer
specifier|private
name|EditLogTailer
name|editLogTailer
init|=
literal|null
decl_stmt|;
comment|/**    * Used when this NN is in standby state to perform checkpoints.    */
DECL|field|standbyCheckpointer
specifier|private
name|StandbyCheckpointer
name|standbyCheckpointer
decl_stmt|;
comment|/**    * Reference to the NN's HAContext object. This is only set once    * {@link #startCommonServices(Configuration, HAContext)} is called.     */
DECL|field|haContext
specifier|private
name|HAContext
name|haContext
decl_stmt|;
DECL|field|haEnabled
specifier|private
specifier|final
name|boolean
name|haEnabled
decl_stmt|;
comment|/** flag indicating whether replication queues have been initialized */
DECL|field|initializedReplQueues
name|boolean
name|initializedReplQueues
init|=
literal|false
decl_stmt|;
comment|/**    * Whether the namenode is in the middle of starting the active service    */
DECL|field|startingActiveService
specifier|private
specifier|volatile
name|boolean
name|startingActiveService
init|=
literal|false
decl_stmt|;
DECL|field|retryCache
specifier|private
specifier|final
name|RetryCache
name|retryCache
decl_stmt|;
DECL|field|provider
specifier|private
name|KeyProviderCryptoExtension
name|provider
init|=
literal|null
decl_stmt|;
DECL|field|imageLoaded
specifier|private
specifier|volatile
name|boolean
name|imageLoaded
init|=
literal|false
decl_stmt|;
DECL|field|cond
specifier|private
specifier|final
name|Condition
name|cond
decl_stmt|;
DECL|field|fsImage
specifier|private
specifier|final
name|FSImage
name|fsImage
decl_stmt|;
DECL|field|topConf
specifier|private
specifier|final
name|TopConf
name|topConf
decl_stmt|;
DECL|field|topMetrics
specifier|private
name|TopMetrics
name|topMetrics
decl_stmt|;
DECL|field|inodeAttributeProvider
specifier|private
name|INodeAttributeProvider
name|inodeAttributeProvider
decl_stmt|;
comment|/**    * Notify that loading of this FSDirectory is complete, and    * it is imageLoaded for use    */
DECL|method|imageLoadComplete ()
name|void
name|imageLoadComplete
parameter_list|()
block|{
name|Preconditions
operator|.
name|checkState
argument_list|(
operator|!
name|imageLoaded
argument_list|,
literal|"FSDirectory already loaded"
argument_list|)
expr_stmt|;
name|setImageLoaded
argument_list|()
expr_stmt|;
block|}
DECL|method|setImageLoaded ()
name|void
name|setImageLoaded
parameter_list|()
block|{
if|if
condition|(
name|imageLoaded
condition|)
return|return;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|setImageLoaded
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|dir
operator|.
name|markNameCacheInitialized
argument_list|()
expr_stmt|;
name|cond
operator|.
name|signalAll
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|//This is for testing purposes only
annotation|@
name|VisibleForTesting
DECL|method|isImageLoaded ()
name|boolean
name|isImageLoaded
parameter_list|()
block|{
return|return
name|imageLoaded
return|;
block|}
comment|// exposed for unit tests
DECL|method|setImageLoaded (boolean flag)
specifier|protected
name|void
name|setImageLoaded
parameter_list|(
name|boolean
name|flag
parameter_list|)
block|{
name|imageLoaded
operator|=
name|flag
expr_stmt|;
block|}
comment|/**    * Block until the object is imageLoaded to be used.    */
DECL|method|waitForLoadingFSImage ()
name|void
name|waitForLoadingFSImage
parameter_list|()
block|{
if|if
condition|(
operator|!
name|imageLoaded
condition|)
block|{
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
while|while
condition|(
operator|!
name|imageLoaded
condition|)
block|{
try|try
block|{
name|cond
operator|.
name|await
argument_list|(
literal|5000
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ignored
parameter_list|)
block|{           }
block|}
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Clear all loaded data    */
DECL|method|clear ()
name|void
name|clear
parameter_list|()
block|{
name|dir
operator|.
name|reset
argument_list|()
expr_stmt|;
name|dtSecretManager
operator|.
name|reset
argument_list|()
expr_stmt|;
name|blockIdManager
operator|.
name|clear
argument_list|()
expr_stmt|;
name|leaseManager
operator|.
name|removeAllLeases
argument_list|()
expr_stmt|;
name|snapshotManager
operator|.
name|clearSnapshottableDirs
argument_list|()
expr_stmt|;
name|cacheManager
operator|.
name|clear
argument_list|()
expr_stmt|;
name|setImageLoaded
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|blockManager
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|getLeaseManager ()
name|LeaseManager
name|getLeaseManager
parameter_list|()
block|{
return|return
name|leaseManager
return|;
block|}
DECL|method|isHaEnabled ()
name|boolean
name|isHaEnabled
parameter_list|()
block|{
return|return
name|haEnabled
return|;
block|}
comment|/**    * Check the supplied configuration for correctness.    * @param conf Supplies the configuration to validate.    * @throws IOException if the configuration could not be queried.    * @throws IllegalArgumentException if the configuration is invalid.    */
DECL|method|checkConfiguration (Configuration conf)
specifier|private
specifier|static
name|void
name|checkConfiguration
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|Collection
argument_list|<
name|URI
argument_list|>
name|namespaceDirs
init|=
name|FSNamesystem
operator|.
name|getNamespaceDirs
argument_list|(
name|conf
argument_list|)
decl_stmt|;
specifier|final
name|Collection
argument_list|<
name|URI
argument_list|>
name|editsDirs
init|=
name|FSNamesystem
operator|.
name|getNamespaceEditsDirs
argument_list|(
name|conf
argument_list|)
decl_stmt|;
specifier|final
name|Collection
argument_list|<
name|URI
argument_list|>
name|requiredEditsDirs
init|=
name|FSNamesystem
operator|.
name|getRequiredNamespaceEditsDirs
argument_list|(
name|conf
argument_list|)
decl_stmt|;
specifier|final
name|Collection
argument_list|<
name|URI
argument_list|>
name|sharedEditsDirs
init|=
name|FSNamesystem
operator|.
name|getSharedEditsDirs
argument_list|(
name|conf
argument_list|)
decl_stmt|;
for|for
control|(
name|URI
name|u
range|:
name|requiredEditsDirs
control|)
block|{
if|if
condition|(
name|u
operator|.
name|toString
argument_list|()
operator|.
name|compareTo
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_EDITS_DIR_DEFAULT
argument_list|)
operator|==
literal|0
condition|)
block|{
continue|continue;
block|}
comment|// Each required directory must also be in editsDirs or in
comment|// sharedEditsDirs.
if|if
condition|(
operator|!
name|editsDirs
operator|.
name|contains
argument_list|(
name|u
argument_list|)
operator|&&
operator|!
name|sharedEditsDirs
operator|.
name|contains
argument_list|(
name|u
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Required edits directory "
operator|+
name|u
operator|.
name|toString
argument_list|()
operator|+
literal|" not present in "
operator|+
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_EDITS_DIR_KEY
operator|+
literal|". "
operator|+
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_EDITS_DIR_KEY
operator|+
literal|"="
operator|+
name|editsDirs
operator|.
name|toString
argument_list|()
operator|+
literal|"; "
operator|+
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_EDITS_DIR_REQUIRED_KEY
operator|+
literal|"="
operator|+
name|requiredEditsDirs
operator|.
name|toString
argument_list|()
operator|+
literal|". "
operator|+
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_SHARED_EDITS_DIR_KEY
operator|+
literal|"="
operator|+
name|sharedEditsDirs
operator|.
name|toString
argument_list|()
operator|+
literal|"."
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
name|namespaceDirs
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Only one image storage directory ("
operator|+
name|DFS_NAMENODE_NAME_DIR_KEY
operator|+
literal|") configured. Beware of data loss"
operator|+
literal|" due to lack of redundant storage directories!"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|editsDirs
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Only one namespace edits storage directory ("
operator|+
name|DFS_NAMENODE_EDITS_DIR_KEY
operator|+
literal|") configured. Beware of data loss"
operator|+
literal|" due to lack of redundant storage directories!"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Instantiates an FSNamesystem loaded from the image and edits    * directories specified in the passed Configuration.    *    * @param conf the Configuration which specifies the storage directories    *             from which to load    * @return an FSNamesystem which contains the loaded namespace    * @throws IOException if loading fails    */
DECL|method|loadFromDisk (Configuration conf)
specifier|static
name|FSNamesystem
name|loadFromDisk
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|checkConfiguration
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|FSImage
name|fsImage
init|=
operator|new
name|FSImage
argument_list|(
name|conf
argument_list|,
name|FSNamesystem
operator|.
name|getNamespaceDirs
argument_list|(
name|conf
argument_list|)
argument_list|,
name|FSNamesystem
operator|.
name|getNamespaceEditsDirs
argument_list|(
name|conf
argument_list|)
argument_list|)
decl_stmt|;
name|FSNamesystem
name|namesystem
init|=
operator|new
name|FSNamesystem
argument_list|(
name|conf
argument_list|,
name|fsImage
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|StartupOption
name|startOpt
init|=
name|NameNode
operator|.
name|getStartupOption
argument_list|(
name|conf
argument_list|)
decl_stmt|;
if|if
condition|(
name|startOpt
operator|==
name|StartupOption
operator|.
name|RECOVER
condition|)
block|{
name|namesystem
operator|.
name|setSafeMode
argument_list|(
name|SafeModeAction
operator|.
name|SAFEMODE_ENTER
argument_list|)
expr_stmt|;
block|}
name|long
name|loadStart
init|=
name|monotonicNow
argument_list|()
decl_stmt|;
try|try
block|{
name|namesystem
operator|.
name|loadFSImage
argument_list|(
name|startOpt
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Encountered exception loading fsimage"
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
name|fsImage
operator|.
name|close
argument_list|()
expr_stmt|;
throw|throw
name|ioe
throw|;
block|}
name|long
name|timeTakenToLoadFSImage
init|=
name|monotonicNow
argument_list|()
operator|-
name|loadStart
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Finished loading FSImage in "
operator|+
name|timeTakenToLoadFSImage
operator|+
literal|" msecs"
argument_list|)
expr_stmt|;
name|NameNodeMetrics
name|nnMetrics
init|=
name|NameNode
operator|.
name|getNameNodeMetrics
argument_list|()
decl_stmt|;
if|if
condition|(
name|nnMetrics
operator|!=
literal|null
condition|)
block|{
name|nnMetrics
operator|.
name|setFsImageLoadTime
argument_list|(
operator|(
name|int
operator|)
name|timeTakenToLoadFSImage
argument_list|)
expr_stmt|;
block|}
return|return
name|namesystem
return|;
block|}
DECL|method|FSNamesystem (Configuration conf, FSImage fsImage)
name|FSNamesystem
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|FSImage
name|fsImage
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|(
name|conf
argument_list|,
name|fsImage
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/**    * Create an FSNamesystem associated with the specified image.    *     * Note that this does not load any data off of disk -- if you would    * like that behavior, use {@link #loadFromDisk(Configuration)}    *    * @param conf configuration    * @param fsImage The FSImage to associate with    * @param ignoreRetryCache Whether or not should ignore the retry cache setup    *                         step. For Secondary NN this should be set to true.    * @throws IOException on bad configuration    */
DECL|method|FSNamesystem (Configuration conf, FSImage fsImage, boolean ignoreRetryCache)
name|FSNamesystem
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|FSImage
name|fsImage
parameter_list|,
name|boolean
name|ignoreRetryCache
parameter_list|)
throws|throws
name|IOException
block|{
name|provider
operator|=
name|DFSUtil
operator|.
name|createKeyProviderCryptoExtension
argument_list|(
name|conf
argument_list|)
expr_stmt|;
if|if
condition|(
name|provider
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"No KeyProvider found."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Found KeyProvider: "
operator|+
name|provider
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|conf
operator|.
name|getBoolean
argument_list|(
name|DFS_NAMENODE_AUDIT_LOG_ASYNC_KEY
argument_list|,
name|DFS_NAMENODE_AUDIT_LOG_ASYNC_DEFAULT
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Enabling async auditlog"
argument_list|)
expr_stmt|;
name|enableAsyncAuditLog
argument_list|()
expr_stmt|;
block|}
name|boolean
name|fair
init|=
name|conf
operator|.
name|getBoolean
argument_list|(
literal|"dfs.namenode.fslock.fair"
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"fsLock is fair:"
operator|+
name|fair
argument_list|)
expr_stmt|;
name|fsLock
operator|=
operator|new
name|FSNamesystemLock
argument_list|(
name|fair
argument_list|)
expr_stmt|;
name|cond
operator|=
name|fsLock
operator|.
name|writeLock
argument_list|()
operator|.
name|newCondition
argument_list|()
expr_stmt|;
name|cpLock
operator|=
operator|new
name|ReentrantLock
argument_list|()
expr_stmt|;
name|this
operator|.
name|fsImage
operator|=
name|fsImage
expr_stmt|;
try|try
block|{
name|resourceRecheckInterval
operator|=
name|conf
operator|.
name|getLong
argument_list|(
name|DFS_NAMENODE_RESOURCE_CHECK_INTERVAL_KEY
argument_list|,
name|DFS_NAMENODE_RESOURCE_CHECK_INTERVAL_DEFAULT
argument_list|)
expr_stmt|;
name|this
operator|.
name|blockManager
operator|=
operator|new
name|BlockManager
argument_list|(
name|this
argument_list|,
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|datanodeStatistics
operator|=
name|blockManager
operator|.
name|getDatanodeManager
argument_list|()
operator|.
name|getDatanodeStatistics
argument_list|()
expr_stmt|;
name|this
operator|.
name|blockIdManager
operator|=
operator|new
name|BlockIdManager
argument_list|(
name|blockManager
argument_list|)
expr_stmt|;
name|this
operator|.
name|fsOwner
operator|=
name|UserGroupInformation
operator|.
name|getCurrentUser
argument_list|()
expr_stmt|;
name|this
operator|.
name|supergroup
operator|=
name|conf
operator|.
name|get
argument_list|(
name|DFS_PERMISSIONS_SUPERUSERGROUP_KEY
argument_list|,
name|DFS_PERMISSIONS_SUPERUSERGROUP_DEFAULT
argument_list|)
expr_stmt|;
name|this
operator|.
name|isPermissionEnabled
operator|=
name|conf
operator|.
name|getBoolean
argument_list|(
name|DFS_PERMISSIONS_ENABLED_KEY
argument_list|,
name|DFS_PERMISSIONS_ENABLED_DEFAULT
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"fsOwner             = "
operator|+
name|fsOwner
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"supergroup          = "
operator|+
name|supergroup
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"isPermissionEnabled = "
operator|+
name|isPermissionEnabled
argument_list|)
expr_stmt|;
comment|// block allocation has to be persisted in HA using a shared edits directory
comment|// so that the standby has up-to-date namespace information
name|nameserviceId
operator|=
name|DFSUtil
operator|.
name|getNamenodeNameServiceId
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|haEnabled
operator|=
name|HAUtil
operator|.
name|isHAEnabled
argument_list|(
name|conf
argument_list|,
name|nameserviceId
argument_list|)
expr_stmt|;
comment|// Sanity check the HA-related config.
if|if
condition|(
name|nameserviceId
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Determined nameservice ID: "
operator|+
name|nameserviceId
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"HA Enabled: "
operator|+
name|haEnabled
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|haEnabled
operator|&&
name|HAUtil
operator|.
name|usesSharedEditsDir
argument_list|(
name|conf
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Configured NNs:\n"
operator|+
name|DFSUtil
operator|.
name|nnAddressesAsString
argument_list|(
name|conf
argument_list|)
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Invalid configuration: a shared edits dir "
operator|+
literal|"must not be specified if HA is not enabled."
argument_list|)
throw|;
block|}
comment|// Get the checksum type from config
name|String
name|checksumTypeStr
init|=
name|conf
operator|.
name|get
argument_list|(
name|DFS_CHECKSUM_TYPE_KEY
argument_list|,
name|DFS_CHECKSUM_TYPE_DEFAULT
argument_list|)
decl_stmt|;
name|DataChecksum
operator|.
name|Type
name|checksumType
decl_stmt|;
try|try
block|{
name|checksumType
operator|=
name|DataChecksum
operator|.
name|Type
operator|.
name|valueOf
argument_list|(
name|checksumTypeStr
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|iae
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Invalid checksum type in "
operator|+
name|DFS_CHECKSUM_TYPE_KEY
operator|+
literal|": "
operator|+
name|checksumTypeStr
argument_list|)
throw|;
block|}
name|this
operator|.
name|serverDefaults
operator|=
operator|new
name|FsServerDefaults
argument_list|(
name|conf
operator|.
name|getLongBytes
argument_list|(
name|DFS_BLOCK_SIZE_KEY
argument_list|,
name|DFS_BLOCK_SIZE_DEFAULT
argument_list|)
argument_list|,
name|conf
operator|.
name|getInt
argument_list|(
name|DFS_BYTES_PER_CHECKSUM_KEY
argument_list|,
name|DFS_BYTES_PER_CHECKSUM_DEFAULT
argument_list|)
argument_list|,
name|conf
operator|.
name|getInt
argument_list|(
name|DFS_CLIENT_WRITE_PACKET_SIZE_KEY
argument_list|,
name|DFS_CLIENT_WRITE_PACKET_SIZE_DEFAULT
argument_list|)
argument_list|,
operator|(
name|short
operator|)
name|conf
operator|.
name|getInt
argument_list|(
name|DFS_REPLICATION_KEY
argument_list|,
name|DFS_REPLICATION_DEFAULT
argument_list|)
argument_list|,
name|conf
operator|.
name|getInt
argument_list|(
name|IO_FILE_BUFFER_SIZE_KEY
argument_list|,
name|IO_FILE_BUFFER_SIZE_DEFAULT
argument_list|)
argument_list|,
name|conf
operator|.
name|getBoolean
argument_list|(
name|DFS_ENCRYPT_DATA_TRANSFER_KEY
argument_list|,
name|DFS_ENCRYPT_DATA_TRANSFER_DEFAULT
argument_list|)
argument_list|,
name|conf
operator|.
name|getLong
argument_list|(
name|FS_TRASH_INTERVAL_KEY
argument_list|,
name|FS_TRASH_INTERVAL_DEFAULT
argument_list|)
argument_list|,
name|checksumType
argument_list|)
expr_stmt|;
name|this
operator|.
name|maxFsObjects
operator|=
name|conf
operator|.
name|getLong
argument_list|(
name|DFS_NAMENODE_MAX_OBJECTS_KEY
argument_list|,
name|DFS_NAMENODE_MAX_OBJECTS_DEFAULT
argument_list|)
expr_stmt|;
name|this
operator|.
name|minBlockSize
operator|=
name|conf
operator|.
name|getLong
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_MIN_BLOCK_SIZE_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_MIN_BLOCK_SIZE_DEFAULT
argument_list|)
expr_stmt|;
name|this
operator|.
name|maxBlocksPerFile
operator|=
name|conf
operator|.
name|getLong
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_MAX_BLOCKS_PER_FILE_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_MAX_BLOCKS_PER_FILE_DEFAULT
argument_list|)
expr_stmt|;
name|this
operator|.
name|accessTimePrecision
operator|=
name|conf
operator|.
name|getLong
argument_list|(
name|DFS_NAMENODE_ACCESSTIME_PRECISION_KEY
argument_list|,
name|DFS_NAMENODE_ACCESSTIME_PRECISION_DEFAULT
argument_list|)
expr_stmt|;
name|this
operator|.
name|dtpReplaceDatanodeOnFailure
operator|=
name|ReplaceDatanodeOnFailure
operator|.
name|get
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|standbyShouldCheckpoint
operator|=
name|conf
operator|.
name|getBoolean
argument_list|(
name|DFS_HA_STANDBY_CHECKPOINTS_KEY
argument_list|,
name|DFS_HA_STANDBY_CHECKPOINTS_DEFAULT
argument_list|)
expr_stmt|;
comment|// # edit autoroll threshold is a multiple of the checkpoint threshold
name|this
operator|.
name|editLogRollerThreshold
operator|=
call|(
name|long
call|)
argument_list|(
name|conf
operator|.
name|getFloat
argument_list|(
name|DFS_NAMENODE_EDIT_LOG_AUTOROLL_MULTIPLIER_THRESHOLD
argument_list|,
name|DFS_NAMENODE_EDIT_LOG_AUTOROLL_MULTIPLIER_THRESHOLD_DEFAULT
argument_list|)
operator|*
name|conf
operator|.
name|getLong
argument_list|(
name|DFS_NAMENODE_CHECKPOINT_TXNS_KEY
argument_list|,
name|DFS_NAMENODE_CHECKPOINT_TXNS_DEFAULT
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|editLogRollerInterval
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|DFS_NAMENODE_EDIT_LOG_AUTOROLL_CHECK_INTERVAL_MS
argument_list|,
name|DFS_NAMENODE_EDIT_LOG_AUTOROLL_CHECK_INTERVAL_MS_DEFAULT
argument_list|)
expr_stmt|;
name|this
operator|.
name|lazyPersistFileScrubIntervalSec
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|DFS_NAMENODE_LAZY_PERSIST_FILE_SCRUB_INTERVAL_SEC
argument_list|,
name|DFS_NAMENODE_LAZY_PERSIST_FILE_SCRUB_INTERVAL_SEC_DEFAULT
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|lazyPersistFileScrubIntervalSec
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|DFS_NAMENODE_LAZY_PERSIST_FILE_SCRUB_INTERVAL_SEC
operator|+
literal|" must be non-zero."
argument_list|)
throw|;
block|}
comment|// For testing purposes, allow the DT secret manager to be started regardless
comment|// of whether security is enabled.
name|alwaysUseDelegationTokensForTests
operator|=
name|conf
operator|.
name|getBoolean
argument_list|(
name|DFS_NAMENODE_DELEGATION_TOKEN_ALWAYS_USE_KEY
argument_list|,
name|DFS_NAMENODE_DELEGATION_TOKEN_ALWAYS_USE_DEFAULT
argument_list|)
expr_stmt|;
name|this
operator|.
name|dtSecretManager
operator|=
name|createDelegationTokenSecretManager
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|dir
operator|=
operator|new
name|FSDirectory
argument_list|(
name|this
argument_list|,
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|snapshotManager
operator|=
operator|new
name|SnapshotManager
argument_list|(
name|dir
argument_list|)
expr_stmt|;
name|this
operator|.
name|cacheManager
operator|=
operator|new
name|CacheManager
argument_list|(
name|this
argument_list|,
name|conf
argument_list|,
name|blockManager
argument_list|)
expr_stmt|;
name|this
operator|.
name|safeMode
operator|=
operator|new
name|SafeModeInfo
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|topConf
operator|=
operator|new
name|TopConf
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|auditLoggers
operator|=
name|initAuditLoggers
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|isDefaultAuditLogger
operator|=
name|auditLoggers
operator|.
name|size
argument_list|()
operator|==
literal|1
operator|&&
name|auditLoggers
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|instanceof
name|DefaultAuditLogger
expr_stmt|;
name|this
operator|.
name|retryCache
operator|=
name|ignoreRetryCache
condition|?
literal|null
else|:
name|initRetryCache
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|Class
argument_list|<
name|?
extends|extends
name|INodeAttributeProvider
argument_list|>
name|klass
init|=
name|conf
operator|.
name|getClass
argument_list|(
name|DFS_NAMENODE_INODE_ATTRIBUTES_PROVIDER_KEY
argument_list|,
literal|null
argument_list|,
name|INodeAttributeProvider
operator|.
name|class
argument_list|)
decl_stmt|;
if|if
condition|(
name|klass
operator|!=
literal|null
condition|)
block|{
name|inodeAttributeProvider
operator|=
name|ReflectionUtils
operator|.
name|newInstance
argument_list|(
name|klass
argument_list|,
name|conf
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Using INode attribute provider: "
operator|+
name|klass
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|" initialization failed."
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|close
argument_list|()
expr_stmt|;
throw|throw
name|e
throw|;
block|}
catch|catch
parameter_list|(
name|RuntimeException
name|re
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|" initialization failed."
argument_list|,
name|re
argument_list|)
expr_stmt|;
name|close
argument_list|()
expr_stmt|;
throw|throw
name|re
throw|;
block|}
block|}
annotation|@
name|VisibleForTesting
DECL|method|getAuditLoggers ()
specifier|public
name|List
argument_list|<
name|AuditLogger
argument_list|>
name|getAuditLoggers
parameter_list|()
block|{
return|return
name|auditLoggers
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|getRetryCache ()
specifier|public
name|RetryCache
name|getRetryCache
parameter_list|()
block|{
return|return
name|retryCache
return|;
block|}
DECL|method|lockRetryCache ()
name|void
name|lockRetryCache
parameter_list|()
block|{
if|if
condition|(
name|retryCache
operator|!=
literal|null
condition|)
block|{
name|retryCache
operator|.
name|lock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|unlockRetryCache ()
name|void
name|unlockRetryCache
parameter_list|()
block|{
if|if
condition|(
name|retryCache
operator|!=
literal|null
condition|)
block|{
name|retryCache
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** Whether or not retry cache is enabled */
DECL|method|hasRetryCache ()
name|boolean
name|hasRetryCache
parameter_list|()
block|{
return|return
name|retryCache
operator|!=
literal|null
return|;
block|}
DECL|method|addCacheEntryWithPayload (byte[] clientId, int callId, Object payload)
name|void
name|addCacheEntryWithPayload
parameter_list|(
name|byte
index|[]
name|clientId
parameter_list|,
name|int
name|callId
parameter_list|,
name|Object
name|payload
parameter_list|)
block|{
if|if
condition|(
name|retryCache
operator|!=
literal|null
condition|)
block|{
name|retryCache
operator|.
name|addCacheEntryWithPayload
argument_list|(
name|clientId
argument_list|,
name|callId
argument_list|,
name|payload
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|addCacheEntry (byte[] clientId, int callId)
name|void
name|addCacheEntry
parameter_list|(
name|byte
index|[]
name|clientId
parameter_list|,
name|int
name|callId
parameter_list|)
block|{
if|if
condition|(
name|retryCache
operator|!=
literal|null
condition|)
block|{
name|retryCache
operator|.
name|addCacheEntry
argument_list|(
name|clientId
argument_list|,
name|callId
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|VisibleForTesting
DECL|method|getProvider ()
specifier|public
name|KeyProviderCryptoExtension
name|getProvider
parameter_list|()
block|{
return|return
name|provider
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|initRetryCache (Configuration conf)
specifier|static
name|RetryCache
name|initRetryCache
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
name|boolean
name|enable
init|=
name|conf
operator|.
name|getBoolean
argument_list|(
name|DFS_NAMENODE_ENABLE_RETRY_CACHE_KEY
argument_list|,
name|DFS_NAMENODE_ENABLE_RETRY_CACHE_DEFAULT
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Retry cache on namenode is "
operator|+
operator|(
name|enable
condition|?
literal|"enabled"
else|:
literal|"disabled"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|enable
condition|)
block|{
name|float
name|heapPercent
init|=
name|conf
operator|.
name|getFloat
argument_list|(
name|DFS_NAMENODE_RETRY_CACHE_HEAP_PERCENT_KEY
argument_list|,
name|DFS_NAMENODE_RETRY_CACHE_HEAP_PERCENT_DEFAULT
argument_list|)
decl_stmt|;
name|long
name|entryExpiryMillis
init|=
name|conf
operator|.
name|getLong
argument_list|(
name|DFS_NAMENODE_RETRY_CACHE_EXPIRYTIME_MILLIS_KEY
argument_list|,
name|DFS_NAMENODE_RETRY_CACHE_EXPIRYTIME_MILLIS_DEFAULT
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Retry cache will use "
operator|+
name|heapPercent
operator|+
literal|" of total heap and retry cache entry expiry time is "
operator|+
name|entryExpiryMillis
operator|+
literal|" millis"
argument_list|)
expr_stmt|;
name|long
name|entryExpiryNanos
init|=
name|entryExpiryMillis
operator|*
literal|1000
operator|*
literal|1000
decl_stmt|;
return|return
operator|new
name|RetryCache
argument_list|(
literal|"NameNodeRetryCache"
argument_list|,
name|heapPercent
argument_list|,
name|entryExpiryNanos
argument_list|)
return|;
block|}
return|return
literal|null
return|;
block|}
DECL|method|initAuditLoggers (Configuration conf)
specifier|private
name|List
argument_list|<
name|AuditLogger
argument_list|>
name|initAuditLoggers
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
comment|// Initialize the custom access loggers if configured.
name|Collection
argument_list|<
name|String
argument_list|>
name|alClasses
init|=
name|conf
operator|.
name|getStringCollection
argument_list|(
name|DFS_NAMENODE_AUDIT_LOGGERS_KEY
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|AuditLogger
argument_list|>
name|auditLoggers
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
if|if
condition|(
name|alClasses
operator|!=
literal|null
operator|&&
operator|!
name|alClasses
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|String
name|className
range|:
name|alClasses
control|)
block|{
try|try
block|{
name|AuditLogger
name|logger
decl_stmt|;
if|if
condition|(
name|DFS_NAMENODE_DEFAULT_AUDIT_LOGGER_NAME
operator|.
name|equals
argument_list|(
name|className
argument_list|)
condition|)
block|{
name|logger
operator|=
operator|new
name|DefaultAuditLogger
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|logger
operator|=
operator|(
name|AuditLogger
operator|)
name|Class
operator|.
name|forName
argument_list|(
name|className
argument_list|)
operator|.
name|newInstance
argument_list|()
expr_stmt|;
block|}
name|logger
operator|.
name|initialize
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|auditLoggers
operator|.
name|add
argument_list|(
name|logger
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RuntimeException
name|re
parameter_list|)
block|{
throw|throw
name|re
throw|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
block|}
comment|// Make sure there is at least one logger installed.
if|if
condition|(
name|auditLoggers
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|auditLoggers
operator|.
name|add
argument_list|(
operator|new
name|DefaultAuditLogger
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Add audit logger to calculate top users
if|if
condition|(
name|topConf
operator|.
name|isEnabled
condition|)
block|{
name|topMetrics
operator|=
operator|new
name|TopMetrics
argument_list|(
name|conf
argument_list|,
name|topConf
operator|.
name|nntopReportingPeriodsMs
argument_list|)
expr_stmt|;
name|auditLoggers
operator|.
name|add
argument_list|(
operator|new
name|TopAuditLogger
argument_list|(
name|topMetrics
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|Collections
operator|.
name|unmodifiableList
argument_list|(
name|auditLoggers
argument_list|)
return|;
block|}
DECL|method|loadFSImage (StartupOption startOpt)
specifier|private
name|void
name|loadFSImage
parameter_list|(
name|StartupOption
name|startOpt
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|FSImage
name|fsImage
init|=
name|getFSImage
argument_list|()
decl_stmt|;
comment|// format before starting up if requested
if|if
condition|(
name|startOpt
operator|==
name|StartupOption
operator|.
name|FORMAT
condition|)
block|{
name|fsImage
operator|.
name|format
argument_list|(
name|this
argument_list|,
name|fsImage
operator|.
name|getStorage
argument_list|()
operator|.
name|determineClusterId
argument_list|()
argument_list|)
expr_stmt|;
comment|// reuse current id
name|startOpt
operator|=
name|StartupOption
operator|.
name|REGULAR
expr_stmt|;
block|}
name|boolean
name|success
init|=
literal|false
decl_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
comment|// We shouldn't be calling saveNamespace if we've come up in standby state.
name|MetaRecoveryContext
name|recovery
init|=
name|startOpt
operator|.
name|createRecoveryContext
argument_list|()
decl_stmt|;
specifier|final
name|boolean
name|staleImage
init|=
name|fsImage
operator|.
name|recoverTransitionRead
argument_list|(
name|startOpt
argument_list|,
name|this
argument_list|,
name|recovery
argument_list|)
decl_stmt|;
if|if
condition|(
name|RollingUpgradeStartupOption
operator|.
name|ROLLBACK
operator|.
name|matches
argument_list|(
name|startOpt
argument_list|)
condition|)
block|{
name|rollingUpgradeInfo
operator|=
literal|null
expr_stmt|;
block|}
specifier|final
name|boolean
name|needToSave
init|=
name|staleImage
operator|&&
operator|!
name|haEnabled
operator|&&
operator|!
name|isRollingUpgrade
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Need to save fs image? "
operator|+
name|needToSave
operator|+
literal|" (staleImage="
operator|+
name|staleImage
operator|+
literal|", haEnabled="
operator|+
name|haEnabled
operator|+
literal|", isRollingUpgrade="
operator|+
name|isRollingUpgrade
argument_list|()
operator|+
literal|")"
argument_list|)
expr_stmt|;
if|if
condition|(
name|needToSave
condition|)
block|{
name|fsImage
operator|.
name|saveNamespace
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|updateStorageVersionForRollingUpgrade
argument_list|(
name|fsImage
operator|.
name|getLayoutVersion
argument_list|()
argument_list|,
name|startOpt
argument_list|)
expr_stmt|;
comment|// No need to save, so mark the phase done.
name|StartupProgress
name|prog
init|=
name|NameNode
operator|.
name|getStartupProgress
argument_list|()
decl_stmt|;
name|prog
operator|.
name|beginPhase
argument_list|(
name|Phase
operator|.
name|SAVING_CHECKPOINT
argument_list|)
expr_stmt|;
name|prog
operator|.
name|endPhase
argument_list|(
name|Phase
operator|.
name|SAVING_CHECKPOINT
argument_list|)
expr_stmt|;
block|}
comment|// This will start a new log segment and write to the seen_txid file, so
comment|// we shouldn't do it when coming up in standby state
if|if
condition|(
operator|!
name|haEnabled
operator|||
operator|(
name|haEnabled
operator|&&
name|startOpt
operator|==
name|StartupOption
operator|.
name|UPGRADE
operator|)
operator|||
operator|(
name|haEnabled
operator|&&
name|startOpt
operator|==
name|StartupOption
operator|.
name|UPGRADEONLY
operator|)
condition|)
block|{
name|fsImage
operator|.
name|openEditLogForWrite
argument_list|()
expr_stmt|;
block|}
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|success
condition|)
block|{
name|fsImage
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
name|imageLoadComplete
argument_list|()
expr_stmt|;
block|}
DECL|method|updateStorageVersionForRollingUpgrade (final long layoutVersion, StartupOption startOpt)
specifier|private
name|void
name|updateStorageVersionForRollingUpgrade
parameter_list|(
specifier|final
name|long
name|layoutVersion
parameter_list|,
name|StartupOption
name|startOpt
parameter_list|)
throws|throws
name|IOException
block|{
name|boolean
name|rollingStarted
init|=
name|RollingUpgradeStartupOption
operator|.
name|STARTED
operator|.
name|matches
argument_list|(
name|startOpt
argument_list|)
operator|&&
name|layoutVersion
operator|>
name|HdfsConstants
operator|.
name|NAMENODE_LAYOUT_VERSION
decl_stmt|;
name|boolean
name|rollingRollback
init|=
name|RollingUpgradeStartupOption
operator|.
name|ROLLBACK
operator|.
name|matches
argument_list|(
name|startOpt
argument_list|)
decl_stmt|;
if|if
condition|(
name|rollingRollback
operator|||
name|rollingStarted
condition|)
block|{
name|fsImage
operator|.
name|updateStorageVersion
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|startSecretManager ()
specifier|private
name|void
name|startSecretManager
parameter_list|()
block|{
if|if
condition|(
name|dtSecretManager
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|dtSecretManager
operator|.
name|startThreads
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// Inability to start secret manager
comment|// can't be recovered from.
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
block|}
DECL|method|startSecretManagerIfNecessary ()
specifier|private
name|void
name|startSecretManagerIfNecessary
parameter_list|()
block|{
name|boolean
name|shouldRun
init|=
name|shouldUseDelegationTokens
argument_list|()
operator|&&
operator|!
name|isInSafeMode
argument_list|()
operator|&&
name|getEditLog
argument_list|()
operator|.
name|isOpenForWrite
argument_list|()
decl_stmt|;
name|boolean
name|running
init|=
name|dtSecretManager
operator|.
name|isRunning
argument_list|()
decl_stmt|;
if|if
condition|(
name|shouldRun
operator|&&
operator|!
name|running
condition|)
block|{
name|startSecretManager
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|stopSecretManager ()
specifier|private
name|void
name|stopSecretManager
parameter_list|()
block|{
if|if
condition|(
name|dtSecretManager
operator|!=
literal|null
condition|)
block|{
name|dtSecretManager
operator|.
name|stopThreads
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**     * Start services common to both active and standby states    */
DECL|method|startCommonServices (Configuration conf, HAContext haContext)
name|void
name|startCommonServices
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|HAContext
name|haContext
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|registerMBean
argument_list|()
expr_stmt|;
comment|// register the MBean for the FSNamesystemState
name|writeLock
argument_list|()
expr_stmt|;
name|this
operator|.
name|haContext
operator|=
name|haContext
expr_stmt|;
try|try
block|{
name|nnResourceChecker
operator|=
operator|new
name|NameNodeResourceChecker
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|checkAvailableResources
argument_list|()
expr_stmt|;
assert|assert
name|safeMode
operator|!=
literal|null
operator|&&
operator|!
name|isPopulatingReplQueues
argument_list|()
assert|;
name|StartupProgress
name|prog
init|=
name|NameNode
operator|.
name|getStartupProgress
argument_list|()
decl_stmt|;
name|prog
operator|.
name|beginPhase
argument_list|(
name|Phase
operator|.
name|SAFEMODE
argument_list|)
expr_stmt|;
name|prog
operator|.
name|setTotal
argument_list|(
name|Phase
operator|.
name|SAFEMODE
argument_list|,
name|STEP_AWAITING_REPORTED_BLOCKS
argument_list|,
name|getCompleteBlocksTotal
argument_list|()
argument_list|)
expr_stmt|;
name|setBlockTotal
argument_list|()
expr_stmt|;
name|blockManager
operator|.
name|activate
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
name|registerMXBean
argument_list|()
expr_stmt|;
name|DefaultMetricsSystem
operator|.
name|instance
argument_list|()
operator|.
name|register
argument_list|(
name|this
argument_list|)
expr_stmt|;
if|if
condition|(
name|inodeAttributeProvider
operator|!=
literal|null
condition|)
block|{
name|inodeAttributeProvider
operator|.
name|start
argument_list|()
expr_stmt|;
name|dir
operator|.
name|setINodeAttributeProvider
argument_list|(
name|inodeAttributeProvider
argument_list|)
expr_stmt|;
block|}
name|snapshotManager
operator|.
name|registerMXBean
argument_list|()
expr_stmt|;
block|}
comment|/**     * Stop services common to both active and standby states    */
DECL|method|stopCommonServices ()
name|void
name|stopCommonServices
parameter_list|()
block|{
name|writeLock
argument_list|()
expr_stmt|;
if|if
condition|(
name|inodeAttributeProvider
operator|!=
literal|null
condition|)
block|{
name|dir
operator|.
name|setINodeAttributeProvider
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|inodeAttributeProvider
operator|.
name|stop
argument_list|()
expr_stmt|;
block|}
try|try
block|{
if|if
condition|(
name|blockManager
operator|!=
literal|null
condition|)
name|blockManager
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
name|RetryCache
operator|.
name|clear
argument_list|(
name|retryCache
argument_list|)
expr_stmt|;
block|}
comment|/**    * Start services required in active state    * @throws IOException    */
DECL|method|startActiveServices ()
name|void
name|startActiveServices
parameter_list|()
throws|throws
name|IOException
block|{
name|startingActiveService
operator|=
literal|true
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Starting services required for active state"
argument_list|)
expr_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|FSEditLog
name|editLog
init|=
name|getFSImage
argument_list|()
operator|.
name|getEditLog
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|editLog
operator|.
name|isOpenForWrite
argument_list|()
condition|)
block|{
comment|// During startup, we're already open for write during initialization.
name|editLog
operator|.
name|initJournalsForWrite
argument_list|()
expr_stmt|;
comment|// May need to recover
name|editLog
operator|.
name|recoverUnclosedStreams
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Catching up to latest edits from old active before "
operator|+
literal|"taking over writer role in edits logs"
argument_list|)
expr_stmt|;
name|editLogTailer
operator|.
name|catchupDuringFailover
argument_list|()
expr_stmt|;
name|blockManager
operator|.
name|setPostponeBlocksFromFuture
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|blockManager
operator|.
name|getDatanodeManager
argument_list|()
operator|.
name|markAllDatanodesStale
argument_list|()
expr_stmt|;
name|blockManager
operator|.
name|clearQueues
argument_list|()
expr_stmt|;
name|blockManager
operator|.
name|processAllPendingDNMessages
argument_list|()
expr_stmt|;
comment|// Only need to re-process the queue, If not in SafeMode.
if|if
condition|(
operator|!
name|isInSafeMode
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Reprocessing replication and invalidation queues"
argument_list|)
expr_stmt|;
name|initializeReplQueues
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"NameNode metadata after re-processing "
operator|+
literal|"replication and invalidation queues during failover:\n"
operator|+
name|metaSaveAsString
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|long
name|nextTxId
init|=
name|getFSImage
argument_list|()
operator|.
name|getLastAppliedTxId
argument_list|()
operator|+
literal|1
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Will take over writing edit logs at txnid "
operator|+
name|nextTxId
argument_list|)
expr_stmt|;
name|editLog
operator|.
name|setNextTxId
argument_list|(
name|nextTxId
argument_list|)
expr_stmt|;
name|getFSImage
argument_list|()
operator|.
name|editLog
operator|.
name|openForWrite
argument_list|()
expr_stmt|;
block|}
comment|// Enable quota checks.
name|dir
operator|.
name|enableQuotaChecks
argument_list|()
expr_stmt|;
if|if
condition|(
name|haEnabled
condition|)
block|{
comment|// Renew all of the leases before becoming active.
comment|// This is because, while we were in standby mode,
comment|// the leases weren't getting renewed on this NN.
comment|// Give them all a fresh start here.
name|leaseManager
operator|.
name|renewAllLeases
argument_list|()
expr_stmt|;
block|}
name|leaseManager
operator|.
name|startMonitor
argument_list|()
expr_stmt|;
name|startSecretManagerIfNecessary
argument_list|()
expr_stmt|;
comment|//ResourceMonitor required only at ActiveNN. See HDFS-2914
name|this
operator|.
name|nnrmthread
operator|=
operator|new
name|Daemon
argument_list|(
operator|new
name|NameNodeResourceMonitor
argument_list|()
argument_list|)
expr_stmt|;
name|nnrmthread
operator|.
name|start
argument_list|()
expr_stmt|;
name|nnEditLogRoller
operator|=
operator|new
name|Daemon
argument_list|(
operator|new
name|NameNodeEditLogRoller
argument_list|(
name|editLogRollerThreshold
argument_list|,
name|editLogRollerInterval
argument_list|)
argument_list|)
expr_stmt|;
name|nnEditLogRoller
operator|.
name|start
argument_list|()
expr_stmt|;
if|if
condition|(
name|lazyPersistFileScrubIntervalSec
operator|>
literal|0
condition|)
block|{
name|lazyPersistFileScrubber
operator|=
operator|new
name|Daemon
argument_list|(
operator|new
name|LazyPersistFileScrubber
argument_list|(
name|lazyPersistFileScrubIntervalSec
argument_list|)
argument_list|)
expr_stmt|;
name|lazyPersistFileScrubber
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
name|cacheManager
operator|.
name|startMonitorThread
argument_list|()
expr_stmt|;
name|blockManager
operator|.
name|getDatanodeManager
argument_list|()
operator|.
name|setShouldSendCachingCommands
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|startingActiveService
operator|=
literal|false
expr_stmt|;
name|checkSafeMode
argument_list|()
expr_stmt|;
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|inActiveState ()
specifier|private
name|boolean
name|inActiveState
parameter_list|()
block|{
return|return
name|haContext
operator|!=
literal|null
operator|&&
name|haContext
operator|.
name|getState
argument_list|()
operator|.
name|getServiceState
argument_list|()
operator|==
name|HAServiceState
operator|.
name|ACTIVE
return|;
block|}
comment|/**    * Initialize replication queues.    */
DECL|method|initializeReplQueues ()
specifier|private
name|void
name|initializeReplQueues
parameter_list|()
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"initializing replication queues"
argument_list|)
expr_stmt|;
name|blockManager
operator|.
name|processMisReplicatedBlocks
argument_list|()
expr_stmt|;
name|initializedReplQueues
operator|=
literal|true
expr_stmt|;
block|}
comment|/**    * @return Whether the namenode is transitioning to active state and is in the    *         middle of the {@link #startActiveServices()}    */
DECL|method|inTransitionToActive ()
specifier|public
name|boolean
name|inTransitionToActive
parameter_list|()
block|{
return|return
name|haEnabled
operator|&&
name|inActiveState
argument_list|()
operator|&&
name|startingActiveService
return|;
block|}
DECL|method|shouldUseDelegationTokens ()
specifier|private
name|boolean
name|shouldUseDelegationTokens
parameter_list|()
block|{
return|return
name|UserGroupInformation
operator|.
name|isSecurityEnabled
argument_list|()
operator|||
name|alwaysUseDelegationTokensForTests
return|;
block|}
comment|/**     * Stop services required in active state    */
DECL|method|stopActiveServices ()
name|void
name|stopActiveServices
parameter_list|()
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Stopping services started for active state"
argument_list|)
expr_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|stopSecretManager
argument_list|()
expr_stmt|;
name|leaseManager
operator|.
name|stopMonitor
argument_list|()
expr_stmt|;
if|if
condition|(
name|nnrmthread
operator|!=
literal|null
condition|)
block|{
operator|(
operator|(
name|NameNodeResourceMonitor
operator|)
name|nnrmthread
operator|.
name|getRunnable
argument_list|()
operator|)
operator|.
name|stopMonitor
argument_list|()
expr_stmt|;
name|nnrmthread
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|nnEditLogRoller
operator|!=
literal|null
condition|)
block|{
operator|(
operator|(
name|NameNodeEditLogRoller
operator|)
name|nnEditLogRoller
operator|.
name|getRunnable
argument_list|()
operator|)
operator|.
name|stop
argument_list|()
expr_stmt|;
name|nnEditLogRoller
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|lazyPersistFileScrubber
operator|!=
literal|null
condition|)
block|{
operator|(
operator|(
name|LazyPersistFileScrubber
operator|)
name|lazyPersistFileScrubber
operator|.
name|getRunnable
argument_list|()
operator|)
operator|.
name|stop
argument_list|()
expr_stmt|;
name|lazyPersistFileScrubber
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|dir
operator|!=
literal|null
operator|&&
name|getFSImage
argument_list|()
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|getFSImage
argument_list|()
operator|.
name|editLog
operator|!=
literal|null
condition|)
block|{
name|getFSImage
argument_list|()
operator|.
name|editLog
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|// Update the fsimage with the last txid that we wrote
comment|// so that the tailer starts from the right spot.
name|getFSImage
argument_list|()
operator|.
name|updateLastAppliedTxIdFromWritten
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|cacheManager
operator|!=
literal|null
condition|)
block|{
name|cacheManager
operator|.
name|stopMonitorThread
argument_list|()
expr_stmt|;
name|cacheManager
operator|.
name|clearDirectiveStats
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|blockManager
operator|!=
literal|null
condition|)
block|{
name|blockManager
operator|.
name|getDatanodeManager
argument_list|()
operator|.
name|clearPendingCachingCommands
argument_list|()
expr_stmt|;
name|blockManager
operator|.
name|getDatanodeManager
argument_list|()
operator|.
name|setShouldSendCachingCommands
argument_list|(
literal|false
argument_list|)
expr_stmt|;
comment|// Don't want to keep replication queues when not in Active.
name|blockManager
operator|.
name|clearQueues
argument_list|()
expr_stmt|;
block|}
name|initializedReplQueues
operator|=
literal|false
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Start services required in standby state     *     * @throws IOException    */
DECL|method|startStandbyServices (final Configuration conf)
name|void
name|startStandbyServices
parameter_list|(
specifier|final
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Starting services required for standby state"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|getFSImage
argument_list|()
operator|.
name|editLog
operator|.
name|isOpenForRead
argument_list|()
condition|)
block|{
comment|// During startup, we're already open for read.
name|getFSImage
argument_list|()
operator|.
name|editLog
operator|.
name|initSharedJournalsForRead
argument_list|()
expr_stmt|;
block|}
name|blockManager
operator|.
name|setPostponeBlocksFromFuture
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|// Disable quota checks while in standby.
name|dir
operator|.
name|disableQuotaChecks
argument_list|()
expr_stmt|;
name|editLogTailer
operator|=
operator|new
name|EditLogTailer
argument_list|(
name|this
argument_list|,
name|conf
argument_list|)
expr_stmt|;
name|editLogTailer
operator|.
name|start
argument_list|()
expr_stmt|;
if|if
condition|(
name|standbyShouldCheckpoint
condition|)
block|{
name|standbyCheckpointer
operator|=
operator|new
name|StandbyCheckpointer
argument_list|(
name|conf
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|standbyCheckpointer
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Called when the NN is in Standby state and the editlog tailer tails the    * OP_ROLLING_UPGRADE_START.    */
DECL|method|triggerRollbackCheckpoint ()
name|void
name|triggerRollbackCheckpoint
parameter_list|()
block|{
name|setNeedRollbackFsImage
argument_list|(
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|standbyCheckpointer
operator|!=
literal|null
condition|)
block|{
name|standbyCheckpointer
operator|.
name|triggerRollbackCheckpoint
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Called while the NN is in Standby state, but just about to be    * asked to enter Active state. This cancels any checkpoints    * currently being taken.    */
DECL|method|prepareToStopStandbyServices ()
name|void
name|prepareToStopStandbyServices
parameter_list|()
throws|throws
name|ServiceFailedException
block|{
if|if
condition|(
name|standbyCheckpointer
operator|!=
literal|null
condition|)
block|{
name|standbyCheckpointer
operator|.
name|cancelAndPreventCheckpoints
argument_list|(
literal|"About to leave standby state"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Stop services required in standby state */
DECL|method|stopStandbyServices ()
name|void
name|stopStandbyServices
parameter_list|()
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Stopping services started for standby state"
argument_list|)
expr_stmt|;
if|if
condition|(
name|standbyCheckpointer
operator|!=
literal|null
condition|)
block|{
name|standbyCheckpointer
operator|.
name|stop
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|editLogTailer
operator|!=
literal|null
condition|)
block|{
name|editLogTailer
operator|.
name|stop
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|dir
operator|!=
literal|null
operator|&&
name|getFSImage
argument_list|()
operator|!=
literal|null
operator|&&
name|getFSImage
argument_list|()
operator|.
name|editLog
operator|!=
literal|null
condition|)
block|{
name|getFSImage
argument_list|()
operator|.
name|editLog
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|checkOperation (OperationCategory op)
specifier|public
name|void
name|checkOperation
parameter_list|(
name|OperationCategory
name|op
parameter_list|)
throws|throws
name|StandbyException
block|{
if|if
condition|(
name|haContext
operator|!=
literal|null
condition|)
block|{
comment|// null in some unit tests
name|haContext
operator|.
name|checkOperation
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * @throws RetriableException    *           If 1) The NameNode is in SafeMode, 2) HA is enabled, and 3)    *           NameNode is in active state    * @throws SafeModeException    *           Otherwise if NameNode is in SafeMode.    */
DECL|method|checkNameNodeSafeMode (String errorMsg)
name|void
name|checkNameNodeSafeMode
parameter_list|(
name|String
name|errorMsg
parameter_list|)
throws|throws
name|RetriableException
throws|,
name|SafeModeException
block|{
if|if
condition|(
name|isInSafeMode
argument_list|()
condition|)
block|{
name|SafeModeException
name|se
init|=
operator|new
name|SafeModeException
argument_list|(
name|errorMsg
argument_list|,
name|safeMode
argument_list|)
decl_stmt|;
if|if
condition|(
name|haEnabled
operator|&&
name|haContext
operator|!=
literal|null
operator|&&
name|haContext
operator|.
name|getState
argument_list|()
operator|.
name|getServiceState
argument_list|()
operator|==
name|HAServiceState
operator|.
name|ACTIVE
operator|&&
name|shouldRetrySafeMode
argument_list|(
name|this
operator|.
name|safeMode
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|RetriableException
argument_list|(
name|se
argument_list|)
throw|;
block|}
else|else
block|{
throw|throw
name|se
throw|;
block|}
block|}
block|}
DECL|method|isPermissionEnabled ()
name|boolean
name|isPermissionEnabled
parameter_list|()
block|{
return|return
name|isPermissionEnabled
return|;
block|}
comment|/**    * We already know that the safemode is on. We will throw a RetriableException    * if the safemode is not manual or caused by low resource.    */
DECL|method|shouldRetrySafeMode (SafeModeInfo safeMode)
specifier|private
name|boolean
name|shouldRetrySafeMode
parameter_list|(
name|SafeModeInfo
name|safeMode
parameter_list|)
block|{
if|if
condition|(
name|safeMode
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
else|else
block|{
return|return
operator|!
name|safeMode
operator|.
name|isManual
argument_list|()
operator|&&
operator|!
name|safeMode
operator|.
name|areResourcesLow
argument_list|()
return|;
block|}
block|}
DECL|method|getNamespaceDirs (Configuration conf)
specifier|public
specifier|static
name|Collection
argument_list|<
name|URI
argument_list|>
name|getNamespaceDirs
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
return|return
name|getStorageDirs
argument_list|(
name|conf
argument_list|,
name|DFS_NAMENODE_NAME_DIR_KEY
argument_list|)
return|;
block|}
comment|/**    * Get all edits dirs which are required. If any shared edits dirs are    * configured, these are also included in the set of required dirs.    *     * @param conf the HDFS configuration.    * @return all required dirs.    */
DECL|method|getRequiredNamespaceEditsDirs (Configuration conf)
specifier|public
specifier|static
name|Collection
argument_list|<
name|URI
argument_list|>
name|getRequiredNamespaceEditsDirs
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
name|Set
argument_list|<
name|URI
argument_list|>
name|ret
init|=
operator|new
name|HashSet
argument_list|<
name|URI
argument_list|>
argument_list|()
decl_stmt|;
name|ret
operator|.
name|addAll
argument_list|(
name|getStorageDirs
argument_list|(
name|conf
argument_list|,
name|DFS_NAMENODE_EDITS_DIR_REQUIRED_KEY
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|.
name|addAll
argument_list|(
name|getSharedEditsDirs
argument_list|(
name|conf
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
DECL|method|getStorageDirs (Configuration conf, String propertyName)
specifier|private
specifier|static
name|Collection
argument_list|<
name|URI
argument_list|>
name|getStorageDirs
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|String
name|propertyName
parameter_list|)
block|{
name|Collection
argument_list|<
name|String
argument_list|>
name|dirNames
init|=
name|conf
operator|.
name|getTrimmedStringCollection
argument_list|(
name|propertyName
argument_list|)
decl_stmt|;
name|StartupOption
name|startOpt
init|=
name|NameNode
operator|.
name|getStartupOption
argument_list|(
name|conf
argument_list|)
decl_stmt|;
if|if
condition|(
name|startOpt
operator|==
name|StartupOption
operator|.
name|IMPORT
condition|)
block|{
comment|// In case of IMPORT this will get rid of default directories
comment|// but will retain directories specified in hdfs-site.xml
comment|// When importing image from a checkpoint, the name-node can
comment|// start with empty set of storage directories.
name|Configuration
name|cE
init|=
operator|new
name|HdfsConfiguration
argument_list|(
literal|false
argument_list|)
decl_stmt|;
name|cE
operator|.
name|addResource
argument_list|(
literal|"core-default.xml"
argument_list|)
expr_stmt|;
name|cE
operator|.
name|addResource
argument_list|(
literal|"core-site.xml"
argument_list|)
expr_stmt|;
name|cE
operator|.
name|addResource
argument_list|(
literal|"hdfs-default.xml"
argument_list|)
expr_stmt|;
name|Collection
argument_list|<
name|String
argument_list|>
name|dirNames2
init|=
name|cE
operator|.
name|getTrimmedStringCollection
argument_list|(
name|propertyName
argument_list|)
decl_stmt|;
name|dirNames
operator|.
name|removeAll
argument_list|(
name|dirNames2
argument_list|)
expr_stmt|;
if|if
condition|(
name|dirNames
operator|.
name|isEmpty
argument_list|()
condition|)
name|LOG
operator|.
name|warn
argument_list|(
literal|"!!! WARNING !!!"
operator|+
literal|"\n\tThe NameNode currently runs without persistent storage."
operator|+
literal|"\n\tAny changes to the file system meta-data may be lost."
operator|+
literal|"\n\tRecommended actions:"
operator|+
literal|"\n\t\t- shutdown and restart NameNode with configured \""
operator|+
name|propertyName
operator|+
literal|"\" in hdfs-site.xml;"
operator|+
literal|"\n\t\t- use Backup Node as a persistent and up-to-date storage "
operator|+
literal|"of the file system meta-data."
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dirNames
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|dirNames
operator|=
name|Collections
operator|.
name|singletonList
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_EDITS_DIR_DEFAULT
argument_list|)
expr_stmt|;
block|}
return|return
name|Util
operator|.
name|stringCollectionAsURIs
argument_list|(
name|dirNames
argument_list|)
return|;
block|}
comment|/**    * Return an ordered list of edits directories to write to.    * The list is ordered such that all shared edits directories    * are ordered before non-shared directories, and any duplicates    * are removed. The order they are specified in the configuration    * is retained.    * @return Collection of shared edits directories.    * @throws IOException if multiple shared edits directories are configured    */
DECL|method|getNamespaceEditsDirs (Configuration conf)
specifier|public
specifier|static
name|List
argument_list|<
name|URI
argument_list|>
name|getNamespaceEditsDirs
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|getNamespaceEditsDirs
argument_list|(
name|conf
argument_list|,
literal|true
argument_list|)
return|;
block|}
DECL|method|getNamespaceEditsDirs (Configuration conf, boolean includeShared)
specifier|public
specifier|static
name|List
argument_list|<
name|URI
argument_list|>
name|getNamespaceEditsDirs
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|boolean
name|includeShared
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Use a LinkedHashSet so that order is maintained while we de-dup
comment|// the entries.
name|LinkedHashSet
argument_list|<
name|URI
argument_list|>
name|editsDirs
init|=
operator|new
name|LinkedHashSet
argument_list|<
name|URI
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|includeShared
condition|)
block|{
name|List
argument_list|<
name|URI
argument_list|>
name|sharedDirs
init|=
name|getSharedEditsDirs
argument_list|(
name|conf
argument_list|)
decl_stmt|;
comment|// Fail until multiple shared edits directories are supported (HDFS-2782)
if|if
condition|(
name|sharedDirs
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Multiple shared edits directories are not yet supported"
argument_list|)
throw|;
block|}
comment|// First add the shared edits dirs. It's critical that the shared dirs
comment|// are added first, since JournalSet syncs them in the order they are listed,
comment|// and we need to make sure all edits are in place in the shared storage
comment|// before they are replicated locally. See HDFS-2874.
for|for
control|(
name|URI
name|dir
range|:
name|sharedDirs
control|)
block|{
if|if
condition|(
operator|!
name|editsDirs
operator|.
name|add
argument_list|(
name|dir
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Edits URI "
operator|+
name|dir
operator|+
literal|" listed multiple times in "
operator|+
name|DFS_NAMENODE_SHARED_EDITS_DIR_KEY
operator|+
literal|". Ignoring duplicates."
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// Now add the non-shared dirs.
for|for
control|(
name|URI
name|dir
range|:
name|getStorageDirs
argument_list|(
name|conf
argument_list|,
name|DFS_NAMENODE_EDITS_DIR_KEY
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|editsDirs
operator|.
name|add
argument_list|(
name|dir
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Edits URI "
operator|+
name|dir
operator|+
literal|" listed multiple times in "
operator|+
name|DFS_NAMENODE_SHARED_EDITS_DIR_KEY
operator|+
literal|" and "
operator|+
name|DFS_NAMENODE_EDITS_DIR_KEY
operator|+
literal|". Ignoring duplicates."
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|editsDirs
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// If this is the case, no edit dirs have been explicitly configured.
comment|// Image dirs are to be used for edits too.
return|return
name|Lists
operator|.
name|newArrayList
argument_list|(
name|getNamespaceDirs
argument_list|(
name|conf
argument_list|)
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|Lists
operator|.
name|newArrayList
argument_list|(
name|editsDirs
argument_list|)
return|;
block|}
block|}
comment|/**    * Returns edit directories that are shared between primary and secondary.    * @param conf configuration    * @return collection of edit directories from {@code conf}    */
DECL|method|getSharedEditsDirs (Configuration conf)
specifier|public
specifier|static
name|List
argument_list|<
name|URI
argument_list|>
name|getSharedEditsDirs
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
comment|// don't use getStorageDirs here, because we want an empty default
comment|// rather than the dir in /tmp
name|Collection
argument_list|<
name|String
argument_list|>
name|dirNames
init|=
name|conf
operator|.
name|getTrimmedStringCollection
argument_list|(
name|DFS_NAMENODE_SHARED_EDITS_DIR_KEY
argument_list|)
decl_stmt|;
return|return
name|Util
operator|.
name|stringCollectionAsURIs
argument_list|(
name|dirNames
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|readLock ()
specifier|public
name|void
name|readLock
parameter_list|()
block|{
name|this
operator|.
name|fsLock
operator|.
name|readLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|readUnlock ()
specifier|public
name|void
name|readUnlock
parameter_list|()
block|{
name|this
operator|.
name|fsLock
operator|.
name|readLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|writeLock ()
specifier|public
name|void
name|writeLock
parameter_list|()
block|{
name|this
operator|.
name|fsLock
operator|.
name|writeLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|writeLockInterruptibly ()
specifier|public
name|void
name|writeLockInterruptibly
parameter_list|()
throws|throws
name|InterruptedException
block|{
name|this
operator|.
name|fsLock
operator|.
name|writeLock
argument_list|()
operator|.
name|lockInterruptibly
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|writeUnlock ()
specifier|public
name|void
name|writeUnlock
parameter_list|()
block|{
name|this
operator|.
name|fsLock
operator|.
name|writeLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|hasWriteLock ()
specifier|public
name|boolean
name|hasWriteLock
parameter_list|()
block|{
return|return
name|this
operator|.
name|fsLock
operator|.
name|isWriteLockedByCurrentThread
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|hasReadLock ()
specifier|public
name|boolean
name|hasReadLock
parameter_list|()
block|{
return|return
name|this
operator|.
name|fsLock
operator|.
name|getReadHoldCount
argument_list|()
operator|>
literal|0
operator|||
name|hasWriteLock
argument_list|()
return|;
block|}
DECL|method|getReadHoldCount ()
specifier|public
name|int
name|getReadHoldCount
parameter_list|()
block|{
return|return
name|this
operator|.
name|fsLock
operator|.
name|getReadHoldCount
argument_list|()
return|;
block|}
DECL|method|getWriteHoldCount ()
specifier|public
name|int
name|getWriteHoldCount
parameter_list|()
block|{
return|return
name|this
operator|.
name|fsLock
operator|.
name|getWriteHoldCount
argument_list|()
return|;
block|}
comment|/** Lock the checkpoint lock */
DECL|method|cpLock ()
specifier|public
name|void
name|cpLock
parameter_list|()
block|{
name|this
operator|.
name|cpLock
operator|.
name|lock
argument_list|()
expr_stmt|;
block|}
comment|/** Lock the checkpoint lock interrupibly */
DECL|method|cpLockInterruptibly ()
specifier|public
name|void
name|cpLockInterruptibly
parameter_list|()
throws|throws
name|InterruptedException
block|{
name|this
operator|.
name|cpLock
operator|.
name|lockInterruptibly
argument_list|()
expr_stmt|;
block|}
comment|/** Unlock the checkpoint lock */
DECL|method|cpUnlock ()
specifier|public
name|void
name|cpUnlock
parameter_list|()
block|{
name|this
operator|.
name|cpLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
DECL|method|getNamespaceInfo ()
name|NamespaceInfo
name|getNamespaceInfo
parameter_list|()
block|{
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
return|return
name|unprotectedGetNamespaceInfo
argument_list|()
return|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Version of @see #getNamespaceInfo() that is not protected by a lock.    */
DECL|method|unprotectedGetNamespaceInfo ()
name|NamespaceInfo
name|unprotectedGetNamespaceInfo
parameter_list|()
block|{
return|return
operator|new
name|NamespaceInfo
argument_list|(
name|getFSImage
argument_list|()
operator|.
name|getStorage
argument_list|()
operator|.
name|getNamespaceID
argument_list|()
argument_list|,
name|getClusterId
argument_list|()
argument_list|,
name|getBlockPoolId
argument_list|()
argument_list|,
name|getFSImage
argument_list|()
operator|.
name|getStorage
argument_list|()
operator|.
name|getCTime
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Close down this file system manager.    * Causes heartbeat and lease daemons to stop; waits briefly for    * them to finish, but a short timeout returns control back to caller.    */
DECL|method|close ()
name|void
name|close
parameter_list|()
block|{
name|fsRunning
operator|=
literal|false
expr_stmt|;
try|try
block|{
name|stopCommonServices
argument_list|()
expr_stmt|;
if|if
condition|(
name|smmthread
operator|!=
literal|null
condition|)
name|smmthread
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
comment|// using finally to ensure we also wait for lease daemon
try|try
block|{
name|stopActiveServices
argument_list|()
expr_stmt|;
name|stopStandbyServices
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ie
parameter_list|)
block|{       }
finally|finally
block|{
name|IOUtils
operator|.
name|cleanup
argument_list|(
name|LOG
argument_list|,
name|dir
argument_list|)
expr_stmt|;
name|IOUtils
operator|.
name|cleanup
argument_list|(
name|LOG
argument_list|,
name|fsImage
argument_list|)
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
DECL|method|isRunning ()
specifier|public
name|boolean
name|isRunning
parameter_list|()
block|{
return|return
name|fsRunning
return|;
block|}
annotation|@
name|Override
DECL|method|isInStandbyState ()
specifier|public
name|boolean
name|isInStandbyState
parameter_list|()
block|{
if|if
condition|(
name|haContext
operator|==
literal|null
operator|||
name|haContext
operator|.
name|getState
argument_list|()
operator|==
literal|null
condition|)
block|{
comment|// We're still starting up. In this case, if HA is
comment|// on for the cluster, we always start in standby. Otherwise
comment|// start in active.
return|return
name|haEnabled
return|;
block|}
return|return
name|HAServiceState
operator|.
name|STANDBY
operator|==
name|haContext
operator|.
name|getState
argument_list|()
operator|.
name|getServiceState
argument_list|()
return|;
block|}
comment|/**    * Dump all metadata into specified file    */
DECL|method|metaSave (String filename)
name|void
name|metaSave
parameter_list|(
name|String
name|filename
parameter_list|)
throws|throws
name|IOException
block|{
name|checkSuperuserPrivilege
argument_list|()
expr_stmt|;
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|UNCHECKED
argument_list|)
expr_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|UNCHECKED
argument_list|)
expr_stmt|;
name|File
name|file
init|=
operator|new
name|File
argument_list|(
name|System
operator|.
name|getProperty
argument_list|(
literal|"hadoop.log.dir"
argument_list|)
argument_list|,
name|filename
argument_list|)
decl_stmt|;
name|PrintWriter
name|out
init|=
operator|new
name|PrintWriter
argument_list|(
operator|new
name|BufferedWriter
argument_list|(
operator|new
name|OutputStreamWriter
argument_list|(
operator|new
name|FileOutputStream
argument_list|(
name|file
argument_list|)
argument_list|,
name|Charsets
operator|.
name|UTF_8
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|metaSave
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|out
operator|.
name|flush
argument_list|()
expr_stmt|;
name|out
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|metaSave (PrintWriter out)
specifier|private
name|void
name|metaSave
parameter_list|(
name|PrintWriter
name|out
parameter_list|)
block|{
assert|assert
name|hasWriteLock
argument_list|()
assert|;
name|long
name|totalInodes
init|=
name|this
operator|.
name|dir
operator|.
name|totalInodes
argument_list|()
decl_stmt|;
name|long
name|totalBlocks
init|=
name|this
operator|.
name|getBlocksTotal
argument_list|()
decl_stmt|;
name|out
operator|.
name|println
argument_list|(
name|totalInodes
operator|+
literal|" files and directories, "
operator|+
name|totalBlocks
operator|+
literal|" blocks = "
operator|+
operator|(
name|totalInodes
operator|+
name|totalBlocks
operator|)
operator|+
literal|" total filesystem objects"
argument_list|)
expr_stmt|;
name|blockManager
operator|.
name|metaSave
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|}
DECL|method|metaSaveAsString ()
specifier|private
name|String
name|metaSaveAsString
parameter_list|()
block|{
name|StringWriter
name|sw
init|=
operator|new
name|StringWriter
argument_list|()
decl_stmt|;
name|PrintWriter
name|pw
init|=
operator|new
name|PrintWriter
argument_list|(
name|sw
argument_list|)
decl_stmt|;
name|metaSave
argument_list|(
name|pw
argument_list|)
expr_stmt|;
name|pw
operator|.
name|flush
argument_list|()
expr_stmt|;
return|return
name|sw
operator|.
name|toString
argument_list|()
return|;
block|}
DECL|method|getServerDefaults ()
name|FsServerDefaults
name|getServerDefaults
parameter_list|()
throws|throws
name|StandbyException
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|READ
argument_list|)
expr_stmt|;
return|return
name|serverDefaults
return|;
block|}
DECL|method|getAccessTimePrecision ()
name|long
name|getAccessTimePrecision
parameter_list|()
block|{
return|return
name|accessTimePrecision
return|;
block|}
DECL|method|isAccessTimeSupported ()
specifier|private
name|boolean
name|isAccessTimeSupported
parameter_list|()
block|{
return|return
name|accessTimePrecision
operator|>
literal|0
return|;
block|}
comment|/////////////////////////////////////////////////////////
comment|//
comment|// These methods are called by HadoopFS clients
comment|//
comment|/////////////////////////////////////////////////////////
comment|/**    * Set permissions for an existing file.    * @throws IOException    */
DECL|method|setPermission (String src, FsPermission permission)
name|void
name|setPermission
parameter_list|(
name|String
name|src
parameter_list|,
name|FsPermission
name|permission
parameter_list|)
throws|throws
name|IOException
block|{
name|HdfsFileStatus
name|auditStat
decl_stmt|;
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|checkNameNodeSafeMode
argument_list|(
literal|"Cannot set permission for "
operator|+
name|src
argument_list|)
expr_stmt|;
name|auditStat
operator|=
name|FSDirAttrOp
operator|.
name|setPermission
argument_list|(
name|dir
argument_list|,
name|src
argument_list|,
name|permission
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|AccessControlException
name|e
parameter_list|)
block|{
name|logAuditEvent
argument_list|(
literal|false
argument_list|,
literal|"setPermission"
argument_list|,
name|src
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
name|getEditLog
argument_list|()
operator|.
name|logSync
argument_list|()
expr_stmt|;
name|logAuditEvent
argument_list|(
literal|true
argument_list|,
literal|"setPermission"
argument_list|,
name|src
argument_list|,
literal|null
argument_list|,
name|auditStat
argument_list|)
expr_stmt|;
block|}
comment|/**    * Set owner for an existing file.    * @throws IOException    */
DECL|method|setOwner (String src, String username, String group)
name|void
name|setOwner
parameter_list|(
name|String
name|src
parameter_list|,
name|String
name|username
parameter_list|,
name|String
name|group
parameter_list|)
throws|throws
name|IOException
block|{
name|HdfsFileStatus
name|auditStat
decl_stmt|;
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|checkNameNodeSafeMode
argument_list|(
literal|"Cannot set owner for "
operator|+
name|src
argument_list|)
expr_stmt|;
name|auditStat
operator|=
name|FSDirAttrOp
operator|.
name|setOwner
argument_list|(
name|dir
argument_list|,
name|src
argument_list|,
name|username
argument_list|,
name|group
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|AccessControlException
name|e
parameter_list|)
block|{
name|logAuditEvent
argument_list|(
literal|false
argument_list|,
literal|"setOwner"
argument_list|,
name|src
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
name|getEditLog
argument_list|()
operator|.
name|logSync
argument_list|()
expr_stmt|;
name|logAuditEvent
argument_list|(
literal|true
argument_list|,
literal|"setOwner"
argument_list|,
name|src
argument_list|,
literal|null
argument_list|,
name|auditStat
argument_list|)
expr_stmt|;
block|}
DECL|class|GetBlockLocationsResult
specifier|static
class|class
name|GetBlockLocationsResult
block|{
DECL|field|updateAccessTime
specifier|final
name|boolean
name|updateAccessTime
decl_stmt|;
DECL|field|blocks
specifier|final
name|LocatedBlocks
name|blocks
decl_stmt|;
DECL|method|updateAccessTime ()
name|boolean
name|updateAccessTime
parameter_list|()
block|{
return|return
name|updateAccessTime
return|;
block|}
DECL|method|GetBlockLocationsResult ( boolean updateAccessTime, LocatedBlocks blocks)
specifier|private
name|GetBlockLocationsResult
parameter_list|(
name|boolean
name|updateAccessTime
parameter_list|,
name|LocatedBlocks
name|blocks
parameter_list|)
block|{
name|this
operator|.
name|updateAccessTime
operator|=
name|updateAccessTime
expr_stmt|;
name|this
operator|.
name|blocks
operator|=
name|blocks
expr_stmt|;
block|}
block|}
comment|/**    * Get block locations within the specified range.    * @see ClientProtocol#getBlockLocations(String, long, long)    */
DECL|method|getBlockLocations (String clientMachine, String srcArg, long offset, long length)
name|LocatedBlocks
name|getBlockLocations
parameter_list|(
name|String
name|clientMachine
parameter_list|,
name|String
name|srcArg
parameter_list|,
name|long
name|offset
parameter_list|,
name|long
name|length
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|READ
argument_list|)
expr_stmt|;
name|GetBlockLocationsResult
name|res
init|=
literal|null
decl_stmt|;
name|FSPermissionChecker
name|pc
init|=
name|getPermissionChecker
argument_list|()
decl_stmt|;
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|READ
argument_list|)
expr_stmt|;
name|res
operator|=
name|getBlockLocations
argument_list|(
name|pc
argument_list|,
name|srcArg
argument_list|,
name|offset
argument_list|,
name|length
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|AccessControlException
name|e
parameter_list|)
block|{
name|logAuditEvent
argument_list|(
literal|false
argument_list|,
literal|"open"
argument_list|,
name|srcArg
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
name|logAuditEvent
argument_list|(
literal|true
argument_list|,
literal|"open"
argument_list|,
name|srcArg
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|.
name|updateAccessTime
argument_list|()
condition|)
block|{
name|byte
index|[]
index|[]
name|pathComponents
init|=
name|FSDirectory
operator|.
name|getPathComponentsForReservedPath
argument_list|(
name|srcArg
argument_list|)
decl_stmt|;
name|String
name|src
init|=
name|srcArg
decl_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
specifier|final
name|long
name|now
init|=
name|now
argument_list|()
decl_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
comment|/**          * Resolve the path again and update the atime only when the file          * exists.          *          * XXX: Races can still occur even after resolving the path again.          * For example:          *          *<ul>          *<li>Get the block location for "/a/b"</li>          *<li>Rename "/a/b" to "/c/b"</li>          *<li>The second resolution still points to "/a/b", which is          *   wrong.</li>          *</ul>          *          * The behavior is incorrect but consistent with the one before          * HDFS-7463. A better fix is to change the edit log of SetTime to          * use inode id instead of a path.          */
name|src
operator|=
name|dir
operator|.
name|resolvePath
argument_list|(
name|pc
argument_list|,
name|srcArg
argument_list|,
name|pathComponents
argument_list|)
expr_stmt|;
specifier|final
name|INodesInPath
name|iip
init|=
name|dir
operator|.
name|getINodesInPath
argument_list|(
name|src
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|INode
name|inode
init|=
name|iip
operator|.
name|getLastINode
argument_list|()
decl_stmt|;
name|boolean
name|updateAccessTime
init|=
name|inode
operator|!=
literal|null
operator|&&
name|now
operator|>
name|inode
operator|.
name|getAccessTime
argument_list|()
operator|+
name|getAccessTimePrecision
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|isInSafeMode
argument_list|()
operator|&&
name|updateAccessTime
condition|)
block|{
name|boolean
name|changed
init|=
name|FSDirAttrOp
operator|.
name|setTimes
argument_list|(
name|dir
argument_list|,
name|inode
argument_list|,
operator|-
literal|1
argument_list|,
name|now
argument_list|,
literal|false
argument_list|,
name|iip
operator|.
name|getLatestSnapshotId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|changed
condition|)
block|{
name|getEditLog
argument_list|()
operator|.
name|logTimes
argument_list|(
name|src
argument_list|,
operator|-
literal|1
argument_list|,
name|now
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to update the access time of "
operator|+
name|src
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
name|LocatedBlocks
name|blocks
init|=
name|res
operator|.
name|blocks
decl_stmt|;
if|if
condition|(
name|blocks
operator|!=
literal|null
condition|)
block|{
name|blockManager
operator|.
name|getDatanodeManager
argument_list|()
operator|.
name|sortLocatedBlocks
argument_list|(
name|clientMachine
argument_list|,
name|blocks
operator|.
name|getLocatedBlocks
argument_list|()
argument_list|)
expr_stmt|;
comment|// lastBlock is not part of getLocatedBlocks(), might need to sort it too
name|LocatedBlock
name|lastBlock
init|=
name|blocks
operator|.
name|getLastLocatedBlock
argument_list|()
decl_stmt|;
if|if
condition|(
name|lastBlock
operator|!=
literal|null
condition|)
block|{
name|ArrayList
argument_list|<
name|LocatedBlock
argument_list|>
name|lastBlockList
init|=
name|Lists
operator|.
name|newArrayList
argument_list|(
name|lastBlock
argument_list|)
decl_stmt|;
name|blockManager
operator|.
name|getDatanodeManager
argument_list|()
operator|.
name|sortLocatedBlocks
argument_list|(
name|clientMachine
argument_list|,
name|lastBlockList
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|blocks
return|;
block|}
comment|/**    * Get block locations within the specified range.    * @see ClientProtocol#getBlockLocations(String, long, long)    * @throws IOException    */
DECL|method|getBlockLocations ( FSPermissionChecker pc, String src, long offset, long length, boolean needBlockToken, boolean checkSafeMode)
name|GetBlockLocationsResult
name|getBlockLocations
parameter_list|(
name|FSPermissionChecker
name|pc
parameter_list|,
name|String
name|src
parameter_list|,
name|long
name|offset
parameter_list|,
name|long
name|length
parameter_list|,
name|boolean
name|needBlockToken
parameter_list|,
name|boolean
name|checkSafeMode
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|offset
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|HadoopIllegalArgumentException
argument_list|(
literal|"Negative offset is not supported. File: "
operator|+
name|src
argument_list|)
throw|;
block|}
if|if
condition|(
name|length
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|HadoopIllegalArgumentException
argument_list|(
literal|"Negative length is not supported. File: "
operator|+
name|src
argument_list|)
throw|;
block|}
specifier|final
name|GetBlockLocationsResult
name|ret
init|=
name|getBlockLocationsInt
argument_list|(
name|pc
argument_list|,
name|src
argument_list|,
name|offset
argument_list|,
name|length
argument_list|,
name|needBlockToken
argument_list|)
decl_stmt|;
if|if
condition|(
name|checkSafeMode
operator|&&
name|isInSafeMode
argument_list|()
condition|)
block|{
for|for
control|(
name|LocatedBlock
name|b
range|:
name|ret
operator|.
name|blocks
operator|.
name|getLocatedBlocks
argument_list|()
control|)
block|{
comment|// if safemode& no block locations yet then throw safemodeException
if|if
condition|(
operator|(
name|b
operator|.
name|getLocations
argument_list|()
operator|==
literal|null
operator|)
operator|||
operator|(
name|b
operator|.
name|getLocations
argument_list|()
operator|.
name|length
operator|==
literal|0
operator|)
condition|)
block|{
name|SafeModeException
name|se
init|=
operator|new
name|SafeModeException
argument_list|(
literal|"Zero blocklocations for "
operator|+
name|src
argument_list|,
name|safeMode
argument_list|)
decl_stmt|;
if|if
condition|(
name|haEnabled
operator|&&
name|haContext
operator|!=
literal|null
operator|&&
name|haContext
operator|.
name|getState
argument_list|()
operator|.
name|getServiceState
argument_list|()
operator|==
name|HAServiceState
operator|.
name|ACTIVE
condition|)
block|{
throw|throw
operator|new
name|RetriableException
argument_list|(
name|se
argument_list|)
throw|;
block|}
else|else
block|{
throw|throw
name|se
throw|;
block|}
block|}
block|}
block|}
return|return
name|ret
return|;
block|}
DECL|method|getBlockLocationsInt ( FSPermissionChecker pc, final String srcArg, long offset, long length, boolean needBlockToken)
specifier|private
name|GetBlockLocationsResult
name|getBlockLocationsInt
parameter_list|(
name|FSPermissionChecker
name|pc
parameter_list|,
specifier|final
name|String
name|srcArg
parameter_list|,
name|long
name|offset
parameter_list|,
name|long
name|length
parameter_list|,
name|boolean
name|needBlockToken
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|src
init|=
name|srcArg
decl_stmt|;
name|byte
index|[]
index|[]
name|pathComponents
init|=
name|FSDirectory
operator|.
name|getPathComponentsForReservedPath
argument_list|(
name|src
argument_list|)
decl_stmt|;
name|src
operator|=
name|dir
operator|.
name|resolvePath
argument_list|(
name|pc
argument_list|,
name|srcArg
argument_list|,
name|pathComponents
argument_list|)
expr_stmt|;
specifier|final
name|INodesInPath
name|iip
init|=
name|dir
operator|.
name|getINodesInPath
argument_list|(
name|src
argument_list|,
literal|true
argument_list|)
decl_stmt|;
specifier|final
name|INodeFile
name|inode
init|=
name|INodeFile
operator|.
name|valueOf
argument_list|(
name|iip
operator|.
name|getLastINode
argument_list|()
argument_list|,
name|src
argument_list|)
decl_stmt|;
if|if
condition|(
name|isPermissionEnabled
condition|)
block|{
name|dir
operator|.
name|checkPathAccess
argument_list|(
name|pc
argument_list|,
name|iip
argument_list|,
name|FsAction
operator|.
name|READ
argument_list|)
expr_stmt|;
name|checkUnreadableBySuperuser
argument_list|(
name|pc
argument_list|,
name|inode
argument_list|,
name|iip
operator|.
name|getPathSnapshotId
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|final
name|long
name|fileSize
init|=
name|iip
operator|.
name|isSnapshot
argument_list|()
condition|?
name|inode
operator|.
name|computeFileSize
argument_list|(
name|iip
operator|.
name|getPathSnapshotId
argument_list|()
argument_list|)
else|:
name|inode
operator|.
name|computeFileSizeNotIncludingLastUcBlock
argument_list|()
decl_stmt|;
name|boolean
name|isUc
init|=
name|inode
operator|.
name|isUnderConstruction
argument_list|()
decl_stmt|;
if|if
condition|(
name|iip
operator|.
name|isSnapshot
argument_list|()
condition|)
block|{
comment|// if src indicates a snapshot file, we need to make sure the returned
comment|// blocks do not exceed the size of the snapshot file.
name|length
operator|=
name|Math
operator|.
name|min
argument_list|(
name|length
argument_list|,
name|fileSize
operator|-
name|offset
argument_list|)
expr_stmt|;
name|isUc
operator|=
literal|false
expr_stmt|;
block|}
specifier|final
name|FileEncryptionInfo
name|feInfo
init|=
name|FSDirectory
operator|.
name|isReservedRawName
argument_list|(
name|srcArg
argument_list|)
condition|?
literal|null
else|:
name|dir
operator|.
name|getFileEncryptionInfo
argument_list|(
name|inode
argument_list|,
name|iip
operator|.
name|getPathSnapshotId
argument_list|()
argument_list|,
name|iip
argument_list|)
decl_stmt|;
specifier|final
name|LocatedBlocks
name|blocks
init|=
name|blockManager
operator|.
name|createLocatedBlocks
argument_list|(
name|inode
operator|.
name|getBlocks
argument_list|(
name|iip
operator|.
name|getPathSnapshotId
argument_list|()
argument_list|)
argument_list|,
name|fileSize
argument_list|,
name|isUc
argument_list|,
name|offset
argument_list|,
name|length
argument_list|,
name|needBlockToken
argument_list|,
name|iip
operator|.
name|isSnapshot
argument_list|()
argument_list|,
name|feInfo
argument_list|)
decl_stmt|;
comment|// Set caching information for the located blocks.
for|for
control|(
name|LocatedBlock
name|lb
range|:
name|blocks
operator|.
name|getLocatedBlocks
argument_list|()
control|)
block|{
name|cacheManager
operator|.
name|setCachedLocations
argument_list|(
name|lb
argument_list|)
expr_stmt|;
block|}
specifier|final
name|long
name|now
init|=
name|now
argument_list|()
decl_stmt|;
name|boolean
name|updateAccessTime
init|=
name|isAccessTimeSupported
argument_list|()
operator|&&
operator|!
name|isInSafeMode
argument_list|()
operator|&&
operator|!
name|iip
operator|.
name|isSnapshot
argument_list|()
operator|&&
name|now
operator|>
name|inode
operator|.
name|getAccessTime
argument_list|()
operator|+
name|getAccessTimePrecision
argument_list|()
decl_stmt|;
return|return
operator|new
name|GetBlockLocationsResult
argument_list|(
name|updateAccessTime
argument_list|,
name|blocks
argument_list|)
return|;
block|}
comment|/**    * Moves all the blocks from {@code srcs} and appends them to {@code target}    * To avoid rollbacks we will verify validity of ALL of the args    * before we start actual move.    *     * This does not support ".inodes" relative path    * @param target target to concat into    * @param srcs file that will be concatenated    * @throws IOException on error    */
DECL|method|concat (String target, String [] srcs, boolean logRetryCache)
name|void
name|concat
parameter_list|(
name|String
name|target
parameter_list|,
name|String
index|[]
name|srcs
parameter_list|,
name|boolean
name|logRetryCache
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|waitForLoadingFSImage
argument_list|()
expr_stmt|;
name|HdfsFileStatus
name|stat
init|=
literal|null
decl_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|checkNameNodeSafeMode
argument_list|(
literal|"Cannot concat "
operator|+
name|target
argument_list|)
expr_stmt|;
name|stat
operator|=
name|FSDirConcatOp
operator|.
name|concat
argument_list|(
name|dir
argument_list|,
name|target
argument_list|,
name|srcs
argument_list|,
name|logRetryCache
argument_list|)
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|getEditLog
argument_list|()
operator|.
name|logSync
argument_list|()
expr_stmt|;
block|}
name|logAuditEvent
argument_list|(
name|success
argument_list|,
literal|"concat"
argument_list|,
name|Arrays
operator|.
name|toString
argument_list|(
name|srcs
argument_list|)
argument_list|,
name|target
argument_list|,
name|stat
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * stores the modification and access time for this inode.     * The access time is precise up to an hour. The transaction, if needed, is    * written to the edits log but is not flushed.    */
DECL|method|setTimes (String src, long mtime, long atime)
name|void
name|setTimes
parameter_list|(
name|String
name|src
parameter_list|,
name|long
name|mtime
parameter_list|,
name|long
name|atime
parameter_list|)
throws|throws
name|IOException
block|{
name|HdfsFileStatus
name|auditStat
decl_stmt|;
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|checkNameNodeSafeMode
argument_list|(
literal|"Cannot set times "
operator|+
name|src
argument_list|)
expr_stmt|;
name|auditStat
operator|=
name|FSDirAttrOp
operator|.
name|setTimes
argument_list|(
name|dir
argument_list|,
name|src
argument_list|,
name|mtime
argument_list|,
name|atime
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|AccessControlException
name|e
parameter_list|)
block|{
name|logAuditEvent
argument_list|(
literal|false
argument_list|,
literal|"setTimes"
argument_list|,
name|src
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
name|getEditLog
argument_list|()
operator|.
name|logSync
argument_list|()
expr_stmt|;
name|logAuditEvent
argument_list|(
literal|true
argument_list|,
literal|"setTimes"
argument_list|,
name|src
argument_list|,
literal|null
argument_list|,
name|auditStat
argument_list|)
expr_stmt|;
block|}
comment|/**    * Truncate file to a lower length.    * Truncate cannot be reverted / recovered from as it causes data loss.    * Truncation at block boundary is atomic, otherwise it requires    * block recovery to truncate the last block of the file.    *    * @return true if client does not need to wait for block recovery,    * false if client needs to wait for block recovery.    */
DECL|method|truncate (String src, long newLength, String clientName, String clientMachine, long mtime)
name|boolean
name|truncate
parameter_list|(
name|String
name|src
parameter_list|,
name|long
name|newLength
parameter_list|,
name|String
name|clientName
parameter_list|,
name|String
name|clientMachine
parameter_list|,
name|long
name|mtime
parameter_list|)
throws|throws
name|IOException
throws|,
name|UnresolvedLinkException
block|{
name|boolean
name|ret
decl_stmt|;
try|try
block|{
name|ret
operator|=
name|truncateInt
argument_list|(
name|src
argument_list|,
name|newLength
argument_list|,
name|clientName
argument_list|,
name|clientMachine
argument_list|,
name|mtime
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|AccessControlException
name|e
parameter_list|)
block|{
name|logAuditEvent
argument_list|(
literal|false
argument_list|,
literal|"truncate"
argument_list|,
name|src
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
return|return
name|ret
return|;
block|}
DECL|method|truncateInt (String srcArg, long newLength, String clientName, String clientMachine, long mtime)
name|boolean
name|truncateInt
parameter_list|(
name|String
name|srcArg
parameter_list|,
name|long
name|newLength
parameter_list|,
name|String
name|clientName
parameter_list|,
name|String
name|clientMachine
parameter_list|,
name|long
name|mtime
parameter_list|)
throws|throws
name|IOException
throws|,
name|UnresolvedLinkException
block|{
name|String
name|src
init|=
name|srcArg
decl_stmt|;
if|if
condition|(
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|debug
argument_list|(
literal|"DIR* NameSystem.truncate: src="
operator|+
name|src
operator|+
literal|" newLength="
operator|+
name|newLength
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|newLength
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|HadoopIllegalArgumentException
argument_list|(
literal|"Cannot truncate to a negative file size: "
operator|+
name|newLength
operator|+
literal|"."
argument_list|)
throw|;
block|}
name|HdfsFileStatus
name|stat
init|=
literal|null
decl_stmt|;
name|FSPermissionChecker
name|pc
init|=
name|getPermissionChecker
argument_list|()
decl_stmt|;
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|boolean
name|res
decl_stmt|;
name|byte
index|[]
index|[]
name|pathComponents
init|=
name|FSDirectory
operator|.
name|getPathComponentsForReservedPath
argument_list|(
name|src
argument_list|)
decl_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
name|BlocksMapUpdateInfo
name|toRemoveBlocks
init|=
operator|new
name|BlocksMapUpdateInfo
argument_list|()
decl_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|checkNameNodeSafeMode
argument_list|(
literal|"Cannot truncate for "
operator|+
name|src
argument_list|)
expr_stmt|;
name|src
operator|=
name|dir
operator|.
name|resolvePath
argument_list|(
name|pc
argument_list|,
name|src
argument_list|,
name|pathComponents
argument_list|)
expr_stmt|;
name|res
operator|=
name|truncateInternal
argument_list|(
name|src
argument_list|,
name|newLength
argument_list|,
name|clientName
argument_list|,
name|clientMachine
argument_list|,
name|mtime
argument_list|,
name|pc
argument_list|,
name|toRemoveBlocks
argument_list|)
expr_stmt|;
name|stat
operator|=
name|dir
operator|.
name|getAuditFileInfo
argument_list|(
name|dir
operator|.
name|getINodesInPath4Write
argument_list|(
name|src
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
name|getEditLog
argument_list|()
operator|.
name|logSync
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|toRemoveBlocks
operator|.
name|getToDeleteList
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|removeBlocks
argument_list|(
name|toRemoveBlocks
argument_list|)
expr_stmt|;
name|toRemoveBlocks
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
name|logAuditEvent
argument_list|(
literal|true
argument_list|,
literal|"truncate"
argument_list|,
name|src
argument_list|,
literal|null
argument_list|,
name|stat
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
comment|/**    * Truncate a file to a given size    * Update the count at each ancestor directory with quota    */
DECL|method|truncateInternal (String src, long newLength, String clientName, String clientMachine, long mtime, FSPermissionChecker pc, BlocksMapUpdateInfo toRemoveBlocks)
name|boolean
name|truncateInternal
parameter_list|(
name|String
name|src
parameter_list|,
name|long
name|newLength
parameter_list|,
name|String
name|clientName
parameter_list|,
name|String
name|clientMachine
parameter_list|,
name|long
name|mtime
parameter_list|,
name|FSPermissionChecker
name|pc
parameter_list|,
name|BlocksMapUpdateInfo
name|toRemoveBlocks
parameter_list|)
throws|throws
name|IOException
throws|,
name|UnresolvedLinkException
block|{
assert|assert
name|hasWriteLock
argument_list|()
assert|;
name|INodesInPath
name|iip
init|=
name|dir
operator|.
name|getINodesInPath4Write
argument_list|(
name|src
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|isPermissionEnabled
condition|)
block|{
name|dir
operator|.
name|checkPathAccess
argument_list|(
name|pc
argument_list|,
name|iip
argument_list|,
name|FsAction
operator|.
name|WRITE
argument_list|)
expr_stmt|;
block|}
name|INodeFile
name|file
init|=
name|INodeFile
operator|.
name|valueOf
argument_list|(
name|iip
operator|.
name|getLastINode
argument_list|()
argument_list|,
name|src
argument_list|)
decl_stmt|;
specifier|final
name|BlockStoragePolicy
name|lpPolicy
init|=
name|blockManager
operator|.
name|getStoragePolicy
argument_list|(
literal|"LAZY_PERSIST"
argument_list|)
decl_stmt|;
if|if
condition|(
name|lpPolicy
operator|!=
literal|null
operator|&&
name|lpPolicy
operator|.
name|getId
argument_list|()
operator|==
name|file
operator|.
name|getStoragePolicyID
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"Cannot truncate lazy persist file "
operator|+
name|src
argument_list|)
throw|;
block|}
comment|// Check if the file is already being truncated with the same length
specifier|final
name|BlockInfoContiguous
name|last
init|=
name|file
operator|.
name|getLastBlock
argument_list|()
decl_stmt|;
if|if
condition|(
name|last
operator|!=
literal|null
operator|&&
name|last
operator|.
name|getBlockUCState
argument_list|()
operator|==
name|BlockUCState
operator|.
name|UNDER_RECOVERY
condition|)
block|{
specifier|final
name|Block
name|truncateBlock
init|=
operator|(
operator|(
name|BlockInfoContiguousUnderConstruction
operator|)
name|last
operator|)
operator|.
name|getTruncateBlock
argument_list|()
decl_stmt|;
if|if
condition|(
name|truncateBlock
operator|!=
literal|null
condition|)
block|{
specifier|final
name|long
name|truncateLength
init|=
name|file
operator|.
name|computeFileSize
argument_list|(
literal|false
argument_list|,
literal|false
argument_list|)
operator|+
name|truncateBlock
operator|.
name|getNumBytes
argument_list|()
decl_stmt|;
if|if
condition|(
name|newLength
operator|==
name|truncateLength
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
block|}
comment|// Opening an existing file for truncate. May need lease recovery.
name|recoverLeaseInternal
argument_list|(
name|RecoverLeaseOp
operator|.
name|TRUNCATE_FILE
argument_list|,
name|iip
argument_list|,
name|src
argument_list|,
name|clientName
argument_list|,
name|clientMachine
argument_list|,
literal|false
argument_list|)
expr_stmt|;
comment|// Truncate length check.
name|long
name|oldLength
init|=
name|file
operator|.
name|computeFileSize
argument_list|()
decl_stmt|;
if|if
condition|(
name|oldLength
operator|==
name|newLength
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
name|oldLength
operator|<
name|newLength
condition|)
block|{
throw|throw
operator|new
name|HadoopIllegalArgumentException
argument_list|(
literal|"Cannot truncate to a larger file size. Current size: "
operator|+
name|oldLength
operator|+
literal|", truncate size: "
operator|+
name|newLength
operator|+
literal|"."
argument_list|)
throw|;
block|}
comment|// Perform INodeFile truncation.
specifier|final
name|QuotaCounts
name|delta
init|=
operator|new
name|QuotaCounts
operator|.
name|Builder
argument_list|()
operator|.
name|build
argument_list|()
decl_stmt|;
name|boolean
name|onBlockBoundary
init|=
name|dir
operator|.
name|truncate
argument_list|(
name|iip
argument_list|,
name|newLength
argument_list|,
name|toRemoveBlocks
argument_list|,
name|mtime
argument_list|,
name|delta
argument_list|)
decl_stmt|;
name|Block
name|truncateBlock
init|=
literal|null
decl_stmt|;
if|if
condition|(
operator|!
name|onBlockBoundary
condition|)
block|{
comment|// Open file for write, but don't log into edits
name|long
name|lastBlockDelta
init|=
name|file
operator|.
name|computeFileSize
argument_list|()
operator|-
name|newLength
decl_stmt|;
assert|assert
name|lastBlockDelta
operator|>
literal|0
operator|:
literal|"delta is 0 only if on block bounday"
assert|;
name|truncateBlock
operator|=
name|prepareFileForTruncate
argument_list|(
name|iip
argument_list|,
name|clientName
argument_list|,
name|clientMachine
argument_list|,
name|lastBlockDelta
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|// update the quota: use the preferred block size for UC block
name|dir
operator|.
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|dir
operator|.
name|updateCountNoQuotaCheck
argument_list|(
name|iip
argument_list|,
name|iip
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|,
name|delta
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|dir
operator|.
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
name|getEditLog
argument_list|()
operator|.
name|logTruncate
argument_list|(
name|src
argument_list|,
name|clientName
argument_list|,
name|clientMachine
argument_list|,
name|newLength
argument_list|,
name|mtime
argument_list|,
name|truncateBlock
argument_list|)
expr_stmt|;
return|return
name|onBlockBoundary
return|;
block|}
comment|/**    * Convert current INode to UnderConstruction.    * Recreate lease.    * Create new block for the truncated copy.    * Schedule truncation of the replicas.    *    * @return the returned block will be written to editLog and passed back into    * this method upon loading.    */
DECL|method|prepareFileForTruncate (INodesInPath iip, String leaseHolder, String clientMachine, long lastBlockDelta, Block newBlock)
name|Block
name|prepareFileForTruncate
parameter_list|(
name|INodesInPath
name|iip
parameter_list|,
name|String
name|leaseHolder
parameter_list|,
name|String
name|clientMachine
parameter_list|,
name|long
name|lastBlockDelta
parameter_list|,
name|Block
name|newBlock
parameter_list|)
throws|throws
name|IOException
block|{
name|INodeFile
name|file
init|=
name|iip
operator|.
name|getLastINode
argument_list|()
operator|.
name|asFile
argument_list|()
decl_stmt|;
name|String
name|src
init|=
name|iip
operator|.
name|getPath
argument_list|()
decl_stmt|;
name|file
operator|.
name|recordModification
argument_list|(
name|iip
operator|.
name|getLatestSnapshotId
argument_list|()
argument_list|)
expr_stmt|;
name|file
operator|.
name|toUnderConstruction
argument_list|(
name|leaseHolder
argument_list|,
name|clientMachine
argument_list|)
expr_stmt|;
assert|assert
name|file
operator|.
name|isUnderConstruction
argument_list|()
operator|:
literal|"inode should be under construction."
assert|;
name|leaseManager
operator|.
name|addLease
argument_list|(
name|file
operator|.
name|getFileUnderConstructionFeature
argument_list|()
operator|.
name|getClientName
argument_list|()
argument_list|,
name|src
argument_list|)
expr_stmt|;
name|boolean
name|shouldRecoverNow
init|=
operator|(
name|newBlock
operator|==
literal|null
operator|)
decl_stmt|;
name|BlockInfoContiguous
name|oldBlock
init|=
name|file
operator|.
name|getLastBlock
argument_list|()
decl_stmt|;
name|boolean
name|shouldCopyOnTruncate
init|=
name|shouldCopyOnTruncate
argument_list|(
name|file
argument_list|,
name|oldBlock
argument_list|)
decl_stmt|;
if|if
condition|(
name|newBlock
operator|==
literal|null
condition|)
block|{
name|newBlock
operator|=
operator|(
name|shouldCopyOnTruncate
operator|)
condition|?
name|createNewBlock
argument_list|()
else|:
operator|new
name|Block
argument_list|(
name|oldBlock
operator|.
name|getBlockId
argument_list|()
argument_list|,
name|oldBlock
operator|.
name|getNumBytes
argument_list|()
argument_list|,
name|nextGenerationStamp
argument_list|(
name|blockIdManager
operator|.
name|isLegacyBlock
argument_list|(
name|oldBlock
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|BlockInfoContiguousUnderConstruction
name|truncatedBlockUC
decl_stmt|;
if|if
condition|(
name|shouldCopyOnTruncate
condition|)
block|{
comment|// Add new truncateBlock into blocksMap and
comment|// use oldBlock as a source for copy-on-truncate recovery
name|truncatedBlockUC
operator|=
operator|new
name|BlockInfoContiguousUnderConstruction
argument_list|(
name|newBlock
argument_list|,
name|file
operator|.
name|getBlockReplication
argument_list|()
argument_list|)
expr_stmt|;
name|truncatedBlockUC
operator|.
name|setNumBytes
argument_list|(
name|oldBlock
operator|.
name|getNumBytes
argument_list|()
operator|-
name|lastBlockDelta
argument_list|)
expr_stmt|;
name|truncatedBlockUC
operator|.
name|setTruncateBlock
argument_list|(
name|oldBlock
argument_list|)
expr_stmt|;
name|file
operator|.
name|setLastBlock
argument_list|(
name|truncatedBlockUC
argument_list|,
name|blockManager
operator|.
name|getStorages
argument_list|(
name|oldBlock
argument_list|)
argument_list|)
expr_stmt|;
name|getBlockManager
argument_list|()
operator|.
name|addBlockCollection
argument_list|(
name|truncatedBlockUC
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|info
argument_list|(
literal|"BLOCK* prepareFileForTruncate: "
operator|+
literal|"Scheduling copy-on-truncate to new size "
operator|+
name|truncatedBlockUC
operator|.
name|getNumBytes
argument_list|()
operator|+
literal|" new block "
operator|+
name|newBlock
operator|+
literal|" old block "
operator|+
name|truncatedBlockUC
operator|.
name|getTruncateBlock
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Use new generation stamp for in-place truncate recovery
name|blockManager
operator|.
name|convertLastBlockToUnderConstruction
argument_list|(
name|file
argument_list|,
name|lastBlockDelta
argument_list|)
expr_stmt|;
name|oldBlock
operator|=
name|file
operator|.
name|getLastBlock
argument_list|()
expr_stmt|;
assert|assert
operator|!
name|oldBlock
operator|.
name|isComplete
argument_list|()
operator|:
literal|"oldBlock should be under construction"
assert|;
name|truncatedBlockUC
operator|=
operator|(
name|BlockInfoContiguousUnderConstruction
operator|)
name|oldBlock
expr_stmt|;
name|truncatedBlockUC
operator|.
name|setTruncateBlock
argument_list|(
operator|new
name|Block
argument_list|(
name|oldBlock
argument_list|)
argument_list|)
expr_stmt|;
name|truncatedBlockUC
operator|.
name|getTruncateBlock
argument_list|()
operator|.
name|setNumBytes
argument_list|(
name|oldBlock
operator|.
name|getNumBytes
argument_list|()
operator|-
name|lastBlockDelta
argument_list|)
expr_stmt|;
name|truncatedBlockUC
operator|.
name|getTruncateBlock
argument_list|()
operator|.
name|setGenerationStamp
argument_list|(
name|newBlock
operator|.
name|getGenerationStamp
argument_list|()
argument_list|)
expr_stmt|;
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|debug
argument_list|(
literal|"BLOCK* prepareFileForTruncate: "
operator|+
literal|"Scheduling in-place block truncate to new size "
operator|+
name|truncatedBlockUC
operator|.
name|getTruncateBlock
argument_list|()
operator|.
name|getNumBytes
argument_list|()
operator|+
literal|" block="
operator|+
name|truncatedBlockUC
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|shouldRecoverNow
condition|)
block|{
name|truncatedBlockUC
operator|.
name|initializeBlockRecovery
argument_list|(
name|newBlock
operator|.
name|getGenerationStamp
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|newBlock
return|;
block|}
comment|/**    * Defines if a replica needs to be copied on truncate or    * can be truncated in place.    */
DECL|method|shouldCopyOnTruncate (INodeFile file, BlockInfoContiguous blk)
name|boolean
name|shouldCopyOnTruncate
parameter_list|(
name|INodeFile
name|file
parameter_list|,
name|BlockInfoContiguous
name|blk
parameter_list|)
block|{
if|if
condition|(
operator|!
name|isUpgradeFinalized
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
name|isRollingUpgrade
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
return|return
name|file
operator|.
name|isBlockInLatestSnapshot
argument_list|(
name|blk
argument_list|)
return|;
block|}
comment|/**    * Create a symbolic link.    */
DECL|method|createSymlink (String target, String link, PermissionStatus dirPerms, boolean createParent, boolean logRetryCache)
name|void
name|createSymlink
parameter_list|(
name|String
name|target
parameter_list|,
name|String
name|link
parameter_list|,
name|PermissionStatus
name|dirPerms
parameter_list|,
name|boolean
name|createParent
parameter_list|,
name|boolean
name|logRetryCache
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|FileSystem
operator|.
name|areSymlinksEnabled
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"Symlinks not supported"
argument_list|)
throw|;
block|}
name|waitForLoadingFSImage
argument_list|()
expr_stmt|;
name|HdfsFileStatus
name|auditStat
init|=
literal|null
decl_stmt|;
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|checkNameNodeSafeMode
argument_list|(
literal|"Cannot create symlink "
operator|+
name|link
argument_list|)
expr_stmt|;
name|auditStat
operator|=
name|FSDirSymlinkOp
operator|.
name|createSymlinkInt
argument_list|(
name|this
argument_list|,
name|target
argument_list|,
name|link
argument_list|,
name|dirPerms
argument_list|,
name|createParent
argument_list|,
name|logRetryCache
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|AccessControlException
name|e
parameter_list|)
block|{
name|logAuditEvent
argument_list|(
literal|false
argument_list|,
literal|"createSymlink"
argument_list|,
name|link
argument_list|,
name|target
argument_list|,
literal|null
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
name|getEditLog
argument_list|()
operator|.
name|logSync
argument_list|()
expr_stmt|;
name|logAuditEvent
argument_list|(
literal|true
argument_list|,
literal|"createSymlink"
argument_list|,
name|link
argument_list|,
name|target
argument_list|,
name|auditStat
argument_list|)
expr_stmt|;
block|}
comment|/**    * Set replication for an existing file.    *     * The NameNode sets new replication and schedules either replication of     * under-replicated data blocks or removal of the excessive block copies     * if the blocks are over-replicated.    *     * @see ClientProtocol#setReplication(String, short)    * @param src file name    * @param replication new replication    * @return true if successful;     *         false if file does not exist or is a directory    */
DECL|method|setReplication (final String src, final short replication)
name|boolean
name|setReplication
parameter_list|(
specifier|final
name|String
name|src
parameter_list|,
specifier|final
name|short
name|replication
parameter_list|)
throws|throws
name|IOException
block|{
name|boolean
name|success
init|=
literal|false
decl_stmt|;
name|waitForLoadingFSImage
argument_list|()
expr_stmt|;
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|checkNameNodeSafeMode
argument_list|(
literal|"Cannot set replication for "
operator|+
name|src
argument_list|)
expr_stmt|;
name|success
operator|=
name|FSDirAttrOp
operator|.
name|setReplication
argument_list|(
name|dir
argument_list|,
name|blockManager
argument_list|,
name|src
argument_list|,
name|replication
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|AccessControlException
name|e
parameter_list|)
block|{
name|logAuditEvent
argument_list|(
literal|false
argument_list|,
literal|"setReplication"
argument_list|,
name|src
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|success
condition|)
block|{
name|getEditLog
argument_list|()
operator|.
name|logSync
argument_list|()
expr_stmt|;
name|logAuditEvent
argument_list|(
literal|true
argument_list|,
literal|"setReplication"
argument_list|,
name|src
argument_list|)
expr_stmt|;
block|}
return|return
name|success
return|;
block|}
comment|/**    * Set the storage policy for a file or a directory.    *    * @param src file/directory path    * @param policyName storage policy name    */
DECL|method|setStoragePolicy (String src, String policyName)
name|void
name|setStoragePolicy
parameter_list|(
name|String
name|src
parameter_list|,
name|String
name|policyName
parameter_list|)
throws|throws
name|IOException
block|{
name|HdfsFileStatus
name|auditStat
decl_stmt|;
name|waitForLoadingFSImage
argument_list|()
expr_stmt|;
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|checkNameNodeSafeMode
argument_list|(
literal|"Cannot set storage policy for "
operator|+
name|src
argument_list|)
expr_stmt|;
name|auditStat
operator|=
name|FSDirAttrOp
operator|.
name|setStoragePolicy
argument_list|(
name|dir
argument_list|,
name|blockManager
argument_list|,
name|src
argument_list|,
name|policyName
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|AccessControlException
name|e
parameter_list|)
block|{
name|logAuditEvent
argument_list|(
literal|false
argument_list|,
literal|"setStoragePolicy"
argument_list|,
name|src
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
name|getEditLog
argument_list|()
operator|.
name|logSync
argument_list|()
expr_stmt|;
name|logAuditEvent
argument_list|(
literal|true
argument_list|,
literal|"setStoragePolicy"
argument_list|,
name|src
argument_list|,
literal|null
argument_list|,
name|auditStat
argument_list|)
expr_stmt|;
block|}
comment|/**    * @return All the existing block storage policies    */
DECL|method|getStoragePolicies ()
name|BlockStoragePolicy
index|[]
name|getStoragePolicies
parameter_list|()
throws|throws
name|IOException
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|READ
argument_list|)
expr_stmt|;
name|waitForLoadingFSImage
argument_list|()
expr_stmt|;
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|READ
argument_list|)
expr_stmt|;
return|return
name|FSDirAttrOp
operator|.
name|getStoragePolicies
argument_list|(
name|blockManager
argument_list|)
return|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|getPreferredBlockSize (String src)
name|long
name|getPreferredBlockSize
parameter_list|(
name|String
name|src
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|READ
argument_list|)
expr_stmt|;
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|READ
argument_list|)
expr_stmt|;
return|return
name|FSDirAttrOp
operator|.
name|getPreferredBlockSize
argument_list|(
name|dir
argument_list|,
name|src
argument_list|)
return|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * If the file is within an encryption zone, select the appropriate     * CryptoProtocolVersion from the list provided by the client. Since the    * client may be newer, we need to handle unknown versions.    *    * @param zone EncryptionZone of the file    * @param supportedVersions List of supported protocol versions    * @return chosen protocol version    * @throws IOException    */
DECL|method|chooseProtocolVersion (EncryptionZone zone, CryptoProtocolVersion[] supportedVersions)
specifier|private
name|CryptoProtocolVersion
name|chooseProtocolVersion
parameter_list|(
name|EncryptionZone
name|zone
parameter_list|,
name|CryptoProtocolVersion
index|[]
name|supportedVersions
parameter_list|)
throws|throws
name|UnknownCryptoProtocolVersionException
throws|,
name|UnresolvedLinkException
throws|,
name|SnapshotAccessControlException
block|{
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|supportedVersions
argument_list|)
expr_stmt|;
comment|// Right now, we only support a single protocol version,
comment|// so simply look for it in the list of provided options
specifier|final
name|CryptoProtocolVersion
name|required
init|=
name|zone
operator|.
name|getVersion
argument_list|()
decl_stmt|;
for|for
control|(
name|CryptoProtocolVersion
name|c
range|:
name|supportedVersions
control|)
block|{
if|if
condition|(
name|c
operator|.
name|equals
argument_list|(
name|CryptoProtocolVersion
operator|.
name|UNKNOWN
argument_list|)
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Ignoring unknown CryptoProtocolVersion provided by "
operator|+
literal|"client: "
operator|+
name|c
operator|.
name|getUnknownValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
if|if
condition|(
name|c
operator|.
name|equals
argument_list|(
name|required
argument_list|)
condition|)
block|{
return|return
name|c
return|;
block|}
block|}
throw|throw
operator|new
name|UnknownCryptoProtocolVersionException
argument_list|(
literal|"No crypto protocol versions provided by the client are supported."
operator|+
literal|" Client provided: "
operator|+
name|Arrays
operator|.
name|toString
argument_list|(
name|supportedVersions
argument_list|)
operator|+
literal|" NameNode supports: "
operator|+
name|Arrays
operator|.
name|toString
argument_list|(
name|CryptoProtocolVersion
operator|.
name|values
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
comment|/**    * Invoke KeyProvider APIs to generate an encrypted data encryption key for an    * encryption zone. Should not be called with any locks held.    *    * @param ezKeyName key name of an encryption zone    * @return New EDEK, or null if ezKeyName is null    * @throws IOException    */
DECL|method|generateEncryptedDataEncryptionKey (String ezKeyName)
specifier|private
name|EncryptedKeyVersion
name|generateEncryptedDataEncryptionKey
parameter_list|(
name|String
name|ezKeyName
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|ezKeyName
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|EncryptedKeyVersion
name|edek
init|=
literal|null
decl_stmt|;
try|try
block|{
name|edek
operator|=
name|provider
operator|.
name|generateEncryptedKey
argument_list|(
name|ezKeyName
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|GeneralSecurityException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|e
argument_list|)
throw|;
block|}
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|edek
argument_list|)
expr_stmt|;
return|return
name|edek
return|;
block|}
comment|/**    * Create a new file entry in the namespace.    *     * For description of parameters and exceptions thrown see    * {@link ClientProtocol#create}, except it returns valid file status upon    * success    */
DECL|method|startFile (String src, PermissionStatus permissions, String holder, String clientMachine, EnumSet<CreateFlag> flag, boolean createParent, short replication, long blockSize, CryptoProtocolVersion[] supportedVersions, boolean logRetryCache)
name|HdfsFileStatus
name|startFile
parameter_list|(
name|String
name|src
parameter_list|,
name|PermissionStatus
name|permissions
parameter_list|,
name|String
name|holder
parameter_list|,
name|String
name|clientMachine
parameter_list|,
name|EnumSet
argument_list|<
name|CreateFlag
argument_list|>
name|flag
parameter_list|,
name|boolean
name|createParent
parameter_list|,
name|short
name|replication
parameter_list|,
name|long
name|blockSize
parameter_list|,
name|CryptoProtocolVersion
index|[]
name|supportedVersions
parameter_list|,
name|boolean
name|logRetryCache
parameter_list|)
throws|throws
name|AccessControlException
throws|,
name|SafeModeException
throws|,
name|FileAlreadyExistsException
throws|,
name|UnresolvedLinkException
throws|,
name|FileNotFoundException
throws|,
name|ParentNotDirectoryException
throws|,
name|IOException
block|{
name|HdfsFileStatus
name|status
init|=
literal|null
decl_stmt|;
try|try
block|{
name|status
operator|=
name|startFileInt
argument_list|(
name|src
argument_list|,
name|permissions
argument_list|,
name|holder
argument_list|,
name|clientMachine
argument_list|,
name|flag
argument_list|,
name|createParent
argument_list|,
name|replication
argument_list|,
name|blockSize
argument_list|,
name|supportedVersions
argument_list|,
name|logRetryCache
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|AccessControlException
name|e
parameter_list|)
block|{
name|logAuditEvent
argument_list|(
literal|false
argument_list|,
literal|"create"
argument_list|,
name|src
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
return|return
name|status
return|;
block|}
DECL|method|startFileInt (final String srcArg, PermissionStatus permissions, String holder, String clientMachine, EnumSet<CreateFlag> flag, boolean createParent, short replication, long blockSize, CryptoProtocolVersion[] supportedVersions, boolean logRetryCache)
specifier|private
name|HdfsFileStatus
name|startFileInt
parameter_list|(
specifier|final
name|String
name|srcArg
parameter_list|,
name|PermissionStatus
name|permissions
parameter_list|,
name|String
name|holder
parameter_list|,
name|String
name|clientMachine
parameter_list|,
name|EnumSet
argument_list|<
name|CreateFlag
argument_list|>
name|flag
parameter_list|,
name|boolean
name|createParent
parameter_list|,
name|short
name|replication
parameter_list|,
name|long
name|blockSize
parameter_list|,
name|CryptoProtocolVersion
index|[]
name|supportedVersions
parameter_list|,
name|boolean
name|logRetryCache
parameter_list|)
throws|throws
name|AccessControlException
throws|,
name|SafeModeException
throws|,
name|FileAlreadyExistsException
throws|,
name|UnresolvedLinkException
throws|,
name|FileNotFoundException
throws|,
name|ParentNotDirectoryException
throws|,
name|IOException
block|{
name|String
name|src
init|=
name|srcArg
decl_stmt|;
if|if
condition|(
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|StringBuilder
name|builder
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|builder
operator|.
name|append
argument_list|(
literal|"DIR* NameSystem.startFile: src="
operator|+
name|src
operator|+
literal|", holder="
operator|+
name|holder
operator|+
literal|", clientMachine="
operator|+
name|clientMachine
operator|+
literal|", createParent="
operator|+
name|createParent
operator|+
literal|", replication="
operator|+
name|replication
operator|+
literal|", createFlag="
operator|+
name|flag
operator|.
name|toString
argument_list|()
operator|+
literal|", blockSize="
operator|+
name|blockSize
argument_list|)
expr_stmt|;
name|builder
operator|.
name|append
argument_list|(
literal|", supportedVersions="
argument_list|)
expr_stmt|;
if|if
condition|(
name|supportedVersions
operator|!=
literal|null
condition|)
block|{
name|builder
operator|.
name|append
argument_list|(
name|Arrays
operator|.
name|toString
argument_list|(
name|supportedVersions
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|builder
operator|.
name|append
argument_list|(
literal|"null"
argument_list|)
expr_stmt|;
block|}
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|debug
argument_list|(
name|builder
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|DFSUtil
operator|.
name|isValidName
argument_list|(
name|src
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|InvalidPathException
argument_list|(
name|src
argument_list|)
throw|;
block|}
name|blockManager
operator|.
name|verifyReplication
argument_list|(
name|src
argument_list|,
name|replication
argument_list|,
name|clientMachine
argument_list|)
expr_stmt|;
name|boolean
name|skipSync
init|=
literal|false
decl_stmt|;
name|HdfsFileStatus
name|stat
init|=
literal|null
decl_stmt|;
name|FSPermissionChecker
name|pc
init|=
name|getPermissionChecker
argument_list|()
decl_stmt|;
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|blockSize
operator|<
name|minBlockSize
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Specified block size is less than configured"
operator|+
literal|" minimum value ("
operator|+
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_MIN_BLOCK_SIZE_KEY
operator|+
literal|"): "
operator|+
name|blockSize
operator|+
literal|"< "
operator|+
name|minBlockSize
argument_list|)
throw|;
block|}
name|byte
index|[]
index|[]
name|pathComponents
init|=
name|FSDirectory
operator|.
name|getPathComponentsForReservedPath
argument_list|(
name|src
argument_list|)
decl_stmt|;
name|boolean
name|create
init|=
name|flag
operator|.
name|contains
argument_list|(
name|CreateFlag
operator|.
name|CREATE
argument_list|)
decl_stmt|;
name|boolean
name|overwrite
init|=
name|flag
operator|.
name|contains
argument_list|(
name|CreateFlag
operator|.
name|OVERWRITE
argument_list|)
decl_stmt|;
name|boolean
name|isLazyPersist
init|=
name|flag
operator|.
name|contains
argument_list|(
name|CreateFlag
operator|.
name|LAZY_PERSIST
argument_list|)
decl_stmt|;
name|waitForLoadingFSImage
argument_list|()
expr_stmt|;
comment|/**      * If the file is in an encryption zone, we optimistically create an      * EDEK for the file by calling out to the configured KeyProvider.      * Since this typically involves doing an RPC, we take the readLock      * initially, then drop it to do the RPC.      *       * Since the path can flip-flop between being in an encryption zone and not      * in the meantime, we need to recheck the preconditions when we retake the      * lock to do the create. If the preconditions are not met, we throw a      * special RetryStartFileException to ask the DFSClient to try the create      * again later.      */
name|CryptoProtocolVersion
name|protocolVersion
init|=
literal|null
decl_stmt|;
name|CipherSuite
name|suite
init|=
literal|null
decl_stmt|;
name|String
name|ezKeyName
init|=
literal|null
decl_stmt|;
name|EncryptedKeyVersion
name|edek
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|provider
operator|!=
literal|null
condition|)
block|{
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
name|src
operator|=
name|dir
operator|.
name|resolvePath
argument_list|(
name|pc
argument_list|,
name|src
argument_list|,
name|pathComponents
argument_list|)
expr_stmt|;
name|INodesInPath
name|iip
init|=
name|dir
operator|.
name|getINodesInPath4Write
argument_list|(
name|src
argument_list|)
decl_stmt|;
comment|// Nothing to do if the path is not within an EZ
specifier|final
name|EncryptionZone
name|zone
init|=
name|dir
operator|.
name|getEZForPath
argument_list|(
name|iip
argument_list|)
decl_stmt|;
if|if
condition|(
name|zone
operator|!=
literal|null
condition|)
block|{
name|protocolVersion
operator|=
name|chooseProtocolVersion
argument_list|(
name|zone
argument_list|,
name|supportedVersions
argument_list|)
expr_stmt|;
name|suite
operator|=
name|zone
operator|.
name|getSuite
argument_list|()
expr_stmt|;
name|ezKeyName
operator|=
name|zone
operator|.
name|getKeyName
argument_list|()
expr_stmt|;
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|protocolVersion
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|suite
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkArgument
argument_list|(
operator|!
name|suite
operator|.
name|equals
argument_list|(
name|CipherSuite
operator|.
name|UNKNOWN
argument_list|)
argument_list|,
literal|"Chose an UNKNOWN CipherSuite!"
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|ezKeyName
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
name|Preconditions
operator|.
name|checkState
argument_list|(
operator|(
name|suite
operator|==
literal|null
operator|&&
name|ezKeyName
operator|==
literal|null
operator|)
operator|||
operator|(
name|suite
operator|!=
literal|null
operator|&&
name|ezKeyName
operator|!=
literal|null
operator|)
argument_list|,
literal|"Both suite and ezKeyName should both be null or not null"
argument_list|)
expr_stmt|;
comment|// Generate EDEK if necessary while not holding the lock
name|edek
operator|=
name|generateEncryptedDataEncryptionKey
argument_list|(
name|ezKeyName
argument_list|)
expr_stmt|;
name|EncryptionFaultInjector
operator|.
name|getInstance
argument_list|()
operator|.
name|startFileAfterGenerateKey
argument_list|()
expr_stmt|;
block|}
comment|// Proceed with the create, using the computed cipher suite and
comment|// generated EDEK
name|BlocksMapUpdateInfo
name|toRemoveBlocks
init|=
literal|null
decl_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|checkNameNodeSafeMode
argument_list|(
literal|"Cannot create file"
operator|+
name|src
argument_list|)
expr_stmt|;
name|dir
operator|.
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|src
operator|=
name|dir
operator|.
name|resolvePath
argument_list|(
name|pc
argument_list|,
name|src
argument_list|,
name|pathComponents
argument_list|)
expr_stmt|;
specifier|final
name|INodesInPath
name|iip
init|=
name|dir
operator|.
name|getINodesInPath4Write
argument_list|(
name|src
argument_list|)
decl_stmt|;
name|toRemoveBlocks
operator|=
name|startFileInternal
argument_list|(
name|pc
argument_list|,
name|iip
argument_list|,
name|permissions
argument_list|,
name|holder
argument_list|,
name|clientMachine
argument_list|,
name|create
argument_list|,
name|overwrite
argument_list|,
name|createParent
argument_list|,
name|replication
argument_list|,
name|blockSize
argument_list|,
name|isLazyPersist
argument_list|,
name|suite
argument_list|,
name|protocolVersion
argument_list|,
name|edek
argument_list|,
name|logRetryCache
argument_list|)
expr_stmt|;
name|stat
operator|=
name|FSDirStatAndListingOp
operator|.
name|getFileInfo
argument_list|(
name|dir
argument_list|,
name|src
argument_list|,
literal|false
argument_list|,
name|FSDirectory
operator|.
name|isReservedRawName
argument_list|(
name|srcArg
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|dir
operator|.
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|StandbyException
name|se
parameter_list|)
block|{
name|skipSync
operator|=
literal|true
expr_stmt|;
throw|throw
name|se
throw|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
comment|// There might be transactions logged while trying to recover the lease.
comment|// They need to be sync'ed even when an exception was thrown.
if|if
condition|(
operator|!
name|skipSync
condition|)
block|{
name|getEditLog
argument_list|()
operator|.
name|logSync
argument_list|()
expr_stmt|;
if|if
condition|(
name|toRemoveBlocks
operator|!=
literal|null
condition|)
block|{
name|removeBlocks
argument_list|(
name|toRemoveBlocks
argument_list|)
expr_stmt|;
name|toRemoveBlocks
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
block|}
name|logAuditEvent
argument_list|(
literal|true
argument_list|,
literal|"create"
argument_list|,
name|srcArg
argument_list|,
literal|null
argument_list|,
name|stat
argument_list|)
expr_stmt|;
return|return
name|stat
return|;
block|}
comment|/**    * Create a new file or overwrite an existing file<br>    *     * Once the file is create the client then allocates a new block with the next    * call using {@link ClientProtocol#addBlock}.    *<p>    * For description of parameters and exceptions thrown see    * {@link ClientProtocol#create}    */
DECL|method|startFileInternal (FSPermissionChecker pc, INodesInPath iip, PermissionStatus permissions, String holder, String clientMachine, boolean create, boolean overwrite, boolean createParent, short replication, long blockSize, boolean isLazyPersist, CipherSuite suite, CryptoProtocolVersion version, EncryptedKeyVersion edek, boolean logRetryEntry)
specifier|private
name|BlocksMapUpdateInfo
name|startFileInternal
parameter_list|(
name|FSPermissionChecker
name|pc
parameter_list|,
name|INodesInPath
name|iip
parameter_list|,
name|PermissionStatus
name|permissions
parameter_list|,
name|String
name|holder
parameter_list|,
name|String
name|clientMachine
parameter_list|,
name|boolean
name|create
parameter_list|,
name|boolean
name|overwrite
parameter_list|,
name|boolean
name|createParent
parameter_list|,
name|short
name|replication
parameter_list|,
name|long
name|blockSize
parameter_list|,
name|boolean
name|isLazyPersist
parameter_list|,
name|CipherSuite
name|suite
parameter_list|,
name|CryptoProtocolVersion
name|version
parameter_list|,
name|EncryptedKeyVersion
name|edek
parameter_list|,
name|boolean
name|logRetryEntry
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|hasWriteLock
argument_list|()
assert|;
comment|// Verify that the destination does not exist as a directory already.
specifier|final
name|INode
name|inode
init|=
name|iip
operator|.
name|getLastINode
argument_list|()
decl_stmt|;
specifier|final
name|String
name|src
init|=
name|iip
operator|.
name|getPath
argument_list|()
decl_stmt|;
if|if
condition|(
name|inode
operator|!=
literal|null
operator|&&
name|inode
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|FileAlreadyExistsException
argument_list|(
name|src
operator|+
literal|" already exists as a directory"
argument_list|)
throw|;
block|}
specifier|final
name|INodeFile
name|myFile
init|=
name|INodeFile
operator|.
name|valueOf
argument_list|(
name|inode
argument_list|,
name|src
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|isPermissionEnabled
condition|)
block|{
if|if
condition|(
name|overwrite
operator|&&
name|myFile
operator|!=
literal|null
condition|)
block|{
name|dir
operator|.
name|checkPathAccess
argument_list|(
name|pc
argument_list|,
name|iip
argument_list|,
name|FsAction
operator|.
name|WRITE
argument_list|)
expr_stmt|;
block|}
comment|/*        * To overwrite existing file, need to check 'w' permission         * of parent (equals to ancestor in this case)        */
name|dir
operator|.
name|checkAncestorAccess
argument_list|(
name|pc
argument_list|,
name|iip
argument_list|,
name|FsAction
operator|.
name|WRITE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|createParent
condition|)
block|{
name|dir
operator|.
name|verifyParentDir
argument_list|(
name|iip
argument_list|,
name|src
argument_list|)
expr_stmt|;
block|}
name|FileEncryptionInfo
name|feInfo
init|=
literal|null
decl_stmt|;
specifier|final
name|EncryptionZone
name|zone
init|=
name|dir
operator|.
name|getEZForPath
argument_list|(
name|iip
argument_list|)
decl_stmt|;
if|if
condition|(
name|zone
operator|!=
literal|null
condition|)
block|{
comment|// The path is now within an EZ, but we're missing encryption parameters
if|if
condition|(
name|suite
operator|==
literal|null
operator|||
name|edek
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|RetryStartFileException
argument_list|()
throw|;
block|}
comment|// Path is within an EZ and we have provided encryption parameters.
comment|// Make sure that the generated EDEK matches the settings of the EZ.
specifier|final
name|String
name|ezKeyName
init|=
name|zone
operator|.
name|getKeyName
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|ezKeyName
operator|.
name|equals
argument_list|(
name|edek
operator|.
name|getEncryptionKeyName
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|RetryStartFileException
argument_list|()
throw|;
block|}
name|feInfo
operator|=
operator|new
name|FileEncryptionInfo
argument_list|(
name|suite
argument_list|,
name|version
argument_list|,
name|edek
operator|.
name|getEncryptedKeyVersion
argument_list|()
operator|.
name|getMaterial
argument_list|()
argument_list|,
name|edek
operator|.
name|getEncryptedKeyIv
argument_list|()
argument_list|,
name|ezKeyName
argument_list|,
name|edek
operator|.
name|getEncryptionKeyVersionName
argument_list|()
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|BlocksMapUpdateInfo
name|toRemoveBlocks
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|myFile
operator|==
literal|null
condition|)
block|{
if|if
condition|(
operator|!
name|create
condition|)
block|{
throw|throw
operator|new
name|FileNotFoundException
argument_list|(
literal|"Can't overwrite non-existent "
operator|+
name|src
operator|+
literal|" for client "
operator|+
name|clientMachine
argument_list|)
throw|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|overwrite
condition|)
block|{
name|toRemoveBlocks
operator|=
operator|new
name|BlocksMapUpdateInfo
argument_list|()
expr_stmt|;
name|List
argument_list|<
name|INode
argument_list|>
name|toRemoveINodes
init|=
operator|new
name|ChunkedArrayList
argument_list|<
name|INode
argument_list|>
argument_list|()
decl_stmt|;
name|long
name|ret
init|=
name|FSDirDeleteOp
operator|.
name|delete
argument_list|(
name|dir
argument_list|,
name|iip
argument_list|,
name|toRemoveBlocks
argument_list|,
name|toRemoveINodes
argument_list|,
name|now
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
operator|>=
literal|0
condition|)
block|{
name|iip
operator|=
name|INodesInPath
operator|.
name|replace
argument_list|(
name|iip
argument_list|,
name|iip
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|FSDirDeleteOp
operator|.
name|incrDeletedFileCount
argument_list|(
name|ret
argument_list|)
expr_stmt|;
name|removeLeasesAndINodes
argument_list|(
name|src
argument_list|,
name|toRemoveINodes
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// If lease soft limit time is expired, recover the lease
name|recoverLeaseInternal
argument_list|(
name|RecoverLeaseOp
operator|.
name|CREATE_FILE
argument_list|,
name|iip
argument_list|,
name|src
argument_list|,
name|holder
argument_list|,
name|clientMachine
argument_list|,
literal|false
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|FileAlreadyExistsException
argument_list|(
name|src
operator|+
literal|" for client "
operator|+
name|clientMachine
operator|+
literal|" already exists"
argument_list|)
throw|;
block|}
block|}
name|checkFsObjectLimit
argument_list|()
expr_stmt|;
name|INodeFile
name|newNode
init|=
literal|null
decl_stmt|;
comment|// Always do an implicit mkdirs for parent directory tree.
name|Map
operator|.
name|Entry
argument_list|<
name|INodesInPath
argument_list|,
name|String
argument_list|>
name|parent
init|=
name|FSDirMkdirOp
operator|.
name|createAncestorDirectories
argument_list|(
name|dir
argument_list|,
name|iip
argument_list|,
name|permissions
argument_list|)
decl_stmt|;
if|if
condition|(
name|parent
operator|!=
literal|null
condition|)
block|{
name|iip
operator|=
name|dir
operator|.
name|addFile
argument_list|(
name|parent
operator|.
name|getKey
argument_list|()
argument_list|,
name|parent
operator|.
name|getValue
argument_list|()
argument_list|,
name|permissions
argument_list|,
name|replication
argument_list|,
name|blockSize
argument_list|,
name|holder
argument_list|,
name|clientMachine
argument_list|)
expr_stmt|;
name|newNode
operator|=
name|iip
operator|!=
literal|null
condition|?
name|iip
operator|.
name|getLastINode
argument_list|()
operator|.
name|asFile
argument_list|()
else|:
literal|null
expr_stmt|;
block|}
if|if
condition|(
name|newNode
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unable to add "
operator|+
name|src
operator|+
literal|" to namespace"
argument_list|)
throw|;
block|}
name|leaseManager
operator|.
name|addLease
argument_list|(
name|newNode
operator|.
name|getFileUnderConstructionFeature
argument_list|()
operator|.
name|getClientName
argument_list|()
argument_list|,
name|src
argument_list|)
expr_stmt|;
comment|// Set encryption attributes if necessary
if|if
condition|(
name|feInfo
operator|!=
literal|null
condition|)
block|{
name|dir
operator|.
name|setFileEncryptionInfo
argument_list|(
name|src
argument_list|,
name|feInfo
argument_list|)
expr_stmt|;
name|newNode
operator|=
name|dir
operator|.
name|getInode
argument_list|(
name|newNode
operator|.
name|getId
argument_list|()
argument_list|)
operator|.
name|asFile
argument_list|()
expr_stmt|;
block|}
name|setNewINodeStoragePolicy
argument_list|(
name|newNode
argument_list|,
name|iip
argument_list|,
name|isLazyPersist
argument_list|)
expr_stmt|;
comment|// record file record in log, record new generation stamp
name|getEditLog
argument_list|()
operator|.
name|logOpenFile
argument_list|(
name|src
argument_list|,
name|newNode
argument_list|,
name|overwrite
argument_list|,
name|logRetryEntry
argument_list|)
expr_stmt|;
if|if
condition|(
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|debug
argument_list|(
literal|"DIR* NameSystem.startFile: added "
operator|+
name|src
operator|+
literal|" inode "
operator|+
name|newNode
operator|.
name|getId
argument_list|()
operator|+
literal|" "
operator|+
name|holder
argument_list|)
expr_stmt|;
block|}
return|return
name|toRemoveBlocks
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ie
parameter_list|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|warn
argument_list|(
literal|"DIR* NameSystem.startFile: "
operator|+
name|src
operator|+
literal|" "
operator|+
name|ie
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
name|ie
throw|;
block|}
block|}
DECL|method|setNewINodeStoragePolicy (INodeFile inode, INodesInPath iip, boolean isLazyPersist)
specifier|private
name|void
name|setNewINodeStoragePolicy
parameter_list|(
name|INodeFile
name|inode
parameter_list|,
name|INodesInPath
name|iip
parameter_list|,
name|boolean
name|isLazyPersist
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|isLazyPersist
condition|)
block|{
name|BlockStoragePolicy
name|lpPolicy
init|=
name|blockManager
operator|.
name|getStoragePolicy
argument_list|(
literal|"LAZY_PERSIST"
argument_list|)
decl_stmt|;
comment|// Set LAZY_PERSIST storage policy if the flag was passed to
comment|// CreateFile.
if|if
condition|(
name|lpPolicy
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|HadoopIllegalArgumentException
argument_list|(
literal|"The LAZY_PERSIST storage policy has been disabled "
operator|+
literal|"by the administrator."
argument_list|)
throw|;
block|}
name|inode
operator|.
name|setStoragePolicyID
argument_list|(
name|lpPolicy
operator|.
name|getId
argument_list|()
argument_list|,
name|iip
operator|.
name|getLatestSnapshotId
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|BlockStoragePolicy
name|effectivePolicy
init|=
name|blockManager
operator|.
name|getStoragePolicy
argument_list|(
name|inode
operator|.
name|getStoragePolicyID
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|effectivePolicy
operator|!=
literal|null
operator|&&
name|effectivePolicy
operator|.
name|isCopyOnCreateFile
argument_list|()
condition|)
block|{
comment|// Copy effective policy from ancestor directory to current file.
name|inode
operator|.
name|setStoragePolicyID
argument_list|(
name|effectivePolicy
operator|.
name|getId
argument_list|()
argument_list|,
name|iip
operator|.
name|getLatestSnapshotId
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Append to an existing file for append.    *<p>    *     * The method returns the last block of the file if this is a partial block,    * which can still be used for writing more data. The client uses the returned    * block locations to form the data pipeline for this block.<br>    * The method returns null if the last block is full. The client then    * allocates a new block with the next call using    * {@link ClientProtocol#addBlock}.    *<p>    *     * For description of parameters and exceptions thrown see    * {@link ClientProtocol#append(String, String, EnumSetWritable)}    *    * @return the last block locations if the block is partial or null otherwise    */
DECL|method|appendFileInternal (FSPermissionChecker pc, INodesInPath iip, String holder, String clientMachine, boolean newBlock, boolean logRetryCache)
specifier|private
name|LocatedBlock
name|appendFileInternal
parameter_list|(
name|FSPermissionChecker
name|pc
parameter_list|,
name|INodesInPath
name|iip
parameter_list|,
name|String
name|holder
parameter_list|,
name|String
name|clientMachine
parameter_list|,
name|boolean
name|newBlock
parameter_list|,
name|boolean
name|logRetryCache
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|hasWriteLock
argument_list|()
assert|;
comment|// Verify that the destination does not exist as a directory already.
specifier|final
name|INode
name|inode
init|=
name|iip
operator|.
name|getLastINode
argument_list|()
decl_stmt|;
specifier|final
name|String
name|src
init|=
name|iip
operator|.
name|getPath
argument_list|()
decl_stmt|;
if|if
condition|(
name|inode
operator|!=
literal|null
operator|&&
name|inode
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|FileAlreadyExistsException
argument_list|(
literal|"Cannot append to directory "
operator|+
name|src
operator|+
literal|"; already exists as a directory."
argument_list|)
throw|;
block|}
if|if
condition|(
name|isPermissionEnabled
condition|)
block|{
name|dir
operator|.
name|checkPathAccess
argument_list|(
name|pc
argument_list|,
name|iip
argument_list|,
name|FsAction
operator|.
name|WRITE
argument_list|)
expr_stmt|;
block|}
try|try
block|{
if|if
condition|(
name|inode
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|FileNotFoundException
argument_list|(
literal|"failed to append to non-existent file "
operator|+
name|src
operator|+
literal|" for client "
operator|+
name|clientMachine
argument_list|)
throw|;
block|}
name|INodeFile
name|myFile
init|=
name|INodeFile
operator|.
name|valueOf
argument_list|(
name|inode
argument_list|,
name|src
argument_list|,
literal|true
argument_list|)
decl_stmt|;
specifier|final
name|BlockStoragePolicy
name|lpPolicy
init|=
name|blockManager
operator|.
name|getStoragePolicy
argument_list|(
literal|"LAZY_PERSIST"
argument_list|)
decl_stmt|;
if|if
condition|(
name|lpPolicy
operator|!=
literal|null
operator|&&
name|lpPolicy
operator|.
name|getId
argument_list|()
operator|==
name|myFile
operator|.
name|getStoragePolicyID
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"Cannot append to lazy persist file "
operator|+
name|src
argument_list|)
throw|;
block|}
comment|// Opening an existing file for append - may need to recover lease.
name|recoverLeaseInternal
argument_list|(
name|RecoverLeaseOp
operator|.
name|APPEND_FILE
argument_list|,
name|iip
argument_list|,
name|src
argument_list|,
name|holder
argument_list|,
name|clientMachine
argument_list|,
literal|false
argument_list|)
expr_stmt|;
specifier|final
name|BlockInfoContiguous
name|lastBlock
init|=
name|myFile
operator|.
name|getLastBlock
argument_list|()
decl_stmt|;
comment|// Check that the block has at least minimum replication.
if|if
condition|(
name|lastBlock
operator|!=
literal|null
operator|&&
name|lastBlock
operator|.
name|isComplete
argument_list|()
operator|&&
operator|!
name|getBlockManager
argument_list|()
operator|.
name|isSufficientlyReplicated
argument_list|(
name|lastBlock
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"append: lastBlock="
operator|+
name|lastBlock
operator|+
literal|" of src="
operator|+
name|src
operator|+
literal|" is not sufficiently replicated yet."
argument_list|)
throw|;
block|}
return|return
name|prepareFileForAppend
argument_list|(
name|src
argument_list|,
name|iip
argument_list|,
name|holder
argument_list|,
name|clientMachine
argument_list|,
name|newBlock
argument_list|,
literal|true
argument_list|,
name|logRetryCache
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ie
parameter_list|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|warn
argument_list|(
literal|"DIR* NameSystem.append: "
operator|+
name|ie
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
name|ie
throw|;
block|}
block|}
comment|/**    * Convert current node to under construction.    * Recreate in-memory lease record.    *     * @param src path to the file    * @param leaseHolder identifier of the lease holder on this file    * @param clientMachine identifier of the client machine    * @param newBlock if the data is appended to a new block    * @param writeToEditLog whether to persist this change to the edit log    * @param logRetryCache whether to record RPC ids in editlog for retry cache    *                      rebuilding    * @return the last block locations if the block is partial or null otherwise    * @throws UnresolvedLinkException    * @throws IOException    */
DECL|method|prepareFileForAppend (String src, INodesInPath iip, String leaseHolder, String clientMachine, boolean newBlock, boolean writeToEditLog, boolean logRetryCache)
name|LocatedBlock
name|prepareFileForAppend
parameter_list|(
name|String
name|src
parameter_list|,
name|INodesInPath
name|iip
parameter_list|,
name|String
name|leaseHolder
parameter_list|,
name|String
name|clientMachine
parameter_list|,
name|boolean
name|newBlock
parameter_list|,
name|boolean
name|writeToEditLog
parameter_list|,
name|boolean
name|logRetryCache
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|INodeFile
name|file
init|=
name|iip
operator|.
name|getLastINode
argument_list|()
operator|.
name|asFile
argument_list|()
decl_stmt|;
specifier|final
name|QuotaCounts
name|delta
init|=
name|verifyQuotaForUCBlock
argument_list|(
name|file
argument_list|,
name|iip
argument_list|)
decl_stmt|;
name|file
operator|.
name|recordModification
argument_list|(
name|iip
operator|.
name|getLatestSnapshotId
argument_list|()
argument_list|)
expr_stmt|;
name|file
operator|.
name|toUnderConstruction
argument_list|(
name|leaseHolder
argument_list|,
name|clientMachine
argument_list|)
expr_stmt|;
name|leaseManager
operator|.
name|addLease
argument_list|(
name|file
operator|.
name|getFileUnderConstructionFeature
argument_list|()
operator|.
name|getClientName
argument_list|()
argument_list|,
name|src
argument_list|)
expr_stmt|;
name|LocatedBlock
name|ret
init|=
literal|null
decl_stmt|;
if|if
condition|(
operator|!
name|newBlock
condition|)
block|{
name|ret
operator|=
name|blockManager
operator|.
name|convertLastBlockToUnderConstruction
argument_list|(
name|file
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|null
operator|&&
name|delta
operator|!=
literal|null
condition|)
block|{
name|Preconditions
operator|.
name|checkState
argument_list|(
name|delta
operator|.
name|getStorageSpace
argument_list|()
operator|>=
literal|0
argument_list|,
literal|"appending to a block with size larger than the preferred block size"
argument_list|)
expr_stmt|;
name|dir
operator|.
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|dir
operator|.
name|updateCountNoQuotaCheck
argument_list|(
name|iip
argument_list|,
name|iip
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|,
name|delta
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|dir
operator|.
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|BlockInfoContiguous
name|lastBlock
init|=
name|file
operator|.
name|getLastBlock
argument_list|()
decl_stmt|;
if|if
condition|(
name|lastBlock
operator|!=
literal|null
condition|)
block|{
name|ExtendedBlock
name|blk
init|=
operator|new
name|ExtendedBlock
argument_list|(
name|this
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|lastBlock
argument_list|)
decl_stmt|;
name|ret
operator|=
operator|new
name|LocatedBlock
argument_list|(
name|blk
argument_list|,
operator|new
name|DatanodeInfo
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|writeToEditLog
condition|)
block|{
name|getEditLog
argument_list|()
operator|.
name|logAppendFile
argument_list|(
name|src
argument_list|,
name|file
argument_list|,
name|newBlock
argument_list|,
name|logRetryCache
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
comment|/**    * Verify quota when using the preferred block size for UC block. This is    * usually used by append and truncate    * @throws QuotaExceededException when violating the storage quota    * @return expected quota usage update. null means no change or no need to    *         update quota usage later    */
DECL|method|verifyQuotaForUCBlock (INodeFile file, INodesInPath iip)
specifier|private
name|QuotaCounts
name|verifyQuotaForUCBlock
parameter_list|(
name|INodeFile
name|file
parameter_list|,
name|INodesInPath
name|iip
parameter_list|)
throws|throws
name|QuotaExceededException
block|{
if|if
condition|(
operator|!
name|isImageLoaded
argument_list|()
operator|||
name|dir
operator|.
name|shouldSkipQuotaChecks
argument_list|()
condition|)
block|{
comment|// Do not check quota if editlog is still being processed
return|return
literal|null
return|;
block|}
if|if
condition|(
name|file
operator|.
name|getLastBlock
argument_list|()
operator|!=
literal|null
condition|)
block|{
specifier|final
name|QuotaCounts
name|delta
init|=
name|computeQuotaDeltaForUCBlock
argument_list|(
name|file
argument_list|)
decl_stmt|;
name|dir
operator|.
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
name|FSDirectory
operator|.
name|verifyQuota
argument_list|(
name|iip
argument_list|,
name|iip
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|,
name|delta
argument_list|,
literal|null
argument_list|)
expr_stmt|;
return|return
name|delta
return|;
block|}
finally|finally
block|{
name|dir
operator|.
name|readUnlock
argument_list|()
expr_stmt|;
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/** Compute quota change for converting a complete block to a UC block */
DECL|method|computeQuotaDeltaForUCBlock (INodeFile file)
specifier|private
name|QuotaCounts
name|computeQuotaDeltaForUCBlock
parameter_list|(
name|INodeFile
name|file
parameter_list|)
block|{
specifier|final
name|QuotaCounts
name|delta
init|=
operator|new
name|QuotaCounts
operator|.
name|Builder
argument_list|()
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|BlockInfoContiguous
name|lastBlock
init|=
name|file
operator|.
name|getLastBlock
argument_list|()
decl_stmt|;
if|if
condition|(
name|lastBlock
operator|!=
literal|null
condition|)
block|{
specifier|final
name|long
name|diff
init|=
name|file
operator|.
name|getPreferredBlockSize
argument_list|()
operator|-
name|lastBlock
operator|.
name|getNumBytes
argument_list|()
decl_stmt|;
specifier|final
name|short
name|repl
init|=
name|file
operator|.
name|getBlockReplication
argument_list|()
decl_stmt|;
name|delta
operator|.
name|addStorageSpace
argument_list|(
name|diff
operator|*
name|repl
argument_list|)
expr_stmt|;
specifier|final
name|BlockStoragePolicy
name|policy
init|=
name|dir
operator|.
name|getBlockStoragePolicySuite
argument_list|()
operator|.
name|getPolicy
argument_list|(
name|file
operator|.
name|getStoragePolicyID
argument_list|()
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|StorageType
argument_list|>
name|types
init|=
name|policy
operator|.
name|chooseStorageTypes
argument_list|(
name|repl
argument_list|)
decl_stmt|;
for|for
control|(
name|StorageType
name|t
range|:
name|types
control|)
block|{
if|if
condition|(
name|t
operator|.
name|supportTypeQuota
argument_list|()
condition|)
block|{
name|delta
operator|.
name|addTypeSpace
argument_list|(
name|t
argument_list|,
name|diff
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|delta
return|;
block|}
comment|/**    * Recover lease;    * Immediately revoke the lease of the current lease holder and start lease    * recovery so that the file can be forced to be closed.    *     * @param src the path of the file to start lease recovery    * @param holder the lease holder's name    * @param clientMachine the client machine's name    * @return true if the file is already closed    * @throws IOException    */
DECL|method|recoverLease (String src, String holder, String clientMachine)
name|boolean
name|recoverLease
parameter_list|(
name|String
name|src
parameter_list|,
name|String
name|holder
parameter_list|,
name|String
name|clientMachine
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|DFSUtil
operator|.
name|isValidName
argument_list|(
name|src
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Invalid file name: "
operator|+
name|src
argument_list|)
throw|;
block|}
name|boolean
name|skipSync
init|=
literal|false
decl_stmt|;
name|FSPermissionChecker
name|pc
init|=
name|getPermissionChecker
argument_list|()
decl_stmt|;
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|byte
index|[]
index|[]
name|pathComponents
init|=
name|FSDirectory
operator|.
name|getPathComponentsForReservedPath
argument_list|(
name|src
argument_list|)
decl_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|checkNameNodeSafeMode
argument_list|(
literal|"Cannot recover the lease of "
operator|+
name|src
argument_list|)
expr_stmt|;
name|src
operator|=
name|dir
operator|.
name|resolvePath
argument_list|(
name|pc
argument_list|,
name|src
argument_list|,
name|pathComponents
argument_list|)
expr_stmt|;
specifier|final
name|INodesInPath
name|iip
init|=
name|dir
operator|.
name|getINodesInPath4Write
argument_list|(
name|src
argument_list|)
decl_stmt|;
specifier|final
name|INodeFile
name|inode
init|=
name|INodeFile
operator|.
name|valueOf
argument_list|(
name|iip
operator|.
name|getLastINode
argument_list|()
argument_list|,
name|src
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|inode
operator|.
name|isUnderConstruction
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
name|isPermissionEnabled
condition|)
block|{
name|dir
operator|.
name|checkPathAccess
argument_list|(
name|pc
argument_list|,
name|iip
argument_list|,
name|FsAction
operator|.
name|WRITE
argument_list|)
expr_stmt|;
block|}
name|recoverLeaseInternal
argument_list|(
name|RecoverLeaseOp
operator|.
name|RECOVER_LEASE
argument_list|,
name|iip
argument_list|,
name|src
argument_list|,
name|holder
argument_list|,
name|clientMachine
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|StandbyException
name|se
parameter_list|)
block|{
name|skipSync
operator|=
literal|true
expr_stmt|;
throw|throw
name|se
throw|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
comment|// There might be transactions logged while trying to recover the lease.
comment|// They need to be sync'ed even when an exception was thrown.
if|if
condition|(
operator|!
name|skipSync
condition|)
block|{
name|getEditLog
argument_list|()
operator|.
name|logSync
argument_list|()
expr_stmt|;
block|}
block|}
return|return
literal|false
return|;
block|}
DECL|enum|RecoverLeaseOp
specifier|private
enum|enum
name|RecoverLeaseOp
block|{
DECL|enumConstant|CREATE_FILE
name|CREATE_FILE
block|,
DECL|enumConstant|APPEND_FILE
name|APPEND_FILE
block|,
DECL|enumConstant|TRUNCATE_FILE
name|TRUNCATE_FILE
block|,
DECL|enumConstant|RECOVER_LEASE
name|RECOVER_LEASE
block|;
DECL|method|getExceptionMessage (String src, String holder, String clientMachine, String reason)
specifier|private
name|String
name|getExceptionMessage
parameter_list|(
name|String
name|src
parameter_list|,
name|String
name|holder
parameter_list|,
name|String
name|clientMachine
parameter_list|,
name|String
name|reason
parameter_list|)
block|{
return|return
literal|"Failed to "
operator|+
name|this
operator|+
literal|" "
operator|+
name|src
operator|+
literal|" for "
operator|+
name|holder
operator|+
literal|" on "
operator|+
name|clientMachine
operator|+
literal|" because "
operator|+
name|reason
return|;
block|}
block|}
DECL|method|recoverLeaseInternal (RecoverLeaseOp op, INodesInPath iip, String src, String holder, String clientMachine, boolean force)
name|void
name|recoverLeaseInternal
parameter_list|(
name|RecoverLeaseOp
name|op
parameter_list|,
name|INodesInPath
name|iip
parameter_list|,
name|String
name|src
parameter_list|,
name|String
name|holder
parameter_list|,
name|String
name|clientMachine
parameter_list|,
name|boolean
name|force
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|hasWriteLock
argument_list|()
assert|;
name|INodeFile
name|file
init|=
name|iip
operator|.
name|getLastINode
argument_list|()
operator|.
name|asFile
argument_list|()
decl_stmt|;
if|if
condition|(
name|file
operator|!=
literal|null
operator|&&
name|file
operator|.
name|isUnderConstruction
argument_list|()
condition|)
block|{
comment|//
comment|// If the file is under construction , then it must be in our
comment|// leases. Find the appropriate lease record.
comment|//
name|Lease
name|lease
init|=
name|leaseManager
operator|.
name|getLease
argument_list|(
name|holder
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|force
operator|&&
name|lease
operator|!=
literal|null
condition|)
block|{
name|Lease
name|leaseFile
init|=
name|leaseManager
operator|.
name|getLeaseByPath
argument_list|(
name|src
argument_list|)
decl_stmt|;
if|if
condition|(
name|leaseFile
operator|!=
literal|null
operator|&&
name|leaseFile
operator|.
name|equals
argument_list|(
name|lease
argument_list|)
condition|)
block|{
comment|// We found the lease for this file but the original
comment|// holder is trying to obtain it again.
throw|throw
operator|new
name|AlreadyBeingCreatedException
argument_list|(
name|op
operator|.
name|getExceptionMessage
argument_list|(
name|src
argument_list|,
name|holder
argument_list|,
name|clientMachine
argument_list|,
name|holder
operator|+
literal|" is already the current lease holder."
argument_list|)
argument_list|)
throw|;
block|}
block|}
comment|//
comment|// Find the original holder.
comment|//
name|FileUnderConstructionFeature
name|uc
init|=
name|file
operator|.
name|getFileUnderConstructionFeature
argument_list|()
decl_stmt|;
name|String
name|clientName
init|=
name|uc
operator|.
name|getClientName
argument_list|()
decl_stmt|;
name|lease
operator|=
name|leaseManager
operator|.
name|getLease
argument_list|(
name|clientName
argument_list|)
expr_stmt|;
if|if
condition|(
name|lease
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|AlreadyBeingCreatedException
argument_list|(
name|op
operator|.
name|getExceptionMessage
argument_list|(
name|src
argument_list|,
name|holder
argument_list|,
name|clientMachine
argument_list|,
literal|"the file is under construction but no leases found."
argument_list|)
argument_list|)
throw|;
block|}
if|if
condition|(
name|force
condition|)
block|{
comment|// close now: no need to wait for soft lease expiration and
comment|// close only the file src
name|LOG
operator|.
name|info
argument_list|(
literal|"recoverLease: "
operator|+
name|lease
operator|+
literal|", src="
operator|+
name|src
operator|+
literal|" from client "
operator|+
name|clientName
argument_list|)
expr_stmt|;
name|internalReleaseLease
argument_list|(
name|lease
argument_list|,
name|src
argument_list|,
name|iip
argument_list|,
name|holder
argument_list|)
expr_stmt|;
block|}
else|else
block|{
assert|assert
name|lease
operator|.
name|getHolder
argument_list|()
operator|.
name|equals
argument_list|(
name|clientName
argument_list|)
operator|:
literal|"Current lease holder "
operator|+
name|lease
operator|.
name|getHolder
argument_list|()
operator|+
literal|" does not match file creator "
operator|+
name|clientName
assert|;
comment|//
comment|// If the original holder has not renewed in the last SOFTLIMIT
comment|// period, then start lease recovery.
comment|//
if|if
condition|(
name|lease
operator|.
name|expiredSoftLimit
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"startFile: recover "
operator|+
name|lease
operator|+
literal|", src="
operator|+
name|src
operator|+
literal|" client "
operator|+
name|clientName
argument_list|)
expr_stmt|;
name|boolean
name|isClosed
init|=
name|internalReleaseLease
argument_list|(
name|lease
argument_list|,
name|src
argument_list|,
name|iip
argument_list|,
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|isClosed
condition|)
throw|throw
operator|new
name|RecoveryInProgressException
argument_list|(
name|op
operator|.
name|getExceptionMessage
argument_list|(
name|src
argument_list|,
name|holder
argument_list|,
name|clientMachine
argument_list|,
literal|"lease recovery is in progress. Try again later."
argument_list|)
argument_list|)
throw|;
block|}
else|else
block|{
specifier|final
name|BlockInfoContiguous
name|lastBlock
init|=
name|file
operator|.
name|getLastBlock
argument_list|()
decl_stmt|;
if|if
condition|(
name|lastBlock
operator|!=
literal|null
operator|&&
name|lastBlock
operator|.
name|getBlockUCState
argument_list|()
operator|==
name|BlockUCState
operator|.
name|UNDER_RECOVERY
condition|)
block|{
throw|throw
operator|new
name|RecoveryInProgressException
argument_list|(
name|op
operator|.
name|getExceptionMessage
argument_list|(
name|src
argument_list|,
name|holder
argument_list|,
name|clientMachine
argument_list|,
literal|"another recovery is in progress by "
operator|+
name|clientName
operator|+
literal|" on "
operator|+
name|uc
operator|.
name|getClientMachine
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
else|else
block|{
throw|throw
operator|new
name|AlreadyBeingCreatedException
argument_list|(
name|op
operator|.
name|getExceptionMessage
argument_list|(
name|src
argument_list|,
name|holder
argument_list|,
name|clientMachine
argument_list|,
literal|"this file lease is currently owned by "
operator|+
name|clientName
operator|+
literal|" on "
operator|+
name|uc
operator|.
name|getClientMachine
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
block|}
block|}
block|}
block|}
comment|/**    * Append to an existing file in the namespace.    */
DECL|method|appendFile (String src, String holder, String clientMachine, EnumSet<CreateFlag> flag, boolean logRetryCache)
name|LastBlockWithStatus
name|appendFile
parameter_list|(
name|String
name|src
parameter_list|,
name|String
name|holder
parameter_list|,
name|String
name|clientMachine
parameter_list|,
name|EnumSet
argument_list|<
name|CreateFlag
argument_list|>
name|flag
parameter_list|,
name|boolean
name|logRetryCache
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
return|return
name|appendFileInt
argument_list|(
name|src
argument_list|,
name|holder
argument_list|,
name|clientMachine
argument_list|,
name|flag
operator|.
name|contains
argument_list|(
name|CreateFlag
operator|.
name|NEW_BLOCK
argument_list|)
argument_list|,
name|logRetryCache
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|AccessControlException
name|e
parameter_list|)
block|{
name|logAuditEvent
argument_list|(
literal|false
argument_list|,
literal|"append"
argument_list|,
name|src
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
DECL|method|appendFileInt (final String srcArg, String holder, String clientMachine, boolean newBlock, boolean logRetryCache)
specifier|private
name|LastBlockWithStatus
name|appendFileInt
parameter_list|(
specifier|final
name|String
name|srcArg
parameter_list|,
name|String
name|holder
parameter_list|,
name|String
name|clientMachine
parameter_list|,
name|boolean
name|newBlock
parameter_list|,
name|boolean
name|logRetryCache
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|src
init|=
name|srcArg
decl_stmt|;
if|if
condition|(
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|debug
argument_list|(
literal|"DIR* NameSystem.appendFile: src="
operator|+
name|src
operator|+
literal|", holder="
operator|+
name|holder
operator|+
literal|", clientMachine="
operator|+
name|clientMachine
argument_list|)
expr_stmt|;
block|}
name|boolean
name|skipSync
init|=
literal|false
decl_stmt|;
name|LocatedBlock
name|lb
init|=
literal|null
decl_stmt|;
name|HdfsFileStatus
name|stat
init|=
literal|null
decl_stmt|;
name|FSPermissionChecker
name|pc
init|=
name|getPermissionChecker
argument_list|()
decl_stmt|;
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|byte
index|[]
index|[]
name|pathComponents
init|=
name|FSDirectory
operator|.
name|getPathComponentsForReservedPath
argument_list|(
name|src
argument_list|)
decl_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|checkNameNodeSafeMode
argument_list|(
literal|"Cannot append to file"
operator|+
name|src
argument_list|)
expr_stmt|;
name|src
operator|=
name|dir
operator|.
name|resolvePath
argument_list|(
name|pc
argument_list|,
name|src
argument_list|,
name|pathComponents
argument_list|)
expr_stmt|;
specifier|final
name|INodesInPath
name|iip
init|=
name|dir
operator|.
name|getINodesInPath4Write
argument_list|(
name|src
argument_list|)
decl_stmt|;
name|lb
operator|=
name|appendFileInternal
argument_list|(
name|pc
argument_list|,
name|iip
argument_list|,
name|holder
argument_list|,
name|clientMachine
argument_list|,
name|newBlock
argument_list|,
name|logRetryCache
argument_list|)
expr_stmt|;
name|stat
operator|=
name|FSDirStatAndListingOp
operator|.
name|getFileInfo
argument_list|(
name|dir
argument_list|,
name|src
argument_list|,
literal|false
argument_list|,
name|FSDirectory
operator|.
name|isReservedRawName
argument_list|(
name|srcArg
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|StandbyException
name|se
parameter_list|)
block|{
name|skipSync
operator|=
literal|true
expr_stmt|;
throw|throw
name|se
throw|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
comment|// There might be transactions logged while trying to recover the lease.
comment|// They need to be sync'ed even when an exception was thrown.
if|if
condition|(
operator|!
name|skipSync
condition|)
block|{
name|getEditLog
argument_list|()
operator|.
name|logSync
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|lb
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|debug
argument_list|(
literal|"DIR* NameSystem.appendFile: file "
operator|+
name|src
operator|+
literal|" for "
operator|+
name|holder
operator|+
literal|" at "
operator|+
name|clientMachine
operator|+
literal|" block "
operator|+
name|lb
operator|.
name|getBlock
argument_list|()
operator|+
literal|" block size "
operator|+
name|lb
operator|.
name|getBlock
argument_list|()
operator|.
name|getNumBytes
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|logAuditEvent
argument_list|(
literal|true
argument_list|,
literal|"append"
argument_list|,
name|srcArg
argument_list|)
expr_stmt|;
return|return
operator|new
name|LastBlockWithStatus
argument_list|(
name|lb
argument_list|,
name|stat
argument_list|)
return|;
block|}
DECL|method|getExtendedBlock (Block blk)
name|ExtendedBlock
name|getExtendedBlock
parameter_list|(
name|Block
name|blk
parameter_list|)
block|{
return|return
operator|new
name|ExtendedBlock
argument_list|(
name|blockPoolId
argument_list|,
name|blk
argument_list|)
return|;
block|}
DECL|method|setBlockPoolId (String bpid)
name|void
name|setBlockPoolId
parameter_list|(
name|String
name|bpid
parameter_list|)
block|{
name|blockPoolId
operator|=
name|bpid
expr_stmt|;
name|blockManager
operator|.
name|setBlockPoolId
argument_list|(
name|blockPoolId
argument_list|)
expr_stmt|;
block|}
comment|/**    * The client would like to obtain an additional block for the indicated    * filename (which is being written-to).  Return an array that consists    * of the block, plus a set of machines.  The first on this list should    * be where the client writes data.  Subsequent items in the list must    * be provided in the connection to the first datanode.    *    * Make sure the previous blocks have been reported by datanodes and    * are replicated.  Will return an empty 2-elt array if we want the    * client to "try again later".    */
DECL|method|getAdditionalBlock (String src, long fileId, String clientName, ExtendedBlock previous, Set<Node> excludedNodes, List<String> favoredNodes)
name|LocatedBlock
name|getAdditionalBlock
parameter_list|(
name|String
name|src
parameter_list|,
name|long
name|fileId
parameter_list|,
name|String
name|clientName
parameter_list|,
name|ExtendedBlock
name|previous
parameter_list|,
name|Set
argument_list|<
name|Node
argument_list|>
name|excludedNodes
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|favoredNodes
parameter_list|)
throws|throws
name|IOException
block|{
name|LocatedBlock
index|[]
name|onRetryBlock
init|=
operator|new
name|LocatedBlock
index|[
literal|1
index|]
decl_stmt|;
name|DatanodeStorageInfo
name|targets
index|[]
init|=
name|getNewBlockTargets
argument_list|(
name|src
argument_list|,
name|fileId
argument_list|,
name|clientName
argument_list|,
name|previous
argument_list|,
name|excludedNodes
argument_list|,
name|favoredNodes
argument_list|,
name|onRetryBlock
argument_list|)
decl_stmt|;
if|if
condition|(
name|targets
operator|==
literal|null
condition|)
block|{
assert|assert
name|onRetryBlock
index|[
literal|0
index|]
operator|!=
literal|null
operator|:
literal|"Retry block is null"
assert|;
comment|// This is a retry. Just return the last block.
return|return
name|onRetryBlock
index|[
literal|0
index|]
return|;
block|}
name|LocatedBlock
name|newBlock
init|=
name|storeAllocatedBlock
argument_list|(
name|src
argument_list|,
name|fileId
argument_list|,
name|clientName
argument_list|,
name|previous
argument_list|,
name|targets
argument_list|)
decl_stmt|;
return|return
name|newBlock
return|;
block|}
comment|/**    * Part I of getAdditionalBlock().    * Analyze the state of the file under read lock to determine if the client    * can add a new block, detect potential retries, lease mismatches,    * and minimal replication of the penultimate block.    *     * Generate target DataNode locations for the new block,    * but do not create the new block yet.    */
DECL|method|getNewBlockTargets (String src, long fileId, String clientName, ExtendedBlock previous, Set<Node> excludedNodes, List<String> favoredNodes, LocatedBlock[] onRetryBlock)
name|DatanodeStorageInfo
index|[]
name|getNewBlockTargets
parameter_list|(
name|String
name|src
parameter_list|,
name|long
name|fileId
parameter_list|,
name|String
name|clientName
parameter_list|,
name|ExtendedBlock
name|previous
parameter_list|,
name|Set
argument_list|<
name|Node
argument_list|>
name|excludedNodes
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|favoredNodes
parameter_list|,
name|LocatedBlock
index|[]
name|onRetryBlock
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|long
name|blockSize
decl_stmt|;
specifier|final
name|int
name|replication
decl_stmt|;
specifier|final
name|byte
name|storagePolicyID
decl_stmt|;
name|Node
name|clientNode
init|=
literal|null
decl_stmt|;
name|String
name|clientMachine
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|debug
argument_list|(
literal|"BLOCK* getAdditionalBlock: "
operator|+
name|src
operator|+
literal|" inodeId "
operator|+
name|fileId
operator|+
literal|" for "
operator|+
name|clientName
argument_list|)
expr_stmt|;
block|}
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|READ
argument_list|)
expr_stmt|;
name|byte
index|[]
index|[]
name|pathComponents
init|=
name|FSDirectory
operator|.
name|getPathComponentsForReservedPath
argument_list|(
name|src
argument_list|)
decl_stmt|;
name|FSPermissionChecker
name|pc
init|=
name|getPermissionChecker
argument_list|()
decl_stmt|;
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|READ
argument_list|)
expr_stmt|;
name|src
operator|=
name|dir
operator|.
name|resolvePath
argument_list|(
name|pc
argument_list|,
name|src
argument_list|,
name|pathComponents
argument_list|)
expr_stmt|;
name|FileState
name|fileState
init|=
name|analyzeFileState
argument_list|(
name|src
argument_list|,
name|fileId
argument_list|,
name|clientName
argument_list|,
name|previous
argument_list|,
name|onRetryBlock
argument_list|)
decl_stmt|;
specifier|final
name|INodeFile
name|pendingFile
init|=
name|fileState
operator|.
name|inode
decl_stmt|;
comment|// Check if the penultimate block is minimally replicated
if|if
condition|(
operator|!
name|checkFileProgress
argument_list|(
name|src
argument_list|,
name|pendingFile
argument_list|,
literal|false
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|NotReplicatedYetException
argument_list|(
literal|"Not replicated yet: "
operator|+
name|src
argument_list|)
throw|;
block|}
name|src
operator|=
name|fileState
operator|.
name|path
expr_stmt|;
if|if
condition|(
name|onRetryBlock
index|[
literal|0
index|]
operator|!=
literal|null
operator|&&
name|onRetryBlock
index|[
literal|0
index|]
operator|.
name|getLocations
argument_list|()
operator|.
name|length
operator|>
literal|0
condition|)
block|{
comment|// This is a retry. No need to generate new locations.
comment|// Use the last block if it has locations.
return|return
literal|null
return|;
block|}
if|if
condition|(
name|pendingFile
operator|.
name|getBlocks
argument_list|()
operator|.
name|length
operator|>=
name|maxBlocksPerFile
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"File has reached the limit on maximum number of"
operator|+
literal|" blocks ("
operator|+
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_MAX_BLOCKS_PER_FILE_KEY
operator|+
literal|"): "
operator|+
name|pendingFile
operator|.
name|getBlocks
argument_list|()
operator|.
name|length
operator|+
literal|">= "
operator|+
name|maxBlocksPerFile
argument_list|)
throw|;
block|}
name|blockSize
operator|=
name|pendingFile
operator|.
name|getPreferredBlockSize
argument_list|()
expr_stmt|;
name|clientMachine
operator|=
name|pendingFile
operator|.
name|getFileUnderConstructionFeature
argument_list|()
operator|.
name|getClientMachine
argument_list|()
expr_stmt|;
name|clientNode
operator|=
name|blockManager
operator|.
name|getDatanodeManager
argument_list|()
operator|.
name|getDatanodeByHost
argument_list|(
name|clientMachine
argument_list|)
expr_stmt|;
name|replication
operator|=
name|pendingFile
operator|.
name|getFileReplication
argument_list|()
expr_stmt|;
name|storagePolicyID
operator|=
name|pendingFile
operator|.
name|getStoragePolicyID
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|clientNode
operator|==
literal|null
condition|)
block|{
name|clientNode
operator|=
name|getClientNode
argument_list|(
name|clientMachine
argument_list|)
expr_stmt|;
block|}
comment|// choose targets for the new block to be allocated.
return|return
name|getBlockManager
argument_list|()
operator|.
name|chooseTarget4NewBlock
argument_list|(
name|src
argument_list|,
name|replication
argument_list|,
name|clientNode
argument_list|,
name|excludedNodes
argument_list|,
name|blockSize
argument_list|,
name|favoredNodes
argument_list|,
name|storagePolicyID
argument_list|)
return|;
block|}
comment|/**    * Part II of getAdditionalBlock().    * Should repeat the same analysis of the file state as in Part 1,    * but under the write lock.    * If the conditions still hold, then allocate a new block with    * the new targets, add it to the INode and to the BlocksMap.    */
DECL|method|storeAllocatedBlock (String src, long fileId, String clientName, ExtendedBlock previous, DatanodeStorageInfo[] targets)
name|LocatedBlock
name|storeAllocatedBlock
parameter_list|(
name|String
name|src
parameter_list|,
name|long
name|fileId
parameter_list|,
name|String
name|clientName
parameter_list|,
name|ExtendedBlock
name|previous
parameter_list|,
name|DatanodeStorageInfo
index|[]
name|targets
parameter_list|)
throws|throws
name|IOException
block|{
name|Block
name|newBlock
init|=
literal|null
decl_stmt|;
name|long
name|offset
decl_stmt|;
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|waitForLoadingFSImage
argument_list|()
expr_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
comment|// Run the full analysis again, since things could have changed
comment|// while chooseTarget() was executing.
name|LocatedBlock
index|[]
name|onRetryBlock
init|=
operator|new
name|LocatedBlock
index|[
literal|1
index|]
decl_stmt|;
name|FileState
name|fileState
init|=
name|analyzeFileState
argument_list|(
name|src
argument_list|,
name|fileId
argument_list|,
name|clientName
argument_list|,
name|previous
argument_list|,
name|onRetryBlock
argument_list|)
decl_stmt|;
specifier|final
name|INodeFile
name|pendingFile
init|=
name|fileState
operator|.
name|inode
decl_stmt|;
name|src
operator|=
name|fileState
operator|.
name|path
expr_stmt|;
if|if
condition|(
name|onRetryBlock
index|[
literal|0
index|]
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|onRetryBlock
index|[
literal|0
index|]
operator|.
name|getLocations
argument_list|()
operator|.
name|length
operator|>
literal|0
condition|)
block|{
comment|// This is a retry. Just return the last block if having locations.
return|return
name|onRetryBlock
index|[
literal|0
index|]
return|;
block|}
else|else
block|{
comment|// add new chosen targets to already allocated block and return
name|BlockInfoContiguous
name|lastBlockInFile
init|=
name|pendingFile
operator|.
name|getLastBlock
argument_list|()
decl_stmt|;
operator|(
operator|(
name|BlockInfoContiguousUnderConstruction
operator|)
name|lastBlockInFile
operator|)
operator|.
name|setExpectedLocations
argument_list|(
name|targets
argument_list|)
expr_stmt|;
name|offset
operator|=
name|pendingFile
operator|.
name|computeFileSize
argument_list|()
expr_stmt|;
return|return
name|makeLocatedBlock
argument_list|(
name|lastBlockInFile
argument_list|,
name|targets
argument_list|,
name|offset
argument_list|)
return|;
block|}
block|}
comment|// commit the last block and complete it if it has minimum replicas
name|commitOrCompleteLastBlock
argument_list|(
name|pendingFile
argument_list|,
name|fileState
operator|.
name|iip
argument_list|,
name|ExtendedBlock
operator|.
name|getLocalBlock
argument_list|(
name|previous
argument_list|)
argument_list|)
expr_stmt|;
comment|// allocate new block, record block locations in INode.
name|newBlock
operator|=
name|createNewBlock
argument_list|()
expr_stmt|;
name|INodesInPath
name|inodesInPath
init|=
name|INodesInPath
operator|.
name|fromINode
argument_list|(
name|pendingFile
argument_list|)
decl_stmt|;
name|saveAllocatedBlock
argument_list|(
name|src
argument_list|,
name|inodesInPath
argument_list|,
name|newBlock
argument_list|,
name|targets
argument_list|)
expr_stmt|;
name|persistNewBlock
argument_list|(
name|src
argument_list|,
name|pendingFile
argument_list|)
expr_stmt|;
name|offset
operator|=
name|pendingFile
operator|.
name|computeFileSize
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
name|getEditLog
argument_list|()
operator|.
name|logSync
argument_list|()
expr_stmt|;
comment|// Return located block
return|return
name|makeLocatedBlock
argument_list|(
name|newBlock
argument_list|,
name|targets
argument_list|,
name|offset
argument_list|)
return|;
block|}
comment|/*    * Resolve clientmachine address to get a network location path    */
DECL|method|getClientNode (String clientMachine)
specifier|private
name|Node
name|getClientNode
parameter_list|(
name|String
name|clientMachine
parameter_list|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|hosts
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|hosts
operator|.
name|add
argument_list|(
name|clientMachine
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|rName
init|=
name|getBlockManager
argument_list|()
operator|.
name|getDatanodeManager
argument_list|()
operator|.
name|resolveNetworkLocation
argument_list|(
name|hosts
argument_list|)
decl_stmt|;
name|Node
name|clientNode
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|rName
operator|!=
literal|null
condition|)
block|{
comment|// Able to resolve clientMachine mapping.
comment|// Create a temp node to findout the rack local nodes
name|clientNode
operator|=
operator|new
name|NodeBase
argument_list|(
name|rName
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|+
name|NodeBase
operator|.
name|PATH_SEPARATOR_STR
operator|+
name|clientMachine
argument_list|)
expr_stmt|;
block|}
return|return
name|clientNode
return|;
block|}
DECL|class|FileState
specifier|static
class|class
name|FileState
block|{
DECL|field|inode
specifier|public
specifier|final
name|INodeFile
name|inode
decl_stmt|;
DECL|field|path
specifier|public
specifier|final
name|String
name|path
decl_stmt|;
DECL|field|iip
specifier|public
specifier|final
name|INodesInPath
name|iip
decl_stmt|;
DECL|method|FileState (INodeFile inode, String fullPath, INodesInPath iip)
specifier|public
name|FileState
parameter_list|(
name|INodeFile
name|inode
parameter_list|,
name|String
name|fullPath
parameter_list|,
name|INodesInPath
name|iip
parameter_list|)
block|{
name|this
operator|.
name|inode
operator|=
name|inode
expr_stmt|;
name|this
operator|.
name|path
operator|=
name|fullPath
expr_stmt|;
name|this
operator|.
name|iip
operator|=
name|iip
expr_stmt|;
block|}
block|}
DECL|method|analyzeFileState (String src, long fileId, String clientName, ExtendedBlock previous, LocatedBlock[] onRetryBlock)
name|FileState
name|analyzeFileState
parameter_list|(
name|String
name|src
parameter_list|,
name|long
name|fileId
parameter_list|,
name|String
name|clientName
parameter_list|,
name|ExtendedBlock
name|previous
parameter_list|,
name|LocatedBlock
index|[]
name|onRetryBlock
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|hasReadLock
argument_list|()
assert|;
name|checkBlock
argument_list|(
name|previous
argument_list|)
expr_stmt|;
name|onRetryBlock
index|[
literal|0
index|]
operator|=
literal|null
expr_stmt|;
name|checkNameNodeSafeMode
argument_list|(
literal|"Cannot add block to "
operator|+
name|src
argument_list|)
expr_stmt|;
comment|// have we exceeded the configured limit of fs objects.
name|checkFsObjectLimit
argument_list|()
expr_stmt|;
name|Block
name|previousBlock
init|=
name|ExtendedBlock
operator|.
name|getLocalBlock
argument_list|(
name|previous
argument_list|)
decl_stmt|;
specifier|final
name|INode
name|inode
decl_stmt|;
specifier|final
name|INodesInPath
name|iip
decl_stmt|;
if|if
condition|(
name|fileId
operator|==
name|HdfsConstantsClient
operator|.
name|GRANDFATHER_INODE_ID
condition|)
block|{
comment|// Older clients may not have given us an inode ID to work with.
comment|// In this case, we have to try to resolve the path and hope it
comment|// hasn't changed or been deleted since the file was opened for write.
name|iip
operator|=
name|dir
operator|.
name|getINodesInPath4Write
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|inode
operator|=
name|iip
operator|.
name|getLastINode
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// Newer clients pass the inode ID, so we can just get the inode
comment|// directly.
name|inode
operator|=
name|dir
operator|.
name|getInode
argument_list|(
name|fileId
argument_list|)
expr_stmt|;
name|iip
operator|=
name|INodesInPath
operator|.
name|fromINode
argument_list|(
name|inode
argument_list|)
expr_stmt|;
if|if
condition|(
name|inode
operator|!=
literal|null
condition|)
block|{
name|src
operator|=
name|iip
operator|.
name|getPath
argument_list|()
expr_stmt|;
block|}
block|}
specifier|final
name|INodeFile
name|pendingFile
init|=
name|checkLease
argument_list|(
name|src
argument_list|,
name|clientName
argument_list|,
name|inode
argument_list|,
name|fileId
argument_list|)
decl_stmt|;
name|BlockInfoContiguous
name|lastBlockInFile
init|=
name|pendingFile
operator|.
name|getLastBlock
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|Block
operator|.
name|matchingIdAndGenStamp
argument_list|(
name|previousBlock
argument_list|,
name|lastBlockInFile
argument_list|)
condition|)
block|{
comment|// The block that the client claims is the current last block
comment|// doesn't match up with what we think is the last block. There are
comment|// four possibilities:
comment|// 1) This is the first block allocation of an append() pipeline
comment|//    which started appending exactly at or exceeding the block boundary.
comment|//    In this case, the client isn't passed the previous block,
comment|//    so it makes the allocateBlock() call with previous=null.
comment|//    We can distinguish this since the last block of the file
comment|//    will be exactly a full block.
comment|// 2) This is a retry from a client that missed the response of a
comment|//    prior getAdditionalBlock() call, perhaps because of a network
comment|//    timeout, or because of an HA failover. In that case, we know
comment|//    by the fact that the client is re-issuing the RPC that it
comment|//    never began to write to the old block. Hence it is safe to
comment|//    to return the existing block.
comment|// 3) This is an entirely bogus request/bug -- we should error out
comment|//    rather than potentially appending a new block with an empty
comment|//    one in the middle, etc
comment|// 4) This is a retry from a client that timed out while
comment|//    the prior getAdditionalBlock() is still being processed,
comment|//    currently working on chooseTarget().
comment|//    There are no means to distinguish between the first and
comment|//    the second attempts in Part I, because the first one hasn't
comment|//    changed the namesystem state yet.
comment|//    We run this analysis again in Part II where case 4 is impossible.
name|BlockInfoContiguous
name|penultimateBlock
init|=
name|pendingFile
operator|.
name|getPenultimateBlock
argument_list|()
decl_stmt|;
if|if
condition|(
name|previous
operator|==
literal|null
operator|&&
name|lastBlockInFile
operator|!=
literal|null
operator|&&
name|lastBlockInFile
operator|.
name|getNumBytes
argument_list|()
operator|>=
name|pendingFile
operator|.
name|getPreferredBlockSize
argument_list|()
operator|&&
name|lastBlockInFile
operator|.
name|isComplete
argument_list|()
condition|)
block|{
comment|// Case 1
if|if
condition|(
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|debug
argument_list|(
literal|"BLOCK* NameSystem.allocateBlock: handling block allocation"
operator|+
literal|" writing to a file with a complete previous block: src="
operator|+
name|src
operator|+
literal|" lastBlock="
operator|+
name|lastBlockInFile
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|Block
operator|.
name|matchingIdAndGenStamp
argument_list|(
name|penultimateBlock
argument_list|,
name|previousBlock
argument_list|)
condition|)
block|{
if|if
condition|(
name|lastBlockInFile
operator|.
name|getNumBytes
argument_list|()
operator|!=
literal|0
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Request looked like a retry to allocate block "
operator|+
name|lastBlockInFile
operator|+
literal|" but it already contains "
operator|+
name|lastBlockInFile
operator|.
name|getNumBytes
argument_list|()
operator|+
literal|" bytes"
argument_list|)
throw|;
block|}
comment|// Case 2
comment|// Return the last block.
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|info
argument_list|(
literal|"BLOCK* allocateBlock: "
operator|+
literal|"caught retry for allocation of a new block in "
operator|+
name|src
operator|+
literal|". Returning previously allocated block "
operator|+
name|lastBlockInFile
argument_list|)
expr_stmt|;
name|long
name|offset
init|=
name|pendingFile
operator|.
name|computeFileSize
argument_list|()
decl_stmt|;
name|onRetryBlock
index|[
literal|0
index|]
operator|=
name|makeLocatedBlock
argument_list|(
name|lastBlockInFile
argument_list|,
operator|(
operator|(
name|BlockInfoContiguousUnderConstruction
operator|)
name|lastBlockInFile
operator|)
operator|.
name|getExpectedStorageLocations
argument_list|()
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
operator|new
name|FileState
argument_list|(
name|pendingFile
argument_list|,
name|src
argument_list|,
name|iip
argument_list|)
return|;
block|}
else|else
block|{
comment|// Case 3
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Cannot allocate block in "
operator|+
name|src
operator|+
literal|": "
operator|+
literal|"passed 'previous' block "
operator|+
name|previous
operator|+
literal|" does not match actual "
operator|+
literal|"last block in file "
operator|+
name|lastBlockInFile
argument_list|)
throw|;
block|}
block|}
return|return
operator|new
name|FileState
argument_list|(
name|pendingFile
argument_list|,
name|src
argument_list|,
name|iip
argument_list|)
return|;
block|}
DECL|method|makeLocatedBlock (Block blk, DatanodeStorageInfo[] locs, long offset)
name|LocatedBlock
name|makeLocatedBlock
parameter_list|(
name|Block
name|blk
parameter_list|,
name|DatanodeStorageInfo
index|[]
name|locs
parameter_list|,
name|long
name|offset
parameter_list|)
throws|throws
name|IOException
block|{
name|LocatedBlock
name|lBlk
init|=
name|BlockManager
operator|.
name|newLocatedBlock
argument_list|(
name|getExtendedBlock
argument_list|(
name|blk
argument_list|)
argument_list|,
name|locs
argument_list|,
name|offset
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|getBlockManager
argument_list|()
operator|.
name|setBlockToken
argument_list|(
name|lBlk
argument_list|,
name|BlockTokenIdentifier
operator|.
name|AccessMode
operator|.
name|WRITE
argument_list|)
expr_stmt|;
return|return
name|lBlk
return|;
block|}
comment|/** @see ClientProtocol#getAdditionalDatanode */
DECL|method|getAdditionalDatanode (String src, long fileId, final ExtendedBlock blk, final DatanodeInfo[] existings, final String[] storageIDs, final Set<Node> excludes, final int numAdditionalNodes, final String clientName )
name|LocatedBlock
name|getAdditionalDatanode
parameter_list|(
name|String
name|src
parameter_list|,
name|long
name|fileId
parameter_list|,
specifier|final
name|ExtendedBlock
name|blk
parameter_list|,
specifier|final
name|DatanodeInfo
index|[]
name|existings
parameter_list|,
specifier|final
name|String
index|[]
name|storageIDs
parameter_list|,
specifier|final
name|Set
argument_list|<
name|Node
argument_list|>
name|excludes
parameter_list|,
specifier|final
name|int
name|numAdditionalNodes
parameter_list|,
specifier|final
name|String
name|clientName
parameter_list|)
throws|throws
name|IOException
block|{
comment|//check if the feature is enabled
name|dtpReplaceDatanodeOnFailure
operator|.
name|checkEnabled
argument_list|()
expr_stmt|;
name|Node
name|clientnode
init|=
literal|null
decl_stmt|;
name|String
name|clientMachine
decl_stmt|;
specifier|final
name|long
name|preferredblocksize
decl_stmt|;
specifier|final
name|byte
name|storagePolicyID
decl_stmt|;
specifier|final
name|List
argument_list|<
name|DatanodeStorageInfo
argument_list|>
name|chosen
decl_stmt|;
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|READ
argument_list|)
expr_stmt|;
name|byte
index|[]
index|[]
name|pathComponents
init|=
name|FSDirectory
operator|.
name|getPathComponentsForReservedPath
argument_list|(
name|src
argument_list|)
decl_stmt|;
name|FSPermissionChecker
name|pc
init|=
name|getPermissionChecker
argument_list|()
decl_stmt|;
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|READ
argument_list|)
expr_stmt|;
comment|//check safe mode
name|checkNameNodeSafeMode
argument_list|(
literal|"Cannot add datanode; src="
operator|+
name|src
operator|+
literal|", blk="
operator|+
name|blk
argument_list|)
expr_stmt|;
name|src
operator|=
name|dir
operator|.
name|resolvePath
argument_list|(
name|pc
argument_list|,
name|src
argument_list|,
name|pathComponents
argument_list|)
expr_stmt|;
comment|//check lease
specifier|final
name|INode
name|inode
decl_stmt|;
if|if
condition|(
name|fileId
operator|==
name|HdfsConstantsClient
operator|.
name|GRANDFATHER_INODE_ID
condition|)
block|{
comment|// Older clients may not have given us an inode ID to work with.
comment|// In this case, we have to try to resolve the path and hope it
comment|// hasn't changed or been deleted since the file was opened for write.
name|inode
operator|=
name|dir
operator|.
name|getINode
argument_list|(
name|src
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|inode
operator|=
name|dir
operator|.
name|getInode
argument_list|(
name|fileId
argument_list|)
expr_stmt|;
if|if
condition|(
name|inode
operator|!=
literal|null
condition|)
name|src
operator|=
name|inode
operator|.
name|getFullPathName
argument_list|()
expr_stmt|;
block|}
specifier|final
name|INodeFile
name|file
init|=
name|checkLease
argument_list|(
name|src
argument_list|,
name|clientName
argument_list|,
name|inode
argument_list|,
name|fileId
argument_list|)
decl_stmt|;
name|clientMachine
operator|=
name|file
operator|.
name|getFileUnderConstructionFeature
argument_list|()
operator|.
name|getClientMachine
argument_list|()
expr_stmt|;
name|clientnode
operator|=
name|blockManager
operator|.
name|getDatanodeManager
argument_list|()
operator|.
name|getDatanodeByHost
argument_list|(
name|clientMachine
argument_list|)
expr_stmt|;
name|preferredblocksize
operator|=
name|file
operator|.
name|getPreferredBlockSize
argument_list|()
expr_stmt|;
name|storagePolicyID
operator|=
name|file
operator|.
name|getStoragePolicyID
argument_list|()
expr_stmt|;
comment|//find datanode storages
specifier|final
name|DatanodeManager
name|dm
init|=
name|blockManager
operator|.
name|getDatanodeManager
argument_list|()
decl_stmt|;
name|chosen
operator|=
name|Arrays
operator|.
name|asList
argument_list|(
name|dm
operator|.
name|getDatanodeStorageInfos
argument_list|(
name|existings
argument_list|,
name|storageIDs
argument_list|)
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|clientnode
operator|==
literal|null
condition|)
block|{
name|clientnode
operator|=
name|getClientNode
argument_list|(
name|clientMachine
argument_list|)
expr_stmt|;
block|}
comment|// choose new datanodes.
specifier|final
name|DatanodeStorageInfo
index|[]
name|targets
init|=
name|blockManager
operator|.
name|chooseTarget4AdditionalDatanode
argument_list|(
name|src
argument_list|,
name|numAdditionalNodes
argument_list|,
name|clientnode
argument_list|,
name|chosen
argument_list|,
name|excludes
argument_list|,
name|preferredblocksize
argument_list|,
name|storagePolicyID
argument_list|)
decl_stmt|;
specifier|final
name|LocatedBlock
name|lb
init|=
name|BlockManager
operator|.
name|newLocatedBlock
argument_list|(
name|blk
argument_list|,
name|targets
argument_list|,
operator|-
literal|1
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|blockManager
operator|.
name|setBlockToken
argument_list|(
name|lb
argument_list|,
name|BlockTokenIdentifier
operator|.
name|AccessMode
operator|.
name|COPY
argument_list|)
expr_stmt|;
return|return
name|lb
return|;
block|}
comment|/**    * The client would like to let go of the given block    */
DECL|method|abandonBlock (ExtendedBlock b, long fileId, String src, String holder)
name|boolean
name|abandonBlock
parameter_list|(
name|ExtendedBlock
name|b
parameter_list|,
name|long
name|fileId
parameter_list|,
name|String
name|src
parameter_list|,
name|String
name|holder
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|debug
argument_list|(
literal|"BLOCK* NameSystem.abandonBlock: "
operator|+
name|b
operator|+
literal|"of file "
operator|+
name|src
argument_list|)
expr_stmt|;
block|}
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|byte
index|[]
index|[]
name|pathComponents
init|=
name|FSDirectory
operator|.
name|getPathComponentsForReservedPath
argument_list|(
name|src
argument_list|)
decl_stmt|;
name|FSPermissionChecker
name|pc
init|=
name|getPermissionChecker
argument_list|()
decl_stmt|;
name|waitForLoadingFSImage
argument_list|()
expr_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|checkNameNodeSafeMode
argument_list|(
literal|"Cannot abandon block "
operator|+
name|b
operator|+
literal|" for file"
operator|+
name|src
argument_list|)
expr_stmt|;
name|src
operator|=
name|dir
operator|.
name|resolvePath
argument_list|(
name|pc
argument_list|,
name|src
argument_list|,
name|pathComponents
argument_list|)
expr_stmt|;
specifier|final
name|INode
name|inode
decl_stmt|;
specifier|final
name|INodesInPath
name|iip
decl_stmt|;
if|if
condition|(
name|fileId
operator|==
name|HdfsConstantsClient
operator|.
name|GRANDFATHER_INODE_ID
condition|)
block|{
comment|// Older clients may not have given us an inode ID to work with.
comment|// In this case, we have to try to resolve the path and hope it
comment|// hasn't changed or been deleted since the file was opened for write.
name|iip
operator|=
name|dir
operator|.
name|getINodesInPath
argument_list|(
name|src
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|inode
operator|=
name|iip
operator|.
name|getLastINode
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|inode
operator|=
name|dir
operator|.
name|getInode
argument_list|(
name|fileId
argument_list|)
expr_stmt|;
name|iip
operator|=
name|INodesInPath
operator|.
name|fromINode
argument_list|(
name|inode
argument_list|)
expr_stmt|;
if|if
condition|(
name|inode
operator|!=
literal|null
condition|)
block|{
name|src
operator|=
name|iip
operator|.
name|getPath
argument_list|()
expr_stmt|;
block|}
block|}
specifier|final
name|INodeFile
name|file
init|=
name|checkLease
argument_list|(
name|src
argument_list|,
name|holder
argument_list|,
name|inode
argument_list|,
name|fileId
argument_list|)
decl_stmt|;
comment|// Remove the block from the pending creates list
name|boolean
name|removed
init|=
name|dir
operator|.
name|removeBlock
argument_list|(
name|src
argument_list|,
name|iip
argument_list|,
name|file
argument_list|,
name|ExtendedBlock
operator|.
name|getLocalBlock
argument_list|(
name|b
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|removed
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|debug
argument_list|(
literal|"BLOCK* NameSystem.abandonBlock: "
operator|+
name|b
operator|+
literal|" is removed from pendingCreates"
argument_list|)
expr_stmt|;
block|}
name|persistBlocks
argument_list|(
name|src
argument_list|,
name|file
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
name|getEditLog
argument_list|()
operator|.
name|logSync
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
DECL|method|checkLease (String src, String holder, INode inode, long fileId)
specifier|private
name|INodeFile
name|checkLease
parameter_list|(
name|String
name|src
parameter_list|,
name|String
name|holder
parameter_list|,
name|INode
name|inode
parameter_list|,
name|long
name|fileId
parameter_list|)
throws|throws
name|LeaseExpiredException
throws|,
name|FileNotFoundException
block|{
assert|assert
name|hasReadLock
argument_list|()
assert|;
specifier|final
name|String
name|ident
init|=
name|src
operator|+
literal|" (inode "
operator|+
name|fileId
operator|+
literal|")"
decl_stmt|;
if|if
condition|(
name|inode
operator|==
literal|null
condition|)
block|{
name|Lease
name|lease
init|=
name|leaseManager
operator|.
name|getLease
argument_list|(
name|holder
argument_list|)
decl_stmt|;
throw|throw
operator|new
name|LeaseExpiredException
argument_list|(
literal|"No lease on "
operator|+
name|ident
operator|+
literal|": File does not exist. "
operator|+
operator|(
name|lease
operator|!=
literal|null
condition|?
name|lease
operator|.
name|toString
argument_list|()
else|:
literal|"Holder "
operator|+
name|holder
operator|+
literal|" does not have any open files."
operator|)
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|inode
operator|.
name|isFile
argument_list|()
condition|)
block|{
name|Lease
name|lease
init|=
name|leaseManager
operator|.
name|getLease
argument_list|(
name|holder
argument_list|)
decl_stmt|;
throw|throw
operator|new
name|LeaseExpiredException
argument_list|(
literal|"No lease on "
operator|+
name|ident
operator|+
literal|": INode is not a regular file. "
operator|+
operator|(
name|lease
operator|!=
literal|null
condition|?
name|lease
operator|.
name|toString
argument_list|()
else|:
literal|"Holder "
operator|+
name|holder
operator|+
literal|" does not have any open files."
operator|)
argument_list|)
throw|;
block|}
specifier|final
name|INodeFile
name|file
init|=
name|inode
operator|.
name|asFile
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|file
operator|.
name|isUnderConstruction
argument_list|()
condition|)
block|{
name|Lease
name|lease
init|=
name|leaseManager
operator|.
name|getLease
argument_list|(
name|holder
argument_list|)
decl_stmt|;
throw|throw
operator|new
name|LeaseExpiredException
argument_list|(
literal|"No lease on "
operator|+
name|ident
operator|+
literal|": File is not open for writing. "
operator|+
operator|(
name|lease
operator|!=
literal|null
condition|?
name|lease
operator|.
name|toString
argument_list|()
else|:
literal|"Holder "
operator|+
name|holder
operator|+
literal|" does not have any open files."
operator|)
argument_list|)
throw|;
block|}
comment|// No further modification is allowed on a deleted file.
comment|// A file is considered deleted, if it is not in the inodeMap or is marked
comment|// as deleted in the snapshot feature.
if|if
condition|(
name|isFileDeleted
argument_list|(
name|file
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|FileNotFoundException
argument_list|(
name|src
argument_list|)
throw|;
block|}
name|String
name|clientName
init|=
name|file
operator|.
name|getFileUnderConstructionFeature
argument_list|()
operator|.
name|getClientName
argument_list|()
decl_stmt|;
if|if
condition|(
name|holder
operator|!=
literal|null
operator|&&
operator|!
name|clientName
operator|.
name|equals
argument_list|(
name|holder
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|LeaseExpiredException
argument_list|(
literal|"Lease mismatch on "
operator|+
name|ident
operator|+
literal|" owned by "
operator|+
name|clientName
operator|+
literal|" but is accessed by "
operator|+
name|holder
argument_list|)
throw|;
block|}
return|return
name|file
return|;
block|}
comment|/**    * Complete in-progress write to the given file.    * @return true if successful, false if the client should continue to retry    *         (e.g if not all blocks have reached minimum replication yet)    * @throws IOException on error (eg lease mismatch, file not open, file deleted)    */
DECL|method|completeFile (final String srcArg, String holder, ExtendedBlock last, long fileId)
name|boolean
name|completeFile
parameter_list|(
specifier|final
name|String
name|srcArg
parameter_list|,
name|String
name|holder
parameter_list|,
name|ExtendedBlock
name|last
parameter_list|,
name|long
name|fileId
parameter_list|)
throws|throws
name|SafeModeException
throws|,
name|UnresolvedLinkException
throws|,
name|IOException
block|{
name|String
name|src
init|=
name|srcArg
decl_stmt|;
if|if
condition|(
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|debug
argument_list|(
literal|"DIR* NameSystem.completeFile: "
operator|+
name|src
operator|+
literal|" for "
operator|+
name|holder
argument_list|)
expr_stmt|;
block|}
name|checkBlock
argument_list|(
name|last
argument_list|)
expr_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|byte
index|[]
index|[]
name|pathComponents
init|=
name|FSDirectory
operator|.
name|getPathComponentsForReservedPath
argument_list|(
name|src
argument_list|)
decl_stmt|;
name|FSPermissionChecker
name|pc
init|=
name|getPermissionChecker
argument_list|()
decl_stmt|;
name|waitForLoadingFSImage
argument_list|()
expr_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|checkNameNodeSafeMode
argument_list|(
literal|"Cannot complete file "
operator|+
name|src
argument_list|)
expr_stmt|;
name|src
operator|=
name|dir
operator|.
name|resolvePath
argument_list|(
name|pc
argument_list|,
name|src
argument_list|,
name|pathComponents
argument_list|)
expr_stmt|;
name|success
operator|=
name|completeFileInternal
argument_list|(
name|src
argument_list|,
name|holder
argument_list|,
name|ExtendedBlock
operator|.
name|getLocalBlock
argument_list|(
name|last
argument_list|)
argument_list|,
name|fileId
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
name|getEditLog
argument_list|()
operator|.
name|logSync
argument_list|()
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|info
argument_list|(
literal|"DIR* completeFile: "
operator|+
name|srcArg
operator|+
literal|" is closed by "
operator|+
name|holder
argument_list|)
expr_stmt|;
block|}
return|return
name|success
return|;
block|}
DECL|method|completeFileInternal (String src, String holder, Block last, long fileId)
specifier|private
name|boolean
name|completeFileInternal
parameter_list|(
name|String
name|src
parameter_list|,
name|String
name|holder
parameter_list|,
name|Block
name|last
parameter_list|,
name|long
name|fileId
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|hasWriteLock
argument_list|()
assert|;
specifier|final
name|INodeFile
name|pendingFile
decl_stmt|;
specifier|final
name|INodesInPath
name|iip
decl_stmt|;
name|INode
name|inode
init|=
literal|null
decl_stmt|;
try|try
block|{
if|if
condition|(
name|fileId
operator|==
name|HdfsConstantsClient
operator|.
name|GRANDFATHER_INODE_ID
condition|)
block|{
comment|// Older clients may not have given us an inode ID to work with.
comment|// In this case, we have to try to resolve the path and hope it
comment|// hasn't changed or been deleted since the file was opened for write.
name|iip
operator|=
name|dir
operator|.
name|getINodesInPath
argument_list|(
name|src
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|inode
operator|=
name|iip
operator|.
name|getLastINode
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|inode
operator|=
name|dir
operator|.
name|getInode
argument_list|(
name|fileId
argument_list|)
expr_stmt|;
name|iip
operator|=
name|INodesInPath
operator|.
name|fromINode
argument_list|(
name|inode
argument_list|)
expr_stmt|;
if|if
condition|(
name|inode
operator|!=
literal|null
condition|)
block|{
name|src
operator|=
name|iip
operator|.
name|getPath
argument_list|()
expr_stmt|;
block|}
block|}
name|pendingFile
operator|=
name|checkLease
argument_list|(
name|src
argument_list|,
name|holder
argument_list|,
name|inode
argument_list|,
name|fileId
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|LeaseExpiredException
name|lee
parameter_list|)
block|{
if|if
condition|(
name|inode
operator|!=
literal|null
operator|&&
name|inode
operator|.
name|isFile
argument_list|()
operator|&&
operator|!
name|inode
operator|.
name|asFile
argument_list|()
operator|.
name|isUnderConstruction
argument_list|()
condition|)
block|{
comment|// This could be a retry RPC - i.e the client tried to close
comment|// the file, but missed the RPC response. Thus, it is trying
comment|// again to close the file. If the file still exists and
comment|// the client's view of the last block matches the actual
comment|// last block, then we'll treat it as a successful close.
comment|// See HDFS-3031.
specifier|final
name|Block
name|realLastBlock
init|=
name|inode
operator|.
name|asFile
argument_list|()
operator|.
name|getLastBlock
argument_list|()
decl_stmt|;
if|if
condition|(
name|Block
operator|.
name|matchingIdAndGenStamp
argument_list|(
name|last
argument_list|,
name|realLastBlock
argument_list|)
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|info
argument_list|(
literal|"DIR* completeFile: "
operator|+
literal|"request from "
operator|+
name|holder
operator|+
literal|" to complete inode "
operator|+
name|fileId
operator|+
literal|"("
operator|+
name|src
operator|+
literal|") which is already closed. But, it appears to be "
operator|+
literal|"an RPC retry. Returning success"
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
throw|throw
name|lee
throw|;
block|}
comment|// Check the state of the penultimate block. It should be completed
comment|// before attempting to complete the last one.
if|if
condition|(
operator|!
name|checkFileProgress
argument_list|(
name|src
argument_list|,
name|pendingFile
argument_list|,
literal|false
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// commit the last block and complete it if it has minimum replicas
name|commitOrCompleteLastBlock
argument_list|(
name|pendingFile
argument_list|,
name|iip
argument_list|,
name|last
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|checkFileProgress
argument_list|(
name|src
argument_list|,
name|pendingFile
argument_list|,
literal|true
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|finalizeINodeFileUnderConstruction
argument_list|(
name|src
argument_list|,
name|pendingFile
argument_list|,
name|Snapshot
operator|.
name|CURRENT_STATE_ID
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|/**    * Save allocated block at the given pending filename    *     * @param src path to the file    * @param inodesInPath representing each of the components of src.    *                     The last INode is the INode for {@code src} file.    * @param newBlock newly allocated block to be save    * @param targets target datanodes where replicas of the new block is placed    * @throws QuotaExceededException If addition of block exceeds space quota    */
DECL|method|saveAllocatedBlock (String src, INodesInPath inodesInPath, Block newBlock, DatanodeStorageInfo[] targets)
specifier|private
name|void
name|saveAllocatedBlock
parameter_list|(
name|String
name|src
parameter_list|,
name|INodesInPath
name|inodesInPath
parameter_list|,
name|Block
name|newBlock
parameter_list|,
name|DatanodeStorageInfo
index|[]
name|targets
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|hasWriteLock
argument_list|()
assert|;
name|BlockInfoContiguous
name|b
init|=
name|dir
operator|.
name|addBlock
argument_list|(
name|src
argument_list|,
name|inodesInPath
argument_list|,
name|newBlock
argument_list|,
name|targets
argument_list|)
decl_stmt|;
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|info
argument_list|(
literal|"BLOCK* allocate "
operator|+
name|b
operator|+
literal|" for "
operator|+
name|src
argument_list|)
expr_stmt|;
name|DatanodeStorageInfo
operator|.
name|incrementBlocksScheduled
argument_list|(
name|targets
argument_list|)
expr_stmt|;
block|}
comment|/**    * Create new block with a unique block id and a new generation stamp.    */
DECL|method|createNewBlock ()
specifier|private
name|Block
name|createNewBlock
parameter_list|()
throws|throws
name|IOException
block|{
assert|assert
name|hasWriteLock
argument_list|()
assert|;
name|Block
name|b
init|=
operator|new
name|Block
argument_list|(
name|nextBlockId
argument_list|()
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|// Increment the generation stamp for every new block.
name|b
operator|.
name|setGenerationStamp
argument_list|(
name|nextGenerationStamp
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|b
return|;
block|}
comment|/**    * Check that the indicated file's blocks are present and    * replicated.  If not, return false. If checkall is true, then check    * all blocks, otherwise check only penultimate block.    */
DECL|method|checkFileProgress (String src, INodeFile v, boolean checkall)
name|boolean
name|checkFileProgress
parameter_list|(
name|String
name|src
parameter_list|,
name|INodeFile
name|v
parameter_list|,
name|boolean
name|checkall
parameter_list|)
block|{
assert|assert
name|hasReadLock
argument_list|()
assert|;
if|if
condition|(
name|checkall
condition|)
block|{
return|return
name|blockManager
operator|.
name|checkBlocksProperlyReplicated
argument_list|(
name|src
argument_list|,
name|v
operator|.
name|getBlocks
argument_list|()
argument_list|)
return|;
block|}
else|else
block|{
comment|// check the penultimate block of this file
name|BlockInfoContiguous
name|b
init|=
name|v
operator|.
name|getPenultimateBlock
argument_list|()
decl_stmt|;
return|return
name|b
operator|==
literal|null
operator|||
name|blockManager
operator|.
name|checkBlocksProperlyReplicated
argument_list|(
name|src
argument_list|,
operator|new
name|BlockInfoContiguous
index|[]
block|{
name|b
block|}
argument_list|)
return|;
block|}
block|}
comment|/**    * Change the indicated filename.     * @deprecated Use {@link #renameTo(String, String, boolean,    * Options.Rename...)} instead.    */
annotation|@
name|Deprecated
DECL|method|renameTo (String src, String dst, boolean logRetryCache)
name|boolean
name|renameTo
parameter_list|(
name|String
name|src
parameter_list|,
name|String
name|dst
parameter_list|,
name|boolean
name|logRetryCache
parameter_list|)
throws|throws
name|IOException
block|{
name|waitForLoadingFSImage
argument_list|()
expr_stmt|;
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|FSDirRenameOp
operator|.
name|RenameOldResult
name|ret
init|=
literal|null
decl_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|checkNameNodeSafeMode
argument_list|(
literal|"Cannot rename "
operator|+
name|src
argument_list|)
expr_stmt|;
name|ret
operator|=
name|FSDirRenameOp
operator|.
name|renameToInt
argument_list|(
name|dir
argument_list|,
name|src
argument_list|,
name|dst
argument_list|,
name|logRetryCache
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|AccessControlException
name|e
parameter_list|)
block|{
name|logAuditEvent
argument_list|(
literal|false
argument_list|,
literal|"rename"
argument_list|,
name|src
argument_list|,
name|dst
argument_list|,
literal|null
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
name|boolean
name|success
init|=
name|ret
operator|!=
literal|null
operator|&&
name|ret
operator|.
name|success
decl_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|getEditLog
argument_list|()
operator|.
name|logSync
argument_list|()
expr_stmt|;
block|}
name|logAuditEvent
argument_list|(
name|success
argument_list|,
literal|"rename"
argument_list|,
name|src
argument_list|,
name|dst
argument_list|,
name|ret
operator|==
literal|null
condition|?
literal|null
else|:
name|ret
operator|.
name|auditStat
argument_list|)
expr_stmt|;
return|return
name|success
return|;
block|}
DECL|method|renameTo (final String src, final String dst, boolean logRetryCache, Options.Rename... options)
name|void
name|renameTo
parameter_list|(
specifier|final
name|String
name|src
parameter_list|,
specifier|final
name|String
name|dst
parameter_list|,
name|boolean
name|logRetryCache
parameter_list|,
name|Options
operator|.
name|Rename
modifier|...
name|options
parameter_list|)
throws|throws
name|IOException
block|{
name|waitForLoadingFSImage
argument_list|()
expr_stmt|;
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|Map
operator|.
name|Entry
argument_list|<
name|BlocksMapUpdateInfo
argument_list|,
name|HdfsFileStatus
argument_list|>
name|res
init|=
literal|null
decl_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|checkNameNodeSafeMode
argument_list|(
literal|"Cannot rename "
operator|+
name|src
argument_list|)
expr_stmt|;
name|res
operator|=
name|FSDirRenameOp
operator|.
name|renameToInt
argument_list|(
name|dir
argument_list|,
name|src
argument_list|,
name|dst
argument_list|,
name|logRetryCache
argument_list|,
name|options
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|AccessControlException
name|e
parameter_list|)
block|{
name|logAuditEvent
argument_list|(
literal|false
argument_list|,
literal|"rename (options="
operator|+
name|Arrays
operator|.
name|toString
argument_list|(
name|options
argument_list|)
operator|+
literal|")"
argument_list|,
name|src
argument_list|,
name|dst
argument_list|,
literal|null
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
name|getEditLog
argument_list|()
operator|.
name|logSync
argument_list|()
expr_stmt|;
name|BlocksMapUpdateInfo
name|collectedBlocks
init|=
name|res
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|HdfsFileStatus
name|auditStat
init|=
name|res
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|collectedBlocks
operator|.
name|getToDeleteList
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|removeBlocks
argument_list|(
name|collectedBlocks
argument_list|)
expr_stmt|;
name|collectedBlocks
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
name|logAuditEvent
argument_list|(
literal|true
argument_list|,
literal|"rename (options="
operator|+
name|Arrays
operator|.
name|toString
argument_list|(
name|options
argument_list|)
operator|+
literal|")"
argument_list|,
name|src
argument_list|,
name|dst
argument_list|,
name|auditStat
argument_list|)
expr_stmt|;
block|}
comment|/**    * Remove the indicated file from namespace.    *     * @see ClientProtocol#delete(String, boolean) for detailed description and     * description of exceptions    */
DECL|method|delete (String src, boolean recursive, boolean logRetryCache)
name|boolean
name|delete
parameter_list|(
name|String
name|src
parameter_list|,
name|boolean
name|recursive
parameter_list|,
name|boolean
name|logRetryCache
parameter_list|)
throws|throws
name|IOException
block|{
name|waitForLoadingFSImage
argument_list|()
expr_stmt|;
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|BlocksMapUpdateInfo
name|toRemovedBlocks
init|=
literal|null
decl_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
name|boolean
name|ret
init|=
literal|false
decl_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|checkNameNodeSafeMode
argument_list|(
literal|"Cannot delete "
operator|+
name|src
argument_list|)
expr_stmt|;
name|toRemovedBlocks
operator|=
name|FSDirDeleteOp
operator|.
name|delete
argument_list|(
name|this
argument_list|,
name|src
argument_list|,
name|recursive
argument_list|,
name|logRetryCache
argument_list|)
expr_stmt|;
name|ret
operator|=
name|toRemovedBlocks
operator|!=
literal|null
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|AccessControlException
name|e
parameter_list|)
block|{
name|logAuditEvent
argument_list|(
literal|false
argument_list|,
literal|"delete"
argument_list|,
name|src
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
name|getEditLog
argument_list|()
operator|.
name|logSync
argument_list|()
expr_stmt|;
if|if
condition|(
name|toRemovedBlocks
operator|!=
literal|null
condition|)
block|{
name|removeBlocks
argument_list|(
name|toRemovedBlocks
argument_list|)
expr_stmt|;
comment|// Incremental deletion of blocks
block|}
name|logAuditEvent
argument_list|(
literal|true
argument_list|,
literal|"delete"
argument_list|,
name|src
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
DECL|method|getPermissionChecker ()
name|FSPermissionChecker
name|getPermissionChecker
parameter_list|()
throws|throws
name|AccessControlException
block|{
return|return
name|dir
operator|.
name|getPermissionChecker
argument_list|()
return|;
block|}
comment|/**    * From the given list, incrementally remove the blocks from blockManager    * Writelock is dropped and reacquired every BLOCK_DELETION_INCREMENT to    * ensure that other waiters on the lock can get in. See HDFS-2938    *     * @param blocks    *          An instance of {@link BlocksMapUpdateInfo} which contains a list    *          of blocks that need to be removed from blocksMap    */
DECL|method|removeBlocks (BlocksMapUpdateInfo blocks)
name|void
name|removeBlocks
parameter_list|(
name|BlocksMapUpdateInfo
name|blocks
parameter_list|)
block|{
name|List
argument_list|<
name|Block
argument_list|>
name|toDeleteList
init|=
name|blocks
operator|.
name|getToDeleteList
argument_list|()
decl_stmt|;
name|Iterator
argument_list|<
name|Block
argument_list|>
name|iter
init|=
name|toDeleteList
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|iter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|BLOCK_DELETION_INCREMENT
operator|&&
name|iter
operator|.
name|hasNext
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|blockManager
operator|.
name|removeBlock
argument_list|(
name|iter
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Remove leases and inodes related to a given path    * @param src The given path    * @param removedINodes Containing the list of inodes to be removed from    *                      inodesMap    * @param acquireINodeMapLock Whether to acquire the lock for inode removal    */
DECL|method|removeLeasesAndINodes (String src, List<INode> removedINodes, final boolean acquireINodeMapLock)
name|void
name|removeLeasesAndINodes
parameter_list|(
name|String
name|src
parameter_list|,
name|List
argument_list|<
name|INode
argument_list|>
name|removedINodes
parameter_list|,
specifier|final
name|boolean
name|acquireINodeMapLock
parameter_list|)
block|{
assert|assert
name|hasWriteLock
argument_list|()
assert|;
name|leaseManager
operator|.
name|removeLeaseWithPrefixPath
argument_list|(
name|src
argument_list|)
expr_stmt|;
comment|// remove inodes from inodesMap
if|if
condition|(
name|removedINodes
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|acquireINodeMapLock
condition|)
block|{
name|dir
operator|.
name|writeLock
argument_list|()
expr_stmt|;
block|}
try|try
block|{
name|dir
operator|.
name|removeFromInodeMap
argument_list|(
name|removedINodes
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|acquireINodeMapLock
condition|)
block|{
name|dir
operator|.
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
name|removedINodes
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Removes the blocks from blocksmap and updates the safemode blocks total    *     * @param blocks    *          An instance of {@link BlocksMapUpdateInfo} which contains a list    *          of blocks that need to be removed from blocksMap    */
DECL|method|removeBlocksAndUpdateSafemodeTotal (BlocksMapUpdateInfo blocks)
name|void
name|removeBlocksAndUpdateSafemodeTotal
parameter_list|(
name|BlocksMapUpdateInfo
name|blocks
parameter_list|)
block|{
assert|assert
name|hasWriteLock
argument_list|()
assert|;
comment|// In the case that we are a Standby tailing edits from the
comment|// active while in safe-mode, we need to track the total number
comment|// of blocks and safe blocks in the system.
name|boolean
name|trackBlockCounts
init|=
name|isSafeModeTrackingBlocks
argument_list|()
decl_stmt|;
name|int
name|numRemovedComplete
init|=
literal|0
decl_stmt|,
name|numRemovedSafe
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Block
name|b
range|:
name|blocks
operator|.
name|getToDeleteList
argument_list|()
control|)
block|{
if|if
condition|(
name|trackBlockCounts
condition|)
block|{
name|BlockInfoContiguous
name|bi
init|=
name|getStoredBlock
argument_list|(
name|b
argument_list|)
decl_stmt|;
if|if
condition|(
name|bi
operator|.
name|isComplete
argument_list|()
condition|)
block|{
name|numRemovedComplete
operator|++
expr_stmt|;
if|if
condition|(
name|bi
operator|.
name|numNodes
argument_list|()
operator|>=
name|blockManager
operator|.
name|minReplication
condition|)
block|{
name|numRemovedSafe
operator|++
expr_stmt|;
block|}
block|}
block|}
name|blockManager
operator|.
name|removeBlock
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|trackBlockCounts
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Adjusting safe-mode totals for deletion."
operator|+
literal|"decreasing safeBlocks by "
operator|+
name|numRemovedSafe
operator|+
literal|", totalBlocks by "
operator|+
name|numRemovedComplete
argument_list|)
expr_stmt|;
block|}
name|adjustSafeModeBlockTotals
argument_list|(
operator|-
name|numRemovedSafe
argument_list|,
operator|-
name|numRemovedComplete
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * @see SafeModeInfo#shouldIncrementallyTrackBlocks    */
DECL|method|isSafeModeTrackingBlocks ()
specifier|private
name|boolean
name|isSafeModeTrackingBlocks
parameter_list|()
block|{
if|if
condition|(
operator|!
name|haEnabled
condition|)
block|{
comment|// Never track blocks incrementally in non-HA code.
return|return
literal|false
return|;
block|}
name|SafeModeInfo
name|sm
init|=
name|this
operator|.
name|safeMode
decl_stmt|;
return|return
name|sm
operator|!=
literal|null
operator|&&
name|sm
operator|.
name|shouldIncrementallyTrackBlocks
argument_list|()
return|;
block|}
comment|/**    * Get the file info for a specific file.    *    * @param src The string representation of the path to the file    * @param resolveLink whether to throw UnresolvedLinkException    *        if src refers to a symlink    *    * @throws AccessControlException if access is denied    * @throws UnresolvedLinkException if a symlink is encountered.    *    * @return object containing information regarding the file    *         or null if file not found    * @throws StandbyException    */
DECL|method|getFileInfo (final String src, boolean resolveLink)
name|HdfsFileStatus
name|getFileInfo
parameter_list|(
specifier|final
name|String
name|src
parameter_list|,
name|boolean
name|resolveLink
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|READ
argument_list|)
expr_stmt|;
name|HdfsFileStatus
name|stat
init|=
literal|null
decl_stmt|;
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|READ
argument_list|)
expr_stmt|;
name|stat
operator|=
name|FSDirStatAndListingOp
operator|.
name|getFileInfo
argument_list|(
name|dir
argument_list|,
name|src
argument_list|,
name|resolveLink
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|AccessControlException
name|e
parameter_list|)
block|{
name|logAuditEvent
argument_list|(
literal|false
argument_list|,
literal|"getfileinfo"
argument_list|,
name|src
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
name|logAuditEvent
argument_list|(
literal|true
argument_list|,
literal|"getfileinfo"
argument_list|,
name|src
argument_list|)
expr_stmt|;
return|return
name|stat
return|;
block|}
comment|/**    * Returns true if the file is closed    */
DECL|method|isFileClosed (final String src)
name|boolean
name|isFileClosed
parameter_list|(
specifier|final
name|String
name|src
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|READ
argument_list|)
expr_stmt|;
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|READ
argument_list|)
expr_stmt|;
return|return
name|FSDirStatAndListingOp
operator|.
name|isFileClosed
argument_list|(
name|dir
argument_list|,
name|src
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|AccessControlException
name|e
parameter_list|)
block|{
name|logAuditEvent
argument_list|(
literal|false
argument_list|,
literal|"isFileClosed"
argument_list|,
name|src
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Create all the necessary directories    */
DECL|method|mkdirs (String src, PermissionStatus permissions, boolean createParent)
name|boolean
name|mkdirs
parameter_list|(
name|String
name|src
parameter_list|,
name|PermissionStatus
name|permissions
parameter_list|,
name|boolean
name|createParent
parameter_list|)
throws|throws
name|IOException
block|{
name|HdfsFileStatus
name|auditStat
init|=
literal|null
decl_stmt|;
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|checkNameNodeSafeMode
argument_list|(
literal|"Cannot create directory "
operator|+
name|src
argument_list|)
expr_stmt|;
name|auditStat
operator|=
name|FSDirMkdirOp
operator|.
name|mkdirs
argument_list|(
name|this
argument_list|,
name|src
argument_list|,
name|permissions
argument_list|,
name|createParent
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|AccessControlException
name|e
parameter_list|)
block|{
name|logAuditEvent
argument_list|(
literal|false
argument_list|,
literal|"mkdirs"
argument_list|,
name|src
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
name|getEditLog
argument_list|()
operator|.
name|logSync
argument_list|()
expr_stmt|;
name|logAuditEvent
argument_list|(
literal|true
argument_list|,
literal|"mkdirs"
argument_list|,
name|src
argument_list|,
literal|null
argument_list|,
name|auditStat
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|/**    * Get the content summary for a specific file/dir.    *    * @param src The string representation of the path to the file    *    * @throws AccessControlException if access is denied    * @throws UnresolvedLinkException if a symlink is encountered.    * @throws FileNotFoundException if no file exists    * @throws StandbyException    * @throws IOException for issues with writing to the audit log    *    * @return object containing information regarding the file    *         or null if file not found    */
DECL|method|getContentSummary (final String src)
name|ContentSummary
name|getContentSummary
parameter_list|(
specifier|final
name|String
name|src
parameter_list|)
throws|throws
name|IOException
block|{
name|readLock
argument_list|()
expr_stmt|;
name|boolean
name|success
init|=
literal|true
decl_stmt|;
try|try
block|{
return|return
name|FSDirStatAndListingOp
operator|.
name|getContentSummary
argument_list|(
name|dir
argument_list|,
name|src
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|AccessControlException
name|ace
parameter_list|)
block|{
name|success
operator|=
literal|false
expr_stmt|;
throw|throw
name|ace
throw|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
name|logAuditEvent
argument_list|(
name|success
argument_list|,
literal|"contentSummary"
argument_list|,
name|src
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Set the namespace quota and storage space quota for a directory.    * See {@link ClientProtocol#setQuota(String, long, long, StorageType)} for the    * contract.    *     * Note: This does not support ".inodes" relative path.    */
DECL|method|setQuota (String src, long nsQuota, long ssQuota, StorageType type)
name|void
name|setQuota
parameter_list|(
name|String
name|src
parameter_list|,
name|long
name|nsQuota
parameter_list|,
name|long
name|ssQuota
parameter_list|,
name|StorageType
name|type
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|checkNameNodeSafeMode
argument_list|(
literal|"Cannot set quota on "
operator|+
name|src
argument_list|)
expr_stmt|;
name|FSDirAttrOp
operator|.
name|setQuota
argument_list|(
name|dir
argument_list|,
name|src
argument_list|,
name|nsQuota
argument_list|,
name|ssQuota
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|getEditLog
argument_list|()
operator|.
name|logSync
argument_list|()
expr_stmt|;
block|}
name|logAuditEvent
argument_list|(
name|success
argument_list|,
literal|"setQuota"
argument_list|,
name|src
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Persist all metadata about this file.    * @param src The string representation of the path    * @param fileId The inode ID that we're fsyncing.  Older clients will pass    *               INodeId.GRANDFATHER_INODE_ID here.    * @param clientName The string representation of the client    * @param lastBlockLength The length of the last block     *                        under construction reported from client.    * @throws IOException if path does not exist    */
DECL|method|fsync (String src, long fileId, String clientName, long lastBlockLength)
name|void
name|fsync
parameter_list|(
name|String
name|src
parameter_list|,
name|long
name|fileId
parameter_list|,
name|String
name|clientName
parameter_list|,
name|long
name|lastBlockLength
parameter_list|)
throws|throws
name|IOException
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|info
argument_list|(
literal|"BLOCK* fsync: "
operator|+
name|src
operator|+
literal|" for "
operator|+
name|clientName
argument_list|)
expr_stmt|;
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|byte
index|[]
index|[]
name|pathComponents
init|=
name|FSDirectory
operator|.
name|getPathComponentsForReservedPath
argument_list|(
name|src
argument_list|)
decl_stmt|;
name|FSPermissionChecker
name|pc
init|=
name|getPermissionChecker
argument_list|()
decl_stmt|;
name|waitForLoadingFSImage
argument_list|()
expr_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|checkNameNodeSafeMode
argument_list|(
literal|"Cannot fsync file "
operator|+
name|src
argument_list|)
expr_stmt|;
name|src
operator|=
name|dir
operator|.
name|resolvePath
argument_list|(
name|pc
argument_list|,
name|src
argument_list|,
name|pathComponents
argument_list|)
expr_stmt|;
specifier|final
name|INode
name|inode
decl_stmt|;
if|if
condition|(
name|fileId
operator|==
name|HdfsConstantsClient
operator|.
name|GRANDFATHER_INODE_ID
condition|)
block|{
comment|// Older clients may not have given us an inode ID to work with.
comment|// In this case, we have to try to resolve the path and hope it
comment|// hasn't changed or been deleted since the file was opened for write.
name|inode
operator|=
name|dir
operator|.
name|getINode
argument_list|(
name|src
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|inode
operator|=
name|dir
operator|.
name|getInode
argument_list|(
name|fileId
argument_list|)
expr_stmt|;
if|if
condition|(
name|inode
operator|!=
literal|null
condition|)
name|src
operator|=
name|inode
operator|.
name|getFullPathName
argument_list|()
expr_stmt|;
block|}
specifier|final
name|INodeFile
name|pendingFile
init|=
name|checkLease
argument_list|(
name|src
argument_list|,
name|clientName
argument_list|,
name|inode
argument_list|,
name|fileId
argument_list|)
decl_stmt|;
if|if
condition|(
name|lastBlockLength
operator|>
literal|0
condition|)
block|{
name|pendingFile
operator|.
name|getFileUnderConstructionFeature
argument_list|()
operator|.
name|updateLengthOfLastBlock
argument_list|(
name|pendingFile
argument_list|,
name|lastBlockLength
argument_list|)
expr_stmt|;
block|}
name|persistBlocks
argument_list|(
name|src
argument_list|,
name|pendingFile
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
name|getEditLog
argument_list|()
operator|.
name|logSync
argument_list|()
expr_stmt|;
block|}
comment|/**    * Move a file that is being written to be immutable.    * @param src The filename    * @param lease The lease for the client creating the file    * @param recoveryLeaseHolder reassign lease to this holder if the last block    *        needs recovery; keep current holder if null.    * @throws AlreadyBeingCreatedException if file is waiting to achieve minimal    *         replication;<br>    *         RecoveryInProgressException if lease recovery is in progress.<br>    *         IOException in case of an error.    * @return true  if file has been successfully finalized and closed or     *         false if block recovery has been initiated. Since the lease owner    *         has been changed and logged, caller should call logSync().    */
DECL|method|internalReleaseLease (Lease lease, String src, INodesInPath iip, String recoveryLeaseHolder)
name|boolean
name|internalReleaseLease
parameter_list|(
name|Lease
name|lease
parameter_list|,
name|String
name|src
parameter_list|,
name|INodesInPath
name|iip
parameter_list|,
name|String
name|recoveryLeaseHolder
parameter_list|)
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Recovering "
operator|+
name|lease
operator|+
literal|", src="
operator|+
name|src
argument_list|)
expr_stmt|;
assert|assert
operator|!
name|isInSafeMode
argument_list|()
assert|;
assert|assert
name|hasWriteLock
argument_list|()
assert|;
specifier|final
name|INodeFile
name|pendingFile
init|=
name|iip
operator|.
name|getLastINode
argument_list|()
operator|.
name|asFile
argument_list|()
decl_stmt|;
name|int
name|nrBlocks
init|=
name|pendingFile
operator|.
name|numBlocks
argument_list|()
decl_stmt|;
name|BlockInfoContiguous
index|[]
name|blocks
init|=
name|pendingFile
operator|.
name|getBlocks
argument_list|()
decl_stmt|;
name|int
name|nrCompleteBlocks
decl_stmt|;
name|BlockInfoContiguous
name|curBlock
init|=
literal|null
decl_stmt|;
for|for
control|(
name|nrCompleteBlocks
operator|=
literal|0
init|;
name|nrCompleteBlocks
operator|<
name|nrBlocks
condition|;
name|nrCompleteBlocks
operator|++
control|)
block|{
name|curBlock
operator|=
name|blocks
index|[
name|nrCompleteBlocks
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|curBlock
operator|.
name|isComplete
argument_list|()
condition|)
break|break;
assert|assert
name|blockManager
operator|.
name|checkMinReplication
argument_list|(
name|curBlock
argument_list|)
operator|:
literal|"A COMPLETE block is not minimally replicated in "
operator|+
name|src
assert|;
block|}
comment|// If there are no incomplete blocks associated with this file,
comment|// then reap lease immediately and close the file.
if|if
condition|(
name|nrCompleteBlocks
operator|==
name|nrBlocks
condition|)
block|{
name|finalizeINodeFileUnderConstruction
argument_list|(
name|src
argument_list|,
name|pendingFile
argument_list|,
name|iip
operator|.
name|getLatestSnapshotId
argument_list|()
argument_list|)
expr_stmt|;
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|warn
argument_list|(
literal|"BLOCK*"
operator|+
literal|" internalReleaseLease: All existing blocks are COMPLETE,"
operator|+
literal|" lease removed, file closed."
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
comment|// closed!
block|}
comment|// Only the last and the penultimate blocks may be in non COMPLETE state.
comment|// If the penultimate block is not COMPLETE, then it must be COMMITTED.
if|if
condition|(
name|nrCompleteBlocks
operator|<
name|nrBlocks
operator|-
literal|2
operator|||
name|nrCompleteBlocks
operator|==
name|nrBlocks
operator|-
literal|2
operator|&&
name|curBlock
operator|!=
literal|null
operator|&&
name|curBlock
operator|.
name|getBlockUCState
argument_list|()
operator|!=
name|BlockUCState
operator|.
name|COMMITTED
condition|)
block|{
specifier|final
name|String
name|message
init|=
literal|"DIR* NameSystem.internalReleaseLease: "
operator|+
literal|"attempt to release a create lock on "
operator|+
name|src
operator|+
literal|" but file is already closed."
decl_stmt|;
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|warn
argument_list|(
name|message
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
name|message
argument_list|)
throw|;
block|}
comment|// The last block is not COMPLETE, and
comment|// that the penultimate block if exists is either COMPLETE or COMMITTED
specifier|final
name|BlockInfoContiguous
name|lastBlock
init|=
name|pendingFile
operator|.
name|getLastBlock
argument_list|()
decl_stmt|;
name|BlockUCState
name|lastBlockState
init|=
name|lastBlock
operator|.
name|getBlockUCState
argument_list|()
decl_stmt|;
name|BlockInfoContiguous
name|penultimateBlock
init|=
name|pendingFile
operator|.
name|getPenultimateBlock
argument_list|()
decl_stmt|;
comment|// If penultimate block doesn't exist then its minReplication is met
name|boolean
name|penultimateBlockMinReplication
init|=
name|penultimateBlock
operator|==
literal|null
condition|?
literal|true
else|:
name|blockManager
operator|.
name|checkMinReplication
argument_list|(
name|penultimateBlock
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|lastBlockState
condition|)
block|{
case|case
name|COMPLETE
case|:
assert|assert
literal|false
operator|:
literal|"Already checked that the last block is incomplete"
assert|;
break|break;
case|case
name|COMMITTED
case|:
comment|// Close file if committed blocks are minimally replicated
if|if
condition|(
name|penultimateBlockMinReplication
operator|&&
name|blockManager
operator|.
name|checkMinReplication
argument_list|(
name|lastBlock
argument_list|)
condition|)
block|{
name|finalizeINodeFileUnderConstruction
argument_list|(
name|src
argument_list|,
name|pendingFile
argument_list|,
name|iip
operator|.
name|getLatestSnapshotId
argument_list|()
argument_list|)
expr_stmt|;
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|warn
argument_list|(
literal|"BLOCK*"
operator|+
literal|" internalReleaseLease: Committed blocks are minimally replicated,"
operator|+
literal|" lease removed, file closed."
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
comment|// closed!
block|}
comment|// Cannot close file right now, since some blocks
comment|// are not yet minimally replicated.
comment|// This may potentially cause infinite loop in lease recovery
comment|// if there are no valid replicas on data-nodes.
name|String
name|message
init|=
literal|"DIR* NameSystem.internalReleaseLease: "
operator|+
literal|"Failed to release lease for file "
operator|+
name|src
operator|+
literal|". Committed blocks are waiting to be minimally replicated."
operator|+
literal|" Try again later."
decl_stmt|;
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|warn
argument_list|(
name|message
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|AlreadyBeingCreatedException
argument_list|(
name|message
argument_list|)
throw|;
case|case
name|UNDER_CONSTRUCTION
case|:
case|case
name|UNDER_RECOVERY
case|:
specifier|final
name|BlockInfoContiguousUnderConstruction
name|uc
init|=
operator|(
name|BlockInfoContiguousUnderConstruction
operator|)
name|lastBlock
decl_stmt|;
comment|// determine if last block was intended to be truncated
name|Block
name|recoveryBlock
init|=
name|uc
operator|.
name|getTruncateBlock
argument_list|()
decl_stmt|;
name|boolean
name|truncateRecovery
init|=
name|recoveryBlock
operator|!=
literal|null
decl_stmt|;
name|boolean
name|copyOnTruncate
init|=
name|truncateRecovery
operator|&&
name|recoveryBlock
operator|.
name|getBlockId
argument_list|()
operator|!=
name|uc
operator|.
name|getBlockId
argument_list|()
decl_stmt|;
assert|assert
operator|!
name|copyOnTruncate
operator|||
name|recoveryBlock
operator|.
name|getBlockId
argument_list|()
operator|<
name|uc
operator|.
name|getBlockId
argument_list|()
operator|&&
name|recoveryBlock
operator|.
name|getGenerationStamp
argument_list|()
operator|<
name|uc
operator|.
name|getGenerationStamp
argument_list|()
operator|&&
name|recoveryBlock
operator|.
name|getNumBytes
argument_list|()
operator|>
name|uc
operator|.
name|getNumBytes
argument_list|()
operator|:
literal|"wrong recoveryBlock"
assert|;
comment|// setup the last block locations from the blockManager if not known
if|if
condition|(
name|uc
operator|.
name|getNumExpectedLocations
argument_list|()
operator|==
literal|0
condition|)
block|{
name|uc
operator|.
name|setExpectedLocations
argument_list|(
name|blockManager
operator|.
name|getStorages
argument_list|(
name|lastBlock
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|uc
operator|.
name|getNumExpectedLocations
argument_list|()
operator|==
literal|0
operator|&&
name|uc
operator|.
name|getNumBytes
argument_list|()
operator|==
literal|0
condition|)
block|{
comment|// There is no datanode reported to this block.
comment|// may be client have crashed before writing data to pipeline.
comment|// This blocks doesn't need any recovery.
comment|// We can remove this block and close the file.
name|pendingFile
operator|.
name|removeLastBlock
argument_list|(
name|lastBlock
argument_list|)
expr_stmt|;
name|finalizeINodeFileUnderConstruction
argument_list|(
name|src
argument_list|,
name|pendingFile
argument_list|,
name|iip
operator|.
name|getLatestSnapshotId
argument_list|()
argument_list|)
expr_stmt|;
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|warn
argument_list|(
literal|"BLOCK* internalReleaseLease: "
operator|+
literal|"Removed empty last block and closed file."
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|// start recovery of the last block for this file
name|long
name|blockRecoveryId
init|=
name|nextGenerationStamp
argument_list|(
name|blockIdManager
operator|.
name|isLegacyBlock
argument_list|(
name|uc
argument_list|)
argument_list|)
decl_stmt|;
name|lease
operator|=
name|reassignLease
argument_list|(
name|lease
argument_list|,
name|src
argument_list|,
name|recoveryLeaseHolder
argument_list|,
name|pendingFile
argument_list|)
expr_stmt|;
if|if
condition|(
name|copyOnTruncate
condition|)
block|{
name|uc
operator|.
name|setGenerationStamp
argument_list|(
name|blockRecoveryId
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|truncateRecovery
condition|)
block|{
name|recoveryBlock
operator|.
name|setGenerationStamp
argument_list|(
name|blockRecoveryId
argument_list|)
expr_stmt|;
block|}
name|uc
operator|.
name|initializeBlockRecovery
argument_list|(
name|blockRecoveryId
argument_list|)
expr_stmt|;
name|leaseManager
operator|.
name|renewLease
argument_list|(
name|lease
argument_list|)
expr_stmt|;
comment|// Cannot close file right now, since the last block requires recovery.
comment|// This may potentially cause infinite loop in lease recovery
comment|// if there are no valid replicas on data-nodes.
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|warn
argument_list|(
literal|"DIR* NameSystem.internalReleaseLease: "
operator|+
literal|"File "
operator|+
name|src
operator|+
literal|" has not been closed."
operator|+
literal|" Lease recovery is in progress. "
operator|+
literal|"RecoveryId = "
operator|+
name|blockRecoveryId
operator|+
literal|" for block "
operator|+
name|lastBlock
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
literal|false
return|;
block|}
DECL|method|reassignLease (Lease lease, String src, String newHolder, INodeFile pendingFile)
specifier|private
name|Lease
name|reassignLease
parameter_list|(
name|Lease
name|lease
parameter_list|,
name|String
name|src
parameter_list|,
name|String
name|newHolder
parameter_list|,
name|INodeFile
name|pendingFile
parameter_list|)
block|{
assert|assert
name|hasWriteLock
argument_list|()
assert|;
if|if
condition|(
name|newHolder
operator|==
literal|null
condition|)
return|return
name|lease
return|;
comment|// The following transaction is not synced. Make sure it's sync'ed later.
name|logReassignLease
argument_list|(
name|lease
operator|.
name|getHolder
argument_list|()
argument_list|,
name|src
argument_list|,
name|newHolder
argument_list|)
expr_stmt|;
return|return
name|reassignLeaseInternal
argument_list|(
name|lease
argument_list|,
name|src
argument_list|,
name|newHolder
argument_list|,
name|pendingFile
argument_list|)
return|;
block|}
DECL|method|reassignLeaseInternal (Lease lease, String src, String newHolder, INodeFile pendingFile)
name|Lease
name|reassignLeaseInternal
parameter_list|(
name|Lease
name|lease
parameter_list|,
name|String
name|src
parameter_list|,
name|String
name|newHolder
parameter_list|,
name|INodeFile
name|pendingFile
parameter_list|)
block|{
assert|assert
name|hasWriteLock
argument_list|()
assert|;
name|pendingFile
operator|.
name|getFileUnderConstructionFeature
argument_list|()
operator|.
name|setClientName
argument_list|(
name|newHolder
argument_list|)
expr_stmt|;
return|return
name|leaseManager
operator|.
name|reassignLease
argument_list|(
name|lease
argument_list|,
name|src
argument_list|,
name|newHolder
argument_list|)
return|;
block|}
DECL|method|commitOrCompleteLastBlock (final INodeFile fileINode, final INodesInPath iip, final Block commitBlock)
specifier|private
name|void
name|commitOrCompleteLastBlock
parameter_list|(
specifier|final
name|INodeFile
name|fileINode
parameter_list|,
specifier|final
name|INodesInPath
name|iip
parameter_list|,
specifier|final
name|Block
name|commitBlock
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|hasWriteLock
argument_list|()
assert|;
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|fileINode
operator|.
name|isUnderConstruction
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|blockManager
operator|.
name|commitOrCompleteLastBlock
argument_list|(
name|fileINode
argument_list|,
name|commitBlock
argument_list|)
condition|)
block|{
return|return;
block|}
comment|// Adjust disk space consumption if required
specifier|final
name|long
name|diff
init|=
name|fileINode
operator|.
name|getPreferredBlockSize
argument_list|()
operator|-
name|commitBlock
operator|.
name|getNumBytes
argument_list|()
decl_stmt|;
if|if
condition|(
name|diff
operator|>
literal|0
condition|)
block|{
try|try
block|{
name|dir
operator|.
name|updateSpaceConsumed
argument_list|(
name|iip
argument_list|,
literal|0
argument_list|,
operator|-
name|diff
argument_list|,
name|fileINode
operator|.
name|getFileReplication
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Unexpected exception while updating disk space."
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|finalizeINodeFileUnderConstruction (String src, INodeFile pendingFile, int latestSnapshot)
specifier|private
name|void
name|finalizeINodeFileUnderConstruction
parameter_list|(
name|String
name|src
parameter_list|,
name|INodeFile
name|pendingFile
parameter_list|,
name|int
name|latestSnapshot
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|hasWriteLock
argument_list|()
assert|;
name|FileUnderConstructionFeature
name|uc
init|=
name|pendingFile
operator|.
name|getFileUnderConstructionFeature
argument_list|()
decl_stmt|;
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|uc
operator|!=
literal|null
argument_list|)
expr_stmt|;
name|leaseManager
operator|.
name|removeLease
argument_list|(
name|uc
operator|.
name|getClientName
argument_list|()
argument_list|,
name|src
argument_list|)
expr_stmt|;
name|pendingFile
operator|.
name|recordModification
argument_list|(
name|latestSnapshot
argument_list|)
expr_stmt|;
comment|// The file is no longer pending.
comment|// Create permanent INode, update blocks. No need to replace the inode here
comment|// since we just remove the uc feature from pendingFile
name|pendingFile
operator|.
name|toCompleteFile
argument_list|(
name|now
argument_list|()
argument_list|)
expr_stmt|;
name|waitForLoadingFSImage
argument_list|()
expr_stmt|;
comment|// close file and persist block allocations for this file
name|closeFile
argument_list|(
name|src
argument_list|,
name|pendingFile
argument_list|)
expr_stmt|;
name|blockManager
operator|.
name|checkReplication
argument_list|(
name|pendingFile
argument_list|)
expr_stmt|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|getStoredBlock (Block block)
name|BlockInfoContiguous
name|getStoredBlock
parameter_list|(
name|Block
name|block
parameter_list|)
block|{
return|return
name|blockManager
operator|.
name|getStoredBlock
argument_list|(
name|block
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|isInSnapshot (BlockInfoContiguousUnderConstruction blockUC)
specifier|public
name|boolean
name|isInSnapshot
parameter_list|(
name|BlockInfoContiguousUnderConstruction
name|blockUC
parameter_list|)
block|{
assert|assert
name|hasReadLock
argument_list|()
assert|;
specifier|final
name|BlockCollection
name|bc
init|=
name|blockUC
operator|.
name|getBlockCollection
argument_list|()
decl_stmt|;
if|if
condition|(
name|bc
operator|==
literal|null
operator|||
operator|!
operator|(
name|bc
operator|instanceof
name|INodeFile
operator|)
operator|||
operator|!
name|bc
operator|.
name|isUnderConstruction
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
name|String
name|fullName
init|=
name|bc
operator|.
name|getName
argument_list|()
decl_stmt|;
try|try
block|{
if|if
condition|(
name|fullName
operator|!=
literal|null
operator|&&
name|fullName
operator|.
name|startsWith
argument_list|(
name|Path
operator|.
name|SEPARATOR
argument_list|)
operator|&&
name|dir
operator|.
name|getINode
argument_list|(
name|fullName
argument_list|)
operator|==
name|bc
condition|)
block|{
comment|// If file exists in normal path then no need to look in snapshot
return|return
literal|false
return|;
block|}
block|}
catch|catch
parameter_list|(
name|UnresolvedLinkException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Error while resolving the link : "
operator|+
name|fullName
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|/*      * 1. if bc is under construction and also with snapshot, and      * bc is not in the current fsdirectory tree, bc must represent a snapshot      * file.       * 2. if fullName is not an absolute path, bc cannot be existent in the       * current fsdirectory tree.       * 3. if bc is not the current node associated with fullName, bc must be a      * snapshot inode.      */
return|return
literal|true
return|;
block|}
DECL|method|commitBlockSynchronization (ExtendedBlock oldBlock, long newgenerationstamp, long newlength, boolean closeFile, boolean deleteblock, DatanodeID[] newtargets, String[] newtargetstorages)
name|void
name|commitBlockSynchronization
parameter_list|(
name|ExtendedBlock
name|oldBlock
parameter_list|,
name|long
name|newgenerationstamp
parameter_list|,
name|long
name|newlength
parameter_list|,
name|boolean
name|closeFile
parameter_list|,
name|boolean
name|deleteblock
parameter_list|,
name|DatanodeID
index|[]
name|newtargets
parameter_list|,
name|String
index|[]
name|newtargetstorages
parameter_list|)
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"commitBlockSynchronization(oldBlock="
operator|+
name|oldBlock
operator|+
literal|", newgenerationstamp="
operator|+
name|newgenerationstamp
operator|+
literal|", newlength="
operator|+
name|newlength
operator|+
literal|", newtargets="
operator|+
name|Arrays
operator|.
name|asList
argument_list|(
name|newtargets
argument_list|)
operator|+
literal|", closeFile="
operator|+
name|closeFile
operator|+
literal|", deleteBlock="
operator|+
name|deleteblock
operator|+
literal|")"
argument_list|)
expr_stmt|;
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|String
name|src
init|=
literal|""
decl_stmt|;
name|waitForLoadingFSImage
argument_list|()
expr_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
name|boolean
name|copyTruncate
init|=
literal|false
decl_stmt|;
name|BlockInfoContiguousUnderConstruction
name|truncatedBlock
init|=
literal|null
decl_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
comment|// If a DN tries to commit to the standby, the recovery will
comment|// fail, and the next retry will succeed on the new NN.
name|checkNameNodeSafeMode
argument_list|(
literal|"Cannot commitBlockSynchronization while in safe mode"
argument_list|)
expr_stmt|;
specifier|final
name|BlockInfoContiguous
name|storedBlock
init|=
name|getStoredBlock
argument_list|(
name|ExtendedBlock
operator|.
name|getLocalBlock
argument_list|(
name|oldBlock
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|storedBlock
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|deleteblock
condition|)
block|{
comment|// This may be a retry attempt so ignore the failure
comment|// to locate the block.
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Block (="
operator|+
name|oldBlock
operator|+
literal|") not found"
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
else|else
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Block (="
operator|+
name|oldBlock
operator|+
literal|") not found"
argument_list|)
throw|;
block|}
block|}
specifier|final
name|long
name|oldGenerationStamp
init|=
name|storedBlock
operator|.
name|getGenerationStamp
argument_list|()
decl_stmt|;
specifier|final
name|long
name|oldNumBytes
init|=
name|storedBlock
operator|.
name|getNumBytes
argument_list|()
decl_stmt|;
comment|//
comment|// The implementation of delete operation (see @deleteInternal method)
comment|// first removes the file paths from namespace, and delays the removal
comment|// of blocks to later time for better performance. When
comment|// commitBlockSynchronization (this method) is called in between, the
comment|// blockCollection of storedBlock could have been assigned to null by
comment|// the delete operation, throw IOException here instead of NPE; if the
comment|// file path is already removed from namespace by the delete operation,
comment|// throw FileNotFoundException here, so not to proceed to the end of
comment|// this method to add a CloseOp to the edit log for an already deleted
comment|// file (See HDFS-6825).
comment|//
if|if
condition|(
name|storedBlock
operator|.
name|isDeleted
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"The blockCollection of "
operator|+
name|storedBlock
operator|+
literal|" is null, likely because the file owning this block was"
operator|+
literal|" deleted and the block removal is delayed"
argument_list|)
throw|;
block|}
name|INodeFile
name|iFile
init|=
operator|(
operator|(
name|INode
operator|)
name|storedBlock
operator|.
name|getBlockCollection
argument_list|()
operator|)
operator|.
name|asFile
argument_list|()
decl_stmt|;
if|if
condition|(
name|isFileDeleted
argument_list|(
name|iFile
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|FileNotFoundException
argument_list|(
literal|"File not found: "
operator|+
name|iFile
operator|.
name|getFullPathName
argument_list|()
operator|+
literal|", likely due to delayed block"
operator|+
literal|" removal"
argument_list|)
throw|;
block|}
if|if
condition|(
operator|(
operator|!
name|iFile
operator|.
name|isUnderConstruction
argument_list|()
operator|||
name|storedBlock
operator|.
name|isComplete
argument_list|()
operator|)
operator|&&
name|iFile
operator|.
name|getLastBlock
argument_list|()
operator|.
name|isComplete
argument_list|()
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Unexpected block (="
operator|+
name|oldBlock
operator|+
literal|") since the file (="
operator|+
name|iFile
operator|.
name|getLocalName
argument_list|()
operator|+
literal|") is not under construction"
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
name|truncatedBlock
operator|=
operator|(
name|BlockInfoContiguousUnderConstruction
operator|)
name|iFile
operator|.
name|getLastBlock
argument_list|()
expr_stmt|;
name|long
name|recoveryId
init|=
name|truncatedBlock
operator|.
name|getBlockRecoveryId
argument_list|()
decl_stmt|;
name|copyTruncate
operator|=
name|truncatedBlock
operator|.
name|getBlockId
argument_list|()
operator|!=
name|storedBlock
operator|.
name|getBlockId
argument_list|()
expr_stmt|;
if|if
condition|(
name|recoveryId
operator|!=
name|newgenerationstamp
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"The recovery id "
operator|+
name|newgenerationstamp
operator|+
literal|" does not match current recovery id "
operator|+
name|recoveryId
operator|+
literal|" for block "
operator|+
name|oldBlock
argument_list|)
throw|;
block|}
if|if
condition|(
name|deleteblock
condition|)
block|{
name|Block
name|blockToDel
init|=
name|ExtendedBlock
operator|.
name|getLocalBlock
argument_list|(
name|oldBlock
argument_list|)
decl_stmt|;
name|boolean
name|remove
init|=
name|iFile
operator|.
name|removeLastBlock
argument_list|(
name|blockToDel
argument_list|)
decl_stmt|;
if|if
condition|(
name|remove
condition|)
block|{
name|blockManager
operator|.
name|removeBlock
argument_list|(
name|storedBlock
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// update last block
if|if
condition|(
operator|!
name|copyTruncate
condition|)
block|{
name|storedBlock
operator|.
name|setGenerationStamp
argument_list|(
name|newgenerationstamp
argument_list|)
expr_stmt|;
name|storedBlock
operator|.
name|setNumBytes
argument_list|(
name|newlength
argument_list|)
expr_stmt|;
block|}
comment|// find the DatanodeDescriptor objects
name|ArrayList
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|trimmedTargets
init|=
operator|new
name|ArrayList
argument_list|<
name|DatanodeDescriptor
argument_list|>
argument_list|(
name|newtargets
operator|.
name|length
argument_list|)
decl_stmt|;
name|ArrayList
argument_list|<
name|String
argument_list|>
name|trimmedStorages
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|(
name|newtargets
operator|.
name|length
argument_list|)
decl_stmt|;
if|if
condition|(
name|newtargets
operator|.
name|length
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|newtargets
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
comment|// try to get targetNode
name|DatanodeDescriptor
name|targetNode
init|=
name|blockManager
operator|.
name|getDatanodeManager
argument_list|()
operator|.
name|getDatanode
argument_list|(
name|newtargets
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|targetNode
operator|!=
literal|null
condition|)
block|{
name|trimmedTargets
operator|.
name|add
argument_list|(
name|targetNode
argument_list|)
expr_stmt|;
name|trimmedStorages
operator|.
name|add
argument_list|(
name|newtargetstorages
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"DatanodeDescriptor (="
operator|+
name|newtargets
index|[
name|i
index|]
operator|+
literal|") not found"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|(
name|closeFile
operator|)
operator|&&
operator|!
name|trimmedTargets
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// the file is getting closed. Insert block locations into blockManager.
comment|// Otherwise fsck will report these blocks as MISSING, especially if the
comment|// blocksReceived from Datanodes take a long time to arrive.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|trimmedTargets
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|DatanodeStorageInfo
name|storageInfo
init|=
name|trimmedTargets
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getStorageInfo
argument_list|(
name|trimmedStorages
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|storageInfo
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|copyTruncate
condition|)
block|{
name|storageInfo
operator|.
name|addBlock
argument_list|(
name|truncatedBlock
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|storageInfo
operator|.
name|addBlock
argument_list|(
name|storedBlock
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|// add pipeline locations into the INodeUnderConstruction
name|DatanodeStorageInfo
index|[]
name|trimmedStorageInfos
init|=
name|blockManager
operator|.
name|getDatanodeManager
argument_list|()
operator|.
name|getDatanodeStorageInfos
argument_list|(
name|trimmedTargets
operator|.
name|toArray
argument_list|(
operator|new
name|DatanodeID
index|[
name|trimmedTargets
operator|.
name|size
argument_list|()
index|]
argument_list|)
argument_list|,
name|trimmedStorages
operator|.
name|toArray
argument_list|(
operator|new
name|String
index|[
name|trimmedStorages
operator|.
name|size
argument_list|()
index|]
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|copyTruncate
condition|)
block|{
name|iFile
operator|.
name|setLastBlock
argument_list|(
name|truncatedBlock
argument_list|,
name|trimmedStorageInfos
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|iFile
operator|.
name|setLastBlock
argument_list|(
name|storedBlock
argument_list|,
name|trimmedStorageInfos
argument_list|)
expr_stmt|;
if|if
condition|(
name|closeFile
condition|)
block|{
name|blockManager
operator|.
name|markBlockReplicasAsCorrupt
argument_list|(
name|storedBlock
argument_list|,
name|oldGenerationStamp
argument_list|,
name|oldNumBytes
argument_list|,
name|trimmedStorageInfos
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|closeFile
condition|)
block|{
if|if
condition|(
name|copyTruncate
condition|)
block|{
name|src
operator|=
name|closeFileCommitBlocks
argument_list|(
name|iFile
argument_list|,
name|truncatedBlock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|iFile
operator|.
name|isBlockInLatestSnapshot
argument_list|(
name|storedBlock
argument_list|)
condition|)
block|{
name|blockManager
operator|.
name|removeBlock
argument_list|(
name|storedBlock
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|src
operator|=
name|closeFileCommitBlocks
argument_list|(
name|iFile
argument_list|,
name|storedBlock
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// If this commit does not want to close the file, persist blocks
name|src
operator|=
name|iFile
operator|.
name|getFullPathName
argument_list|()
expr_stmt|;
name|persistBlocks
argument_list|(
name|src
argument_list|,
name|iFile
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
name|getEditLog
argument_list|()
operator|.
name|logSync
argument_list|()
expr_stmt|;
if|if
condition|(
name|closeFile
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"commitBlockSynchronization(oldBlock="
operator|+
name|oldBlock
operator|+
literal|", file="
operator|+
name|src
operator|+
operator|(
name|copyTruncate
condition|?
literal|", newBlock="
operator|+
name|truncatedBlock
else|:
literal|", newgenerationstamp="
operator|+
name|newgenerationstamp
operator|)
operator|+
literal|", newlength="
operator|+
name|newlength
operator|+
literal|", newtargets="
operator|+
name|Arrays
operator|.
name|asList
argument_list|(
name|newtargets
argument_list|)
operator|+
literal|") successful"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"commitBlockSynchronization("
operator|+
name|oldBlock
operator|+
literal|") successful"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * @param pendingFile open file that needs to be closed    * @param storedBlock last block    * @return Path of the file that was closed.    * @throws IOException on error    */
annotation|@
name|VisibleForTesting
DECL|method|closeFileCommitBlocks (INodeFile pendingFile, BlockInfoContiguous storedBlock)
name|String
name|closeFileCommitBlocks
parameter_list|(
name|INodeFile
name|pendingFile
parameter_list|,
name|BlockInfoContiguous
name|storedBlock
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|INodesInPath
name|iip
init|=
name|INodesInPath
operator|.
name|fromINode
argument_list|(
name|pendingFile
argument_list|)
decl_stmt|;
specifier|final
name|String
name|src
init|=
name|iip
operator|.
name|getPath
argument_list|()
decl_stmt|;
comment|// commit the last block and complete it if it has minimum replicas
name|commitOrCompleteLastBlock
argument_list|(
name|pendingFile
argument_list|,
name|iip
argument_list|,
name|storedBlock
argument_list|)
expr_stmt|;
comment|//remove lease, close file
name|finalizeINodeFileUnderConstruction
argument_list|(
name|src
argument_list|,
name|pendingFile
argument_list|,
name|Snapshot
operator|.
name|findLatestSnapshot
argument_list|(
name|pendingFile
argument_list|,
name|Snapshot
operator|.
name|CURRENT_STATE_ID
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|src
return|;
block|}
comment|/**    * Renew the lease(s) held by the given client    */
DECL|method|renewLease (String holder)
name|void
name|renewLease
parameter_list|(
name|String
name|holder
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|checkNameNodeSafeMode
argument_list|(
literal|"Cannot renew lease for "
operator|+
name|holder
argument_list|)
expr_stmt|;
name|leaseManager
operator|.
name|renewLease
argument_list|(
name|holder
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Get a partial listing of the indicated directory    *    * @param src the directory name    * @param startAfter the name to start after    * @param needLocation if blockLocations need to be returned    * @return a partial listing starting after startAfter    *     * @throws AccessControlException if access is denied    * @throws UnresolvedLinkException if symbolic link is encountered    * @throws IOException if other I/O error occurred    */
DECL|method|getListing (String src, byte[] startAfter, boolean needLocation)
name|DirectoryListing
name|getListing
parameter_list|(
name|String
name|src
parameter_list|,
name|byte
index|[]
name|startAfter
parameter_list|,
name|boolean
name|needLocation
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|READ
argument_list|)
expr_stmt|;
name|DirectoryListing
name|dl
init|=
literal|null
decl_stmt|;
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|NameNode
operator|.
name|OperationCategory
operator|.
name|READ
argument_list|)
expr_stmt|;
name|dl
operator|=
name|FSDirStatAndListingOp
operator|.
name|getListingInt
argument_list|(
name|dir
argument_list|,
name|src
argument_list|,
name|startAfter
argument_list|,
name|needLocation
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|AccessControlException
name|e
parameter_list|)
block|{
name|logAuditEvent
argument_list|(
literal|false
argument_list|,
literal|"listStatus"
argument_list|,
name|src
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
name|logAuditEvent
argument_list|(
literal|true
argument_list|,
literal|"listStatus"
argument_list|,
name|src
argument_list|)
expr_stmt|;
return|return
name|dl
return|;
block|}
comment|/////////////////////////////////////////////////////////
comment|//
comment|// These methods are called by datanodes
comment|//
comment|/////////////////////////////////////////////////////////
comment|/**    * Register Datanode.    *<p>    * The purpose of registration is to identify whether the new datanode    * serves a new data storage, and will report new data block copies,    * which the namenode was not aware of; or the datanode is a replacement    * node for the data storage that was previously served by a different    * or the same (in terms of host:port) datanode.    * The data storages are distinguished by their storageIDs. When a new    * data storage is reported the namenode issues a new unique storageID.    *<p>    * Finally, the namenode returns its namespaceID as the registrationID    * for the datanodes.     * namespaceID is a persistent attribute of the name space.    * The registrationID is checked every time the datanode is communicating    * with the namenode.     * Datanodes with inappropriate registrationID are rejected.    * If the namenode stops, and then restarts it can restore its     * namespaceID and will continue serving the datanodes that has previously    * registered with the namenode without restarting the whole cluster.    *     * @see org.apache.hadoop.hdfs.server.datanode.DataNode    */
DECL|method|registerDatanode (DatanodeRegistration nodeReg)
name|void
name|registerDatanode
parameter_list|(
name|DatanodeRegistration
name|nodeReg
parameter_list|)
throws|throws
name|IOException
block|{
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|getBlockManager
argument_list|()
operator|.
name|getDatanodeManager
argument_list|()
operator|.
name|registerDatanode
argument_list|(
name|nodeReg
argument_list|)
expr_stmt|;
name|checkSafeMode
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Get registrationID for datanodes based on the namespaceID.    *     * @see #registerDatanode(DatanodeRegistration)    * @return registration ID    */
DECL|method|getRegistrationID ()
name|String
name|getRegistrationID
parameter_list|()
block|{
return|return
name|Storage
operator|.
name|getRegistrationID
argument_list|(
name|getFSImage
argument_list|()
operator|.
name|getStorage
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * The given node has reported in.  This method should:    * 1) Record the heartbeat, so the datanode isn't timed out    * 2) Adjust usage stats for future block allocation    *     * If a substantial amount of time passed since the last datanode     * heartbeat then request an immediate block report.      *     * @return an array of datanode commands     * @throws IOException    */
DECL|method|handleHeartbeat (DatanodeRegistration nodeReg, StorageReport[] reports, long cacheCapacity, long cacheUsed, int xceiverCount, int xmitsInProgress, int failedVolumes, VolumeFailureSummary volumeFailureSummary)
name|HeartbeatResponse
name|handleHeartbeat
parameter_list|(
name|DatanodeRegistration
name|nodeReg
parameter_list|,
name|StorageReport
index|[]
name|reports
parameter_list|,
name|long
name|cacheCapacity
parameter_list|,
name|long
name|cacheUsed
parameter_list|,
name|int
name|xceiverCount
parameter_list|,
name|int
name|xmitsInProgress
parameter_list|,
name|int
name|failedVolumes
parameter_list|,
name|VolumeFailureSummary
name|volumeFailureSummary
parameter_list|)
throws|throws
name|IOException
block|{
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
comment|//get datanode commands
specifier|final
name|int
name|maxTransfer
init|=
name|blockManager
operator|.
name|getMaxReplicationStreams
argument_list|()
operator|-
name|xmitsInProgress
decl_stmt|;
name|DatanodeCommand
index|[]
name|cmds
init|=
name|blockManager
operator|.
name|getDatanodeManager
argument_list|()
operator|.
name|handleHeartbeat
argument_list|(
name|nodeReg
argument_list|,
name|reports
argument_list|,
name|blockPoolId
argument_list|,
name|cacheCapacity
argument_list|,
name|cacheUsed
argument_list|,
name|xceiverCount
argument_list|,
name|maxTransfer
argument_list|,
name|failedVolumes
argument_list|,
name|volumeFailureSummary
argument_list|)
decl_stmt|;
comment|//create ha status
specifier|final
name|NNHAStatusHeartbeat
name|haState
init|=
operator|new
name|NNHAStatusHeartbeat
argument_list|(
name|haContext
operator|.
name|getState
argument_list|()
operator|.
name|getServiceState
argument_list|()
argument_list|,
name|getFSImage
argument_list|()
operator|.
name|getLastAppliedOrWrittenTxId
argument_list|()
argument_list|)
decl_stmt|;
return|return
operator|new
name|HeartbeatResponse
argument_list|(
name|cmds
argument_list|,
name|haState
argument_list|,
name|rollingUpgradeInfo
argument_list|)
return|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Returns whether or not there were available resources at the last check of    * resources.    *    * @return true if there were sufficient resources available, false otherwise.    */
DECL|method|nameNodeHasResourcesAvailable ()
name|boolean
name|nameNodeHasResourcesAvailable
parameter_list|()
block|{
return|return
name|hasResourcesAvailable
return|;
block|}
comment|/**    * Perform resource checks and cache the results.    */
DECL|method|checkAvailableResources ()
name|void
name|checkAvailableResources
parameter_list|()
block|{
name|Preconditions
operator|.
name|checkState
argument_list|(
name|nnResourceChecker
operator|!=
literal|null
argument_list|,
literal|"nnResourceChecker not initialized"
argument_list|)
expr_stmt|;
name|hasResourcesAvailable
operator|=
name|nnResourceChecker
operator|.
name|hasAvailableDiskSpace
argument_list|()
expr_stmt|;
block|}
comment|/**    * Persist the block list for the inode.    * @param path    * @param file    * @param logRetryCache    */
DECL|method|persistBlocks (String path, INodeFile file, boolean logRetryCache)
specifier|private
name|void
name|persistBlocks
parameter_list|(
name|String
name|path
parameter_list|,
name|INodeFile
name|file
parameter_list|,
name|boolean
name|logRetryCache
parameter_list|)
block|{
assert|assert
name|hasWriteLock
argument_list|()
assert|;
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|file
operator|.
name|isUnderConstruction
argument_list|()
argument_list|)
expr_stmt|;
name|getEditLog
argument_list|()
operator|.
name|logUpdateBlocks
argument_list|(
name|path
argument_list|,
name|file
argument_list|,
name|logRetryCache
argument_list|)
expr_stmt|;
if|if
condition|(
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|debug
argument_list|(
literal|"persistBlocks: "
operator|+
name|path
operator|+
literal|" with "
operator|+
name|file
operator|.
name|getBlocks
argument_list|()
operator|.
name|length
operator|+
literal|" blocks is persisted to"
operator|+
literal|" the file system"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Close file.    * @param path    * @param file    */
DECL|method|closeFile (String path, INodeFile file)
specifier|private
name|void
name|closeFile
parameter_list|(
name|String
name|path
parameter_list|,
name|INodeFile
name|file
parameter_list|)
block|{
assert|assert
name|hasWriteLock
argument_list|()
assert|;
name|waitForLoadingFSImage
argument_list|()
expr_stmt|;
comment|// file is closed
name|getEditLog
argument_list|()
operator|.
name|logCloseFile
argument_list|(
name|path
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|debug
argument_list|(
literal|"closeFile: "
operator|+
name|path
operator|+
literal|" with "
operator|+
name|file
operator|.
name|getBlocks
argument_list|()
operator|.
name|length
operator|+
literal|" blocks is persisted to the file system"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Periodically calls hasAvailableResources of NameNodeResourceChecker, and if    * there are found to be insufficient resources available, causes the NN to    * enter safe mode. If resources are later found to have returned to    * acceptable levels, this daemon will cause the NN to exit safe mode.    */
DECL|class|NameNodeResourceMonitor
class|class
name|NameNodeResourceMonitor
implements|implements
name|Runnable
block|{
DECL|field|shouldNNRmRun
name|boolean
name|shouldNNRmRun
init|=
literal|true
decl_stmt|;
annotation|@
name|Override
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
try|try
block|{
while|while
condition|(
name|fsRunning
operator|&&
name|shouldNNRmRun
condition|)
block|{
name|checkAvailableResources
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|nameNodeHasResourcesAvailable
argument_list|()
condition|)
block|{
name|String
name|lowResourcesMsg
init|=
literal|"NameNode low on available disk space. "
decl_stmt|;
if|if
condition|(
operator|!
name|isInSafeMode
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|lowResourcesMsg
operator|+
literal|"Entering safe mode."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|lowResourcesMsg
operator|+
literal|"Already in safe mode."
argument_list|)
expr_stmt|;
block|}
name|enterSafeMode
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|resourceRecheckInterval
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
comment|// Deliberately ignore
block|}
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|FSNamesystem
operator|.
name|LOG
operator|.
name|error
argument_list|(
literal|"Exception in NameNodeResourceMonitor: "
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|stopMonitor ()
specifier|public
name|void
name|stopMonitor
parameter_list|()
block|{
name|shouldNNRmRun
operator|=
literal|false
expr_stmt|;
block|}
block|}
DECL|class|NameNodeEditLogRoller
class|class
name|NameNodeEditLogRoller
implements|implements
name|Runnable
block|{
DECL|field|shouldRun
specifier|private
name|boolean
name|shouldRun
init|=
literal|true
decl_stmt|;
DECL|field|rollThreshold
specifier|private
specifier|final
name|long
name|rollThreshold
decl_stmt|;
DECL|field|sleepIntervalMs
specifier|private
specifier|final
name|long
name|sleepIntervalMs
decl_stmt|;
DECL|method|NameNodeEditLogRoller (long rollThreshold, int sleepIntervalMs)
specifier|public
name|NameNodeEditLogRoller
parameter_list|(
name|long
name|rollThreshold
parameter_list|,
name|int
name|sleepIntervalMs
parameter_list|)
block|{
name|this
operator|.
name|rollThreshold
operator|=
name|rollThreshold
expr_stmt|;
name|this
operator|.
name|sleepIntervalMs
operator|=
name|sleepIntervalMs
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
while|while
condition|(
name|fsRunning
operator|&&
name|shouldRun
condition|)
block|{
try|try
block|{
name|FSEditLog
name|editLog
init|=
name|getFSImage
argument_list|()
operator|.
name|getEditLog
argument_list|()
decl_stmt|;
name|long
name|numEdits
init|=
name|editLog
operator|.
name|getLastWrittenTxId
argument_list|()
operator|-
name|editLog
operator|.
name|getCurSegmentTxId
argument_list|()
decl_stmt|;
if|if
condition|(
name|numEdits
operator|>
name|rollThreshold
condition|)
block|{
name|FSNamesystem
operator|.
name|LOG
operator|.
name|info
argument_list|(
literal|"NameNode rolling its own edit log because"
operator|+
literal|" number of edits in open segment exceeds threshold of "
operator|+
name|rollThreshold
argument_list|)
expr_stmt|;
name|rollEditLog
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|FSNamesystem
operator|.
name|LOG
operator|.
name|error
argument_list|(
literal|"Swallowing exception in "
operator|+
name|NameNodeEditLogRoller
operator|.
name|class
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|":"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|sleepIntervalMs
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|FSNamesystem
operator|.
name|LOG
operator|.
name|info
argument_list|(
name|NameNodeEditLogRoller
operator|.
name|class
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|" was interrupted, exiting"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
DECL|method|stop ()
specifier|public
name|void
name|stop
parameter_list|()
block|{
name|shouldRun
operator|=
literal|false
expr_stmt|;
block|}
block|}
comment|/**    * Daemon to periodically scan the namespace for lazyPersist files    * with missing blocks and unlink them.    */
DECL|class|LazyPersistFileScrubber
class|class
name|LazyPersistFileScrubber
implements|implements
name|Runnable
block|{
DECL|field|shouldRun
specifier|private
specifier|volatile
name|boolean
name|shouldRun
init|=
literal|true
decl_stmt|;
DECL|field|scrubIntervalSec
specifier|final
name|int
name|scrubIntervalSec
decl_stmt|;
DECL|method|LazyPersistFileScrubber (final int scrubIntervalSec)
specifier|public
name|LazyPersistFileScrubber
parameter_list|(
specifier|final
name|int
name|scrubIntervalSec
parameter_list|)
block|{
name|this
operator|.
name|scrubIntervalSec
operator|=
name|scrubIntervalSec
expr_stmt|;
block|}
comment|/**      * Periodically go over the list of lazyPersist files with missing      * blocks and unlink them from the namespace.      */
DECL|method|clearCorruptLazyPersistFiles ()
specifier|private
name|void
name|clearCorruptLazyPersistFiles
parameter_list|()
throws|throws
name|IOException
block|{
name|BlockStoragePolicy
name|lpPolicy
init|=
name|blockManager
operator|.
name|getStoragePolicy
argument_list|(
literal|"LAZY_PERSIST"
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|BlockCollection
argument_list|>
name|filesToDelete
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|boolean
name|changed
init|=
literal|false
decl_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
specifier|final
name|Iterator
argument_list|<
name|Block
argument_list|>
name|it
init|=
name|blockManager
operator|.
name|getCorruptReplicaBlockIterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Block
name|b
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|BlockInfoContiguous
name|blockInfo
init|=
name|blockManager
operator|.
name|getStoredBlock
argument_list|(
name|b
argument_list|)
decl_stmt|;
if|if
condition|(
name|blockInfo
operator|.
name|getBlockCollection
argument_list|()
operator|.
name|getStoragePolicyID
argument_list|()
operator|==
name|lpPolicy
operator|.
name|getId
argument_list|()
condition|)
block|{
name|filesToDelete
operator|.
name|add
argument_list|(
name|blockInfo
operator|.
name|getBlockCollection
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|BlockCollection
name|bc
range|:
name|filesToDelete
control|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Removing lazyPersist file "
operator|+
name|bc
operator|.
name|getName
argument_list|()
operator|+
literal|" with no replicas."
argument_list|)
expr_stmt|;
name|BlocksMapUpdateInfo
name|toRemoveBlocks
init|=
name|FSDirDeleteOp
operator|.
name|deleteInternal
argument_list|(
name|FSNamesystem
operator|.
name|this
argument_list|,
name|bc
operator|.
name|getName
argument_list|()
argument_list|,
name|INodesInPath
operator|.
name|fromINode
argument_list|(
operator|(
name|INodeFile
operator|)
name|bc
argument_list|)
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|changed
operator||=
name|toRemoveBlocks
operator|!=
literal|null
expr_stmt|;
if|if
condition|(
name|toRemoveBlocks
operator|!=
literal|null
condition|)
block|{
name|removeBlocks
argument_list|(
name|toRemoveBlocks
argument_list|)
expr_stmt|;
comment|// Incremental deletion of blocks
block|}
block|}
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|changed
condition|)
block|{
name|getEditLog
argument_list|()
operator|.
name|logSync
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
while|while
condition|(
name|fsRunning
operator|&&
name|shouldRun
condition|)
block|{
try|try
block|{
name|clearCorruptLazyPersistFiles
argument_list|()
expr_stmt|;
name|Thread
operator|.
name|sleep
argument_list|(
name|scrubIntervalSec
operator|*
literal|1000
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|FSNamesystem
operator|.
name|LOG
operator|.
name|info
argument_list|(
literal|"LazyPersistFileScrubber was interrupted, exiting"
argument_list|)
expr_stmt|;
break|break;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|FSNamesystem
operator|.
name|LOG
operator|.
name|error
argument_list|(
literal|"Ignoring exception in LazyPersistFileScrubber:"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|stop ()
specifier|public
name|void
name|stop
parameter_list|()
block|{
name|shouldRun
operator|=
literal|false
expr_stmt|;
block|}
block|}
DECL|method|getFSImage ()
specifier|public
name|FSImage
name|getFSImage
parameter_list|()
block|{
return|return
name|fsImage
return|;
block|}
DECL|method|getEditLog ()
specifier|public
name|FSEditLog
name|getEditLog
parameter_list|()
block|{
return|return
name|getFSImage
argument_list|()
operator|.
name|getEditLog
argument_list|()
return|;
block|}
DECL|method|checkBlock (ExtendedBlock block)
specifier|private
name|void
name|checkBlock
parameter_list|(
name|ExtendedBlock
name|block
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|block
operator|!=
literal|null
operator|&&
operator|!
name|this
operator|.
name|blockPoolId
operator|.
name|equals
argument_list|(
name|block
operator|.
name|getBlockPoolId
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unexpected BlockPoolId "
operator|+
name|block
operator|.
name|getBlockPoolId
argument_list|()
operator|+
literal|" - expected "
operator|+
name|blockPoolId
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Metric
argument_list|(
block|{
literal|"MissingBlocks"
block|,
literal|"Number of missing blocks"
block|}
argument_list|)
DECL|method|getMissingBlocksCount ()
specifier|public
name|long
name|getMissingBlocksCount
parameter_list|()
block|{
comment|// not locking
return|return
name|blockManager
operator|.
name|getMissingBlocksCount
argument_list|()
return|;
block|}
annotation|@
name|Metric
argument_list|(
block|{
literal|"MissingReplOneBlocks"
block|,
literal|"Number of missing blocks "
operator|+
literal|"with replication factor 1"
block|}
argument_list|)
DECL|method|getMissingReplOneBlocksCount ()
specifier|public
name|long
name|getMissingReplOneBlocksCount
parameter_list|()
block|{
comment|// not locking
return|return
name|blockManager
operator|.
name|getMissingReplOneBlocksCount
argument_list|()
return|;
block|}
annotation|@
name|Metric
argument_list|(
block|{
literal|"ExpiredHeartbeats"
block|,
literal|"Number of expired heartbeats"
block|}
argument_list|)
DECL|method|getExpiredHeartbeats ()
specifier|public
name|int
name|getExpiredHeartbeats
parameter_list|()
block|{
return|return
name|datanodeStatistics
operator|.
name|getExpiredHeartbeats
argument_list|()
return|;
block|}
annotation|@
name|Metric
argument_list|(
block|{
literal|"TransactionsSinceLastCheckpoint"
block|,
literal|"Number of transactions since last checkpoint"
block|}
argument_list|)
DECL|method|getTransactionsSinceLastCheckpoint ()
specifier|public
name|long
name|getTransactionsSinceLastCheckpoint
parameter_list|()
block|{
return|return
name|getFSImage
argument_list|()
operator|.
name|getLastAppliedOrWrittenTxId
argument_list|()
operator|-
name|getFSImage
argument_list|()
operator|.
name|getStorage
argument_list|()
operator|.
name|getMostRecentCheckpointTxId
argument_list|()
return|;
block|}
annotation|@
name|Metric
argument_list|(
block|{
literal|"TransactionsSinceLastLogRoll"
block|,
literal|"Number of transactions since last edit log roll"
block|}
argument_list|)
DECL|method|getTransactionsSinceLastLogRoll ()
specifier|public
name|long
name|getTransactionsSinceLastLogRoll
parameter_list|()
block|{
if|if
condition|(
name|isInStandbyState
argument_list|()
operator|||
operator|!
name|getEditLog
argument_list|()
operator|.
name|isSegmentOpen
argument_list|()
condition|)
block|{
return|return
literal|0
return|;
block|}
else|else
block|{
return|return
name|getEditLog
argument_list|()
operator|.
name|getLastWrittenTxId
argument_list|()
operator|-
name|getEditLog
argument_list|()
operator|.
name|getCurSegmentTxId
argument_list|()
operator|+
literal|1
return|;
block|}
block|}
annotation|@
name|Metric
argument_list|(
block|{
literal|"LastWrittenTransactionId"
block|,
literal|"Transaction ID written to the edit log"
block|}
argument_list|)
DECL|method|getLastWrittenTransactionId ()
specifier|public
name|long
name|getLastWrittenTransactionId
parameter_list|()
block|{
return|return
name|getEditLog
argument_list|()
operator|.
name|getLastWrittenTxId
argument_list|()
return|;
block|}
annotation|@
name|Metric
argument_list|(
block|{
literal|"LastCheckpointTime"
block|,
literal|"Time in milliseconds since the epoch of the last checkpoint"
block|}
argument_list|)
DECL|method|getLastCheckpointTime ()
specifier|public
name|long
name|getLastCheckpointTime
parameter_list|()
block|{
return|return
name|getFSImage
argument_list|()
operator|.
name|getStorage
argument_list|()
operator|.
name|getMostRecentCheckpointTime
argument_list|()
return|;
block|}
comment|/** @see ClientProtocol#getStats() */
DECL|method|getStats ()
name|long
index|[]
name|getStats
parameter_list|()
block|{
specifier|final
name|long
index|[]
name|stats
init|=
name|datanodeStatistics
operator|.
name|getStats
argument_list|()
decl_stmt|;
name|stats
index|[
name|ClientProtocol
operator|.
name|GET_STATS_UNDER_REPLICATED_IDX
index|]
operator|=
name|getUnderReplicatedBlocks
argument_list|()
expr_stmt|;
name|stats
index|[
name|ClientProtocol
operator|.
name|GET_STATS_CORRUPT_BLOCKS_IDX
index|]
operator|=
name|getCorruptReplicaBlocks
argument_list|()
expr_stmt|;
name|stats
index|[
name|ClientProtocol
operator|.
name|GET_STATS_MISSING_BLOCKS_IDX
index|]
operator|=
name|getMissingBlocksCount
argument_list|()
expr_stmt|;
name|stats
index|[
name|ClientProtocol
operator|.
name|GET_STATS_MISSING_REPL_ONE_BLOCKS_IDX
index|]
operator|=
name|getMissingReplOneBlocksCount
argument_list|()
expr_stmt|;
return|return
name|stats
return|;
block|}
annotation|@
name|Override
comment|// FSNamesystemMBean
annotation|@
name|Metric
argument_list|(
block|{
literal|"CapacityTotal"
block|,
literal|"Total raw capacity of data nodes in bytes"
block|}
argument_list|)
DECL|method|getCapacityTotal ()
specifier|public
name|long
name|getCapacityTotal
parameter_list|()
block|{
return|return
name|datanodeStatistics
operator|.
name|getCapacityTotal
argument_list|()
return|;
block|}
annotation|@
name|Metric
argument_list|(
block|{
literal|"CapacityTotalGB"
block|,
literal|"Total raw capacity of data nodes in GB"
block|}
argument_list|)
DECL|method|getCapacityTotalGB ()
specifier|public
name|float
name|getCapacityTotalGB
parameter_list|()
block|{
return|return
name|DFSUtil
operator|.
name|roundBytesToGB
argument_list|(
name|getCapacityTotal
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
comment|// FSNamesystemMBean
annotation|@
name|Metric
argument_list|(
block|{
literal|"CapacityUsed"
block|,
literal|"Total used capacity across all data nodes in bytes"
block|}
argument_list|)
DECL|method|getCapacityUsed ()
specifier|public
name|long
name|getCapacityUsed
parameter_list|()
block|{
return|return
name|datanodeStatistics
operator|.
name|getCapacityUsed
argument_list|()
return|;
block|}
annotation|@
name|Metric
argument_list|(
block|{
literal|"CapacityUsedGB"
block|,
literal|"Total used capacity across all data nodes in GB"
block|}
argument_list|)
DECL|method|getCapacityUsedGB ()
specifier|public
name|float
name|getCapacityUsedGB
parameter_list|()
block|{
return|return
name|DFSUtil
operator|.
name|roundBytesToGB
argument_list|(
name|getCapacityUsed
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
comment|// FSNamesystemMBean
annotation|@
name|Metric
argument_list|(
block|{
literal|"CapacityRemaining"
block|,
literal|"Remaining capacity in bytes"
block|}
argument_list|)
DECL|method|getCapacityRemaining ()
specifier|public
name|long
name|getCapacityRemaining
parameter_list|()
block|{
return|return
name|datanodeStatistics
operator|.
name|getCapacityRemaining
argument_list|()
return|;
block|}
annotation|@
name|Metric
argument_list|(
block|{
literal|"CapacityRemainingGB"
block|,
literal|"Remaining capacity in GB"
block|}
argument_list|)
DECL|method|getCapacityRemainingGB ()
specifier|public
name|float
name|getCapacityRemainingGB
parameter_list|()
block|{
return|return
name|DFSUtil
operator|.
name|roundBytesToGB
argument_list|(
name|getCapacityRemaining
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Metric
argument_list|(
block|{
literal|"CapacityUsedNonDFS"
block|,
literal|"Total space used by data nodes for non DFS purposes in bytes"
block|}
argument_list|)
DECL|method|getCapacityUsedNonDFS ()
specifier|public
name|long
name|getCapacityUsedNonDFS
parameter_list|()
block|{
return|return
name|datanodeStatistics
operator|.
name|getCapacityUsedNonDFS
argument_list|()
return|;
block|}
comment|/**    * Total number of connections.    */
annotation|@
name|Override
comment|// FSNamesystemMBean
annotation|@
name|Metric
DECL|method|getTotalLoad ()
specifier|public
name|int
name|getTotalLoad
parameter_list|()
block|{
return|return
name|datanodeStatistics
operator|.
name|getXceiverCount
argument_list|()
return|;
block|}
annotation|@
name|Metric
argument_list|(
block|{
literal|"SnapshottableDirectories"
block|,
literal|"Number of snapshottable directories"
block|}
argument_list|)
DECL|method|getNumSnapshottableDirs ()
specifier|public
name|int
name|getNumSnapshottableDirs
parameter_list|()
block|{
return|return
name|this
operator|.
name|snapshotManager
operator|.
name|getNumSnapshottableDirs
argument_list|()
return|;
block|}
annotation|@
name|Metric
argument_list|(
block|{
literal|"Snapshots"
block|,
literal|"The number of snapshots"
block|}
argument_list|)
DECL|method|getNumSnapshots ()
specifier|public
name|int
name|getNumSnapshots
parameter_list|()
block|{
return|return
name|this
operator|.
name|snapshotManager
operator|.
name|getNumSnapshots
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|getSnapshotStats ()
specifier|public
name|String
name|getSnapshotStats
parameter_list|()
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|info
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
argument_list|()
decl_stmt|;
name|info
operator|.
name|put
argument_list|(
literal|"SnapshottableDirectories"
argument_list|,
name|this
operator|.
name|getNumSnapshottableDirs
argument_list|()
argument_list|)
expr_stmt|;
name|info
operator|.
name|put
argument_list|(
literal|"Snapshots"
argument_list|,
name|this
operator|.
name|getNumSnapshots
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|JSON
operator|.
name|toString
argument_list|(
name|info
argument_list|)
return|;
block|}
DECL|method|getNumberOfDatanodes (DatanodeReportType type)
name|int
name|getNumberOfDatanodes
parameter_list|(
name|DatanodeReportType
name|type
parameter_list|)
block|{
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
return|return
name|getBlockManager
argument_list|()
operator|.
name|getDatanodeManager
argument_list|()
operator|.
name|getDatanodeListForReport
argument_list|(
name|type
argument_list|)
operator|.
name|size
argument_list|()
return|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|datanodeReport (final DatanodeReportType type )
name|DatanodeInfo
index|[]
name|datanodeReport
parameter_list|(
specifier|final
name|DatanodeReportType
name|type
parameter_list|)
throws|throws
name|AccessControlException
throws|,
name|StandbyException
block|{
name|checkSuperuserPrivilege
argument_list|()
expr_stmt|;
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|UNCHECKED
argument_list|)
expr_stmt|;
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|UNCHECKED
argument_list|)
expr_stmt|;
specifier|final
name|DatanodeManager
name|dm
init|=
name|getBlockManager
argument_list|()
operator|.
name|getDatanodeManager
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|results
init|=
name|dm
operator|.
name|getDatanodeListForReport
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|DatanodeInfo
index|[]
name|arr
init|=
operator|new
name|DatanodeInfo
index|[
name|results
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|arr
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|arr
index|[
name|i
index|]
operator|=
operator|new
name|DatanodeInfo
argument_list|(
name|results
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|arr
return|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|getDatanodeStorageReport (final DatanodeReportType type )
name|DatanodeStorageReport
index|[]
name|getDatanodeStorageReport
parameter_list|(
specifier|final
name|DatanodeReportType
name|type
parameter_list|)
throws|throws
name|AccessControlException
throws|,
name|StandbyException
block|{
name|checkSuperuserPrivilege
argument_list|()
expr_stmt|;
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|UNCHECKED
argument_list|)
expr_stmt|;
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|UNCHECKED
argument_list|)
expr_stmt|;
specifier|final
name|DatanodeManager
name|dm
init|=
name|getBlockManager
argument_list|()
operator|.
name|getDatanodeManager
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|datanodes
init|=
name|dm
operator|.
name|getDatanodeListForReport
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|DatanodeStorageReport
index|[]
name|reports
init|=
operator|new
name|DatanodeStorageReport
index|[
name|datanodes
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|reports
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|DatanodeDescriptor
name|d
init|=
name|datanodes
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|reports
index|[
name|i
index|]
operator|=
operator|new
name|DatanodeStorageReport
argument_list|(
operator|new
name|DatanodeInfo
argument_list|(
name|d
argument_list|)
argument_list|,
name|d
operator|.
name|getStorageReports
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|reports
return|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Save namespace image.    * This will save current namespace into fsimage file and empty edits file.    * Requires superuser privilege and safe mode.    */
DECL|method|saveNamespace (final long timeWindow, final long txGap)
name|boolean
name|saveNamespace
parameter_list|(
specifier|final
name|long
name|timeWindow
parameter_list|,
specifier|final
name|long
name|txGap
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|UNCHECKED
argument_list|)
expr_stmt|;
name|checkSuperuserPrivilege
argument_list|()
expr_stmt|;
name|boolean
name|saved
init|=
literal|false
decl_stmt|;
name|cpLock
argument_list|()
expr_stmt|;
comment|// Block if a checkpointing is in progress on standby.
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|UNCHECKED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isInSafeMode
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Safe mode should be turned ON "
operator|+
literal|"in order to create namespace image."
argument_list|)
throw|;
block|}
name|saved
operator|=
name|getFSImage
argument_list|()
operator|.
name|saveNamespace
argument_list|(
name|timeWindow
argument_list|,
name|txGap
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
name|cpUnlock
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|saved
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"New namespace image has been created"
argument_list|)
expr_stmt|;
block|}
return|return
name|saved
return|;
block|}
comment|/**    * Enables/Disables/Checks restoring failed storage replicas if the storage becomes available again.    * Requires superuser privilege.    *     * @throws AccessControlException if superuser privilege is violated.    */
DECL|method|restoreFailedStorage (String arg)
name|boolean
name|restoreFailedStorage
parameter_list|(
name|String
name|arg
parameter_list|)
throws|throws
name|AccessControlException
throws|,
name|StandbyException
block|{
name|checkSuperuserPrivilege
argument_list|()
expr_stmt|;
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|UNCHECKED
argument_list|)
expr_stmt|;
name|cpLock
argument_list|()
expr_stmt|;
comment|// Block if a checkpointing is in progress on standby.
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|UNCHECKED
argument_list|)
expr_stmt|;
comment|// if it is disabled - enable it and vice versa.
if|if
condition|(
name|arg
operator|.
name|equals
argument_list|(
literal|"check"
argument_list|)
condition|)
return|return
name|getFSImage
argument_list|()
operator|.
name|getStorage
argument_list|()
operator|.
name|getRestoreFailedStorage
argument_list|()
return|;
name|boolean
name|val
init|=
name|arg
operator|.
name|equals
argument_list|(
literal|"true"
argument_list|)
decl_stmt|;
comment|// false if not
name|getFSImage
argument_list|()
operator|.
name|getStorage
argument_list|()
operator|.
name|setRestoreFailedStorage
argument_list|(
name|val
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
name|cpUnlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|getStartTime ()
name|Date
name|getStartTime
parameter_list|()
block|{
return|return
operator|new
name|Date
argument_list|(
name|startTime
argument_list|)
return|;
block|}
DECL|method|finalizeUpgrade ()
name|void
name|finalizeUpgrade
parameter_list|()
throws|throws
name|IOException
block|{
name|checkSuperuserPrivilege
argument_list|()
expr_stmt|;
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|UNCHECKED
argument_list|)
expr_stmt|;
name|cpLock
argument_list|()
expr_stmt|;
comment|// Block if a checkpointing is in progress on standby.
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|UNCHECKED
argument_list|)
expr_stmt|;
name|getFSImage
argument_list|()
operator|.
name|finalizeUpgrade
argument_list|(
name|this
operator|.
name|isHaEnabled
argument_list|()
operator|&&
name|inActiveState
argument_list|()
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
name|cpUnlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|refreshNodes ()
name|void
name|refreshNodes
parameter_list|()
throws|throws
name|IOException
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|UNCHECKED
argument_list|)
expr_stmt|;
name|checkSuperuserPrivilege
argument_list|()
expr_stmt|;
name|getBlockManager
argument_list|()
operator|.
name|getDatanodeManager
argument_list|()
operator|.
name|refreshNodes
argument_list|(
operator|new
name|HdfsConfiguration
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|setBalancerBandwidth (long bandwidth)
name|void
name|setBalancerBandwidth
parameter_list|(
name|long
name|bandwidth
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|UNCHECKED
argument_list|)
expr_stmt|;
name|checkSuperuserPrivilege
argument_list|()
expr_stmt|;
name|getBlockManager
argument_list|()
operator|.
name|getDatanodeManager
argument_list|()
operator|.
name|setBalancerBandwidth
argument_list|(
name|bandwidth
argument_list|)
expr_stmt|;
block|}
comment|/**    * Persist the new block (the last block of the given file).    * @param path    * @param file    */
DECL|method|persistNewBlock (String path, INodeFile file)
specifier|private
name|void
name|persistNewBlock
parameter_list|(
name|String
name|path
parameter_list|,
name|INodeFile
name|file
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|file
operator|.
name|isUnderConstruction
argument_list|()
argument_list|)
expr_stmt|;
name|getEditLog
argument_list|()
operator|.
name|logAddBlock
argument_list|(
name|path
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|debug
argument_list|(
literal|"persistNewBlock: "
operator|+
name|path
operator|+
literal|" with new block "
operator|+
name|file
operator|.
name|getLastBlock
argument_list|()
operator|.
name|toString
argument_list|()
operator|+
literal|", current total block count is "
operator|+
name|file
operator|.
name|getBlocks
argument_list|()
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * SafeModeInfo contains information related to the safe mode.    *<p>    * An instance of {@link SafeModeInfo} is created when the name node    * enters safe mode.    *<p>    * During name node startup {@link SafeModeInfo} counts the number of    *<em>safe blocks</em>, those that have at least the minimal number of    * replicas, and calculates the ratio of safe blocks to the total number    * of blocks in the system, which is the size of blocks in    * {@link FSNamesystem#blockManager}. When the ratio reaches the    * {@link #threshold} it starts the SafeModeMonitor daemon in order    * to monitor whether the safe mode {@link #extension} is passed.    * Then it leaves safe mode and destroys itself.    *<p>    * If safe mode is turned on manually then the number of safe blocks is    * not tracked because the name node is not intended to leave safe mode    * automatically in the case.    *    * @see ClientProtocol#setSafeMode(HdfsConstants.SafeModeAction, boolean)    */
DECL|class|SafeModeInfo
specifier|public
class|class
name|SafeModeInfo
block|{
comment|// configuration fields
comment|/** Safe mode threshold condition %.*/
DECL|field|threshold
specifier|private
specifier|final
name|double
name|threshold
decl_stmt|;
comment|/** Safe mode minimum number of datanodes alive */
DECL|field|datanodeThreshold
specifier|private
specifier|final
name|int
name|datanodeThreshold
decl_stmt|;
comment|/**      * Safe mode extension after the threshold.      * Make it volatile so that getSafeModeTip can read the latest value      * without taking a lock.      */
DECL|field|extension
specifier|private
specifier|volatile
name|int
name|extension
decl_stmt|;
comment|/** Min replication required by safe mode. */
DECL|field|safeReplication
specifier|private
specifier|final
name|int
name|safeReplication
decl_stmt|;
comment|/** threshold for populating needed replication queues */
DECL|field|replQueueThreshold
specifier|private
specifier|final
name|double
name|replQueueThreshold
decl_stmt|;
comment|// internal fields
comment|/** Time when threshold was reached.      *<br> -1 safe mode is off      *<br> 0 safe mode is on, and threshold is not reached yet      *<br>>0 safe mode is on, but we are in extension period       */
DECL|field|reached
specifier|private
name|long
name|reached
init|=
operator|-
literal|1
decl_stmt|;
DECL|field|reachedTimestamp
specifier|private
name|long
name|reachedTimestamp
init|=
operator|-
literal|1
decl_stmt|;
comment|/** Total number of blocks. */
DECL|field|blockTotal
name|int
name|blockTotal
decl_stmt|;
comment|/** Number of safe blocks. */
DECL|field|blockSafe
name|int
name|blockSafe
decl_stmt|;
comment|/** Number of blocks needed to satisfy safe mode threshold condition */
DECL|field|blockThreshold
specifier|private
name|int
name|blockThreshold
decl_stmt|;
comment|/** Number of blocks needed before populating replication queues */
DECL|field|blockReplQueueThreshold
specifier|private
name|int
name|blockReplQueueThreshold
decl_stmt|;
comment|/** time of the last status printout */
DECL|field|lastStatusReport
specifier|private
name|long
name|lastStatusReport
init|=
literal|0
decl_stmt|;
comment|/**      * Was safemode entered automatically because available resources were low.      * Make it volatile so that getSafeModeTip can read the latest value      * without taking a lock.      */
DECL|field|resourcesLow
specifier|private
specifier|volatile
name|boolean
name|resourcesLow
init|=
literal|false
decl_stmt|;
comment|/** Should safemode adjust its block totals as blocks come in */
DECL|field|shouldIncrementallyTrackBlocks
specifier|private
name|boolean
name|shouldIncrementallyTrackBlocks
init|=
literal|false
decl_stmt|;
comment|/** counter for tracking startup progress of reported blocks */
DECL|field|awaitingReportedBlocksCounter
specifier|private
name|Counter
name|awaitingReportedBlocksCounter
decl_stmt|;
comment|/**      * Creates SafeModeInfo when the name node enters      * automatic safe mode at startup.      *        * @param conf configuration      */
DECL|method|SafeModeInfo (Configuration conf)
specifier|private
name|SafeModeInfo
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
name|this
operator|.
name|threshold
operator|=
name|conf
operator|.
name|getFloat
argument_list|(
name|DFS_NAMENODE_SAFEMODE_THRESHOLD_PCT_KEY
argument_list|,
name|DFS_NAMENODE_SAFEMODE_THRESHOLD_PCT_DEFAULT
argument_list|)
expr_stmt|;
if|if
condition|(
name|threshold
operator|>
literal|1.0
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"The threshold value should't be greater than 1, threshold: "
operator|+
name|threshold
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|datanodeThreshold
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|DFS_NAMENODE_SAFEMODE_MIN_DATANODES_KEY
argument_list|,
name|DFS_NAMENODE_SAFEMODE_MIN_DATANODES_DEFAULT
argument_list|)
expr_stmt|;
name|this
operator|.
name|extension
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|DFS_NAMENODE_SAFEMODE_EXTENSION_KEY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|this
operator|.
name|safeReplication
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|DFS_NAMENODE_REPLICATION_MIN_KEY
argument_list|,
name|DFS_NAMENODE_REPLICATION_MIN_DEFAULT
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|DFS_NAMENODE_SAFEMODE_THRESHOLD_PCT_KEY
operator|+
literal|" = "
operator|+
name|threshold
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|DFS_NAMENODE_SAFEMODE_MIN_DATANODES_KEY
operator|+
literal|" = "
operator|+
name|datanodeThreshold
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|DFS_NAMENODE_SAFEMODE_EXTENSION_KEY
operator|+
literal|"     = "
operator|+
name|extension
argument_list|)
expr_stmt|;
comment|// default to safe mode threshold (i.e., don't populate queues before leaving safe mode)
name|this
operator|.
name|replQueueThreshold
operator|=
name|conf
operator|.
name|getFloat
argument_list|(
name|DFS_NAMENODE_REPL_QUEUE_THRESHOLD_PCT_KEY
argument_list|,
operator|(
name|float
operator|)
name|threshold
argument_list|)
expr_stmt|;
name|this
operator|.
name|blockTotal
operator|=
literal|0
expr_stmt|;
name|this
operator|.
name|blockSafe
operator|=
literal|0
expr_stmt|;
block|}
comment|/**      * In the HA case, the StandbyNode can be in safemode while the namespace      * is modified by the edit log tailer. In this case, the number of total      * blocks changes as edits are processed (eg blocks are added and deleted).      * However, we don't want to do the incremental tracking during the      * startup-time loading process -- only once the initial total has been      * set after the image has been loaded.      */
DECL|method|shouldIncrementallyTrackBlocks ()
specifier|private
name|boolean
name|shouldIncrementallyTrackBlocks
parameter_list|()
block|{
return|return
name|shouldIncrementallyTrackBlocks
return|;
block|}
comment|/**      * Creates SafeModeInfo when safe mode is entered manually, or because      * available resources are low.      *      * The {@link #threshold} is set to 1.5 so that it could never be reached.      * {@link #blockTotal} is set to -1 to indicate that safe mode is manual.      *       * @see SafeModeInfo      */
DECL|method|SafeModeInfo (boolean resourcesLow)
specifier|private
name|SafeModeInfo
parameter_list|(
name|boolean
name|resourcesLow
parameter_list|)
block|{
name|this
operator|.
name|threshold
operator|=
literal|1.5f
expr_stmt|;
comment|// this threshold can never be reached
name|this
operator|.
name|datanodeThreshold
operator|=
name|Integer
operator|.
name|MAX_VALUE
expr_stmt|;
name|this
operator|.
name|extension
operator|=
name|Integer
operator|.
name|MAX_VALUE
expr_stmt|;
name|this
operator|.
name|safeReplication
operator|=
name|Short
operator|.
name|MAX_VALUE
operator|+
literal|1
expr_stmt|;
comment|// more than maxReplication
name|this
operator|.
name|replQueueThreshold
operator|=
literal|1.5f
expr_stmt|;
comment|// can never be reached
name|this
operator|.
name|blockTotal
operator|=
operator|-
literal|1
expr_stmt|;
name|this
operator|.
name|blockSafe
operator|=
operator|-
literal|1
expr_stmt|;
name|this
operator|.
name|resourcesLow
operator|=
name|resourcesLow
expr_stmt|;
name|enter
argument_list|()
expr_stmt|;
name|reportStatus
argument_list|(
literal|"STATE* Safe mode is ON."
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**      * Check if safe mode is on.      * @return true if in safe mode      */
DECL|method|isOn ()
specifier|private
specifier|synchronized
name|boolean
name|isOn
parameter_list|()
block|{
name|doConsistencyCheck
argument_list|()
expr_stmt|;
return|return
name|this
operator|.
name|reached
operator|>=
literal|0
return|;
block|}
comment|/**      * Enter safe mode.      */
DECL|method|enter ()
specifier|private
name|void
name|enter
parameter_list|()
block|{
name|this
operator|.
name|reached
operator|=
literal|0
expr_stmt|;
name|this
operator|.
name|reachedTimestamp
operator|=
literal|0
expr_stmt|;
block|}
comment|/**      * Leave safe mode.      *<p>      * Check for invalid, under-& over-replicated blocks in the end of startup.      */
DECL|method|leave ()
specifier|private
specifier|synchronized
name|void
name|leave
parameter_list|()
block|{
comment|// if not done yet, initialize replication queues.
comment|// In the standby, do not populate repl queues
if|if
condition|(
operator|!
name|isPopulatingReplQueues
argument_list|()
operator|&&
name|shouldPopulateReplQueues
argument_list|()
condition|)
block|{
name|initializeReplQueues
argument_list|()
expr_stmt|;
block|}
name|long
name|timeInSafemode
init|=
name|now
argument_list|()
operator|-
name|startTime
decl_stmt|;
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|info
argument_list|(
literal|"STATE* Leaving safe mode after "
operator|+
name|timeInSafemode
operator|/
literal|1000
operator|+
literal|" secs"
argument_list|)
expr_stmt|;
name|NameNode
operator|.
name|getNameNodeMetrics
argument_list|()
operator|.
name|setSafeModeTime
argument_list|(
operator|(
name|int
operator|)
name|timeInSafemode
argument_list|)
expr_stmt|;
comment|//Log the following only once (when transitioning from ON -> OFF)
if|if
condition|(
name|reached
operator|>=
literal|0
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|info
argument_list|(
literal|"STATE* Safe mode is OFF"
argument_list|)
expr_stmt|;
block|}
name|reached
operator|=
operator|-
literal|1
expr_stmt|;
name|reachedTimestamp
operator|=
operator|-
literal|1
expr_stmt|;
name|safeMode
operator|=
literal|null
expr_stmt|;
specifier|final
name|NetworkTopology
name|nt
init|=
name|blockManager
operator|.
name|getDatanodeManager
argument_list|()
operator|.
name|getNetworkTopology
argument_list|()
decl_stmt|;
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|info
argument_list|(
literal|"STATE* Network topology has "
operator|+
name|nt
operator|.
name|getNumOfRacks
argument_list|()
operator|+
literal|" racks and "
operator|+
name|nt
operator|.
name|getNumOfLeaves
argument_list|()
operator|+
literal|" datanodes"
argument_list|)
expr_stmt|;
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|info
argument_list|(
literal|"STATE* UnderReplicatedBlocks has "
operator|+
name|blockManager
operator|.
name|numOfUnderReplicatedBlocks
argument_list|()
operator|+
literal|" blocks"
argument_list|)
expr_stmt|;
name|startSecretManagerIfNecessary
argument_list|()
expr_stmt|;
comment|// If startup has not yet completed, end safemode phase.
name|StartupProgress
name|prog
init|=
name|NameNode
operator|.
name|getStartupProgress
argument_list|()
decl_stmt|;
if|if
condition|(
name|prog
operator|.
name|getStatus
argument_list|(
name|Phase
operator|.
name|SAFEMODE
argument_list|)
operator|!=
name|Status
operator|.
name|COMPLETE
condition|)
block|{
name|prog
operator|.
name|endStep
argument_list|(
name|Phase
operator|.
name|SAFEMODE
argument_list|,
name|STEP_AWAITING_REPORTED_BLOCKS
argument_list|)
expr_stmt|;
name|prog
operator|.
name|endPhase
argument_list|(
name|Phase
operator|.
name|SAFEMODE
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Check whether we have reached the threshold for       * initializing replication queues.      */
DECL|method|canInitializeReplQueues ()
specifier|private
specifier|synchronized
name|boolean
name|canInitializeReplQueues
parameter_list|()
block|{
return|return
name|shouldPopulateReplQueues
argument_list|()
operator|&&
name|blockSafe
operator|>=
name|blockReplQueueThreshold
return|;
block|}
comment|/**       * Safe mode can be turned off iff       * the threshold is reached and       * the extension time have passed.      * @return true if can leave or false otherwise.      */
DECL|method|canLeave ()
specifier|private
specifier|synchronized
name|boolean
name|canLeave
parameter_list|()
block|{
if|if
condition|(
name|reached
operator|==
literal|0
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|monotonicNow
argument_list|()
operator|-
name|reached
operator|<
name|extension
condition|)
block|{
name|reportStatus
argument_list|(
literal|"STATE* Safe mode ON, in safe mode extension."
argument_list|,
literal|false
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|needEnter
argument_list|()
condition|)
block|{
name|reportStatus
argument_list|(
literal|"STATE* Safe mode ON, thresholds not met."
argument_list|,
literal|false
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
comment|/**       * There is no need to enter safe mode       * if DFS is empty or {@link #threshold} == 0      */
DECL|method|needEnter ()
specifier|private
name|boolean
name|needEnter
parameter_list|()
block|{
return|return
operator|(
name|threshold
operator|!=
literal|0
operator|&&
name|blockSafe
operator|<
name|blockThreshold
operator|)
operator|||
operator|(
name|datanodeThreshold
operator|!=
literal|0
operator|&&
name|getNumLiveDataNodes
argument_list|()
operator|<
name|datanodeThreshold
operator|)
operator|||
operator|(
operator|!
name|nameNodeHasResourcesAvailable
argument_list|()
operator|)
return|;
block|}
comment|/**      * Check and trigger safe mode if needed.       */
DECL|method|checkMode ()
specifier|private
name|void
name|checkMode
parameter_list|()
block|{
comment|// Have to have write-lock since leaving safemode initializes
comment|// repl queues, which requires write lock
assert|assert
name|hasWriteLock
argument_list|()
assert|;
if|if
condition|(
name|inTransitionToActive
argument_list|()
condition|)
block|{
return|return;
block|}
comment|// if smmthread is already running, the block threshold must have been
comment|// reached before, there is no need to enter the safe mode again
if|if
condition|(
name|smmthread
operator|==
literal|null
operator|&&
name|needEnter
argument_list|()
condition|)
block|{
name|enter
argument_list|()
expr_stmt|;
comment|// check if we are ready to initialize replication queues
if|if
condition|(
name|canInitializeReplQueues
argument_list|()
operator|&&
operator|!
name|isPopulatingReplQueues
argument_list|()
operator|&&
operator|!
name|haEnabled
condition|)
block|{
name|initializeReplQueues
argument_list|()
expr_stmt|;
block|}
name|reportStatus
argument_list|(
literal|"STATE* Safe mode ON."
argument_list|,
literal|false
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// the threshold is reached or was reached before
if|if
condition|(
operator|!
name|isOn
argument_list|()
operator|||
comment|// safe mode is off
name|extension
operator|<=
literal|0
operator|||
name|threshold
operator|<=
literal|0
condition|)
block|{
comment|// don't need to wait
name|this
operator|.
name|leave
argument_list|()
expr_stmt|;
comment|// leave safe mode
return|return;
block|}
if|if
condition|(
name|reached
operator|>
literal|0
condition|)
block|{
comment|// threshold has already been reached before
name|reportStatus
argument_list|(
literal|"STATE* Safe mode ON."
argument_list|,
literal|false
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// start monitor
name|reached
operator|=
name|monotonicNow
argument_list|()
expr_stmt|;
name|reachedTimestamp
operator|=
name|now
argument_list|()
expr_stmt|;
if|if
condition|(
name|smmthread
operator|==
literal|null
condition|)
block|{
name|smmthread
operator|=
operator|new
name|Daemon
argument_list|(
operator|new
name|SafeModeMonitor
argument_list|()
argument_list|)
expr_stmt|;
name|smmthread
operator|.
name|start
argument_list|()
expr_stmt|;
name|reportStatus
argument_list|(
literal|"STATE* Safe mode extension entered."
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|// check if we are ready to initialize replication queues
if|if
condition|(
name|canInitializeReplQueues
argument_list|()
operator|&&
operator|!
name|isPopulatingReplQueues
argument_list|()
operator|&&
operator|!
name|haEnabled
condition|)
block|{
name|initializeReplQueues
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Set total number of blocks.      */
DECL|method|setBlockTotal (int total)
specifier|private
specifier|synchronized
name|void
name|setBlockTotal
parameter_list|(
name|int
name|total
parameter_list|)
block|{
name|this
operator|.
name|blockTotal
operator|=
name|total
expr_stmt|;
name|this
operator|.
name|blockThreshold
operator|=
call|(
name|int
call|)
argument_list|(
name|blockTotal
operator|*
name|threshold
argument_list|)
expr_stmt|;
name|this
operator|.
name|blockReplQueueThreshold
operator|=
call|(
name|int
call|)
argument_list|(
name|blockTotal
operator|*
name|replQueueThreshold
argument_list|)
expr_stmt|;
if|if
condition|(
name|haEnabled
condition|)
block|{
comment|// After we initialize the block count, any further namespace
comment|// modifications done while in safe mode need to keep track
comment|// of the number of total blocks in the system.
name|this
operator|.
name|shouldIncrementallyTrackBlocks
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|blockSafe
operator|<
literal|0
condition|)
name|this
operator|.
name|blockSafe
operator|=
literal|0
expr_stmt|;
name|checkMode
argument_list|()
expr_stmt|;
block|}
comment|/**      * Increment number of safe blocks if current block has       * reached minimal replication.      * @param replication current replication       */
DECL|method|incrementSafeBlockCount (short replication)
specifier|private
specifier|synchronized
name|void
name|incrementSafeBlockCount
parameter_list|(
name|short
name|replication
parameter_list|)
block|{
if|if
condition|(
name|replication
operator|==
name|safeReplication
condition|)
block|{
name|this
operator|.
name|blockSafe
operator|++
expr_stmt|;
comment|// Report startup progress only if we haven't completed startup yet.
name|StartupProgress
name|prog
init|=
name|NameNode
operator|.
name|getStartupProgress
argument_list|()
decl_stmt|;
if|if
condition|(
name|prog
operator|.
name|getStatus
argument_list|(
name|Phase
operator|.
name|SAFEMODE
argument_list|)
operator|!=
name|Status
operator|.
name|COMPLETE
condition|)
block|{
if|if
condition|(
name|this
operator|.
name|awaitingReportedBlocksCounter
operator|==
literal|null
condition|)
block|{
name|this
operator|.
name|awaitingReportedBlocksCounter
operator|=
name|prog
operator|.
name|getCounter
argument_list|(
name|Phase
operator|.
name|SAFEMODE
argument_list|,
name|STEP_AWAITING_REPORTED_BLOCKS
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|awaitingReportedBlocksCounter
operator|.
name|increment
argument_list|()
expr_stmt|;
block|}
name|checkMode
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Decrement number of safe blocks if current block has       * fallen below minimal replication.      * @param replication current replication       */
DECL|method|decrementSafeBlockCount (short replication)
specifier|private
specifier|synchronized
name|void
name|decrementSafeBlockCount
parameter_list|(
name|short
name|replication
parameter_list|)
block|{
if|if
condition|(
name|replication
operator|==
name|safeReplication
operator|-
literal|1
condition|)
block|{
name|this
operator|.
name|blockSafe
operator|--
expr_stmt|;
comment|//blockSafe is set to -1 in manual / low resources safemode
assert|assert
name|blockSafe
operator|>=
literal|0
operator|||
name|isManual
argument_list|()
operator|||
name|areResourcesLow
argument_list|()
assert|;
name|checkMode
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Check if safe mode was entered manually      */
DECL|method|isManual ()
specifier|private
name|boolean
name|isManual
parameter_list|()
block|{
return|return
name|extension
operator|==
name|Integer
operator|.
name|MAX_VALUE
return|;
block|}
comment|/**      * Set manual safe mode.      */
DECL|method|setManual ()
specifier|private
specifier|synchronized
name|void
name|setManual
parameter_list|()
block|{
name|extension
operator|=
name|Integer
operator|.
name|MAX_VALUE
expr_stmt|;
block|}
comment|/**      * Check if safe mode was entered due to resources being low.      */
DECL|method|areResourcesLow ()
specifier|private
name|boolean
name|areResourcesLow
parameter_list|()
block|{
return|return
name|resourcesLow
return|;
block|}
comment|/**      * Set that resources are low for this instance of safe mode.      */
DECL|method|setResourcesLow ()
specifier|private
name|void
name|setResourcesLow
parameter_list|()
block|{
name|resourcesLow
operator|=
literal|true
expr_stmt|;
block|}
comment|/**      * A tip on how safe mode is to be turned off: manually or automatically.      */
DECL|method|getTurnOffTip ()
name|String
name|getTurnOffTip
parameter_list|()
block|{
if|if
condition|(
operator|!
name|isOn
argument_list|()
condition|)
block|{
return|return
literal|"Safe mode is OFF."
return|;
block|}
comment|//Manual OR low-resource safemode. (Admin intervention required)
name|String
name|adminMsg
init|=
literal|"It was turned on manually. "
decl_stmt|;
if|if
condition|(
name|areResourcesLow
argument_list|()
condition|)
block|{
name|adminMsg
operator|=
literal|"Resources are low on NN. Please add or free up more "
operator|+
literal|"resources then turn off safe mode manually. NOTE:  If you turn off"
operator|+
literal|" safe mode before adding resources, "
operator|+
literal|"the NN will immediately return to safe mode. "
expr_stmt|;
block|}
if|if
condition|(
name|isManual
argument_list|()
operator|||
name|areResourcesLow
argument_list|()
condition|)
block|{
return|return
name|adminMsg
operator|+
literal|"Use \"hdfs dfsadmin -safemode leave\" to turn safe mode off."
return|;
block|}
name|boolean
name|thresholdsMet
init|=
literal|true
decl_stmt|;
name|int
name|numLive
init|=
name|getNumLiveDataNodes
argument_list|()
decl_stmt|;
name|String
name|msg
init|=
literal|""
decl_stmt|;
if|if
condition|(
name|blockSafe
operator|<
name|blockThreshold
condition|)
block|{
name|msg
operator|+=
name|String
operator|.
name|format
argument_list|(
literal|"The reported blocks %d needs additional %d"
operator|+
literal|" blocks to reach the threshold %.4f of total blocks %d.%n"
argument_list|,
name|blockSafe
argument_list|,
operator|(
name|blockThreshold
operator|-
name|blockSafe
operator|)
argument_list|,
name|threshold
argument_list|,
name|blockTotal
argument_list|)
expr_stmt|;
name|thresholdsMet
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|msg
operator|+=
name|String
operator|.
name|format
argument_list|(
literal|"The reported blocks %d has reached the threshold"
operator|+
literal|" %.4f of total blocks %d. "
argument_list|,
name|blockSafe
argument_list|,
name|threshold
argument_list|,
name|blockTotal
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|numLive
operator|<
name|datanodeThreshold
condition|)
block|{
name|msg
operator|+=
name|String
operator|.
name|format
argument_list|(
literal|"The number of live datanodes %d needs an additional %d live "
operator|+
literal|"datanodes to reach the minimum number %d.%n"
argument_list|,
name|numLive
argument_list|,
operator|(
name|datanodeThreshold
operator|-
name|numLive
operator|)
argument_list|,
name|datanodeThreshold
argument_list|)
expr_stmt|;
name|thresholdsMet
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|msg
operator|+=
name|String
operator|.
name|format
argument_list|(
literal|"The number of live datanodes %d has reached "
operator|+
literal|"the minimum number %d. "
argument_list|,
name|numLive
argument_list|,
name|datanodeThreshold
argument_list|)
expr_stmt|;
block|}
name|msg
operator|+=
operator|(
name|reached
operator|>
literal|0
operator|)
condition|?
literal|"In safe mode extension. "
else|:
literal|""
expr_stmt|;
name|msg
operator|+=
literal|"Safe mode will be turned off automatically "
expr_stmt|;
if|if
condition|(
operator|!
name|thresholdsMet
condition|)
block|{
name|msg
operator|+=
literal|"once the thresholds have been reached."
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|reached
operator|+
name|extension
operator|-
name|monotonicNow
argument_list|()
operator|>
literal|0
condition|)
block|{
name|msg
operator|+=
operator|(
literal|"in "
operator|+
operator|(
name|reached
operator|+
name|extension
operator|-
name|monotonicNow
argument_list|()
operator|)
operator|/
literal|1000
operator|+
literal|" seconds."
operator|)
expr_stmt|;
block|}
else|else
block|{
name|msg
operator|+=
literal|"soon."
expr_stmt|;
block|}
return|return
name|msg
return|;
block|}
comment|/**      * Print status every 20 seconds.      */
DECL|method|reportStatus (String msg, boolean rightNow)
specifier|private
name|void
name|reportStatus
parameter_list|(
name|String
name|msg
parameter_list|,
name|boolean
name|rightNow
parameter_list|)
block|{
name|long
name|curTime
init|=
name|now
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|rightNow
operator|&&
operator|(
name|curTime
operator|-
name|lastStatusReport
operator|<
literal|20
operator|*
literal|1000
operator|)
condition|)
return|return;
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|info
argument_list|(
name|msg
operator|+
literal|" \n"
operator|+
name|getTurnOffTip
argument_list|()
argument_list|)
expr_stmt|;
name|lastStatusReport
operator|=
name|curTime
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|String
name|resText
init|=
literal|"Current safe blocks = "
operator|+
name|blockSafe
operator|+
literal|". Target blocks = "
operator|+
name|blockThreshold
operator|+
literal|" for threshold = %"
operator|+
name|threshold
operator|+
literal|". Minimal replication = "
operator|+
name|safeReplication
operator|+
literal|"."
decl_stmt|;
if|if
condition|(
name|reached
operator|>
literal|0
condition|)
name|resText
operator|+=
literal|" Threshold was reached "
operator|+
operator|new
name|Date
argument_list|(
name|reachedTimestamp
argument_list|)
operator|+
literal|"."
expr_stmt|;
return|return
name|resText
return|;
block|}
comment|/**      * Checks consistency of the class state.      * This is costly so only runs if asserts are enabled.      */
DECL|method|doConsistencyCheck ()
specifier|private
name|void
name|doConsistencyCheck
parameter_list|()
block|{
name|boolean
name|assertsOn
init|=
literal|false
decl_stmt|;
assert|assert
name|assertsOn
operator|=
literal|true
assert|;
comment|// set to true if asserts are on
if|if
condition|(
operator|!
name|assertsOn
condition|)
return|return;
if|if
condition|(
name|blockTotal
operator|==
operator|-
literal|1
operator|&&
name|blockSafe
operator|==
operator|-
literal|1
condition|)
block|{
return|return;
comment|// manual safe mode
block|}
name|int
name|activeBlocks
init|=
name|blockManager
operator|.
name|getActiveBlockCount
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|blockTotal
operator|!=
name|activeBlocks
operator|)
operator|&&
operator|!
operator|(
name|blockSafe
operator|>=
literal|0
operator|&&
name|blockSafe
operator|<=
name|blockTotal
operator|)
condition|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|" SafeMode: Inconsistent filesystem state: "
operator|+
literal|"SafeMode data: blockTotal="
operator|+
name|blockTotal
operator|+
literal|" blockSafe="
operator|+
name|blockSafe
operator|+
literal|"; "
operator|+
literal|"BlockManager data: active="
operator|+
name|activeBlocks
argument_list|)
throw|;
block|}
block|}
DECL|method|adjustBlockTotals (int deltaSafe, int deltaTotal)
specifier|private
specifier|synchronized
name|void
name|adjustBlockTotals
parameter_list|(
name|int
name|deltaSafe
parameter_list|,
name|int
name|deltaTotal
parameter_list|)
block|{
if|if
condition|(
operator|!
name|shouldIncrementallyTrackBlocks
condition|)
block|{
return|return;
block|}
assert|assert
name|haEnabled
assert|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Adjusting block totals from "
operator|+
name|blockSafe
operator|+
literal|"/"
operator|+
name|blockTotal
operator|+
literal|" to "
operator|+
operator|(
name|blockSafe
operator|+
name|deltaSafe
operator|)
operator|+
literal|"/"
operator|+
operator|(
name|blockTotal
operator|+
name|deltaTotal
operator|)
argument_list|)
expr_stmt|;
block|}
assert|assert
name|blockSafe
operator|+
name|deltaSafe
operator|>=
literal|0
operator|:
literal|"Can't reduce blockSafe "
operator|+
name|blockSafe
operator|+
literal|" by "
operator|+
name|deltaSafe
operator|+
literal|": would be negative"
assert|;
assert|assert
name|blockTotal
operator|+
name|deltaTotal
operator|>=
literal|0
operator|:
literal|"Can't reduce blockTotal "
operator|+
name|blockTotal
operator|+
literal|" by "
operator|+
name|deltaTotal
operator|+
literal|": would be negative"
assert|;
name|blockSafe
operator|+=
name|deltaSafe
expr_stmt|;
name|setBlockTotal
argument_list|(
name|blockTotal
operator|+
name|deltaTotal
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Periodically check whether it is time to leave safe mode.    * This thread starts when the threshold level is reached.    *    */
DECL|class|SafeModeMonitor
class|class
name|SafeModeMonitor
implements|implements
name|Runnable
block|{
comment|/** interval in msec for checking safe mode: {@value} */
DECL|field|recheckInterval
specifier|private
specifier|static
specifier|final
name|long
name|recheckInterval
init|=
literal|1000
decl_stmt|;
comment|/**      */
annotation|@
name|Override
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
while|while
condition|(
name|fsRunning
condition|)
block|{
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
name|safeMode
operator|==
literal|null
condition|)
block|{
comment|// Not in safe mode.
break|break;
block|}
if|if
condition|(
name|safeMode
operator|.
name|canLeave
argument_list|()
condition|)
block|{
comment|// Leave safe mode.
name|safeMode
operator|.
name|leave
argument_list|()
expr_stmt|;
name|smmthread
operator|=
literal|null
expr_stmt|;
break|break;
block|}
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|recheckInterval
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
comment|// Ignored
block|}
block|}
if|if
condition|(
operator|!
name|fsRunning
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"NameNode is being shutdown, exit SafeModeMonitor thread"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|setSafeMode (SafeModeAction action)
name|boolean
name|setSafeMode
parameter_list|(
name|SafeModeAction
name|action
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|action
operator|!=
name|SafeModeAction
operator|.
name|SAFEMODE_GET
condition|)
block|{
name|checkSuperuserPrivilege
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|action
condition|)
block|{
case|case
name|SAFEMODE_LEAVE
case|:
comment|// leave safe mode
name|leaveSafeMode
argument_list|()
expr_stmt|;
break|break;
case|case
name|SAFEMODE_ENTER
case|:
comment|// enter safe mode
name|enterSafeMode
argument_list|(
literal|false
argument_list|)
expr_stmt|;
break|break;
default|default:
name|LOG
operator|.
name|error
argument_list|(
literal|"Unexpected safe mode action"
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|isInSafeMode
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|checkSafeMode ()
specifier|public
name|void
name|checkSafeMode
parameter_list|()
block|{
comment|// safeMode is volatile, and may be set to null at any time
name|SafeModeInfo
name|safeMode
init|=
name|this
operator|.
name|safeMode
decl_stmt|;
if|if
condition|(
name|safeMode
operator|!=
literal|null
condition|)
block|{
name|safeMode
operator|.
name|checkMode
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|isInSafeMode ()
specifier|public
name|boolean
name|isInSafeMode
parameter_list|()
block|{
comment|// safeMode is volatile, and may be set to null at any time
name|SafeModeInfo
name|safeMode
init|=
name|this
operator|.
name|safeMode
decl_stmt|;
if|if
condition|(
name|safeMode
operator|==
literal|null
condition|)
return|return
literal|false
return|;
return|return
name|safeMode
operator|.
name|isOn
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|isInStartupSafeMode ()
specifier|public
name|boolean
name|isInStartupSafeMode
parameter_list|()
block|{
comment|// safeMode is volatile, and may be set to null at any time
name|SafeModeInfo
name|safeMode
init|=
name|this
operator|.
name|safeMode
decl_stmt|;
if|if
condition|(
name|safeMode
operator|==
literal|null
condition|)
return|return
literal|false
return|;
comment|// If the NN is in safemode, and not due to manual / low resources, we
comment|// assume it must be because of startup. If the NN had low resources during
comment|// startup, we assume it came out of startup safemode and it is now in low
comment|// resources safemode
return|return
operator|!
name|safeMode
operator|.
name|isManual
argument_list|()
operator|&&
operator|!
name|safeMode
operator|.
name|areResourcesLow
argument_list|()
operator|&&
name|safeMode
operator|.
name|isOn
argument_list|()
return|;
block|}
comment|/**    * Check if replication queues are to be populated    * @return true when node is HAState.Active and not in the very first safemode    */
annotation|@
name|Override
DECL|method|isPopulatingReplQueues ()
specifier|public
name|boolean
name|isPopulatingReplQueues
parameter_list|()
block|{
if|if
condition|(
operator|!
name|shouldPopulateReplQueues
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
name|initializedReplQueues
return|;
block|}
DECL|method|shouldPopulateReplQueues ()
specifier|private
name|boolean
name|shouldPopulateReplQueues
parameter_list|()
block|{
if|if
condition|(
name|haContext
operator|==
literal|null
operator|||
name|haContext
operator|.
name|getState
argument_list|()
operator|==
literal|null
condition|)
return|return
literal|false
return|;
return|return
name|haContext
operator|.
name|getState
argument_list|()
operator|.
name|shouldPopulateReplQueues
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|incrementSafeBlockCount (int replication)
specifier|public
name|void
name|incrementSafeBlockCount
parameter_list|(
name|int
name|replication
parameter_list|)
block|{
comment|// safeMode is volatile, and may be set to null at any time
name|SafeModeInfo
name|safeMode
init|=
name|this
operator|.
name|safeMode
decl_stmt|;
if|if
condition|(
name|safeMode
operator|==
literal|null
condition|)
return|return;
name|safeMode
operator|.
name|incrementSafeBlockCount
argument_list|(
operator|(
name|short
operator|)
name|replication
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|decrementSafeBlockCount (Block b)
specifier|public
name|void
name|decrementSafeBlockCount
parameter_list|(
name|Block
name|b
parameter_list|)
block|{
comment|// safeMode is volatile, and may be set to null at any time
name|SafeModeInfo
name|safeMode
init|=
name|this
operator|.
name|safeMode
decl_stmt|;
if|if
condition|(
name|safeMode
operator|==
literal|null
condition|)
comment|// mostly true
return|return;
name|BlockInfoContiguous
name|storedBlock
init|=
name|getStoredBlock
argument_list|(
name|b
argument_list|)
decl_stmt|;
if|if
condition|(
name|storedBlock
operator|.
name|isComplete
argument_list|()
condition|)
block|{
name|safeMode
operator|.
name|decrementSafeBlockCount
argument_list|(
operator|(
name|short
operator|)
name|blockManager
operator|.
name|countNodes
argument_list|(
name|b
argument_list|)
operator|.
name|liveReplicas
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Adjust the total number of blocks safe and expected during safe mode.    * If safe mode is not currently on, this is a no-op.    * @param deltaSafe the change in number of safe blocks    * @param deltaTotal the change i nnumber of total blocks expected    */
annotation|@
name|Override
DECL|method|adjustSafeModeBlockTotals (int deltaSafe, int deltaTotal)
specifier|public
name|void
name|adjustSafeModeBlockTotals
parameter_list|(
name|int
name|deltaSafe
parameter_list|,
name|int
name|deltaTotal
parameter_list|)
block|{
comment|// safeMode is volatile, and may be set to null at any time
name|SafeModeInfo
name|safeMode
init|=
name|this
operator|.
name|safeMode
decl_stmt|;
if|if
condition|(
name|safeMode
operator|==
literal|null
condition|)
return|return;
name|safeMode
operator|.
name|adjustBlockTotals
argument_list|(
name|deltaSafe
argument_list|,
name|deltaTotal
argument_list|)
expr_stmt|;
block|}
comment|/**    * Set the total number of blocks in the system.     */
DECL|method|setBlockTotal ()
specifier|public
name|void
name|setBlockTotal
parameter_list|()
block|{
comment|// safeMode is volatile, and may be set to null at any time
name|SafeModeInfo
name|safeMode
init|=
name|this
operator|.
name|safeMode
decl_stmt|;
if|if
condition|(
name|safeMode
operator|==
literal|null
condition|)
return|return;
name|safeMode
operator|.
name|setBlockTotal
argument_list|(
operator|(
name|int
operator|)
name|getCompleteBlocksTotal
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Get the total number of blocks in the system.     */
annotation|@
name|Override
comment|// FSNamesystemMBean
annotation|@
name|Metric
DECL|method|getBlocksTotal ()
specifier|public
name|long
name|getBlocksTotal
parameter_list|()
block|{
return|return
name|blockManager
operator|.
name|getTotalBlocks
argument_list|()
return|;
block|}
comment|/**    * Get the total number of COMPLETE blocks in the system.    * For safe mode only complete blocks are counted.    */
DECL|method|getCompleteBlocksTotal ()
specifier|private
name|long
name|getCompleteBlocksTotal
parameter_list|()
block|{
comment|// Calculate number of blocks under construction
name|long
name|numUCBlocks
init|=
literal|0
decl_stmt|;
name|readLock
argument_list|()
expr_stmt|;
name|numUCBlocks
operator|=
name|leaseManager
operator|.
name|getNumUnderConstructionBlocks
argument_list|()
expr_stmt|;
try|try
block|{
return|return
name|getBlocksTotal
argument_list|()
operator|-
name|numUCBlocks
return|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Enter safe mode. If resourcesLow is false, then we assume it is manual    * @throws IOException    */
DECL|method|enterSafeMode (boolean resourcesLow)
name|void
name|enterSafeMode
parameter_list|(
name|boolean
name|resourcesLow
parameter_list|)
throws|throws
name|IOException
block|{
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
comment|// Stop the secret manager, since rolling the master key would
comment|// try to write to the edit log
name|stopSecretManager
argument_list|()
expr_stmt|;
comment|// Ensure that any concurrent operations have been fully synced
comment|// before entering safe mode. This ensures that the FSImage
comment|// is entirely stable on disk as soon as we're in safe mode.
name|boolean
name|isEditlogOpenForWrite
init|=
name|getEditLog
argument_list|()
operator|.
name|isOpenForWrite
argument_list|()
decl_stmt|;
comment|// Before Editlog is in OpenForWrite mode, editLogStream will be null. So,
comment|// logSyncAll call can be called only when Edlitlog is in OpenForWrite mode
if|if
condition|(
name|isEditlogOpenForWrite
condition|)
block|{
name|getEditLog
argument_list|()
operator|.
name|logSyncAll
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|isInSafeMode
argument_list|()
condition|)
block|{
name|safeMode
operator|=
operator|new
name|SafeModeInfo
argument_list|(
name|resourcesLow
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|resourcesLow
condition|)
block|{
name|safeMode
operator|.
name|setResourcesLow
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|safeMode
operator|.
name|setManual
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|isEditlogOpenForWrite
condition|)
block|{
name|getEditLog
argument_list|()
operator|.
name|logSyncAll
argument_list|()
expr_stmt|;
block|}
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|info
argument_list|(
literal|"STATE* Safe mode is ON"
operator|+
name|safeMode
operator|.
name|getTurnOffTip
argument_list|()
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Leave safe mode.    */
DECL|method|leaveSafeMode ()
name|void
name|leaveSafeMode
parameter_list|()
block|{
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
operator|!
name|isInSafeMode
argument_list|()
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|info
argument_list|(
literal|"STATE* Safe mode is already OFF"
argument_list|)
expr_stmt|;
return|return;
block|}
name|safeMode
operator|.
name|leave
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|getSafeModeTip ()
name|String
name|getSafeModeTip
parameter_list|()
block|{
comment|// There is no need to take readLock.
comment|// Don't use isInSafeMode as this.safeMode might be set to null.
comment|// after isInSafeMode returns.
name|boolean
name|inSafeMode
decl_stmt|;
name|SafeModeInfo
name|safeMode
init|=
name|this
operator|.
name|safeMode
decl_stmt|;
if|if
condition|(
name|safeMode
operator|==
literal|null
condition|)
block|{
name|inSafeMode
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|inSafeMode
operator|=
name|safeMode
operator|.
name|isOn
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|inSafeMode
condition|)
block|{
return|return
literal|""
return|;
block|}
else|else
block|{
return|return
name|safeMode
operator|.
name|getTurnOffTip
argument_list|()
return|;
block|}
block|}
DECL|method|rollEditLog ()
name|CheckpointSignature
name|rollEditLog
parameter_list|()
throws|throws
name|IOException
block|{
name|checkSuperuserPrivilege
argument_list|()
expr_stmt|;
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|JOURNAL
argument_list|)
expr_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|JOURNAL
argument_list|)
expr_stmt|;
name|checkNameNodeSafeMode
argument_list|(
literal|"Log not rolled"
argument_list|)
expr_stmt|;
if|if
condition|(
name|Server
operator|.
name|isRpcInvocation
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Roll Edit Log from "
operator|+
name|Server
operator|.
name|getRemoteAddress
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|getFSImage
argument_list|()
operator|.
name|rollEditLog
argument_list|()
return|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|startCheckpoint (NamenodeRegistration backupNode, NamenodeRegistration activeNamenode)
name|NamenodeCommand
name|startCheckpoint
parameter_list|(
name|NamenodeRegistration
name|backupNode
parameter_list|,
name|NamenodeRegistration
name|activeNamenode
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|CHECKPOINT
argument_list|)
expr_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|CHECKPOINT
argument_list|)
expr_stmt|;
name|checkNameNodeSafeMode
argument_list|(
literal|"Checkpoint not started"
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Start checkpoint for "
operator|+
name|backupNode
operator|.
name|getAddress
argument_list|()
argument_list|)
expr_stmt|;
name|NamenodeCommand
name|cmd
init|=
name|getFSImage
argument_list|()
operator|.
name|startCheckpoint
argument_list|(
name|backupNode
argument_list|,
name|activeNamenode
argument_list|)
decl_stmt|;
name|getEditLog
argument_list|()
operator|.
name|logSync
argument_list|()
expr_stmt|;
return|return
name|cmd
return|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|processIncrementalBlockReport (final DatanodeID nodeID, final StorageReceivedDeletedBlocks srdb)
specifier|public
name|void
name|processIncrementalBlockReport
parameter_list|(
specifier|final
name|DatanodeID
name|nodeID
parameter_list|,
specifier|final
name|StorageReceivedDeletedBlocks
name|srdb
parameter_list|)
throws|throws
name|IOException
block|{
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|blockManager
operator|.
name|processIncrementalBlockReport
argument_list|(
name|nodeID
argument_list|,
name|srdb
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|endCheckpoint (NamenodeRegistration registration, CheckpointSignature sig)
name|void
name|endCheckpoint
parameter_list|(
name|NamenodeRegistration
name|registration
parameter_list|,
name|CheckpointSignature
name|sig
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|CHECKPOINT
argument_list|)
expr_stmt|;
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|CHECKPOINT
argument_list|)
expr_stmt|;
name|checkNameNodeSafeMode
argument_list|(
literal|"Checkpoint not ended"
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"End checkpoint for "
operator|+
name|registration
operator|.
name|getAddress
argument_list|()
argument_list|)
expr_stmt|;
name|getFSImage
argument_list|()
operator|.
name|endCheckpoint
argument_list|(
name|sig
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|createFsOwnerPermissions (FsPermission permission)
name|PermissionStatus
name|createFsOwnerPermissions
parameter_list|(
name|FsPermission
name|permission
parameter_list|)
block|{
return|return
operator|new
name|PermissionStatus
argument_list|(
name|fsOwner
operator|.
name|getShortUserName
argument_list|()
argument_list|,
name|supergroup
argument_list|,
name|permission
argument_list|)
return|;
block|}
DECL|method|checkUnreadableBySuperuser (FSPermissionChecker pc, INode inode, int snapshotId)
specifier|private
name|void
name|checkUnreadableBySuperuser
parameter_list|(
name|FSPermissionChecker
name|pc
parameter_list|,
name|INode
name|inode
parameter_list|,
name|int
name|snapshotId
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|pc
operator|.
name|isSuperUser
argument_list|()
condition|)
block|{
for|for
control|(
name|XAttr
name|xattr
range|:
name|FSDirXAttrOp
operator|.
name|getXAttrs
argument_list|(
name|dir
argument_list|,
name|inode
argument_list|,
name|snapshotId
argument_list|)
control|)
block|{
if|if
condition|(
name|XAttrHelper
operator|.
name|getPrefixName
argument_list|(
name|xattr
argument_list|)
operator|.
name|equals
argument_list|(
name|SECURITY_XATTR_UNREADABLE_BY_SUPERUSER
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|AccessControlException
argument_list|(
literal|"Access is denied for "
operator|+
name|pc
operator|.
name|getUser
argument_list|()
operator|+
literal|" since the superuser is not allowed to "
operator|+
literal|"perform this operation."
argument_list|)
throw|;
block|}
block|}
block|}
block|}
annotation|@
name|Override
DECL|method|checkSuperuserPrivilege ()
specifier|public
name|void
name|checkSuperuserPrivilege
parameter_list|()
throws|throws
name|AccessControlException
block|{
if|if
condition|(
name|isPermissionEnabled
condition|)
block|{
name|FSPermissionChecker
name|pc
init|=
name|getPermissionChecker
argument_list|()
decl_stmt|;
name|pc
operator|.
name|checkSuperuserPrivilege
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Check to see if we have exceeded the limit on the number    * of inodes.    */
DECL|method|checkFsObjectLimit ()
name|void
name|checkFsObjectLimit
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|maxFsObjects
operator|!=
literal|0
operator|&&
name|maxFsObjects
operator|<=
name|dir
operator|.
name|totalInodes
argument_list|()
operator|+
name|getBlocksTotal
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Exceeded the configured number of objects "
operator|+
name|maxFsObjects
operator|+
literal|" in the filesystem."
argument_list|)
throw|;
block|}
block|}
comment|/**    * Get the total number of objects in the system.     */
annotation|@
name|Override
comment|// FSNamesystemMBean
DECL|method|getMaxObjects ()
specifier|public
name|long
name|getMaxObjects
parameter_list|()
block|{
return|return
name|maxFsObjects
return|;
block|}
annotation|@
name|Override
comment|// FSNamesystemMBean
annotation|@
name|Metric
DECL|method|getFilesTotal ()
specifier|public
name|long
name|getFilesTotal
parameter_list|()
block|{
comment|// There is no need to take fSNamesystem's lock as
comment|// FSDirectory has its own lock.
return|return
name|this
operator|.
name|dir
operator|.
name|totalInodes
argument_list|()
return|;
block|}
annotation|@
name|Override
comment|// FSNamesystemMBean
annotation|@
name|Metric
DECL|method|getPendingReplicationBlocks ()
specifier|public
name|long
name|getPendingReplicationBlocks
parameter_list|()
block|{
return|return
name|blockManager
operator|.
name|getPendingReplicationBlocksCount
argument_list|()
return|;
block|}
annotation|@
name|Override
comment|// FSNamesystemMBean
annotation|@
name|Metric
DECL|method|getUnderReplicatedBlocks ()
specifier|public
name|long
name|getUnderReplicatedBlocks
parameter_list|()
block|{
return|return
name|blockManager
operator|.
name|getUnderReplicatedBlocksCount
argument_list|()
return|;
block|}
comment|/** Returns number of blocks with corrupt replicas */
annotation|@
name|Metric
argument_list|(
block|{
literal|"CorruptBlocks"
block|,
literal|"Number of blocks with corrupt replicas"
block|}
argument_list|)
DECL|method|getCorruptReplicaBlocks ()
specifier|public
name|long
name|getCorruptReplicaBlocks
parameter_list|()
block|{
return|return
name|blockManager
operator|.
name|getCorruptReplicaBlocksCount
argument_list|()
return|;
block|}
annotation|@
name|Override
comment|// FSNamesystemMBean
annotation|@
name|Metric
DECL|method|getScheduledReplicationBlocks ()
specifier|public
name|long
name|getScheduledReplicationBlocks
parameter_list|()
block|{
return|return
name|blockManager
operator|.
name|getScheduledReplicationBlocksCount
argument_list|()
return|;
block|}
annotation|@
name|Override
annotation|@
name|Metric
DECL|method|getPendingDeletionBlocks ()
specifier|public
name|long
name|getPendingDeletionBlocks
parameter_list|()
block|{
return|return
name|blockManager
operator|.
name|getPendingDeletionBlocksCount
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|getBlockDeletionStartTime ()
specifier|public
name|long
name|getBlockDeletionStartTime
parameter_list|()
block|{
return|return
name|startTime
operator|+
name|blockManager
operator|.
name|getStartupDelayBlockDeletionInMs
argument_list|()
return|;
block|}
annotation|@
name|Metric
DECL|method|getExcessBlocks ()
specifier|public
name|long
name|getExcessBlocks
parameter_list|()
block|{
return|return
name|blockManager
operator|.
name|getExcessBlocksCount
argument_list|()
return|;
block|}
comment|// HA-only metric
annotation|@
name|Metric
DECL|method|getPostponedMisreplicatedBlocks ()
specifier|public
name|long
name|getPostponedMisreplicatedBlocks
parameter_list|()
block|{
return|return
name|blockManager
operator|.
name|getPostponedMisreplicatedBlocksCount
argument_list|()
return|;
block|}
comment|// HA-only metric
annotation|@
name|Metric
DECL|method|getPendingDataNodeMessageCount ()
specifier|public
name|int
name|getPendingDataNodeMessageCount
parameter_list|()
block|{
return|return
name|blockManager
operator|.
name|getPendingDataNodeMessageCount
argument_list|()
return|;
block|}
comment|// HA-only metric
annotation|@
name|Metric
DECL|method|getHAState ()
specifier|public
name|String
name|getHAState
parameter_list|()
block|{
return|return
name|haContext
operator|.
name|getState
argument_list|()
operator|.
name|toString
argument_list|()
return|;
block|}
comment|// HA-only metric
annotation|@
name|Metric
DECL|method|getMillisSinceLastLoadedEdits ()
specifier|public
name|long
name|getMillisSinceLastLoadedEdits
parameter_list|()
block|{
if|if
condition|(
name|isInStandbyState
argument_list|()
operator|&&
name|editLogTailer
operator|!=
literal|null
condition|)
block|{
return|return
name|monotonicNow
argument_list|()
operator|-
name|editLogTailer
operator|.
name|getLastLoadTimeMs
argument_list|()
return|;
block|}
else|else
block|{
return|return
literal|0
return|;
block|}
block|}
annotation|@
name|Metric
DECL|method|getBlockCapacity ()
specifier|public
name|int
name|getBlockCapacity
parameter_list|()
block|{
return|return
name|blockManager
operator|.
name|getCapacity
argument_list|()
return|;
block|}
annotation|@
name|Override
comment|// FSNamesystemMBean
DECL|method|getFSState ()
specifier|public
name|String
name|getFSState
parameter_list|()
block|{
return|return
name|isInSafeMode
argument_list|()
condition|?
literal|"safeMode"
else|:
literal|"Operational"
return|;
block|}
DECL|field|mbeanName
specifier|private
name|ObjectName
name|mbeanName
decl_stmt|;
DECL|field|mxbeanName
specifier|private
name|ObjectName
name|mxbeanName
decl_stmt|;
comment|/**    * Register the FSNamesystem MBean using the name    *        "hadoop:service=NameNode,name=FSNamesystemState"    */
DECL|method|registerMBean ()
specifier|private
name|void
name|registerMBean
parameter_list|()
block|{
comment|// We can only implement one MXBean interface, so we keep the old one.
try|try
block|{
name|StandardMBean
name|bean
init|=
operator|new
name|StandardMBean
argument_list|(
name|this
argument_list|,
name|FSNamesystemMBean
operator|.
name|class
argument_list|)
decl_stmt|;
name|mbeanName
operator|=
name|MBeans
operator|.
name|register
argument_list|(
literal|"NameNode"
argument_list|,
literal|"FSNamesystemState"
argument_list|,
name|bean
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NotCompliantMBeanException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Bad MBean setup"
argument_list|,
name|e
argument_list|)
throw|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Registered FSNamesystemState MBean"
argument_list|)
expr_stmt|;
block|}
comment|/**    * shutdown FSNamesystem    */
DECL|method|shutdown ()
name|void
name|shutdown
parameter_list|()
block|{
if|if
condition|(
name|snapshotManager
operator|!=
literal|null
condition|)
block|{
name|snapshotManager
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|mbeanName
operator|!=
literal|null
condition|)
block|{
name|MBeans
operator|.
name|unregister
argument_list|(
name|mbeanName
argument_list|)
expr_stmt|;
name|mbeanName
operator|=
literal|null
expr_stmt|;
block|}
if|if
condition|(
name|mxbeanName
operator|!=
literal|null
condition|)
block|{
name|MBeans
operator|.
name|unregister
argument_list|(
name|mxbeanName
argument_list|)
expr_stmt|;
name|mxbeanName
operator|=
literal|null
expr_stmt|;
block|}
if|if
condition|(
name|dir
operator|!=
literal|null
condition|)
block|{
name|dir
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|blockManager
operator|!=
literal|null
condition|)
block|{
name|blockManager
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
comment|// FSNamesystemMBean
DECL|method|getNumLiveDataNodes ()
specifier|public
name|int
name|getNumLiveDataNodes
parameter_list|()
block|{
return|return
name|getBlockManager
argument_list|()
operator|.
name|getDatanodeManager
argument_list|()
operator|.
name|getNumLiveDataNodes
argument_list|()
return|;
block|}
annotation|@
name|Override
comment|// FSNamesystemMBean
DECL|method|getNumDeadDataNodes ()
specifier|public
name|int
name|getNumDeadDataNodes
parameter_list|()
block|{
return|return
name|getBlockManager
argument_list|()
operator|.
name|getDatanodeManager
argument_list|()
operator|.
name|getNumDeadDataNodes
argument_list|()
return|;
block|}
annotation|@
name|Override
comment|// FSNamesystemMBean
DECL|method|getNumDecomLiveDataNodes ()
specifier|public
name|int
name|getNumDecomLiveDataNodes
parameter_list|()
block|{
specifier|final
name|List
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|live
init|=
operator|new
name|ArrayList
argument_list|<
name|DatanodeDescriptor
argument_list|>
argument_list|()
decl_stmt|;
name|getBlockManager
argument_list|()
operator|.
name|getDatanodeManager
argument_list|()
operator|.
name|fetchDatanodes
argument_list|(
name|live
argument_list|,
literal|null
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|int
name|liveDecommissioned
init|=
literal|0
decl_stmt|;
for|for
control|(
name|DatanodeDescriptor
name|node
range|:
name|live
control|)
block|{
name|liveDecommissioned
operator|+=
name|node
operator|.
name|isDecommissioned
argument_list|()
condition|?
literal|1
else|:
literal|0
expr_stmt|;
block|}
return|return
name|liveDecommissioned
return|;
block|}
annotation|@
name|Override
comment|// FSNamesystemMBean
DECL|method|getNumDecomDeadDataNodes ()
specifier|public
name|int
name|getNumDecomDeadDataNodes
parameter_list|()
block|{
specifier|final
name|List
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|dead
init|=
operator|new
name|ArrayList
argument_list|<
name|DatanodeDescriptor
argument_list|>
argument_list|()
decl_stmt|;
name|getBlockManager
argument_list|()
operator|.
name|getDatanodeManager
argument_list|()
operator|.
name|fetchDatanodes
argument_list|(
literal|null
argument_list|,
name|dead
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|int
name|deadDecommissioned
init|=
literal|0
decl_stmt|;
for|for
control|(
name|DatanodeDescriptor
name|node
range|:
name|dead
control|)
block|{
name|deadDecommissioned
operator|+=
name|node
operator|.
name|isDecommissioned
argument_list|()
condition|?
literal|1
else|:
literal|0
expr_stmt|;
block|}
return|return
name|deadDecommissioned
return|;
block|}
annotation|@
name|Override
comment|// FSNamesystemMBean
DECL|method|getVolumeFailuresTotal ()
specifier|public
name|int
name|getVolumeFailuresTotal
parameter_list|()
block|{
name|List
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|live
init|=
operator|new
name|ArrayList
argument_list|<
name|DatanodeDescriptor
argument_list|>
argument_list|()
decl_stmt|;
name|getBlockManager
argument_list|()
operator|.
name|getDatanodeManager
argument_list|()
operator|.
name|fetchDatanodes
argument_list|(
name|live
argument_list|,
literal|null
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|int
name|volumeFailuresTotal
init|=
literal|0
decl_stmt|;
for|for
control|(
name|DatanodeDescriptor
name|node
range|:
name|live
control|)
block|{
name|volumeFailuresTotal
operator|+=
name|node
operator|.
name|getVolumeFailures
argument_list|()
expr_stmt|;
block|}
return|return
name|volumeFailuresTotal
return|;
block|}
annotation|@
name|Override
comment|// FSNamesystemMBean
DECL|method|getEstimatedCapacityLostTotal ()
specifier|public
name|long
name|getEstimatedCapacityLostTotal
parameter_list|()
block|{
name|List
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|live
init|=
operator|new
name|ArrayList
argument_list|<
name|DatanodeDescriptor
argument_list|>
argument_list|()
decl_stmt|;
name|getBlockManager
argument_list|()
operator|.
name|getDatanodeManager
argument_list|()
operator|.
name|fetchDatanodes
argument_list|(
name|live
argument_list|,
literal|null
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|long
name|estimatedCapacityLostTotal
init|=
literal|0
decl_stmt|;
for|for
control|(
name|DatanodeDescriptor
name|node
range|:
name|live
control|)
block|{
name|VolumeFailureSummary
name|volumeFailureSummary
init|=
name|node
operator|.
name|getVolumeFailureSummary
argument_list|()
decl_stmt|;
if|if
condition|(
name|volumeFailureSummary
operator|!=
literal|null
condition|)
block|{
name|estimatedCapacityLostTotal
operator|+=
name|volumeFailureSummary
operator|.
name|getEstimatedCapacityLostTotal
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|estimatedCapacityLostTotal
return|;
block|}
annotation|@
name|Override
comment|// FSNamesystemMBean
DECL|method|getNumDecommissioningDataNodes ()
specifier|public
name|int
name|getNumDecommissioningDataNodes
parameter_list|()
block|{
return|return
name|getBlockManager
argument_list|()
operator|.
name|getDatanodeManager
argument_list|()
operator|.
name|getDecommissioningNodes
argument_list|()
operator|.
name|size
argument_list|()
return|;
block|}
annotation|@
name|Override
comment|// FSNamesystemMBean
annotation|@
name|Metric
argument_list|(
block|{
literal|"StaleDataNodes"
block|,
literal|"Number of datanodes marked stale due to delayed heartbeat"
block|}
argument_list|)
DECL|method|getNumStaleDataNodes ()
specifier|public
name|int
name|getNumStaleDataNodes
parameter_list|()
block|{
return|return
name|getBlockManager
argument_list|()
operator|.
name|getDatanodeManager
argument_list|()
operator|.
name|getNumStaleNodes
argument_list|()
return|;
block|}
comment|/**    * Storages are marked as "content stale" after NN restart or fails over and    * before NN receives the first Heartbeat followed by the first Blockreport.    */
annotation|@
name|Override
comment|// FSNamesystemMBean
DECL|method|getNumStaleStorages ()
specifier|public
name|int
name|getNumStaleStorages
parameter_list|()
block|{
return|return
name|getBlockManager
argument_list|()
operator|.
name|getDatanodeManager
argument_list|()
operator|.
name|getNumStaleStorages
argument_list|()
return|;
block|}
annotation|@
name|Override
comment|// FSNamesystemMBean
DECL|method|getTopUserOpCounts ()
specifier|public
name|String
name|getTopUserOpCounts
parameter_list|()
block|{
if|if
condition|(
operator|!
name|topConf
operator|.
name|isEnabled
condition|)
block|{
return|return
literal|null
return|;
block|}
name|Date
name|now
init|=
operator|new
name|Date
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RollingWindowManager
operator|.
name|TopWindow
argument_list|>
name|topWindows
init|=
name|topMetrics
operator|.
name|getTopWindows
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|topMap
init|=
operator|new
name|TreeMap
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
argument_list|()
decl_stmt|;
name|topMap
operator|.
name|put
argument_list|(
literal|"windows"
argument_list|,
name|topWindows
argument_list|)
expr_stmt|;
name|topMap
operator|.
name|put
argument_list|(
literal|"timestamp"
argument_list|,
name|DFSUtil
operator|.
name|dateToIso8601String
argument_list|(
name|now
argument_list|)
argument_list|)
expr_stmt|;
name|ObjectMapper
name|mapper
init|=
operator|new
name|ObjectMapper
argument_list|()
decl_stmt|;
try|try
block|{
return|return
name|mapper
operator|.
name|writeValueAsString
argument_list|(
name|topMap
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to fetch TopUser metrics"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
comment|/**    * Increments, logs and then returns the stamp    */
DECL|method|nextGenerationStamp (boolean legacyBlock)
name|long
name|nextGenerationStamp
parameter_list|(
name|boolean
name|legacyBlock
parameter_list|)
throws|throws
name|IOException
throws|,
name|SafeModeException
block|{
assert|assert
name|hasWriteLock
argument_list|()
assert|;
name|checkNameNodeSafeMode
argument_list|(
literal|"Cannot get next generation stamp"
argument_list|)
expr_stmt|;
name|long
name|gs
init|=
name|blockIdManager
operator|.
name|nextGenerationStamp
argument_list|(
name|legacyBlock
argument_list|)
decl_stmt|;
if|if
condition|(
name|legacyBlock
condition|)
block|{
name|getEditLog
argument_list|()
operator|.
name|logGenerationStampV1
argument_list|(
name|gs
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|getEditLog
argument_list|()
operator|.
name|logGenerationStampV2
argument_list|(
name|gs
argument_list|)
expr_stmt|;
block|}
comment|// NB: callers sync the log
return|return
name|gs
return|;
block|}
comment|/**    * Increments, logs and then returns the block ID    */
DECL|method|nextBlockId ()
specifier|private
name|long
name|nextBlockId
parameter_list|()
throws|throws
name|IOException
block|{
assert|assert
name|hasWriteLock
argument_list|()
assert|;
name|checkNameNodeSafeMode
argument_list|(
literal|"Cannot get next block ID"
argument_list|)
expr_stmt|;
specifier|final
name|long
name|blockId
init|=
name|blockIdManager
operator|.
name|nextBlockId
argument_list|()
decl_stmt|;
name|getEditLog
argument_list|()
operator|.
name|logAllocateBlockId
argument_list|(
name|blockId
argument_list|)
expr_stmt|;
comment|// NB: callers sync the log
return|return
name|blockId
return|;
block|}
DECL|method|isFileDeleted (INodeFile file)
specifier|private
name|boolean
name|isFileDeleted
parameter_list|(
name|INodeFile
name|file
parameter_list|)
block|{
comment|// Not in the inodeMap or in the snapshot but marked deleted.
if|if
condition|(
name|dir
operator|.
name|getInode
argument_list|(
name|file
operator|.
name|getId
argument_list|()
argument_list|)
operator|==
literal|null
condition|)
block|{
return|return
literal|true
return|;
block|}
comment|// look at the path hierarchy to see if one parent is deleted by recursive
comment|// deletion
name|INode
name|tmpChild
init|=
name|file
decl_stmt|;
name|INodeDirectory
name|tmpParent
init|=
name|file
operator|.
name|getParent
argument_list|()
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
if|if
condition|(
name|tmpParent
operator|==
literal|null
condition|)
block|{
return|return
literal|true
return|;
block|}
name|INode
name|childINode
init|=
name|tmpParent
operator|.
name|getChild
argument_list|(
name|tmpChild
operator|.
name|getLocalNameBytes
argument_list|()
argument_list|,
name|Snapshot
operator|.
name|CURRENT_STATE_ID
argument_list|)
decl_stmt|;
if|if
condition|(
name|childINode
operator|==
literal|null
operator|||
operator|!
name|childINode
operator|.
name|equals
argument_list|(
name|tmpChild
argument_list|)
condition|)
block|{
comment|// a newly created INode with the same name as an already deleted one
comment|// would be a different INode than the deleted one
return|return
literal|true
return|;
block|}
if|if
condition|(
name|tmpParent
operator|.
name|isRoot
argument_list|()
condition|)
block|{
break|break;
block|}
name|tmpChild
operator|=
name|tmpParent
expr_stmt|;
name|tmpParent
operator|=
name|tmpParent
operator|.
name|getParent
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|file
operator|.
name|isWithSnapshot
argument_list|()
operator|&&
name|file
operator|.
name|getFileWithSnapshotFeature
argument_list|()
operator|.
name|isCurrentFileDeleted
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
DECL|method|checkUCBlock (ExtendedBlock block, String clientName)
specifier|private
name|INodeFile
name|checkUCBlock
parameter_list|(
name|ExtendedBlock
name|block
parameter_list|,
name|String
name|clientName
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|hasWriteLock
argument_list|()
assert|;
name|checkNameNodeSafeMode
argument_list|(
literal|"Cannot get a new generation stamp and an "
operator|+
literal|"access token for block "
operator|+
name|block
argument_list|)
expr_stmt|;
comment|// check stored block state
name|BlockInfoContiguous
name|storedBlock
init|=
name|getStoredBlock
argument_list|(
name|ExtendedBlock
operator|.
name|getLocalBlock
argument_list|(
name|block
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|storedBlock
operator|==
literal|null
operator|||
name|storedBlock
operator|.
name|getBlockUCState
argument_list|()
operator|!=
name|BlockUCState
operator|.
name|UNDER_CONSTRUCTION
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|block
operator|+
literal|" does not exist or is not under Construction"
operator|+
name|storedBlock
argument_list|)
throw|;
block|}
comment|// check file inode
specifier|final
name|INodeFile
name|file
init|=
operator|(
operator|(
name|INode
operator|)
name|storedBlock
operator|.
name|getBlockCollection
argument_list|()
operator|)
operator|.
name|asFile
argument_list|()
decl_stmt|;
if|if
condition|(
name|file
operator|==
literal|null
operator|||
operator|!
name|file
operator|.
name|isUnderConstruction
argument_list|()
operator|||
name|isFileDeleted
argument_list|(
name|file
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"The file "
operator|+
name|storedBlock
operator|+
literal|" belonged to does not exist or it is not under construction."
argument_list|)
throw|;
block|}
comment|// check lease
if|if
condition|(
name|clientName
operator|==
literal|null
operator|||
operator|!
name|clientName
operator|.
name|equals
argument_list|(
name|file
operator|.
name|getFileUnderConstructionFeature
argument_list|()
operator|.
name|getClientName
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|LeaseExpiredException
argument_list|(
literal|"Lease mismatch: "
operator|+
name|block
operator|+
literal|" is accessed by a non lease holder "
operator|+
name|clientName
argument_list|)
throw|;
block|}
return|return
name|file
return|;
block|}
comment|/**    * Client is reporting some bad block locations.    */
DECL|method|reportBadBlocks (LocatedBlock[] blocks)
name|void
name|reportBadBlocks
parameter_list|(
name|LocatedBlock
index|[]
name|blocks
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|info
argument_list|(
literal|"*DIR* reportBadBlocks"
argument_list|)
expr_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|blocks
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|ExtendedBlock
name|blk
init|=
name|blocks
index|[
name|i
index|]
operator|.
name|getBlock
argument_list|()
decl_stmt|;
name|DatanodeInfo
index|[]
name|nodes
init|=
name|blocks
index|[
name|i
index|]
operator|.
name|getLocations
argument_list|()
decl_stmt|;
name|String
index|[]
name|storageIDs
init|=
name|blocks
index|[
name|i
index|]
operator|.
name|getStorageIDs
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|nodes
operator|.
name|length
condition|;
name|j
operator|++
control|)
block|{
name|blockManager
operator|.
name|findAndMarkBlockAsCorrupt
argument_list|(
name|blk
argument_list|,
name|nodes
index|[
name|j
index|]
argument_list|,
name|storageIDs
operator|==
literal|null
condition|?
literal|null
else|:
name|storageIDs
index|[
name|j
index|]
argument_list|,
literal|"client machine reported it"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Get a new generation stamp together with an access token for     * a block under construction    *     * This method is called for recovering a failed pipeline or setting up    * a pipeline to append to a block.    *     * @param block a block    * @param clientName the name of a client    * @return a located block with a new generation stamp and an access token    * @throws IOException if any error occurs    */
DECL|method|updateBlockForPipeline (ExtendedBlock block, String clientName)
name|LocatedBlock
name|updateBlockForPipeline
parameter_list|(
name|ExtendedBlock
name|block
parameter_list|,
name|String
name|clientName
parameter_list|)
throws|throws
name|IOException
block|{
name|LocatedBlock
name|locatedBlock
decl_stmt|;
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
comment|// check vadility of parameters
name|checkUCBlock
argument_list|(
name|block
argument_list|,
name|clientName
argument_list|)
expr_stmt|;
comment|// get a new generation stamp and an access token
name|block
operator|.
name|setGenerationStamp
argument_list|(
name|nextGenerationStamp
argument_list|(
name|blockIdManager
operator|.
name|isLegacyBlock
argument_list|(
name|block
operator|.
name|getLocalBlock
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|locatedBlock
operator|=
operator|new
name|LocatedBlock
argument_list|(
name|block
argument_list|,
operator|new
name|DatanodeInfo
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|blockManager
operator|.
name|setBlockToken
argument_list|(
name|locatedBlock
argument_list|,
name|BlockTokenIdentifier
operator|.
name|AccessMode
operator|.
name|WRITE
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
comment|// Ensure we record the new generation stamp
name|getEditLog
argument_list|()
operator|.
name|logSync
argument_list|()
expr_stmt|;
return|return
name|locatedBlock
return|;
block|}
comment|/**    * Update a pipeline for a block under construction    *     * @param clientName the name of the client    * @param oldBlock and old block    * @param newBlock a new block with a new generation stamp and length    * @param newNodes datanodes in the pipeline    * @throws IOException if any error occurs    */
DECL|method|updatePipeline ( String clientName, ExtendedBlock oldBlock, ExtendedBlock newBlock, DatanodeID[] newNodes, String[] newStorageIDs, boolean logRetryCache)
name|void
name|updatePipeline
parameter_list|(
name|String
name|clientName
parameter_list|,
name|ExtendedBlock
name|oldBlock
parameter_list|,
name|ExtendedBlock
name|newBlock
parameter_list|,
name|DatanodeID
index|[]
name|newNodes
parameter_list|,
name|String
index|[]
name|newStorageIDs
parameter_list|,
name|boolean
name|logRetryCache
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"updatePipeline("
operator|+
name|oldBlock
operator|.
name|getLocalBlock
argument_list|()
operator|+
literal|", newGS="
operator|+
name|newBlock
operator|.
name|getGenerationStamp
argument_list|()
operator|+
literal|", newLength="
operator|+
name|newBlock
operator|.
name|getNumBytes
argument_list|()
operator|+
literal|", newNodes="
operator|+
name|Arrays
operator|.
name|asList
argument_list|(
name|newNodes
argument_list|)
operator|+
literal|", client="
operator|+
name|clientName
operator|+
literal|")"
argument_list|)
expr_stmt|;
name|waitForLoadingFSImage
argument_list|()
expr_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|checkNameNodeSafeMode
argument_list|(
literal|"Pipeline not updated"
argument_list|)
expr_stmt|;
assert|assert
name|newBlock
operator|.
name|getBlockId
argument_list|()
operator|==
name|oldBlock
operator|.
name|getBlockId
argument_list|()
operator|:
name|newBlock
operator|+
literal|" and "
operator|+
name|oldBlock
operator|+
literal|" has different block identifier"
assert|;
name|updatePipelineInternal
argument_list|(
name|clientName
argument_list|,
name|oldBlock
argument_list|,
name|newBlock
argument_list|,
name|newNodes
argument_list|,
name|newStorageIDs
argument_list|,
name|logRetryCache
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
name|getEditLog
argument_list|()
operator|.
name|logSync
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"updatePipeline("
operator|+
name|oldBlock
operator|.
name|getLocalBlock
argument_list|()
operator|+
literal|" => "
operator|+
name|newBlock
operator|.
name|getLocalBlock
argument_list|()
operator|+
literal|") success"
argument_list|)
expr_stmt|;
block|}
DECL|method|updatePipelineInternal (String clientName, ExtendedBlock oldBlock, ExtendedBlock newBlock, DatanodeID[] newNodes, String[] newStorageIDs, boolean logRetryCache)
specifier|private
name|void
name|updatePipelineInternal
parameter_list|(
name|String
name|clientName
parameter_list|,
name|ExtendedBlock
name|oldBlock
parameter_list|,
name|ExtendedBlock
name|newBlock
parameter_list|,
name|DatanodeID
index|[]
name|newNodes
parameter_list|,
name|String
index|[]
name|newStorageIDs
parameter_list|,
name|boolean
name|logRetryCache
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|hasWriteLock
argument_list|()
assert|;
comment|// check the vadility of the block and lease holder name
specifier|final
name|INodeFile
name|pendingFile
init|=
name|checkUCBlock
argument_list|(
name|oldBlock
argument_list|,
name|clientName
argument_list|)
decl_stmt|;
specifier|final
name|BlockInfoContiguousUnderConstruction
name|blockinfo
init|=
operator|(
name|BlockInfoContiguousUnderConstruction
operator|)
name|pendingFile
operator|.
name|getLastBlock
argument_list|()
decl_stmt|;
comment|// check new GS& length: this is not expected
if|if
condition|(
name|newBlock
operator|.
name|getGenerationStamp
argument_list|()
operator|<=
name|blockinfo
operator|.
name|getGenerationStamp
argument_list|()
operator|||
name|newBlock
operator|.
name|getNumBytes
argument_list|()
operator|<
name|blockinfo
operator|.
name|getNumBytes
argument_list|()
condition|)
block|{
name|String
name|msg
init|=
literal|"Update "
operator|+
name|oldBlock
operator|+
literal|" (len = "
operator|+
name|blockinfo
operator|.
name|getNumBytes
argument_list|()
operator|+
literal|") to an older state: "
operator|+
name|newBlock
operator|+
literal|" (len = "
operator|+
name|newBlock
operator|.
name|getNumBytes
argument_list|()
operator|+
literal|")"
decl_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
name|msg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
name|msg
argument_list|)
throw|;
block|}
comment|// Update old block with the new generation stamp and new length
name|blockinfo
operator|.
name|setNumBytes
argument_list|(
name|newBlock
operator|.
name|getNumBytes
argument_list|()
argument_list|)
expr_stmt|;
name|blockinfo
operator|.
name|setGenerationStampAndVerifyReplicas
argument_list|(
name|newBlock
operator|.
name|getGenerationStamp
argument_list|()
argument_list|)
expr_stmt|;
comment|// find the DatanodeDescriptor objects
specifier|final
name|DatanodeStorageInfo
index|[]
name|storages
init|=
name|blockManager
operator|.
name|getDatanodeManager
argument_list|()
operator|.
name|getDatanodeStorageInfos
argument_list|(
name|newNodes
argument_list|,
name|newStorageIDs
argument_list|)
decl_stmt|;
name|blockinfo
operator|.
name|setExpectedLocations
argument_list|(
name|storages
argument_list|)
expr_stmt|;
name|String
name|src
init|=
name|pendingFile
operator|.
name|getFullPathName
argument_list|()
decl_stmt|;
name|persistBlocks
argument_list|(
name|src
argument_list|,
name|pendingFile
argument_list|,
name|logRetryCache
argument_list|)
expr_stmt|;
block|}
comment|// rename was successful. If any part of the renamed subtree had
comment|// files that were being written to, update with new filename.
DECL|method|unprotectedChangeLease (String src, String dst)
name|void
name|unprotectedChangeLease
parameter_list|(
name|String
name|src
parameter_list|,
name|String
name|dst
parameter_list|)
block|{
assert|assert
name|hasWriteLock
argument_list|()
assert|;
name|leaseManager
operator|.
name|changeLease
argument_list|(
name|src
argument_list|,
name|dst
argument_list|)
expr_stmt|;
block|}
comment|/**    * Serializes leases.    */
DECL|method|saveFilesUnderConstruction (DataOutputStream out, Map<Long, INodeFile> snapshotUCMap)
name|void
name|saveFilesUnderConstruction
parameter_list|(
name|DataOutputStream
name|out
parameter_list|,
name|Map
argument_list|<
name|Long
argument_list|,
name|INodeFile
argument_list|>
name|snapshotUCMap
parameter_list|)
throws|throws
name|IOException
block|{
comment|// This is run by an inferior thread of saveNamespace, which holds a read
comment|// lock on our behalf. If we took the read lock here, we could block
comment|// for fairness if a writer is waiting on the lock.
synchronized|synchronized
init|(
name|leaseManager
init|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|INodeFile
argument_list|>
name|nodes
init|=
name|leaseManager
operator|.
name|getINodesUnderConstruction
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|INodeFile
argument_list|>
name|entry
range|:
name|nodes
operator|.
name|entrySet
argument_list|()
control|)
block|{
comment|// TODO: for HDFS-5428, because of rename operations, some
comment|// under-construction files that are
comment|// in the current fs directory can also be captured in the
comment|// snapshotUCMap. We should remove them from the snapshotUCMap.
name|snapshotUCMap
operator|.
name|remove
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|out
operator|.
name|writeInt
argument_list|(
name|nodes
operator|.
name|size
argument_list|()
operator|+
name|snapshotUCMap
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
comment|// write the size
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|INodeFile
argument_list|>
name|entry
range|:
name|nodes
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|FSImageSerialization
operator|.
name|writeINodeUnderConstruction
argument_list|(
name|out
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|,
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|Long
argument_list|,
name|INodeFile
argument_list|>
name|entry
range|:
name|snapshotUCMap
operator|.
name|entrySet
argument_list|()
control|)
block|{
comment|// for those snapshot INodeFileUC, we use "/.reserved/.inodes/<inodeid>"
comment|// as their paths
name|StringBuilder
name|b
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|b
operator|.
name|append
argument_list|(
name|FSDirectory
operator|.
name|DOT_RESERVED_PATH_PREFIX
argument_list|)
operator|.
name|append
argument_list|(
name|Path
operator|.
name|SEPARATOR
argument_list|)
operator|.
name|append
argument_list|(
name|FSDirectory
operator|.
name|DOT_INODES_STRING
argument_list|)
operator|.
name|append
argument_list|(
name|Path
operator|.
name|SEPARATOR
argument_list|)
operator|.
name|append
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
name|FSImageSerialization
operator|.
name|writeINodeUnderConstruction
argument_list|(
name|out
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|,
name|b
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * @return all the under-construction files in the lease map    */
DECL|method|getFilesUnderConstruction ()
name|Map
argument_list|<
name|String
argument_list|,
name|INodeFile
argument_list|>
name|getFilesUnderConstruction
parameter_list|()
block|{
synchronized|synchronized
init|(
name|leaseManager
init|)
block|{
return|return
name|leaseManager
operator|.
name|getINodesUnderConstruction
argument_list|()
return|;
block|}
block|}
comment|/**    * Register a Backup name-node, verifying that it belongs    * to the correct namespace, and adding it to the set of    * active journals if necessary.    *     * @param bnReg registration of the new BackupNode    * @param nnReg registration of this NameNode    * @throws IOException if the namespace IDs do not match    */
DECL|method|registerBackupNode (NamenodeRegistration bnReg, NamenodeRegistration nnReg)
name|void
name|registerBackupNode
parameter_list|(
name|NamenodeRegistration
name|bnReg
parameter_list|,
name|NamenodeRegistration
name|nnReg
parameter_list|)
throws|throws
name|IOException
block|{
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
name|getFSImage
argument_list|()
operator|.
name|getStorage
argument_list|()
operator|.
name|getNamespaceID
argument_list|()
operator|!=
name|bnReg
operator|.
name|getNamespaceID
argument_list|()
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Incompatible namespaceIDs: "
operator|+
literal|" Namenode namespaceID = "
operator|+
name|getFSImage
argument_list|()
operator|.
name|getStorage
argument_list|()
operator|.
name|getNamespaceID
argument_list|()
operator|+
literal|"; "
operator|+
name|bnReg
operator|.
name|getRole
argument_list|()
operator|+
literal|" node namespaceID = "
operator|+
name|bnReg
operator|.
name|getNamespaceID
argument_list|()
argument_list|)
throw|;
if|if
condition|(
name|bnReg
operator|.
name|getRole
argument_list|()
operator|==
name|NamenodeRole
operator|.
name|BACKUP
condition|)
block|{
name|getFSImage
argument_list|()
operator|.
name|getEditLog
argument_list|()
operator|.
name|registerBackupNode
argument_list|(
name|bnReg
argument_list|,
name|nnReg
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Release (unregister) backup node.    *<p>    * Find and remove the backup stream corresponding to the node.    * @throws IOException    */
DECL|method|releaseBackupNode (NamenodeRegistration registration)
name|void
name|releaseBackupNode
parameter_list|(
name|NamenodeRegistration
name|registration
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|getFSImage
argument_list|()
operator|.
name|getStorage
argument_list|()
operator|.
name|getNamespaceID
argument_list|()
operator|!=
name|registration
operator|.
name|getNamespaceID
argument_list|()
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Incompatible namespaceIDs: "
operator|+
literal|" Namenode namespaceID = "
operator|+
name|getFSImage
argument_list|()
operator|.
name|getStorage
argument_list|()
operator|.
name|getNamespaceID
argument_list|()
operator|+
literal|"; "
operator|+
name|registration
operator|.
name|getRole
argument_list|()
operator|+
literal|" node namespaceID = "
operator|+
name|registration
operator|.
name|getNamespaceID
argument_list|()
argument_list|)
throw|;
name|getEditLog
argument_list|()
operator|.
name|releaseBackupStream
argument_list|(
name|registration
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|class|CorruptFileBlockInfo
specifier|static
class|class
name|CorruptFileBlockInfo
block|{
DECL|field|path
specifier|final
name|String
name|path
decl_stmt|;
DECL|field|block
specifier|final
name|Block
name|block
decl_stmt|;
DECL|method|CorruptFileBlockInfo (String p, Block b)
specifier|public
name|CorruptFileBlockInfo
parameter_list|(
name|String
name|p
parameter_list|,
name|Block
name|b
parameter_list|)
block|{
name|path
operator|=
name|p
expr_stmt|;
name|block
operator|=
name|b
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|block
operator|.
name|getBlockName
argument_list|()
operator|+
literal|"\t"
operator|+
name|path
return|;
block|}
block|}
comment|/**    * @param path Restrict corrupt files to this portion of namespace.    * @param cookieTab Support for continuation; cookieTab  tells where    *                  to start from    * @return a list in which each entry describes a corrupt file/block    * @throws IOException    */
DECL|method|listCorruptFileBlocks (String path, String[] cookieTab)
name|Collection
argument_list|<
name|CorruptFileBlockInfo
argument_list|>
name|listCorruptFileBlocks
parameter_list|(
name|String
name|path
parameter_list|,
name|String
index|[]
name|cookieTab
parameter_list|)
throws|throws
name|IOException
block|{
name|checkSuperuserPrivilege
argument_list|()
expr_stmt|;
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|READ
argument_list|)
expr_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
name|ArrayList
argument_list|<
name|CorruptFileBlockInfo
argument_list|>
name|corruptFiles
init|=
operator|new
name|ArrayList
argument_list|<
name|CorruptFileBlockInfo
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|cookieTab
operator|==
literal|null
condition|)
block|{
name|cookieTab
operator|=
operator|new
name|String
index|[]
block|{
literal|null
block|}
expr_stmt|;
block|}
comment|// Do a quick check if there are any corrupt files without taking the lock
if|if
condition|(
name|blockManager
operator|.
name|getMissingBlocksCount
argument_list|()
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|cookieTab
index|[
literal|0
index|]
operator|==
literal|null
condition|)
block|{
name|cookieTab
index|[
literal|0
index|]
operator|=
name|String
operator|.
name|valueOf
argument_list|(
name|getIntCookie
argument_list|(
name|cookieTab
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"there are no corrupt file blocks."
argument_list|)
expr_stmt|;
return|return
name|corruptFiles
return|;
block|}
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|READ
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isPopulatingReplQueues
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Cannot run listCorruptFileBlocks because "
operator|+
literal|"replication queues have not been initialized."
argument_list|)
throw|;
block|}
comment|// print a limited # of corrupt files per call
specifier|final
name|Iterator
argument_list|<
name|Block
argument_list|>
name|blkIterator
init|=
name|blockManager
operator|.
name|getCorruptReplicaBlockIterator
argument_list|()
decl_stmt|;
name|int
name|skip
init|=
name|getIntCookie
argument_list|(
name|cookieTab
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|skip
operator|&&
name|blkIterator
operator|.
name|hasNext
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|blkIterator
operator|.
name|next
argument_list|()
expr_stmt|;
block|}
while|while
condition|(
name|blkIterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Block
name|blk
init|=
name|blkIterator
operator|.
name|next
argument_list|()
decl_stmt|;
specifier|final
name|INode
name|inode
init|=
operator|(
name|INode
operator|)
name|blockManager
operator|.
name|getBlockCollection
argument_list|(
name|blk
argument_list|)
decl_stmt|;
name|skip
operator|++
expr_stmt|;
if|if
condition|(
name|inode
operator|!=
literal|null
operator|&&
name|blockManager
operator|.
name|countNodes
argument_list|(
name|blk
argument_list|)
operator|.
name|liveReplicas
argument_list|()
operator|==
literal|0
condition|)
block|{
name|String
name|src
init|=
name|FSDirectory
operator|.
name|getFullPathName
argument_list|(
name|inode
argument_list|)
decl_stmt|;
if|if
condition|(
name|src
operator|.
name|startsWith
argument_list|(
name|path
argument_list|)
condition|)
block|{
name|corruptFiles
operator|.
name|add
argument_list|(
operator|new
name|CorruptFileBlockInfo
argument_list|(
name|src
argument_list|,
name|blk
argument_list|)
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
if|if
condition|(
name|count
operator|>=
name|DEFAULT_MAX_CORRUPT_FILEBLOCKS_RETURNED
condition|)
break|break;
block|}
block|}
block|}
name|cookieTab
index|[
literal|0
index|]
operator|=
name|String
operator|.
name|valueOf
argument_list|(
name|skip
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"list corrupt file blocks returned: "
operator|+
name|count
argument_list|)
expr_stmt|;
return|return
name|corruptFiles
return|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Convert string cookie to integer.    */
DECL|method|getIntCookie (String cookie)
specifier|private
specifier|static
name|int
name|getIntCookie
parameter_list|(
name|String
name|cookie
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
if|if
condition|(
name|cookie
operator|==
literal|null
condition|)
block|{
name|c
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
try|try
block|{
name|c
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|cookie
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
name|c
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|c
operator|=
name|Math
operator|.
name|max
argument_list|(
literal|0
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return
name|c
return|;
block|}
comment|/**    * Create delegation token secret manager    */
DECL|method|createDelegationTokenSecretManager ( Configuration conf)
specifier|private
name|DelegationTokenSecretManager
name|createDelegationTokenSecretManager
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
return|return
operator|new
name|DelegationTokenSecretManager
argument_list|(
name|conf
operator|.
name|getLong
argument_list|(
name|DFS_NAMENODE_DELEGATION_KEY_UPDATE_INTERVAL_KEY
argument_list|,
name|DFS_NAMENODE_DELEGATION_KEY_UPDATE_INTERVAL_DEFAULT
argument_list|)
argument_list|,
name|conf
operator|.
name|getLong
argument_list|(
name|DFS_NAMENODE_DELEGATION_TOKEN_MAX_LIFETIME_KEY
argument_list|,
name|DFS_NAMENODE_DELEGATION_TOKEN_MAX_LIFETIME_DEFAULT
argument_list|)
argument_list|,
name|conf
operator|.
name|getLong
argument_list|(
name|DFS_NAMENODE_DELEGATION_TOKEN_RENEW_INTERVAL_KEY
argument_list|,
name|DFS_NAMENODE_DELEGATION_TOKEN_RENEW_INTERVAL_DEFAULT
argument_list|)
argument_list|,
name|DELEGATION_TOKEN_REMOVER_SCAN_INTERVAL
argument_list|,
name|conf
operator|.
name|getBoolean
argument_list|(
name|DFS_NAMENODE_AUDIT_LOG_TOKEN_TRACKING_ID_KEY
argument_list|,
name|DFS_NAMENODE_AUDIT_LOG_TOKEN_TRACKING_ID_DEFAULT
argument_list|)
argument_list|,
name|this
argument_list|)
return|;
block|}
comment|/**    * Returns the DelegationTokenSecretManager instance in the namesystem.    * @return delegation token secret manager object    */
DECL|method|getDelegationTokenSecretManager ()
name|DelegationTokenSecretManager
name|getDelegationTokenSecretManager
parameter_list|()
block|{
return|return
name|dtSecretManager
return|;
block|}
comment|/**    * @param renewer Renewer information    * @return delegation toek    * @throws IOException on error    */
DECL|method|getDelegationToken (Text renewer)
name|Token
argument_list|<
name|DelegationTokenIdentifier
argument_list|>
name|getDelegationToken
parameter_list|(
name|Text
name|renewer
parameter_list|)
throws|throws
name|IOException
block|{
name|Token
argument_list|<
name|DelegationTokenIdentifier
argument_list|>
name|token
decl_stmt|;
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|checkNameNodeSafeMode
argument_list|(
literal|"Cannot issue delegation token"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isAllowedDelegationTokenOp
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Delegation Token can be issued only with kerberos or web authentication"
argument_list|)
throw|;
block|}
if|if
condition|(
name|dtSecretManager
operator|==
literal|null
operator|||
operator|!
name|dtSecretManager
operator|.
name|isRunning
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"trying to get DT with no secret manager running"
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
name|UserGroupInformation
name|ugi
init|=
name|getRemoteUser
argument_list|()
decl_stmt|;
name|String
name|user
init|=
name|ugi
operator|.
name|getUserName
argument_list|()
decl_stmt|;
name|Text
name|owner
init|=
operator|new
name|Text
argument_list|(
name|user
argument_list|)
decl_stmt|;
name|Text
name|realUser
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|ugi
operator|.
name|getRealUser
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|realUser
operator|=
operator|new
name|Text
argument_list|(
name|ugi
operator|.
name|getRealUser
argument_list|()
operator|.
name|getUserName
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|DelegationTokenIdentifier
name|dtId
init|=
operator|new
name|DelegationTokenIdentifier
argument_list|(
name|owner
argument_list|,
name|renewer
argument_list|,
name|realUser
argument_list|)
decl_stmt|;
name|token
operator|=
operator|new
name|Token
argument_list|<
name|DelegationTokenIdentifier
argument_list|>
argument_list|(
name|dtId
argument_list|,
name|dtSecretManager
argument_list|)
expr_stmt|;
name|long
name|expiryTime
init|=
name|dtSecretManager
operator|.
name|getTokenExpiryTime
argument_list|(
name|dtId
argument_list|)
decl_stmt|;
name|getEditLog
argument_list|()
operator|.
name|logGetDelegationToken
argument_list|(
name|dtId
argument_list|,
name|expiryTime
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
name|getEditLog
argument_list|()
operator|.
name|logSync
argument_list|()
expr_stmt|;
return|return
name|token
return|;
block|}
comment|/**    *     * @param token token to renew    * @return new expiryTime of the token    * @throws InvalidToken if {@code token} is invalid    * @throws IOException on other errors    */
DECL|method|renewDelegationToken (Token<DelegationTokenIdentifier> token)
name|long
name|renewDelegationToken
parameter_list|(
name|Token
argument_list|<
name|DelegationTokenIdentifier
argument_list|>
name|token
parameter_list|)
throws|throws
name|InvalidToken
throws|,
name|IOException
block|{
name|long
name|expiryTime
decl_stmt|;
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|checkNameNodeSafeMode
argument_list|(
literal|"Cannot renew delegation token"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isAllowedDelegationTokenOp
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Delegation Token can be renewed only with kerberos or web authentication"
argument_list|)
throw|;
block|}
name|String
name|renewer
init|=
name|getRemoteUser
argument_list|()
operator|.
name|getShortUserName
argument_list|()
decl_stmt|;
name|expiryTime
operator|=
name|dtSecretManager
operator|.
name|renewToken
argument_list|(
name|token
argument_list|,
name|renewer
argument_list|)
expr_stmt|;
name|DelegationTokenIdentifier
name|id
init|=
operator|new
name|DelegationTokenIdentifier
argument_list|()
decl_stmt|;
name|ByteArrayInputStream
name|buf
init|=
operator|new
name|ByteArrayInputStream
argument_list|(
name|token
operator|.
name|getIdentifier
argument_list|()
argument_list|)
decl_stmt|;
name|DataInputStream
name|in
init|=
operator|new
name|DataInputStream
argument_list|(
name|buf
argument_list|)
decl_stmt|;
name|id
operator|.
name|readFields
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|getEditLog
argument_list|()
operator|.
name|logRenewDelegationToken
argument_list|(
name|id
argument_list|,
name|expiryTime
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
name|getEditLog
argument_list|()
operator|.
name|logSync
argument_list|()
expr_stmt|;
return|return
name|expiryTime
return|;
block|}
comment|/**    *     * @param token token to cancel    * @throws IOException on error    */
DECL|method|cancelDelegationToken (Token<DelegationTokenIdentifier> token)
name|void
name|cancelDelegationToken
parameter_list|(
name|Token
argument_list|<
name|DelegationTokenIdentifier
argument_list|>
name|token
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|checkNameNodeSafeMode
argument_list|(
literal|"Cannot cancel delegation token"
argument_list|)
expr_stmt|;
name|String
name|canceller
init|=
name|getRemoteUser
argument_list|()
operator|.
name|getUserName
argument_list|()
decl_stmt|;
name|DelegationTokenIdentifier
name|id
init|=
name|dtSecretManager
operator|.
name|cancelToken
argument_list|(
name|token
argument_list|,
name|canceller
argument_list|)
decl_stmt|;
name|getEditLog
argument_list|()
operator|.
name|logCancelDelegationToken
argument_list|(
name|id
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
name|getEditLog
argument_list|()
operator|.
name|logSync
argument_list|()
expr_stmt|;
block|}
comment|/**    * @param out save state of the secret manager    * @param sdPath String storage directory path    */
DECL|method|saveSecretManagerStateCompat (DataOutputStream out, String sdPath)
name|void
name|saveSecretManagerStateCompat
parameter_list|(
name|DataOutputStream
name|out
parameter_list|,
name|String
name|sdPath
parameter_list|)
throws|throws
name|IOException
block|{
name|dtSecretManager
operator|.
name|saveSecretManagerStateCompat
argument_list|(
name|out
argument_list|,
name|sdPath
argument_list|)
expr_stmt|;
block|}
DECL|method|saveSecretManagerState ()
name|SecretManagerState
name|saveSecretManagerState
parameter_list|()
block|{
return|return
name|dtSecretManager
operator|.
name|saveSecretManagerState
argument_list|()
return|;
block|}
comment|/**    * @param in load the state of secret manager from input stream    */
DECL|method|loadSecretManagerStateCompat (DataInput in)
name|void
name|loadSecretManagerStateCompat
parameter_list|(
name|DataInput
name|in
parameter_list|)
throws|throws
name|IOException
block|{
name|dtSecretManager
operator|.
name|loadSecretManagerStateCompat
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
DECL|method|loadSecretManagerState (SecretManagerSection s, List<SecretManagerSection.DelegationKey> keys, List<SecretManagerSection.PersistToken> tokens)
name|void
name|loadSecretManagerState
parameter_list|(
name|SecretManagerSection
name|s
parameter_list|,
name|List
argument_list|<
name|SecretManagerSection
operator|.
name|DelegationKey
argument_list|>
name|keys
parameter_list|,
name|List
argument_list|<
name|SecretManagerSection
operator|.
name|PersistToken
argument_list|>
name|tokens
parameter_list|)
throws|throws
name|IOException
block|{
name|dtSecretManager
operator|.
name|loadSecretManagerState
argument_list|(
operator|new
name|SecretManagerState
argument_list|(
name|s
argument_list|,
name|keys
argument_list|,
name|tokens
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Log the updateMasterKey operation to edit logs    *     * @param key new delegation key.    */
DECL|method|logUpdateMasterKey (DelegationKey key)
specifier|public
name|void
name|logUpdateMasterKey
parameter_list|(
name|DelegationKey
name|key
parameter_list|)
block|{
assert|assert
operator|!
name|isInSafeMode
argument_list|()
operator|:
literal|"this should never be called while in safemode, since we stop "
operator|+
literal|"the DT manager before entering safemode!"
assert|;
comment|// No need to hold FSN lock since we don't access any internal
comment|// structures, and this is stopped before the FSN shuts itself
comment|// down, etc.
name|getEditLog
argument_list|()
operator|.
name|logUpdateMasterKey
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|getEditLog
argument_list|()
operator|.
name|logSync
argument_list|()
expr_stmt|;
block|}
comment|/**    * Log the cancellation of expired tokens to edit logs    *     * @param id token identifier to cancel    */
DECL|method|logExpireDelegationToken (DelegationTokenIdentifier id)
specifier|public
name|void
name|logExpireDelegationToken
parameter_list|(
name|DelegationTokenIdentifier
name|id
parameter_list|)
block|{
assert|assert
operator|!
name|isInSafeMode
argument_list|()
operator|:
literal|"this should never be called while in safemode, since we stop "
operator|+
literal|"the DT manager before entering safemode!"
assert|;
comment|// No need to hold FSN lock since we don't access any internal
comment|// structures, and this is stopped before the FSN shuts itself
comment|// down, etc.
name|getEditLog
argument_list|()
operator|.
name|logCancelDelegationToken
argument_list|(
name|id
argument_list|)
expr_stmt|;
block|}
DECL|method|logReassignLease (String leaseHolder, String src, String newHolder)
specifier|private
name|void
name|logReassignLease
parameter_list|(
name|String
name|leaseHolder
parameter_list|,
name|String
name|src
parameter_list|,
name|String
name|newHolder
parameter_list|)
block|{
assert|assert
name|hasWriteLock
argument_list|()
assert|;
name|getEditLog
argument_list|()
operator|.
name|logReassignLease
argument_list|(
name|leaseHolder
argument_list|,
name|src
argument_list|,
name|newHolder
argument_list|)
expr_stmt|;
block|}
comment|/**    *     * @return true if delegation token operation is allowed    */
DECL|method|isAllowedDelegationTokenOp ()
specifier|private
name|boolean
name|isAllowedDelegationTokenOp
parameter_list|()
throws|throws
name|IOException
block|{
name|AuthenticationMethod
name|authMethod
init|=
name|getConnectionAuthenticationMethod
argument_list|()
decl_stmt|;
if|if
condition|(
name|UserGroupInformation
operator|.
name|isSecurityEnabled
argument_list|()
operator|&&
operator|(
name|authMethod
operator|!=
name|AuthenticationMethod
operator|.
name|KERBEROS
operator|)
operator|&&
operator|(
name|authMethod
operator|!=
name|AuthenticationMethod
operator|.
name|KERBEROS_SSL
operator|)
operator|&&
operator|(
name|authMethod
operator|!=
name|AuthenticationMethod
operator|.
name|CERTIFICATE
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Returns authentication method used to establish the connection    * @return AuthenticationMethod used to establish connection    * @throws IOException    */
DECL|method|getConnectionAuthenticationMethod ()
specifier|private
name|AuthenticationMethod
name|getConnectionAuthenticationMethod
parameter_list|()
throws|throws
name|IOException
block|{
name|UserGroupInformation
name|ugi
init|=
name|getRemoteUser
argument_list|()
decl_stmt|;
name|AuthenticationMethod
name|authMethod
init|=
name|ugi
operator|.
name|getAuthenticationMethod
argument_list|()
decl_stmt|;
if|if
condition|(
name|authMethod
operator|==
name|AuthenticationMethod
operator|.
name|PROXY
condition|)
block|{
name|authMethod
operator|=
name|ugi
operator|.
name|getRealUser
argument_list|()
operator|.
name|getAuthenticationMethod
argument_list|()
expr_stmt|;
block|}
return|return
name|authMethod
return|;
block|}
comment|/**    * Client invoked methods are invoked over RPC and will be in     * RPC call context even if the client exits.    */
DECL|method|isExternalInvocation ()
name|boolean
name|isExternalInvocation
parameter_list|()
block|{
return|return
name|Server
operator|.
name|isRpcInvocation
argument_list|()
operator|||
name|NamenodeWebHdfsMethods
operator|.
name|isWebHdfsInvocation
argument_list|()
return|;
block|}
DECL|method|getRemoteIp ()
specifier|private
specifier|static
name|InetAddress
name|getRemoteIp
parameter_list|()
block|{
name|InetAddress
name|ip
init|=
name|Server
operator|.
name|getRemoteIp
argument_list|()
decl_stmt|;
if|if
condition|(
name|ip
operator|!=
literal|null
condition|)
block|{
return|return
name|ip
return|;
block|}
return|return
name|NamenodeWebHdfsMethods
operator|.
name|getRemoteIp
argument_list|()
return|;
block|}
comment|// optimize ugi lookup for RPC operations to avoid a trip through
comment|// UGI.getCurrentUser which is synch'ed
DECL|method|getRemoteUser ()
specifier|private
specifier|static
name|UserGroupInformation
name|getRemoteUser
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|NameNode
operator|.
name|getRemoteUser
argument_list|()
return|;
block|}
comment|/**    * Log fsck event in the audit log     */
DECL|method|logFsckEvent (String src, InetAddress remoteAddress)
name|void
name|logFsckEvent
parameter_list|(
name|String
name|src
parameter_list|,
name|InetAddress
name|remoteAddress
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|isAuditEnabled
argument_list|()
condition|)
block|{
name|logAuditEvent
argument_list|(
literal|true
argument_list|,
name|getRemoteUser
argument_list|()
argument_list|,
name|remoteAddress
argument_list|,
literal|"fsck"
argument_list|,
name|src
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Register NameNodeMXBean    */
DECL|method|registerMXBean ()
specifier|private
name|void
name|registerMXBean
parameter_list|()
block|{
name|mxbeanName
operator|=
name|MBeans
operator|.
name|register
argument_list|(
literal|"NameNode"
argument_list|,
literal|"NameNodeInfo"
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
comment|/**    * Class representing Namenode information for JMX interfaces    */
annotation|@
name|Override
comment|// NameNodeMXBean
DECL|method|getVersion ()
specifier|public
name|String
name|getVersion
parameter_list|()
block|{
return|return
name|VersionInfo
operator|.
name|getVersion
argument_list|()
operator|+
literal|", r"
operator|+
name|VersionInfo
operator|.
name|getRevision
argument_list|()
return|;
block|}
annotation|@
name|Override
comment|// NameNodeMXBean
DECL|method|getUsed ()
specifier|public
name|long
name|getUsed
parameter_list|()
block|{
return|return
name|this
operator|.
name|getCapacityUsed
argument_list|()
return|;
block|}
annotation|@
name|Override
comment|// NameNodeMXBean
DECL|method|getFree ()
specifier|public
name|long
name|getFree
parameter_list|()
block|{
return|return
name|this
operator|.
name|getCapacityRemaining
argument_list|()
return|;
block|}
annotation|@
name|Override
comment|// NameNodeMXBean
DECL|method|getTotal ()
specifier|public
name|long
name|getTotal
parameter_list|()
block|{
return|return
name|this
operator|.
name|getCapacityTotal
argument_list|()
return|;
block|}
annotation|@
name|Override
comment|// NameNodeMXBean
DECL|method|getSafemode ()
specifier|public
name|String
name|getSafemode
parameter_list|()
block|{
if|if
condition|(
operator|!
name|this
operator|.
name|isInSafeMode
argument_list|()
condition|)
return|return
literal|""
return|;
return|return
literal|"Safe mode is ON. "
operator|+
name|this
operator|.
name|getSafeModeTip
argument_list|()
return|;
block|}
annotation|@
name|Override
comment|// NameNodeMXBean
DECL|method|isUpgradeFinalized ()
specifier|public
name|boolean
name|isUpgradeFinalized
parameter_list|()
block|{
return|return
name|this
operator|.
name|getFSImage
argument_list|()
operator|.
name|isUpgradeFinalized
argument_list|()
return|;
block|}
annotation|@
name|Override
comment|// NameNodeMXBean
DECL|method|getNonDfsUsedSpace ()
specifier|public
name|long
name|getNonDfsUsedSpace
parameter_list|()
block|{
return|return
name|datanodeStatistics
operator|.
name|getCapacityUsedNonDFS
argument_list|()
return|;
block|}
annotation|@
name|Override
comment|// NameNodeMXBean
DECL|method|getPercentUsed ()
specifier|public
name|float
name|getPercentUsed
parameter_list|()
block|{
return|return
name|datanodeStatistics
operator|.
name|getCapacityUsedPercent
argument_list|()
return|;
block|}
annotation|@
name|Override
comment|// NameNodeMXBean
DECL|method|getBlockPoolUsedSpace ()
specifier|public
name|long
name|getBlockPoolUsedSpace
parameter_list|()
block|{
return|return
name|datanodeStatistics
operator|.
name|getBlockPoolUsed
argument_list|()
return|;
block|}
annotation|@
name|Override
comment|// NameNodeMXBean
DECL|method|getPercentBlockPoolUsed ()
specifier|public
name|float
name|getPercentBlockPoolUsed
parameter_list|()
block|{
return|return
name|datanodeStatistics
operator|.
name|getPercentBlockPoolUsed
argument_list|()
return|;
block|}
annotation|@
name|Override
comment|// NameNodeMXBean
DECL|method|getPercentRemaining ()
specifier|public
name|float
name|getPercentRemaining
parameter_list|()
block|{
return|return
name|datanodeStatistics
operator|.
name|getCapacityRemainingPercent
argument_list|()
return|;
block|}
annotation|@
name|Override
comment|// NameNodeMXBean
DECL|method|getCacheCapacity ()
specifier|public
name|long
name|getCacheCapacity
parameter_list|()
block|{
return|return
name|datanodeStatistics
operator|.
name|getCacheCapacity
argument_list|()
return|;
block|}
annotation|@
name|Override
comment|// NameNodeMXBean
DECL|method|getCacheUsed ()
specifier|public
name|long
name|getCacheUsed
parameter_list|()
block|{
return|return
name|datanodeStatistics
operator|.
name|getCacheUsed
argument_list|()
return|;
block|}
annotation|@
name|Override
comment|// NameNodeMXBean
DECL|method|getTotalBlocks ()
specifier|public
name|long
name|getTotalBlocks
parameter_list|()
block|{
return|return
name|getBlocksTotal
argument_list|()
return|;
block|}
annotation|@
name|Override
comment|// NameNodeMXBean
annotation|@
name|Metric
DECL|method|getTotalFiles ()
specifier|public
name|long
name|getTotalFiles
parameter_list|()
block|{
return|return
name|getFilesTotal
argument_list|()
return|;
block|}
annotation|@
name|Override
comment|// NameNodeMXBean
DECL|method|getNumberOfMissingBlocks ()
specifier|public
name|long
name|getNumberOfMissingBlocks
parameter_list|()
block|{
return|return
name|getMissingBlocksCount
argument_list|()
return|;
block|}
annotation|@
name|Override
comment|// NameNodeMXBean
DECL|method|getNumberOfMissingBlocksWithReplicationFactorOne ()
specifier|public
name|long
name|getNumberOfMissingBlocksWithReplicationFactorOne
parameter_list|()
block|{
return|return
name|getMissingReplOneBlocksCount
argument_list|()
return|;
block|}
annotation|@
name|Override
comment|// NameNodeMXBean
DECL|method|getThreads ()
specifier|public
name|int
name|getThreads
parameter_list|()
block|{
return|return
name|ManagementFactory
operator|.
name|getThreadMXBean
argument_list|()
operator|.
name|getThreadCount
argument_list|()
return|;
block|}
comment|/**    * Returned information is a JSON representation of map with host name as the    * key and value is a map of live node attribute keys to its values    */
annotation|@
name|Override
comment|// NameNodeMXBean
DECL|method|getLiveNodes ()
specifier|public
name|String
name|getLiveNodes
parameter_list|()
block|{
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
argument_list|>
name|info
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|live
init|=
operator|new
name|ArrayList
argument_list|<
name|DatanodeDescriptor
argument_list|>
argument_list|()
decl_stmt|;
name|blockManager
operator|.
name|getDatanodeManager
argument_list|()
operator|.
name|fetchDatanodes
argument_list|(
name|live
argument_list|,
literal|null
argument_list|,
literal|true
argument_list|)
expr_stmt|;
for|for
control|(
name|DatanodeDescriptor
name|node
range|:
name|live
control|)
block|{
name|ImmutableMap
operator|.
name|Builder
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|innerinfo
init|=
name|ImmutableMap
operator|.
expr|<
name|String
decl_stmt|,
name|Object
decl|>
name|builder
argument_list|()
decl_stmt|;
name|innerinfo
operator|.
name|put
argument_list|(
literal|"infoAddr"
argument_list|,
name|node
operator|.
name|getInfoAddr
argument_list|()
argument_list|)
operator|.
name|put
argument_list|(
literal|"infoSecureAddr"
argument_list|,
name|node
operator|.
name|getInfoSecureAddr
argument_list|()
argument_list|)
operator|.
name|put
argument_list|(
literal|"xferaddr"
argument_list|,
name|node
operator|.
name|getXferAddr
argument_list|()
argument_list|)
operator|.
name|put
argument_list|(
literal|"lastContact"
argument_list|,
name|getLastContact
argument_list|(
name|node
argument_list|)
argument_list|)
operator|.
name|put
argument_list|(
literal|"usedSpace"
argument_list|,
name|getDfsUsed
argument_list|(
name|node
argument_list|)
argument_list|)
operator|.
name|put
argument_list|(
literal|"adminState"
argument_list|,
name|node
operator|.
name|getAdminState
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
operator|.
name|put
argument_list|(
literal|"nonDfsUsedSpace"
argument_list|,
name|node
operator|.
name|getNonDfsUsed
argument_list|()
argument_list|)
operator|.
name|put
argument_list|(
literal|"capacity"
argument_list|,
name|node
operator|.
name|getCapacity
argument_list|()
argument_list|)
operator|.
name|put
argument_list|(
literal|"numBlocks"
argument_list|,
name|node
operator|.
name|numBlocks
argument_list|()
argument_list|)
operator|.
name|put
argument_list|(
literal|"version"
argument_list|,
name|node
operator|.
name|getSoftwareVersion
argument_list|()
argument_list|)
operator|.
name|put
argument_list|(
literal|"used"
argument_list|,
name|node
operator|.
name|getDfsUsed
argument_list|()
argument_list|)
operator|.
name|put
argument_list|(
literal|"remaining"
argument_list|,
name|node
operator|.
name|getRemaining
argument_list|()
argument_list|)
operator|.
name|put
argument_list|(
literal|"blockScheduled"
argument_list|,
name|node
operator|.
name|getBlocksScheduled
argument_list|()
argument_list|)
operator|.
name|put
argument_list|(
literal|"blockPoolUsed"
argument_list|,
name|node
operator|.
name|getBlockPoolUsed
argument_list|()
argument_list|)
operator|.
name|put
argument_list|(
literal|"blockPoolUsedPercent"
argument_list|,
name|node
operator|.
name|getBlockPoolUsedPercent
argument_list|()
argument_list|)
operator|.
name|put
argument_list|(
literal|"volfails"
argument_list|,
name|node
operator|.
name|getVolumeFailures
argument_list|()
argument_list|)
expr_stmt|;
name|VolumeFailureSummary
name|volumeFailureSummary
init|=
name|node
operator|.
name|getVolumeFailureSummary
argument_list|()
decl_stmt|;
if|if
condition|(
name|volumeFailureSummary
operator|!=
literal|null
condition|)
block|{
name|innerinfo
operator|.
name|put
argument_list|(
literal|"failedStorageLocations"
argument_list|,
name|volumeFailureSummary
operator|.
name|getFailedStorageLocations
argument_list|()
argument_list|)
operator|.
name|put
argument_list|(
literal|"lastVolumeFailureDate"
argument_list|,
name|volumeFailureSummary
operator|.
name|getLastVolumeFailureDate
argument_list|()
argument_list|)
operator|.
name|put
argument_list|(
literal|"estimatedCapacityLostTotal"
argument_list|,
name|volumeFailureSummary
operator|.
name|getEstimatedCapacityLostTotal
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|info
operator|.
name|put
argument_list|(
name|node
operator|.
name|getHostName
argument_list|()
operator|+
literal|":"
operator|+
name|node
operator|.
name|getXferPort
argument_list|()
argument_list|,
name|innerinfo
operator|.
name|build
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|JSON
operator|.
name|toString
argument_list|(
name|info
argument_list|)
return|;
block|}
comment|/**    * Returned information is a JSON representation of map with host name as the    * key and value is a map of dead node attribute keys to its values    */
annotation|@
name|Override
comment|// NameNodeMXBean
DECL|method|getDeadNodes ()
specifier|public
name|String
name|getDeadNodes
parameter_list|()
block|{
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
argument_list|>
name|info
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|dead
init|=
operator|new
name|ArrayList
argument_list|<
name|DatanodeDescriptor
argument_list|>
argument_list|()
decl_stmt|;
name|blockManager
operator|.
name|getDatanodeManager
argument_list|()
operator|.
name|fetchDatanodes
argument_list|(
literal|null
argument_list|,
name|dead
argument_list|,
literal|true
argument_list|)
expr_stmt|;
for|for
control|(
name|DatanodeDescriptor
name|node
range|:
name|dead
control|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|innerinfo
init|=
name|ImmutableMap
operator|.
expr|<
name|String
decl_stmt|,
name|Object
decl|>
name|builder
argument_list|()
decl|.
name|put
argument_list|(
literal|"lastContact"
argument_list|,
name|getLastContact
argument_list|(
name|node
argument_list|)
argument_list|)
decl|.
name|put
argument_list|(
literal|"decommissioned"
argument_list|,
name|node
operator|.
name|isDecommissioned
argument_list|()
argument_list|)
decl|.
name|put
argument_list|(
literal|"xferaddr"
argument_list|,
name|node
operator|.
name|getXferAddr
argument_list|()
argument_list|)
decl|.
name|build
argument_list|()
decl_stmt|;
name|info
operator|.
name|put
argument_list|(
name|node
operator|.
name|getHostName
argument_list|()
operator|+
literal|":"
operator|+
name|node
operator|.
name|getXferPort
argument_list|()
argument_list|,
name|innerinfo
argument_list|)
expr_stmt|;
block|}
return|return
name|JSON
operator|.
name|toString
argument_list|(
name|info
argument_list|)
return|;
block|}
comment|/**    * Returned information is a JSON representation of map with host name as the    * key and value is a map of decommissioning node attribute keys to its    * values    */
annotation|@
name|Override
comment|// NameNodeMXBean
DECL|method|getDecomNodes ()
specifier|public
name|String
name|getDecomNodes
parameter_list|()
block|{
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
argument_list|>
name|info
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|decomNodeList
init|=
name|blockManager
operator|.
name|getDatanodeManager
argument_list|(         )
operator|.
name|getDecommissioningNodes
argument_list|()
decl_stmt|;
for|for
control|(
name|DatanodeDescriptor
name|node
range|:
name|decomNodeList
control|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|innerinfo
init|=
name|ImmutableMap
operator|.
expr|<
name|String
decl_stmt|,
name|Object
decl|>
name|builder
argument_list|()
decl|.
name|put
argument_list|(
literal|"xferaddr"
argument_list|,
name|node
operator|.
name|getXferAddr
argument_list|()
argument_list|)
decl|.
name|put
argument_list|(
literal|"underReplicatedBlocks"
argument_list|,
name|node
operator|.
name|decommissioningStatus
operator|.
name|getUnderReplicatedBlocks
argument_list|()
argument_list|)
decl|.
name|put
argument_list|(
literal|"decommissionOnlyReplicas"
argument_list|,
name|node
operator|.
name|decommissioningStatus
operator|.
name|getDecommissionOnlyReplicas
argument_list|()
argument_list|)
decl|.
name|put
argument_list|(
literal|"underReplicateInOpenFiles"
argument_list|,
name|node
operator|.
name|decommissioningStatus
operator|.
name|getUnderReplicatedInOpenFiles
argument_list|()
argument_list|)
decl|.
name|build
argument_list|()
decl_stmt|;
name|info
operator|.
name|put
argument_list|(
name|node
operator|.
name|getHostName
argument_list|()
operator|+
literal|":"
operator|+
name|node
operator|.
name|getXferPort
argument_list|()
argument_list|,
name|innerinfo
argument_list|)
expr_stmt|;
block|}
return|return
name|JSON
operator|.
name|toString
argument_list|(
name|info
argument_list|)
return|;
block|}
DECL|method|getLastContact (DatanodeDescriptor alivenode)
specifier|private
name|long
name|getLastContact
parameter_list|(
name|DatanodeDescriptor
name|alivenode
parameter_list|)
block|{
return|return
operator|(
name|monotonicNow
argument_list|()
operator|-
name|alivenode
operator|.
name|getLastUpdateMonotonic
argument_list|()
operator|)
operator|/
literal|1000
return|;
block|}
DECL|method|getDfsUsed (DatanodeDescriptor alivenode)
specifier|private
name|long
name|getDfsUsed
parameter_list|(
name|DatanodeDescriptor
name|alivenode
parameter_list|)
block|{
return|return
name|alivenode
operator|.
name|getDfsUsed
argument_list|()
return|;
block|}
annotation|@
name|Override
comment|// NameNodeMXBean
DECL|method|getClusterId ()
specifier|public
name|String
name|getClusterId
parameter_list|()
block|{
return|return
name|getFSImage
argument_list|()
operator|.
name|getStorage
argument_list|()
operator|.
name|getClusterID
argument_list|()
return|;
block|}
annotation|@
name|Override
comment|// NameNodeMXBean
DECL|method|getBlockPoolId ()
specifier|public
name|String
name|getBlockPoolId
parameter_list|()
block|{
return|return
name|blockPoolId
return|;
block|}
annotation|@
name|Override
comment|// NameNodeMXBean
DECL|method|getNameDirStatuses ()
specifier|public
name|String
name|getNameDirStatuses
parameter_list|()
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|File
argument_list|,
name|StorageDirType
argument_list|>
argument_list|>
name|statusMap
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|File
argument_list|,
name|StorageDirType
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|File
argument_list|,
name|StorageDirType
argument_list|>
name|activeDirs
init|=
operator|new
name|HashMap
argument_list|<
name|File
argument_list|,
name|StorageDirType
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|StorageDirectory
argument_list|>
name|it
init|=
name|getFSImage
argument_list|()
operator|.
name|getStorage
argument_list|()
operator|.
name|dirIterator
argument_list|()
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|StorageDirectory
name|st
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|activeDirs
operator|.
name|put
argument_list|(
name|st
operator|.
name|getRoot
argument_list|()
argument_list|,
name|st
operator|.
name|getStorageDirType
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|statusMap
operator|.
name|put
argument_list|(
literal|"active"
argument_list|,
name|activeDirs
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|Storage
operator|.
name|StorageDirectory
argument_list|>
name|removedStorageDirs
init|=
name|getFSImage
argument_list|()
operator|.
name|getStorage
argument_list|()
operator|.
name|getRemovedStorageDirs
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|File
argument_list|,
name|StorageDirType
argument_list|>
name|failedDirs
init|=
operator|new
name|HashMap
argument_list|<
name|File
argument_list|,
name|StorageDirType
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|StorageDirectory
name|st
range|:
name|removedStorageDirs
control|)
block|{
name|failedDirs
operator|.
name|put
argument_list|(
name|st
operator|.
name|getRoot
argument_list|()
argument_list|,
name|st
operator|.
name|getStorageDirType
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|statusMap
operator|.
name|put
argument_list|(
literal|"failed"
argument_list|,
name|failedDirs
argument_list|)
expr_stmt|;
return|return
name|JSON
operator|.
name|toString
argument_list|(
name|statusMap
argument_list|)
return|;
block|}
annotation|@
name|Override
comment|// NameNodeMXBean
DECL|method|getNodeUsage ()
specifier|public
name|String
name|getNodeUsage
parameter_list|()
block|{
name|float
name|median
init|=
literal|0
decl_stmt|;
name|float
name|max
init|=
literal|0
decl_stmt|;
name|float
name|min
init|=
literal|0
decl_stmt|;
name|float
name|dev
init|=
literal|0
decl_stmt|;
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
argument_list|>
name|info
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|live
init|=
operator|new
name|ArrayList
argument_list|<
name|DatanodeDescriptor
argument_list|>
argument_list|()
decl_stmt|;
name|blockManager
operator|.
name|getDatanodeManager
argument_list|()
operator|.
name|fetchDatanodes
argument_list|(
name|live
argument_list|,
literal|null
argument_list|,
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|live
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|float
name|totalDfsUsed
init|=
literal|0
decl_stmt|;
name|float
index|[]
name|usages
init|=
operator|new
name|float
index|[
name|live
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|DatanodeDescriptor
name|dn
range|:
name|live
control|)
block|{
name|usages
index|[
name|i
operator|++
index|]
operator|=
name|dn
operator|.
name|getDfsUsedPercent
argument_list|()
expr_stmt|;
name|totalDfsUsed
operator|+=
name|dn
operator|.
name|getDfsUsedPercent
argument_list|()
expr_stmt|;
block|}
name|totalDfsUsed
operator|/=
name|live
operator|.
name|size
argument_list|()
expr_stmt|;
name|Arrays
operator|.
name|sort
argument_list|(
name|usages
argument_list|)
expr_stmt|;
name|median
operator|=
name|usages
index|[
name|usages
operator|.
name|length
operator|/
literal|2
index|]
expr_stmt|;
name|max
operator|=
name|usages
index|[
name|usages
operator|.
name|length
operator|-
literal|1
index|]
expr_stmt|;
name|min
operator|=
name|usages
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|usages
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|dev
operator|+=
operator|(
name|usages
index|[
name|i
index|]
operator|-
name|totalDfsUsed
operator|)
operator|*
operator|(
name|usages
index|[
name|i
index|]
operator|-
name|totalDfsUsed
operator|)
expr_stmt|;
block|}
name|dev
operator|=
operator|(
name|float
operator|)
name|Math
operator|.
name|sqrt
argument_list|(
name|dev
operator|/
name|usages
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|innerInfo
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
argument_list|()
decl_stmt|;
name|innerInfo
operator|.
name|put
argument_list|(
literal|"min"
argument_list|,
name|StringUtils
operator|.
name|format
argument_list|(
literal|"%.2f%%"
argument_list|,
name|min
argument_list|)
argument_list|)
expr_stmt|;
name|innerInfo
operator|.
name|put
argument_list|(
literal|"median"
argument_list|,
name|StringUtils
operator|.
name|format
argument_list|(
literal|"%.2f%%"
argument_list|,
name|median
argument_list|)
argument_list|)
expr_stmt|;
name|innerInfo
operator|.
name|put
argument_list|(
literal|"max"
argument_list|,
name|StringUtils
operator|.
name|format
argument_list|(
literal|"%.2f%%"
argument_list|,
name|max
argument_list|)
argument_list|)
expr_stmt|;
name|innerInfo
operator|.
name|put
argument_list|(
literal|"stdDev"
argument_list|,
name|StringUtils
operator|.
name|format
argument_list|(
literal|"%.2f%%"
argument_list|,
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|info
operator|.
name|put
argument_list|(
literal|"nodeUsage"
argument_list|,
name|innerInfo
argument_list|)
expr_stmt|;
return|return
name|JSON
operator|.
name|toString
argument_list|(
name|info
argument_list|)
return|;
block|}
annotation|@
name|Override
comment|// NameNodeMXBean
DECL|method|getNameJournalStatus ()
specifier|public
name|String
name|getNameJournalStatus
parameter_list|()
block|{
name|List
argument_list|<
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|>
name|jasList
init|=
operator|new
name|ArrayList
argument_list|<
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|FSEditLog
name|log
init|=
name|getFSImage
argument_list|()
operator|.
name|getEditLog
argument_list|()
decl_stmt|;
if|if
condition|(
name|log
operator|!=
literal|null
condition|)
block|{
name|boolean
name|openForWrite
init|=
name|log
operator|.
name|isOpenForWrite
argument_list|()
decl_stmt|;
for|for
control|(
name|JournalAndStream
name|jas
range|:
name|log
operator|.
name|getJournals
argument_list|()
control|)
block|{
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|jasMap
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|String
name|manager
init|=
name|jas
operator|.
name|getManager
argument_list|()
operator|.
name|toString
argument_list|()
decl_stmt|;
name|jasMap
operator|.
name|put
argument_list|(
literal|"required"
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
name|jas
operator|.
name|isRequired
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|jasMap
operator|.
name|put
argument_list|(
literal|"disabled"
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
name|jas
operator|.
name|isDisabled
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|jasMap
operator|.
name|put
argument_list|(
literal|"manager"
argument_list|,
name|manager
argument_list|)
expr_stmt|;
if|if
condition|(
name|jas
operator|.
name|isDisabled
argument_list|()
condition|)
block|{
name|jasMap
operator|.
name|put
argument_list|(
literal|"stream"
argument_list|,
literal|"Failed"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|openForWrite
condition|)
block|{
name|EditLogOutputStream
name|elos
init|=
name|jas
operator|.
name|getCurrentStream
argument_list|()
decl_stmt|;
if|if
condition|(
name|elos
operator|!=
literal|null
condition|)
block|{
name|jasMap
operator|.
name|put
argument_list|(
literal|"stream"
argument_list|,
name|elos
operator|.
name|generateReport
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|jasMap
operator|.
name|put
argument_list|(
literal|"stream"
argument_list|,
literal|"not currently writing"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|jasMap
operator|.
name|put
argument_list|(
literal|"stream"
argument_list|,
literal|"open for read"
argument_list|)
expr_stmt|;
block|}
name|jasList
operator|.
name|add
argument_list|(
name|jasMap
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|JSON
operator|.
name|toString
argument_list|(
name|jasList
argument_list|)
return|;
block|}
annotation|@
name|Override
comment|// NameNodeMxBean
DECL|method|getJournalTransactionInfo ()
specifier|public
name|String
name|getJournalTransactionInfo
parameter_list|()
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|txnIdMap
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|txnIdMap
operator|.
name|put
argument_list|(
literal|"LastAppliedOrWrittenTxId"
argument_list|,
name|Long
operator|.
name|toString
argument_list|(
name|this
operator|.
name|getFSImage
argument_list|()
operator|.
name|getLastAppliedOrWrittenTxId
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|txnIdMap
operator|.
name|put
argument_list|(
literal|"MostRecentCheckpointTxId"
argument_list|,
name|Long
operator|.
name|toString
argument_list|(
name|this
operator|.
name|getFSImage
argument_list|()
operator|.
name|getMostRecentCheckpointTxId
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|JSON
operator|.
name|toString
argument_list|(
name|txnIdMap
argument_list|)
return|;
block|}
annotation|@
name|Override
comment|// NameNodeMXBean
DECL|method|getNNStarted ()
specifier|public
name|String
name|getNNStarted
parameter_list|()
block|{
return|return
name|getStartTime
argument_list|()
operator|.
name|toString
argument_list|()
return|;
block|}
annotation|@
name|Override
comment|// NameNodeMXBean
DECL|method|getCompileInfo ()
specifier|public
name|String
name|getCompileInfo
parameter_list|()
block|{
return|return
name|VersionInfo
operator|.
name|getDate
argument_list|()
operator|+
literal|" by "
operator|+
name|VersionInfo
operator|.
name|getUser
argument_list|()
operator|+
literal|" from "
operator|+
name|VersionInfo
operator|.
name|getBranch
argument_list|()
return|;
block|}
comment|/** @return the block manager. */
DECL|method|getBlockManager ()
specifier|public
name|BlockManager
name|getBlockManager
parameter_list|()
block|{
return|return
name|blockManager
return|;
block|}
DECL|method|getBlockIdManager ()
specifier|public
name|BlockIdManager
name|getBlockIdManager
parameter_list|()
block|{
return|return
name|blockIdManager
return|;
block|}
comment|/** @return the FSDirectory. */
DECL|method|getFSDirectory ()
specifier|public
name|FSDirectory
name|getFSDirectory
parameter_list|()
block|{
return|return
name|dir
return|;
block|}
comment|/** Set the FSDirectory. */
annotation|@
name|VisibleForTesting
DECL|method|setFSDirectory (FSDirectory dir)
specifier|public
name|void
name|setFSDirectory
parameter_list|(
name|FSDirectory
name|dir
parameter_list|)
block|{
name|this
operator|.
name|dir
operator|=
name|dir
expr_stmt|;
block|}
comment|/** @return the cache manager. */
DECL|method|getCacheManager ()
specifier|public
name|CacheManager
name|getCacheManager
parameter_list|()
block|{
return|return
name|cacheManager
return|;
block|}
annotation|@
name|Override
comment|// NameNodeMXBean
DECL|method|getCorruptFiles ()
specifier|public
name|String
name|getCorruptFiles
parameter_list|()
block|{
name|List
argument_list|<
name|String
argument_list|>
name|list
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|Collection
argument_list|<
name|FSNamesystem
operator|.
name|CorruptFileBlockInfo
argument_list|>
name|corruptFileBlocks
decl_stmt|;
try|try
block|{
name|corruptFileBlocks
operator|=
name|listCorruptFileBlocks
argument_list|(
literal|"/"
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|int
name|corruptFileCount
init|=
name|corruptFileBlocks
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|corruptFileCount
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|FSNamesystem
operator|.
name|CorruptFileBlockInfo
name|c
range|:
name|corruptFileBlocks
control|)
block|{
name|list
operator|.
name|add
argument_list|(
name|c
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Get corrupt file blocks returned error: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|JSON
operator|.
name|toString
argument_list|(
name|list
argument_list|)
return|;
block|}
annotation|@
name|Override
comment|//NameNodeMXBean
DECL|method|getDistinctVersionCount ()
specifier|public
name|int
name|getDistinctVersionCount
parameter_list|()
block|{
return|return
name|blockManager
operator|.
name|getDatanodeManager
argument_list|()
operator|.
name|getDatanodesSoftwareVersions
argument_list|()
operator|.
name|size
argument_list|()
return|;
block|}
annotation|@
name|Override
comment|//NameNodeMXBean
DECL|method|getDistinctVersions ()
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|getDistinctVersions
parameter_list|()
block|{
return|return
name|blockManager
operator|.
name|getDatanodeManager
argument_list|()
operator|.
name|getDatanodesSoftwareVersions
argument_list|()
return|;
block|}
annotation|@
name|Override
comment|//NameNodeMXBean
DECL|method|getSoftwareVersion ()
specifier|public
name|String
name|getSoftwareVersion
parameter_list|()
block|{
return|return
name|VersionInfo
operator|.
name|getVersion
argument_list|()
return|;
block|}
comment|/**    * Verifies that the given identifier and password are valid and match.    * @param identifier Token identifier.    * @param password Password in the token.    */
DECL|method|verifyToken (DelegationTokenIdentifier identifier, byte[] password)
specifier|public
specifier|synchronized
name|void
name|verifyToken
parameter_list|(
name|DelegationTokenIdentifier
name|identifier
parameter_list|,
name|byte
index|[]
name|password
parameter_list|)
throws|throws
name|InvalidToken
throws|,
name|RetriableException
block|{
try|try
block|{
name|getDelegationTokenSecretManager
argument_list|()
operator|.
name|verifyToken
argument_list|(
name|identifier
argument_list|,
name|password
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InvalidToken
name|it
parameter_list|)
block|{
if|if
condition|(
name|inTransitionToActive
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|RetriableException
argument_list|(
name|it
argument_list|)
throw|;
block|}
throw|throw
name|it
throw|;
block|}
block|}
annotation|@
name|Override
DECL|method|isGenStampInFuture (Block block)
specifier|public
name|boolean
name|isGenStampInFuture
parameter_list|(
name|Block
name|block
parameter_list|)
block|{
return|return
name|blockIdManager
operator|.
name|isGenStampInFuture
argument_list|(
name|block
argument_list|)
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|getEditLogTailer ()
specifier|public
name|EditLogTailer
name|getEditLogTailer
parameter_list|()
block|{
return|return
name|editLogTailer
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|setEditLogTailerForTests (EditLogTailer tailer)
specifier|public
name|void
name|setEditLogTailerForTests
parameter_list|(
name|EditLogTailer
name|tailer
parameter_list|)
block|{
name|this
operator|.
name|editLogTailer
operator|=
name|tailer
expr_stmt|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|setFsLockForTests (ReentrantReadWriteLock lock)
name|void
name|setFsLockForTests
parameter_list|(
name|ReentrantReadWriteLock
name|lock
parameter_list|)
block|{
name|this
operator|.
name|fsLock
operator|.
name|coarseLock
operator|=
name|lock
expr_stmt|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|getFsLockForTests ()
specifier|public
name|ReentrantReadWriteLock
name|getFsLockForTests
parameter_list|()
block|{
return|return
name|fsLock
operator|.
name|coarseLock
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|getCpLockForTests ()
specifier|public
name|ReentrantLock
name|getCpLockForTests
parameter_list|()
block|{
return|return
name|cpLock
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|getSafeModeInfoForTests ()
specifier|public
name|SafeModeInfo
name|getSafeModeInfoForTests
parameter_list|()
block|{
return|return
name|safeMode
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|setNNResourceChecker (NameNodeResourceChecker nnResourceChecker)
specifier|public
name|void
name|setNNResourceChecker
parameter_list|(
name|NameNodeResourceChecker
name|nnResourceChecker
parameter_list|)
block|{
name|this
operator|.
name|nnResourceChecker
operator|=
name|nnResourceChecker
expr_stmt|;
block|}
DECL|method|getSnapshotManager ()
specifier|public
name|SnapshotManager
name|getSnapshotManager
parameter_list|()
block|{
return|return
name|snapshotManager
return|;
block|}
comment|/** Allow snapshot on a directory. */
DECL|method|allowSnapshot (String path)
name|void
name|allowSnapshot
parameter_list|(
name|String
name|path
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|checkNameNodeSafeMode
argument_list|(
literal|"Cannot allow snapshot for "
operator|+
name|path
argument_list|)
expr_stmt|;
name|checkSuperuserPrivilege
argument_list|()
expr_stmt|;
name|FSDirSnapshotOp
operator|.
name|allowSnapshot
argument_list|(
name|dir
argument_list|,
name|snapshotManager
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
name|getEditLog
argument_list|()
operator|.
name|logSync
argument_list|()
expr_stmt|;
name|logAuditEvent
argument_list|(
name|success
argument_list|,
literal|"allowSnapshot"
argument_list|,
name|path
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/** Disallow snapshot on a directory. */
DECL|method|disallowSnapshot (String path)
name|void
name|disallowSnapshot
parameter_list|(
name|String
name|path
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|checkNameNodeSafeMode
argument_list|(
literal|"Cannot disallow snapshot for "
operator|+
name|path
argument_list|)
expr_stmt|;
name|checkSuperuserPrivilege
argument_list|()
expr_stmt|;
name|FSDirSnapshotOp
operator|.
name|disallowSnapshot
argument_list|(
name|dir
argument_list|,
name|snapshotManager
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
name|getEditLog
argument_list|()
operator|.
name|logSync
argument_list|()
expr_stmt|;
name|logAuditEvent
argument_list|(
name|success
argument_list|,
literal|"disallowSnapshot"
argument_list|,
name|path
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**    * Create a snapshot    * @param snapshotRoot The directory path where the snapshot is taken    * @param snapshotName The name of the snapshot    */
DECL|method|createSnapshot (String snapshotRoot, String snapshotName, boolean logRetryCache)
name|String
name|createSnapshot
parameter_list|(
name|String
name|snapshotRoot
parameter_list|,
name|String
name|snapshotName
parameter_list|,
name|boolean
name|logRetryCache
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|snapshotPath
init|=
literal|null
decl_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|checkNameNodeSafeMode
argument_list|(
literal|"Cannot create snapshot for "
operator|+
name|snapshotRoot
argument_list|)
expr_stmt|;
name|snapshotPath
operator|=
name|FSDirSnapshotOp
operator|.
name|createSnapshot
argument_list|(
name|dir
argument_list|,
name|snapshotManager
argument_list|,
name|snapshotRoot
argument_list|,
name|snapshotName
argument_list|,
name|logRetryCache
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
name|getEditLog
argument_list|()
operator|.
name|logSync
argument_list|()
expr_stmt|;
name|logAuditEvent
argument_list|(
name|snapshotPath
operator|!=
literal|null
argument_list|,
literal|"createSnapshot"
argument_list|,
name|snapshotRoot
argument_list|,
name|snapshotPath
argument_list|,
literal|null
argument_list|)
expr_stmt|;
return|return
name|snapshotPath
return|;
block|}
comment|/**    * Rename a snapshot    * @param path The directory path where the snapshot was taken    * @param snapshotOldName Old snapshot name    * @param snapshotNewName New snapshot name    * @throws SafeModeException    * @throws IOException     */
DECL|method|renameSnapshot ( String path, String snapshotOldName, String snapshotNewName, boolean logRetryCache)
name|void
name|renameSnapshot
parameter_list|(
name|String
name|path
parameter_list|,
name|String
name|snapshotOldName
parameter_list|,
name|String
name|snapshotNewName
parameter_list|,
name|boolean
name|logRetryCache
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|checkNameNodeSafeMode
argument_list|(
literal|"Cannot rename snapshot for "
operator|+
name|path
argument_list|)
expr_stmt|;
name|FSDirSnapshotOp
operator|.
name|renameSnapshot
argument_list|(
name|dir
argument_list|,
name|snapshotManager
argument_list|,
name|path
argument_list|,
name|snapshotOldName
argument_list|,
name|snapshotNewName
argument_list|,
name|logRetryCache
argument_list|)
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
name|getEditLog
argument_list|()
operator|.
name|logSync
argument_list|()
expr_stmt|;
name|String
name|oldSnapshotRoot
init|=
name|Snapshot
operator|.
name|getSnapshotPath
argument_list|(
name|path
argument_list|,
name|snapshotOldName
argument_list|)
decl_stmt|;
name|String
name|newSnapshotRoot
init|=
name|Snapshot
operator|.
name|getSnapshotPath
argument_list|(
name|path
argument_list|,
name|snapshotNewName
argument_list|)
decl_stmt|;
name|logAuditEvent
argument_list|(
name|success
argument_list|,
literal|"renameSnapshot"
argument_list|,
name|oldSnapshotRoot
argument_list|,
name|newSnapshotRoot
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**    * Get the list of snapshottable directories that are owned     * by the current user. Return all the snapshottable directories if the     * current user is a super user.    * @return The list of all the current snapshottable directories    * @throws IOException    */
DECL|method|getSnapshottableDirListing ()
specifier|public
name|SnapshottableDirectoryStatus
index|[]
name|getSnapshottableDirListing
parameter_list|()
throws|throws
name|IOException
block|{
name|SnapshottableDirectoryStatus
index|[]
name|status
init|=
literal|null
decl_stmt|;
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|READ
argument_list|)
expr_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|READ
argument_list|)
expr_stmt|;
name|status
operator|=
name|FSDirSnapshotOp
operator|.
name|getSnapshottableDirListing
argument_list|(
name|dir
argument_list|,
name|snapshotManager
argument_list|)
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
name|logAuditEvent
argument_list|(
name|success
argument_list|,
literal|"listSnapshottableDirectory"
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
comment|/**    * Get the difference between two snapshots (or between a snapshot and the    * current status) of a snapshottable directory.    *     * @param path The full path of the snapshottable directory.    * @param fromSnapshot Name of the snapshot to calculate the diff from. Null    *          or empty string indicates the current tree.    * @param toSnapshot Name of the snapshot to calculated the diff to. Null or    *          empty string indicates the current tree.    * @return A report about the difference between {@code fromSnapshot} and     *         {@code toSnapshot}. Modified/deleted/created/renamed files and     *         directories belonging to the snapshottable directories are listed     *         and labeled as M/-/+/R respectively.     * @throws IOException    */
DECL|method|getSnapshotDiffReport (String path, String fromSnapshot, String toSnapshot)
name|SnapshotDiffReport
name|getSnapshotDiffReport
parameter_list|(
name|String
name|path
parameter_list|,
name|String
name|fromSnapshot
parameter_list|,
name|String
name|toSnapshot
parameter_list|)
throws|throws
name|IOException
block|{
name|SnapshotDiffReport
name|diffs
init|=
literal|null
decl_stmt|;
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|READ
argument_list|)
expr_stmt|;
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|READ
argument_list|)
expr_stmt|;
name|diffs
operator|=
name|FSDirSnapshotOp
operator|.
name|getSnapshotDiffReport
argument_list|(
name|dir
argument_list|,
name|snapshotManager
argument_list|,
name|path
argument_list|,
name|fromSnapshot
argument_list|,
name|toSnapshot
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
name|String
name|fromSnapshotRoot
init|=
operator|(
name|fromSnapshot
operator|==
literal|null
operator|||
name|fromSnapshot
operator|.
name|isEmpty
argument_list|()
operator|)
condition|?
name|path
else|:
name|Snapshot
operator|.
name|getSnapshotPath
argument_list|(
name|path
argument_list|,
name|fromSnapshot
argument_list|)
decl_stmt|;
name|String
name|toSnapshotRoot
init|=
operator|(
name|toSnapshot
operator|==
literal|null
operator|||
name|toSnapshot
operator|.
name|isEmpty
argument_list|()
operator|)
condition|?
name|path
else|:
name|Snapshot
operator|.
name|getSnapshotPath
argument_list|(
name|path
argument_list|,
name|toSnapshot
argument_list|)
decl_stmt|;
name|logAuditEvent
argument_list|(
name|diffs
operator|!=
literal|null
argument_list|,
literal|"computeSnapshotDiff"
argument_list|,
name|fromSnapshotRoot
argument_list|,
name|toSnapshotRoot
argument_list|,
literal|null
argument_list|)
expr_stmt|;
return|return
name|diffs
return|;
block|}
comment|/**    * Delete a snapshot of a snapshottable directory    * @param snapshotRoot The snapshottable directory    * @param snapshotName The name of the to-be-deleted snapshot    * @throws SafeModeException    * @throws IOException    */
DECL|method|deleteSnapshot (String snapshotRoot, String snapshotName, boolean logRetryCache)
name|void
name|deleteSnapshot
parameter_list|(
name|String
name|snapshotRoot
parameter_list|,
name|String
name|snapshotName
parameter_list|,
name|boolean
name|logRetryCache
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
name|BlocksMapUpdateInfo
name|blocksToBeDeleted
init|=
literal|null
decl_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|checkNameNodeSafeMode
argument_list|(
literal|"Cannot delete snapshot for "
operator|+
name|snapshotRoot
argument_list|)
expr_stmt|;
name|blocksToBeDeleted
operator|=
name|FSDirSnapshotOp
operator|.
name|deleteSnapshot
argument_list|(
name|dir
argument_list|,
name|snapshotManager
argument_list|,
name|snapshotRoot
argument_list|,
name|snapshotName
argument_list|,
name|logRetryCache
argument_list|)
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
name|getEditLog
argument_list|()
operator|.
name|logSync
argument_list|()
expr_stmt|;
comment|// Breaking the pattern as removing blocks have to happen outside of the
comment|// global lock
if|if
condition|(
name|blocksToBeDeleted
operator|!=
literal|null
condition|)
block|{
name|removeBlocks
argument_list|(
name|blocksToBeDeleted
argument_list|)
expr_stmt|;
block|}
name|String
name|rootPath
init|=
name|Snapshot
operator|.
name|getSnapshotPath
argument_list|(
name|snapshotRoot
argument_list|,
name|snapshotName
argument_list|)
decl_stmt|;
name|logAuditEvent
argument_list|(
name|success
argument_list|,
literal|"deleteSnapshot"
argument_list|,
name|rootPath
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**    * Remove a list of INodeDirectorySnapshottable from the SnapshotManager    * @param toRemove the list of INodeDirectorySnapshottable to be removed    */
DECL|method|removeSnapshottableDirs (List<INodeDirectory> toRemove)
name|void
name|removeSnapshottableDirs
parameter_list|(
name|List
argument_list|<
name|INodeDirectory
argument_list|>
name|toRemove
parameter_list|)
block|{
if|if
condition|(
name|snapshotManager
operator|!=
literal|null
condition|)
block|{
name|snapshotManager
operator|.
name|removeSnapshottable
argument_list|(
name|toRemove
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|queryRollingUpgrade ()
name|RollingUpgradeInfo
name|queryRollingUpgrade
parameter_list|()
throws|throws
name|IOException
block|{
name|checkSuperuserPrivilege
argument_list|()
expr_stmt|;
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|READ
argument_list|)
expr_stmt|;
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
name|rollingUpgradeInfo
operator|!=
literal|null
condition|)
block|{
name|boolean
name|hasRollbackImage
init|=
name|this
operator|.
name|getFSImage
argument_list|()
operator|.
name|hasRollbackFSImage
argument_list|()
decl_stmt|;
name|rollingUpgradeInfo
operator|.
name|setCreatedRollbackImages
argument_list|(
name|hasRollbackImage
argument_list|)
expr_stmt|;
block|}
return|return
name|rollingUpgradeInfo
return|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|startRollingUpgrade ()
name|RollingUpgradeInfo
name|startRollingUpgrade
parameter_list|()
throws|throws
name|IOException
block|{
name|checkSuperuserPrivilege
argument_list|()
expr_stmt|;
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|isRollingUpgrade
argument_list|()
condition|)
block|{
return|return
name|rollingUpgradeInfo
return|;
block|}
name|long
name|startTime
init|=
name|now
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|haEnabled
condition|)
block|{
comment|// for non-HA, we require NN to be in safemode
name|startRollingUpgradeInternalForNonHA
argument_list|(
name|startTime
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// for HA, NN cannot be in safemode
name|checkNameNodeSafeMode
argument_list|(
literal|"Failed to start rolling upgrade"
argument_list|)
expr_stmt|;
name|startRollingUpgradeInternal
argument_list|(
name|startTime
argument_list|)
expr_stmt|;
block|}
name|getEditLog
argument_list|()
operator|.
name|logStartRollingUpgrade
argument_list|(
name|rollingUpgradeInfo
operator|.
name|getStartTime
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|haEnabled
condition|)
block|{
comment|// roll the edit log to make sure the standby NameNode can tail
name|getFSImage
argument_list|()
operator|.
name|rollEditLog
argument_list|()
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
name|getEditLog
argument_list|()
operator|.
name|logSync
argument_list|()
expr_stmt|;
if|if
condition|(
name|auditLog
operator|.
name|isInfoEnabled
argument_list|()
operator|&&
name|isExternalInvocation
argument_list|()
condition|)
block|{
name|logAuditEvent
argument_list|(
literal|true
argument_list|,
literal|"startRollingUpgrade"
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
return|return
name|rollingUpgradeInfo
return|;
block|}
comment|/**    * Update internal state to indicate that a rolling upgrade is in progress.    * @param startTime rolling upgrade start time    */
DECL|method|startRollingUpgradeInternal (long startTime)
name|void
name|startRollingUpgradeInternal
parameter_list|(
name|long
name|startTime
parameter_list|)
throws|throws
name|IOException
block|{
name|checkRollingUpgrade
argument_list|(
literal|"start rolling upgrade"
argument_list|)
expr_stmt|;
name|getFSImage
argument_list|()
operator|.
name|checkUpgrade
argument_list|()
expr_stmt|;
name|setRollingUpgradeInfo
argument_list|(
literal|false
argument_list|,
name|startTime
argument_list|)
expr_stmt|;
block|}
comment|/**    * Update internal state to indicate that a rolling upgrade is in progress for    * non-HA setup. This requires the namesystem is in SafeMode and after doing a    * checkpoint for rollback the namesystem will quit the safemode automatically     */
DECL|method|startRollingUpgradeInternalForNonHA (long startTime)
specifier|private
name|void
name|startRollingUpgradeInternalForNonHA
parameter_list|(
name|long
name|startTime
parameter_list|)
throws|throws
name|IOException
block|{
name|Preconditions
operator|.
name|checkState
argument_list|(
operator|!
name|haEnabled
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isInSafeMode
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Safe mode should be turned ON "
operator|+
literal|"in order to create namespace image."
argument_list|)
throw|;
block|}
name|checkRollingUpgrade
argument_list|(
literal|"start rolling upgrade"
argument_list|)
expr_stmt|;
name|getFSImage
argument_list|()
operator|.
name|checkUpgrade
argument_list|()
expr_stmt|;
comment|// in non-HA setup, we do an extra checkpoint to generate a rollback image
name|getFSImage
argument_list|()
operator|.
name|saveNamespace
argument_list|(
name|this
argument_list|,
name|NameNodeFile
operator|.
name|IMAGE_ROLLBACK
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Successfully saved namespace for preparing rolling upgrade."
argument_list|)
expr_stmt|;
comment|// leave SafeMode automatically
name|setSafeMode
argument_list|(
name|SafeModeAction
operator|.
name|SAFEMODE_LEAVE
argument_list|)
expr_stmt|;
name|setRollingUpgradeInfo
argument_list|(
literal|true
argument_list|,
name|startTime
argument_list|)
expr_stmt|;
block|}
DECL|method|setRollingUpgradeInfo (boolean createdRollbackImages, long startTime)
name|void
name|setRollingUpgradeInfo
parameter_list|(
name|boolean
name|createdRollbackImages
parameter_list|,
name|long
name|startTime
parameter_list|)
block|{
name|rollingUpgradeInfo
operator|=
operator|new
name|RollingUpgradeInfo
argument_list|(
name|blockPoolId
argument_list|,
name|createdRollbackImages
argument_list|,
name|startTime
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
block|}
DECL|method|setCreatedRollbackImages (boolean created)
specifier|public
name|void
name|setCreatedRollbackImages
parameter_list|(
name|boolean
name|created
parameter_list|)
block|{
if|if
condition|(
name|rollingUpgradeInfo
operator|!=
literal|null
condition|)
block|{
name|rollingUpgradeInfo
operator|.
name|setCreatedRollbackImages
argument_list|(
name|created
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|getRollingUpgradeInfo ()
specifier|public
name|RollingUpgradeInfo
name|getRollingUpgradeInfo
parameter_list|()
block|{
return|return
name|rollingUpgradeInfo
return|;
block|}
DECL|method|isNeedRollbackFsImage ()
specifier|public
name|boolean
name|isNeedRollbackFsImage
parameter_list|()
block|{
return|return
name|needRollbackFsImage
return|;
block|}
DECL|method|setNeedRollbackFsImage (boolean needRollbackFsImage)
specifier|public
name|void
name|setNeedRollbackFsImage
parameter_list|(
name|boolean
name|needRollbackFsImage
parameter_list|)
block|{
name|this
operator|.
name|needRollbackFsImage
operator|=
name|needRollbackFsImage
expr_stmt|;
block|}
annotation|@
name|Override
comment|// NameNodeMXBean
DECL|method|getRollingUpgradeStatus ()
specifier|public
name|RollingUpgradeInfo
operator|.
name|Bean
name|getRollingUpgradeStatus
parameter_list|()
block|{
name|RollingUpgradeInfo
name|upgradeInfo
init|=
name|getRollingUpgradeInfo
argument_list|()
decl_stmt|;
if|if
condition|(
name|upgradeInfo
operator|!=
literal|null
condition|)
block|{
return|return
operator|new
name|RollingUpgradeInfo
operator|.
name|Bean
argument_list|(
name|upgradeInfo
argument_list|)
return|;
block|}
return|return
literal|null
return|;
block|}
comment|/** Is rolling upgrade in progress? */
DECL|method|isRollingUpgrade ()
specifier|public
name|boolean
name|isRollingUpgrade
parameter_list|()
block|{
return|return
name|rollingUpgradeInfo
operator|!=
literal|null
operator|&&
operator|!
name|rollingUpgradeInfo
operator|.
name|isFinalized
argument_list|()
return|;
block|}
DECL|method|checkRollingUpgrade (String action)
name|void
name|checkRollingUpgrade
parameter_list|(
name|String
name|action
parameter_list|)
throws|throws
name|RollingUpgradeException
block|{
if|if
condition|(
name|isRollingUpgrade
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|RollingUpgradeException
argument_list|(
literal|"Failed to "
operator|+
name|action
operator|+
literal|" since a rolling upgrade is already in progress."
operator|+
literal|" Existing rolling upgrade info:\n"
operator|+
name|rollingUpgradeInfo
argument_list|)
throw|;
block|}
block|}
DECL|method|finalizeRollingUpgrade ()
name|RollingUpgradeInfo
name|finalizeRollingUpgrade
parameter_list|()
throws|throws
name|IOException
block|{
name|checkSuperuserPrivilege
argument_list|()
expr_stmt|;
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isRollingUpgrade
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
name|checkNameNodeSafeMode
argument_list|(
literal|"Failed to finalize rolling upgrade"
argument_list|)
expr_stmt|;
name|finalizeRollingUpgradeInternal
argument_list|(
name|now
argument_list|()
argument_list|)
expr_stmt|;
name|getEditLog
argument_list|()
operator|.
name|logFinalizeRollingUpgrade
argument_list|(
name|rollingUpgradeInfo
operator|.
name|getFinalizeTime
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|haEnabled
condition|)
block|{
comment|// roll the edit log to make sure the standby NameNode can tail
name|getFSImage
argument_list|()
operator|.
name|rollEditLog
argument_list|()
expr_stmt|;
block|}
name|getFSImage
argument_list|()
operator|.
name|updateStorageVersion
argument_list|()
expr_stmt|;
name|getFSImage
argument_list|()
operator|.
name|renameCheckpoint
argument_list|(
name|NameNodeFile
operator|.
name|IMAGE_ROLLBACK
argument_list|,
name|NameNodeFile
operator|.
name|IMAGE
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|haEnabled
condition|)
block|{
comment|// Sync not needed for ha since the edit was rolled after logging.
name|getEditLog
argument_list|()
operator|.
name|logSync
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|auditLog
operator|.
name|isInfoEnabled
argument_list|()
operator|&&
name|isExternalInvocation
argument_list|()
condition|)
block|{
name|logAuditEvent
argument_list|(
literal|true
argument_list|,
literal|"finalizeRollingUpgrade"
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
return|return
name|rollingUpgradeInfo
return|;
block|}
DECL|method|finalizeRollingUpgradeInternal (long finalizeTime)
name|void
name|finalizeRollingUpgradeInternal
parameter_list|(
name|long
name|finalizeTime
parameter_list|)
block|{
comment|// Set the finalize time
name|rollingUpgradeInfo
operator|.
name|finalize
argument_list|(
name|finalizeTime
argument_list|)
expr_stmt|;
block|}
DECL|method|addCacheDirective (CacheDirectiveInfo directive, EnumSet<CacheFlag> flags, boolean logRetryCache)
name|long
name|addCacheDirective
parameter_list|(
name|CacheDirectiveInfo
name|directive
parameter_list|,
name|EnumSet
argument_list|<
name|CacheFlag
argument_list|>
name|flags
parameter_list|,
name|boolean
name|logRetryCache
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|CacheDirectiveInfo
name|effectiveDirective
init|=
literal|null
decl_stmt|;
if|if
condition|(
operator|!
name|flags
operator|.
name|contains
argument_list|(
name|CacheFlag
operator|.
name|FORCE
argument_list|)
condition|)
block|{
name|cacheManager
operator|.
name|waitForRescanIfNeeded
argument_list|()
expr_stmt|;
block|}
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|isInSafeMode
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SafeModeException
argument_list|(
literal|"Cannot add cache directive"
argument_list|,
name|safeMode
argument_list|)
throw|;
block|}
name|effectiveDirective
operator|=
name|FSNDNCacheOp
operator|.
name|addCacheDirective
argument_list|(
name|this
argument_list|,
name|cacheManager
argument_list|,
name|directive
argument_list|,
name|flags
argument_list|,
name|logRetryCache
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
name|boolean
name|success
init|=
name|effectiveDirective
operator|!=
literal|null
decl_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|getEditLog
argument_list|()
operator|.
name|logSync
argument_list|()
expr_stmt|;
block|}
name|String
name|effectiveDirectiveStr
init|=
name|effectiveDirective
operator|!=
literal|null
condition|?
name|effectiveDirective
operator|.
name|toString
argument_list|()
else|:
literal|null
decl_stmt|;
name|logAuditEvent
argument_list|(
name|success
argument_list|,
literal|"addCacheDirective"
argument_list|,
name|effectiveDirectiveStr
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
return|return
name|effectiveDirective
operator|!=
literal|null
condition|?
name|effectiveDirective
operator|.
name|getId
argument_list|()
else|:
literal|0
return|;
block|}
DECL|method|modifyCacheDirective (CacheDirectiveInfo directive, EnumSet<CacheFlag> flags, boolean logRetryCache)
name|void
name|modifyCacheDirective
parameter_list|(
name|CacheDirectiveInfo
name|directive
parameter_list|,
name|EnumSet
argument_list|<
name|CacheFlag
argument_list|>
name|flags
parameter_list|,
name|boolean
name|logRetryCache
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
if|if
condition|(
operator|!
name|flags
operator|.
name|contains
argument_list|(
name|CacheFlag
operator|.
name|FORCE
argument_list|)
condition|)
block|{
name|cacheManager
operator|.
name|waitForRescanIfNeeded
argument_list|()
expr_stmt|;
block|}
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|isInSafeMode
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SafeModeException
argument_list|(
literal|"Cannot add cache directive"
argument_list|,
name|safeMode
argument_list|)
throw|;
block|}
name|FSNDNCacheOp
operator|.
name|modifyCacheDirective
argument_list|(
name|this
argument_list|,
name|cacheManager
argument_list|,
name|directive
argument_list|,
name|flags
argument_list|,
name|logRetryCache
argument_list|)
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|getEditLog
argument_list|()
operator|.
name|logSync
argument_list|()
expr_stmt|;
block|}
name|String
name|idStr
init|=
literal|"{id: "
operator|+
name|directive
operator|.
name|getId
argument_list|()
operator|.
name|toString
argument_list|()
operator|+
literal|"}"
decl_stmt|;
name|logAuditEvent
argument_list|(
name|success
argument_list|,
literal|"modifyCacheDirective"
argument_list|,
name|idStr
argument_list|,
name|directive
operator|.
name|toString
argument_list|()
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|removeCacheDirective (long id, boolean logRetryCache)
name|void
name|removeCacheDirective
parameter_list|(
name|long
name|id
parameter_list|,
name|boolean
name|logRetryCache
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|isInSafeMode
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SafeModeException
argument_list|(
literal|"Cannot remove cache directives"
argument_list|,
name|safeMode
argument_list|)
throw|;
block|}
name|FSNDNCacheOp
operator|.
name|removeCacheDirective
argument_list|(
name|this
argument_list|,
name|cacheManager
argument_list|,
name|id
argument_list|,
name|logRetryCache
argument_list|)
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
name|String
name|idStr
init|=
literal|"{id: "
operator|+
name|Long
operator|.
name|toString
argument_list|(
name|id
argument_list|)
operator|+
literal|"}"
decl_stmt|;
name|logAuditEvent
argument_list|(
name|success
argument_list|,
literal|"removeCacheDirective"
argument_list|,
name|idStr
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
name|getEditLog
argument_list|()
operator|.
name|logSync
argument_list|()
expr_stmt|;
block|}
DECL|method|listCacheDirectives ( long startId, CacheDirectiveInfo filter)
name|BatchedListEntries
argument_list|<
name|CacheDirectiveEntry
argument_list|>
name|listCacheDirectives
parameter_list|(
name|long
name|startId
parameter_list|,
name|CacheDirectiveInfo
name|filter
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|READ
argument_list|)
expr_stmt|;
name|BatchedListEntries
argument_list|<
name|CacheDirectiveEntry
argument_list|>
name|results
decl_stmt|;
name|cacheManager
operator|.
name|waitForRescanIfNeeded
argument_list|()
expr_stmt|;
name|readLock
argument_list|()
expr_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|READ
argument_list|)
expr_stmt|;
name|results
operator|=
name|FSNDNCacheOp
operator|.
name|listCacheDirectives
argument_list|(
name|this
argument_list|,
name|cacheManager
argument_list|,
name|startId
argument_list|,
name|filter
argument_list|)
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
name|logAuditEvent
argument_list|(
name|success
argument_list|,
literal|"listCacheDirectives"
argument_list|,
name|filter
operator|.
name|toString
argument_list|()
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
return|return
name|results
return|;
block|}
DECL|method|addCachePool (CachePoolInfo req, boolean logRetryCache)
name|void
name|addCachePool
parameter_list|(
name|CachePoolInfo
name|req
parameter_list|,
name|boolean
name|logRetryCache
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
name|String
name|poolInfoStr
init|=
literal|null
decl_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|isInSafeMode
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SafeModeException
argument_list|(
literal|"Cannot add cache pool "
operator|+
name|req
operator|.
name|getPoolName
argument_list|()
argument_list|,
name|safeMode
argument_list|)
throw|;
block|}
name|CachePoolInfo
name|info
init|=
name|FSNDNCacheOp
operator|.
name|addCachePool
argument_list|(
name|this
argument_list|,
name|cacheManager
argument_list|,
name|req
argument_list|,
name|logRetryCache
argument_list|)
decl_stmt|;
name|poolInfoStr
operator|=
name|info
operator|.
name|toString
argument_list|()
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
name|logAuditEvent
argument_list|(
name|success
argument_list|,
literal|"addCachePool"
argument_list|,
name|poolInfoStr
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
name|getEditLog
argument_list|()
operator|.
name|logSync
argument_list|()
expr_stmt|;
block|}
DECL|method|modifyCachePool (CachePoolInfo req, boolean logRetryCache)
name|void
name|modifyCachePool
parameter_list|(
name|CachePoolInfo
name|req
parameter_list|,
name|boolean
name|logRetryCache
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|isInSafeMode
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SafeModeException
argument_list|(
literal|"Cannot modify cache pool "
operator|+
name|req
operator|.
name|getPoolName
argument_list|()
argument_list|,
name|safeMode
argument_list|)
throw|;
block|}
name|FSNDNCacheOp
operator|.
name|modifyCachePool
argument_list|(
name|this
argument_list|,
name|cacheManager
argument_list|,
name|req
argument_list|,
name|logRetryCache
argument_list|)
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
name|String
name|poolNameStr
init|=
literal|"{poolName: "
operator|+
operator|(
name|req
operator|==
literal|null
condition|?
literal|null
else|:
name|req
operator|.
name|getPoolName
argument_list|()
operator|)
operator|+
literal|"}"
decl_stmt|;
name|logAuditEvent
argument_list|(
name|success
argument_list|,
literal|"modifyCachePool"
argument_list|,
name|poolNameStr
argument_list|,
name|req
operator|==
literal|null
condition|?
literal|null
else|:
name|req
operator|.
name|toString
argument_list|()
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
name|getEditLog
argument_list|()
operator|.
name|logSync
argument_list|()
expr_stmt|;
block|}
DECL|method|removeCachePool (String cachePoolName, boolean logRetryCache)
name|void
name|removeCachePool
parameter_list|(
name|String
name|cachePoolName
parameter_list|,
name|boolean
name|logRetryCache
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|isInSafeMode
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SafeModeException
argument_list|(
literal|"Cannot remove cache pool "
operator|+
name|cachePoolName
argument_list|,
name|safeMode
argument_list|)
throw|;
block|}
name|FSNDNCacheOp
operator|.
name|removeCachePool
argument_list|(
name|this
argument_list|,
name|cacheManager
argument_list|,
name|cachePoolName
argument_list|,
name|logRetryCache
argument_list|)
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
name|String
name|poolNameStr
init|=
literal|"{poolName: "
operator|+
name|cachePoolName
operator|+
literal|"}"
decl_stmt|;
name|logAuditEvent
argument_list|(
name|success
argument_list|,
literal|"removeCachePool"
argument_list|,
name|poolNameStr
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
name|getEditLog
argument_list|()
operator|.
name|logSync
argument_list|()
expr_stmt|;
block|}
DECL|method|listCachePools (String prevKey)
name|BatchedListEntries
argument_list|<
name|CachePoolEntry
argument_list|>
name|listCachePools
parameter_list|(
name|String
name|prevKey
parameter_list|)
throws|throws
name|IOException
block|{
name|BatchedListEntries
argument_list|<
name|CachePoolEntry
argument_list|>
name|results
decl_stmt|;
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|READ
argument_list|)
expr_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
name|cacheManager
operator|.
name|waitForRescanIfNeeded
argument_list|()
expr_stmt|;
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|READ
argument_list|)
expr_stmt|;
name|results
operator|=
name|FSNDNCacheOp
operator|.
name|listCachePools
argument_list|(
name|this
argument_list|,
name|cacheManager
argument_list|,
name|prevKey
argument_list|)
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
name|logAuditEvent
argument_list|(
name|success
argument_list|,
literal|"listCachePools"
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
return|return
name|results
return|;
block|}
DECL|method|modifyAclEntries (final String src, List<AclEntry> aclSpec)
name|void
name|modifyAclEntries
parameter_list|(
specifier|final
name|String
name|src
parameter_list|,
name|List
argument_list|<
name|AclEntry
argument_list|>
name|aclSpec
parameter_list|)
throws|throws
name|IOException
block|{
name|HdfsFileStatus
name|auditStat
init|=
literal|null
decl_stmt|;
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|checkNameNodeSafeMode
argument_list|(
literal|"Cannot modify ACL entries on "
operator|+
name|src
argument_list|)
expr_stmt|;
name|auditStat
operator|=
name|FSDirAclOp
operator|.
name|modifyAclEntries
argument_list|(
name|dir
argument_list|,
name|src
argument_list|,
name|aclSpec
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|AccessControlException
name|e
parameter_list|)
block|{
name|logAuditEvent
argument_list|(
literal|false
argument_list|,
literal|"modifyAclEntries"
argument_list|,
name|src
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
name|getEditLog
argument_list|()
operator|.
name|logSync
argument_list|()
expr_stmt|;
name|logAuditEvent
argument_list|(
literal|true
argument_list|,
literal|"modifyAclEntries"
argument_list|,
name|src
argument_list|,
literal|null
argument_list|,
name|auditStat
argument_list|)
expr_stmt|;
block|}
DECL|method|removeAclEntries (final String src, List<AclEntry> aclSpec)
name|void
name|removeAclEntries
parameter_list|(
specifier|final
name|String
name|src
parameter_list|,
name|List
argument_list|<
name|AclEntry
argument_list|>
name|aclSpec
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|HdfsFileStatus
name|auditStat
init|=
literal|null
decl_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|checkNameNodeSafeMode
argument_list|(
literal|"Cannot remove ACL entries on "
operator|+
name|src
argument_list|)
expr_stmt|;
name|auditStat
operator|=
name|FSDirAclOp
operator|.
name|removeAclEntries
argument_list|(
name|dir
argument_list|,
name|src
argument_list|,
name|aclSpec
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|AccessControlException
name|e
parameter_list|)
block|{
name|logAuditEvent
argument_list|(
literal|false
argument_list|,
literal|"removeAclEntries"
argument_list|,
name|src
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
name|getEditLog
argument_list|()
operator|.
name|logSync
argument_list|()
expr_stmt|;
name|logAuditEvent
argument_list|(
literal|true
argument_list|,
literal|"removeAclEntries"
argument_list|,
name|src
argument_list|,
literal|null
argument_list|,
name|auditStat
argument_list|)
expr_stmt|;
block|}
DECL|method|removeDefaultAcl (final String src)
name|void
name|removeDefaultAcl
parameter_list|(
specifier|final
name|String
name|src
parameter_list|)
throws|throws
name|IOException
block|{
name|HdfsFileStatus
name|auditStat
init|=
literal|null
decl_stmt|;
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|checkNameNodeSafeMode
argument_list|(
literal|"Cannot remove default ACL entries on "
operator|+
name|src
argument_list|)
expr_stmt|;
name|auditStat
operator|=
name|FSDirAclOp
operator|.
name|removeDefaultAcl
argument_list|(
name|dir
argument_list|,
name|src
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|AccessControlException
name|e
parameter_list|)
block|{
name|logAuditEvent
argument_list|(
literal|false
argument_list|,
literal|"removeDefaultAcl"
argument_list|,
name|src
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
name|getEditLog
argument_list|()
operator|.
name|logSync
argument_list|()
expr_stmt|;
name|logAuditEvent
argument_list|(
literal|true
argument_list|,
literal|"removeDefaultAcl"
argument_list|,
name|src
argument_list|,
literal|null
argument_list|,
name|auditStat
argument_list|)
expr_stmt|;
block|}
DECL|method|removeAcl (final String src)
name|void
name|removeAcl
parameter_list|(
specifier|final
name|String
name|src
parameter_list|)
throws|throws
name|IOException
block|{
name|HdfsFileStatus
name|auditStat
init|=
literal|null
decl_stmt|;
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|checkNameNodeSafeMode
argument_list|(
literal|"Cannot remove ACL on "
operator|+
name|src
argument_list|)
expr_stmt|;
name|auditStat
operator|=
name|FSDirAclOp
operator|.
name|removeAcl
argument_list|(
name|dir
argument_list|,
name|src
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|AccessControlException
name|e
parameter_list|)
block|{
name|logAuditEvent
argument_list|(
literal|false
argument_list|,
literal|"removeAcl"
argument_list|,
name|src
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
name|getEditLog
argument_list|()
operator|.
name|logSync
argument_list|()
expr_stmt|;
name|logAuditEvent
argument_list|(
literal|true
argument_list|,
literal|"removeAcl"
argument_list|,
name|src
argument_list|,
literal|null
argument_list|,
name|auditStat
argument_list|)
expr_stmt|;
block|}
DECL|method|setAcl (final String src, List<AclEntry> aclSpec)
name|void
name|setAcl
parameter_list|(
specifier|final
name|String
name|src
parameter_list|,
name|List
argument_list|<
name|AclEntry
argument_list|>
name|aclSpec
parameter_list|)
throws|throws
name|IOException
block|{
name|HdfsFileStatus
name|auditStat
init|=
literal|null
decl_stmt|;
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|checkNameNodeSafeMode
argument_list|(
literal|"Cannot set ACL on "
operator|+
name|src
argument_list|)
expr_stmt|;
name|auditStat
operator|=
name|FSDirAclOp
operator|.
name|setAcl
argument_list|(
name|dir
argument_list|,
name|src
argument_list|,
name|aclSpec
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|AccessControlException
name|e
parameter_list|)
block|{
name|logAuditEvent
argument_list|(
literal|false
argument_list|,
literal|"setAcl"
argument_list|,
name|src
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
name|getEditLog
argument_list|()
operator|.
name|logSync
argument_list|()
expr_stmt|;
name|logAuditEvent
argument_list|(
literal|true
argument_list|,
literal|"setAcl"
argument_list|,
name|src
argument_list|,
literal|null
argument_list|,
name|auditStat
argument_list|)
expr_stmt|;
block|}
DECL|method|getAclStatus (String src)
name|AclStatus
name|getAclStatus
parameter_list|(
name|String
name|src
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|READ
argument_list|)
expr_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|READ
argument_list|)
expr_stmt|;
specifier|final
name|AclStatus
name|ret
init|=
name|FSDirAclOp
operator|.
name|getAclStatus
argument_list|(
name|dir
argument_list|,
name|src
argument_list|)
decl_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
return|return
name|ret
return|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
name|logAuditEvent
argument_list|(
name|success
argument_list|,
literal|"getAclStatus"
argument_list|,
name|src
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Create an encryption zone on directory src using the specified key.    *    * @param src     the path of a directory which will be the root of the    *                encryption zone. The directory must be empty.    * @param keyName name of a key which must be present in the configured    *                KeyProvider.    * @throws AccessControlException  if the caller is not the superuser.    * @throws UnresolvedLinkException if the path can't be resolved.    * @throws SafeModeException       if the Namenode is in safe mode.    */
DECL|method|createEncryptionZone (final String src, final String keyName, boolean logRetryCache)
name|void
name|createEncryptionZone
parameter_list|(
specifier|final
name|String
name|src
parameter_list|,
specifier|final
name|String
name|keyName
parameter_list|,
name|boolean
name|logRetryCache
parameter_list|)
throws|throws
name|IOException
throws|,
name|UnresolvedLinkException
throws|,
name|SafeModeException
throws|,
name|AccessControlException
block|{
try|try
block|{
if|if
condition|(
name|provider
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Can't create an encryption zone for "
operator|+
name|src
operator|+
literal|" since no key provider is available."
argument_list|)
throw|;
block|}
if|if
condition|(
name|keyName
operator|==
literal|null
operator|||
name|keyName
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Must specify a key name when creating an "
operator|+
literal|"encryption zone"
argument_list|)
throw|;
block|}
name|KeyProvider
operator|.
name|Metadata
name|metadata
init|=
name|provider
operator|.
name|getMetadata
argument_list|(
name|keyName
argument_list|)
decl_stmt|;
if|if
condition|(
name|metadata
operator|==
literal|null
condition|)
block|{
comment|/*          * It would be nice if we threw something more specific than          * IOException when the key is not found, but the KeyProvider API          * doesn't provide for that. If that API is ever changed to throw          * something more specific (e.g. UnknownKeyException) then we can          * update this to match it, or better yet, just rethrow the          * KeyProvider's exception.          */
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Key "
operator|+
name|keyName
operator|+
literal|" doesn't exist."
argument_list|)
throw|;
block|}
comment|// If the provider supports pool for EDEKs, this will fill in the pool
name|provider
operator|.
name|warmUpEncryptedKeys
argument_list|(
name|keyName
argument_list|)
expr_stmt|;
name|createEncryptionZoneInt
argument_list|(
name|src
argument_list|,
name|metadata
operator|.
name|getCipher
argument_list|()
argument_list|,
name|keyName
argument_list|,
name|logRetryCache
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|AccessControlException
name|e
parameter_list|)
block|{
name|logAuditEvent
argument_list|(
literal|false
argument_list|,
literal|"createEncryptionZone"
argument_list|,
name|src
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
DECL|method|createEncryptionZoneInt (final String srcArg, String cipher, String keyName, final boolean logRetryCache)
specifier|private
name|void
name|createEncryptionZoneInt
parameter_list|(
specifier|final
name|String
name|srcArg
parameter_list|,
name|String
name|cipher
parameter_list|,
name|String
name|keyName
parameter_list|,
specifier|final
name|boolean
name|logRetryCache
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|src
init|=
name|srcArg
decl_stmt|;
name|HdfsFileStatus
name|resultingStat
init|=
literal|null
decl_stmt|;
name|checkSuperuserPrivilege
argument_list|()
expr_stmt|;
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
specifier|final
name|byte
index|[]
index|[]
name|pathComponents
init|=
name|FSDirectory
operator|.
name|getPathComponentsForReservedPath
argument_list|(
name|src
argument_list|)
decl_stmt|;
name|FSPermissionChecker
name|pc
init|=
name|getPermissionChecker
argument_list|()
decl_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkSuperuserPrivilege
argument_list|()
expr_stmt|;
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|checkNameNodeSafeMode
argument_list|(
literal|"Cannot create encryption zone on "
operator|+
name|src
argument_list|)
expr_stmt|;
name|src
operator|=
name|dir
operator|.
name|resolvePath
argument_list|(
name|pc
argument_list|,
name|src
argument_list|,
name|pathComponents
argument_list|)
expr_stmt|;
specifier|final
name|CipherSuite
name|suite
init|=
name|CipherSuite
operator|.
name|convert
argument_list|(
name|cipher
argument_list|)
decl_stmt|;
comment|// For now this is hardcoded, as we only support one method.
specifier|final
name|CryptoProtocolVersion
name|version
init|=
name|CryptoProtocolVersion
operator|.
name|ENCRYPTION_ZONES
decl_stmt|;
specifier|final
name|XAttr
name|ezXAttr
init|=
name|dir
operator|.
name|createEncryptionZone
argument_list|(
name|src
argument_list|,
name|suite
argument_list|,
name|version
argument_list|,
name|keyName
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|XAttr
argument_list|>
name|xAttrs
init|=
name|Lists
operator|.
name|newArrayListWithCapacity
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|xAttrs
operator|.
name|add
argument_list|(
name|ezXAttr
argument_list|)
expr_stmt|;
name|getEditLog
argument_list|()
operator|.
name|logSetXAttrs
argument_list|(
name|src
argument_list|,
name|xAttrs
argument_list|,
name|logRetryCache
argument_list|)
expr_stmt|;
specifier|final
name|INodesInPath
name|iip
init|=
name|dir
operator|.
name|getINodesInPath4Write
argument_list|(
name|src
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|resultingStat
operator|=
name|dir
operator|.
name|getAuditFileInfo
argument_list|(
name|iip
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
name|getEditLog
argument_list|()
operator|.
name|logSync
argument_list|()
expr_stmt|;
name|logAuditEvent
argument_list|(
literal|true
argument_list|,
literal|"createEncryptionZone"
argument_list|,
name|srcArg
argument_list|,
literal|null
argument_list|,
name|resultingStat
argument_list|)
expr_stmt|;
block|}
comment|/**    * Get the encryption zone for the specified path.    *    * @param srcArg the path of a file or directory to get the EZ for.    * @return the EZ of the of the path or null if none.    * @throws AccessControlException  if the caller is not the superuser.    * @throws UnresolvedLinkException if the path can't be resolved.    */
DECL|method|getEZForPath (final String srcArg)
name|EncryptionZone
name|getEZForPath
parameter_list|(
specifier|final
name|String
name|srcArg
parameter_list|)
throws|throws
name|AccessControlException
throws|,
name|UnresolvedLinkException
throws|,
name|IOException
block|{
name|String
name|src
init|=
name|srcArg
decl_stmt|;
name|HdfsFileStatus
name|resultingStat
init|=
literal|null
decl_stmt|;
specifier|final
name|byte
index|[]
index|[]
name|pathComponents
init|=
name|FSDirectory
operator|.
name|getPathComponentsForReservedPath
argument_list|(
name|src
argument_list|)
decl_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
specifier|final
name|FSPermissionChecker
name|pc
init|=
name|getPermissionChecker
argument_list|()
decl_stmt|;
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|READ
argument_list|)
expr_stmt|;
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|READ
argument_list|)
expr_stmt|;
name|src
operator|=
name|dir
operator|.
name|resolvePath
argument_list|(
name|pc
argument_list|,
name|src
argument_list|,
name|pathComponents
argument_list|)
expr_stmt|;
specifier|final
name|INodesInPath
name|iip
init|=
name|dir
operator|.
name|getINodesInPath
argument_list|(
name|src
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|isPermissionEnabled
condition|)
block|{
name|dir
operator|.
name|checkPathAccess
argument_list|(
name|pc
argument_list|,
name|iip
argument_list|,
name|FsAction
operator|.
name|READ
argument_list|)
expr_stmt|;
block|}
specifier|final
name|EncryptionZone
name|ret
init|=
name|dir
operator|.
name|getEZForPath
argument_list|(
name|iip
argument_list|)
decl_stmt|;
name|resultingStat
operator|=
name|dir
operator|.
name|getAuditFileInfo
argument_list|(
name|iip
argument_list|)
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
return|return
name|ret
return|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
name|logAuditEvent
argument_list|(
name|success
argument_list|,
literal|"getEZForPath"
argument_list|,
name|srcArg
argument_list|,
literal|null
argument_list|,
name|resultingStat
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|listEncryptionZones (long prevId)
name|BatchedListEntries
argument_list|<
name|EncryptionZone
argument_list|>
name|listEncryptionZones
parameter_list|(
name|long
name|prevId
parameter_list|)
throws|throws
name|IOException
block|{
name|boolean
name|success
init|=
literal|false
decl_stmt|;
name|checkSuperuserPrivilege
argument_list|()
expr_stmt|;
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|READ
argument_list|)
expr_stmt|;
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkSuperuserPrivilege
argument_list|()
expr_stmt|;
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|READ
argument_list|)
expr_stmt|;
specifier|final
name|BatchedListEntries
argument_list|<
name|EncryptionZone
argument_list|>
name|ret
init|=
name|dir
operator|.
name|listEncryptionZones
argument_list|(
name|prevId
argument_list|)
decl_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
return|return
name|ret
return|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
name|logAuditEvent
argument_list|(
name|success
argument_list|,
literal|"listEncryptionZones"
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|setXAttr (String src, XAttr xAttr, EnumSet<XAttrSetFlag> flag, boolean logRetryCache)
name|void
name|setXAttr
parameter_list|(
name|String
name|src
parameter_list|,
name|XAttr
name|xAttr
parameter_list|,
name|EnumSet
argument_list|<
name|XAttrSetFlag
argument_list|>
name|flag
parameter_list|,
name|boolean
name|logRetryCache
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|HdfsFileStatus
name|auditStat
init|=
literal|null
decl_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|checkNameNodeSafeMode
argument_list|(
literal|"Cannot set XAttr on "
operator|+
name|src
argument_list|)
expr_stmt|;
name|auditStat
operator|=
name|FSDirXAttrOp
operator|.
name|setXAttr
argument_list|(
name|dir
argument_list|,
name|src
argument_list|,
name|xAttr
argument_list|,
name|flag
argument_list|,
name|logRetryCache
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|AccessControlException
name|e
parameter_list|)
block|{
name|logAuditEvent
argument_list|(
literal|false
argument_list|,
literal|"setXAttr"
argument_list|,
name|src
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
name|getEditLog
argument_list|()
operator|.
name|logSync
argument_list|()
expr_stmt|;
name|logAuditEvent
argument_list|(
literal|true
argument_list|,
literal|"setXAttr"
argument_list|,
name|src
argument_list|,
literal|null
argument_list|,
name|auditStat
argument_list|)
expr_stmt|;
block|}
DECL|method|getXAttrs (final String src, List<XAttr> xAttrs)
name|List
argument_list|<
name|XAttr
argument_list|>
name|getXAttrs
parameter_list|(
specifier|final
name|String
name|src
parameter_list|,
name|List
argument_list|<
name|XAttr
argument_list|>
name|xAttrs
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|READ
argument_list|)
expr_stmt|;
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|READ
argument_list|)
expr_stmt|;
return|return
name|FSDirXAttrOp
operator|.
name|getXAttrs
argument_list|(
name|dir
argument_list|,
name|src
argument_list|,
name|xAttrs
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|AccessControlException
name|e
parameter_list|)
block|{
name|logAuditEvent
argument_list|(
literal|false
argument_list|,
literal|"getXAttrs"
argument_list|,
name|src
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|listXAttrs (String src)
name|List
argument_list|<
name|XAttr
argument_list|>
name|listXAttrs
parameter_list|(
name|String
name|src
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|READ
argument_list|)
expr_stmt|;
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|READ
argument_list|)
expr_stmt|;
return|return
name|FSDirXAttrOp
operator|.
name|listXAttrs
argument_list|(
name|dir
argument_list|,
name|src
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|AccessControlException
name|e
parameter_list|)
block|{
name|logAuditEvent
argument_list|(
literal|false
argument_list|,
literal|"listXAttrs"
argument_list|,
name|src
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|removeXAttr (String src, XAttr xAttr, boolean logRetryCache)
name|void
name|removeXAttr
parameter_list|(
name|String
name|src
parameter_list|,
name|XAttr
name|xAttr
parameter_list|,
name|boolean
name|logRetryCache
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|HdfsFileStatus
name|auditStat
init|=
literal|null
decl_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|checkNameNodeSafeMode
argument_list|(
literal|"Cannot remove XAttr entry on "
operator|+
name|src
argument_list|)
expr_stmt|;
name|auditStat
operator|=
name|FSDirXAttrOp
operator|.
name|removeXAttr
argument_list|(
name|dir
argument_list|,
name|src
argument_list|,
name|xAttr
argument_list|,
name|logRetryCache
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|AccessControlException
name|e
parameter_list|)
block|{
name|logAuditEvent
argument_list|(
literal|false
argument_list|,
literal|"removeXAttr"
argument_list|,
name|src
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
name|getEditLog
argument_list|()
operator|.
name|logSync
argument_list|()
expr_stmt|;
name|logAuditEvent
argument_list|(
literal|true
argument_list|,
literal|"removeXAttr"
argument_list|,
name|src
argument_list|,
literal|null
argument_list|,
name|auditStat
argument_list|)
expr_stmt|;
block|}
DECL|method|checkAccess (String src, FsAction mode)
name|void
name|checkAccess
parameter_list|(
name|String
name|src
parameter_list|,
name|FsAction
name|mode
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|READ
argument_list|)
expr_stmt|;
name|byte
index|[]
index|[]
name|pathComponents
init|=
name|FSDirectory
operator|.
name|getPathComponentsForReservedPath
argument_list|(
name|src
argument_list|)
decl_stmt|;
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|READ
argument_list|)
expr_stmt|;
name|src
operator|=
name|FSDirectory
operator|.
name|resolvePath
argument_list|(
name|src
argument_list|,
name|pathComponents
argument_list|,
name|dir
argument_list|)
expr_stmt|;
specifier|final
name|INodesInPath
name|iip
init|=
name|dir
operator|.
name|getINodesInPath
argument_list|(
name|src
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|INode
name|inode
init|=
name|iip
operator|.
name|getLastINode
argument_list|()
decl_stmt|;
if|if
condition|(
name|inode
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|FileNotFoundException
argument_list|(
literal|"Path not found"
argument_list|)
throw|;
block|}
if|if
condition|(
name|isPermissionEnabled
condition|)
block|{
name|FSPermissionChecker
name|pc
init|=
name|getPermissionChecker
argument_list|()
decl_stmt|;
name|dir
operator|.
name|checkPathAccess
argument_list|(
name|pc
argument_list|,
name|iip
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|AccessControlException
name|e
parameter_list|)
block|{
name|logAuditEvent
argument_list|(
literal|false
argument_list|,
literal|"checkAccess"
argument_list|,
name|src
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Default AuditLogger implementation; used when no access logger is    * defined in the config file. It can also be explicitly listed in the    * config file.    */
DECL|class|DefaultAuditLogger
specifier|private
specifier|static
class|class
name|DefaultAuditLogger
extends|extends
name|HdfsAuditLogger
block|{
DECL|field|logTokenTrackingId
specifier|private
name|boolean
name|logTokenTrackingId
decl_stmt|;
annotation|@
name|Override
DECL|method|initialize (Configuration conf)
specifier|public
name|void
name|initialize
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
name|logTokenTrackingId
operator|=
name|conf
operator|.
name|getBoolean
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_AUDIT_LOG_TOKEN_TRACKING_ID_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_AUDIT_LOG_TOKEN_TRACKING_ID_DEFAULT
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|logAuditEvent (boolean succeeded, String userName, InetAddress addr, String cmd, String src, String dst, FileStatus status, UserGroupInformation ugi, DelegationTokenSecretManager dtSecretManager)
specifier|public
name|void
name|logAuditEvent
parameter_list|(
name|boolean
name|succeeded
parameter_list|,
name|String
name|userName
parameter_list|,
name|InetAddress
name|addr
parameter_list|,
name|String
name|cmd
parameter_list|,
name|String
name|src
parameter_list|,
name|String
name|dst
parameter_list|,
name|FileStatus
name|status
parameter_list|,
name|UserGroupInformation
name|ugi
parameter_list|,
name|DelegationTokenSecretManager
name|dtSecretManager
parameter_list|)
block|{
if|if
condition|(
name|auditLog
operator|.
name|isInfoEnabled
argument_list|()
condition|)
block|{
specifier|final
name|StringBuilder
name|sb
init|=
name|auditBuffer
operator|.
name|get
argument_list|()
decl_stmt|;
name|sb
operator|.
name|setLength
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"allowed="
argument_list|)
operator|.
name|append
argument_list|(
name|succeeded
argument_list|)
operator|.
name|append
argument_list|(
literal|"\t"
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"ugi="
argument_list|)
operator|.
name|append
argument_list|(
name|userName
argument_list|)
operator|.
name|append
argument_list|(
literal|"\t"
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"ip="
argument_list|)
operator|.
name|append
argument_list|(
name|addr
argument_list|)
operator|.
name|append
argument_list|(
literal|"\t"
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"cmd="
argument_list|)
operator|.
name|append
argument_list|(
name|cmd
argument_list|)
operator|.
name|append
argument_list|(
literal|"\t"
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"src="
argument_list|)
operator|.
name|append
argument_list|(
name|src
argument_list|)
operator|.
name|append
argument_list|(
literal|"\t"
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"dst="
argument_list|)
operator|.
name|append
argument_list|(
name|dst
argument_list|)
operator|.
name|append
argument_list|(
literal|"\t"
argument_list|)
expr_stmt|;
if|if
condition|(
literal|null
operator|==
name|status
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|"perm=null"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sb
operator|.
name|append
argument_list|(
literal|"perm="
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|status
operator|.
name|getOwner
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|":"
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|status
operator|.
name|getGroup
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|":"
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|status
operator|.
name|getPermission
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|logTokenTrackingId
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|"\t"
argument_list|)
operator|.
name|append
argument_list|(
literal|"trackingId="
argument_list|)
expr_stmt|;
name|String
name|trackingId
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|ugi
operator|!=
literal|null
operator|&&
name|dtSecretManager
operator|!=
literal|null
operator|&&
name|ugi
operator|.
name|getAuthenticationMethod
argument_list|()
operator|==
name|AuthenticationMethod
operator|.
name|TOKEN
condition|)
block|{
for|for
control|(
name|TokenIdentifier
name|tid
range|:
name|ugi
operator|.
name|getTokenIdentifiers
argument_list|()
control|)
block|{
if|if
condition|(
name|tid
operator|instanceof
name|DelegationTokenIdentifier
condition|)
block|{
name|DelegationTokenIdentifier
name|dtid
init|=
operator|(
name|DelegationTokenIdentifier
operator|)
name|tid
decl_stmt|;
name|trackingId
operator|=
name|dtSecretManager
operator|.
name|getTokenTrackingId
argument_list|(
name|dtid
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
name|sb
operator|.
name|append
argument_list|(
name|trackingId
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
literal|"\t"
argument_list|)
operator|.
name|append
argument_list|(
literal|"proto="
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|NamenodeWebHdfsMethods
operator|.
name|isWebHdfsInvocation
argument_list|()
condition|?
literal|"webhdfs"
else|:
literal|"rpc"
argument_list|)
expr_stmt|;
name|logAuditMessage
argument_list|(
name|sb
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|logAuditMessage (String message)
specifier|public
name|void
name|logAuditMessage
parameter_list|(
name|String
name|message
parameter_list|)
block|{
name|auditLog
operator|.
name|info
argument_list|(
name|message
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|enableAsyncAuditLog ()
specifier|private
specifier|static
name|void
name|enableAsyncAuditLog
parameter_list|()
block|{
if|if
condition|(
operator|!
operator|(
name|auditLog
operator|instanceof
name|Log4JLogger
operator|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Log4j is required to enable async auditlog"
argument_list|)
expr_stmt|;
return|return;
block|}
name|Logger
name|logger
init|=
operator|(
operator|(
name|Log4JLogger
operator|)
name|auditLog
operator|)
operator|.
name|getLogger
argument_list|()
decl_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|List
argument_list|<
name|Appender
argument_list|>
name|appenders
init|=
name|Collections
operator|.
name|list
argument_list|(
name|logger
operator|.
name|getAllAppenders
argument_list|()
argument_list|)
decl_stmt|;
comment|// failsafe against trying to async it more than once
if|if
condition|(
operator|!
name|appenders
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
operator|(
name|appenders
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|instanceof
name|AsyncAppender
operator|)
condition|)
block|{
name|AsyncAppender
name|asyncAppender
init|=
operator|new
name|AsyncAppender
argument_list|()
decl_stmt|;
comment|// change logger to have an async appender containing all the
comment|// previously configured appenders
for|for
control|(
name|Appender
name|appender
range|:
name|appenders
control|)
block|{
name|logger
operator|.
name|removeAppender
argument_list|(
name|appender
argument_list|)
expr_stmt|;
name|asyncAppender
operator|.
name|addAppender
argument_list|(
name|appender
argument_list|)
expr_stmt|;
block|}
name|logger
operator|.
name|addAppender
argument_list|(
name|asyncAppender
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

