begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdfs.server.namenode
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|crypto
operator|.
name|key
operator|.
name|KeyProviderCryptoExtension
operator|.
name|EncryptedKeyVersion
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|CommonConfigurationKeysPublic
operator|.
name|FS_TRASH_INTERVAL_DEFAULT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|CommonConfigurationKeysPublic
operator|.
name|FS_TRASH_INTERVAL_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|CommonConfigurationKeysPublic
operator|.
name|IO_FILE_BUFFER_SIZE_DEFAULT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|CommonConfigurationKeysPublic
operator|.
name|IO_FILE_BUFFER_SIZE_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_BLOCK_SIZE_DEFAULT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_BLOCK_SIZE_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|client
operator|.
name|HdfsClientConfigKeys
operator|.
name|DFS_BYTES_PER_CHECKSUM_DEFAULT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|client
operator|.
name|HdfsClientConfigKeys
operator|.
name|DFS_BYTES_PER_CHECKSUM_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_CHECKSUM_TYPE_DEFAULT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_CHECKSUM_TYPE_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|client
operator|.
name|HdfsClientConfigKeys
operator|.
name|DFS_CLIENT_WRITE_PACKET_SIZE_DEFAULT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|client
operator|.
name|HdfsClientConfigKeys
operator|.
name|DFS_CLIENT_WRITE_PACKET_SIZE_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_ENCRYPT_DATA_TRANSFER_DEFAULT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_ENCRYPT_DATA_TRANSFER_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_HA_STANDBY_CHECKPOINTS_DEFAULT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_HA_STANDBY_CHECKPOINTS_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_AUDIT_LOGGERS_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_AUDIT_LOG_ASYNC_DEFAULT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_AUDIT_LOG_ASYNC_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_AUDIT_LOG_TOKEN_TRACKING_ID_DEFAULT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_AUDIT_LOG_TOKEN_TRACKING_ID_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_CHECKPOINT_TXNS_DEFAULT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_CHECKPOINT_TXNS_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_DEFAULT_AUDIT_LOGGER_NAME
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_DELEGATION_KEY_UPDATE_INTERVAL_DEFAULT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_DELEGATION_KEY_UPDATE_INTERVAL_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_DELEGATION_TOKEN_ALWAYS_USE_DEFAULT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_DELEGATION_TOKEN_ALWAYS_USE_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_DELEGATION_TOKEN_MAX_LIFETIME_DEFAULT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_DELEGATION_TOKEN_MAX_LIFETIME_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_DELEGATION_TOKEN_RENEW_INTERVAL_DEFAULT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_DELEGATION_TOKEN_RENEW_INTERVAL_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_EDITS_DIR_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_EDITS_DIR_REQUIRED_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_EDIT_LOG_AUTOROLL_CHECK_INTERVAL_MS
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_EDIT_LOG_AUTOROLL_CHECK_INTERVAL_MS_DEFAULT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_EDIT_LOG_AUTOROLL_MULTIPLIER_THRESHOLD
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_EDIT_LOG_AUTOROLL_MULTIPLIER_THRESHOLD_DEFAULT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_ENABLE_RETRY_CACHE_DEFAULT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_ENABLE_RETRY_CACHE_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_LAZY_PERSIST_FILE_SCRUB_INTERVAL_SEC
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_LAZY_PERSIST_FILE_SCRUB_INTERVAL_SEC_DEFAULT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_INODE_ATTRIBUTES_PROVIDER_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_MAX_OBJECTS_DEFAULT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_MAX_OBJECTS_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_NAME_DIR_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_REPL_QUEUE_THRESHOLD_PCT_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_RESOURCE_CHECK_INTERVAL_DEFAULT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_RESOURCE_CHECK_INTERVAL_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_RETRY_CACHE_EXPIRYTIME_MILLIS_DEFAULT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_RETRY_CACHE_EXPIRYTIME_MILLIS_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_RETRY_CACHE_HEAP_PERCENT_DEFAULT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_RETRY_CACHE_HEAP_PERCENT_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_SAFEMODE_EXTENSION_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_SAFEMODE_MIN_DATANODES_DEFAULT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_SAFEMODE_MIN_DATANODES_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_SAFEMODE_THRESHOLD_PCT_DEFAULT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_SAFEMODE_THRESHOLD_PCT_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_SHARED_EDITS_DIR_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_PERMISSIONS_ENABLED_DEFAULT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_PERMISSIONS_ENABLED_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_PERMISSIONS_SUPERUSERGROUP_DEFAULT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_PERMISSIONS_SUPERUSERGROUP_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_REPLICATION_DEFAULT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_REPLICATION_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|FSDirStatAndListingOp
operator|.
name|*
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Time
operator|.
name|now
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Time
operator|.
name|monotonicNow
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|BufferedWriter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataInput
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileNotFoundException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStreamWriter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|PrintWriter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|StringWriter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|management
operator|.
name|ManagementFactory
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|InetAddress
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URI
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|GeneralSecurityException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Date
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|EnumSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|Condition
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|ReentrantLock
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|ReentrantReadWriteLock
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|management
operator|.
name|NotCompliantMBeanException
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|management
operator|.
name|ObjectName
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|management
operator|.
name|StandardMBean
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|impl
operator|.
name|Log4JLogger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|HadoopIllegalArgumentException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|crypto
operator|.
name|CipherSuite
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|crypto
operator|.
name|CryptoProtocolVersion
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|crypto
operator|.
name|key
operator|.
name|KeyProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|crypto
operator|.
name|key
operator|.
name|KeyProviderCryptoExtension
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|BatchedRemoteIterator
operator|.
name|BatchedListEntries
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|CacheFlag
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|ContentSummary
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|CreateFlag
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FsServerDefaults
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|InvalidPathException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Options
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|UnresolvedLinkException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|XAttr
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|XAttrSetFlag
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|permission
operator|.
name|AclEntry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|permission
operator|.
name|AclStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|permission
operator|.
name|FsAction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|permission
operator|.
name|FsPermission
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|permission
operator|.
name|PermissionStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|StorageType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ha
operator|.
name|HAServiceProtocol
operator|.
name|HAServiceState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ha
operator|.
name|ServiceFailedException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|BlockStoragePolicy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|HAUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|HdfsConfiguration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|UnknownCryptoProtocolVersionException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|AlreadyBeingCreatedException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|Block
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|CacheDirectiveEntry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|CacheDirectiveInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|CachePoolEntry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|CachePoolInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|ClientProtocol
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|DatanodeID
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|DatanodeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|DirectoryListing
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|EncryptionZone
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|ExtendedBlock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|HdfsConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|LastBlockWithStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|HdfsConstants
operator|.
name|DatanodeReportType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|HdfsConstants
operator|.
name|SafeModeAction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|HdfsFileStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|LocatedBlock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|LocatedBlocks
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|RecoveryInProgressException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|RollingUpgradeException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|RollingUpgradeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|SnapshotAccessControlException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|SnapshotDiffReport
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|SnapshottableDirectoryStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|datatransfer
operator|.
name|ReplaceDatanodeOnFailure
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|security
operator|.
name|token
operator|.
name|block
operator|.
name|BlockTokenIdentifier
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|security
operator|.
name|token
operator|.
name|delegation
operator|.
name|DelegationTokenIdentifier
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|security
operator|.
name|token
operator|.
name|delegation
operator|.
name|DelegationTokenSecretManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|security
operator|.
name|token
operator|.
name|delegation
operator|.
name|DelegationTokenSecretManager
operator|.
name|SecretManagerState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|blockmanagement
operator|.
name|BlockCollection
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|blockmanagement
operator|.
name|BlockIdManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|blockmanagement
operator|.
name|BlockInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|blockmanagement
operator|.
name|BlockManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|blockmanagement
operator|.
name|BlockUnderConstructionFeature
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|blockmanagement
operator|.
name|DatanodeDescriptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|blockmanagement
operator|.
name|DatanodeManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|blockmanagement
operator|.
name|DatanodeStatistics
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|blockmanagement
operator|.
name|DatanodeStorageInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|HdfsServerConstants
operator|.
name|BlockUCState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|HdfsServerConstants
operator|.
name|NamenodeRole
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|HdfsServerConstants
operator|.
name|RollingUpgradeStartupOption
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|HdfsServerConstants
operator|.
name|StartupOption
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|Storage
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|Storage
operator|.
name|StorageDirType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|Storage
operator|.
name|StorageDirectory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|Util
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|FsImageProto
operator|.
name|SecretManagerSection
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|INode
operator|.
name|BlocksMapUpdateInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|JournalSet
operator|.
name|JournalAndStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|LeaseManager
operator|.
name|Lease
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|NNStorage
operator|.
name|NameNodeFile
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|NameNode
operator|.
name|OperationCategory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|NameNodeLayoutVersion
operator|.
name|Feature
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|ha
operator|.
name|EditLogTailer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|ha
operator|.
name|HAContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|ha
operator|.
name|StandbyCheckpointer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|metrics
operator|.
name|FSNamesystemMBean
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|metrics
operator|.
name|NameNodeMetrics
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|snapshot
operator|.
name|Snapshot
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|snapshot
operator|.
name|SnapshotManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|startupprogress
operator|.
name|Phase
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|startupprogress
operator|.
name|StartupProgress
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|startupprogress
operator|.
name|StartupProgress
operator|.
name|Counter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|startupprogress
operator|.
name|Status
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|startupprogress
operator|.
name|Step
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|startupprogress
operator|.
name|StepType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|top
operator|.
name|TopAuditLogger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|top
operator|.
name|TopConf
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|top
operator|.
name|metrics
operator|.
name|TopMetrics
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|top
operator|.
name|window
operator|.
name|RollingWindowManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|web
operator|.
name|resources
operator|.
name|NamenodeWebHdfsMethods
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|DatanodeCommand
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|DatanodeRegistration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|DatanodeStorageReport
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|HeartbeatResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|NNHAStatusHeartbeat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|NamenodeCommand
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|NamenodeRegistration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|NamespaceInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|StorageReceivedDeletedBlocks
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|StorageReport
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|VolumeFailureSummary
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|Text
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|RetriableException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|RetryCache
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|Server
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|StandbyException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|metrics2
operator|.
name|annotation
operator|.
name|Metric
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|metrics2
operator|.
name|annotation
operator|.
name|Metrics
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|metrics2
operator|.
name|lib
operator|.
name|DefaultMetricsSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|metrics2
operator|.
name|util
operator|.
name|MBeans
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|net
operator|.
name|NetworkTopology
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|net
operator|.
name|Node
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|AccessControlException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|UserGroupInformation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|UserGroupInformation
operator|.
name|AuthenticationMethod
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|token
operator|.
name|SecretManager
operator|.
name|InvalidToken
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|token
operator|.
name|Token
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|token
operator|.
name|TokenIdentifier
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|token
operator|.
name|delegation
operator|.
name|DelegationKey
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Daemon
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|DataChecksum
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|ReflectionUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|VersionInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|log4j
operator|.
name|Appender
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|log4j
operator|.
name|AsyncAppender
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|log4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|codehaus
operator|.
name|jackson
operator|.
name|map
operator|.
name|ObjectMapper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|mortbay
operator|.
name|util
operator|.
name|ajax
operator|.
name|JSON
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Charsets
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableMap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_comment
comment|/**  * FSNamesystem is a container of both transient  * and persisted name-space state, and does all the book-keeping  * work on a NameNode.  *  * Its roles are briefly described below:  *  * 1) Is the container for BlockManager, DatanodeManager,  *    DelegationTokens, LeaseManager, etc. services.  * 2) RPC calls that modify or inspect the name-space  *    should get delegated here.  * 3) Anything that touches only blocks (eg. block reports),  *    it delegates to BlockManager.  * 4) Anything that touches only file information (eg. permissions, mkdirs),  *    it delegates to FSDirectory.  * 5) Anything that crosses two of the above components should be  *    coordinated here.  * 6) Logs mutations to FSEditLog.  *  * This class and its contents keep:  *  * 1)  Valid fsname --> blocklist  (kept on disk, logged)  * 2)  Set of all valid blocks (inverted #1)  * 3)  block --> machinelist (kept in memory, rebuilt dynamically from reports)  * 4)  machine --> blocklist (inverted #2)  * 5)  LRU cache of updated-heartbeat machines  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
annotation|@
name|Metrics
argument_list|(
name|context
operator|=
literal|"dfs"
argument_list|)
DECL|class|FSNamesystem
specifier|public
class|class
name|FSNamesystem
implements|implements
name|Namesystem
implements|,
name|FSNamesystemMBean
implements|,
name|NameNodeMXBean
block|{
DECL|field|LOG
specifier|public
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|FSNamesystem
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|auditBuffer
specifier|private
specifier|static
specifier|final
name|ThreadLocal
argument_list|<
name|StringBuilder
argument_list|>
name|auditBuffer
init|=
operator|new
name|ThreadLocal
argument_list|<
name|StringBuilder
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|protected
name|StringBuilder
name|initialValue
parameter_list|()
block|{
return|return
operator|new
name|StringBuilder
argument_list|()
return|;
block|}
block|}
decl_stmt|;
DECL|field|blockIdManager
specifier|private
specifier|final
name|BlockIdManager
name|blockIdManager
decl_stmt|;
annotation|@
name|VisibleForTesting
DECL|method|isAuditEnabled ()
specifier|public
name|boolean
name|isAuditEnabled
parameter_list|()
block|{
return|return
operator|!
name|isDefaultAuditLogger
operator|||
name|auditLog
operator|.
name|isInfoEnabled
argument_list|()
return|;
block|}
DECL|method|logAuditEvent (boolean succeeded, String cmd, String src)
specifier|private
name|void
name|logAuditEvent
parameter_list|(
name|boolean
name|succeeded
parameter_list|,
name|String
name|cmd
parameter_list|,
name|String
name|src
parameter_list|)
throws|throws
name|IOException
block|{
name|logAuditEvent
argument_list|(
name|succeeded
argument_list|,
name|cmd
argument_list|,
name|src
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
DECL|method|logAuditEvent (boolean succeeded, String cmd, String src, String dst, HdfsFileStatus stat)
specifier|private
name|void
name|logAuditEvent
parameter_list|(
name|boolean
name|succeeded
parameter_list|,
name|String
name|cmd
parameter_list|,
name|String
name|src
parameter_list|,
name|String
name|dst
parameter_list|,
name|HdfsFileStatus
name|stat
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|isAuditEnabled
argument_list|()
operator|&&
name|isExternalInvocation
argument_list|()
condition|)
block|{
name|logAuditEvent
argument_list|(
name|succeeded
argument_list|,
name|getRemoteUser
argument_list|()
argument_list|,
name|getRemoteIp
argument_list|()
argument_list|,
name|cmd
argument_list|,
name|src
argument_list|,
name|dst
argument_list|,
name|stat
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|logAuditEvent (boolean succeeded, UserGroupInformation ugi, InetAddress addr, String cmd, String src, String dst, HdfsFileStatus stat)
specifier|private
name|void
name|logAuditEvent
parameter_list|(
name|boolean
name|succeeded
parameter_list|,
name|UserGroupInformation
name|ugi
parameter_list|,
name|InetAddress
name|addr
parameter_list|,
name|String
name|cmd
parameter_list|,
name|String
name|src
parameter_list|,
name|String
name|dst
parameter_list|,
name|HdfsFileStatus
name|stat
parameter_list|)
block|{
name|FileStatus
name|status
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|stat
operator|!=
literal|null
condition|)
block|{
name|Path
name|symlink
init|=
name|stat
operator|.
name|isSymlink
argument_list|()
condition|?
operator|new
name|Path
argument_list|(
name|stat
operator|.
name|getSymlink
argument_list|()
argument_list|)
else|:
literal|null
decl_stmt|;
name|Path
name|path
init|=
name|dst
operator|!=
literal|null
condition|?
operator|new
name|Path
argument_list|(
name|dst
argument_list|)
else|:
operator|new
name|Path
argument_list|(
name|src
argument_list|)
decl_stmt|;
name|status
operator|=
operator|new
name|FileStatus
argument_list|(
name|stat
operator|.
name|getLen
argument_list|()
argument_list|,
name|stat
operator|.
name|isDir
argument_list|()
argument_list|,
name|stat
operator|.
name|getReplication
argument_list|()
argument_list|,
name|stat
operator|.
name|getBlockSize
argument_list|()
argument_list|,
name|stat
operator|.
name|getModificationTime
argument_list|()
argument_list|,
name|stat
operator|.
name|getAccessTime
argument_list|()
argument_list|,
name|stat
operator|.
name|getPermission
argument_list|()
argument_list|,
name|stat
operator|.
name|getOwner
argument_list|()
argument_list|,
name|stat
operator|.
name|getGroup
argument_list|()
argument_list|,
name|symlink
argument_list|,
name|path
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|AuditLogger
name|logger
range|:
name|auditLoggers
control|)
block|{
if|if
condition|(
name|logger
operator|instanceof
name|HdfsAuditLogger
condition|)
block|{
name|HdfsAuditLogger
name|hdfsLogger
init|=
operator|(
name|HdfsAuditLogger
operator|)
name|logger
decl_stmt|;
name|hdfsLogger
operator|.
name|logAuditEvent
argument_list|(
name|succeeded
argument_list|,
name|ugi
operator|.
name|toString
argument_list|()
argument_list|,
name|addr
argument_list|,
name|cmd
argument_list|,
name|src
argument_list|,
name|dst
argument_list|,
name|status
argument_list|,
name|ugi
argument_list|,
name|dtSecretManager
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|logger
operator|.
name|logAuditEvent
argument_list|(
name|succeeded
argument_list|,
name|ugi
operator|.
name|toString
argument_list|()
argument_list|,
name|addr
argument_list|,
name|cmd
argument_list|,
name|src
argument_list|,
name|dst
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Logger for audit events, noting successful FSNamesystem operations. Emits    * to FSNamesystem.audit at INFO. Each event causes a set of tab-separated    *<code>key=value</code> pairs to be written for the following properties:    *<code>    * ugi=&lt;ugi in RPC&gt;    * ip=&lt;remote IP&gt;    * cmd=&lt;command&gt;    * src=&lt;src path&gt;    * dst=&lt;dst path (optional)&gt;    * perm=&lt;permissions (optional)&gt;    *</code>    */
DECL|field|auditLog
specifier|public
specifier|static
specifier|final
name|Log
name|auditLog
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|FSNamesystem
operator|.
name|class
operator|.
name|getName
argument_list|()
operator|+
literal|".audit"
argument_list|)
decl_stmt|;
DECL|field|DEFAULT_MAX_CORRUPT_FILEBLOCKS_RETURNED
specifier|static
specifier|final
name|int
name|DEFAULT_MAX_CORRUPT_FILEBLOCKS_RETURNED
init|=
literal|100
decl_stmt|;
DECL|field|BLOCK_DELETION_INCREMENT
specifier|static
name|int
name|BLOCK_DELETION_INCREMENT
init|=
literal|1000
decl_stmt|;
DECL|field|isPermissionEnabled
specifier|private
specifier|final
name|boolean
name|isPermissionEnabled
decl_stmt|;
DECL|field|fsOwner
specifier|private
specifier|final
name|UserGroupInformation
name|fsOwner
decl_stmt|;
DECL|field|supergroup
specifier|private
specifier|final
name|String
name|supergroup
decl_stmt|;
DECL|field|standbyShouldCheckpoint
specifier|private
specifier|final
name|boolean
name|standbyShouldCheckpoint
decl_stmt|;
comment|// Scan interval is not configurable.
DECL|field|DELEGATION_TOKEN_REMOVER_SCAN_INTERVAL
specifier|private
specifier|static
specifier|final
name|long
name|DELEGATION_TOKEN_REMOVER_SCAN_INTERVAL
init|=
name|TimeUnit
operator|.
name|MILLISECONDS
operator|.
name|convert
argument_list|(
literal|1
argument_list|,
name|TimeUnit
operator|.
name|HOURS
argument_list|)
decl_stmt|;
DECL|field|dtSecretManager
specifier|final
name|DelegationTokenSecretManager
name|dtSecretManager
decl_stmt|;
DECL|field|alwaysUseDelegationTokensForTests
specifier|private
specifier|final
name|boolean
name|alwaysUseDelegationTokensForTests
decl_stmt|;
DECL|field|STEP_AWAITING_REPORTED_BLOCKS
specifier|private
specifier|static
specifier|final
name|Step
name|STEP_AWAITING_REPORTED_BLOCKS
init|=
operator|new
name|Step
argument_list|(
name|StepType
operator|.
name|AWAITING_REPORTED_BLOCKS
argument_list|)
decl_stmt|;
comment|// Tracks whether the default audit logger is the only configured audit
comment|// logger; this allows isAuditEnabled() to return false in case the
comment|// underlying logger is disabled, and avoid some unnecessary work.
DECL|field|isDefaultAuditLogger
specifier|private
specifier|final
name|boolean
name|isDefaultAuditLogger
decl_stmt|;
DECL|field|auditLoggers
specifier|private
specifier|final
name|List
argument_list|<
name|AuditLogger
argument_list|>
name|auditLoggers
decl_stmt|;
comment|/** The namespace tree. */
DECL|field|dir
name|FSDirectory
name|dir
decl_stmt|;
DECL|field|blockManager
specifier|private
specifier|final
name|BlockManager
name|blockManager
decl_stmt|;
DECL|field|snapshotManager
specifier|private
specifier|final
name|SnapshotManager
name|snapshotManager
decl_stmt|;
DECL|field|cacheManager
specifier|private
specifier|final
name|CacheManager
name|cacheManager
decl_stmt|;
DECL|field|datanodeStatistics
specifier|private
specifier|final
name|DatanodeStatistics
name|datanodeStatistics
decl_stmt|;
DECL|field|nameserviceId
specifier|private
name|String
name|nameserviceId
decl_stmt|;
DECL|field|rollingUpgradeInfo
specifier|private
specifier|volatile
name|RollingUpgradeInfo
name|rollingUpgradeInfo
init|=
literal|null
decl_stmt|;
comment|/**    * A flag that indicates whether the checkpointer should checkpoint a rollback    * fsimage. The edit log tailer sets this flag. The checkpoint will create a    * rollback fsimage if the flag is true, and then change the flag to false.    */
DECL|field|needRollbackFsImage
specifier|private
specifier|volatile
name|boolean
name|needRollbackFsImage
decl_stmt|;
comment|// Block pool ID used by this namenode
DECL|field|blockPoolId
specifier|private
name|String
name|blockPoolId
decl_stmt|;
DECL|field|leaseManager
specifier|final
name|LeaseManager
name|leaseManager
init|=
operator|new
name|LeaseManager
argument_list|(
name|this
argument_list|)
decl_stmt|;
DECL|field|smmthread
specifier|volatile
name|Daemon
name|smmthread
init|=
literal|null
decl_stmt|;
comment|// SafeModeMonitor thread
DECL|field|nnrmthread
name|Daemon
name|nnrmthread
init|=
literal|null
decl_stmt|;
comment|// NamenodeResourceMonitor thread
DECL|field|nnEditLogRoller
name|Daemon
name|nnEditLogRoller
init|=
literal|null
decl_stmt|;
comment|// NameNodeEditLogRoller thread
comment|// A daemon to periodically clean up corrupt lazyPersist files
comment|// from the name space.
DECL|field|lazyPersistFileScrubber
name|Daemon
name|lazyPersistFileScrubber
init|=
literal|null
decl_stmt|;
comment|/**    * When an active namenode will roll its own edit log, in # edits    */
DECL|field|editLogRollerThreshold
specifier|private
specifier|final
name|long
name|editLogRollerThreshold
decl_stmt|;
comment|/**    * Check interval of an active namenode's edit log roller thread     */
DECL|field|editLogRollerInterval
specifier|private
specifier|final
name|int
name|editLogRollerInterval
decl_stmt|;
comment|/**    * How frequently we scan and unlink corrupt lazyPersist files.    * (In seconds)    */
DECL|field|lazyPersistFileScrubIntervalSec
specifier|private
specifier|final
name|int
name|lazyPersistFileScrubIntervalSec
decl_stmt|;
DECL|field|hasResourcesAvailable
specifier|private
specifier|volatile
name|boolean
name|hasResourcesAvailable
init|=
literal|false
decl_stmt|;
DECL|field|fsRunning
specifier|private
specifier|volatile
name|boolean
name|fsRunning
init|=
literal|true
decl_stmt|;
comment|/** The start time of the namesystem. */
DECL|field|startTime
specifier|private
specifier|final
name|long
name|startTime
init|=
name|now
argument_list|()
decl_stmt|;
comment|/** The interval of namenode checking for the disk space availability */
DECL|field|resourceRecheckInterval
specifier|private
specifier|final
name|long
name|resourceRecheckInterval
decl_stmt|;
comment|// The actual resource checker instance.
DECL|field|nnResourceChecker
name|NameNodeResourceChecker
name|nnResourceChecker
decl_stmt|;
DECL|field|serverDefaults
specifier|private
specifier|final
name|FsServerDefaults
name|serverDefaults
decl_stmt|;
DECL|field|dtpReplaceDatanodeOnFailure
specifier|private
specifier|final
name|ReplaceDatanodeOnFailure
name|dtpReplaceDatanodeOnFailure
decl_stmt|;
DECL|field|safeMode
specifier|private
specifier|volatile
name|SafeModeInfo
name|safeMode
decl_stmt|;
comment|// safe mode information
DECL|field|maxFsObjects
specifier|private
specifier|final
name|long
name|maxFsObjects
decl_stmt|;
comment|// maximum number of fs objects
DECL|field|minBlockSize
specifier|private
specifier|final
name|long
name|minBlockSize
decl_stmt|;
comment|// minimum block size
DECL|field|maxBlocksPerFile
specifier|final
name|long
name|maxBlocksPerFile
decl_stmt|;
comment|// maximum # of blocks per file
comment|/** Lock to protect FSNamesystem. */
DECL|field|fsLock
specifier|private
specifier|final
name|FSNamesystemLock
name|fsLock
decl_stmt|;
comment|/**     * Checkpoint lock to protect FSNamesystem modification on standby NNs.    * Unlike fsLock, it does not affect block updates. On active NNs, this lock    * does not provide proper protection, because there are operations that    * modify both block and name system state.  Even on standby, fsLock is     * used when block state changes need to be blocked.    */
DECL|field|cpLock
specifier|private
specifier|final
name|ReentrantLock
name|cpLock
decl_stmt|;
comment|/**    * Used when this NN is in standby state to read from the shared edit log.    */
DECL|field|editLogTailer
specifier|private
name|EditLogTailer
name|editLogTailer
init|=
literal|null
decl_stmt|;
comment|/**    * Used when this NN is in standby state to perform checkpoints.    */
DECL|field|standbyCheckpointer
specifier|private
name|StandbyCheckpointer
name|standbyCheckpointer
decl_stmt|;
comment|/**    * Reference to the NN's HAContext object. This is only set once    * {@link #startCommonServices(Configuration, HAContext)} is called.     */
DECL|field|haContext
specifier|private
name|HAContext
name|haContext
decl_stmt|;
DECL|field|haEnabled
specifier|private
specifier|final
name|boolean
name|haEnabled
decl_stmt|;
comment|/**    * Whether the namenode is in the middle of starting the active service    */
DECL|field|startingActiveService
specifier|private
specifier|volatile
name|boolean
name|startingActiveService
init|=
literal|false
decl_stmt|;
DECL|field|retryCache
specifier|private
specifier|final
name|RetryCache
name|retryCache
decl_stmt|;
DECL|field|provider
specifier|private
name|KeyProviderCryptoExtension
name|provider
init|=
literal|null
decl_stmt|;
DECL|field|imageLoaded
specifier|private
specifier|volatile
name|boolean
name|imageLoaded
init|=
literal|false
decl_stmt|;
DECL|field|cond
specifier|private
specifier|final
name|Condition
name|cond
decl_stmt|;
DECL|field|fsImage
specifier|private
specifier|final
name|FSImage
name|fsImage
decl_stmt|;
DECL|field|topConf
specifier|private
specifier|final
name|TopConf
name|topConf
decl_stmt|;
DECL|field|topMetrics
specifier|private
name|TopMetrics
name|topMetrics
decl_stmt|;
DECL|field|inodeAttributeProvider
specifier|private
name|INodeAttributeProvider
name|inodeAttributeProvider
decl_stmt|;
comment|/**    * Notify that loading of this FSDirectory is complete, and    * it is imageLoaded for use    */
DECL|method|imageLoadComplete ()
name|void
name|imageLoadComplete
parameter_list|()
block|{
name|Preconditions
operator|.
name|checkState
argument_list|(
operator|!
name|imageLoaded
argument_list|,
literal|"FSDirectory already loaded"
argument_list|)
expr_stmt|;
name|setImageLoaded
argument_list|()
expr_stmt|;
block|}
DECL|method|setImageLoaded ()
name|void
name|setImageLoaded
parameter_list|()
block|{
if|if
condition|(
name|imageLoaded
condition|)
return|return;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|setImageLoaded
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|dir
operator|.
name|markNameCacheInitialized
argument_list|()
expr_stmt|;
name|cond
operator|.
name|signalAll
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|//This is for testing purposes only
annotation|@
name|VisibleForTesting
DECL|method|isImageLoaded ()
name|boolean
name|isImageLoaded
parameter_list|()
block|{
return|return
name|imageLoaded
return|;
block|}
comment|// exposed for unit tests
DECL|method|setImageLoaded (boolean flag)
specifier|protected
name|void
name|setImageLoaded
parameter_list|(
name|boolean
name|flag
parameter_list|)
block|{
name|imageLoaded
operator|=
name|flag
expr_stmt|;
block|}
comment|/**    * Block until the object is imageLoaded to be used.    */
DECL|method|waitForLoadingFSImage ()
name|void
name|waitForLoadingFSImage
parameter_list|()
block|{
if|if
condition|(
operator|!
name|imageLoaded
condition|)
block|{
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
while|while
condition|(
operator|!
name|imageLoaded
condition|)
block|{
try|try
block|{
name|cond
operator|.
name|await
argument_list|(
literal|5000
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ignored
parameter_list|)
block|{           }
block|}
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Clear all loaded data    */
DECL|method|clear ()
name|void
name|clear
parameter_list|()
block|{
name|dir
operator|.
name|reset
argument_list|()
expr_stmt|;
name|dtSecretManager
operator|.
name|reset
argument_list|()
expr_stmt|;
name|blockIdManager
operator|.
name|clear
argument_list|()
expr_stmt|;
name|leaseManager
operator|.
name|removeAllLeases
argument_list|()
expr_stmt|;
name|snapshotManager
operator|.
name|clearSnapshottableDirs
argument_list|()
expr_stmt|;
name|cacheManager
operator|.
name|clear
argument_list|()
expr_stmt|;
name|setImageLoaded
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|blockManager
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|getLeaseManager ()
name|LeaseManager
name|getLeaseManager
parameter_list|()
block|{
return|return
name|leaseManager
return|;
block|}
DECL|method|isHaEnabled ()
name|boolean
name|isHaEnabled
parameter_list|()
block|{
return|return
name|haEnabled
return|;
block|}
comment|/**    * Check the supplied configuration for correctness.    * @param conf Supplies the configuration to validate.    * @throws IOException if the configuration could not be queried.    * @throws IllegalArgumentException if the configuration is invalid.    */
DECL|method|checkConfiguration (Configuration conf)
specifier|private
specifier|static
name|void
name|checkConfiguration
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|Collection
argument_list|<
name|URI
argument_list|>
name|namespaceDirs
init|=
name|FSNamesystem
operator|.
name|getNamespaceDirs
argument_list|(
name|conf
argument_list|)
decl_stmt|;
specifier|final
name|Collection
argument_list|<
name|URI
argument_list|>
name|editsDirs
init|=
name|FSNamesystem
operator|.
name|getNamespaceEditsDirs
argument_list|(
name|conf
argument_list|)
decl_stmt|;
specifier|final
name|Collection
argument_list|<
name|URI
argument_list|>
name|requiredEditsDirs
init|=
name|FSNamesystem
operator|.
name|getRequiredNamespaceEditsDirs
argument_list|(
name|conf
argument_list|)
decl_stmt|;
specifier|final
name|Collection
argument_list|<
name|URI
argument_list|>
name|sharedEditsDirs
init|=
name|FSNamesystem
operator|.
name|getSharedEditsDirs
argument_list|(
name|conf
argument_list|)
decl_stmt|;
for|for
control|(
name|URI
name|u
range|:
name|requiredEditsDirs
control|)
block|{
if|if
condition|(
name|u
operator|.
name|toString
argument_list|()
operator|.
name|compareTo
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_EDITS_DIR_DEFAULT
argument_list|)
operator|==
literal|0
condition|)
block|{
continue|continue;
block|}
comment|// Each required directory must also be in editsDirs or in
comment|// sharedEditsDirs.
if|if
condition|(
operator|!
name|editsDirs
operator|.
name|contains
argument_list|(
name|u
argument_list|)
operator|&&
operator|!
name|sharedEditsDirs
operator|.
name|contains
argument_list|(
name|u
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Required edits directory "
operator|+
name|u
operator|.
name|toString
argument_list|()
operator|+
literal|" not present in "
operator|+
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_EDITS_DIR_KEY
operator|+
literal|". "
operator|+
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_EDITS_DIR_KEY
operator|+
literal|"="
operator|+
name|editsDirs
operator|.
name|toString
argument_list|()
operator|+
literal|"; "
operator|+
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_EDITS_DIR_REQUIRED_KEY
operator|+
literal|"="
operator|+
name|requiredEditsDirs
operator|.
name|toString
argument_list|()
operator|+
literal|". "
operator|+
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_SHARED_EDITS_DIR_KEY
operator|+
literal|"="
operator|+
name|sharedEditsDirs
operator|.
name|toString
argument_list|()
operator|+
literal|"."
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
name|namespaceDirs
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Only one image storage directory ("
operator|+
name|DFS_NAMENODE_NAME_DIR_KEY
operator|+
literal|") configured. Beware of data loss"
operator|+
literal|" due to lack of redundant storage directories!"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|editsDirs
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Only one namespace edits storage directory ("
operator|+
name|DFS_NAMENODE_EDITS_DIR_KEY
operator|+
literal|") configured. Beware of data loss"
operator|+
literal|" due to lack of redundant storage directories!"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Instantiates an FSNamesystem loaded from the image and edits    * directories specified in the passed Configuration.    *    * @param conf the Configuration which specifies the storage directories    *             from which to load    * @return an FSNamesystem which contains the loaded namespace    * @throws IOException if loading fails    */
DECL|method|loadFromDisk (Configuration conf)
specifier|static
name|FSNamesystem
name|loadFromDisk
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|checkConfiguration
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|FSImage
name|fsImage
init|=
operator|new
name|FSImage
argument_list|(
name|conf
argument_list|,
name|FSNamesystem
operator|.
name|getNamespaceDirs
argument_list|(
name|conf
argument_list|)
argument_list|,
name|FSNamesystem
operator|.
name|getNamespaceEditsDirs
argument_list|(
name|conf
argument_list|)
argument_list|)
decl_stmt|;
name|FSNamesystem
name|namesystem
init|=
operator|new
name|FSNamesystem
argument_list|(
name|conf
argument_list|,
name|fsImage
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|StartupOption
name|startOpt
init|=
name|NameNode
operator|.
name|getStartupOption
argument_list|(
name|conf
argument_list|)
decl_stmt|;
if|if
condition|(
name|startOpt
operator|==
name|StartupOption
operator|.
name|RECOVER
condition|)
block|{
name|namesystem
operator|.
name|setSafeMode
argument_list|(
name|SafeModeAction
operator|.
name|SAFEMODE_ENTER
argument_list|)
expr_stmt|;
block|}
name|long
name|loadStart
init|=
name|monotonicNow
argument_list|()
decl_stmt|;
try|try
block|{
name|namesystem
operator|.
name|loadFSImage
argument_list|(
name|startOpt
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Encountered exception loading fsimage"
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
name|fsImage
operator|.
name|close
argument_list|()
expr_stmt|;
throw|throw
name|ioe
throw|;
block|}
name|long
name|timeTakenToLoadFSImage
init|=
name|monotonicNow
argument_list|()
operator|-
name|loadStart
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Finished loading FSImage in "
operator|+
name|timeTakenToLoadFSImage
operator|+
literal|" msecs"
argument_list|)
expr_stmt|;
name|NameNodeMetrics
name|nnMetrics
init|=
name|NameNode
operator|.
name|getNameNodeMetrics
argument_list|()
decl_stmt|;
if|if
condition|(
name|nnMetrics
operator|!=
literal|null
condition|)
block|{
name|nnMetrics
operator|.
name|setFsImageLoadTime
argument_list|(
operator|(
name|int
operator|)
name|timeTakenToLoadFSImage
argument_list|)
expr_stmt|;
block|}
return|return
name|namesystem
return|;
block|}
DECL|method|FSNamesystem (Configuration conf, FSImage fsImage)
name|FSNamesystem
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|FSImage
name|fsImage
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|(
name|conf
argument_list|,
name|fsImage
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/**    * Create an FSNamesystem associated with the specified image.    *     * Note that this does not load any data off of disk -- if you would    * like that behavior, use {@link #loadFromDisk(Configuration)}    *    * @param conf configuration    * @param fsImage The FSImage to associate with    * @param ignoreRetryCache Whether or not should ignore the retry cache setup    *                         step. For Secondary NN this should be set to true.    * @throws IOException on bad configuration    */
DECL|method|FSNamesystem (Configuration conf, FSImage fsImage, boolean ignoreRetryCache)
name|FSNamesystem
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|FSImage
name|fsImage
parameter_list|,
name|boolean
name|ignoreRetryCache
parameter_list|)
throws|throws
name|IOException
block|{
name|provider
operator|=
name|DFSUtil
operator|.
name|createKeyProviderCryptoExtension
argument_list|(
name|conf
argument_list|)
expr_stmt|;
if|if
condition|(
name|provider
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"No KeyProvider found."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Found KeyProvider: "
operator|+
name|provider
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|conf
operator|.
name|getBoolean
argument_list|(
name|DFS_NAMENODE_AUDIT_LOG_ASYNC_KEY
argument_list|,
name|DFS_NAMENODE_AUDIT_LOG_ASYNC_DEFAULT
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Enabling async auditlog"
argument_list|)
expr_stmt|;
name|enableAsyncAuditLog
argument_list|()
expr_stmt|;
block|}
name|boolean
name|fair
init|=
name|conf
operator|.
name|getBoolean
argument_list|(
literal|"dfs.namenode.fslock.fair"
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"fsLock is fair:"
operator|+
name|fair
argument_list|)
expr_stmt|;
name|fsLock
operator|=
operator|new
name|FSNamesystemLock
argument_list|(
name|fair
argument_list|)
expr_stmt|;
name|cond
operator|=
name|fsLock
operator|.
name|writeLock
argument_list|()
operator|.
name|newCondition
argument_list|()
expr_stmt|;
name|cpLock
operator|=
operator|new
name|ReentrantLock
argument_list|()
expr_stmt|;
name|this
operator|.
name|fsImage
operator|=
name|fsImage
expr_stmt|;
try|try
block|{
name|resourceRecheckInterval
operator|=
name|conf
operator|.
name|getLong
argument_list|(
name|DFS_NAMENODE_RESOURCE_CHECK_INTERVAL_KEY
argument_list|,
name|DFS_NAMENODE_RESOURCE_CHECK_INTERVAL_DEFAULT
argument_list|)
expr_stmt|;
name|this
operator|.
name|blockManager
operator|=
operator|new
name|BlockManager
argument_list|(
name|this
argument_list|,
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|datanodeStatistics
operator|=
name|blockManager
operator|.
name|getDatanodeManager
argument_list|()
operator|.
name|getDatanodeStatistics
argument_list|()
expr_stmt|;
name|this
operator|.
name|blockIdManager
operator|=
operator|new
name|BlockIdManager
argument_list|(
name|blockManager
argument_list|)
expr_stmt|;
name|this
operator|.
name|fsOwner
operator|=
name|UserGroupInformation
operator|.
name|getCurrentUser
argument_list|()
expr_stmt|;
name|this
operator|.
name|supergroup
operator|=
name|conf
operator|.
name|get
argument_list|(
name|DFS_PERMISSIONS_SUPERUSERGROUP_KEY
argument_list|,
name|DFS_PERMISSIONS_SUPERUSERGROUP_DEFAULT
argument_list|)
expr_stmt|;
name|this
operator|.
name|isPermissionEnabled
operator|=
name|conf
operator|.
name|getBoolean
argument_list|(
name|DFS_PERMISSIONS_ENABLED_KEY
argument_list|,
name|DFS_PERMISSIONS_ENABLED_DEFAULT
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"fsOwner             = "
operator|+
name|fsOwner
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"supergroup          = "
operator|+
name|supergroup
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"isPermissionEnabled = "
operator|+
name|isPermissionEnabled
argument_list|)
expr_stmt|;
comment|// block allocation has to be persisted in HA using a shared edits directory
comment|// so that the standby has up-to-date namespace information
name|nameserviceId
operator|=
name|DFSUtil
operator|.
name|getNamenodeNameServiceId
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|haEnabled
operator|=
name|HAUtil
operator|.
name|isHAEnabled
argument_list|(
name|conf
argument_list|,
name|nameserviceId
argument_list|)
expr_stmt|;
comment|// Sanity check the HA-related config.
if|if
condition|(
name|nameserviceId
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Determined nameservice ID: "
operator|+
name|nameserviceId
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"HA Enabled: "
operator|+
name|haEnabled
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|haEnabled
operator|&&
name|HAUtil
operator|.
name|usesSharedEditsDir
argument_list|(
name|conf
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Configured NNs:\n"
operator|+
name|DFSUtil
operator|.
name|nnAddressesAsString
argument_list|(
name|conf
argument_list|)
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Invalid configuration: a shared edits dir "
operator|+
literal|"must not be specified if HA is not enabled."
argument_list|)
throw|;
block|}
comment|// Get the checksum type from config
name|String
name|checksumTypeStr
init|=
name|conf
operator|.
name|get
argument_list|(
name|DFS_CHECKSUM_TYPE_KEY
argument_list|,
name|DFS_CHECKSUM_TYPE_DEFAULT
argument_list|)
decl_stmt|;
name|DataChecksum
operator|.
name|Type
name|checksumType
decl_stmt|;
try|try
block|{
name|checksumType
operator|=
name|DataChecksum
operator|.
name|Type
operator|.
name|valueOf
argument_list|(
name|checksumTypeStr
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|iae
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Invalid checksum type in "
operator|+
name|DFS_CHECKSUM_TYPE_KEY
operator|+
literal|": "
operator|+
name|checksumTypeStr
argument_list|)
throw|;
block|}
name|this
operator|.
name|serverDefaults
operator|=
operator|new
name|FsServerDefaults
argument_list|(
name|conf
operator|.
name|getLongBytes
argument_list|(
name|DFS_BLOCK_SIZE_KEY
argument_list|,
name|DFS_BLOCK_SIZE_DEFAULT
argument_list|)
argument_list|,
name|conf
operator|.
name|getInt
argument_list|(
name|DFS_BYTES_PER_CHECKSUM_KEY
argument_list|,
name|DFS_BYTES_PER_CHECKSUM_DEFAULT
argument_list|)
argument_list|,
name|conf
operator|.
name|getInt
argument_list|(
name|DFS_CLIENT_WRITE_PACKET_SIZE_KEY
argument_list|,
name|DFS_CLIENT_WRITE_PACKET_SIZE_DEFAULT
argument_list|)
argument_list|,
operator|(
name|short
operator|)
name|conf
operator|.
name|getInt
argument_list|(
name|DFS_REPLICATION_KEY
argument_list|,
name|DFS_REPLICATION_DEFAULT
argument_list|)
argument_list|,
name|conf
operator|.
name|getInt
argument_list|(
name|IO_FILE_BUFFER_SIZE_KEY
argument_list|,
name|IO_FILE_BUFFER_SIZE_DEFAULT
argument_list|)
argument_list|,
name|conf
operator|.
name|getBoolean
argument_list|(
name|DFS_ENCRYPT_DATA_TRANSFER_KEY
argument_list|,
name|DFS_ENCRYPT_DATA_TRANSFER_DEFAULT
argument_list|)
argument_list|,
name|conf
operator|.
name|getLong
argument_list|(
name|FS_TRASH_INTERVAL_KEY
argument_list|,
name|FS_TRASH_INTERVAL_DEFAULT
argument_list|)
argument_list|,
name|checksumType
argument_list|)
expr_stmt|;
name|this
operator|.
name|maxFsObjects
operator|=
name|conf
operator|.
name|getLong
argument_list|(
name|DFS_NAMENODE_MAX_OBJECTS_KEY
argument_list|,
name|DFS_NAMENODE_MAX_OBJECTS_DEFAULT
argument_list|)
expr_stmt|;
name|this
operator|.
name|minBlockSize
operator|=
name|conf
operator|.
name|getLong
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_MIN_BLOCK_SIZE_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_MIN_BLOCK_SIZE_DEFAULT
argument_list|)
expr_stmt|;
name|this
operator|.
name|maxBlocksPerFile
operator|=
name|conf
operator|.
name|getLong
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_MAX_BLOCKS_PER_FILE_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_MAX_BLOCKS_PER_FILE_DEFAULT
argument_list|)
expr_stmt|;
name|this
operator|.
name|dtpReplaceDatanodeOnFailure
operator|=
name|ReplaceDatanodeOnFailure
operator|.
name|get
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|standbyShouldCheckpoint
operator|=
name|conf
operator|.
name|getBoolean
argument_list|(
name|DFS_HA_STANDBY_CHECKPOINTS_KEY
argument_list|,
name|DFS_HA_STANDBY_CHECKPOINTS_DEFAULT
argument_list|)
expr_stmt|;
comment|// # edit autoroll threshold is a multiple of the checkpoint threshold
name|this
operator|.
name|editLogRollerThreshold
operator|=
call|(
name|long
call|)
argument_list|(
name|conf
operator|.
name|getFloat
argument_list|(
name|DFS_NAMENODE_EDIT_LOG_AUTOROLL_MULTIPLIER_THRESHOLD
argument_list|,
name|DFS_NAMENODE_EDIT_LOG_AUTOROLL_MULTIPLIER_THRESHOLD_DEFAULT
argument_list|)
operator|*
name|conf
operator|.
name|getLong
argument_list|(
name|DFS_NAMENODE_CHECKPOINT_TXNS_KEY
argument_list|,
name|DFS_NAMENODE_CHECKPOINT_TXNS_DEFAULT
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|editLogRollerInterval
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|DFS_NAMENODE_EDIT_LOG_AUTOROLL_CHECK_INTERVAL_MS
argument_list|,
name|DFS_NAMENODE_EDIT_LOG_AUTOROLL_CHECK_INTERVAL_MS_DEFAULT
argument_list|)
expr_stmt|;
name|this
operator|.
name|lazyPersistFileScrubIntervalSec
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|DFS_NAMENODE_LAZY_PERSIST_FILE_SCRUB_INTERVAL_SEC
argument_list|,
name|DFS_NAMENODE_LAZY_PERSIST_FILE_SCRUB_INTERVAL_SEC_DEFAULT
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|lazyPersistFileScrubIntervalSec
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|DFS_NAMENODE_LAZY_PERSIST_FILE_SCRUB_INTERVAL_SEC
operator|+
literal|" must be zero (for disable) or greater than zero."
argument_list|)
throw|;
block|}
comment|// For testing purposes, allow the DT secret manager to be started regardless
comment|// of whether security is enabled.
name|alwaysUseDelegationTokensForTests
operator|=
name|conf
operator|.
name|getBoolean
argument_list|(
name|DFS_NAMENODE_DELEGATION_TOKEN_ALWAYS_USE_KEY
argument_list|,
name|DFS_NAMENODE_DELEGATION_TOKEN_ALWAYS_USE_DEFAULT
argument_list|)
expr_stmt|;
name|this
operator|.
name|dtSecretManager
operator|=
name|createDelegationTokenSecretManager
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|dir
operator|=
operator|new
name|FSDirectory
argument_list|(
name|this
argument_list|,
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|snapshotManager
operator|=
operator|new
name|SnapshotManager
argument_list|(
name|dir
argument_list|)
expr_stmt|;
name|this
operator|.
name|cacheManager
operator|=
operator|new
name|CacheManager
argument_list|(
name|this
argument_list|,
name|conf
argument_list|,
name|blockManager
argument_list|)
expr_stmt|;
name|this
operator|.
name|safeMode
operator|=
operator|new
name|SafeModeInfo
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|topConf
operator|=
operator|new
name|TopConf
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|auditLoggers
operator|=
name|initAuditLoggers
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|isDefaultAuditLogger
operator|=
name|auditLoggers
operator|.
name|size
argument_list|()
operator|==
literal|1
operator|&&
name|auditLoggers
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|instanceof
name|DefaultAuditLogger
expr_stmt|;
name|this
operator|.
name|retryCache
operator|=
name|ignoreRetryCache
condition|?
literal|null
else|:
name|initRetryCache
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|Class
argument_list|<
name|?
extends|extends
name|INodeAttributeProvider
argument_list|>
name|klass
init|=
name|conf
operator|.
name|getClass
argument_list|(
name|DFS_NAMENODE_INODE_ATTRIBUTES_PROVIDER_KEY
argument_list|,
literal|null
argument_list|,
name|INodeAttributeProvider
operator|.
name|class
argument_list|)
decl_stmt|;
if|if
condition|(
name|klass
operator|!=
literal|null
condition|)
block|{
name|inodeAttributeProvider
operator|=
name|ReflectionUtils
operator|.
name|newInstance
argument_list|(
name|klass
argument_list|,
name|conf
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Using INode attribute provider: "
operator|+
name|klass
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|" initialization failed."
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|close
argument_list|()
expr_stmt|;
throw|throw
name|e
throw|;
block|}
catch|catch
parameter_list|(
name|RuntimeException
name|re
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|" initialization failed."
argument_list|,
name|re
argument_list|)
expr_stmt|;
name|close
argument_list|()
expr_stmt|;
throw|throw
name|re
throw|;
block|}
block|}
annotation|@
name|VisibleForTesting
DECL|method|getAuditLoggers ()
specifier|public
name|List
argument_list|<
name|AuditLogger
argument_list|>
name|getAuditLoggers
parameter_list|()
block|{
return|return
name|auditLoggers
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|getRetryCache ()
specifier|public
name|RetryCache
name|getRetryCache
parameter_list|()
block|{
return|return
name|retryCache
return|;
block|}
DECL|method|lockRetryCache ()
name|void
name|lockRetryCache
parameter_list|()
block|{
if|if
condition|(
name|retryCache
operator|!=
literal|null
condition|)
block|{
name|retryCache
operator|.
name|lock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|unlockRetryCache ()
name|void
name|unlockRetryCache
parameter_list|()
block|{
if|if
condition|(
name|retryCache
operator|!=
literal|null
condition|)
block|{
name|retryCache
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** Whether or not retry cache is enabled */
DECL|method|hasRetryCache ()
name|boolean
name|hasRetryCache
parameter_list|()
block|{
return|return
name|retryCache
operator|!=
literal|null
return|;
block|}
DECL|method|addCacheEntryWithPayload (byte[] clientId, int callId, Object payload)
name|void
name|addCacheEntryWithPayload
parameter_list|(
name|byte
index|[]
name|clientId
parameter_list|,
name|int
name|callId
parameter_list|,
name|Object
name|payload
parameter_list|)
block|{
if|if
condition|(
name|retryCache
operator|!=
literal|null
condition|)
block|{
name|retryCache
operator|.
name|addCacheEntryWithPayload
argument_list|(
name|clientId
argument_list|,
name|callId
argument_list|,
name|payload
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|addCacheEntry (byte[] clientId, int callId)
name|void
name|addCacheEntry
parameter_list|(
name|byte
index|[]
name|clientId
parameter_list|,
name|int
name|callId
parameter_list|)
block|{
if|if
condition|(
name|retryCache
operator|!=
literal|null
condition|)
block|{
name|retryCache
operator|.
name|addCacheEntry
argument_list|(
name|clientId
argument_list|,
name|callId
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|VisibleForTesting
DECL|method|getProvider ()
specifier|public
name|KeyProviderCryptoExtension
name|getProvider
parameter_list|()
block|{
return|return
name|provider
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|initRetryCache (Configuration conf)
specifier|static
name|RetryCache
name|initRetryCache
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
name|boolean
name|enable
init|=
name|conf
operator|.
name|getBoolean
argument_list|(
name|DFS_NAMENODE_ENABLE_RETRY_CACHE_KEY
argument_list|,
name|DFS_NAMENODE_ENABLE_RETRY_CACHE_DEFAULT
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Retry cache on namenode is "
operator|+
operator|(
name|enable
condition|?
literal|"enabled"
else|:
literal|"disabled"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|enable
condition|)
block|{
name|float
name|heapPercent
init|=
name|conf
operator|.
name|getFloat
argument_list|(
name|DFS_NAMENODE_RETRY_CACHE_HEAP_PERCENT_KEY
argument_list|,
name|DFS_NAMENODE_RETRY_CACHE_HEAP_PERCENT_DEFAULT
argument_list|)
decl_stmt|;
name|long
name|entryExpiryMillis
init|=
name|conf
operator|.
name|getLong
argument_list|(
name|DFS_NAMENODE_RETRY_CACHE_EXPIRYTIME_MILLIS_KEY
argument_list|,
name|DFS_NAMENODE_RETRY_CACHE_EXPIRYTIME_MILLIS_DEFAULT
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Retry cache will use "
operator|+
name|heapPercent
operator|+
literal|" of total heap and retry cache entry expiry time is "
operator|+
name|entryExpiryMillis
operator|+
literal|" millis"
argument_list|)
expr_stmt|;
name|long
name|entryExpiryNanos
init|=
name|entryExpiryMillis
operator|*
literal|1000
operator|*
literal|1000
decl_stmt|;
return|return
operator|new
name|RetryCache
argument_list|(
literal|"NameNodeRetryCache"
argument_list|,
name|heapPercent
argument_list|,
name|entryExpiryNanos
argument_list|)
return|;
block|}
return|return
literal|null
return|;
block|}
DECL|method|initAuditLoggers (Configuration conf)
specifier|private
name|List
argument_list|<
name|AuditLogger
argument_list|>
name|initAuditLoggers
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
comment|// Initialize the custom access loggers if configured.
name|Collection
argument_list|<
name|String
argument_list|>
name|alClasses
init|=
name|conf
operator|.
name|getStringCollection
argument_list|(
name|DFS_NAMENODE_AUDIT_LOGGERS_KEY
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|AuditLogger
argument_list|>
name|auditLoggers
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
if|if
condition|(
name|alClasses
operator|!=
literal|null
operator|&&
operator|!
name|alClasses
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|String
name|className
range|:
name|alClasses
control|)
block|{
try|try
block|{
name|AuditLogger
name|logger
decl_stmt|;
if|if
condition|(
name|DFS_NAMENODE_DEFAULT_AUDIT_LOGGER_NAME
operator|.
name|equals
argument_list|(
name|className
argument_list|)
condition|)
block|{
name|logger
operator|=
operator|new
name|DefaultAuditLogger
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|logger
operator|=
operator|(
name|AuditLogger
operator|)
name|Class
operator|.
name|forName
argument_list|(
name|className
argument_list|)
operator|.
name|newInstance
argument_list|()
expr_stmt|;
block|}
name|logger
operator|.
name|initialize
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|auditLoggers
operator|.
name|add
argument_list|(
name|logger
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RuntimeException
name|re
parameter_list|)
block|{
throw|throw
name|re
throw|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
block|}
comment|// Make sure there is at least one logger installed.
if|if
condition|(
name|auditLoggers
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|auditLoggers
operator|.
name|add
argument_list|(
operator|new
name|DefaultAuditLogger
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Add audit logger to calculate top users
if|if
condition|(
name|topConf
operator|.
name|isEnabled
condition|)
block|{
name|topMetrics
operator|=
operator|new
name|TopMetrics
argument_list|(
name|conf
argument_list|,
name|topConf
operator|.
name|nntopReportingPeriodsMs
argument_list|)
expr_stmt|;
name|auditLoggers
operator|.
name|add
argument_list|(
operator|new
name|TopAuditLogger
argument_list|(
name|topMetrics
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|Collections
operator|.
name|unmodifiableList
argument_list|(
name|auditLoggers
argument_list|)
return|;
block|}
DECL|method|loadFSImage (StartupOption startOpt)
specifier|private
name|void
name|loadFSImage
parameter_list|(
name|StartupOption
name|startOpt
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|FSImage
name|fsImage
init|=
name|getFSImage
argument_list|()
decl_stmt|;
comment|// format before starting up if requested
if|if
condition|(
name|startOpt
operator|==
name|StartupOption
operator|.
name|FORMAT
condition|)
block|{
name|fsImage
operator|.
name|format
argument_list|(
name|this
argument_list|,
name|fsImage
operator|.
name|getStorage
argument_list|()
operator|.
name|determineClusterId
argument_list|()
argument_list|)
expr_stmt|;
comment|// reuse current id
name|startOpt
operator|=
name|StartupOption
operator|.
name|REGULAR
expr_stmt|;
block|}
name|boolean
name|success
init|=
literal|false
decl_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
comment|// We shouldn't be calling saveNamespace if we've come up in standby state.
name|MetaRecoveryContext
name|recovery
init|=
name|startOpt
operator|.
name|createRecoveryContext
argument_list|()
decl_stmt|;
specifier|final
name|boolean
name|staleImage
init|=
name|fsImage
operator|.
name|recoverTransitionRead
argument_list|(
name|startOpt
argument_list|,
name|this
argument_list|,
name|recovery
argument_list|)
decl_stmt|;
if|if
condition|(
name|RollingUpgradeStartupOption
operator|.
name|ROLLBACK
operator|.
name|matches
argument_list|(
name|startOpt
argument_list|)
condition|)
block|{
name|rollingUpgradeInfo
operator|=
literal|null
expr_stmt|;
block|}
specifier|final
name|boolean
name|needToSave
init|=
name|staleImage
operator|&&
operator|!
name|haEnabled
operator|&&
operator|!
name|isRollingUpgrade
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Need to save fs image? "
operator|+
name|needToSave
operator|+
literal|" (staleImage="
operator|+
name|staleImage
operator|+
literal|", haEnabled="
operator|+
name|haEnabled
operator|+
literal|", isRollingUpgrade="
operator|+
name|isRollingUpgrade
argument_list|()
operator|+
literal|")"
argument_list|)
expr_stmt|;
if|if
condition|(
name|needToSave
condition|)
block|{
name|fsImage
operator|.
name|saveNamespace
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// No need to save, so mark the phase done.
name|StartupProgress
name|prog
init|=
name|NameNode
operator|.
name|getStartupProgress
argument_list|()
decl_stmt|;
name|prog
operator|.
name|beginPhase
argument_list|(
name|Phase
operator|.
name|SAVING_CHECKPOINT
argument_list|)
expr_stmt|;
name|prog
operator|.
name|endPhase
argument_list|(
name|Phase
operator|.
name|SAVING_CHECKPOINT
argument_list|)
expr_stmt|;
block|}
comment|// This will start a new log segment and write to the seen_txid file, so
comment|// we shouldn't do it when coming up in standby state
if|if
condition|(
operator|!
name|haEnabled
operator|||
operator|(
name|haEnabled
operator|&&
name|startOpt
operator|==
name|StartupOption
operator|.
name|UPGRADE
operator|)
operator|||
operator|(
name|haEnabled
operator|&&
name|startOpt
operator|==
name|StartupOption
operator|.
name|UPGRADEONLY
operator|)
condition|)
block|{
name|fsImage
operator|.
name|openEditLogForWrite
argument_list|(
name|getEffectiveLayoutVersion
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|success
condition|)
block|{
name|fsImage
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
name|imageLoadComplete
argument_list|()
expr_stmt|;
block|}
DECL|method|startSecretManager ()
specifier|private
name|void
name|startSecretManager
parameter_list|()
block|{
if|if
condition|(
name|dtSecretManager
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|dtSecretManager
operator|.
name|startThreads
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// Inability to start secret manager
comment|// can't be recovered from.
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
block|}
DECL|method|startSecretManagerIfNecessary ()
specifier|private
name|void
name|startSecretManagerIfNecessary
parameter_list|()
block|{
name|boolean
name|shouldRun
init|=
name|shouldUseDelegationTokens
argument_list|()
operator|&&
operator|!
name|isInSafeMode
argument_list|()
operator|&&
name|getEditLog
argument_list|()
operator|.
name|isOpenForWrite
argument_list|()
decl_stmt|;
name|boolean
name|running
init|=
name|dtSecretManager
operator|.
name|isRunning
argument_list|()
decl_stmt|;
if|if
condition|(
name|shouldRun
operator|&&
operator|!
name|running
condition|)
block|{
name|startSecretManager
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|stopSecretManager ()
specifier|private
name|void
name|stopSecretManager
parameter_list|()
block|{
if|if
condition|(
name|dtSecretManager
operator|!=
literal|null
condition|)
block|{
name|dtSecretManager
operator|.
name|stopThreads
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**     * Start services common to both active and standby states    */
DECL|method|startCommonServices (Configuration conf, HAContext haContext)
name|void
name|startCommonServices
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|HAContext
name|haContext
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|registerMBean
argument_list|()
expr_stmt|;
comment|// register the MBean for the FSNamesystemState
name|writeLock
argument_list|()
expr_stmt|;
name|this
operator|.
name|haContext
operator|=
name|haContext
expr_stmt|;
try|try
block|{
name|nnResourceChecker
operator|=
operator|new
name|NameNodeResourceChecker
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|checkAvailableResources
argument_list|()
expr_stmt|;
assert|assert
name|safeMode
operator|!=
literal|null
operator|&&
operator|!
name|blockManager
operator|.
name|isPopulatingReplQueues
argument_list|()
assert|;
name|StartupProgress
name|prog
init|=
name|NameNode
operator|.
name|getStartupProgress
argument_list|()
decl_stmt|;
name|prog
operator|.
name|beginPhase
argument_list|(
name|Phase
operator|.
name|SAFEMODE
argument_list|)
expr_stmt|;
name|long
name|completeBlocksTotal
init|=
name|getCompleteBlocksTotal
argument_list|()
decl_stmt|;
name|prog
operator|.
name|setTotal
argument_list|(
name|Phase
operator|.
name|SAFEMODE
argument_list|,
name|STEP_AWAITING_REPORTED_BLOCKS
argument_list|,
name|completeBlocksTotal
argument_list|)
expr_stmt|;
name|setBlockTotal
argument_list|(
name|completeBlocksTotal
argument_list|)
expr_stmt|;
name|blockManager
operator|.
name|activate
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
name|registerMXBean
argument_list|()
expr_stmt|;
name|DefaultMetricsSystem
operator|.
name|instance
argument_list|()
operator|.
name|register
argument_list|(
name|this
argument_list|)
expr_stmt|;
if|if
condition|(
name|inodeAttributeProvider
operator|!=
literal|null
condition|)
block|{
name|inodeAttributeProvider
operator|.
name|start
argument_list|()
expr_stmt|;
name|dir
operator|.
name|setINodeAttributeProvider
argument_list|(
name|inodeAttributeProvider
argument_list|)
expr_stmt|;
block|}
name|snapshotManager
operator|.
name|registerMXBean
argument_list|()
expr_stmt|;
block|}
comment|/**     * Stop services common to both active and standby states    */
DECL|method|stopCommonServices ()
name|void
name|stopCommonServices
parameter_list|()
block|{
name|writeLock
argument_list|()
expr_stmt|;
if|if
condition|(
name|inodeAttributeProvider
operator|!=
literal|null
condition|)
block|{
name|dir
operator|.
name|setINodeAttributeProvider
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|inodeAttributeProvider
operator|.
name|stop
argument_list|()
expr_stmt|;
block|}
try|try
block|{
if|if
condition|(
name|blockManager
operator|!=
literal|null
condition|)
name|blockManager
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
name|RetryCache
operator|.
name|clear
argument_list|(
name|retryCache
argument_list|)
expr_stmt|;
block|}
comment|/**    * Start services required in active state    * @throws IOException    */
DECL|method|startActiveServices ()
name|void
name|startActiveServices
parameter_list|()
throws|throws
name|IOException
block|{
name|startingActiveService
operator|=
literal|true
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Starting services required for active state"
argument_list|)
expr_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|FSEditLog
name|editLog
init|=
name|getFSImage
argument_list|()
operator|.
name|getEditLog
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|editLog
operator|.
name|isOpenForWrite
argument_list|()
condition|)
block|{
comment|// During startup, we're already open for write during initialization.
name|editLog
operator|.
name|initJournalsForWrite
argument_list|()
expr_stmt|;
comment|// May need to recover
name|editLog
operator|.
name|recoverUnclosedStreams
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Catching up to latest edits from old active before "
operator|+
literal|"taking over writer role in edits logs"
argument_list|)
expr_stmt|;
name|editLogTailer
operator|.
name|catchupDuringFailover
argument_list|()
expr_stmt|;
name|blockManager
operator|.
name|setPostponeBlocksFromFuture
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|blockManager
operator|.
name|getDatanodeManager
argument_list|()
operator|.
name|markAllDatanodesStale
argument_list|()
expr_stmt|;
name|blockManager
operator|.
name|clearQueues
argument_list|()
expr_stmt|;
name|blockManager
operator|.
name|processAllPendingDNMessages
argument_list|()
expr_stmt|;
comment|// Only need to re-process the queue, If not in SafeMode.
if|if
condition|(
operator|!
name|isInSafeMode
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Reprocessing replication and invalidation queues"
argument_list|)
expr_stmt|;
name|blockManager
operator|.
name|initializeReplQueues
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"NameNode metadata after re-processing "
operator|+
literal|"replication and invalidation queues during failover:\n"
operator|+
name|metaSaveAsString
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|long
name|nextTxId
init|=
name|getFSImage
argument_list|()
operator|.
name|getLastAppliedTxId
argument_list|()
operator|+
literal|1
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Will take over writing edit logs at txnid "
operator|+
name|nextTxId
argument_list|)
expr_stmt|;
name|editLog
operator|.
name|setNextTxId
argument_list|(
name|nextTxId
argument_list|)
expr_stmt|;
name|getFSImage
argument_list|()
operator|.
name|editLog
operator|.
name|openForWrite
argument_list|(
name|getEffectiveLayoutVersion
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Enable quota checks.
name|dir
operator|.
name|enableQuotaChecks
argument_list|()
expr_stmt|;
if|if
condition|(
name|haEnabled
condition|)
block|{
comment|// Renew all of the leases before becoming active.
comment|// This is because, while we were in standby mode,
comment|// the leases weren't getting renewed on this NN.
comment|// Give them all a fresh start here.
name|leaseManager
operator|.
name|renewAllLeases
argument_list|()
expr_stmt|;
block|}
name|leaseManager
operator|.
name|startMonitor
argument_list|()
expr_stmt|;
name|startSecretManagerIfNecessary
argument_list|()
expr_stmt|;
comment|//ResourceMonitor required only at ActiveNN. See HDFS-2914
name|this
operator|.
name|nnrmthread
operator|=
operator|new
name|Daemon
argument_list|(
operator|new
name|NameNodeResourceMonitor
argument_list|()
argument_list|)
expr_stmt|;
name|nnrmthread
operator|.
name|start
argument_list|()
expr_stmt|;
name|nnEditLogRoller
operator|=
operator|new
name|Daemon
argument_list|(
operator|new
name|NameNodeEditLogRoller
argument_list|(
name|editLogRollerThreshold
argument_list|,
name|editLogRollerInterval
argument_list|)
argument_list|)
expr_stmt|;
name|nnEditLogRoller
operator|.
name|start
argument_list|()
expr_stmt|;
if|if
condition|(
name|lazyPersistFileScrubIntervalSec
operator|>
literal|0
condition|)
block|{
name|lazyPersistFileScrubber
operator|=
operator|new
name|Daemon
argument_list|(
operator|new
name|LazyPersistFileScrubber
argument_list|(
name|lazyPersistFileScrubIntervalSec
argument_list|)
argument_list|)
expr_stmt|;
name|lazyPersistFileScrubber
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Lazy persist file scrubber is disabled,"
operator|+
literal|" configured scrub interval is zero."
argument_list|)
expr_stmt|;
block|}
name|cacheManager
operator|.
name|startMonitorThread
argument_list|()
expr_stmt|;
name|blockManager
operator|.
name|getDatanodeManager
argument_list|()
operator|.
name|setShouldSendCachingCommands
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|startingActiveService
operator|=
literal|false
expr_stmt|;
name|checkSafeMode
argument_list|()
expr_stmt|;
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|inActiveState ()
specifier|private
name|boolean
name|inActiveState
parameter_list|()
block|{
return|return
name|haContext
operator|!=
literal|null
operator|&&
name|haContext
operator|.
name|getState
argument_list|()
operator|.
name|getServiceState
argument_list|()
operator|==
name|HAServiceState
operator|.
name|ACTIVE
return|;
block|}
comment|/**    * @return Whether the namenode is transitioning to active state and is in the    *         middle of the {@link #startActiveServices()}    */
DECL|method|inTransitionToActive ()
specifier|public
name|boolean
name|inTransitionToActive
parameter_list|()
block|{
return|return
name|haEnabled
operator|&&
name|inActiveState
argument_list|()
operator|&&
name|startingActiveService
return|;
block|}
DECL|method|shouldUseDelegationTokens ()
specifier|private
name|boolean
name|shouldUseDelegationTokens
parameter_list|()
block|{
return|return
name|UserGroupInformation
operator|.
name|isSecurityEnabled
argument_list|()
operator|||
name|alwaysUseDelegationTokensForTests
return|;
block|}
comment|/**     * Stop services required in active state    */
DECL|method|stopActiveServices ()
name|void
name|stopActiveServices
parameter_list|()
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Stopping services started for active state"
argument_list|)
expr_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|stopSecretManager
argument_list|()
expr_stmt|;
name|leaseManager
operator|.
name|stopMonitor
argument_list|()
expr_stmt|;
if|if
condition|(
name|nnrmthread
operator|!=
literal|null
condition|)
block|{
operator|(
operator|(
name|NameNodeResourceMonitor
operator|)
name|nnrmthread
operator|.
name|getRunnable
argument_list|()
operator|)
operator|.
name|stopMonitor
argument_list|()
expr_stmt|;
name|nnrmthread
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|nnEditLogRoller
operator|!=
literal|null
condition|)
block|{
operator|(
operator|(
name|NameNodeEditLogRoller
operator|)
name|nnEditLogRoller
operator|.
name|getRunnable
argument_list|()
operator|)
operator|.
name|stop
argument_list|()
expr_stmt|;
name|nnEditLogRoller
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|lazyPersistFileScrubber
operator|!=
literal|null
condition|)
block|{
operator|(
operator|(
name|LazyPersistFileScrubber
operator|)
name|lazyPersistFileScrubber
operator|.
name|getRunnable
argument_list|()
operator|)
operator|.
name|stop
argument_list|()
expr_stmt|;
name|lazyPersistFileScrubber
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|dir
operator|!=
literal|null
operator|&&
name|getFSImage
argument_list|()
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|getFSImage
argument_list|()
operator|.
name|editLog
operator|!=
literal|null
condition|)
block|{
name|getFSImage
argument_list|()
operator|.
name|editLog
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|// Update the fsimage with the last txid that we wrote
comment|// so that the tailer starts from the right spot.
name|getFSImage
argument_list|()
operator|.
name|updateLastAppliedTxIdFromWritten
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|cacheManager
operator|!=
literal|null
condition|)
block|{
name|cacheManager
operator|.
name|stopMonitorThread
argument_list|()
expr_stmt|;
name|cacheManager
operator|.
name|clearDirectiveStats
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|blockManager
operator|!=
literal|null
condition|)
block|{
name|blockManager
operator|.
name|getDatanodeManager
argument_list|()
operator|.
name|clearPendingCachingCommands
argument_list|()
expr_stmt|;
name|blockManager
operator|.
name|getDatanodeManager
argument_list|()
operator|.
name|setShouldSendCachingCommands
argument_list|(
literal|false
argument_list|)
expr_stmt|;
comment|// Don't want to keep replication queues when not in Active.
name|blockManager
operator|.
name|clearQueues
argument_list|()
expr_stmt|;
name|blockManager
operator|.
name|setInitializedReplQueues
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Start services required in standby state     *     * @throws IOException    */
DECL|method|startStandbyServices (final Configuration conf)
name|void
name|startStandbyServices
parameter_list|(
specifier|final
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Starting services required for standby state"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|getFSImage
argument_list|()
operator|.
name|editLog
operator|.
name|isOpenForRead
argument_list|()
condition|)
block|{
comment|// During startup, we're already open for read.
name|getFSImage
argument_list|()
operator|.
name|editLog
operator|.
name|initSharedJournalsForRead
argument_list|()
expr_stmt|;
block|}
name|blockManager
operator|.
name|setPostponeBlocksFromFuture
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|// Disable quota checks while in standby.
name|dir
operator|.
name|disableQuotaChecks
argument_list|()
expr_stmt|;
name|editLogTailer
operator|=
operator|new
name|EditLogTailer
argument_list|(
name|this
argument_list|,
name|conf
argument_list|)
expr_stmt|;
name|editLogTailer
operator|.
name|start
argument_list|()
expr_stmt|;
if|if
condition|(
name|standbyShouldCheckpoint
condition|)
block|{
name|standbyCheckpointer
operator|=
operator|new
name|StandbyCheckpointer
argument_list|(
name|conf
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|standbyCheckpointer
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Called when the NN is in Standby state and the editlog tailer tails the    * OP_ROLLING_UPGRADE_START.    */
DECL|method|triggerRollbackCheckpoint ()
name|void
name|triggerRollbackCheckpoint
parameter_list|()
block|{
name|setNeedRollbackFsImage
argument_list|(
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|standbyCheckpointer
operator|!=
literal|null
condition|)
block|{
name|standbyCheckpointer
operator|.
name|triggerRollbackCheckpoint
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Called while the NN is in Standby state, but just about to be    * asked to enter Active state. This cancels any checkpoints    * currently being taken.    */
DECL|method|prepareToStopStandbyServices ()
name|void
name|prepareToStopStandbyServices
parameter_list|()
throws|throws
name|ServiceFailedException
block|{
if|if
condition|(
name|standbyCheckpointer
operator|!=
literal|null
condition|)
block|{
name|standbyCheckpointer
operator|.
name|cancelAndPreventCheckpoints
argument_list|(
literal|"About to leave standby state"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Stop services required in standby state */
DECL|method|stopStandbyServices ()
name|void
name|stopStandbyServices
parameter_list|()
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Stopping services started for standby state"
argument_list|)
expr_stmt|;
if|if
condition|(
name|standbyCheckpointer
operator|!=
literal|null
condition|)
block|{
name|standbyCheckpointer
operator|.
name|stop
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|editLogTailer
operator|!=
literal|null
condition|)
block|{
name|editLogTailer
operator|.
name|stop
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|dir
operator|!=
literal|null
operator|&&
name|getFSImage
argument_list|()
operator|!=
literal|null
operator|&&
name|getFSImage
argument_list|()
operator|.
name|editLog
operator|!=
literal|null
condition|)
block|{
name|getFSImage
argument_list|()
operator|.
name|editLog
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|checkOperation (OperationCategory op)
specifier|public
name|void
name|checkOperation
parameter_list|(
name|OperationCategory
name|op
parameter_list|)
throws|throws
name|StandbyException
block|{
if|if
condition|(
name|haContext
operator|!=
literal|null
condition|)
block|{
comment|// null in some unit tests
name|haContext
operator|.
name|checkOperation
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * @throws RetriableException    *           If 1) The NameNode is in SafeMode, 2) HA is enabled, and 3)    *           NameNode is in active state    * @throws SafeModeException    *           Otherwise if NameNode is in SafeMode.    */
DECL|method|checkNameNodeSafeMode (String errorMsg)
name|void
name|checkNameNodeSafeMode
parameter_list|(
name|String
name|errorMsg
parameter_list|)
throws|throws
name|RetriableException
throws|,
name|SafeModeException
block|{
if|if
condition|(
name|isInSafeMode
argument_list|()
condition|)
block|{
name|SafeModeException
name|se
init|=
name|newSafemodeException
argument_list|(
name|errorMsg
argument_list|)
decl_stmt|;
if|if
condition|(
name|haEnabled
operator|&&
name|haContext
operator|!=
literal|null
operator|&&
name|haContext
operator|.
name|getState
argument_list|()
operator|.
name|getServiceState
argument_list|()
operator|==
name|HAServiceState
operator|.
name|ACTIVE
operator|&&
name|shouldRetrySafeMode
argument_list|(
name|this
operator|.
name|safeMode
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|RetriableException
argument_list|(
name|se
argument_list|)
throw|;
block|}
else|else
block|{
throw|throw
name|se
throw|;
block|}
block|}
block|}
DECL|method|newSafemodeException (String errorMsg)
specifier|private
name|SafeModeException
name|newSafemodeException
parameter_list|(
name|String
name|errorMsg
parameter_list|)
block|{
return|return
operator|new
name|SafeModeException
argument_list|(
name|errorMsg
operator|+
literal|". Name node is in safe "
operator|+
literal|"mode.\n"
operator|+
name|safeMode
operator|.
name|getTurnOffTip
argument_list|()
argument_list|)
return|;
block|}
DECL|method|isPermissionEnabled ()
name|boolean
name|isPermissionEnabled
parameter_list|()
block|{
return|return
name|isPermissionEnabled
return|;
block|}
comment|/**    * We already know that the safemode is on. We will throw a RetriableException    * if the safemode is not manual or caused by low resource.    */
DECL|method|shouldRetrySafeMode (SafeModeInfo safeMode)
specifier|private
name|boolean
name|shouldRetrySafeMode
parameter_list|(
name|SafeModeInfo
name|safeMode
parameter_list|)
block|{
if|if
condition|(
name|safeMode
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
else|else
block|{
return|return
operator|!
name|safeMode
operator|.
name|isManual
argument_list|()
operator|&&
operator|!
name|safeMode
operator|.
name|areResourcesLow
argument_list|()
return|;
block|}
block|}
DECL|method|getNamespaceDirs (Configuration conf)
specifier|public
specifier|static
name|Collection
argument_list|<
name|URI
argument_list|>
name|getNamespaceDirs
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
return|return
name|getStorageDirs
argument_list|(
name|conf
argument_list|,
name|DFS_NAMENODE_NAME_DIR_KEY
argument_list|)
return|;
block|}
comment|/**    * Get all edits dirs which are required. If any shared edits dirs are    * configured, these are also included in the set of required dirs.    *     * @param conf the HDFS configuration.    * @return all required dirs.    */
DECL|method|getRequiredNamespaceEditsDirs (Configuration conf)
specifier|public
specifier|static
name|Collection
argument_list|<
name|URI
argument_list|>
name|getRequiredNamespaceEditsDirs
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
name|Set
argument_list|<
name|URI
argument_list|>
name|ret
init|=
operator|new
name|HashSet
argument_list|<
name|URI
argument_list|>
argument_list|()
decl_stmt|;
name|ret
operator|.
name|addAll
argument_list|(
name|getStorageDirs
argument_list|(
name|conf
argument_list|,
name|DFS_NAMENODE_EDITS_DIR_REQUIRED_KEY
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|.
name|addAll
argument_list|(
name|getSharedEditsDirs
argument_list|(
name|conf
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
DECL|method|getStorageDirs (Configuration conf, String propertyName)
specifier|private
specifier|static
name|Collection
argument_list|<
name|URI
argument_list|>
name|getStorageDirs
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|String
name|propertyName
parameter_list|)
block|{
name|Collection
argument_list|<
name|String
argument_list|>
name|dirNames
init|=
name|conf
operator|.
name|getTrimmedStringCollection
argument_list|(
name|propertyName
argument_list|)
decl_stmt|;
name|StartupOption
name|startOpt
init|=
name|NameNode
operator|.
name|getStartupOption
argument_list|(
name|conf
argument_list|)
decl_stmt|;
if|if
condition|(
name|startOpt
operator|==
name|StartupOption
operator|.
name|IMPORT
condition|)
block|{
comment|// In case of IMPORT this will get rid of default directories
comment|// but will retain directories specified in hdfs-site.xml
comment|// When importing image from a checkpoint, the name-node can
comment|// start with empty set of storage directories.
name|Configuration
name|cE
init|=
operator|new
name|HdfsConfiguration
argument_list|(
literal|false
argument_list|)
decl_stmt|;
name|cE
operator|.
name|addResource
argument_list|(
literal|"core-default.xml"
argument_list|)
expr_stmt|;
name|cE
operator|.
name|addResource
argument_list|(
literal|"core-site.xml"
argument_list|)
expr_stmt|;
name|cE
operator|.
name|addResource
argument_list|(
literal|"hdfs-default.xml"
argument_list|)
expr_stmt|;
name|Collection
argument_list|<
name|String
argument_list|>
name|dirNames2
init|=
name|cE
operator|.
name|getTrimmedStringCollection
argument_list|(
name|propertyName
argument_list|)
decl_stmt|;
name|dirNames
operator|.
name|removeAll
argument_list|(
name|dirNames2
argument_list|)
expr_stmt|;
if|if
condition|(
name|dirNames
operator|.
name|isEmpty
argument_list|()
condition|)
name|LOG
operator|.
name|warn
argument_list|(
literal|"!!! WARNING !!!"
operator|+
literal|"\n\tThe NameNode currently runs without persistent storage."
operator|+
literal|"\n\tAny changes to the file system meta-data may be lost."
operator|+
literal|"\n\tRecommended actions:"
operator|+
literal|"\n\t\t- shutdown and restart NameNode with configured \""
operator|+
name|propertyName
operator|+
literal|"\" in hdfs-site.xml;"
operator|+
literal|"\n\t\t- use Backup Node as a persistent and up-to-date storage "
operator|+
literal|"of the file system meta-data."
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dirNames
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|dirNames
operator|=
name|Collections
operator|.
name|singletonList
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_EDITS_DIR_DEFAULT
argument_list|)
expr_stmt|;
block|}
return|return
name|Util
operator|.
name|stringCollectionAsURIs
argument_list|(
name|dirNames
argument_list|)
return|;
block|}
comment|/**    * Return an ordered list of edits directories to write to.    * The list is ordered such that all shared edits directories    * are ordered before non-shared directories, and any duplicates    * are removed. The order they are specified in the configuration    * is retained.    * @return Collection of shared edits directories.    * @throws IOException if multiple shared edits directories are configured    */
DECL|method|getNamespaceEditsDirs (Configuration conf)
specifier|public
specifier|static
name|List
argument_list|<
name|URI
argument_list|>
name|getNamespaceEditsDirs
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|getNamespaceEditsDirs
argument_list|(
name|conf
argument_list|,
literal|true
argument_list|)
return|;
block|}
DECL|method|getNamespaceEditsDirs (Configuration conf, boolean includeShared)
specifier|public
specifier|static
name|List
argument_list|<
name|URI
argument_list|>
name|getNamespaceEditsDirs
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|boolean
name|includeShared
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Use a LinkedHashSet so that order is maintained while we de-dup
comment|// the entries.
name|LinkedHashSet
argument_list|<
name|URI
argument_list|>
name|editsDirs
init|=
operator|new
name|LinkedHashSet
argument_list|<
name|URI
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|includeShared
condition|)
block|{
name|List
argument_list|<
name|URI
argument_list|>
name|sharedDirs
init|=
name|getSharedEditsDirs
argument_list|(
name|conf
argument_list|)
decl_stmt|;
comment|// Fail until multiple shared edits directories are supported (HDFS-2782)
if|if
condition|(
name|sharedDirs
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Multiple shared edits directories are not yet supported"
argument_list|)
throw|;
block|}
comment|// First add the shared edits dirs. It's critical that the shared dirs
comment|// are added first, since JournalSet syncs them in the order they are listed,
comment|// and we need to make sure all edits are in place in the shared storage
comment|// before they are replicated locally. See HDFS-2874.
for|for
control|(
name|URI
name|dir
range|:
name|sharedDirs
control|)
block|{
if|if
condition|(
operator|!
name|editsDirs
operator|.
name|add
argument_list|(
name|dir
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Edits URI "
operator|+
name|dir
operator|+
literal|" listed multiple times in "
operator|+
name|DFS_NAMENODE_SHARED_EDITS_DIR_KEY
operator|+
literal|". Ignoring duplicates."
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// Now add the non-shared dirs.
for|for
control|(
name|URI
name|dir
range|:
name|getStorageDirs
argument_list|(
name|conf
argument_list|,
name|DFS_NAMENODE_EDITS_DIR_KEY
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|editsDirs
operator|.
name|add
argument_list|(
name|dir
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Edits URI "
operator|+
name|dir
operator|+
literal|" listed multiple times in "
operator|+
name|DFS_NAMENODE_SHARED_EDITS_DIR_KEY
operator|+
literal|" and "
operator|+
name|DFS_NAMENODE_EDITS_DIR_KEY
operator|+
literal|". Ignoring duplicates."
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|editsDirs
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// If this is the case, no edit dirs have been explicitly configured.
comment|// Image dirs are to be used for edits too.
return|return
name|Lists
operator|.
name|newArrayList
argument_list|(
name|getNamespaceDirs
argument_list|(
name|conf
argument_list|)
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|Lists
operator|.
name|newArrayList
argument_list|(
name|editsDirs
argument_list|)
return|;
block|}
block|}
comment|/**    * Returns edit directories that are shared between primary and secondary.    * @param conf configuration    * @return collection of edit directories from {@code conf}    */
DECL|method|getSharedEditsDirs (Configuration conf)
specifier|public
specifier|static
name|List
argument_list|<
name|URI
argument_list|>
name|getSharedEditsDirs
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
comment|// don't use getStorageDirs here, because we want an empty default
comment|// rather than the dir in /tmp
name|Collection
argument_list|<
name|String
argument_list|>
name|dirNames
init|=
name|conf
operator|.
name|getTrimmedStringCollection
argument_list|(
name|DFS_NAMENODE_SHARED_EDITS_DIR_KEY
argument_list|)
decl_stmt|;
return|return
name|Util
operator|.
name|stringCollectionAsURIs
argument_list|(
name|dirNames
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|readLock ()
specifier|public
name|void
name|readLock
parameter_list|()
block|{
name|this
operator|.
name|fsLock
operator|.
name|readLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|readUnlock ()
specifier|public
name|void
name|readUnlock
parameter_list|()
block|{
name|this
operator|.
name|fsLock
operator|.
name|readLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|writeLock ()
specifier|public
name|void
name|writeLock
parameter_list|()
block|{
name|this
operator|.
name|fsLock
operator|.
name|writeLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|writeLockInterruptibly ()
specifier|public
name|void
name|writeLockInterruptibly
parameter_list|()
throws|throws
name|InterruptedException
block|{
name|this
operator|.
name|fsLock
operator|.
name|writeLock
argument_list|()
operator|.
name|lockInterruptibly
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|writeUnlock ()
specifier|public
name|void
name|writeUnlock
parameter_list|()
block|{
name|this
operator|.
name|fsLock
operator|.
name|writeLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|hasWriteLock ()
specifier|public
name|boolean
name|hasWriteLock
parameter_list|()
block|{
return|return
name|this
operator|.
name|fsLock
operator|.
name|isWriteLockedByCurrentThread
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|hasReadLock ()
specifier|public
name|boolean
name|hasReadLock
parameter_list|()
block|{
return|return
name|this
operator|.
name|fsLock
operator|.
name|getReadHoldCount
argument_list|()
operator|>
literal|0
operator|||
name|hasWriteLock
argument_list|()
return|;
block|}
DECL|method|getReadHoldCount ()
specifier|public
name|int
name|getReadHoldCount
parameter_list|()
block|{
return|return
name|this
operator|.
name|fsLock
operator|.
name|getReadHoldCount
argument_list|()
return|;
block|}
DECL|method|getWriteHoldCount ()
specifier|public
name|int
name|getWriteHoldCount
parameter_list|()
block|{
return|return
name|this
operator|.
name|fsLock
operator|.
name|getWriteHoldCount
argument_list|()
return|;
block|}
comment|/** Lock the checkpoint lock */
DECL|method|cpLock ()
specifier|public
name|void
name|cpLock
parameter_list|()
block|{
name|this
operator|.
name|cpLock
operator|.
name|lock
argument_list|()
expr_stmt|;
block|}
comment|/** Lock the checkpoint lock interrupibly */
DECL|method|cpLockInterruptibly ()
specifier|public
name|void
name|cpLockInterruptibly
parameter_list|()
throws|throws
name|InterruptedException
block|{
name|this
operator|.
name|cpLock
operator|.
name|lockInterruptibly
argument_list|()
expr_stmt|;
block|}
comment|/** Unlock the checkpoint lock */
DECL|method|cpUnlock ()
specifier|public
name|void
name|cpUnlock
parameter_list|()
block|{
name|this
operator|.
name|cpLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
DECL|method|getNamespaceInfo ()
name|NamespaceInfo
name|getNamespaceInfo
parameter_list|()
block|{
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
return|return
name|unprotectedGetNamespaceInfo
argument_list|()
return|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Version of @see #getNamespaceInfo() that is not protected by a lock.    */
DECL|method|unprotectedGetNamespaceInfo ()
name|NamespaceInfo
name|unprotectedGetNamespaceInfo
parameter_list|()
block|{
return|return
operator|new
name|NamespaceInfo
argument_list|(
name|getFSImage
argument_list|()
operator|.
name|getStorage
argument_list|()
operator|.
name|getNamespaceID
argument_list|()
argument_list|,
name|getClusterId
argument_list|()
argument_list|,
name|getBlockPoolId
argument_list|()
argument_list|,
name|getFSImage
argument_list|()
operator|.
name|getStorage
argument_list|()
operator|.
name|getCTime
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Close down this file system manager.    * Causes heartbeat and lease daemons to stop; waits briefly for    * them to finish, but a short timeout returns control back to caller.    */
DECL|method|close ()
name|void
name|close
parameter_list|()
block|{
name|fsRunning
operator|=
literal|false
expr_stmt|;
try|try
block|{
name|stopCommonServices
argument_list|()
expr_stmt|;
if|if
condition|(
name|smmthread
operator|!=
literal|null
condition|)
name|smmthread
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
comment|// using finally to ensure we also wait for lease daemon
try|try
block|{
name|stopActiveServices
argument_list|()
expr_stmt|;
name|stopStandbyServices
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ie
parameter_list|)
block|{       }
finally|finally
block|{
name|IOUtils
operator|.
name|cleanup
argument_list|(
name|LOG
argument_list|,
name|dir
argument_list|)
expr_stmt|;
name|IOUtils
operator|.
name|cleanup
argument_list|(
name|LOG
argument_list|,
name|fsImage
argument_list|)
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
DECL|method|isRunning ()
specifier|public
name|boolean
name|isRunning
parameter_list|()
block|{
return|return
name|fsRunning
return|;
block|}
annotation|@
name|Override
DECL|method|isInStandbyState ()
specifier|public
name|boolean
name|isInStandbyState
parameter_list|()
block|{
if|if
condition|(
name|haContext
operator|==
literal|null
operator|||
name|haContext
operator|.
name|getState
argument_list|()
operator|==
literal|null
condition|)
block|{
comment|// We're still starting up. In this case, if HA is
comment|// on for the cluster, we always start in standby. Otherwise
comment|// start in active.
return|return
name|haEnabled
return|;
block|}
return|return
name|HAServiceState
operator|.
name|STANDBY
operator|==
name|haContext
operator|.
name|getState
argument_list|()
operator|.
name|getServiceState
argument_list|()
return|;
block|}
comment|/**    * Dump all metadata into specified file    */
DECL|method|metaSave (String filename)
name|void
name|metaSave
parameter_list|(
name|String
name|filename
parameter_list|)
throws|throws
name|IOException
block|{
name|checkSuperuserPrivilege
argument_list|()
expr_stmt|;
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|UNCHECKED
argument_list|)
expr_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|UNCHECKED
argument_list|)
expr_stmt|;
name|File
name|file
init|=
operator|new
name|File
argument_list|(
name|System
operator|.
name|getProperty
argument_list|(
literal|"hadoop.log.dir"
argument_list|)
argument_list|,
name|filename
argument_list|)
decl_stmt|;
name|PrintWriter
name|out
init|=
operator|new
name|PrintWriter
argument_list|(
operator|new
name|BufferedWriter
argument_list|(
operator|new
name|OutputStreamWriter
argument_list|(
operator|new
name|FileOutputStream
argument_list|(
name|file
argument_list|)
argument_list|,
name|Charsets
operator|.
name|UTF_8
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|metaSave
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|out
operator|.
name|flush
argument_list|()
expr_stmt|;
name|out
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|metaSave (PrintWriter out)
specifier|private
name|void
name|metaSave
parameter_list|(
name|PrintWriter
name|out
parameter_list|)
block|{
assert|assert
name|hasWriteLock
argument_list|()
assert|;
name|long
name|totalInodes
init|=
name|this
operator|.
name|dir
operator|.
name|totalInodes
argument_list|()
decl_stmt|;
name|long
name|totalBlocks
init|=
name|this
operator|.
name|getBlocksTotal
argument_list|()
decl_stmt|;
name|out
operator|.
name|println
argument_list|(
name|totalInodes
operator|+
literal|" files and directories, "
operator|+
name|totalBlocks
operator|+
literal|" blocks = "
operator|+
operator|(
name|totalInodes
operator|+
name|totalBlocks
operator|)
operator|+
literal|" total filesystem objects"
argument_list|)
expr_stmt|;
name|blockManager
operator|.
name|metaSave
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|}
DECL|method|metaSaveAsString ()
specifier|private
name|String
name|metaSaveAsString
parameter_list|()
block|{
name|StringWriter
name|sw
init|=
operator|new
name|StringWriter
argument_list|()
decl_stmt|;
name|PrintWriter
name|pw
init|=
operator|new
name|PrintWriter
argument_list|(
name|sw
argument_list|)
decl_stmt|;
name|metaSave
argument_list|(
name|pw
argument_list|)
expr_stmt|;
name|pw
operator|.
name|flush
argument_list|()
expr_stmt|;
return|return
name|sw
operator|.
name|toString
argument_list|()
return|;
block|}
DECL|method|getServerDefaults ()
name|FsServerDefaults
name|getServerDefaults
parameter_list|()
throws|throws
name|StandbyException
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|READ
argument_list|)
expr_stmt|;
return|return
name|serverDefaults
return|;
block|}
comment|/////////////////////////////////////////////////////////
comment|//
comment|// These methods are called by HadoopFS clients
comment|//
comment|/////////////////////////////////////////////////////////
comment|/**    * Set permissions for an existing file.    * @throws IOException    */
DECL|method|setPermission (String src, FsPermission permission)
name|void
name|setPermission
parameter_list|(
name|String
name|src
parameter_list|,
name|FsPermission
name|permission
parameter_list|)
throws|throws
name|IOException
block|{
name|HdfsFileStatus
name|auditStat
decl_stmt|;
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|checkNameNodeSafeMode
argument_list|(
literal|"Cannot set permission for "
operator|+
name|src
argument_list|)
expr_stmt|;
name|auditStat
operator|=
name|FSDirAttrOp
operator|.
name|setPermission
argument_list|(
name|dir
argument_list|,
name|src
argument_list|,
name|permission
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|AccessControlException
name|e
parameter_list|)
block|{
name|logAuditEvent
argument_list|(
literal|false
argument_list|,
literal|"setPermission"
argument_list|,
name|src
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
name|getEditLog
argument_list|()
operator|.
name|logSync
argument_list|()
expr_stmt|;
name|logAuditEvent
argument_list|(
literal|true
argument_list|,
literal|"setPermission"
argument_list|,
name|src
argument_list|,
literal|null
argument_list|,
name|auditStat
argument_list|)
expr_stmt|;
block|}
comment|/**    * Set owner for an existing file.    * @throws IOException    */
DECL|method|setOwner (String src, String username, String group)
name|void
name|setOwner
parameter_list|(
name|String
name|src
parameter_list|,
name|String
name|username
parameter_list|,
name|String
name|group
parameter_list|)
throws|throws
name|IOException
block|{
name|HdfsFileStatus
name|auditStat
decl_stmt|;
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|checkNameNodeSafeMode
argument_list|(
literal|"Cannot set owner for "
operator|+
name|src
argument_list|)
expr_stmt|;
name|auditStat
operator|=
name|FSDirAttrOp
operator|.
name|setOwner
argument_list|(
name|dir
argument_list|,
name|src
argument_list|,
name|username
argument_list|,
name|group
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|AccessControlException
name|e
parameter_list|)
block|{
name|logAuditEvent
argument_list|(
literal|false
argument_list|,
literal|"setOwner"
argument_list|,
name|src
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
name|getEditLog
argument_list|()
operator|.
name|logSync
argument_list|()
expr_stmt|;
name|logAuditEvent
argument_list|(
literal|true
argument_list|,
literal|"setOwner"
argument_list|,
name|src
argument_list|,
literal|null
argument_list|,
name|auditStat
argument_list|)
expr_stmt|;
block|}
comment|/**    * Get block locations within the specified range.    * @see ClientProtocol#getBlockLocations(String, long, long)    */
DECL|method|getBlockLocations (String clientMachine, String srcArg, long offset, long length)
name|LocatedBlocks
name|getBlockLocations
parameter_list|(
name|String
name|clientMachine
parameter_list|,
name|String
name|srcArg
parameter_list|,
name|long
name|offset
parameter_list|,
name|long
name|length
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|READ
argument_list|)
expr_stmt|;
name|GetBlockLocationsResult
name|res
init|=
literal|null
decl_stmt|;
name|FSPermissionChecker
name|pc
init|=
name|getPermissionChecker
argument_list|()
decl_stmt|;
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|READ
argument_list|)
expr_stmt|;
name|res
operator|=
name|FSDirStatAndListingOp
operator|.
name|getBlockLocations
argument_list|(
name|dir
argument_list|,
name|pc
argument_list|,
name|srcArg
argument_list|,
name|offset
argument_list|,
name|length
argument_list|,
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|isInSafeMode
argument_list|()
condition|)
block|{
for|for
control|(
name|LocatedBlock
name|b
range|:
name|res
operator|.
name|blocks
operator|.
name|getLocatedBlocks
argument_list|()
control|)
block|{
comment|// if safemode& no block locations yet then throw safemodeException
if|if
condition|(
operator|(
name|b
operator|.
name|getLocations
argument_list|()
operator|==
literal|null
operator|)
operator|||
operator|(
name|b
operator|.
name|getLocations
argument_list|()
operator|.
name|length
operator|==
literal|0
operator|)
condition|)
block|{
name|SafeModeException
name|se
init|=
name|newSafemodeException
argument_list|(
literal|"Zero blocklocations for "
operator|+
name|srcArg
argument_list|)
decl_stmt|;
if|if
condition|(
name|haEnabled
operator|&&
name|haContext
operator|!=
literal|null
operator|&&
name|haContext
operator|.
name|getState
argument_list|()
operator|.
name|getServiceState
argument_list|()
operator|==
name|HAServiceState
operator|.
name|ACTIVE
condition|)
block|{
throw|throw
operator|new
name|RetriableException
argument_list|(
name|se
argument_list|)
throw|;
block|}
else|else
block|{
throw|throw
name|se
throw|;
block|}
block|}
block|}
block|}
block|}
catch|catch
parameter_list|(
name|AccessControlException
name|e
parameter_list|)
block|{
name|logAuditEvent
argument_list|(
literal|false
argument_list|,
literal|"open"
argument_list|,
name|srcArg
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
name|logAuditEvent
argument_list|(
literal|true
argument_list|,
literal|"open"
argument_list|,
name|srcArg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isInSafeMode
argument_list|()
operator|&&
name|res
operator|.
name|updateAccessTime
argument_list|()
condition|)
block|{
name|byte
index|[]
index|[]
name|pathComponents
init|=
name|FSDirectory
operator|.
name|getPathComponentsForReservedPath
argument_list|(
name|srcArg
argument_list|)
decl_stmt|;
name|String
name|src
init|=
name|srcArg
decl_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
specifier|final
name|long
name|now
init|=
name|now
argument_list|()
decl_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
comment|/**          * Resolve the path again and update the atime only when the file          * exists.          *          * XXX: Races can still occur even after resolving the path again.          * For example:          *          *<ul>          *<li>Get the block location for "/a/b"</li>          *<li>Rename "/a/b" to "/c/b"</li>          *<li>The second resolution still points to "/a/b", which is          *   wrong.</li>          *</ul>          *          * The behavior is incorrect but consistent with the one before          * HDFS-7463. A better fix is to change the edit log of SetTime to          * use inode id instead of a path.          */
name|src
operator|=
name|dir
operator|.
name|resolvePath
argument_list|(
name|pc
argument_list|,
name|srcArg
argument_list|,
name|pathComponents
argument_list|)
expr_stmt|;
specifier|final
name|INodesInPath
name|iip
init|=
name|dir
operator|.
name|getINodesInPath
argument_list|(
name|src
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|INode
name|inode
init|=
name|iip
operator|.
name|getLastINode
argument_list|()
decl_stmt|;
name|boolean
name|updateAccessTime
init|=
name|inode
operator|!=
literal|null
operator|&&
name|now
operator|>
name|inode
operator|.
name|getAccessTime
argument_list|()
operator|+
name|dir
operator|.
name|getAccessTimePrecision
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|isInSafeMode
argument_list|()
operator|&&
name|updateAccessTime
condition|)
block|{
name|boolean
name|changed
init|=
name|FSDirAttrOp
operator|.
name|setTimes
argument_list|(
name|dir
argument_list|,
name|inode
argument_list|,
operator|-
literal|1
argument_list|,
name|now
argument_list|,
literal|false
argument_list|,
name|iip
operator|.
name|getLatestSnapshotId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|changed
condition|)
block|{
name|getEditLog
argument_list|()
operator|.
name|logTimes
argument_list|(
name|src
argument_list|,
operator|-
literal|1
argument_list|,
name|now
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to update the access time of "
operator|+
name|src
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
name|LocatedBlocks
name|blocks
init|=
name|res
operator|.
name|blocks
decl_stmt|;
if|if
condition|(
name|blocks
operator|!=
literal|null
condition|)
block|{
name|blockManager
operator|.
name|getDatanodeManager
argument_list|()
operator|.
name|sortLocatedBlocks
argument_list|(
name|clientMachine
argument_list|,
name|blocks
operator|.
name|getLocatedBlocks
argument_list|()
argument_list|)
expr_stmt|;
comment|// lastBlock is not part of getLocatedBlocks(), might need to sort it too
name|LocatedBlock
name|lastBlock
init|=
name|blocks
operator|.
name|getLastLocatedBlock
argument_list|()
decl_stmt|;
if|if
condition|(
name|lastBlock
operator|!=
literal|null
condition|)
block|{
name|ArrayList
argument_list|<
name|LocatedBlock
argument_list|>
name|lastBlockList
init|=
name|Lists
operator|.
name|newArrayList
argument_list|(
name|lastBlock
argument_list|)
decl_stmt|;
name|blockManager
operator|.
name|getDatanodeManager
argument_list|()
operator|.
name|sortLocatedBlocks
argument_list|(
name|clientMachine
argument_list|,
name|lastBlockList
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|blocks
return|;
block|}
comment|/**    * Moves all the blocks from {@code srcs} and appends them to {@code target}    * To avoid rollbacks we will verify validity of ALL of the args    * before we start actual move.    *     * This does not support ".inodes" relative path    * @param target target to concat into    * @param srcs file that will be concatenated    * @throws IOException on error    */
DECL|method|concat (String target, String [] srcs, boolean logRetryCache)
name|void
name|concat
parameter_list|(
name|String
name|target
parameter_list|,
name|String
index|[]
name|srcs
parameter_list|,
name|boolean
name|logRetryCache
parameter_list|)
throws|throws
name|IOException
block|{
name|waitForLoadingFSImage
argument_list|()
expr_stmt|;
name|HdfsFileStatus
name|stat
init|=
literal|null
decl_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|checkNameNodeSafeMode
argument_list|(
literal|"Cannot concat "
operator|+
name|target
argument_list|)
expr_stmt|;
name|stat
operator|=
name|FSDirConcatOp
operator|.
name|concat
argument_list|(
name|dir
argument_list|,
name|target
argument_list|,
name|srcs
argument_list|,
name|logRetryCache
argument_list|)
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|getEditLog
argument_list|()
operator|.
name|logSync
argument_list|()
expr_stmt|;
block|}
name|logAuditEvent
argument_list|(
name|success
argument_list|,
literal|"concat"
argument_list|,
name|Arrays
operator|.
name|toString
argument_list|(
name|srcs
argument_list|)
argument_list|,
name|target
argument_list|,
name|stat
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * stores the modification and access time for this inode.     * The access time is precise up to an hour. The transaction, if needed, is    * written to the edits log but is not flushed.    */
DECL|method|setTimes (String src, long mtime, long atime)
name|void
name|setTimes
parameter_list|(
name|String
name|src
parameter_list|,
name|long
name|mtime
parameter_list|,
name|long
name|atime
parameter_list|)
throws|throws
name|IOException
block|{
name|HdfsFileStatus
name|auditStat
decl_stmt|;
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|checkNameNodeSafeMode
argument_list|(
literal|"Cannot set times "
operator|+
name|src
argument_list|)
expr_stmt|;
name|auditStat
operator|=
name|FSDirAttrOp
operator|.
name|setTimes
argument_list|(
name|dir
argument_list|,
name|src
argument_list|,
name|mtime
argument_list|,
name|atime
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|AccessControlException
name|e
parameter_list|)
block|{
name|logAuditEvent
argument_list|(
literal|false
argument_list|,
literal|"setTimes"
argument_list|,
name|src
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
name|getEditLog
argument_list|()
operator|.
name|logSync
argument_list|()
expr_stmt|;
name|logAuditEvent
argument_list|(
literal|true
argument_list|,
literal|"setTimes"
argument_list|,
name|src
argument_list|,
literal|null
argument_list|,
name|auditStat
argument_list|)
expr_stmt|;
block|}
comment|/**    * Truncate file to a lower length.    * Truncate cannot be reverted / recovered from as it causes data loss.    * Truncation at block boundary is atomic, otherwise it requires    * block recovery to truncate the last block of the file.    *    * @return true if client does not need to wait for block recovery,    *         false if client needs to wait for block recovery.    */
DECL|method|truncate (String src, long newLength, String clientName, String clientMachine, long mtime)
name|boolean
name|truncate
parameter_list|(
name|String
name|src
parameter_list|,
name|long
name|newLength
parameter_list|,
name|String
name|clientName
parameter_list|,
name|String
name|clientMachine
parameter_list|,
name|long
name|mtime
parameter_list|)
throws|throws
name|IOException
throws|,
name|UnresolvedLinkException
block|{
name|requireEffectiveLayoutVersionForFeature
argument_list|(
name|Feature
operator|.
name|TRUNCATE
argument_list|)
expr_stmt|;
specifier|final
name|FSDirTruncateOp
operator|.
name|TruncateResult
name|r
decl_stmt|;
try|try
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|debug
argument_list|(
literal|"DIR* NameSystem.truncate: src={} newLength={}"
argument_list|,
name|src
argument_list|,
name|newLength
argument_list|)
expr_stmt|;
if|if
condition|(
name|newLength
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|HadoopIllegalArgumentException
argument_list|(
literal|"Cannot truncate to a negative file size: "
operator|+
name|newLength
operator|+
literal|"."
argument_list|)
throw|;
block|}
specifier|final
name|FSPermissionChecker
name|pc
init|=
name|getPermissionChecker
argument_list|()
decl_stmt|;
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
name|BlocksMapUpdateInfo
name|toRemoveBlocks
init|=
operator|new
name|BlocksMapUpdateInfo
argument_list|()
decl_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|checkNameNodeSafeMode
argument_list|(
literal|"Cannot truncate for "
operator|+
name|src
argument_list|)
expr_stmt|;
name|r
operator|=
name|FSDirTruncateOp
operator|.
name|truncate
argument_list|(
name|this
argument_list|,
name|src
argument_list|,
name|newLength
argument_list|,
name|clientName
argument_list|,
name|clientMachine
argument_list|,
name|mtime
argument_list|,
name|toRemoveBlocks
argument_list|,
name|pc
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
name|getEditLog
argument_list|()
operator|.
name|logSync
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|toRemoveBlocks
operator|.
name|getToDeleteList
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|removeBlocks
argument_list|(
name|toRemoveBlocks
argument_list|)
expr_stmt|;
name|toRemoveBlocks
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
name|logAuditEvent
argument_list|(
literal|true
argument_list|,
literal|"truncate"
argument_list|,
name|src
argument_list|,
literal|null
argument_list|,
name|r
operator|.
name|getFileStatus
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|AccessControlException
name|e
parameter_list|)
block|{
name|logAuditEvent
argument_list|(
literal|false
argument_list|,
literal|"truncate"
argument_list|,
name|src
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
return|return
name|r
operator|.
name|getResult
argument_list|()
return|;
block|}
comment|/**    * Create a symbolic link.    */
DECL|method|createSymlink (String target, String link, PermissionStatus dirPerms, boolean createParent, boolean logRetryCache)
name|void
name|createSymlink
parameter_list|(
name|String
name|target
parameter_list|,
name|String
name|link
parameter_list|,
name|PermissionStatus
name|dirPerms
parameter_list|,
name|boolean
name|createParent
parameter_list|,
name|boolean
name|logRetryCache
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|FileSystem
operator|.
name|areSymlinksEnabled
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"Symlinks not supported"
argument_list|)
throw|;
block|}
name|waitForLoadingFSImage
argument_list|()
expr_stmt|;
name|HdfsFileStatus
name|auditStat
init|=
literal|null
decl_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|checkNameNodeSafeMode
argument_list|(
literal|"Cannot create symlink "
operator|+
name|link
argument_list|)
expr_stmt|;
name|auditStat
operator|=
name|FSDirSymlinkOp
operator|.
name|createSymlinkInt
argument_list|(
name|this
argument_list|,
name|target
argument_list|,
name|link
argument_list|,
name|dirPerms
argument_list|,
name|createParent
argument_list|,
name|logRetryCache
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|AccessControlException
name|e
parameter_list|)
block|{
name|logAuditEvent
argument_list|(
literal|false
argument_list|,
literal|"createSymlink"
argument_list|,
name|link
argument_list|,
name|target
argument_list|,
literal|null
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
name|getEditLog
argument_list|()
operator|.
name|logSync
argument_list|()
expr_stmt|;
name|logAuditEvent
argument_list|(
literal|true
argument_list|,
literal|"createSymlink"
argument_list|,
name|link
argument_list|,
name|target
argument_list|,
name|auditStat
argument_list|)
expr_stmt|;
block|}
comment|/**    * Set replication for an existing file.    *     * The NameNode sets new replication and schedules either replication of     * under-replicated data blocks or removal of the excessive block copies     * if the blocks are over-replicated.    *     * @see ClientProtocol#setReplication(String, short)    * @param src file name    * @param replication new replication    * @return true if successful;     *         false if file does not exist or is a directory    */
DECL|method|setReplication (final String src, final short replication)
name|boolean
name|setReplication
parameter_list|(
specifier|final
name|String
name|src
parameter_list|,
specifier|final
name|short
name|replication
parameter_list|)
throws|throws
name|IOException
block|{
name|boolean
name|success
init|=
literal|false
decl_stmt|;
name|waitForLoadingFSImage
argument_list|()
expr_stmt|;
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|checkNameNodeSafeMode
argument_list|(
literal|"Cannot set replication for "
operator|+
name|src
argument_list|)
expr_stmt|;
name|success
operator|=
name|FSDirAttrOp
operator|.
name|setReplication
argument_list|(
name|dir
argument_list|,
name|blockManager
argument_list|,
name|src
argument_list|,
name|replication
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|AccessControlException
name|e
parameter_list|)
block|{
name|logAuditEvent
argument_list|(
literal|false
argument_list|,
literal|"setReplication"
argument_list|,
name|src
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|success
condition|)
block|{
name|getEditLog
argument_list|()
operator|.
name|logSync
argument_list|()
expr_stmt|;
name|logAuditEvent
argument_list|(
literal|true
argument_list|,
literal|"setReplication"
argument_list|,
name|src
argument_list|)
expr_stmt|;
block|}
return|return
name|success
return|;
block|}
comment|/**    * Set the storage policy for a file or a directory.    *    * @param src file/directory path    * @param policyName storage policy name    */
DECL|method|setStoragePolicy (String src, String policyName)
name|void
name|setStoragePolicy
parameter_list|(
name|String
name|src
parameter_list|,
name|String
name|policyName
parameter_list|)
throws|throws
name|IOException
block|{
name|HdfsFileStatus
name|auditStat
decl_stmt|;
name|waitForLoadingFSImage
argument_list|()
expr_stmt|;
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|checkNameNodeSafeMode
argument_list|(
literal|"Cannot set storage policy for "
operator|+
name|src
argument_list|)
expr_stmt|;
name|auditStat
operator|=
name|FSDirAttrOp
operator|.
name|setStoragePolicy
argument_list|(
name|dir
argument_list|,
name|blockManager
argument_list|,
name|src
argument_list|,
name|policyName
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|AccessControlException
name|e
parameter_list|)
block|{
name|logAuditEvent
argument_list|(
literal|false
argument_list|,
literal|"setStoragePolicy"
argument_list|,
name|src
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
name|getEditLog
argument_list|()
operator|.
name|logSync
argument_list|()
expr_stmt|;
name|logAuditEvent
argument_list|(
literal|true
argument_list|,
literal|"setStoragePolicy"
argument_list|,
name|src
argument_list|,
literal|null
argument_list|,
name|auditStat
argument_list|)
expr_stmt|;
block|}
comment|/**    * Get the storage policy for a file or a directory.    *    * @param src    *          file/directory path    * @return storage policy object    */
DECL|method|getStoragePolicy (String src)
name|BlockStoragePolicy
name|getStoragePolicy
parameter_list|(
name|String
name|src
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|READ
argument_list|)
expr_stmt|;
name|waitForLoadingFSImage
argument_list|()
expr_stmt|;
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|READ
argument_list|)
expr_stmt|;
return|return
name|FSDirAttrOp
operator|.
name|getStoragePolicy
argument_list|(
name|dir
argument_list|,
name|blockManager
argument_list|,
name|src
argument_list|)
return|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * @return All the existing block storage policies    */
DECL|method|getStoragePolicies ()
name|BlockStoragePolicy
index|[]
name|getStoragePolicies
parameter_list|()
throws|throws
name|IOException
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|READ
argument_list|)
expr_stmt|;
name|waitForLoadingFSImage
argument_list|()
expr_stmt|;
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|READ
argument_list|)
expr_stmt|;
return|return
name|FSDirAttrOp
operator|.
name|getStoragePolicies
argument_list|(
name|blockManager
argument_list|)
return|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|getPreferredBlockSize (String src)
name|long
name|getPreferredBlockSize
parameter_list|(
name|String
name|src
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|READ
argument_list|)
expr_stmt|;
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|READ
argument_list|)
expr_stmt|;
return|return
name|FSDirAttrOp
operator|.
name|getPreferredBlockSize
argument_list|(
name|dir
argument_list|,
name|src
argument_list|)
return|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * If the file is within an encryption zone, select the appropriate     * CryptoProtocolVersion from the list provided by the client. Since the    * client may be newer, we need to handle unknown versions.    *    * @param zone EncryptionZone of the file    * @param supportedVersions List of supported protocol versions    * @return chosen protocol version    * @throws IOException    */
DECL|method|chooseProtocolVersion ( EncryptionZone zone, CryptoProtocolVersion[] supportedVersions)
name|CryptoProtocolVersion
name|chooseProtocolVersion
parameter_list|(
name|EncryptionZone
name|zone
parameter_list|,
name|CryptoProtocolVersion
index|[]
name|supportedVersions
parameter_list|)
throws|throws
name|UnknownCryptoProtocolVersionException
throws|,
name|UnresolvedLinkException
throws|,
name|SnapshotAccessControlException
block|{
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|supportedVersions
argument_list|)
expr_stmt|;
comment|// Right now, we only support a single protocol version,
comment|// so simply look for it in the list of provided options
specifier|final
name|CryptoProtocolVersion
name|required
init|=
name|zone
operator|.
name|getVersion
argument_list|()
decl_stmt|;
for|for
control|(
name|CryptoProtocolVersion
name|c
range|:
name|supportedVersions
control|)
block|{
if|if
condition|(
name|c
operator|.
name|equals
argument_list|(
name|CryptoProtocolVersion
operator|.
name|UNKNOWN
argument_list|)
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Ignoring unknown CryptoProtocolVersion provided by "
operator|+
literal|"client: "
operator|+
name|c
operator|.
name|getUnknownValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
if|if
condition|(
name|c
operator|.
name|equals
argument_list|(
name|required
argument_list|)
condition|)
block|{
return|return
name|c
return|;
block|}
block|}
throw|throw
operator|new
name|UnknownCryptoProtocolVersionException
argument_list|(
literal|"No crypto protocol versions provided by the client are supported."
operator|+
literal|" Client provided: "
operator|+
name|Arrays
operator|.
name|toString
argument_list|(
name|supportedVersions
argument_list|)
operator|+
literal|" NameNode supports: "
operator|+
name|Arrays
operator|.
name|toString
argument_list|(
name|CryptoProtocolVersion
operator|.
name|values
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
comment|/**    * Invoke KeyProvider APIs to generate an encrypted data encryption key for an    * encryption zone. Should not be called with any locks held.    *    * @param ezKeyName key name of an encryption zone    * @return New EDEK, or null if ezKeyName is null    * @throws IOException    */
DECL|method|generateEncryptedDataEncryptionKey (String ezKeyName)
specifier|private
name|EncryptedKeyVersion
name|generateEncryptedDataEncryptionKey
parameter_list|(
name|String
name|ezKeyName
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|ezKeyName
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|EncryptedKeyVersion
name|edek
init|=
literal|null
decl_stmt|;
try|try
block|{
name|edek
operator|=
name|provider
operator|.
name|generateEncryptedKey
argument_list|(
name|ezKeyName
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|GeneralSecurityException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|e
argument_list|)
throw|;
block|}
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|edek
argument_list|)
expr_stmt|;
return|return
name|edek
return|;
block|}
comment|/**    * Create a new file entry in the namespace.    *     * For description of parameters and exceptions thrown see    * {@link ClientProtocol#create}, except it returns valid file status upon    * success    */
DECL|method|startFile (String src, PermissionStatus permissions, String holder, String clientMachine, EnumSet<CreateFlag> flag, boolean createParent, short replication, long blockSize, CryptoProtocolVersion[] supportedVersions, boolean logRetryCache)
name|HdfsFileStatus
name|startFile
parameter_list|(
name|String
name|src
parameter_list|,
name|PermissionStatus
name|permissions
parameter_list|,
name|String
name|holder
parameter_list|,
name|String
name|clientMachine
parameter_list|,
name|EnumSet
argument_list|<
name|CreateFlag
argument_list|>
name|flag
parameter_list|,
name|boolean
name|createParent
parameter_list|,
name|short
name|replication
parameter_list|,
name|long
name|blockSize
parameter_list|,
name|CryptoProtocolVersion
index|[]
name|supportedVersions
parameter_list|,
name|boolean
name|logRetryCache
parameter_list|)
throws|throws
name|IOException
block|{
name|HdfsFileStatus
name|status
decl_stmt|;
try|try
block|{
name|status
operator|=
name|startFileInt
argument_list|(
name|src
argument_list|,
name|permissions
argument_list|,
name|holder
argument_list|,
name|clientMachine
argument_list|,
name|flag
argument_list|,
name|createParent
argument_list|,
name|replication
argument_list|,
name|blockSize
argument_list|,
name|supportedVersions
argument_list|,
name|logRetryCache
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|AccessControlException
name|e
parameter_list|)
block|{
name|logAuditEvent
argument_list|(
literal|false
argument_list|,
literal|"create"
argument_list|,
name|src
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
name|logAuditEvent
argument_list|(
literal|true
argument_list|,
literal|"create"
argument_list|,
name|src
argument_list|,
literal|null
argument_list|,
name|status
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
DECL|method|startFileInt (final String src, PermissionStatus permissions, String holder, String clientMachine, EnumSet<CreateFlag> flag, boolean createParent, short replication, long blockSize, CryptoProtocolVersion[] supportedVersions, boolean logRetryCache)
specifier|private
name|HdfsFileStatus
name|startFileInt
parameter_list|(
specifier|final
name|String
name|src
parameter_list|,
name|PermissionStatus
name|permissions
parameter_list|,
name|String
name|holder
parameter_list|,
name|String
name|clientMachine
parameter_list|,
name|EnumSet
argument_list|<
name|CreateFlag
argument_list|>
name|flag
parameter_list|,
name|boolean
name|createParent
parameter_list|,
name|short
name|replication
parameter_list|,
name|long
name|blockSize
parameter_list|,
name|CryptoProtocolVersion
index|[]
name|supportedVersions
parameter_list|,
name|boolean
name|logRetryCache
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|StringBuilder
name|builder
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|builder
operator|.
name|append
argument_list|(
literal|"DIR* NameSystem.startFile: src="
argument_list|)
operator|.
name|append
argument_list|(
name|src
argument_list|)
operator|.
name|append
argument_list|(
literal|", holder="
argument_list|)
operator|.
name|append
argument_list|(
name|holder
argument_list|)
operator|.
name|append
argument_list|(
literal|", clientMachine="
argument_list|)
operator|.
name|append
argument_list|(
name|clientMachine
argument_list|)
operator|.
name|append
argument_list|(
literal|", createParent="
argument_list|)
operator|.
name|append
argument_list|(
name|createParent
argument_list|)
operator|.
name|append
argument_list|(
literal|", replication="
argument_list|)
operator|.
name|append
argument_list|(
name|replication
argument_list|)
operator|.
name|append
argument_list|(
literal|", createFlag="
argument_list|)
operator|.
name|append
argument_list|(
name|flag
operator|.
name|toString
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|", blockSize="
argument_list|)
operator|.
name|append
argument_list|(
name|blockSize
argument_list|)
operator|.
name|append
argument_list|(
literal|", supportedVersions="
argument_list|)
operator|.
name|append
argument_list|(
name|supportedVersions
operator|==
literal|null
condition|?
literal|null
else|:
name|Arrays
operator|.
name|toString
argument_list|(
name|supportedVersions
argument_list|)
argument_list|)
expr_stmt|;
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|debug
argument_list|(
name|builder
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|DFSUtil
operator|.
name|isValidName
argument_list|(
name|src
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|InvalidPathException
argument_list|(
name|src
argument_list|)
throw|;
block|}
name|blockManager
operator|.
name|verifyReplication
argument_list|(
name|src
argument_list|,
name|replication
argument_list|,
name|clientMachine
argument_list|)
expr_stmt|;
if|if
condition|(
name|blockSize
operator|<
name|minBlockSize
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Specified block size is less than configured"
operator|+
literal|" minimum value ("
operator|+
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_MIN_BLOCK_SIZE_KEY
operator|+
literal|"): "
operator|+
name|blockSize
operator|+
literal|"< "
operator|+
name|minBlockSize
argument_list|)
throw|;
block|}
name|FSPermissionChecker
name|pc
init|=
name|getPermissionChecker
argument_list|()
decl_stmt|;
name|waitForLoadingFSImage
argument_list|()
expr_stmt|;
comment|/**      * If the file is in an encryption zone, we optimistically create an      * EDEK for the file by calling out to the configured KeyProvider.      * Since this typically involves doing an RPC, we take the readLock      * initially, then drop it to do the RPC.      *       * Since the path can flip-flop between being in an encryption zone and not      * in the meantime, we need to recheck the preconditions when we retake the      * lock to do the create. If the preconditions are not met, we throw a      * special RetryStartFileException to ask the DFSClient to try the create      * again later.      */
name|FSDirWriteFileOp
operator|.
name|EncryptionKeyInfo
name|ezInfo
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|provider
operator|!=
literal|null
condition|)
block|{
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|READ
argument_list|)
expr_stmt|;
name|ezInfo
operator|=
name|FSDirWriteFileOp
operator|.
name|getEncryptionKeyInfo
argument_list|(
name|this
argument_list|,
name|pc
argument_list|,
name|src
argument_list|,
name|supportedVersions
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
comment|// Generate EDEK if necessary while not holding the lock
if|if
condition|(
name|ezInfo
operator|!=
literal|null
condition|)
block|{
name|ezInfo
operator|.
name|edek
operator|=
name|generateEncryptedDataEncryptionKey
argument_list|(
name|ezInfo
operator|.
name|ezKeyName
argument_list|)
expr_stmt|;
block|}
name|EncryptionFaultInjector
operator|.
name|getInstance
argument_list|()
operator|.
name|startFileAfterGenerateKey
argument_list|()
expr_stmt|;
block|}
name|boolean
name|skipSync
init|=
literal|false
decl_stmt|;
name|HdfsFileStatus
name|stat
init|=
literal|null
decl_stmt|;
comment|// Proceed with the create, using the computed cipher suite and
comment|// generated EDEK
name|BlocksMapUpdateInfo
name|toRemoveBlocks
init|=
operator|new
name|BlocksMapUpdateInfo
argument_list|()
decl_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|checkNameNodeSafeMode
argument_list|(
literal|"Cannot create file"
operator|+
name|src
argument_list|)
expr_stmt|;
name|dir
operator|.
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|stat
operator|=
name|FSDirWriteFileOp
operator|.
name|startFile
argument_list|(
name|this
argument_list|,
name|pc
argument_list|,
name|src
argument_list|,
name|permissions
argument_list|,
name|holder
argument_list|,
name|clientMachine
argument_list|,
name|flag
argument_list|,
name|createParent
argument_list|,
name|replication
argument_list|,
name|blockSize
argument_list|,
name|ezInfo
argument_list|,
name|toRemoveBlocks
argument_list|,
name|logRetryCache
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|dir
operator|.
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|skipSync
operator|=
name|e
operator|instanceof
name|StandbyException
expr_stmt|;
throw|throw
name|e
throw|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
comment|// There might be transactions logged while trying to recover the lease.
comment|// They need to be sync'ed even when an exception was thrown.
if|if
condition|(
operator|!
name|skipSync
condition|)
block|{
name|getEditLog
argument_list|()
operator|.
name|logSync
argument_list|()
expr_stmt|;
name|removeBlocks
argument_list|(
name|toRemoveBlocks
argument_list|)
expr_stmt|;
name|toRemoveBlocks
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|stat
return|;
block|}
comment|/**    * Recover lease;    * Immediately revoke the lease of the current lease holder and start lease    * recovery so that the file can be forced to be closed.    *     * @param src the path of the file to start lease recovery    * @param holder the lease holder's name    * @param clientMachine the client machine's name    * @return true if the file is already closed or    *         if the lease can be released and the file can be closed.    * @throws IOException    */
DECL|method|recoverLease (String src, String holder, String clientMachine)
name|boolean
name|recoverLease
parameter_list|(
name|String
name|src
parameter_list|,
name|String
name|holder
parameter_list|,
name|String
name|clientMachine
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|DFSUtil
operator|.
name|isValidName
argument_list|(
name|src
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Invalid file name: "
operator|+
name|src
argument_list|)
throw|;
block|}
name|boolean
name|skipSync
init|=
literal|false
decl_stmt|;
name|FSPermissionChecker
name|pc
init|=
name|getPermissionChecker
argument_list|()
decl_stmt|;
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|byte
index|[]
index|[]
name|pathComponents
init|=
name|FSDirectory
operator|.
name|getPathComponentsForReservedPath
argument_list|(
name|src
argument_list|)
decl_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|checkNameNodeSafeMode
argument_list|(
literal|"Cannot recover the lease of "
operator|+
name|src
argument_list|)
expr_stmt|;
name|src
operator|=
name|dir
operator|.
name|resolvePath
argument_list|(
name|pc
argument_list|,
name|src
argument_list|,
name|pathComponents
argument_list|)
expr_stmt|;
specifier|final
name|INodesInPath
name|iip
init|=
name|dir
operator|.
name|getINodesInPath4Write
argument_list|(
name|src
argument_list|)
decl_stmt|;
specifier|final
name|INodeFile
name|inode
init|=
name|INodeFile
operator|.
name|valueOf
argument_list|(
name|iip
operator|.
name|getLastINode
argument_list|()
argument_list|,
name|src
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|inode
operator|.
name|isUnderConstruction
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
name|isPermissionEnabled
condition|)
block|{
name|dir
operator|.
name|checkPathAccess
argument_list|(
name|pc
argument_list|,
name|iip
argument_list|,
name|FsAction
operator|.
name|WRITE
argument_list|)
expr_stmt|;
block|}
return|return
name|recoverLeaseInternal
argument_list|(
name|RecoverLeaseOp
operator|.
name|RECOVER_LEASE
argument_list|,
name|iip
argument_list|,
name|src
argument_list|,
name|holder
argument_list|,
name|clientMachine
argument_list|,
literal|true
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|StandbyException
name|se
parameter_list|)
block|{
name|skipSync
operator|=
literal|true
expr_stmt|;
throw|throw
name|se
throw|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
comment|// There might be transactions logged while trying to recover the lease.
comment|// They need to be sync'ed even when an exception was thrown.
if|if
condition|(
operator|!
name|skipSync
condition|)
block|{
name|getEditLog
argument_list|()
operator|.
name|logSync
argument_list|()
expr_stmt|;
block|}
block|}
block|}
DECL|enum|RecoverLeaseOp
enum|enum
name|RecoverLeaseOp
block|{
DECL|enumConstant|CREATE_FILE
name|CREATE_FILE
block|,
DECL|enumConstant|APPEND_FILE
name|APPEND_FILE
block|,
DECL|enumConstant|TRUNCATE_FILE
name|TRUNCATE_FILE
block|,
DECL|enumConstant|RECOVER_LEASE
name|RECOVER_LEASE
block|;
DECL|method|getExceptionMessage (String src, String holder, String clientMachine, String reason)
specifier|private
name|String
name|getExceptionMessage
parameter_list|(
name|String
name|src
parameter_list|,
name|String
name|holder
parameter_list|,
name|String
name|clientMachine
parameter_list|,
name|String
name|reason
parameter_list|)
block|{
return|return
literal|"Failed to "
operator|+
name|this
operator|+
literal|" "
operator|+
name|src
operator|+
literal|" for "
operator|+
name|holder
operator|+
literal|" on "
operator|+
name|clientMachine
operator|+
literal|" because "
operator|+
name|reason
return|;
block|}
block|}
DECL|method|recoverLeaseInternal (RecoverLeaseOp op, INodesInPath iip, String src, String holder, String clientMachine, boolean force)
name|boolean
name|recoverLeaseInternal
parameter_list|(
name|RecoverLeaseOp
name|op
parameter_list|,
name|INodesInPath
name|iip
parameter_list|,
name|String
name|src
parameter_list|,
name|String
name|holder
parameter_list|,
name|String
name|clientMachine
parameter_list|,
name|boolean
name|force
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|hasWriteLock
argument_list|()
assert|;
name|INodeFile
name|file
init|=
name|iip
operator|.
name|getLastINode
argument_list|()
operator|.
name|asFile
argument_list|()
decl_stmt|;
if|if
condition|(
name|file
operator|.
name|isUnderConstruction
argument_list|()
condition|)
block|{
comment|//
comment|// If the file is under construction , then it must be in our
comment|// leases. Find the appropriate lease record.
comment|//
name|Lease
name|lease
init|=
name|leaseManager
operator|.
name|getLease
argument_list|(
name|holder
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|force
operator|&&
name|lease
operator|!=
literal|null
condition|)
block|{
name|Lease
name|leaseFile
init|=
name|leaseManager
operator|.
name|getLease
argument_list|(
name|file
argument_list|)
decl_stmt|;
if|if
condition|(
name|leaseFile
operator|!=
literal|null
operator|&&
name|leaseFile
operator|.
name|equals
argument_list|(
name|lease
argument_list|)
condition|)
block|{
comment|// We found the lease for this file but the original
comment|// holder is trying to obtain it again.
throw|throw
operator|new
name|AlreadyBeingCreatedException
argument_list|(
name|op
operator|.
name|getExceptionMessage
argument_list|(
name|src
argument_list|,
name|holder
argument_list|,
name|clientMachine
argument_list|,
name|holder
operator|+
literal|" is already the current lease holder."
argument_list|)
argument_list|)
throw|;
block|}
block|}
comment|//
comment|// Find the original holder.
comment|//
name|FileUnderConstructionFeature
name|uc
init|=
name|file
operator|.
name|getFileUnderConstructionFeature
argument_list|()
decl_stmt|;
name|String
name|clientName
init|=
name|uc
operator|.
name|getClientName
argument_list|()
decl_stmt|;
name|lease
operator|=
name|leaseManager
operator|.
name|getLease
argument_list|(
name|clientName
argument_list|)
expr_stmt|;
if|if
condition|(
name|lease
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|AlreadyBeingCreatedException
argument_list|(
name|op
operator|.
name|getExceptionMessage
argument_list|(
name|src
argument_list|,
name|holder
argument_list|,
name|clientMachine
argument_list|,
literal|"the file is under construction but no leases found."
argument_list|)
argument_list|)
throw|;
block|}
if|if
condition|(
name|force
condition|)
block|{
comment|// close now: no need to wait for soft lease expiration and
comment|// close only the file src
name|LOG
operator|.
name|info
argument_list|(
literal|"recoverLease: "
operator|+
name|lease
operator|+
literal|", src="
operator|+
name|src
operator|+
literal|" from client "
operator|+
name|clientName
argument_list|)
expr_stmt|;
return|return
name|internalReleaseLease
argument_list|(
name|lease
argument_list|,
name|src
argument_list|,
name|iip
argument_list|,
name|holder
argument_list|)
return|;
block|}
else|else
block|{
assert|assert
name|lease
operator|.
name|getHolder
argument_list|()
operator|.
name|equals
argument_list|(
name|clientName
argument_list|)
operator|:
literal|"Current lease holder "
operator|+
name|lease
operator|.
name|getHolder
argument_list|()
operator|+
literal|" does not match file creator "
operator|+
name|clientName
assert|;
comment|//
comment|// If the original holder has not renewed in the last SOFTLIMIT
comment|// period, then start lease recovery.
comment|//
if|if
condition|(
name|lease
operator|.
name|expiredSoftLimit
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"startFile: recover "
operator|+
name|lease
operator|+
literal|", src="
operator|+
name|src
operator|+
literal|" client "
operator|+
name|clientName
argument_list|)
expr_stmt|;
if|if
condition|(
name|internalReleaseLease
argument_list|(
name|lease
argument_list|,
name|src
argument_list|,
name|iip
argument_list|,
literal|null
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|RecoveryInProgressException
argument_list|(
name|op
operator|.
name|getExceptionMessage
argument_list|(
name|src
argument_list|,
name|holder
argument_list|,
name|clientMachine
argument_list|,
literal|"lease recovery is in progress. Try again later."
argument_list|)
argument_list|)
throw|;
block|}
block|}
else|else
block|{
specifier|final
name|BlockInfo
name|lastBlock
init|=
name|file
operator|.
name|getLastBlock
argument_list|()
decl_stmt|;
if|if
condition|(
name|lastBlock
operator|!=
literal|null
operator|&&
name|lastBlock
operator|.
name|getBlockUCState
argument_list|()
operator|==
name|BlockUCState
operator|.
name|UNDER_RECOVERY
condition|)
block|{
throw|throw
operator|new
name|RecoveryInProgressException
argument_list|(
name|op
operator|.
name|getExceptionMessage
argument_list|(
name|src
argument_list|,
name|holder
argument_list|,
name|clientMachine
argument_list|,
literal|"another recovery is in progress by "
operator|+
name|clientName
operator|+
literal|" on "
operator|+
name|uc
operator|.
name|getClientMachine
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
else|else
block|{
throw|throw
operator|new
name|AlreadyBeingCreatedException
argument_list|(
name|op
operator|.
name|getExceptionMessage
argument_list|(
name|src
argument_list|,
name|holder
argument_list|,
name|clientMachine
argument_list|,
literal|"this file lease is currently owned by "
operator|+
name|clientName
operator|+
literal|" on "
operator|+
name|uc
operator|.
name|getClientMachine
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
block|}
block|}
block|}
else|else
block|{
return|return
literal|true
return|;
block|}
block|}
comment|/**    * Append to an existing file in the namespace.    */
DECL|method|appendFile (String srcArg, String holder, String clientMachine, EnumSet<CreateFlag> flag, boolean logRetryCache)
name|LastBlockWithStatus
name|appendFile
parameter_list|(
name|String
name|srcArg
parameter_list|,
name|String
name|holder
parameter_list|,
name|String
name|clientMachine
parameter_list|,
name|EnumSet
argument_list|<
name|CreateFlag
argument_list|>
name|flag
parameter_list|,
name|boolean
name|logRetryCache
parameter_list|)
throws|throws
name|IOException
block|{
name|boolean
name|newBlock
init|=
name|flag
operator|.
name|contains
argument_list|(
name|CreateFlag
operator|.
name|NEW_BLOCK
argument_list|)
decl_stmt|;
if|if
condition|(
name|newBlock
condition|)
block|{
name|requireEffectiveLayoutVersionForFeature
argument_list|(
name|Feature
operator|.
name|APPEND_NEW_BLOCK
argument_list|)
expr_stmt|;
block|}
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|debug
argument_list|(
literal|"DIR* NameSystem.appendFile: src={}, holder={}, clientMachine={}"
argument_list|,
name|srcArg
argument_list|,
name|holder
argument_list|,
name|clientMachine
argument_list|)
expr_stmt|;
try|try
block|{
name|boolean
name|skipSync
init|=
literal|false
decl_stmt|;
name|LastBlockWithStatus
name|lbs
init|=
literal|null
decl_stmt|;
specifier|final
name|FSPermissionChecker
name|pc
init|=
name|getPermissionChecker
argument_list|()
decl_stmt|;
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|checkNameNodeSafeMode
argument_list|(
literal|"Cannot append to file"
operator|+
name|srcArg
argument_list|)
expr_stmt|;
name|lbs
operator|=
name|FSDirAppendOp
operator|.
name|appendFile
argument_list|(
name|this
argument_list|,
name|srcArg
argument_list|,
name|pc
argument_list|,
name|holder
argument_list|,
name|clientMachine
argument_list|,
name|newBlock
argument_list|,
name|logRetryCache
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|StandbyException
name|se
parameter_list|)
block|{
name|skipSync
operator|=
literal|true
expr_stmt|;
throw|throw
name|se
throw|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
comment|// There might be transactions logged while trying to recover the lease
comment|// They need to be sync'ed even when an exception was thrown.
if|if
condition|(
operator|!
name|skipSync
condition|)
block|{
name|getEditLog
argument_list|()
operator|.
name|logSync
argument_list|()
expr_stmt|;
block|}
block|}
name|logAuditEvent
argument_list|(
literal|true
argument_list|,
literal|"append"
argument_list|,
name|srcArg
argument_list|)
expr_stmt|;
return|return
name|lbs
return|;
block|}
catch|catch
parameter_list|(
name|AccessControlException
name|e
parameter_list|)
block|{
name|logAuditEvent
argument_list|(
literal|false
argument_list|,
literal|"append"
argument_list|,
name|srcArg
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
DECL|method|getExtendedBlock (Block blk)
name|ExtendedBlock
name|getExtendedBlock
parameter_list|(
name|Block
name|blk
parameter_list|)
block|{
return|return
operator|new
name|ExtendedBlock
argument_list|(
name|blockPoolId
argument_list|,
name|blk
argument_list|)
return|;
block|}
DECL|method|setBlockPoolId (String bpid)
name|void
name|setBlockPoolId
parameter_list|(
name|String
name|bpid
parameter_list|)
block|{
name|blockPoolId
operator|=
name|bpid
expr_stmt|;
name|blockManager
operator|.
name|setBlockPoolId
argument_list|(
name|blockPoolId
argument_list|)
expr_stmt|;
block|}
comment|/**    * The client would like to obtain an additional block for the indicated    * filename (which is being written-to).  Return an array that consists    * of the block, plus a set of machines.  The first on this list should    * be where the client writes data.  Subsequent items in the list must    * be provided in the connection to the first datanode.    *    * Make sure the previous blocks have been reported by datanodes and    * are replicated.  Will return an empty 2-elt array if we want the    * client to "try again later".    */
DECL|method|getAdditionalBlock ( String src, long fileId, String clientName, ExtendedBlock previous, DatanodeInfo[] excludedNodes, String[] favoredNodes)
name|LocatedBlock
name|getAdditionalBlock
parameter_list|(
name|String
name|src
parameter_list|,
name|long
name|fileId
parameter_list|,
name|String
name|clientName
parameter_list|,
name|ExtendedBlock
name|previous
parameter_list|,
name|DatanodeInfo
index|[]
name|excludedNodes
parameter_list|,
name|String
index|[]
name|favoredNodes
parameter_list|)
throws|throws
name|IOException
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|debug
argument_list|(
literal|"BLOCK* getAdditionalBlock: {}  inodeId {}"
operator|+
literal|" for {}"
argument_list|,
name|src
argument_list|,
name|fileId
argument_list|,
name|clientName
argument_list|)
expr_stmt|;
name|waitForLoadingFSImage
argument_list|()
expr_stmt|;
name|LocatedBlock
index|[]
name|onRetryBlock
init|=
operator|new
name|LocatedBlock
index|[
literal|1
index|]
decl_stmt|;
name|FSDirWriteFileOp
operator|.
name|ValidateAddBlockResult
name|r
decl_stmt|;
name|FSPermissionChecker
name|pc
init|=
name|getPermissionChecker
argument_list|()
decl_stmt|;
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|READ
argument_list|)
expr_stmt|;
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|READ
argument_list|)
expr_stmt|;
name|r
operator|=
name|FSDirWriteFileOp
operator|.
name|validateAddBlock
argument_list|(
name|this
argument_list|,
name|pc
argument_list|,
name|src
argument_list|,
name|fileId
argument_list|,
name|clientName
argument_list|,
name|previous
argument_list|,
name|onRetryBlock
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|r
operator|==
literal|null
condition|)
block|{
assert|assert
name|onRetryBlock
index|[
literal|0
index|]
operator|!=
literal|null
operator|:
literal|"Retry block is null"
assert|;
comment|// This is a retry. Just return the last block.
return|return
name|onRetryBlock
index|[
literal|0
index|]
return|;
block|}
name|DatanodeStorageInfo
index|[]
name|targets
init|=
name|FSDirWriteFileOp
operator|.
name|chooseTargetForNewBlock
argument_list|(
name|blockManager
argument_list|,
name|src
argument_list|,
name|excludedNodes
argument_list|,
name|favoredNodes
argument_list|,
name|r
argument_list|)
decl_stmt|;
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
name|LocatedBlock
name|lb
decl_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|lb
operator|=
name|FSDirWriteFileOp
operator|.
name|storeAllocatedBlock
argument_list|(
name|this
argument_list|,
name|src
argument_list|,
name|fileId
argument_list|,
name|clientName
argument_list|,
name|previous
argument_list|,
name|targets
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
name|getEditLog
argument_list|()
operator|.
name|logSync
argument_list|()
expr_stmt|;
return|return
name|lb
return|;
block|}
comment|/** @see ClientProtocol#getAdditionalDatanode */
DECL|method|getAdditionalDatanode (String src, long fileId, final ExtendedBlock blk, final DatanodeInfo[] existings, final String[] storageIDs, final Set<Node> excludes, final int numAdditionalNodes, final String clientName )
name|LocatedBlock
name|getAdditionalDatanode
parameter_list|(
name|String
name|src
parameter_list|,
name|long
name|fileId
parameter_list|,
specifier|final
name|ExtendedBlock
name|blk
parameter_list|,
specifier|final
name|DatanodeInfo
index|[]
name|existings
parameter_list|,
specifier|final
name|String
index|[]
name|storageIDs
parameter_list|,
specifier|final
name|Set
argument_list|<
name|Node
argument_list|>
name|excludes
parameter_list|,
specifier|final
name|int
name|numAdditionalNodes
parameter_list|,
specifier|final
name|String
name|clientName
parameter_list|)
throws|throws
name|IOException
block|{
comment|//check if the feature is enabled
name|dtpReplaceDatanodeOnFailure
operator|.
name|checkEnabled
argument_list|()
expr_stmt|;
name|Node
name|clientnode
init|=
literal|null
decl_stmt|;
name|String
name|clientMachine
decl_stmt|;
specifier|final
name|long
name|preferredblocksize
decl_stmt|;
specifier|final
name|byte
name|storagePolicyID
decl_stmt|;
specifier|final
name|List
argument_list|<
name|DatanodeStorageInfo
argument_list|>
name|chosen
decl_stmt|;
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|READ
argument_list|)
expr_stmt|;
name|byte
index|[]
index|[]
name|pathComponents
init|=
name|FSDirectory
operator|.
name|getPathComponentsForReservedPath
argument_list|(
name|src
argument_list|)
decl_stmt|;
name|FSPermissionChecker
name|pc
init|=
name|getPermissionChecker
argument_list|()
decl_stmt|;
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|READ
argument_list|)
expr_stmt|;
comment|//check safe mode
name|checkNameNodeSafeMode
argument_list|(
literal|"Cannot add datanode; src="
operator|+
name|src
operator|+
literal|", blk="
operator|+
name|blk
argument_list|)
expr_stmt|;
name|src
operator|=
name|dir
operator|.
name|resolvePath
argument_list|(
name|pc
argument_list|,
name|src
argument_list|,
name|pathComponents
argument_list|)
expr_stmt|;
comment|//check lease
specifier|final
name|INode
name|inode
decl_stmt|;
if|if
condition|(
name|fileId
operator|==
name|HdfsConstants
operator|.
name|GRANDFATHER_INODE_ID
condition|)
block|{
comment|// Older clients may not have given us an inode ID to work with.
comment|// In this case, we have to try to resolve the path and hope it
comment|// hasn't changed or been deleted since the file was opened for write.
name|inode
operator|=
name|dir
operator|.
name|getINode
argument_list|(
name|src
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|inode
operator|=
name|dir
operator|.
name|getInode
argument_list|(
name|fileId
argument_list|)
expr_stmt|;
if|if
condition|(
name|inode
operator|!=
literal|null
condition|)
name|src
operator|=
name|inode
operator|.
name|getFullPathName
argument_list|()
expr_stmt|;
block|}
specifier|final
name|INodeFile
name|file
init|=
name|checkLease
argument_list|(
name|src
argument_list|,
name|clientName
argument_list|,
name|inode
argument_list|,
name|fileId
argument_list|)
decl_stmt|;
name|clientMachine
operator|=
name|file
operator|.
name|getFileUnderConstructionFeature
argument_list|()
operator|.
name|getClientMachine
argument_list|()
expr_stmt|;
name|clientnode
operator|=
name|blockManager
operator|.
name|getDatanodeManager
argument_list|()
operator|.
name|getDatanodeByHost
argument_list|(
name|clientMachine
argument_list|)
expr_stmt|;
name|preferredblocksize
operator|=
name|file
operator|.
name|getPreferredBlockSize
argument_list|()
expr_stmt|;
name|storagePolicyID
operator|=
name|file
operator|.
name|getStoragePolicyID
argument_list|()
expr_stmt|;
comment|//find datanode storages
specifier|final
name|DatanodeManager
name|dm
init|=
name|blockManager
operator|.
name|getDatanodeManager
argument_list|()
decl_stmt|;
name|chosen
operator|=
name|Arrays
operator|.
name|asList
argument_list|(
name|dm
operator|.
name|getDatanodeStorageInfos
argument_list|(
name|existings
argument_list|,
name|storageIDs
argument_list|)
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|clientnode
operator|==
literal|null
condition|)
block|{
name|clientnode
operator|=
name|FSDirWriteFileOp
operator|.
name|getClientNode
argument_list|(
name|blockManager
argument_list|,
name|clientMachine
argument_list|)
expr_stmt|;
block|}
comment|// choose new datanodes.
specifier|final
name|DatanodeStorageInfo
index|[]
name|targets
init|=
name|blockManager
operator|.
name|chooseTarget4AdditionalDatanode
argument_list|(
name|src
argument_list|,
name|numAdditionalNodes
argument_list|,
name|clientnode
argument_list|,
name|chosen
argument_list|,
name|excludes
argument_list|,
name|preferredblocksize
argument_list|,
name|storagePolicyID
argument_list|)
decl_stmt|;
specifier|final
name|LocatedBlock
name|lb
init|=
name|BlockManager
operator|.
name|newLocatedBlock
argument_list|(
name|blk
argument_list|,
name|targets
argument_list|,
operator|-
literal|1
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|blockManager
operator|.
name|setBlockToken
argument_list|(
name|lb
argument_list|,
name|BlockTokenIdentifier
operator|.
name|AccessMode
operator|.
name|COPY
argument_list|)
expr_stmt|;
return|return
name|lb
return|;
block|}
comment|/**    * The client would like to let go of the given block    */
DECL|method|abandonBlock (ExtendedBlock b, long fileId, String src, String holder)
name|void
name|abandonBlock
parameter_list|(
name|ExtendedBlock
name|b
parameter_list|,
name|long
name|fileId
parameter_list|,
name|String
name|src
parameter_list|,
name|String
name|holder
parameter_list|)
throws|throws
name|IOException
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|debug
argument_list|(
literal|"BLOCK* NameSystem.abandonBlock: {} of file {}"
argument_list|,
name|b
argument_list|,
name|src
argument_list|)
expr_stmt|;
name|waitForLoadingFSImage
argument_list|()
expr_stmt|;
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|FSPermissionChecker
name|pc
init|=
name|getPermissionChecker
argument_list|()
decl_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|checkNameNodeSafeMode
argument_list|(
literal|"Cannot abandon block "
operator|+
name|b
operator|+
literal|" for file"
operator|+
name|src
argument_list|)
expr_stmt|;
name|FSDirWriteFileOp
operator|.
name|abandonBlock
argument_list|(
name|dir
argument_list|,
name|pc
argument_list|,
name|b
argument_list|,
name|fileId
argument_list|,
name|src
argument_list|,
name|holder
argument_list|)
expr_stmt|;
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|debug
argument_list|(
literal|"BLOCK* NameSystem.abandonBlock: {} is "
operator|+
literal|"removed from pendingCreates"
argument_list|,
name|b
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
name|getEditLog
argument_list|()
operator|.
name|logSync
argument_list|()
expr_stmt|;
block|}
DECL|method|checkLease ( String src, String holder, INode inode, long fileId)
name|INodeFile
name|checkLease
parameter_list|(
name|String
name|src
parameter_list|,
name|String
name|holder
parameter_list|,
name|INode
name|inode
parameter_list|,
name|long
name|fileId
parameter_list|)
throws|throws
name|LeaseExpiredException
throws|,
name|FileNotFoundException
block|{
assert|assert
name|hasReadLock
argument_list|()
assert|;
specifier|final
name|String
name|ident
init|=
name|src
operator|+
literal|" (inode "
operator|+
name|fileId
operator|+
literal|")"
decl_stmt|;
if|if
condition|(
name|inode
operator|==
literal|null
condition|)
block|{
name|Lease
name|lease
init|=
name|leaseManager
operator|.
name|getLease
argument_list|(
name|holder
argument_list|)
decl_stmt|;
throw|throw
operator|new
name|FileNotFoundException
argument_list|(
literal|"No lease on "
operator|+
name|ident
operator|+
literal|": File does not exist. "
operator|+
operator|(
name|lease
operator|!=
literal|null
condition|?
name|lease
operator|.
name|toString
argument_list|()
else|:
literal|"Holder "
operator|+
name|holder
operator|+
literal|" does not have any open files."
operator|)
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|inode
operator|.
name|isFile
argument_list|()
condition|)
block|{
name|Lease
name|lease
init|=
name|leaseManager
operator|.
name|getLease
argument_list|(
name|holder
argument_list|)
decl_stmt|;
throw|throw
operator|new
name|LeaseExpiredException
argument_list|(
literal|"No lease on "
operator|+
name|ident
operator|+
literal|": INode is not a regular file. "
operator|+
operator|(
name|lease
operator|!=
literal|null
condition|?
name|lease
operator|.
name|toString
argument_list|()
else|:
literal|"Holder "
operator|+
name|holder
operator|+
literal|" does not have any open files."
operator|)
argument_list|)
throw|;
block|}
specifier|final
name|INodeFile
name|file
init|=
name|inode
operator|.
name|asFile
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|file
operator|.
name|isUnderConstruction
argument_list|()
condition|)
block|{
name|Lease
name|lease
init|=
name|leaseManager
operator|.
name|getLease
argument_list|(
name|holder
argument_list|)
decl_stmt|;
throw|throw
operator|new
name|LeaseExpiredException
argument_list|(
literal|"No lease on "
operator|+
name|ident
operator|+
literal|": File is not open for writing. "
operator|+
operator|(
name|lease
operator|!=
literal|null
condition|?
name|lease
operator|.
name|toString
argument_list|()
else|:
literal|"Holder "
operator|+
name|holder
operator|+
literal|" does not have any open files."
operator|)
argument_list|)
throw|;
block|}
comment|// No further modification is allowed on a deleted file.
comment|// A file is considered deleted, if it is not in the inodeMap or is marked
comment|// as deleted in the snapshot feature.
if|if
condition|(
name|isFileDeleted
argument_list|(
name|file
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|FileNotFoundException
argument_list|(
name|src
argument_list|)
throw|;
block|}
name|String
name|clientName
init|=
name|file
operator|.
name|getFileUnderConstructionFeature
argument_list|()
operator|.
name|getClientName
argument_list|()
decl_stmt|;
if|if
condition|(
name|holder
operator|!=
literal|null
operator|&&
operator|!
name|clientName
operator|.
name|equals
argument_list|(
name|holder
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|LeaseExpiredException
argument_list|(
literal|"Lease mismatch on "
operator|+
name|ident
operator|+
literal|" owned by "
operator|+
name|clientName
operator|+
literal|" but is accessed by "
operator|+
name|holder
argument_list|)
throw|;
block|}
return|return
name|file
return|;
block|}
comment|/**    * Complete in-progress write to the given file.    * @return true if successful, false if the client should continue to retry    *         (e.g if not all blocks have reached minimum replication yet)    * @throws IOException on error (eg lease mismatch, file not open, file deleted)    */
DECL|method|completeFile (final String src, String holder, ExtendedBlock last, long fileId)
name|boolean
name|completeFile
parameter_list|(
specifier|final
name|String
name|src
parameter_list|,
name|String
name|holder
parameter_list|,
name|ExtendedBlock
name|last
parameter_list|,
name|long
name|fileId
parameter_list|)
throws|throws
name|IOException
block|{
name|boolean
name|success
init|=
literal|false
decl_stmt|;
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|waitForLoadingFSImage
argument_list|()
expr_stmt|;
name|FSPermissionChecker
name|pc
init|=
name|getPermissionChecker
argument_list|()
decl_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|checkNameNodeSafeMode
argument_list|(
literal|"Cannot complete file "
operator|+
name|src
argument_list|)
expr_stmt|;
name|success
operator|=
name|FSDirWriteFileOp
operator|.
name|completeFile
argument_list|(
name|this
argument_list|,
name|pc
argument_list|,
name|src
argument_list|,
name|holder
argument_list|,
name|last
argument_list|,
name|fileId
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
name|getEditLog
argument_list|()
operator|.
name|logSync
argument_list|()
expr_stmt|;
return|return
name|success
return|;
block|}
comment|/**    * Create new block with a unique block id and a new generation stamp.    */
DECL|method|createNewBlock ()
name|Block
name|createNewBlock
parameter_list|()
throws|throws
name|IOException
block|{
assert|assert
name|hasWriteLock
argument_list|()
assert|;
name|Block
name|b
init|=
operator|new
name|Block
argument_list|(
name|nextBlockId
argument_list|()
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|// Increment the generation stamp for every new block.
name|b
operator|.
name|setGenerationStamp
argument_list|(
name|nextGenerationStamp
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|b
return|;
block|}
comment|/**    * Check that the indicated file's blocks are present and    * replicated.  If not, return false. If checkall is true, then check    * all blocks, otherwise check only penultimate block.    */
DECL|method|checkFileProgress (String src, INodeFile v, boolean checkall)
name|boolean
name|checkFileProgress
parameter_list|(
name|String
name|src
parameter_list|,
name|INodeFile
name|v
parameter_list|,
name|boolean
name|checkall
parameter_list|)
block|{
assert|assert
name|hasReadLock
argument_list|()
assert|;
if|if
condition|(
name|checkall
condition|)
block|{
return|return
name|blockManager
operator|.
name|checkBlocksProperlyReplicated
argument_list|(
name|src
argument_list|,
name|v
operator|.
name|getBlocks
argument_list|()
argument_list|)
return|;
block|}
else|else
block|{
comment|// check the penultimate block of this file
name|BlockInfo
name|b
init|=
name|v
operator|.
name|getPenultimateBlock
argument_list|()
decl_stmt|;
return|return
name|b
operator|==
literal|null
operator|||
name|blockManager
operator|.
name|checkBlocksProperlyReplicated
argument_list|(
name|src
argument_list|,
operator|new
name|BlockInfo
index|[]
block|{
name|b
block|}
argument_list|)
return|;
block|}
block|}
comment|/**    * Change the indicated filename.     * @deprecated Use {@link #renameTo(String, String, boolean,    * Options.Rename...)} instead.    */
annotation|@
name|Deprecated
DECL|method|renameTo (String src, String dst, boolean logRetryCache)
name|boolean
name|renameTo
parameter_list|(
name|String
name|src
parameter_list|,
name|String
name|dst
parameter_list|,
name|boolean
name|logRetryCache
parameter_list|)
throws|throws
name|IOException
block|{
name|waitForLoadingFSImage
argument_list|()
expr_stmt|;
name|FSDirRenameOp
operator|.
name|RenameOldResult
name|ret
init|=
literal|null
decl_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|checkNameNodeSafeMode
argument_list|(
literal|"Cannot rename "
operator|+
name|src
argument_list|)
expr_stmt|;
name|ret
operator|=
name|FSDirRenameOp
operator|.
name|renameToInt
argument_list|(
name|dir
argument_list|,
name|src
argument_list|,
name|dst
argument_list|,
name|logRetryCache
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|AccessControlException
name|e
parameter_list|)
block|{
name|logAuditEvent
argument_list|(
literal|false
argument_list|,
literal|"rename"
argument_list|,
name|src
argument_list|,
name|dst
argument_list|,
literal|null
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
name|boolean
name|success
init|=
name|ret
operator|!=
literal|null
operator|&&
name|ret
operator|.
name|success
decl_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|getEditLog
argument_list|()
operator|.
name|logSync
argument_list|()
expr_stmt|;
block|}
name|logAuditEvent
argument_list|(
name|success
argument_list|,
literal|"rename"
argument_list|,
name|src
argument_list|,
name|dst
argument_list|,
name|ret
operator|==
literal|null
condition|?
literal|null
else|:
name|ret
operator|.
name|auditStat
argument_list|)
expr_stmt|;
return|return
name|success
return|;
block|}
DECL|method|renameTo (final String src, final String dst, boolean logRetryCache, Options.Rename... options)
name|void
name|renameTo
parameter_list|(
specifier|final
name|String
name|src
parameter_list|,
specifier|final
name|String
name|dst
parameter_list|,
name|boolean
name|logRetryCache
parameter_list|,
name|Options
operator|.
name|Rename
modifier|...
name|options
parameter_list|)
throws|throws
name|IOException
block|{
name|waitForLoadingFSImage
argument_list|()
expr_stmt|;
name|Map
operator|.
name|Entry
argument_list|<
name|BlocksMapUpdateInfo
argument_list|,
name|HdfsFileStatus
argument_list|>
name|res
init|=
literal|null
decl_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|checkNameNodeSafeMode
argument_list|(
literal|"Cannot rename "
operator|+
name|src
argument_list|)
expr_stmt|;
name|res
operator|=
name|FSDirRenameOp
operator|.
name|renameToInt
argument_list|(
name|dir
argument_list|,
name|src
argument_list|,
name|dst
argument_list|,
name|logRetryCache
argument_list|,
name|options
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|AccessControlException
name|e
parameter_list|)
block|{
name|logAuditEvent
argument_list|(
literal|false
argument_list|,
literal|"rename (options="
operator|+
name|Arrays
operator|.
name|toString
argument_list|(
name|options
argument_list|)
operator|+
literal|")"
argument_list|,
name|src
argument_list|,
name|dst
argument_list|,
literal|null
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
name|getEditLog
argument_list|()
operator|.
name|logSync
argument_list|()
expr_stmt|;
name|BlocksMapUpdateInfo
name|collectedBlocks
init|=
name|res
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|HdfsFileStatus
name|auditStat
init|=
name|res
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|collectedBlocks
operator|.
name|getToDeleteList
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|removeBlocks
argument_list|(
name|collectedBlocks
argument_list|)
expr_stmt|;
name|collectedBlocks
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
name|logAuditEvent
argument_list|(
literal|true
argument_list|,
literal|"rename (options="
operator|+
name|Arrays
operator|.
name|toString
argument_list|(
name|options
argument_list|)
operator|+
literal|")"
argument_list|,
name|src
argument_list|,
name|dst
argument_list|,
name|auditStat
argument_list|)
expr_stmt|;
block|}
comment|/**    * Remove the indicated file from namespace.    *     * @see ClientProtocol#delete(String, boolean) for detailed description and     * description of exceptions    */
DECL|method|delete (String src, boolean recursive, boolean logRetryCache)
name|boolean
name|delete
parameter_list|(
name|String
name|src
parameter_list|,
name|boolean
name|recursive
parameter_list|,
name|boolean
name|logRetryCache
parameter_list|)
throws|throws
name|IOException
block|{
name|waitForLoadingFSImage
argument_list|()
expr_stmt|;
name|BlocksMapUpdateInfo
name|toRemovedBlocks
init|=
literal|null
decl_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
name|boolean
name|ret
init|=
literal|false
decl_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|checkNameNodeSafeMode
argument_list|(
literal|"Cannot delete "
operator|+
name|src
argument_list|)
expr_stmt|;
name|toRemovedBlocks
operator|=
name|FSDirDeleteOp
operator|.
name|delete
argument_list|(
name|this
argument_list|,
name|src
argument_list|,
name|recursive
argument_list|,
name|logRetryCache
argument_list|)
expr_stmt|;
name|ret
operator|=
name|toRemovedBlocks
operator|!=
literal|null
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|AccessControlException
name|e
parameter_list|)
block|{
name|logAuditEvent
argument_list|(
literal|false
argument_list|,
literal|"delete"
argument_list|,
name|src
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
name|getEditLog
argument_list|()
operator|.
name|logSync
argument_list|()
expr_stmt|;
if|if
condition|(
name|toRemovedBlocks
operator|!=
literal|null
condition|)
block|{
name|removeBlocks
argument_list|(
name|toRemovedBlocks
argument_list|)
expr_stmt|;
comment|// Incremental deletion of blocks
block|}
name|logAuditEvent
argument_list|(
literal|true
argument_list|,
literal|"delete"
argument_list|,
name|src
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
DECL|method|getPermissionChecker ()
name|FSPermissionChecker
name|getPermissionChecker
parameter_list|()
throws|throws
name|AccessControlException
block|{
return|return
name|dir
operator|.
name|getPermissionChecker
argument_list|()
return|;
block|}
comment|/**    * From the given list, incrementally remove the blocks from blockManager    * Writelock is dropped and reacquired every BLOCK_DELETION_INCREMENT to    * ensure that other waiters on the lock can get in. See HDFS-2938    *     * @param blocks    *          An instance of {@link BlocksMapUpdateInfo} which contains a list    *          of blocks that need to be removed from blocksMap    */
DECL|method|removeBlocks (BlocksMapUpdateInfo blocks)
name|void
name|removeBlocks
parameter_list|(
name|BlocksMapUpdateInfo
name|blocks
parameter_list|)
block|{
name|List
argument_list|<
name|BlockInfo
argument_list|>
name|toDeleteList
init|=
name|blocks
operator|.
name|getToDeleteList
argument_list|()
decl_stmt|;
name|Iterator
argument_list|<
name|BlockInfo
argument_list|>
name|iter
init|=
name|toDeleteList
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|iter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|BLOCK_DELETION_INCREMENT
operator|&&
name|iter
operator|.
name|hasNext
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|blockManager
operator|.
name|removeBlock
argument_list|(
name|iter
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Remove leases and inodes related to a given path    * @param removedUCFiles INodes whose leases need to be released    * @param removedINodes Containing the list of inodes to be removed from    *                      inodesMap    * @param acquireINodeMapLock Whether to acquire the lock for inode removal    */
DECL|method|removeLeasesAndINodes (List<Long> removedUCFiles, List<INode> removedINodes, final boolean acquireINodeMapLock)
name|void
name|removeLeasesAndINodes
parameter_list|(
name|List
argument_list|<
name|Long
argument_list|>
name|removedUCFiles
parameter_list|,
name|List
argument_list|<
name|INode
argument_list|>
name|removedINodes
parameter_list|,
specifier|final
name|boolean
name|acquireINodeMapLock
parameter_list|)
block|{
assert|assert
name|hasWriteLock
argument_list|()
assert|;
name|leaseManager
operator|.
name|removeLeases
argument_list|(
name|removedUCFiles
argument_list|)
expr_stmt|;
comment|// remove inodes from inodesMap
if|if
condition|(
name|removedINodes
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|acquireINodeMapLock
condition|)
block|{
name|dir
operator|.
name|writeLock
argument_list|()
expr_stmt|;
block|}
try|try
block|{
name|dir
operator|.
name|removeFromInodeMap
argument_list|(
name|removedINodes
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|acquireINodeMapLock
condition|)
block|{
name|dir
operator|.
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
name|removedINodes
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Removes the blocks from blocksmap and updates the safemode blocks total    *     * @param blocks    *          An instance of {@link BlocksMapUpdateInfo} which contains a list    *          of blocks that need to be removed from blocksMap    */
DECL|method|removeBlocksAndUpdateSafemodeTotal (BlocksMapUpdateInfo blocks)
name|void
name|removeBlocksAndUpdateSafemodeTotal
parameter_list|(
name|BlocksMapUpdateInfo
name|blocks
parameter_list|)
block|{
assert|assert
name|hasWriteLock
argument_list|()
assert|;
comment|// In the case that we are a Standby tailing edits from the
comment|// active while in safe-mode, we need to track the total number
comment|// of blocks and safe blocks in the system.
name|boolean
name|trackBlockCounts
init|=
name|isSafeModeTrackingBlocks
argument_list|()
decl_stmt|;
name|int
name|numRemovedComplete
init|=
literal|0
decl_stmt|,
name|numRemovedSafe
init|=
literal|0
decl_stmt|;
for|for
control|(
name|BlockInfo
name|b
range|:
name|blocks
operator|.
name|getToDeleteList
argument_list|()
control|)
block|{
if|if
condition|(
name|trackBlockCounts
condition|)
block|{
if|if
condition|(
name|b
operator|.
name|isComplete
argument_list|()
condition|)
block|{
name|numRemovedComplete
operator|++
expr_stmt|;
if|if
condition|(
name|blockManager
operator|.
name|checkMinReplication
argument_list|(
name|b
argument_list|)
condition|)
block|{
name|numRemovedSafe
operator|++
expr_stmt|;
block|}
block|}
block|}
name|blockManager
operator|.
name|removeBlock
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|trackBlockCounts
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Adjusting safe-mode totals for deletion."
operator|+
literal|"decreasing safeBlocks by "
operator|+
name|numRemovedSafe
operator|+
literal|", totalBlocks by "
operator|+
name|numRemovedComplete
argument_list|)
expr_stmt|;
block|}
name|adjustSafeModeBlockTotals
argument_list|(
operator|-
name|numRemovedSafe
argument_list|,
operator|-
name|numRemovedComplete
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * @see SafeModeInfo#shouldIncrementallyTrackBlocks    */
DECL|method|isSafeModeTrackingBlocks ()
specifier|private
name|boolean
name|isSafeModeTrackingBlocks
parameter_list|()
block|{
if|if
condition|(
operator|!
name|haEnabled
condition|)
block|{
comment|// Never track blocks incrementally in non-HA code.
return|return
literal|false
return|;
block|}
name|SafeModeInfo
name|sm
init|=
name|this
operator|.
name|safeMode
decl_stmt|;
return|return
name|sm
operator|!=
literal|null
operator|&&
name|sm
operator|.
name|shouldIncrementallyTrackBlocks
argument_list|()
return|;
block|}
comment|/**    * Get the file info for a specific file.    *    * @param src The string representation of the path to the file    * @param resolveLink whether to throw UnresolvedLinkException    *        if src refers to a symlink    *    * @throws AccessControlException if access is denied    * @throws UnresolvedLinkException if a symlink is encountered.    *    * @return object containing information regarding the file    *         or null if file not found    * @throws StandbyException    */
DECL|method|getFileInfo (final String src, boolean resolveLink)
name|HdfsFileStatus
name|getFileInfo
parameter_list|(
specifier|final
name|String
name|src
parameter_list|,
name|boolean
name|resolveLink
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|READ
argument_list|)
expr_stmt|;
name|HdfsFileStatus
name|stat
init|=
literal|null
decl_stmt|;
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|READ
argument_list|)
expr_stmt|;
name|stat
operator|=
name|FSDirStatAndListingOp
operator|.
name|getFileInfo
argument_list|(
name|dir
argument_list|,
name|src
argument_list|,
name|resolveLink
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|AccessControlException
name|e
parameter_list|)
block|{
name|logAuditEvent
argument_list|(
literal|false
argument_list|,
literal|"getfileinfo"
argument_list|,
name|src
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
name|logAuditEvent
argument_list|(
literal|true
argument_list|,
literal|"getfileinfo"
argument_list|,
name|src
argument_list|)
expr_stmt|;
return|return
name|stat
return|;
block|}
comment|/**    * Returns true if the file is closed    */
DECL|method|isFileClosed (final String src)
name|boolean
name|isFileClosed
parameter_list|(
specifier|final
name|String
name|src
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|READ
argument_list|)
expr_stmt|;
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|READ
argument_list|)
expr_stmt|;
return|return
name|FSDirStatAndListingOp
operator|.
name|isFileClosed
argument_list|(
name|dir
argument_list|,
name|src
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|AccessControlException
name|e
parameter_list|)
block|{
name|logAuditEvent
argument_list|(
literal|false
argument_list|,
literal|"isFileClosed"
argument_list|,
name|src
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Create all the necessary directories    */
DECL|method|mkdirs (String src, PermissionStatus permissions, boolean createParent)
name|boolean
name|mkdirs
parameter_list|(
name|String
name|src
parameter_list|,
name|PermissionStatus
name|permissions
parameter_list|,
name|boolean
name|createParent
parameter_list|)
throws|throws
name|IOException
block|{
name|HdfsFileStatus
name|auditStat
init|=
literal|null
decl_stmt|;
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|checkNameNodeSafeMode
argument_list|(
literal|"Cannot create directory "
operator|+
name|src
argument_list|)
expr_stmt|;
name|auditStat
operator|=
name|FSDirMkdirOp
operator|.
name|mkdirs
argument_list|(
name|this
argument_list|,
name|src
argument_list|,
name|permissions
argument_list|,
name|createParent
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|AccessControlException
name|e
parameter_list|)
block|{
name|logAuditEvent
argument_list|(
literal|false
argument_list|,
literal|"mkdirs"
argument_list|,
name|src
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
name|getEditLog
argument_list|()
operator|.
name|logSync
argument_list|()
expr_stmt|;
name|logAuditEvent
argument_list|(
literal|true
argument_list|,
literal|"mkdirs"
argument_list|,
name|src
argument_list|,
literal|null
argument_list|,
name|auditStat
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|/**    * Get the content summary for a specific file/dir.    *    * @param src The string representation of the path to the file    *    * @throws AccessControlException if access is denied    * @throws UnresolvedLinkException if a symlink is encountered.    * @throws FileNotFoundException if no file exists    * @throws StandbyException    * @throws IOException for issues with writing to the audit log    *    * @return object containing information regarding the file    *         or null if file not found    */
DECL|method|getContentSummary (final String src)
name|ContentSummary
name|getContentSummary
parameter_list|(
specifier|final
name|String
name|src
parameter_list|)
throws|throws
name|IOException
block|{
name|readLock
argument_list|()
expr_stmt|;
name|boolean
name|success
init|=
literal|true
decl_stmt|;
try|try
block|{
return|return
name|FSDirStatAndListingOp
operator|.
name|getContentSummary
argument_list|(
name|dir
argument_list|,
name|src
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|AccessControlException
name|ace
parameter_list|)
block|{
name|success
operator|=
literal|false
expr_stmt|;
throw|throw
name|ace
throw|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
name|logAuditEvent
argument_list|(
name|success
argument_list|,
literal|"contentSummary"
argument_list|,
name|src
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Set the namespace quota and storage space quota for a directory.    * See {@link ClientProtocol#setQuota(String, long, long, StorageType)} for the    * contract.    *     * Note: This does not support ".inodes" relative path.    */
DECL|method|setQuota (String src, long nsQuota, long ssQuota, StorageType type)
name|void
name|setQuota
parameter_list|(
name|String
name|src
parameter_list|,
name|long
name|nsQuota
parameter_list|,
name|long
name|ssQuota
parameter_list|,
name|StorageType
name|type
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|type
operator|!=
literal|null
condition|)
block|{
name|requireEffectiveLayoutVersionForFeature
argument_list|(
name|Feature
operator|.
name|QUOTA_BY_STORAGE_TYPE
argument_list|)
expr_stmt|;
block|}
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|checkNameNodeSafeMode
argument_list|(
literal|"Cannot set quota on "
operator|+
name|src
argument_list|)
expr_stmt|;
name|FSDirAttrOp
operator|.
name|setQuota
argument_list|(
name|dir
argument_list|,
name|src
argument_list|,
name|nsQuota
argument_list|,
name|ssQuota
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|getEditLog
argument_list|()
operator|.
name|logSync
argument_list|()
expr_stmt|;
block|}
name|logAuditEvent
argument_list|(
name|success
argument_list|,
literal|"setQuota"
argument_list|,
name|src
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Persist all metadata about this file.    * @param src The string representation of the path    * @param fileId The inode ID that we're fsyncing.  Older clients will pass    *               INodeId.GRANDFATHER_INODE_ID here.    * @param clientName The string representation of the client    * @param lastBlockLength The length of the last block     *                        under construction reported from client.    * @throws IOException if path does not exist    */
DECL|method|fsync (String src, long fileId, String clientName, long lastBlockLength)
name|void
name|fsync
parameter_list|(
name|String
name|src
parameter_list|,
name|long
name|fileId
parameter_list|,
name|String
name|clientName
parameter_list|,
name|long
name|lastBlockLength
parameter_list|)
throws|throws
name|IOException
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|info
argument_list|(
literal|"BLOCK* fsync: "
operator|+
name|src
operator|+
literal|" for "
operator|+
name|clientName
argument_list|)
expr_stmt|;
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|byte
index|[]
index|[]
name|pathComponents
init|=
name|FSDirectory
operator|.
name|getPathComponentsForReservedPath
argument_list|(
name|src
argument_list|)
decl_stmt|;
name|FSPermissionChecker
name|pc
init|=
name|getPermissionChecker
argument_list|()
decl_stmt|;
name|waitForLoadingFSImage
argument_list|()
expr_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|checkNameNodeSafeMode
argument_list|(
literal|"Cannot fsync file "
operator|+
name|src
argument_list|)
expr_stmt|;
name|src
operator|=
name|dir
operator|.
name|resolvePath
argument_list|(
name|pc
argument_list|,
name|src
argument_list|,
name|pathComponents
argument_list|)
expr_stmt|;
specifier|final
name|INode
name|inode
decl_stmt|;
if|if
condition|(
name|fileId
operator|==
name|HdfsConstants
operator|.
name|GRANDFATHER_INODE_ID
condition|)
block|{
comment|// Older clients may not have given us an inode ID to work with.
comment|// In this case, we have to try to resolve the path and hope it
comment|// hasn't changed or been deleted since the file was opened for write.
name|inode
operator|=
name|dir
operator|.
name|getINode
argument_list|(
name|src
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|inode
operator|=
name|dir
operator|.
name|getInode
argument_list|(
name|fileId
argument_list|)
expr_stmt|;
if|if
condition|(
name|inode
operator|!=
literal|null
condition|)
name|src
operator|=
name|inode
operator|.
name|getFullPathName
argument_list|()
expr_stmt|;
block|}
specifier|final
name|INodeFile
name|pendingFile
init|=
name|checkLease
argument_list|(
name|src
argument_list|,
name|clientName
argument_list|,
name|inode
argument_list|,
name|fileId
argument_list|)
decl_stmt|;
if|if
condition|(
name|lastBlockLength
operator|>
literal|0
condition|)
block|{
name|pendingFile
operator|.
name|getFileUnderConstructionFeature
argument_list|()
operator|.
name|updateLengthOfLastBlock
argument_list|(
name|pendingFile
argument_list|,
name|lastBlockLength
argument_list|)
expr_stmt|;
block|}
name|FSDirWriteFileOp
operator|.
name|persistBlocks
argument_list|(
name|dir
argument_list|,
name|src
argument_list|,
name|pendingFile
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
name|getEditLog
argument_list|()
operator|.
name|logSync
argument_list|()
expr_stmt|;
block|}
comment|/**    * Move a file that is being written to be immutable.    * @param src The filename    * @param lease The lease for the client creating the file    * @param recoveryLeaseHolder reassign lease to this holder if the last block    *        needs recovery; keep current holder if null.    * @throws AlreadyBeingCreatedException if file is waiting to achieve minimal    *         replication;<br>    *         RecoveryInProgressException if lease recovery is in progress.<br>    *         IOException in case of an error.    * @return true  if file has been successfully finalized and closed or     *         false if block recovery has been initiated. Since the lease owner    *         has been changed and logged, caller should call logSync().    */
DECL|method|internalReleaseLease (Lease lease, String src, INodesInPath iip, String recoveryLeaseHolder)
name|boolean
name|internalReleaseLease
parameter_list|(
name|Lease
name|lease
parameter_list|,
name|String
name|src
parameter_list|,
name|INodesInPath
name|iip
parameter_list|,
name|String
name|recoveryLeaseHolder
parameter_list|)
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Recovering "
operator|+
name|lease
operator|+
literal|", src="
operator|+
name|src
argument_list|)
expr_stmt|;
assert|assert
operator|!
name|isInSafeMode
argument_list|()
assert|;
assert|assert
name|hasWriteLock
argument_list|()
assert|;
specifier|final
name|INodeFile
name|pendingFile
init|=
name|iip
operator|.
name|getLastINode
argument_list|()
operator|.
name|asFile
argument_list|()
decl_stmt|;
name|int
name|nrBlocks
init|=
name|pendingFile
operator|.
name|numBlocks
argument_list|()
decl_stmt|;
name|BlockInfo
index|[]
name|blocks
init|=
name|pendingFile
operator|.
name|getBlocks
argument_list|()
decl_stmt|;
name|int
name|nrCompleteBlocks
decl_stmt|;
name|BlockInfo
name|curBlock
init|=
literal|null
decl_stmt|;
for|for
control|(
name|nrCompleteBlocks
operator|=
literal|0
init|;
name|nrCompleteBlocks
operator|<
name|nrBlocks
condition|;
name|nrCompleteBlocks
operator|++
control|)
block|{
name|curBlock
operator|=
name|blocks
index|[
name|nrCompleteBlocks
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|curBlock
operator|.
name|isComplete
argument_list|()
condition|)
break|break;
assert|assert
name|blockManager
operator|.
name|checkMinReplication
argument_list|(
name|curBlock
argument_list|)
operator|:
literal|"A COMPLETE block is not minimally replicated in "
operator|+
name|src
assert|;
block|}
comment|// If there are no incomplete blocks associated with this file,
comment|// then reap lease immediately and close the file.
if|if
condition|(
name|nrCompleteBlocks
operator|==
name|nrBlocks
condition|)
block|{
name|finalizeINodeFileUnderConstruction
argument_list|(
name|src
argument_list|,
name|pendingFile
argument_list|,
name|iip
operator|.
name|getLatestSnapshotId
argument_list|()
argument_list|)
expr_stmt|;
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|warn
argument_list|(
literal|"BLOCK*"
operator|+
literal|" internalReleaseLease: All existing blocks are COMPLETE,"
operator|+
literal|" lease removed, file closed."
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
comment|// closed!
block|}
comment|// Only the last and the penultimate blocks may be in non COMPLETE state.
comment|// If the penultimate block is not COMPLETE, then it must be COMMITTED.
if|if
condition|(
name|nrCompleteBlocks
operator|<
name|nrBlocks
operator|-
literal|2
operator|||
name|nrCompleteBlocks
operator|==
name|nrBlocks
operator|-
literal|2
operator|&&
name|curBlock
operator|!=
literal|null
operator|&&
name|curBlock
operator|.
name|getBlockUCState
argument_list|()
operator|!=
name|BlockUCState
operator|.
name|COMMITTED
condition|)
block|{
specifier|final
name|String
name|message
init|=
literal|"DIR* NameSystem.internalReleaseLease: "
operator|+
literal|"attempt to release a create lock on "
operator|+
name|src
operator|+
literal|" but file is already closed."
decl_stmt|;
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|warn
argument_list|(
name|message
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
name|message
argument_list|)
throw|;
block|}
comment|// The last block is not COMPLETE, and
comment|// that the penultimate block if exists is either COMPLETE or COMMITTED
specifier|final
name|BlockInfo
name|lastBlock
init|=
name|pendingFile
operator|.
name|getLastBlock
argument_list|()
decl_stmt|;
name|BlockUCState
name|lastBlockState
init|=
name|lastBlock
operator|.
name|getBlockUCState
argument_list|()
decl_stmt|;
name|BlockInfo
name|penultimateBlock
init|=
name|pendingFile
operator|.
name|getPenultimateBlock
argument_list|()
decl_stmt|;
comment|// If penultimate block doesn't exist then its minReplication is met
name|boolean
name|penultimateBlockMinReplication
init|=
name|penultimateBlock
operator|==
literal|null
operator|||
name|blockManager
operator|.
name|checkMinReplication
argument_list|(
name|penultimateBlock
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|lastBlockState
condition|)
block|{
case|case
name|COMPLETE
case|:
assert|assert
literal|false
operator|:
literal|"Already checked that the last block is incomplete"
assert|;
break|break;
case|case
name|COMMITTED
case|:
comment|// Close file if committed blocks are minimally replicated
if|if
condition|(
name|penultimateBlockMinReplication
operator|&&
name|blockManager
operator|.
name|checkMinReplication
argument_list|(
name|lastBlock
argument_list|)
condition|)
block|{
name|finalizeINodeFileUnderConstruction
argument_list|(
name|src
argument_list|,
name|pendingFile
argument_list|,
name|iip
operator|.
name|getLatestSnapshotId
argument_list|()
argument_list|)
expr_stmt|;
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|warn
argument_list|(
literal|"BLOCK*"
operator|+
literal|" internalReleaseLease: Committed blocks are minimally replicated,"
operator|+
literal|" lease removed, file closed."
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
comment|// closed!
block|}
comment|// Cannot close file right now, since some blocks
comment|// are not yet minimally replicated.
comment|// This may potentially cause infinite loop in lease recovery
comment|// if there are no valid replicas on data-nodes.
name|String
name|message
init|=
literal|"DIR* NameSystem.internalReleaseLease: "
operator|+
literal|"Failed to release lease for file "
operator|+
name|src
operator|+
literal|". Committed blocks are waiting to be minimally replicated."
operator|+
literal|" Try again later."
decl_stmt|;
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|warn
argument_list|(
name|message
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|AlreadyBeingCreatedException
argument_list|(
name|message
argument_list|)
throw|;
case|case
name|UNDER_CONSTRUCTION
case|:
case|case
name|UNDER_RECOVERY
case|:
name|BlockUnderConstructionFeature
name|uc
init|=
name|lastBlock
operator|.
name|getUnderConstructionFeature
argument_list|()
decl_stmt|;
comment|// determine if last block was intended to be truncated
name|Block
name|recoveryBlock
init|=
name|uc
operator|.
name|getTruncateBlock
argument_list|()
decl_stmt|;
name|boolean
name|truncateRecovery
init|=
name|recoveryBlock
operator|!=
literal|null
decl_stmt|;
name|boolean
name|copyOnTruncate
init|=
name|truncateRecovery
operator|&&
name|recoveryBlock
operator|.
name|getBlockId
argument_list|()
operator|!=
name|lastBlock
operator|.
name|getBlockId
argument_list|()
decl_stmt|;
assert|assert
operator|!
name|copyOnTruncate
operator|||
name|recoveryBlock
operator|.
name|getBlockId
argument_list|()
operator|<
name|lastBlock
operator|.
name|getBlockId
argument_list|()
operator|&&
name|recoveryBlock
operator|.
name|getGenerationStamp
argument_list|()
operator|<
name|lastBlock
operator|.
name|getGenerationStamp
argument_list|()
operator|&&
name|recoveryBlock
operator|.
name|getNumBytes
argument_list|()
operator|>
name|lastBlock
operator|.
name|getNumBytes
argument_list|()
operator|:
literal|"wrong recoveryBlock"
assert|;
comment|// setup the last block locations from the blockManager if not known
if|if
condition|(
name|uc
operator|.
name|getNumExpectedLocations
argument_list|()
operator|==
literal|0
condition|)
block|{
name|uc
operator|.
name|setExpectedLocations
argument_list|(
name|lastBlock
argument_list|,
name|blockManager
operator|.
name|getStorages
argument_list|(
name|lastBlock
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|uc
operator|.
name|getNumExpectedLocations
argument_list|()
operator|==
literal|0
operator|&&
name|lastBlock
operator|.
name|getNumBytes
argument_list|()
operator|==
literal|0
condition|)
block|{
comment|// There is no datanode reported to this block.
comment|// may be client have crashed before writing data to pipeline.
comment|// This blocks doesn't need any recovery.
comment|// We can remove this block and close the file.
name|pendingFile
operator|.
name|removeLastBlock
argument_list|(
name|lastBlock
argument_list|)
expr_stmt|;
name|finalizeINodeFileUnderConstruction
argument_list|(
name|src
argument_list|,
name|pendingFile
argument_list|,
name|iip
operator|.
name|getLatestSnapshotId
argument_list|()
argument_list|)
expr_stmt|;
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|warn
argument_list|(
literal|"BLOCK* internalReleaseLease: "
operator|+
literal|"Removed empty last block and closed file."
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|// start recovery of the last block for this file
name|long
name|blockRecoveryId
init|=
name|nextGenerationStamp
argument_list|(
name|blockIdManager
operator|.
name|isLegacyBlock
argument_list|(
name|lastBlock
argument_list|)
argument_list|)
decl_stmt|;
name|lease
operator|=
name|reassignLease
argument_list|(
name|lease
argument_list|,
name|src
argument_list|,
name|recoveryLeaseHolder
argument_list|,
name|pendingFile
argument_list|)
expr_stmt|;
if|if
condition|(
name|copyOnTruncate
condition|)
block|{
name|lastBlock
operator|.
name|setGenerationStamp
argument_list|(
name|blockRecoveryId
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|truncateRecovery
condition|)
block|{
name|recoveryBlock
operator|.
name|setGenerationStamp
argument_list|(
name|blockRecoveryId
argument_list|)
expr_stmt|;
block|}
name|uc
operator|.
name|initializeBlockRecovery
argument_list|(
name|lastBlock
argument_list|,
name|blockRecoveryId
argument_list|)
expr_stmt|;
name|leaseManager
operator|.
name|renewLease
argument_list|(
name|lease
argument_list|)
expr_stmt|;
comment|// Cannot close file right now, since the last block requires recovery.
comment|// This may potentially cause infinite loop in lease recovery
comment|// if there are no valid replicas on data-nodes.
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|warn
argument_list|(
literal|"DIR* NameSystem.internalReleaseLease: "
operator|+
literal|"File "
operator|+
name|src
operator|+
literal|" has not been closed."
operator|+
literal|" Lease recovery is in progress. "
operator|+
literal|"RecoveryId = "
operator|+
name|blockRecoveryId
operator|+
literal|" for block "
operator|+
name|lastBlock
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
literal|false
return|;
block|}
DECL|method|reassignLease (Lease lease, String src, String newHolder, INodeFile pendingFile)
specifier|private
name|Lease
name|reassignLease
parameter_list|(
name|Lease
name|lease
parameter_list|,
name|String
name|src
parameter_list|,
name|String
name|newHolder
parameter_list|,
name|INodeFile
name|pendingFile
parameter_list|)
block|{
assert|assert
name|hasWriteLock
argument_list|()
assert|;
if|if
condition|(
name|newHolder
operator|==
literal|null
condition|)
return|return
name|lease
return|;
comment|// The following transaction is not synced. Make sure it's sync'ed later.
name|logReassignLease
argument_list|(
name|lease
operator|.
name|getHolder
argument_list|()
argument_list|,
name|src
argument_list|,
name|newHolder
argument_list|)
expr_stmt|;
return|return
name|reassignLeaseInternal
argument_list|(
name|lease
argument_list|,
name|newHolder
argument_list|,
name|pendingFile
argument_list|)
return|;
block|}
DECL|method|reassignLeaseInternal (Lease lease, String newHolder, INodeFile pendingFile)
name|Lease
name|reassignLeaseInternal
parameter_list|(
name|Lease
name|lease
parameter_list|,
name|String
name|newHolder
parameter_list|,
name|INodeFile
name|pendingFile
parameter_list|)
block|{
assert|assert
name|hasWriteLock
argument_list|()
assert|;
name|pendingFile
operator|.
name|getFileUnderConstructionFeature
argument_list|()
operator|.
name|setClientName
argument_list|(
name|newHolder
argument_list|)
expr_stmt|;
return|return
name|leaseManager
operator|.
name|reassignLease
argument_list|(
name|lease
argument_list|,
name|pendingFile
argument_list|,
name|newHolder
argument_list|)
return|;
block|}
DECL|method|commitOrCompleteLastBlock ( final INodeFile fileINode, final INodesInPath iip, final Block commitBlock)
name|void
name|commitOrCompleteLastBlock
parameter_list|(
specifier|final
name|INodeFile
name|fileINode
parameter_list|,
specifier|final
name|INodesInPath
name|iip
parameter_list|,
specifier|final
name|Block
name|commitBlock
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|hasWriteLock
argument_list|()
assert|;
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|fileINode
operator|.
name|isUnderConstruction
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|blockManager
operator|.
name|commitOrCompleteLastBlock
argument_list|(
name|fileINode
argument_list|,
name|commitBlock
argument_list|)
condition|)
block|{
return|return;
block|}
comment|// Adjust disk space consumption if required
specifier|final
name|long
name|diff
init|=
name|fileINode
operator|.
name|getPreferredBlockSize
argument_list|()
operator|-
name|commitBlock
operator|.
name|getNumBytes
argument_list|()
decl_stmt|;
if|if
condition|(
name|diff
operator|>
literal|0
condition|)
block|{
try|try
block|{
name|dir
operator|.
name|updateSpaceConsumed
argument_list|(
name|iip
argument_list|,
literal|0
argument_list|,
operator|-
name|diff
argument_list|,
name|fileINode
operator|.
name|getFileReplication
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Unexpected exception while updating disk space."
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|finalizeINodeFileUnderConstruction ( String src, INodeFile pendingFile, int latestSnapshot)
name|void
name|finalizeINodeFileUnderConstruction
parameter_list|(
name|String
name|src
parameter_list|,
name|INodeFile
name|pendingFile
parameter_list|,
name|int
name|latestSnapshot
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|hasWriteLock
argument_list|()
assert|;
name|FileUnderConstructionFeature
name|uc
init|=
name|pendingFile
operator|.
name|getFileUnderConstructionFeature
argument_list|()
decl_stmt|;
if|if
condition|(
name|uc
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Cannot finalize file "
operator|+
name|src
operator|+
literal|" because it is not under construction"
argument_list|)
throw|;
block|}
name|leaseManager
operator|.
name|removeLease
argument_list|(
name|uc
operator|.
name|getClientName
argument_list|()
argument_list|,
name|pendingFile
argument_list|)
expr_stmt|;
name|pendingFile
operator|.
name|recordModification
argument_list|(
name|latestSnapshot
argument_list|)
expr_stmt|;
comment|// The file is no longer pending.
comment|// Create permanent INode, update blocks. No need to replace the inode here
comment|// since we just remove the uc feature from pendingFile
name|pendingFile
operator|.
name|toCompleteFile
argument_list|(
name|now
argument_list|()
argument_list|)
expr_stmt|;
name|waitForLoadingFSImage
argument_list|()
expr_stmt|;
comment|// close file and persist block allocations for this file
name|closeFile
argument_list|(
name|src
argument_list|,
name|pendingFile
argument_list|)
expr_stmt|;
name|blockManager
operator|.
name|checkReplication
argument_list|(
name|pendingFile
argument_list|)
expr_stmt|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|getStoredBlock (Block block)
name|BlockInfo
name|getStoredBlock
parameter_list|(
name|Block
name|block
parameter_list|)
block|{
return|return
name|blockManager
operator|.
name|getStoredBlock
argument_list|(
name|block
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|isInSnapshot (BlockInfo blockUC)
specifier|public
name|boolean
name|isInSnapshot
parameter_list|(
name|BlockInfo
name|blockUC
parameter_list|)
block|{
assert|assert
name|hasReadLock
argument_list|()
assert|;
specifier|final
name|BlockCollection
name|bc
init|=
name|blockManager
operator|.
name|getBlockCollection
argument_list|(
name|blockUC
argument_list|)
decl_stmt|;
if|if
condition|(
name|bc
operator|==
literal|null
operator|||
operator|!
operator|(
name|bc
operator|instanceof
name|INodeFile
operator|)
operator|||
operator|!
name|bc
operator|.
name|isUnderConstruction
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
name|String
name|fullName
init|=
name|bc
operator|.
name|getName
argument_list|()
decl_stmt|;
try|try
block|{
if|if
condition|(
name|fullName
operator|!=
literal|null
operator|&&
name|fullName
operator|.
name|startsWith
argument_list|(
name|Path
operator|.
name|SEPARATOR
argument_list|)
operator|&&
name|dir
operator|.
name|getINode
argument_list|(
name|fullName
argument_list|)
operator|==
name|bc
condition|)
block|{
comment|// If file exists in normal path then no need to look in snapshot
return|return
literal|false
return|;
block|}
block|}
catch|catch
parameter_list|(
name|UnresolvedLinkException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Error while resolving the link : "
operator|+
name|fullName
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|/*      * 1. if bc is under construction and also with snapshot, and      * bc is not in the current fsdirectory tree, bc must represent a snapshot      * file.       * 2. if fullName is not an absolute path, bc cannot be existent in the       * current fsdirectory tree.       * 3. if bc is not the current node associated with fullName, bc must be a      * snapshot inode.      */
return|return
literal|true
return|;
block|}
annotation|@
name|Override
DECL|method|getBlockCollection (long id)
specifier|public
name|BlockCollection
name|getBlockCollection
parameter_list|(
name|long
name|id
parameter_list|)
block|{
name|INode
name|inode
init|=
name|getFSDirectory
argument_list|()
operator|.
name|getInode
argument_list|(
name|id
argument_list|)
decl_stmt|;
return|return
name|inode
operator|==
literal|null
condition|?
literal|null
else|:
name|inode
operator|.
name|asFile
argument_list|()
return|;
block|}
DECL|method|commitBlockSynchronization (ExtendedBlock oldBlock, long newgenerationstamp, long newlength, boolean closeFile, boolean deleteblock, DatanodeID[] newtargets, String[] newtargetstorages)
name|void
name|commitBlockSynchronization
parameter_list|(
name|ExtendedBlock
name|oldBlock
parameter_list|,
name|long
name|newgenerationstamp
parameter_list|,
name|long
name|newlength
parameter_list|,
name|boolean
name|closeFile
parameter_list|,
name|boolean
name|deleteblock
parameter_list|,
name|DatanodeID
index|[]
name|newtargets
parameter_list|,
name|String
index|[]
name|newtargetstorages
parameter_list|)
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"commitBlockSynchronization(oldBlock="
operator|+
name|oldBlock
operator|+
literal|", newgenerationstamp="
operator|+
name|newgenerationstamp
operator|+
literal|", newlength="
operator|+
name|newlength
operator|+
literal|", newtargets="
operator|+
name|Arrays
operator|.
name|asList
argument_list|(
name|newtargets
argument_list|)
operator|+
literal|", closeFile="
operator|+
name|closeFile
operator|+
literal|", deleteBlock="
operator|+
name|deleteblock
operator|+
literal|")"
argument_list|)
expr_stmt|;
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|String
name|src
init|=
literal|""
decl_stmt|;
name|waitForLoadingFSImage
argument_list|()
expr_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
name|boolean
name|copyTruncate
init|=
literal|false
decl_stmt|;
name|BlockInfo
name|truncatedBlock
init|=
literal|null
decl_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
comment|// If a DN tries to commit to the standby, the recovery will
comment|// fail, and the next retry will succeed on the new NN.
name|checkNameNodeSafeMode
argument_list|(
literal|"Cannot commitBlockSynchronization while in safe mode"
argument_list|)
expr_stmt|;
specifier|final
name|BlockInfo
name|storedBlock
init|=
name|getStoredBlock
argument_list|(
name|ExtendedBlock
operator|.
name|getLocalBlock
argument_list|(
name|oldBlock
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|storedBlock
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|deleteblock
condition|)
block|{
comment|// This may be a retry attempt so ignore the failure
comment|// to locate the block.
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Block (="
operator|+
name|oldBlock
operator|+
literal|") not found"
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
else|else
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Block (="
operator|+
name|oldBlock
operator|+
literal|") not found"
argument_list|)
throw|;
block|}
block|}
specifier|final
name|long
name|oldGenerationStamp
init|=
name|storedBlock
operator|.
name|getGenerationStamp
argument_list|()
decl_stmt|;
specifier|final
name|long
name|oldNumBytes
init|=
name|storedBlock
operator|.
name|getNumBytes
argument_list|()
decl_stmt|;
comment|//
comment|// The implementation of delete operation (see @deleteInternal method)
comment|// first removes the file paths from namespace, and delays the removal
comment|// of blocks to later time for better performance. When
comment|// commitBlockSynchronization (this method) is called in between, the
comment|// blockCollection of storedBlock could have been assigned to null by
comment|// the delete operation, throw IOException here instead of NPE; if the
comment|// file path is already removed from namespace by the delete operation,
comment|// throw FileNotFoundException here, so not to proceed to the end of
comment|// this method to add a CloseOp to the edit log for an already deleted
comment|// file (See HDFS-6825).
comment|//
if|if
condition|(
name|storedBlock
operator|.
name|isDeleted
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"The blockCollection of "
operator|+
name|storedBlock
operator|+
literal|" is null, likely because the file owning this block was"
operator|+
literal|" deleted and the block removal is delayed"
argument_list|)
throw|;
block|}
name|long
name|bcId
init|=
name|storedBlock
operator|.
name|getBlockCollectionId
argument_list|()
decl_stmt|;
name|INodeFile
name|iFile
init|=
operator|(
operator|(
name|INode
operator|)
name|getBlockCollection
argument_list|(
name|bcId
argument_list|)
operator|)
operator|.
name|asFile
argument_list|()
decl_stmt|;
if|if
condition|(
name|isFileDeleted
argument_list|(
name|iFile
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|FileNotFoundException
argument_list|(
literal|"File not found: "
operator|+
name|iFile
operator|.
name|getFullPathName
argument_list|()
operator|+
literal|", likely due to delayed block"
operator|+
literal|" removal"
argument_list|)
throw|;
block|}
if|if
condition|(
operator|(
operator|!
name|iFile
operator|.
name|isUnderConstruction
argument_list|()
operator|||
name|storedBlock
operator|.
name|isComplete
argument_list|()
operator|)
operator|&&
name|iFile
operator|.
name|getLastBlock
argument_list|()
operator|.
name|isComplete
argument_list|()
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Unexpected block (="
operator|+
name|oldBlock
operator|+
literal|") since the file (="
operator|+
name|iFile
operator|.
name|getLocalName
argument_list|()
operator|+
literal|") is not under construction"
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
name|truncatedBlock
operator|=
name|iFile
operator|.
name|getLastBlock
argument_list|()
expr_stmt|;
name|long
name|recoveryId
init|=
name|truncatedBlock
operator|.
name|getUnderConstructionFeature
argument_list|()
operator|.
name|getBlockRecoveryId
argument_list|()
decl_stmt|;
name|copyTruncate
operator|=
name|truncatedBlock
operator|.
name|getBlockId
argument_list|()
operator|!=
name|storedBlock
operator|.
name|getBlockId
argument_list|()
expr_stmt|;
if|if
condition|(
name|recoveryId
operator|!=
name|newgenerationstamp
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"The recovery id "
operator|+
name|newgenerationstamp
operator|+
literal|" does not match current recovery id "
operator|+
name|recoveryId
operator|+
literal|" for block "
operator|+
name|oldBlock
argument_list|)
throw|;
block|}
if|if
condition|(
name|deleteblock
condition|)
block|{
name|Block
name|blockToDel
init|=
name|ExtendedBlock
operator|.
name|getLocalBlock
argument_list|(
name|oldBlock
argument_list|)
decl_stmt|;
name|boolean
name|remove
init|=
name|iFile
operator|.
name|removeLastBlock
argument_list|(
name|blockToDel
argument_list|)
operator|!=
literal|null
decl_stmt|;
if|if
condition|(
name|remove
condition|)
block|{
name|blockManager
operator|.
name|removeBlock
argument_list|(
name|storedBlock
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// update last block
if|if
condition|(
operator|!
name|copyTruncate
condition|)
block|{
name|storedBlock
operator|.
name|setGenerationStamp
argument_list|(
name|newgenerationstamp
argument_list|)
expr_stmt|;
name|storedBlock
operator|.
name|setNumBytes
argument_list|(
name|newlength
argument_list|)
expr_stmt|;
block|}
comment|// find the DatanodeDescriptor objects
name|ArrayList
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|trimmedTargets
init|=
operator|new
name|ArrayList
argument_list|<
name|DatanodeDescriptor
argument_list|>
argument_list|(
name|newtargets
operator|.
name|length
argument_list|)
decl_stmt|;
name|ArrayList
argument_list|<
name|String
argument_list|>
name|trimmedStorages
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|(
name|newtargets
operator|.
name|length
argument_list|)
decl_stmt|;
if|if
condition|(
name|newtargets
operator|.
name|length
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|newtargets
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
comment|// try to get targetNode
name|DatanodeDescriptor
name|targetNode
init|=
name|blockManager
operator|.
name|getDatanodeManager
argument_list|()
operator|.
name|getDatanode
argument_list|(
name|newtargets
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|targetNode
operator|!=
literal|null
condition|)
block|{
name|trimmedTargets
operator|.
name|add
argument_list|(
name|targetNode
argument_list|)
expr_stmt|;
name|trimmedStorages
operator|.
name|add
argument_list|(
name|newtargetstorages
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"DatanodeDescriptor (="
operator|+
name|newtargets
index|[
name|i
index|]
operator|+
literal|") not found"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|(
name|closeFile
operator|)
operator|&&
operator|!
name|trimmedTargets
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// the file is getting closed. Insert block locations into blockManager.
comment|// Otherwise fsck will report these blocks as MISSING, especially if the
comment|// blocksReceived from Datanodes take a long time to arrive.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|trimmedTargets
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|DatanodeStorageInfo
name|storageInfo
init|=
name|trimmedTargets
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getStorageInfo
argument_list|(
name|trimmedStorages
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|storageInfo
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|copyTruncate
condition|)
block|{
name|storageInfo
operator|.
name|addBlock
argument_list|(
name|truncatedBlock
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|storageInfo
operator|.
name|addBlock
argument_list|(
name|storedBlock
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|// add pipeline locations into the INodeUnderConstruction
name|DatanodeStorageInfo
index|[]
name|trimmedStorageInfos
init|=
name|blockManager
operator|.
name|getDatanodeManager
argument_list|()
operator|.
name|getDatanodeStorageInfos
argument_list|(
name|trimmedTargets
operator|.
name|toArray
argument_list|(
operator|new
name|DatanodeID
index|[
name|trimmedTargets
operator|.
name|size
argument_list|()
index|]
argument_list|)
argument_list|,
name|trimmedStorages
operator|.
name|toArray
argument_list|(
operator|new
name|String
index|[
name|trimmedStorages
operator|.
name|size
argument_list|()
index|]
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|copyTruncate
condition|)
block|{
name|iFile
operator|.
name|convertLastBlockToUC
argument_list|(
name|truncatedBlock
argument_list|,
name|trimmedStorageInfos
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|iFile
operator|.
name|convertLastBlockToUC
argument_list|(
name|storedBlock
argument_list|,
name|trimmedStorageInfos
argument_list|)
expr_stmt|;
if|if
condition|(
name|closeFile
condition|)
block|{
name|blockManager
operator|.
name|markBlockReplicasAsCorrupt
argument_list|(
name|storedBlock
argument_list|,
name|oldGenerationStamp
argument_list|,
name|oldNumBytes
argument_list|,
name|trimmedStorageInfos
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|closeFile
condition|)
block|{
if|if
condition|(
name|copyTruncate
condition|)
block|{
name|src
operator|=
name|closeFileCommitBlocks
argument_list|(
name|iFile
argument_list|,
name|truncatedBlock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|iFile
operator|.
name|isBlockInLatestSnapshot
argument_list|(
name|storedBlock
argument_list|)
condition|)
block|{
name|blockManager
operator|.
name|removeBlock
argument_list|(
name|storedBlock
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|src
operator|=
name|closeFileCommitBlocks
argument_list|(
name|iFile
argument_list|,
name|storedBlock
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// If this commit does not want to close the file, persist blocks
name|src
operator|=
name|iFile
operator|.
name|getFullPathName
argument_list|()
expr_stmt|;
name|FSDirWriteFileOp
operator|.
name|persistBlocks
argument_list|(
name|dir
argument_list|,
name|src
argument_list|,
name|iFile
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
name|getEditLog
argument_list|()
operator|.
name|logSync
argument_list|()
expr_stmt|;
if|if
condition|(
name|closeFile
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"commitBlockSynchronization(oldBlock="
operator|+
name|oldBlock
operator|+
literal|", file="
operator|+
name|src
operator|+
operator|(
name|copyTruncate
condition|?
literal|", newBlock="
operator|+
name|truncatedBlock
else|:
literal|", newgenerationstamp="
operator|+
name|newgenerationstamp
operator|)
operator|+
literal|", newlength="
operator|+
name|newlength
operator|+
literal|", newtargets="
operator|+
name|Arrays
operator|.
name|asList
argument_list|(
name|newtargets
argument_list|)
operator|+
literal|") successful"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"commitBlockSynchronization("
operator|+
name|oldBlock
operator|+
literal|") successful"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * @param pendingFile open file that needs to be closed    * @param storedBlock last block    * @return Path of the file that was closed.    * @throws IOException on error    */
annotation|@
name|VisibleForTesting
DECL|method|closeFileCommitBlocks (INodeFile pendingFile, BlockInfo storedBlock)
name|String
name|closeFileCommitBlocks
parameter_list|(
name|INodeFile
name|pendingFile
parameter_list|,
name|BlockInfo
name|storedBlock
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|INodesInPath
name|iip
init|=
name|INodesInPath
operator|.
name|fromINode
argument_list|(
name|pendingFile
argument_list|)
decl_stmt|;
specifier|final
name|String
name|src
init|=
name|iip
operator|.
name|getPath
argument_list|()
decl_stmt|;
comment|// commit the last block and complete it if it has minimum replicas
name|commitOrCompleteLastBlock
argument_list|(
name|pendingFile
argument_list|,
name|iip
argument_list|,
name|storedBlock
argument_list|)
expr_stmt|;
comment|//remove lease, close file
name|finalizeINodeFileUnderConstruction
argument_list|(
name|src
argument_list|,
name|pendingFile
argument_list|,
name|Snapshot
operator|.
name|findLatestSnapshot
argument_list|(
name|pendingFile
argument_list|,
name|Snapshot
operator|.
name|CURRENT_STATE_ID
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|src
return|;
block|}
comment|/**    * Renew the lease(s) held by the given client    */
DECL|method|renewLease (String holder)
name|void
name|renewLease
parameter_list|(
name|String
name|holder
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|checkNameNodeSafeMode
argument_list|(
literal|"Cannot renew lease for "
operator|+
name|holder
argument_list|)
expr_stmt|;
name|leaseManager
operator|.
name|renewLease
argument_list|(
name|holder
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Get a partial listing of the indicated directory    *    * @param src the directory name    * @param startAfter the name to start after    * @param needLocation if blockLocations need to be returned    * @return a partial listing starting after startAfter    *     * @throws AccessControlException if access is denied    * @throws UnresolvedLinkException if symbolic link is encountered    * @throws IOException if other I/O error occurred    */
DECL|method|getListing (String src, byte[] startAfter, boolean needLocation)
name|DirectoryListing
name|getListing
parameter_list|(
name|String
name|src
parameter_list|,
name|byte
index|[]
name|startAfter
parameter_list|,
name|boolean
name|needLocation
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|READ
argument_list|)
expr_stmt|;
name|DirectoryListing
name|dl
init|=
literal|null
decl_stmt|;
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|NameNode
operator|.
name|OperationCategory
operator|.
name|READ
argument_list|)
expr_stmt|;
name|dl
operator|=
name|getListingInt
argument_list|(
name|dir
argument_list|,
name|src
argument_list|,
name|startAfter
argument_list|,
name|needLocation
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|AccessControlException
name|e
parameter_list|)
block|{
name|logAuditEvent
argument_list|(
literal|false
argument_list|,
literal|"listStatus"
argument_list|,
name|src
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
name|logAuditEvent
argument_list|(
literal|true
argument_list|,
literal|"listStatus"
argument_list|,
name|src
argument_list|)
expr_stmt|;
return|return
name|dl
return|;
block|}
comment|/////////////////////////////////////////////////////////
comment|//
comment|// These methods are called by datanodes
comment|//
comment|/////////////////////////////////////////////////////////
comment|/**    * Register Datanode.    *<p>    * The purpose of registration is to identify whether the new datanode    * serves a new data storage, and will report new data block copies,    * which the namenode was not aware of; or the datanode is a replacement    * node for the data storage that was previously served by a different    * or the same (in terms of host:port) datanode.    * The data storages are distinguished by their storageIDs. When a new    * data storage is reported the namenode issues a new unique storageID.    *<p>    * Finally, the namenode returns its namespaceID as the registrationID    * for the datanodes.     * namespaceID is a persistent attribute of the name space.    * The registrationID is checked every time the datanode is communicating    * with the namenode.     * Datanodes with inappropriate registrationID are rejected.    * If the namenode stops, and then restarts it can restore its     * namespaceID and will continue serving the datanodes that has previously    * registered with the namenode without restarting the whole cluster.    *     * @see org.apache.hadoop.hdfs.server.datanode.DataNode    */
DECL|method|registerDatanode (DatanodeRegistration nodeReg)
name|void
name|registerDatanode
parameter_list|(
name|DatanodeRegistration
name|nodeReg
parameter_list|)
throws|throws
name|IOException
block|{
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|getBlockManager
argument_list|()
operator|.
name|getDatanodeManager
argument_list|()
operator|.
name|registerDatanode
argument_list|(
name|nodeReg
argument_list|)
expr_stmt|;
name|checkSafeMode
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Get registrationID for datanodes based on the namespaceID.    *     * @see #registerDatanode(DatanodeRegistration)    * @return registration ID    */
DECL|method|getRegistrationID ()
name|String
name|getRegistrationID
parameter_list|()
block|{
return|return
name|Storage
operator|.
name|getRegistrationID
argument_list|(
name|getFSImage
argument_list|()
operator|.
name|getStorage
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * The given node has reported in.  This method should:    * 1) Record the heartbeat, so the datanode isn't timed out    * 2) Adjust usage stats for future block allocation    *     * If a substantial amount of time passed since the last datanode     * heartbeat then request an immediate block report.      *     * @return an array of datanode commands     * @throws IOException    */
DECL|method|handleHeartbeat (DatanodeRegistration nodeReg, StorageReport[] reports, long cacheCapacity, long cacheUsed, int xceiverCount, int xmitsInProgress, int failedVolumes, VolumeFailureSummary volumeFailureSummary, boolean requestFullBlockReportLease)
name|HeartbeatResponse
name|handleHeartbeat
parameter_list|(
name|DatanodeRegistration
name|nodeReg
parameter_list|,
name|StorageReport
index|[]
name|reports
parameter_list|,
name|long
name|cacheCapacity
parameter_list|,
name|long
name|cacheUsed
parameter_list|,
name|int
name|xceiverCount
parameter_list|,
name|int
name|xmitsInProgress
parameter_list|,
name|int
name|failedVolumes
parameter_list|,
name|VolumeFailureSummary
name|volumeFailureSummary
parameter_list|,
name|boolean
name|requestFullBlockReportLease
parameter_list|)
throws|throws
name|IOException
block|{
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
comment|//get datanode commands
specifier|final
name|int
name|maxTransfer
init|=
name|blockManager
operator|.
name|getMaxReplicationStreams
argument_list|()
operator|-
name|xmitsInProgress
decl_stmt|;
name|DatanodeCommand
index|[]
name|cmds
init|=
name|blockManager
operator|.
name|getDatanodeManager
argument_list|()
operator|.
name|handleHeartbeat
argument_list|(
name|nodeReg
argument_list|,
name|reports
argument_list|,
name|blockPoolId
argument_list|,
name|cacheCapacity
argument_list|,
name|cacheUsed
argument_list|,
name|xceiverCount
argument_list|,
name|maxTransfer
argument_list|,
name|failedVolumes
argument_list|,
name|volumeFailureSummary
argument_list|)
decl_stmt|;
name|long
name|blockReportLeaseId
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|requestFullBlockReportLease
condition|)
block|{
name|blockReportLeaseId
operator|=
name|blockManager
operator|.
name|requestBlockReportLeaseId
argument_list|(
name|nodeReg
argument_list|)
expr_stmt|;
block|}
comment|//create ha status
specifier|final
name|NNHAStatusHeartbeat
name|haState
init|=
operator|new
name|NNHAStatusHeartbeat
argument_list|(
name|haContext
operator|.
name|getState
argument_list|()
operator|.
name|getServiceState
argument_list|()
argument_list|,
name|getFSImage
argument_list|()
operator|.
name|getLastAppliedOrWrittenTxId
argument_list|()
argument_list|)
decl_stmt|;
return|return
operator|new
name|HeartbeatResponse
argument_list|(
name|cmds
argument_list|,
name|haState
argument_list|,
name|rollingUpgradeInfo
argument_list|,
name|blockReportLeaseId
argument_list|)
return|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Returns whether or not there were available resources at the last check of    * resources.    *    * @return true if there were sufficient resources available, false otherwise.    */
DECL|method|nameNodeHasResourcesAvailable ()
name|boolean
name|nameNodeHasResourcesAvailable
parameter_list|()
block|{
return|return
name|hasResourcesAvailable
return|;
block|}
comment|/**    * Perform resource checks and cache the results.    */
DECL|method|checkAvailableResources ()
name|void
name|checkAvailableResources
parameter_list|()
block|{
name|Preconditions
operator|.
name|checkState
argument_list|(
name|nnResourceChecker
operator|!=
literal|null
argument_list|,
literal|"nnResourceChecker not initialized"
argument_list|)
expr_stmt|;
name|hasResourcesAvailable
operator|=
name|nnResourceChecker
operator|.
name|hasAvailableDiskSpace
argument_list|()
expr_stmt|;
block|}
comment|/**    * Close file.    * @param path    * @param file    */
DECL|method|closeFile (String path, INodeFile file)
specifier|private
name|void
name|closeFile
parameter_list|(
name|String
name|path
parameter_list|,
name|INodeFile
name|file
parameter_list|)
block|{
assert|assert
name|hasWriteLock
argument_list|()
assert|;
name|waitForLoadingFSImage
argument_list|()
expr_stmt|;
comment|// file is closed
name|getEditLog
argument_list|()
operator|.
name|logCloseFile
argument_list|(
name|path
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|debug
argument_list|(
literal|"closeFile: {} with {} blocks is persisted"
operator|+
literal|" to the file system"
argument_list|,
name|path
argument_list|,
name|file
operator|.
name|getBlocks
argument_list|()
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
comment|/**    * Periodically calls hasAvailableResources of NameNodeResourceChecker, and if    * there are found to be insufficient resources available, causes the NN to    * enter safe mode. If resources are later found to have returned to    * acceptable levels, this daemon will cause the NN to exit safe mode.    */
DECL|class|NameNodeResourceMonitor
class|class
name|NameNodeResourceMonitor
implements|implements
name|Runnable
block|{
DECL|field|shouldNNRmRun
name|boolean
name|shouldNNRmRun
init|=
literal|true
decl_stmt|;
annotation|@
name|Override
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
try|try
block|{
while|while
condition|(
name|fsRunning
operator|&&
name|shouldNNRmRun
condition|)
block|{
name|checkAvailableResources
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|nameNodeHasResourcesAvailable
argument_list|()
condition|)
block|{
name|String
name|lowResourcesMsg
init|=
literal|"NameNode low on available disk space. "
decl_stmt|;
if|if
condition|(
operator|!
name|isInSafeMode
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|lowResourcesMsg
operator|+
literal|"Entering safe mode."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|lowResourcesMsg
operator|+
literal|"Already in safe mode."
argument_list|)
expr_stmt|;
block|}
name|enterSafeMode
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|resourceRecheckInterval
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
comment|// Deliberately ignore
block|}
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|FSNamesystem
operator|.
name|LOG
operator|.
name|error
argument_list|(
literal|"Exception in NameNodeResourceMonitor: "
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|stopMonitor ()
specifier|public
name|void
name|stopMonitor
parameter_list|()
block|{
name|shouldNNRmRun
operator|=
literal|false
expr_stmt|;
block|}
block|}
DECL|class|NameNodeEditLogRoller
class|class
name|NameNodeEditLogRoller
implements|implements
name|Runnable
block|{
DECL|field|shouldRun
specifier|private
name|boolean
name|shouldRun
init|=
literal|true
decl_stmt|;
DECL|field|rollThreshold
specifier|private
specifier|final
name|long
name|rollThreshold
decl_stmt|;
DECL|field|sleepIntervalMs
specifier|private
specifier|final
name|long
name|sleepIntervalMs
decl_stmt|;
DECL|method|NameNodeEditLogRoller (long rollThreshold, int sleepIntervalMs)
specifier|public
name|NameNodeEditLogRoller
parameter_list|(
name|long
name|rollThreshold
parameter_list|,
name|int
name|sleepIntervalMs
parameter_list|)
block|{
name|this
operator|.
name|rollThreshold
operator|=
name|rollThreshold
expr_stmt|;
name|this
operator|.
name|sleepIntervalMs
operator|=
name|sleepIntervalMs
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
while|while
condition|(
name|fsRunning
operator|&&
name|shouldRun
condition|)
block|{
try|try
block|{
name|FSEditLog
name|editLog
init|=
name|getFSImage
argument_list|()
operator|.
name|getEditLog
argument_list|()
decl_stmt|;
name|long
name|numEdits
init|=
name|editLog
operator|.
name|getLastWrittenTxId
argument_list|()
operator|-
name|editLog
operator|.
name|getCurSegmentTxId
argument_list|()
decl_stmt|;
if|if
condition|(
name|numEdits
operator|>
name|rollThreshold
condition|)
block|{
name|FSNamesystem
operator|.
name|LOG
operator|.
name|info
argument_list|(
literal|"NameNode rolling its own edit log because"
operator|+
literal|" number of edits in open segment exceeds threshold of "
operator|+
name|rollThreshold
argument_list|)
expr_stmt|;
name|rollEditLog
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|FSNamesystem
operator|.
name|LOG
operator|.
name|error
argument_list|(
literal|"Swallowing exception in "
operator|+
name|NameNodeEditLogRoller
operator|.
name|class
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|":"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|sleepIntervalMs
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|FSNamesystem
operator|.
name|LOG
operator|.
name|info
argument_list|(
name|NameNodeEditLogRoller
operator|.
name|class
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|" was interrupted, exiting"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
DECL|method|stop ()
specifier|public
name|void
name|stop
parameter_list|()
block|{
name|shouldRun
operator|=
literal|false
expr_stmt|;
block|}
block|}
comment|/**    * Daemon to periodically scan the namespace for lazyPersist files    * with missing blocks and unlink them.    */
DECL|class|LazyPersistFileScrubber
class|class
name|LazyPersistFileScrubber
implements|implements
name|Runnable
block|{
DECL|field|shouldRun
specifier|private
specifier|volatile
name|boolean
name|shouldRun
init|=
literal|true
decl_stmt|;
DECL|field|scrubIntervalSec
specifier|final
name|int
name|scrubIntervalSec
decl_stmt|;
DECL|method|LazyPersistFileScrubber (final int scrubIntervalSec)
specifier|public
name|LazyPersistFileScrubber
parameter_list|(
specifier|final
name|int
name|scrubIntervalSec
parameter_list|)
block|{
name|this
operator|.
name|scrubIntervalSec
operator|=
name|scrubIntervalSec
expr_stmt|;
block|}
comment|/**      * Periodically go over the list of lazyPersist files with missing      * blocks and unlink them from the namespace.      */
DECL|method|clearCorruptLazyPersistFiles ()
specifier|private
name|void
name|clearCorruptLazyPersistFiles
parameter_list|()
throws|throws
name|IOException
block|{
name|BlockStoragePolicy
name|lpPolicy
init|=
name|blockManager
operator|.
name|getStoragePolicy
argument_list|(
literal|"LAZY_PERSIST"
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|BlockCollection
argument_list|>
name|filesToDelete
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|boolean
name|changed
init|=
literal|false
decl_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
specifier|final
name|Iterator
argument_list|<
name|BlockInfo
argument_list|>
name|it
init|=
name|blockManager
operator|.
name|getCorruptReplicaBlockIterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Block
name|b
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|BlockInfo
name|blockInfo
init|=
name|blockManager
operator|.
name|getStoredBlock
argument_list|(
name|b
argument_list|)
decl_stmt|;
name|BlockCollection
name|bc
init|=
name|getBlockCollection
argument_list|(
name|blockInfo
operator|.
name|getBlockCollectionId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|bc
operator|.
name|getStoragePolicyID
argument_list|()
operator|==
name|lpPolicy
operator|.
name|getId
argument_list|()
condition|)
block|{
name|filesToDelete
operator|.
name|add
argument_list|(
name|bc
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|BlockCollection
name|bc
range|:
name|filesToDelete
control|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Removing lazyPersist file "
operator|+
name|bc
operator|.
name|getName
argument_list|()
operator|+
literal|" with no replicas."
argument_list|)
expr_stmt|;
name|BlocksMapUpdateInfo
name|toRemoveBlocks
init|=
name|FSDirDeleteOp
operator|.
name|deleteInternal
argument_list|(
name|FSNamesystem
operator|.
name|this
argument_list|,
name|bc
operator|.
name|getName
argument_list|()
argument_list|,
name|INodesInPath
operator|.
name|fromINode
argument_list|(
operator|(
name|INodeFile
operator|)
name|bc
argument_list|)
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|changed
operator||=
name|toRemoveBlocks
operator|!=
literal|null
expr_stmt|;
if|if
condition|(
name|toRemoveBlocks
operator|!=
literal|null
condition|)
block|{
name|removeBlocks
argument_list|(
name|toRemoveBlocks
argument_list|)
expr_stmt|;
comment|// Incremental deletion of blocks
block|}
block|}
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|changed
condition|)
block|{
name|getEditLog
argument_list|()
operator|.
name|logSync
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
while|while
condition|(
name|fsRunning
operator|&&
name|shouldRun
condition|)
block|{
try|try
block|{
if|if
condition|(
operator|!
name|isInSafeMode
argument_list|()
condition|)
block|{
name|clearCorruptLazyPersistFiles
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|FSNamesystem
operator|.
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|FSNamesystem
operator|.
name|LOG
operator|.
name|debug
argument_list|(
literal|"Namenode is in safemode, skipping scrubbing of corrupted lazy-persist files."
argument_list|)
expr_stmt|;
block|}
block|}
name|Thread
operator|.
name|sleep
argument_list|(
name|scrubIntervalSec
operator|*
literal|1000
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|FSNamesystem
operator|.
name|LOG
operator|.
name|info
argument_list|(
literal|"LazyPersistFileScrubber was interrupted, exiting"
argument_list|)
expr_stmt|;
break|break;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|FSNamesystem
operator|.
name|LOG
operator|.
name|error
argument_list|(
literal|"Ignoring exception in LazyPersistFileScrubber:"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|stop ()
specifier|public
name|void
name|stop
parameter_list|()
block|{
name|shouldRun
operator|=
literal|false
expr_stmt|;
block|}
block|}
DECL|method|getFSImage ()
specifier|public
name|FSImage
name|getFSImage
parameter_list|()
block|{
return|return
name|fsImage
return|;
block|}
DECL|method|getEditLog ()
specifier|public
name|FSEditLog
name|getEditLog
parameter_list|()
block|{
return|return
name|getFSImage
argument_list|()
operator|.
name|getEditLog
argument_list|()
return|;
block|}
annotation|@
name|Metric
argument_list|(
block|{
literal|"MissingBlocks"
block|,
literal|"Number of missing blocks"
block|}
argument_list|)
DECL|method|getMissingBlocksCount ()
specifier|public
name|long
name|getMissingBlocksCount
parameter_list|()
block|{
comment|// not locking
return|return
name|blockManager
operator|.
name|getMissingBlocksCount
argument_list|()
return|;
block|}
annotation|@
name|Metric
argument_list|(
block|{
literal|"MissingReplOneBlocks"
block|,
literal|"Number of missing blocks "
operator|+
literal|"with replication factor 1"
block|}
argument_list|)
DECL|method|getMissingReplOneBlocksCount ()
specifier|public
name|long
name|getMissingReplOneBlocksCount
parameter_list|()
block|{
comment|// not locking
return|return
name|blockManager
operator|.
name|getMissingReplOneBlocksCount
argument_list|()
return|;
block|}
annotation|@
name|Metric
argument_list|(
block|{
literal|"ExpiredHeartbeats"
block|,
literal|"Number of expired heartbeats"
block|}
argument_list|)
DECL|method|getExpiredHeartbeats ()
specifier|public
name|int
name|getExpiredHeartbeats
parameter_list|()
block|{
return|return
name|datanodeStatistics
operator|.
name|getExpiredHeartbeats
argument_list|()
return|;
block|}
annotation|@
name|Metric
argument_list|(
block|{
literal|"TransactionsSinceLastCheckpoint"
block|,
literal|"Number of transactions since last checkpoint"
block|}
argument_list|)
DECL|method|getTransactionsSinceLastCheckpoint ()
specifier|public
name|long
name|getTransactionsSinceLastCheckpoint
parameter_list|()
block|{
return|return
name|getFSImage
argument_list|()
operator|.
name|getLastAppliedOrWrittenTxId
argument_list|()
operator|-
name|getFSImage
argument_list|()
operator|.
name|getStorage
argument_list|()
operator|.
name|getMostRecentCheckpointTxId
argument_list|()
return|;
block|}
annotation|@
name|Metric
argument_list|(
block|{
literal|"TransactionsSinceLastLogRoll"
block|,
literal|"Number of transactions since last edit log roll"
block|}
argument_list|)
DECL|method|getTransactionsSinceLastLogRoll ()
specifier|public
name|long
name|getTransactionsSinceLastLogRoll
parameter_list|()
block|{
if|if
condition|(
name|isInStandbyState
argument_list|()
operator|||
operator|!
name|getEditLog
argument_list|()
operator|.
name|isSegmentOpen
argument_list|()
condition|)
block|{
return|return
literal|0
return|;
block|}
else|else
block|{
return|return
name|getEditLog
argument_list|()
operator|.
name|getLastWrittenTxId
argument_list|()
operator|-
name|getEditLog
argument_list|()
operator|.
name|getCurSegmentTxId
argument_list|()
operator|+
literal|1
return|;
block|}
block|}
annotation|@
name|Metric
argument_list|(
block|{
literal|"LastWrittenTransactionId"
block|,
literal|"Transaction ID written to the edit log"
block|}
argument_list|)
DECL|method|getLastWrittenTransactionId ()
specifier|public
name|long
name|getLastWrittenTransactionId
parameter_list|()
block|{
return|return
name|getEditLog
argument_list|()
operator|.
name|getLastWrittenTxId
argument_list|()
return|;
block|}
annotation|@
name|Metric
argument_list|(
block|{
literal|"LastCheckpointTime"
block|,
literal|"Time in milliseconds since the epoch of the last checkpoint"
block|}
argument_list|)
DECL|method|getLastCheckpointTime ()
specifier|public
name|long
name|getLastCheckpointTime
parameter_list|()
block|{
return|return
name|getFSImage
argument_list|()
operator|.
name|getStorage
argument_list|()
operator|.
name|getMostRecentCheckpointTime
argument_list|()
return|;
block|}
comment|/** @see ClientProtocol#getStats() */
DECL|method|getStats ()
name|long
index|[]
name|getStats
parameter_list|()
block|{
specifier|final
name|long
index|[]
name|stats
init|=
name|datanodeStatistics
operator|.
name|getStats
argument_list|()
decl_stmt|;
name|stats
index|[
name|ClientProtocol
operator|.
name|GET_STATS_UNDER_REPLICATED_IDX
index|]
operator|=
name|getUnderReplicatedBlocks
argument_list|()
expr_stmt|;
name|stats
index|[
name|ClientProtocol
operator|.
name|GET_STATS_CORRUPT_BLOCKS_IDX
index|]
operator|=
name|getCorruptReplicaBlocks
argument_list|()
expr_stmt|;
name|stats
index|[
name|ClientProtocol
operator|.
name|GET_STATS_MISSING_BLOCKS_IDX
index|]
operator|=
name|getMissingBlocksCount
argument_list|()
expr_stmt|;
name|stats
index|[
name|ClientProtocol
operator|.
name|GET_STATS_MISSING_REPL_ONE_BLOCKS_IDX
index|]
operator|=
name|getMissingReplOneBlocksCount
argument_list|()
expr_stmt|;
return|return
name|stats
return|;
block|}
annotation|@
name|Override
comment|// FSNamesystemMBean
annotation|@
name|Metric
argument_list|(
block|{
literal|"CapacityTotal"
block|,
literal|"Total raw capacity of data nodes in bytes"
block|}
argument_list|)
DECL|method|getCapacityTotal ()
specifier|public
name|long
name|getCapacityTotal
parameter_list|()
block|{
return|return
name|datanodeStatistics
operator|.
name|getCapacityTotal
argument_list|()
return|;
block|}
annotation|@
name|Metric
argument_list|(
block|{
literal|"CapacityTotalGB"
block|,
literal|"Total raw capacity of data nodes in GB"
block|}
argument_list|)
DECL|method|getCapacityTotalGB ()
specifier|public
name|float
name|getCapacityTotalGB
parameter_list|()
block|{
return|return
name|DFSUtil
operator|.
name|roundBytesToGB
argument_list|(
name|getCapacityTotal
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
comment|// FSNamesystemMBean
annotation|@
name|Metric
argument_list|(
block|{
literal|"CapacityUsed"
block|,
literal|"Total used capacity across all data nodes in bytes"
block|}
argument_list|)
DECL|method|getCapacityUsed ()
specifier|public
name|long
name|getCapacityUsed
parameter_list|()
block|{
return|return
name|datanodeStatistics
operator|.
name|getCapacityUsed
argument_list|()
return|;
block|}
annotation|@
name|Metric
argument_list|(
block|{
literal|"CapacityUsedGB"
block|,
literal|"Total used capacity across all data nodes in GB"
block|}
argument_list|)
DECL|method|getCapacityUsedGB ()
specifier|public
name|float
name|getCapacityUsedGB
parameter_list|()
block|{
return|return
name|DFSUtil
operator|.
name|roundBytesToGB
argument_list|(
name|getCapacityUsed
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
comment|// FSNamesystemMBean
annotation|@
name|Metric
argument_list|(
block|{
literal|"CapacityRemaining"
block|,
literal|"Remaining capacity in bytes"
block|}
argument_list|)
DECL|method|getCapacityRemaining ()
specifier|public
name|long
name|getCapacityRemaining
parameter_list|()
block|{
return|return
name|datanodeStatistics
operator|.
name|getCapacityRemaining
argument_list|()
return|;
block|}
annotation|@
name|Metric
argument_list|(
block|{
literal|"CapacityRemainingGB"
block|,
literal|"Remaining capacity in GB"
block|}
argument_list|)
DECL|method|getCapacityRemainingGB ()
specifier|public
name|float
name|getCapacityRemainingGB
parameter_list|()
block|{
return|return
name|DFSUtil
operator|.
name|roundBytesToGB
argument_list|(
name|getCapacityRemaining
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Metric
argument_list|(
block|{
literal|"CapacityUsedNonDFS"
block|,
literal|"Total space used by data nodes for non DFS purposes in bytes"
block|}
argument_list|)
DECL|method|getCapacityUsedNonDFS ()
specifier|public
name|long
name|getCapacityUsedNonDFS
parameter_list|()
block|{
return|return
name|datanodeStatistics
operator|.
name|getCapacityUsedNonDFS
argument_list|()
return|;
block|}
comment|/**    * Total number of connections.    */
annotation|@
name|Override
comment|// FSNamesystemMBean
annotation|@
name|Metric
DECL|method|getTotalLoad ()
specifier|public
name|int
name|getTotalLoad
parameter_list|()
block|{
return|return
name|datanodeStatistics
operator|.
name|getXceiverCount
argument_list|()
return|;
block|}
annotation|@
name|Metric
argument_list|(
block|{
literal|"SnapshottableDirectories"
block|,
literal|"Number of snapshottable directories"
block|}
argument_list|)
DECL|method|getNumSnapshottableDirs ()
specifier|public
name|int
name|getNumSnapshottableDirs
parameter_list|()
block|{
return|return
name|this
operator|.
name|snapshotManager
operator|.
name|getNumSnapshottableDirs
argument_list|()
return|;
block|}
annotation|@
name|Metric
argument_list|(
block|{
literal|"Snapshots"
block|,
literal|"The number of snapshots"
block|}
argument_list|)
DECL|method|getNumSnapshots ()
specifier|public
name|int
name|getNumSnapshots
parameter_list|()
block|{
return|return
name|this
operator|.
name|snapshotManager
operator|.
name|getNumSnapshots
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|getSnapshotStats ()
specifier|public
name|String
name|getSnapshotStats
parameter_list|()
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|info
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
argument_list|()
decl_stmt|;
name|info
operator|.
name|put
argument_list|(
literal|"SnapshottableDirectories"
argument_list|,
name|this
operator|.
name|getNumSnapshottableDirs
argument_list|()
argument_list|)
expr_stmt|;
name|info
operator|.
name|put
argument_list|(
literal|"Snapshots"
argument_list|,
name|this
operator|.
name|getNumSnapshots
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|JSON
operator|.
name|toString
argument_list|(
name|info
argument_list|)
return|;
block|}
annotation|@
name|Override
comment|// FSNamesystemMBean
annotation|@
name|Metric
argument_list|(
block|{
literal|"NumEncryptionZones"
block|,
literal|"The number of encryption zones"
block|}
argument_list|)
DECL|method|getNumEncryptionZones ()
specifier|public
name|int
name|getNumEncryptionZones
parameter_list|()
block|{
return|return
name|dir
operator|.
name|ezManager
operator|.
name|getNumEncryptionZones
argument_list|()
return|;
block|}
comment|/**    * Returns the length of the wait Queue for the FSNameSystemLock.    *    * A larger number here indicates lots of threads are waiting for    * FSNameSystemLock.    *    * @return int - Number of Threads waiting to acquire FSNameSystemLock    */
annotation|@
name|Override
annotation|@
name|Metric
argument_list|(
block|{
literal|"LockQueueLength"
block|,
literal|"Number of threads waiting to "
operator|+
literal|"acquire FSNameSystemLock"
block|}
argument_list|)
DECL|method|getFsLockQueueLength ()
specifier|public
name|int
name|getFsLockQueueLength
parameter_list|()
block|{
return|return
name|fsLock
operator|.
name|getQueueLength
argument_list|()
return|;
block|}
DECL|method|getNumberOfDatanodes (DatanodeReportType type)
name|int
name|getNumberOfDatanodes
parameter_list|(
name|DatanodeReportType
name|type
parameter_list|)
block|{
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
return|return
name|getBlockManager
argument_list|()
operator|.
name|getDatanodeManager
argument_list|()
operator|.
name|getDatanodeListForReport
argument_list|(
name|type
argument_list|)
operator|.
name|size
argument_list|()
return|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|datanodeReport (final DatanodeReportType type )
name|DatanodeInfo
index|[]
name|datanodeReport
parameter_list|(
specifier|final
name|DatanodeReportType
name|type
parameter_list|)
throws|throws
name|AccessControlException
throws|,
name|StandbyException
block|{
name|checkSuperuserPrivilege
argument_list|()
expr_stmt|;
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|UNCHECKED
argument_list|)
expr_stmt|;
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|UNCHECKED
argument_list|)
expr_stmt|;
specifier|final
name|DatanodeManager
name|dm
init|=
name|getBlockManager
argument_list|()
operator|.
name|getDatanodeManager
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|results
init|=
name|dm
operator|.
name|getDatanodeListForReport
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|DatanodeInfo
index|[]
name|arr
init|=
operator|new
name|DatanodeInfo
index|[
name|results
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|arr
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|arr
index|[
name|i
index|]
operator|=
operator|new
name|DatanodeInfo
argument_list|(
name|results
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|arr
return|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|getDatanodeStorageReport (final DatanodeReportType type )
name|DatanodeStorageReport
index|[]
name|getDatanodeStorageReport
parameter_list|(
specifier|final
name|DatanodeReportType
name|type
parameter_list|)
throws|throws
name|AccessControlException
throws|,
name|StandbyException
block|{
name|checkSuperuserPrivilege
argument_list|()
expr_stmt|;
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|UNCHECKED
argument_list|)
expr_stmt|;
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|UNCHECKED
argument_list|)
expr_stmt|;
specifier|final
name|DatanodeManager
name|dm
init|=
name|getBlockManager
argument_list|()
operator|.
name|getDatanodeManager
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|datanodes
init|=
name|dm
operator|.
name|getDatanodeListForReport
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|DatanodeStorageReport
index|[]
name|reports
init|=
operator|new
name|DatanodeStorageReport
index|[
name|datanodes
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|reports
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|DatanodeDescriptor
name|d
init|=
name|datanodes
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|reports
index|[
name|i
index|]
operator|=
operator|new
name|DatanodeStorageReport
argument_list|(
operator|new
name|DatanodeInfo
argument_list|(
name|d
argument_list|)
argument_list|,
name|d
operator|.
name|getStorageReports
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|reports
return|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Save namespace image.    * This will save current namespace into fsimage file and empty edits file.    * Requires superuser privilege and safe mode.    */
DECL|method|saveNamespace (final long timeWindow, final long txGap)
name|boolean
name|saveNamespace
parameter_list|(
specifier|final
name|long
name|timeWindow
parameter_list|,
specifier|final
name|long
name|txGap
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|UNCHECKED
argument_list|)
expr_stmt|;
name|checkSuperuserPrivilege
argument_list|()
expr_stmt|;
name|boolean
name|saved
init|=
literal|false
decl_stmt|;
name|cpLock
argument_list|()
expr_stmt|;
comment|// Block if a checkpointing is in progress on standby.
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|UNCHECKED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isInSafeMode
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Safe mode should be turned ON "
operator|+
literal|"in order to create namespace image."
argument_list|)
throw|;
block|}
name|saved
operator|=
name|getFSImage
argument_list|()
operator|.
name|saveNamespace
argument_list|(
name|timeWindow
argument_list|,
name|txGap
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
name|cpUnlock
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|saved
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"New namespace image has been created"
argument_list|)
expr_stmt|;
block|}
return|return
name|saved
return|;
block|}
comment|/**    * Enables/Disables/Checks restoring failed storage replicas if the storage becomes available again.    * Requires superuser privilege.    *     * @throws AccessControlException if superuser privilege is violated.    */
DECL|method|restoreFailedStorage (String arg)
name|boolean
name|restoreFailedStorage
parameter_list|(
name|String
name|arg
parameter_list|)
throws|throws
name|AccessControlException
throws|,
name|StandbyException
block|{
name|checkSuperuserPrivilege
argument_list|()
expr_stmt|;
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|UNCHECKED
argument_list|)
expr_stmt|;
name|cpLock
argument_list|()
expr_stmt|;
comment|// Block if a checkpointing is in progress on standby.
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|UNCHECKED
argument_list|)
expr_stmt|;
comment|// if it is disabled - enable it and vice versa.
if|if
condition|(
name|arg
operator|.
name|equals
argument_list|(
literal|"check"
argument_list|)
condition|)
return|return
name|getFSImage
argument_list|()
operator|.
name|getStorage
argument_list|()
operator|.
name|getRestoreFailedStorage
argument_list|()
return|;
name|boolean
name|val
init|=
name|arg
operator|.
name|equals
argument_list|(
literal|"true"
argument_list|)
decl_stmt|;
comment|// false if not
name|getFSImage
argument_list|()
operator|.
name|getStorage
argument_list|()
operator|.
name|setRestoreFailedStorage
argument_list|(
name|val
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
name|cpUnlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|getStartTime ()
name|Date
name|getStartTime
parameter_list|()
block|{
return|return
operator|new
name|Date
argument_list|(
name|startTime
argument_list|)
return|;
block|}
DECL|method|finalizeUpgrade ()
name|void
name|finalizeUpgrade
parameter_list|()
throws|throws
name|IOException
block|{
name|checkSuperuserPrivilege
argument_list|()
expr_stmt|;
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|UNCHECKED
argument_list|)
expr_stmt|;
name|cpLock
argument_list|()
expr_stmt|;
comment|// Block if a checkpointing is in progress on standby.
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|UNCHECKED
argument_list|)
expr_stmt|;
name|getFSImage
argument_list|()
operator|.
name|finalizeUpgrade
argument_list|(
name|this
operator|.
name|isHaEnabled
argument_list|()
operator|&&
name|inActiveState
argument_list|()
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
name|cpUnlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|refreshNodes ()
name|void
name|refreshNodes
parameter_list|()
throws|throws
name|IOException
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|UNCHECKED
argument_list|)
expr_stmt|;
name|checkSuperuserPrivilege
argument_list|()
expr_stmt|;
name|getBlockManager
argument_list|()
operator|.
name|getDatanodeManager
argument_list|()
operator|.
name|refreshNodes
argument_list|(
operator|new
name|HdfsConfiguration
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|setBalancerBandwidth (long bandwidth)
name|void
name|setBalancerBandwidth
parameter_list|(
name|long
name|bandwidth
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|UNCHECKED
argument_list|)
expr_stmt|;
name|checkSuperuserPrivilege
argument_list|()
expr_stmt|;
name|getBlockManager
argument_list|()
operator|.
name|getDatanodeManager
argument_list|()
operator|.
name|setBalancerBandwidth
argument_list|(
name|bandwidth
argument_list|)
expr_stmt|;
block|}
comment|/**    * SafeModeInfo contains information related to the safe mode.    *<p>    * An instance of {@link SafeModeInfo} is created when the name node    * enters safe mode.    *<p>    * During name node startup {@link SafeModeInfo} counts the number of    *<em>safe blocks</em>, those that have at least the minimal number of    * replicas, and calculates the ratio of safe blocks to the total number    * of blocks in the system, which is the size of blocks in    * {@link FSNamesystem#blockManager}. When the ratio reaches the    * {@link #threshold} it starts the SafeModeMonitor daemon in order    * to monitor whether the safe mode {@link #extension} is passed.    * Then it leaves safe mode and destroys itself.    *<p>    * If safe mode is turned on manually then the number of safe blocks is    * not tracked because the name node is not intended to leave safe mode    * automatically in the case.    *    * @see ClientProtocol#setSafeMode(HdfsConstants.SafeModeAction, boolean)    */
DECL|class|SafeModeInfo
specifier|public
class|class
name|SafeModeInfo
block|{
comment|// configuration fields
comment|/** Safe mode threshold condition %.*/
DECL|field|threshold
specifier|private
specifier|final
name|double
name|threshold
decl_stmt|;
comment|/** Safe mode minimum number of datanodes alive */
DECL|field|datanodeThreshold
specifier|private
specifier|final
name|int
name|datanodeThreshold
decl_stmt|;
comment|/**      * Safe mode extension after the threshold.      * Make it volatile so that getSafeModeTip can read the latest value      * without taking a lock.      */
DECL|field|extension
specifier|private
specifier|volatile
name|int
name|extension
decl_stmt|;
comment|/** Min replication required by safe mode. */
DECL|field|safeReplication
specifier|private
specifier|final
name|int
name|safeReplication
decl_stmt|;
comment|/** threshold for populating needed replication queues */
DECL|field|replQueueThreshold
specifier|private
specifier|final
name|double
name|replQueueThreshold
decl_stmt|;
comment|// internal fields
comment|/** Time when threshold was reached.      *<br> -1 safe mode is off      *<br> 0 safe mode is on, and threshold is not reached yet      *<br>>0 safe mode is on, but we are in extension period       */
DECL|field|reached
specifier|private
name|long
name|reached
init|=
operator|-
literal|1
decl_stmt|;
DECL|field|reachedTimestamp
specifier|private
name|long
name|reachedTimestamp
init|=
operator|-
literal|1
decl_stmt|;
comment|/** Total number of blocks. */
DECL|field|blockTotal
name|int
name|blockTotal
decl_stmt|;
comment|/** Number of safe blocks. */
DECL|field|blockSafe
name|int
name|blockSafe
decl_stmt|;
comment|/** Number of blocks needed to satisfy safe mode threshold condition */
DECL|field|blockThreshold
specifier|private
name|int
name|blockThreshold
decl_stmt|;
comment|/** Number of blocks needed before populating replication queues */
DECL|field|blockReplQueueThreshold
specifier|private
name|int
name|blockReplQueueThreshold
decl_stmt|;
comment|/** time of the last status printout */
DECL|field|lastStatusReport
specifier|private
name|long
name|lastStatusReport
init|=
literal|0
decl_stmt|;
comment|/**      * Was safemode entered automatically because available resources were low.      * Make it volatile so that getSafeModeTip can read the latest value      * without taking a lock.      */
DECL|field|resourcesLow
specifier|private
specifier|volatile
name|boolean
name|resourcesLow
init|=
literal|false
decl_stmt|;
comment|/** Should safemode adjust its block totals as blocks come in */
DECL|field|shouldIncrementallyTrackBlocks
specifier|private
name|boolean
name|shouldIncrementallyTrackBlocks
init|=
literal|false
decl_stmt|;
comment|/** counter for tracking startup progress of reported blocks */
DECL|field|awaitingReportedBlocksCounter
specifier|private
name|Counter
name|awaitingReportedBlocksCounter
decl_stmt|;
comment|/**      * Creates SafeModeInfo when the name node enters      * automatic safe mode at startup.      *        * @param conf configuration      */
DECL|method|SafeModeInfo (Configuration conf)
specifier|private
name|SafeModeInfo
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
name|this
operator|.
name|threshold
operator|=
name|conf
operator|.
name|getFloat
argument_list|(
name|DFS_NAMENODE_SAFEMODE_THRESHOLD_PCT_KEY
argument_list|,
name|DFS_NAMENODE_SAFEMODE_THRESHOLD_PCT_DEFAULT
argument_list|)
expr_stmt|;
if|if
condition|(
name|threshold
operator|>
literal|1.0
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"The threshold value should't be greater than 1, threshold: "
operator|+
name|threshold
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|datanodeThreshold
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|DFS_NAMENODE_SAFEMODE_MIN_DATANODES_KEY
argument_list|,
name|DFS_NAMENODE_SAFEMODE_MIN_DATANODES_DEFAULT
argument_list|)
expr_stmt|;
name|this
operator|.
name|extension
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|DFS_NAMENODE_SAFEMODE_EXTENSION_KEY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|int
name|minReplication
init|=
name|conf
operator|.
name|getInt
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_REPLICATION_MIN_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_REPLICATION_MIN_DEFAULT
argument_list|)
decl_stmt|;
comment|// DFS_NAMENODE_SAFEMODE_REPLICATION_MIN_KEY is an expert level setting,
comment|// setting this lower than the min replication is not recommended
comment|// and/or dangerous for production setups.
comment|// When it's unset, safeReplication will use dfs.namenode.replication.min
name|this
operator|.
name|safeReplication
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_SAFEMODE_REPLICATION_MIN_KEY
argument_list|,
name|minReplication
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|DFS_NAMENODE_SAFEMODE_THRESHOLD_PCT_KEY
operator|+
literal|" = "
operator|+
name|threshold
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|DFS_NAMENODE_SAFEMODE_MIN_DATANODES_KEY
operator|+
literal|" = "
operator|+
name|datanodeThreshold
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|DFS_NAMENODE_SAFEMODE_EXTENSION_KEY
operator|+
literal|"     = "
operator|+
name|extension
argument_list|)
expr_stmt|;
comment|// default to safe mode threshold (i.e., don't populate queues before leaving safe mode)
name|this
operator|.
name|replQueueThreshold
operator|=
name|conf
operator|.
name|getFloat
argument_list|(
name|DFS_NAMENODE_REPL_QUEUE_THRESHOLD_PCT_KEY
argument_list|,
operator|(
name|float
operator|)
name|threshold
argument_list|)
expr_stmt|;
name|this
operator|.
name|blockTotal
operator|=
literal|0
expr_stmt|;
name|this
operator|.
name|blockSafe
operator|=
literal|0
expr_stmt|;
block|}
comment|/**      * In the HA case, the StandbyNode can be in safemode while the namespace      * is modified by the edit log tailer. In this case, the number of total      * blocks changes as edits are processed (eg blocks are added and deleted).      * However, we don't want to do the incremental tracking during the      * startup-time loading process -- only once the initial total has been      * set after the image has been loaded.      */
DECL|method|shouldIncrementallyTrackBlocks ()
specifier|private
name|boolean
name|shouldIncrementallyTrackBlocks
parameter_list|()
block|{
return|return
name|shouldIncrementallyTrackBlocks
return|;
block|}
comment|/**      * Creates SafeModeInfo when safe mode is entered manually, or because      * available resources are low.      *      * The {@link #threshold} is set to 1.5 so that it could never be reached.      * {@link #blockTotal} is set to -1 to indicate that safe mode is manual.      *       * @see SafeModeInfo      */
DECL|method|SafeModeInfo (boolean resourcesLow)
specifier|private
name|SafeModeInfo
parameter_list|(
name|boolean
name|resourcesLow
parameter_list|)
block|{
name|this
operator|.
name|threshold
operator|=
literal|1.5f
expr_stmt|;
comment|// this threshold can never be reached
name|this
operator|.
name|datanodeThreshold
operator|=
name|Integer
operator|.
name|MAX_VALUE
expr_stmt|;
name|this
operator|.
name|extension
operator|=
name|Integer
operator|.
name|MAX_VALUE
expr_stmt|;
name|this
operator|.
name|safeReplication
operator|=
name|Short
operator|.
name|MAX_VALUE
operator|+
literal|1
expr_stmt|;
comment|// more than maxReplication
name|this
operator|.
name|replQueueThreshold
operator|=
literal|1.5f
expr_stmt|;
comment|// can never be reached
name|this
operator|.
name|blockTotal
operator|=
operator|-
literal|1
expr_stmt|;
name|this
operator|.
name|blockSafe
operator|=
operator|-
literal|1
expr_stmt|;
name|this
operator|.
name|resourcesLow
operator|=
name|resourcesLow
expr_stmt|;
name|enter
argument_list|()
expr_stmt|;
name|reportStatus
argument_list|(
literal|"STATE* Safe mode is ON."
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**      * Check if safe mode is on.      * @return true if in safe mode      */
DECL|method|isOn ()
specifier|private
specifier|synchronized
name|boolean
name|isOn
parameter_list|()
block|{
name|doConsistencyCheck
argument_list|()
expr_stmt|;
return|return
name|this
operator|.
name|reached
operator|>=
literal|0
return|;
block|}
comment|/**      * Enter safe mode.      */
DECL|method|enter ()
specifier|private
name|void
name|enter
parameter_list|()
block|{
name|this
operator|.
name|reached
operator|=
literal|0
expr_stmt|;
name|this
operator|.
name|reachedTimestamp
operator|=
literal|0
expr_stmt|;
block|}
comment|/**      * Leave safe mode.      *<p>      * Check for invalid, under-& over-replicated blocks in the end of startup.      */
DECL|method|leave ()
specifier|private
specifier|synchronized
name|void
name|leave
parameter_list|()
block|{
comment|// if not done yet, initialize replication queues.
comment|// In the standby, do not populate repl queues
if|if
condition|(
operator|!
name|blockManager
operator|.
name|isPopulatingReplQueues
argument_list|()
operator|&&
name|blockManager
operator|.
name|shouldPopulateReplQueues
argument_list|()
condition|)
block|{
name|blockManager
operator|.
name|initializeReplQueues
argument_list|()
expr_stmt|;
block|}
name|long
name|timeInSafemode
init|=
name|now
argument_list|()
operator|-
name|startTime
decl_stmt|;
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|info
argument_list|(
literal|"STATE* Leaving safe mode after "
operator|+
name|timeInSafemode
operator|/
literal|1000
operator|+
literal|" secs"
argument_list|)
expr_stmt|;
name|NameNode
operator|.
name|getNameNodeMetrics
argument_list|()
operator|.
name|setSafeModeTime
argument_list|(
operator|(
name|int
operator|)
name|timeInSafemode
argument_list|)
expr_stmt|;
comment|//Log the following only once (when transitioning from ON -> OFF)
if|if
condition|(
name|reached
operator|>=
literal|0
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|info
argument_list|(
literal|"STATE* Safe mode is OFF"
argument_list|)
expr_stmt|;
block|}
name|reached
operator|=
operator|-
literal|1
expr_stmt|;
name|reachedTimestamp
operator|=
operator|-
literal|1
expr_stmt|;
name|safeMode
operator|=
literal|null
expr_stmt|;
specifier|final
name|NetworkTopology
name|nt
init|=
name|blockManager
operator|.
name|getDatanodeManager
argument_list|()
operator|.
name|getNetworkTopology
argument_list|()
decl_stmt|;
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|info
argument_list|(
literal|"STATE* Network topology has "
operator|+
name|nt
operator|.
name|getNumOfRacks
argument_list|()
operator|+
literal|" racks and "
operator|+
name|nt
operator|.
name|getNumOfLeaves
argument_list|()
operator|+
literal|" datanodes"
argument_list|)
expr_stmt|;
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|info
argument_list|(
literal|"STATE* UnderReplicatedBlocks has "
operator|+
name|blockManager
operator|.
name|numOfUnderReplicatedBlocks
argument_list|()
operator|+
literal|" blocks"
argument_list|)
expr_stmt|;
name|startSecretManagerIfNecessary
argument_list|()
expr_stmt|;
comment|// If startup has not yet completed, end safemode phase.
name|StartupProgress
name|prog
init|=
name|NameNode
operator|.
name|getStartupProgress
argument_list|()
decl_stmt|;
if|if
condition|(
name|prog
operator|.
name|getStatus
argument_list|(
name|Phase
operator|.
name|SAFEMODE
argument_list|)
operator|!=
name|Status
operator|.
name|COMPLETE
condition|)
block|{
name|prog
operator|.
name|endStep
argument_list|(
name|Phase
operator|.
name|SAFEMODE
argument_list|,
name|STEP_AWAITING_REPORTED_BLOCKS
argument_list|)
expr_stmt|;
name|prog
operator|.
name|endPhase
argument_list|(
name|Phase
operator|.
name|SAFEMODE
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Check whether we have reached the threshold for       * initializing replication queues.      */
DECL|method|canInitializeReplQueues ()
specifier|private
specifier|synchronized
name|boolean
name|canInitializeReplQueues
parameter_list|()
block|{
return|return
name|blockManager
operator|.
name|shouldPopulateReplQueues
argument_list|()
operator|&&
name|blockSafe
operator|>=
name|blockReplQueueThreshold
return|;
block|}
comment|/**       * Safe mode can be turned off iff       * the threshold is reached and       * the extension time have passed.      * @return true if can leave or false otherwise.      */
DECL|method|canLeave ()
specifier|private
specifier|synchronized
name|boolean
name|canLeave
parameter_list|()
block|{
if|if
condition|(
name|reached
operator|==
literal|0
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|monotonicNow
argument_list|()
operator|-
name|reached
operator|<
name|extension
condition|)
block|{
name|reportStatus
argument_list|(
literal|"STATE* Safe mode ON, in safe mode extension."
argument_list|,
literal|false
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|needEnter
argument_list|()
condition|)
block|{
name|reportStatus
argument_list|(
literal|"STATE* Safe mode ON, thresholds not met."
argument_list|,
literal|false
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
comment|/**       * There is no need to enter safe mode       * if DFS is empty or {@link #threshold} == 0      */
DECL|method|needEnter ()
specifier|private
name|boolean
name|needEnter
parameter_list|()
block|{
return|return
operator|(
name|threshold
operator|!=
literal|0
operator|&&
name|blockSafe
operator|<
name|blockThreshold
operator|)
operator|||
operator|(
name|datanodeThreshold
operator|!=
literal|0
operator|&&
name|getNumLiveDataNodes
argument_list|()
operator|<
name|datanodeThreshold
operator|)
operator|||
operator|(
operator|!
name|nameNodeHasResourcesAvailable
argument_list|()
operator|)
return|;
block|}
comment|/**      * Check and trigger safe mode if needed.       */
DECL|method|checkMode ()
specifier|private
name|void
name|checkMode
parameter_list|()
block|{
comment|// Have to have write-lock since leaving safemode initializes
comment|// repl queues, which requires write lock
assert|assert
name|hasWriteLock
argument_list|()
assert|;
if|if
condition|(
name|inTransitionToActive
argument_list|()
condition|)
block|{
return|return;
block|}
comment|// if smmthread is already running, the block threshold must have been
comment|// reached before, there is no need to enter the safe mode again
if|if
condition|(
name|smmthread
operator|==
literal|null
operator|&&
name|needEnter
argument_list|()
condition|)
block|{
name|enter
argument_list|()
expr_stmt|;
comment|// check if we are ready to initialize replication queues
if|if
condition|(
name|canInitializeReplQueues
argument_list|()
operator|&&
operator|!
name|blockManager
operator|.
name|isPopulatingReplQueues
argument_list|()
operator|&&
operator|!
name|haEnabled
condition|)
block|{
name|blockManager
operator|.
name|initializeReplQueues
argument_list|()
expr_stmt|;
block|}
name|reportStatus
argument_list|(
literal|"STATE* Safe mode ON."
argument_list|,
literal|false
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// the threshold is reached or was reached before
if|if
condition|(
operator|!
name|isOn
argument_list|()
operator|||
comment|// safe mode is off
name|extension
operator|<=
literal|0
operator|||
name|threshold
operator|<=
literal|0
condition|)
block|{
comment|// don't need to wait
name|this
operator|.
name|leave
argument_list|()
expr_stmt|;
comment|// leave safe mode
return|return;
block|}
if|if
condition|(
name|reached
operator|>
literal|0
condition|)
block|{
comment|// threshold has already been reached before
name|reportStatus
argument_list|(
literal|"STATE* Safe mode ON."
argument_list|,
literal|false
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// start monitor
name|reached
operator|=
name|monotonicNow
argument_list|()
expr_stmt|;
name|reachedTimestamp
operator|=
name|now
argument_list|()
expr_stmt|;
if|if
condition|(
name|smmthread
operator|==
literal|null
condition|)
block|{
name|smmthread
operator|=
operator|new
name|Daemon
argument_list|(
operator|new
name|SafeModeMonitor
argument_list|()
argument_list|)
expr_stmt|;
name|smmthread
operator|.
name|start
argument_list|()
expr_stmt|;
name|reportStatus
argument_list|(
literal|"STATE* Safe mode extension entered."
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|// check if we are ready to initialize replication queues
if|if
condition|(
name|canInitializeReplQueues
argument_list|()
operator|&&
operator|!
name|blockManager
operator|.
name|isPopulatingReplQueues
argument_list|()
operator|&&
operator|!
name|haEnabled
condition|)
block|{
name|blockManager
operator|.
name|initializeReplQueues
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Set total number of blocks.      */
DECL|method|setBlockTotal (int total)
specifier|private
specifier|synchronized
name|void
name|setBlockTotal
parameter_list|(
name|int
name|total
parameter_list|)
block|{
name|this
operator|.
name|blockTotal
operator|=
name|total
expr_stmt|;
name|this
operator|.
name|blockThreshold
operator|=
call|(
name|int
call|)
argument_list|(
name|blockTotal
operator|*
name|threshold
argument_list|)
expr_stmt|;
name|this
operator|.
name|blockReplQueueThreshold
operator|=
call|(
name|int
call|)
argument_list|(
name|blockTotal
operator|*
name|replQueueThreshold
argument_list|)
expr_stmt|;
if|if
condition|(
name|haEnabled
condition|)
block|{
comment|// After we initialize the block count, any further namespace
comment|// modifications done while in safe mode need to keep track
comment|// of the number of total blocks in the system.
name|this
operator|.
name|shouldIncrementallyTrackBlocks
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|blockSafe
operator|<
literal|0
condition|)
name|this
operator|.
name|blockSafe
operator|=
literal|0
expr_stmt|;
name|checkMode
argument_list|()
expr_stmt|;
block|}
comment|/**      * Increment number of safe blocks if current block has       * reached minimal replication.      * @param replication current replication       */
DECL|method|incrementSafeBlockCount (short replication)
specifier|private
specifier|synchronized
name|void
name|incrementSafeBlockCount
parameter_list|(
name|short
name|replication
parameter_list|)
block|{
if|if
condition|(
name|replication
operator|==
name|safeReplication
condition|)
block|{
name|this
operator|.
name|blockSafe
operator|++
expr_stmt|;
comment|// Report startup progress only if we haven't completed startup yet.
name|StartupProgress
name|prog
init|=
name|NameNode
operator|.
name|getStartupProgress
argument_list|()
decl_stmt|;
if|if
condition|(
name|prog
operator|.
name|getStatus
argument_list|(
name|Phase
operator|.
name|SAFEMODE
argument_list|)
operator|!=
name|Status
operator|.
name|COMPLETE
condition|)
block|{
if|if
condition|(
name|this
operator|.
name|awaitingReportedBlocksCounter
operator|==
literal|null
condition|)
block|{
name|this
operator|.
name|awaitingReportedBlocksCounter
operator|=
name|prog
operator|.
name|getCounter
argument_list|(
name|Phase
operator|.
name|SAFEMODE
argument_list|,
name|STEP_AWAITING_REPORTED_BLOCKS
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|awaitingReportedBlocksCounter
operator|.
name|increment
argument_list|()
expr_stmt|;
block|}
name|checkMode
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Decrement number of safe blocks if current block has       * fallen below minimal replication.      * @param replication current replication       */
DECL|method|decrementSafeBlockCount (short replication)
specifier|private
specifier|synchronized
name|void
name|decrementSafeBlockCount
parameter_list|(
name|short
name|replication
parameter_list|)
block|{
if|if
condition|(
name|replication
operator|==
name|safeReplication
operator|-
literal|1
condition|)
block|{
name|this
operator|.
name|blockSafe
operator|--
expr_stmt|;
comment|//blockSafe is set to -1 in manual / low resources safemode
assert|assert
name|blockSafe
operator|>=
literal|0
operator|||
name|isManual
argument_list|()
operator|||
name|areResourcesLow
argument_list|()
assert|;
name|checkMode
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Check if safe mode was entered manually      */
DECL|method|isManual ()
specifier|private
name|boolean
name|isManual
parameter_list|()
block|{
return|return
name|extension
operator|==
name|Integer
operator|.
name|MAX_VALUE
return|;
block|}
comment|/**      * Set manual safe mode.      */
DECL|method|setManual ()
specifier|private
specifier|synchronized
name|void
name|setManual
parameter_list|()
block|{
name|extension
operator|=
name|Integer
operator|.
name|MAX_VALUE
expr_stmt|;
block|}
comment|/**      * Check if safe mode was entered due to resources being low.      */
DECL|method|areResourcesLow ()
specifier|private
name|boolean
name|areResourcesLow
parameter_list|()
block|{
return|return
name|resourcesLow
return|;
block|}
comment|/**      * Set that resources are low for this instance of safe mode.      */
DECL|method|setResourcesLow ()
specifier|private
name|void
name|setResourcesLow
parameter_list|()
block|{
name|resourcesLow
operator|=
literal|true
expr_stmt|;
block|}
comment|/**      * A tip on how safe mode is to be turned off: manually or automatically.      */
DECL|method|getTurnOffTip ()
name|String
name|getTurnOffTip
parameter_list|()
block|{
if|if
condition|(
operator|!
name|isOn
argument_list|()
condition|)
block|{
return|return
literal|"Safe mode is OFF."
return|;
block|}
comment|//Manual OR low-resource safemode. (Admin intervention required)
name|String
name|adminMsg
init|=
literal|"It was turned on manually. "
decl_stmt|;
if|if
condition|(
name|areResourcesLow
argument_list|()
condition|)
block|{
name|adminMsg
operator|=
literal|"Resources are low on NN. Please add or free up more "
operator|+
literal|"resources then turn off safe mode manually. NOTE:  If you turn off"
operator|+
literal|" safe mode before adding resources, "
operator|+
literal|"the NN will immediately return to safe mode. "
expr_stmt|;
block|}
if|if
condition|(
name|isManual
argument_list|()
operator|||
name|areResourcesLow
argument_list|()
condition|)
block|{
return|return
name|adminMsg
operator|+
literal|"Use \"hdfs dfsadmin -safemode leave\" to turn safe mode off."
return|;
block|}
name|boolean
name|thresholdsMet
init|=
literal|true
decl_stmt|;
name|int
name|numLive
init|=
name|getNumLiveDataNodes
argument_list|()
decl_stmt|;
name|String
name|msg
init|=
literal|""
decl_stmt|;
if|if
condition|(
name|blockSafe
operator|<
name|blockThreshold
condition|)
block|{
name|msg
operator|+=
name|String
operator|.
name|format
argument_list|(
literal|"The reported blocks %d needs additional %d"
operator|+
literal|" blocks to reach the threshold %.4f of total blocks %d.%n"
argument_list|,
name|blockSafe
argument_list|,
operator|(
name|blockThreshold
operator|-
name|blockSafe
operator|)
argument_list|,
name|threshold
argument_list|,
name|blockTotal
argument_list|)
expr_stmt|;
name|thresholdsMet
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|msg
operator|+=
name|String
operator|.
name|format
argument_list|(
literal|"The reported blocks %d has reached the threshold"
operator|+
literal|" %.4f of total blocks %d. "
argument_list|,
name|blockSafe
argument_list|,
name|threshold
argument_list|,
name|blockTotal
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|numLive
operator|<
name|datanodeThreshold
condition|)
block|{
name|msg
operator|+=
name|String
operator|.
name|format
argument_list|(
literal|"The number of live datanodes %d needs an additional %d live "
operator|+
literal|"datanodes to reach the minimum number %d.%n"
argument_list|,
name|numLive
argument_list|,
operator|(
name|datanodeThreshold
operator|-
name|numLive
operator|)
argument_list|,
name|datanodeThreshold
argument_list|)
expr_stmt|;
name|thresholdsMet
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|msg
operator|+=
name|String
operator|.
name|format
argument_list|(
literal|"The number of live datanodes %d has reached "
operator|+
literal|"the minimum number %d. "
argument_list|,
name|numLive
argument_list|,
name|datanodeThreshold
argument_list|)
expr_stmt|;
block|}
name|msg
operator|+=
operator|(
name|reached
operator|>
literal|0
operator|)
condition|?
literal|"In safe mode extension. "
else|:
literal|""
expr_stmt|;
name|msg
operator|+=
literal|"Safe mode will be turned off automatically "
expr_stmt|;
if|if
condition|(
operator|!
name|thresholdsMet
condition|)
block|{
name|msg
operator|+=
literal|"once the thresholds have been reached."
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|reached
operator|+
name|extension
operator|-
name|monotonicNow
argument_list|()
operator|>
literal|0
condition|)
block|{
name|msg
operator|+=
operator|(
literal|"in "
operator|+
operator|(
name|reached
operator|+
name|extension
operator|-
name|monotonicNow
argument_list|()
operator|)
operator|/
literal|1000
operator|+
literal|" seconds."
operator|)
expr_stmt|;
block|}
else|else
block|{
name|msg
operator|+=
literal|"soon."
expr_stmt|;
block|}
return|return
name|msg
return|;
block|}
comment|/**      * Print status every 20 seconds.      */
DECL|method|reportStatus (String msg, boolean rightNow)
specifier|private
name|void
name|reportStatus
parameter_list|(
name|String
name|msg
parameter_list|,
name|boolean
name|rightNow
parameter_list|)
block|{
name|long
name|curTime
init|=
name|now
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|rightNow
operator|&&
operator|(
name|curTime
operator|-
name|lastStatusReport
operator|<
literal|20
operator|*
literal|1000
operator|)
condition|)
return|return;
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|info
argument_list|(
name|msg
operator|+
literal|" \n"
operator|+
name|getTurnOffTip
argument_list|()
argument_list|)
expr_stmt|;
name|lastStatusReport
operator|=
name|curTime
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|String
name|resText
init|=
literal|"Current safe blocks = "
operator|+
name|blockSafe
operator|+
literal|". Target blocks = "
operator|+
name|blockThreshold
operator|+
literal|" for threshold = %"
operator|+
name|threshold
operator|+
literal|". Minimal replication = "
operator|+
name|safeReplication
operator|+
literal|"."
decl_stmt|;
if|if
condition|(
name|reached
operator|>
literal|0
condition|)
name|resText
operator|+=
literal|" Threshold was reached "
operator|+
operator|new
name|Date
argument_list|(
name|reachedTimestamp
argument_list|)
operator|+
literal|"."
expr_stmt|;
return|return
name|resText
return|;
block|}
comment|/**      * Checks consistency of the class state.      * This is costly so only runs if asserts are enabled.      */
DECL|method|doConsistencyCheck ()
specifier|private
name|void
name|doConsistencyCheck
parameter_list|()
block|{
name|boolean
name|assertsOn
init|=
literal|false
decl_stmt|;
assert|assert
name|assertsOn
operator|=
literal|true
assert|;
comment|// set to true if asserts are on
if|if
condition|(
operator|!
name|assertsOn
condition|)
return|return;
if|if
condition|(
name|blockTotal
operator|==
operator|-
literal|1
operator|&&
name|blockSafe
operator|==
operator|-
literal|1
condition|)
block|{
return|return;
comment|// manual safe mode
block|}
name|int
name|activeBlocks
init|=
name|blockManager
operator|.
name|getActiveBlockCount
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|blockTotal
operator|!=
name|activeBlocks
operator|)
operator|&&
operator|!
operator|(
name|blockSafe
operator|>=
literal|0
operator|&&
name|blockSafe
operator|<=
name|blockTotal
operator|)
condition|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|" SafeMode: Inconsistent filesystem state: "
operator|+
literal|"SafeMode data: blockTotal="
operator|+
name|blockTotal
operator|+
literal|" blockSafe="
operator|+
name|blockSafe
operator|+
literal|"; "
operator|+
literal|"BlockManager data: active="
operator|+
name|activeBlocks
argument_list|)
throw|;
block|}
block|}
DECL|method|adjustBlockTotals (int deltaSafe, int deltaTotal)
specifier|private
specifier|synchronized
name|void
name|adjustBlockTotals
parameter_list|(
name|int
name|deltaSafe
parameter_list|,
name|int
name|deltaTotal
parameter_list|)
block|{
if|if
condition|(
operator|!
name|shouldIncrementallyTrackBlocks
condition|)
block|{
return|return;
block|}
assert|assert
name|haEnabled
assert|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Adjusting block totals from "
operator|+
name|blockSafe
operator|+
literal|"/"
operator|+
name|blockTotal
operator|+
literal|" to "
operator|+
operator|(
name|blockSafe
operator|+
name|deltaSafe
operator|)
operator|+
literal|"/"
operator|+
operator|(
name|blockTotal
operator|+
name|deltaTotal
operator|)
argument_list|)
expr_stmt|;
block|}
assert|assert
name|blockSafe
operator|+
name|deltaSafe
operator|>=
literal|0
operator|:
literal|"Can't reduce blockSafe "
operator|+
name|blockSafe
operator|+
literal|" by "
operator|+
name|deltaSafe
operator|+
literal|": would be negative"
assert|;
assert|assert
name|blockTotal
operator|+
name|deltaTotal
operator|>=
literal|0
operator|:
literal|"Can't reduce blockTotal "
operator|+
name|blockTotal
operator|+
literal|" by "
operator|+
name|deltaTotal
operator|+
literal|": would be negative"
assert|;
name|blockSafe
operator|+=
name|deltaSafe
expr_stmt|;
name|setBlockTotal
argument_list|(
name|blockTotal
operator|+
name|deltaTotal
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Periodically check whether it is time to leave safe mode.    * This thread starts when the threshold level is reached.    *    */
DECL|class|SafeModeMonitor
class|class
name|SafeModeMonitor
implements|implements
name|Runnable
block|{
comment|/** interval in msec for checking safe mode: {@value} */
DECL|field|recheckInterval
specifier|private
specifier|static
specifier|final
name|long
name|recheckInterval
init|=
literal|1000
decl_stmt|;
comment|/**      */
annotation|@
name|Override
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
while|while
condition|(
name|fsRunning
condition|)
block|{
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
name|safeMode
operator|==
literal|null
condition|)
block|{
comment|// Not in safe mode.
break|break;
block|}
if|if
condition|(
name|safeMode
operator|.
name|canLeave
argument_list|()
condition|)
block|{
comment|// Leave safe mode.
name|safeMode
operator|.
name|leave
argument_list|()
expr_stmt|;
name|smmthread
operator|=
literal|null
expr_stmt|;
break|break;
block|}
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|recheckInterval
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
comment|// Ignored
block|}
block|}
if|if
condition|(
operator|!
name|fsRunning
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"NameNode is being shutdown, exit SafeModeMonitor thread"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|setSafeMode (SafeModeAction action)
name|boolean
name|setSafeMode
parameter_list|(
name|SafeModeAction
name|action
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|action
operator|!=
name|SafeModeAction
operator|.
name|SAFEMODE_GET
condition|)
block|{
name|checkSuperuserPrivilege
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|action
condition|)
block|{
case|case
name|SAFEMODE_LEAVE
case|:
comment|// leave safe mode
name|leaveSafeMode
argument_list|()
expr_stmt|;
break|break;
case|case
name|SAFEMODE_ENTER
case|:
comment|// enter safe mode
name|enterSafeMode
argument_list|(
literal|false
argument_list|)
expr_stmt|;
break|break;
default|default:
name|LOG
operator|.
name|error
argument_list|(
literal|"Unexpected safe mode action"
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|isInSafeMode
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|checkSafeMode ()
specifier|public
name|void
name|checkSafeMode
parameter_list|()
block|{
comment|// safeMode is volatile, and may be set to null at any time
name|SafeModeInfo
name|safeMode
init|=
name|this
operator|.
name|safeMode
decl_stmt|;
if|if
condition|(
name|safeMode
operator|!=
literal|null
condition|)
block|{
name|safeMode
operator|.
name|checkMode
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|isInSafeMode ()
specifier|public
name|boolean
name|isInSafeMode
parameter_list|()
block|{
comment|// safeMode is volatile, and may be set to null at any time
name|SafeModeInfo
name|safeMode
init|=
name|this
operator|.
name|safeMode
decl_stmt|;
if|if
condition|(
name|safeMode
operator|==
literal|null
condition|)
return|return
literal|false
return|;
return|return
name|safeMode
operator|.
name|isOn
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|isInStartupSafeMode ()
specifier|public
name|boolean
name|isInStartupSafeMode
parameter_list|()
block|{
comment|// safeMode is volatile, and may be set to null at any time
name|SafeModeInfo
name|safeMode
init|=
name|this
operator|.
name|safeMode
decl_stmt|;
if|if
condition|(
name|safeMode
operator|==
literal|null
condition|)
return|return
literal|false
return|;
comment|// If the NN is in safemode, and not due to manual / low resources, we
comment|// assume it must be because of startup. If the NN had low resources during
comment|// startup, we assume it came out of startup safemode and it is now in low
comment|// resources safemode
return|return
operator|!
name|safeMode
operator|.
name|isManual
argument_list|()
operator|&&
operator|!
name|safeMode
operator|.
name|areResourcesLow
argument_list|()
operator|&&
name|safeMode
operator|.
name|isOn
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|incrementSafeBlockCount (int replication)
specifier|public
name|void
name|incrementSafeBlockCount
parameter_list|(
name|int
name|replication
parameter_list|)
block|{
comment|// safeMode is volatile, and may be set to null at any time
name|SafeModeInfo
name|safeMode
init|=
name|this
operator|.
name|safeMode
decl_stmt|;
if|if
condition|(
name|safeMode
operator|==
literal|null
condition|)
return|return;
name|safeMode
operator|.
name|incrementSafeBlockCount
argument_list|(
operator|(
name|short
operator|)
name|replication
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|decrementSafeBlockCount (BlockInfo b)
specifier|public
name|void
name|decrementSafeBlockCount
parameter_list|(
name|BlockInfo
name|b
parameter_list|)
block|{
comment|// safeMode is volatile, and may be set to null at any time
name|SafeModeInfo
name|safeMode
init|=
name|this
operator|.
name|safeMode
decl_stmt|;
if|if
condition|(
name|safeMode
operator|==
literal|null
condition|)
comment|// mostly true
return|return;
name|BlockInfo
name|storedBlock
init|=
name|getStoredBlock
argument_list|(
name|b
argument_list|)
decl_stmt|;
if|if
condition|(
name|storedBlock
operator|.
name|isComplete
argument_list|()
condition|)
block|{
name|safeMode
operator|.
name|decrementSafeBlockCount
argument_list|(
operator|(
name|short
operator|)
name|blockManager
operator|.
name|countNodes
argument_list|(
name|b
argument_list|)
operator|.
name|liveReplicas
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Adjust the total number of blocks safe and expected during safe mode.    * If safe mode is not currently on, this is a no-op.    * @param deltaSafe the change in number of safe blocks    * @param deltaTotal the change i nnumber of total blocks expected    */
annotation|@
name|Override
DECL|method|adjustSafeModeBlockTotals (int deltaSafe, int deltaTotal)
specifier|public
name|void
name|adjustSafeModeBlockTotals
parameter_list|(
name|int
name|deltaSafe
parameter_list|,
name|int
name|deltaTotal
parameter_list|)
block|{
comment|// safeMode is volatile, and may be set to null at any time
name|SafeModeInfo
name|safeMode
init|=
name|this
operator|.
name|safeMode
decl_stmt|;
if|if
condition|(
name|safeMode
operator|==
literal|null
condition|)
return|return;
name|safeMode
operator|.
name|adjustBlockTotals
argument_list|(
name|deltaSafe
argument_list|,
name|deltaTotal
argument_list|)
expr_stmt|;
block|}
comment|/**    * Set the total number of blocks in the system.     */
DECL|method|setBlockTotal (long completeBlocksTotal)
specifier|public
name|void
name|setBlockTotal
parameter_list|(
name|long
name|completeBlocksTotal
parameter_list|)
block|{
comment|// safeMode is volatile, and may be set to null at any time
name|SafeModeInfo
name|safeMode
init|=
name|this
operator|.
name|safeMode
decl_stmt|;
if|if
condition|(
name|safeMode
operator|==
literal|null
condition|)
return|return;
name|safeMode
operator|.
name|setBlockTotal
argument_list|(
operator|(
name|int
operator|)
name|completeBlocksTotal
argument_list|)
expr_stmt|;
block|}
comment|/**    * Get the total number of blocks in the system.     */
annotation|@
name|Override
comment|// FSNamesystemMBean
annotation|@
name|Metric
DECL|method|getBlocksTotal ()
specifier|public
name|long
name|getBlocksTotal
parameter_list|()
block|{
return|return
name|blockManager
operator|.
name|getTotalBlocks
argument_list|()
return|;
block|}
comment|/**    * Get the number of files under construction in the system.    */
annotation|@
name|Metric
argument_list|(
block|{
literal|"NumFilesUnderConstruction"
block|,
literal|"Number of files under construction"
block|}
argument_list|)
DECL|method|getNumFilesUnderConstruction ()
specifier|public
name|long
name|getNumFilesUnderConstruction
parameter_list|()
block|{
return|return
name|leaseManager
operator|.
name|countPath
argument_list|()
return|;
block|}
comment|/**    * Get the total number of active clients holding lease in the system.    */
annotation|@
name|Metric
argument_list|(
block|{
literal|"NumActiveClients"
block|,
literal|"Number of active clients holding lease"
block|}
argument_list|)
DECL|method|getNumActiveClients ()
specifier|public
name|long
name|getNumActiveClients
parameter_list|()
block|{
return|return
name|leaseManager
operator|.
name|countLease
argument_list|()
return|;
block|}
comment|/**    * Get the total number of COMPLETE blocks in the system.    * For safe mode only complete blocks are counted.    * This is invoked only during NN startup and checkpointing.    */
DECL|method|getCompleteBlocksTotal ()
specifier|public
name|long
name|getCompleteBlocksTotal
parameter_list|()
block|{
comment|// Calculate number of blocks under construction
name|long
name|numUCBlocks
init|=
literal|0
decl_stmt|;
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
name|numUCBlocks
operator|=
name|leaseManager
operator|.
name|getNumUnderConstructionBlocks
argument_list|()
expr_stmt|;
return|return
name|getBlocksTotal
argument_list|()
operator|-
name|numUCBlocks
return|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Enter safe mode. If resourcesLow is false, then we assume it is manual    * @throws IOException    */
DECL|method|enterSafeMode (boolean resourcesLow)
name|void
name|enterSafeMode
parameter_list|(
name|boolean
name|resourcesLow
parameter_list|)
throws|throws
name|IOException
block|{
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
comment|// Stop the secret manager, since rolling the master key would
comment|// try to write to the edit log
name|stopSecretManager
argument_list|()
expr_stmt|;
comment|// Ensure that any concurrent operations have been fully synced
comment|// before entering safe mode. This ensures that the FSImage
comment|// is entirely stable on disk as soon as we're in safe mode.
name|boolean
name|isEditlogOpenForWrite
init|=
name|getEditLog
argument_list|()
operator|.
name|isOpenForWrite
argument_list|()
decl_stmt|;
comment|// Before Editlog is in OpenForWrite mode, editLogStream will be null. So,
comment|// logSyncAll call can be called only when Edlitlog is in OpenForWrite mode
if|if
condition|(
name|isEditlogOpenForWrite
condition|)
block|{
name|getEditLog
argument_list|()
operator|.
name|logSyncAll
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|isInSafeMode
argument_list|()
condition|)
block|{
name|safeMode
operator|=
operator|new
name|SafeModeInfo
argument_list|(
name|resourcesLow
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|resourcesLow
condition|)
block|{
name|safeMode
operator|.
name|setResourcesLow
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|safeMode
operator|.
name|setManual
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|isEditlogOpenForWrite
condition|)
block|{
name|getEditLog
argument_list|()
operator|.
name|logSyncAll
argument_list|()
expr_stmt|;
block|}
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|info
argument_list|(
literal|"STATE* Safe mode is ON"
operator|+
name|safeMode
operator|.
name|getTurnOffTip
argument_list|()
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Leave safe mode.    */
DECL|method|leaveSafeMode ()
name|void
name|leaveSafeMode
parameter_list|()
block|{
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
operator|!
name|isInSafeMode
argument_list|()
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|info
argument_list|(
literal|"STATE* Safe mode is already OFF"
argument_list|)
expr_stmt|;
return|return;
block|}
name|safeMode
operator|.
name|leave
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|getSafeModeTip ()
name|String
name|getSafeModeTip
parameter_list|()
block|{
comment|// There is no need to take readLock.
comment|// Don't use isInSafeMode as this.safeMode might be set to null.
comment|// after isInSafeMode returns.
name|boolean
name|inSafeMode
decl_stmt|;
name|SafeModeInfo
name|safeMode
init|=
name|this
operator|.
name|safeMode
decl_stmt|;
if|if
condition|(
name|safeMode
operator|==
literal|null
condition|)
block|{
name|inSafeMode
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|inSafeMode
operator|=
name|safeMode
operator|.
name|isOn
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|inSafeMode
condition|)
block|{
return|return
literal|""
return|;
block|}
else|else
block|{
return|return
name|safeMode
operator|.
name|getTurnOffTip
argument_list|()
return|;
block|}
block|}
DECL|method|rollEditLog ()
name|CheckpointSignature
name|rollEditLog
parameter_list|()
throws|throws
name|IOException
block|{
name|checkSuperuserPrivilege
argument_list|()
expr_stmt|;
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|JOURNAL
argument_list|)
expr_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|JOURNAL
argument_list|)
expr_stmt|;
name|checkNameNodeSafeMode
argument_list|(
literal|"Log not rolled"
argument_list|)
expr_stmt|;
if|if
condition|(
name|Server
operator|.
name|isRpcInvocation
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Roll Edit Log from "
operator|+
name|Server
operator|.
name|getRemoteAddress
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|getFSImage
argument_list|()
operator|.
name|rollEditLog
argument_list|(
name|getEffectiveLayoutVersion
argument_list|()
argument_list|)
return|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|startCheckpoint (NamenodeRegistration backupNode, NamenodeRegistration activeNamenode)
name|NamenodeCommand
name|startCheckpoint
parameter_list|(
name|NamenodeRegistration
name|backupNode
parameter_list|,
name|NamenodeRegistration
name|activeNamenode
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|CHECKPOINT
argument_list|)
expr_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|CHECKPOINT
argument_list|)
expr_stmt|;
name|checkNameNodeSafeMode
argument_list|(
literal|"Checkpoint not started"
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Start checkpoint for "
operator|+
name|backupNode
operator|.
name|getAddress
argument_list|()
argument_list|)
expr_stmt|;
name|NamenodeCommand
name|cmd
init|=
name|getFSImage
argument_list|()
operator|.
name|startCheckpoint
argument_list|(
name|backupNode
argument_list|,
name|activeNamenode
argument_list|,
name|getEffectiveLayoutVersion
argument_list|()
argument_list|)
decl_stmt|;
name|getEditLog
argument_list|()
operator|.
name|logSync
argument_list|()
expr_stmt|;
return|return
name|cmd
return|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|processIncrementalBlockReport (final DatanodeID nodeID, final StorageReceivedDeletedBlocks srdb)
specifier|public
name|void
name|processIncrementalBlockReport
parameter_list|(
specifier|final
name|DatanodeID
name|nodeID
parameter_list|,
specifier|final
name|StorageReceivedDeletedBlocks
name|srdb
parameter_list|)
throws|throws
name|IOException
block|{
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|blockManager
operator|.
name|processIncrementalBlockReport
argument_list|(
name|nodeID
argument_list|,
name|srdb
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|endCheckpoint (NamenodeRegistration registration, CheckpointSignature sig)
name|void
name|endCheckpoint
parameter_list|(
name|NamenodeRegistration
name|registration
parameter_list|,
name|CheckpointSignature
name|sig
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|CHECKPOINT
argument_list|)
expr_stmt|;
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|CHECKPOINT
argument_list|)
expr_stmt|;
name|checkNameNodeSafeMode
argument_list|(
literal|"Checkpoint not ended"
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"End checkpoint for "
operator|+
name|registration
operator|.
name|getAddress
argument_list|()
argument_list|)
expr_stmt|;
name|getFSImage
argument_list|()
operator|.
name|endCheckpoint
argument_list|(
name|sig
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|createFsOwnerPermissions (FsPermission permission)
name|PermissionStatus
name|createFsOwnerPermissions
parameter_list|(
name|FsPermission
name|permission
parameter_list|)
block|{
return|return
operator|new
name|PermissionStatus
argument_list|(
name|fsOwner
operator|.
name|getShortUserName
argument_list|()
argument_list|,
name|supergroup
argument_list|,
name|permission
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|checkSuperuserPrivilege ()
specifier|public
name|void
name|checkSuperuserPrivilege
parameter_list|()
throws|throws
name|AccessControlException
block|{
if|if
condition|(
name|isPermissionEnabled
condition|)
block|{
name|FSPermissionChecker
name|pc
init|=
name|getPermissionChecker
argument_list|()
decl_stmt|;
name|pc
operator|.
name|checkSuperuserPrivilege
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Check to see if we have exceeded the limit on the number    * of inodes.    */
DECL|method|checkFsObjectLimit ()
name|void
name|checkFsObjectLimit
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|maxFsObjects
operator|!=
literal|0
operator|&&
name|maxFsObjects
operator|<=
name|dir
operator|.
name|totalInodes
argument_list|()
operator|+
name|getBlocksTotal
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Exceeded the configured number of objects "
operator|+
name|maxFsObjects
operator|+
literal|" in the filesystem."
argument_list|)
throw|;
block|}
block|}
comment|/**    * Get the total number of objects in the system.     */
annotation|@
name|Override
comment|// FSNamesystemMBean
DECL|method|getMaxObjects ()
specifier|public
name|long
name|getMaxObjects
parameter_list|()
block|{
return|return
name|maxFsObjects
return|;
block|}
annotation|@
name|Override
comment|// FSNamesystemMBean
annotation|@
name|Metric
DECL|method|getFilesTotal ()
specifier|public
name|long
name|getFilesTotal
parameter_list|()
block|{
comment|// There is no need to take fSNamesystem's lock as
comment|// FSDirectory has its own lock.
return|return
name|this
operator|.
name|dir
operator|.
name|totalInodes
argument_list|()
return|;
block|}
annotation|@
name|Override
comment|// FSNamesystemMBean
annotation|@
name|Metric
DECL|method|getPendingReplicationBlocks ()
specifier|public
name|long
name|getPendingReplicationBlocks
parameter_list|()
block|{
return|return
name|blockManager
operator|.
name|getPendingReplicationBlocksCount
argument_list|()
return|;
block|}
annotation|@
name|Override
comment|// FSNamesystemMBean
annotation|@
name|Metric
DECL|method|getUnderReplicatedBlocks ()
specifier|public
name|long
name|getUnderReplicatedBlocks
parameter_list|()
block|{
return|return
name|blockManager
operator|.
name|getUnderReplicatedBlocksCount
argument_list|()
return|;
block|}
comment|/** Returns number of blocks with corrupt replicas */
annotation|@
name|Metric
argument_list|(
block|{
literal|"CorruptBlocks"
block|,
literal|"Number of blocks with corrupt replicas"
block|}
argument_list|)
DECL|method|getCorruptReplicaBlocks ()
specifier|public
name|long
name|getCorruptReplicaBlocks
parameter_list|()
block|{
return|return
name|blockManager
operator|.
name|getCorruptReplicaBlocksCount
argument_list|()
return|;
block|}
annotation|@
name|Override
comment|// FSNamesystemMBean
annotation|@
name|Metric
DECL|method|getScheduledReplicationBlocks ()
specifier|public
name|long
name|getScheduledReplicationBlocks
parameter_list|()
block|{
return|return
name|blockManager
operator|.
name|getScheduledReplicationBlocksCount
argument_list|()
return|;
block|}
annotation|@
name|Override
annotation|@
name|Metric
DECL|method|getPendingDeletionBlocks ()
specifier|public
name|long
name|getPendingDeletionBlocks
parameter_list|()
block|{
return|return
name|blockManager
operator|.
name|getPendingDeletionBlocksCount
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|getBlockDeletionStartTime ()
specifier|public
name|long
name|getBlockDeletionStartTime
parameter_list|()
block|{
return|return
name|startTime
operator|+
name|blockManager
operator|.
name|getStartupDelayBlockDeletionInMs
argument_list|()
return|;
block|}
annotation|@
name|Metric
DECL|method|getExcessBlocks ()
specifier|public
name|long
name|getExcessBlocks
parameter_list|()
block|{
return|return
name|blockManager
operator|.
name|getExcessBlocksCount
argument_list|()
return|;
block|}
comment|// HA-only metric
annotation|@
name|Metric
DECL|method|getPostponedMisreplicatedBlocks ()
specifier|public
name|long
name|getPostponedMisreplicatedBlocks
parameter_list|()
block|{
return|return
name|blockManager
operator|.
name|getPostponedMisreplicatedBlocksCount
argument_list|()
return|;
block|}
comment|// HA-only metric
annotation|@
name|Metric
DECL|method|getPendingDataNodeMessageCount ()
specifier|public
name|int
name|getPendingDataNodeMessageCount
parameter_list|()
block|{
return|return
name|blockManager
operator|.
name|getPendingDataNodeMessageCount
argument_list|()
return|;
block|}
comment|// HA-only metric
annotation|@
name|Metric
DECL|method|getHAState ()
specifier|public
name|String
name|getHAState
parameter_list|()
block|{
return|return
name|haContext
operator|.
name|getState
argument_list|()
operator|.
name|toString
argument_list|()
return|;
block|}
comment|// HA-only metric
annotation|@
name|Metric
DECL|method|getMillisSinceLastLoadedEdits ()
specifier|public
name|long
name|getMillisSinceLastLoadedEdits
parameter_list|()
block|{
if|if
condition|(
name|isInStandbyState
argument_list|()
operator|&&
name|editLogTailer
operator|!=
literal|null
condition|)
block|{
return|return
name|monotonicNow
argument_list|()
operator|-
name|editLogTailer
operator|.
name|getLastLoadTimeMs
argument_list|()
return|;
block|}
else|else
block|{
return|return
literal|0
return|;
block|}
block|}
annotation|@
name|Metric
DECL|method|getBlockCapacity ()
specifier|public
name|int
name|getBlockCapacity
parameter_list|()
block|{
return|return
name|blockManager
operator|.
name|getCapacity
argument_list|()
return|;
block|}
annotation|@
name|Override
comment|// FSNamesystemMBean
DECL|method|getFSState ()
specifier|public
name|String
name|getFSState
parameter_list|()
block|{
return|return
name|isInSafeMode
argument_list|()
condition|?
literal|"safeMode"
else|:
literal|"Operational"
return|;
block|}
DECL|field|mbeanName
specifier|private
name|ObjectName
name|mbeanName
decl_stmt|;
DECL|field|mxbeanName
specifier|private
name|ObjectName
name|mxbeanName
decl_stmt|;
comment|/**    * Register the FSNamesystem MBean using the name    *        "hadoop:service=NameNode,name=FSNamesystemState"    */
DECL|method|registerMBean ()
specifier|private
name|void
name|registerMBean
parameter_list|()
block|{
comment|// We can only implement one MXBean interface, so we keep the old one.
try|try
block|{
name|StandardMBean
name|bean
init|=
operator|new
name|StandardMBean
argument_list|(
name|this
argument_list|,
name|FSNamesystemMBean
operator|.
name|class
argument_list|)
decl_stmt|;
name|mbeanName
operator|=
name|MBeans
operator|.
name|register
argument_list|(
literal|"NameNode"
argument_list|,
literal|"FSNamesystemState"
argument_list|,
name|bean
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NotCompliantMBeanException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Bad MBean setup"
argument_list|,
name|e
argument_list|)
throw|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Registered FSNamesystemState MBean"
argument_list|)
expr_stmt|;
block|}
comment|/**    * shutdown FSNamesystem    */
DECL|method|shutdown ()
name|void
name|shutdown
parameter_list|()
block|{
if|if
condition|(
name|snapshotManager
operator|!=
literal|null
condition|)
block|{
name|snapshotManager
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|mbeanName
operator|!=
literal|null
condition|)
block|{
name|MBeans
operator|.
name|unregister
argument_list|(
name|mbeanName
argument_list|)
expr_stmt|;
name|mbeanName
operator|=
literal|null
expr_stmt|;
block|}
if|if
condition|(
name|mxbeanName
operator|!=
literal|null
condition|)
block|{
name|MBeans
operator|.
name|unregister
argument_list|(
name|mxbeanName
argument_list|)
expr_stmt|;
name|mxbeanName
operator|=
literal|null
expr_stmt|;
block|}
if|if
condition|(
name|dir
operator|!=
literal|null
condition|)
block|{
name|dir
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|blockManager
operator|!=
literal|null
condition|)
block|{
name|blockManager
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
comment|// FSNamesystemMBean
DECL|method|getNumLiveDataNodes ()
specifier|public
name|int
name|getNumLiveDataNodes
parameter_list|()
block|{
return|return
name|getBlockManager
argument_list|()
operator|.
name|getDatanodeManager
argument_list|()
operator|.
name|getNumLiveDataNodes
argument_list|()
return|;
block|}
annotation|@
name|Override
comment|// FSNamesystemMBean
DECL|method|getNumDeadDataNodes ()
specifier|public
name|int
name|getNumDeadDataNodes
parameter_list|()
block|{
return|return
name|getBlockManager
argument_list|()
operator|.
name|getDatanodeManager
argument_list|()
operator|.
name|getNumDeadDataNodes
argument_list|()
return|;
block|}
annotation|@
name|Override
comment|// FSNamesystemMBean
DECL|method|getNumDecomLiveDataNodes ()
specifier|public
name|int
name|getNumDecomLiveDataNodes
parameter_list|()
block|{
specifier|final
name|List
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|live
init|=
operator|new
name|ArrayList
argument_list|<
name|DatanodeDescriptor
argument_list|>
argument_list|()
decl_stmt|;
name|getBlockManager
argument_list|()
operator|.
name|getDatanodeManager
argument_list|()
operator|.
name|fetchDatanodes
argument_list|(
name|live
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|int
name|liveDecommissioned
init|=
literal|0
decl_stmt|;
for|for
control|(
name|DatanodeDescriptor
name|node
range|:
name|live
control|)
block|{
name|liveDecommissioned
operator|+=
name|node
operator|.
name|isDecommissioned
argument_list|()
condition|?
literal|1
else|:
literal|0
expr_stmt|;
block|}
return|return
name|liveDecommissioned
return|;
block|}
annotation|@
name|Override
comment|// FSNamesystemMBean
DECL|method|getNumDecomDeadDataNodes ()
specifier|public
name|int
name|getNumDecomDeadDataNodes
parameter_list|()
block|{
specifier|final
name|List
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|dead
init|=
operator|new
name|ArrayList
argument_list|<
name|DatanodeDescriptor
argument_list|>
argument_list|()
decl_stmt|;
name|getBlockManager
argument_list|()
operator|.
name|getDatanodeManager
argument_list|()
operator|.
name|fetchDatanodes
argument_list|(
literal|null
argument_list|,
name|dead
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|int
name|deadDecommissioned
init|=
literal|0
decl_stmt|;
for|for
control|(
name|DatanodeDescriptor
name|node
range|:
name|dead
control|)
block|{
name|deadDecommissioned
operator|+=
name|node
operator|.
name|isDecommissioned
argument_list|()
condition|?
literal|1
else|:
literal|0
expr_stmt|;
block|}
return|return
name|deadDecommissioned
return|;
block|}
annotation|@
name|Override
comment|// FSNamesystemMBean
DECL|method|getVolumeFailuresTotal ()
specifier|public
name|int
name|getVolumeFailuresTotal
parameter_list|()
block|{
name|List
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|live
init|=
operator|new
name|ArrayList
argument_list|<
name|DatanodeDescriptor
argument_list|>
argument_list|()
decl_stmt|;
name|getBlockManager
argument_list|()
operator|.
name|getDatanodeManager
argument_list|()
operator|.
name|fetchDatanodes
argument_list|(
name|live
argument_list|,
literal|null
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|int
name|volumeFailuresTotal
init|=
literal|0
decl_stmt|;
for|for
control|(
name|DatanodeDescriptor
name|node
range|:
name|live
control|)
block|{
name|volumeFailuresTotal
operator|+=
name|node
operator|.
name|getVolumeFailures
argument_list|()
expr_stmt|;
block|}
return|return
name|volumeFailuresTotal
return|;
block|}
annotation|@
name|Override
comment|// FSNamesystemMBean
DECL|method|getEstimatedCapacityLostTotal ()
specifier|public
name|long
name|getEstimatedCapacityLostTotal
parameter_list|()
block|{
name|List
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|live
init|=
operator|new
name|ArrayList
argument_list|<
name|DatanodeDescriptor
argument_list|>
argument_list|()
decl_stmt|;
name|getBlockManager
argument_list|()
operator|.
name|getDatanodeManager
argument_list|()
operator|.
name|fetchDatanodes
argument_list|(
name|live
argument_list|,
literal|null
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|long
name|estimatedCapacityLostTotal
init|=
literal|0
decl_stmt|;
for|for
control|(
name|DatanodeDescriptor
name|node
range|:
name|live
control|)
block|{
name|VolumeFailureSummary
name|volumeFailureSummary
init|=
name|node
operator|.
name|getVolumeFailureSummary
argument_list|()
decl_stmt|;
if|if
condition|(
name|volumeFailureSummary
operator|!=
literal|null
condition|)
block|{
name|estimatedCapacityLostTotal
operator|+=
name|volumeFailureSummary
operator|.
name|getEstimatedCapacityLostTotal
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|estimatedCapacityLostTotal
return|;
block|}
annotation|@
name|Override
comment|// FSNamesystemMBean
DECL|method|getNumDecommissioningDataNodes ()
specifier|public
name|int
name|getNumDecommissioningDataNodes
parameter_list|()
block|{
return|return
name|getBlockManager
argument_list|()
operator|.
name|getDatanodeManager
argument_list|()
operator|.
name|getDecommissioningNodes
argument_list|()
operator|.
name|size
argument_list|()
return|;
block|}
annotation|@
name|Override
comment|// FSNamesystemMBean
annotation|@
name|Metric
argument_list|(
block|{
literal|"StaleDataNodes"
block|,
literal|"Number of datanodes marked stale due to delayed heartbeat"
block|}
argument_list|)
DECL|method|getNumStaleDataNodes ()
specifier|public
name|int
name|getNumStaleDataNodes
parameter_list|()
block|{
return|return
name|getBlockManager
argument_list|()
operator|.
name|getDatanodeManager
argument_list|()
operator|.
name|getNumStaleNodes
argument_list|()
return|;
block|}
comment|/**    * Storages are marked as "content stale" after NN restart or fails over and    * before NN receives the first Heartbeat followed by the first Blockreport.    */
annotation|@
name|Override
comment|// FSNamesystemMBean
DECL|method|getNumStaleStorages ()
specifier|public
name|int
name|getNumStaleStorages
parameter_list|()
block|{
return|return
name|getBlockManager
argument_list|()
operator|.
name|getDatanodeManager
argument_list|()
operator|.
name|getNumStaleStorages
argument_list|()
return|;
block|}
annotation|@
name|Override
comment|// FSNamesystemMBean
DECL|method|getTopUserOpCounts ()
specifier|public
name|String
name|getTopUserOpCounts
parameter_list|()
block|{
if|if
condition|(
operator|!
name|topConf
operator|.
name|isEnabled
condition|)
block|{
return|return
literal|null
return|;
block|}
name|Date
name|now
init|=
operator|new
name|Date
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RollingWindowManager
operator|.
name|TopWindow
argument_list|>
name|topWindows
init|=
name|topMetrics
operator|.
name|getTopWindows
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|topMap
init|=
operator|new
name|TreeMap
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
argument_list|()
decl_stmt|;
name|topMap
operator|.
name|put
argument_list|(
literal|"windows"
argument_list|,
name|topWindows
argument_list|)
expr_stmt|;
name|topMap
operator|.
name|put
argument_list|(
literal|"timestamp"
argument_list|,
name|DFSUtil
operator|.
name|dateToIso8601String
argument_list|(
name|now
argument_list|)
argument_list|)
expr_stmt|;
name|ObjectMapper
name|mapper
init|=
operator|new
name|ObjectMapper
argument_list|()
decl_stmt|;
try|try
block|{
return|return
name|mapper
operator|.
name|writeValueAsString
argument_list|(
name|topMap
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to fetch TopUser metrics"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
comment|/**    * Increments, logs and then returns the stamp    */
DECL|method|nextGenerationStamp (boolean legacyBlock)
name|long
name|nextGenerationStamp
parameter_list|(
name|boolean
name|legacyBlock
parameter_list|)
throws|throws
name|IOException
throws|,
name|SafeModeException
block|{
assert|assert
name|hasWriteLock
argument_list|()
assert|;
name|checkNameNodeSafeMode
argument_list|(
literal|"Cannot get next generation stamp"
argument_list|)
expr_stmt|;
name|long
name|gs
init|=
name|blockIdManager
operator|.
name|nextGenerationStamp
argument_list|(
name|legacyBlock
argument_list|)
decl_stmt|;
if|if
condition|(
name|legacyBlock
condition|)
block|{
name|getEditLog
argument_list|()
operator|.
name|logGenerationStampV1
argument_list|(
name|gs
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|getEditLog
argument_list|()
operator|.
name|logGenerationStampV2
argument_list|(
name|gs
argument_list|)
expr_stmt|;
block|}
comment|// NB: callers sync the log
return|return
name|gs
return|;
block|}
comment|/**    * Increments, logs and then returns the block ID    */
DECL|method|nextBlockId ()
specifier|private
name|long
name|nextBlockId
parameter_list|()
throws|throws
name|IOException
block|{
assert|assert
name|hasWriteLock
argument_list|()
assert|;
name|checkNameNodeSafeMode
argument_list|(
literal|"Cannot get next block ID"
argument_list|)
expr_stmt|;
specifier|final
name|long
name|blockId
init|=
name|blockIdManager
operator|.
name|nextBlockId
argument_list|()
decl_stmt|;
name|getEditLog
argument_list|()
operator|.
name|logAllocateBlockId
argument_list|(
name|blockId
argument_list|)
expr_stmt|;
comment|// NB: callers sync the log
return|return
name|blockId
return|;
block|}
DECL|method|isFileDeleted (INodeFile file)
specifier|private
name|boolean
name|isFileDeleted
parameter_list|(
name|INodeFile
name|file
parameter_list|)
block|{
comment|// Not in the inodeMap or in the snapshot but marked deleted.
if|if
condition|(
name|dir
operator|.
name|getInode
argument_list|(
name|file
operator|.
name|getId
argument_list|()
argument_list|)
operator|==
literal|null
condition|)
block|{
return|return
literal|true
return|;
block|}
comment|// look at the path hierarchy to see if one parent is deleted by recursive
comment|// deletion
name|INode
name|tmpChild
init|=
name|file
decl_stmt|;
name|INodeDirectory
name|tmpParent
init|=
name|file
operator|.
name|getParent
argument_list|()
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
if|if
condition|(
name|tmpParent
operator|==
literal|null
condition|)
block|{
return|return
literal|true
return|;
block|}
name|INode
name|childINode
init|=
name|tmpParent
operator|.
name|getChild
argument_list|(
name|tmpChild
operator|.
name|getLocalNameBytes
argument_list|()
argument_list|,
name|Snapshot
operator|.
name|CURRENT_STATE_ID
argument_list|)
decl_stmt|;
if|if
condition|(
name|childINode
operator|==
literal|null
operator|||
operator|!
name|childINode
operator|.
name|equals
argument_list|(
name|tmpChild
argument_list|)
condition|)
block|{
comment|// a newly created INode with the same name as an already deleted one
comment|// would be a different INode than the deleted one
return|return
literal|true
return|;
block|}
if|if
condition|(
name|tmpParent
operator|.
name|isRoot
argument_list|()
condition|)
block|{
break|break;
block|}
name|tmpChild
operator|=
name|tmpParent
expr_stmt|;
name|tmpParent
operator|=
name|tmpParent
operator|.
name|getParent
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|file
operator|.
name|isWithSnapshot
argument_list|()
operator|&&
name|file
operator|.
name|getFileWithSnapshotFeature
argument_list|()
operator|.
name|isCurrentFileDeleted
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
DECL|method|checkUCBlock (ExtendedBlock block, String clientName)
specifier|private
name|INodeFile
name|checkUCBlock
parameter_list|(
name|ExtendedBlock
name|block
parameter_list|,
name|String
name|clientName
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|hasWriteLock
argument_list|()
assert|;
name|checkNameNodeSafeMode
argument_list|(
literal|"Cannot get a new generation stamp and an "
operator|+
literal|"access token for block "
operator|+
name|block
argument_list|)
expr_stmt|;
comment|// check stored block state
name|BlockInfo
name|storedBlock
init|=
name|getStoredBlock
argument_list|(
name|ExtendedBlock
operator|.
name|getLocalBlock
argument_list|(
name|block
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|storedBlock
operator|==
literal|null
operator|||
name|storedBlock
operator|.
name|getBlockUCState
argument_list|()
operator|!=
name|BlockUCState
operator|.
name|UNDER_CONSTRUCTION
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|block
operator|+
literal|" does not exist or is not under Construction"
operator|+
name|storedBlock
argument_list|)
throw|;
block|}
comment|// check file inode
name|long
name|bcId
init|=
name|storedBlock
operator|.
name|getBlockCollectionId
argument_list|()
decl_stmt|;
specifier|final
name|INodeFile
name|file
init|=
operator|(
operator|(
name|INode
operator|)
name|getBlockCollection
argument_list|(
name|bcId
argument_list|)
operator|)
operator|.
name|asFile
argument_list|()
decl_stmt|;
if|if
condition|(
name|file
operator|==
literal|null
operator|||
operator|!
name|file
operator|.
name|isUnderConstruction
argument_list|()
operator|||
name|isFileDeleted
argument_list|(
name|file
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"The file "
operator|+
name|storedBlock
operator|+
literal|" belonged to does not exist or it is not under construction."
argument_list|)
throw|;
block|}
comment|// check lease
if|if
condition|(
name|clientName
operator|==
literal|null
operator|||
operator|!
name|clientName
operator|.
name|equals
argument_list|(
name|file
operator|.
name|getFileUnderConstructionFeature
argument_list|()
operator|.
name|getClientName
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|LeaseExpiredException
argument_list|(
literal|"Lease mismatch: "
operator|+
name|block
operator|+
literal|" is accessed by a non lease holder "
operator|+
name|clientName
argument_list|)
throw|;
block|}
return|return
name|file
return|;
block|}
comment|/**    * Client is reporting some bad block locations.    */
DECL|method|reportBadBlocks (LocatedBlock[] blocks)
name|void
name|reportBadBlocks
parameter_list|(
name|LocatedBlock
index|[]
name|blocks
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|info
argument_list|(
literal|"*DIR* reportBadBlocks"
argument_list|)
expr_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|blocks
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|ExtendedBlock
name|blk
init|=
name|blocks
index|[
name|i
index|]
operator|.
name|getBlock
argument_list|()
decl_stmt|;
name|DatanodeInfo
index|[]
name|nodes
init|=
name|blocks
index|[
name|i
index|]
operator|.
name|getLocations
argument_list|()
decl_stmt|;
name|String
index|[]
name|storageIDs
init|=
name|blocks
index|[
name|i
index|]
operator|.
name|getStorageIDs
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|nodes
operator|.
name|length
condition|;
name|j
operator|++
control|)
block|{
name|blockManager
operator|.
name|findAndMarkBlockAsCorrupt
argument_list|(
name|blk
argument_list|,
name|nodes
index|[
name|j
index|]
argument_list|,
name|storageIDs
operator|==
literal|null
condition|?
literal|null
else|:
name|storageIDs
index|[
name|j
index|]
argument_list|,
literal|"client machine reported it"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Get a new generation stamp together with an access token for     * a block under construction    *     * This method is called for recovering a failed pipeline or setting up    * a pipeline to append to a block.    *     * @param block a block    * @param clientName the name of a client    * @return a located block with a new generation stamp and an access token    * @throws IOException if any error occurs    */
DECL|method|updateBlockForPipeline (ExtendedBlock block, String clientName)
name|LocatedBlock
name|updateBlockForPipeline
parameter_list|(
name|ExtendedBlock
name|block
parameter_list|,
name|String
name|clientName
parameter_list|)
throws|throws
name|IOException
block|{
name|LocatedBlock
name|locatedBlock
decl_stmt|;
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
comment|// check vadility of parameters
name|checkUCBlock
argument_list|(
name|block
argument_list|,
name|clientName
argument_list|)
expr_stmt|;
comment|// get a new generation stamp and an access token
name|block
operator|.
name|setGenerationStamp
argument_list|(
name|nextGenerationStamp
argument_list|(
name|blockIdManager
operator|.
name|isLegacyBlock
argument_list|(
name|block
operator|.
name|getLocalBlock
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|locatedBlock
operator|=
operator|new
name|LocatedBlock
argument_list|(
name|block
argument_list|,
operator|new
name|DatanodeInfo
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|blockManager
operator|.
name|setBlockToken
argument_list|(
name|locatedBlock
argument_list|,
name|BlockTokenIdentifier
operator|.
name|AccessMode
operator|.
name|WRITE
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
comment|// Ensure we record the new generation stamp
name|getEditLog
argument_list|()
operator|.
name|logSync
argument_list|()
expr_stmt|;
return|return
name|locatedBlock
return|;
block|}
comment|/**    * Update a pipeline for a block under construction    *     * @param clientName the name of the client    * @param oldBlock and old block    * @param newBlock a new block with a new generation stamp and length    * @param newNodes datanodes in the pipeline    * @throws IOException if any error occurs    */
DECL|method|updatePipeline ( String clientName, ExtendedBlock oldBlock, ExtendedBlock newBlock, DatanodeID[] newNodes, String[] newStorageIDs, boolean logRetryCache)
name|void
name|updatePipeline
parameter_list|(
name|String
name|clientName
parameter_list|,
name|ExtendedBlock
name|oldBlock
parameter_list|,
name|ExtendedBlock
name|newBlock
parameter_list|,
name|DatanodeID
index|[]
name|newNodes
parameter_list|,
name|String
index|[]
name|newStorageIDs
parameter_list|,
name|boolean
name|logRetryCache
parameter_list|)
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"updatePipeline("
operator|+
name|oldBlock
operator|.
name|getLocalBlock
argument_list|()
operator|+
literal|", newGS="
operator|+
name|newBlock
operator|.
name|getGenerationStamp
argument_list|()
operator|+
literal|", newLength="
operator|+
name|newBlock
operator|.
name|getNumBytes
argument_list|()
operator|+
literal|", newNodes="
operator|+
name|Arrays
operator|.
name|asList
argument_list|(
name|newNodes
argument_list|)
operator|+
literal|", client="
operator|+
name|clientName
operator|+
literal|")"
argument_list|)
expr_stmt|;
name|waitForLoadingFSImage
argument_list|()
expr_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|checkNameNodeSafeMode
argument_list|(
literal|"Pipeline not updated"
argument_list|)
expr_stmt|;
assert|assert
name|newBlock
operator|.
name|getBlockId
argument_list|()
operator|==
name|oldBlock
operator|.
name|getBlockId
argument_list|()
operator|:
name|newBlock
operator|+
literal|" and "
operator|+
name|oldBlock
operator|+
literal|" has different block identifier"
assert|;
name|updatePipelineInternal
argument_list|(
name|clientName
argument_list|,
name|oldBlock
argument_list|,
name|newBlock
argument_list|,
name|newNodes
argument_list|,
name|newStorageIDs
argument_list|,
name|logRetryCache
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
name|getEditLog
argument_list|()
operator|.
name|logSync
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"updatePipeline("
operator|+
name|oldBlock
operator|.
name|getLocalBlock
argument_list|()
operator|+
literal|" => "
operator|+
name|newBlock
operator|.
name|getLocalBlock
argument_list|()
operator|+
literal|") success"
argument_list|)
expr_stmt|;
block|}
DECL|method|updatePipelineInternal (String clientName, ExtendedBlock oldBlock, ExtendedBlock newBlock, DatanodeID[] newNodes, String[] newStorageIDs, boolean logRetryCache)
specifier|private
name|void
name|updatePipelineInternal
parameter_list|(
name|String
name|clientName
parameter_list|,
name|ExtendedBlock
name|oldBlock
parameter_list|,
name|ExtendedBlock
name|newBlock
parameter_list|,
name|DatanodeID
index|[]
name|newNodes
parameter_list|,
name|String
index|[]
name|newStorageIDs
parameter_list|,
name|boolean
name|logRetryCache
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|hasWriteLock
argument_list|()
assert|;
comment|// check the vadility of the block and lease holder name
specifier|final
name|INodeFile
name|pendingFile
init|=
name|checkUCBlock
argument_list|(
name|oldBlock
argument_list|,
name|clientName
argument_list|)
decl_stmt|;
specifier|final
name|BlockInfo
name|blockinfo
init|=
name|pendingFile
operator|.
name|getLastBlock
argument_list|()
decl_stmt|;
assert|assert
operator|!
name|blockinfo
operator|.
name|isComplete
argument_list|()
assert|;
comment|// check new GS& length: this is not expected
if|if
condition|(
name|newBlock
operator|.
name|getGenerationStamp
argument_list|()
operator|<=
name|blockinfo
operator|.
name|getGenerationStamp
argument_list|()
operator|||
name|newBlock
operator|.
name|getNumBytes
argument_list|()
operator|<
name|blockinfo
operator|.
name|getNumBytes
argument_list|()
condition|)
block|{
name|String
name|msg
init|=
literal|"Update "
operator|+
name|oldBlock
operator|+
literal|" (len = "
operator|+
name|blockinfo
operator|.
name|getNumBytes
argument_list|()
operator|+
literal|") to an older state: "
operator|+
name|newBlock
operator|+
literal|" (len = "
operator|+
name|newBlock
operator|.
name|getNumBytes
argument_list|()
operator|+
literal|")"
decl_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
name|msg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
name|msg
argument_list|)
throw|;
block|}
comment|// Update old block with the new generation stamp and new length
name|blockinfo
operator|.
name|setNumBytes
argument_list|(
name|newBlock
operator|.
name|getNumBytes
argument_list|()
argument_list|)
expr_stmt|;
name|blockinfo
operator|.
name|setGenerationStampAndVerifyReplicas
argument_list|(
name|newBlock
operator|.
name|getGenerationStamp
argument_list|()
argument_list|)
expr_stmt|;
comment|// find the DatanodeDescriptor objects
specifier|final
name|DatanodeStorageInfo
index|[]
name|storages
init|=
name|blockManager
operator|.
name|getDatanodeManager
argument_list|()
operator|.
name|getDatanodeStorageInfos
argument_list|(
name|newNodes
argument_list|,
name|newStorageIDs
argument_list|)
decl_stmt|;
name|blockinfo
operator|.
name|getUnderConstructionFeature
argument_list|()
operator|.
name|setExpectedLocations
argument_list|(
name|blockinfo
argument_list|,
name|storages
argument_list|)
expr_stmt|;
name|String
name|src
init|=
name|pendingFile
operator|.
name|getFullPathName
argument_list|()
decl_stmt|;
name|FSDirWriteFileOp
operator|.
name|persistBlocks
argument_list|(
name|dir
argument_list|,
name|src
argument_list|,
name|pendingFile
argument_list|,
name|logRetryCache
argument_list|)
expr_stmt|;
block|}
comment|/**    * Register a Backup name-node, verifying that it belongs    * to the correct namespace, and adding it to the set of    * active journals if necessary.    *     * @param bnReg registration of the new BackupNode    * @param nnReg registration of this NameNode    * @throws IOException if the namespace IDs do not match    */
DECL|method|registerBackupNode (NamenodeRegistration bnReg, NamenodeRegistration nnReg)
name|void
name|registerBackupNode
parameter_list|(
name|NamenodeRegistration
name|bnReg
parameter_list|,
name|NamenodeRegistration
name|nnReg
parameter_list|)
throws|throws
name|IOException
block|{
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
name|getFSImage
argument_list|()
operator|.
name|getStorage
argument_list|()
operator|.
name|getNamespaceID
argument_list|()
operator|!=
name|bnReg
operator|.
name|getNamespaceID
argument_list|()
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Incompatible namespaceIDs: "
operator|+
literal|" Namenode namespaceID = "
operator|+
name|getFSImage
argument_list|()
operator|.
name|getStorage
argument_list|()
operator|.
name|getNamespaceID
argument_list|()
operator|+
literal|"; "
operator|+
name|bnReg
operator|.
name|getRole
argument_list|()
operator|+
literal|" node namespaceID = "
operator|+
name|bnReg
operator|.
name|getNamespaceID
argument_list|()
argument_list|)
throw|;
if|if
condition|(
name|bnReg
operator|.
name|getRole
argument_list|()
operator|==
name|NamenodeRole
operator|.
name|BACKUP
condition|)
block|{
name|getFSImage
argument_list|()
operator|.
name|getEditLog
argument_list|()
operator|.
name|registerBackupNode
argument_list|(
name|bnReg
argument_list|,
name|nnReg
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Release (unregister) backup node.    *<p>    * Find and remove the backup stream corresponding to the node.    * @throws IOException    */
DECL|method|releaseBackupNode (NamenodeRegistration registration)
name|void
name|releaseBackupNode
parameter_list|(
name|NamenodeRegistration
name|registration
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|getFSImage
argument_list|()
operator|.
name|getStorage
argument_list|()
operator|.
name|getNamespaceID
argument_list|()
operator|!=
name|registration
operator|.
name|getNamespaceID
argument_list|()
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Incompatible namespaceIDs: "
operator|+
literal|" Namenode namespaceID = "
operator|+
name|getFSImage
argument_list|()
operator|.
name|getStorage
argument_list|()
operator|.
name|getNamespaceID
argument_list|()
operator|+
literal|"; "
operator|+
name|registration
operator|.
name|getRole
argument_list|()
operator|+
literal|" node namespaceID = "
operator|+
name|registration
operator|.
name|getNamespaceID
argument_list|()
argument_list|)
throw|;
name|getEditLog
argument_list|()
operator|.
name|releaseBackupStream
argument_list|(
name|registration
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|class|CorruptFileBlockInfo
specifier|static
class|class
name|CorruptFileBlockInfo
block|{
DECL|field|path
specifier|final
name|String
name|path
decl_stmt|;
DECL|field|block
specifier|final
name|Block
name|block
decl_stmt|;
DECL|method|CorruptFileBlockInfo (String p, Block b)
specifier|public
name|CorruptFileBlockInfo
parameter_list|(
name|String
name|p
parameter_list|,
name|Block
name|b
parameter_list|)
block|{
name|path
operator|=
name|p
expr_stmt|;
name|block
operator|=
name|b
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|block
operator|.
name|getBlockName
argument_list|()
operator|+
literal|"\t"
operator|+
name|path
return|;
block|}
block|}
comment|/**    * @param path Restrict corrupt files to this portion of namespace.    * @param cookieTab Support for continuation; cookieTab  tells where    *                  to start from    * @return a list in which each entry describes a corrupt file/block    * @throws IOException    */
DECL|method|listCorruptFileBlocks (String path, String[] cookieTab)
name|Collection
argument_list|<
name|CorruptFileBlockInfo
argument_list|>
name|listCorruptFileBlocks
parameter_list|(
name|String
name|path
parameter_list|,
name|String
index|[]
name|cookieTab
parameter_list|)
throws|throws
name|IOException
block|{
name|checkSuperuserPrivilege
argument_list|()
expr_stmt|;
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|READ
argument_list|)
expr_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
name|ArrayList
argument_list|<
name|CorruptFileBlockInfo
argument_list|>
name|corruptFiles
init|=
operator|new
name|ArrayList
argument_list|<
name|CorruptFileBlockInfo
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|cookieTab
operator|==
literal|null
condition|)
block|{
name|cookieTab
operator|=
operator|new
name|String
index|[]
block|{
literal|null
block|}
expr_stmt|;
block|}
comment|// Do a quick check if there are any corrupt files without taking the lock
if|if
condition|(
name|blockManager
operator|.
name|getMissingBlocksCount
argument_list|()
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|cookieTab
index|[
literal|0
index|]
operator|==
literal|null
condition|)
block|{
name|cookieTab
index|[
literal|0
index|]
operator|=
name|String
operator|.
name|valueOf
argument_list|(
name|getIntCookie
argument_list|(
name|cookieTab
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"there are no corrupt file blocks."
argument_list|)
expr_stmt|;
block|}
return|return
name|corruptFiles
return|;
block|}
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|READ
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|blockManager
operator|.
name|isPopulatingReplQueues
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Cannot run listCorruptFileBlocks because "
operator|+
literal|"replication queues have not been initialized."
argument_list|)
throw|;
block|}
comment|// print a limited # of corrupt files per call
specifier|final
name|Iterator
argument_list|<
name|BlockInfo
argument_list|>
name|blkIterator
init|=
name|blockManager
operator|.
name|getCorruptReplicaBlockIterator
argument_list|()
decl_stmt|;
name|int
name|skip
init|=
name|getIntCookie
argument_list|(
name|cookieTab
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|skip
operator|&&
name|blkIterator
operator|.
name|hasNext
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|blkIterator
operator|.
name|next
argument_list|()
expr_stmt|;
block|}
while|while
condition|(
name|blkIterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|BlockInfo
name|blk
init|=
name|blkIterator
operator|.
name|next
argument_list|()
decl_stmt|;
name|BlockCollection
name|bc
init|=
name|getBlockCollection
argument_list|(
name|blk
operator|.
name|getBlockCollectionId
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|INode
name|inode
init|=
operator|(
name|INode
operator|)
name|bc
decl_stmt|;
name|skip
operator|++
expr_stmt|;
if|if
condition|(
name|inode
operator|!=
literal|null
operator|&&
name|blockManager
operator|.
name|countNodes
argument_list|(
name|blk
argument_list|)
operator|.
name|liveReplicas
argument_list|()
operator|==
literal|0
condition|)
block|{
name|String
name|src
init|=
name|FSDirectory
operator|.
name|getFullPathName
argument_list|(
name|inode
argument_list|)
decl_stmt|;
if|if
condition|(
name|src
operator|.
name|startsWith
argument_list|(
name|path
argument_list|)
condition|)
block|{
name|corruptFiles
operator|.
name|add
argument_list|(
operator|new
name|CorruptFileBlockInfo
argument_list|(
name|src
argument_list|,
name|blk
argument_list|)
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
if|if
condition|(
name|count
operator|>=
name|DEFAULT_MAX_CORRUPT_FILEBLOCKS_RETURNED
condition|)
break|break;
block|}
block|}
block|}
name|cookieTab
index|[
literal|0
index|]
operator|=
name|String
operator|.
name|valueOf
argument_list|(
name|skip
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"list corrupt file blocks returned: "
operator|+
name|count
argument_list|)
expr_stmt|;
block|}
return|return
name|corruptFiles
return|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Convert string cookie to integer.    */
DECL|method|getIntCookie (String cookie)
specifier|private
specifier|static
name|int
name|getIntCookie
parameter_list|(
name|String
name|cookie
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
if|if
condition|(
name|cookie
operator|==
literal|null
condition|)
block|{
name|c
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
try|try
block|{
name|c
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|cookie
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
name|c
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|c
operator|=
name|Math
operator|.
name|max
argument_list|(
literal|0
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return
name|c
return|;
block|}
comment|/**    * Create delegation token secret manager    */
DECL|method|createDelegationTokenSecretManager ( Configuration conf)
specifier|private
name|DelegationTokenSecretManager
name|createDelegationTokenSecretManager
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
return|return
operator|new
name|DelegationTokenSecretManager
argument_list|(
name|conf
operator|.
name|getLong
argument_list|(
name|DFS_NAMENODE_DELEGATION_KEY_UPDATE_INTERVAL_KEY
argument_list|,
name|DFS_NAMENODE_DELEGATION_KEY_UPDATE_INTERVAL_DEFAULT
argument_list|)
argument_list|,
name|conf
operator|.
name|getLong
argument_list|(
name|DFS_NAMENODE_DELEGATION_TOKEN_MAX_LIFETIME_KEY
argument_list|,
name|DFS_NAMENODE_DELEGATION_TOKEN_MAX_LIFETIME_DEFAULT
argument_list|)
argument_list|,
name|conf
operator|.
name|getLong
argument_list|(
name|DFS_NAMENODE_DELEGATION_TOKEN_RENEW_INTERVAL_KEY
argument_list|,
name|DFS_NAMENODE_DELEGATION_TOKEN_RENEW_INTERVAL_DEFAULT
argument_list|)
argument_list|,
name|DELEGATION_TOKEN_REMOVER_SCAN_INTERVAL
argument_list|,
name|conf
operator|.
name|getBoolean
argument_list|(
name|DFS_NAMENODE_AUDIT_LOG_TOKEN_TRACKING_ID_KEY
argument_list|,
name|DFS_NAMENODE_AUDIT_LOG_TOKEN_TRACKING_ID_DEFAULT
argument_list|)
argument_list|,
name|this
argument_list|)
return|;
block|}
comment|/**    * Returns the DelegationTokenSecretManager instance in the namesystem.    * @return delegation token secret manager object    */
DECL|method|getDelegationTokenSecretManager ()
name|DelegationTokenSecretManager
name|getDelegationTokenSecretManager
parameter_list|()
block|{
return|return
name|dtSecretManager
return|;
block|}
comment|/**    * @param renewer Renewer information    * @return delegation toek    * @throws IOException on error    */
DECL|method|getDelegationToken (Text renewer)
name|Token
argument_list|<
name|DelegationTokenIdentifier
argument_list|>
name|getDelegationToken
parameter_list|(
name|Text
name|renewer
parameter_list|)
throws|throws
name|IOException
block|{
name|Token
argument_list|<
name|DelegationTokenIdentifier
argument_list|>
name|token
decl_stmt|;
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|checkNameNodeSafeMode
argument_list|(
literal|"Cannot issue delegation token"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isAllowedDelegationTokenOp
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Delegation Token can be issued only with kerberos or web authentication"
argument_list|)
throw|;
block|}
if|if
condition|(
name|dtSecretManager
operator|==
literal|null
operator|||
operator|!
name|dtSecretManager
operator|.
name|isRunning
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"trying to get DT with no secret manager running"
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
name|UserGroupInformation
name|ugi
init|=
name|getRemoteUser
argument_list|()
decl_stmt|;
name|String
name|user
init|=
name|ugi
operator|.
name|getUserName
argument_list|()
decl_stmt|;
name|Text
name|owner
init|=
operator|new
name|Text
argument_list|(
name|user
argument_list|)
decl_stmt|;
name|Text
name|realUser
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|ugi
operator|.
name|getRealUser
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|realUser
operator|=
operator|new
name|Text
argument_list|(
name|ugi
operator|.
name|getRealUser
argument_list|()
operator|.
name|getUserName
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|DelegationTokenIdentifier
name|dtId
init|=
operator|new
name|DelegationTokenIdentifier
argument_list|(
name|owner
argument_list|,
name|renewer
argument_list|,
name|realUser
argument_list|)
decl_stmt|;
name|token
operator|=
operator|new
name|Token
argument_list|<
name|DelegationTokenIdentifier
argument_list|>
argument_list|(
name|dtId
argument_list|,
name|dtSecretManager
argument_list|)
expr_stmt|;
name|long
name|expiryTime
init|=
name|dtSecretManager
operator|.
name|getTokenExpiryTime
argument_list|(
name|dtId
argument_list|)
decl_stmt|;
name|getEditLog
argument_list|()
operator|.
name|logGetDelegationToken
argument_list|(
name|dtId
argument_list|,
name|expiryTime
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
name|getEditLog
argument_list|()
operator|.
name|logSync
argument_list|()
expr_stmt|;
return|return
name|token
return|;
block|}
comment|/**    *     * @param token token to renew    * @return new expiryTime of the token    * @throws InvalidToken if {@code token} is invalid    * @throws IOException on other errors    */
DECL|method|renewDelegationToken (Token<DelegationTokenIdentifier> token)
name|long
name|renewDelegationToken
parameter_list|(
name|Token
argument_list|<
name|DelegationTokenIdentifier
argument_list|>
name|token
parameter_list|)
throws|throws
name|InvalidToken
throws|,
name|IOException
block|{
name|long
name|expiryTime
decl_stmt|;
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|checkNameNodeSafeMode
argument_list|(
literal|"Cannot renew delegation token"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isAllowedDelegationTokenOp
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Delegation Token can be renewed only with kerberos or web authentication"
argument_list|)
throw|;
block|}
name|String
name|renewer
init|=
name|getRemoteUser
argument_list|()
operator|.
name|getShortUserName
argument_list|()
decl_stmt|;
name|expiryTime
operator|=
name|dtSecretManager
operator|.
name|renewToken
argument_list|(
name|token
argument_list|,
name|renewer
argument_list|)
expr_stmt|;
name|DelegationTokenIdentifier
name|id
init|=
operator|new
name|DelegationTokenIdentifier
argument_list|()
decl_stmt|;
name|ByteArrayInputStream
name|buf
init|=
operator|new
name|ByteArrayInputStream
argument_list|(
name|token
operator|.
name|getIdentifier
argument_list|()
argument_list|)
decl_stmt|;
name|DataInputStream
name|in
init|=
operator|new
name|DataInputStream
argument_list|(
name|buf
argument_list|)
decl_stmt|;
name|id
operator|.
name|readFields
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|getEditLog
argument_list|()
operator|.
name|logRenewDelegationToken
argument_list|(
name|id
argument_list|,
name|expiryTime
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
name|getEditLog
argument_list|()
operator|.
name|logSync
argument_list|()
expr_stmt|;
return|return
name|expiryTime
return|;
block|}
comment|/**    *     * @param token token to cancel    * @throws IOException on error    */
DECL|method|cancelDelegationToken (Token<DelegationTokenIdentifier> token)
name|void
name|cancelDelegationToken
parameter_list|(
name|Token
argument_list|<
name|DelegationTokenIdentifier
argument_list|>
name|token
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|checkNameNodeSafeMode
argument_list|(
literal|"Cannot cancel delegation token"
argument_list|)
expr_stmt|;
name|String
name|canceller
init|=
name|getRemoteUser
argument_list|()
operator|.
name|getUserName
argument_list|()
decl_stmt|;
name|DelegationTokenIdentifier
name|id
init|=
name|dtSecretManager
operator|.
name|cancelToken
argument_list|(
name|token
argument_list|,
name|canceller
argument_list|)
decl_stmt|;
name|getEditLog
argument_list|()
operator|.
name|logCancelDelegationToken
argument_list|(
name|id
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
name|getEditLog
argument_list|()
operator|.
name|logSync
argument_list|()
expr_stmt|;
block|}
comment|/**    * @param out save state of the secret manager    * @param sdPath String storage directory path    */
DECL|method|saveSecretManagerStateCompat (DataOutputStream out, String sdPath)
name|void
name|saveSecretManagerStateCompat
parameter_list|(
name|DataOutputStream
name|out
parameter_list|,
name|String
name|sdPath
parameter_list|)
throws|throws
name|IOException
block|{
name|dtSecretManager
operator|.
name|saveSecretManagerStateCompat
argument_list|(
name|out
argument_list|,
name|sdPath
argument_list|)
expr_stmt|;
block|}
DECL|method|saveSecretManagerState ()
name|SecretManagerState
name|saveSecretManagerState
parameter_list|()
block|{
return|return
name|dtSecretManager
operator|.
name|saveSecretManagerState
argument_list|()
return|;
block|}
comment|/**    * @param in load the state of secret manager from input stream    */
DECL|method|loadSecretManagerStateCompat (DataInput in)
name|void
name|loadSecretManagerStateCompat
parameter_list|(
name|DataInput
name|in
parameter_list|)
throws|throws
name|IOException
block|{
name|dtSecretManager
operator|.
name|loadSecretManagerStateCompat
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
DECL|method|loadSecretManagerState (SecretManagerSection s, List<SecretManagerSection.DelegationKey> keys, List<SecretManagerSection.PersistToken> tokens)
name|void
name|loadSecretManagerState
parameter_list|(
name|SecretManagerSection
name|s
parameter_list|,
name|List
argument_list|<
name|SecretManagerSection
operator|.
name|DelegationKey
argument_list|>
name|keys
parameter_list|,
name|List
argument_list|<
name|SecretManagerSection
operator|.
name|PersistToken
argument_list|>
name|tokens
parameter_list|)
throws|throws
name|IOException
block|{
name|dtSecretManager
operator|.
name|loadSecretManagerState
argument_list|(
operator|new
name|SecretManagerState
argument_list|(
name|s
argument_list|,
name|keys
argument_list|,
name|tokens
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Log the updateMasterKey operation to edit logs    *     * @param key new delegation key.    */
DECL|method|logUpdateMasterKey (DelegationKey key)
specifier|public
name|void
name|logUpdateMasterKey
parameter_list|(
name|DelegationKey
name|key
parameter_list|)
block|{
assert|assert
operator|!
name|isInSafeMode
argument_list|()
operator|:
literal|"this should never be called while in safemode, since we stop "
operator|+
literal|"the DT manager before entering safemode!"
assert|;
comment|// No need to hold FSN lock since we don't access any internal
comment|// structures, and this is stopped before the FSN shuts itself
comment|// down, etc.
name|getEditLog
argument_list|()
operator|.
name|logUpdateMasterKey
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|getEditLog
argument_list|()
operator|.
name|logSync
argument_list|()
expr_stmt|;
block|}
comment|/**    * Log the cancellation of expired tokens to edit logs    *     * @param id token identifier to cancel    */
DECL|method|logExpireDelegationToken (DelegationTokenIdentifier id)
specifier|public
name|void
name|logExpireDelegationToken
parameter_list|(
name|DelegationTokenIdentifier
name|id
parameter_list|)
block|{
assert|assert
operator|!
name|isInSafeMode
argument_list|()
operator|:
literal|"this should never be called while in safemode, since we stop "
operator|+
literal|"the DT manager before entering safemode!"
assert|;
comment|// No need to hold FSN lock since we don't access any internal
comment|// structures, and this is stopped before the FSN shuts itself
comment|// down, etc.
name|getEditLog
argument_list|()
operator|.
name|logCancelDelegationToken
argument_list|(
name|id
argument_list|)
expr_stmt|;
block|}
DECL|method|logReassignLease (String leaseHolder, String src, String newHolder)
specifier|private
name|void
name|logReassignLease
parameter_list|(
name|String
name|leaseHolder
parameter_list|,
name|String
name|src
parameter_list|,
name|String
name|newHolder
parameter_list|)
block|{
assert|assert
name|hasWriteLock
argument_list|()
assert|;
name|getEditLog
argument_list|()
operator|.
name|logReassignLease
argument_list|(
name|leaseHolder
argument_list|,
name|src
argument_list|,
name|newHolder
argument_list|)
expr_stmt|;
block|}
comment|/**    *     * @return true if delegation token operation is allowed    */
DECL|method|isAllowedDelegationTokenOp ()
specifier|private
name|boolean
name|isAllowedDelegationTokenOp
parameter_list|()
throws|throws
name|IOException
block|{
name|AuthenticationMethod
name|authMethod
init|=
name|getConnectionAuthenticationMethod
argument_list|()
decl_stmt|;
if|if
condition|(
name|UserGroupInformation
operator|.
name|isSecurityEnabled
argument_list|()
operator|&&
operator|(
name|authMethod
operator|!=
name|AuthenticationMethod
operator|.
name|KERBEROS
operator|)
operator|&&
operator|(
name|authMethod
operator|!=
name|AuthenticationMethod
operator|.
name|KERBEROS_SSL
operator|)
operator|&&
operator|(
name|authMethod
operator|!=
name|AuthenticationMethod
operator|.
name|CERTIFICATE
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Returns authentication method used to establish the connection    * @return AuthenticationMethod used to establish connection    * @throws IOException    */
DECL|method|getConnectionAuthenticationMethod ()
specifier|private
name|AuthenticationMethod
name|getConnectionAuthenticationMethod
parameter_list|()
throws|throws
name|IOException
block|{
name|UserGroupInformation
name|ugi
init|=
name|getRemoteUser
argument_list|()
decl_stmt|;
name|AuthenticationMethod
name|authMethod
init|=
name|ugi
operator|.
name|getAuthenticationMethod
argument_list|()
decl_stmt|;
if|if
condition|(
name|authMethod
operator|==
name|AuthenticationMethod
operator|.
name|PROXY
condition|)
block|{
name|authMethod
operator|=
name|ugi
operator|.
name|getRealUser
argument_list|()
operator|.
name|getAuthenticationMethod
argument_list|()
expr_stmt|;
block|}
return|return
name|authMethod
return|;
block|}
comment|/**    * Client invoked methods are invoked over RPC and will be in     * RPC call context even if the client exits.    */
DECL|method|isExternalInvocation ()
name|boolean
name|isExternalInvocation
parameter_list|()
block|{
return|return
name|Server
operator|.
name|isRpcInvocation
argument_list|()
operator|||
name|NamenodeWebHdfsMethods
operator|.
name|isWebHdfsInvocation
argument_list|()
return|;
block|}
DECL|method|getRemoteIp ()
specifier|private
specifier|static
name|InetAddress
name|getRemoteIp
parameter_list|()
block|{
name|InetAddress
name|ip
init|=
name|Server
operator|.
name|getRemoteIp
argument_list|()
decl_stmt|;
if|if
condition|(
name|ip
operator|!=
literal|null
condition|)
block|{
return|return
name|ip
return|;
block|}
return|return
name|NamenodeWebHdfsMethods
operator|.
name|getRemoteIp
argument_list|()
return|;
block|}
comment|// optimize ugi lookup for RPC operations to avoid a trip through
comment|// UGI.getCurrentUser which is synch'ed
DECL|method|getRemoteUser ()
specifier|private
specifier|static
name|UserGroupInformation
name|getRemoteUser
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|NameNode
operator|.
name|getRemoteUser
argument_list|()
return|;
block|}
comment|/**    * Log fsck event in the audit log     */
DECL|method|logFsckEvent (String src, InetAddress remoteAddress)
name|void
name|logFsckEvent
parameter_list|(
name|String
name|src
parameter_list|,
name|InetAddress
name|remoteAddress
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|isAuditEnabled
argument_list|()
condition|)
block|{
name|logAuditEvent
argument_list|(
literal|true
argument_list|,
name|getRemoteUser
argument_list|()
argument_list|,
name|remoteAddress
argument_list|,
literal|"fsck"
argument_list|,
name|src
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Register NameNodeMXBean    */
DECL|method|registerMXBean ()
specifier|private
name|void
name|registerMXBean
parameter_list|()
block|{
name|mxbeanName
operator|=
name|MBeans
operator|.
name|register
argument_list|(
literal|"NameNode"
argument_list|,
literal|"NameNodeInfo"
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
comment|/**    * Class representing Namenode information for JMX interfaces    */
annotation|@
name|Override
comment|// NameNodeMXBean
DECL|method|getVersion ()
specifier|public
name|String
name|getVersion
parameter_list|()
block|{
return|return
name|VersionInfo
operator|.
name|getVersion
argument_list|()
operator|+
literal|", r"
operator|+
name|VersionInfo
operator|.
name|getRevision
argument_list|()
return|;
block|}
annotation|@
name|Override
comment|// NameNodeMXBean
DECL|method|getUsed ()
specifier|public
name|long
name|getUsed
parameter_list|()
block|{
return|return
name|this
operator|.
name|getCapacityUsed
argument_list|()
return|;
block|}
annotation|@
name|Override
comment|// NameNodeMXBean
DECL|method|getFree ()
specifier|public
name|long
name|getFree
parameter_list|()
block|{
return|return
name|this
operator|.
name|getCapacityRemaining
argument_list|()
return|;
block|}
annotation|@
name|Override
comment|// NameNodeMXBean
DECL|method|getTotal ()
specifier|public
name|long
name|getTotal
parameter_list|()
block|{
return|return
name|this
operator|.
name|getCapacityTotal
argument_list|()
return|;
block|}
annotation|@
name|Override
comment|// NameNodeMXBean
DECL|method|getSafemode ()
specifier|public
name|String
name|getSafemode
parameter_list|()
block|{
if|if
condition|(
operator|!
name|this
operator|.
name|isInSafeMode
argument_list|()
condition|)
return|return
literal|""
return|;
return|return
literal|"Safe mode is ON. "
operator|+
name|this
operator|.
name|getSafeModeTip
argument_list|()
return|;
block|}
annotation|@
name|Override
comment|// NameNodeMXBean
DECL|method|isUpgradeFinalized ()
specifier|public
name|boolean
name|isUpgradeFinalized
parameter_list|()
block|{
return|return
name|this
operator|.
name|getFSImage
argument_list|()
operator|.
name|isUpgradeFinalized
argument_list|()
return|;
block|}
annotation|@
name|Override
comment|// NameNodeMXBean
DECL|method|getNonDfsUsedSpace ()
specifier|public
name|long
name|getNonDfsUsedSpace
parameter_list|()
block|{
return|return
name|datanodeStatistics
operator|.
name|getCapacityUsedNonDFS
argument_list|()
return|;
block|}
annotation|@
name|Override
comment|// NameNodeMXBean
DECL|method|getPercentUsed ()
specifier|public
name|float
name|getPercentUsed
parameter_list|()
block|{
return|return
name|datanodeStatistics
operator|.
name|getCapacityUsedPercent
argument_list|()
return|;
block|}
annotation|@
name|Override
comment|// NameNodeMXBean
DECL|method|getBlockPoolUsedSpace ()
specifier|public
name|long
name|getBlockPoolUsedSpace
parameter_list|()
block|{
return|return
name|datanodeStatistics
operator|.
name|getBlockPoolUsed
argument_list|()
return|;
block|}
annotation|@
name|Override
comment|// NameNodeMXBean
DECL|method|getPercentBlockPoolUsed ()
specifier|public
name|float
name|getPercentBlockPoolUsed
parameter_list|()
block|{
return|return
name|datanodeStatistics
operator|.
name|getPercentBlockPoolUsed
argument_list|()
return|;
block|}
annotation|@
name|Override
comment|// NameNodeMXBean
DECL|method|getPercentRemaining ()
specifier|public
name|float
name|getPercentRemaining
parameter_list|()
block|{
return|return
name|datanodeStatistics
operator|.
name|getCapacityRemainingPercent
argument_list|()
return|;
block|}
annotation|@
name|Override
comment|// NameNodeMXBean
DECL|method|getCacheCapacity ()
specifier|public
name|long
name|getCacheCapacity
parameter_list|()
block|{
return|return
name|datanodeStatistics
operator|.
name|getCacheCapacity
argument_list|()
return|;
block|}
annotation|@
name|Override
comment|// NameNodeMXBean
DECL|method|getCacheUsed ()
specifier|public
name|long
name|getCacheUsed
parameter_list|()
block|{
return|return
name|datanodeStatistics
operator|.
name|getCacheUsed
argument_list|()
return|;
block|}
annotation|@
name|Override
comment|// NameNodeMXBean
DECL|method|getTotalBlocks ()
specifier|public
name|long
name|getTotalBlocks
parameter_list|()
block|{
return|return
name|getBlocksTotal
argument_list|()
return|;
block|}
annotation|@
name|Override
comment|// NameNodeMXBean
annotation|@
name|Metric
DECL|method|getTotalFiles ()
specifier|public
name|long
name|getTotalFiles
parameter_list|()
block|{
return|return
name|getFilesTotal
argument_list|()
return|;
block|}
annotation|@
name|Override
comment|// NameNodeMXBean
DECL|method|getNumberOfMissingBlocks ()
specifier|public
name|long
name|getNumberOfMissingBlocks
parameter_list|()
block|{
return|return
name|getMissingBlocksCount
argument_list|()
return|;
block|}
annotation|@
name|Override
comment|// NameNodeMXBean
DECL|method|getNumberOfMissingBlocksWithReplicationFactorOne ()
specifier|public
name|long
name|getNumberOfMissingBlocksWithReplicationFactorOne
parameter_list|()
block|{
return|return
name|getMissingReplOneBlocksCount
argument_list|()
return|;
block|}
annotation|@
name|Override
comment|// NameNodeMXBean
DECL|method|getThreads ()
specifier|public
name|int
name|getThreads
parameter_list|()
block|{
return|return
name|ManagementFactory
operator|.
name|getThreadMXBean
argument_list|()
operator|.
name|getThreadCount
argument_list|()
return|;
block|}
comment|/**    * Returned information is a JSON representation of map with host name as the    * key and value is a map of live node attribute keys to its values    */
annotation|@
name|Override
comment|// NameNodeMXBean
DECL|method|getLiveNodes ()
specifier|public
name|String
name|getLiveNodes
parameter_list|()
block|{
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
argument_list|>
name|info
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|live
init|=
operator|new
name|ArrayList
argument_list|<
name|DatanodeDescriptor
argument_list|>
argument_list|()
decl_stmt|;
name|blockManager
operator|.
name|getDatanodeManager
argument_list|()
operator|.
name|fetchDatanodes
argument_list|(
name|live
argument_list|,
literal|null
argument_list|,
literal|true
argument_list|)
expr_stmt|;
for|for
control|(
name|DatanodeDescriptor
name|node
range|:
name|live
control|)
block|{
name|ImmutableMap
operator|.
name|Builder
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|innerinfo
init|=
name|ImmutableMap
operator|.
expr|<
name|String
decl_stmt|,
name|Object
decl|>
name|builder
argument_list|()
decl_stmt|;
name|innerinfo
operator|.
name|put
argument_list|(
literal|"infoAddr"
argument_list|,
name|node
operator|.
name|getInfoAddr
argument_list|()
argument_list|)
operator|.
name|put
argument_list|(
literal|"infoSecureAddr"
argument_list|,
name|node
operator|.
name|getInfoSecureAddr
argument_list|()
argument_list|)
operator|.
name|put
argument_list|(
literal|"xferaddr"
argument_list|,
name|node
operator|.
name|getXferAddr
argument_list|()
argument_list|)
operator|.
name|put
argument_list|(
literal|"lastContact"
argument_list|,
name|getLastContact
argument_list|(
name|node
argument_list|)
argument_list|)
operator|.
name|put
argument_list|(
literal|"usedSpace"
argument_list|,
name|getDfsUsed
argument_list|(
name|node
argument_list|)
argument_list|)
operator|.
name|put
argument_list|(
literal|"adminState"
argument_list|,
name|node
operator|.
name|getAdminState
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
operator|.
name|put
argument_list|(
literal|"nonDfsUsedSpace"
argument_list|,
name|node
operator|.
name|getNonDfsUsed
argument_list|()
argument_list|)
operator|.
name|put
argument_list|(
literal|"capacity"
argument_list|,
name|node
operator|.
name|getCapacity
argument_list|()
argument_list|)
operator|.
name|put
argument_list|(
literal|"numBlocks"
argument_list|,
name|node
operator|.
name|numBlocks
argument_list|()
argument_list|)
operator|.
name|put
argument_list|(
literal|"version"
argument_list|,
name|node
operator|.
name|getSoftwareVersion
argument_list|()
argument_list|)
operator|.
name|put
argument_list|(
literal|"used"
argument_list|,
name|node
operator|.
name|getDfsUsed
argument_list|()
argument_list|)
operator|.
name|put
argument_list|(
literal|"remaining"
argument_list|,
name|node
operator|.
name|getRemaining
argument_list|()
argument_list|)
operator|.
name|put
argument_list|(
literal|"blockScheduled"
argument_list|,
name|node
operator|.
name|getBlocksScheduled
argument_list|()
argument_list|)
operator|.
name|put
argument_list|(
literal|"blockPoolUsed"
argument_list|,
name|node
operator|.
name|getBlockPoolUsed
argument_list|()
argument_list|)
operator|.
name|put
argument_list|(
literal|"blockPoolUsedPercent"
argument_list|,
name|node
operator|.
name|getBlockPoolUsedPercent
argument_list|()
argument_list|)
operator|.
name|put
argument_list|(
literal|"volfails"
argument_list|,
name|node
operator|.
name|getVolumeFailures
argument_list|()
argument_list|)
expr_stmt|;
name|VolumeFailureSummary
name|volumeFailureSummary
init|=
name|node
operator|.
name|getVolumeFailureSummary
argument_list|()
decl_stmt|;
if|if
condition|(
name|volumeFailureSummary
operator|!=
literal|null
condition|)
block|{
name|innerinfo
operator|.
name|put
argument_list|(
literal|"failedStorageLocations"
argument_list|,
name|volumeFailureSummary
operator|.
name|getFailedStorageLocations
argument_list|()
argument_list|)
operator|.
name|put
argument_list|(
literal|"lastVolumeFailureDate"
argument_list|,
name|volumeFailureSummary
operator|.
name|getLastVolumeFailureDate
argument_list|()
argument_list|)
operator|.
name|put
argument_list|(
literal|"estimatedCapacityLostTotal"
argument_list|,
name|volumeFailureSummary
operator|.
name|getEstimatedCapacityLostTotal
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|info
operator|.
name|put
argument_list|(
name|node
operator|.
name|getHostName
argument_list|()
operator|+
literal|":"
operator|+
name|node
operator|.
name|getXferPort
argument_list|()
argument_list|,
name|innerinfo
operator|.
name|build
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|JSON
operator|.
name|toString
argument_list|(
name|info
argument_list|)
return|;
block|}
comment|/**    * Returned information is a JSON representation of map with host name as the    * key and value is a map of dead node attribute keys to its values    */
annotation|@
name|Override
comment|// NameNodeMXBean
DECL|method|getDeadNodes ()
specifier|public
name|String
name|getDeadNodes
parameter_list|()
block|{
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
argument_list|>
name|info
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|dead
init|=
operator|new
name|ArrayList
argument_list|<
name|DatanodeDescriptor
argument_list|>
argument_list|()
decl_stmt|;
name|blockManager
operator|.
name|getDatanodeManager
argument_list|()
operator|.
name|fetchDatanodes
argument_list|(
literal|null
argument_list|,
name|dead
argument_list|,
literal|true
argument_list|)
expr_stmt|;
for|for
control|(
name|DatanodeDescriptor
name|node
range|:
name|dead
control|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|innerinfo
init|=
name|ImmutableMap
operator|.
expr|<
name|String
decl_stmt|,
name|Object
decl|>
name|builder
argument_list|()
decl|.
name|put
argument_list|(
literal|"lastContact"
argument_list|,
name|getLastContact
argument_list|(
name|node
argument_list|)
argument_list|)
decl|.
name|put
argument_list|(
literal|"decommissioned"
argument_list|,
name|node
operator|.
name|isDecommissioned
argument_list|()
argument_list|)
decl|.
name|put
argument_list|(
literal|"xferaddr"
argument_list|,
name|node
operator|.
name|getXferAddr
argument_list|()
argument_list|)
decl|.
name|build
argument_list|()
decl_stmt|;
name|info
operator|.
name|put
argument_list|(
name|node
operator|.
name|getHostName
argument_list|()
operator|+
literal|":"
operator|+
name|node
operator|.
name|getXferPort
argument_list|()
argument_list|,
name|innerinfo
argument_list|)
expr_stmt|;
block|}
return|return
name|JSON
operator|.
name|toString
argument_list|(
name|info
argument_list|)
return|;
block|}
comment|/**    * Returned information is a JSON representation of map with host name as the    * key and value is a map of decommissioning node attribute keys to its    * values    */
annotation|@
name|Override
comment|// NameNodeMXBean
DECL|method|getDecomNodes ()
specifier|public
name|String
name|getDecomNodes
parameter_list|()
block|{
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
argument_list|>
name|info
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|decomNodeList
init|=
name|blockManager
operator|.
name|getDatanodeManager
argument_list|(         )
operator|.
name|getDecommissioningNodes
argument_list|()
decl_stmt|;
for|for
control|(
name|DatanodeDescriptor
name|node
range|:
name|decomNodeList
control|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|innerinfo
init|=
name|ImmutableMap
operator|.
expr|<
name|String
decl_stmt|,
name|Object
decl|>
name|builder
argument_list|()
decl|.
name|put
argument_list|(
literal|"xferaddr"
argument_list|,
name|node
operator|.
name|getXferAddr
argument_list|()
argument_list|)
decl|.
name|put
argument_list|(
literal|"underReplicatedBlocks"
argument_list|,
name|node
operator|.
name|decommissioningStatus
operator|.
name|getUnderReplicatedBlocks
argument_list|()
argument_list|)
decl|.
name|put
argument_list|(
literal|"decommissionOnlyReplicas"
argument_list|,
name|node
operator|.
name|decommissioningStatus
operator|.
name|getDecommissionOnlyReplicas
argument_list|()
argument_list|)
decl|.
name|put
argument_list|(
literal|"underReplicateInOpenFiles"
argument_list|,
name|node
operator|.
name|decommissioningStatus
operator|.
name|getUnderReplicatedInOpenFiles
argument_list|()
argument_list|)
decl|.
name|build
argument_list|()
decl_stmt|;
name|info
operator|.
name|put
argument_list|(
name|node
operator|.
name|getHostName
argument_list|()
operator|+
literal|":"
operator|+
name|node
operator|.
name|getXferPort
argument_list|()
argument_list|,
name|innerinfo
argument_list|)
expr_stmt|;
block|}
return|return
name|JSON
operator|.
name|toString
argument_list|(
name|info
argument_list|)
return|;
block|}
DECL|method|getLastContact (DatanodeDescriptor alivenode)
specifier|private
name|long
name|getLastContact
parameter_list|(
name|DatanodeDescriptor
name|alivenode
parameter_list|)
block|{
return|return
operator|(
name|monotonicNow
argument_list|()
operator|-
name|alivenode
operator|.
name|getLastUpdateMonotonic
argument_list|()
operator|)
operator|/
literal|1000
return|;
block|}
DECL|method|getDfsUsed (DatanodeDescriptor alivenode)
specifier|private
name|long
name|getDfsUsed
parameter_list|(
name|DatanodeDescriptor
name|alivenode
parameter_list|)
block|{
return|return
name|alivenode
operator|.
name|getDfsUsed
argument_list|()
return|;
block|}
annotation|@
name|Override
comment|// NameNodeMXBean
DECL|method|getClusterId ()
specifier|public
name|String
name|getClusterId
parameter_list|()
block|{
return|return
name|getFSImage
argument_list|()
operator|.
name|getStorage
argument_list|()
operator|.
name|getClusterID
argument_list|()
return|;
block|}
annotation|@
name|Override
comment|// NameNodeMXBean
DECL|method|getBlockPoolId ()
specifier|public
name|String
name|getBlockPoolId
parameter_list|()
block|{
return|return
name|blockPoolId
return|;
block|}
annotation|@
name|Override
comment|// NameNodeMXBean
DECL|method|getNameDirStatuses ()
specifier|public
name|String
name|getNameDirStatuses
parameter_list|()
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|File
argument_list|,
name|StorageDirType
argument_list|>
argument_list|>
name|statusMap
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|File
argument_list|,
name|StorageDirType
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|File
argument_list|,
name|StorageDirType
argument_list|>
name|activeDirs
init|=
operator|new
name|HashMap
argument_list|<
name|File
argument_list|,
name|StorageDirType
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|StorageDirectory
argument_list|>
name|it
init|=
name|getFSImage
argument_list|()
operator|.
name|getStorage
argument_list|()
operator|.
name|dirIterator
argument_list|()
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|StorageDirectory
name|st
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|activeDirs
operator|.
name|put
argument_list|(
name|st
operator|.
name|getRoot
argument_list|()
argument_list|,
name|st
operator|.
name|getStorageDirType
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|statusMap
operator|.
name|put
argument_list|(
literal|"active"
argument_list|,
name|activeDirs
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|Storage
operator|.
name|StorageDirectory
argument_list|>
name|removedStorageDirs
init|=
name|getFSImage
argument_list|()
operator|.
name|getStorage
argument_list|()
operator|.
name|getRemovedStorageDirs
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|File
argument_list|,
name|StorageDirType
argument_list|>
name|failedDirs
init|=
operator|new
name|HashMap
argument_list|<
name|File
argument_list|,
name|StorageDirType
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|StorageDirectory
name|st
range|:
name|removedStorageDirs
control|)
block|{
name|failedDirs
operator|.
name|put
argument_list|(
name|st
operator|.
name|getRoot
argument_list|()
argument_list|,
name|st
operator|.
name|getStorageDirType
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|statusMap
operator|.
name|put
argument_list|(
literal|"failed"
argument_list|,
name|failedDirs
argument_list|)
expr_stmt|;
return|return
name|JSON
operator|.
name|toString
argument_list|(
name|statusMap
argument_list|)
return|;
block|}
annotation|@
name|Override
comment|// NameNodeMXBean
DECL|method|getNodeUsage ()
specifier|public
name|String
name|getNodeUsage
parameter_list|()
block|{
name|float
name|median
init|=
literal|0
decl_stmt|;
name|float
name|max
init|=
literal|0
decl_stmt|;
name|float
name|min
init|=
literal|0
decl_stmt|;
name|float
name|dev
init|=
literal|0
decl_stmt|;
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
argument_list|>
name|info
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|live
init|=
operator|new
name|ArrayList
argument_list|<
name|DatanodeDescriptor
argument_list|>
argument_list|()
decl_stmt|;
name|blockManager
operator|.
name|getDatanodeManager
argument_list|()
operator|.
name|fetchDatanodes
argument_list|(
name|live
argument_list|,
literal|null
argument_list|,
literal|true
argument_list|)
expr_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|it
init|=
name|live
operator|.
name|iterator
argument_list|()
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|DatanodeDescriptor
name|node
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|node
operator|.
name|isDecommissionInProgress
argument_list|()
operator|||
name|node
operator|.
name|isDecommissioned
argument_list|()
condition|)
block|{
name|it
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|live
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|float
name|totalDfsUsed
init|=
literal|0
decl_stmt|;
name|float
index|[]
name|usages
init|=
operator|new
name|float
index|[
name|live
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|DatanodeDescriptor
name|dn
range|:
name|live
control|)
block|{
name|usages
index|[
name|i
operator|++
index|]
operator|=
name|dn
operator|.
name|getDfsUsedPercent
argument_list|()
expr_stmt|;
name|totalDfsUsed
operator|+=
name|dn
operator|.
name|getDfsUsedPercent
argument_list|()
expr_stmt|;
block|}
name|totalDfsUsed
operator|/=
name|live
operator|.
name|size
argument_list|()
expr_stmt|;
name|Arrays
operator|.
name|sort
argument_list|(
name|usages
argument_list|)
expr_stmt|;
name|median
operator|=
name|usages
index|[
name|usages
operator|.
name|length
operator|/
literal|2
index|]
expr_stmt|;
name|max
operator|=
name|usages
index|[
name|usages
operator|.
name|length
operator|-
literal|1
index|]
expr_stmt|;
name|min
operator|=
name|usages
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|usages
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|dev
operator|+=
operator|(
name|usages
index|[
name|i
index|]
operator|-
name|totalDfsUsed
operator|)
operator|*
operator|(
name|usages
index|[
name|i
index|]
operator|-
name|totalDfsUsed
operator|)
expr_stmt|;
block|}
name|dev
operator|=
operator|(
name|float
operator|)
name|Math
operator|.
name|sqrt
argument_list|(
name|dev
operator|/
name|usages
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|innerInfo
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
argument_list|()
decl_stmt|;
name|innerInfo
operator|.
name|put
argument_list|(
literal|"min"
argument_list|,
name|StringUtils
operator|.
name|format
argument_list|(
literal|"%.2f%%"
argument_list|,
name|min
argument_list|)
argument_list|)
expr_stmt|;
name|innerInfo
operator|.
name|put
argument_list|(
literal|"median"
argument_list|,
name|StringUtils
operator|.
name|format
argument_list|(
literal|"%.2f%%"
argument_list|,
name|median
argument_list|)
argument_list|)
expr_stmt|;
name|innerInfo
operator|.
name|put
argument_list|(
literal|"max"
argument_list|,
name|StringUtils
operator|.
name|format
argument_list|(
literal|"%.2f%%"
argument_list|,
name|max
argument_list|)
argument_list|)
expr_stmt|;
name|innerInfo
operator|.
name|put
argument_list|(
literal|"stdDev"
argument_list|,
name|StringUtils
operator|.
name|format
argument_list|(
literal|"%.2f%%"
argument_list|,
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|info
operator|.
name|put
argument_list|(
literal|"nodeUsage"
argument_list|,
name|innerInfo
argument_list|)
expr_stmt|;
return|return
name|JSON
operator|.
name|toString
argument_list|(
name|info
argument_list|)
return|;
block|}
annotation|@
name|Override
comment|// NameNodeMXBean
DECL|method|getNameJournalStatus ()
specifier|public
name|String
name|getNameJournalStatus
parameter_list|()
block|{
name|List
argument_list|<
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|>
name|jasList
init|=
operator|new
name|ArrayList
argument_list|<
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|FSEditLog
name|log
init|=
name|getFSImage
argument_list|()
operator|.
name|getEditLog
argument_list|()
decl_stmt|;
if|if
condition|(
name|log
operator|!=
literal|null
condition|)
block|{
name|boolean
name|openForWrite
init|=
name|log
operator|.
name|isOpenForWrite
argument_list|()
decl_stmt|;
for|for
control|(
name|JournalAndStream
name|jas
range|:
name|log
operator|.
name|getJournals
argument_list|()
control|)
block|{
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|jasMap
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|String
name|manager
init|=
name|jas
operator|.
name|getManager
argument_list|()
operator|.
name|toString
argument_list|()
decl_stmt|;
name|jasMap
operator|.
name|put
argument_list|(
literal|"required"
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
name|jas
operator|.
name|isRequired
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|jasMap
operator|.
name|put
argument_list|(
literal|"disabled"
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
name|jas
operator|.
name|isDisabled
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|jasMap
operator|.
name|put
argument_list|(
literal|"manager"
argument_list|,
name|manager
argument_list|)
expr_stmt|;
if|if
condition|(
name|jas
operator|.
name|isDisabled
argument_list|()
condition|)
block|{
name|jasMap
operator|.
name|put
argument_list|(
literal|"stream"
argument_list|,
literal|"Failed"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|openForWrite
condition|)
block|{
name|EditLogOutputStream
name|elos
init|=
name|jas
operator|.
name|getCurrentStream
argument_list|()
decl_stmt|;
if|if
condition|(
name|elos
operator|!=
literal|null
condition|)
block|{
name|jasMap
operator|.
name|put
argument_list|(
literal|"stream"
argument_list|,
name|elos
operator|.
name|generateReport
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|jasMap
operator|.
name|put
argument_list|(
literal|"stream"
argument_list|,
literal|"not currently writing"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|jasMap
operator|.
name|put
argument_list|(
literal|"stream"
argument_list|,
literal|"open for read"
argument_list|)
expr_stmt|;
block|}
name|jasList
operator|.
name|add
argument_list|(
name|jasMap
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|JSON
operator|.
name|toString
argument_list|(
name|jasList
argument_list|)
return|;
block|}
annotation|@
name|Override
comment|// NameNodeMxBean
DECL|method|getJournalTransactionInfo ()
specifier|public
name|String
name|getJournalTransactionInfo
parameter_list|()
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|txnIdMap
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|txnIdMap
operator|.
name|put
argument_list|(
literal|"LastAppliedOrWrittenTxId"
argument_list|,
name|Long
operator|.
name|toString
argument_list|(
name|this
operator|.
name|getFSImage
argument_list|()
operator|.
name|getLastAppliedOrWrittenTxId
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|txnIdMap
operator|.
name|put
argument_list|(
literal|"MostRecentCheckpointTxId"
argument_list|,
name|Long
operator|.
name|toString
argument_list|(
name|this
operator|.
name|getFSImage
argument_list|()
operator|.
name|getMostRecentCheckpointTxId
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|JSON
operator|.
name|toString
argument_list|(
name|txnIdMap
argument_list|)
return|;
block|}
annotation|@
name|Override
comment|// NameNodeMXBean
DECL|method|getNNStarted ()
specifier|public
name|String
name|getNNStarted
parameter_list|()
block|{
return|return
name|getStartTime
argument_list|()
operator|.
name|toString
argument_list|()
return|;
block|}
annotation|@
name|Override
comment|// NameNodeMXBean
DECL|method|getNNStartedTimeInMillis ()
specifier|public
name|long
name|getNNStartedTimeInMillis
parameter_list|()
block|{
return|return
name|startTime
return|;
block|}
annotation|@
name|Override
comment|// NameNodeMXBean
DECL|method|getCompileInfo ()
specifier|public
name|String
name|getCompileInfo
parameter_list|()
block|{
return|return
name|VersionInfo
operator|.
name|getDate
argument_list|()
operator|+
literal|" by "
operator|+
name|VersionInfo
operator|.
name|getUser
argument_list|()
operator|+
literal|" from "
operator|+
name|VersionInfo
operator|.
name|getBranch
argument_list|()
return|;
block|}
comment|/** @return the block manager. */
DECL|method|getBlockManager ()
specifier|public
name|BlockManager
name|getBlockManager
parameter_list|()
block|{
return|return
name|blockManager
return|;
block|}
DECL|method|getBlockIdManager ()
specifier|public
name|BlockIdManager
name|getBlockIdManager
parameter_list|()
block|{
return|return
name|blockIdManager
return|;
block|}
comment|/** @return the FSDirectory. */
DECL|method|getFSDirectory ()
specifier|public
name|FSDirectory
name|getFSDirectory
parameter_list|()
block|{
return|return
name|dir
return|;
block|}
comment|/** Set the FSDirectory. */
annotation|@
name|VisibleForTesting
DECL|method|setFSDirectory (FSDirectory dir)
specifier|public
name|void
name|setFSDirectory
parameter_list|(
name|FSDirectory
name|dir
parameter_list|)
block|{
name|this
operator|.
name|dir
operator|=
name|dir
expr_stmt|;
block|}
comment|/** @return the cache manager. */
annotation|@
name|Override
DECL|method|getCacheManager ()
specifier|public
name|CacheManager
name|getCacheManager
parameter_list|()
block|{
return|return
name|cacheManager
return|;
block|}
annotation|@
name|Override
DECL|method|getHAContext ()
specifier|public
name|HAContext
name|getHAContext
parameter_list|()
block|{
return|return
name|haContext
return|;
block|}
annotation|@
name|Override
comment|// NameNodeMXBean
DECL|method|getCorruptFiles ()
specifier|public
name|String
name|getCorruptFiles
parameter_list|()
block|{
name|List
argument_list|<
name|String
argument_list|>
name|list
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|Collection
argument_list|<
name|FSNamesystem
operator|.
name|CorruptFileBlockInfo
argument_list|>
name|corruptFileBlocks
decl_stmt|;
try|try
block|{
name|corruptFileBlocks
operator|=
name|listCorruptFileBlocks
argument_list|(
literal|"/"
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|int
name|corruptFileCount
init|=
name|corruptFileBlocks
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|corruptFileCount
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|FSNamesystem
operator|.
name|CorruptFileBlockInfo
name|c
range|:
name|corruptFileBlocks
control|)
block|{
name|list
operator|.
name|add
argument_list|(
name|c
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Get corrupt file blocks returned error: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|JSON
operator|.
name|toString
argument_list|(
name|list
argument_list|)
return|;
block|}
annotation|@
name|Override
comment|//NameNodeMXBean
DECL|method|getDistinctVersionCount ()
specifier|public
name|int
name|getDistinctVersionCount
parameter_list|()
block|{
return|return
name|blockManager
operator|.
name|getDatanodeManager
argument_list|()
operator|.
name|getDatanodesSoftwareVersions
argument_list|()
operator|.
name|size
argument_list|()
return|;
block|}
annotation|@
name|Override
comment|//NameNodeMXBean
DECL|method|getDistinctVersions ()
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|getDistinctVersions
parameter_list|()
block|{
return|return
name|blockManager
operator|.
name|getDatanodeManager
argument_list|()
operator|.
name|getDatanodesSoftwareVersions
argument_list|()
return|;
block|}
annotation|@
name|Override
comment|//NameNodeMXBean
DECL|method|getSoftwareVersion ()
specifier|public
name|String
name|getSoftwareVersion
parameter_list|()
block|{
return|return
name|VersionInfo
operator|.
name|getVersion
argument_list|()
return|;
block|}
comment|/**    * Verifies that the given identifier and password are valid and match.    * @param identifier Token identifier.    * @param password Password in the token.    */
DECL|method|verifyToken (DelegationTokenIdentifier identifier, byte[] password)
specifier|public
specifier|synchronized
name|void
name|verifyToken
parameter_list|(
name|DelegationTokenIdentifier
name|identifier
parameter_list|,
name|byte
index|[]
name|password
parameter_list|)
throws|throws
name|InvalidToken
throws|,
name|RetriableException
block|{
try|try
block|{
name|getDelegationTokenSecretManager
argument_list|()
operator|.
name|verifyToken
argument_list|(
name|identifier
argument_list|,
name|password
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InvalidToken
name|it
parameter_list|)
block|{
if|if
condition|(
name|inTransitionToActive
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|RetriableException
argument_list|(
name|it
argument_list|)
throw|;
block|}
throw|throw
name|it
throw|;
block|}
block|}
annotation|@
name|Override
DECL|method|isGenStampInFuture (Block block)
specifier|public
name|boolean
name|isGenStampInFuture
parameter_list|(
name|Block
name|block
parameter_list|)
block|{
return|return
name|blockIdManager
operator|.
name|isGenStampInFuture
argument_list|(
name|block
argument_list|)
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|getEditLogTailer ()
specifier|public
name|EditLogTailer
name|getEditLogTailer
parameter_list|()
block|{
return|return
name|editLogTailer
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|setEditLogTailerForTests (EditLogTailer tailer)
specifier|public
name|void
name|setEditLogTailerForTests
parameter_list|(
name|EditLogTailer
name|tailer
parameter_list|)
block|{
name|this
operator|.
name|editLogTailer
operator|=
name|tailer
expr_stmt|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|setFsLockForTests (ReentrantReadWriteLock lock)
name|void
name|setFsLockForTests
parameter_list|(
name|ReentrantReadWriteLock
name|lock
parameter_list|)
block|{
name|this
operator|.
name|fsLock
operator|.
name|coarseLock
operator|=
name|lock
expr_stmt|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|getFsLockForTests ()
specifier|public
name|ReentrantReadWriteLock
name|getFsLockForTests
parameter_list|()
block|{
return|return
name|fsLock
operator|.
name|coarseLock
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|getCpLockForTests ()
specifier|public
name|ReentrantLock
name|getCpLockForTests
parameter_list|()
block|{
return|return
name|cpLock
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|getSafeModeInfoForTests ()
specifier|public
name|SafeModeInfo
name|getSafeModeInfoForTests
parameter_list|()
block|{
return|return
name|safeMode
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|setNNResourceChecker (NameNodeResourceChecker nnResourceChecker)
specifier|public
name|void
name|setNNResourceChecker
parameter_list|(
name|NameNodeResourceChecker
name|nnResourceChecker
parameter_list|)
block|{
name|this
operator|.
name|nnResourceChecker
operator|=
name|nnResourceChecker
expr_stmt|;
block|}
DECL|method|getSnapshotManager ()
specifier|public
name|SnapshotManager
name|getSnapshotManager
parameter_list|()
block|{
return|return
name|snapshotManager
return|;
block|}
comment|/** Allow snapshot on a directory. */
DECL|method|allowSnapshot (String path)
name|void
name|allowSnapshot
parameter_list|(
name|String
name|path
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|checkNameNodeSafeMode
argument_list|(
literal|"Cannot allow snapshot for "
operator|+
name|path
argument_list|)
expr_stmt|;
name|checkSuperuserPrivilege
argument_list|()
expr_stmt|;
name|FSDirSnapshotOp
operator|.
name|allowSnapshot
argument_list|(
name|dir
argument_list|,
name|snapshotManager
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
name|getEditLog
argument_list|()
operator|.
name|logSync
argument_list|()
expr_stmt|;
name|logAuditEvent
argument_list|(
name|success
argument_list|,
literal|"allowSnapshot"
argument_list|,
name|path
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/** Disallow snapshot on a directory. */
DECL|method|disallowSnapshot (String path)
name|void
name|disallowSnapshot
parameter_list|(
name|String
name|path
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|checkNameNodeSafeMode
argument_list|(
literal|"Cannot disallow snapshot for "
operator|+
name|path
argument_list|)
expr_stmt|;
name|checkSuperuserPrivilege
argument_list|()
expr_stmt|;
name|FSDirSnapshotOp
operator|.
name|disallowSnapshot
argument_list|(
name|dir
argument_list|,
name|snapshotManager
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
name|getEditLog
argument_list|()
operator|.
name|logSync
argument_list|()
expr_stmt|;
name|logAuditEvent
argument_list|(
name|success
argument_list|,
literal|"disallowSnapshot"
argument_list|,
name|path
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**    * Create a snapshot    * @param snapshotRoot The directory path where the snapshot is taken    * @param snapshotName The name of the snapshot    */
DECL|method|createSnapshot (String snapshotRoot, String snapshotName, boolean logRetryCache)
name|String
name|createSnapshot
parameter_list|(
name|String
name|snapshotRoot
parameter_list|,
name|String
name|snapshotName
parameter_list|,
name|boolean
name|logRetryCache
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|snapshotPath
init|=
literal|null
decl_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|checkNameNodeSafeMode
argument_list|(
literal|"Cannot create snapshot for "
operator|+
name|snapshotRoot
argument_list|)
expr_stmt|;
name|snapshotPath
operator|=
name|FSDirSnapshotOp
operator|.
name|createSnapshot
argument_list|(
name|dir
argument_list|,
name|snapshotManager
argument_list|,
name|snapshotRoot
argument_list|,
name|snapshotName
argument_list|,
name|logRetryCache
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
name|getEditLog
argument_list|()
operator|.
name|logSync
argument_list|()
expr_stmt|;
name|logAuditEvent
argument_list|(
name|snapshotPath
operator|!=
literal|null
argument_list|,
literal|"createSnapshot"
argument_list|,
name|snapshotRoot
argument_list|,
name|snapshotPath
argument_list|,
literal|null
argument_list|)
expr_stmt|;
return|return
name|snapshotPath
return|;
block|}
comment|/**    * Rename a snapshot    * @param path The directory path where the snapshot was taken    * @param snapshotOldName Old snapshot name    * @param snapshotNewName New snapshot name    * @throws SafeModeException    * @throws IOException     */
DECL|method|renameSnapshot ( String path, String snapshotOldName, String snapshotNewName, boolean logRetryCache)
name|void
name|renameSnapshot
parameter_list|(
name|String
name|path
parameter_list|,
name|String
name|snapshotOldName
parameter_list|,
name|String
name|snapshotNewName
parameter_list|,
name|boolean
name|logRetryCache
parameter_list|)
throws|throws
name|IOException
block|{
name|boolean
name|success
init|=
literal|false
decl_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|checkNameNodeSafeMode
argument_list|(
literal|"Cannot rename snapshot for "
operator|+
name|path
argument_list|)
expr_stmt|;
name|FSDirSnapshotOp
operator|.
name|renameSnapshot
argument_list|(
name|dir
argument_list|,
name|snapshotManager
argument_list|,
name|path
argument_list|,
name|snapshotOldName
argument_list|,
name|snapshotNewName
argument_list|,
name|logRetryCache
argument_list|)
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
name|getEditLog
argument_list|()
operator|.
name|logSync
argument_list|()
expr_stmt|;
name|String
name|oldSnapshotRoot
init|=
name|Snapshot
operator|.
name|getSnapshotPath
argument_list|(
name|path
argument_list|,
name|snapshotOldName
argument_list|)
decl_stmt|;
name|String
name|newSnapshotRoot
init|=
name|Snapshot
operator|.
name|getSnapshotPath
argument_list|(
name|path
argument_list|,
name|snapshotNewName
argument_list|)
decl_stmt|;
name|logAuditEvent
argument_list|(
name|success
argument_list|,
literal|"renameSnapshot"
argument_list|,
name|oldSnapshotRoot
argument_list|,
name|newSnapshotRoot
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**    * Get the list of snapshottable directories that are owned     * by the current user. Return all the snapshottable directories if the     * current user is a super user.    * @return The list of all the current snapshottable directories    * @throws IOException    */
DECL|method|getSnapshottableDirListing ()
specifier|public
name|SnapshottableDirectoryStatus
index|[]
name|getSnapshottableDirListing
parameter_list|()
throws|throws
name|IOException
block|{
name|SnapshottableDirectoryStatus
index|[]
name|status
init|=
literal|null
decl_stmt|;
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|READ
argument_list|)
expr_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|READ
argument_list|)
expr_stmt|;
name|status
operator|=
name|FSDirSnapshotOp
operator|.
name|getSnapshottableDirListing
argument_list|(
name|dir
argument_list|,
name|snapshotManager
argument_list|)
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
name|logAuditEvent
argument_list|(
name|success
argument_list|,
literal|"listSnapshottableDirectory"
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
comment|/**    * Get the difference between two snapshots (or between a snapshot and the    * current status) of a snapshottable directory.    *     * @param path The full path of the snapshottable directory.    * @param fromSnapshot Name of the snapshot to calculate the diff from. Null    *          or empty string indicates the current tree.    * @param toSnapshot Name of the snapshot to calculated the diff to. Null or    *          empty string indicates the current tree.    * @return A report about the difference between {@code fromSnapshot} and     *         {@code toSnapshot}. Modified/deleted/created/renamed files and     *         directories belonging to the snapshottable directories are listed     *         and labeled as M/-/+/R respectively.     * @throws IOException    */
DECL|method|getSnapshotDiffReport (String path, String fromSnapshot, String toSnapshot)
name|SnapshotDiffReport
name|getSnapshotDiffReport
parameter_list|(
name|String
name|path
parameter_list|,
name|String
name|fromSnapshot
parameter_list|,
name|String
name|toSnapshot
parameter_list|)
throws|throws
name|IOException
block|{
name|SnapshotDiffReport
name|diffs
init|=
literal|null
decl_stmt|;
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|READ
argument_list|)
expr_stmt|;
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|READ
argument_list|)
expr_stmt|;
name|diffs
operator|=
name|FSDirSnapshotOp
operator|.
name|getSnapshotDiffReport
argument_list|(
name|dir
argument_list|,
name|snapshotManager
argument_list|,
name|path
argument_list|,
name|fromSnapshot
argument_list|,
name|toSnapshot
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
name|String
name|fromSnapshotRoot
init|=
operator|(
name|fromSnapshot
operator|==
literal|null
operator|||
name|fromSnapshot
operator|.
name|isEmpty
argument_list|()
operator|)
condition|?
name|path
else|:
name|Snapshot
operator|.
name|getSnapshotPath
argument_list|(
name|path
argument_list|,
name|fromSnapshot
argument_list|)
decl_stmt|;
name|String
name|toSnapshotRoot
init|=
operator|(
name|toSnapshot
operator|==
literal|null
operator|||
name|toSnapshot
operator|.
name|isEmpty
argument_list|()
operator|)
condition|?
name|path
else|:
name|Snapshot
operator|.
name|getSnapshotPath
argument_list|(
name|path
argument_list|,
name|toSnapshot
argument_list|)
decl_stmt|;
name|logAuditEvent
argument_list|(
name|diffs
operator|!=
literal|null
argument_list|,
literal|"computeSnapshotDiff"
argument_list|,
name|fromSnapshotRoot
argument_list|,
name|toSnapshotRoot
argument_list|,
literal|null
argument_list|)
expr_stmt|;
return|return
name|diffs
return|;
block|}
comment|/**    * Delete a snapshot of a snapshottable directory    * @param snapshotRoot The snapshottable directory    * @param snapshotName The name of the to-be-deleted snapshot    * @throws SafeModeException    * @throws IOException    */
DECL|method|deleteSnapshot (String snapshotRoot, String snapshotName, boolean logRetryCache)
name|void
name|deleteSnapshot
parameter_list|(
name|String
name|snapshotRoot
parameter_list|,
name|String
name|snapshotName
parameter_list|,
name|boolean
name|logRetryCache
parameter_list|)
throws|throws
name|IOException
block|{
name|boolean
name|success
init|=
literal|false
decl_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
name|BlocksMapUpdateInfo
name|blocksToBeDeleted
init|=
literal|null
decl_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|checkNameNodeSafeMode
argument_list|(
literal|"Cannot delete snapshot for "
operator|+
name|snapshotRoot
argument_list|)
expr_stmt|;
name|blocksToBeDeleted
operator|=
name|FSDirSnapshotOp
operator|.
name|deleteSnapshot
argument_list|(
name|dir
argument_list|,
name|snapshotManager
argument_list|,
name|snapshotRoot
argument_list|,
name|snapshotName
argument_list|,
name|logRetryCache
argument_list|)
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
name|getEditLog
argument_list|()
operator|.
name|logSync
argument_list|()
expr_stmt|;
comment|// Breaking the pattern as removing blocks have to happen outside of the
comment|// global lock
if|if
condition|(
name|blocksToBeDeleted
operator|!=
literal|null
condition|)
block|{
name|removeBlocks
argument_list|(
name|blocksToBeDeleted
argument_list|)
expr_stmt|;
block|}
name|String
name|rootPath
init|=
name|Snapshot
operator|.
name|getSnapshotPath
argument_list|(
name|snapshotRoot
argument_list|,
name|snapshotName
argument_list|)
decl_stmt|;
name|logAuditEvent
argument_list|(
name|success
argument_list|,
literal|"deleteSnapshot"
argument_list|,
name|rootPath
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**    * Remove a list of INodeDirectorySnapshottable from the SnapshotManager    * @param toRemove the list of INodeDirectorySnapshottable to be removed    */
DECL|method|removeSnapshottableDirs (List<INodeDirectory> toRemove)
name|void
name|removeSnapshottableDirs
parameter_list|(
name|List
argument_list|<
name|INodeDirectory
argument_list|>
name|toRemove
parameter_list|)
block|{
if|if
condition|(
name|snapshotManager
operator|!=
literal|null
condition|)
block|{
name|snapshotManager
operator|.
name|removeSnapshottable
argument_list|(
name|toRemove
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|queryRollingUpgrade ()
name|RollingUpgradeInfo
name|queryRollingUpgrade
parameter_list|()
throws|throws
name|IOException
block|{
name|checkSuperuserPrivilege
argument_list|()
expr_stmt|;
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|READ
argument_list|)
expr_stmt|;
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
operator|!
name|isRollingUpgrade
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|rollingUpgradeInfo
argument_list|)
expr_stmt|;
name|boolean
name|hasRollbackImage
init|=
name|this
operator|.
name|getFSImage
argument_list|()
operator|.
name|hasRollbackFSImage
argument_list|()
decl_stmt|;
name|rollingUpgradeInfo
operator|.
name|setCreatedRollbackImages
argument_list|(
name|hasRollbackImage
argument_list|)
expr_stmt|;
return|return
name|rollingUpgradeInfo
return|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|startRollingUpgrade ()
name|RollingUpgradeInfo
name|startRollingUpgrade
parameter_list|()
throws|throws
name|IOException
block|{
name|checkSuperuserPrivilege
argument_list|()
expr_stmt|;
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|isRollingUpgrade
argument_list|()
condition|)
block|{
return|return
name|rollingUpgradeInfo
return|;
block|}
name|long
name|startTime
init|=
name|now
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|haEnabled
condition|)
block|{
comment|// for non-HA, we require NN to be in safemode
name|startRollingUpgradeInternalForNonHA
argument_list|(
name|startTime
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// for HA, NN cannot be in safemode
name|checkNameNodeSafeMode
argument_list|(
literal|"Failed to start rolling upgrade"
argument_list|)
expr_stmt|;
name|startRollingUpgradeInternal
argument_list|(
name|startTime
argument_list|)
expr_stmt|;
block|}
name|getEditLog
argument_list|()
operator|.
name|logStartRollingUpgrade
argument_list|(
name|rollingUpgradeInfo
operator|.
name|getStartTime
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|haEnabled
condition|)
block|{
comment|// roll the edit log to make sure the standby NameNode can tail
name|getFSImage
argument_list|()
operator|.
name|rollEditLog
argument_list|(
name|getEffectiveLayoutVersion
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
name|getEditLog
argument_list|()
operator|.
name|logSync
argument_list|()
expr_stmt|;
if|if
condition|(
name|auditLog
operator|.
name|isInfoEnabled
argument_list|()
operator|&&
name|isExternalInvocation
argument_list|()
condition|)
block|{
name|logAuditEvent
argument_list|(
literal|true
argument_list|,
literal|"startRollingUpgrade"
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
return|return
name|rollingUpgradeInfo
return|;
block|}
comment|/**    * Update internal state to indicate that a rolling upgrade is in progress.    * @param startTime rolling upgrade start time    */
DECL|method|startRollingUpgradeInternal (long startTime)
name|void
name|startRollingUpgradeInternal
parameter_list|(
name|long
name|startTime
parameter_list|)
throws|throws
name|IOException
block|{
name|checkRollingUpgrade
argument_list|(
literal|"start rolling upgrade"
argument_list|)
expr_stmt|;
name|getFSImage
argument_list|()
operator|.
name|checkUpgrade
argument_list|()
expr_stmt|;
name|setRollingUpgradeInfo
argument_list|(
literal|false
argument_list|,
name|startTime
argument_list|)
expr_stmt|;
block|}
comment|/**    * Update internal state to indicate that a rolling upgrade is in progress for    * non-HA setup. This requires the namesystem is in SafeMode and after doing a    * checkpoint for rollback the namesystem will quit the safemode automatically     */
DECL|method|startRollingUpgradeInternalForNonHA (long startTime)
specifier|private
name|void
name|startRollingUpgradeInternalForNonHA
parameter_list|(
name|long
name|startTime
parameter_list|)
throws|throws
name|IOException
block|{
name|Preconditions
operator|.
name|checkState
argument_list|(
operator|!
name|haEnabled
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isInSafeMode
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Safe mode should be turned ON "
operator|+
literal|"in order to create namespace image."
argument_list|)
throw|;
block|}
name|checkRollingUpgrade
argument_list|(
literal|"start rolling upgrade"
argument_list|)
expr_stmt|;
name|getFSImage
argument_list|()
operator|.
name|checkUpgrade
argument_list|()
expr_stmt|;
comment|// in non-HA setup, we do an extra checkpoint to generate a rollback image
name|getFSImage
argument_list|()
operator|.
name|saveNamespace
argument_list|(
name|this
argument_list|,
name|NameNodeFile
operator|.
name|IMAGE_ROLLBACK
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Successfully saved namespace for preparing rolling upgrade."
argument_list|)
expr_stmt|;
comment|// leave SafeMode automatically
name|setSafeMode
argument_list|(
name|SafeModeAction
operator|.
name|SAFEMODE_LEAVE
argument_list|)
expr_stmt|;
name|setRollingUpgradeInfo
argument_list|(
literal|true
argument_list|,
name|startTime
argument_list|)
expr_stmt|;
block|}
DECL|method|setRollingUpgradeInfo (boolean createdRollbackImages, long startTime)
name|void
name|setRollingUpgradeInfo
parameter_list|(
name|boolean
name|createdRollbackImages
parameter_list|,
name|long
name|startTime
parameter_list|)
block|{
name|rollingUpgradeInfo
operator|=
operator|new
name|RollingUpgradeInfo
argument_list|(
name|blockPoolId
argument_list|,
name|createdRollbackImages
argument_list|,
name|startTime
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
block|}
DECL|method|setCreatedRollbackImages (boolean created)
specifier|public
name|void
name|setCreatedRollbackImages
parameter_list|(
name|boolean
name|created
parameter_list|)
block|{
if|if
condition|(
name|rollingUpgradeInfo
operator|!=
literal|null
condition|)
block|{
name|rollingUpgradeInfo
operator|.
name|setCreatedRollbackImages
argument_list|(
name|created
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|getRollingUpgradeInfo ()
specifier|public
name|RollingUpgradeInfo
name|getRollingUpgradeInfo
parameter_list|()
block|{
return|return
name|rollingUpgradeInfo
return|;
block|}
DECL|method|isNeedRollbackFsImage ()
specifier|public
name|boolean
name|isNeedRollbackFsImage
parameter_list|()
block|{
return|return
name|needRollbackFsImage
return|;
block|}
DECL|method|setNeedRollbackFsImage (boolean needRollbackFsImage)
specifier|public
name|void
name|setNeedRollbackFsImage
parameter_list|(
name|boolean
name|needRollbackFsImage
parameter_list|)
block|{
name|this
operator|.
name|needRollbackFsImage
operator|=
name|needRollbackFsImage
expr_stmt|;
block|}
annotation|@
name|Override
comment|// NameNodeMXBean
DECL|method|getRollingUpgradeStatus ()
specifier|public
name|RollingUpgradeInfo
operator|.
name|Bean
name|getRollingUpgradeStatus
parameter_list|()
block|{
if|if
condition|(
operator|!
name|isRollingUpgrade
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
name|RollingUpgradeInfo
name|upgradeInfo
init|=
name|getRollingUpgradeInfo
argument_list|()
decl_stmt|;
if|if
condition|(
name|upgradeInfo
operator|.
name|createdRollbackImages
argument_list|()
condition|)
block|{
return|return
operator|new
name|RollingUpgradeInfo
operator|.
name|Bean
argument_list|(
name|upgradeInfo
argument_list|)
return|;
block|}
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
comment|// check again after acquiring the read lock.
name|upgradeInfo
operator|=
name|getRollingUpgradeInfo
argument_list|()
expr_stmt|;
if|if
condition|(
name|upgradeInfo
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
operator|!
name|upgradeInfo
operator|.
name|createdRollbackImages
argument_list|()
condition|)
block|{
name|boolean
name|hasRollbackImage
init|=
name|this
operator|.
name|getFSImage
argument_list|()
operator|.
name|hasRollbackFSImage
argument_list|()
decl_stmt|;
name|upgradeInfo
operator|.
name|setCreatedRollbackImages
argument_list|(
name|hasRollbackImage
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Encountered exception setting Rollback Image"
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
return|return
operator|new
name|RollingUpgradeInfo
operator|.
name|Bean
argument_list|(
name|upgradeInfo
argument_list|)
return|;
block|}
comment|/** Is rolling upgrade in progress? */
DECL|method|isRollingUpgrade ()
specifier|public
name|boolean
name|isRollingUpgrade
parameter_list|()
block|{
return|return
name|rollingUpgradeInfo
operator|!=
literal|null
operator|&&
operator|!
name|rollingUpgradeInfo
operator|.
name|isFinalized
argument_list|()
return|;
block|}
comment|/**    * Returns the layout version in effect.  Under normal operation, this is the    * same as the software's current layout version, defined in    * {@link NameNodeLayoutVersion#CURRENT_LAYOUT_VERSION}.  During a rolling    * upgrade, this can retain the layout version that was persisted to metadata    * prior to starting the rolling upgrade, back to a lower bound defined in    * {@link NameNodeLayoutVersion#MINIMUM_COMPATIBLE_LAYOUT_VERSION}.  New    * fsimage files and edit log segments will continue to be written with this    * older layout version, so that the files are still readable by the old    * software version if the admin chooses to downgrade.    *    * @return layout version in effect    */
DECL|method|getEffectiveLayoutVersion ()
specifier|public
name|int
name|getEffectiveLayoutVersion
parameter_list|()
block|{
return|return
name|getEffectiveLayoutVersion
argument_list|(
name|isRollingUpgrade
argument_list|()
argument_list|,
name|fsImage
operator|.
name|getStorage
argument_list|()
operator|.
name|getLayoutVersion
argument_list|()
argument_list|,
name|NameNodeLayoutVersion
operator|.
name|MINIMUM_COMPATIBLE_LAYOUT_VERSION
argument_list|,
name|NameNodeLayoutVersion
operator|.
name|CURRENT_LAYOUT_VERSION
argument_list|)
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|getEffectiveLayoutVersion (boolean isRollingUpgrade, int storageLV, int minCompatLV, int currentLV)
specifier|static
name|int
name|getEffectiveLayoutVersion
parameter_list|(
name|boolean
name|isRollingUpgrade
parameter_list|,
name|int
name|storageLV
parameter_list|,
name|int
name|minCompatLV
parameter_list|,
name|int
name|currentLV
parameter_list|)
block|{
if|if
condition|(
name|isRollingUpgrade
condition|)
block|{
if|if
condition|(
name|storageLV
operator|<=
name|minCompatLV
condition|)
block|{
comment|// The prior layout version satisfies the minimum compatible layout
comment|// version of the current software.  Keep reporting the prior layout
comment|// as the effective one.  Downgrade is possible.
return|return
name|storageLV
return|;
block|}
block|}
comment|// The current software cannot satisfy the layout version of the prior
comment|// software.  Proceed with using the current layout version.
return|return
name|currentLV
return|;
block|}
comment|/**    * Performs a pre-condition check that the layout version in effect is    * sufficient to support the requested {@link Feature}.  If not, then the    * method throws {@link HadoopIllegalArgumentException} to deny the operation.    * This exception class is registered as a terse exception, so it prevents    * verbose stack traces in the NameNode log.  During a rolling upgrade, this    * method is used to restrict usage of new features.  This prevents writing    * new edit log operations that would be unreadable by the old software    * version if the admin chooses to downgrade.    *    * @param f feature to check    * @throws HadoopIllegalArgumentException if the current layout version in    *     effect is insufficient to support the feature    */
DECL|method|requireEffectiveLayoutVersionForFeature (Feature f)
specifier|private
name|void
name|requireEffectiveLayoutVersionForFeature
parameter_list|(
name|Feature
name|f
parameter_list|)
throws|throws
name|HadoopIllegalArgumentException
block|{
name|int
name|lv
init|=
name|getEffectiveLayoutVersion
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|NameNodeLayoutVersion
operator|.
name|supports
argument_list|(
name|f
argument_list|,
name|lv
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|HadoopIllegalArgumentException
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Feature %s unsupported at NameNode layout version %d.  If a "
operator|+
literal|"rolling upgrade is in progress, then it must be finalized before "
operator|+
literal|"using this feature."
argument_list|,
name|f
argument_list|,
name|lv
argument_list|)
argument_list|)
throw|;
block|}
block|}
DECL|method|checkRollingUpgrade (String action)
name|void
name|checkRollingUpgrade
parameter_list|(
name|String
name|action
parameter_list|)
throws|throws
name|RollingUpgradeException
block|{
if|if
condition|(
name|isRollingUpgrade
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|RollingUpgradeException
argument_list|(
literal|"Failed to "
operator|+
name|action
operator|+
literal|" since a rolling upgrade is already in progress."
operator|+
literal|" Existing rolling upgrade info:\n"
operator|+
name|rollingUpgradeInfo
argument_list|)
throw|;
block|}
block|}
DECL|method|finalizeRollingUpgrade ()
name|RollingUpgradeInfo
name|finalizeRollingUpgrade
parameter_list|()
throws|throws
name|IOException
block|{
name|checkSuperuserPrivilege
argument_list|()
expr_stmt|;
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isRollingUpgrade
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
name|checkNameNodeSafeMode
argument_list|(
literal|"Failed to finalize rolling upgrade"
argument_list|)
expr_stmt|;
name|finalizeRollingUpgradeInternal
argument_list|(
name|now
argument_list|()
argument_list|)
expr_stmt|;
name|getEditLog
argument_list|()
operator|.
name|logFinalizeRollingUpgrade
argument_list|(
name|rollingUpgradeInfo
operator|.
name|getFinalizeTime
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|haEnabled
condition|)
block|{
comment|// roll the edit log to make sure the standby NameNode can tail
name|getFSImage
argument_list|()
operator|.
name|rollEditLog
argument_list|(
name|getEffectiveLayoutVersion
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|getFSImage
argument_list|()
operator|.
name|updateStorageVersion
argument_list|()
expr_stmt|;
name|getFSImage
argument_list|()
operator|.
name|renameCheckpoint
argument_list|(
name|NameNodeFile
operator|.
name|IMAGE_ROLLBACK
argument_list|,
name|NameNodeFile
operator|.
name|IMAGE
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|haEnabled
condition|)
block|{
comment|// Sync not needed for ha since the edit was rolled after logging.
name|getEditLog
argument_list|()
operator|.
name|logSync
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|auditLog
operator|.
name|isInfoEnabled
argument_list|()
operator|&&
name|isExternalInvocation
argument_list|()
condition|)
block|{
name|logAuditEvent
argument_list|(
literal|true
argument_list|,
literal|"finalizeRollingUpgrade"
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
return|return
name|rollingUpgradeInfo
return|;
block|}
DECL|method|finalizeRollingUpgradeInternal (long finalizeTime)
name|void
name|finalizeRollingUpgradeInternal
parameter_list|(
name|long
name|finalizeTime
parameter_list|)
block|{
comment|// Set the finalize time
name|rollingUpgradeInfo
operator|.
name|finalize
argument_list|(
name|finalizeTime
argument_list|)
expr_stmt|;
block|}
DECL|method|addCacheDirective (CacheDirectiveInfo directive, EnumSet<CacheFlag> flags, boolean logRetryCache)
name|long
name|addCacheDirective
parameter_list|(
name|CacheDirectiveInfo
name|directive
parameter_list|,
name|EnumSet
argument_list|<
name|CacheFlag
argument_list|>
name|flags
parameter_list|,
name|boolean
name|logRetryCache
parameter_list|)
throws|throws
name|IOException
block|{
name|CacheDirectiveInfo
name|effectiveDirective
init|=
literal|null
decl_stmt|;
if|if
condition|(
operator|!
name|flags
operator|.
name|contains
argument_list|(
name|CacheFlag
operator|.
name|FORCE
argument_list|)
condition|)
block|{
name|cacheManager
operator|.
name|waitForRescanIfNeeded
argument_list|()
expr_stmt|;
block|}
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|checkNameNodeSafeMode
argument_list|(
literal|"Cannot add cache directive"
argument_list|)
expr_stmt|;
name|effectiveDirective
operator|=
name|FSNDNCacheOp
operator|.
name|addCacheDirective
argument_list|(
name|this
argument_list|,
name|cacheManager
argument_list|,
name|directive
argument_list|,
name|flags
argument_list|,
name|logRetryCache
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
name|boolean
name|success
init|=
name|effectiveDirective
operator|!=
literal|null
decl_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|getEditLog
argument_list|()
operator|.
name|logSync
argument_list|()
expr_stmt|;
block|}
name|String
name|effectiveDirectiveStr
init|=
name|effectiveDirective
operator|!=
literal|null
condition|?
name|effectiveDirective
operator|.
name|toString
argument_list|()
else|:
literal|null
decl_stmt|;
name|logAuditEvent
argument_list|(
name|success
argument_list|,
literal|"addCacheDirective"
argument_list|,
name|effectiveDirectiveStr
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
return|return
name|effectiveDirective
operator|!=
literal|null
condition|?
name|effectiveDirective
operator|.
name|getId
argument_list|()
else|:
literal|0
return|;
block|}
DECL|method|modifyCacheDirective (CacheDirectiveInfo directive, EnumSet<CacheFlag> flags, boolean logRetryCache)
name|void
name|modifyCacheDirective
parameter_list|(
name|CacheDirectiveInfo
name|directive
parameter_list|,
name|EnumSet
argument_list|<
name|CacheFlag
argument_list|>
name|flags
parameter_list|,
name|boolean
name|logRetryCache
parameter_list|)
throws|throws
name|IOException
block|{
name|boolean
name|success
init|=
literal|false
decl_stmt|;
if|if
condition|(
operator|!
name|flags
operator|.
name|contains
argument_list|(
name|CacheFlag
operator|.
name|FORCE
argument_list|)
condition|)
block|{
name|cacheManager
operator|.
name|waitForRescanIfNeeded
argument_list|()
expr_stmt|;
block|}
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|checkNameNodeSafeMode
argument_list|(
literal|"Cannot add cache directive"
argument_list|)
expr_stmt|;
name|FSNDNCacheOp
operator|.
name|modifyCacheDirective
argument_list|(
name|this
argument_list|,
name|cacheManager
argument_list|,
name|directive
argument_list|,
name|flags
argument_list|,
name|logRetryCache
argument_list|)
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|getEditLog
argument_list|()
operator|.
name|logSync
argument_list|()
expr_stmt|;
block|}
name|String
name|idStr
init|=
literal|"{id: "
operator|+
name|directive
operator|.
name|getId
argument_list|()
operator|.
name|toString
argument_list|()
operator|+
literal|"}"
decl_stmt|;
name|logAuditEvent
argument_list|(
name|success
argument_list|,
literal|"modifyCacheDirective"
argument_list|,
name|idStr
argument_list|,
name|directive
operator|.
name|toString
argument_list|()
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|removeCacheDirective (long id, boolean logRetryCache)
name|void
name|removeCacheDirective
parameter_list|(
name|long
name|id
parameter_list|,
name|boolean
name|logRetryCache
parameter_list|)
throws|throws
name|IOException
block|{
name|boolean
name|success
init|=
literal|false
decl_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|checkNameNodeSafeMode
argument_list|(
literal|"Cannot remove cache directives"
argument_list|)
expr_stmt|;
name|FSNDNCacheOp
operator|.
name|removeCacheDirective
argument_list|(
name|this
argument_list|,
name|cacheManager
argument_list|,
name|id
argument_list|,
name|logRetryCache
argument_list|)
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
name|String
name|idStr
init|=
literal|"{id: "
operator|+
name|Long
operator|.
name|toString
argument_list|(
name|id
argument_list|)
operator|+
literal|"}"
decl_stmt|;
name|logAuditEvent
argument_list|(
name|success
argument_list|,
literal|"removeCacheDirective"
argument_list|,
name|idStr
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
name|getEditLog
argument_list|()
operator|.
name|logSync
argument_list|()
expr_stmt|;
block|}
DECL|method|listCacheDirectives ( long startId, CacheDirectiveInfo filter)
name|BatchedListEntries
argument_list|<
name|CacheDirectiveEntry
argument_list|>
name|listCacheDirectives
parameter_list|(
name|long
name|startId
parameter_list|,
name|CacheDirectiveInfo
name|filter
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|READ
argument_list|)
expr_stmt|;
name|BatchedListEntries
argument_list|<
name|CacheDirectiveEntry
argument_list|>
name|results
decl_stmt|;
name|cacheManager
operator|.
name|waitForRescanIfNeeded
argument_list|()
expr_stmt|;
name|readLock
argument_list|()
expr_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|READ
argument_list|)
expr_stmt|;
name|results
operator|=
name|FSNDNCacheOp
operator|.
name|listCacheDirectives
argument_list|(
name|this
argument_list|,
name|cacheManager
argument_list|,
name|startId
argument_list|,
name|filter
argument_list|)
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
name|logAuditEvent
argument_list|(
name|success
argument_list|,
literal|"listCacheDirectives"
argument_list|,
name|filter
operator|.
name|toString
argument_list|()
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
return|return
name|results
return|;
block|}
DECL|method|addCachePool (CachePoolInfo req, boolean logRetryCache)
name|void
name|addCachePool
parameter_list|(
name|CachePoolInfo
name|req
parameter_list|,
name|boolean
name|logRetryCache
parameter_list|)
throws|throws
name|IOException
block|{
name|writeLock
argument_list|()
expr_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
name|String
name|poolInfoStr
init|=
literal|null
decl_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|checkNameNodeSafeMode
argument_list|(
literal|"Cannot add cache pool"
operator|+
operator|(
name|req
operator|==
literal|null
condition|?
literal|null
else|:
name|req
operator|.
name|getPoolName
argument_list|()
operator|)
argument_list|)
expr_stmt|;
name|CachePoolInfo
name|info
init|=
name|FSNDNCacheOp
operator|.
name|addCachePool
argument_list|(
name|this
argument_list|,
name|cacheManager
argument_list|,
name|req
argument_list|,
name|logRetryCache
argument_list|)
decl_stmt|;
name|poolInfoStr
operator|=
name|info
operator|.
name|toString
argument_list|()
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
name|logAuditEvent
argument_list|(
name|success
argument_list|,
literal|"addCachePool"
argument_list|,
name|poolInfoStr
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
name|getEditLog
argument_list|()
operator|.
name|logSync
argument_list|()
expr_stmt|;
block|}
DECL|method|modifyCachePool (CachePoolInfo req, boolean logRetryCache)
name|void
name|modifyCachePool
parameter_list|(
name|CachePoolInfo
name|req
parameter_list|,
name|boolean
name|logRetryCache
parameter_list|)
throws|throws
name|IOException
block|{
name|writeLock
argument_list|()
expr_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|checkNameNodeSafeMode
argument_list|(
literal|"Cannot modify cache pool"
operator|+
operator|(
name|req
operator|==
literal|null
condition|?
literal|null
else|:
name|req
operator|.
name|getPoolName
argument_list|()
operator|)
argument_list|)
expr_stmt|;
name|FSNDNCacheOp
operator|.
name|modifyCachePool
argument_list|(
name|this
argument_list|,
name|cacheManager
argument_list|,
name|req
argument_list|,
name|logRetryCache
argument_list|)
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
name|String
name|poolNameStr
init|=
literal|"{poolName: "
operator|+
operator|(
name|req
operator|==
literal|null
condition|?
literal|null
else|:
name|req
operator|.
name|getPoolName
argument_list|()
operator|)
operator|+
literal|"}"
decl_stmt|;
name|logAuditEvent
argument_list|(
name|success
argument_list|,
literal|"modifyCachePool"
argument_list|,
name|poolNameStr
argument_list|,
name|req
operator|==
literal|null
condition|?
literal|null
else|:
name|req
operator|.
name|toString
argument_list|()
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
name|getEditLog
argument_list|()
operator|.
name|logSync
argument_list|()
expr_stmt|;
block|}
DECL|method|removeCachePool (String cachePoolName, boolean logRetryCache)
name|void
name|removeCachePool
parameter_list|(
name|String
name|cachePoolName
parameter_list|,
name|boolean
name|logRetryCache
parameter_list|)
throws|throws
name|IOException
block|{
name|writeLock
argument_list|()
expr_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|checkNameNodeSafeMode
argument_list|(
literal|"Cannot modify cache pool"
operator|+
name|cachePoolName
argument_list|)
expr_stmt|;
name|FSNDNCacheOp
operator|.
name|removeCachePool
argument_list|(
name|this
argument_list|,
name|cacheManager
argument_list|,
name|cachePoolName
argument_list|,
name|logRetryCache
argument_list|)
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
name|String
name|poolNameStr
init|=
literal|"{poolName: "
operator|+
name|cachePoolName
operator|+
literal|"}"
decl_stmt|;
name|logAuditEvent
argument_list|(
name|success
argument_list|,
literal|"removeCachePool"
argument_list|,
name|poolNameStr
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
name|getEditLog
argument_list|()
operator|.
name|logSync
argument_list|()
expr_stmt|;
block|}
DECL|method|listCachePools (String prevKey)
name|BatchedListEntries
argument_list|<
name|CachePoolEntry
argument_list|>
name|listCachePools
parameter_list|(
name|String
name|prevKey
parameter_list|)
throws|throws
name|IOException
block|{
name|BatchedListEntries
argument_list|<
name|CachePoolEntry
argument_list|>
name|results
decl_stmt|;
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|READ
argument_list|)
expr_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
name|cacheManager
operator|.
name|waitForRescanIfNeeded
argument_list|()
expr_stmt|;
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|READ
argument_list|)
expr_stmt|;
name|results
operator|=
name|FSNDNCacheOp
operator|.
name|listCachePools
argument_list|(
name|this
argument_list|,
name|cacheManager
argument_list|,
name|prevKey
argument_list|)
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
name|logAuditEvent
argument_list|(
name|success
argument_list|,
literal|"listCachePools"
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
return|return
name|results
return|;
block|}
DECL|method|modifyAclEntries (final String src, List<AclEntry> aclSpec)
name|void
name|modifyAclEntries
parameter_list|(
specifier|final
name|String
name|src
parameter_list|,
name|List
argument_list|<
name|AclEntry
argument_list|>
name|aclSpec
parameter_list|)
throws|throws
name|IOException
block|{
name|HdfsFileStatus
name|auditStat
init|=
literal|null
decl_stmt|;
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|checkNameNodeSafeMode
argument_list|(
literal|"Cannot modify ACL entries on "
operator|+
name|src
argument_list|)
expr_stmt|;
name|auditStat
operator|=
name|FSDirAclOp
operator|.
name|modifyAclEntries
argument_list|(
name|dir
argument_list|,
name|src
argument_list|,
name|aclSpec
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|AccessControlException
name|e
parameter_list|)
block|{
name|logAuditEvent
argument_list|(
literal|false
argument_list|,
literal|"modifyAclEntries"
argument_list|,
name|src
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
name|getEditLog
argument_list|()
operator|.
name|logSync
argument_list|()
expr_stmt|;
name|logAuditEvent
argument_list|(
literal|true
argument_list|,
literal|"modifyAclEntries"
argument_list|,
name|src
argument_list|,
literal|null
argument_list|,
name|auditStat
argument_list|)
expr_stmt|;
block|}
DECL|method|removeAclEntries (final String src, List<AclEntry> aclSpec)
name|void
name|removeAclEntries
parameter_list|(
specifier|final
name|String
name|src
parameter_list|,
name|List
argument_list|<
name|AclEntry
argument_list|>
name|aclSpec
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|HdfsFileStatus
name|auditStat
init|=
literal|null
decl_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|checkNameNodeSafeMode
argument_list|(
literal|"Cannot remove ACL entries on "
operator|+
name|src
argument_list|)
expr_stmt|;
name|auditStat
operator|=
name|FSDirAclOp
operator|.
name|removeAclEntries
argument_list|(
name|dir
argument_list|,
name|src
argument_list|,
name|aclSpec
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|AccessControlException
name|e
parameter_list|)
block|{
name|logAuditEvent
argument_list|(
literal|false
argument_list|,
literal|"removeAclEntries"
argument_list|,
name|src
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
name|getEditLog
argument_list|()
operator|.
name|logSync
argument_list|()
expr_stmt|;
name|logAuditEvent
argument_list|(
literal|true
argument_list|,
literal|"removeAclEntries"
argument_list|,
name|src
argument_list|,
literal|null
argument_list|,
name|auditStat
argument_list|)
expr_stmt|;
block|}
DECL|method|removeDefaultAcl (final String src)
name|void
name|removeDefaultAcl
parameter_list|(
specifier|final
name|String
name|src
parameter_list|)
throws|throws
name|IOException
block|{
name|HdfsFileStatus
name|auditStat
init|=
literal|null
decl_stmt|;
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|checkNameNodeSafeMode
argument_list|(
literal|"Cannot remove default ACL entries on "
operator|+
name|src
argument_list|)
expr_stmt|;
name|auditStat
operator|=
name|FSDirAclOp
operator|.
name|removeDefaultAcl
argument_list|(
name|dir
argument_list|,
name|src
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|AccessControlException
name|e
parameter_list|)
block|{
name|logAuditEvent
argument_list|(
literal|false
argument_list|,
literal|"removeDefaultAcl"
argument_list|,
name|src
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
name|getEditLog
argument_list|()
operator|.
name|logSync
argument_list|()
expr_stmt|;
name|logAuditEvent
argument_list|(
literal|true
argument_list|,
literal|"removeDefaultAcl"
argument_list|,
name|src
argument_list|,
literal|null
argument_list|,
name|auditStat
argument_list|)
expr_stmt|;
block|}
DECL|method|removeAcl (final String src)
name|void
name|removeAcl
parameter_list|(
specifier|final
name|String
name|src
parameter_list|)
throws|throws
name|IOException
block|{
name|HdfsFileStatus
name|auditStat
init|=
literal|null
decl_stmt|;
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|checkNameNodeSafeMode
argument_list|(
literal|"Cannot remove ACL on "
operator|+
name|src
argument_list|)
expr_stmt|;
name|auditStat
operator|=
name|FSDirAclOp
operator|.
name|removeAcl
argument_list|(
name|dir
argument_list|,
name|src
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|AccessControlException
name|e
parameter_list|)
block|{
name|logAuditEvent
argument_list|(
literal|false
argument_list|,
literal|"removeAcl"
argument_list|,
name|src
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
name|getEditLog
argument_list|()
operator|.
name|logSync
argument_list|()
expr_stmt|;
name|logAuditEvent
argument_list|(
literal|true
argument_list|,
literal|"removeAcl"
argument_list|,
name|src
argument_list|,
literal|null
argument_list|,
name|auditStat
argument_list|)
expr_stmt|;
block|}
DECL|method|setAcl (final String src, List<AclEntry> aclSpec)
name|void
name|setAcl
parameter_list|(
specifier|final
name|String
name|src
parameter_list|,
name|List
argument_list|<
name|AclEntry
argument_list|>
name|aclSpec
parameter_list|)
throws|throws
name|IOException
block|{
name|HdfsFileStatus
name|auditStat
init|=
literal|null
decl_stmt|;
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|checkNameNodeSafeMode
argument_list|(
literal|"Cannot set ACL on "
operator|+
name|src
argument_list|)
expr_stmt|;
name|auditStat
operator|=
name|FSDirAclOp
operator|.
name|setAcl
argument_list|(
name|dir
argument_list|,
name|src
argument_list|,
name|aclSpec
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|AccessControlException
name|e
parameter_list|)
block|{
name|logAuditEvent
argument_list|(
literal|false
argument_list|,
literal|"setAcl"
argument_list|,
name|src
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
name|getEditLog
argument_list|()
operator|.
name|logSync
argument_list|()
expr_stmt|;
name|logAuditEvent
argument_list|(
literal|true
argument_list|,
literal|"setAcl"
argument_list|,
name|src
argument_list|,
literal|null
argument_list|,
name|auditStat
argument_list|)
expr_stmt|;
block|}
DECL|method|getAclStatus (String src)
name|AclStatus
name|getAclStatus
parameter_list|(
name|String
name|src
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|READ
argument_list|)
expr_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|READ
argument_list|)
expr_stmt|;
specifier|final
name|AclStatus
name|ret
init|=
name|FSDirAclOp
operator|.
name|getAclStatus
argument_list|(
name|dir
argument_list|,
name|src
argument_list|)
decl_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
return|return
name|ret
return|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
name|logAuditEvent
argument_list|(
name|success
argument_list|,
literal|"getAclStatus"
argument_list|,
name|src
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Create an encryption zone on directory src using the specified key.    *    * @param src     the path of a directory which will be the root of the    *                encryption zone. The directory must be empty.    * @param keyName name of a key which must be present in the configured    *                KeyProvider.    * @throws AccessControlException  if the caller is not the superuser.    * @throws UnresolvedLinkException if the path can't be resolved.    * @throws SafeModeException       if the Namenode is in safe mode.    */
DECL|method|createEncryptionZone (final String src, final String keyName, boolean logRetryCache)
name|void
name|createEncryptionZone
parameter_list|(
specifier|final
name|String
name|src
parameter_list|,
specifier|final
name|String
name|keyName
parameter_list|,
name|boolean
name|logRetryCache
parameter_list|)
throws|throws
name|IOException
throws|,
name|UnresolvedLinkException
throws|,
name|SafeModeException
throws|,
name|AccessControlException
block|{
try|try
block|{
if|if
condition|(
name|provider
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Can't create an encryption zone for "
operator|+
name|src
operator|+
literal|" since no key provider is available."
argument_list|)
throw|;
block|}
if|if
condition|(
name|keyName
operator|==
literal|null
operator|||
name|keyName
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Must specify a key name when creating an "
operator|+
literal|"encryption zone"
argument_list|)
throw|;
block|}
name|KeyProvider
operator|.
name|Metadata
name|metadata
init|=
name|provider
operator|.
name|getMetadata
argument_list|(
name|keyName
argument_list|)
decl_stmt|;
if|if
condition|(
name|metadata
operator|==
literal|null
condition|)
block|{
comment|/*          * It would be nice if we threw something more specific than          * IOException when the key is not found, but the KeyProvider API          * doesn't provide for that. If that API is ever changed to throw          * something more specific (e.g. UnknownKeyException) then we can          * update this to match it, or better yet, just rethrow the          * KeyProvider's exception.          */
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Key "
operator|+
name|keyName
operator|+
literal|" doesn't exist."
argument_list|)
throw|;
block|}
comment|// If the provider supports pool for EDEKs, this will fill in the pool
name|provider
operator|.
name|warmUpEncryptedKeys
argument_list|(
name|keyName
argument_list|)
expr_stmt|;
name|createEncryptionZoneInt
argument_list|(
name|src
argument_list|,
name|metadata
operator|.
name|getCipher
argument_list|()
argument_list|,
name|keyName
argument_list|,
name|logRetryCache
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|AccessControlException
name|e
parameter_list|)
block|{
name|logAuditEvent
argument_list|(
literal|false
argument_list|,
literal|"createEncryptionZone"
argument_list|,
name|src
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
DECL|method|createEncryptionZoneInt (final String srcArg, String cipher, String keyName, final boolean logRetryCache)
specifier|private
name|void
name|createEncryptionZoneInt
parameter_list|(
specifier|final
name|String
name|srcArg
parameter_list|,
name|String
name|cipher
parameter_list|,
name|String
name|keyName
parameter_list|,
specifier|final
name|boolean
name|logRetryCache
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|src
init|=
name|srcArg
decl_stmt|;
name|HdfsFileStatus
name|resultingStat
init|=
literal|null
decl_stmt|;
name|checkSuperuserPrivilege
argument_list|()
expr_stmt|;
specifier|final
name|byte
index|[]
index|[]
name|pathComponents
init|=
name|FSDirectory
operator|.
name|getPathComponentsForReservedPath
argument_list|(
name|src
argument_list|)
decl_stmt|;
name|FSPermissionChecker
name|pc
init|=
name|getPermissionChecker
argument_list|()
decl_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkSuperuserPrivilege
argument_list|()
expr_stmt|;
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|checkNameNodeSafeMode
argument_list|(
literal|"Cannot create encryption zone on "
operator|+
name|src
argument_list|)
expr_stmt|;
name|src
operator|=
name|dir
operator|.
name|resolvePath
argument_list|(
name|pc
argument_list|,
name|src
argument_list|,
name|pathComponents
argument_list|)
expr_stmt|;
specifier|final
name|CipherSuite
name|suite
init|=
name|CipherSuite
operator|.
name|convert
argument_list|(
name|cipher
argument_list|)
decl_stmt|;
comment|// For now this is hardcoded, as we only support one method.
specifier|final
name|CryptoProtocolVersion
name|version
init|=
name|CryptoProtocolVersion
operator|.
name|ENCRYPTION_ZONES
decl_stmt|;
specifier|final
name|XAttr
name|ezXAttr
init|=
name|dir
operator|.
name|createEncryptionZone
argument_list|(
name|src
argument_list|,
name|suite
argument_list|,
name|version
argument_list|,
name|keyName
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|XAttr
argument_list|>
name|xAttrs
init|=
name|Lists
operator|.
name|newArrayListWithCapacity
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|xAttrs
operator|.
name|add
argument_list|(
name|ezXAttr
argument_list|)
expr_stmt|;
name|getEditLog
argument_list|()
operator|.
name|logSetXAttrs
argument_list|(
name|src
argument_list|,
name|xAttrs
argument_list|,
name|logRetryCache
argument_list|)
expr_stmt|;
specifier|final
name|INodesInPath
name|iip
init|=
name|dir
operator|.
name|getINodesInPath4Write
argument_list|(
name|src
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|resultingStat
operator|=
name|dir
operator|.
name|getAuditFileInfo
argument_list|(
name|iip
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
name|getEditLog
argument_list|()
operator|.
name|logSync
argument_list|()
expr_stmt|;
name|logAuditEvent
argument_list|(
literal|true
argument_list|,
literal|"createEncryptionZone"
argument_list|,
name|srcArg
argument_list|,
literal|null
argument_list|,
name|resultingStat
argument_list|)
expr_stmt|;
block|}
comment|/**    * Get the encryption zone for the specified path.    *    * @param srcArg the path of a file or directory to get the EZ for.    * @return the EZ of the of the path or null if none.    * @throws AccessControlException  if the caller is not the superuser.    * @throws UnresolvedLinkException if the path can't be resolved.    */
DECL|method|getEZForPath (final String srcArg)
name|EncryptionZone
name|getEZForPath
parameter_list|(
specifier|final
name|String
name|srcArg
parameter_list|)
throws|throws
name|AccessControlException
throws|,
name|UnresolvedLinkException
throws|,
name|IOException
block|{
name|String
name|src
init|=
name|srcArg
decl_stmt|;
name|HdfsFileStatus
name|resultingStat
init|=
literal|null
decl_stmt|;
specifier|final
name|byte
index|[]
index|[]
name|pathComponents
init|=
name|FSDirectory
operator|.
name|getPathComponentsForReservedPath
argument_list|(
name|src
argument_list|)
decl_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
specifier|final
name|FSPermissionChecker
name|pc
init|=
name|getPermissionChecker
argument_list|()
decl_stmt|;
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|READ
argument_list|)
expr_stmt|;
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|READ
argument_list|)
expr_stmt|;
name|src
operator|=
name|dir
operator|.
name|resolvePath
argument_list|(
name|pc
argument_list|,
name|src
argument_list|,
name|pathComponents
argument_list|)
expr_stmt|;
specifier|final
name|INodesInPath
name|iip
init|=
name|dir
operator|.
name|getINodesInPath
argument_list|(
name|src
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|isPermissionEnabled
condition|)
block|{
name|dir
operator|.
name|checkPathAccess
argument_list|(
name|pc
argument_list|,
name|iip
argument_list|,
name|FsAction
operator|.
name|READ
argument_list|)
expr_stmt|;
block|}
specifier|final
name|EncryptionZone
name|ret
init|=
name|dir
operator|.
name|getEZForPath
argument_list|(
name|iip
argument_list|)
decl_stmt|;
name|resultingStat
operator|=
name|dir
operator|.
name|getAuditFileInfo
argument_list|(
name|iip
argument_list|)
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
return|return
name|ret
return|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
name|logAuditEvent
argument_list|(
name|success
argument_list|,
literal|"getEZForPath"
argument_list|,
name|srcArg
argument_list|,
literal|null
argument_list|,
name|resultingStat
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|listEncryptionZones (long prevId)
name|BatchedListEntries
argument_list|<
name|EncryptionZone
argument_list|>
name|listEncryptionZones
parameter_list|(
name|long
name|prevId
parameter_list|)
throws|throws
name|IOException
block|{
name|boolean
name|success
init|=
literal|false
decl_stmt|;
name|checkSuperuserPrivilege
argument_list|()
expr_stmt|;
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|READ
argument_list|)
expr_stmt|;
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkSuperuserPrivilege
argument_list|()
expr_stmt|;
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|READ
argument_list|)
expr_stmt|;
specifier|final
name|BatchedListEntries
argument_list|<
name|EncryptionZone
argument_list|>
name|ret
init|=
name|dir
operator|.
name|listEncryptionZones
argument_list|(
name|prevId
argument_list|)
decl_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
return|return
name|ret
return|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
name|logAuditEvent
argument_list|(
name|success
argument_list|,
literal|"listEncryptionZones"
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|setXAttr (String src, XAttr xAttr, EnumSet<XAttrSetFlag> flag, boolean logRetryCache)
name|void
name|setXAttr
parameter_list|(
name|String
name|src
parameter_list|,
name|XAttr
name|xAttr
parameter_list|,
name|EnumSet
argument_list|<
name|XAttrSetFlag
argument_list|>
name|flag
parameter_list|,
name|boolean
name|logRetryCache
parameter_list|)
throws|throws
name|IOException
block|{
name|HdfsFileStatus
name|auditStat
init|=
literal|null
decl_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|checkNameNodeSafeMode
argument_list|(
literal|"Cannot set XAttr on "
operator|+
name|src
argument_list|)
expr_stmt|;
name|auditStat
operator|=
name|FSDirXAttrOp
operator|.
name|setXAttr
argument_list|(
name|dir
argument_list|,
name|src
argument_list|,
name|xAttr
argument_list|,
name|flag
argument_list|,
name|logRetryCache
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|AccessControlException
name|e
parameter_list|)
block|{
name|logAuditEvent
argument_list|(
literal|false
argument_list|,
literal|"setXAttr"
argument_list|,
name|src
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
name|getEditLog
argument_list|()
operator|.
name|logSync
argument_list|()
expr_stmt|;
name|logAuditEvent
argument_list|(
literal|true
argument_list|,
literal|"setXAttr"
argument_list|,
name|src
argument_list|,
literal|null
argument_list|,
name|auditStat
argument_list|)
expr_stmt|;
block|}
DECL|method|getXAttrs (final String src, List<XAttr> xAttrs)
name|List
argument_list|<
name|XAttr
argument_list|>
name|getXAttrs
parameter_list|(
specifier|final
name|String
name|src
parameter_list|,
name|List
argument_list|<
name|XAttr
argument_list|>
name|xAttrs
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|READ
argument_list|)
expr_stmt|;
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|READ
argument_list|)
expr_stmt|;
return|return
name|FSDirXAttrOp
operator|.
name|getXAttrs
argument_list|(
name|dir
argument_list|,
name|src
argument_list|,
name|xAttrs
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|AccessControlException
name|e
parameter_list|)
block|{
name|logAuditEvent
argument_list|(
literal|false
argument_list|,
literal|"getXAttrs"
argument_list|,
name|src
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|listXAttrs (String src)
name|List
argument_list|<
name|XAttr
argument_list|>
name|listXAttrs
parameter_list|(
name|String
name|src
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|READ
argument_list|)
expr_stmt|;
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|READ
argument_list|)
expr_stmt|;
return|return
name|FSDirXAttrOp
operator|.
name|listXAttrs
argument_list|(
name|dir
argument_list|,
name|src
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|AccessControlException
name|e
parameter_list|)
block|{
name|logAuditEvent
argument_list|(
literal|false
argument_list|,
literal|"listXAttrs"
argument_list|,
name|src
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|removeXAttr (String src, XAttr xAttr, boolean logRetryCache)
name|void
name|removeXAttr
parameter_list|(
name|String
name|src
parameter_list|,
name|XAttr
name|xAttr
parameter_list|,
name|boolean
name|logRetryCache
parameter_list|)
throws|throws
name|IOException
block|{
name|HdfsFileStatus
name|auditStat
init|=
literal|null
decl_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|checkNameNodeSafeMode
argument_list|(
literal|"Cannot remove XAttr entry on "
operator|+
name|src
argument_list|)
expr_stmt|;
name|auditStat
operator|=
name|FSDirXAttrOp
operator|.
name|removeXAttr
argument_list|(
name|dir
argument_list|,
name|src
argument_list|,
name|xAttr
argument_list|,
name|logRetryCache
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|AccessControlException
name|e
parameter_list|)
block|{
name|logAuditEvent
argument_list|(
literal|false
argument_list|,
literal|"removeXAttr"
argument_list|,
name|src
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
name|getEditLog
argument_list|()
operator|.
name|logSync
argument_list|()
expr_stmt|;
name|logAuditEvent
argument_list|(
literal|true
argument_list|,
literal|"removeXAttr"
argument_list|,
name|src
argument_list|,
literal|null
argument_list|,
name|auditStat
argument_list|)
expr_stmt|;
block|}
DECL|method|checkAccess (String src, FsAction mode)
name|void
name|checkAccess
parameter_list|(
name|String
name|src
parameter_list|,
name|FsAction
name|mode
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|READ
argument_list|)
expr_stmt|;
name|byte
index|[]
index|[]
name|pathComponents
init|=
name|FSDirectory
operator|.
name|getPathComponentsForReservedPath
argument_list|(
name|src
argument_list|)
decl_stmt|;
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|READ
argument_list|)
expr_stmt|;
name|src
operator|=
name|FSDirectory
operator|.
name|resolvePath
argument_list|(
name|src
argument_list|,
name|pathComponents
argument_list|,
name|dir
argument_list|)
expr_stmt|;
specifier|final
name|INodesInPath
name|iip
init|=
name|dir
operator|.
name|getINodesInPath
argument_list|(
name|src
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|INode
name|inode
init|=
name|iip
operator|.
name|getLastINode
argument_list|()
decl_stmt|;
if|if
condition|(
name|inode
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|FileNotFoundException
argument_list|(
literal|"Path not found"
argument_list|)
throw|;
block|}
if|if
condition|(
name|isPermissionEnabled
condition|)
block|{
name|FSPermissionChecker
name|pc
init|=
name|getPermissionChecker
argument_list|()
decl_stmt|;
name|dir
operator|.
name|checkPathAccess
argument_list|(
name|pc
argument_list|,
name|iip
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|AccessControlException
name|e
parameter_list|)
block|{
name|logAuditEvent
argument_list|(
literal|false
argument_list|,
literal|"checkAccess"
argument_list|,
name|src
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Default AuditLogger implementation; used when no access logger is    * defined in the config file. It can also be explicitly listed in the    * config file.    */
annotation|@
name|VisibleForTesting
DECL|class|DefaultAuditLogger
specifier|static
class|class
name|DefaultAuditLogger
extends|extends
name|HdfsAuditLogger
block|{
DECL|field|logTokenTrackingId
specifier|private
name|boolean
name|logTokenTrackingId
decl_stmt|;
DECL|field|debugCmdSet
specifier|private
name|Set
argument_list|<
name|String
argument_list|>
name|debugCmdSet
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
annotation|@
name|Override
DECL|method|initialize (Configuration conf)
specifier|public
name|void
name|initialize
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
name|logTokenTrackingId
operator|=
name|conf
operator|.
name|getBoolean
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_AUDIT_LOG_TOKEN_TRACKING_ID_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_AUDIT_LOG_TOKEN_TRACKING_ID_DEFAULT
argument_list|)
expr_stmt|;
name|debugCmdSet
operator|.
name|addAll
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|conf
operator|.
name|getTrimmedStrings
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_AUDIT_LOG_DEBUG_CMDLIST
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|logAuditEvent (boolean succeeded, String userName, InetAddress addr, String cmd, String src, String dst, FileStatus status, UserGroupInformation ugi, DelegationTokenSecretManager dtSecretManager)
specifier|public
name|void
name|logAuditEvent
parameter_list|(
name|boolean
name|succeeded
parameter_list|,
name|String
name|userName
parameter_list|,
name|InetAddress
name|addr
parameter_list|,
name|String
name|cmd
parameter_list|,
name|String
name|src
parameter_list|,
name|String
name|dst
parameter_list|,
name|FileStatus
name|status
parameter_list|,
name|UserGroupInformation
name|ugi
parameter_list|,
name|DelegationTokenSecretManager
name|dtSecretManager
parameter_list|)
block|{
if|if
condition|(
name|auditLog
operator|.
name|isDebugEnabled
argument_list|()
operator|||
operator|(
name|auditLog
operator|.
name|isInfoEnabled
argument_list|()
operator|&&
operator|!
name|debugCmdSet
operator|.
name|contains
argument_list|(
name|cmd
argument_list|)
operator|)
condition|)
block|{
specifier|final
name|StringBuilder
name|sb
init|=
name|auditBuffer
operator|.
name|get
argument_list|()
decl_stmt|;
name|sb
operator|.
name|setLength
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"allowed="
argument_list|)
operator|.
name|append
argument_list|(
name|succeeded
argument_list|)
operator|.
name|append
argument_list|(
literal|"\t"
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"ugi="
argument_list|)
operator|.
name|append
argument_list|(
name|userName
argument_list|)
operator|.
name|append
argument_list|(
literal|"\t"
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"ip="
argument_list|)
operator|.
name|append
argument_list|(
name|addr
argument_list|)
operator|.
name|append
argument_list|(
literal|"\t"
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"cmd="
argument_list|)
operator|.
name|append
argument_list|(
name|cmd
argument_list|)
operator|.
name|append
argument_list|(
literal|"\t"
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"src="
argument_list|)
operator|.
name|append
argument_list|(
name|src
argument_list|)
operator|.
name|append
argument_list|(
literal|"\t"
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"dst="
argument_list|)
operator|.
name|append
argument_list|(
name|dst
argument_list|)
operator|.
name|append
argument_list|(
literal|"\t"
argument_list|)
expr_stmt|;
if|if
condition|(
literal|null
operator|==
name|status
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|"perm=null"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sb
operator|.
name|append
argument_list|(
literal|"perm="
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|status
operator|.
name|getOwner
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|":"
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|status
operator|.
name|getGroup
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|":"
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|status
operator|.
name|getPermission
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|logTokenTrackingId
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|"\t"
argument_list|)
operator|.
name|append
argument_list|(
literal|"trackingId="
argument_list|)
expr_stmt|;
name|String
name|trackingId
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|ugi
operator|!=
literal|null
operator|&&
name|dtSecretManager
operator|!=
literal|null
operator|&&
name|ugi
operator|.
name|getAuthenticationMethod
argument_list|()
operator|==
name|AuthenticationMethod
operator|.
name|TOKEN
condition|)
block|{
for|for
control|(
name|TokenIdentifier
name|tid
range|:
name|ugi
operator|.
name|getTokenIdentifiers
argument_list|()
control|)
block|{
if|if
condition|(
name|tid
operator|instanceof
name|DelegationTokenIdentifier
condition|)
block|{
name|DelegationTokenIdentifier
name|dtid
init|=
operator|(
name|DelegationTokenIdentifier
operator|)
name|tid
decl_stmt|;
name|trackingId
operator|=
name|dtSecretManager
operator|.
name|getTokenTrackingId
argument_list|(
name|dtid
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
name|sb
operator|.
name|append
argument_list|(
name|trackingId
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
literal|"\t"
argument_list|)
operator|.
name|append
argument_list|(
literal|"proto="
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|NamenodeWebHdfsMethods
operator|.
name|isWebHdfsInvocation
argument_list|()
condition|?
literal|"webhdfs"
else|:
literal|"rpc"
argument_list|)
expr_stmt|;
name|logAuditMessage
argument_list|(
name|sb
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|logAuditMessage (String message)
specifier|public
name|void
name|logAuditMessage
parameter_list|(
name|String
name|message
parameter_list|)
block|{
name|auditLog
operator|.
name|info
argument_list|(
name|message
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|enableAsyncAuditLog ()
specifier|private
specifier|static
name|void
name|enableAsyncAuditLog
parameter_list|()
block|{
if|if
condition|(
operator|!
operator|(
name|auditLog
operator|instanceof
name|Log4JLogger
operator|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Log4j is required to enable async auditlog"
argument_list|)
expr_stmt|;
return|return;
block|}
name|Logger
name|logger
init|=
operator|(
operator|(
name|Log4JLogger
operator|)
name|auditLog
operator|)
operator|.
name|getLogger
argument_list|()
decl_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|List
argument_list|<
name|Appender
argument_list|>
name|appenders
init|=
name|Collections
operator|.
name|list
argument_list|(
name|logger
operator|.
name|getAllAppenders
argument_list|()
argument_list|)
decl_stmt|;
comment|// failsafe against trying to async it more than once
if|if
condition|(
operator|!
name|appenders
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
operator|(
name|appenders
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|instanceof
name|AsyncAppender
operator|)
condition|)
block|{
name|AsyncAppender
name|asyncAppender
init|=
operator|new
name|AsyncAppender
argument_list|()
decl_stmt|;
comment|// change logger to have an async appender containing all the
comment|// previously configured appenders
for|for
control|(
name|Appender
name|appender
range|:
name|appenders
control|)
block|{
name|logger
operator|.
name|removeAppender
argument_list|(
name|appender
argument_list|)
expr_stmt|;
name|asyncAppender
operator|.
name|addAppender
argument_list|(
name|appender
argument_list|)
expr_stmt|;
block|}
name|logger
operator|.
name|addAppender
argument_list|(
name|asyncAppender
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Return total number of Sync Operations on FSEditLog.    */
annotation|@
name|Override
annotation|@
name|Metric
argument_list|(
block|{
literal|"TotalSyncCount"
block|,
literal|"Total number of sync operations performed on edit logs"
block|}
argument_list|)
DECL|method|getTotalSyncCount ()
specifier|public
name|long
name|getTotalSyncCount
parameter_list|()
block|{
return|return
name|fsImage
operator|.
name|editLog
operator|.
name|getTotalSyncCount
argument_list|()
return|;
block|}
comment|/**    * Return total time spent doing sync operations on FSEditLog.    */
annotation|@
name|Override
annotation|@
name|Metric
argument_list|(
block|{
literal|"TotalSyncTimes"
block|,
literal|"Total time spend in sync operation on various edit logs"
block|}
argument_list|)
DECL|method|getTotalSyncTimes ()
specifier|public
name|String
name|getTotalSyncTimes
parameter_list|()
block|{
name|JournalSet
name|journalSet
init|=
name|fsImage
operator|.
name|editLog
operator|.
name|getJournalSet
argument_list|()
decl_stmt|;
if|if
condition|(
name|journalSet
operator|!=
literal|null
condition|)
block|{
return|return
name|journalSet
operator|.
name|getSyncTimes
argument_list|()
return|;
block|}
else|else
block|{
return|return
literal|""
return|;
block|}
block|}
block|}
end_class

end_unit

