begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdfs.server.namenode
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|CommonConfigurationKeysPublic
operator|.
name|FS_TRASH_INTERVAL_DEFAULT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|CommonConfigurationKeysPublic
operator|.
name|FS_TRASH_INTERVAL_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|CommonConfigurationKeysPublic
operator|.
name|IO_FILE_BUFFER_SIZE_DEFAULT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|CommonConfigurationKeysPublic
operator|.
name|IO_FILE_BUFFER_SIZE_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_BLOCK_SIZE_DEFAULT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_BLOCK_SIZE_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_BYTES_PER_CHECKSUM_DEFAULT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_BYTES_PER_CHECKSUM_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_CHECKSUM_TYPE_DEFAULT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_CHECKSUM_TYPE_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_CLIENT_WRITE_PACKET_SIZE_DEFAULT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_CLIENT_WRITE_PACKET_SIZE_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_ENCRYPT_DATA_TRANSFER_DEFAULT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_ENCRYPT_DATA_TRANSFER_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_HA_STANDBY_CHECKPOINTS_DEFAULT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_HA_STANDBY_CHECKPOINTS_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_ACCESSTIME_PRECISION_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_AUDIT_LOGGERS_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_DEFAULT_AUDIT_LOGGER_NAME
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_DELEGATION_KEY_UPDATE_INTERVAL_DEFAULT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_DELEGATION_KEY_UPDATE_INTERVAL_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_DELEGATION_TOKEN_ALWAYS_USE_DEFAULT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_DELEGATION_TOKEN_ALWAYS_USE_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_DELEGATION_TOKEN_MAX_LIFETIME_DEFAULT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_DELEGATION_TOKEN_MAX_LIFETIME_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_DELEGATION_TOKEN_RENEW_INTERVAL_DEFAULT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_DELEGATION_TOKEN_RENEW_INTERVAL_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_EDITS_DIR_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_EDITS_DIR_REQUIRED_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_MAX_OBJECTS_DEFAULT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_MAX_OBJECTS_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_NAME_DIR_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_REPLICATION_MIN_DEFAULT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_REPLICATION_MIN_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_REPL_QUEUE_THRESHOLD_PCT_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_RESOURCE_CHECK_INTERVAL_DEFAULT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_RESOURCE_CHECK_INTERVAL_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_SAFEMODE_EXTENSION_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_SAFEMODE_MIN_DATANODES_DEFAULT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_SAFEMODE_MIN_DATANODES_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_SAFEMODE_THRESHOLD_PCT_DEFAULT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_SAFEMODE_THRESHOLD_PCT_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_SHARED_EDITS_DIR_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_PERMISSIONS_ENABLED_DEFAULT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_PERMISSIONS_ENABLED_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_PERMISSIONS_SUPERUSERGROUP_DEFAULT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_PERMISSIONS_SUPERUSERGROUP_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_PERSIST_BLOCKS_DEFAULT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_PERSIST_BLOCKS_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_REPLICATION_DEFAULT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_REPLICATION_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_SUPPORT_APPEND_DEFAULT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_SUPPORT_APPEND_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Time
operator|.
name|now
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|BufferedWriter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileNotFoundException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStreamWriter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|PrintWriter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|StringWriter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|management
operator|.
name|ManagementFactory
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|InetAddress
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URI
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Date
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|EnumSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|ReentrantReadWriteLock
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|management
operator|.
name|NotCompliantMBeanException
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|management
operator|.
name|ObjectName
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|management
operator|.
name|StandardMBean
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|HadoopIllegalArgumentException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|ContentSummary
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|CreateFlag
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileAlreadyExistsException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FsServerDefaults
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|InvalidPathException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Options
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Options
operator|.
name|Rename
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|ParentNotDirectoryException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|UnresolvedLinkException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|permission
operator|.
name|FsAction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|permission
operator|.
name|FsPermission
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|permission
operator|.
name|PermissionStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ha
operator|.
name|HAServiceProtocol
operator|.
name|HAServiceState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ha
operator|.
name|ServiceFailedException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|HAUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|HdfsConfiguration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|AlreadyBeingCreatedException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|Block
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|ClientProtocol
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|DatanodeID
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|DatanodeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|DirectoryListing
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|ExtendedBlock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|HdfsConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|SnapshottableDirectoryStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|HdfsConstants
operator|.
name|DatanodeReportType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|HdfsConstants
operator|.
name|SafeModeAction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|HdfsFileStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|LocatedBlock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|LocatedBlocks
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|QuotaExceededException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|RecoveryInProgressException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|datatransfer
operator|.
name|ReplaceDatanodeOnFailure
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|security
operator|.
name|token
operator|.
name|block
operator|.
name|BlockTokenSecretManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|security
operator|.
name|token
operator|.
name|block
operator|.
name|BlockTokenSecretManager
operator|.
name|AccessMode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|security
operator|.
name|token
operator|.
name|delegation
operator|.
name|DelegationTokenIdentifier
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|security
operator|.
name|token
operator|.
name|delegation
operator|.
name|DelegationTokenSecretManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|blockmanagement
operator|.
name|BlockCollection
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|blockmanagement
operator|.
name|BlockInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|blockmanagement
operator|.
name|BlockInfoUnderConstruction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|blockmanagement
operator|.
name|BlockManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|blockmanagement
operator|.
name|DatanodeDescriptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|blockmanagement
operator|.
name|DatanodeManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|blockmanagement
operator|.
name|DatanodeStatistics
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|GenerationStamp
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|HdfsServerConstants
operator|.
name|BlockUCState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|HdfsServerConstants
operator|.
name|NamenodeRole
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|HdfsServerConstants
operator|.
name|StartupOption
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|Storage
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|Storage
operator|.
name|StorageDirType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|Storage
operator|.
name|StorageDirectory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|Util
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|INode
operator|.
name|BlocksMapINodeUpdateEntry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|INode
operator|.
name|BlocksMapUpdateInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|INodeDirectory
operator|.
name|INodesInPath
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|LeaseManager
operator|.
name|Lease
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|NameNode
operator|.
name|OperationCategory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|ha
operator|.
name|EditLogTailer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|ha
operator|.
name|HAContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|ha
operator|.
name|HAState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|ha
operator|.
name|StandbyCheckpointer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|metrics
operator|.
name|FSNamesystemMBean
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|metrics
operator|.
name|NameNodeMetrics
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|snapshot
operator|.
name|INodeDirectorySnapshottable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|snapshot
operator|.
name|INodeFileUnderConstructionWithSnapshot
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|snapshot
operator|.
name|INodeFileWithSnapshot
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|snapshot
operator|.
name|Snapshot
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|snapshot
operator|.
name|SnapshotManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|web
operator|.
name|resources
operator|.
name|NamenodeWebHdfsMethods
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|DatanodeCommand
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|DatanodeRegistration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|HeartbeatResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|NNHAStatusHeartbeat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|NamenodeCommand
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|NamenodeRegistration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|NamespaceInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|Text
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|Server
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|StandbyException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|metrics2
operator|.
name|annotation
operator|.
name|Metric
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|metrics2
operator|.
name|annotation
operator|.
name|Metrics
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|metrics2
operator|.
name|lib
operator|.
name|DefaultMetricsSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|metrics2
operator|.
name|util
operator|.
name|MBeans
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|net
operator|.
name|NetworkTopology
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|net
operator|.
name|Node
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|AccessControlException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|UserGroupInformation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|UserGroupInformation
operator|.
name|AuthenticationMethod
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|token
operator|.
name|SecretManager
operator|.
name|InvalidToken
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|token
operator|.
name|Token
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|token
operator|.
name|delegation
operator|.
name|DelegationKey
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Daemon
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|DataChecksum
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Time
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|VersionInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|mortbay
operator|.
name|util
operator|.
name|ajax
operator|.
name|JSON
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Charsets
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_comment
comment|/**  * FSNamesystem is a container of both transient  * and persisted name-space state, and does all the book-keeping  * work on a NameNode.  *  * Its roles are briefly described below:  *  * 1) Is the container for BlockManager, DatanodeManager,  *    DelegationTokens, LeaseManager, etc. services.  * 2) RPC calls that modify or inspect the name-space  *    should get delegated here.  * 3) Anything that touches only blocks (eg. block reports),  *    it delegates to BlockManager.  * 4) Anything that touches only file information (eg. permissions, mkdirs),  *    it delegates to FSDirectory.  * 5) Anything that crosses two of the above components should be  *    coordinated here.  * 6) Logs mutations to FSEditLog.  *  * This class and its contents keep:  *  * 1)  Valid fsname --> blocklist  (kept on disk, logged)  * 2)  Set of all valid blocks (inverted #1)  * 3)  block --> machinelist (kept in memory, rebuilt dynamically from reports)  * 4)  machine --> blocklist (inverted #2)  * 5)  LRU cache of updated-heartbeat machines  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
annotation|@
name|Metrics
argument_list|(
name|context
operator|=
literal|"dfs"
argument_list|)
DECL|class|FSNamesystem
specifier|public
class|class
name|FSNamesystem
implements|implements
name|Namesystem
implements|,
name|FSClusterStats
implements|,
name|FSNamesystemMBean
implements|,
name|NameNodeMXBean
block|{
DECL|field|LOG
specifier|public
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|FSNamesystem
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|auditBuffer
specifier|private
specifier|static
specifier|final
name|ThreadLocal
argument_list|<
name|StringBuilder
argument_list|>
name|auditBuffer
init|=
operator|new
name|ThreadLocal
argument_list|<
name|StringBuilder
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|protected
name|StringBuilder
name|initialValue
parameter_list|()
block|{
return|return
operator|new
name|StringBuilder
argument_list|()
return|;
block|}
block|}
decl_stmt|;
DECL|method|isAuditEnabled ()
specifier|private
name|boolean
name|isAuditEnabled
parameter_list|()
block|{
return|return
operator|!
name|isDefaultAuditLogger
operator|||
name|auditLog
operator|.
name|isInfoEnabled
argument_list|()
return|;
block|}
DECL|method|logAuditEvent (UserGroupInformation ugi, InetAddress addr, String cmd, String src, String dst, HdfsFileStatus stat)
specifier|private
name|void
name|logAuditEvent
parameter_list|(
name|UserGroupInformation
name|ugi
parameter_list|,
name|InetAddress
name|addr
parameter_list|,
name|String
name|cmd
parameter_list|,
name|String
name|src
parameter_list|,
name|String
name|dst
parameter_list|,
name|HdfsFileStatus
name|stat
parameter_list|)
block|{
name|logAuditEvent
argument_list|(
literal|true
argument_list|,
name|ugi
argument_list|,
name|addr
argument_list|,
name|cmd
argument_list|,
name|src
argument_list|,
name|dst
argument_list|,
name|stat
argument_list|)
expr_stmt|;
block|}
DECL|method|logAuditEvent (boolean succeeded, UserGroupInformation ugi, InetAddress addr, String cmd, String src, String dst, HdfsFileStatus stat)
specifier|private
name|void
name|logAuditEvent
parameter_list|(
name|boolean
name|succeeded
parameter_list|,
name|UserGroupInformation
name|ugi
parameter_list|,
name|InetAddress
name|addr
parameter_list|,
name|String
name|cmd
parameter_list|,
name|String
name|src
parameter_list|,
name|String
name|dst
parameter_list|,
name|HdfsFileStatus
name|stat
parameter_list|)
block|{
name|FileStatus
name|status
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|stat
operator|!=
literal|null
condition|)
block|{
name|Path
name|symlink
init|=
name|stat
operator|.
name|isSymlink
argument_list|()
condition|?
operator|new
name|Path
argument_list|(
name|stat
operator|.
name|getSymlink
argument_list|()
argument_list|)
else|:
literal|null
decl_stmt|;
name|Path
name|path
init|=
name|dst
operator|!=
literal|null
condition|?
operator|new
name|Path
argument_list|(
name|dst
argument_list|)
else|:
operator|new
name|Path
argument_list|(
name|src
argument_list|)
decl_stmt|;
name|status
operator|=
operator|new
name|FileStatus
argument_list|(
name|stat
operator|.
name|getLen
argument_list|()
argument_list|,
name|stat
operator|.
name|isDir
argument_list|()
argument_list|,
name|stat
operator|.
name|getReplication
argument_list|()
argument_list|,
name|stat
operator|.
name|getBlockSize
argument_list|()
argument_list|,
name|stat
operator|.
name|getModificationTime
argument_list|()
argument_list|,
name|stat
operator|.
name|getAccessTime
argument_list|()
argument_list|,
name|stat
operator|.
name|getPermission
argument_list|()
argument_list|,
name|stat
operator|.
name|getOwner
argument_list|()
argument_list|,
name|stat
operator|.
name|getGroup
argument_list|()
argument_list|,
name|symlink
argument_list|,
name|path
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|AuditLogger
name|logger
range|:
name|auditLoggers
control|)
block|{
name|logger
operator|.
name|logAuditEvent
argument_list|(
name|succeeded
argument_list|,
name|ugi
operator|.
name|toString
argument_list|()
argument_list|,
name|addr
argument_list|,
name|cmd
argument_list|,
name|src
argument_list|,
name|dst
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Logger for audit events, noting successful FSNamesystem operations. Emits    * to FSNamesystem.audit at INFO. Each event causes a set of tab-separated    *<code>key=value</code> pairs to be written for the following properties:    *<code>    * ugi=&lt;ugi in RPC&gt;    * ip=&lt;remote IP&gt;    * cmd=&lt;command&gt;    * src=&lt;src path&gt;    * dst=&lt;dst path (optional)&gt;    * perm=&lt;permissions (optional)&gt;    *</code>    */
DECL|field|auditLog
specifier|public
specifier|static
specifier|final
name|Log
name|auditLog
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|FSNamesystem
operator|.
name|class
operator|.
name|getName
argument_list|()
operator|+
literal|".audit"
argument_list|)
decl_stmt|;
DECL|field|DEFAULT_MAX_CORRUPT_FILEBLOCKS_RETURNED
specifier|static
specifier|final
name|int
name|DEFAULT_MAX_CORRUPT_FILEBLOCKS_RETURNED
init|=
literal|100
decl_stmt|;
DECL|field|BLOCK_DELETION_INCREMENT
specifier|static
name|int
name|BLOCK_DELETION_INCREMENT
init|=
literal|1000
decl_stmt|;
DECL|field|isPermissionEnabled
specifier|private
specifier|final
name|boolean
name|isPermissionEnabled
decl_stmt|;
DECL|field|persistBlocks
specifier|private
specifier|final
name|boolean
name|persistBlocks
decl_stmt|;
DECL|field|fsOwner
specifier|private
specifier|final
name|UserGroupInformation
name|fsOwner
decl_stmt|;
DECL|field|supergroup
specifier|private
specifier|final
name|String
name|supergroup
decl_stmt|;
DECL|field|standbyShouldCheckpoint
specifier|private
specifier|final
name|boolean
name|standbyShouldCheckpoint
decl_stmt|;
comment|// Scan interval is not configurable.
DECL|field|DELEGATION_TOKEN_REMOVER_SCAN_INTERVAL
specifier|private
specifier|static
specifier|final
name|long
name|DELEGATION_TOKEN_REMOVER_SCAN_INTERVAL
init|=
name|TimeUnit
operator|.
name|MILLISECONDS
operator|.
name|convert
argument_list|(
literal|1
argument_list|,
name|TimeUnit
operator|.
name|HOURS
argument_list|)
decl_stmt|;
DECL|field|dtSecretManager
specifier|final
name|DelegationTokenSecretManager
name|dtSecretManager
decl_stmt|;
DECL|field|alwaysUseDelegationTokensForTests
specifier|private
specifier|final
name|boolean
name|alwaysUseDelegationTokensForTests
decl_stmt|;
comment|// Tracks whether the default audit logger is the only configured audit
comment|// logger; this allows isAuditEnabled() to return false in case the
comment|// underlying logger is disabled, and avoid some unnecessary work.
DECL|field|isDefaultAuditLogger
specifier|private
specifier|final
name|boolean
name|isDefaultAuditLogger
decl_stmt|;
DECL|field|auditLoggers
specifier|private
specifier|final
name|List
argument_list|<
name|AuditLogger
argument_list|>
name|auditLoggers
decl_stmt|;
comment|/** The namespace tree. */
DECL|field|dir
name|FSDirectory
name|dir
decl_stmt|;
DECL|field|blockManager
specifier|private
specifier|final
name|BlockManager
name|blockManager
decl_stmt|;
DECL|field|snapshotManager
specifier|private
specifier|final
name|SnapshotManager
name|snapshotManager
decl_stmt|;
DECL|field|datanodeStatistics
specifier|private
specifier|final
name|DatanodeStatistics
name|datanodeStatistics
decl_stmt|;
comment|// Block pool ID used by this namenode
DECL|field|blockPoolId
specifier|private
name|String
name|blockPoolId
decl_stmt|;
DECL|field|leaseManager
specifier|final
name|LeaseManager
name|leaseManager
init|=
operator|new
name|LeaseManager
argument_list|(
name|this
argument_list|)
decl_stmt|;
DECL|field|smmthread
name|Daemon
name|smmthread
init|=
literal|null
decl_stmt|;
comment|// SafeModeMonitor thread
DECL|field|nnrmthread
name|Daemon
name|nnrmthread
init|=
literal|null
decl_stmt|;
comment|// NamenodeResourceMonitor thread
DECL|field|hasResourcesAvailable
specifier|private
specifier|volatile
name|boolean
name|hasResourcesAvailable
init|=
literal|false
decl_stmt|;
DECL|field|fsRunning
specifier|private
specifier|volatile
name|boolean
name|fsRunning
init|=
literal|true
decl_stmt|;
comment|/** The start time of the namesystem. */
DECL|field|startTime
specifier|private
specifier|final
name|long
name|startTime
init|=
name|now
argument_list|()
decl_stmt|;
comment|/** The interval of namenode checking for the disk space availability */
DECL|field|resourceRecheckInterval
specifier|private
specifier|final
name|long
name|resourceRecheckInterval
decl_stmt|;
comment|// The actual resource checker instance.
DECL|field|nnResourceChecker
name|NameNodeResourceChecker
name|nnResourceChecker
decl_stmt|;
DECL|field|serverDefaults
specifier|private
specifier|final
name|FsServerDefaults
name|serverDefaults
decl_stmt|;
DECL|field|supportAppends
specifier|private
specifier|final
name|boolean
name|supportAppends
decl_stmt|;
DECL|field|dtpReplaceDatanodeOnFailure
specifier|private
specifier|final
name|ReplaceDatanodeOnFailure
name|dtpReplaceDatanodeOnFailure
decl_stmt|;
DECL|field|safeMode
specifier|private
specifier|volatile
name|SafeModeInfo
name|safeMode
decl_stmt|;
comment|// safe mode information
DECL|field|maxFsObjects
specifier|private
specifier|final
name|long
name|maxFsObjects
decl_stmt|;
comment|// maximum number of fs objects
comment|/**    * The global generation stamp for this file system.     */
DECL|field|generationStamp
specifier|private
specifier|final
name|GenerationStamp
name|generationStamp
init|=
operator|new
name|GenerationStamp
argument_list|()
decl_stmt|;
comment|// precision of access times.
DECL|field|accessTimePrecision
specifier|private
specifier|final
name|long
name|accessTimePrecision
decl_stmt|;
comment|/** Lock to protect FSNamesystem. */
DECL|field|fsLock
specifier|private
name|ReentrantReadWriteLock
name|fsLock
init|=
operator|new
name|ReentrantReadWriteLock
argument_list|(
literal|true
argument_list|)
decl_stmt|;
comment|/**    * Used when this NN is in standby state to read from the shared edit log.    */
DECL|field|editLogTailer
specifier|private
name|EditLogTailer
name|editLogTailer
init|=
literal|null
decl_stmt|;
comment|/**    * Used when this NN is in standby state to perform checkpoints.    */
DECL|field|standbyCheckpointer
specifier|private
name|StandbyCheckpointer
name|standbyCheckpointer
decl_stmt|;
comment|/**    * Reference to the NN's HAContext object. This is only set once    * {@link #startCommonServices(Configuration, HAContext)} is called.     */
DECL|field|haContext
specifier|private
name|HAContext
name|haContext
decl_stmt|;
DECL|field|haEnabled
specifier|private
specifier|final
name|boolean
name|haEnabled
decl_stmt|;
DECL|field|inodeId
specifier|private
name|INodeId
name|inodeId
decl_stmt|;
comment|/**    * Set the last allocated inode id when fsimage or editlog is loaded.     */
DECL|method|resetLastInodeId (long newValue)
specifier|public
name|void
name|resetLastInodeId
parameter_list|(
name|long
name|newValue
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
name|inodeId
operator|.
name|skipTo
argument_list|(
name|newValue
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalStateException
name|ise
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|ise
argument_list|)
throw|;
block|}
block|}
comment|/** Should only be used for tests to reset to any value */
DECL|method|resetLastInodeIdWithoutChecking (long newValue)
name|void
name|resetLastInodeIdWithoutChecking
parameter_list|(
name|long
name|newValue
parameter_list|)
block|{
name|inodeId
operator|.
name|setCurrentValue
argument_list|(
name|newValue
argument_list|)
expr_stmt|;
block|}
comment|/** @return the last inode ID. */
DECL|method|getLastInodeId ()
specifier|public
name|long
name|getLastInodeId
parameter_list|()
block|{
return|return
name|inodeId
operator|.
name|getCurrentValue
argument_list|()
return|;
block|}
comment|/** Allocate a new inode ID. */
DECL|method|allocateNewInodeId ()
specifier|public
name|long
name|allocateNewInodeId
parameter_list|()
block|{
return|return
name|inodeId
operator|.
name|nextValue
argument_list|()
return|;
block|}
comment|/**    * Clear all loaded data    */
DECL|method|clear ()
name|void
name|clear
parameter_list|()
block|{
name|dir
operator|.
name|reset
argument_list|()
expr_stmt|;
name|dtSecretManager
operator|.
name|reset
argument_list|()
expr_stmt|;
name|generationStamp
operator|.
name|setCurrentValue
argument_list|(
name|GenerationStamp
operator|.
name|LAST_RESERVED_STAMP
argument_list|)
expr_stmt|;
name|leaseManager
operator|.
name|removeAllLeases
argument_list|()
expr_stmt|;
name|inodeId
operator|.
name|setCurrentValue
argument_list|(
name|INodeId
operator|.
name|LAST_RESERVED_ID
argument_list|)
expr_stmt|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|getLeaseManager ()
name|LeaseManager
name|getLeaseManager
parameter_list|()
block|{
return|return
name|leaseManager
return|;
block|}
comment|/**    /**    * Instantiates an FSNamesystem loaded from the image and edits    * directories specified in the passed Configuration.    *     * @param conf the Configuration which specifies the storage directories    *             from which to load    * @return an FSNamesystem which contains the loaded namespace    * @throws IOException if loading fails    */
DECL|method|loadFromDisk (Configuration conf)
specifier|public
specifier|static
name|FSNamesystem
name|loadFromDisk
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|Collection
argument_list|<
name|URI
argument_list|>
name|namespaceDirs
init|=
name|FSNamesystem
operator|.
name|getNamespaceDirs
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|URI
argument_list|>
name|namespaceEditsDirs
init|=
name|FSNamesystem
operator|.
name|getNamespaceEditsDirs
argument_list|(
name|conf
argument_list|)
decl_stmt|;
return|return
name|loadFromDisk
argument_list|(
name|conf
argument_list|,
name|namespaceDirs
argument_list|,
name|namespaceEditsDirs
argument_list|)
return|;
block|}
comment|/**    * Instantiates an FSNamesystem loaded from the image and edits    * directories passed.    *     * @param conf the Configuration which specifies the storage directories    *             from which to load    * @param namespaceDirs directories to load the fsimages    * @param namespaceEditsDirs directories to load the edits from    * @return an FSNamesystem which contains the loaded namespace    * @throws IOException if loading fails    */
DECL|method|loadFromDisk (Configuration conf, Collection<URI> namespaceDirs, List<URI> namespaceEditsDirs)
specifier|public
specifier|static
name|FSNamesystem
name|loadFromDisk
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|Collection
argument_list|<
name|URI
argument_list|>
name|namespaceDirs
parameter_list|,
name|List
argument_list|<
name|URI
argument_list|>
name|namespaceEditsDirs
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|namespaceDirs
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Only one image storage directory ("
operator|+
name|DFS_NAMENODE_NAME_DIR_KEY
operator|+
literal|") configured. Beware of dataloss"
operator|+
literal|" due to lack of redundant storage directories!"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|namespaceEditsDirs
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Only one namespace edits storage directory ("
operator|+
name|DFS_NAMENODE_EDITS_DIR_KEY
operator|+
literal|") configured. Beware of dataloss"
operator|+
literal|" due to lack of redundant storage directories!"
argument_list|)
expr_stmt|;
block|}
name|FSImage
name|fsImage
init|=
operator|new
name|FSImage
argument_list|(
name|conf
argument_list|,
name|namespaceDirs
argument_list|,
name|namespaceEditsDirs
argument_list|)
decl_stmt|;
name|FSNamesystem
name|namesystem
init|=
operator|new
name|FSNamesystem
argument_list|(
name|conf
argument_list|,
name|fsImage
argument_list|)
decl_stmt|;
name|StartupOption
name|startOpt
init|=
name|NameNode
operator|.
name|getStartupOption
argument_list|(
name|conf
argument_list|)
decl_stmt|;
if|if
condition|(
name|startOpt
operator|==
name|StartupOption
operator|.
name|RECOVER
condition|)
block|{
name|namesystem
operator|.
name|setSafeMode
argument_list|(
name|SafeModeAction
operator|.
name|SAFEMODE_ENTER
argument_list|)
expr_stmt|;
block|}
name|long
name|loadStart
init|=
name|now
argument_list|()
decl_stmt|;
name|String
name|nameserviceId
init|=
name|DFSUtil
operator|.
name|getNamenodeNameServiceId
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|namesystem
operator|.
name|loadFSImage
argument_list|(
name|startOpt
argument_list|,
name|fsImage
argument_list|,
name|HAUtil
operator|.
name|isHAEnabled
argument_list|(
name|conf
argument_list|,
name|nameserviceId
argument_list|)
argument_list|)
expr_stmt|;
name|long
name|timeTakenToLoadFSImage
init|=
name|now
argument_list|()
operator|-
name|loadStart
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Finished loading FSImage in "
operator|+
name|timeTakenToLoadFSImage
operator|+
literal|" msecs"
argument_list|)
expr_stmt|;
name|NameNodeMetrics
name|nnMetrics
init|=
name|NameNode
operator|.
name|getNameNodeMetrics
argument_list|()
decl_stmt|;
if|if
condition|(
name|nnMetrics
operator|!=
literal|null
condition|)
block|{
name|nnMetrics
operator|.
name|setFsImageLoadTime
argument_list|(
operator|(
name|int
operator|)
name|timeTakenToLoadFSImage
argument_list|)
expr_stmt|;
block|}
return|return
name|namesystem
return|;
block|}
comment|/**    * Create an FSNamesystem associated with the specified image.    *     * Note that this does not load any data off of disk -- if you would    * like that behavior, use {@link #loadFromDisk(Configuration)}     * @param fnImage The FSImage to associate with    * @param conf configuration    * @throws IOException on bad configuration    */
DECL|method|FSNamesystem (Configuration conf, FSImage fsImage)
name|FSNamesystem
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|FSImage
name|fsImage
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
name|resourceRecheckInterval
operator|=
name|conf
operator|.
name|getLong
argument_list|(
name|DFS_NAMENODE_RESOURCE_CHECK_INTERVAL_KEY
argument_list|,
name|DFS_NAMENODE_RESOURCE_CHECK_INTERVAL_DEFAULT
argument_list|)
expr_stmt|;
name|this
operator|.
name|blockManager
operator|=
operator|new
name|BlockManager
argument_list|(
name|this
argument_list|,
name|this
argument_list|,
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|datanodeStatistics
operator|=
name|blockManager
operator|.
name|getDatanodeManager
argument_list|()
operator|.
name|getDatanodeStatistics
argument_list|()
expr_stmt|;
name|this
operator|.
name|fsOwner
operator|=
name|UserGroupInformation
operator|.
name|getCurrentUser
argument_list|()
expr_stmt|;
name|this
operator|.
name|supergroup
operator|=
name|conf
operator|.
name|get
argument_list|(
name|DFS_PERMISSIONS_SUPERUSERGROUP_KEY
argument_list|,
name|DFS_PERMISSIONS_SUPERUSERGROUP_DEFAULT
argument_list|)
expr_stmt|;
name|this
operator|.
name|isPermissionEnabled
operator|=
name|conf
operator|.
name|getBoolean
argument_list|(
name|DFS_PERMISSIONS_ENABLED_KEY
argument_list|,
name|DFS_PERMISSIONS_ENABLED_DEFAULT
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"fsOwner             = "
operator|+
name|fsOwner
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"supergroup          = "
operator|+
name|supergroup
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"isPermissionEnabled = "
operator|+
name|isPermissionEnabled
argument_list|)
expr_stmt|;
specifier|final
name|boolean
name|persistBlocks
init|=
name|conf
operator|.
name|getBoolean
argument_list|(
name|DFS_PERSIST_BLOCKS_KEY
argument_list|,
name|DFS_PERSIST_BLOCKS_DEFAULT
argument_list|)
decl_stmt|;
comment|// block allocation has to be persisted in HA using a shared edits directory
comment|// so that the standby has up-to-date namespace information
name|String
name|nameserviceId
init|=
name|DFSUtil
operator|.
name|getNamenodeNameServiceId
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|this
operator|.
name|haEnabled
operator|=
name|HAUtil
operator|.
name|isHAEnabled
argument_list|(
name|conf
argument_list|,
name|nameserviceId
argument_list|)
expr_stmt|;
name|this
operator|.
name|persistBlocks
operator|=
name|persistBlocks
operator|||
operator|(
name|haEnabled
operator|&&
name|HAUtil
operator|.
name|usesSharedEditsDir
argument_list|(
name|conf
argument_list|)
operator|)
expr_stmt|;
comment|// Sanity check the HA-related config.
if|if
condition|(
name|nameserviceId
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Determined nameservice ID: "
operator|+
name|nameserviceId
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"HA Enabled: "
operator|+
name|haEnabled
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|haEnabled
operator|&&
name|HAUtil
operator|.
name|usesSharedEditsDir
argument_list|(
name|conf
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Configured NNs:\n"
operator|+
name|DFSUtil
operator|.
name|nnAddressesAsString
argument_list|(
name|conf
argument_list|)
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Invalid configuration: a shared edits dir "
operator|+
literal|"must not be specified if HA is not enabled."
argument_list|)
throw|;
block|}
comment|// Get the checksum type from config
name|String
name|checksumTypeStr
init|=
name|conf
operator|.
name|get
argument_list|(
name|DFS_CHECKSUM_TYPE_KEY
argument_list|,
name|DFS_CHECKSUM_TYPE_DEFAULT
argument_list|)
decl_stmt|;
name|DataChecksum
operator|.
name|Type
name|checksumType
decl_stmt|;
try|try
block|{
name|checksumType
operator|=
name|DataChecksum
operator|.
name|Type
operator|.
name|valueOf
argument_list|(
name|checksumTypeStr
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|iae
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Invalid checksum type in "
operator|+
name|DFS_CHECKSUM_TYPE_KEY
operator|+
literal|": "
operator|+
name|checksumTypeStr
argument_list|)
throw|;
block|}
name|this
operator|.
name|serverDefaults
operator|=
operator|new
name|FsServerDefaults
argument_list|(
name|conf
operator|.
name|getLongBytes
argument_list|(
name|DFS_BLOCK_SIZE_KEY
argument_list|,
name|DFS_BLOCK_SIZE_DEFAULT
argument_list|)
argument_list|,
name|conf
operator|.
name|getInt
argument_list|(
name|DFS_BYTES_PER_CHECKSUM_KEY
argument_list|,
name|DFS_BYTES_PER_CHECKSUM_DEFAULT
argument_list|)
argument_list|,
name|conf
operator|.
name|getInt
argument_list|(
name|DFS_CLIENT_WRITE_PACKET_SIZE_KEY
argument_list|,
name|DFS_CLIENT_WRITE_PACKET_SIZE_DEFAULT
argument_list|)
argument_list|,
operator|(
name|short
operator|)
name|conf
operator|.
name|getInt
argument_list|(
name|DFS_REPLICATION_KEY
argument_list|,
name|DFS_REPLICATION_DEFAULT
argument_list|)
argument_list|,
name|conf
operator|.
name|getInt
argument_list|(
name|IO_FILE_BUFFER_SIZE_KEY
argument_list|,
name|IO_FILE_BUFFER_SIZE_DEFAULT
argument_list|)
argument_list|,
name|conf
operator|.
name|getBoolean
argument_list|(
name|DFS_ENCRYPT_DATA_TRANSFER_KEY
argument_list|,
name|DFS_ENCRYPT_DATA_TRANSFER_DEFAULT
argument_list|)
argument_list|,
name|conf
operator|.
name|getLong
argument_list|(
name|FS_TRASH_INTERVAL_KEY
argument_list|,
name|FS_TRASH_INTERVAL_DEFAULT
argument_list|)
argument_list|,
name|checksumType
argument_list|)
expr_stmt|;
name|this
operator|.
name|maxFsObjects
operator|=
name|conf
operator|.
name|getLong
argument_list|(
name|DFS_NAMENODE_MAX_OBJECTS_KEY
argument_list|,
name|DFS_NAMENODE_MAX_OBJECTS_DEFAULT
argument_list|)
expr_stmt|;
name|this
operator|.
name|accessTimePrecision
operator|=
name|conf
operator|.
name|getLong
argument_list|(
name|DFS_NAMENODE_ACCESSTIME_PRECISION_KEY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|this
operator|.
name|supportAppends
operator|=
name|conf
operator|.
name|getBoolean
argument_list|(
name|DFS_SUPPORT_APPEND_KEY
argument_list|,
name|DFS_SUPPORT_APPEND_DEFAULT
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Append Enabled: "
operator|+
name|supportAppends
argument_list|)
expr_stmt|;
name|this
operator|.
name|dtpReplaceDatanodeOnFailure
operator|=
name|ReplaceDatanodeOnFailure
operator|.
name|get
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|standbyShouldCheckpoint
operator|=
name|conf
operator|.
name|getBoolean
argument_list|(
name|DFS_HA_STANDBY_CHECKPOINTS_KEY
argument_list|,
name|DFS_HA_STANDBY_CHECKPOINTS_DEFAULT
argument_list|)
expr_stmt|;
name|this
operator|.
name|inodeId
operator|=
operator|new
name|INodeId
argument_list|()
expr_stmt|;
comment|// For testing purposes, allow the DT secret manager to be started regardless
comment|// of whether security is enabled.
name|alwaysUseDelegationTokensForTests
operator|=
name|conf
operator|.
name|getBoolean
argument_list|(
name|DFS_NAMENODE_DELEGATION_TOKEN_ALWAYS_USE_KEY
argument_list|,
name|DFS_NAMENODE_DELEGATION_TOKEN_ALWAYS_USE_DEFAULT
argument_list|)
expr_stmt|;
name|this
operator|.
name|dtSecretManager
operator|=
name|createDelegationTokenSecretManager
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|dir
operator|=
operator|new
name|FSDirectory
argument_list|(
name|fsImage
argument_list|,
name|this
argument_list|,
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|snapshotManager
operator|=
operator|new
name|SnapshotManager
argument_list|(
name|dir
argument_list|)
expr_stmt|;
name|this
operator|.
name|safeMode
operator|=
operator|new
name|SafeModeInfo
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|auditLoggers
operator|=
name|initAuditLoggers
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|isDefaultAuditLogger
operator|=
name|auditLoggers
operator|.
name|size
argument_list|()
operator|==
literal|1
operator|&&
name|auditLoggers
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|instanceof
name|DefaultAuditLogger
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|" initialization failed."
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|close
argument_list|()
expr_stmt|;
throw|throw
name|e
throw|;
block|}
catch|catch
parameter_list|(
name|RuntimeException
name|re
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|" initialization failed."
argument_list|,
name|re
argument_list|)
expr_stmt|;
name|close
argument_list|()
expr_stmt|;
throw|throw
name|re
throw|;
block|}
block|}
DECL|method|initAuditLoggers (Configuration conf)
specifier|private
name|List
argument_list|<
name|AuditLogger
argument_list|>
name|initAuditLoggers
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
comment|// Initialize the custom access loggers if configured.
name|Collection
argument_list|<
name|String
argument_list|>
name|alClasses
init|=
name|conf
operator|.
name|getStringCollection
argument_list|(
name|DFS_NAMENODE_AUDIT_LOGGERS_KEY
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|AuditLogger
argument_list|>
name|auditLoggers
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
if|if
condition|(
name|alClasses
operator|!=
literal|null
operator|&&
operator|!
name|alClasses
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|String
name|className
range|:
name|alClasses
control|)
block|{
try|try
block|{
name|AuditLogger
name|logger
decl_stmt|;
if|if
condition|(
name|DFS_NAMENODE_DEFAULT_AUDIT_LOGGER_NAME
operator|.
name|equals
argument_list|(
name|className
argument_list|)
condition|)
block|{
name|logger
operator|=
operator|new
name|DefaultAuditLogger
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|logger
operator|=
operator|(
name|AuditLogger
operator|)
name|Class
operator|.
name|forName
argument_list|(
name|className
argument_list|)
operator|.
name|newInstance
argument_list|()
expr_stmt|;
block|}
name|logger
operator|.
name|initialize
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|auditLoggers
operator|.
name|add
argument_list|(
name|logger
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RuntimeException
name|re
parameter_list|)
block|{
throw|throw
name|re
throw|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
block|}
comment|// Make sure there is at least one logger installed.
if|if
condition|(
name|auditLoggers
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|auditLoggers
operator|.
name|add
argument_list|(
operator|new
name|DefaultAuditLogger
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|auditLoggers
return|;
block|}
DECL|method|loadFSImage (StartupOption startOpt, FSImage fsImage, boolean haEnabled)
name|void
name|loadFSImage
parameter_list|(
name|StartupOption
name|startOpt
parameter_list|,
name|FSImage
name|fsImage
parameter_list|,
name|boolean
name|haEnabled
parameter_list|)
throws|throws
name|IOException
block|{
comment|// format before starting up if requested
if|if
condition|(
name|startOpt
operator|==
name|StartupOption
operator|.
name|FORMAT
condition|)
block|{
name|fsImage
operator|.
name|format
argument_list|(
name|this
argument_list|,
name|fsImage
operator|.
name|getStorage
argument_list|()
operator|.
name|determineClusterId
argument_list|()
argument_list|)
expr_stmt|;
comment|// reuse current id
name|startOpt
operator|=
name|StartupOption
operator|.
name|REGULAR
expr_stmt|;
block|}
name|boolean
name|success
init|=
literal|false
decl_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
comment|// We shouldn't be calling saveNamespace if we've come up in standby state.
name|MetaRecoveryContext
name|recovery
init|=
name|startOpt
operator|.
name|createRecoveryContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|fsImage
operator|.
name|recoverTransitionRead
argument_list|(
name|startOpt
argument_list|,
name|this
argument_list|,
name|recovery
argument_list|)
operator|&&
operator|!
name|haEnabled
condition|)
block|{
name|fsImage
operator|.
name|saveNamespace
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
comment|// This will start a new log segment and write to the seen_txid file, so
comment|// we shouldn't do it when coming up in standby state
if|if
condition|(
operator|!
name|haEnabled
condition|)
block|{
name|fsImage
operator|.
name|openEditLogForWrite
argument_list|()
expr_stmt|;
block|}
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|success
condition|)
block|{
name|fsImage
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
name|dir
operator|.
name|imageLoadComplete
argument_list|()
expr_stmt|;
block|}
DECL|method|startSecretManager ()
specifier|private
name|void
name|startSecretManager
parameter_list|()
block|{
if|if
condition|(
name|dtSecretManager
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|dtSecretManager
operator|.
name|startThreads
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// Inability to start secret manager
comment|// can't be recovered from.
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
block|}
DECL|method|startSecretManagerIfNecessary ()
specifier|private
name|void
name|startSecretManagerIfNecessary
parameter_list|()
block|{
name|boolean
name|shouldRun
init|=
name|shouldUseDelegationTokens
argument_list|()
operator|&&
operator|!
name|isInSafeMode
argument_list|()
operator|&&
name|getEditLog
argument_list|()
operator|.
name|isOpenForWrite
argument_list|()
decl_stmt|;
name|boolean
name|running
init|=
name|dtSecretManager
operator|.
name|isRunning
argument_list|()
decl_stmt|;
if|if
condition|(
name|shouldRun
operator|&&
operator|!
name|running
condition|)
block|{
name|startSecretManager
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|stopSecretManager ()
specifier|private
name|void
name|stopSecretManager
parameter_list|()
block|{
if|if
condition|(
name|dtSecretManager
operator|!=
literal|null
condition|)
block|{
name|dtSecretManager
operator|.
name|stopThreads
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**     * Start services common to both active and standby states    * @param haContext     * @throws IOException    */
DECL|method|startCommonServices (Configuration conf, HAContext haContext)
name|void
name|startCommonServices
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|HAContext
name|haContext
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|registerMBean
argument_list|()
expr_stmt|;
comment|// register the MBean for the FSNamesystemState
name|writeLock
argument_list|()
expr_stmt|;
name|this
operator|.
name|haContext
operator|=
name|haContext
expr_stmt|;
try|try
block|{
name|nnResourceChecker
operator|=
operator|new
name|NameNodeResourceChecker
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|checkAvailableResources
argument_list|()
expr_stmt|;
assert|assert
name|safeMode
operator|!=
literal|null
operator|&&
operator|!
name|safeMode
operator|.
name|isPopulatingReplQueues
argument_list|()
assert|;
name|setBlockTotal
argument_list|()
expr_stmt|;
name|blockManager
operator|.
name|activate
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
name|registerMXBean
argument_list|()
expr_stmt|;
name|DefaultMetricsSystem
operator|.
name|instance
argument_list|()
operator|.
name|register
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
comment|/**     * Stop services common to both active and standby states    * @throws IOException    */
DECL|method|stopCommonServices ()
name|void
name|stopCommonServices
parameter_list|()
block|{
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
name|blockManager
operator|!=
literal|null
condition|)
name|blockManager
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Start services required in active state    * @throws IOException    */
DECL|method|startActiveServices ()
name|void
name|startActiveServices
parameter_list|()
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Starting services required for active state"
argument_list|)
expr_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|FSEditLog
name|editLog
init|=
name|dir
operator|.
name|fsImage
operator|.
name|getEditLog
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|editLog
operator|.
name|isOpenForWrite
argument_list|()
condition|)
block|{
comment|// During startup, we're already open for write during initialization.
name|editLog
operator|.
name|initJournalsForWrite
argument_list|()
expr_stmt|;
comment|// May need to recover
name|editLog
operator|.
name|recoverUnclosedStreams
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Catching up to latest edits from old active before "
operator|+
literal|"taking over writer role in edits logs"
argument_list|)
expr_stmt|;
name|editLogTailer
operator|.
name|catchupDuringFailover
argument_list|()
expr_stmt|;
name|blockManager
operator|.
name|setPostponeBlocksFromFuture
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|blockManager
operator|.
name|getDatanodeManager
argument_list|()
operator|.
name|markAllDatanodesStale
argument_list|()
expr_stmt|;
name|blockManager
operator|.
name|clearQueues
argument_list|()
expr_stmt|;
name|blockManager
operator|.
name|processAllPendingDNMessages
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|isInSafeMode
argument_list|()
operator|||
operator|(
name|isInSafeMode
argument_list|()
operator|&&
name|safeMode
operator|.
name|isPopulatingReplQueues
argument_list|()
operator|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Reprocessing replication and invalidation queues"
argument_list|)
expr_stmt|;
name|blockManager
operator|.
name|processMisReplicatedBlocks
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"NameNode metadata after re-processing "
operator|+
literal|"replication and invalidation queues during failover:\n"
operator|+
name|metaSaveAsString
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|long
name|nextTxId
init|=
name|dir
operator|.
name|fsImage
operator|.
name|getLastAppliedTxId
argument_list|()
operator|+
literal|1
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Will take over writing edit logs at txnid "
operator|+
name|nextTxId
argument_list|)
expr_stmt|;
name|editLog
operator|.
name|setNextTxId
argument_list|(
name|nextTxId
argument_list|)
expr_stmt|;
name|dir
operator|.
name|fsImage
operator|.
name|editLog
operator|.
name|openForWrite
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|haEnabled
condition|)
block|{
comment|// Renew all of the leases before becoming active.
comment|// This is because, while we were in standby mode,
comment|// the leases weren't getting renewed on this NN.
comment|// Give them all a fresh start here.
name|leaseManager
operator|.
name|renewAllLeases
argument_list|()
expr_stmt|;
block|}
name|leaseManager
operator|.
name|startMonitor
argument_list|()
expr_stmt|;
name|startSecretManagerIfNecessary
argument_list|()
expr_stmt|;
comment|//ResourceMonitor required only at ActiveNN. See HDFS-2914
name|this
operator|.
name|nnrmthread
operator|=
operator|new
name|Daemon
argument_list|(
operator|new
name|NameNodeResourceMonitor
argument_list|()
argument_list|)
expr_stmt|;
name|nnrmthread
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|shouldUseDelegationTokens ()
specifier|private
name|boolean
name|shouldUseDelegationTokens
parameter_list|()
block|{
return|return
name|UserGroupInformation
operator|.
name|isSecurityEnabled
argument_list|()
operator|||
name|alwaysUseDelegationTokensForTests
return|;
block|}
comment|/**     * Stop services required in active state    * @throws InterruptedException    */
DECL|method|stopActiveServices ()
name|void
name|stopActiveServices
parameter_list|()
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Stopping services started for active state"
argument_list|)
expr_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|stopSecretManager
argument_list|()
expr_stmt|;
if|if
condition|(
name|leaseManager
operator|!=
literal|null
condition|)
block|{
name|leaseManager
operator|.
name|stopMonitor
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|nnrmthread
operator|!=
literal|null
condition|)
block|{
operator|(
operator|(
name|NameNodeResourceMonitor
operator|)
name|nnrmthread
operator|.
name|getRunnable
argument_list|()
operator|)
operator|.
name|stopMonitor
argument_list|()
expr_stmt|;
name|nnrmthread
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|dir
operator|!=
literal|null
operator|&&
name|dir
operator|.
name|fsImage
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|dir
operator|.
name|fsImage
operator|.
name|editLog
operator|!=
literal|null
condition|)
block|{
name|dir
operator|.
name|fsImage
operator|.
name|editLog
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|// Update the fsimage with the last txid that we wrote
comment|// so that the tailer starts from the right spot.
name|dir
operator|.
name|fsImage
operator|.
name|updateLastAppliedTxIdFromWritten
argument_list|()
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Start services required in standby state     *     * @throws IOException    */
DECL|method|startStandbyServices (final Configuration conf)
name|void
name|startStandbyServices
parameter_list|(
specifier|final
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Starting services required for standby state"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dir
operator|.
name|fsImage
operator|.
name|editLog
operator|.
name|isOpenForRead
argument_list|()
condition|)
block|{
comment|// During startup, we're already open for read.
name|dir
operator|.
name|fsImage
operator|.
name|editLog
operator|.
name|initSharedJournalsForRead
argument_list|()
expr_stmt|;
block|}
name|blockManager
operator|.
name|setPostponeBlocksFromFuture
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|editLogTailer
operator|=
operator|new
name|EditLogTailer
argument_list|(
name|this
argument_list|,
name|conf
argument_list|)
expr_stmt|;
name|editLogTailer
operator|.
name|start
argument_list|()
expr_stmt|;
if|if
condition|(
name|standbyShouldCheckpoint
condition|)
block|{
name|standbyCheckpointer
operator|=
operator|new
name|StandbyCheckpointer
argument_list|(
name|conf
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|standbyCheckpointer
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Called while the NN is in Standby state, but just about to be    * asked to enter Active state. This cancels any checkpoints    * currently being taken.    */
DECL|method|prepareToStopStandbyServices ()
name|void
name|prepareToStopStandbyServices
parameter_list|()
throws|throws
name|ServiceFailedException
block|{
if|if
condition|(
name|standbyCheckpointer
operator|!=
literal|null
condition|)
block|{
name|standbyCheckpointer
operator|.
name|cancelAndPreventCheckpoints
argument_list|(
literal|"About to leave standby state"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Stop services required in standby state */
DECL|method|stopStandbyServices ()
name|void
name|stopStandbyServices
parameter_list|()
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Stopping services started for standby state"
argument_list|)
expr_stmt|;
if|if
condition|(
name|standbyCheckpointer
operator|!=
literal|null
condition|)
block|{
name|standbyCheckpointer
operator|.
name|stop
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|editLogTailer
operator|!=
literal|null
condition|)
block|{
name|editLogTailer
operator|.
name|stop
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|dir
operator|!=
literal|null
operator|&&
name|dir
operator|.
name|fsImage
operator|!=
literal|null
operator|&&
name|dir
operator|.
name|fsImage
operator|.
name|editLog
operator|!=
literal|null
condition|)
block|{
name|dir
operator|.
name|fsImage
operator|.
name|editLog
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|checkOperation (OperationCategory op)
specifier|public
name|void
name|checkOperation
parameter_list|(
name|OperationCategory
name|op
parameter_list|)
throws|throws
name|StandbyException
block|{
if|if
condition|(
name|haContext
operator|!=
literal|null
condition|)
block|{
comment|// null in some unit tests
name|haContext
operator|.
name|checkOperation
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|getNamespaceDirs (Configuration conf)
specifier|public
specifier|static
name|Collection
argument_list|<
name|URI
argument_list|>
name|getNamespaceDirs
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
return|return
name|getStorageDirs
argument_list|(
name|conf
argument_list|,
name|DFS_NAMENODE_NAME_DIR_KEY
argument_list|)
return|;
block|}
comment|/**    * Get all edits dirs which are required. If any shared edits dirs are    * configured, these are also included in the set of required dirs.    *     * @param conf the HDFS configuration.    * @return all required dirs.    */
DECL|method|getRequiredNamespaceEditsDirs (Configuration conf)
specifier|public
specifier|static
name|Collection
argument_list|<
name|URI
argument_list|>
name|getRequiredNamespaceEditsDirs
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
name|Set
argument_list|<
name|URI
argument_list|>
name|ret
init|=
operator|new
name|HashSet
argument_list|<
name|URI
argument_list|>
argument_list|()
decl_stmt|;
name|ret
operator|.
name|addAll
argument_list|(
name|getStorageDirs
argument_list|(
name|conf
argument_list|,
name|DFS_NAMENODE_EDITS_DIR_REQUIRED_KEY
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|.
name|addAll
argument_list|(
name|getSharedEditsDirs
argument_list|(
name|conf
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
DECL|method|getStorageDirs (Configuration conf, String propertyName)
specifier|private
specifier|static
name|Collection
argument_list|<
name|URI
argument_list|>
name|getStorageDirs
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|String
name|propertyName
parameter_list|)
block|{
name|Collection
argument_list|<
name|String
argument_list|>
name|dirNames
init|=
name|conf
operator|.
name|getTrimmedStringCollection
argument_list|(
name|propertyName
argument_list|)
decl_stmt|;
name|StartupOption
name|startOpt
init|=
name|NameNode
operator|.
name|getStartupOption
argument_list|(
name|conf
argument_list|)
decl_stmt|;
if|if
condition|(
name|startOpt
operator|==
name|StartupOption
operator|.
name|IMPORT
condition|)
block|{
comment|// In case of IMPORT this will get rid of default directories
comment|// but will retain directories specified in hdfs-site.xml
comment|// When importing image from a checkpoint, the name-node can
comment|// start with empty set of storage directories.
name|Configuration
name|cE
init|=
operator|new
name|HdfsConfiguration
argument_list|(
literal|false
argument_list|)
decl_stmt|;
name|cE
operator|.
name|addResource
argument_list|(
literal|"core-default.xml"
argument_list|)
expr_stmt|;
name|cE
operator|.
name|addResource
argument_list|(
literal|"core-site.xml"
argument_list|)
expr_stmt|;
name|cE
operator|.
name|addResource
argument_list|(
literal|"hdfs-default.xml"
argument_list|)
expr_stmt|;
name|Collection
argument_list|<
name|String
argument_list|>
name|dirNames2
init|=
name|cE
operator|.
name|getTrimmedStringCollection
argument_list|(
name|propertyName
argument_list|)
decl_stmt|;
name|dirNames
operator|.
name|removeAll
argument_list|(
name|dirNames2
argument_list|)
expr_stmt|;
if|if
condition|(
name|dirNames
operator|.
name|isEmpty
argument_list|()
condition|)
name|LOG
operator|.
name|warn
argument_list|(
literal|"!!! WARNING !!!"
operator|+
literal|"\n\tThe NameNode currently runs without persistent storage."
operator|+
literal|"\n\tAny changes to the file system meta-data may be lost."
operator|+
literal|"\n\tRecommended actions:"
operator|+
literal|"\n\t\t- shutdown and restart NameNode with configured \""
operator|+
name|propertyName
operator|+
literal|"\" in hdfs-site.xml;"
operator|+
literal|"\n\t\t- use Backup Node as a persistent and up-to-date storage "
operator|+
literal|"of the file system meta-data."
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dirNames
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|dirNames
operator|=
name|Collections
operator|.
name|singletonList
argument_list|(
literal|"file:///tmp/hadoop/dfs/name"
argument_list|)
expr_stmt|;
block|}
return|return
name|Util
operator|.
name|stringCollectionAsURIs
argument_list|(
name|dirNames
argument_list|)
return|;
block|}
comment|/**    * Return an ordered list of edits directories to write to.    * The list is ordered such that all shared edits directories    * are ordered before non-shared directories, and any duplicates    * are removed. The order they are specified in the configuration    * is retained.    * @return Collection of shared edits directories.    * @throws IOException if multiple shared edits directories are configured    */
DECL|method|getNamespaceEditsDirs (Configuration conf)
specifier|public
specifier|static
name|List
argument_list|<
name|URI
argument_list|>
name|getNamespaceEditsDirs
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|getNamespaceEditsDirs
argument_list|(
name|conf
argument_list|,
literal|true
argument_list|)
return|;
block|}
DECL|method|getNamespaceEditsDirs (Configuration conf, boolean includeShared)
specifier|public
specifier|static
name|List
argument_list|<
name|URI
argument_list|>
name|getNamespaceEditsDirs
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|boolean
name|includeShared
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Use a LinkedHashSet so that order is maintained while we de-dup
comment|// the entries.
name|LinkedHashSet
argument_list|<
name|URI
argument_list|>
name|editsDirs
init|=
operator|new
name|LinkedHashSet
argument_list|<
name|URI
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|includeShared
condition|)
block|{
name|List
argument_list|<
name|URI
argument_list|>
name|sharedDirs
init|=
name|getSharedEditsDirs
argument_list|(
name|conf
argument_list|)
decl_stmt|;
comment|// Fail until multiple shared edits directories are supported (HDFS-2782)
if|if
condition|(
name|sharedDirs
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Multiple shared edits directories are not yet supported"
argument_list|)
throw|;
block|}
comment|// First add the shared edits dirs. It's critical that the shared dirs
comment|// are added first, since JournalSet syncs them in the order they are listed,
comment|// and we need to make sure all edits are in place in the shared storage
comment|// before they are replicated locally. See HDFS-2874.
for|for
control|(
name|URI
name|dir
range|:
name|sharedDirs
control|)
block|{
if|if
condition|(
operator|!
name|editsDirs
operator|.
name|add
argument_list|(
name|dir
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Edits URI "
operator|+
name|dir
operator|+
literal|" listed multiple times in "
operator|+
name|DFS_NAMENODE_SHARED_EDITS_DIR_KEY
operator|+
literal|". Ignoring duplicates."
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// Now add the non-shared dirs.
for|for
control|(
name|URI
name|dir
range|:
name|getStorageDirs
argument_list|(
name|conf
argument_list|,
name|DFS_NAMENODE_EDITS_DIR_KEY
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|editsDirs
operator|.
name|add
argument_list|(
name|dir
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Edits URI "
operator|+
name|dir
operator|+
literal|" listed multiple times in "
operator|+
name|DFS_NAMENODE_SHARED_EDITS_DIR_KEY
operator|+
literal|" and "
operator|+
name|DFS_NAMENODE_EDITS_DIR_KEY
operator|+
literal|". Ignoring duplicates."
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|editsDirs
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// If this is the case, no edit dirs have been explicitly configured.
comment|// Image dirs are to be used for edits too.
return|return
name|Lists
operator|.
name|newArrayList
argument_list|(
name|getNamespaceDirs
argument_list|(
name|conf
argument_list|)
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|Lists
operator|.
name|newArrayList
argument_list|(
name|editsDirs
argument_list|)
return|;
block|}
block|}
comment|/**    * Returns edit directories that are shared between primary and secondary.    * @param conf    * @return Collection of edit directories.    */
DECL|method|getSharedEditsDirs (Configuration conf)
specifier|public
specifier|static
name|List
argument_list|<
name|URI
argument_list|>
name|getSharedEditsDirs
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
comment|// don't use getStorageDirs here, because we want an empty default
comment|// rather than the dir in /tmp
name|Collection
argument_list|<
name|String
argument_list|>
name|dirNames
init|=
name|conf
operator|.
name|getTrimmedStringCollection
argument_list|(
name|DFS_NAMENODE_SHARED_EDITS_DIR_KEY
argument_list|)
decl_stmt|;
return|return
name|Util
operator|.
name|stringCollectionAsURIs
argument_list|(
name|dirNames
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|readLock ()
specifier|public
name|void
name|readLock
parameter_list|()
block|{
name|this
operator|.
name|fsLock
operator|.
name|readLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|readUnlock ()
specifier|public
name|void
name|readUnlock
parameter_list|()
block|{
name|this
operator|.
name|fsLock
operator|.
name|readLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|writeLock ()
specifier|public
name|void
name|writeLock
parameter_list|()
block|{
name|this
operator|.
name|fsLock
operator|.
name|writeLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|writeLockInterruptibly ()
specifier|public
name|void
name|writeLockInterruptibly
parameter_list|()
throws|throws
name|InterruptedException
block|{
name|this
operator|.
name|fsLock
operator|.
name|writeLock
argument_list|()
operator|.
name|lockInterruptibly
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|writeUnlock ()
specifier|public
name|void
name|writeUnlock
parameter_list|()
block|{
name|this
operator|.
name|fsLock
operator|.
name|writeLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|hasWriteLock ()
specifier|public
name|boolean
name|hasWriteLock
parameter_list|()
block|{
return|return
name|this
operator|.
name|fsLock
operator|.
name|isWriteLockedByCurrentThread
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|hasReadLock ()
specifier|public
name|boolean
name|hasReadLock
parameter_list|()
block|{
return|return
name|this
operator|.
name|fsLock
operator|.
name|getReadHoldCount
argument_list|()
operator|>
literal|0
return|;
block|}
annotation|@
name|Override
DECL|method|hasReadOrWriteLock ()
specifier|public
name|boolean
name|hasReadOrWriteLock
parameter_list|()
block|{
return|return
name|hasReadLock
argument_list|()
operator|||
name|hasWriteLock
argument_list|()
return|;
block|}
DECL|method|getNamespaceInfo ()
name|NamespaceInfo
name|getNamespaceInfo
parameter_list|()
block|{
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
return|return
name|unprotectedGetNamespaceInfo
argument_list|()
return|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Version of @see #getNamespaceInfo() that is not protected by a lock.    */
DECL|method|unprotectedGetNamespaceInfo ()
name|NamespaceInfo
name|unprotectedGetNamespaceInfo
parameter_list|()
block|{
return|return
operator|new
name|NamespaceInfo
argument_list|(
name|dir
operator|.
name|fsImage
operator|.
name|getStorage
argument_list|()
operator|.
name|getNamespaceID
argument_list|()
argument_list|,
name|getClusterId
argument_list|()
argument_list|,
name|getBlockPoolId
argument_list|()
argument_list|,
name|dir
operator|.
name|fsImage
operator|.
name|getStorage
argument_list|()
operator|.
name|getCTime
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Close down this file system manager.    * Causes heartbeat and lease daemons to stop; waits briefly for    * them to finish, but a short timeout returns control back to caller.    */
DECL|method|close ()
name|void
name|close
parameter_list|()
block|{
name|fsRunning
operator|=
literal|false
expr_stmt|;
try|try
block|{
name|stopCommonServices
argument_list|()
expr_stmt|;
if|if
condition|(
name|smmthread
operator|!=
literal|null
condition|)
name|smmthread
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
comment|// using finally to ensure we also wait for lease daemon
try|try
block|{
name|stopActiveServices
argument_list|()
expr_stmt|;
name|stopStandbyServices
argument_list|()
expr_stmt|;
if|if
condition|(
name|dir
operator|!=
literal|null
condition|)
block|{
name|dir
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ie
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Error closing FSDirectory"
argument_list|,
name|ie
argument_list|)
expr_stmt|;
name|IOUtils
operator|.
name|cleanup
argument_list|(
name|LOG
argument_list|,
name|dir
argument_list|)
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
DECL|method|isRunning ()
specifier|public
name|boolean
name|isRunning
parameter_list|()
block|{
return|return
name|fsRunning
return|;
block|}
annotation|@
name|Override
DECL|method|isInStandbyState ()
specifier|public
name|boolean
name|isInStandbyState
parameter_list|()
block|{
if|if
condition|(
name|haContext
operator|==
literal|null
operator|||
name|haContext
operator|.
name|getState
argument_list|()
operator|==
literal|null
condition|)
block|{
comment|// We're still starting up. In this case, if HA is
comment|// on for the cluster, we always start in standby. Otherwise
comment|// start in active.
return|return
name|haEnabled
return|;
block|}
return|return
name|HAServiceState
operator|.
name|STANDBY
operator|==
name|haContext
operator|.
name|getState
argument_list|()
operator|.
name|getServiceState
argument_list|()
return|;
block|}
comment|/**    * Dump all metadata into specified file    */
DECL|method|metaSave (String filename)
name|void
name|metaSave
parameter_list|(
name|String
name|filename
parameter_list|)
throws|throws
name|IOException
block|{
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkSuperuserPrivilege
argument_list|()
expr_stmt|;
name|File
name|file
init|=
operator|new
name|File
argument_list|(
name|System
operator|.
name|getProperty
argument_list|(
literal|"hadoop.log.dir"
argument_list|)
argument_list|,
name|filename
argument_list|)
decl_stmt|;
name|PrintWriter
name|out
init|=
operator|new
name|PrintWriter
argument_list|(
operator|new
name|BufferedWriter
argument_list|(
operator|new
name|OutputStreamWriter
argument_list|(
operator|new
name|FileOutputStream
argument_list|(
name|file
argument_list|,
literal|true
argument_list|)
argument_list|,
name|Charsets
operator|.
name|UTF_8
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|metaSave
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|out
operator|.
name|flush
argument_list|()
expr_stmt|;
name|out
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|metaSave (PrintWriter out)
specifier|private
name|void
name|metaSave
parameter_list|(
name|PrintWriter
name|out
parameter_list|)
block|{
assert|assert
name|hasWriteLock
argument_list|()
assert|;
name|long
name|totalInodes
init|=
name|this
operator|.
name|dir
operator|.
name|totalInodes
argument_list|()
decl_stmt|;
name|long
name|totalBlocks
init|=
name|this
operator|.
name|getBlocksTotal
argument_list|()
decl_stmt|;
name|out
operator|.
name|println
argument_list|(
name|totalInodes
operator|+
literal|" files and directories, "
operator|+
name|totalBlocks
operator|+
literal|" blocks = "
operator|+
operator|(
name|totalInodes
operator|+
name|totalBlocks
operator|)
operator|+
literal|" total filesystem objects"
argument_list|)
expr_stmt|;
name|blockManager
operator|.
name|metaSave
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|}
DECL|method|metaSaveAsString ()
specifier|private
name|String
name|metaSaveAsString
parameter_list|()
block|{
name|StringWriter
name|sw
init|=
operator|new
name|StringWriter
argument_list|()
decl_stmt|;
name|PrintWriter
name|pw
init|=
operator|new
name|PrintWriter
argument_list|(
name|sw
argument_list|)
decl_stmt|;
name|metaSave
argument_list|(
name|pw
argument_list|)
expr_stmt|;
name|pw
operator|.
name|flush
argument_list|()
expr_stmt|;
return|return
name|sw
operator|.
name|toString
argument_list|()
return|;
block|}
DECL|method|getDefaultBlockSize ()
name|long
name|getDefaultBlockSize
parameter_list|()
block|{
return|return
name|serverDefaults
operator|.
name|getBlockSize
argument_list|()
return|;
block|}
DECL|method|getServerDefaults ()
name|FsServerDefaults
name|getServerDefaults
parameter_list|()
throws|throws
name|StandbyException
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|READ
argument_list|)
expr_stmt|;
return|return
name|serverDefaults
return|;
block|}
DECL|method|getAccessTimePrecision ()
name|long
name|getAccessTimePrecision
parameter_list|()
block|{
return|return
name|accessTimePrecision
return|;
block|}
DECL|method|isAccessTimeSupported ()
specifier|private
name|boolean
name|isAccessTimeSupported
parameter_list|()
block|{
return|return
name|accessTimePrecision
operator|>
literal|0
return|;
block|}
comment|/////////////////////////////////////////////////////////
comment|//
comment|// These methods are called by HadoopFS clients
comment|//
comment|/////////////////////////////////////////////////////////
comment|/**    * Set permissions for an existing file.    * @throws IOException    */
DECL|method|setPermission (String src, FsPermission permission)
name|void
name|setPermission
parameter_list|(
name|String
name|src
parameter_list|,
name|FsPermission
name|permission
parameter_list|)
throws|throws
name|AccessControlException
throws|,
name|FileNotFoundException
throws|,
name|SafeModeException
throws|,
name|UnresolvedLinkException
throws|,
name|IOException
block|{
try|try
block|{
name|setPermissionInt
argument_list|(
name|src
argument_list|,
name|permission
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|AccessControlException
name|e
parameter_list|)
block|{
if|if
condition|(
name|isAuditEnabled
argument_list|()
operator|&&
name|isExternalInvocation
argument_list|()
condition|)
block|{
name|logAuditEvent
argument_list|(
literal|false
argument_list|,
name|UserGroupInformation
operator|.
name|getCurrentUser
argument_list|()
argument_list|,
name|getRemoteIp
argument_list|()
argument_list|,
literal|"setPermission"
argument_list|,
name|src
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
throw|throw
name|e
throw|;
block|}
block|}
DECL|method|setPermissionInt (String src, FsPermission permission)
specifier|private
name|void
name|setPermissionInt
parameter_list|(
name|String
name|src
parameter_list|,
name|FsPermission
name|permission
parameter_list|)
throws|throws
name|AccessControlException
throws|,
name|FileNotFoundException
throws|,
name|SafeModeException
throws|,
name|UnresolvedLinkException
throws|,
name|IOException
block|{
name|HdfsFileStatus
name|resultingStat
init|=
literal|null
decl_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|isInSafeMode
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SafeModeException
argument_list|(
literal|"Cannot set permission for "
operator|+
name|src
argument_list|,
name|safeMode
argument_list|)
throw|;
block|}
name|checkOwner
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|dir
operator|.
name|setPermission
argument_list|(
name|src
argument_list|,
name|permission
argument_list|)
expr_stmt|;
if|if
condition|(
name|isAuditEnabled
argument_list|()
operator|&&
name|isExternalInvocation
argument_list|()
condition|)
block|{
name|resultingStat
operator|=
name|dir
operator|.
name|getFileInfo
argument_list|(
name|src
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
name|getEditLog
argument_list|()
operator|.
name|logSync
argument_list|()
expr_stmt|;
if|if
condition|(
name|isAuditEnabled
argument_list|()
operator|&&
name|isExternalInvocation
argument_list|()
condition|)
block|{
name|logAuditEvent
argument_list|(
name|UserGroupInformation
operator|.
name|getCurrentUser
argument_list|()
argument_list|,
name|getRemoteIp
argument_list|()
argument_list|,
literal|"setPermission"
argument_list|,
name|src
argument_list|,
literal|null
argument_list|,
name|resultingStat
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Set owner for an existing file.    * @throws IOException    */
DECL|method|setOwner (String src, String username, String group)
name|void
name|setOwner
parameter_list|(
name|String
name|src
parameter_list|,
name|String
name|username
parameter_list|,
name|String
name|group
parameter_list|)
throws|throws
name|AccessControlException
throws|,
name|FileNotFoundException
throws|,
name|SafeModeException
throws|,
name|UnresolvedLinkException
throws|,
name|IOException
block|{
try|try
block|{
name|setOwnerInt
argument_list|(
name|src
argument_list|,
name|username
argument_list|,
name|group
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|AccessControlException
name|e
parameter_list|)
block|{
if|if
condition|(
name|isAuditEnabled
argument_list|()
operator|&&
name|isExternalInvocation
argument_list|()
condition|)
block|{
name|logAuditEvent
argument_list|(
literal|false
argument_list|,
name|UserGroupInformation
operator|.
name|getCurrentUser
argument_list|()
argument_list|,
name|getRemoteIp
argument_list|()
argument_list|,
literal|"setOwner"
argument_list|,
name|src
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
throw|throw
name|e
throw|;
block|}
block|}
DECL|method|setOwnerInt (String src, String username, String group)
specifier|private
name|void
name|setOwnerInt
parameter_list|(
name|String
name|src
parameter_list|,
name|String
name|username
parameter_list|,
name|String
name|group
parameter_list|)
throws|throws
name|AccessControlException
throws|,
name|FileNotFoundException
throws|,
name|SafeModeException
throws|,
name|UnresolvedLinkException
throws|,
name|IOException
block|{
name|HdfsFileStatus
name|resultingStat
init|=
literal|null
decl_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|isInSafeMode
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SafeModeException
argument_list|(
literal|"Cannot set owner for "
operator|+
name|src
argument_list|,
name|safeMode
argument_list|)
throw|;
block|}
name|FSPermissionChecker
name|pc
init|=
name|checkOwner
argument_list|(
name|src
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|pc
operator|.
name|isSuper
condition|)
block|{
if|if
condition|(
name|username
operator|!=
literal|null
operator|&&
operator|!
name|pc
operator|.
name|user
operator|.
name|equals
argument_list|(
name|username
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|AccessControlException
argument_list|(
literal|"Non-super user cannot change owner."
argument_list|)
throw|;
block|}
if|if
condition|(
name|group
operator|!=
literal|null
operator|&&
operator|!
name|pc
operator|.
name|containsGroup
argument_list|(
name|group
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|AccessControlException
argument_list|(
literal|"User does not belong to "
operator|+
name|group
operator|+
literal|" ."
argument_list|)
throw|;
block|}
block|}
name|dir
operator|.
name|setOwner
argument_list|(
name|src
argument_list|,
name|username
argument_list|,
name|group
argument_list|)
expr_stmt|;
if|if
condition|(
name|isAuditEnabled
argument_list|()
operator|&&
name|isExternalInvocation
argument_list|()
condition|)
block|{
name|resultingStat
operator|=
name|dir
operator|.
name|getFileInfo
argument_list|(
name|src
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
name|getEditLog
argument_list|()
operator|.
name|logSync
argument_list|()
expr_stmt|;
if|if
condition|(
name|isAuditEnabled
argument_list|()
operator|&&
name|isExternalInvocation
argument_list|()
condition|)
block|{
name|logAuditEvent
argument_list|(
name|UserGroupInformation
operator|.
name|getCurrentUser
argument_list|()
argument_list|,
name|getRemoteIp
argument_list|()
argument_list|,
literal|"setOwner"
argument_list|,
name|src
argument_list|,
literal|null
argument_list|,
name|resultingStat
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Get block locations within the specified range.    * @see ClientProtocol#getBlockLocations(String, long, long)    */
DECL|method|getBlockLocations (String clientMachine, String src, long offset, long length)
name|LocatedBlocks
name|getBlockLocations
parameter_list|(
name|String
name|clientMachine
parameter_list|,
name|String
name|src
parameter_list|,
name|long
name|offset
parameter_list|,
name|long
name|length
parameter_list|)
throws|throws
name|AccessControlException
throws|,
name|FileNotFoundException
throws|,
name|UnresolvedLinkException
throws|,
name|IOException
block|{
name|LocatedBlocks
name|blocks
init|=
name|getBlockLocations
argument_list|(
name|src
argument_list|,
name|offset
argument_list|,
name|length
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|blocks
operator|!=
literal|null
condition|)
block|{
name|blockManager
operator|.
name|getDatanodeManager
argument_list|()
operator|.
name|sortLocatedBlocks
argument_list|(
name|clientMachine
argument_list|,
name|blocks
operator|.
name|getLocatedBlocks
argument_list|()
argument_list|)
expr_stmt|;
name|LocatedBlock
name|lastBlock
init|=
name|blocks
operator|.
name|getLastLocatedBlock
argument_list|()
decl_stmt|;
if|if
condition|(
name|lastBlock
operator|!=
literal|null
condition|)
block|{
name|ArrayList
argument_list|<
name|LocatedBlock
argument_list|>
name|lastBlockList
init|=
operator|new
name|ArrayList
argument_list|<
name|LocatedBlock
argument_list|>
argument_list|()
decl_stmt|;
name|lastBlockList
operator|.
name|add
argument_list|(
name|lastBlock
argument_list|)
expr_stmt|;
name|blockManager
operator|.
name|getDatanodeManager
argument_list|()
operator|.
name|sortLocatedBlocks
argument_list|(
name|clientMachine
argument_list|,
name|lastBlockList
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|blocks
return|;
block|}
comment|/**    * Get block locations within the specified range.    * @see ClientProtocol#getBlockLocations(String, long, long)    * @throws FileNotFoundException, UnresolvedLinkException, IOException    */
DECL|method|getBlockLocations (String src, long offset, long length, boolean doAccessTime, boolean needBlockToken, boolean checkSafeMode)
name|LocatedBlocks
name|getBlockLocations
parameter_list|(
name|String
name|src
parameter_list|,
name|long
name|offset
parameter_list|,
name|long
name|length
parameter_list|,
name|boolean
name|doAccessTime
parameter_list|,
name|boolean
name|needBlockToken
parameter_list|,
name|boolean
name|checkSafeMode
parameter_list|)
throws|throws
name|FileNotFoundException
throws|,
name|UnresolvedLinkException
throws|,
name|IOException
block|{
try|try
block|{
return|return
name|getBlockLocationsInt
argument_list|(
name|src
argument_list|,
name|offset
argument_list|,
name|length
argument_list|,
name|doAccessTime
argument_list|,
name|needBlockToken
argument_list|,
name|checkSafeMode
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|AccessControlException
name|e
parameter_list|)
block|{
if|if
condition|(
name|isAuditEnabled
argument_list|()
operator|&&
name|isExternalInvocation
argument_list|()
condition|)
block|{
name|logAuditEvent
argument_list|(
literal|false
argument_list|,
name|UserGroupInformation
operator|.
name|getCurrentUser
argument_list|()
argument_list|,
name|getRemoteIp
argument_list|()
argument_list|,
literal|"open"
argument_list|,
name|src
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
throw|throw
name|e
throw|;
block|}
block|}
DECL|method|getBlockLocationsInt (String src, long offset, long length, boolean doAccessTime, boolean needBlockToken, boolean checkSafeMode)
specifier|private
name|LocatedBlocks
name|getBlockLocationsInt
parameter_list|(
name|String
name|src
parameter_list|,
name|long
name|offset
parameter_list|,
name|long
name|length
parameter_list|,
name|boolean
name|doAccessTime
parameter_list|,
name|boolean
name|needBlockToken
parameter_list|,
name|boolean
name|checkSafeMode
parameter_list|)
throws|throws
name|FileNotFoundException
throws|,
name|UnresolvedLinkException
throws|,
name|IOException
block|{
if|if
condition|(
name|isPermissionEnabled
condition|)
block|{
name|checkPathAccess
argument_list|(
name|src
argument_list|,
name|FsAction
operator|.
name|READ
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|offset
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|HadoopIllegalArgumentException
argument_list|(
literal|"Negative offset is not supported. File: "
operator|+
name|src
argument_list|)
throw|;
block|}
if|if
condition|(
name|length
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|HadoopIllegalArgumentException
argument_list|(
literal|"Negative length is not supported. File: "
operator|+
name|src
argument_list|)
throw|;
block|}
specifier|final
name|LocatedBlocks
name|ret
init|=
name|getBlockLocationsUpdateTimes
argument_list|(
name|src
argument_list|,
name|offset
argument_list|,
name|length
argument_list|,
name|doAccessTime
argument_list|,
name|needBlockToken
argument_list|)
decl_stmt|;
if|if
condition|(
name|isAuditEnabled
argument_list|()
operator|&&
name|isExternalInvocation
argument_list|()
condition|)
block|{
name|logAuditEvent
argument_list|(
name|UserGroupInformation
operator|.
name|getCurrentUser
argument_list|()
argument_list|,
name|getRemoteIp
argument_list|()
argument_list|,
literal|"open"
argument_list|,
name|src
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|checkSafeMode
operator|&&
name|isInSafeMode
argument_list|()
condition|)
block|{
for|for
control|(
name|LocatedBlock
name|b
range|:
name|ret
operator|.
name|getLocatedBlocks
argument_list|()
control|)
block|{
comment|// if safemode& no block locations yet then throw safemodeException
if|if
condition|(
operator|(
name|b
operator|.
name|getLocations
argument_list|()
operator|==
literal|null
operator|)
operator|||
operator|(
name|b
operator|.
name|getLocations
argument_list|()
operator|.
name|length
operator|==
literal|0
operator|)
condition|)
block|{
throw|throw
operator|new
name|SafeModeException
argument_list|(
literal|"Zero blocklocations for "
operator|+
name|src
argument_list|,
name|safeMode
argument_list|)
throw|;
block|}
block|}
block|}
return|return
name|ret
return|;
block|}
comment|/*    * Get block locations within the specified range, updating the    * access times if necessary.     */
DECL|method|getBlockLocationsUpdateTimes (String src, long offset, long length, boolean doAccessTime, boolean needBlockToken)
specifier|private
name|LocatedBlocks
name|getBlockLocationsUpdateTimes
parameter_list|(
name|String
name|src
parameter_list|,
name|long
name|offset
parameter_list|,
name|long
name|length
parameter_list|,
name|boolean
name|doAccessTime
parameter_list|,
name|boolean
name|needBlockToken
parameter_list|)
throws|throws
name|FileNotFoundException
throws|,
name|UnresolvedLinkException
throws|,
name|IOException
block|{
for|for
control|(
name|int
name|attempt
init|=
literal|0
init|;
name|attempt
operator|<
literal|2
condition|;
name|attempt
operator|++
control|)
block|{
if|if
condition|(
name|attempt
operator|==
literal|0
condition|)
block|{
comment|// first attempt is with readlock
name|readLock
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// second attempt is with  write lock
name|writeLock
argument_list|()
expr_stmt|;
comment|// writelock is needed to set accesstime
block|}
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|READ
argument_list|)
expr_stmt|;
comment|// if the namenode is in safemode, then do not update access time
if|if
condition|(
name|isInSafeMode
argument_list|()
condition|)
block|{
name|doAccessTime
operator|=
literal|false
expr_stmt|;
block|}
specifier|final
name|INodesInPath
name|iip
init|=
name|dir
operator|.
name|getINodesInPath
argument_list|(
name|src
argument_list|)
decl_stmt|;
specifier|final
name|INodeFile
name|inode
init|=
name|INodeFile
operator|.
name|valueOf
argument_list|(
name|iip
operator|.
name|getLastINode
argument_list|()
argument_list|,
name|src
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|iip
operator|.
name|isSnapshot
argument_list|()
comment|//snapshots are readonly, so don't update atime.
operator|&&
name|doAccessTime
operator|&&
name|isAccessTimeSupported
argument_list|()
condition|)
block|{
specifier|final
name|long
name|now
init|=
name|now
argument_list|()
decl_stmt|;
if|if
condition|(
name|now
operator|<=
name|inode
operator|.
name|getAccessTime
argument_list|()
operator|+
name|getAccessTimePrecision
argument_list|()
condition|)
block|{
comment|// if we have to set access time but we only have the readlock, then
comment|// restart this entire operation with the writeLock.
if|if
condition|(
name|attempt
operator|==
literal|0
condition|)
block|{
continue|continue;
block|}
block|}
name|dir
operator|.
name|setTimes
argument_list|(
name|src
argument_list|,
name|inode
argument_list|,
operator|-
literal|1
argument_list|,
name|now
argument_list|,
literal|false
argument_list|,
name|iip
operator|.
name|getLatestSnapshot
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|blockManager
operator|.
name|createLocatedBlocks
argument_list|(
name|inode
operator|.
name|getBlocks
argument_list|()
argument_list|,
name|inode
operator|.
name|computeFileSize
argument_list|(
literal|false
argument_list|)
argument_list|,
name|inode
operator|.
name|isUnderConstruction
argument_list|()
argument_list|,
name|offset
argument_list|,
name|length
argument_list|,
name|needBlockToken
argument_list|)
return|;
block|}
finally|finally
block|{
if|if
condition|(
name|attempt
operator|==
literal|0
condition|)
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
block|}
return|return
literal|null
return|;
comment|// can never reach here
block|}
comment|/**    * Moves all the blocks from srcs and appends them to trg    * To avoid rollbacks we will verify validitity of ALL of the args    * before we start actual move.    * @param target    * @param srcs    * @throws IOException    */
DECL|method|concat (String target, String [] srcs)
name|void
name|concat
parameter_list|(
name|String
name|target
parameter_list|,
name|String
index|[]
name|srcs
parameter_list|)
throws|throws
name|IOException
throws|,
name|UnresolvedLinkException
block|{
try|try
block|{
name|concatInt
argument_list|(
name|target
argument_list|,
name|srcs
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|AccessControlException
name|e
parameter_list|)
block|{
if|if
condition|(
name|isAuditEnabled
argument_list|()
operator|&&
name|isExternalInvocation
argument_list|()
condition|)
block|{
name|logAuditEvent
argument_list|(
literal|false
argument_list|,
name|UserGroupInformation
operator|.
name|getLoginUser
argument_list|()
argument_list|,
name|getRemoteIp
argument_list|()
argument_list|,
literal|"concat"
argument_list|,
name|Arrays
operator|.
name|toString
argument_list|(
name|srcs
argument_list|)
argument_list|,
name|target
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
throw|throw
name|e
throw|;
block|}
block|}
DECL|method|concatInt (String target, String [] srcs)
specifier|private
name|void
name|concatInt
parameter_list|(
name|String
name|target
parameter_list|,
name|String
index|[]
name|srcs
parameter_list|)
throws|throws
name|IOException
throws|,
name|UnresolvedLinkException
block|{
if|if
condition|(
name|FSNamesystem
operator|.
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|FSNamesystem
operator|.
name|LOG
operator|.
name|debug
argument_list|(
literal|"concat "
operator|+
name|Arrays
operator|.
name|toString
argument_list|(
name|srcs
argument_list|)
operator|+
literal|" to "
operator|+
name|target
argument_list|)
expr_stmt|;
block|}
comment|// verify args
if|if
condition|(
name|target
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Target file name is empty"
argument_list|)
throw|;
block|}
if|if
condition|(
name|srcs
operator|==
literal|null
operator|||
name|srcs
operator|.
name|length
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"No sources given"
argument_list|)
throw|;
block|}
comment|// We require all files be in the same directory
name|String
name|trgParent
init|=
name|target
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|target
operator|.
name|lastIndexOf
argument_list|(
name|Path
operator|.
name|SEPARATOR_CHAR
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|s
range|:
name|srcs
control|)
block|{
name|String
name|srcParent
init|=
name|s
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|s
operator|.
name|lastIndexOf
argument_list|(
name|Path
operator|.
name|SEPARATOR_CHAR
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|srcParent
operator|.
name|equals
argument_list|(
name|trgParent
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Sources and target are not in the same directory"
argument_list|)
throw|;
block|}
block|}
name|HdfsFileStatus
name|resultingStat
init|=
literal|null
decl_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|isInSafeMode
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SafeModeException
argument_list|(
literal|"Cannot concat "
operator|+
name|target
argument_list|,
name|safeMode
argument_list|)
throw|;
block|}
name|concatInternal
argument_list|(
name|target
argument_list|,
name|srcs
argument_list|)
expr_stmt|;
if|if
condition|(
name|isAuditEnabled
argument_list|()
operator|&&
name|isExternalInvocation
argument_list|()
condition|)
block|{
name|resultingStat
operator|=
name|dir
operator|.
name|getFileInfo
argument_list|(
name|target
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
name|getEditLog
argument_list|()
operator|.
name|logSync
argument_list|()
expr_stmt|;
if|if
condition|(
name|isAuditEnabled
argument_list|()
operator|&&
name|isExternalInvocation
argument_list|()
condition|)
block|{
name|logAuditEvent
argument_list|(
name|UserGroupInformation
operator|.
name|getLoginUser
argument_list|()
argument_list|,
name|getRemoteIp
argument_list|()
argument_list|,
literal|"concat"
argument_list|,
name|Arrays
operator|.
name|toString
argument_list|(
name|srcs
argument_list|)
argument_list|,
name|target
argument_list|,
name|resultingStat
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** See {@link #concat(String, String[])} */
DECL|method|concatInternal (String target, String [] srcs)
specifier|private
name|void
name|concatInternal
parameter_list|(
name|String
name|target
parameter_list|,
name|String
index|[]
name|srcs
parameter_list|)
throws|throws
name|IOException
throws|,
name|UnresolvedLinkException
block|{
assert|assert
name|hasWriteLock
argument_list|()
assert|;
comment|// write permission for the target
if|if
condition|(
name|isPermissionEnabled
condition|)
block|{
name|checkPathAccess
argument_list|(
name|target
argument_list|,
name|FsAction
operator|.
name|WRITE
argument_list|)
expr_stmt|;
comment|// and srcs
for|for
control|(
name|String
name|aSrc
range|:
name|srcs
control|)
block|{
name|checkPathAccess
argument_list|(
name|aSrc
argument_list|,
name|FsAction
operator|.
name|READ
argument_list|)
expr_stmt|;
comment|// read the file
name|checkParentAccess
argument_list|(
name|aSrc
argument_list|,
name|FsAction
operator|.
name|WRITE
argument_list|)
expr_stmt|;
comment|// for delete
block|}
block|}
comment|// to make sure no two files are the same
name|Set
argument_list|<
name|INode
argument_list|>
name|si
init|=
operator|new
name|HashSet
argument_list|<
name|INode
argument_list|>
argument_list|()
decl_stmt|;
comment|// we put the following prerequisite for the operation
comment|// replication and blocks sizes should be the same for ALL the blocks
comment|// check the target
specifier|final
name|INodeFile
name|trgInode
init|=
name|INodeFile
operator|.
name|valueOf
argument_list|(
name|dir
operator|.
name|getMutableINode
argument_list|(
name|target
argument_list|)
argument_list|,
name|target
argument_list|)
decl_stmt|;
if|if
condition|(
name|trgInode
operator|.
name|isUnderConstruction
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|HadoopIllegalArgumentException
argument_list|(
literal|"concat: target file "
operator|+
name|target
operator|+
literal|" is under construction"
argument_list|)
throw|;
block|}
comment|// per design target shouldn't be empty and all the blocks same size
if|if
condition|(
name|trgInode
operator|.
name|numBlocks
argument_list|()
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|HadoopIllegalArgumentException
argument_list|(
literal|"concat: target file "
operator|+
name|target
operator|+
literal|" is empty"
argument_list|)
throw|;
block|}
if|if
condition|(
name|trgInode
operator|instanceof
name|INodeFileWithSnapshot
condition|)
block|{
throw|throw
operator|new
name|HadoopIllegalArgumentException
argument_list|(
literal|"concat: target file "
operator|+
name|target
operator|+
literal|" is in a snapshot"
argument_list|)
throw|;
block|}
name|long
name|blockSize
init|=
name|trgInode
operator|.
name|getPreferredBlockSize
argument_list|()
decl_stmt|;
comment|// check the end block to be full
specifier|final
name|BlockInfo
name|last
init|=
name|trgInode
operator|.
name|getLastBlock
argument_list|()
decl_stmt|;
if|if
condition|(
name|blockSize
operator|!=
name|last
operator|.
name|getNumBytes
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|HadoopIllegalArgumentException
argument_list|(
literal|"The last block in "
operator|+
name|target
operator|+
literal|" is not full; last block size = "
operator|+
name|last
operator|.
name|getNumBytes
argument_list|()
operator|+
literal|" but file block size = "
operator|+
name|blockSize
argument_list|)
throw|;
block|}
name|si
operator|.
name|add
argument_list|(
name|trgInode
argument_list|)
expr_stmt|;
specifier|final
name|short
name|repl
init|=
name|trgInode
operator|.
name|getFileReplication
argument_list|()
decl_stmt|;
comment|// now check the srcs
name|boolean
name|endSrc
init|=
literal|false
decl_stmt|;
comment|// final src file doesn't have to have full end block
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|srcs
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|String
name|src
init|=
name|srcs
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|i
operator|==
name|srcs
operator|.
name|length
operator|-
literal|1
condition|)
name|endSrc
operator|=
literal|true
expr_stmt|;
specifier|final
name|INodeFile
name|srcInode
init|=
name|INodeFile
operator|.
name|valueOf
argument_list|(
name|dir
operator|.
name|getMutableINode
argument_list|(
name|src
argument_list|)
argument_list|,
name|src
argument_list|)
decl_stmt|;
if|if
condition|(
name|src
operator|.
name|isEmpty
argument_list|()
operator|||
name|srcInode
operator|.
name|isUnderConstruction
argument_list|()
operator|||
name|srcInode
operator|.
name|numBlocks
argument_list|()
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|HadoopIllegalArgumentException
argument_list|(
literal|"concat: source file "
operator|+
name|src
operator|+
literal|" is invalid or empty or underConstruction"
argument_list|)
throw|;
block|}
comment|// check replication and blocks size
if|if
condition|(
name|repl
operator|!=
name|srcInode
operator|.
name|getFileReplication
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|HadoopIllegalArgumentException
argument_list|(
literal|"concat: the soruce file "
operator|+
name|src
operator|+
literal|" and the target file "
operator|+
name|target
operator|+
literal|" should have the same replication: source replication is "
operator|+
name|srcInode
operator|.
name|getBlockReplication
argument_list|()
operator|+
literal|" but target replication is "
operator|+
name|repl
argument_list|)
throw|;
block|}
comment|//boolean endBlock=false;
comment|// verify that all the blocks are of the same length as target
comment|// should be enough to check the end blocks
specifier|final
name|BlockInfo
index|[]
name|srcBlocks
init|=
name|srcInode
operator|.
name|getBlocks
argument_list|()
decl_stmt|;
name|int
name|idx
init|=
name|srcBlocks
operator|.
name|length
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|endSrc
condition|)
name|idx
operator|=
name|srcBlocks
operator|.
name|length
operator|-
literal|2
expr_stmt|;
comment|// end block of endSrc is OK not to be full
if|if
condition|(
name|idx
operator|>=
literal|0
operator|&&
name|srcBlocks
index|[
name|idx
index|]
operator|.
name|getNumBytes
argument_list|()
operator|!=
name|blockSize
condition|)
block|{
throw|throw
operator|new
name|HadoopIllegalArgumentException
argument_list|(
literal|"concat: the soruce file "
operator|+
name|src
operator|+
literal|" and the target file "
operator|+
name|target
operator|+
literal|" should have the same blocks sizes: target block size is "
operator|+
name|blockSize
operator|+
literal|" but the size of source block "
operator|+
name|idx
operator|+
literal|" is "
operator|+
name|srcBlocks
index|[
name|idx
index|]
operator|.
name|getNumBytes
argument_list|()
argument_list|)
throw|;
block|}
name|si
operator|.
name|add
argument_list|(
name|srcInode
argument_list|)
expr_stmt|;
block|}
comment|// make sure no two files are the same
if|if
condition|(
name|si
operator|.
name|size
argument_list|()
operator|<
name|srcs
operator|.
name|length
operator|+
literal|1
condition|)
block|{
comment|// trg + srcs
comment|// it means at least two files are the same
throw|throw
operator|new
name|HadoopIllegalArgumentException
argument_list|(
literal|"concat: at least two of the source files are the same"
argument_list|)
throw|;
block|}
if|if
condition|(
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|debug
argument_list|(
literal|"DIR* NameSystem.concat: "
operator|+
name|Arrays
operator|.
name|toString
argument_list|(
name|srcs
argument_list|)
operator|+
literal|" to "
operator|+
name|target
argument_list|)
expr_stmt|;
block|}
name|dir
operator|.
name|concat
argument_list|(
name|target
argument_list|,
name|srcs
argument_list|)
expr_stmt|;
block|}
comment|/**    * stores the modification and access time for this inode.     * The access time is precise upto an hour. The transaction, if needed, is    * written to the edits log but is not flushed.    */
DECL|method|setTimes (String src, long mtime, long atime)
name|void
name|setTimes
parameter_list|(
name|String
name|src
parameter_list|,
name|long
name|mtime
parameter_list|,
name|long
name|atime
parameter_list|)
throws|throws
name|IOException
throws|,
name|UnresolvedLinkException
block|{
try|try
block|{
name|setTimesInt
argument_list|(
name|src
argument_list|,
name|mtime
argument_list|,
name|atime
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|AccessControlException
name|e
parameter_list|)
block|{
if|if
condition|(
name|isAuditEnabled
argument_list|()
operator|&&
name|isExternalInvocation
argument_list|()
condition|)
block|{
name|logAuditEvent
argument_list|(
literal|false
argument_list|,
name|UserGroupInformation
operator|.
name|getCurrentUser
argument_list|()
argument_list|,
name|getRemoteIp
argument_list|()
argument_list|,
literal|"setTimes"
argument_list|,
name|src
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
throw|throw
name|e
throw|;
block|}
block|}
DECL|method|setTimesInt (String src, long mtime, long atime)
specifier|private
name|void
name|setTimesInt
parameter_list|(
name|String
name|src
parameter_list|,
name|long
name|mtime
parameter_list|,
name|long
name|atime
parameter_list|)
throws|throws
name|IOException
throws|,
name|UnresolvedLinkException
block|{
if|if
condition|(
operator|!
name|isAccessTimeSupported
argument_list|()
operator|&&
name|atime
operator|!=
operator|-
literal|1
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Access time for hdfs is not configured. "
operator|+
literal|" Please set "
operator|+
name|DFS_NAMENODE_ACCESSTIME_PRECISION_KEY
operator|+
literal|" configuration parameter."
argument_list|)
throw|;
block|}
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
comment|// Write access is required to set access and modification times
if|if
condition|(
name|isPermissionEnabled
condition|)
block|{
name|checkPathAccess
argument_list|(
name|src
argument_list|,
name|FsAction
operator|.
name|WRITE
argument_list|)
expr_stmt|;
block|}
specifier|final
name|INodesInPath
name|iip
init|=
name|dir
operator|.
name|getMutableINodesInPath
argument_list|(
name|src
argument_list|)
decl_stmt|;
specifier|final
name|INode
name|inode
init|=
name|iip
operator|.
name|getLastINode
argument_list|()
decl_stmt|;
if|if
condition|(
name|inode
operator|!=
literal|null
condition|)
block|{
name|dir
operator|.
name|setTimes
argument_list|(
name|src
argument_list|,
name|inode
argument_list|,
name|mtime
argument_list|,
name|atime
argument_list|,
literal|true
argument_list|,
name|iip
operator|.
name|getLatestSnapshot
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|isAuditEnabled
argument_list|()
operator|&&
name|isExternalInvocation
argument_list|()
condition|)
block|{
specifier|final
name|HdfsFileStatus
name|stat
init|=
name|dir
operator|.
name|getFileInfo
argument_list|(
name|src
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|logAuditEvent
argument_list|(
name|UserGroupInformation
operator|.
name|getCurrentUser
argument_list|()
argument_list|,
name|getRemoteIp
argument_list|()
argument_list|,
literal|"setTimes"
argument_list|,
name|src
argument_list|,
literal|null
argument_list|,
name|stat
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
throw|throw
operator|new
name|FileNotFoundException
argument_list|(
literal|"File/Directory "
operator|+
name|src
operator|+
literal|" does not exist."
argument_list|)
throw|;
block|}
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Create a symbolic link.    */
DECL|method|createSymlink (String target, String link, PermissionStatus dirPerms, boolean createParent)
name|void
name|createSymlink
parameter_list|(
name|String
name|target
parameter_list|,
name|String
name|link
parameter_list|,
name|PermissionStatus
name|dirPerms
parameter_list|,
name|boolean
name|createParent
parameter_list|)
throws|throws
name|IOException
throws|,
name|UnresolvedLinkException
block|{
try|try
block|{
name|createSymlinkInt
argument_list|(
name|target
argument_list|,
name|link
argument_list|,
name|dirPerms
argument_list|,
name|createParent
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|AccessControlException
name|e
parameter_list|)
block|{
if|if
condition|(
name|isAuditEnabled
argument_list|()
operator|&&
name|isExternalInvocation
argument_list|()
condition|)
block|{
name|logAuditEvent
argument_list|(
literal|false
argument_list|,
name|UserGroupInformation
operator|.
name|getCurrentUser
argument_list|()
argument_list|,
name|getRemoteIp
argument_list|()
argument_list|,
literal|"createSymlink"
argument_list|,
name|link
argument_list|,
name|target
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
throw|throw
name|e
throw|;
block|}
block|}
DECL|method|createSymlinkInt (String target, String link, PermissionStatus dirPerms, boolean createParent)
specifier|private
name|void
name|createSymlinkInt
parameter_list|(
name|String
name|target
parameter_list|,
name|String
name|link
parameter_list|,
name|PermissionStatus
name|dirPerms
parameter_list|,
name|boolean
name|createParent
parameter_list|)
throws|throws
name|IOException
throws|,
name|UnresolvedLinkException
block|{
name|HdfsFileStatus
name|resultingStat
init|=
literal|null
decl_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|createParent
condition|)
block|{
name|verifyParentDir
argument_list|(
name|link
argument_list|)
expr_stmt|;
block|}
name|createSymlinkInternal
argument_list|(
name|target
argument_list|,
name|link
argument_list|,
name|dirPerms
argument_list|,
name|createParent
argument_list|)
expr_stmt|;
if|if
condition|(
name|isAuditEnabled
argument_list|()
operator|&&
name|isExternalInvocation
argument_list|()
condition|)
block|{
name|resultingStat
operator|=
name|dir
operator|.
name|getFileInfo
argument_list|(
name|link
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
name|getEditLog
argument_list|()
operator|.
name|logSync
argument_list|()
expr_stmt|;
if|if
condition|(
name|isAuditEnabled
argument_list|()
operator|&&
name|isExternalInvocation
argument_list|()
condition|)
block|{
name|logAuditEvent
argument_list|(
name|UserGroupInformation
operator|.
name|getCurrentUser
argument_list|()
argument_list|,
name|getRemoteIp
argument_list|()
argument_list|,
literal|"createSymlink"
argument_list|,
name|link
argument_list|,
name|target
argument_list|,
name|resultingStat
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Create a symbolic link.    */
DECL|method|createSymlinkInternal (String target, String link, PermissionStatus dirPerms, boolean createParent)
specifier|private
name|void
name|createSymlinkInternal
parameter_list|(
name|String
name|target
parameter_list|,
name|String
name|link
parameter_list|,
name|PermissionStatus
name|dirPerms
parameter_list|,
name|boolean
name|createParent
parameter_list|)
throws|throws
name|IOException
throws|,
name|UnresolvedLinkException
block|{
assert|assert
name|hasWriteLock
argument_list|()
assert|;
if|if
condition|(
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|debug
argument_list|(
literal|"DIR* NameSystem.createSymlink: target="
operator|+
name|target
operator|+
literal|" link="
operator|+
name|link
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isInSafeMode
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SafeModeException
argument_list|(
literal|"Cannot create symlink "
operator|+
name|link
argument_list|,
name|safeMode
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|DFSUtil
operator|.
name|isValidName
argument_list|(
name|link
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|InvalidPathException
argument_list|(
literal|"Invalid file name: "
operator|+
name|link
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|dir
operator|.
name|isValidToCreate
argument_list|(
name|link
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"failed to create link "
operator|+
name|link
operator|+
literal|" either because the filename is invalid or the file exists"
argument_list|)
throw|;
block|}
if|if
condition|(
name|isPermissionEnabled
condition|)
block|{
name|checkAncestorAccess
argument_list|(
name|link
argument_list|,
name|FsAction
operator|.
name|WRITE
argument_list|)
expr_stmt|;
block|}
comment|// validate that we have enough inodes.
name|checkFsObjectLimit
argument_list|()
expr_stmt|;
comment|// add symbolic link to namespace
name|dir
operator|.
name|addSymlink
argument_list|(
name|link
argument_list|,
name|target
argument_list|,
name|dirPerms
argument_list|,
name|createParent
argument_list|)
expr_stmt|;
block|}
comment|/**    * Set replication for an existing file.    *     * The NameNode sets new replication and schedules either replication of     * under-replicated data blocks or removal of the excessive block copies     * if the blocks are over-replicated.    *     * @see ClientProtocol#setReplication(String, short)    * @param src file name    * @param replication new replication    * @return true if successful;     *         false if file does not exist or is a directory    */
DECL|method|setReplication (final String src, final short replication)
name|boolean
name|setReplication
parameter_list|(
specifier|final
name|String
name|src
parameter_list|,
specifier|final
name|short
name|replication
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
return|return
name|setReplicationInt
argument_list|(
name|src
argument_list|,
name|replication
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|AccessControlException
name|e
parameter_list|)
block|{
if|if
condition|(
name|isAuditEnabled
argument_list|()
operator|&&
name|isExternalInvocation
argument_list|()
condition|)
block|{
name|logAuditEvent
argument_list|(
literal|false
argument_list|,
name|UserGroupInformation
operator|.
name|getCurrentUser
argument_list|()
argument_list|,
name|getRemoteIp
argument_list|()
argument_list|,
literal|"setReplication"
argument_list|,
name|src
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
throw|throw
name|e
throw|;
block|}
block|}
DECL|method|setReplicationInt (final String src, final short replication)
specifier|private
name|boolean
name|setReplicationInt
parameter_list|(
specifier|final
name|String
name|src
parameter_list|,
specifier|final
name|short
name|replication
parameter_list|)
throws|throws
name|IOException
block|{
name|blockManager
operator|.
name|verifyReplication
argument_list|(
name|src
argument_list|,
name|replication
argument_list|,
literal|null
argument_list|)
expr_stmt|;
specifier|final
name|boolean
name|isFile
decl_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|isInSafeMode
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SafeModeException
argument_list|(
literal|"Cannot set replication for "
operator|+
name|src
argument_list|,
name|safeMode
argument_list|)
throw|;
block|}
if|if
condition|(
name|isPermissionEnabled
condition|)
block|{
name|checkPathAccess
argument_list|(
name|src
argument_list|,
name|FsAction
operator|.
name|WRITE
argument_list|)
expr_stmt|;
block|}
specifier|final
name|short
index|[]
name|oldReplication
init|=
operator|new
name|short
index|[
literal|1
index|]
decl_stmt|;
specifier|final
name|Block
index|[]
name|blocks
init|=
name|dir
operator|.
name|setReplication
argument_list|(
name|src
argument_list|,
name|replication
argument_list|,
name|oldReplication
argument_list|)
decl_stmt|;
name|isFile
operator|=
name|blocks
operator|!=
literal|null
expr_stmt|;
if|if
condition|(
name|isFile
condition|)
block|{
name|blockManager
operator|.
name|setReplication
argument_list|(
name|oldReplication
index|[
literal|0
index|]
argument_list|,
name|replication
argument_list|,
name|src
argument_list|,
name|blocks
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
name|getEditLog
argument_list|()
operator|.
name|logSync
argument_list|()
expr_stmt|;
if|if
condition|(
name|isFile
operator|&&
name|isAuditEnabled
argument_list|()
operator|&&
name|isExternalInvocation
argument_list|()
condition|)
block|{
name|logAuditEvent
argument_list|(
name|UserGroupInformation
operator|.
name|getCurrentUser
argument_list|()
argument_list|,
name|getRemoteIp
argument_list|()
argument_list|,
literal|"setReplication"
argument_list|,
name|src
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
return|return
name|isFile
return|;
block|}
DECL|method|getPreferredBlockSize (String filename)
name|long
name|getPreferredBlockSize
parameter_list|(
name|String
name|filename
parameter_list|)
throws|throws
name|IOException
throws|,
name|UnresolvedLinkException
block|{
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|READ
argument_list|)
expr_stmt|;
if|if
condition|(
name|isPermissionEnabled
condition|)
block|{
name|checkTraverse
argument_list|(
name|filename
argument_list|)
expr_stmt|;
block|}
return|return
name|dir
operator|.
name|getPreferredBlockSize
argument_list|(
name|filename
argument_list|)
return|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Verify that parent directory of src exists.    */
DECL|method|verifyParentDir (String src)
specifier|private
name|void
name|verifyParentDir
parameter_list|(
name|String
name|src
parameter_list|)
throws|throws
name|FileNotFoundException
throws|,
name|ParentNotDirectoryException
throws|,
name|UnresolvedLinkException
block|{
assert|assert
name|hasReadOrWriteLock
argument_list|()
assert|;
name|Path
name|parent
init|=
operator|new
name|Path
argument_list|(
name|src
argument_list|)
operator|.
name|getParent
argument_list|()
decl_stmt|;
if|if
condition|(
name|parent
operator|!=
literal|null
condition|)
block|{
specifier|final
name|INode
name|parentNode
init|=
name|dir
operator|.
name|getINode
argument_list|(
name|parent
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|parentNode
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|FileNotFoundException
argument_list|(
literal|"Parent directory doesn't exist: "
operator|+
name|parent
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
operator|!
name|parentNode
operator|.
name|isDirectory
argument_list|()
operator|&&
operator|!
name|parentNode
operator|.
name|isSymlink
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|ParentNotDirectoryException
argument_list|(
literal|"Parent path is not a directory: "
operator|+
name|parent
argument_list|)
throw|;
block|}
block|}
block|}
comment|/**    * Create a new file entry in the namespace.    *     * For description of parameters and exceptions thrown see     * {@link ClientProtocol#create()}    */
DECL|method|startFile (String src, PermissionStatus permissions, String holder, String clientMachine, EnumSet<CreateFlag> flag, boolean createParent, short replication, long blockSize)
name|void
name|startFile
parameter_list|(
name|String
name|src
parameter_list|,
name|PermissionStatus
name|permissions
parameter_list|,
name|String
name|holder
parameter_list|,
name|String
name|clientMachine
parameter_list|,
name|EnumSet
argument_list|<
name|CreateFlag
argument_list|>
name|flag
parameter_list|,
name|boolean
name|createParent
parameter_list|,
name|short
name|replication
parameter_list|,
name|long
name|blockSize
parameter_list|)
throws|throws
name|AccessControlException
throws|,
name|SafeModeException
throws|,
name|FileAlreadyExistsException
throws|,
name|UnresolvedLinkException
throws|,
name|FileNotFoundException
throws|,
name|ParentNotDirectoryException
throws|,
name|IOException
block|{
try|try
block|{
name|startFileInt
argument_list|(
name|src
argument_list|,
name|permissions
argument_list|,
name|holder
argument_list|,
name|clientMachine
argument_list|,
name|flag
argument_list|,
name|createParent
argument_list|,
name|replication
argument_list|,
name|blockSize
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|AccessControlException
name|e
parameter_list|)
block|{
if|if
condition|(
name|isAuditEnabled
argument_list|()
operator|&&
name|isExternalInvocation
argument_list|()
condition|)
block|{
name|logAuditEvent
argument_list|(
literal|false
argument_list|,
name|UserGroupInformation
operator|.
name|getCurrentUser
argument_list|()
argument_list|,
name|getRemoteIp
argument_list|()
argument_list|,
literal|"create"
argument_list|,
name|src
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
throw|throw
name|e
throw|;
block|}
block|}
DECL|method|startFileInt (String src, PermissionStatus permissions, String holder, String clientMachine, EnumSet<CreateFlag> flag, boolean createParent, short replication, long blockSize)
specifier|private
name|void
name|startFileInt
parameter_list|(
name|String
name|src
parameter_list|,
name|PermissionStatus
name|permissions
parameter_list|,
name|String
name|holder
parameter_list|,
name|String
name|clientMachine
parameter_list|,
name|EnumSet
argument_list|<
name|CreateFlag
argument_list|>
name|flag
parameter_list|,
name|boolean
name|createParent
parameter_list|,
name|short
name|replication
parameter_list|,
name|long
name|blockSize
parameter_list|)
throws|throws
name|AccessControlException
throws|,
name|SafeModeException
throws|,
name|FileAlreadyExistsException
throws|,
name|UnresolvedLinkException
throws|,
name|FileNotFoundException
throws|,
name|ParentNotDirectoryException
throws|,
name|IOException
block|{
name|boolean
name|skipSync
init|=
literal|false
decl_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|startFileInternal
argument_list|(
name|src
argument_list|,
name|permissions
argument_list|,
name|holder
argument_list|,
name|clientMachine
argument_list|,
name|flag
argument_list|,
name|createParent
argument_list|,
name|replication
argument_list|,
name|blockSize
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|StandbyException
name|se
parameter_list|)
block|{
name|skipSync
operator|=
literal|true
expr_stmt|;
throw|throw
name|se
throw|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
comment|// There might be transactions logged while trying to recover the lease.
comment|// They need to be sync'ed even when an exception was thrown.
if|if
condition|(
operator|!
name|skipSync
condition|)
block|{
name|getEditLog
argument_list|()
operator|.
name|logSync
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|isAuditEnabled
argument_list|()
operator|&&
name|isExternalInvocation
argument_list|()
condition|)
block|{
specifier|final
name|HdfsFileStatus
name|stat
init|=
name|dir
operator|.
name|getFileInfo
argument_list|(
name|src
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|logAuditEvent
argument_list|(
name|UserGroupInformation
operator|.
name|getCurrentUser
argument_list|()
argument_list|,
name|getRemoteIp
argument_list|()
argument_list|,
literal|"create"
argument_list|,
name|src
argument_list|,
literal|null
argument_list|,
name|stat
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Create new or open an existing file for append.<p>    *     * In case of opening the file for append, the method returns the last    * block of the file if this is a partial block, which can still be used    * for writing more data. The client uses the returned block locations    * to form the data pipeline for this block.<br>    * The method returns null if the last block is full or if this is a     * new file. The client then allocates a new block with the next call    * using {@link NameNode#addBlock()}.<p>    *    * For description of parameters and exceptions thrown see     * {@link ClientProtocol#create()}    *     * @return the last block locations if the block is partial or null otherwise    */
DECL|method|startFileInternal (String src, PermissionStatus permissions, String holder, String clientMachine, EnumSet<CreateFlag> flag, boolean createParent, short replication, long blockSize)
specifier|private
name|LocatedBlock
name|startFileInternal
parameter_list|(
name|String
name|src
parameter_list|,
name|PermissionStatus
name|permissions
parameter_list|,
name|String
name|holder
parameter_list|,
name|String
name|clientMachine
parameter_list|,
name|EnumSet
argument_list|<
name|CreateFlag
argument_list|>
name|flag
parameter_list|,
name|boolean
name|createParent
parameter_list|,
name|short
name|replication
parameter_list|,
name|long
name|blockSize
parameter_list|)
throws|throws
name|SafeModeException
throws|,
name|FileAlreadyExistsException
throws|,
name|AccessControlException
throws|,
name|UnresolvedLinkException
throws|,
name|FileNotFoundException
throws|,
name|ParentNotDirectoryException
throws|,
name|IOException
block|{
assert|assert
name|hasWriteLock
argument_list|()
assert|;
if|if
condition|(
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|debug
argument_list|(
literal|"DIR* NameSystem.startFile: src="
operator|+
name|src
operator|+
literal|", holder="
operator|+
name|holder
operator|+
literal|", clientMachine="
operator|+
name|clientMachine
operator|+
literal|", createParent="
operator|+
name|createParent
operator|+
literal|", replication="
operator|+
name|replication
operator|+
literal|", createFlag="
operator|+
name|flag
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isInSafeMode
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SafeModeException
argument_list|(
literal|"Cannot create file"
operator|+
name|src
argument_list|,
name|safeMode
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|DFSUtil
operator|.
name|isValidName
argument_list|(
name|src
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|InvalidPathException
argument_list|(
name|src
argument_list|)
throw|;
block|}
comment|// Verify that the destination does not exist as a directory already.
name|boolean
name|pathExists
init|=
name|dir
operator|.
name|existsMutable
argument_list|(
name|src
argument_list|)
decl_stmt|;
if|if
condition|(
name|pathExists
operator|&&
name|dir
operator|.
name|isDir
argument_list|(
name|src
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|FileAlreadyExistsException
argument_list|(
literal|"Cannot create file "
operator|+
name|src
operator|+
literal|"; already exists as a directory."
argument_list|)
throw|;
block|}
name|boolean
name|overwrite
init|=
name|flag
operator|.
name|contains
argument_list|(
name|CreateFlag
operator|.
name|OVERWRITE
argument_list|)
decl_stmt|;
name|boolean
name|append
init|=
name|flag
operator|.
name|contains
argument_list|(
name|CreateFlag
operator|.
name|APPEND
argument_list|)
decl_stmt|;
if|if
condition|(
name|isPermissionEnabled
condition|)
block|{
if|if
condition|(
name|append
operator|||
operator|(
name|overwrite
operator|&&
name|pathExists
operator|)
condition|)
block|{
name|checkPathAccess
argument_list|(
name|src
argument_list|,
name|FsAction
operator|.
name|WRITE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|checkAncestorAccess
argument_list|(
name|src
argument_list|,
name|FsAction
operator|.
name|WRITE
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|createParent
condition|)
block|{
name|verifyParentDir
argument_list|(
name|src
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|blockManager
operator|.
name|verifyReplication
argument_list|(
name|src
argument_list|,
name|replication
argument_list|,
name|clientMachine
argument_list|)
expr_stmt|;
name|boolean
name|create
init|=
name|flag
operator|.
name|contains
argument_list|(
name|CreateFlag
operator|.
name|CREATE
argument_list|)
decl_stmt|;
specifier|final
name|INodesInPath
name|iip
init|=
name|dir
operator|.
name|getINodesInPath
argument_list|(
name|src
argument_list|)
decl_stmt|;
specifier|final
name|INode
name|myFile
init|=
name|iip
operator|.
name|getINode
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|myFile
operator|==
literal|null
condition|)
block|{
if|if
condition|(
operator|!
name|create
condition|)
block|{
throw|throw
operator|new
name|FileNotFoundException
argument_list|(
literal|"failed to overwrite or append to non-existent file "
operator|+
name|src
operator|+
literal|" on client "
operator|+
name|clientMachine
argument_list|)
throw|;
block|}
block|}
else|else
block|{
comment|// File exists - must be one of append or overwrite
if|if
condition|(
name|overwrite
condition|)
block|{
name|delete
argument_list|(
name|src
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Opening an existing file for write - may need to recover lease.
name|recoverLeaseInternal
argument_list|(
name|myFile
argument_list|,
name|src
argument_list|,
name|holder
argument_list|,
name|clientMachine
argument_list|,
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|append
condition|)
block|{
throw|throw
operator|new
name|FileAlreadyExistsException
argument_list|(
literal|"failed to create file "
operator|+
name|src
operator|+
literal|" on client "
operator|+
name|clientMachine
operator|+
literal|" because the file exists"
argument_list|)
throw|;
block|}
block|}
block|}
specifier|final
name|DatanodeDescriptor
name|clientNode
init|=
name|blockManager
operator|.
name|getDatanodeManager
argument_list|()
operator|.
name|getDatanodeByHost
argument_list|(
name|clientMachine
argument_list|)
decl_stmt|;
if|if
condition|(
name|append
operator|&&
name|myFile
operator|!=
literal|null
condition|)
block|{
specifier|final
name|INodeFile
name|f
init|=
name|INodeFile
operator|.
name|valueOf
argument_list|(
name|myFile
argument_list|,
name|src
argument_list|)
decl_stmt|;
return|return
name|prepareFileForWrite
argument_list|(
name|src
argument_list|,
name|f
argument_list|,
name|holder
argument_list|,
name|clientMachine
argument_list|,
name|clientNode
argument_list|,
literal|true
argument_list|,
name|iip
operator|.
name|getLatestSnapshot
argument_list|()
argument_list|)
return|;
block|}
else|else
block|{
comment|// Now we can add the name to the filesystem. This file has no
comment|// blocks associated with it.
comment|//
name|checkFsObjectLimit
argument_list|()
expr_stmt|;
comment|// increment global generation stamp
name|long
name|genstamp
init|=
name|nextGenerationStamp
argument_list|()
decl_stmt|;
name|INodeFileUnderConstruction
name|newNode
init|=
name|dir
operator|.
name|addFile
argument_list|(
name|src
argument_list|,
name|permissions
argument_list|,
name|replication
argument_list|,
name|blockSize
argument_list|,
name|holder
argument_list|,
name|clientMachine
argument_list|,
name|clientNode
argument_list|,
name|genstamp
argument_list|)
decl_stmt|;
if|if
condition|(
name|newNode
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"DIR* NameSystem.startFile: "
operator|+
literal|"Unable to add file to namespace."
argument_list|)
throw|;
block|}
name|leaseManager
operator|.
name|addLease
argument_list|(
name|newNode
operator|.
name|getClientName
argument_list|()
argument_list|,
name|src
argument_list|)
expr_stmt|;
comment|// record file record in log, record new generation stamp
name|getEditLog
argument_list|()
operator|.
name|logOpenFile
argument_list|(
name|src
argument_list|,
name|newNode
argument_list|)
expr_stmt|;
if|if
condition|(
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|debug
argument_list|(
literal|"DIR* NameSystem.startFile: "
operator|+
literal|"add "
operator|+
name|src
operator|+
literal|" to namespace for "
operator|+
name|holder
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ie
parameter_list|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|warn
argument_list|(
literal|"DIR* NameSystem.startFile: "
operator|+
name|ie
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
name|ie
throw|;
block|}
return|return
literal|null
return|;
block|}
comment|/**    * Replace current node with a INodeUnderConstruction.    * Recreate in-memory lease record.    *     * @param src path to the file    * @param file existing file object    * @param leaseHolder identifier of the lease holder on this file    * @param clientMachine identifier of the client machine    * @param clientNode if the client is collocated with a DN, that DN's descriptor    * @param writeToEditLog whether to persist this change to the edit log    * @return the last block locations if the block is partial or null otherwise    * @throws UnresolvedLinkException    * @throws IOException    */
DECL|method|prepareFileForWrite (String src, INodeFile file, String leaseHolder, String clientMachine, DatanodeDescriptor clientNode, boolean writeToEditLog, Snapshot latestSnapshot)
name|LocatedBlock
name|prepareFileForWrite
parameter_list|(
name|String
name|src
parameter_list|,
name|INodeFile
name|file
parameter_list|,
name|String
name|leaseHolder
parameter_list|,
name|String
name|clientMachine
parameter_list|,
name|DatanodeDescriptor
name|clientNode
parameter_list|,
name|boolean
name|writeToEditLog
parameter_list|,
name|Snapshot
name|latestSnapshot
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|latestSnapshot
operator|!=
literal|null
condition|)
block|{
name|file
operator|=
name|file
operator|.
name|recordModification
argument_list|(
name|latestSnapshot
argument_list|)
expr_stmt|;
block|}
specifier|final
name|INodeFileUnderConstruction
name|cons
init|=
name|file
operator|.
name|toUnderConstruction
argument_list|(
name|leaseHolder
argument_list|,
name|clientMachine
argument_list|,
name|clientNode
argument_list|)
decl_stmt|;
name|dir
operator|.
name|replaceINodeFile
argument_list|(
name|src
argument_list|,
name|file
argument_list|,
name|cons
argument_list|,
name|latestSnapshot
argument_list|)
expr_stmt|;
name|leaseManager
operator|.
name|addLease
argument_list|(
name|cons
operator|.
name|getClientName
argument_list|()
argument_list|,
name|src
argument_list|)
expr_stmt|;
name|LocatedBlock
name|ret
init|=
name|blockManager
operator|.
name|convertLastBlockToUnderConstruction
argument_list|(
name|cons
argument_list|)
decl_stmt|;
if|if
condition|(
name|writeToEditLog
condition|)
block|{
name|getEditLog
argument_list|()
operator|.
name|logOpenFile
argument_list|(
name|src
argument_list|,
name|cons
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
comment|/**    * Recover lease;    * Immediately revoke the lease of the current lease holder and start lease    * recovery so that the file can be forced to be closed.    *     * @param src the path of the file to start lease recovery    * @param holder the lease holder's name    * @param clientMachine the client machine's name    * @return true if the file is already closed    * @throws IOException    */
DECL|method|recoverLease (String src, String holder, String clientMachine)
name|boolean
name|recoverLease
parameter_list|(
name|String
name|src
parameter_list|,
name|String
name|holder
parameter_list|,
name|String
name|clientMachine
parameter_list|)
throws|throws
name|IOException
block|{
name|boolean
name|skipSync
init|=
literal|false
decl_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|isInSafeMode
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SafeModeException
argument_list|(
literal|"Cannot recover the lease of "
operator|+
name|src
argument_list|,
name|safeMode
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|DFSUtil
operator|.
name|isValidName
argument_list|(
name|src
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Invalid file name: "
operator|+
name|src
argument_list|)
throw|;
block|}
specifier|final
name|INodeFile
name|inode
init|=
name|INodeFile
operator|.
name|valueOf
argument_list|(
name|dir
operator|.
name|getINode
argument_list|(
name|src
argument_list|)
argument_list|,
name|src
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|inode
operator|.
name|isUnderConstruction
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
name|isPermissionEnabled
condition|)
block|{
name|checkPathAccess
argument_list|(
name|src
argument_list|,
name|FsAction
operator|.
name|WRITE
argument_list|)
expr_stmt|;
block|}
name|recoverLeaseInternal
argument_list|(
name|inode
argument_list|,
name|src
argument_list|,
name|holder
argument_list|,
name|clientMachine
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|StandbyException
name|se
parameter_list|)
block|{
name|skipSync
operator|=
literal|true
expr_stmt|;
throw|throw
name|se
throw|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
comment|// There might be transactions logged while trying to recover the lease.
comment|// They need to be sync'ed even when an exception was thrown.
if|if
condition|(
operator|!
name|skipSync
condition|)
block|{
name|getEditLog
argument_list|()
operator|.
name|logSync
argument_list|()
expr_stmt|;
block|}
block|}
return|return
literal|false
return|;
block|}
DECL|method|recoverLeaseInternal (INode fileInode, String src, String holder, String clientMachine, boolean force)
specifier|private
name|void
name|recoverLeaseInternal
parameter_list|(
name|INode
name|fileInode
parameter_list|,
name|String
name|src
parameter_list|,
name|String
name|holder
parameter_list|,
name|String
name|clientMachine
parameter_list|,
name|boolean
name|force
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|hasWriteLock
argument_list|()
assert|;
if|if
condition|(
name|fileInode
operator|!=
literal|null
operator|&&
name|fileInode
operator|.
name|isUnderConstruction
argument_list|()
condition|)
block|{
name|INodeFileUnderConstruction
name|pendingFile
init|=
operator|(
name|INodeFileUnderConstruction
operator|)
name|fileInode
decl_stmt|;
comment|//
comment|// If the file is under construction , then it must be in our
comment|// leases. Find the appropriate lease record.
comment|//
name|Lease
name|lease
init|=
name|leaseManager
operator|.
name|getLease
argument_list|(
name|holder
argument_list|)
decl_stmt|;
comment|//
comment|// We found the lease for this file. And surprisingly the original
comment|// holder is trying to recreate this file. This should never occur.
comment|//
if|if
condition|(
operator|!
name|force
operator|&&
name|lease
operator|!=
literal|null
condition|)
block|{
name|Lease
name|leaseFile
init|=
name|leaseManager
operator|.
name|getLeaseByPath
argument_list|(
name|src
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|leaseFile
operator|!=
literal|null
operator|&&
name|leaseFile
operator|.
name|equals
argument_list|(
name|lease
argument_list|)
operator|)
operator|||
name|lease
operator|.
name|getHolder
argument_list|()
operator|.
name|equals
argument_list|(
name|holder
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|AlreadyBeingCreatedException
argument_list|(
literal|"failed to create file "
operator|+
name|src
operator|+
literal|" for "
operator|+
name|holder
operator|+
literal|" on client "
operator|+
name|clientMachine
operator|+
literal|" because current leaseholder is trying to recreate file."
argument_list|)
throw|;
block|}
block|}
comment|//
comment|// Find the original holder.
comment|//
name|lease
operator|=
name|leaseManager
operator|.
name|getLease
argument_list|(
name|pendingFile
operator|.
name|getClientName
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|lease
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|AlreadyBeingCreatedException
argument_list|(
literal|"failed to create file "
operator|+
name|src
operator|+
literal|" for "
operator|+
name|holder
operator|+
literal|" on client "
operator|+
name|clientMachine
operator|+
literal|" because pendingCreates is non-null but no leases found."
argument_list|)
throw|;
block|}
if|if
condition|(
name|force
condition|)
block|{
comment|// close now: no need to wait for soft lease expiration and
comment|// close only the file src
name|LOG
operator|.
name|info
argument_list|(
literal|"recoverLease: "
operator|+
name|lease
operator|+
literal|", src="
operator|+
name|src
operator|+
literal|" from client "
operator|+
name|pendingFile
operator|.
name|getClientName
argument_list|()
argument_list|)
expr_stmt|;
name|internalReleaseLease
argument_list|(
name|lease
argument_list|,
name|src
argument_list|,
name|holder
argument_list|)
expr_stmt|;
block|}
else|else
block|{
assert|assert
name|lease
operator|.
name|getHolder
argument_list|()
operator|.
name|equals
argument_list|(
name|pendingFile
operator|.
name|getClientName
argument_list|()
argument_list|)
operator|:
literal|"Current lease holder "
operator|+
name|lease
operator|.
name|getHolder
argument_list|()
operator|+
literal|" does not match file creator "
operator|+
name|pendingFile
operator|.
name|getClientName
argument_list|()
assert|;
comment|//
comment|// If the original holder has not renewed in the last SOFTLIMIT
comment|// period, then start lease recovery.
comment|//
if|if
condition|(
name|lease
operator|.
name|expiredSoftLimit
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"startFile: recover "
operator|+
name|lease
operator|+
literal|", src="
operator|+
name|src
operator|+
literal|" client "
operator|+
name|pendingFile
operator|.
name|getClientName
argument_list|()
argument_list|)
expr_stmt|;
name|boolean
name|isClosed
init|=
name|internalReleaseLease
argument_list|(
name|lease
argument_list|,
name|src
argument_list|,
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|isClosed
condition|)
throw|throw
operator|new
name|RecoveryInProgressException
argument_list|(
literal|"Failed to close file "
operator|+
name|src
operator|+
literal|". Lease recovery is in progress. Try again later."
argument_list|)
throw|;
block|}
else|else
block|{
specifier|final
name|BlockInfo
name|lastBlock
init|=
name|pendingFile
operator|.
name|getLastBlock
argument_list|()
decl_stmt|;
if|if
condition|(
name|lastBlock
operator|!=
literal|null
operator|&&
name|lastBlock
operator|.
name|getBlockUCState
argument_list|()
operator|==
name|BlockUCState
operator|.
name|UNDER_RECOVERY
condition|)
block|{
throw|throw
operator|new
name|RecoveryInProgressException
argument_list|(
literal|"Recovery in progress, file ["
operator|+
name|src
operator|+
literal|"], "
operator|+
literal|"lease owner ["
operator|+
name|lease
operator|.
name|getHolder
argument_list|()
operator|+
literal|"]"
argument_list|)
throw|;
block|}
else|else
block|{
throw|throw
operator|new
name|AlreadyBeingCreatedException
argument_list|(
literal|"Failed to create file ["
operator|+
name|src
operator|+
literal|"] for ["
operator|+
name|holder
operator|+
literal|"] on client ["
operator|+
name|clientMachine
operator|+
literal|"], because this file is already being created by ["
operator|+
name|pendingFile
operator|.
name|getClientName
argument_list|()
operator|+
literal|"] on ["
operator|+
name|pendingFile
operator|.
name|getClientMachine
argument_list|()
operator|+
literal|"]"
argument_list|)
throw|;
block|}
block|}
block|}
block|}
block|}
comment|/**    * Append to an existing file in the namespace.    */
DECL|method|appendFile (String src, String holder, String clientMachine)
name|LocatedBlock
name|appendFile
parameter_list|(
name|String
name|src
parameter_list|,
name|String
name|holder
parameter_list|,
name|String
name|clientMachine
parameter_list|)
throws|throws
name|AccessControlException
throws|,
name|SafeModeException
throws|,
name|FileAlreadyExistsException
throws|,
name|FileNotFoundException
throws|,
name|ParentNotDirectoryException
throws|,
name|IOException
block|{
try|try
block|{
return|return
name|appendFileInt
argument_list|(
name|src
argument_list|,
name|holder
argument_list|,
name|clientMachine
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|AccessControlException
name|e
parameter_list|)
block|{
if|if
condition|(
name|isAuditEnabled
argument_list|()
operator|&&
name|isExternalInvocation
argument_list|()
condition|)
block|{
name|logAuditEvent
argument_list|(
literal|false
argument_list|,
name|UserGroupInformation
operator|.
name|getCurrentUser
argument_list|()
argument_list|,
name|getRemoteIp
argument_list|()
argument_list|,
literal|"append"
argument_list|,
name|src
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
throw|throw
name|e
throw|;
block|}
block|}
DECL|method|appendFileInt (String src, String holder, String clientMachine)
specifier|private
name|LocatedBlock
name|appendFileInt
parameter_list|(
name|String
name|src
parameter_list|,
name|String
name|holder
parameter_list|,
name|String
name|clientMachine
parameter_list|)
throws|throws
name|AccessControlException
throws|,
name|SafeModeException
throws|,
name|FileAlreadyExistsException
throws|,
name|FileNotFoundException
throws|,
name|ParentNotDirectoryException
throws|,
name|IOException
block|{
name|boolean
name|skipSync
init|=
literal|false
decl_stmt|;
if|if
condition|(
operator|!
name|supportAppends
condition|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"Append is not enabled on this NameNode. Use the "
operator|+
name|DFS_SUPPORT_APPEND_KEY
operator|+
literal|" configuration option to enable it."
argument_list|)
throw|;
block|}
name|LocatedBlock
name|lb
init|=
literal|null
decl_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|lb
operator|=
name|startFileInternal
argument_list|(
name|src
argument_list|,
literal|null
argument_list|,
name|holder
argument_list|,
name|clientMachine
argument_list|,
name|EnumSet
operator|.
name|of
argument_list|(
name|CreateFlag
operator|.
name|APPEND
argument_list|)
argument_list|,
literal|false
argument_list|,
name|blockManager
operator|.
name|maxReplication
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|StandbyException
name|se
parameter_list|)
block|{
name|skipSync
operator|=
literal|true
expr_stmt|;
throw|throw
name|se
throw|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
comment|// There might be transactions logged while trying to recover the lease.
comment|// They need to be sync'ed even when an exception was thrown.
if|if
condition|(
operator|!
name|skipSync
condition|)
block|{
name|getEditLog
argument_list|()
operator|.
name|logSync
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|lb
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|debug
argument_list|(
literal|"DIR* NameSystem.appendFile: file "
operator|+
name|src
operator|+
literal|" for "
operator|+
name|holder
operator|+
literal|" at "
operator|+
name|clientMachine
operator|+
literal|" block "
operator|+
name|lb
operator|.
name|getBlock
argument_list|()
operator|+
literal|" block size "
operator|+
name|lb
operator|.
name|getBlock
argument_list|()
operator|.
name|getNumBytes
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|isAuditEnabled
argument_list|()
operator|&&
name|isExternalInvocation
argument_list|()
condition|)
block|{
name|logAuditEvent
argument_list|(
name|UserGroupInformation
operator|.
name|getCurrentUser
argument_list|()
argument_list|,
name|getRemoteIp
argument_list|()
argument_list|,
literal|"append"
argument_list|,
name|src
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
return|return
name|lb
return|;
block|}
DECL|method|getExtendedBlock (Block blk)
name|ExtendedBlock
name|getExtendedBlock
parameter_list|(
name|Block
name|blk
parameter_list|)
block|{
return|return
operator|new
name|ExtendedBlock
argument_list|(
name|blockPoolId
argument_list|,
name|blk
argument_list|)
return|;
block|}
DECL|method|setBlockPoolId (String bpid)
name|void
name|setBlockPoolId
parameter_list|(
name|String
name|bpid
parameter_list|)
block|{
name|blockPoolId
operator|=
name|bpid
expr_stmt|;
name|blockManager
operator|.
name|setBlockPoolId
argument_list|(
name|blockPoolId
argument_list|)
expr_stmt|;
block|}
comment|/**    * The client would like to obtain an additional block for the indicated    * filename (which is being written-to).  Return an array that consists    * of the block, plus a set of machines.  The first on this list should    * be where the client writes data.  Subsequent items in the list must    * be provided in the connection to the first datanode.    *    * Make sure the previous blocks have been reported by datanodes and    * are replicated.  Will return an empty 2-elt array if we want the    * client to "try again later".    */
DECL|method|getAdditionalBlock (String src, String clientName, ExtendedBlock previous, HashMap<Node, Node> excludedNodes )
name|LocatedBlock
name|getAdditionalBlock
parameter_list|(
name|String
name|src
parameter_list|,
name|String
name|clientName
parameter_list|,
name|ExtendedBlock
name|previous
parameter_list|,
name|HashMap
argument_list|<
name|Node
argument_list|,
name|Node
argument_list|>
name|excludedNodes
parameter_list|)
throws|throws
name|LeaseExpiredException
throws|,
name|NotReplicatedYetException
throws|,
name|QuotaExceededException
throws|,
name|SafeModeException
throws|,
name|UnresolvedLinkException
throws|,
name|IOException
block|{
name|checkBlock
argument_list|(
name|previous
argument_list|)
expr_stmt|;
name|Block
name|previousBlock
init|=
name|ExtendedBlock
operator|.
name|getLocalBlock
argument_list|(
name|previous
argument_list|)
decl_stmt|;
name|long
name|fileLength
decl_stmt|,
name|blockSize
decl_stmt|;
name|int
name|replication
decl_stmt|;
name|DatanodeDescriptor
name|clientNode
init|=
literal|null
decl_stmt|;
name|Block
name|newBlock
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|debug
argument_list|(
literal|"BLOCK* NameSystem.getAdditionalBlock: file "
operator|+
name|src
operator|+
literal|" for "
operator|+
name|clientName
argument_list|)
expr_stmt|;
block|}
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|isInSafeMode
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SafeModeException
argument_list|(
literal|"Cannot add block to "
operator|+
name|src
argument_list|,
name|safeMode
argument_list|)
throw|;
block|}
comment|// have we exceeded the configured limit of fs objects.
name|checkFsObjectLimit
argument_list|()
expr_stmt|;
name|INodeFileUnderConstruction
name|pendingFile
init|=
name|checkLease
argument_list|(
name|src
argument_list|,
name|clientName
argument_list|)
decl_stmt|;
name|BlockInfo
name|lastBlockInFile
init|=
name|pendingFile
operator|.
name|getLastBlock
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|Block
operator|.
name|matchingIdAndGenStamp
argument_list|(
name|previousBlock
argument_list|,
name|lastBlockInFile
argument_list|)
condition|)
block|{
comment|// The block that the client claims is the current last block
comment|// doesn't match up with what we think is the last block. There are
comment|// three possibilities:
comment|// 1) This is the first block allocation of an append() pipeline
comment|//    which started appending exactly at a block boundary.
comment|//    In this case, the client isn't passed the previous block,
comment|//    so it makes the allocateBlock() call with previous=null.
comment|//    We can distinguish this since the last block of the file
comment|//    will be exactly a full block.
comment|// 2) This is a retry from a client that missed the response of a
comment|//    prior getAdditionalBlock() call, perhaps because of a network
comment|//    timeout, or because of an HA failover. In that case, we know
comment|//    by the fact that the client is re-issuing the RPC that it
comment|//    never began to write to the old block. Hence it is safe to
comment|//    abandon it and allocate a new one.
comment|// 3) This is an entirely bogus request/bug -- we should error out
comment|//    rather than potentially appending a new block with an empty
comment|//    one in the middle, etc
name|BlockInfo
name|penultimateBlock
init|=
name|pendingFile
operator|.
name|getPenultimateBlock
argument_list|()
decl_stmt|;
if|if
condition|(
name|previous
operator|==
literal|null
operator|&&
name|lastBlockInFile
operator|!=
literal|null
operator|&&
name|lastBlockInFile
operator|.
name|getNumBytes
argument_list|()
operator|==
name|pendingFile
operator|.
name|getPreferredBlockSize
argument_list|()
operator|&&
name|lastBlockInFile
operator|.
name|isComplete
argument_list|()
condition|)
block|{
comment|// Case 1
if|if
condition|(
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|debug
argument_list|(
literal|"BLOCK* NameSystem.allocateBlock: handling block allocation"
operator|+
literal|" writing to a file with a complete previous block: src="
operator|+
name|src
operator|+
literal|" lastBlock="
operator|+
name|lastBlockInFile
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|Block
operator|.
name|matchingIdAndGenStamp
argument_list|(
name|penultimateBlock
argument_list|,
name|previousBlock
argument_list|)
condition|)
block|{
comment|// Case 2
if|if
condition|(
name|lastBlockInFile
operator|.
name|getNumBytes
argument_list|()
operator|!=
literal|0
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Request looked like a retry to allocate block "
operator|+
name|lastBlockInFile
operator|+
literal|" but it already contains "
operator|+
name|lastBlockInFile
operator|.
name|getNumBytes
argument_list|()
operator|+
literal|" bytes"
argument_list|)
throw|;
block|}
comment|// The retry case ("b" above) -- abandon the old block.
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|info
argument_list|(
literal|"BLOCK* allocateBlock: "
operator|+
literal|"caught retry for allocation of a new block in "
operator|+
name|src
operator|+
literal|". Abandoning old block "
operator|+
name|lastBlockInFile
argument_list|)
expr_stmt|;
name|dir
operator|.
name|removeBlock
argument_list|(
name|src
argument_list|,
name|pendingFile
argument_list|,
name|lastBlockInFile
argument_list|)
expr_stmt|;
name|dir
operator|.
name|persistBlocks
argument_list|(
name|src
argument_list|,
name|pendingFile
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Cannot allocate block in "
operator|+
name|src
operator|+
literal|": "
operator|+
literal|"passed 'previous' block "
operator|+
name|previous
operator|+
literal|" does not match actual "
operator|+
literal|"last block in file "
operator|+
name|lastBlockInFile
argument_list|)
throw|;
block|}
block|}
comment|// commit the last block and complete it if it has minimum replicas
name|commitOrCompleteLastBlock
argument_list|(
name|pendingFile
argument_list|,
name|previousBlock
argument_list|)
expr_stmt|;
comment|//
comment|// If we fail this, bad things happen!
comment|//
if|if
condition|(
operator|!
name|checkFileProgress
argument_list|(
name|pendingFile
argument_list|,
literal|false
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|NotReplicatedYetException
argument_list|(
literal|"Not replicated yet:"
operator|+
name|src
argument_list|)
throw|;
block|}
name|fileLength
operator|=
name|pendingFile
operator|.
name|computeContentSummary
argument_list|()
operator|.
name|getLength
argument_list|()
expr_stmt|;
name|blockSize
operator|=
name|pendingFile
operator|.
name|getPreferredBlockSize
argument_list|()
expr_stmt|;
name|clientNode
operator|=
name|pendingFile
operator|.
name|getClientNode
argument_list|()
expr_stmt|;
name|replication
operator|=
name|pendingFile
operator|.
name|getFileReplication
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
comment|// choose targets for the new block to be allocated.
specifier|final
name|DatanodeDescriptor
name|targets
index|[]
init|=
name|blockManager
operator|.
name|chooseTarget
argument_list|(
name|src
argument_list|,
name|replication
argument_list|,
name|clientNode
argument_list|,
name|excludedNodes
argument_list|,
name|blockSize
argument_list|)
decl_stmt|;
comment|// Allocate a new block and record it in the INode.
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|isInSafeMode
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SafeModeException
argument_list|(
literal|"Cannot add block to "
operator|+
name|src
argument_list|,
name|safeMode
argument_list|)
throw|;
block|}
specifier|final
name|INodesInPath
name|iip
init|=
name|dir
operator|.
name|rootDir
operator|.
name|getExistingPathINodes
argument_list|(
name|src
argument_list|,
literal|true
argument_list|)
decl_stmt|;
specifier|final
name|INodeFileUnderConstruction
name|pendingFile
init|=
name|checkLease
argument_list|(
name|src
argument_list|,
name|clientName
argument_list|,
name|iip
operator|.
name|getLastINode
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|checkFileProgress
argument_list|(
name|pendingFile
argument_list|,
literal|false
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|NotReplicatedYetException
argument_list|(
literal|"Not replicated yet:"
operator|+
name|src
argument_list|)
throw|;
block|}
comment|// allocate new block record block locations in INode.
name|newBlock
operator|=
name|allocateBlock
argument_list|(
name|src
argument_list|,
name|iip
argument_list|,
name|targets
argument_list|)
expr_stmt|;
for|for
control|(
name|DatanodeDescriptor
name|dn
range|:
name|targets
control|)
block|{
name|dn
operator|.
name|incBlocksScheduled
argument_list|()
expr_stmt|;
block|}
name|dir
operator|.
name|persistBlocks
argument_list|(
name|src
argument_list|,
name|pendingFile
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|persistBlocks
condition|)
block|{
name|getEditLog
argument_list|()
operator|.
name|logSync
argument_list|()
expr_stmt|;
block|}
comment|// Create next block
name|LocatedBlock
name|b
init|=
operator|new
name|LocatedBlock
argument_list|(
name|getExtendedBlock
argument_list|(
name|newBlock
argument_list|)
argument_list|,
name|targets
argument_list|,
name|fileLength
argument_list|)
decl_stmt|;
name|blockManager
operator|.
name|setBlockToken
argument_list|(
name|b
argument_list|,
name|BlockTokenSecretManager
operator|.
name|AccessMode
operator|.
name|WRITE
argument_list|)
expr_stmt|;
return|return
name|b
return|;
block|}
comment|/** @see NameNode#getAdditionalDatanode(String, ExtendedBlock, DatanodeInfo[], DatanodeInfo[], int, String) */
DECL|method|getAdditionalDatanode (final String src, final ExtendedBlock blk, final DatanodeInfo[] existings, final HashMap<Node, Node> excludes, final int numAdditionalNodes, final String clientName )
name|LocatedBlock
name|getAdditionalDatanode
parameter_list|(
specifier|final
name|String
name|src
parameter_list|,
specifier|final
name|ExtendedBlock
name|blk
parameter_list|,
specifier|final
name|DatanodeInfo
index|[]
name|existings
parameter_list|,
specifier|final
name|HashMap
argument_list|<
name|Node
argument_list|,
name|Node
argument_list|>
name|excludes
parameter_list|,
specifier|final
name|int
name|numAdditionalNodes
parameter_list|,
specifier|final
name|String
name|clientName
parameter_list|)
throws|throws
name|IOException
block|{
comment|//check if the feature is enabled
name|dtpReplaceDatanodeOnFailure
operator|.
name|checkEnabled
argument_list|()
expr_stmt|;
specifier|final
name|DatanodeDescriptor
name|clientnode
decl_stmt|;
specifier|final
name|long
name|preferredblocksize
decl_stmt|;
specifier|final
name|List
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|chosen
decl_stmt|;
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
comment|//check safe mode
if|if
condition|(
name|isInSafeMode
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SafeModeException
argument_list|(
literal|"Cannot add datanode; src="
operator|+
name|src
operator|+
literal|", blk="
operator|+
name|blk
argument_list|,
name|safeMode
argument_list|)
throw|;
block|}
comment|//check lease
specifier|final
name|INodeFileUnderConstruction
name|file
init|=
name|checkLease
argument_list|(
name|src
argument_list|,
name|clientName
argument_list|)
decl_stmt|;
name|clientnode
operator|=
name|file
operator|.
name|getClientNode
argument_list|()
expr_stmt|;
name|preferredblocksize
operator|=
name|file
operator|.
name|getPreferredBlockSize
argument_list|()
expr_stmt|;
comment|//find datanode descriptors
name|chosen
operator|=
operator|new
name|ArrayList
argument_list|<
name|DatanodeDescriptor
argument_list|>
argument_list|()
expr_stmt|;
for|for
control|(
name|DatanodeInfo
name|d
range|:
name|existings
control|)
block|{
specifier|final
name|DatanodeDescriptor
name|descriptor
init|=
name|blockManager
operator|.
name|getDatanodeManager
argument_list|(             )
operator|.
name|getDatanode
argument_list|(
name|d
argument_list|)
decl_stmt|;
if|if
condition|(
name|descriptor
operator|!=
literal|null
condition|)
block|{
name|chosen
operator|.
name|add
argument_list|(
name|descriptor
argument_list|)
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
comment|// choose new datanodes.
specifier|final
name|DatanodeInfo
index|[]
name|targets
init|=
name|blockManager
operator|.
name|getBlockPlacementPolicy
argument_list|(         )
operator|.
name|chooseTarget
argument_list|(
name|src
argument_list|,
name|numAdditionalNodes
argument_list|,
name|clientnode
argument_list|,
name|chosen
argument_list|,
literal|true
argument_list|,
name|excludes
argument_list|,
name|preferredblocksize
argument_list|)
decl_stmt|;
specifier|final
name|LocatedBlock
name|lb
init|=
operator|new
name|LocatedBlock
argument_list|(
name|blk
argument_list|,
name|targets
argument_list|)
decl_stmt|;
name|blockManager
operator|.
name|setBlockToken
argument_list|(
name|lb
argument_list|,
name|AccessMode
operator|.
name|COPY
argument_list|)
expr_stmt|;
return|return
name|lb
return|;
block|}
comment|/**    * The client would like to let go of the given block    */
DECL|method|abandonBlock (ExtendedBlock b, String src, String holder)
name|boolean
name|abandonBlock
parameter_list|(
name|ExtendedBlock
name|b
parameter_list|,
name|String
name|src
parameter_list|,
name|String
name|holder
parameter_list|)
throws|throws
name|LeaseExpiredException
throws|,
name|FileNotFoundException
throws|,
name|UnresolvedLinkException
throws|,
name|IOException
block|{
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
comment|//
comment|// Remove the block from the pending creates list
comment|//
if|if
condition|(
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|debug
argument_list|(
literal|"BLOCK* NameSystem.abandonBlock: "
operator|+
name|b
operator|+
literal|"of file "
operator|+
name|src
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isInSafeMode
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SafeModeException
argument_list|(
literal|"Cannot abandon block "
operator|+
name|b
operator|+
literal|" for fle"
operator|+
name|src
argument_list|,
name|safeMode
argument_list|)
throw|;
block|}
name|INodeFileUnderConstruction
name|file
init|=
name|checkLease
argument_list|(
name|src
argument_list|,
name|holder
argument_list|)
decl_stmt|;
name|dir
operator|.
name|removeBlock
argument_list|(
name|src
argument_list|,
name|file
argument_list|,
name|ExtendedBlock
operator|.
name|getLocalBlock
argument_list|(
name|b
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|debug
argument_list|(
literal|"BLOCK* NameSystem.abandonBlock: "
operator|+
name|b
operator|+
literal|" is removed from pendingCreates"
argument_list|)
expr_stmt|;
block|}
name|dir
operator|.
name|persistBlocks
argument_list|(
name|src
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|persistBlocks
condition|)
block|{
name|getEditLog
argument_list|()
operator|.
name|logSync
argument_list|()
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
comment|/** make sure that we still have the lease on this file. */
DECL|method|checkLease (String src, String holder)
specifier|private
name|INodeFileUnderConstruction
name|checkLease
parameter_list|(
name|String
name|src
parameter_list|,
name|String
name|holder
parameter_list|)
throws|throws
name|LeaseExpiredException
throws|,
name|UnresolvedLinkException
block|{
return|return
name|checkLease
argument_list|(
name|src
argument_list|,
name|holder
argument_list|,
name|dir
operator|.
name|getINode
argument_list|(
name|src
argument_list|)
argument_list|)
return|;
block|}
DECL|method|checkLease (String src, String holder, INode file)
specifier|private
name|INodeFileUnderConstruction
name|checkLease
parameter_list|(
name|String
name|src
parameter_list|,
name|String
name|holder
parameter_list|,
name|INode
name|file
parameter_list|)
throws|throws
name|LeaseExpiredException
block|{
assert|assert
name|hasReadOrWriteLock
argument_list|()
assert|;
if|if
condition|(
name|file
operator|==
literal|null
operator|||
operator|!
operator|(
name|file
operator|instanceof
name|INodeFile
operator|)
condition|)
block|{
name|Lease
name|lease
init|=
name|leaseManager
operator|.
name|getLease
argument_list|(
name|holder
argument_list|)
decl_stmt|;
throw|throw
operator|new
name|LeaseExpiredException
argument_list|(
literal|"No lease on "
operator|+
name|src
operator|+
literal|": File does not exist. "
operator|+
operator|(
name|lease
operator|!=
literal|null
condition|?
name|lease
operator|.
name|toString
argument_list|()
else|:
literal|"Holder "
operator|+
name|holder
operator|+
literal|" does not have any open files."
operator|)
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|file
operator|.
name|isUnderConstruction
argument_list|()
condition|)
block|{
name|Lease
name|lease
init|=
name|leaseManager
operator|.
name|getLease
argument_list|(
name|holder
argument_list|)
decl_stmt|;
throw|throw
operator|new
name|LeaseExpiredException
argument_list|(
literal|"No lease on "
operator|+
name|src
operator|+
literal|": File is not open for writing. "
operator|+
operator|(
name|lease
operator|!=
literal|null
condition|?
name|lease
operator|.
name|toString
argument_list|()
else|:
literal|"Holder "
operator|+
name|holder
operator|+
literal|" does not have any open files."
operator|)
argument_list|)
throw|;
block|}
name|INodeFileUnderConstruction
name|pendingFile
init|=
operator|(
name|INodeFileUnderConstruction
operator|)
name|file
decl_stmt|;
if|if
condition|(
name|holder
operator|!=
literal|null
operator|&&
operator|!
name|pendingFile
operator|.
name|getClientName
argument_list|()
operator|.
name|equals
argument_list|(
name|holder
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|LeaseExpiredException
argument_list|(
literal|"Lease mismatch on "
operator|+
name|src
operator|+
literal|" owned by "
operator|+
name|pendingFile
operator|.
name|getClientName
argument_list|()
operator|+
literal|" but is accessed by "
operator|+
name|holder
argument_list|)
throw|;
block|}
return|return
name|pendingFile
return|;
block|}
comment|/**    * Complete in-progress write to the given file.    * @return true if successful, false if the client should continue to retry    *         (e.g if not all blocks have reached minimum replication yet)    * @throws IOException on error (eg lease mismatch, file not open, file deleted)    */
DECL|method|completeFile (String src, String holder, ExtendedBlock last)
name|boolean
name|completeFile
parameter_list|(
name|String
name|src
parameter_list|,
name|String
name|holder
parameter_list|,
name|ExtendedBlock
name|last
parameter_list|)
throws|throws
name|SafeModeException
throws|,
name|UnresolvedLinkException
throws|,
name|IOException
block|{
name|checkBlock
argument_list|(
name|last
argument_list|)
expr_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|success
operator|=
name|completeFileInternal
argument_list|(
name|src
argument_list|,
name|holder
argument_list|,
name|ExtendedBlock
operator|.
name|getLocalBlock
argument_list|(
name|last
argument_list|)
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
name|getEditLog
argument_list|()
operator|.
name|logSync
argument_list|()
expr_stmt|;
return|return
name|success
return|;
block|}
DECL|method|completeFileInternal (String src, String holder, Block last)
specifier|private
name|boolean
name|completeFileInternal
parameter_list|(
name|String
name|src
parameter_list|,
name|String
name|holder
parameter_list|,
name|Block
name|last
parameter_list|)
throws|throws
name|SafeModeException
throws|,
name|UnresolvedLinkException
throws|,
name|IOException
block|{
assert|assert
name|hasWriteLock
argument_list|()
assert|;
if|if
condition|(
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|debug
argument_list|(
literal|"DIR* NameSystem.completeFile: "
operator|+
name|src
operator|+
literal|" for "
operator|+
name|holder
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isInSafeMode
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SafeModeException
argument_list|(
literal|"Cannot complete file "
operator|+
name|src
argument_list|,
name|safeMode
argument_list|)
throw|;
block|}
specifier|final
name|INodesInPath
name|iip
init|=
name|dir
operator|.
name|getINodesInPath
argument_list|(
name|src
argument_list|)
decl_stmt|;
specifier|final
name|INodeFileUnderConstruction
name|pendingFile
decl_stmt|;
try|try
block|{
name|pendingFile
operator|=
name|checkLease
argument_list|(
name|src
argument_list|,
name|holder
argument_list|,
name|iip
operator|.
name|getINode
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|LeaseExpiredException
name|lee
parameter_list|)
block|{
specifier|final
name|INode
name|inode
init|=
name|dir
operator|.
name|getINode
argument_list|(
name|src
argument_list|)
decl_stmt|;
if|if
condition|(
name|inode
operator|!=
literal|null
operator|&&
name|inode
operator|instanceof
name|INodeFile
operator|&&
operator|!
name|inode
operator|.
name|isUnderConstruction
argument_list|()
condition|)
block|{
comment|// This could be a retry RPC - i.e the client tried to close
comment|// the file, but missed the RPC response. Thus, it is trying
comment|// again to close the file. If the file still exists and
comment|// the client's view of the last block matches the actual
comment|// last block, then we'll treat it as a successful close.
comment|// See HDFS-3031.
specifier|final
name|Block
name|realLastBlock
init|=
operator|(
operator|(
name|INodeFile
operator|)
name|inode
operator|)
operator|.
name|getLastBlock
argument_list|()
decl_stmt|;
if|if
condition|(
name|Block
operator|.
name|matchingIdAndGenStamp
argument_list|(
name|last
argument_list|,
name|realLastBlock
argument_list|)
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|info
argument_list|(
literal|"DIR* completeFile: "
operator|+
literal|"request from "
operator|+
name|holder
operator|+
literal|" to complete "
operator|+
name|src
operator|+
literal|" which is already closed. But, it appears to be an RPC "
operator|+
literal|"retry. Returning success"
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
throw|throw
name|lee
throw|;
block|}
comment|// commit the last block and complete it if it has minimum replicas
name|commitOrCompleteLastBlock
argument_list|(
name|pendingFile
argument_list|,
name|last
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|checkFileProgress
argument_list|(
name|pendingFile
argument_list|,
literal|true
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|finalizeINodeFileUnderConstruction
argument_list|(
name|src
argument_list|,
name|pendingFile
argument_list|,
name|iip
operator|.
name|getLatestSnapshot
argument_list|()
argument_list|)
expr_stmt|;
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|info
argument_list|(
literal|"DIR* completeFile: "
operator|+
name|src
operator|+
literal|" is closed by "
operator|+
name|holder
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|/**    * Allocate a block at the given pending filename    *     * @param src path to the file    * @param inodesInPath representing each of the components of src.     *                     The last INode is the INode for the file.    * @throws QuotaExceededException If addition of block exceeds space quota    */
DECL|method|allocateBlock (String src, INodesInPath inodesInPath, DatanodeDescriptor targets[])
specifier|private
name|Block
name|allocateBlock
parameter_list|(
name|String
name|src
parameter_list|,
name|INodesInPath
name|inodesInPath
parameter_list|,
name|DatanodeDescriptor
name|targets
index|[]
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|hasWriteLock
argument_list|()
assert|;
name|Block
name|b
init|=
operator|new
name|Block
argument_list|(
name|getFSImage
argument_list|()
operator|.
name|getUniqueBlockId
argument_list|()
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|// Increment the generation stamp for every new block.
name|b
operator|.
name|setGenerationStamp
argument_list|(
name|nextGenerationStamp
argument_list|()
argument_list|)
expr_stmt|;
name|b
operator|=
name|dir
operator|.
name|addBlock
argument_list|(
name|src
argument_list|,
name|inodesInPath
argument_list|,
name|b
argument_list|,
name|targets
argument_list|)
expr_stmt|;
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|info
argument_list|(
literal|"BLOCK* allocateBlock: "
operator|+
name|src
operator|+
literal|". "
operator|+
name|blockPoolId
operator|+
literal|" "
operator|+
name|b
argument_list|)
expr_stmt|;
return|return
name|b
return|;
block|}
comment|/**    * Check that the indicated file's blocks are present and    * replicated.  If not, return false. If checkall is true, then check    * all blocks, otherwise check only penultimate block.    */
DECL|method|checkFileProgress (INodeFile v, boolean checkall)
name|boolean
name|checkFileProgress
parameter_list|(
name|INodeFile
name|v
parameter_list|,
name|boolean
name|checkall
parameter_list|)
block|{
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
name|checkall
condition|)
block|{
comment|//
comment|// check all blocks of the file.
comment|//
for|for
control|(
name|BlockInfo
name|block
range|:
name|v
operator|.
name|getBlocks
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|block
operator|.
name|isComplete
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"BLOCK* checkFileProgress: "
operator|+
name|block
operator|+
literal|" has not reached minimal replication "
operator|+
name|blockManager
operator|.
name|minReplication
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
block|}
else|else
block|{
comment|//
comment|// check the penultimate block of this file
comment|//
name|BlockInfo
name|b
init|=
name|v
operator|.
name|getPenultimateBlock
argument_list|()
decl_stmt|;
if|if
condition|(
name|b
operator|!=
literal|null
operator|&&
operator|!
name|b
operator|.
name|isComplete
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"BLOCK* checkFileProgress: "
operator|+
name|b
operator|+
literal|" has not reached minimal replication "
operator|+
name|blockManager
operator|.
name|minReplication
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|////////////////////////////////////////////////////////////////
comment|// Here's how to handle block-copy failure during client write:
comment|// -- As usual, the client's write should result in a streaming
comment|// backup write to a k-machine sequence.
comment|// -- If one of the backup machines fails, no worries.  Fail silently.
comment|// -- Before client is allowed to close and finalize file, make sure
comment|// that the blocks are backed up.  Namenode may have to issue specific backup
comment|// commands to make up for earlier datanode failures.  Once all copies
comment|// are made, edit namespace and return to client.
comment|////////////////////////////////////////////////////////////////
comment|/**     * Change the indicated filename.     * @deprecated Use {@link #renameTo(String, String, Options.Rename...)} instead.    */
annotation|@
name|Deprecated
DECL|method|renameTo (String src, String dst)
name|boolean
name|renameTo
parameter_list|(
name|String
name|src
parameter_list|,
name|String
name|dst
parameter_list|)
throws|throws
name|IOException
throws|,
name|UnresolvedLinkException
block|{
try|try
block|{
return|return
name|renameToInt
argument_list|(
name|src
argument_list|,
name|dst
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|AccessControlException
name|e
parameter_list|)
block|{
if|if
condition|(
name|isAuditEnabled
argument_list|()
operator|&&
name|isExternalInvocation
argument_list|()
condition|)
block|{
name|logAuditEvent
argument_list|(
literal|false
argument_list|,
name|UserGroupInformation
operator|.
name|getCurrentUser
argument_list|()
argument_list|,
name|getRemoteIp
argument_list|()
argument_list|,
literal|"rename"
argument_list|,
name|src
argument_list|,
name|dst
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
throw|throw
name|e
throw|;
block|}
block|}
DECL|method|renameToInt (String src, String dst)
specifier|private
name|boolean
name|renameToInt
parameter_list|(
name|String
name|src
parameter_list|,
name|String
name|dst
parameter_list|)
throws|throws
name|IOException
throws|,
name|UnresolvedLinkException
block|{
name|boolean
name|status
init|=
literal|false
decl_stmt|;
name|HdfsFileStatus
name|resultingStat
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|debug
argument_list|(
literal|"DIR* NameSystem.renameTo: "
operator|+
name|src
operator|+
literal|" to "
operator|+
name|dst
argument_list|)
expr_stmt|;
block|}
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|status
operator|=
name|renameToInternal
argument_list|(
name|src
argument_list|,
name|dst
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&&
name|isAuditEnabled
argument_list|()
operator|&&
name|isExternalInvocation
argument_list|()
condition|)
block|{
name|resultingStat
operator|=
name|dir
operator|.
name|getFileInfo
argument_list|(
name|dst
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
name|getEditLog
argument_list|()
operator|.
name|logSync
argument_list|()
expr_stmt|;
if|if
condition|(
name|status
operator|&&
name|isAuditEnabled
argument_list|()
operator|&&
name|isExternalInvocation
argument_list|()
condition|)
block|{
name|logAuditEvent
argument_list|(
name|UserGroupInformation
operator|.
name|getCurrentUser
argument_list|()
argument_list|,
name|getRemoteIp
argument_list|()
argument_list|,
literal|"rename"
argument_list|,
name|src
argument_list|,
name|dst
argument_list|,
name|resultingStat
argument_list|)
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
comment|/** @deprecated See {@link #renameTo(String, String)} */
annotation|@
name|Deprecated
DECL|method|renameToInternal (String src, String dst)
specifier|private
name|boolean
name|renameToInternal
parameter_list|(
name|String
name|src
parameter_list|,
name|String
name|dst
parameter_list|)
throws|throws
name|IOException
throws|,
name|UnresolvedLinkException
block|{
assert|assert
name|hasWriteLock
argument_list|()
assert|;
if|if
condition|(
name|isInSafeMode
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SafeModeException
argument_list|(
literal|"Cannot rename "
operator|+
name|src
argument_list|,
name|safeMode
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|DFSUtil
operator|.
name|isValidName
argument_list|(
name|dst
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Invalid name: "
operator|+
name|dst
argument_list|)
throw|;
block|}
if|if
condition|(
name|isPermissionEnabled
condition|)
block|{
comment|//We should not be doing this.  This is move() not renameTo().
comment|//but for now,
comment|//NOTE: yes, this is bad!  it's assuming much lower level behavior
comment|//      of rewriting the dst
name|String
name|actualdst
init|=
name|dir
operator|.
name|isDir
argument_list|(
name|dst
argument_list|)
condition|?
name|dst
operator|+
name|Path
operator|.
name|SEPARATOR
operator|+
operator|new
name|Path
argument_list|(
name|src
argument_list|)
operator|.
name|getName
argument_list|()
else|:
name|dst
decl_stmt|;
name|checkParentAccess
argument_list|(
name|src
argument_list|,
name|FsAction
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|checkAncestorAccess
argument_list|(
name|actualdst
argument_list|,
name|FsAction
operator|.
name|WRITE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dir
operator|.
name|renameTo
argument_list|(
name|src
argument_list|,
name|dst
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
comment|/** Rename src to dst */
DECL|method|renameTo (String src, String dst, Options.Rename... options)
name|void
name|renameTo
parameter_list|(
name|String
name|src
parameter_list|,
name|String
name|dst
parameter_list|,
name|Options
operator|.
name|Rename
modifier|...
name|options
parameter_list|)
throws|throws
name|IOException
throws|,
name|UnresolvedLinkException
block|{
name|HdfsFileStatus
name|resultingStat
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|debug
argument_list|(
literal|"DIR* NameSystem.renameTo: with options - "
operator|+
name|src
operator|+
literal|" to "
operator|+
name|dst
argument_list|)
expr_stmt|;
block|}
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|renameToInternal
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|options
argument_list|)
expr_stmt|;
if|if
condition|(
name|isAuditEnabled
argument_list|()
operator|&&
name|isExternalInvocation
argument_list|()
condition|)
block|{
name|resultingStat
operator|=
name|dir
operator|.
name|getFileInfo
argument_list|(
name|dst
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
name|getEditLog
argument_list|()
operator|.
name|logSync
argument_list|()
expr_stmt|;
if|if
condition|(
name|isAuditEnabled
argument_list|()
operator|&&
name|isExternalInvocation
argument_list|()
condition|)
block|{
name|StringBuilder
name|cmd
init|=
operator|new
name|StringBuilder
argument_list|(
literal|"rename options="
argument_list|)
decl_stmt|;
for|for
control|(
name|Rename
name|option
range|:
name|options
control|)
block|{
name|cmd
operator|.
name|append
argument_list|(
name|option
operator|.
name|value
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
block|}
name|logAuditEvent
argument_list|(
name|UserGroupInformation
operator|.
name|getCurrentUser
argument_list|()
argument_list|,
name|getRemoteIp
argument_list|()
argument_list|,
name|cmd
operator|.
name|toString
argument_list|()
argument_list|,
name|src
argument_list|,
name|dst
argument_list|,
name|resultingStat
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|renameToInternal (String src, String dst, Options.Rename... options)
specifier|private
name|void
name|renameToInternal
parameter_list|(
name|String
name|src
parameter_list|,
name|String
name|dst
parameter_list|,
name|Options
operator|.
name|Rename
modifier|...
name|options
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|hasWriteLock
argument_list|()
assert|;
if|if
condition|(
name|isInSafeMode
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SafeModeException
argument_list|(
literal|"Cannot rename "
operator|+
name|src
argument_list|,
name|safeMode
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|DFSUtil
operator|.
name|isValidName
argument_list|(
name|dst
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|InvalidPathException
argument_list|(
literal|"Invalid name: "
operator|+
name|dst
argument_list|)
throw|;
block|}
if|if
condition|(
name|isPermissionEnabled
condition|)
block|{
name|checkParentAccess
argument_list|(
name|src
argument_list|,
name|FsAction
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|checkAncestorAccess
argument_list|(
name|dst
argument_list|,
name|FsAction
operator|.
name|WRITE
argument_list|)
expr_stmt|;
block|}
name|dir
operator|.
name|renameTo
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|options
argument_list|)
expr_stmt|;
block|}
comment|/**    * Remove the indicated file from namespace.    *     * @see ClientProtocol#delete(String, boolean) for detailed descriptoin and     * description of exceptions    */
DECL|method|delete (String src, boolean recursive)
name|boolean
name|delete
parameter_list|(
name|String
name|src
parameter_list|,
name|boolean
name|recursive
parameter_list|)
throws|throws
name|AccessControlException
throws|,
name|SafeModeException
throws|,
name|UnresolvedLinkException
throws|,
name|IOException
block|{
try|try
block|{
return|return
name|deleteInt
argument_list|(
name|src
argument_list|,
name|recursive
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|AccessControlException
name|e
parameter_list|)
block|{
if|if
condition|(
name|isAuditEnabled
argument_list|()
operator|&&
name|isExternalInvocation
argument_list|()
condition|)
block|{
name|logAuditEvent
argument_list|(
literal|false
argument_list|,
name|UserGroupInformation
operator|.
name|getCurrentUser
argument_list|()
argument_list|,
name|getRemoteIp
argument_list|()
argument_list|,
literal|"delete"
argument_list|,
name|src
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
throw|throw
name|e
throw|;
block|}
block|}
DECL|method|deleteInt (String src, boolean recursive)
specifier|private
name|boolean
name|deleteInt
parameter_list|(
name|String
name|src
parameter_list|,
name|boolean
name|recursive
parameter_list|)
throws|throws
name|AccessControlException
throws|,
name|SafeModeException
throws|,
name|UnresolvedLinkException
throws|,
name|IOException
block|{
if|if
condition|(
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|debug
argument_list|(
literal|"DIR* NameSystem.delete: "
operator|+
name|src
argument_list|)
expr_stmt|;
block|}
name|boolean
name|status
init|=
name|deleteInternal
argument_list|(
name|src
argument_list|,
name|recursive
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|status
operator|&&
name|isAuditEnabled
argument_list|()
operator|&&
name|isExternalInvocation
argument_list|()
condition|)
block|{
name|logAuditEvent
argument_list|(
name|UserGroupInformation
operator|.
name|getCurrentUser
argument_list|()
argument_list|,
name|getRemoteIp
argument_list|()
argument_list|,
literal|"delete"
argument_list|,
name|src
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
comment|/**    * Remove a file/directory from the namespace.    *<p>    * For large directories, deletion is incremental. The blocks under    * the directory are collected and deleted a small number at a time holding    * the {@link FSNamesystem} lock.    *<p>    * For small directory or file the deletion is done in one shot.    *     * @see ClientProtocol#delete(String, boolean) for description of exceptions    */
DECL|method|deleteInternal (String src, boolean recursive, boolean enforcePermission)
specifier|private
name|boolean
name|deleteInternal
parameter_list|(
name|String
name|src
parameter_list|,
name|boolean
name|recursive
parameter_list|,
name|boolean
name|enforcePermission
parameter_list|)
throws|throws
name|AccessControlException
throws|,
name|SafeModeException
throws|,
name|UnresolvedLinkException
throws|,
name|IOException
block|{
name|BlocksMapUpdateInfo
name|collectedBlocks
init|=
operator|new
name|BlocksMapUpdateInfo
argument_list|()
decl_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|isInSafeMode
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SafeModeException
argument_list|(
literal|"Cannot delete "
operator|+
name|src
argument_list|,
name|safeMode
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|recursive
operator|&&
name|dir
operator|.
name|isNonEmptyDirectory
argument_list|(
name|src
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|src
operator|+
literal|" is non empty"
argument_list|)
throw|;
block|}
if|if
condition|(
name|enforcePermission
operator|&&
name|isPermissionEnabled
condition|)
block|{
name|checkPermission
argument_list|(
name|src
argument_list|,
literal|false
argument_list|,
literal|null
argument_list|,
name|FsAction
operator|.
name|WRITE
argument_list|,
literal|null
argument_list|,
name|FsAction
operator|.
name|ALL
argument_list|)
expr_stmt|;
block|}
comment|// Unlink the target directory from directory tree
if|if
condition|(
operator|!
name|dir
operator|.
name|delete
argument_list|(
name|src
argument_list|,
name|collectedBlocks
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
name|getEditLog
argument_list|()
operator|.
name|logSync
argument_list|()
expr_stmt|;
name|removeBlocks
argument_list|(
name|collectedBlocks
argument_list|)
expr_stmt|;
comment|// Incremental deletion of blocks
name|collectedBlocks
operator|.
name|clear
argument_list|()
expr_stmt|;
if|if
condition|(
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|debug
argument_list|(
literal|"DIR* Namesystem.delete: "
operator|+
name|src
operator|+
literal|" is removed"
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
comment|/**    * From the given list, incrementally remove the blocks from blockManager    * Writelock is dropped and reacquired every BLOCK_DELETION_INCREMENT to    * ensure that other waiters on the lock can get in. See HDFS-2938    *     * @param blocks    *          An instance of {@link BlocksMapUpdateInfo} which contains a list    *          of blocks that need to be removed from blocksMap    */
DECL|method|removeBlocks (BlocksMapUpdateInfo blocks)
name|void
name|removeBlocks
parameter_list|(
name|BlocksMapUpdateInfo
name|blocks
parameter_list|)
block|{
name|Iterator
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|Block
argument_list|,
name|BlocksMapINodeUpdateEntry
argument_list|>
argument_list|>
name|iter
init|=
name|blocks
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|iter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
for|for
control|(
name|int
name|numberToHandle
init|=
name|BLOCK_DELETION_INCREMENT
init|;
name|iter
operator|.
name|hasNext
argument_list|()
operator|&&
name|numberToHandle
operator|>
literal|0
condition|;
name|numberToHandle
operator|--
control|)
block|{
name|Map
operator|.
name|Entry
argument_list|<
name|Block
argument_list|,
name|BlocksMapINodeUpdateEntry
argument_list|>
name|entry
init|=
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
name|updateBlocksMap
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Update the blocksMap for a given block.    *     * @param entry    *          The update entry containing both the block and its new INode. The    *          block should be removed from the blocksMap if the INode is null,    *          otherwise the INode for the block will be updated in the    *          blocksMap.    */
DECL|method|updateBlocksMap ( Map.Entry<Block, BlocksMapINodeUpdateEntry> entry)
specifier|private
name|void
name|updateBlocksMap
parameter_list|(
name|Map
operator|.
name|Entry
argument_list|<
name|Block
argument_list|,
name|BlocksMapINodeUpdateEntry
argument_list|>
name|entry
parameter_list|)
block|{
name|Block
name|block
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|BlocksMapINodeUpdateEntry
name|value
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
name|blockManager
operator|.
name|removeBlock
argument_list|(
name|block
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|BlockCollection
name|toDelete
init|=
name|value
operator|.
name|getToDelete
argument_list|()
decl_stmt|;
name|BlockInfo
name|originalBlockInfo
init|=
name|blockManager
operator|.
name|getStoredBlock
argument_list|(
name|block
argument_list|)
decl_stmt|;
comment|// The FSDirectory tree and the blocksMap share the same INode reference.
comment|// Thus we use "==" to check if the INode for the block belongs to the
comment|// current file (instead of the INode from a snapshot file).
if|if
condition|(
name|originalBlockInfo
operator|!=
literal|null
operator|&&
name|toDelete
operator|==
name|originalBlockInfo
operator|.
name|getBlockCollection
argument_list|()
condition|)
block|{
name|blockManager
operator|.
name|addBlockCollection
argument_list|(
name|originalBlockInfo
argument_list|,
name|value
operator|.
name|getToReplace
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Remove leases and blocks related to a given path    * @param src The given path    * @param blocks Containing the list of blocks to be deleted from blocksMap    */
DECL|method|removePathAndBlocks (String src, BlocksMapUpdateInfo blocks)
name|void
name|removePathAndBlocks
parameter_list|(
name|String
name|src
parameter_list|,
name|BlocksMapUpdateInfo
name|blocks
parameter_list|)
block|{
assert|assert
name|hasWriteLock
argument_list|()
assert|;
name|leaseManager
operator|.
name|removeLeaseWithPrefixPath
argument_list|(
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
name|blocks
operator|==
literal|null
condition|)
block|{
return|return;
block|}
comment|// In the case that we are a Standby tailing edits from the
comment|// active while in safe-mode, we need to track the total number
comment|// of blocks and safe blocks in the system.
name|boolean
name|trackBlockCounts
init|=
name|isSafeModeTrackingBlocks
argument_list|()
decl_stmt|;
name|int
name|numRemovedComplete
init|=
literal|0
decl_stmt|,
name|numRemovedSafe
init|=
literal|0
decl_stmt|;
name|Iterator
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|Block
argument_list|,
name|BlocksMapINodeUpdateEntry
argument_list|>
argument_list|>
name|blockIter
init|=
name|blocks
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|blockIter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Map
operator|.
name|Entry
argument_list|<
name|Block
argument_list|,
name|BlocksMapINodeUpdateEntry
argument_list|>
name|entry
init|=
name|blockIter
operator|.
name|next
argument_list|()
decl_stmt|;
name|Block
name|b
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
if|if
condition|(
name|trackBlockCounts
condition|)
block|{
name|BlockInfo
name|bi
init|=
name|blockManager
operator|.
name|getStoredBlock
argument_list|(
name|b
argument_list|)
decl_stmt|;
if|if
condition|(
name|bi
operator|.
name|isComplete
argument_list|()
condition|)
block|{
name|numRemovedComplete
operator|++
expr_stmt|;
if|if
condition|(
name|bi
operator|.
name|numNodes
argument_list|()
operator|>=
name|blockManager
operator|.
name|minReplication
condition|)
block|{
name|numRemovedSafe
operator|++
expr_stmt|;
block|}
block|}
block|}
name|updateBlocksMap
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|trackBlockCounts
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Adjusting safe-mode totals for deletion of "
operator|+
name|src
operator|+
literal|":"
operator|+
literal|"decreasing safeBlocks by "
operator|+
name|numRemovedSafe
operator|+
literal|", totalBlocks by "
operator|+
name|numRemovedComplete
argument_list|)
expr_stmt|;
block|}
name|adjustSafeModeBlockTotals
argument_list|(
operator|-
name|numRemovedSafe
argument_list|,
operator|-
name|numRemovedComplete
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * @see SafeModeInfo#shouldIncrementallyTrackBlocks    */
DECL|method|isSafeModeTrackingBlocks ()
specifier|private
name|boolean
name|isSafeModeTrackingBlocks
parameter_list|()
block|{
if|if
condition|(
operator|!
name|haEnabled
condition|)
block|{
comment|// Never track blocks incrementally in non-HA code.
return|return
literal|false
return|;
block|}
name|SafeModeInfo
name|sm
init|=
name|this
operator|.
name|safeMode
decl_stmt|;
return|return
name|sm
operator|!=
literal|null
operator|&&
name|sm
operator|.
name|shouldIncrementallyTrackBlocks
argument_list|()
return|;
block|}
comment|/**    * Get the file info for a specific file.    *    * @param src The string representation of the path to the file    * @param resolveLink whether to throw UnresolvedLinkException     *        if src refers to a symlink    *    * @throws AccessControlException if access is denied    * @throws UnresolvedLinkException if a symlink is encountered.    *    * @return object containing information regarding the file    *         or null if file not found    * @throws StandbyException     */
DECL|method|getFileInfo (String src, boolean resolveLink)
name|HdfsFileStatus
name|getFileInfo
parameter_list|(
name|String
name|src
parameter_list|,
name|boolean
name|resolveLink
parameter_list|)
throws|throws
name|AccessControlException
throws|,
name|UnresolvedLinkException
throws|,
name|StandbyException
throws|,
name|IOException
block|{
name|HdfsFileStatus
name|stat
init|=
literal|null
decl_stmt|;
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|READ
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|DFSUtil
operator|.
name|isValidName
argument_list|(
name|src
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|InvalidPathException
argument_list|(
literal|"Invalid file name: "
operator|+
name|src
argument_list|)
throw|;
block|}
if|if
condition|(
name|isPermissionEnabled
condition|)
block|{
name|checkTraverse
argument_list|(
name|src
argument_list|)
expr_stmt|;
block|}
name|stat
operator|=
name|dir
operator|.
name|getFileInfo
argument_list|(
name|src
argument_list|,
name|resolveLink
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|AccessControlException
name|e
parameter_list|)
block|{
if|if
condition|(
name|isAuditEnabled
argument_list|()
operator|&&
name|isExternalInvocation
argument_list|()
condition|)
block|{
name|logAuditEvent
argument_list|(
literal|false
argument_list|,
name|UserGroupInformation
operator|.
name|getCurrentUser
argument_list|()
argument_list|,
name|getRemoteIp
argument_list|()
argument_list|,
literal|"getfileinfo"
argument_list|,
name|src
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
throw|throw
name|e
throw|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|isAuditEnabled
argument_list|()
operator|&&
name|isExternalInvocation
argument_list|()
condition|)
block|{
name|logAuditEvent
argument_list|(
name|UserGroupInformation
operator|.
name|getCurrentUser
argument_list|()
argument_list|,
name|getRemoteIp
argument_list|()
argument_list|,
literal|"getfileinfo"
argument_list|,
name|src
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
return|return
name|stat
return|;
block|}
comment|/**    * Create all the necessary directories    */
DECL|method|mkdirs (String src, PermissionStatus permissions, boolean createParent)
name|boolean
name|mkdirs
parameter_list|(
name|String
name|src
parameter_list|,
name|PermissionStatus
name|permissions
parameter_list|,
name|boolean
name|createParent
parameter_list|)
throws|throws
name|IOException
throws|,
name|UnresolvedLinkException
block|{
try|try
block|{
return|return
name|mkdirsInt
argument_list|(
name|src
argument_list|,
name|permissions
argument_list|,
name|createParent
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|AccessControlException
name|e
parameter_list|)
block|{
if|if
condition|(
name|isAuditEnabled
argument_list|()
operator|&&
name|isExternalInvocation
argument_list|()
condition|)
block|{
name|logAuditEvent
argument_list|(
literal|false
argument_list|,
name|UserGroupInformation
operator|.
name|getCurrentUser
argument_list|()
argument_list|,
name|getRemoteIp
argument_list|()
argument_list|,
literal|"mkdirs"
argument_list|,
name|src
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
throw|throw
name|e
throw|;
block|}
block|}
DECL|method|mkdirsInt (String src, PermissionStatus permissions, boolean createParent)
specifier|private
name|boolean
name|mkdirsInt
parameter_list|(
name|String
name|src
parameter_list|,
name|PermissionStatus
name|permissions
parameter_list|,
name|boolean
name|createParent
parameter_list|)
throws|throws
name|IOException
throws|,
name|UnresolvedLinkException
block|{
name|boolean
name|status
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|debug
argument_list|(
literal|"DIR* NameSystem.mkdirs: "
operator|+
name|src
argument_list|)
expr_stmt|;
block|}
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|status
operator|=
name|mkdirsInternal
argument_list|(
name|src
argument_list|,
name|permissions
argument_list|,
name|createParent
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
name|getEditLog
argument_list|()
operator|.
name|logSync
argument_list|()
expr_stmt|;
if|if
condition|(
name|status
operator|&&
name|isAuditEnabled
argument_list|()
operator|&&
name|isExternalInvocation
argument_list|()
condition|)
block|{
specifier|final
name|HdfsFileStatus
name|stat
init|=
name|dir
operator|.
name|getFileInfo
argument_list|(
name|src
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|logAuditEvent
argument_list|(
name|UserGroupInformation
operator|.
name|getCurrentUser
argument_list|()
argument_list|,
name|getRemoteIp
argument_list|()
argument_list|,
literal|"mkdirs"
argument_list|,
name|src
argument_list|,
literal|null
argument_list|,
name|stat
argument_list|)
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
comment|/**    * Create all the necessary directories    */
DECL|method|mkdirsInternal (String src, PermissionStatus permissions, boolean createParent)
specifier|private
name|boolean
name|mkdirsInternal
parameter_list|(
name|String
name|src
parameter_list|,
name|PermissionStatus
name|permissions
parameter_list|,
name|boolean
name|createParent
parameter_list|)
throws|throws
name|IOException
throws|,
name|UnresolvedLinkException
block|{
assert|assert
name|hasWriteLock
argument_list|()
assert|;
if|if
condition|(
name|isInSafeMode
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SafeModeException
argument_list|(
literal|"Cannot create directory "
operator|+
name|src
argument_list|,
name|safeMode
argument_list|)
throw|;
block|}
if|if
condition|(
name|isPermissionEnabled
condition|)
block|{
name|checkTraverse
argument_list|(
name|src
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dir
operator|.
name|isDirMutable
argument_list|(
name|src
argument_list|)
condition|)
block|{
comment|// all the users of mkdirs() are used to expect 'true' even if
comment|// a new directory is not created.
return|return
literal|true
return|;
block|}
if|if
condition|(
operator|!
name|DFSUtil
operator|.
name|isValidName
argument_list|(
name|src
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|InvalidPathException
argument_list|(
name|src
argument_list|)
throw|;
block|}
if|if
condition|(
name|isPermissionEnabled
condition|)
block|{
name|checkAncestorAccess
argument_list|(
name|src
argument_list|,
name|FsAction
operator|.
name|WRITE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|createParent
condition|)
block|{
name|verifyParentDir
argument_list|(
name|src
argument_list|)
expr_stmt|;
block|}
comment|// validate that we have enough inodes. This is, at best, a
comment|// heuristic because the mkdirs() operation migth need to
comment|// create multiple inodes.
name|checkFsObjectLimit
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|dir
operator|.
name|mkdirs
argument_list|(
name|src
argument_list|,
name|permissions
argument_list|,
literal|false
argument_list|,
name|now
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Failed to create directory: "
operator|+
name|src
argument_list|)
throw|;
block|}
return|return
literal|true
return|;
block|}
DECL|method|getContentSummary (String src)
name|ContentSummary
name|getContentSummary
parameter_list|(
name|String
name|src
parameter_list|)
throws|throws
name|AccessControlException
throws|,
name|FileNotFoundException
throws|,
name|UnresolvedLinkException
throws|,
name|StandbyException
block|{
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|READ
argument_list|)
expr_stmt|;
if|if
condition|(
name|isPermissionEnabled
condition|)
block|{
name|checkPermission
argument_list|(
name|src
argument_list|,
literal|false
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|FsAction
operator|.
name|READ_EXECUTE
argument_list|)
expr_stmt|;
block|}
return|return
name|dir
operator|.
name|getContentSummary
argument_list|(
name|src
argument_list|)
return|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Set the namespace quota and diskspace quota for a directory.    * See {@link ClientProtocol#setQuota(String, long, long)} for the     * contract.    */
DECL|method|setQuota (String path, long nsQuota, long dsQuota)
name|void
name|setQuota
parameter_list|(
name|String
name|path
parameter_list|,
name|long
name|nsQuota
parameter_list|,
name|long
name|dsQuota
parameter_list|)
throws|throws
name|IOException
throws|,
name|UnresolvedLinkException
block|{
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|isInSafeMode
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SafeModeException
argument_list|(
literal|"Cannot set quota on "
operator|+
name|path
argument_list|,
name|safeMode
argument_list|)
throw|;
block|}
if|if
condition|(
name|isPermissionEnabled
condition|)
block|{
name|checkSuperuserPrivilege
argument_list|()
expr_stmt|;
block|}
name|dir
operator|.
name|setQuota
argument_list|(
name|path
argument_list|,
name|nsQuota
argument_list|,
name|dsQuota
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
name|getEditLog
argument_list|()
operator|.
name|logSync
argument_list|()
expr_stmt|;
block|}
comment|/** Persist all metadata about this file.    * @param src The string representation of the path    * @param clientName The string representation of the client    * @param lastBlockLength The length of the last block     *                        under construction reported from client.    * @throws IOException if path does not exist    */
DECL|method|fsync (String src, String clientName, long lastBlockLength)
name|void
name|fsync
parameter_list|(
name|String
name|src
parameter_list|,
name|String
name|clientName
parameter_list|,
name|long
name|lastBlockLength
parameter_list|)
throws|throws
name|IOException
throws|,
name|UnresolvedLinkException
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|info
argument_list|(
literal|"BLOCK* fsync: "
operator|+
name|src
operator|+
literal|" for "
operator|+
name|clientName
argument_list|)
expr_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|isInSafeMode
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SafeModeException
argument_list|(
literal|"Cannot fsync file "
operator|+
name|src
argument_list|,
name|safeMode
argument_list|)
throw|;
block|}
name|INodeFileUnderConstruction
name|pendingFile
init|=
name|checkLease
argument_list|(
name|src
argument_list|,
name|clientName
argument_list|)
decl_stmt|;
if|if
condition|(
name|lastBlockLength
operator|>
literal|0
condition|)
block|{
name|pendingFile
operator|.
name|updateLengthOfLastBlock
argument_list|(
name|lastBlockLength
argument_list|)
expr_stmt|;
block|}
name|dir
operator|.
name|persistBlocks
argument_list|(
name|src
argument_list|,
name|pendingFile
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
name|getEditLog
argument_list|()
operator|.
name|logSync
argument_list|()
expr_stmt|;
block|}
comment|/**    * Move a file that is being written to be immutable.    * @param src The filename    * @param lease The lease for the client creating the file    * @param recoveryLeaseHolder reassign lease to this holder if the last block    *        needs recovery; keep current holder if null.    * @throws AlreadyBeingCreatedException if file is waiting to achieve minimal    *         replication;<br>    *         RecoveryInProgressException if lease recovery is in progress.<br>    *         IOException in case of an error.    * @return true  if file has been successfully finalized and closed or     *         false if block recovery has been initiated. Since the lease owner    *         has been changed and logged, caller should call logSync().    */
DECL|method|internalReleaseLease (Lease lease, String src, String recoveryLeaseHolder)
name|boolean
name|internalReleaseLease
parameter_list|(
name|Lease
name|lease
parameter_list|,
name|String
name|src
parameter_list|,
name|String
name|recoveryLeaseHolder
parameter_list|)
throws|throws
name|AlreadyBeingCreatedException
throws|,
name|IOException
throws|,
name|UnresolvedLinkException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Recovering "
operator|+
name|lease
operator|+
literal|", src="
operator|+
name|src
argument_list|)
expr_stmt|;
assert|assert
operator|!
name|isInSafeMode
argument_list|()
assert|;
assert|assert
name|hasWriteLock
argument_list|()
assert|;
specifier|final
name|INodesInPath
name|iip
init|=
name|dir
operator|.
name|getINodesInPath
argument_list|(
name|src
argument_list|)
decl_stmt|;
specifier|final
name|INodeFileUnderConstruction
name|pendingFile
init|=
name|INodeFileUnderConstruction
operator|.
name|valueOf
argument_list|(
name|iip
operator|.
name|getINode
argument_list|(
literal|0
argument_list|)
argument_list|,
name|src
argument_list|)
decl_stmt|;
name|int
name|nrBlocks
init|=
name|pendingFile
operator|.
name|numBlocks
argument_list|()
decl_stmt|;
name|BlockInfo
index|[]
name|blocks
init|=
name|pendingFile
operator|.
name|getBlocks
argument_list|()
decl_stmt|;
name|int
name|nrCompleteBlocks
decl_stmt|;
name|BlockInfo
name|curBlock
init|=
literal|null
decl_stmt|;
for|for
control|(
name|nrCompleteBlocks
operator|=
literal|0
init|;
name|nrCompleteBlocks
operator|<
name|nrBlocks
condition|;
name|nrCompleteBlocks
operator|++
control|)
block|{
name|curBlock
operator|=
name|blocks
index|[
name|nrCompleteBlocks
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|curBlock
operator|.
name|isComplete
argument_list|()
condition|)
break|break;
assert|assert
name|blockManager
operator|.
name|checkMinReplication
argument_list|(
name|curBlock
argument_list|)
operator|:
literal|"A COMPLETE block is not minimally replicated in "
operator|+
name|src
assert|;
block|}
comment|// If there are no incomplete blocks associated with this file,
comment|// then reap lease immediately and close the file.
if|if
condition|(
name|nrCompleteBlocks
operator|==
name|nrBlocks
condition|)
block|{
name|finalizeINodeFileUnderConstruction
argument_list|(
name|src
argument_list|,
name|pendingFile
argument_list|,
name|iip
operator|.
name|getLatestSnapshot
argument_list|()
argument_list|)
expr_stmt|;
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|warn
argument_list|(
literal|"BLOCK*"
operator|+
literal|" internalReleaseLease: All existing blocks are COMPLETE,"
operator|+
literal|" lease removed, file closed."
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
comment|// closed!
block|}
comment|// Only the last and the penultimate blocks may be in non COMPLETE state.
comment|// If the penultimate block is not COMPLETE, then it must be COMMITTED.
if|if
condition|(
name|nrCompleteBlocks
operator|<
name|nrBlocks
operator|-
literal|2
operator|||
name|nrCompleteBlocks
operator|==
name|nrBlocks
operator|-
literal|2
operator|&&
name|curBlock
operator|!=
literal|null
operator|&&
name|curBlock
operator|.
name|getBlockUCState
argument_list|()
operator|!=
name|BlockUCState
operator|.
name|COMMITTED
condition|)
block|{
specifier|final
name|String
name|message
init|=
literal|"DIR* NameSystem.internalReleaseLease: "
operator|+
literal|"attempt to release a create lock on "
operator|+
name|src
operator|+
literal|" but file is already closed."
decl_stmt|;
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|warn
argument_list|(
name|message
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
name|message
argument_list|)
throw|;
block|}
comment|// The last block is not COMPLETE, and
comment|// that the penultimate block if exists is either COMPLETE or COMMITTED
specifier|final
name|BlockInfo
name|lastBlock
init|=
name|pendingFile
operator|.
name|getLastBlock
argument_list|()
decl_stmt|;
name|BlockUCState
name|lastBlockState
init|=
name|lastBlock
operator|.
name|getBlockUCState
argument_list|()
decl_stmt|;
name|BlockInfo
name|penultimateBlock
init|=
name|pendingFile
operator|.
name|getPenultimateBlock
argument_list|()
decl_stmt|;
name|boolean
name|penultimateBlockMinReplication
decl_stmt|;
name|BlockUCState
name|penultimateBlockState
decl_stmt|;
if|if
condition|(
name|penultimateBlock
operator|==
literal|null
condition|)
block|{
name|penultimateBlockState
operator|=
name|BlockUCState
operator|.
name|COMPLETE
expr_stmt|;
comment|// If penultimate block doesn't exist then its minReplication is met
name|penultimateBlockMinReplication
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|penultimateBlockState
operator|=
name|BlockUCState
operator|.
name|COMMITTED
expr_stmt|;
name|penultimateBlockMinReplication
operator|=
name|blockManager
operator|.
name|checkMinReplication
argument_list|(
name|penultimateBlock
argument_list|)
expr_stmt|;
block|}
assert|assert
name|penultimateBlockState
operator|==
name|BlockUCState
operator|.
name|COMPLETE
operator|||
name|penultimateBlockState
operator|==
name|BlockUCState
operator|.
name|COMMITTED
operator|:
literal|"Unexpected state of penultimate block in "
operator|+
name|src
assert|;
switch|switch
condition|(
name|lastBlockState
condition|)
block|{
case|case
name|COMPLETE
case|:
assert|assert
literal|false
operator|:
literal|"Already checked that the last block is incomplete"
assert|;
break|break;
case|case
name|COMMITTED
case|:
comment|// Close file if committed blocks are minimally replicated
if|if
condition|(
name|penultimateBlockMinReplication
operator|&&
name|blockManager
operator|.
name|checkMinReplication
argument_list|(
name|lastBlock
argument_list|)
condition|)
block|{
name|finalizeINodeFileUnderConstruction
argument_list|(
name|src
argument_list|,
name|pendingFile
argument_list|,
name|iip
operator|.
name|getLatestSnapshot
argument_list|()
argument_list|)
expr_stmt|;
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|warn
argument_list|(
literal|"BLOCK*"
operator|+
literal|" internalReleaseLease: Committed blocks are minimally replicated,"
operator|+
literal|" lease removed, file closed."
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
comment|// closed!
block|}
comment|// Cannot close file right now, since some blocks
comment|// are not yet minimally replicated.
comment|// This may potentially cause infinite loop in lease recovery
comment|// if there are no valid replicas on data-nodes.
name|String
name|message
init|=
literal|"DIR* NameSystem.internalReleaseLease: "
operator|+
literal|"Failed to release lease for file "
operator|+
name|src
operator|+
literal|". Committed blocks are waiting to be minimally replicated."
operator|+
literal|" Try again later."
decl_stmt|;
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|warn
argument_list|(
name|message
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|AlreadyBeingCreatedException
argument_list|(
name|message
argument_list|)
throw|;
case|case
name|UNDER_CONSTRUCTION
case|:
case|case
name|UNDER_RECOVERY
case|:
specifier|final
name|BlockInfoUnderConstruction
name|uc
init|=
operator|(
name|BlockInfoUnderConstruction
operator|)
name|lastBlock
decl_stmt|;
comment|// setup the last block locations from the blockManager if not known
if|if
condition|(
name|uc
operator|.
name|getNumExpectedLocations
argument_list|()
operator|==
literal|0
condition|)
block|{
name|uc
operator|.
name|setExpectedLocations
argument_list|(
name|blockManager
operator|.
name|getNodes
argument_list|(
name|lastBlock
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// start recovery of the last block for this file
name|long
name|blockRecoveryId
init|=
name|nextGenerationStamp
argument_list|()
decl_stmt|;
name|lease
operator|=
name|reassignLease
argument_list|(
name|lease
argument_list|,
name|src
argument_list|,
name|recoveryLeaseHolder
argument_list|,
name|pendingFile
argument_list|)
expr_stmt|;
name|uc
operator|.
name|initializeBlockRecovery
argument_list|(
name|blockRecoveryId
argument_list|)
expr_stmt|;
name|leaseManager
operator|.
name|renewLease
argument_list|(
name|lease
argument_list|)
expr_stmt|;
comment|// Cannot close file right now, since the last block requires recovery.
comment|// This may potentially cause infinite loop in lease recovery
comment|// if there are no valid replicas on data-nodes.
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|warn
argument_list|(
literal|"DIR* NameSystem.internalReleaseLease: "
operator|+
literal|"File "
operator|+
name|src
operator|+
literal|" has not been closed."
operator|+
literal|" Lease recovery is in progress. "
operator|+
literal|"RecoveryId = "
operator|+
name|blockRecoveryId
operator|+
literal|" for block "
operator|+
name|lastBlock
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
literal|false
return|;
block|}
DECL|method|reassignLease (Lease lease, String src, String newHolder, INodeFileUnderConstruction pendingFile)
specifier|private
name|Lease
name|reassignLease
parameter_list|(
name|Lease
name|lease
parameter_list|,
name|String
name|src
parameter_list|,
name|String
name|newHolder
parameter_list|,
name|INodeFileUnderConstruction
name|pendingFile
parameter_list|)
block|{
assert|assert
name|hasWriteLock
argument_list|()
assert|;
if|if
condition|(
name|newHolder
operator|==
literal|null
condition|)
return|return
name|lease
return|;
comment|// The following transaction is not synced. Make sure it's sync'ed later.
name|logReassignLease
argument_list|(
name|lease
operator|.
name|getHolder
argument_list|()
argument_list|,
name|src
argument_list|,
name|newHolder
argument_list|)
expr_stmt|;
return|return
name|reassignLeaseInternal
argument_list|(
name|lease
argument_list|,
name|src
argument_list|,
name|newHolder
argument_list|,
name|pendingFile
argument_list|)
return|;
block|}
DECL|method|reassignLeaseInternal (Lease lease, String src, String newHolder, INodeFileUnderConstruction pendingFile)
name|Lease
name|reassignLeaseInternal
parameter_list|(
name|Lease
name|lease
parameter_list|,
name|String
name|src
parameter_list|,
name|String
name|newHolder
parameter_list|,
name|INodeFileUnderConstruction
name|pendingFile
parameter_list|)
block|{
assert|assert
name|hasWriteLock
argument_list|()
assert|;
name|pendingFile
operator|.
name|setClientName
argument_list|(
name|newHolder
argument_list|)
expr_stmt|;
return|return
name|leaseManager
operator|.
name|reassignLease
argument_list|(
name|lease
argument_list|,
name|src
argument_list|,
name|newHolder
argument_list|)
return|;
block|}
DECL|method|commitOrCompleteLastBlock (final INodeFileUnderConstruction fileINode, final Block commitBlock)
specifier|private
name|void
name|commitOrCompleteLastBlock
parameter_list|(
specifier|final
name|INodeFileUnderConstruction
name|fileINode
parameter_list|,
specifier|final
name|Block
name|commitBlock
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|hasWriteLock
argument_list|()
assert|;
if|if
condition|(
operator|!
name|blockManager
operator|.
name|commitOrCompleteLastBlock
argument_list|(
name|fileINode
argument_list|,
name|commitBlock
argument_list|)
condition|)
block|{
return|return;
block|}
comment|// Adjust disk space consumption if required
specifier|final
name|long
name|diff
init|=
name|fileINode
operator|.
name|getPreferredBlockSize
argument_list|()
operator|-
name|commitBlock
operator|.
name|getNumBytes
argument_list|()
decl_stmt|;
if|if
condition|(
name|diff
operator|>
literal|0
condition|)
block|{
try|try
block|{
name|String
name|path
init|=
name|leaseManager
operator|.
name|findPath
argument_list|(
name|fileINode
argument_list|)
decl_stmt|;
name|dir
operator|.
name|updateSpaceConsumed
argument_list|(
name|path
argument_list|,
literal|0
argument_list|,
operator|-
name|diff
operator|*
name|fileINode
operator|.
name|getFileReplication
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Unexpected exception while updating disk space."
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|finalizeINodeFileUnderConstruction (String src, INodeFileUnderConstruction pendingFile, Snapshot latestSnapshot)
specifier|private
name|void
name|finalizeINodeFileUnderConstruction
parameter_list|(
name|String
name|src
parameter_list|,
name|INodeFileUnderConstruction
name|pendingFile
parameter_list|,
name|Snapshot
name|latestSnapshot
parameter_list|)
throws|throws
name|IOException
throws|,
name|UnresolvedLinkException
block|{
assert|assert
name|hasWriteLock
argument_list|()
assert|;
name|leaseManager
operator|.
name|removeLease
argument_list|(
name|pendingFile
operator|.
name|getClientName
argument_list|()
argument_list|,
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
name|latestSnapshot
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|pendingFile
operator|.
name|getClass
argument_list|()
operator|==
name|INodeFileUnderConstruction
operator|.
name|class
condition|)
block|{
comment|// Replace it with INodeFileUnderConstructionWithSnapshot.
comment|// This replacement does not need to be recorded in snapshot.
name|INodeFileUnderConstructionWithSnapshot
name|pendingFileWithSnaphsot
init|=
operator|new
name|INodeFileUnderConstructionWithSnapshot
argument_list|(
name|pendingFile
argument_list|)
decl_stmt|;
name|dir
operator|.
name|replaceINodeFile
argument_list|(
name|src
argument_list|,
name|pendingFile
argument_list|,
name|pendingFileWithSnaphsot
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|pendingFile
operator|=
name|pendingFileWithSnaphsot
expr_stmt|;
block|}
name|pendingFile
operator|=
operator|(
name|INodeFileUnderConstruction
operator|)
name|pendingFile
operator|.
name|recordModification
argument_list|(
name|latestSnapshot
argument_list|)
expr_stmt|;
block|}
comment|// The file is no longer pending.
comment|// Create permanent INode, update blocks
specifier|final
name|INodeFile
name|newFile
init|=
name|pendingFile
operator|.
name|toINodeFile
argument_list|(
name|now
argument_list|()
argument_list|)
decl_stmt|;
name|dir
operator|.
name|replaceINodeFile
argument_list|(
name|src
argument_list|,
name|pendingFile
argument_list|,
name|newFile
argument_list|,
name|latestSnapshot
argument_list|)
expr_stmt|;
comment|// close file and persist block allocations for this file
name|dir
operator|.
name|closeFile
argument_list|(
name|src
argument_list|,
name|newFile
argument_list|)
expr_stmt|;
name|blockManager
operator|.
name|checkReplication
argument_list|(
name|newFile
argument_list|)
expr_stmt|;
block|}
DECL|method|commitBlockSynchronization (ExtendedBlock lastblock, long newgenerationstamp, long newlength, boolean closeFile, boolean deleteblock, DatanodeID[] newtargets, String[] newtargetstorages)
name|void
name|commitBlockSynchronization
parameter_list|(
name|ExtendedBlock
name|lastblock
parameter_list|,
name|long
name|newgenerationstamp
parameter_list|,
name|long
name|newlength
parameter_list|,
name|boolean
name|closeFile
parameter_list|,
name|boolean
name|deleteblock
parameter_list|,
name|DatanodeID
index|[]
name|newtargets
parameter_list|,
name|String
index|[]
name|newtargetstorages
parameter_list|)
throws|throws
name|IOException
throws|,
name|UnresolvedLinkException
block|{
name|String
name|src
init|=
literal|""
decl_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
comment|// If a DN tries to commit to the standby, the recovery will
comment|// fail, and the next retry will succeed on the new NN.
if|if
condition|(
name|isInSafeMode
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SafeModeException
argument_list|(
literal|"Cannot commitBlockSynchronization while in safe mode"
argument_list|,
name|safeMode
argument_list|)
throw|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"commitBlockSynchronization(lastblock="
operator|+
name|lastblock
operator|+
literal|", newgenerationstamp="
operator|+
name|newgenerationstamp
operator|+
literal|", newlength="
operator|+
name|newlength
operator|+
literal|", newtargets="
operator|+
name|Arrays
operator|.
name|asList
argument_list|(
name|newtargets
argument_list|)
operator|+
literal|", closeFile="
operator|+
name|closeFile
operator|+
literal|", deleteBlock="
operator|+
name|deleteblock
operator|+
literal|")"
argument_list|)
expr_stmt|;
specifier|final
name|BlockInfo
name|storedBlock
init|=
name|blockManager
operator|.
name|getStoredBlock
argument_list|(
name|ExtendedBlock
operator|.
name|getLocalBlock
argument_list|(
name|lastblock
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|storedBlock
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Block (="
operator|+
name|lastblock
operator|+
literal|") not found"
argument_list|)
throw|;
block|}
name|INodeFile
name|iFile
init|=
operator|(
name|INodeFile
operator|)
name|storedBlock
operator|.
name|getBlockCollection
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|iFile
operator|.
name|isUnderConstruction
argument_list|()
operator|||
name|storedBlock
operator|.
name|isComplete
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unexpected block (="
operator|+
name|lastblock
operator|+
literal|") since the file (="
operator|+
name|iFile
operator|.
name|getLocalName
argument_list|()
operator|+
literal|") is not under construction"
argument_list|)
throw|;
block|}
name|long
name|recoveryId
init|=
operator|(
operator|(
name|BlockInfoUnderConstruction
operator|)
name|storedBlock
operator|)
operator|.
name|getBlockRecoveryId
argument_list|()
decl_stmt|;
if|if
condition|(
name|recoveryId
operator|!=
name|newgenerationstamp
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"The recovery id "
operator|+
name|newgenerationstamp
operator|+
literal|" does not match current recovery id "
operator|+
name|recoveryId
operator|+
literal|" for block "
operator|+
name|lastblock
argument_list|)
throw|;
block|}
name|INodeFileUnderConstruction
name|pendingFile
init|=
operator|(
name|INodeFileUnderConstruction
operator|)
name|iFile
decl_stmt|;
if|if
condition|(
name|deleteblock
condition|)
block|{
name|pendingFile
operator|.
name|removeLastBlock
argument_list|(
name|ExtendedBlock
operator|.
name|getLocalBlock
argument_list|(
name|lastblock
argument_list|)
argument_list|)
expr_stmt|;
name|blockManager
operator|.
name|removeBlockFromMap
argument_list|(
name|storedBlock
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// update last block
name|storedBlock
operator|.
name|setGenerationStamp
argument_list|(
name|newgenerationstamp
argument_list|)
expr_stmt|;
name|storedBlock
operator|.
name|setNumBytes
argument_list|(
name|newlength
argument_list|)
expr_stmt|;
comment|// find the DatanodeDescriptor objects
comment|// There should be no locations in the blockManager till now because the
comment|// file is underConstruction
name|DatanodeDescriptor
index|[]
name|descriptors
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|newtargets
operator|.
name|length
operator|>
literal|0
condition|)
block|{
name|descriptors
operator|=
operator|new
name|DatanodeDescriptor
index|[
name|newtargets
operator|.
name|length
index|]
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|newtargets
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|descriptors
index|[
name|i
index|]
operator|=
name|blockManager
operator|.
name|getDatanodeManager
argument_list|()
operator|.
name|getDatanode
argument_list|(
name|newtargets
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|closeFile
operator|)
operator|&&
operator|(
name|descriptors
operator|!=
literal|null
operator|)
condition|)
block|{
comment|// the file is getting closed. Insert block locations into blockManager.
comment|// Otherwise fsck will report these blocks as MISSING, especially if the
comment|// blocksReceived from Datanodes take a long time to arrive.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|descriptors
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|descriptors
index|[
name|i
index|]
operator|.
name|addBlock
argument_list|(
name|storedBlock
argument_list|)
expr_stmt|;
block|}
block|}
comment|// add pipeline locations into the INodeUnderConstruction
name|pendingFile
operator|.
name|setLastBlock
argument_list|(
name|storedBlock
argument_list|,
name|descriptors
argument_list|)
expr_stmt|;
block|}
name|src
operator|=
name|leaseManager
operator|.
name|findPath
argument_list|(
name|pendingFile
argument_list|)
expr_stmt|;
if|if
condition|(
name|closeFile
condition|)
block|{
comment|// commit the last block and complete it if it has minimum replicas
name|commitOrCompleteLastBlock
argument_list|(
name|pendingFile
argument_list|,
name|storedBlock
argument_list|)
expr_stmt|;
comment|//remove lease, close file
name|finalizeINodeFileUnderConstruction
argument_list|(
name|src
argument_list|,
name|pendingFile
argument_list|,
name|Snapshot
operator|.
name|findLatestSnapshot
argument_list|(
name|pendingFile
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// If this commit does not want to close the file, persist blocks
name|dir
operator|.
name|persistBlocks
argument_list|(
name|src
argument_list|,
name|pendingFile
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
name|getEditLog
argument_list|()
operator|.
name|logSync
argument_list|()
expr_stmt|;
if|if
condition|(
name|closeFile
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"commitBlockSynchronization(newblock="
operator|+
name|lastblock
operator|+
literal|", file="
operator|+
name|src
operator|+
literal|", newgenerationstamp="
operator|+
name|newgenerationstamp
operator|+
literal|", newlength="
operator|+
name|newlength
operator|+
literal|", newtargets="
operator|+
name|Arrays
operator|.
name|asList
argument_list|(
name|newtargets
argument_list|)
operator|+
literal|") successful"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"commitBlockSynchronization("
operator|+
name|lastblock
operator|+
literal|") successful"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Renew the lease(s) held by the given client    */
DECL|method|renewLease (String holder)
name|void
name|renewLease
parameter_list|(
name|String
name|holder
parameter_list|)
throws|throws
name|IOException
block|{
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|isInSafeMode
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SafeModeException
argument_list|(
literal|"Cannot renew lease for "
operator|+
name|holder
argument_list|,
name|safeMode
argument_list|)
throw|;
block|}
name|leaseManager
operator|.
name|renewLease
argument_list|(
name|holder
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Get a partial listing of the indicated directory    *    * @param src the directory name    * @param startAfter the name to start after    * @param needLocation if blockLocations need to be returned    * @return a partial listing starting after startAfter    *     * @throws AccessControlException if access is denied    * @throws UnresolvedLinkException if symbolic link is encountered    * @throws IOException if other I/O error occurred    */
DECL|method|getListing (String src, byte[] startAfter, boolean needLocation)
name|DirectoryListing
name|getListing
parameter_list|(
name|String
name|src
parameter_list|,
name|byte
index|[]
name|startAfter
parameter_list|,
name|boolean
name|needLocation
parameter_list|)
throws|throws
name|AccessControlException
throws|,
name|UnresolvedLinkException
throws|,
name|IOException
block|{
try|try
block|{
return|return
name|getListingInt
argument_list|(
name|src
argument_list|,
name|startAfter
argument_list|,
name|needLocation
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|AccessControlException
name|e
parameter_list|)
block|{
if|if
condition|(
name|isAuditEnabled
argument_list|()
operator|&&
name|isExternalInvocation
argument_list|()
condition|)
block|{
name|logAuditEvent
argument_list|(
literal|false
argument_list|,
name|UserGroupInformation
operator|.
name|getCurrentUser
argument_list|()
argument_list|,
name|getRemoteIp
argument_list|()
argument_list|,
literal|"listStatus"
argument_list|,
name|src
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
throw|throw
name|e
throw|;
block|}
block|}
DECL|method|getListingInt (String src, byte[] startAfter, boolean needLocation)
specifier|private
name|DirectoryListing
name|getListingInt
parameter_list|(
name|String
name|src
parameter_list|,
name|byte
index|[]
name|startAfter
parameter_list|,
name|boolean
name|needLocation
parameter_list|)
throws|throws
name|AccessControlException
throws|,
name|UnresolvedLinkException
throws|,
name|IOException
block|{
name|DirectoryListing
name|dl
decl_stmt|;
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|READ
argument_list|)
expr_stmt|;
if|if
condition|(
name|isPermissionEnabled
condition|)
block|{
if|if
condition|(
name|dir
operator|.
name|isDir
argument_list|(
name|src
argument_list|)
condition|)
block|{
name|checkPathAccess
argument_list|(
name|src
argument_list|,
name|FsAction
operator|.
name|READ_EXECUTE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|checkTraverse
argument_list|(
name|src
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|isAuditEnabled
argument_list|()
operator|&&
name|isExternalInvocation
argument_list|()
condition|)
block|{
name|logAuditEvent
argument_list|(
name|UserGroupInformation
operator|.
name|getCurrentUser
argument_list|()
argument_list|,
name|getRemoteIp
argument_list|()
argument_list|,
literal|"listStatus"
argument_list|,
name|src
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
name|dl
operator|=
name|dir
operator|.
name|getListing
argument_list|(
name|src
argument_list|,
name|startAfter
argument_list|,
name|needLocation
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
return|return
name|dl
return|;
block|}
comment|/////////////////////////////////////////////////////////
comment|//
comment|// These methods are called by datanodes
comment|//
comment|/////////////////////////////////////////////////////////
comment|/**    * Register Datanode.    *<p>    * The purpose of registration is to identify whether the new datanode    * serves a new data storage, and will report new data block copies,    * which the namenode was not aware of; or the datanode is a replacement    * node for the data storage that was previously served by a different    * or the same (in terms of host:port) datanode.    * The data storages are distinguished by their storageIDs. When a new    * data storage is reported the namenode issues a new unique storageID.    *<p>    * Finally, the namenode returns its namespaceID as the registrationID    * for the datanodes.     * namespaceID is a persistent attribute of the name space.    * The registrationID is checked every time the datanode is communicating    * with the namenode.     * Datanodes with inappropriate registrationID are rejected.    * If the namenode stops, and then restarts it can restore its     * namespaceID and will continue serving the datanodes that has previously    * registered with the namenode without restarting the whole cluster.    *     * @see org.apache.hadoop.hdfs.server.datanode.DataNode    */
DECL|method|registerDatanode (DatanodeRegistration nodeReg)
name|void
name|registerDatanode
parameter_list|(
name|DatanodeRegistration
name|nodeReg
parameter_list|)
throws|throws
name|IOException
block|{
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|getBlockManager
argument_list|()
operator|.
name|getDatanodeManager
argument_list|()
operator|.
name|registerDatanode
argument_list|(
name|nodeReg
argument_list|)
expr_stmt|;
name|checkSafeMode
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Get registrationID for datanodes based on the namespaceID.    *     * @see #registerDatanode(DatanodeRegistration)    * @return registration ID    */
DECL|method|getRegistrationID ()
name|String
name|getRegistrationID
parameter_list|()
block|{
return|return
name|Storage
operator|.
name|getRegistrationID
argument_list|(
name|dir
operator|.
name|fsImage
operator|.
name|getStorage
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * The given node has reported in.  This method should:    * 1) Record the heartbeat, so the datanode isn't timed out    * 2) Adjust usage stats for future block allocation    *     * If a substantial amount of time passed since the last datanode     * heartbeat then request an immediate block report.      *     * @return an array of datanode commands     * @throws IOException    */
DECL|method|handleHeartbeat (DatanodeRegistration nodeReg, long capacity, long dfsUsed, long remaining, long blockPoolUsed, int xceiverCount, int xmitsInProgress, int failedVolumes)
name|HeartbeatResponse
name|handleHeartbeat
parameter_list|(
name|DatanodeRegistration
name|nodeReg
parameter_list|,
name|long
name|capacity
parameter_list|,
name|long
name|dfsUsed
parameter_list|,
name|long
name|remaining
parameter_list|,
name|long
name|blockPoolUsed
parameter_list|,
name|int
name|xceiverCount
parameter_list|,
name|int
name|xmitsInProgress
parameter_list|,
name|int
name|failedVolumes
parameter_list|)
throws|throws
name|IOException
block|{
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
specifier|final
name|int
name|maxTransfer
init|=
name|blockManager
operator|.
name|getMaxReplicationStreams
argument_list|()
operator|-
name|xmitsInProgress
decl_stmt|;
name|DatanodeCommand
index|[]
name|cmds
init|=
name|blockManager
operator|.
name|getDatanodeManager
argument_list|()
operator|.
name|handleHeartbeat
argument_list|(
name|nodeReg
argument_list|,
name|blockPoolId
argument_list|,
name|capacity
argument_list|,
name|dfsUsed
argument_list|,
name|remaining
argument_list|,
name|blockPoolUsed
argument_list|,
name|xceiverCount
argument_list|,
name|maxTransfer
argument_list|,
name|failedVolumes
argument_list|)
decl_stmt|;
return|return
operator|new
name|HeartbeatResponse
argument_list|(
name|cmds
argument_list|,
name|createHaStatusHeartbeat
argument_list|()
argument_list|)
return|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|createHaStatusHeartbeat ()
specifier|private
name|NNHAStatusHeartbeat
name|createHaStatusHeartbeat
parameter_list|()
block|{
name|HAState
name|state
init|=
name|haContext
operator|.
name|getState
argument_list|()
decl_stmt|;
return|return
operator|new
name|NNHAStatusHeartbeat
argument_list|(
name|state
operator|.
name|getServiceState
argument_list|()
argument_list|,
name|getFSImage
argument_list|()
operator|.
name|getLastAppliedOrWrittenTxId
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Returns whether or not there were available resources at the last check of    * resources.    *    * @return true if there were sufficient resources available, false otherwise.    */
DECL|method|nameNodeHasResourcesAvailable ()
name|boolean
name|nameNodeHasResourcesAvailable
parameter_list|()
block|{
return|return
name|hasResourcesAvailable
return|;
block|}
comment|/**    * Perform resource checks and cache the results.    * @throws IOException    */
DECL|method|checkAvailableResources ()
name|void
name|checkAvailableResources
parameter_list|()
block|{
name|Preconditions
operator|.
name|checkState
argument_list|(
name|nnResourceChecker
operator|!=
literal|null
argument_list|,
literal|"nnResourceChecker not initialized"
argument_list|)
expr_stmt|;
name|hasResourcesAvailable
operator|=
name|nnResourceChecker
operator|.
name|hasAvailableDiskSpace
argument_list|()
expr_stmt|;
block|}
comment|/**    * Periodically calls hasAvailableResources of NameNodeResourceChecker, and if    * there are found to be insufficient resources available, causes the NN to    * enter safe mode. If resources are later found to have returned to    * acceptable levels, this daemon will cause the NN to exit safe mode.    */
DECL|class|NameNodeResourceMonitor
class|class
name|NameNodeResourceMonitor
implements|implements
name|Runnable
block|{
DECL|field|shouldNNRmRun
name|boolean
name|shouldNNRmRun
init|=
literal|true
decl_stmt|;
annotation|@
name|Override
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
try|try
block|{
while|while
condition|(
name|fsRunning
operator|&&
name|shouldNNRmRun
condition|)
block|{
name|checkAvailableResources
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|nameNodeHasResourcesAvailable
argument_list|()
condition|)
block|{
name|String
name|lowResourcesMsg
init|=
literal|"NameNode low on available disk space. "
decl_stmt|;
if|if
condition|(
operator|!
name|isInSafeMode
argument_list|()
condition|)
block|{
name|FSNamesystem
operator|.
name|LOG
operator|.
name|warn
argument_list|(
name|lowResourcesMsg
operator|+
literal|"Entering safe mode."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|FSNamesystem
operator|.
name|LOG
operator|.
name|warn
argument_list|(
name|lowResourcesMsg
operator|+
literal|"Already in safe mode."
argument_list|)
expr_stmt|;
block|}
name|enterSafeMode
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|resourceRecheckInterval
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
comment|// Deliberately ignore
block|}
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|FSNamesystem
operator|.
name|LOG
operator|.
name|error
argument_list|(
literal|"Exception in NameNodeResourceMonitor: "
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|stopMonitor ()
specifier|public
name|void
name|stopMonitor
parameter_list|()
block|{
name|shouldNNRmRun
operator|=
literal|false
expr_stmt|;
block|}
block|}
DECL|method|getFSImage ()
specifier|public
name|FSImage
name|getFSImage
parameter_list|()
block|{
return|return
name|dir
operator|.
name|fsImage
return|;
block|}
DECL|method|getEditLog ()
specifier|public
name|FSEditLog
name|getEditLog
parameter_list|()
block|{
return|return
name|getFSImage
argument_list|()
operator|.
name|getEditLog
argument_list|()
return|;
block|}
DECL|method|checkBlock (ExtendedBlock block)
specifier|private
name|void
name|checkBlock
parameter_list|(
name|ExtendedBlock
name|block
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|block
operator|!=
literal|null
operator|&&
operator|!
name|this
operator|.
name|blockPoolId
operator|.
name|equals
argument_list|(
name|block
operator|.
name|getBlockPoolId
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unexpected BlockPoolId "
operator|+
name|block
operator|.
name|getBlockPoolId
argument_list|()
operator|+
literal|" - expected "
operator|+
name|blockPoolId
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Metric
argument_list|(
block|{
literal|"MissingBlocks"
block|,
literal|"Number of missing blocks"
block|}
argument_list|)
DECL|method|getMissingBlocksCount ()
specifier|public
name|long
name|getMissingBlocksCount
parameter_list|()
block|{
comment|// not locking
return|return
name|blockManager
operator|.
name|getMissingBlocksCount
argument_list|()
return|;
block|}
annotation|@
name|Metric
argument_list|(
block|{
literal|"ExpiredHeartbeats"
block|,
literal|"Number of expired heartbeats"
block|}
argument_list|)
DECL|method|getExpiredHeartbeats ()
specifier|public
name|int
name|getExpiredHeartbeats
parameter_list|()
block|{
return|return
name|datanodeStatistics
operator|.
name|getExpiredHeartbeats
argument_list|()
return|;
block|}
annotation|@
name|Metric
argument_list|(
block|{
literal|"TransactionsSinceLastCheckpoint"
block|,
literal|"Number of transactions since last checkpoint"
block|}
argument_list|)
DECL|method|getTransactionsSinceLastCheckpoint ()
specifier|public
name|long
name|getTransactionsSinceLastCheckpoint
parameter_list|()
block|{
return|return
name|getEditLog
argument_list|()
operator|.
name|getLastWrittenTxId
argument_list|()
operator|-
name|getFSImage
argument_list|()
operator|.
name|getStorage
argument_list|()
operator|.
name|getMostRecentCheckpointTxId
argument_list|()
return|;
block|}
annotation|@
name|Metric
argument_list|(
block|{
literal|"TransactionsSinceLastLogRoll"
block|,
literal|"Number of transactions since last edit log roll"
block|}
argument_list|)
DECL|method|getTransactionsSinceLastLogRoll ()
specifier|public
name|long
name|getTransactionsSinceLastLogRoll
parameter_list|()
block|{
if|if
condition|(
name|isInStandbyState
argument_list|()
operator|||
operator|!
name|getEditLog
argument_list|()
operator|.
name|isSegmentOpen
argument_list|()
condition|)
block|{
return|return
literal|0
return|;
block|}
else|else
block|{
return|return
name|getEditLog
argument_list|()
operator|.
name|getLastWrittenTxId
argument_list|()
operator|-
name|getEditLog
argument_list|()
operator|.
name|getCurSegmentTxId
argument_list|()
operator|+
literal|1
return|;
block|}
block|}
annotation|@
name|Metric
argument_list|(
block|{
literal|"LastWrittenTransactionId"
block|,
literal|"Transaction ID written to the edit log"
block|}
argument_list|)
DECL|method|getLastWrittenTransactionId ()
specifier|public
name|long
name|getLastWrittenTransactionId
parameter_list|()
block|{
return|return
name|getEditLog
argument_list|()
operator|.
name|getLastWrittenTxId
argument_list|()
return|;
block|}
annotation|@
name|Metric
argument_list|(
block|{
literal|"LastCheckpointTime"
block|,
literal|"Time in milliseconds since the epoch of the last checkpoint"
block|}
argument_list|)
DECL|method|getLastCheckpointTime ()
specifier|public
name|long
name|getLastCheckpointTime
parameter_list|()
block|{
return|return
name|getFSImage
argument_list|()
operator|.
name|getStorage
argument_list|()
operator|.
name|getMostRecentCheckpointTime
argument_list|()
return|;
block|}
comment|/** @see ClientProtocol#getStats() */
DECL|method|getStats ()
name|long
index|[]
name|getStats
parameter_list|()
block|{
specifier|final
name|long
index|[]
name|stats
init|=
name|datanodeStatistics
operator|.
name|getStats
argument_list|()
decl_stmt|;
name|stats
index|[
name|ClientProtocol
operator|.
name|GET_STATS_UNDER_REPLICATED_IDX
index|]
operator|=
name|getUnderReplicatedBlocks
argument_list|()
expr_stmt|;
name|stats
index|[
name|ClientProtocol
operator|.
name|GET_STATS_CORRUPT_BLOCKS_IDX
index|]
operator|=
name|getCorruptReplicaBlocks
argument_list|()
expr_stmt|;
name|stats
index|[
name|ClientProtocol
operator|.
name|GET_STATS_MISSING_BLOCKS_IDX
index|]
operator|=
name|getMissingBlocksCount
argument_list|()
expr_stmt|;
return|return
name|stats
return|;
block|}
comment|/**    * Total raw bytes including non-dfs used space.    */
annotation|@
name|Override
comment|// FSNamesystemMBean
DECL|method|getCapacityTotal ()
specifier|public
name|long
name|getCapacityTotal
parameter_list|()
block|{
return|return
name|datanodeStatistics
operator|.
name|getCapacityTotal
argument_list|()
return|;
block|}
annotation|@
name|Metric
DECL|method|getCapacityTotalGB ()
specifier|public
name|float
name|getCapacityTotalGB
parameter_list|()
block|{
return|return
name|DFSUtil
operator|.
name|roundBytesToGB
argument_list|(
name|getCapacityTotal
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Total used space by data nodes    */
annotation|@
name|Override
comment|// FSNamesystemMBean
DECL|method|getCapacityUsed ()
specifier|public
name|long
name|getCapacityUsed
parameter_list|()
block|{
return|return
name|datanodeStatistics
operator|.
name|getCapacityUsed
argument_list|()
return|;
block|}
annotation|@
name|Metric
DECL|method|getCapacityUsedGB ()
specifier|public
name|float
name|getCapacityUsedGB
parameter_list|()
block|{
return|return
name|DFSUtil
operator|.
name|roundBytesToGB
argument_list|(
name|getCapacityUsed
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|getCapacityRemaining ()
specifier|public
name|long
name|getCapacityRemaining
parameter_list|()
block|{
return|return
name|datanodeStatistics
operator|.
name|getCapacityRemaining
argument_list|()
return|;
block|}
annotation|@
name|Metric
DECL|method|getCapacityRemainingGB ()
specifier|public
name|float
name|getCapacityRemainingGB
parameter_list|()
block|{
return|return
name|DFSUtil
operator|.
name|roundBytesToGB
argument_list|(
name|getCapacityRemaining
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Total number of connections.    */
annotation|@
name|Override
comment|// FSNamesystemMBean
annotation|@
name|Metric
DECL|method|getTotalLoad ()
specifier|public
name|int
name|getTotalLoad
parameter_list|()
block|{
return|return
name|datanodeStatistics
operator|.
name|getXceiverCount
argument_list|()
return|;
block|}
annotation|@
name|Metric
argument_list|(
block|{
literal|"SnapshottableDirectories"
block|,
literal|"Number of snapshottable directories"
block|}
argument_list|)
DECL|method|getNumSnapshottableDirs ()
specifier|public
name|long
name|getNumSnapshottableDirs
parameter_list|()
block|{
return|return
name|this
operator|.
name|snapshotManager
operator|.
name|getNumSnapshottableDirs
argument_list|()
return|;
block|}
annotation|@
name|Metric
argument_list|(
block|{
literal|"Snapshots"
block|,
literal|"The number of snapshots"
block|}
argument_list|)
DECL|method|getNumSnapshots ()
specifier|public
name|long
name|getNumSnapshots
parameter_list|()
block|{
return|return
name|this
operator|.
name|snapshotManager
operator|.
name|getNumSnapshots
argument_list|()
return|;
block|}
DECL|method|getNumberOfDatanodes (DatanodeReportType type)
name|int
name|getNumberOfDatanodes
parameter_list|(
name|DatanodeReportType
name|type
parameter_list|)
block|{
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
return|return
name|getBlockManager
argument_list|()
operator|.
name|getDatanodeManager
argument_list|()
operator|.
name|getDatanodeListForReport
argument_list|(
name|type
argument_list|)
operator|.
name|size
argument_list|()
return|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|datanodeReport (final DatanodeReportType type )
name|DatanodeInfo
index|[]
name|datanodeReport
parameter_list|(
specifier|final
name|DatanodeReportType
name|type
parameter_list|)
throws|throws
name|AccessControlException
block|{
name|checkSuperuserPrivilege
argument_list|()
expr_stmt|;
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
specifier|final
name|DatanodeManager
name|dm
init|=
name|getBlockManager
argument_list|()
operator|.
name|getDatanodeManager
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|results
init|=
name|dm
operator|.
name|getDatanodeListForReport
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|DatanodeInfo
index|[]
name|arr
init|=
operator|new
name|DatanodeInfo
index|[
name|results
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|arr
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|arr
index|[
name|i
index|]
operator|=
operator|new
name|DatanodeInfo
argument_list|(
name|results
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|arr
return|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Save namespace image.    * This will save current namespace into fsimage file and empty edits file.    * Requires superuser privilege and safe mode.    *     * @throws AccessControlException if superuser privilege is violated.    * @throws IOException if     */
DECL|method|saveNamespace ()
name|void
name|saveNamespace
parameter_list|()
throws|throws
name|AccessControlException
throws|,
name|IOException
block|{
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkSuperuserPrivilege
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|isInSafeMode
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Safe mode should be turned ON "
operator|+
literal|"in order to create namespace image."
argument_list|)
throw|;
block|}
name|getFSImage
argument_list|()
operator|.
name|saveNamespace
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"New namespace image has been created"
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Enables/Disables/Checks restoring failed storage replicas if the storage becomes available again.    * Requires superuser privilege.    *     * @throws AccessControlException if superuser privilege is violated.    */
DECL|method|restoreFailedStorage (String arg)
name|boolean
name|restoreFailedStorage
parameter_list|(
name|String
name|arg
parameter_list|)
throws|throws
name|AccessControlException
block|{
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkSuperuserPrivilege
argument_list|()
expr_stmt|;
comment|// if it is disabled - enable it and vice versa.
if|if
condition|(
name|arg
operator|.
name|equals
argument_list|(
literal|"check"
argument_list|)
condition|)
return|return
name|getFSImage
argument_list|()
operator|.
name|getStorage
argument_list|()
operator|.
name|getRestoreFailedStorage
argument_list|()
return|;
name|boolean
name|val
init|=
name|arg
operator|.
name|equals
argument_list|(
literal|"true"
argument_list|)
decl_stmt|;
comment|// false if not
name|getFSImage
argument_list|()
operator|.
name|getStorage
argument_list|()
operator|.
name|setRestoreFailedStorage
argument_list|(
name|val
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|getStartTime ()
name|Date
name|getStartTime
parameter_list|()
block|{
return|return
operator|new
name|Date
argument_list|(
name|startTime
argument_list|)
return|;
block|}
DECL|method|finalizeUpgrade ()
name|void
name|finalizeUpgrade
parameter_list|()
throws|throws
name|IOException
block|{
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|checkSuperuserPrivilege
argument_list|()
expr_stmt|;
name|getFSImage
argument_list|()
operator|.
name|finalizeUpgrade
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|refreshNodes ()
name|void
name|refreshNodes
parameter_list|()
throws|throws
name|IOException
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|UNCHECKED
argument_list|)
expr_stmt|;
name|checkSuperuserPrivilege
argument_list|()
expr_stmt|;
name|getBlockManager
argument_list|()
operator|.
name|getDatanodeManager
argument_list|()
operator|.
name|refreshNodes
argument_list|(
operator|new
name|HdfsConfiguration
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|setBalancerBandwidth (long bandwidth)
name|void
name|setBalancerBandwidth
parameter_list|(
name|long
name|bandwidth
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|UNCHECKED
argument_list|)
expr_stmt|;
name|checkSuperuserPrivilege
argument_list|()
expr_stmt|;
name|getBlockManager
argument_list|()
operator|.
name|getDatanodeManager
argument_list|()
operator|.
name|setBalancerBandwidth
argument_list|(
name|bandwidth
argument_list|)
expr_stmt|;
block|}
comment|/**    * SafeModeInfo contains information related to the safe mode.    *<p>    * An instance of {@link SafeModeInfo} is created when the name node    * enters safe mode.    *<p>    * During name node startup {@link SafeModeInfo} counts the number of    *<em>safe blocks</em>, those that have at least the minimal number of    * replicas, and calculates the ratio of safe blocks to the total number    * of blocks in the system, which is the size of blocks in    * {@link FSNamesystem#blockManager}. When the ratio reaches the    * {@link #threshold} it starts the {@link SafeModeMonitor} daemon in order    * to monitor whether the safe mode {@link #extension} is passed.    * Then it leaves safe mode and destroys itself.    *<p>    * If safe mode is turned on manually then the number of safe blocks is    * not tracked because the name node is not intended to leave safe mode    * automatically in the case.    *    * @see ClientProtocol#setSafeMode(HdfsConstants.SafeModeAction)    * @see SafeModeMonitor    */
DECL|class|SafeModeInfo
class|class
name|SafeModeInfo
block|{
comment|// configuration fields
comment|/** Safe mode threshold condition %.*/
DECL|field|threshold
specifier|private
name|double
name|threshold
decl_stmt|;
comment|/** Safe mode minimum number of datanodes alive */
DECL|field|datanodeThreshold
specifier|private
name|int
name|datanodeThreshold
decl_stmt|;
comment|/** Safe mode extension after the threshold. */
DECL|field|extension
specifier|private
name|int
name|extension
decl_stmt|;
comment|/** Min replication required by safe mode. */
DECL|field|safeReplication
specifier|private
name|int
name|safeReplication
decl_stmt|;
comment|/** threshold for populating needed replication queues */
DECL|field|replQueueThreshold
specifier|private
name|double
name|replQueueThreshold
decl_stmt|;
comment|// internal fields
comment|/** Time when threshold was reached.      *       *<br>-1 safe mode is off      *<br> 0 safe mode is on, but threshold is not reached yet       */
DECL|field|reached
specifier|private
name|long
name|reached
init|=
operator|-
literal|1
decl_stmt|;
comment|/** Total number of blocks. */
DECL|field|blockTotal
name|int
name|blockTotal
decl_stmt|;
comment|/** Number of safe blocks. */
DECL|field|blockSafe
name|int
name|blockSafe
decl_stmt|;
comment|/** Number of blocks needed to satisfy safe mode threshold condition */
DECL|field|blockThreshold
specifier|private
name|int
name|blockThreshold
decl_stmt|;
comment|/** Number of blocks needed before populating replication queues */
DECL|field|blockReplQueueThreshold
specifier|private
name|int
name|blockReplQueueThreshold
decl_stmt|;
comment|/** time of the last status printout */
DECL|field|lastStatusReport
specifier|private
name|long
name|lastStatusReport
init|=
literal|0
decl_stmt|;
comment|/** flag indicating whether replication queues have been initialized */
DECL|field|initializedReplQueues
name|boolean
name|initializedReplQueues
init|=
literal|false
decl_stmt|;
comment|/** Was safemode entered automatically because available resources were low. */
DECL|field|resourcesLow
specifier|private
name|boolean
name|resourcesLow
init|=
literal|false
decl_stmt|;
comment|/** Should safemode adjust its block totals as blocks come in */
DECL|field|shouldIncrementallyTrackBlocks
specifier|private
name|boolean
name|shouldIncrementallyTrackBlocks
init|=
literal|false
decl_stmt|;
comment|/**      * Creates SafeModeInfo when the name node enters      * automatic safe mode at startup.      *        * @param conf configuration      */
DECL|method|SafeModeInfo (Configuration conf)
specifier|private
name|SafeModeInfo
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
name|this
operator|.
name|threshold
operator|=
name|conf
operator|.
name|getFloat
argument_list|(
name|DFS_NAMENODE_SAFEMODE_THRESHOLD_PCT_KEY
argument_list|,
name|DFS_NAMENODE_SAFEMODE_THRESHOLD_PCT_DEFAULT
argument_list|)
expr_stmt|;
if|if
condition|(
name|threshold
operator|>
literal|1.0
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"The threshold value should't be greater than 1, threshold: "
operator|+
name|threshold
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|datanodeThreshold
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|DFS_NAMENODE_SAFEMODE_MIN_DATANODES_KEY
argument_list|,
name|DFS_NAMENODE_SAFEMODE_MIN_DATANODES_DEFAULT
argument_list|)
expr_stmt|;
name|this
operator|.
name|extension
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|DFS_NAMENODE_SAFEMODE_EXTENSION_KEY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|this
operator|.
name|safeReplication
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|DFS_NAMENODE_REPLICATION_MIN_KEY
argument_list|,
name|DFS_NAMENODE_REPLICATION_MIN_DEFAULT
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|DFS_NAMENODE_SAFEMODE_THRESHOLD_PCT_KEY
operator|+
literal|" = "
operator|+
name|threshold
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|DFS_NAMENODE_SAFEMODE_MIN_DATANODES_KEY
operator|+
literal|" = "
operator|+
name|datanodeThreshold
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|DFS_NAMENODE_SAFEMODE_EXTENSION_KEY
operator|+
literal|"     = "
operator|+
name|extension
argument_list|)
expr_stmt|;
comment|// default to safe mode threshold (i.e., don't populate queues before leaving safe mode)
name|this
operator|.
name|replQueueThreshold
operator|=
name|conf
operator|.
name|getFloat
argument_list|(
name|DFS_NAMENODE_REPL_QUEUE_THRESHOLD_PCT_KEY
argument_list|,
operator|(
name|float
operator|)
name|threshold
argument_list|)
expr_stmt|;
name|this
operator|.
name|blockTotal
operator|=
literal|0
expr_stmt|;
name|this
operator|.
name|blockSafe
operator|=
literal|0
expr_stmt|;
block|}
comment|/**      * In the HA case, the StandbyNode can be in safemode while the namespace      * is modified by the edit log tailer. In this case, the number of total      * blocks changes as edits are processed (eg blocks are added and deleted).      * However, we don't want to do the incremental tracking during the      * startup-time loading process -- only once the initial total has been      * set after the image has been loaded.      */
DECL|method|shouldIncrementallyTrackBlocks ()
specifier|private
name|boolean
name|shouldIncrementallyTrackBlocks
parameter_list|()
block|{
return|return
name|shouldIncrementallyTrackBlocks
return|;
block|}
comment|/**      * Creates SafeModeInfo when safe mode is entered manually, or because      * available resources are low.      *      * The {@link #threshold} is set to 1.5 so that it could never be reached.      * {@link #blockTotal} is set to -1 to indicate that safe mode is manual.      *       * @see SafeModeInfo      */
DECL|method|SafeModeInfo (boolean resourcesLow)
specifier|private
name|SafeModeInfo
parameter_list|(
name|boolean
name|resourcesLow
parameter_list|)
block|{
name|this
operator|.
name|threshold
operator|=
literal|1.5f
expr_stmt|;
comment|// this threshold can never be reached
name|this
operator|.
name|datanodeThreshold
operator|=
name|Integer
operator|.
name|MAX_VALUE
expr_stmt|;
name|this
operator|.
name|extension
operator|=
name|Integer
operator|.
name|MAX_VALUE
expr_stmt|;
name|this
operator|.
name|safeReplication
operator|=
name|Short
operator|.
name|MAX_VALUE
operator|+
literal|1
expr_stmt|;
comment|// more than maxReplication
name|this
operator|.
name|replQueueThreshold
operator|=
literal|1.5f
expr_stmt|;
comment|// can never be reached
name|this
operator|.
name|blockTotal
operator|=
operator|-
literal|1
expr_stmt|;
name|this
operator|.
name|blockSafe
operator|=
operator|-
literal|1
expr_stmt|;
name|this
operator|.
name|reached
operator|=
operator|-
literal|1
expr_stmt|;
name|this
operator|.
name|resourcesLow
operator|=
name|resourcesLow
expr_stmt|;
name|enter
argument_list|()
expr_stmt|;
name|reportStatus
argument_list|(
literal|"STATE* Safe mode is ON."
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**      * Check if safe mode is on.      * @return true if in safe mode      */
DECL|method|isOn ()
specifier|private
specifier|synchronized
name|boolean
name|isOn
parameter_list|()
block|{
name|doConsistencyCheck
argument_list|()
expr_stmt|;
return|return
name|this
operator|.
name|reached
operator|>=
literal|0
return|;
block|}
comment|/**      * Check if we are populating replication queues.      */
DECL|method|isPopulatingReplQueues ()
specifier|private
specifier|synchronized
name|boolean
name|isPopulatingReplQueues
parameter_list|()
block|{
return|return
name|initializedReplQueues
return|;
block|}
comment|/**      * Enter safe mode.      */
DECL|method|enter ()
specifier|private
name|void
name|enter
parameter_list|()
block|{
name|this
operator|.
name|reached
operator|=
literal|0
expr_stmt|;
block|}
comment|/**      * Leave safe mode.      *<p>      * Check for invalid, under-& over-replicated blocks in the end of startup.      */
DECL|method|leave ()
specifier|private
specifier|synchronized
name|void
name|leave
parameter_list|()
block|{
comment|// if not done yet, initialize replication queues.
comment|// In the standby, do not populate repl queues
if|if
condition|(
operator|!
name|isPopulatingReplQueues
argument_list|()
operator|&&
name|shouldPopulateReplQueues
argument_list|()
condition|)
block|{
name|initializeReplQueues
argument_list|()
expr_stmt|;
block|}
name|long
name|timeInSafemode
init|=
name|now
argument_list|()
operator|-
name|startTime
decl_stmt|;
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|info
argument_list|(
literal|"STATE* Leaving safe mode after "
operator|+
name|timeInSafemode
operator|/
literal|1000
operator|+
literal|" secs"
argument_list|)
expr_stmt|;
name|NameNode
operator|.
name|getNameNodeMetrics
argument_list|()
operator|.
name|setSafeModeTime
argument_list|(
operator|(
name|int
operator|)
name|timeInSafemode
argument_list|)
expr_stmt|;
if|if
condition|(
name|reached
operator|>=
literal|0
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|info
argument_list|(
literal|"STATE* Safe mode is OFF"
argument_list|)
expr_stmt|;
block|}
name|reached
operator|=
operator|-
literal|1
expr_stmt|;
name|safeMode
operator|=
literal|null
expr_stmt|;
specifier|final
name|NetworkTopology
name|nt
init|=
name|blockManager
operator|.
name|getDatanodeManager
argument_list|()
operator|.
name|getNetworkTopology
argument_list|()
decl_stmt|;
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|info
argument_list|(
literal|"STATE* Network topology has "
operator|+
name|nt
operator|.
name|getNumOfRacks
argument_list|()
operator|+
literal|" racks and "
operator|+
name|nt
operator|.
name|getNumOfLeaves
argument_list|()
operator|+
literal|" datanodes"
argument_list|)
expr_stmt|;
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|info
argument_list|(
literal|"STATE* UnderReplicatedBlocks has "
operator|+
name|blockManager
operator|.
name|numOfUnderReplicatedBlocks
argument_list|()
operator|+
literal|" blocks"
argument_list|)
expr_stmt|;
name|startSecretManagerIfNecessary
argument_list|()
expr_stmt|;
block|}
comment|/**      * Initialize replication queues.      */
DECL|method|initializeReplQueues ()
specifier|private
specifier|synchronized
name|void
name|initializeReplQueues
parameter_list|()
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"initializing replication queues"
argument_list|)
expr_stmt|;
assert|assert
operator|!
name|isPopulatingReplQueues
argument_list|()
operator|:
literal|"Already initialized repl queues"
assert|;
name|long
name|startTimeMisReplicatedScan
init|=
name|now
argument_list|()
decl_stmt|;
name|blockManager
operator|.
name|processMisReplicatedBlocks
argument_list|()
expr_stmt|;
name|initializedReplQueues
operator|=
literal|true
expr_stmt|;
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|info
argument_list|(
literal|"STATE* Replication Queue initialization "
operator|+
literal|"scan for invalid, over- and under-replicated blocks "
operator|+
literal|"completed in "
operator|+
operator|(
name|now
argument_list|()
operator|-
name|startTimeMisReplicatedScan
operator|)
operator|+
literal|" msec"
argument_list|)
expr_stmt|;
block|}
comment|/**      * Check whether we have reached the threshold for       * initializing replication queues.      */
DECL|method|canInitializeReplQueues ()
specifier|private
specifier|synchronized
name|boolean
name|canInitializeReplQueues
parameter_list|()
block|{
return|return
name|shouldPopulateReplQueues
argument_list|()
operator|&&
name|blockSafe
operator|>=
name|blockReplQueueThreshold
return|;
block|}
comment|/**       * Safe mode can be turned off iff       * the threshold is reached and       * the extension time have passed.      * @return true if can leave or false otherwise.      */
DECL|method|canLeave ()
specifier|private
specifier|synchronized
name|boolean
name|canLeave
parameter_list|()
block|{
if|if
condition|(
name|reached
operator|==
literal|0
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|now
argument_list|()
operator|-
name|reached
operator|<
name|extension
condition|)
block|{
name|reportStatus
argument_list|(
literal|"STATE* Safe mode ON."
argument_list|,
literal|false
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
operator|!
name|needEnter
argument_list|()
return|;
block|}
comment|/**       * There is no need to enter safe mode       * if DFS is empty or {@link #threshold} == 0      */
DECL|method|needEnter ()
specifier|private
name|boolean
name|needEnter
parameter_list|()
block|{
return|return
operator|(
name|threshold
operator|!=
literal|0
operator|&&
name|blockSafe
operator|<
name|blockThreshold
operator|)
operator|||
operator|(
name|getNumLiveDataNodes
argument_list|()
operator|<
name|datanodeThreshold
operator|)
operator|||
operator|(
operator|!
name|nameNodeHasResourcesAvailable
argument_list|()
operator|)
return|;
block|}
comment|/**      * Check and trigger safe mode if needed.       */
DECL|method|checkMode ()
specifier|private
name|void
name|checkMode
parameter_list|()
block|{
comment|// Have to have write-lock since leaving safemode initializes
comment|// repl queues, which requires write lock
assert|assert
name|hasWriteLock
argument_list|()
assert|;
if|if
condition|(
name|needEnter
argument_list|()
condition|)
block|{
name|enter
argument_list|()
expr_stmt|;
comment|// check if we are ready to initialize replication queues
if|if
condition|(
name|canInitializeReplQueues
argument_list|()
operator|&&
operator|!
name|isPopulatingReplQueues
argument_list|()
condition|)
block|{
name|initializeReplQueues
argument_list|()
expr_stmt|;
block|}
name|reportStatus
argument_list|(
literal|"STATE* Safe mode ON."
argument_list|,
literal|false
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// the threshold is reached
if|if
condition|(
operator|!
name|isOn
argument_list|()
operator|||
comment|// safe mode is off
name|extension
operator|<=
literal|0
operator|||
name|threshold
operator|<=
literal|0
condition|)
block|{
comment|// don't need to wait
name|this
operator|.
name|leave
argument_list|()
expr_stmt|;
comment|// leave safe mode
return|return;
block|}
if|if
condition|(
name|reached
operator|>
literal|0
condition|)
block|{
comment|// threshold has already been reached before
name|reportStatus
argument_list|(
literal|"STATE* Safe mode ON."
argument_list|,
literal|false
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// start monitor
name|reached
operator|=
name|now
argument_list|()
expr_stmt|;
name|smmthread
operator|=
operator|new
name|Daemon
argument_list|(
operator|new
name|SafeModeMonitor
argument_list|()
argument_list|)
expr_stmt|;
name|smmthread
operator|.
name|start
argument_list|()
expr_stmt|;
name|reportStatus
argument_list|(
literal|"STATE* Safe mode extension entered."
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|// check if we are ready to initialize replication queues
if|if
condition|(
name|canInitializeReplQueues
argument_list|()
operator|&&
operator|!
name|isPopulatingReplQueues
argument_list|()
condition|)
block|{
name|initializeReplQueues
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Set total number of blocks.      */
DECL|method|setBlockTotal (int total)
specifier|private
specifier|synchronized
name|void
name|setBlockTotal
parameter_list|(
name|int
name|total
parameter_list|)
block|{
name|this
operator|.
name|blockTotal
operator|=
name|total
expr_stmt|;
name|this
operator|.
name|blockThreshold
operator|=
call|(
name|int
call|)
argument_list|(
name|blockTotal
operator|*
name|threshold
argument_list|)
expr_stmt|;
name|this
operator|.
name|blockReplQueueThreshold
operator|=
call|(
name|int
call|)
argument_list|(
name|blockTotal
operator|*
name|replQueueThreshold
argument_list|)
expr_stmt|;
if|if
condition|(
name|haEnabled
condition|)
block|{
comment|// After we initialize the block count, any further namespace
comment|// modifications done while in safe mode need to keep track
comment|// of the number of total blocks in the system.
name|this
operator|.
name|shouldIncrementallyTrackBlocks
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|blockSafe
operator|<
literal|0
condition|)
name|this
operator|.
name|blockSafe
operator|=
literal|0
expr_stmt|;
name|checkMode
argument_list|()
expr_stmt|;
block|}
comment|/**      * Increment number of safe blocks if current block has       * reached minimal replication.      * @param replication current replication       */
DECL|method|incrementSafeBlockCount (short replication)
specifier|private
specifier|synchronized
name|void
name|incrementSafeBlockCount
parameter_list|(
name|short
name|replication
parameter_list|)
block|{
if|if
condition|(
name|replication
operator|==
name|safeReplication
condition|)
block|{
name|this
operator|.
name|blockSafe
operator|++
expr_stmt|;
name|checkMode
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Decrement number of safe blocks if current block has       * fallen below minimal replication.      * @param replication current replication       */
DECL|method|decrementSafeBlockCount (short replication)
specifier|private
specifier|synchronized
name|void
name|decrementSafeBlockCount
parameter_list|(
name|short
name|replication
parameter_list|)
block|{
if|if
condition|(
name|replication
operator|==
name|safeReplication
operator|-
literal|1
condition|)
block|{
name|this
operator|.
name|blockSafe
operator|--
expr_stmt|;
assert|assert
name|blockSafe
operator|>=
literal|0
operator|||
name|isManual
argument_list|()
assert|;
name|checkMode
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Check if safe mode was entered manually or automatically (at startup, or      * when disk space is low).      */
DECL|method|isManual ()
specifier|private
name|boolean
name|isManual
parameter_list|()
block|{
return|return
name|extension
operator|==
name|Integer
operator|.
name|MAX_VALUE
operator|&&
operator|!
name|resourcesLow
return|;
block|}
comment|/**      * Set manual safe mode.      */
DECL|method|setManual ()
specifier|private
specifier|synchronized
name|void
name|setManual
parameter_list|()
block|{
name|extension
operator|=
name|Integer
operator|.
name|MAX_VALUE
expr_stmt|;
block|}
comment|/**      * Check if safe mode was entered due to resources being low.      */
DECL|method|areResourcesLow ()
specifier|private
name|boolean
name|areResourcesLow
parameter_list|()
block|{
return|return
name|resourcesLow
return|;
block|}
comment|/**      * Set that resources are low for this instance of safe mode.      */
DECL|method|setResourcesLow ()
specifier|private
name|void
name|setResourcesLow
parameter_list|()
block|{
name|resourcesLow
operator|=
literal|true
expr_stmt|;
block|}
comment|/**      * A tip on how safe mode is to be turned off: manually or automatically.      */
DECL|method|getTurnOffTip ()
name|String
name|getTurnOffTip
parameter_list|()
block|{
if|if
condition|(
name|reached
operator|<
literal|0
condition|)
return|return
literal|"Safe mode is OFF."
return|;
name|String
name|leaveMsg
init|=
literal|""
decl_stmt|;
if|if
condition|(
name|areResourcesLow
argument_list|()
condition|)
block|{
name|leaveMsg
operator|=
literal|"Resources are low on NN. "
operator|+
literal|"Please add or free up more resources then turn off safe mode manually.  "
operator|+
literal|"NOTE:  If you turn off safe mode before adding resources, "
operator|+
literal|"the NN will immediately return to safe mode."
expr_stmt|;
block|}
else|else
block|{
name|leaveMsg
operator|=
literal|"Safe mode will be turned off automatically"
expr_stmt|;
block|}
if|if
condition|(
name|isManual
argument_list|()
condition|)
block|{
name|leaveMsg
operator|=
literal|"Use \"hdfs dfsadmin -safemode leave\" to turn safe mode off"
expr_stmt|;
block|}
if|if
condition|(
name|blockTotal
operator|<
literal|0
condition|)
return|return
name|leaveMsg
operator|+
literal|"."
return|;
name|int
name|numLive
init|=
name|getNumLiveDataNodes
argument_list|()
decl_stmt|;
name|String
name|msg
init|=
literal|""
decl_stmt|;
if|if
condition|(
name|reached
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|blockSafe
operator|<
name|blockThreshold
condition|)
block|{
name|msg
operator|+=
name|String
operator|.
name|format
argument_list|(
literal|"The reported blocks %d needs additional %d"
operator|+
literal|" blocks to reach the threshold %.4f of total blocks %d."
argument_list|,
name|blockSafe
argument_list|,
operator|(
name|blockThreshold
operator|-
name|blockSafe
operator|)
operator|+
literal|1
argument_list|,
name|threshold
argument_list|,
name|blockTotal
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|numLive
operator|<
name|datanodeThreshold
condition|)
block|{
if|if
condition|(
operator|!
literal|""
operator|.
name|equals
argument_list|(
name|msg
argument_list|)
condition|)
block|{
name|msg
operator|+=
literal|"\n"
expr_stmt|;
block|}
name|msg
operator|+=
name|String
operator|.
name|format
argument_list|(
literal|"The number of live datanodes %d needs an additional %d live "
operator|+
literal|"datanodes to reach the minimum number %d."
argument_list|,
name|numLive
argument_list|,
operator|(
name|datanodeThreshold
operator|-
name|numLive
operator|)
argument_list|,
name|datanodeThreshold
argument_list|)
expr_stmt|;
block|}
name|msg
operator|+=
literal|" "
operator|+
name|leaveMsg
expr_stmt|;
block|}
else|else
block|{
name|msg
operator|=
name|String
operator|.
name|format
argument_list|(
literal|"The reported blocks %d has reached the threshold"
operator|+
literal|" %.4f of total blocks %d."
argument_list|,
name|blockSafe
argument_list|,
name|threshold
argument_list|,
name|blockTotal
argument_list|)
expr_stmt|;
if|if
condition|(
name|datanodeThreshold
operator|>
literal|0
condition|)
block|{
name|msg
operator|+=
name|String
operator|.
name|format
argument_list|(
literal|" The number of live datanodes %d has reached "
operator|+
literal|"the minimum number %d."
argument_list|,
name|numLive
argument_list|,
name|datanodeThreshold
argument_list|)
expr_stmt|;
block|}
name|msg
operator|+=
literal|" "
operator|+
name|leaveMsg
expr_stmt|;
block|}
if|if
condition|(
name|reached
operator|==
literal|0
operator|||
name|isManual
argument_list|()
condition|)
block|{
comment|// threshold is not reached or manual
return|return
name|msg
operator|+
literal|"."
return|;
block|}
comment|// extension period is in progress
return|return
name|msg
operator|+
literal|" in "
operator|+
name|Math
operator|.
name|abs
argument_list|(
name|reached
operator|+
name|extension
operator|-
name|now
argument_list|()
argument_list|)
operator|/
literal|1000
operator|+
literal|" seconds."
return|;
block|}
comment|/**      * Print status every 20 seconds.      */
DECL|method|reportStatus (String msg, boolean rightNow)
specifier|private
name|void
name|reportStatus
parameter_list|(
name|String
name|msg
parameter_list|,
name|boolean
name|rightNow
parameter_list|)
block|{
name|long
name|curTime
init|=
name|now
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|rightNow
operator|&&
operator|(
name|curTime
operator|-
name|lastStatusReport
operator|<
literal|20
operator|*
literal|1000
operator|)
condition|)
return|return;
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|info
argument_list|(
name|msg
operator|+
literal|" \n"
operator|+
name|getTurnOffTip
argument_list|()
argument_list|)
expr_stmt|;
name|lastStatusReport
operator|=
name|curTime
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|String
name|resText
init|=
literal|"Current safe blocks = "
operator|+
name|blockSafe
operator|+
literal|". Target blocks = "
operator|+
name|blockThreshold
operator|+
literal|" for threshold = %"
operator|+
name|threshold
operator|+
literal|". Minimal replication = "
operator|+
name|safeReplication
operator|+
literal|"."
decl_stmt|;
if|if
condition|(
name|reached
operator|>
literal|0
condition|)
name|resText
operator|+=
literal|" Threshold was reached "
operator|+
operator|new
name|Date
argument_list|(
name|reached
argument_list|)
operator|+
literal|"."
expr_stmt|;
return|return
name|resText
return|;
block|}
comment|/**      * Checks consistency of the class state.      * This is costly so only runs if asserts are enabled.      */
DECL|method|doConsistencyCheck ()
specifier|private
name|void
name|doConsistencyCheck
parameter_list|()
block|{
name|boolean
name|assertsOn
init|=
literal|false
decl_stmt|;
assert|assert
name|assertsOn
operator|=
literal|true
assert|;
comment|// set to true if asserts are on
if|if
condition|(
operator|!
name|assertsOn
condition|)
return|return;
if|if
condition|(
name|blockTotal
operator|==
operator|-
literal|1
operator|&&
name|blockSafe
operator|==
operator|-
literal|1
condition|)
block|{
return|return;
comment|// manual safe mode
block|}
name|int
name|activeBlocks
init|=
name|blockManager
operator|.
name|getActiveBlockCount
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|blockTotal
operator|!=
name|activeBlocks
operator|)
operator|&&
operator|!
operator|(
name|blockSafe
operator|>=
literal|0
operator|&&
name|blockSafe
operator|<=
name|blockTotal
operator|)
condition|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|" SafeMode: Inconsistent filesystem state: "
operator|+
literal|"SafeMode data: blockTotal="
operator|+
name|blockTotal
operator|+
literal|" blockSafe="
operator|+
name|blockSafe
operator|+
literal|"; "
operator|+
literal|"BlockManager data: active="
operator|+
name|activeBlocks
argument_list|)
throw|;
block|}
block|}
DECL|method|adjustBlockTotals (int deltaSafe, int deltaTotal)
specifier|private
specifier|synchronized
name|void
name|adjustBlockTotals
parameter_list|(
name|int
name|deltaSafe
parameter_list|,
name|int
name|deltaTotal
parameter_list|)
block|{
if|if
condition|(
operator|!
name|shouldIncrementallyTrackBlocks
condition|)
block|{
return|return;
block|}
assert|assert
name|haEnabled
assert|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Adjusting block totals from "
operator|+
name|blockSafe
operator|+
literal|"/"
operator|+
name|blockTotal
operator|+
literal|" to "
operator|+
operator|(
name|blockSafe
operator|+
name|deltaSafe
operator|)
operator|+
literal|"/"
operator|+
operator|(
name|blockTotal
operator|+
name|deltaTotal
operator|)
argument_list|)
expr_stmt|;
block|}
assert|assert
name|blockSafe
operator|+
name|deltaSafe
operator|>=
literal|0
operator|:
literal|"Can't reduce blockSafe "
operator|+
name|blockSafe
operator|+
literal|" by "
operator|+
name|deltaSafe
operator|+
literal|": would be negative"
assert|;
assert|assert
name|blockTotal
operator|+
name|deltaTotal
operator|>=
literal|0
operator|:
literal|"Can't reduce blockTotal "
operator|+
name|blockTotal
operator|+
literal|" by "
operator|+
name|deltaTotal
operator|+
literal|": would be negative"
assert|;
name|blockSafe
operator|+=
name|deltaSafe
expr_stmt|;
name|setBlockTotal
argument_list|(
name|blockTotal
operator|+
name|deltaTotal
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Periodically check whether it is time to leave safe mode.    * This thread starts when the threshold level is reached.    *    */
DECL|class|SafeModeMonitor
class|class
name|SafeModeMonitor
implements|implements
name|Runnable
block|{
comment|/** interval in msec for checking safe mode: {@value} */
DECL|field|recheckInterval
specifier|private
specifier|static
specifier|final
name|long
name|recheckInterval
init|=
literal|1000
decl_stmt|;
comment|/**      */
annotation|@
name|Override
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
while|while
condition|(
name|fsRunning
operator|&&
operator|(
name|safeMode
operator|!=
literal|null
operator|&&
operator|!
name|safeMode
operator|.
name|canLeave
argument_list|()
operator|)
condition|)
block|{
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|recheckInterval
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{         }
block|}
if|if
condition|(
operator|!
name|fsRunning
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"NameNode is being shutdown, exit SafeModeMonitor thread"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// leave safe mode and stop the monitor
name|leaveSafeMode
argument_list|()
expr_stmt|;
block|}
name|smmthread
operator|=
literal|null
expr_stmt|;
block|}
block|}
DECL|method|setSafeMode (SafeModeAction action)
name|boolean
name|setSafeMode
parameter_list|(
name|SafeModeAction
name|action
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|action
operator|!=
name|SafeModeAction
operator|.
name|SAFEMODE_GET
condition|)
block|{
name|checkSuperuserPrivilege
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|action
condition|)
block|{
case|case
name|SAFEMODE_LEAVE
case|:
comment|// leave safe mode
name|leaveSafeMode
argument_list|()
expr_stmt|;
break|break;
case|case
name|SAFEMODE_ENTER
case|:
comment|// enter safe mode
name|enterSafeMode
argument_list|(
literal|false
argument_list|)
expr_stmt|;
break|break;
default|default:
name|LOG
operator|.
name|error
argument_list|(
literal|"Unexpected safe mode action"
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|isInSafeMode
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|checkSafeMode ()
specifier|public
name|void
name|checkSafeMode
parameter_list|()
block|{
comment|// safeMode is volatile, and may be set to null at any time
name|SafeModeInfo
name|safeMode
init|=
name|this
operator|.
name|safeMode
decl_stmt|;
if|if
condition|(
name|safeMode
operator|!=
literal|null
condition|)
block|{
name|safeMode
operator|.
name|checkMode
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|isInSafeMode ()
specifier|public
name|boolean
name|isInSafeMode
parameter_list|()
block|{
comment|// safeMode is volatile, and may be set to null at any time
name|SafeModeInfo
name|safeMode
init|=
name|this
operator|.
name|safeMode
decl_stmt|;
if|if
condition|(
name|safeMode
operator|==
literal|null
condition|)
return|return
literal|false
return|;
return|return
name|safeMode
operator|.
name|isOn
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|isInStartupSafeMode ()
specifier|public
name|boolean
name|isInStartupSafeMode
parameter_list|()
block|{
comment|// safeMode is volatile, and may be set to null at any time
name|SafeModeInfo
name|safeMode
init|=
name|this
operator|.
name|safeMode
decl_stmt|;
if|if
condition|(
name|safeMode
operator|==
literal|null
condition|)
return|return
literal|false
return|;
return|return
operator|!
name|safeMode
operator|.
name|isManual
argument_list|()
operator|&&
name|safeMode
operator|.
name|isOn
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|isPopulatingReplQueues ()
specifier|public
name|boolean
name|isPopulatingReplQueues
parameter_list|()
block|{
if|if
condition|(
operator|!
name|shouldPopulateReplQueues
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// safeMode is volatile, and may be set to null at any time
name|SafeModeInfo
name|safeMode
init|=
name|this
operator|.
name|safeMode
decl_stmt|;
if|if
condition|(
name|safeMode
operator|==
literal|null
condition|)
return|return
literal|true
return|;
return|return
name|safeMode
operator|.
name|isPopulatingReplQueues
argument_list|()
return|;
block|}
DECL|method|shouldPopulateReplQueues ()
specifier|private
name|boolean
name|shouldPopulateReplQueues
parameter_list|()
block|{
if|if
condition|(
name|haContext
operator|==
literal|null
operator|||
name|haContext
operator|.
name|getState
argument_list|()
operator|==
literal|null
condition|)
return|return
literal|false
return|;
return|return
name|haContext
operator|.
name|getState
argument_list|()
operator|.
name|shouldPopulateReplQueues
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|incrementSafeBlockCount (int replication)
specifier|public
name|void
name|incrementSafeBlockCount
parameter_list|(
name|int
name|replication
parameter_list|)
block|{
comment|// safeMode is volatile, and may be set to null at any time
name|SafeModeInfo
name|safeMode
init|=
name|this
operator|.
name|safeMode
decl_stmt|;
if|if
condition|(
name|safeMode
operator|==
literal|null
condition|)
return|return;
name|safeMode
operator|.
name|incrementSafeBlockCount
argument_list|(
operator|(
name|short
operator|)
name|replication
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|decrementSafeBlockCount (Block b)
specifier|public
name|void
name|decrementSafeBlockCount
parameter_list|(
name|Block
name|b
parameter_list|)
block|{
comment|// safeMode is volatile, and may be set to null at any time
name|SafeModeInfo
name|safeMode
init|=
name|this
operator|.
name|safeMode
decl_stmt|;
if|if
condition|(
name|safeMode
operator|==
literal|null
condition|)
comment|// mostly true
return|return;
name|BlockInfo
name|storedBlock
init|=
name|blockManager
operator|.
name|getStoredBlock
argument_list|(
name|b
argument_list|)
decl_stmt|;
if|if
condition|(
name|storedBlock
operator|.
name|isComplete
argument_list|()
condition|)
block|{
name|safeMode
operator|.
name|decrementSafeBlockCount
argument_list|(
operator|(
name|short
operator|)
name|blockManager
operator|.
name|countNodes
argument_list|(
name|b
argument_list|)
operator|.
name|liveReplicas
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Adjust the total number of blocks safe and expected during safe mode.    * If safe mode is not currently on, this is a no-op.    * @param deltaSafe the change in number of safe blocks    * @param deltaTotal the change i nnumber of total blocks expected    */
annotation|@
name|Override
DECL|method|adjustSafeModeBlockTotals (int deltaSafe, int deltaTotal)
specifier|public
name|void
name|adjustSafeModeBlockTotals
parameter_list|(
name|int
name|deltaSafe
parameter_list|,
name|int
name|deltaTotal
parameter_list|)
block|{
comment|// safeMode is volatile, and may be set to null at any time
name|SafeModeInfo
name|safeMode
init|=
name|this
operator|.
name|safeMode
decl_stmt|;
if|if
condition|(
name|safeMode
operator|==
literal|null
condition|)
return|return;
name|safeMode
operator|.
name|adjustBlockTotals
argument_list|(
name|deltaSafe
argument_list|,
name|deltaTotal
argument_list|)
expr_stmt|;
block|}
comment|/**    * Set the total number of blocks in the system.     */
DECL|method|setBlockTotal ()
specifier|public
name|void
name|setBlockTotal
parameter_list|()
block|{
comment|// safeMode is volatile, and may be set to null at any time
name|SafeModeInfo
name|safeMode
init|=
name|this
operator|.
name|safeMode
decl_stmt|;
if|if
condition|(
name|safeMode
operator|==
literal|null
condition|)
return|return;
name|safeMode
operator|.
name|setBlockTotal
argument_list|(
operator|(
name|int
operator|)
name|getCompleteBlocksTotal
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Get the total number of blocks in the system.     */
annotation|@
name|Override
comment|// FSNamesystemMBean
annotation|@
name|Metric
DECL|method|getBlocksTotal ()
specifier|public
name|long
name|getBlocksTotal
parameter_list|()
block|{
return|return
name|blockManager
operator|.
name|getTotalBlocks
argument_list|()
return|;
block|}
comment|/**    * Get the total number of COMPLETE blocks in the system.    * For safe mode only complete blocks are counted.    */
DECL|method|getCompleteBlocksTotal ()
specifier|private
name|long
name|getCompleteBlocksTotal
parameter_list|()
block|{
comment|// Calculate number of blocks under construction
name|long
name|numUCBlocks
init|=
literal|0
decl_stmt|;
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
for|for
control|(
name|Lease
name|lease
range|:
name|leaseManager
operator|.
name|getSortedLeases
argument_list|()
control|)
block|{
for|for
control|(
name|String
name|path
range|:
name|lease
operator|.
name|getPaths
argument_list|()
control|)
block|{
specifier|final
name|INodeFileUnderConstruction
name|cons
decl_stmt|;
try|try
block|{
name|cons
operator|=
name|INodeFileUnderConstruction
operator|.
name|valueOf
argument_list|(
name|dir
operator|.
name|getINode
argument_list|(
name|path
argument_list|)
argument_list|,
name|path
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnresolvedLinkException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"Lease files should reside on this FS"
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
name|BlockInfo
index|[]
name|blocks
init|=
name|cons
operator|.
name|getBlocks
argument_list|()
decl_stmt|;
if|if
condition|(
name|blocks
operator|==
literal|null
condition|)
continue|continue;
for|for
control|(
name|BlockInfo
name|b
range|:
name|blocks
control|)
block|{
if|if
condition|(
operator|!
name|b
operator|.
name|isComplete
argument_list|()
condition|)
name|numUCBlocks
operator|++
expr_stmt|;
block|}
block|}
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Number of blocks under construction: "
operator|+
name|numUCBlocks
argument_list|)
expr_stmt|;
return|return
name|getBlocksTotal
argument_list|()
operator|-
name|numUCBlocks
return|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Enter safe mode manually.    * @throws IOException    */
DECL|method|enterSafeMode (boolean resourcesLow)
name|void
name|enterSafeMode
parameter_list|(
name|boolean
name|resourcesLow
parameter_list|)
throws|throws
name|IOException
block|{
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
comment|// Stop the secret manager, since rolling the master key would
comment|// try to write to the edit log
name|stopSecretManager
argument_list|()
expr_stmt|;
comment|// Ensure that any concurrent operations have been fully synced
comment|// before entering safe mode. This ensures that the FSImage
comment|// is entirely stable on disk as soon as we're in safe mode.
name|boolean
name|isEditlogOpenForWrite
init|=
name|getEditLog
argument_list|()
operator|.
name|isOpenForWrite
argument_list|()
decl_stmt|;
comment|// Before Editlog is in OpenForWrite mode, editLogStream will be null. So,
comment|// logSyncAll call can be called only when Edlitlog is in OpenForWrite mode
if|if
condition|(
name|isEditlogOpenForWrite
condition|)
block|{
name|getEditLog
argument_list|()
operator|.
name|logSyncAll
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|isInSafeMode
argument_list|()
condition|)
block|{
name|safeMode
operator|=
operator|new
name|SafeModeInfo
argument_list|(
name|resourcesLow
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|resourcesLow
condition|)
block|{
name|safeMode
operator|.
name|setResourcesLow
argument_list|()
expr_stmt|;
block|}
name|safeMode
operator|.
name|setManual
argument_list|()
expr_stmt|;
if|if
condition|(
name|isEditlogOpenForWrite
condition|)
block|{
name|getEditLog
argument_list|()
operator|.
name|logSyncAll
argument_list|()
expr_stmt|;
block|}
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|info
argument_list|(
literal|"STATE* Safe mode is ON"
operator|+
name|safeMode
operator|.
name|getTurnOffTip
argument_list|()
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Leave safe mode.    * @throws IOException    */
DECL|method|leaveSafeMode ()
name|void
name|leaveSafeMode
parameter_list|()
block|{
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
operator|!
name|isInSafeMode
argument_list|()
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|info
argument_list|(
literal|"STATE* Safe mode is already OFF"
argument_list|)
expr_stmt|;
return|return;
block|}
name|safeMode
operator|.
name|leave
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|getSafeModeTip ()
name|String
name|getSafeModeTip
parameter_list|()
block|{
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
operator|!
name|isInSafeMode
argument_list|()
condition|)
block|{
return|return
literal|""
return|;
block|}
return|return
name|safeMode
operator|.
name|getTurnOffTip
argument_list|()
return|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|rollEditLog ()
name|CheckpointSignature
name|rollEditLog
parameter_list|()
throws|throws
name|IOException
block|{
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|JOURNAL
argument_list|)
expr_stmt|;
name|checkSuperuserPrivilege
argument_list|()
expr_stmt|;
if|if
condition|(
name|isInSafeMode
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SafeModeException
argument_list|(
literal|"Log not rolled"
argument_list|,
name|safeMode
argument_list|)
throw|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Roll Edit Log from "
operator|+
name|Server
operator|.
name|getRemoteAddress
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|getFSImage
argument_list|()
operator|.
name|rollEditLog
argument_list|()
return|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|startCheckpoint ( NamenodeRegistration bnReg, NamenodeRegistration nnReg)
name|NamenodeCommand
name|startCheckpoint
parameter_list|(
name|NamenodeRegistration
name|bnReg
parameter_list|,
comment|// backup node
name|NamenodeRegistration
name|nnReg
parameter_list|)
comment|// active name-node
throws|throws
name|IOException
block|{
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|CHECKPOINT
argument_list|)
expr_stmt|;
if|if
condition|(
name|isInSafeMode
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SafeModeException
argument_list|(
literal|"Checkpoint not started"
argument_list|,
name|safeMode
argument_list|)
throw|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Start checkpoint for "
operator|+
name|bnReg
operator|.
name|getAddress
argument_list|()
argument_list|)
expr_stmt|;
name|NamenodeCommand
name|cmd
init|=
name|getFSImage
argument_list|()
operator|.
name|startCheckpoint
argument_list|(
name|bnReg
argument_list|,
name|nnReg
argument_list|)
decl_stmt|;
name|getEditLog
argument_list|()
operator|.
name|logSync
argument_list|()
expr_stmt|;
return|return
name|cmd
return|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|endCheckpoint (NamenodeRegistration registration, CheckpointSignature sig)
name|void
name|endCheckpoint
parameter_list|(
name|NamenodeRegistration
name|registration
parameter_list|,
name|CheckpointSignature
name|sig
parameter_list|)
throws|throws
name|IOException
block|{
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|CHECKPOINT
argument_list|)
expr_stmt|;
if|if
condition|(
name|isInSafeMode
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SafeModeException
argument_list|(
literal|"Checkpoint not ended"
argument_list|,
name|safeMode
argument_list|)
throw|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"End checkpoint for "
operator|+
name|registration
operator|.
name|getAddress
argument_list|()
argument_list|)
expr_stmt|;
name|getFSImage
argument_list|()
operator|.
name|endCheckpoint
argument_list|(
name|sig
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|createFsOwnerPermissions (FsPermission permission)
name|PermissionStatus
name|createFsOwnerPermissions
parameter_list|(
name|FsPermission
name|permission
parameter_list|)
block|{
return|return
operator|new
name|PermissionStatus
argument_list|(
name|fsOwner
operator|.
name|getShortUserName
argument_list|()
argument_list|,
name|supergroup
argument_list|,
name|permission
argument_list|)
return|;
block|}
DECL|method|checkOwner (String path )
specifier|private
name|FSPermissionChecker
name|checkOwner
parameter_list|(
name|String
name|path
parameter_list|)
throws|throws
name|AccessControlException
throws|,
name|UnresolvedLinkException
block|{
return|return
name|checkPermission
argument_list|(
name|path
argument_list|,
literal|true
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
return|;
block|}
DECL|method|checkPathAccess (String path, FsAction access )
specifier|private
name|FSPermissionChecker
name|checkPathAccess
parameter_list|(
name|String
name|path
parameter_list|,
name|FsAction
name|access
parameter_list|)
throws|throws
name|AccessControlException
throws|,
name|UnresolvedLinkException
block|{
return|return
name|checkPermission
argument_list|(
name|path
argument_list|,
literal|false
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|access
argument_list|,
literal|null
argument_list|)
return|;
block|}
DECL|method|checkParentAccess (String path, FsAction access )
specifier|private
name|FSPermissionChecker
name|checkParentAccess
parameter_list|(
name|String
name|path
parameter_list|,
name|FsAction
name|access
parameter_list|)
throws|throws
name|AccessControlException
throws|,
name|UnresolvedLinkException
block|{
return|return
name|checkPermission
argument_list|(
name|path
argument_list|,
literal|false
argument_list|,
literal|null
argument_list|,
name|access
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
return|;
block|}
DECL|method|checkAncestorAccess (String path, FsAction access )
specifier|private
name|FSPermissionChecker
name|checkAncestorAccess
parameter_list|(
name|String
name|path
parameter_list|,
name|FsAction
name|access
parameter_list|)
throws|throws
name|AccessControlException
throws|,
name|UnresolvedLinkException
block|{
return|return
name|checkPermission
argument_list|(
name|path
argument_list|,
literal|false
argument_list|,
name|access
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
return|;
block|}
DECL|method|checkTraverse (String path )
specifier|private
name|FSPermissionChecker
name|checkTraverse
parameter_list|(
name|String
name|path
parameter_list|)
throws|throws
name|AccessControlException
throws|,
name|UnresolvedLinkException
block|{
return|return
name|checkPermission
argument_list|(
name|path
argument_list|,
literal|false
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|checkSuperuserPrivilege ()
specifier|public
name|void
name|checkSuperuserPrivilege
parameter_list|()
throws|throws
name|AccessControlException
block|{
if|if
condition|(
name|isPermissionEnabled
condition|)
block|{
name|FSPermissionChecker
operator|.
name|checkSuperuserPrivilege
argument_list|(
name|fsOwner
argument_list|,
name|supergroup
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Check whether current user have permissions to access the path.    * For more details of the parameters, see    * {@link FSPermissionChecker#checkPermission(String, INodeDirectory, boolean, FsAction, FsAction, FsAction, FsAction)}.    */
DECL|method|checkPermission (String path, boolean doCheckOwner, FsAction ancestorAccess, FsAction parentAccess, FsAction access, FsAction subAccess)
specifier|private
name|FSPermissionChecker
name|checkPermission
parameter_list|(
name|String
name|path
parameter_list|,
name|boolean
name|doCheckOwner
parameter_list|,
name|FsAction
name|ancestorAccess
parameter_list|,
name|FsAction
name|parentAccess
parameter_list|,
name|FsAction
name|access
parameter_list|,
name|FsAction
name|subAccess
parameter_list|)
throws|throws
name|AccessControlException
throws|,
name|UnresolvedLinkException
block|{
name|FSPermissionChecker
name|pc
init|=
operator|new
name|FSPermissionChecker
argument_list|(
name|fsOwner
operator|.
name|getShortUserName
argument_list|()
argument_list|,
name|supergroup
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|pc
operator|.
name|isSuper
condition|)
block|{
name|dir
operator|.
name|waitForReady
argument_list|()
expr_stmt|;
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
name|pc
operator|.
name|checkPermission
argument_list|(
name|path
argument_list|,
name|dir
operator|.
name|rootDir
argument_list|,
name|doCheckOwner
argument_list|,
name|ancestorAccess
argument_list|,
name|parentAccess
argument_list|,
name|access
argument_list|,
name|subAccess
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|pc
return|;
block|}
comment|/**    * Check to see if we have exceeded the limit on the number    * of inodes.    */
DECL|method|checkFsObjectLimit ()
name|void
name|checkFsObjectLimit
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|maxFsObjects
operator|!=
literal|0
operator|&&
name|maxFsObjects
operator|<=
name|dir
operator|.
name|totalInodes
argument_list|()
operator|+
name|getBlocksTotal
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Exceeded the configured number of objects "
operator|+
name|maxFsObjects
operator|+
literal|" in the filesystem."
argument_list|)
throw|;
block|}
block|}
comment|/**    * Get the total number of objects in the system.     */
DECL|method|getMaxObjects ()
name|long
name|getMaxObjects
parameter_list|()
block|{
return|return
name|maxFsObjects
return|;
block|}
annotation|@
name|Override
comment|// FSNamesystemMBean
annotation|@
name|Metric
DECL|method|getFilesTotal ()
specifier|public
name|long
name|getFilesTotal
parameter_list|()
block|{
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
return|return
name|this
operator|.
name|dir
operator|.
name|totalInodes
argument_list|()
return|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
comment|// FSNamesystemMBean
annotation|@
name|Metric
DECL|method|getPendingReplicationBlocks ()
specifier|public
name|long
name|getPendingReplicationBlocks
parameter_list|()
block|{
return|return
name|blockManager
operator|.
name|getPendingReplicationBlocksCount
argument_list|()
return|;
block|}
annotation|@
name|Override
comment|// FSNamesystemMBean
annotation|@
name|Metric
DECL|method|getUnderReplicatedBlocks ()
specifier|public
name|long
name|getUnderReplicatedBlocks
parameter_list|()
block|{
return|return
name|blockManager
operator|.
name|getUnderReplicatedBlocksCount
argument_list|()
return|;
block|}
comment|/** Returns number of blocks with corrupt replicas */
annotation|@
name|Metric
argument_list|(
block|{
literal|"CorruptBlocks"
block|,
literal|"Number of blocks with corrupt replicas"
block|}
argument_list|)
DECL|method|getCorruptReplicaBlocks ()
specifier|public
name|long
name|getCorruptReplicaBlocks
parameter_list|()
block|{
return|return
name|blockManager
operator|.
name|getCorruptReplicaBlocksCount
argument_list|()
return|;
block|}
annotation|@
name|Override
comment|// FSNamesystemMBean
annotation|@
name|Metric
DECL|method|getScheduledReplicationBlocks ()
specifier|public
name|long
name|getScheduledReplicationBlocks
parameter_list|()
block|{
return|return
name|blockManager
operator|.
name|getScheduledReplicationBlocksCount
argument_list|()
return|;
block|}
annotation|@
name|Metric
DECL|method|getPendingDeletionBlocks ()
specifier|public
name|long
name|getPendingDeletionBlocks
parameter_list|()
block|{
return|return
name|blockManager
operator|.
name|getPendingDeletionBlocksCount
argument_list|()
return|;
block|}
annotation|@
name|Metric
DECL|method|getExcessBlocks ()
specifier|public
name|long
name|getExcessBlocks
parameter_list|()
block|{
return|return
name|blockManager
operator|.
name|getExcessBlocksCount
argument_list|()
return|;
block|}
comment|// HA-only metric
annotation|@
name|Metric
DECL|method|getPostponedMisreplicatedBlocks ()
specifier|public
name|long
name|getPostponedMisreplicatedBlocks
parameter_list|()
block|{
return|return
name|blockManager
operator|.
name|getPostponedMisreplicatedBlocksCount
argument_list|()
return|;
block|}
comment|// HA-only metric
annotation|@
name|Metric
DECL|method|getPendingDataNodeMessageCount ()
specifier|public
name|int
name|getPendingDataNodeMessageCount
parameter_list|()
block|{
return|return
name|blockManager
operator|.
name|getPendingDataNodeMessageCount
argument_list|()
return|;
block|}
comment|// HA-only metric
annotation|@
name|Metric
DECL|method|getHAState ()
specifier|public
name|String
name|getHAState
parameter_list|()
block|{
return|return
name|haContext
operator|.
name|getState
argument_list|()
operator|.
name|toString
argument_list|()
return|;
block|}
comment|// HA-only metric
annotation|@
name|Metric
DECL|method|getMillisSinceLastLoadedEdits ()
specifier|public
name|long
name|getMillisSinceLastLoadedEdits
parameter_list|()
block|{
if|if
condition|(
name|isInStandbyState
argument_list|()
operator|&&
name|editLogTailer
operator|!=
literal|null
condition|)
block|{
return|return
name|now
argument_list|()
operator|-
name|editLogTailer
operator|.
name|getLastLoadTimestamp
argument_list|()
return|;
block|}
else|else
block|{
return|return
literal|0
return|;
block|}
block|}
annotation|@
name|Metric
DECL|method|getBlockCapacity ()
specifier|public
name|int
name|getBlockCapacity
parameter_list|()
block|{
return|return
name|blockManager
operator|.
name|getCapacity
argument_list|()
return|;
block|}
annotation|@
name|Override
comment|// FSNamesystemMBean
DECL|method|getFSState ()
specifier|public
name|String
name|getFSState
parameter_list|()
block|{
return|return
name|isInSafeMode
argument_list|()
condition|?
literal|"safeMode"
else|:
literal|"Operational"
return|;
block|}
DECL|field|mbeanName
specifier|private
name|ObjectName
name|mbeanName
decl_stmt|;
comment|/**    * Register the FSNamesystem MBean using the name    *        "hadoop:service=NameNode,name=FSNamesystemState"    */
DECL|method|registerMBean ()
specifier|private
name|void
name|registerMBean
parameter_list|()
block|{
comment|// We can only implement one MXBean interface, so we keep the old one.
try|try
block|{
name|StandardMBean
name|bean
init|=
operator|new
name|StandardMBean
argument_list|(
name|this
argument_list|,
name|FSNamesystemMBean
operator|.
name|class
argument_list|)
decl_stmt|;
name|mbeanName
operator|=
name|MBeans
operator|.
name|register
argument_list|(
literal|"NameNode"
argument_list|,
literal|"FSNamesystemState"
argument_list|,
name|bean
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NotCompliantMBeanException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Bad MBean setup"
argument_list|,
name|e
argument_list|)
throw|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Registered FSNamesystemState MBean"
argument_list|)
expr_stmt|;
block|}
comment|/**    * shutdown FSNamesystem    */
DECL|method|shutdown ()
name|void
name|shutdown
parameter_list|()
block|{
if|if
condition|(
name|mbeanName
operator|!=
literal|null
condition|)
name|MBeans
operator|.
name|unregister
argument_list|(
name|mbeanName
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
comment|// FSNamesystemMBean
DECL|method|getNumLiveDataNodes ()
specifier|public
name|int
name|getNumLiveDataNodes
parameter_list|()
block|{
return|return
name|getBlockManager
argument_list|()
operator|.
name|getDatanodeManager
argument_list|()
operator|.
name|getNumLiveDataNodes
argument_list|()
return|;
block|}
annotation|@
name|Override
comment|// FSNamesystemMBean
DECL|method|getNumDeadDataNodes ()
specifier|public
name|int
name|getNumDeadDataNodes
parameter_list|()
block|{
return|return
name|getBlockManager
argument_list|()
operator|.
name|getDatanodeManager
argument_list|()
operator|.
name|getNumDeadDataNodes
argument_list|()
return|;
block|}
annotation|@
name|Override
comment|// FSNamesystemMBean
annotation|@
name|Metric
argument_list|(
block|{
literal|"StaleDataNodes"
block|,
literal|"Number of datanodes marked stale due to delayed heartbeat"
block|}
argument_list|)
DECL|method|getNumStaleDataNodes ()
specifier|public
name|int
name|getNumStaleDataNodes
parameter_list|()
block|{
return|return
name|getBlockManager
argument_list|()
operator|.
name|getDatanodeManager
argument_list|()
operator|.
name|getNumStaleNodes
argument_list|()
return|;
block|}
comment|/**    * Sets the generation stamp for this filesystem    */
DECL|method|setGenerationStamp (long stamp)
name|void
name|setGenerationStamp
parameter_list|(
name|long
name|stamp
parameter_list|)
block|{
name|generationStamp
operator|.
name|setCurrentValue
argument_list|(
name|stamp
argument_list|)
expr_stmt|;
block|}
comment|/**    * Gets the generation stamp for this filesystem    */
DECL|method|getGenerationStamp ()
name|long
name|getGenerationStamp
parameter_list|()
block|{
return|return
name|generationStamp
operator|.
name|getCurrentValue
argument_list|()
return|;
block|}
comment|/**    * Increments, logs and then returns the stamp    */
DECL|method|nextGenerationStamp ()
specifier|private
name|long
name|nextGenerationStamp
parameter_list|()
throws|throws
name|SafeModeException
block|{
assert|assert
name|hasWriteLock
argument_list|()
assert|;
if|if
condition|(
name|isInSafeMode
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SafeModeException
argument_list|(
literal|"Cannot get next generation stamp"
argument_list|,
name|safeMode
argument_list|)
throw|;
block|}
specifier|final
name|long
name|gs
init|=
name|generationStamp
operator|.
name|nextValue
argument_list|()
decl_stmt|;
name|getEditLog
argument_list|()
operator|.
name|logGenerationStamp
argument_list|(
name|gs
argument_list|)
expr_stmt|;
comment|// NB: callers sync the log
return|return
name|gs
return|;
block|}
DECL|method|checkUCBlock (ExtendedBlock block, String clientName)
specifier|private
name|INodeFileUnderConstruction
name|checkUCBlock
parameter_list|(
name|ExtendedBlock
name|block
parameter_list|,
name|String
name|clientName
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|hasWriteLock
argument_list|()
assert|;
if|if
condition|(
name|isInSafeMode
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SafeModeException
argument_list|(
literal|"Cannot get a new generation stamp and an "
operator|+
literal|"access token for block "
operator|+
name|block
argument_list|,
name|safeMode
argument_list|)
throw|;
block|}
comment|// check stored block state
name|BlockInfo
name|storedBlock
init|=
name|blockManager
operator|.
name|getStoredBlock
argument_list|(
name|ExtendedBlock
operator|.
name|getLocalBlock
argument_list|(
name|block
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|storedBlock
operator|==
literal|null
operator|||
name|storedBlock
operator|.
name|getBlockUCState
argument_list|()
operator|!=
name|BlockUCState
operator|.
name|UNDER_CONSTRUCTION
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|block
operator|+
literal|" does not exist or is not under Construction"
operator|+
name|storedBlock
argument_list|)
throw|;
block|}
comment|// check file inode
name|INodeFile
name|file
init|=
operator|(
name|INodeFile
operator|)
name|storedBlock
operator|.
name|getBlockCollection
argument_list|()
decl_stmt|;
if|if
condition|(
name|file
operator|==
literal|null
operator|||
operator|!
name|file
operator|.
name|isUnderConstruction
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"The file "
operator|+
name|storedBlock
operator|+
literal|" belonged to does not exist or it is not under construction."
argument_list|)
throw|;
block|}
comment|// check lease
name|INodeFileUnderConstruction
name|pendingFile
init|=
operator|(
name|INodeFileUnderConstruction
operator|)
name|file
decl_stmt|;
if|if
condition|(
name|clientName
operator|==
literal|null
operator|||
operator|!
name|clientName
operator|.
name|equals
argument_list|(
name|pendingFile
operator|.
name|getClientName
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|LeaseExpiredException
argument_list|(
literal|"Lease mismatch: "
operator|+
name|block
operator|+
literal|" is accessed by a non lease holder "
operator|+
name|clientName
argument_list|)
throw|;
block|}
return|return
name|pendingFile
return|;
block|}
comment|/**    * Client is reporting some bad block locations.    */
DECL|method|reportBadBlocks (LocatedBlock[] blocks)
name|void
name|reportBadBlocks
parameter_list|(
name|LocatedBlock
index|[]
name|blocks
parameter_list|)
throws|throws
name|IOException
block|{
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|info
argument_list|(
literal|"*DIR* reportBadBlocks"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|blocks
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|ExtendedBlock
name|blk
init|=
name|blocks
index|[
name|i
index|]
operator|.
name|getBlock
argument_list|()
decl_stmt|;
name|DatanodeInfo
index|[]
name|nodes
init|=
name|blocks
index|[
name|i
index|]
operator|.
name|getLocations
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|nodes
operator|.
name|length
condition|;
name|j
operator|++
control|)
block|{
name|DatanodeInfo
name|dn
init|=
name|nodes
index|[
name|j
index|]
decl_stmt|;
name|blockManager
operator|.
name|findAndMarkBlockAsCorrupt
argument_list|(
name|blk
argument_list|,
name|dn
argument_list|,
literal|"client machine reported it"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Get a new generation stamp together with an access token for     * a block under construction    *     * This method is called for recovering a failed pipeline or setting up    * a pipeline to append to a block.    *     * @param block a block    * @param clientName the name of a client    * @return a located block with a new generation stamp and an access token    * @throws IOException if any error occurs    */
DECL|method|updateBlockForPipeline (ExtendedBlock block, String clientName)
name|LocatedBlock
name|updateBlockForPipeline
parameter_list|(
name|ExtendedBlock
name|block
parameter_list|,
name|String
name|clientName
parameter_list|)
throws|throws
name|IOException
block|{
name|LocatedBlock
name|locatedBlock
decl_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
comment|// check vadility of parameters
name|checkUCBlock
argument_list|(
name|block
argument_list|,
name|clientName
argument_list|)
expr_stmt|;
comment|// get a new generation stamp and an access token
name|block
operator|.
name|setGenerationStamp
argument_list|(
name|nextGenerationStamp
argument_list|()
argument_list|)
expr_stmt|;
name|locatedBlock
operator|=
operator|new
name|LocatedBlock
argument_list|(
name|block
argument_list|,
operator|new
name|DatanodeInfo
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|blockManager
operator|.
name|setBlockToken
argument_list|(
name|locatedBlock
argument_list|,
name|AccessMode
operator|.
name|WRITE
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
comment|// Ensure we record the new generation stamp
name|getEditLog
argument_list|()
operator|.
name|logSync
argument_list|()
expr_stmt|;
return|return
name|locatedBlock
return|;
block|}
comment|/**    * Update a pipeline for a block under construction    *     * @param clientName the name of the client    * @param oldblock and old block    * @param newBlock a new block with a new generation stamp and length    * @param newNodes datanodes in the pipeline    * @throws IOException if any error occurs    */
DECL|method|updatePipeline (String clientName, ExtendedBlock oldBlock, ExtendedBlock newBlock, DatanodeID[] newNodes)
name|void
name|updatePipeline
parameter_list|(
name|String
name|clientName
parameter_list|,
name|ExtendedBlock
name|oldBlock
parameter_list|,
name|ExtendedBlock
name|newBlock
parameter_list|,
name|DatanodeID
index|[]
name|newNodes
parameter_list|)
throws|throws
name|IOException
block|{
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|isInSafeMode
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SafeModeException
argument_list|(
literal|"Pipeline not updated"
argument_list|,
name|safeMode
argument_list|)
throw|;
block|}
assert|assert
name|newBlock
operator|.
name|getBlockId
argument_list|()
operator|==
name|oldBlock
operator|.
name|getBlockId
argument_list|()
operator|:
name|newBlock
operator|+
literal|" and "
operator|+
name|oldBlock
operator|+
literal|" has different block identifier"
assert|;
name|LOG
operator|.
name|info
argument_list|(
literal|"updatePipeline(block="
operator|+
name|oldBlock
operator|+
literal|", newGenerationStamp="
operator|+
name|newBlock
operator|.
name|getGenerationStamp
argument_list|()
operator|+
literal|", newLength="
operator|+
name|newBlock
operator|.
name|getNumBytes
argument_list|()
operator|+
literal|", newNodes="
operator|+
name|Arrays
operator|.
name|asList
argument_list|(
name|newNodes
argument_list|)
operator|+
literal|", clientName="
operator|+
name|clientName
operator|+
literal|")"
argument_list|)
expr_stmt|;
name|updatePipelineInternal
argument_list|(
name|clientName
argument_list|,
name|oldBlock
argument_list|,
name|newBlock
argument_list|,
name|newNodes
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
name|getEditLog
argument_list|()
operator|.
name|logSync
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"updatePipeline("
operator|+
name|oldBlock
operator|+
literal|") successfully to "
operator|+
name|newBlock
argument_list|)
expr_stmt|;
block|}
comment|/** @see #updatePipeline(String, ExtendedBlock, ExtendedBlock, DatanodeID[]) */
DECL|method|updatePipelineInternal (String clientName, ExtendedBlock oldBlock, ExtendedBlock newBlock, DatanodeID[] newNodes)
specifier|private
name|void
name|updatePipelineInternal
parameter_list|(
name|String
name|clientName
parameter_list|,
name|ExtendedBlock
name|oldBlock
parameter_list|,
name|ExtendedBlock
name|newBlock
parameter_list|,
name|DatanodeID
index|[]
name|newNodes
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|hasWriteLock
argument_list|()
assert|;
comment|// check the vadility of the block and lease holder name
specifier|final
name|INodeFileUnderConstruction
name|pendingFile
init|=
name|checkUCBlock
argument_list|(
name|oldBlock
argument_list|,
name|clientName
argument_list|)
decl_stmt|;
specifier|final
name|BlockInfoUnderConstruction
name|blockinfo
init|=
operator|(
name|BlockInfoUnderConstruction
operator|)
name|pendingFile
operator|.
name|getLastBlock
argument_list|()
decl_stmt|;
comment|// check new GS& length: this is not expected
if|if
condition|(
name|newBlock
operator|.
name|getGenerationStamp
argument_list|()
operator|<=
name|blockinfo
operator|.
name|getGenerationStamp
argument_list|()
operator|||
name|newBlock
operator|.
name|getNumBytes
argument_list|()
operator|<
name|blockinfo
operator|.
name|getNumBytes
argument_list|()
condition|)
block|{
name|String
name|msg
init|=
literal|"Update "
operator|+
name|oldBlock
operator|+
literal|" (len = "
operator|+
name|blockinfo
operator|.
name|getNumBytes
argument_list|()
operator|+
literal|") to an older state: "
operator|+
name|newBlock
operator|+
literal|" (len = "
operator|+
name|newBlock
operator|.
name|getNumBytes
argument_list|()
operator|+
literal|")"
decl_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
name|msg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
name|msg
argument_list|)
throw|;
block|}
comment|// Update old block with the new generation stamp and new length
name|blockinfo
operator|.
name|setGenerationStamp
argument_list|(
name|newBlock
operator|.
name|getGenerationStamp
argument_list|()
argument_list|)
expr_stmt|;
name|blockinfo
operator|.
name|setNumBytes
argument_list|(
name|newBlock
operator|.
name|getNumBytes
argument_list|()
argument_list|)
expr_stmt|;
comment|// find the DatanodeDescriptor objects
specifier|final
name|DatanodeManager
name|dm
init|=
name|getBlockManager
argument_list|()
operator|.
name|getDatanodeManager
argument_list|()
decl_stmt|;
name|DatanodeDescriptor
index|[]
name|descriptors
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|newNodes
operator|.
name|length
operator|>
literal|0
condition|)
block|{
name|descriptors
operator|=
operator|new
name|DatanodeDescriptor
index|[
name|newNodes
operator|.
name|length
index|]
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|newNodes
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|descriptors
index|[
name|i
index|]
operator|=
name|dm
operator|.
name|getDatanode
argument_list|(
name|newNodes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|blockinfo
operator|.
name|setExpectedLocations
argument_list|(
name|descriptors
argument_list|)
expr_stmt|;
name|String
name|src
init|=
name|leaseManager
operator|.
name|findPath
argument_list|(
name|pendingFile
argument_list|)
decl_stmt|;
name|dir
operator|.
name|persistBlocks
argument_list|(
name|src
argument_list|,
name|pendingFile
argument_list|)
expr_stmt|;
block|}
comment|// rename was successful. If any part of the renamed subtree had
comment|// files that were being written to, update with new filename.
DECL|method|unprotectedChangeLease (String src, String dst)
name|void
name|unprotectedChangeLease
parameter_list|(
name|String
name|src
parameter_list|,
name|String
name|dst
parameter_list|)
block|{
assert|assert
name|hasWriteLock
argument_list|()
assert|;
name|leaseManager
operator|.
name|changeLease
argument_list|(
name|src
argument_list|,
name|dst
argument_list|)
expr_stmt|;
block|}
comment|/**    * Serializes leases.     */
DECL|method|saveFilesUnderConstruction (DataOutputStream out)
name|void
name|saveFilesUnderConstruction
parameter_list|(
name|DataOutputStream
name|out
parameter_list|)
throws|throws
name|IOException
block|{
comment|// This is run by an inferior thread of saveNamespace, which holds a read
comment|// lock on our behalf. If we took the read lock here, we could block
comment|// for fairness if a writer is waiting on the lock.
synchronized|synchronized
init|(
name|leaseManager
init|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|INodeFileUnderConstruction
argument_list|>
name|nodes
init|=
name|leaseManager
operator|.
name|getINodesUnderConstruction
argument_list|()
decl_stmt|;
name|out
operator|.
name|writeInt
argument_list|(
name|nodes
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
comment|// write the size
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|INodeFileUnderConstruction
argument_list|>
name|entry
range|:
name|nodes
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|FSImageSerialization
operator|.
name|writeINodeUnderConstruction
argument_list|(
name|out
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|,
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Register a Backup name-node, verifying that it belongs    * to the correct namespace, and adding it to the set of    * active journals if necessary.    *     * @param bnReg registration of the new BackupNode    * @param nnReg registration of this NameNode    * @throws IOException if the namespace IDs do not match    */
DECL|method|registerBackupNode (NamenodeRegistration bnReg, NamenodeRegistration nnReg)
name|void
name|registerBackupNode
parameter_list|(
name|NamenodeRegistration
name|bnReg
parameter_list|,
name|NamenodeRegistration
name|nnReg
parameter_list|)
throws|throws
name|IOException
block|{
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
name|getFSImage
argument_list|()
operator|.
name|getStorage
argument_list|()
operator|.
name|getNamespaceID
argument_list|()
operator|!=
name|bnReg
operator|.
name|getNamespaceID
argument_list|()
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Incompatible namespaceIDs: "
operator|+
literal|" Namenode namespaceID = "
operator|+
name|getFSImage
argument_list|()
operator|.
name|getStorage
argument_list|()
operator|.
name|getNamespaceID
argument_list|()
operator|+
literal|"; "
operator|+
name|bnReg
operator|.
name|getRole
argument_list|()
operator|+
literal|" node namespaceID = "
operator|+
name|bnReg
operator|.
name|getNamespaceID
argument_list|()
argument_list|)
throw|;
if|if
condition|(
name|bnReg
operator|.
name|getRole
argument_list|()
operator|==
name|NamenodeRole
operator|.
name|BACKUP
condition|)
block|{
name|getFSImage
argument_list|()
operator|.
name|getEditLog
argument_list|()
operator|.
name|registerBackupNode
argument_list|(
name|bnReg
argument_list|,
name|nnReg
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Release (unregister) backup node.    *<p>    * Find and remove the backup stream corresponding to the node.    * @param registration    * @throws IOException    */
DECL|method|releaseBackupNode (NamenodeRegistration registration)
name|void
name|releaseBackupNode
parameter_list|(
name|NamenodeRegistration
name|registration
parameter_list|)
throws|throws
name|IOException
block|{
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
name|getFSImage
argument_list|()
operator|.
name|getStorage
argument_list|()
operator|.
name|getNamespaceID
argument_list|()
operator|!=
name|registration
operator|.
name|getNamespaceID
argument_list|()
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Incompatible namespaceIDs: "
operator|+
literal|" Namenode namespaceID = "
operator|+
name|getFSImage
argument_list|()
operator|.
name|getStorage
argument_list|()
operator|.
name|getNamespaceID
argument_list|()
operator|+
literal|"; "
operator|+
name|registration
operator|.
name|getRole
argument_list|()
operator|+
literal|" node namespaceID = "
operator|+
name|registration
operator|.
name|getNamespaceID
argument_list|()
argument_list|)
throw|;
name|getEditLog
argument_list|()
operator|.
name|releaseBackupStream
argument_list|(
name|registration
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|class|CorruptFileBlockInfo
specifier|static
class|class
name|CorruptFileBlockInfo
block|{
DECL|field|path
name|String
name|path
decl_stmt|;
DECL|field|block
name|Block
name|block
decl_stmt|;
DECL|method|CorruptFileBlockInfo (String p, Block b)
specifier|public
name|CorruptFileBlockInfo
parameter_list|(
name|String
name|p
parameter_list|,
name|Block
name|b
parameter_list|)
block|{
name|path
operator|=
name|p
expr_stmt|;
name|block
operator|=
name|b
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|block
operator|.
name|getBlockName
argument_list|()
operator|+
literal|"\t"
operator|+
name|path
return|;
block|}
block|}
comment|/**    * @param path Restrict corrupt files to this portion of namespace.    * @param startBlockAfter Support for continuation; the set of files we return    *  back is ordered by blockid; startBlockAfter tells where to start from    * @return a list in which each entry describes a corrupt file/block    * @throws AccessControlException    * @throws IOException    */
DECL|method|listCorruptFileBlocks (String path, String[] cookieTab)
name|Collection
argument_list|<
name|CorruptFileBlockInfo
argument_list|>
name|listCorruptFileBlocks
parameter_list|(
name|String
name|path
parameter_list|,
name|String
index|[]
name|cookieTab
parameter_list|)
throws|throws
name|IOException
block|{
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|READ
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isPopulatingReplQueues
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Cannot run listCorruptFileBlocks because "
operator|+
literal|"replication queues have not been initialized."
argument_list|)
throw|;
block|}
name|checkSuperuserPrivilege
argument_list|()
expr_stmt|;
comment|// print a limited # of corrupt files per call
name|int
name|count
init|=
literal|0
decl_stmt|;
name|ArrayList
argument_list|<
name|CorruptFileBlockInfo
argument_list|>
name|corruptFiles
init|=
operator|new
name|ArrayList
argument_list|<
name|CorruptFileBlockInfo
argument_list|>
argument_list|()
decl_stmt|;
specifier|final
name|Iterator
argument_list|<
name|Block
argument_list|>
name|blkIterator
init|=
name|blockManager
operator|.
name|getCorruptReplicaBlockIterator
argument_list|()
decl_stmt|;
if|if
condition|(
name|cookieTab
operator|==
literal|null
condition|)
block|{
name|cookieTab
operator|=
operator|new
name|String
index|[]
block|{
literal|null
block|}
expr_stmt|;
block|}
name|int
name|skip
init|=
name|getIntCookie
argument_list|(
name|cookieTab
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|skip
operator|&&
name|blkIterator
operator|.
name|hasNext
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|blkIterator
operator|.
name|next
argument_list|()
expr_stmt|;
block|}
while|while
condition|(
name|blkIterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Block
name|blk
init|=
name|blkIterator
operator|.
name|next
argument_list|()
decl_stmt|;
name|INode
name|inode
init|=
operator|(
name|INodeFile
operator|)
name|blockManager
operator|.
name|getBlockCollection
argument_list|(
name|blk
argument_list|)
decl_stmt|;
name|skip
operator|++
expr_stmt|;
if|if
condition|(
name|inode
operator|!=
literal|null
operator|&&
name|blockManager
operator|.
name|countNodes
argument_list|(
name|blk
argument_list|)
operator|.
name|liveReplicas
argument_list|()
operator|==
literal|0
condition|)
block|{
name|String
name|src
init|=
name|FSDirectory
operator|.
name|getFullPathName
argument_list|(
name|inode
argument_list|)
decl_stmt|;
if|if
condition|(
name|src
operator|.
name|startsWith
argument_list|(
name|path
argument_list|)
condition|)
block|{
name|corruptFiles
operator|.
name|add
argument_list|(
operator|new
name|CorruptFileBlockInfo
argument_list|(
name|src
argument_list|,
name|blk
argument_list|)
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
if|if
condition|(
name|count
operator|>=
name|DEFAULT_MAX_CORRUPT_FILEBLOCKS_RETURNED
condition|)
break|break;
block|}
block|}
block|}
name|cookieTab
index|[
literal|0
index|]
operator|=
name|String
operator|.
name|valueOf
argument_list|(
name|skip
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"list corrupt file blocks returned: "
operator|+
name|count
argument_list|)
expr_stmt|;
return|return
name|corruptFiles
return|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Convert string cookie to integer.    */
DECL|method|getIntCookie (String cookie)
specifier|private
specifier|static
name|int
name|getIntCookie
parameter_list|(
name|String
name|cookie
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
if|if
condition|(
name|cookie
operator|==
literal|null
condition|)
block|{
name|c
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
try|try
block|{
name|c
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|cookie
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
name|c
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|c
operator|=
name|Math
operator|.
name|max
argument_list|(
literal|0
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return
name|c
return|;
block|}
comment|/**    * Create delegation token secret manager    */
DECL|method|createDelegationTokenSecretManager ( Configuration conf)
specifier|private
name|DelegationTokenSecretManager
name|createDelegationTokenSecretManager
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
return|return
operator|new
name|DelegationTokenSecretManager
argument_list|(
name|conf
operator|.
name|getLong
argument_list|(
name|DFS_NAMENODE_DELEGATION_KEY_UPDATE_INTERVAL_KEY
argument_list|,
name|DFS_NAMENODE_DELEGATION_KEY_UPDATE_INTERVAL_DEFAULT
argument_list|)
argument_list|,
name|conf
operator|.
name|getLong
argument_list|(
name|DFS_NAMENODE_DELEGATION_TOKEN_MAX_LIFETIME_KEY
argument_list|,
name|DFS_NAMENODE_DELEGATION_TOKEN_MAX_LIFETIME_DEFAULT
argument_list|)
argument_list|,
name|conf
operator|.
name|getLong
argument_list|(
name|DFS_NAMENODE_DELEGATION_TOKEN_RENEW_INTERVAL_KEY
argument_list|,
name|DFS_NAMENODE_DELEGATION_TOKEN_RENEW_INTERVAL_DEFAULT
argument_list|)
argument_list|,
name|DELEGATION_TOKEN_REMOVER_SCAN_INTERVAL
argument_list|,
name|this
argument_list|)
return|;
block|}
comment|/**    * Returns the DelegationTokenSecretManager instance in the namesystem.    * @return delegation token secret manager object    */
DECL|method|getDelegationTokenSecretManager ()
name|DelegationTokenSecretManager
name|getDelegationTokenSecretManager
parameter_list|()
block|{
return|return
name|dtSecretManager
return|;
block|}
comment|/**    * @param renewer    * @return Token<DelegationTokenIdentifier>    * @throws IOException    */
DECL|method|getDelegationToken (Text renewer)
name|Token
argument_list|<
name|DelegationTokenIdentifier
argument_list|>
name|getDelegationToken
parameter_list|(
name|Text
name|renewer
parameter_list|)
throws|throws
name|IOException
block|{
name|Token
argument_list|<
name|DelegationTokenIdentifier
argument_list|>
name|token
decl_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|isInSafeMode
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SafeModeException
argument_list|(
literal|"Cannot issue delegation token"
argument_list|,
name|safeMode
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|isAllowedDelegationTokenOp
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Delegation Token can be issued only with kerberos or web authentication"
argument_list|)
throw|;
block|}
if|if
condition|(
name|dtSecretManager
operator|==
literal|null
operator|||
operator|!
name|dtSecretManager
operator|.
name|isRunning
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"trying to get DT with no secret manager running"
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
name|UserGroupInformation
name|ugi
init|=
name|UserGroupInformation
operator|.
name|getCurrentUser
argument_list|()
decl_stmt|;
name|String
name|user
init|=
name|ugi
operator|.
name|getUserName
argument_list|()
decl_stmt|;
name|Text
name|owner
init|=
operator|new
name|Text
argument_list|(
name|user
argument_list|)
decl_stmt|;
name|Text
name|realUser
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|ugi
operator|.
name|getRealUser
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|realUser
operator|=
operator|new
name|Text
argument_list|(
name|ugi
operator|.
name|getRealUser
argument_list|()
operator|.
name|getUserName
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|DelegationTokenIdentifier
name|dtId
init|=
operator|new
name|DelegationTokenIdentifier
argument_list|(
name|owner
argument_list|,
name|renewer
argument_list|,
name|realUser
argument_list|)
decl_stmt|;
name|token
operator|=
operator|new
name|Token
argument_list|<
name|DelegationTokenIdentifier
argument_list|>
argument_list|(
name|dtId
argument_list|,
name|dtSecretManager
argument_list|)
expr_stmt|;
name|long
name|expiryTime
init|=
name|dtSecretManager
operator|.
name|getTokenExpiryTime
argument_list|(
name|dtId
argument_list|)
decl_stmt|;
name|getEditLog
argument_list|()
operator|.
name|logGetDelegationToken
argument_list|(
name|dtId
argument_list|,
name|expiryTime
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
name|getEditLog
argument_list|()
operator|.
name|logSync
argument_list|()
expr_stmt|;
return|return
name|token
return|;
block|}
comment|/**    *     * @param token    * @return New expiryTime of the token    * @throws InvalidToken    * @throws IOException    */
DECL|method|renewDelegationToken (Token<DelegationTokenIdentifier> token)
name|long
name|renewDelegationToken
parameter_list|(
name|Token
argument_list|<
name|DelegationTokenIdentifier
argument_list|>
name|token
parameter_list|)
throws|throws
name|InvalidToken
throws|,
name|IOException
block|{
name|long
name|expiryTime
decl_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|isInSafeMode
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SafeModeException
argument_list|(
literal|"Cannot renew delegation token"
argument_list|,
name|safeMode
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|isAllowedDelegationTokenOp
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Delegation Token can be renewed only with kerberos or web authentication"
argument_list|)
throw|;
block|}
name|String
name|renewer
init|=
name|UserGroupInformation
operator|.
name|getCurrentUser
argument_list|()
operator|.
name|getShortUserName
argument_list|()
decl_stmt|;
name|expiryTime
operator|=
name|dtSecretManager
operator|.
name|renewToken
argument_list|(
name|token
argument_list|,
name|renewer
argument_list|)
expr_stmt|;
name|DelegationTokenIdentifier
name|id
init|=
operator|new
name|DelegationTokenIdentifier
argument_list|()
decl_stmt|;
name|ByteArrayInputStream
name|buf
init|=
operator|new
name|ByteArrayInputStream
argument_list|(
name|token
operator|.
name|getIdentifier
argument_list|()
argument_list|)
decl_stmt|;
name|DataInputStream
name|in
init|=
operator|new
name|DataInputStream
argument_list|(
name|buf
argument_list|)
decl_stmt|;
name|id
operator|.
name|readFields
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|getEditLog
argument_list|()
operator|.
name|logRenewDelegationToken
argument_list|(
name|id
argument_list|,
name|expiryTime
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
name|getEditLog
argument_list|()
operator|.
name|logSync
argument_list|()
expr_stmt|;
return|return
name|expiryTime
return|;
block|}
comment|/**    *     * @param token    * @throws IOException    */
DECL|method|cancelDelegationToken (Token<DelegationTokenIdentifier> token)
name|void
name|cancelDelegationToken
parameter_list|(
name|Token
argument_list|<
name|DelegationTokenIdentifier
argument_list|>
name|token
parameter_list|)
throws|throws
name|IOException
block|{
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|isInSafeMode
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SafeModeException
argument_list|(
literal|"Cannot cancel delegation token"
argument_list|,
name|safeMode
argument_list|)
throw|;
block|}
name|String
name|canceller
init|=
name|UserGroupInformation
operator|.
name|getCurrentUser
argument_list|()
operator|.
name|getUserName
argument_list|()
decl_stmt|;
name|DelegationTokenIdentifier
name|id
init|=
name|dtSecretManager
operator|.
name|cancelToken
argument_list|(
name|token
argument_list|,
name|canceller
argument_list|)
decl_stmt|;
name|getEditLog
argument_list|()
operator|.
name|logCancelDelegationToken
argument_list|(
name|id
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
name|getEditLog
argument_list|()
operator|.
name|logSync
argument_list|()
expr_stmt|;
block|}
comment|/**    * @param out save state of the secret manager    */
DECL|method|saveSecretManagerState (DataOutputStream out)
name|void
name|saveSecretManagerState
parameter_list|(
name|DataOutputStream
name|out
parameter_list|)
throws|throws
name|IOException
block|{
name|dtSecretManager
operator|.
name|saveSecretManagerState
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|}
comment|/**    * @param in load the state of secret manager from input stream    */
DECL|method|loadSecretManagerState (DataInputStream in)
name|void
name|loadSecretManagerState
parameter_list|(
name|DataInputStream
name|in
parameter_list|)
throws|throws
name|IOException
block|{
name|dtSecretManager
operator|.
name|loadSecretManagerState
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
comment|/**    * Log the updateMasterKey operation to edit logs    *     * @param key new delegation key.    */
DECL|method|logUpdateMasterKey (DelegationKey key)
specifier|public
name|void
name|logUpdateMasterKey
parameter_list|(
name|DelegationKey
name|key
parameter_list|)
block|{
assert|assert
operator|!
name|isInSafeMode
argument_list|()
operator|:
literal|"this should never be called while in safemode, since we stop "
operator|+
literal|"the DT manager before entering safemode!"
assert|;
comment|// No need to hold FSN lock since we don't access any internal
comment|// structures, and this is stopped before the FSN shuts itself
comment|// down, etc.
name|getEditLog
argument_list|()
operator|.
name|logUpdateMasterKey
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|getEditLog
argument_list|()
operator|.
name|logSync
argument_list|()
expr_stmt|;
block|}
DECL|method|logReassignLease (String leaseHolder, String src, String newHolder)
specifier|private
name|void
name|logReassignLease
parameter_list|(
name|String
name|leaseHolder
parameter_list|,
name|String
name|src
parameter_list|,
name|String
name|newHolder
parameter_list|)
block|{
assert|assert
name|hasWriteLock
argument_list|()
assert|;
name|getEditLog
argument_list|()
operator|.
name|logReassignLease
argument_list|(
name|leaseHolder
argument_list|,
name|src
argument_list|,
name|newHolder
argument_list|)
expr_stmt|;
block|}
comment|/**    *     * @return true if delegation token operation is allowed    */
DECL|method|isAllowedDelegationTokenOp ()
specifier|private
name|boolean
name|isAllowedDelegationTokenOp
parameter_list|()
throws|throws
name|IOException
block|{
name|AuthenticationMethod
name|authMethod
init|=
name|getConnectionAuthenticationMethod
argument_list|()
decl_stmt|;
if|if
condition|(
name|UserGroupInformation
operator|.
name|isSecurityEnabled
argument_list|()
operator|&&
operator|(
name|authMethod
operator|!=
name|AuthenticationMethod
operator|.
name|KERBEROS
operator|)
operator|&&
operator|(
name|authMethod
operator|!=
name|AuthenticationMethod
operator|.
name|KERBEROS_SSL
operator|)
operator|&&
operator|(
name|authMethod
operator|!=
name|AuthenticationMethod
operator|.
name|CERTIFICATE
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Returns authentication method used to establish the connection    * @return AuthenticationMethod used to establish connection    * @throws IOException    */
DECL|method|getConnectionAuthenticationMethod ()
specifier|private
name|AuthenticationMethod
name|getConnectionAuthenticationMethod
parameter_list|()
throws|throws
name|IOException
block|{
name|UserGroupInformation
name|ugi
init|=
name|UserGroupInformation
operator|.
name|getCurrentUser
argument_list|()
decl_stmt|;
name|AuthenticationMethod
name|authMethod
init|=
name|ugi
operator|.
name|getAuthenticationMethod
argument_list|()
decl_stmt|;
if|if
condition|(
name|authMethod
operator|==
name|AuthenticationMethod
operator|.
name|PROXY
condition|)
block|{
name|authMethod
operator|=
name|ugi
operator|.
name|getRealUser
argument_list|()
operator|.
name|getAuthenticationMethod
argument_list|()
expr_stmt|;
block|}
return|return
name|authMethod
return|;
block|}
comment|/**    * Client invoked methods are invoked over RPC and will be in     * RPC call context even if the client exits.    */
DECL|method|isExternalInvocation ()
specifier|private
name|boolean
name|isExternalInvocation
parameter_list|()
block|{
return|return
name|Server
operator|.
name|isRpcInvocation
argument_list|()
operator|||
name|NamenodeWebHdfsMethods
operator|.
name|isWebHdfsInvocation
argument_list|()
return|;
block|}
DECL|method|getRemoteIp ()
specifier|private
specifier|static
name|InetAddress
name|getRemoteIp
parameter_list|()
block|{
name|InetAddress
name|ip
init|=
name|Server
operator|.
name|getRemoteIp
argument_list|()
decl_stmt|;
if|if
condition|(
name|ip
operator|!=
literal|null
condition|)
block|{
return|return
name|ip
return|;
block|}
return|return
name|NamenodeWebHdfsMethods
operator|.
name|getRemoteIp
argument_list|()
return|;
block|}
comment|/**    * Log fsck event in the audit log     */
DECL|method|logFsckEvent (String src, InetAddress remoteAddress)
name|void
name|logFsckEvent
parameter_list|(
name|String
name|src
parameter_list|,
name|InetAddress
name|remoteAddress
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|isAuditEnabled
argument_list|()
condition|)
block|{
name|logAuditEvent
argument_list|(
name|UserGroupInformation
operator|.
name|getCurrentUser
argument_list|()
argument_list|,
name|remoteAddress
argument_list|,
literal|"fsck"
argument_list|,
name|src
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Register NameNodeMXBean    */
DECL|method|registerMXBean ()
specifier|private
name|void
name|registerMXBean
parameter_list|()
block|{
name|MBeans
operator|.
name|register
argument_list|(
literal|"NameNode"
argument_list|,
literal|"NameNodeInfo"
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
comment|/**    * Class representing Namenode information for JMX interfaces    */
annotation|@
name|Override
comment|// NameNodeMXBean
DECL|method|getVersion ()
specifier|public
name|String
name|getVersion
parameter_list|()
block|{
return|return
name|VersionInfo
operator|.
name|getVersion
argument_list|()
operator|+
literal|", r"
operator|+
name|VersionInfo
operator|.
name|getRevision
argument_list|()
return|;
block|}
annotation|@
name|Override
comment|// NameNodeMXBean
DECL|method|getUsed ()
specifier|public
name|long
name|getUsed
parameter_list|()
block|{
return|return
name|this
operator|.
name|getCapacityUsed
argument_list|()
return|;
block|}
annotation|@
name|Override
comment|// NameNodeMXBean
DECL|method|getFree ()
specifier|public
name|long
name|getFree
parameter_list|()
block|{
return|return
name|this
operator|.
name|getCapacityRemaining
argument_list|()
return|;
block|}
annotation|@
name|Override
comment|// NameNodeMXBean
DECL|method|getTotal ()
specifier|public
name|long
name|getTotal
parameter_list|()
block|{
return|return
name|this
operator|.
name|getCapacityTotal
argument_list|()
return|;
block|}
annotation|@
name|Override
comment|// NameNodeMXBean
DECL|method|getSafemode ()
specifier|public
name|String
name|getSafemode
parameter_list|()
block|{
if|if
condition|(
operator|!
name|this
operator|.
name|isInSafeMode
argument_list|()
condition|)
return|return
literal|""
return|;
return|return
literal|"Safe mode is ON."
operator|+
name|this
operator|.
name|getSafeModeTip
argument_list|()
return|;
block|}
annotation|@
name|Override
comment|// NameNodeMXBean
DECL|method|isUpgradeFinalized ()
specifier|public
name|boolean
name|isUpgradeFinalized
parameter_list|()
block|{
return|return
name|this
operator|.
name|getFSImage
argument_list|()
operator|.
name|isUpgradeFinalized
argument_list|()
return|;
block|}
annotation|@
name|Override
comment|// NameNodeMXBean
DECL|method|getNonDfsUsedSpace ()
specifier|public
name|long
name|getNonDfsUsedSpace
parameter_list|()
block|{
return|return
name|datanodeStatistics
operator|.
name|getCapacityUsedNonDFS
argument_list|()
return|;
block|}
annotation|@
name|Override
comment|// NameNodeMXBean
DECL|method|getPercentUsed ()
specifier|public
name|float
name|getPercentUsed
parameter_list|()
block|{
return|return
name|datanodeStatistics
operator|.
name|getCapacityUsedPercent
argument_list|()
return|;
block|}
annotation|@
name|Override
comment|// NameNodeMXBean
DECL|method|getBlockPoolUsedSpace ()
specifier|public
name|long
name|getBlockPoolUsedSpace
parameter_list|()
block|{
return|return
name|datanodeStatistics
operator|.
name|getBlockPoolUsed
argument_list|()
return|;
block|}
annotation|@
name|Override
comment|// NameNodeMXBean
DECL|method|getPercentBlockPoolUsed ()
specifier|public
name|float
name|getPercentBlockPoolUsed
parameter_list|()
block|{
return|return
name|datanodeStatistics
operator|.
name|getPercentBlockPoolUsed
argument_list|()
return|;
block|}
annotation|@
name|Override
comment|// NameNodeMXBean
DECL|method|getPercentRemaining ()
specifier|public
name|float
name|getPercentRemaining
parameter_list|()
block|{
return|return
name|datanodeStatistics
operator|.
name|getCapacityRemainingPercent
argument_list|()
return|;
block|}
annotation|@
name|Override
comment|// NameNodeMXBean
DECL|method|getTotalBlocks ()
specifier|public
name|long
name|getTotalBlocks
parameter_list|()
block|{
return|return
name|getBlocksTotal
argument_list|()
return|;
block|}
annotation|@
name|Override
comment|// NameNodeMXBean
annotation|@
name|Metric
DECL|method|getTotalFiles ()
specifier|public
name|long
name|getTotalFiles
parameter_list|()
block|{
return|return
name|getFilesTotal
argument_list|()
return|;
block|}
annotation|@
name|Override
comment|// NameNodeMXBean
DECL|method|getNumberOfMissingBlocks ()
specifier|public
name|long
name|getNumberOfMissingBlocks
parameter_list|()
block|{
return|return
name|getMissingBlocksCount
argument_list|()
return|;
block|}
annotation|@
name|Override
comment|// NameNodeMXBean
DECL|method|getThreads ()
specifier|public
name|int
name|getThreads
parameter_list|()
block|{
return|return
name|ManagementFactory
operator|.
name|getThreadMXBean
argument_list|()
operator|.
name|getThreadCount
argument_list|()
return|;
block|}
comment|/**    * Returned information is a JSON representation of map with host name as the    * key and value is a map of live node attribute keys to its values    */
annotation|@
name|Override
comment|// NameNodeMXBean
DECL|method|getLiveNodes ()
specifier|public
name|String
name|getLiveNodes
parameter_list|()
block|{
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
argument_list|>
name|info
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|live
init|=
operator|new
name|ArrayList
argument_list|<
name|DatanodeDescriptor
argument_list|>
argument_list|()
decl_stmt|;
name|blockManager
operator|.
name|getDatanodeManager
argument_list|()
operator|.
name|fetchDatanodes
argument_list|(
name|live
argument_list|,
literal|null
argument_list|,
literal|true
argument_list|)
expr_stmt|;
for|for
control|(
name|DatanodeDescriptor
name|node
range|:
name|live
control|)
block|{
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|innerinfo
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
argument_list|()
decl_stmt|;
name|innerinfo
operator|.
name|put
argument_list|(
literal|"lastContact"
argument_list|,
name|getLastContact
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
name|innerinfo
operator|.
name|put
argument_list|(
literal|"usedSpace"
argument_list|,
name|getDfsUsed
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
name|innerinfo
operator|.
name|put
argument_list|(
literal|"adminState"
argument_list|,
name|node
operator|.
name|getAdminState
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|innerinfo
operator|.
name|put
argument_list|(
literal|"nonDfsUsedSpace"
argument_list|,
name|node
operator|.
name|getNonDfsUsed
argument_list|()
argument_list|)
expr_stmt|;
name|innerinfo
operator|.
name|put
argument_list|(
literal|"capacity"
argument_list|,
name|node
operator|.
name|getCapacity
argument_list|()
argument_list|)
expr_stmt|;
name|innerinfo
operator|.
name|put
argument_list|(
literal|"numBlocks"
argument_list|,
name|node
operator|.
name|numBlocks
argument_list|()
argument_list|)
expr_stmt|;
name|info
operator|.
name|put
argument_list|(
name|node
operator|.
name|getHostName
argument_list|()
argument_list|,
name|innerinfo
argument_list|)
expr_stmt|;
block|}
return|return
name|JSON
operator|.
name|toString
argument_list|(
name|info
argument_list|)
return|;
block|}
comment|/**    * Returned information is a JSON representation of map with host name as the    * key and value is a map of dead node attribute keys to its values    */
annotation|@
name|Override
comment|// NameNodeMXBean
DECL|method|getDeadNodes ()
specifier|public
name|String
name|getDeadNodes
parameter_list|()
block|{
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
argument_list|>
name|info
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|dead
init|=
operator|new
name|ArrayList
argument_list|<
name|DatanodeDescriptor
argument_list|>
argument_list|()
decl_stmt|;
name|blockManager
operator|.
name|getDatanodeManager
argument_list|()
operator|.
name|fetchDatanodes
argument_list|(
literal|null
argument_list|,
name|dead
argument_list|,
literal|true
argument_list|)
expr_stmt|;
for|for
control|(
name|DatanodeDescriptor
name|node
range|:
name|dead
control|)
block|{
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|innerinfo
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
argument_list|()
decl_stmt|;
name|innerinfo
operator|.
name|put
argument_list|(
literal|"lastContact"
argument_list|,
name|getLastContact
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
name|innerinfo
operator|.
name|put
argument_list|(
literal|"decommissioned"
argument_list|,
name|node
operator|.
name|isDecommissioned
argument_list|()
argument_list|)
expr_stmt|;
name|info
operator|.
name|put
argument_list|(
name|node
operator|.
name|getHostName
argument_list|()
argument_list|,
name|innerinfo
argument_list|)
expr_stmt|;
block|}
return|return
name|JSON
operator|.
name|toString
argument_list|(
name|info
argument_list|)
return|;
block|}
comment|/**    * Returned information is a JSON representation of map with host name as the    * key and value is a map of decomisioning node attribute keys to its values    */
annotation|@
name|Override
comment|// NameNodeMXBean
DECL|method|getDecomNodes ()
specifier|public
name|String
name|getDecomNodes
parameter_list|()
block|{
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
argument_list|>
name|info
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|decomNodeList
init|=
name|blockManager
operator|.
name|getDatanodeManager
argument_list|(         )
operator|.
name|getDecommissioningNodes
argument_list|()
decl_stmt|;
for|for
control|(
name|DatanodeDescriptor
name|node
range|:
name|decomNodeList
control|)
block|{
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|innerinfo
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
argument_list|()
decl_stmt|;
name|innerinfo
operator|.
name|put
argument_list|(
literal|"underReplicatedBlocks"
argument_list|,
name|node
operator|.
name|decommissioningStatus
operator|.
name|getUnderReplicatedBlocks
argument_list|()
argument_list|)
expr_stmt|;
name|innerinfo
operator|.
name|put
argument_list|(
literal|"decommissionOnlyReplicas"
argument_list|,
name|node
operator|.
name|decommissioningStatus
operator|.
name|getDecommissionOnlyReplicas
argument_list|()
argument_list|)
expr_stmt|;
name|innerinfo
operator|.
name|put
argument_list|(
literal|"underReplicateInOpenFiles"
argument_list|,
name|node
operator|.
name|decommissioningStatus
operator|.
name|getUnderReplicatedInOpenFiles
argument_list|()
argument_list|)
expr_stmt|;
name|info
operator|.
name|put
argument_list|(
name|node
operator|.
name|getHostName
argument_list|()
argument_list|,
name|innerinfo
argument_list|)
expr_stmt|;
block|}
return|return
name|JSON
operator|.
name|toString
argument_list|(
name|info
argument_list|)
return|;
block|}
DECL|method|getLastContact (DatanodeDescriptor alivenode)
specifier|private
name|long
name|getLastContact
parameter_list|(
name|DatanodeDescriptor
name|alivenode
parameter_list|)
block|{
return|return
operator|(
name|Time
operator|.
name|now
argument_list|()
operator|-
name|alivenode
operator|.
name|getLastUpdate
argument_list|()
operator|)
operator|/
literal|1000
return|;
block|}
DECL|method|getDfsUsed (DatanodeDescriptor alivenode)
specifier|private
name|long
name|getDfsUsed
parameter_list|(
name|DatanodeDescriptor
name|alivenode
parameter_list|)
block|{
return|return
name|alivenode
operator|.
name|getDfsUsed
argument_list|()
return|;
block|}
annotation|@
name|Override
comment|// NameNodeMXBean
DECL|method|getClusterId ()
specifier|public
name|String
name|getClusterId
parameter_list|()
block|{
return|return
name|dir
operator|.
name|fsImage
operator|.
name|getStorage
argument_list|()
operator|.
name|getClusterID
argument_list|()
return|;
block|}
annotation|@
name|Override
comment|// NameNodeMXBean
DECL|method|getBlockPoolId ()
specifier|public
name|String
name|getBlockPoolId
parameter_list|()
block|{
return|return
name|blockPoolId
return|;
block|}
annotation|@
name|Override
comment|// NameNodeMXBean
DECL|method|getNameDirStatuses ()
specifier|public
name|String
name|getNameDirStatuses
parameter_list|()
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|File
argument_list|,
name|StorageDirType
argument_list|>
argument_list|>
name|statusMap
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|File
argument_list|,
name|StorageDirType
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|File
argument_list|,
name|StorageDirType
argument_list|>
name|activeDirs
init|=
operator|new
name|HashMap
argument_list|<
name|File
argument_list|,
name|StorageDirType
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|StorageDirectory
argument_list|>
name|it
init|=
name|getFSImage
argument_list|()
operator|.
name|getStorage
argument_list|()
operator|.
name|dirIterator
argument_list|()
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|StorageDirectory
name|st
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|activeDirs
operator|.
name|put
argument_list|(
name|st
operator|.
name|getRoot
argument_list|()
argument_list|,
name|st
operator|.
name|getStorageDirType
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|statusMap
operator|.
name|put
argument_list|(
literal|"active"
argument_list|,
name|activeDirs
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|Storage
operator|.
name|StorageDirectory
argument_list|>
name|removedStorageDirs
init|=
name|getFSImage
argument_list|()
operator|.
name|getStorage
argument_list|()
operator|.
name|getRemovedStorageDirs
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|File
argument_list|,
name|StorageDirType
argument_list|>
name|failedDirs
init|=
operator|new
name|HashMap
argument_list|<
name|File
argument_list|,
name|StorageDirType
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|StorageDirectory
name|st
range|:
name|removedStorageDirs
control|)
block|{
name|failedDirs
operator|.
name|put
argument_list|(
name|st
operator|.
name|getRoot
argument_list|()
argument_list|,
name|st
operator|.
name|getStorageDirType
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|statusMap
operator|.
name|put
argument_list|(
literal|"failed"
argument_list|,
name|failedDirs
argument_list|)
expr_stmt|;
return|return
name|JSON
operator|.
name|toString
argument_list|(
name|statusMap
argument_list|)
return|;
block|}
comment|/** @return the block manager. */
DECL|method|getBlockManager ()
specifier|public
name|BlockManager
name|getBlockManager
parameter_list|()
block|{
return|return
name|blockManager
return|;
block|}
comment|/** @return the FSDirectory. */
DECL|method|getFSDirectory ()
specifier|public
name|FSDirectory
name|getFSDirectory
parameter_list|()
block|{
return|return
name|dir
return|;
block|}
comment|/**    * Verifies that the given identifier and password are valid and match.    * @param identifier Token identifier.    * @param password Password in the token.    * @throws InvalidToken    */
DECL|method|verifyToken (DelegationTokenIdentifier identifier, byte[] password)
specifier|public
specifier|synchronized
name|void
name|verifyToken
parameter_list|(
name|DelegationTokenIdentifier
name|identifier
parameter_list|,
name|byte
index|[]
name|password
parameter_list|)
throws|throws
name|InvalidToken
block|{
name|getDelegationTokenSecretManager
argument_list|()
operator|.
name|verifyToken
argument_list|(
name|identifier
argument_list|,
name|password
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|isGenStampInFuture (long genStamp)
specifier|public
name|boolean
name|isGenStampInFuture
parameter_list|(
name|long
name|genStamp
parameter_list|)
block|{
return|return
operator|(
name|genStamp
operator|>
name|getGenerationStamp
argument_list|()
operator|)
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|getEditLogTailer ()
specifier|public
name|EditLogTailer
name|getEditLogTailer
parameter_list|()
block|{
return|return
name|editLogTailer
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|setFsLockForTests (ReentrantReadWriteLock lock)
name|void
name|setFsLockForTests
parameter_list|(
name|ReentrantReadWriteLock
name|lock
parameter_list|)
block|{
name|this
operator|.
name|fsLock
operator|=
name|lock
expr_stmt|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|getFsLockForTests ()
name|ReentrantReadWriteLock
name|getFsLockForTests
parameter_list|()
block|{
return|return
name|fsLock
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|getSafeModeInfoForTests ()
specifier|public
name|SafeModeInfo
name|getSafeModeInfoForTests
parameter_list|()
block|{
return|return
name|safeMode
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|setNNResourceChecker (NameNodeResourceChecker nnResourceChecker)
specifier|public
name|void
name|setNNResourceChecker
parameter_list|(
name|NameNodeResourceChecker
name|nnResourceChecker
parameter_list|)
block|{
name|this
operator|.
name|nnResourceChecker
operator|=
name|nnResourceChecker
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|isAvoidingStaleDataNodesForWrite ()
specifier|public
name|boolean
name|isAvoidingStaleDataNodesForWrite
parameter_list|()
block|{
return|return
name|this
operator|.
name|blockManager
operator|.
name|getDatanodeManager
argument_list|()
operator|.
name|isAvoidingStaleDataNodesForWrite
argument_list|()
return|;
block|}
DECL|method|getSnapshotManager ()
specifier|public
name|SnapshotManager
name|getSnapshotManager
parameter_list|()
block|{
return|return
name|snapshotManager
return|;
block|}
comment|/** Allow snapshot on a directroy. */
DECL|method|allowSnapshot (String path)
specifier|public
name|void
name|allowSnapshot
parameter_list|(
name|String
name|path
parameter_list|)
throws|throws
name|SafeModeException
throws|,
name|IOException
block|{
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|isInSafeMode
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SafeModeException
argument_list|(
literal|"Cannot allow snapshot for "
operator|+
name|path
argument_list|,
name|safeMode
argument_list|)
throw|;
block|}
name|checkOwner
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|snapshotManager
operator|.
name|setSnapshottable
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|getEditLog
argument_list|()
operator|.
name|logAllowSnapshot
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
name|getEditLog
argument_list|()
operator|.
name|logSync
argument_list|()
expr_stmt|;
comment|//TODO: need to update metrics in corresponding SnapshotManager method
if|if
condition|(
name|auditLog
operator|.
name|isInfoEnabled
argument_list|()
operator|&&
name|isExternalInvocation
argument_list|()
condition|)
block|{
name|logAuditEvent
argument_list|(
name|UserGroupInformation
operator|.
name|getCurrentUser
argument_list|()
argument_list|,
name|getRemoteIp
argument_list|()
argument_list|,
literal|"allowSnapshot"
argument_list|,
name|path
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Disallow snapshot on a directory. */
DECL|method|disallowSnapshot (String path)
specifier|public
name|void
name|disallowSnapshot
parameter_list|(
name|String
name|path
parameter_list|)
throws|throws
name|SafeModeException
throws|,
name|IOException
block|{
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|isInSafeMode
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SafeModeException
argument_list|(
literal|"Cannot disallow snapshot for "
operator|+
name|path
argument_list|,
name|safeMode
argument_list|)
throw|;
block|}
name|checkOwner
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|snapshotManager
operator|.
name|resetSnapshottable
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|getEditLog
argument_list|()
operator|.
name|logDisallowSnapshot
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
name|getEditLog
argument_list|()
operator|.
name|logSync
argument_list|()
expr_stmt|;
comment|//TODO: need to update metrics in corresponding SnapshotManager method
if|if
condition|(
name|auditLog
operator|.
name|isInfoEnabled
argument_list|()
operator|&&
name|isExternalInvocation
argument_list|()
condition|)
block|{
name|logAuditEvent
argument_list|(
name|UserGroupInformation
operator|.
name|getCurrentUser
argument_list|()
argument_list|,
name|getRemoteIp
argument_list|()
argument_list|,
literal|"disallowSnapshot"
argument_list|,
name|path
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Create a snapshot    * @param snapshotRoot The directory path where the snapshot is taken    * @param snapshotName The name of the snapshot    */
DECL|method|createSnapshot (String snapshotRoot, String snapshotName)
specifier|public
name|void
name|createSnapshot
parameter_list|(
name|String
name|snapshotRoot
parameter_list|,
name|String
name|snapshotName
parameter_list|)
throws|throws
name|SafeModeException
throws|,
name|IOException
block|{
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|isInSafeMode
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SafeModeException
argument_list|(
literal|"Cannot create snapshot for "
operator|+
name|snapshotRoot
argument_list|,
name|safeMode
argument_list|)
throw|;
block|}
name|checkOwner
argument_list|(
name|snapshotRoot
argument_list|)
expr_stmt|;
name|dir
operator|.
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|snapshotManager
operator|.
name|createSnapshot
argument_list|(
name|snapshotRoot
argument_list|,
name|snapshotName
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|dir
operator|.
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
name|getEditLog
argument_list|()
operator|.
name|logCreateSnapshot
argument_list|(
name|snapshotRoot
argument_list|,
name|snapshotName
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
name|getEditLog
argument_list|()
operator|.
name|logSync
argument_list|()
expr_stmt|;
if|if
condition|(
name|auditLog
operator|.
name|isInfoEnabled
argument_list|()
operator|&&
name|isExternalInvocation
argument_list|()
condition|)
block|{
name|Path
name|rootPath
init|=
operator|new
name|Path
argument_list|(
name|snapshotRoot
argument_list|,
name|HdfsConstants
operator|.
name|DOT_SNAPSHOT_DIR
operator|+
name|Path
operator|.
name|SEPARATOR
operator|+
name|snapshotName
argument_list|)
decl_stmt|;
name|logAuditEvent
argument_list|(
name|UserGroupInformation
operator|.
name|getCurrentUser
argument_list|()
argument_list|,
name|getRemoteIp
argument_list|()
argument_list|,
literal|"createSnapshot"
argument_list|,
name|snapshotRoot
argument_list|,
name|rootPath
operator|.
name|toString
argument_list|()
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Rename a snapshot    * @param path The directory path where the snapshot was taken    * @param snapshotOldName Old snapshot name    * @param snapshotNewName New snapshot name    * @throws SafeModeException    * @throws IOException     */
DECL|method|renameSnapshot (String path, String snapshotOldName, String snapshotNewName)
specifier|public
name|void
name|renameSnapshot
parameter_list|(
name|String
name|path
parameter_list|,
name|String
name|snapshotOldName
parameter_list|,
name|String
name|snapshotNewName
parameter_list|)
throws|throws
name|SafeModeException
throws|,
name|IOException
block|{
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|isInSafeMode
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SafeModeException
argument_list|(
literal|"Cannot rename snapshot for "
operator|+
name|path
argument_list|,
name|safeMode
argument_list|)
throw|;
block|}
name|checkOwner
argument_list|(
name|path
argument_list|)
expr_stmt|;
comment|// TODO: check if the new name is valid. May also need this for
comment|// creationSnapshot
name|snapshotManager
operator|.
name|renameSnapshot
argument_list|(
name|path
argument_list|,
name|snapshotOldName
argument_list|,
name|snapshotNewName
argument_list|)
expr_stmt|;
name|getEditLog
argument_list|()
operator|.
name|logRenameSnapshot
argument_list|(
name|path
argument_list|,
name|snapshotOldName
argument_list|,
name|snapshotNewName
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
name|getEditLog
argument_list|()
operator|.
name|logSync
argument_list|()
expr_stmt|;
if|if
condition|(
name|auditLog
operator|.
name|isInfoEnabled
argument_list|()
operator|&&
name|isExternalInvocation
argument_list|()
condition|)
block|{
name|Path
name|oldSnapshotRoot
init|=
operator|new
name|Path
argument_list|(
name|path
argument_list|,
name|HdfsConstants
operator|.
name|DOT_SNAPSHOT_DIR
operator|+
literal|"/"
operator|+
name|snapshotOldName
argument_list|)
decl_stmt|;
name|Path
name|newSnapshotRoot
init|=
operator|new
name|Path
argument_list|(
name|path
argument_list|,
name|HdfsConstants
operator|.
name|DOT_SNAPSHOT_DIR
operator|+
literal|"/"
operator|+
name|snapshotNewName
argument_list|)
decl_stmt|;
name|logAuditEvent
argument_list|(
name|UserGroupInformation
operator|.
name|getCurrentUser
argument_list|()
argument_list|,
name|getRemoteIp
argument_list|()
argument_list|,
literal|"renameSnapshot"
argument_list|,
name|oldSnapshotRoot
operator|.
name|toString
argument_list|()
argument_list|,
name|newSnapshotRoot
operator|.
name|toString
argument_list|()
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Get the list of all the current snapshottable directories    * @return The list of all the current snapshottable directories    * @throws IOException    */
DECL|method|getSnapshottableDirListing ()
specifier|public
name|SnapshottableDirectoryStatus
index|[]
name|getSnapshottableDirListing
parameter_list|()
throws|throws
name|IOException
block|{
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|READ
argument_list|)
expr_stmt|;
name|SnapshottableDirectoryStatus
index|[]
name|status
init|=
name|snapshotManager
operator|.
name|getSnapshottableDirListing
argument_list|()
decl_stmt|;
if|if
condition|(
name|auditLog
operator|.
name|isInfoEnabled
argument_list|()
operator|&&
name|isExternalInvocation
argument_list|()
condition|)
block|{
name|logAuditEvent
argument_list|(
name|UserGroupInformation
operator|.
name|getCurrentUser
argument_list|()
argument_list|,
name|getRemoteIp
argument_list|()
argument_list|,
literal|"listSnapshottableDirectory"
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Delete a snapshot of a snapshottable directory    * @param snapshotRoot The snapshottable directory    * @param snapshotName The name of the to-be-deleted snapshot    * @throws SafeModeException    * @throws IOException    */
DECL|method|deleteSnapshot (String snapshotRoot, String snapshotName)
specifier|public
name|void
name|deleteSnapshot
parameter_list|(
name|String
name|snapshotRoot
parameter_list|,
name|String
name|snapshotName
parameter_list|)
throws|throws
name|SafeModeException
throws|,
name|IOException
block|{
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|WRITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|isInSafeMode
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SafeModeException
argument_list|(
literal|"Cannot delete snapshot for "
operator|+
name|snapshotRoot
argument_list|,
name|safeMode
argument_list|)
throw|;
block|}
name|checkOwner
argument_list|(
name|snapshotRoot
argument_list|)
expr_stmt|;
name|BlocksMapUpdateInfo
name|collectedBlocks
init|=
operator|new
name|BlocksMapUpdateInfo
argument_list|()
decl_stmt|;
name|dir
operator|.
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|snapshotManager
operator|.
name|deleteSnapshot
argument_list|(
name|snapshotRoot
argument_list|,
name|snapshotName
argument_list|,
name|collectedBlocks
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|dir
operator|.
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
name|this
operator|.
name|removeBlocks
argument_list|(
name|collectedBlocks
argument_list|)
expr_stmt|;
name|collectedBlocks
operator|.
name|clear
argument_list|()
expr_stmt|;
name|getEditLog
argument_list|()
operator|.
name|logDeleteSnapshot
argument_list|(
name|snapshotRoot
argument_list|,
name|snapshotName
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
name|getEditLog
argument_list|()
operator|.
name|logSync
argument_list|()
expr_stmt|;
if|if
condition|(
name|auditLog
operator|.
name|isInfoEnabled
argument_list|()
operator|&&
name|isExternalInvocation
argument_list|()
condition|)
block|{
name|Path
name|rootPath
init|=
operator|new
name|Path
argument_list|(
name|snapshotRoot
argument_list|,
name|HdfsConstants
operator|.
name|DOT_SNAPSHOT_DIR
operator|+
name|Path
operator|.
name|SEPARATOR
operator|+
name|snapshotName
argument_list|)
decl_stmt|;
name|logAuditEvent
argument_list|(
name|UserGroupInformation
operator|.
name|getCurrentUser
argument_list|()
argument_list|,
name|getRemoteIp
argument_list|()
argument_list|,
literal|"deleteSnapshot"
argument_list|,
name|rootPath
operator|.
name|toString
argument_list|()
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Remove a list of INodeDirectorySnapshottable from the SnapshotManager    * @param toRemove the list of INodeDirectorySnapshottable to be removed    */
DECL|method|removeSnapshottableDirs (List<INodeDirectorySnapshottable> toRemove)
name|void
name|removeSnapshottableDirs
parameter_list|(
name|List
argument_list|<
name|INodeDirectorySnapshottable
argument_list|>
name|toRemove
parameter_list|)
block|{
if|if
condition|(
name|snapshotManager
operator|!=
literal|null
condition|)
block|{
name|snapshotManager
operator|.
name|removeSnapshottableDirs
argument_list|(
name|toRemove
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Default AuditLogger implementation; used when no access logger is    * defined in the config file. It can also be explicitly listed in the    * config file.    */
DECL|class|DefaultAuditLogger
specifier|private
specifier|static
class|class
name|DefaultAuditLogger
implements|implements
name|AuditLogger
block|{
annotation|@
name|Override
DECL|method|initialize (Configuration conf)
specifier|public
name|void
name|initialize
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
comment|// Nothing to do.
block|}
annotation|@
name|Override
DECL|method|logAuditEvent (boolean succeeded, String userName, InetAddress addr, String cmd, String src, String dst, FileStatus status)
specifier|public
name|void
name|logAuditEvent
parameter_list|(
name|boolean
name|succeeded
parameter_list|,
name|String
name|userName
parameter_list|,
name|InetAddress
name|addr
parameter_list|,
name|String
name|cmd
parameter_list|,
name|String
name|src
parameter_list|,
name|String
name|dst
parameter_list|,
name|FileStatus
name|status
parameter_list|)
block|{
if|if
condition|(
name|auditLog
operator|.
name|isInfoEnabled
argument_list|()
condition|)
block|{
specifier|final
name|StringBuilder
name|sb
init|=
name|auditBuffer
operator|.
name|get
argument_list|()
decl_stmt|;
name|sb
operator|.
name|setLength
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"allowed="
argument_list|)
operator|.
name|append
argument_list|(
name|succeeded
argument_list|)
operator|.
name|append
argument_list|(
literal|"\t"
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"ugi="
argument_list|)
operator|.
name|append
argument_list|(
name|userName
argument_list|)
operator|.
name|append
argument_list|(
literal|"\t"
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"ip="
argument_list|)
operator|.
name|append
argument_list|(
name|addr
argument_list|)
operator|.
name|append
argument_list|(
literal|"\t"
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"cmd="
argument_list|)
operator|.
name|append
argument_list|(
name|cmd
argument_list|)
operator|.
name|append
argument_list|(
literal|"\t"
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"src="
argument_list|)
operator|.
name|append
argument_list|(
name|src
argument_list|)
operator|.
name|append
argument_list|(
literal|"\t"
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"dst="
argument_list|)
operator|.
name|append
argument_list|(
name|dst
argument_list|)
operator|.
name|append
argument_list|(
literal|"\t"
argument_list|)
expr_stmt|;
if|if
condition|(
literal|null
operator|==
name|status
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|"perm=null"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sb
operator|.
name|append
argument_list|(
literal|"perm="
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|status
operator|.
name|getOwner
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|":"
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|status
operator|.
name|getGroup
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|":"
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|status
operator|.
name|getPermission
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|auditLog
operator|.
name|info
argument_list|(
name|sb
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_class

end_unit

