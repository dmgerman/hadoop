begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdfs.server.balancer
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|balancer
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|util
operator|.
name|StripedBlockUtil
operator|.
name|getInternalBlockLength
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocolPB
operator|.
name|PBHelperClient
operator|.
name|vintPrefixed
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|BufferedInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|BufferedOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|Socket
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|EnumMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutionException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutorService
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Executors
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Future
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ThreadPoolExecutor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|StorageType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSUtilClient
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DistributedFileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|client
operator|.
name|HdfsClientConfigKeys
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|Block
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|DatanodeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|ExtendedBlock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|HdfsConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|datatransfer
operator|.
name|BlockPinningException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|datatransfer
operator|.
name|DataTransferProtoUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|datatransfer
operator|.
name|IOStreamPair
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|datatransfer
operator|.
name|Sender
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|datatransfer
operator|.
name|TrustedChannelResolver
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|datatransfer
operator|.
name|sasl
operator|.
name|DataTransferSaslUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|datatransfer
operator|.
name|sasl
operator|.
name|SaslDataTransferClient
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|proto
operator|.
name|DataTransferProtos
operator|.
name|BlockOpResponseProto
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|proto
operator|.
name|DataTransferProtos
operator|.
name|Status
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|security
operator|.
name|token
operator|.
name|block
operator|.
name|BlockTokenIdentifier
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|balancer
operator|.
name|Dispatcher
operator|.
name|DDatanode
operator|.
name|StorageGroup
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|blockmanagement
operator|.
name|BlockPlacementPolicies
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|BlockType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|BlocksWithLocations
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|BlocksWithLocations
operator|.
name|BlockWithLocations
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|BlocksWithLocations
operator|.
name|StripedBlockWithLocations
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|DatanodeStorageReport
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|net
operator|.
name|NetUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|net
operator|.
name|NetworkTopology
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|token
operator|.
name|Token
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Time
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_comment
comment|/** Dispatching block replica moves between datanodes. */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
DECL|class|Dispatcher
specifier|public
class|class
name|Dispatcher
block|{
DECL|field|LOG
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|Dispatcher
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/**    * the period of time to delay the usage of a DataNode after hitting    * errors when using it for migrating data    */
DECL|field|delayAfterErrors
specifier|private
specifier|static
name|long
name|delayAfterErrors
init|=
literal|10
operator|*
literal|1000
decl_stmt|;
DECL|field|nnc
specifier|private
specifier|final
name|NameNodeConnector
name|nnc
decl_stmt|;
DECL|field|saslClient
specifier|private
specifier|final
name|SaslDataTransferClient
name|saslClient
decl_stmt|;
comment|/** Set of datanodes to be excluded. */
DECL|field|excludedNodes
specifier|private
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|excludedNodes
decl_stmt|;
comment|/** Restrict to the following nodes. */
DECL|field|includedNodes
specifier|private
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|includedNodes
decl_stmt|;
DECL|field|sources
specifier|private
specifier|final
name|Collection
argument_list|<
name|Source
argument_list|>
name|sources
init|=
operator|new
name|HashSet
argument_list|<
name|Source
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|targets
specifier|private
specifier|final
name|Collection
argument_list|<
name|StorageGroup
argument_list|>
name|targets
init|=
operator|new
name|HashSet
argument_list|<
name|StorageGroup
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|globalBlocks
specifier|private
specifier|final
name|GlobalBlockMap
name|globalBlocks
init|=
operator|new
name|GlobalBlockMap
argument_list|()
decl_stmt|;
DECL|field|movedBlocks
specifier|private
specifier|final
name|MovedBlocks
argument_list|<
name|StorageGroup
argument_list|>
name|movedBlocks
decl_stmt|;
comment|/** Map (datanodeUuid,storageType -> StorageGroup) */
DECL|field|storageGroupMap
specifier|private
specifier|final
name|StorageGroupMap
argument_list|<
name|StorageGroup
argument_list|>
name|storageGroupMap
init|=
operator|new
name|StorageGroupMap
argument_list|<
name|StorageGroup
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|cluster
specifier|private
name|NetworkTopology
name|cluster
decl_stmt|;
DECL|field|dispatchExecutor
specifier|private
specifier|final
name|ExecutorService
name|dispatchExecutor
decl_stmt|;
DECL|field|moverThreadAllocator
specifier|private
specifier|final
name|Allocator
name|moverThreadAllocator
decl_stmt|;
comment|/** The maximum number of concurrent blocks moves at a datanode */
DECL|field|maxConcurrentMovesPerNode
specifier|private
specifier|final
name|int
name|maxConcurrentMovesPerNode
decl_stmt|;
DECL|field|getBlocksSize
specifier|private
specifier|final
name|long
name|getBlocksSize
decl_stmt|;
DECL|field|getBlocksMinBlockSize
specifier|private
specifier|final
name|long
name|getBlocksMinBlockSize
decl_stmt|;
DECL|field|blockMoveTimeout
specifier|private
specifier|final
name|long
name|blockMoveTimeout
decl_stmt|;
comment|/**    * If no block can be moved out of a {@link Source} after this configured    * amount of time, the Source should give up choosing the next possible move.    */
DECL|field|maxNoMoveInterval
specifier|private
specifier|final
name|int
name|maxNoMoveInterval
decl_stmt|;
DECL|field|ioFileBufferSize
specifier|private
specifier|final
name|int
name|ioFileBufferSize
decl_stmt|;
DECL|field|connectToDnViaHostname
specifier|private
specifier|final
name|boolean
name|connectToDnViaHostname
decl_stmt|;
DECL|field|placementPolicies
specifier|private
name|BlockPlacementPolicies
name|placementPolicies
decl_stmt|;
DECL|class|Allocator
specifier|static
class|class
name|Allocator
block|{
DECL|field|max
specifier|private
specifier|final
name|int
name|max
decl_stmt|;
DECL|field|count
specifier|private
name|int
name|count
init|=
literal|0
decl_stmt|;
DECL|method|Allocator (int max)
name|Allocator
parameter_list|(
name|int
name|max
parameter_list|)
block|{
name|this
operator|.
name|max
operator|=
name|max
expr_stmt|;
block|}
DECL|method|allocate (int n)
specifier|synchronized
name|int
name|allocate
parameter_list|(
name|int
name|n
parameter_list|)
block|{
specifier|final
name|int
name|remaining
init|=
name|max
operator|-
name|count
decl_stmt|;
if|if
condition|(
name|remaining
operator|<=
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
else|else
block|{
specifier|final
name|int
name|allocated
init|=
name|remaining
operator|<
name|n
condition|?
name|remaining
else|:
name|n
decl_stmt|;
name|count
operator|+=
name|allocated
expr_stmt|;
return|return
name|allocated
return|;
block|}
block|}
DECL|method|reset ()
specifier|synchronized
name|void
name|reset
parameter_list|()
block|{
name|count
operator|=
literal|0
expr_stmt|;
block|}
block|}
DECL|class|GlobalBlockMap
specifier|private
specifier|static
class|class
name|GlobalBlockMap
block|{
DECL|field|map
specifier|private
specifier|final
name|Map
argument_list|<
name|Block
argument_list|,
name|DBlock
argument_list|>
name|map
init|=
operator|new
name|HashMap
argument_list|<
name|Block
argument_list|,
name|DBlock
argument_list|>
argument_list|()
decl_stmt|;
comment|/**      * Put block in the map if it's not found      * @return the block which be put in the map the first time      */
DECL|method|putIfAbsent (Block blk, DBlock dblk)
specifier|private
name|DBlock
name|putIfAbsent
parameter_list|(
name|Block
name|blk
parameter_list|,
name|DBlock
name|dblk
parameter_list|)
block|{
if|if
condition|(
operator|!
name|map
operator|.
name|containsKey
argument_list|(
name|blk
argument_list|)
condition|)
block|{
name|map
operator|.
name|put
argument_list|(
name|blk
argument_list|,
name|dblk
argument_list|)
expr_stmt|;
return|return
name|dblk
return|;
block|}
return|return
name|map
operator|.
name|get
argument_list|(
name|blk
argument_list|)
return|;
block|}
comment|/** Remove all blocks except for the moved blocks. */
DECL|method|removeAllButRetain (MovedBlocks<StorageGroup> movedBlocks)
specifier|private
name|void
name|removeAllButRetain
parameter_list|(
name|MovedBlocks
argument_list|<
name|StorageGroup
argument_list|>
name|movedBlocks
parameter_list|)
block|{
for|for
control|(
name|Iterator
argument_list|<
name|Block
argument_list|>
name|i
init|=
name|map
operator|.
name|keySet
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
if|if
condition|(
operator|!
name|movedBlocks
operator|.
name|contains
argument_list|(
name|i
operator|.
name|next
argument_list|()
argument_list|)
condition|)
block|{
name|i
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
DECL|class|StorageGroupMap
specifier|public
specifier|static
class|class
name|StorageGroupMap
parameter_list|<
name|G
extends|extends
name|StorageGroup
parameter_list|>
block|{
DECL|method|toKey (String datanodeUuid, StorageType storageType)
specifier|private
specifier|static
name|String
name|toKey
parameter_list|(
name|String
name|datanodeUuid
parameter_list|,
name|StorageType
name|storageType
parameter_list|)
block|{
return|return
name|datanodeUuid
operator|+
literal|":"
operator|+
name|storageType
return|;
block|}
DECL|field|map
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|G
argument_list|>
name|map
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|G
argument_list|>
argument_list|()
decl_stmt|;
DECL|method|get (String datanodeUuid, StorageType storageType)
specifier|public
name|G
name|get
parameter_list|(
name|String
name|datanodeUuid
parameter_list|,
name|StorageType
name|storageType
parameter_list|)
block|{
return|return
name|map
operator|.
name|get
argument_list|(
name|toKey
argument_list|(
name|datanodeUuid
argument_list|,
name|storageType
argument_list|)
argument_list|)
return|;
block|}
DECL|method|put (G g)
specifier|public
name|void
name|put
parameter_list|(
name|G
name|g
parameter_list|)
block|{
specifier|final
name|String
name|key
init|=
name|toKey
argument_list|(
name|g
operator|.
name|getDatanodeInfo
argument_list|()
operator|.
name|getDatanodeUuid
argument_list|()
argument_list|,
name|g
operator|.
name|storageType
argument_list|)
decl_stmt|;
specifier|final
name|StorageGroup
name|existing
init|=
name|map
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|g
argument_list|)
decl_stmt|;
name|Preconditions
operator|.
name|checkState
argument_list|(
name|existing
operator|==
literal|null
argument_list|)
expr_stmt|;
block|}
DECL|method|size ()
name|int
name|size
parameter_list|()
block|{
return|return
name|map
operator|.
name|size
argument_list|()
return|;
block|}
DECL|method|clear ()
name|void
name|clear
parameter_list|()
block|{
name|map
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
DECL|method|values ()
specifier|public
name|Collection
argument_list|<
name|G
argument_list|>
name|values
parameter_list|()
block|{
return|return
name|map
operator|.
name|values
argument_list|()
return|;
block|}
block|}
comment|/** This class keeps track of a scheduled reportedBlock move */
DECL|class|PendingMove
specifier|public
class|class
name|PendingMove
block|{
DECL|field|reportedBlock
specifier|private
name|DBlock
name|reportedBlock
decl_stmt|;
DECL|field|source
specifier|private
name|Source
name|source
decl_stmt|;
DECL|field|proxySource
specifier|private
name|DDatanode
name|proxySource
decl_stmt|;
DECL|field|target
specifier|private
name|StorageGroup
name|target
decl_stmt|;
DECL|method|PendingMove (Source source, StorageGroup target)
specifier|private
name|PendingMove
parameter_list|(
name|Source
name|source
parameter_list|,
name|StorageGroup
name|target
parameter_list|)
block|{
name|this
operator|.
name|source
operator|=
name|source
expr_stmt|;
name|this
operator|.
name|target
operator|=
name|target
expr_stmt|;
block|}
DECL|method|getSource ()
specifier|public
name|DatanodeInfo
name|getSource
parameter_list|()
block|{
return|return
name|source
operator|.
name|getDatanodeInfo
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
specifier|final
name|Block
name|b
init|=
name|reportedBlock
operator|!=
literal|null
condition|?
name|reportedBlock
operator|.
name|getBlock
argument_list|()
else|:
literal|null
decl_stmt|;
name|String
name|bStr
init|=
name|b
operator|!=
literal|null
condition|?
operator|(
name|b
operator|+
literal|" with size="
operator|+
name|b
operator|.
name|getNumBytes
argument_list|()
operator|+
literal|" "
operator|)
else|:
literal|" "
decl_stmt|;
return|return
name|bStr
operator|+
literal|"from "
operator|+
name|source
operator|.
name|getDisplayName
argument_list|()
operator|+
literal|" to "
operator|+
name|target
operator|.
name|getDisplayName
argument_list|()
operator|+
literal|" through "
operator|+
operator|(
name|proxySource
operator|!=
literal|null
condition|?
name|proxySource
operator|.
name|datanode
else|:
literal|""
operator|)
return|;
block|}
comment|/**      * Choose a good block/blockGroup from source& Get reportedBlock from      * the block& Choose a proxy source for the reportedBlock.      *       * @return true if a block and its proxy are chosen; false otherwise      */
DECL|method|chooseBlockAndProxy ()
specifier|private
name|boolean
name|chooseBlockAndProxy
parameter_list|()
block|{
comment|// source and target must have the same storage type
specifier|final
name|StorageType
name|t
init|=
name|source
operator|.
name|getStorageType
argument_list|()
decl_stmt|;
comment|// iterate all source's blocks until find a good one
for|for
control|(
name|Iterator
argument_list|<
name|DBlock
argument_list|>
name|i
init|=
name|source
operator|.
name|getBlockIterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
if|if
condition|(
name|markMovedIfGoodBlock
argument_list|(
name|i
operator|.
name|next
argument_list|()
argument_list|,
name|t
argument_list|)
condition|)
block|{
name|i
operator|.
name|remove
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/**      * @return true if the given block is good for the tentative move.      */
DECL|method|markMovedIfGoodBlock (DBlock block, StorageType targetStorageType)
specifier|private
name|boolean
name|markMovedIfGoodBlock
parameter_list|(
name|DBlock
name|block
parameter_list|,
name|StorageType
name|targetStorageType
parameter_list|)
block|{
synchronized|synchronized
init|(
name|block
init|)
block|{
synchronized|synchronized
init|(
name|movedBlocks
init|)
block|{
if|if
condition|(
name|isGoodBlockCandidate
argument_list|(
name|source
argument_list|,
name|target
argument_list|,
name|targetStorageType
argument_list|,
name|block
argument_list|)
condition|)
block|{
if|if
condition|(
name|block
operator|instanceof
name|DBlockStriped
condition|)
block|{
name|reportedBlock
operator|=
operator|(
operator|(
name|DBlockStriped
operator|)
name|block
operator|)
operator|.
name|getInternalBlock
argument_list|(
name|source
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|reportedBlock
operator|=
name|block
expr_stmt|;
block|}
if|if
condition|(
name|chooseProxySource
argument_list|()
condition|)
block|{
name|movedBlocks
operator|.
name|put
argument_list|(
name|block
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Decided to move "
operator|+
name|this
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
block|}
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/**      * Choose a proxy source.      *       * @return true if a proxy is found; otherwise false      */
DECL|method|chooseProxySource ()
specifier|private
name|boolean
name|chooseProxySource
parameter_list|()
block|{
specifier|final
name|DatanodeInfo
name|targetDN
init|=
name|target
operator|.
name|getDatanodeInfo
argument_list|()
decl_stmt|;
comment|// if source and target are same nodes then no need of proxy
if|if
condition|(
name|source
operator|.
name|getDatanodeInfo
argument_list|()
operator|.
name|equals
argument_list|(
name|targetDN
argument_list|)
operator|&&
name|addTo
argument_list|(
name|source
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
comment|// if node group is supported, first try add nodes in the same node group
if|if
condition|(
name|cluster
operator|.
name|isNodeGroupAware
argument_list|()
condition|)
block|{
for|for
control|(
name|StorageGroup
name|loc
range|:
name|reportedBlock
operator|.
name|getLocations
argument_list|()
control|)
block|{
if|if
condition|(
name|cluster
operator|.
name|isOnSameNodeGroup
argument_list|(
name|loc
operator|.
name|getDatanodeInfo
argument_list|()
argument_list|,
name|targetDN
argument_list|)
operator|&&
name|addTo
argument_list|(
name|loc
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
block|}
comment|// check if there is replica which is on the same rack with the target
for|for
control|(
name|StorageGroup
name|loc
range|:
name|reportedBlock
operator|.
name|getLocations
argument_list|()
control|)
block|{
if|if
condition|(
name|cluster
operator|.
name|isOnSameRack
argument_list|(
name|loc
operator|.
name|getDatanodeInfo
argument_list|()
argument_list|,
name|targetDN
argument_list|)
operator|&&
name|addTo
argument_list|(
name|loc
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
comment|// find out a non-busy replica
for|for
control|(
name|StorageGroup
name|loc
range|:
name|reportedBlock
operator|.
name|getLocations
argument_list|()
control|)
block|{
if|if
condition|(
name|addTo
argument_list|(
name|loc
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/** add to a proxy source for specific reportedBlock movement */
DECL|method|addTo (StorageGroup g)
specifier|private
name|boolean
name|addTo
parameter_list|(
name|StorageGroup
name|g
parameter_list|)
block|{
specifier|final
name|DDatanode
name|dn
init|=
name|g
operator|.
name|getDDatanode
argument_list|()
decl_stmt|;
if|if
condition|(
name|dn
operator|.
name|addPendingBlock
argument_list|(
name|this
argument_list|)
condition|)
block|{
name|proxySource
operator|=
name|dn
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
comment|/** Dispatch the move to the proxy source& wait for the response. */
DECL|method|dispatch ()
specifier|private
name|void
name|dispatch
parameter_list|()
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Start moving "
operator|+
name|this
argument_list|)
expr_stmt|;
assert|assert
operator|!
operator|(
name|reportedBlock
operator|instanceof
name|DBlockStriped
operator|)
assert|;
name|Socket
name|sock
init|=
operator|new
name|Socket
argument_list|()
decl_stmt|;
name|DataOutputStream
name|out
init|=
literal|null
decl_stmt|;
name|DataInputStream
name|in
init|=
literal|null
decl_stmt|;
try|try
block|{
name|sock
operator|.
name|connect
argument_list|(
name|NetUtils
operator|.
name|createSocketAddr
argument_list|(
name|target
operator|.
name|getDatanodeInfo
argument_list|()
operator|.
name|getXferAddr
argument_list|(
name|Dispatcher
operator|.
name|this
operator|.
name|connectToDnViaHostname
argument_list|)
argument_list|)
argument_list|,
name|HdfsConstants
operator|.
name|READ_TIMEOUT
argument_list|)
expr_stmt|;
comment|// Set read timeout so that it doesn't hang forever against
comment|// unresponsive nodes. Datanode normally sends IN_PROGRESS response
comment|// twice within the client read timeout period (every 30 seconds by
comment|// default). Here, we make it give up after 5 minutes of no response.
name|sock
operator|.
name|setSoTimeout
argument_list|(
name|HdfsConstants
operator|.
name|READ_TIMEOUT
operator|*
literal|5
argument_list|)
expr_stmt|;
name|sock
operator|.
name|setKeepAlive
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|OutputStream
name|unbufOut
init|=
name|sock
operator|.
name|getOutputStream
argument_list|()
decl_stmt|;
name|InputStream
name|unbufIn
init|=
name|sock
operator|.
name|getInputStream
argument_list|()
decl_stmt|;
name|ExtendedBlock
name|eb
init|=
operator|new
name|ExtendedBlock
argument_list|(
name|nnc
operator|.
name|getBlockpoolID
argument_list|()
argument_list|,
name|reportedBlock
operator|.
name|getBlock
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|KeyManager
name|km
init|=
name|nnc
operator|.
name|getKeyManager
argument_list|()
decl_stmt|;
name|Token
argument_list|<
name|BlockTokenIdentifier
argument_list|>
name|accessToken
init|=
name|km
operator|.
name|getAccessToken
argument_list|(
name|eb
argument_list|,
operator|new
name|StorageType
index|[]
block|{
name|target
operator|.
name|storageType
block|}
argument_list|)
decl_stmt|;
name|IOStreamPair
name|saslStreams
init|=
name|saslClient
operator|.
name|socketSend
argument_list|(
name|sock
argument_list|,
name|unbufOut
argument_list|,
name|unbufIn
argument_list|,
name|km
argument_list|,
name|accessToken
argument_list|,
name|target
operator|.
name|getDatanodeInfo
argument_list|()
argument_list|)
decl_stmt|;
name|unbufOut
operator|=
name|saslStreams
operator|.
name|out
expr_stmt|;
name|unbufIn
operator|=
name|saslStreams
operator|.
name|in
expr_stmt|;
name|out
operator|=
operator|new
name|DataOutputStream
argument_list|(
operator|new
name|BufferedOutputStream
argument_list|(
name|unbufOut
argument_list|,
name|ioFileBufferSize
argument_list|)
argument_list|)
expr_stmt|;
name|in
operator|=
operator|new
name|DataInputStream
argument_list|(
operator|new
name|BufferedInputStream
argument_list|(
name|unbufIn
argument_list|,
name|ioFileBufferSize
argument_list|)
argument_list|)
expr_stmt|;
name|sendRequest
argument_list|(
name|out
argument_list|,
name|eb
argument_list|,
name|accessToken
argument_list|)
expr_stmt|;
name|receiveResponse
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|nnc
operator|.
name|getBytesMoved
argument_list|()
operator|.
name|addAndGet
argument_list|(
name|reportedBlock
operator|.
name|getNumBytes
argument_list|()
argument_list|)
expr_stmt|;
name|target
operator|.
name|getDDatanode
argument_list|()
operator|.
name|setHasSuccess
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Successfully moved "
operator|+
name|this
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to move "
operator|+
name|this
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|target
operator|.
name|getDDatanode
argument_list|()
operator|.
name|setHasFailure
argument_list|()
expr_stmt|;
comment|// Check that the failure is due to block pinning errors.
if|if
condition|(
name|e
operator|instanceof
name|BlockPinningException
condition|)
block|{
comment|// Pinned block can't be moved. Add this block into failure list.
comment|// Later in the next iteration mover will exclude these blocks from
comment|// pending moves.
name|target
operator|.
name|getDDatanode
argument_list|()
operator|.
name|addBlockPinningFailures
argument_list|(
name|this
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// Proxy or target may have some issues, delay before using these nodes
comment|// further in order to avoid a potential storm of "threads quota
comment|// exceeded" warnings when the dispatcher gets out of sync with work
comment|// going on in datanodes.
name|proxySource
operator|.
name|activateDelay
argument_list|(
name|delayAfterErrors
argument_list|)
expr_stmt|;
name|target
operator|.
name|getDDatanode
argument_list|()
operator|.
name|activateDelay
argument_list|(
name|delayAfterErrors
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|IOUtils
operator|.
name|closeStream
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|IOUtils
operator|.
name|closeStream
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|IOUtils
operator|.
name|closeSocket
argument_list|(
name|sock
argument_list|)
expr_stmt|;
name|proxySource
operator|.
name|removePendingBlock
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|target
operator|.
name|getDDatanode
argument_list|()
operator|.
name|removePendingBlock
argument_list|(
name|this
argument_list|)
expr_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
name|reset
argument_list|()
expr_stmt|;
block|}
synchronized|synchronized
init|(
name|Dispatcher
operator|.
name|this
init|)
block|{
name|Dispatcher
operator|.
name|this
operator|.
name|notifyAll
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/** Send a reportedBlock replace request to the output stream */
DECL|method|sendRequest (DataOutputStream out, ExtendedBlock eb, Token<BlockTokenIdentifier> accessToken)
specifier|private
name|void
name|sendRequest
parameter_list|(
name|DataOutputStream
name|out
parameter_list|,
name|ExtendedBlock
name|eb
parameter_list|,
name|Token
argument_list|<
name|BlockTokenIdentifier
argument_list|>
name|accessToken
parameter_list|)
throws|throws
name|IOException
block|{
operator|new
name|Sender
argument_list|(
name|out
argument_list|)
operator|.
name|replaceBlock
argument_list|(
name|eb
argument_list|,
name|target
operator|.
name|storageType
argument_list|,
name|accessToken
argument_list|,
name|source
operator|.
name|getDatanodeInfo
argument_list|()
operator|.
name|getDatanodeUuid
argument_list|()
argument_list|,
name|proxySource
operator|.
name|datanode
argument_list|)
expr_stmt|;
block|}
comment|/** Check whether to continue waiting for response */
DECL|method|stopWaitingForResponse (long startTime)
specifier|private
name|boolean
name|stopWaitingForResponse
parameter_list|(
name|long
name|startTime
parameter_list|)
block|{
return|return
name|source
operator|.
name|isIterationOver
argument_list|()
operator|||
operator|(
name|blockMoveTimeout
operator|>
literal|0
operator|&&
operator|(
name|Time
operator|.
name|monotonicNow
argument_list|()
operator|-
name|startTime
operator|>
name|blockMoveTimeout
operator|)
operator|)
return|;
block|}
comment|/** Receive a reportedBlock copy response from the input stream */
DECL|method|receiveResponse (DataInputStream in)
specifier|private
name|void
name|receiveResponse
parameter_list|(
name|DataInputStream
name|in
parameter_list|)
throws|throws
name|IOException
block|{
name|long
name|startTime
init|=
name|Time
operator|.
name|monotonicNow
argument_list|()
decl_stmt|;
name|BlockOpResponseProto
name|response
init|=
name|BlockOpResponseProto
operator|.
name|parseFrom
argument_list|(
name|vintPrefixed
argument_list|(
name|in
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
name|response
operator|.
name|getStatus
argument_list|()
operator|==
name|Status
operator|.
name|IN_PROGRESS
condition|)
block|{
comment|// read intermediate responses
name|response
operator|=
name|BlockOpResponseProto
operator|.
name|parseFrom
argument_list|(
name|vintPrefixed
argument_list|(
name|in
argument_list|)
argument_list|)
expr_stmt|;
comment|// Stop waiting for slow block moves. Even if it stops waiting,
comment|// the actual move may continue.
if|if
condition|(
name|stopWaitingForResponse
argument_list|(
name|startTime
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Block move timed out"
argument_list|)
throw|;
block|}
block|}
name|String
name|logInfo
init|=
literal|"reportedBlock move is failed"
decl_stmt|;
name|DataTransferProtoUtil
operator|.
name|checkBlockOpStatus
argument_list|(
name|response
argument_list|,
name|logInfo
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/** reset the object */
DECL|method|reset ()
specifier|private
name|void
name|reset
parameter_list|()
block|{
name|reportedBlock
operator|=
literal|null
expr_stmt|;
name|source
operator|=
literal|null
expr_stmt|;
name|proxySource
operator|=
literal|null
expr_stmt|;
name|target
operator|=
literal|null
expr_stmt|;
block|}
block|}
comment|/** A class for keeping track of block locations in the dispatcher. */
DECL|class|DBlock
specifier|public
specifier|static
class|class
name|DBlock
extends|extends
name|MovedBlocks
operator|.
name|Locations
argument_list|<
name|StorageGroup
argument_list|>
block|{
DECL|method|DBlock (Block block)
specifier|public
name|DBlock
parameter_list|(
name|Block
name|block
parameter_list|)
block|{
name|super
argument_list|(
name|block
argument_list|)
expr_stmt|;
block|}
DECL|method|getNumBytes (StorageGroup storage)
specifier|public
name|long
name|getNumBytes
parameter_list|(
name|StorageGroup
name|storage
parameter_list|)
block|{
return|return
name|super
operator|.
name|getNumBytes
argument_list|()
return|;
block|}
block|}
DECL|class|DBlockStriped
specifier|public
specifier|static
class|class
name|DBlockStriped
extends|extends
name|DBlock
block|{
DECL|field|indices
specifier|final
name|byte
index|[]
name|indices
decl_stmt|;
DECL|field|dataBlockNum
specifier|final
name|short
name|dataBlockNum
decl_stmt|;
DECL|field|cellSize
specifier|final
name|int
name|cellSize
decl_stmt|;
DECL|method|DBlockStriped (Block block, byte[] indices, short dataBlockNum, int cellSize)
specifier|public
name|DBlockStriped
parameter_list|(
name|Block
name|block
parameter_list|,
name|byte
index|[]
name|indices
parameter_list|,
name|short
name|dataBlockNum
parameter_list|,
name|int
name|cellSize
parameter_list|)
block|{
name|super
argument_list|(
name|block
argument_list|)
expr_stmt|;
name|this
operator|.
name|indices
operator|=
name|indices
expr_stmt|;
name|this
operator|.
name|dataBlockNum
operator|=
name|dataBlockNum
expr_stmt|;
name|this
operator|.
name|cellSize
operator|=
name|cellSize
expr_stmt|;
block|}
DECL|method|getInternalBlock (StorageGroup storage)
specifier|public
name|DBlock
name|getInternalBlock
parameter_list|(
name|StorageGroup
name|storage
parameter_list|)
block|{
name|int
name|idxInLocs
init|=
name|locations
operator|.
name|indexOf
argument_list|(
name|storage
argument_list|)
decl_stmt|;
if|if
condition|(
name|idxInLocs
operator|==
operator|-
literal|1
condition|)
block|{
return|return
literal|null
return|;
block|}
name|byte
name|idxInGroup
init|=
name|indices
index|[
name|idxInLocs
index|]
decl_stmt|;
name|long
name|blkId
init|=
name|getBlock
argument_list|()
operator|.
name|getBlockId
argument_list|()
operator|+
name|idxInGroup
decl_stmt|;
name|long
name|numBytes
init|=
name|getInternalBlockLength
argument_list|(
name|getNumBytes
argument_list|()
argument_list|,
name|cellSize
argument_list|,
name|dataBlockNum
argument_list|,
name|idxInGroup
argument_list|)
decl_stmt|;
name|Block
name|blk
init|=
operator|new
name|Block
argument_list|(
name|getBlock
argument_list|()
argument_list|)
decl_stmt|;
name|blk
operator|.
name|setBlockId
argument_list|(
name|blkId
argument_list|)
expr_stmt|;
name|blk
operator|.
name|setNumBytes
argument_list|(
name|numBytes
argument_list|)
expr_stmt|;
name|DBlock
name|dblk
init|=
operator|new
name|DBlock
argument_list|(
name|blk
argument_list|)
decl_stmt|;
name|dblk
operator|.
name|addLocation
argument_list|(
name|storage
argument_list|)
expr_stmt|;
return|return
name|dblk
return|;
block|}
annotation|@
name|Override
DECL|method|getNumBytes (StorageGroup storage)
specifier|public
name|long
name|getNumBytes
parameter_list|(
name|StorageGroup
name|storage
parameter_list|)
block|{
return|return
name|getInternalBlock
argument_list|(
name|storage
argument_list|)
operator|.
name|getNumBytes
argument_list|()
return|;
block|}
block|}
comment|/** The class represents a desired move. */
DECL|class|Task
specifier|static
class|class
name|Task
block|{
DECL|field|target
specifier|private
specifier|final
name|StorageGroup
name|target
decl_stmt|;
DECL|field|size
specifier|private
name|long
name|size
decl_stmt|;
comment|// bytes scheduled to move
DECL|method|Task (StorageGroup target, long size)
name|Task
parameter_list|(
name|StorageGroup
name|target
parameter_list|,
name|long
name|size
parameter_list|)
block|{
name|this
operator|.
name|target
operator|=
name|target
expr_stmt|;
name|this
operator|.
name|size
operator|=
name|size
expr_stmt|;
block|}
DECL|method|getSize ()
name|long
name|getSize
parameter_list|()
block|{
return|return
name|size
return|;
block|}
block|}
comment|/** A class that keeps track of a datanode. */
DECL|class|DDatanode
specifier|public
specifier|static
class|class
name|DDatanode
block|{
comment|/** A group of storages in a datanode with the same storage type. */
DECL|class|StorageGroup
specifier|public
class|class
name|StorageGroup
block|{
DECL|field|storageType
specifier|final
name|StorageType
name|storageType
decl_stmt|;
DECL|field|maxSize2Move
specifier|final
name|long
name|maxSize2Move
decl_stmt|;
DECL|field|scheduledSize
specifier|private
name|long
name|scheduledSize
init|=
literal|0L
decl_stmt|;
DECL|method|StorageGroup (StorageType storageType, long maxSize2Move)
specifier|private
name|StorageGroup
parameter_list|(
name|StorageType
name|storageType
parameter_list|,
name|long
name|maxSize2Move
parameter_list|)
block|{
name|this
operator|.
name|storageType
operator|=
name|storageType
expr_stmt|;
name|this
operator|.
name|maxSize2Move
operator|=
name|maxSize2Move
expr_stmt|;
block|}
DECL|method|getStorageType ()
specifier|public
name|StorageType
name|getStorageType
parameter_list|()
block|{
return|return
name|storageType
return|;
block|}
DECL|method|getDDatanode ()
specifier|private
name|DDatanode
name|getDDatanode
parameter_list|()
block|{
return|return
name|DDatanode
operator|.
name|this
return|;
block|}
DECL|method|getDatanodeInfo ()
specifier|public
name|DatanodeInfo
name|getDatanodeInfo
parameter_list|()
block|{
return|return
name|DDatanode
operator|.
name|this
operator|.
name|datanode
return|;
block|}
comment|/** Decide if still need to move more bytes */
DECL|method|hasSpaceForScheduling ()
name|boolean
name|hasSpaceForScheduling
parameter_list|()
block|{
return|return
name|hasSpaceForScheduling
argument_list|(
literal|0L
argument_list|)
return|;
block|}
DECL|method|hasSpaceForScheduling (long size)
specifier|synchronized
name|boolean
name|hasSpaceForScheduling
parameter_list|(
name|long
name|size
parameter_list|)
block|{
return|return
name|availableSizeToMove
argument_list|()
operator|>
name|size
return|;
block|}
comment|/** @return the total number of bytes that need to be moved */
DECL|method|availableSizeToMove ()
specifier|synchronized
name|long
name|availableSizeToMove
parameter_list|()
block|{
return|return
name|maxSize2Move
operator|-
name|scheduledSize
return|;
block|}
comment|/** increment scheduled size */
DECL|method|incScheduledSize (long size)
specifier|public
specifier|synchronized
name|void
name|incScheduledSize
parameter_list|(
name|long
name|size
parameter_list|)
block|{
name|scheduledSize
operator|+=
name|size
expr_stmt|;
block|}
comment|/** @return scheduled size */
DECL|method|getScheduledSize ()
specifier|synchronized
name|long
name|getScheduledSize
parameter_list|()
block|{
return|return
name|scheduledSize
return|;
block|}
comment|/** Reset scheduled size to zero. */
DECL|method|resetScheduledSize ()
specifier|synchronized
name|void
name|resetScheduledSize
parameter_list|()
block|{
name|scheduledSize
operator|=
literal|0L
expr_stmt|;
block|}
DECL|method|addPendingMove (DBlock block, final PendingMove pm)
specifier|private
name|PendingMove
name|addPendingMove
parameter_list|(
name|DBlock
name|block
parameter_list|,
specifier|final
name|PendingMove
name|pm
parameter_list|)
block|{
if|if
condition|(
name|getDDatanode
argument_list|()
operator|.
name|addPendingBlock
argument_list|(
name|pm
argument_list|)
condition|)
block|{
if|if
condition|(
name|pm
operator|.
name|markMovedIfGoodBlock
argument_list|(
name|block
argument_list|,
name|getStorageType
argument_list|()
argument_list|)
condition|)
block|{
name|incScheduledSize
argument_list|(
name|pm
operator|.
name|reportedBlock
operator|.
name|getNumBytes
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|pm
return|;
block|}
else|else
block|{
name|getDDatanode
argument_list|()
operator|.
name|removePendingBlock
argument_list|(
name|pm
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/** @return the name for display */
DECL|method|getDisplayName ()
name|String
name|getDisplayName
parameter_list|()
block|{
return|return
name|datanode
operator|+
literal|":"
operator|+
name|storageType
return|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|getDisplayName
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|hashCode ()
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|getStorageType
argument_list|()
operator|.
name|hashCode
argument_list|()
operator|^
name|getDatanodeInfo
argument_list|()
operator|.
name|hashCode
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|equals (Object obj)
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|obj
parameter_list|)
block|{
if|if
condition|(
name|this
operator|==
name|obj
condition|)
block|{
return|return
literal|true
return|;
block|}
elseif|else
if|if
condition|(
name|obj
operator|==
literal|null
operator|||
operator|!
operator|(
name|obj
operator|instanceof
name|StorageGroup
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
else|else
block|{
specifier|final
name|StorageGroup
name|that
init|=
operator|(
name|StorageGroup
operator|)
name|obj
decl_stmt|;
return|return
name|this
operator|.
name|getStorageType
argument_list|()
operator|==
name|that
operator|.
name|getStorageType
argument_list|()
operator|&&
name|this
operator|.
name|getDatanodeInfo
argument_list|()
operator|.
name|equals
argument_list|(
name|that
operator|.
name|getDatanodeInfo
argument_list|()
argument_list|)
return|;
block|}
block|}
block|}
DECL|field|datanode
specifier|final
name|DatanodeInfo
name|datanode
decl_stmt|;
DECL|field|sourceMap
specifier|private
specifier|final
name|EnumMap
argument_list|<
name|StorageType
argument_list|,
name|Source
argument_list|>
name|sourceMap
init|=
operator|new
name|EnumMap
argument_list|<
name|StorageType
argument_list|,
name|Source
argument_list|>
argument_list|(
name|StorageType
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|targetMap
specifier|private
specifier|final
name|EnumMap
argument_list|<
name|StorageType
argument_list|,
name|StorageGroup
argument_list|>
name|targetMap
init|=
operator|new
name|EnumMap
argument_list|<
name|StorageType
argument_list|,
name|StorageGroup
argument_list|>
argument_list|(
name|StorageType
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|delayUntil
specifier|protected
name|long
name|delayUntil
init|=
literal|0L
decl_stmt|;
comment|/** blocks being moved but not confirmed yet */
DECL|field|pendings
specifier|private
specifier|final
name|List
argument_list|<
name|PendingMove
argument_list|>
name|pendings
decl_stmt|;
DECL|field|hasFailure
specifier|private
specifier|volatile
name|boolean
name|hasFailure
init|=
literal|false
decl_stmt|;
DECL|field|blockPinningFailures
specifier|private
name|Map
argument_list|<
name|Long
argument_list|,
name|Set
argument_list|<
name|DatanodeInfo
argument_list|>
argument_list|>
name|blockPinningFailures
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|hasSuccess
specifier|private
specifier|volatile
name|boolean
name|hasSuccess
init|=
literal|false
decl_stmt|;
DECL|field|moveExecutor
specifier|private
name|ExecutorService
name|moveExecutor
decl_stmt|;
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|":"
operator|+
name|datanode
return|;
block|}
DECL|method|DDatanode (DatanodeInfo datanode, int maxConcurrentMoves)
specifier|private
name|DDatanode
parameter_list|(
name|DatanodeInfo
name|datanode
parameter_list|,
name|int
name|maxConcurrentMoves
parameter_list|)
block|{
name|this
operator|.
name|datanode
operator|=
name|datanode
expr_stmt|;
name|this
operator|.
name|pendings
operator|=
operator|new
name|ArrayList
argument_list|<
name|PendingMove
argument_list|>
argument_list|(
name|maxConcurrentMoves
argument_list|)
expr_stmt|;
block|}
DECL|method|getDatanodeInfo ()
specifier|public
name|DatanodeInfo
name|getDatanodeInfo
parameter_list|()
block|{
return|return
name|datanode
return|;
block|}
DECL|method|initMoveExecutor (int poolSize)
specifier|synchronized
name|ExecutorService
name|initMoveExecutor
parameter_list|(
name|int
name|poolSize
parameter_list|)
block|{
return|return
name|moveExecutor
operator|=
name|Executors
operator|.
name|newFixedThreadPool
argument_list|(
name|poolSize
argument_list|)
return|;
block|}
DECL|method|getMoveExecutor ()
specifier|synchronized
name|ExecutorService
name|getMoveExecutor
parameter_list|()
block|{
return|return
name|moveExecutor
return|;
block|}
DECL|method|shutdownMoveExecutor ()
specifier|synchronized
name|void
name|shutdownMoveExecutor
parameter_list|()
block|{
if|if
condition|(
name|moveExecutor
operator|!=
literal|null
condition|)
block|{
name|moveExecutor
operator|.
name|shutdown
argument_list|()
expr_stmt|;
name|moveExecutor
operator|=
literal|null
expr_stmt|;
block|}
block|}
DECL|method|put (StorageType storageType, G g, EnumMap<StorageType, G> map)
specifier|private
specifier|static
parameter_list|<
name|G
extends|extends
name|StorageGroup
parameter_list|>
name|void
name|put
parameter_list|(
name|StorageType
name|storageType
parameter_list|,
name|G
name|g
parameter_list|,
name|EnumMap
argument_list|<
name|StorageType
argument_list|,
name|G
argument_list|>
name|map
parameter_list|)
block|{
specifier|final
name|StorageGroup
name|existing
init|=
name|map
operator|.
name|put
argument_list|(
name|storageType
argument_list|,
name|g
argument_list|)
decl_stmt|;
name|Preconditions
operator|.
name|checkState
argument_list|(
name|existing
operator|==
literal|null
argument_list|)
expr_stmt|;
block|}
DECL|method|addTarget (StorageType storageType, long maxSize2Move)
specifier|public
name|StorageGroup
name|addTarget
parameter_list|(
name|StorageType
name|storageType
parameter_list|,
name|long
name|maxSize2Move
parameter_list|)
block|{
specifier|final
name|StorageGroup
name|g
init|=
operator|new
name|StorageGroup
argument_list|(
name|storageType
argument_list|,
name|maxSize2Move
argument_list|)
decl_stmt|;
name|put
argument_list|(
name|storageType
argument_list|,
name|g
argument_list|,
name|targetMap
argument_list|)
expr_stmt|;
return|return
name|g
return|;
block|}
DECL|method|addSource (StorageType storageType, long maxSize2Move, Dispatcher d)
specifier|public
name|Source
name|addSource
parameter_list|(
name|StorageType
name|storageType
parameter_list|,
name|long
name|maxSize2Move
parameter_list|,
name|Dispatcher
name|d
parameter_list|)
block|{
specifier|final
name|Source
name|s
init|=
name|d
operator|.
expr|new
name|Source
argument_list|(
name|storageType
argument_list|,
name|maxSize2Move
argument_list|,
name|this
argument_list|)
decl_stmt|;
name|put
argument_list|(
name|storageType
argument_list|,
name|s
argument_list|,
name|sourceMap
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
DECL|method|activateDelay (long delta)
specifier|synchronized
specifier|private
name|void
name|activateDelay
parameter_list|(
name|long
name|delta
parameter_list|)
block|{
name|delayUntil
operator|=
name|Time
operator|.
name|monotonicNow
argument_list|()
operator|+
name|delta
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|this
operator|+
literal|" activateDelay "
operator|+
name|delta
operator|/
literal|1000.0
operator|+
literal|" seconds"
argument_list|)
expr_stmt|;
block|}
DECL|method|isDelayActive ()
specifier|synchronized
specifier|private
name|boolean
name|isDelayActive
parameter_list|()
block|{
if|if
condition|(
name|delayUntil
operator|==
literal|0
operator|||
name|Time
operator|.
name|monotonicNow
argument_list|()
operator|>
name|delayUntil
condition|)
block|{
name|delayUntil
operator|=
literal|0
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
comment|/** Check if all the dispatched moves are done */
DECL|method|isPendingQEmpty ()
specifier|synchronized
name|boolean
name|isPendingQEmpty
parameter_list|()
block|{
return|return
name|pendings
operator|.
name|isEmpty
argument_list|()
return|;
block|}
comment|/** Add a scheduled block move to the node */
DECL|method|addPendingBlock (PendingMove pendingBlock)
specifier|synchronized
name|boolean
name|addPendingBlock
parameter_list|(
name|PendingMove
name|pendingBlock
parameter_list|)
block|{
if|if
condition|(
operator|!
name|isDelayActive
argument_list|()
condition|)
block|{
return|return
name|pendings
operator|.
name|add
argument_list|(
name|pendingBlock
argument_list|)
return|;
block|}
return|return
literal|false
return|;
block|}
comment|/** Remove a scheduled block move from the node */
DECL|method|removePendingBlock (PendingMove pendingBlock)
specifier|synchronized
name|boolean
name|removePendingBlock
parameter_list|(
name|PendingMove
name|pendingBlock
parameter_list|)
block|{
return|return
name|pendings
operator|.
name|remove
argument_list|(
name|pendingBlock
argument_list|)
return|;
block|}
DECL|method|setHasFailure ()
name|void
name|setHasFailure
parameter_list|()
block|{
name|this
operator|.
name|hasFailure
operator|=
literal|true
expr_stmt|;
block|}
DECL|method|addBlockPinningFailures (PendingMove pendingBlock)
name|void
name|addBlockPinningFailures
parameter_list|(
name|PendingMove
name|pendingBlock
parameter_list|)
block|{
synchronized|synchronized
init|(
name|blockPinningFailures
init|)
block|{
name|long
name|blockId
init|=
name|pendingBlock
operator|.
name|reportedBlock
operator|.
name|getBlock
argument_list|()
operator|.
name|getBlockId
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|DatanodeInfo
argument_list|>
name|pinnedLocations
init|=
name|blockPinningFailures
operator|.
name|get
argument_list|(
name|blockId
argument_list|)
decl_stmt|;
if|if
condition|(
name|pinnedLocations
operator|==
literal|null
condition|)
block|{
name|pinnedLocations
operator|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
expr_stmt|;
name|blockPinningFailures
operator|.
name|put
argument_list|(
name|blockId
argument_list|,
name|pinnedLocations
argument_list|)
expr_stmt|;
block|}
name|pinnedLocations
operator|.
name|add
argument_list|(
name|pendingBlock
operator|.
name|getSource
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|getBlockPinningFailureList ()
name|Map
argument_list|<
name|Long
argument_list|,
name|Set
argument_list|<
name|DatanodeInfo
argument_list|>
argument_list|>
name|getBlockPinningFailureList
parameter_list|()
block|{
return|return
name|blockPinningFailures
return|;
block|}
DECL|method|setHasSuccess ()
name|void
name|setHasSuccess
parameter_list|()
block|{
name|this
operator|.
name|hasSuccess
operator|=
literal|true
expr_stmt|;
block|}
block|}
comment|/** A node that can be the sources of a block move */
DECL|class|Source
specifier|public
class|class
name|Source
extends|extends
name|DDatanode
operator|.
name|StorageGroup
block|{
DECL|field|tasks
specifier|private
specifier|final
name|List
argument_list|<
name|Task
argument_list|>
name|tasks
init|=
operator|new
name|ArrayList
argument_list|<
name|Task
argument_list|>
argument_list|(
literal|2
argument_list|)
decl_stmt|;
DECL|field|blocksToReceive
specifier|private
name|long
name|blocksToReceive
init|=
literal|0L
decl_stmt|;
DECL|field|startTime
specifier|private
specifier|final
name|long
name|startTime
init|=
name|Time
operator|.
name|monotonicNow
argument_list|()
decl_stmt|;
comment|/**      * Source blocks point to the objects in {@link Dispatcher#globalBlocks}      * because we want to keep one copy of a block and be aware that the      * locations are changing over time.      */
DECL|field|srcBlocks
specifier|private
specifier|final
name|List
argument_list|<
name|DBlock
argument_list|>
name|srcBlocks
init|=
operator|new
name|ArrayList
argument_list|<
name|DBlock
argument_list|>
argument_list|()
decl_stmt|;
DECL|method|Source (StorageType storageType, long maxSize2Move, DDatanode dn)
specifier|private
name|Source
parameter_list|(
name|StorageType
name|storageType
parameter_list|,
name|long
name|maxSize2Move
parameter_list|,
name|DDatanode
name|dn
parameter_list|)
block|{
name|dn
operator|.
name|super
argument_list|(
name|storageType
argument_list|,
name|maxSize2Move
argument_list|)
expr_stmt|;
block|}
comment|/**      * Check if the iteration is over      */
DECL|method|isIterationOver ()
specifier|public
name|boolean
name|isIterationOver
parameter_list|()
block|{
return|return
operator|(
name|Time
operator|.
name|monotonicNow
argument_list|()
operator|-
name|startTime
operator|>
name|MAX_ITERATION_TIME
operator|)
return|;
block|}
comment|/** Add a task */
DECL|method|addTask (Task task)
name|void
name|addTask
parameter_list|(
name|Task
name|task
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkState
argument_list|(
name|task
operator|.
name|target
operator|!=
name|this
argument_list|,
literal|"Source and target are the same storage group "
operator|+
name|getDisplayName
argument_list|()
argument_list|)
expr_stmt|;
name|incScheduledSize
argument_list|(
name|task
operator|.
name|size
argument_list|)
expr_stmt|;
name|tasks
operator|.
name|add
argument_list|(
name|task
argument_list|)
expr_stmt|;
block|}
comment|/** @return an iterator to this source's blocks */
DECL|method|getBlockIterator ()
name|Iterator
argument_list|<
name|DBlock
argument_list|>
name|getBlockIterator
parameter_list|()
block|{
return|return
name|srcBlocks
operator|.
name|iterator
argument_list|()
return|;
block|}
comment|/**      * Fetch new blocks of this source from namenode and update this source's      * block list& {@link Dispatcher#globalBlocks}.      *       * @return the total size of the received blocks in the number of bytes.      */
DECL|method|getBlockList ()
specifier|private
name|long
name|getBlockList
parameter_list|()
throws|throws
name|IOException
block|{
specifier|final
name|long
name|size
init|=
name|Math
operator|.
name|min
argument_list|(
name|getBlocksSize
argument_list|,
name|blocksToReceive
argument_list|)
decl_stmt|;
specifier|final
name|BlocksWithLocations
name|newBlksLocs
init|=
name|nnc
operator|.
name|getBlocks
argument_list|(
name|getDatanodeInfo
argument_list|()
argument_list|,
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"getBlocks("
operator|+
name|getDatanodeInfo
argument_list|()
operator|+
literal|", "
operator|+
name|StringUtils
operator|.
name|TraditionalBinaryPrefix
operator|.
name|long2String
argument_list|(
name|size
argument_list|,
literal|"B"
argument_list|,
literal|2
argument_list|)
operator|+
literal|") returns "
operator|+
name|newBlksLocs
operator|.
name|getBlocks
argument_list|()
operator|.
name|length
operator|+
literal|" blocks."
argument_list|)
expr_stmt|;
block|}
name|long
name|bytesReceived
init|=
literal|0
decl_stmt|;
for|for
control|(
name|BlockWithLocations
name|blkLocs
range|:
name|newBlksLocs
operator|.
name|getBlocks
argument_list|()
control|)
block|{
comment|// Skip small blocks.
if|if
condition|(
name|blkLocs
operator|.
name|getBlock
argument_list|()
operator|.
name|getNumBytes
argument_list|()
operator|<
name|getBlocksMinBlockSize
condition|)
block|{
continue|continue;
block|}
name|DBlock
name|block
decl_stmt|;
if|if
condition|(
name|blkLocs
operator|instanceof
name|StripedBlockWithLocations
condition|)
block|{
name|StripedBlockWithLocations
name|sblkLocs
init|=
operator|(
name|StripedBlockWithLocations
operator|)
name|blkLocs
decl_stmt|;
comment|// approximate size
name|bytesReceived
operator|+=
name|sblkLocs
operator|.
name|getBlock
argument_list|()
operator|.
name|getNumBytes
argument_list|()
operator|/
name|sblkLocs
operator|.
name|getDataBlockNum
argument_list|()
expr_stmt|;
name|block
operator|=
operator|new
name|DBlockStriped
argument_list|(
name|sblkLocs
operator|.
name|getBlock
argument_list|()
argument_list|,
name|sblkLocs
operator|.
name|getIndices
argument_list|()
argument_list|,
name|sblkLocs
operator|.
name|getDataBlockNum
argument_list|()
argument_list|,
name|sblkLocs
operator|.
name|getCellSize
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bytesReceived
operator|+=
name|blkLocs
operator|.
name|getBlock
argument_list|()
operator|.
name|getNumBytes
argument_list|()
expr_stmt|;
name|block
operator|=
operator|new
name|DBlock
argument_list|(
name|blkLocs
operator|.
name|getBlock
argument_list|()
argument_list|)
expr_stmt|;
block|}
synchronized|synchronized
init|(
name|globalBlocks
init|)
block|{
name|block
operator|=
name|globalBlocks
operator|.
name|putIfAbsent
argument_list|(
name|blkLocs
operator|.
name|getBlock
argument_list|()
argument_list|,
name|block
argument_list|)
expr_stmt|;
synchronized|synchronized
init|(
name|block
init|)
block|{
name|block
operator|.
name|clearLocations
argument_list|()
expr_stmt|;
comment|// update locations
specifier|final
name|String
index|[]
name|datanodeUuids
init|=
name|blkLocs
operator|.
name|getDatanodeUuids
argument_list|()
decl_stmt|;
specifier|final
name|StorageType
index|[]
name|storageTypes
init|=
name|blkLocs
operator|.
name|getStorageTypes
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|datanodeUuids
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|StorageGroup
name|g
init|=
name|storageGroupMap
operator|.
name|get
argument_list|(
name|datanodeUuids
index|[
name|i
index|]
argument_list|,
name|storageTypes
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|g
operator|!=
literal|null
condition|)
block|{
comment|// not unknown
name|block
operator|.
name|addLocation
argument_list|(
name|g
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|srcBlocks
operator|.
name|contains
argument_list|(
name|block
argument_list|)
operator|&&
name|isGoodBlockCandidate
argument_list|(
name|block
argument_list|)
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Add "
operator|+
name|block
operator|+
literal|" to "
operator|+
name|this
argument_list|)
expr_stmt|;
block|}
name|srcBlocks
operator|.
name|add
argument_list|(
name|block
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|bytesReceived
return|;
block|}
comment|/** Decide if the given block is a good candidate to move or not */
DECL|method|isGoodBlockCandidate (DBlock block)
specifier|private
name|boolean
name|isGoodBlockCandidate
parameter_list|(
name|DBlock
name|block
parameter_list|)
block|{
comment|// source and target must have the same storage type
specifier|final
name|StorageType
name|sourceStorageType
init|=
name|getStorageType
argument_list|()
decl_stmt|;
for|for
control|(
name|Task
name|t
range|:
name|tasks
control|)
block|{
if|if
condition|(
name|Dispatcher
operator|.
name|this
operator|.
name|isGoodBlockCandidate
argument_list|(
name|this
argument_list|,
name|t
operator|.
name|target
argument_list|,
name|sourceStorageType
argument_list|,
name|block
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/**      * Choose a move for the source. The block's source, target, and proxy      * are determined too. When choosing proxy and target, source&      * target throttling has been considered. They are chosen only when they      * have the capacity to support this block move. The block should be      * dispatched immediately after this method is returned.      * If the block is a block group. Only the internal block on this source      * will be dispatched.      *       * @return a move that's good for the source to dispatch immediately.      */
DECL|method|chooseNextMove ()
specifier|private
name|PendingMove
name|chooseNextMove
parameter_list|()
block|{
for|for
control|(
name|Iterator
argument_list|<
name|Task
argument_list|>
name|i
init|=
name|tasks
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
specifier|final
name|Task
name|task
init|=
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
specifier|final
name|DDatanode
name|target
init|=
name|task
operator|.
name|target
operator|.
name|getDDatanode
argument_list|()
decl_stmt|;
specifier|final
name|PendingMove
name|pendingBlock
init|=
operator|new
name|PendingMove
argument_list|(
name|this
argument_list|,
name|task
operator|.
name|target
argument_list|)
decl_stmt|;
if|if
condition|(
name|target
operator|.
name|addPendingBlock
argument_list|(
name|pendingBlock
argument_list|)
condition|)
block|{
comment|// target is not busy, so do a tentative block allocation
if|if
condition|(
name|pendingBlock
operator|.
name|chooseBlockAndProxy
argument_list|()
condition|)
block|{
name|long
name|blockSize
init|=
name|pendingBlock
operator|.
name|reportedBlock
operator|.
name|getNumBytes
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|incScheduledSize
argument_list|(
operator|-
name|blockSize
argument_list|)
expr_stmt|;
name|task
operator|.
name|size
operator|-=
name|blockSize
expr_stmt|;
if|if
condition|(
name|task
operator|.
name|size
operator|<=
literal|0
condition|)
block|{
name|i
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
return|return
name|pendingBlock
return|;
block|}
else|else
block|{
comment|// cancel the tentative move
name|target
operator|.
name|removePendingBlock
argument_list|(
name|pendingBlock
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/** Add a pending move */
DECL|method|addPendingMove (DBlock block, StorageGroup target)
specifier|public
name|PendingMove
name|addPendingMove
parameter_list|(
name|DBlock
name|block
parameter_list|,
name|StorageGroup
name|target
parameter_list|)
block|{
return|return
name|target
operator|.
name|addPendingMove
argument_list|(
name|block
argument_list|,
operator|new
name|PendingMove
argument_list|(
name|this
argument_list|,
name|target
argument_list|)
argument_list|)
return|;
block|}
comment|/** Iterate all source's blocks to remove moved ones */
DECL|method|removeMovedBlocks ()
specifier|private
name|void
name|removeMovedBlocks
parameter_list|()
block|{
for|for
control|(
name|Iterator
argument_list|<
name|DBlock
argument_list|>
name|i
init|=
name|getBlockIterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
if|if
condition|(
name|movedBlocks
operator|.
name|contains
argument_list|(
name|i
operator|.
name|next
argument_list|()
operator|.
name|getBlock
argument_list|()
argument_list|)
condition|)
block|{
name|i
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/** @return if should fetch more blocks from namenode */
DECL|method|shouldFetchMoreBlocks ()
specifier|private
name|boolean
name|shouldFetchMoreBlocks
parameter_list|()
block|{
return|return
name|blocksToReceive
operator|>
literal|0
return|;
block|}
DECL|field|MAX_ITERATION_TIME
specifier|private
specifier|static
specifier|final
name|long
name|MAX_ITERATION_TIME
init|=
literal|20
operator|*
literal|60
operator|*
literal|1000L
decl_stmt|;
comment|// 20 mins
comment|/**      * This method iteratively does the following: it first selects a block to      * move, then sends a request to the proxy source to start the block move      * when the source's block list falls below a threshold, it asks the      * namenode for more blocks. It terminates when it has dispatch enough block      * move tasks or it has received enough blocks from the namenode, or the      * elapsed time of the iteration has exceeded the max time limit.      *      * @param delay - time to sleep before sending getBlocks. Intended to      * disperse Balancer RPCs to NameNode for large clusters. See HDFS-11384.      */
DECL|method|dispatchBlocks (long delay)
specifier|private
name|void
name|dispatchBlocks
parameter_list|(
name|long
name|delay
parameter_list|)
block|{
name|this
operator|.
name|blocksToReceive
operator|=
literal|2
operator|*
name|getScheduledSize
argument_list|()
expr_stmt|;
name|long
name|previousMoveTimestamp
init|=
name|Time
operator|.
name|monotonicNow
argument_list|()
decl_stmt|;
while|while
condition|(
name|getScheduledSize
argument_list|()
operator|>
literal|0
operator|&&
operator|!
name|isIterationOver
argument_list|()
operator|&&
operator|(
operator|!
name|srcBlocks
operator|.
name|isEmpty
argument_list|()
operator|||
name|blocksToReceive
operator|>
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
name|this
operator|+
literal|" blocksToReceive="
operator|+
name|blocksToReceive
operator|+
literal|", scheduledSize="
operator|+
name|getScheduledSize
argument_list|()
operator|+
literal|", srcBlocks#="
operator|+
name|srcBlocks
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|final
name|PendingMove
name|p
init|=
name|chooseNextMove
argument_list|()
decl_stmt|;
if|if
condition|(
name|p
operator|!=
literal|null
condition|)
block|{
comment|// Reset previous move timestamp
name|previousMoveTimestamp
operator|=
name|Time
operator|.
name|monotonicNow
argument_list|()
expr_stmt|;
name|executePendingMove
argument_list|(
name|p
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|// Since we cannot schedule any block to move,
comment|// remove any moved blocks from the source block list and
name|removeMovedBlocks
argument_list|()
expr_stmt|;
comment|// filter already moved blocks
comment|// check if we should fetch more blocks from the namenode
if|if
condition|(
name|shouldFetchMoreBlocks
argument_list|()
condition|)
block|{
comment|// fetch new blocks
try|try
block|{
if|if
condition|(
name|delay
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Sleeping "
operator|+
name|delay
operator|+
literal|"  msec."
argument_list|)
expr_stmt|;
block|}
name|Thread
operator|.
name|sleep
argument_list|(
name|delay
argument_list|)
expr_stmt|;
block|}
specifier|final
name|long
name|received
init|=
name|getBlockList
argument_list|()
decl_stmt|;
if|if
condition|(
name|received
operator|==
literal|0
condition|)
block|{
return|return;
block|}
name|blocksToReceive
operator|-=
name|received
expr_stmt|;
continue|continue;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ignored
parameter_list|)
block|{
comment|// nothing to do
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Exception while getting reportedBlock list"
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return;
block|}
finally|finally
block|{
name|delay
operator|=
literal|0L
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// jump out of while-loop after the configured timeout.
name|long
name|noMoveInterval
init|=
name|Time
operator|.
name|monotonicNow
argument_list|()
operator|-
name|previousMoveTimestamp
decl_stmt|;
if|if
condition|(
name|noMoveInterval
operator|>
name|maxNoMoveInterval
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Failed to find a pending move for "
operator|+
name|noMoveInterval
operator|+
literal|" ms.  Skipping "
operator|+
name|this
argument_list|)
expr_stmt|;
name|resetScheduledSize
argument_list|()
expr_stmt|;
block|}
block|}
comment|// Now we can not schedule any block to move and there are
comment|// no new blocks added to the source block list, so we wait.
try|try
block|{
synchronized|synchronized
init|(
name|Dispatcher
operator|.
name|this
init|)
block|{
name|Dispatcher
operator|.
name|this
operator|.
name|wait
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
comment|// wait for targets/sources to be idle
block|}
comment|// Didn't find a possible move in this iteration of the while loop,
comment|// adding a small delay before choosing next move again.
name|Thread
operator|.
name|sleep
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ignored
parameter_list|)
block|{         }
block|}
if|if
condition|(
name|isIterationOver
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"The maximum iteration time ("
operator|+
name|MAX_ITERATION_TIME
operator|/
literal|1000
operator|+
literal|" seconds) has been reached. Stopping "
operator|+
name|this
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|hashCode ()
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|super
operator|.
name|hashCode
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|equals (Object obj)
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|obj
parameter_list|)
block|{
return|return
name|super
operator|.
name|equals
argument_list|(
name|obj
argument_list|)
return|;
block|}
block|}
comment|/** Constructor called by Mover. */
DECL|method|Dispatcher (NameNodeConnector nnc, Set<String> includedNodes, Set<String> excludedNodes, long movedWinWidth, int moverThreads, int dispatcherThreads, int maxConcurrentMovesPerNode, int maxNoMoveInterval, Configuration conf)
specifier|public
name|Dispatcher
parameter_list|(
name|NameNodeConnector
name|nnc
parameter_list|,
name|Set
argument_list|<
name|String
argument_list|>
name|includedNodes
parameter_list|,
name|Set
argument_list|<
name|String
argument_list|>
name|excludedNodes
parameter_list|,
name|long
name|movedWinWidth
parameter_list|,
name|int
name|moverThreads
parameter_list|,
name|int
name|dispatcherThreads
parameter_list|,
name|int
name|maxConcurrentMovesPerNode
parameter_list|,
name|int
name|maxNoMoveInterval
parameter_list|,
name|Configuration
name|conf
parameter_list|)
block|{
name|this
argument_list|(
name|nnc
argument_list|,
name|includedNodes
argument_list|,
name|excludedNodes
argument_list|,
name|movedWinWidth
argument_list|,
name|moverThreads
argument_list|,
name|dispatcherThreads
argument_list|,
name|maxConcurrentMovesPerNode
argument_list|,
literal|0L
argument_list|,
literal|0L
argument_list|,
literal|0
argument_list|,
name|maxNoMoveInterval
argument_list|,
name|conf
argument_list|)
expr_stmt|;
block|}
DECL|method|Dispatcher (NameNodeConnector nnc, Set<String> includedNodes, Set<String> excludedNodes, long movedWinWidth, int moverThreads, int dispatcherThreads, int maxConcurrentMovesPerNode, long getBlocksSize, long getBlocksMinBlockSize, int blockMoveTimeout, int maxNoMoveInterval, Configuration conf)
name|Dispatcher
parameter_list|(
name|NameNodeConnector
name|nnc
parameter_list|,
name|Set
argument_list|<
name|String
argument_list|>
name|includedNodes
parameter_list|,
name|Set
argument_list|<
name|String
argument_list|>
name|excludedNodes
parameter_list|,
name|long
name|movedWinWidth
parameter_list|,
name|int
name|moverThreads
parameter_list|,
name|int
name|dispatcherThreads
parameter_list|,
name|int
name|maxConcurrentMovesPerNode
parameter_list|,
name|long
name|getBlocksSize
parameter_list|,
name|long
name|getBlocksMinBlockSize
parameter_list|,
name|int
name|blockMoveTimeout
parameter_list|,
name|int
name|maxNoMoveInterval
parameter_list|,
name|Configuration
name|conf
parameter_list|)
block|{
name|this
operator|.
name|nnc
operator|=
name|nnc
expr_stmt|;
name|this
operator|.
name|excludedNodes
operator|=
name|excludedNodes
expr_stmt|;
name|this
operator|.
name|includedNodes
operator|=
name|includedNodes
expr_stmt|;
name|this
operator|.
name|movedBlocks
operator|=
operator|new
name|MovedBlocks
argument_list|<
name|StorageGroup
argument_list|>
argument_list|(
name|movedWinWidth
argument_list|)
expr_stmt|;
name|this
operator|.
name|cluster
operator|=
name|NetworkTopology
operator|.
name|getInstance
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|dispatchExecutor
operator|=
name|dispatcherThreads
operator|==
literal|0
condition|?
literal|null
else|:
name|Executors
operator|.
name|newFixedThreadPool
argument_list|(
name|dispatcherThreads
argument_list|)
expr_stmt|;
name|this
operator|.
name|moverThreadAllocator
operator|=
operator|new
name|Allocator
argument_list|(
name|moverThreads
argument_list|)
expr_stmt|;
name|this
operator|.
name|maxConcurrentMovesPerNode
operator|=
name|maxConcurrentMovesPerNode
expr_stmt|;
name|this
operator|.
name|getBlocksSize
operator|=
name|getBlocksSize
expr_stmt|;
name|this
operator|.
name|getBlocksMinBlockSize
operator|=
name|getBlocksMinBlockSize
expr_stmt|;
name|this
operator|.
name|blockMoveTimeout
operator|=
name|blockMoveTimeout
expr_stmt|;
name|this
operator|.
name|maxNoMoveInterval
operator|=
name|maxNoMoveInterval
expr_stmt|;
name|this
operator|.
name|saslClient
operator|=
operator|new
name|SaslDataTransferClient
argument_list|(
name|conf
argument_list|,
name|DataTransferSaslUtil
operator|.
name|getSaslPropertiesResolver
argument_list|(
name|conf
argument_list|)
argument_list|,
name|TrustedChannelResolver
operator|.
name|getInstance
argument_list|(
name|conf
argument_list|)
argument_list|,
name|nnc
operator|.
name|fallbackToSimpleAuth
argument_list|)
expr_stmt|;
name|this
operator|.
name|ioFileBufferSize
operator|=
name|DFSUtilClient
operator|.
name|getIoFileBufferSize
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|connectToDnViaHostname
operator|=
name|conf
operator|.
name|getBoolean
argument_list|(
name|HdfsClientConfigKeys
operator|.
name|DFS_CLIENT_USE_DN_HOSTNAME
argument_list|,
name|HdfsClientConfigKeys
operator|.
name|DFS_CLIENT_USE_DN_HOSTNAME_DEFAULT
argument_list|)
expr_stmt|;
name|placementPolicies
operator|=
operator|new
name|BlockPlacementPolicies
argument_list|(
name|conf
argument_list|,
literal|null
argument_list|,
name|cluster
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
DECL|method|getDistributedFileSystem ()
specifier|public
name|DistributedFileSystem
name|getDistributedFileSystem
parameter_list|()
block|{
return|return
name|nnc
operator|.
name|getDistributedFileSystem
argument_list|()
return|;
block|}
DECL|method|getStorageGroupMap ()
specifier|public
name|StorageGroupMap
argument_list|<
name|StorageGroup
argument_list|>
name|getStorageGroupMap
parameter_list|()
block|{
return|return
name|storageGroupMap
return|;
block|}
DECL|method|getCluster ()
specifier|public
name|NetworkTopology
name|getCluster
parameter_list|()
block|{
return|return
name|cluster
return|;
block|}
DECL|method|getBytesMoved ()
name|long
name|getBytesMoved
parameter_list|()
block|{
return|return
name|nnc
operator|.
name|getBytesMoved
argument_list|()
operator|.
name|get
argument_list|()
return|;
block|}
DECL|method|bytesToMove ()
name|long
name|bytesToMove
parameter_list|()
block|{
name|Preconditions
operator|.
name|checkState
argument_list|(
name|storageGroupMap
operator|.
name|size
argument_list|()
operator|>=
name|sources
operator|.
name|size
argument_list|()
operator|+
name|targets
operator|.
name|size
argument_list|()
argument_list|,
literal|"Mismatched number of storage groups ("
operator|+
name|storageGroupMap
operator|.
name|size
argument_list|()
operator|+
literal|"< "
operator|+
name|sources
operator|.
name|size
argument_list|()
operator|+
literal|" sources + "
operator|+
name|targets
operator|.
name|size
argument_list|()
operator|+
literal|" targets)"
argument_list|)
expr_stmt|;
name|long
name|b
init|=
literal|0L
decl_stmt|;
for|for
control|(
name|Source
name|src
range|:
name|sources
control|)
block|{
name|b
operator|+=
name|src
operator|.
name|getScheduledSize
argument_list|()
expr_stmt|;
block|}
return|return
name|b
return|;
block|}
DECL|method|add (Source source, StorageGroup target)
name|void
name|add
parameter_list|(
name|Source
name|source
parameter_list|,
name|StorageGroup
name|target
parameter_list|)
block|{
name|sources
operator|.
name|add
argument_list|(
name|source
argument_list|)
expr_stmt|;
name|targets
operator|.
name|add
argument_list|(
name|target
argument_list|)
expr_stmt|;
block|}
DECL|method|shouldIgnore (DatanodeInfo dn)
specifier|private
name|boolean
name|shouldIgnore
parameter_list|(
name|DatanodeInfo
name|dn
parameter_list|)
block|{
comment|// ignore out-of-service nodes
specifier|final
name|boolean
name|outOfService
init|=
operator|!
name|dn
operator|.
name|isInService
argument_list|()
decl_stmt|;
comment|// ignore nodes in exclude list
specifier|final
name|boolean
name|excluded
init|=
name|Util
operator|.
name|isExcluded
argument_list|(
name|excludedNodes
argument_list|,
name|dn
argument_list|)
decl_stmt|;
comment|// ignore nodes not in the include list (if include list is not empty)
specifier|final
name|boolean
name|notIncluded
init|=
operator|!
name|Util
operator|.
name|isIncluded
argument_list|(
name|includedNodes
argument_list|,
name|dn
argument_list|)
decl_stmt|;
if|if
condition|(
name|outOfService
operator|||
name|excluded
operator|||
name|notIncluded
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Excluding datanode "
operator|+
name|dn
operator|+
literal|": outOfService="
operator|+
name|outOfService
operator|+
literal|", excluded="
operator|+
name|excluded
operator|+
literal|", notIncluded="
operator|+
name|notIncluded
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
comment|/** Get live datanode storage reports and then build the network topology. */
DECL|method|init ()
specifier|public
name|List
argument_list|<
name|DatanodeStorageReport
argument_list|>
name|init
parameter_list|()
throws|throws
name|IOException
block|{
specifier|final
name|DatanodeStorageReport
index|[]
name|reports
init|=
name|nnc
operator|.
name|getLiveDatanodeStorageReport
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|DatanodeStorageReport
argument_list|>
name|trimmed
init|=
operator|new
name|ArrayList
argument_list|<
name|DatanodeStorageReport
argument_list|>
argument_list|()
decl_stmt|;
comment|// create network topology and classify utilization collections:
comment|// over-utilized, above-average, below-average and under-utilized.
for|for
control|(
name|DatanodeStorageReport
name|r
range|:
name|DFSUtil
operator|.
name|shuffle
argument_list|(
name|reports
argument_list|)
control|)
block|{
specifier|final
name|DatanodeInfo
name|datanode
init|=
name|r
operator|.
name|getDatanodeInfo
argument_list|()
decl_stmt|;
if|if
condition|(
name|shouldIgnore
argument_list|(
name|datanode
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|trimmed
operator|.
name|add
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|cluster
operator|.
name|add
argument_list|(
name|datanode
argument_list|)
expr_stmt|;
block|}
return|return
name|trimmed
return|;
block|}
DECL|method|newDatanode (DatanodeInfo datanode)
specifier|public
name|DDatanode
name|newDatanode
parameter_list|(
name|DatanodeInfo
name|datanode
parameter_list|)
block|{
return|return
operator|new
name|DDatanode
argument_list|(
name|datanode
argument_list|,
name|maxConcurrentMovesPerNode
argument_list|)
return|;
block|}
DECL|method|executePendingMove (final PendingMove p)
specifier|public
name|void
name|executePendingMove
parameter_list|(
specifier|final
name|PendingMove
name|p
parameter_list|)
block|{
comment|// move the reportedBlock
specifier|final
name|DDatanode
name|targetDn
init|=
name|p
operator|.
name|target
operator|.
name|getDDatanode
argument_list|()
decl_stmt|;
name|ExecutorService
name|moveExecutor
init|=
name|targetDn
operator|.
name|getMoveExecutor
argument_list|()
decl_stmt|;
if|if
condition|(
name|moveExecutor
operator|==
literal|null
condition|)
block|{
specifier|final
name|int
name|nThreads
init|=
name|moverThreadAllocator
operator|.
name|allocate
argument_list|(
name|maxConcurrentMovesPerNode
argument_list|)
decl_stmt|;
if|if
condition|(
name|nThreads
operator|>
literal|0
condition|)
block|{
name|moveExecutor
operator|=
name|targetDn
operator|.
name|initMoveExecutor
argument_list|(
name|nThreads
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|moveExecutor
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"No mover threads available: skip moving "
operator|+
name|p
argument_list|)
expr_stmt|;
name|targetDn
operator|.
name|removePendingBlock
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|.
name|proxySource
operator|.
name|removePendingBlock
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return;
block|}
name|moveExecutor
operator|.
name|execute
argument_list|(
operator|new
name|Runnable
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
name|p
operator|.
name|dispatch
argument_list|()
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
DECL|method|dispatchAndCheckContinue ()
specifier|public
name|boolean
name|dispatchAndCheckContinue
parameter_list|()
throws|throws
name|InterruptedException
block|{
return|return
name|nnc
operator|.
name|shouldContinue
argument_list|(
name|dispatchBlockMoves
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * The best-effort limit on the number of RPCs per second    * the Balancer will send to the NameNode.    */
DECL|field|BALANCER_NUM_RPC_PER_SEC
specifier|final
specifier|static
name|int
name|BALANCER_NUM_RPC_PER_SEC
init|=
literal|20
decl_stmt|;
comment|/**    * Dispatch block moves for each source. The thread selects blocks to move&    * sends request to proxy source to initiate block move. The process is flow    * controlled. Block selection is blocked if there are too many un-confirmed    * block moves.    *     * @return the total number of bytes successfully moved in this iteration.    */
DECL|method|dispatchBlockMoves ()
specifier|private
name|long
name|dispatchBlockMoves
parameter_list|()
throws|throws
name|InterruptedException
block|{
specifier|final
name|long
name|bytesLastMoved
init|=
name|getBytesMoved
argument_list|()
decl_stmt|;
specifier|final
name|Future
argument_list|<
name|?
argument_list|>
index|[]
name|futures
init|=
operator|new
name|Future
argument_list|<
name|?
argument_list|>
index|[
name|sources
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
name|int
name|concurrentThreads
init|=
name|Math
operator|.
name|min
argument_list|(
name|sources
operator|.
name|size
argument_list|()
argument_list|,
operator|(
operator|(
name|ThreadPoolExecutor
operator|)
name|dispatchExecutor
operator|)
operator|.
name|getCorePoolSize
argument_list|()
argument_list|)
decl_stmt|;
assert|assert
name|concurrentThreads
operator|>
literal|0
operator|:
literal|"Number of concurrent threads is 0."
assert|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Balancer allowed RPCs per sec = "
operator|+
name|BALANCER_NUM_RPC_PER_SEC
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Balancer concurrent threads = "
operator|+
name|concurrentThreads
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Disperse Interval sec = "
operator|+
name|concurrentThreads
operator|/
name|BALANCER_NUM_RPC_PER_SEC
argument_list|)
expr_stmt|;
block|}
name|long
name|dSec
init|=
literal|0
decl_stmt|;
specifier|final
name|Iterator
argument_list|<
name|Source
argument_list|>
name|i
init|=
name|sources
operator|.
name|iterator
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|futures
operator|.
name|length
condition|;
name|j
operator|++
control|)
block|{
specifier|final
name|Source
name|s
init|=
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
specifier|final
name|long
name|delay
init|=
name|dSec
operator|*
literal|1000
decl_stmt|;
name|futures
index|[
name|j
index|]
operator|=
name|dispatchExecutor
operator|.
name|submit
argument_list|(
operator|new
name|Runnable
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
name|s
operator|.
name|dispatchBlocks
argument_list|(
name|delay
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
comment|// Calculate delay in seconds for the next iteration
if|if
condition|(
name|j
operator|>=
name|concurrentThreads
condition|)
block|{
name|dSec
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|j
operator|+
literal|1
operator|)
operator|%
name|BALANCER_NUM_RPC_PER_SEC
operator|==
literal|0
condition|)
block|{
name|dSec
operator|++
expr_stmt|;
block|}
block|}
comment|// wait for all dispatcher threads to finish
for|for
control|(
name|Future
argument_list|<
name|?
argument_list|>
name|future
range|:
name|futures
control|)
block|{
try|try
block|{
name|future
operator|.
name|get
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ExecutionException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Dispatcher thread failed"
argument_list|,
name|e
operator|.
name|getCause
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|// wait for all reportedBlock moving to be done
name|waitForMoveCompletion
argument_list|(
name|targets
argument_list|)
expr_stmt|;
return|return
name|getBytesMoved
argument_list|()
operator|-
name|bytesLastMoved
return|;
block|}
comment|/**    * Wait for all reportedBlock move confirmations.    * @return true if there is failed move execution    */
DECL|method|waitForMoveCompletion ( Iterable<? extends StorageGroup> targets)
specifier|public
specifier|static
name|boolean
name|waitForMoveCompletion
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|StorageGroup
argument_list|>
name|targets
parameter_list|)
block|{
name|boolean
name|hasFailure
init|=
literal|false
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|boolean
name|empty
init|=
literal|true
decl_stmt|;
for|for
control|(
name|StorageGroup
name|t
range|:
name|targets
control|)
block|{
if|if
condition|(
operator|!
name|t
operator|.
name|getDDatanode
argument_list|()
operator|.
name|isPendingQEmpty
argument_list|()
condition|)
block|{
name|empty
operator|=
literal|false
expr_stmt|;
break|break;
block|}
else|else
block|{
name|hasFailure
operator||=
name|t
operator|.
name|getDDatanode
argument_list|()
operator|.
name|hasFailure
expr_stmt|;
block|}
block|}
if|if
condition|(
name|empty
condition|)
block|{
return|return
name|hasFailure
return|;
comment|// all pending queues are empty
block|}
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ignored
parameter_list|)
block|{       }
block|}
block|}
comment|/**    * Check any of the block movements are failed due to block pinning errors. If    * yes, add the failed blockId and its respective source node location to the    * excluded list.    */
DECL|method|checkForBlockPinningFailures ( Map<Long, Set<DatanodeInfo>> excludedPinnedBlocks, Iterable<? extends StorageGroup> targets)
specifier|public
specifier|static
name|void
name|checkForBlockPinningFailures
parameter_list|(
name|Map
argument_list|<
name|Long
argument_list|,
name|Set
argument_list|<
name|DatanodeInfo
argument_list|>
argument_list|>
name|excludedPinnedBlocks
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|StorageGroup
argument_list|>
name|targets
parameter_list|)
block|{
for|for
control|(
name|StorageGroup
name|t
range|:
name|targets
control|)
block|{
name|Map
argument_list|<
name|Long
argument_list|,
name|Set
argument_list|<
name|DatanodeInfo
argument_list|>
argument_list|>
name|blockPinningFailureList
init|=
name|t
operator|.
name|getDDatanode
argument_list|()
operator|.
name|getBlockPinningFailureList
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|Entry
argument_list|<
name|Long
argument_list|,
name|Set
argument_list|<
name|DatanodeInfo
argument_list|>
argument_list|>
argument_list|>
name|entrySet
init|=
name|blockPinningFailureList
operator|.
name|entrySet
argument_list|()
decl_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|Long
argument_list|,
name|Set
argument_list|<
name|DatanodeInfo
argument_list|>
argument_list|>
name|entry
range|:
name|entrySet
control|)
block|{
name|Long
name|blockId
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|DatanodeInfo
argument_list|>
name|locs
init|=
name|excludedPinnedBlocks
operator|.
name|get
argument_list|(
name|blockId
argument_list|)
decl_stmt|;
if|if
condition|(
name|locs
operator|==
literal|null
condition|)
block|{
comment|// blockId doesn't exists in the excluded list.
name|locs
operator|=
name|entry
operator|.
name|getValue
argument_list|()
expr_stmt|;
name|excludedPinnedBlocks
operator|.
name|put
argument_list|(
name|blockId
argument_list|,
name|locs
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// blockId already exists in the excluded list, add the pinned node.
name|locs
operator|.
name|addAll
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**    * @return true if some moves are success.    */
DECL|method|checkForSuccess ( Iterable<? extends StorageGroup> targets)
specifier|public
specifier|static
name|boolean
name|checkForSuccess
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|StorageGroup
argument_list|>
name|targets
parameter_list|)
block|{
name|boolean
name|hasSuccess
init|=
literal|false
decl_stmt|;
for|for
control|(
name|StorageGroup
name|t
range|:
name|targets
control|)
block|{
name|hasSuccess
operator||=
name|t
operator|.
name|getDDatanode
argument_list|()
operator|.
name|hasSuccess
expr_stmt|;
block|}
return|return
name|hasSuccess
return|;
block|}
comment|/**    * Decide if the block/blockGroup is a good candidate to be moved from source    * to target. A block is a good candidate if    * 1. the block is not in the process of being moved/has not been moved;    * 2. the block does not have a replica/internalBlock on the target;    * 3. doing the move does not reduce the number of racks that the block has    */
DECL|method|isGoodBlockCandidate (StorageGroup source, StorageGroup target, StorageType targetStorageType, DBlock block)
specifier|private
name|boolean
name|isGoodBlockCandidate
parameter_list|(
name|StorageGroup
name|source
parameter_list|,
name|StorageGroup
name|target
parameter_list|,
name|StorageType
name|targetStorageType
parameter_list|,
name|DBlock
name|block
parameter_list|)
block|{
if|if
condition|(
name|source
operator|.
name|equals
argument_list|(
name|target
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|target
operator|.
name|storageType
operator|!=
name|targetStorageType
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// check if the block is moved or not
if|if
condition|(
name|movedBlocks
operator|.
name|contains
argument_list|(
name|block
operator|.
name|getBlock
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
specifier|final
name|DatanodeInfo
name|targetDatanode
init|=
name|target
operator|.
name|getDatanodeInfo
argument_list|()
decl_stmt|;
if|if
condition|(
name|source
operator|.
name|getDatanodeInfo
argument_list|()
operator|.
name|equals
argument_list|(
name|targetDatanode
argument_list|)
condition|)
block|{
comment|// the reportedBlock is moved inside same DN
return|return
literal|true
return|;
block|}
comment|// check if block has replica in target node
for|for
control|(
name|StorageGroup
name|blockLocation
range|:
name|block
operator|.
name|getLocations
argument_list|()
control|)
block|{
if|if
condition|(
name|blockLocation
operator|.
name|getDatanodeInfo
argument_list|()
operator|.
name|equals
argument_list|(
name|targetDatanode
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
if|if
condition|(
operator|!
name|isGoodBlockCandidateForPlacementPolicy
argument_list|(
name|source
argument_list|,
name|target
argument_list|,
name|block
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
comment|// Check if the move will violate the block placement policy.
DECL|method|isGoodBlockCandidateForPlacementPolicy (StorageGroup source, StorageGroup target, DBlock block)
specifier|private
name|boolean
name|isGoodBlockCandidateForPlacementPolicy
parameter_list|(
name|StorageGroup
name|source
parameter_list|,
name|StorageGroup
name|target
parameter_list|,
name|DBlock
name|block
parameter_list|)
block|{
name|List
argument_list|<
name|DatanodeInfo
argument_list|>
name|datanodeInfos
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
synchronized|synchronized
init|(
name|block
init|)
block|{
for|for
control|(
name|StorageGroup
name|loc
range|:
name|block
operator|.
name|locations
control|)
block|{
name|datanodeInfos
operator|.
name|add
argument_list|(
name|loc
operator|.
name|getDatanodeInfo
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|datanodeInfos
operator|.
name|add
argument_list|(
name|target
operator|.
name|getDatanodeInfo
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|placementPolicies
operator|.
name|getPolicy
argument_list|(
name|BlockType
operator|.
name|CONTIGUOUS
argument_list|)
operator|.
name|isMovable
argument_list|(
name|datanodeInfos
argument_list|,
name|source
operator|.
name|getDatanodeInfo
argument_list|()
argument_list|,
name|target
operator|.
name|getDatanodeInfo
argument_list|()
argument_list|)
return|;
block|}
comment|/** Reset all fields in order to prepare for the next iteration */
DECL|method|reset (Configuration conf)
name|void
name|reset
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
name|cluster
operator|=
name|NetworkTopology
operator|.
name|getInstance
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|storageGroupMap
operator|.
name|clear
argument_list|()
expr_stmt|;
name|sources
operator|.
name|clear
argument_list|()
expr_stmt|;
name|moverThreadAllocator
operator|.
name|reset
argument_list|()
expr_stmt|;
for|for
control|(
name|StorageGroup
name|t
range|:
name|targets
control|)
block|{
name|t
operator|.
name|getDDatanode
argument_list|()
operator|.
name|shutdownMoveExecutor
argument_list|()
expr_stmt|;
block|}
name|targets
operator|.
name|clear
argument_list|()
expr_stmt|;
name|globalBlocks
operator|.
name|removeAllButRetain
argument_list|(
name|movedBlocks
argument_list|)
expr_stmt|;
name|movedBlocks
operator|.
name|cleanup
argument_list|()
expr_stmt|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|setDelayAfterErrors (long time)
specifier|public
specifier|static
name|void
name|setDelayAfterErrors
parameter_list|(
name|long
name|time
parameter_list|)
block|{
name|delayAfterErrors
operator|=
name|time
expr_stmt|;
block|}
comment|/** shutdown thread pools */
DECL|method|shutdownNow ()
specifier|public
name|void
name|shutdownNow
parameter_list|()
block|{
if|if
condition|(
name|dispatchExecutor
operator|!=
literal|null
condition|)
block|{
name|dispatchExecutor
operator|.
name|shutdownNow
argument_list|()
expr_stmt|;
block|}
block|}
DECL|class|Util
specifier|static
class|class
name|Util
block|{
comment|/** @return true if data node is part of the excludedNodes. */
DECL|method|isExcluded (Set<String> excludedNodes, DatanodeInfo dn)
specifier|static
name|boolean
name|isExcluded
parameter_list|(
name|Set
argument_list|<
name|String
argument_list|>
name|excludedNodes
parameter_list|,
name|DatanodeInfo
name|dn
parameter_list|)
block|{
return|return
name|isIn
argument_list|(
name|excludedNodes
argument_list|,
name|dn
argument_list|)
return|;
block|}
comment|/**      * @return true if includedNodes is empty or data node is part of the      *         includedNodes.      */
DECL|method|isIncluded (Set<String> includedNodes, DatanodeInfo dn)
specifier|static
name|boolean
name|isIncluded
parameter_list|(
name|Set
argument_list|<
name|String
argument_list|>
name|includedNodes
parameter_list|,
name|DatanodeInfo
name|dn
parameter_list|)
block|{
return|return
operator|(
name|includedNodes
operator|.
name|isEmpty
argument_list|()
operator|||
name|isIn
argument_list|(
name|includedNodes
argument_list|,
name|dn
argument_list|)
operator|)
return|;
block|}
comment|/**      * Match is checked using host name , ip address with and without port      * number.      *       * @return true if the datanode's transfer address matches the set of nodes.      */
DECL|method|isIn (Set<String> datanodes, DatanodeInfo dn)
specifier|private
specifier|static
name|boolean
name|isIn
parameter_list|(
name|Set
argument_list|<
name|String
argument_list|>
name|datanodes
parameter_list|,
name|DatanodeInfo
name|dn
parameter_list|)
block|{
return|return
name|isIn
argument_list|(
name|datanodes
argument_list|,
name|dn
operator|.
name|getPeerHostName
argument_list|()
argument_list|,
name|dn
operator|.
name|getXferPort
argument_list|()
argument_list|)
operator|||
name|isIn
argument_list|(
name|datanodes
argument_list|,
name|dn
operator|.
name|getIpAddr
argument_list|()
argument_list|,
name|dn
operator|.
name|getXferPort
argument_list|()
argument_list|)
operator|||
name|isIn
argument_list|(
name|datanodes
argument_list|,
name|dn
operator|.
name|getHostName
argument_list|()
argument_list|,
name|dn
operator|.
name|getXferPort
argument_list|()
argument_list|)
return|;
block|}
comment|/** @return true if nodes contains host or host:port */
DECL|method|isIn (Set<String> nodes, String host, int port)
specifier|private
specifier|static
name|boolean
name|isIn
parameter_list|(
name|Set
argument_list|<
name|String
argument_list|>
name|nodes
parameter_list|,
name|String
name|host
parameter_list|,
name|int
name|port
parameter_list|)
block|{
if|if
condition|(
name|host
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
operator|(
name|nodes
operator|.
name|contains
argument_list|(
name|host
argument_list|)
operator|||
name|nodes
operator|.
name|contains
argument_list|(
name|host
operator|+
literal|":"
operator|+
name|port
argument_list|)
operator|)
return|;
block|}
block|}
block|}
end_class

end_unit

