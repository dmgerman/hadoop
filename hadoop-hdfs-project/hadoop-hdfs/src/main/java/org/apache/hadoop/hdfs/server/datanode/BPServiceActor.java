begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdfs.server.datanode
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Time
operator|.
name|now
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|InetSocketAddress
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|SocketTimeoutException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ha
operator|.
name|HAServiceProtocol
operator|.
name|HAServiceState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|StorageType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|BlockListAsLongs
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|DatanodeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|ExtendedBlock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|HdfsConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|LocatedBlock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|UnregisteredNodeException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocolPB
operator|.
name|DatanodeProtocolClientSideTranslatorPB
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|IncorrectVersionException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|FSNamesystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|DatanodeCommand
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|DatanodeRegistration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|DatanodeStorage
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|DisallowedDatanodeException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|HeartbeatResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|NamespaceInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|ReceivedDeletedBlockInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|StorageBlockReport
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|StorageReceivedDeletedBlocks
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|StorageReport
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|RemoteException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Time
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|VersionInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|VersionUtil
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Maps
import|;
end_import

begin_comment
comment|/**  * A thread per active or standby namenode to perform:  *<ul>  *<li> Pre-registration handshake with namenode</li>  *<li> Registration with namenode</li>  *<li> Send periodic heartbeats to the namenode</li>  *<li> Handle commands received from the namenode</li>  *</ul>  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
DECL|class|BPServiceActor
class|class
name|BPServiceActor
implements|implements
name|Runnable
block|{
DECL|field|LOG
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|DataNode
operator|.
name|LOG
decl_stmt|;
DECL|field|nnAddr
specifier|final
name|InetSocketAddress
name|nnAddr
decl_stmt|;
DECL|field|state
name|HAServiceState
name|state
decl_stmt|;
DECL|field|bpos
name|BPOfferService
name|bpos
decl_stmt|;
comment|// lastBlockReport, lastDeletedReport and lastHeartbeat may be assigned/read
comment|// by testing threads (through BPServiceActor#triggerXXX), while also
comment|// assigned/read by the actor thread. Thus they should be declared as volatile
comment|// to make sure the "happens-before" consistency.
DECL|field|lastBlockReport
specifier|volatile
name|long
name|lastBlockReport
init|=
literal|0
decl_stmt|;
DECL|field|lastDeletedReport
specifier|volatile
name|long
name|lastDeletedReport
init|=
literal|0
decl_stmt|;
DECL|field|resetBlockReportTime
name|boolean
name|resetBlockReportTime
init|=
literal|true
decl_stmt|;
DECL|field|lastCacheReport
specifier|volatile
name|long
name|lastCacheReport
init|=
literal|0
decl_stmt|;
DECL|field|bpThread
name|Thread
name|bpThread
decl_stmt|;
DECL|field|bpNamenode
name|DatanodeProtocolClientSideTranslatorPB
name|bpNamenode
decl_stmt|;
DECL|field|lastHeartbeat
specifier|private
specifier|volatile
name|long
name|lastHeartbeat
init|=
literal|0
decl_stmt|;
DECL|field|initialized
specifier|private
specifier|volatile
name|boolean
name|initialized
init|=
literal|false
decl_stmt|;
comment|/**    * Between block reports (which happen on the order of once an hour) the    * DN reports smaller incremental changes to its block list. This map,    * keyed by block ID, contains the pending changes which have yet to be    * reported to the NN. Access should be synchronized on this object.    */
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|PerStoragePendingIncrementalBR
argument_list|>
DECL|field|pendingIncrementalBRperStorage
name|pendingIncrementalBRperStorage
init|=
name|Maps
operator|.
name|newHashMap
argument_list|()
decl_stmt|;
DECL|field|pendingReceivedRequests
specifier|private
specifier|volatile
name|int
name|pendingReceivedRequests
init|=
literal|0
decl_stmt|;
DECL|field|shouldServiceRun
specifier|private
specifier|volatile
name|boolean
name|shouldServiceRun
init|=
literal|true
decl_stmt|;
DECL|field|dn
specifier|private
specifier|final
name|DataNode
name|dn
decl_stmt|;
DECL|field|dnConf
specifier|private
specifier|final
name|DNConf
name|dnConf
decl_stmt|;
DECL|field|bpRegistration
specifier|private
name|DatanodeRegistration
name|bpRegistration
decl_stmt|;
DECL|method|BPServiceActor (InetSocketAddress nnAddr, BPOfferService bpos)
name|BPServiceActor
parameter_list|(
name|InetSocketAddress
name|nnAddr
parameter_list|,
name|BPOfferService
name|bpos
parameter_list|)
block|{
name|this
operator|.
name|bpos
operator|=
name|bpos
expr_stmt|;
name|this
operator|.
name|dn
operator|=
name|bpos
operator|.
name|getDataNode
argument_list|()
expr_stmt|;
name|this
operator|.
name|nnAddr
operator|=
name|nnAddr
expr_stmt|;
name|this
operator|.
name|dnConf
operator|=
name|dn
operator|.
name|getDnConf
argument_list|()
expr_stmt|;
block|}
comment|/**    * returns true if BP thread has completed initialization of storage    * and has registered with the corresponding namenode    * @return true if initialized    */
DECL|method|isInitialized ()
name|boolean
name|isInitialized
parameter_list|()
block|{
return|return
name|initialized
return|;
block|}
DECL|method|isAlive ()
name|boolean
name|isAlive
parameter_list|()
block|{
return|return
name|shouldServiceRun
operator|&&
name|bpThread
operator|.
name|isAlive
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|bpos
operator|.
name|toString
argument_list|()
operator|+
literal|" service to "
operator|+
name|nnAddr
return|;
block|}
DECL|method|getNNSocketAddress ()
name|InetSocketAddress
name|getNNSocketAddress
parameter_list|()
block|{
return|return
name|nnAddr
return|;
block|}
comment|/**    * Used to inject a spy NN in the unit tests.    */
annotation|@
name|VisibleForTesting
DECL|method|setNameNode (DatanodeProtocolClientSideTranslatorPB dnProtocol)
name|void
name|setNameNode
parameter_list|(
name|DatanodeProtocolClientSideTranslatorPB
name|dnProtocol
parameter_list|)
block|{
name|bpNamenode
operator|=
name|dnProtocol
expr_stmt|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|getNameNodeProxy ()
name|DatanodeProtocolClientSideTranslatorPB
name|getNameNodeProxy
parameter_list|()
block|{
return|return
name|bpNamenode
return|;
block|}
comment|/**    * Perform the first part of the handshake with the NameNode.    * This calls<code>versionRequest</code> to determine the NN's    * namespace and version info. It automatically retries until    * the NN responds or the DN is shutting down.    *     * @return the NamespaceInfo    */
annotation|@
name|VisibleForTesting
DECL|method|retrieveNamespaceInfo ()
name|NamespaceInfo
name|retrieveNamespaceInfo
parameter_list|()
throws|throws
name|IOException
block|{
name|NamespaceInfo
name|nsInfo
init|=
literal|null
decl_stmt|;
while|while
condition|(
name|shouldRun
argument_list|()
condition|)
block|{
try|try
block|{
name|nsInfo
operator|=
name|bpNamenode
operator|.
name|versionRequest
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
name|this
operator|+
literal|" received versionRequest response: "
operator|+
name|nsInfo
argument_list|)
expr_stmt|;
break|break;
block|}
catch|catch
parameter_list|(
name|SocketTimeoutException
name|e
parameter_list|)
block|{
comment|// namenode is busy
name|LOG
operator|.
name|warn
argument_list|(
literal|"Problem connecting to server: "
operator|+
name|nnAddr
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// namenode is not available
name|LOG
operator|.
name|warn
argument_list|(
literal|"Problem connecting to server: "
operator|+
name|nnAddr
argument_list|)
expr_stmt|;
block|}
comment|// try again in a second
name|sleepAndLogInterrupts
argument_list|(
literal|5000
argument_list|,
literal|"requesting version info from NN"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nsInfo
operator|!=
literal|null
condition|)
block|{
name|checkNNVersion
argument_list|(
name|nsInfo
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"DN shut down before block pool connected"
argument_list|)
throw|;
block|}
return|return
name|nsInfo
return|;
block|}
DECL|method|checkNNVersion (NamespaceInfo nsInfo)
specifier|private
name|void
name|checkNNVersion
parameter_list|(
name|NamespaceInfo
name|nsInfo
parameter_list|)
throws|throws
name|IncorrectVersionException
block|{
comment|// build and layout versions should match
name|String
name|nnVersion
init|=
name|nsInfo
operator|.
name|getSoftwareVersion
argument_list|()
decl_stmt|;
name|String
name|minimumNameNodeVersion
init|=
name|dnConf
operator|.
name|getMinimumNameNodeVersion
argument_list|()
decl_stmt|;
if|if
condition|(
name|VersionUtil
operator|.
name|compareVersions
argument_list|(
name|nnVersion
argument_list|,
name|minimumNameNodeVersion
argument_list|)
operator|<
literal|0
condition|)
block|{
name|IncorrectVersionException
name|ive
init|=
operator|new
name|IncorrectVersionException
argument_list|(
name|minimumNameNodeVersion
argument_list|,
name|nnVersion
argument_list|,
literal|"NameNode"
argument_list|,
literal|"DataNode"
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
name|ive
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
name|ive
throw|;
block|}
name|String
name|dnVersion
init|=
name|VersionInfo
operator|.
name|getVersion
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|nnVersion
operator|.
name|equals
argument_list|(
name|dnVersion
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Reported NameNode version '"
operator|+
name|nnVersion
operator|+
literal|"' does not match "
operator|+
literal|"DataNode version '"
operator|+
name|dnVersion
operator|+
literal|"' but is within acceptable "
operator|+
literal|"limits. Note: This is normal during a rolling upgrade."
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|HdfsConstants
operator|.
name|DATANODE_LAYOUT_VERSION
operator|!=
name|nsInfo
operator|.
name|getLayoutVersion
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"DataNode and NameNode layout versions are different:"
operator|+
literal|" DataNode version: "
operator|+
name|HdfsConstants
operator|.
name|DATANODE_LAYOUT_VERSION
operator|+
literal|" NameNode version: "
operator|+
name|nsInfo
operator|.
name|getLayoutVersion
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|connectToNNAndHandshake ()
specifier|private
name|void
name|connectToNNAndHandshake
parameter_list|()
throws|throws
name|IOException
block|{
comment|// get NN proxy
name|bpNamenode
operator|=
name|dn
operator|.
name|connectToNN
argument_list|(
name|nnAddr
argument_list|)
expr_stmt|;
comment|// First phase of the handshake with NN - get the namespace
comment|// info.
name|NamespaceInfo
name|nsInfo
init|=
name|retrieveNamespaceInfo
argument_list|()
decl_stmt|;
comment|// Verify that this matches the other NN in this HA pair.
comment|// This also initializes our block pool in the DN if we are
comment|// the first NN connection for this BP.
name|bpos
operator|.
name|verifyAndSetNamespaceInfo
argument_list|(
name|nsInfo
argument_list|)
expr_stmt|;
comment|// Second phase of the handshake with the NN.
name|register
argument_list|()
expr_stmt|;
block|}
comment|/**    * This methods  arranges for the data node to send the block report at     * the next heartbeat.    */
DECL|method|scheduleBlockReport (long delay)
name|void
name|scheduleBlockReport
parameter_list|(
name|long
name|delay
parameter_list|)
block|{
if|if
condition|(
name|delay
operator|>
literal|0
condition|)
block|{
comment|// send BR after random delay
name|lastBlockReport
operator|=
name|Time
operator|.
name|now
argument_list|()
operator|-
operator|(
name|dnConf
operator|.
name|blockReportInterval
operator|-
name|DFSUtil
operator|.
name|getRandom
argument_list|()
operator|.
name|nextInt
argument_list|(
call|(
name|int
call|)
argument_list|(
name|delay
argument_list|)
argument_list|)
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|// send at next heartbeat
name|lastBlockReport
operator|=
name|lastHeartbeat
operator|-
name|dnConf
operator|.
name|blockReportInterval
expr_stmt|;
block|}
name|resetBlockReportTime
operator|=
literal|true
expr_stmt|;
comment|// reset future BRs for randomness
block|}
DECL|method|reportBadBlocks (ExtendedBlock block, String storageUuid, StorageType storageType)
name|void
name|reportBadBlocks
parameter_list|(
name|ExtendedBlock
name|block
parameter_list|,
name|String
name|storageUuid
parameter_list|,
name|StorageType
name|storageType
parameter_list|)
block|{
if|if
condition|(
name|bpRegistration
operator|==
literal|null
condition|)
block|{
return|return;
block|}
name|DatanodeInfo
index|[]
name|dnArr
init|=
block|{
operator|new
name|DatanodeInfo
argument_list|(
name|bpRegistration
argument_list|)
block|}
decl_stmt|;
name|String
index|[]
name|uuids
init|=
block|{
name|storageUuid
block|}
decl_stmt|;
name|StorageType
index|[]
name|types
init|=
block|{
name|storageType
block|}
decl_stmt|;
name|LocatedBlock
index|[]
name|blocks
init|=
block|{
operator|new
name|LocatedBlock
argument_list|(
name|block
argument_list|,
name|dnArr
argument_list|,
name|uuids
argument_list|,
name|types
argument_list|)
block|}
decl_stmt|;
try|try
block|{
name|bpNamenode
operator|.
name|reportBadBlocks
argument_list|(
name|blocks
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|/* One common reason is that NameNode could be in safe mode.        * Should we keep on retrying in that case?        */
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to report bad block "
operator|+
name|block
operator|+
literal|" to namenode : "
operator|+
literal|" Exception"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Report received blocks and delete hints to the Namenode for each    * storage.    *    * @throws IOException    */
DECL|method|reportReceivedDeletedBlocks ()
specifier|private
name|void
name|reportReceivedDeletedBlocks
parameter_list|()
throws|throws
name|IOException
block|{
comment|// Generate a list of the pending reports for each storage under the lock
name|ArrayList
argument_list|<
name|StorageReceivedDeletedBlocks
argument_list|>
name|reports
init|=
operator|new
name|ArrayList
argument_list|<
name|StorageReceivedDeletedBlocks
argument_list|>
argument_list|(
name|pendingIncrementalBRperStorage
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
synchronized|synchronized
init|(
name|pendingIncrementalBRperStorage
init|)
block|{
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|PerStoragePendingIncrementalBR
argument_list|>
name|entry
range|:
name|pendingIncrementalBRperStorage
operator|.
name|entrySet
argument_list|()
control|)
block|{
specifier|final
name|String
name|storageUuid
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
specifier|final
name|PerStoragePendingIncrementalBR
name|perStorageMap
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|perStorageMap
operator|.
name|getBlockInfoCount
argument_list|()
operator|>
literal|0
condition|)
block|{
comment|// Send newly-received and deleted blockids to namenode
name|ReceivedDeletedBlockInfo
index|[]
name|rdbi
init|=
name|perStorageMap
operator|.
name|dequeueBlockInfos
argument_list|()
decl_stmt|;
name|pendingReceivedRequests
operator|=
operator|(
name|pendingReceivedRequests
operator|>
name|rdbi
operator|.
name|length
condition|?
operator|(
name|pendingReceivedRequests
operator|-
name|rdbi
operator|.
name|length
operator|)
else|:
literal|0
operator|)
expr_stmt|;
name|reports
operator|.
name|add
argument_list|(
operator|new
name|StorageReceivedDeletedBlocks
argument_list|(
name|storageUuid
argument_list|,
name|rdbi
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|reports
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
comment|// Nothing new to report.
return|return;
block|}
comment|// Send incremental block reports to the Namenode outside the lock
name|boolean
name|success
init|=
literal|false
decl_stmt|;
try|try
block|{
name|bpNamenode
operator|.
name|blockReceivedAndDeleted
argument_list|(
name|bpRegistration
argument_list|,
name|bpos
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|reports
operator|.
name|toArray
argument_list|(
operator|new
name|StorageReceivedDeletedBlocks
index|[
name|reports
operator|.
name|size
argument_list|()
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|success
condition|)
block|{
synchronized|synchronized
init|(
name|pendingIncrementalBRperStorage
init|)
block|{
for|for
control|(
name|StorageReceivedDeletedBlocks
name|report
range|:
name|reports
control|)
block|{
comment|// If we didn't succeed in sending the report, put all of the
comment|// blocks back onto our queue, but only in the case where we
comment|// didn't put something newer in the meantime.
name|PerStoragePendingIncrementalBR
name|perStorageMap
init|=
name|pendingIncrementalBRperStorage
operator|.
name|get
argument_list|(
name|report
operator|.
name|getStorageID
argument_list|()
argument_list|)
decl_stmt|;
name|pendingReceivedRequests
operator|+=
name|perStorageMap
operator|.
name|putMissingBlockInfos
argument_list|(
name|report
operator|.
name|getBlocks
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
comment|/**    * Retrieve the incremental BR state for a given storage UUID    * @param storageUuid    * @return    */
DECL|method|getIncrementalBRMapForStorage ( String storageUuid)
specifier|private
name|PerStoragePendingIncrementalBR
name|getIncrementalBRMapForStorage
parameter_list|(
name|String
name|storageUuid
parameter_list|)
block|{
name|PerStoragePendingIncrementalBR
name|mapForStorage
init|=
name|pendingIncrementalBRperStorage
operator|.
name|get
argument_list|(
name|storageUuid
argument_list|)
decl_stmt|;
if|if
condition|(
name|mapForStorage
operator|==
literal|null
condition|)
block|{
comment|// This is the first time we are adding incremental BR state for
comment|// this storage so create a new map. This is required once per
comment|// storage, per service actor.
name|mapForStorage
operator|=
operator|new
name|PerStoragePendingIncrementalBR
argument_list|()
expr_stmt|;
name|pendingIncrementalBRperStorage
operator|.
name|put
argument_list|(
name|storageUuid
argument_list|,
name|mapForStorage
argument_list|)
expr_stmt|;
block|}
return|return
name|mapForStorage
return|;
block|}
comment|/**    * Add a blockInfo for notification to NameNode. If another entry    * exists for the same block it is removed.    *    * Caller must synchronize access using pendingIncrementalBRperStorage.    * @param bInfo    * @param storageUuid    */
DECL|method|addPendingReplicationBlockInfo (ReceivedDeletedBlockInfo bInfo, String storageUuid)
name|void
name|addPendingReplicationBlockInfo
parameter_list|(
name|ReceivedDeletedBlockInfo
name|bInfo
parameter_list|,
name|String
name|storageUuid
parameter_list|)
block|{
comment|// Make sure another entry for the same block is first removed.
comment|// There may only be one such entry.
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|PerStoragePendingIncrementalBR
argument_list|>
name|entry
range|:
name|pendingIncrementalBRperStorage
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
name|entry
operator|.
name|getValue
argument_list|()
operator|.
name|removeBlockInfo
argument_list|(
name|bInfo
argument_list|)
condition|)
block|{
break|break;
block|}
block|}
name|getIncrementalBRMapForStorage
argument_list|(
name|storageUuid
argument_list|)
operator|.
name|putBlockInfo
argument_list|(
name|bInfo
argument_list|)
expr_stmt|;
block|}
comment|/*    * Informing the name node could take a long long time! Should we wait    * till namenode is informed before responding with success to the    * client? For now we don't.    */
DECL|method|notifyNamenodeBlockImmediately ( ReceivedDeletedBlockInfo bInfo, String storageUuid)
name|void
name|notifyNamenodeBlockImmediately
parameter_list|(
name|ReceivedDeletedBlockInfo
name|bInfo
parameter_list|,
name|String
name|storageUuid
parameter_list|)
block|{
synchronized|synchronized
init|(
name|pendingIncrementalBRperStorage
init|)
block|{
name|addPendingReplicationBlockInfo
argument_list|(
name|bInfo
argument_list|,
name|storageUuid
argument_list|)
expr_stmt|;
name|pendingReceivedRequests
operator|++
expr_stmt|;
name|pendingIncrementalBRperStorage
operator|.
name|notifyAll
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|notifyNamenodeDeletedBlock ( ReceivedDeletedBlockInfo bInfo, String storageUuid)
name|void
name|notifyNamenodeDeletedBlock
parameter_list|(
name|ReceivedDeletedBlockInfo
name|bInfo
parameter_list|,
name|String
name|storageUuid
parameter_list|)
block|{
synchronized|synchronized
init|(
name|pendingIncrementalBRperStorage
init|)
block|{
name|addPendingReplicationBlockInfo
argument_list|(
name|bInfo
argument_list|,
name|storageUuid
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Run an immediate block report on this thread. Used by tests.    */
annotation|@
name|VisibleForTesting
DECL|method|triggerBlockReportForTests ()
name|void
name|triggerBlockReportForTests
parameter_list|()
block|{
synchronized|synchronized
init|(
name|pendingIncrementalBRperStorage
init|)
block|{
name|lastBlockReport
operator|=
literal|0
expr_stmt|;
name|lastHeartbeat
operator|=
literal|0
expr_stmt|;
name|pendingIncrementalBRperStorage
operator|.
name|notifyAll
argument_list|()
expr_stmt|;
while|while
condition|(
name|lastBlockReport
operator|==
literal|0
condition|)
block|{
try|try
block|{
name|pendingIncrementalBRperStorage
operator|.
name|wait
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
return|return;
block|}
block|}
block|}
block|}
annotation|@
name|VisibleForTesting
DECL|method|triggerHeartbeatForTests ()
name|void
name|triggerHeartbeatForTests
parameter_list|()
block|{
synchronized|synchronized
init|(
name|pendingIncrementalBRperStorage
init|)
block|{
name|lastHeartbeat
operator|=
literal|0
expr_stmt|;
name|pendingIncrementalBRperStorage
operator|.
name|notifyAll
argument_list|()
expr_stmt|;
while|while
condition|(
name|lastHeartbeat
operator|==
literal|0
condition|)
block|{
try|try
block|{
name|pendingIncrementalBRperStorage
operator|.
name|wait
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
return|return;
block|}
block|}
block|}
block|}
annotation|@
name|VisibleForTesting
DECL|method|triggerDeletionReportForTests ()
name|void
name|triggerDeletionReportForTests
parameter_list|()
block|{
synchronized|synchronized
init|(
name|pendingIncrementalBRperStorage
init|)
block|{
name|lastDeletedReport
operator|=
literal|0
expr_stmt|;
name|pendingIncrementalBRperStorage
operator|.
name|notifyAll
argument_list|()
expr_stmt|;
while|while
condition|(
name|lastDeletedReport
operator|==
literal|0
condition|)
block|{
try|try
block|{
name|pendingIncrementalBRperStorage
operator|.
name|wait
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
return|return;
block|}
block|}
block|}
block|}
comment|/**    * Report the list blocks to the Namenode    * @throws IOException    */
DECL|method|blockReport ()
name|DatanodeCommand
name|blockReport
parameter_list|()
throws|throws
name|IOException
block|{
comment|// send block report if timer has expired.
name|DatanodeCommand
name|cmd
init|=
literal|null
decl_stmt|;
name|long
name|startTime
init|=
name|now
argument_list|()
decl_stmt|;
if|if
condition|(
name|startTime
operator|-
name|lastBlockReport
operator|>
name|dnConf
operator|.
name|blockReportInterval
condition|)
block|{
comment|// Flush any block information that precedes the block report. Otherwise
comment|// we have a chance that we will miss the delHint information
comment|// or we will report an RBW replica after the BlockReport already reports
comment|// a FINALIZED one.
name|reportReceivedDeletedBlocks
argument_list|()
expr_stmt|;
comment|// Send one block report per known storage.
comment|// Create block report
name|long
name|brCreateStartTime
init|=
name|now
argument_list|()
decl_stmt|;
name|long
name|totalBlockCount
init|=
literal|0
decl_stmt|;
name|Map
argument_list|<
name|DatanodeStorage
argument_list|,
name|BlockListAsLongs
argument_list|>
name|perVolumeBlockLists
init|=
name|dn
operator|.
name|getFSDataset
argument_list|()
operator|.
name|getBlockReports
argument_list|(
name|bpos
operator|.
name|getBlockPoolId
argument_list|()
argument_list|)
decl_stmt|;
comment|// Send block report
name|long
name|brSendStartTime
init|=
name|now
argument_list|()
decl_stmt|;
name|StorageBlockReport
index|[]
name|reports
init|=
operator|new
name|StorageBlockReport
index|[
name|perVolumeBlockLists
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|DatanodeStorage
argument_list|,
name|BlockListAsLongs
argument_list|>
name|kvPair
range|:
name|perVolumeBlockLists
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|DatanodeStorage
name|dnStorage
init|=
name|kvPair
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|BlockListAsLongs
name|blockList
init|=
name|kvPair
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|totalBlockCount
operator|+=
name|blockList
operator|.
name|getNumberOfBlocks
argument_list|()
expr_stmt|;
name|reports
index|[
name|i
operator|++
index|]
operator|=
operator|new
name|StorageBlockReport
argument_list|(
name|dnStorage
argument_list|,
name|blockList
operator|.
name|getBlockListAsLongs
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|cmd
operator|=
name|bpNamenode
operator|.
name|blockReport
argument_list|(
name|bpRegistration
argument_list|,
name|bpos
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|reports
argument_list|)
expr_stmt|;
comment|// Log the block report processing stats from Datanode perspective
name|long
name|brSendCost
init|=
name|now
argument_list|()
operator|-
name|brSendStartTime
decl_stmt|;
name|long
name|brCreateCost
init|=
name|brSendStartTime
operator|-
name|brCreateStartTime
decl_stmt|;
name|dn
operator|.
name|getMetrics
argument_list|()
operator|.
name|addBlockReport
argument_list|(
name|brSendCost
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"BlockReport of "
operator|+
name|totalBlockCount
operator|+
literal|" blocks took "
operator|+
name|brCreateCost
operator|+
literal|" msec to generate and "
operator|+
name|brSendCost
operator|+
literal|" msecs for RPC and NN processing"
argument_list|)
expr_stmt|;
comment|// If we have sent the first block report, then wait a random
comment|// time before we start the periodic block reports.
if|if
condition|(
name|resetBlockReportTime
condition|)
block|{
name|lastBlockReport
operator|=
name|startTime
operator|-
name|DFSUtil
operator|.
name|getRandom
argument_list|()
operator|.
name|nextInt
argument_list|(
call|(
name|int
call|)
argument_list|(
name|dnConf
operator|.
name|blockReportInterval
argument_list|)
argument_list|)
expr_stmt|;
name|resetBlockReportTime
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
comment|/* say the last block report was at 8:20:14. The current report          * should have started around 9:20:14 (default 1 hour interval).          * If current time is :          *   1) normal like 9:20:18, next report should be at 10:20:14          *   2) unexpected like 11:35:43, next report should be at 12:20:14          */
name|lastBlockReport
operator|+=
operator|(
name|now
argument_list|()
operator|-
name|lastBlockReport
operator|)
operator|/
name|dnConf
operator|.
name|blockReportInterval
operator|*
name|dnConf
operator|.
name|blockReportInterval
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"sent block report, processed command:"
operator|+
name|cmd
argument_list|)
expr_stmt|;
block|}
return|return
name|cmd
return|;
block|}
DECL|method|cacheReport ()
name|DatanodeCommand
name|cacheReport
parameter_list|()
throws|throws
name|IOException
block|{
comment|// If caching is disabled, do not send a cache report
if|if
condition|(
name|dn
operator|.
name|getFSDataset
argument_list|()
operator|.
name|getCacheCapacity
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
literal|null
return|;
block|}
comment|// send cache report if timer has expired.
name|DatanodeCommand
name|cmd
init|=
literal|null
decl_stmt|;
name|long
name|startTime
init|=
name|Time
operator|.
name|monotonicNow
argument_list|()
decl_stmt|;
if|if
condition|(
name|startTime
operator|-
name|lastCacheReport
operator|>
name|dnConf
operator|.
name|cacheReportInterval
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Sending cacheReport from service actor: "
operator|+
name|this
argument_list|)
expr_stmt|;
block|}
name|lastCacheReport
operator|=
name|startTime
expr_stmt|;
name|String
name|bpid
init|=
name|bpos
operator|.
name|getBlockPoolId
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Long
argument_list|>
name|blockIds
init|=
name|dn
operator|.
name|getFSDataset
argument_list|()
operator|.
name|getCacheReport
argument_list|(
name|bpid
argument_list|)
decl_stmt|;
name|long
name|createTime
init|=
name|Time
operator|.
name|monotonicNow
argument_list|()
decl_stmt|;
name|cmd
operator|=
name|bpNamenode
operator|.
name|cacheReport
argument_list|(
name|bpRegistration
argument_list|,
name|bpid
argument_list|,
name|blockIds
argument_list|)
expr_stmt|;
name|long
name|sendTime
init|=
name|Time
operator|.
name|monotonicNow
argument_list|()
decl_stmt|;
name|long
name|createCost
init|=
name|createTime
operator|-
name|startTime
decl_stmt|;
name|long
name|sendCost
init|=
name|sendTime
operator|-
name|createTime
decl_stmt|;
name|dn
operator|.
name|getMetrics
argument_list|()
operator|.
name|addCacheReport
argument_list|(
name|sendCost
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"CacheReport of "
operator|+
name|blockIds
operator|.
name|size
argument_list|()
operator|+
literal|" block(s) took "
operator|+
name|createCost
operator|+
literal|" msec to generate and "
operator|+
name|sendCost
operator|+
literal|" msecs for RPC and NN processing"
argument_list|)
expr_stmt|;
block|}
return|return
name|cmd
return|;
block|}
DECL|method|sendHeartBeat ()
name|HeartbeatResponse
name|sendHeartBeat
parameter_list|()
throws|throws
name|IOException
block|{
name|StorageReport
index|[]
name|reports
init|=
name|dn
operator|.
name|getFSDataset
argument_list|()
operator|.
name|getStorageReports
argument_list|(
name|bpos
operator|.
name|getBlockPoolId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Sending heartbeat with "
operator|+
name|reports
operator|.
name|length
operator|+
literal|" storage reports from service actor: "
operator|+
name|this
argument_list|)
expr_stmt|;
block|}
return|return
name|bpNamenode
operator|.
name|sendHeartbeat
argument_list|(
name|bpRegistration
argument_list|,
name|reports
argument_list|,
name|dn
operator|.
name|getFSDataset
argument_list|()
operator|.
name|getCacheCapacity
argument_list|()
argument_list|,
name|dn
operator|.
name|getFSDataset
argument_list|()
operator|.
name|getCacheUsed
argument_list|()
argument_list|,
name|dn
operator|.
name|getXmitsInProgress
argument_list|()
argument_list|,
name|dn
operator|.
name|getXceiverCount
argument_list|()
argument_list|,
name|dn
operator|.
name|getFSDataset
argument_list|()
operator|.
name|getNumFailedVolumes
argument_list|()
argument_list|)
return|;
block|}
comment|//This must be called only by BPOfferService
DECL|method|start ()
name|void
name|start
parameter_list|()
block|{
if|if
condition|(
operator|(
name|bpThread
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|bpThread
operator|.
name|isAlive
argument_list|()
operator|)
condition|)
block|{
comment|//Thread is started already
return|return;
block|}
name|bpThread
operator|=
operator|new
name|Thread
argument_list|(
name|this
argument_list|,
name|formatThreadName
argument_list|()
argument_list|)
expr_stmt|;
name|bpThread
operator|.
name|setDaemon
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|// needed for JUnit testing
name|bpThread
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
DECL|method|formatThreadName ()
specifier|private
name|String
name|formatThreadName
parameter_list|()
block|{
name|Collection
argument_list|<
name|StorageLocation
argument_list|>
name|dataDirs
init|=
name|DataNode
operator|.
name|getStorageLocations
argument_list|(
name|dn
operator|.
name|getConf
argument_list|()
argument_list|)
decl_stmt|;
return|return
literal|"DataNode: ["
operator|+
name|dataDirs
operator|.
name|toString
argument_list|()
operator|+
literal|"] "
operator|+
literal|" heartbeating to "
operator|+
name|nnAddr
return|;
block|}
comment|//This must be called only by blockPoolManager.
DECL|method|stop ()
name|void
name|stop
parameter_list|()
block|{
name|shouldServiceRun
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|bpThread
operator|!=
literal|null
condition|)
block|{
name|bpThread
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
block|}
comment|//This must be called only by blockPoolManager
DECL|method|join ()
name|void
name|join
parameter_list|()
block|{
try|try
block|{
if|if
condition|(
name|bpThread
operator|!=
literal|null
condition|)
block|{
name|bpThread
operator|.
name|join
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{ }
block|}
comment|//Cleanup method to be called by current thread before exiting.
DECL|method|cleanUp ()
specifier|private
specifier|synchronized
name|void
name|cleanUp
parameter_list|()
block|{
name|shouldServiceRun
operator|=
literal|false
expr_stmt|;
name|IOUtils
operator|.
name|cleanup
argument_list|(
name|LOG
argument_list|,
name|bpNamenode
argument_list|)
expr_stmt|;
name|bpos
operator|.
name|shutdownActor
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
comment|/**    * Main loop for each BP thread. Run until shutdown,    * forever calling remote NameNode functions.    */
DECL|method|offerService ()
specifier|private
name|void
name|offerService
parameter_list|()
throws|throws
name|Exception
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"For namenode "
operator|+
name|nnAddr
operator|+
literal|" using"
operator|+
literal|" DELETEREPORT_INTERVAL of "
operator|+
name|dnConf
operator|.
name|deleteReportInterval
operator|+
literal|" msec "
operator|+
literal|" BLOCKREPORT_INTERVAL of "
operator|+
name|dnConf
operator|.
name|blockReportInterval
operator|+
literal|"msec"
operator|+
literal|" CACHEREPORT_INTERVAL of "
operator|+
name|dnConf
operator|.
name|cacheReportInterval
operator|+
literal|"msec"
operator|+
literal|" Initial delay: "
operator|+
name|dnConf
operator|.
name|initialBlockReportDelay
operator|+
literal|"msec"
operator|+
literal|"; heartBeatInterval="
operator|+
name|dnConf
operator|.
name|heartBeatInterval
argument_list|)
expr_stmt|;
comment|//
comment|// Now loop for a long time....
comment|//
while|while
condition|(
name|shouldRun
argument_list|()
condition|)
block|{
try|try
block|{
name|long
name|startTime
init|=
name|now
argument_list|()
decl_stmt|;
comment|//
comment|// Every so often, send heartbeat or block-report
comment|//
if|if
condition|(
name|startTime
operator|-
name|lastHeartbeat
operator|>=
name|dnConf
operator|.
name|heartBeatInterval
condition|)
block|{
comment|//
comment|// All heartbeat messages include following info:
comment|// -- Datanode name
comment|// -- data transfer port
comment|// -- Total capacity
comment|// -- Bytes remaining
comment|//
name|lastHeartbeat
operator|=
name|startTime
expr_stmt|;
if|if
condition|(
operator|!
name|dn
operator|.
name|areHeartbeatsDisabledForTests
argument_list|()
condition|)
block|{
name|HeartbeatResponse
name|resp
init|=
name|sendHeartBeat
argument_list|()
decl_stmt|;
assert|assert
name|resp
operator|!=
literal|null
assert|;
name|dn
operator|.
name|getMetrics
argument_list|()
operator|.
name|addHeartbeat
argument_list|(
name|now
argument_list|()
operator|-
name|startTime
argument_list|)
expr_stmt|;
comment|// If the state of this NN has changed (eg STANDBY->ACTIVE)
comment|// then let the BPOfferService update itself.
comment|//
comment|// Important that this happens before processCommand below,
comment|// since the first heartbeat to a new active might have commands
comment|// that we should actually process.
name|bpos
operator|.
name|updateActorStatesFromHeartbeat
argument_list|(
name|this
argument_list|,
name|resp
operator|.
name|getNameNodeHaState
argument_list|()
argument_list|)
expr_stmt|;
name|state
operator|=
name|resp
operator|.
name|getNameNodeHaState
argument_list|()
operator|.
name|getState
argument_list|()
expr_stmt|;
name|long
name|startProcessCommands
init|=
name|now
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|processCommand
argument_list|(
name|resp
operator|.
name|getCommands
argument_list|()
argument_list|)
condition|)
continue|continue;
name|long
name|endProcessCommands
init|=
name|now
argument_list|()
decl_stmt|;
if|if
condition|(
name|endProcessCommands
operator|-
name|startProcessCommands
operator|>
literal|2000
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Took "
operator|+
operator|(
name|endProcessCommands
operator|-
name|startProcessCommands
operator|)
operator|+
literal|"ms to process "
operator|+
name|resp
operator|.
name|getCommands
argument_list|()
operator|.
name|length
operator|+
literal|" commands from NN"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|pendingReceivedRequests
operator|>
literal|0
operator|||
operator|(
name|startTime
operator|-
name|lastDeletedReport
operator|>
name|dnConf
operator|.
name|deleteReportInterval
operator|)
condition|)
block|{
name|reportReceivedDeletedBlocks
argument_list|()
expr_stmt|;
name|lastDeletedReport
operator|=
name|startTime
expr_stmt|;
block|}
name|DatanodeCommand
name|cmd
init|=
name|blockReport
argument_list|()
decl_stmt|;
name|processCommand
argument_list|(
operator|new
name|DatanodeCommand
index|[]
block|{
name|cmd
block|}
argument_list|)
expr_stmt|;
name|cmd
operator|=
name|cacheReport
argument_list|()
expr_stmt|;
name|processCommand
argument_list|(
operator|new
name|DatanodeCommand
index|[]
block|{
name|cmd
block|}
argument_list|)
expr_stmt|;
comment|// Now safe to start scanning the block pool.
comment|// If it has already been started, this is a no-op.
if|if
condition|(
name|dn
operator|.
name|blockScanner
operator|!=
literal|null
condition|)
block|{
name|dn
operator|.
name|blockScanner
operator|.
name|addBlockPool
argument_list|(
name|bpos
operator|.
name|getBlockPoolId
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|//
comment|// There is no work to do;  sleep until hearbeat timer elapses,
comment|// or work arrives, and then iterate again.
comment|//
name|long
name|waitTime
init|=
name|dnConf
operator|.
name|heartBeatInterval
operator|-
operator|(
name|Time
operator|.
name|now
argument_list|()
operator|-
name|lastHeartbeat
operator|)
decl_stmt|;
synchronized|synchronized
init|(
name|pendingIncrementalBRperStorage
init|)
block|{
if|if
condition|(
name|waitTime
operator|>
literal|0
operator|&&
name|pendingReceivedRequests
operator|==
literal|0
condition|)
block|{
try|try
block|{
name|pendingIncrementalBRperStorage
operator|.
name|wait
argument_list|(
name|waitTime
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"BPOfferService for "
operator|+
name|this
operator|+
literal|" interrupted"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// synchronized
block|}
catch|catch
parameter_list|(
name|RemoteException
name|re
parameter_list|)
block|{
name|String
name|reClass
init|=
name|re
operator|.
name|getClassName
argument_list|()
decl_stmt|;
if|if
condition|(
name|UnregisteredNodeException
operator|.
name|class
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|reClass
argument_list|)
operator|||
name|DisallowedDatanodeException
operator|.
name|class
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|reClass
argument_list|)
operator|||
name|IncorrectVersionException
operator|.
name|class
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|reClass
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|this
operator|+
literal|" is shutting down"
argument_list|,
name|re
argument_list|)
expr_stmt|;
name|shouldServiceRun
operator|=
literal|false
expr_stmt|;
return|return;
block|}
name|LOG
operator|.
name|warn
argument_list|(
literal|"RemoteException in offerService"
argument_list|,
name|re
argument_list|)
expr_stmt|;
try|try
block|{
name|long
name|sleepTime
init|=
name|Math
operator|.
name|min
argument_list|(
literal|1000
argument_list|,
name|dnConf
operator|.
name|heartBeatInterval
argument_list|)
decl_stmt|;
name|Thread
operator|.
name|sleep
argument_list|(
name|sleepTime
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"IOException in offerService"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
comment|// while (shouldRun())
block|}
comment|// offerService
comment|/**    * Register one bp with the corresponding NameNode    *<p>    * The bpDatanode needs to register with the namenode on startup in order    * 1) to report which storage it is serving now and     * 2) to receive a registrationID    *      * issued by the namenode to recognize registered datanodes.    *     * @see FSNamesystem#registerDatanode(DatanodeRegistration)    * @throws IOException    */
DECL|method|register ()
name|void
name|register
parameter_list|()
throws|throws
name|IOException
block|{
comment|// The handshake() phase loaded the block pool storage
comment|// off disk - so update the bpRegistration object from that info
name|bpRegistration
operator|=
name|bpos
operator|.
name|createRegistration
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|this
operator|+
literal|" beginning handshake with NN"
argument_list|)
expr_stmt|;
while|while
condition|(
name|shouldRun
argument_list|()
condition|)
block|{
try|try
block|{
comment|// Use returned registration from namenode with updated fields
name|bpRegistration
operator|=
name|bpNamenode
operator|.
name|registerDatanode
argument_list|(
name|bpRegistration
argument_list|)
expr_stmt|;
break|break;
block|}
catch|catch
parameter_list|(
name|SocketTimeoutException
name|e
parameter_list|)
block|{
comment|// namenode is busy
name|LOG
operator|.
name|info
argument_list|(
literal|"Problem connecting to server: "
operator|+
name|nnAddr
argument_list|)
expr_stmt|;
name|sleepAndLogInterrupts
argument_list|(
literal|1000
argument_list|,
literal|"connecting to server"
argument_list|)
expr_stmt|;
block|}
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Block pool "
operator|+
name|this
operator|+
literal|" successfully registered with NN"
argument_list|)
expr_stmt|;
name|bpos
operator|.
name|registrationSucceeded
argument_list|(
name|this
argument_list|,
name|bpRegistration
argument_list|)
expr_stmt|;
comment|// random short delay - helps scatter the BR from all DNs
name|scheduleBlockReport
argument_list|(
name|dnConf
operator|.
name|initialBlockReportDelay
argument_list|)
expr_stmt|;
block|}
DECL|method|sleepAndLogInterrupts (int millis, String stateString)
specifier|private
name|void
name|sleepAndLogInterrupts
parameter_list|(
name|int
name|millis
parameter_list|,
name|String
name|stateString
parameter_list|)
block|{
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|millis
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"BPOfferService "
operator|+
name|this
operator|+
literal|" interrupted while "
operator|+
name|stateString
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * No matter what kind of exception we get, keep retrying to offerService().    * That's the loop that connects to the NameNode and provides basic DataNode    * functionality.    *    * Only stop when "shouldRun" or "shouldServiceRun" is turned off, which can    * happen either at shutdown or due to refreshNamenodes.    */
annotation|@
name|Override
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
name|LOG
operator|.
name|info
argument_list|(
name|this
operator|+
literal|" starting to offer service"
argument_list|)
expr_stmt|;
try|try
block|{
comment|// init stuff
try|try
block|{
comment|// setup storage
name|connectToNNAndHandshake
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
comment|// Initial handshake, storage recovery or registration failed
comment|// End BPOfferService thread
name|LOG
operator|.
name|fatal
argument_list|(
literal|"Initialization failed for block pool "
operator|+
name|this
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
return|return;
block|}
name|initialized
operator|=
literal|true
expr_stmt|;
comment|// bp is initialized;
while|while
condition|(
name|shouldRun
argument_list|()
condition|)
block|{
try|try
block|{
name|offerService
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Exception in BPOfferService for "
operator|+
name|this
argument_list|,
name|ex
argument_list|)
expr_stmt|;
name|sleepAndLogInterrupts
argument_list|(
literal|5000
argument_list|,
literal|"offering service"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Unexpected exception in block pool "
operator|+
name|this
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Ending block pool service for: "
operator|+
name|this
argument_list|)
expr_stmt|;
name|cleanUp
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|shouldRun ()
specifier|private
name|boolean
name|shouldRun
parameter_list|()
block|{
return|return
name|shouldServiceRun
operator|&&
name|dn
operator|.
name|shouldRun
argument_list|()
return|;
block|}
comment|/**    * Process an array of datanode commands    *     * @param cmds an array of datanode commands    * @return true if further processing may be required or false otherwise.     */
DECL|method|processCommand (DatanodeCommand[] cmds)
name|boolean
name|processCommand
parameter_list|(
name|DatanodeCommand
index|[]
name|cmds
parameter_list|)
block|{
if|if
condition|(
name|cmds
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|DatanodeCommand
name|cmd
range|:
name|cmds
control|)
block|{
try|try
block|{
if|if
condition|(
name|bpos
operator|.
name|processCommandFromActor
argument_list|(
name|cmd
argument_list|,
name|this
argument_list|)
operator|==
literal|false
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Error processing datanode Command"
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
literal|true
return|;
block|}
DECL|method|trySendErrorReport (int errCode, String errMsg)
name|void
name|trySendErrorReport
parameter_list|(
name|int
name|errCode
parameter_list|,
name|String
name|errMsg
parameter_list|)
block|{
try|try
block|{
name|bpNamenode
operator|.
name|errorReport
argument_list|(
name|bpRegistration
argument_list|,
name|errCode
argument_list|,
name|errMsg
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Error reporting an error to NameNode "
operator|+
name|nnAddr
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Report a bad block from another DN in this cluster.    */
DECL|method|reportRemoteBadBlock (DatanodeInfo dnInfo, ExtendedBlock block)
name|void
name|reportRemoteBadBlock
parameter_list|(
name|DatanodeInfo
name|dnInfo
parameter_list|,
name|ExtendedBlock
name|block
parameter_list|)
throws|throws
name|IOException
block|{
name|LocatedBlock
name|lb
init|=
operator|new
name|LocatedBlock
argument_list|(
name|block
argument_list|,
operator|new
name|DatanodeInfo
index|[]
block|{
name|dnInfo
block|}
argument_list|)
decl_stmt|;
name|bpNamenode
operator|.
name|reportBadBlocks
argument_list|(
operator|new
name|LocatedBlock
index|[]
block|{
name|lb
block|}
argument_list|)
expr_stmt|;
block|}
DECL|method|reRegister ()
name|void
name|reRegister
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|shouldRun
argument_list|()
condition|)
block|{
comment|// re-retrieve namespace info to make sure that, if the NN
comment|// was restarted, we still match its version (HDFS-2120)
name|retrieveNamespaceInfo
argument_list|()
expr_stmt|;
comment|// and re-register
name|register
argument_list|()
expr_stmt|;
block|}
block|}
DECL|class|PerStoragePendingIncrementalBR
specifier|private
specifier|static
class|class
name|PerStoragePendingIncrementalBR
block|{
DECL|field|pendingIncrementalBR
specifier|private
name|Map
argument_list|<
name|Long
argument_list|,
name|ReceivedDeletedBlockInfo
argument_list|>
name|pendingIncrementalBR
init|=
name|Maps
operator|.
name|newHashMap
argument_list|()
decl_stmt|;
comment|/**      * Return the number of blocks on this storage that have pending      * incremental block reports.      * @return      */
DECL|method|getBlockInfoCount ()
name|int
name|getBlockInfoCount
parameter_list|()
block|{
return|return
name|pendingIncrementalBR
operator|.
name|size
argument_list|()
return|;
block|}
comment|/**      * Dequeue and return all pending incremental block report state.      * @return      */
DECL|method|dequeueBlockInfos ()
name|ReceivedDeletedBlockInfo
index|[]
name|dequeueBlockInfos
parameter_list|()
block|{
name|ReceivedDeletedBlockInfo
index|[]
name|blockInfos
init|=
name|pendingIncrementalBR
operator|.
name|values
argument_list|()
operator|.
name|toArray
argument_list|(
operator|new
name|ReceivedDeletedBlockInfo
index|[
name|getBlockInfoCount
argument_list|()
index|]
argument_list|)
decl_stmt|;
name|pendingIncrementalBR
operator|.
name|clear
argument_list|()
expr_stmt|;
return|return
name|blockInfos
return|;
block|}
comment|/**      * Add blocks from blockArray to pendingIncrementalBR, unless the      * block already exists in pendingIncrementalBR.      * @param blockArray list of blocks to add.      * @return the number of missing blocks that we added.      */
DECL|method|putMissingBlockInfos (ReceivedDeletedBlockInfo[] blockArray)
name|int
name|putMissingBlockInfos
parameter_list|(
name|ReceivedDeletedBlockInfo
index|[]
name|blockArray
parameter_list|)
block|{
name|int
name|blocksPut
init|=
literal|0
decl_stmt|;
for|for
control|(
name|ReceivedDeletedBlockInfo
name|rdbi
range|:
name|blockArray
control|)
block|{
if|if
condition|(
operator|!
name|pendingIncrementalBR
operator|.
name|containsKey
argument_list|(
name|rdbi
operator|.
name|getBlock
argument_list|()
operator|.
name|getBlockId
argument_list|()
argument_list|)
condition|)
block|{
name|pendingIncrementalBR
operator|.
name|put
argument_list|(
name|rdbi
operator|.
name|getBlock
argument_list|()
operator|.
name|getBlockId
argument_list|()
argument_list|,
name|rdbi
argument_list|)
expr_stmt|;
operator|++
name|blocksPut
expr_stmt|;
block|}
block|}
return|return
name|blocksPut
return|;
block|}
comment|/**      * Add pending incremental block report for a single block.      * @param blockID      * @param blockInfo      */
DECL|method|putBlockInfo (ReceivedDeletedBlockInfo blockInfo)
name|void
name|putBlockInfo
parameter_list|(
name|ReceivedDeletedBlockInfo
name|blockInfo
parameter_list|)
block|{
name|pendingIncrementalBR
operator|.
name|put
argument_list|(
name|blockInfo
operator|.
name|getBlock
argument_list|()
operator|.
name|getBlockId
argument_list|()
argument_list|,
name|blockInfo
argument_list|)
expr_stmt|;
block|}
comment|/**      * Remove pending incremental block report for a single block if it      * exists.      *      * @param blockInfo      * @return true if a report was removed, false if no report existed for      *         the given block.      */
DECL|method|removeBlockInfo (ReceivedDeletedBlockInfo blockInfo)
name|boolean
name|removeBlockInfo
parameter_list|(
name|ReceivedDeletedBlockInfo
name|blockInfo
parameter_list|)
block|{
return|return
operator|(
name|pendingIncrementalBR
operator|.
name|remove
argument_list|(
name|blockInfo
operator|.
name|getBlock
argument_list|()
operator|.
name|getBlockId
argument_list|()
argument_list|)
operator|!=
literal|null
operator|)
return|;
block|}
block|}
block|}
end_class

end_unit

