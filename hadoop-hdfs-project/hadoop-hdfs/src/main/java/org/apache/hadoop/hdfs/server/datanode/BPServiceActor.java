begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdfs.server.datanode
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Time
operator|.
name|monotonicNow
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Closeable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|EOFException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|InetSocketAddress
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|SocketTimeoutException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|SortedSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|CountDownLatch
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ThreadLocalRandom
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicBoolean
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ha
operator|.
name|HAServiceProtocol
operator|.
name|HAServiceState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|client
operator|.
name|BlockReportOptions
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|BlockListAsLongs
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|DatanodeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|ExtendedBlock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|LocatedBlock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|RollingUpgradeStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|UnregisteredNodeException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocolPB
operator|.
name|DatanodeLifelineProtocolClientSideTranslatorPB
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocolPB
operator|.
name|DatanodeProtocolClientSideTranslatorPB
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|IncorrectVersionException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|FSNamesystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|BlockReportContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|DatanodeCommand
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|DatanodeRegistration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|DatanodeStorage
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|DisallowedDatanodeException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|HeartbeatResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|NamespaceInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|SlowDiskReports
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|SlowPeerReports
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|StorageBlockReport
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|StorageReport
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|VolumeFailureSummary
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|RemoteException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|net
operator|.
name|NetUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Time
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|VersionInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|VersionUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Joiner
import|;
end_import

begin_comment
comment|/**  * A thread per active or standby namenode to perform:  *<ul>  *<li> Pre-registration handshake with namenode</li>  *<li> Registration with namenode</li>  *<li> Send periodic heartbeats to the namenode</li>  *<li> Handle commands received from the namenode</li>  *</ul>  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
DECL|class|BPServiceActor
class|class
name|BPServiceActor
implements|implements
name|Runnable
block|{
DECL|field|LOG
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|DataNode
operator|.
name|LOG
decl_stmt|;
DECL|field|nnAddr
specifier|final
name|InetSocketAddress
name|nnAddr
decl_stmt|;
DECL|field|state
name|HAServiceState
name|state
decl_stmt|;
DECL|field|bpos
specifier|final
name|BPOfferService
name|bpos
decl_stmt|;
DECL|field|lastCacheReport
specifier|volatile
name|long
name|lastCacheReport
init|=
literal|0
decl_stmt|;
DECL|field|scheduler
specifier|private
specifier|final
name|Scheduler
name|scheduler
decl_stmt|;
DECL|field|bpThread
name|Thread
name|bpThread
decl_stmt|;
DECL|field|bpNamenode
name|DatanodeProtocolClientSideTranslatorPB
name|bpNamenode
decl_stmt|;
DECL|enum|RunningState
specifier|static
enum|enum
name|RunningState
block|{
DECL|enumConstant|CONNECTING
DECL|enumConstant|INIT_FAILED
DECL|enumConstant|RUNNING
DECL|enumConstant|EXITED
DECL|enumConstant|FAILED
name|CONNECTING
block|,
name|INIT_FAILED
block|,
name|RUNNING
block|,
name|EXITED
block|,
name|FAILED
block|;   }
DECL|field|runningState
specifier|private
specifier|volatile
name|RunningState
name|runningState
init|=
name|RunningState
operator|.
name|CONNECTING
decl_stmt|;
DECL|field|shouldServiceRun
specifier|private
specifier|volatile
name|boolean
name|shouldServiceRun
init|=
literal|true
decl_stmt|;
DECL|field|dn
specifier|private
specifier|final
name|DataNode
name|dn
decl_stmt|;
DECL|field|dnConf
specifier|private
specifier|final
name|DNConf
name|dnConf
decl_stmt|;
DECL|field|prevBlockReportId
specifier|private
name|long
name|prevBlockReportId
decl_stmt|;
DECL|field|blockReportSizes
specifier|private
specifier|final
name|SortedSet
argument_list|<
name|Integer
argument_list|>
name|blockReportSizes
init|=
name|Collections
operator|.
name|synchronizedSortedSet
argument_list|(
operator|new
name|TreeSet
argument_list|<>
argument_list|()
argument_list|)
decl_stmt|;
DECL|field|maxDataLength
specifier|private
specifier|final
name|int
name|maxDataLength
decl_stmt|;
DECL|field|ibrManager
specifier|private
specifier|final
name|IncrementalBlockReportManager
name|ibrManager
decl_stmt|;
DECL|field|bpRegistration
specifier|private
name|DatanodeRegistration
name|bpRegistration
decl_stmt|;
DECL|field|bpThreadQueue
specifier|final
name|LinkedList
argument_list|<
name|BPServiceActorAction
argument_list|>
name|bpThreadQueue
init|=
operator|new
name|LinkedList
argument_list|<
name|BPServiceActorAction
argument_list|>
argument_list|()
decl_stmt|;
DECL|method|BPServiceActor (InetSocketAddress nnAddr, InetSocketAddress lifelineNnAddr, BPOfferService bpos)
name|BPServiceActor
parameter_list|(
name|InetSocketAddress
name|nnAddr
parameter_list|,
name|InetSocketAddress
name|lifelineNnAddr
parameter_list|,
name|BPOfferService
name|bpos
parameter_list|)
block|{
name|this
operator|.
name|bpos
operator|=
name|bpos
expr_stmt|;
name|this
operator|.
name|dn
operator|=
name|bpos
operator|.
name|getDataNode
argument_list|()
expr_stmt|;
name|this
operator|.
name|nnAddr
operator|=
name|nnAddr
expr_stmt|;
name|this
operator|.
name|lifelineSender
operator|=
name|lifelineNnAddr
operator|!=
literal|null
condition|?
operator|new
name|LifelineSender
argument_list|(
name|lifelineNnAddr
argument_list|)
else|:
literal|null
expr_stmt|;
name|this
operator|.
name|initialRegistrationComplete
operator|=
name|lifelineNnAddr
operator|!=
literal|null
condition|?
operator|new
name|CountDownLatch
argument_list|(
literal|1
argument_list|)
else|:
literal|null
expr_stmt|;
name|this
operator|.
name|dnConf
operator|=
name|dn
operator|.
name|getDnConf
argument_list|()
expr_stmt|;
name|this
operator|.
name|ibrManager
operator|=
operator|new
name|IncrementalBlockReportManager
argument_list|(
name|dnConf
operator|.
name|ibrInterval
argument_list|,
name|dn
operator|.
name|getMetrics
argument_list|()
argument_list|)
expr_stmt|;
name|prevBlockReportId
operator|=
name|ThreadLocalRandom
operator|.
name|current
argument_list|()
operator|.
name|nextLong
argument_list|()
expr_stmt|;
name|scheduler
operator|=
operator|new
name|Scheduler
argument_list|(
name|dnConf
operator|.
name|heartBeatInterval
argument_list|,
name|dnConf
operator|.
name|getLifelineIntervalMs
argument_list|()
argument_list|,
name|dnConf
operator|.
name|blockReportInterval
argument_list|,
name|dnConf
operator|.
name|outliersReportIntervalMs
argument_list|)
expr_stmt|;
comment|// get the value of maxDataLength.
name|this
operator|.
name|maxDataLength
operator|=
name|dnConf
operator|.
name|getMaxDataLength
argument_list|()
expr_stmt|;
block|}
DECL|method|getBpRegistration ()
specifier|public
name|DatanodeRegistration
name|getBpRegistration
parameter_list|()
block|{
return|return
name|bpRegistration
return|;
block|}
DECL|method|getIbrManager ()
name|IncrementalBlockReportManager
name|getIbrManager
parameter_list|()
block|{
return|return
name|ibrManager
return|;
block|}
DECL|method|isAlive ()
name|boolean
name|isAlive
parameter_list|()
block|{
if|if
condition|(
operator|!
name|shouldServiceRun
operator|||
operator|!
name|bpThread
operator|.
name|isAlive
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
name|runningState
operator|==
name|BPServiceActor
operator|.
name|RunningState
operator|.
name|RUNNING
operator|||
name|runningState
operator|==
name|BPServiceActor
operator|.
name|RunningState
operator|.
name|CONNECTING
return|;
block|}
DECL|method|getRunningState ()
name|String
name|getRunningState
parameter_list|()
block|{
return|return
name|runningState
operator|.
name|toString
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|bpos
operator|.
name|toString
argument_list|()
operator|+
literal|" service to "
operator|+
name|nnAddr
return|;
block|}
DECL|method|getNNSocketAddress ()
name|InetSocketAddress
name|getNNSocketAddress
parameter_list|()
block|{
return|return
name|nnAddr
return|;
block|}
DECL|method|getNameNodeAddress ()
specifier|private
name|String
name|getNameNodeAddress
parameter_list|()
block|{
return|return
name|NetUtils
operator|.
name|getHostPortString
argument_list|(
name|getNNSocketAddress
argument_list|()
argument_list|)
return|;
block|}
DECL|method|getActorInfoMap ()
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|getActorInfoMap
parameter_list|()
block|{
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|info
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|info
operator|.
name|put
argument_list|(
literal|"NamenodeAddress"
argument_list|,
name|getNameNodeAddress
argument_list|()
argument_list|)
expr_stmt|;
name|info
operator|.
name|put
argument_list|(
literal|"BlockPoolID"
argument_list|,
name|bpos
operator|.
name|getBlockPoolId
argument_list|()
argument_list|)
expr_stmt|;
name|info
operator|.
name|put
argument_list|(
literal|"ActorState"
argument_list|,
name|getRunningState
argument_list|()
argument_list|)
expr_stmt|;
name|info
operator|.
name|put
argument_list|(
literal|"LastHeartbeat"
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
name|getScheduler
argument_list|()
operator|.
name|getLastHearbeatTime
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|info
operator|.
name|put
argument_list|(
literal|"LastBlockReport"
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
name|getScheduler
argument_list|()
operator|.
name|getLastBlockReportTime
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|info
operator|.
name|put
argument_list|(
literal|"maxBlockReportSize"
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
name|getMaxBlockReportSize
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|info
operator|.
name|put
argument_list|(
literal|"maxDataLength"
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
name|maxDataLength
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|info
return|;
block|}
DECL|field|initialRegistrationComplete
specifier|private
specifier|final
name|CountDownLatch
name|initialRegistrationComplete
decl_stmt|;
DECL|field|lifelineSender
specifier|private
specifier|final
name|LifelineSender
name|lifelineSender
decl_stmt|;
comment|/**    * Used to inject a spy NN in the unit tests.    */
annotation|@
name|VisibleForTesting
DECL|method|setNameNode (DatanodeProtocolClientSideTranslatorPB dnProtocol)
name|void
name|setNameNode
parameter_list|(
name|DatanodeProtocolClientSideTranslatorPB
name|dnProtocol
parameter_list|)
block|{
name|bpNamenode
operator|=
name|dnProtocol
expr_stmt|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|getNameNodeProxy ()
name|DatanodeProtocolClientSideTranslatorPB
name|getNameNodeProxy
parameter_list|()
block|{
return|return
name|bpNamenode
return|;
block|}
comment|/**    * Used to inject a spy NN in the unit tests.    */
annotation|@
name|VisibleForTesting
DECL|method|setLifelineNameNode ( DatanodeLifelineProtocolClientSideTranslatorPB dnLifelineProtocol)
name|void
name|setLifelineNameNode
parameter_list|(
name|DatanodeLifelineProtocolClientSideTranslatorPB
name|dnLifelineProtocol
parameter_list|)
block|{
name|lifelineSender
operator|.
name|lifelineNamenode
operator|=
name|dnLifelineProtocol
expr_stmt|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|getLifelineNameNodeProxy ()
name|DatanodeLifelineProtocolClientSideTranslatorPB
name|getLifelineNameNodeProxy
parameter_list|()
block|{
return|return
name|lifelineSender
operator|.
name|lifelineNamenode
return|;
block|}
comment|/**    * Perform the first part of the handshake with the NameNode.    * This calls<code>versionRequest</code> to determine the NN's    * namespace and version info. It automatically retries until    * the NN responds or the DN is shutting down.    *     * @return the NamespaceInfo    */
annotation|@
name|VisibleForTesting
DECL|method|retrieveNamespaceInfo ()
name|NamespaceInfo
name|retrieveNamespaceInfo
parameter_list|()
throws|throws
name|IOException
block|{
name|NamespaceInfo
name|nsInfo
init|=
literal|null
decl_stmt|;
while|while
condition|(
name|shouldRun
argument_list|()
condition|)
block|{
try|try
block|{
name|nsInfo
operator|=
name|bpNamenode
operator|.
name|versionRequest
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
name|this
operator|+
literal|" received versionRequest response: "
operator|+
name|nsInfo
argument_list|)
expr_stmt|;
break|break;
block|}
catch|catch
parameter_list|(
name|SocketTimeoutException
name|e
parameter_list|)
block|{
comment|// namenode is busy
name|LOG
operator|.
name|warn
argument_list|(
literal|"Problem connecting to server: "
operator|+
name|nnAddr
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// namenode is not available
name|LOG
operator|.
name|warn
argument_list|(
literal|"Problem connecting to server: "
operator|+
name|nnAddr
argument_list|)
expr_stmt|;
block|}
comment|// try again in a second
name|sleepAndLogInterrupts
argument_list|(
literal|5000
argument_list|,
literal|"requesting version info from NN"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nsInfo
operator|!=
literal|null
condition|)
block|{
name|checkNNVersion
argument_list|(
name|nsInfo
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"DN shut down before block pool connected"
argument_list|)
throw|;
block|}
return|return
name|nsInfo
return|;
block|}
DECL|method|checkNNVersion (NamespaceInfo nsInfo)
specifier|private
name|void
name|checkNNVersion
parameter_list|(
name|NamespaceInfo
name|nsInfo
parameter_list|)
throws|throws
name|IncorrectVersionException
block|{
comment|// build and layout versions should match
name|String
name|nnVersion
init|=
name|nsInfo
operator|.
name|getSoftwareVersion
argument_list|()
decl_stmt|;
name|String
name|minimumNameNodeVersion
init|=
name|dnConf
operator|.
name|getMinimumNameNodeVersion
argument_list|()
decl_stmt|;
if|if
condition|(
name|VersionUtil
operator|.
name|compareVersions
argument_list|(
name|nnVersion
argument_list|,
name|minimumNameNodeVersion
argument_list|)
operator|<
literal|0
condition|)
block|{
name|IncorrectVersionException
name|ive
init|=
operator|new
name|IncorrectVersionException
argument_list|(
name|minimumNameNodeVersion
argument_list|,
name|nnVersion
argument_list|,
literal|"NameNode"
argument_list|,
literal|"DataNode"
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
name|ive
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
name|ive
throw|;
block|}
name|String
name|dnVersion
init|=
name|VersionInfo
operator|.
name|getVersion
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|nnVersion
operator|.
name|equals
argument_list|(
name|dnVersion
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Reported NameNode version '"
operator|+
name|nnVersion
operator|+
literal|"' does not match "
operator|+
literal|"DataNode version '"
operator|+
name|dnVersion
operator|+
literal|"' but is within acceptable "
operator|+
literal|"limits. Note: This is normal during a rolling upgrade."
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|connectToNNAndHandshake ()
specifier|private
name|void
name|connectToNNAndHandshake
parameter_list|()
throws|throws
name|IOException
block|{
comment|// get NN proxy
name|bpNamenode
operator|=
name|dn
operator|.
name|connectToNN
argument_list|(
name|nnAddr
argument_list|)
expr_stmt|;
comment|// First phase of the handshake with NN - get the namespace
comment|// info.
name|NamespaceInfo
name|nsInfo
init|=
name|retrieveNamespaceInfo
argument_list|()
decl_stmt|;
comment|// Verify that this matches the other NN in this HA pair.
comment|// This also initializes our block pool in the DN if we are
comment|// the first NN connection for this BP.
name|bpos
operator|.
name|verifyAndSetNamespaceInfo
argument_list|(
name|this
argument_list|,
name|nsInfo
argument_list|)
expr_stmt|;
comment|/* set thread name again to include NamespaceInfo when it's available. */
name|this
operator|.
name|bpThread
operator|.
name|setName
argument_list|(
name|formatThreadName
argument_list|(
literal|"heartbeating"
argument_list|,
name|nnAddr
argument_list|)
argument_list|)
expr_stmt|;
comment|// Second phase of the handshake with the NN.
name|register
argument_list|(
name|nsInfo
argument_list|)
expr_stmt|;
block|}
comment|/**    * Run an immediate block report on this thread. Used by tests.    */
annotation|@
name|VisibleForTesting
DECL|method|triggerBlockReportForTests ()
name|void
name|triggerBlockReportForTests
parameter_list|()
block|{
synchronized|synchronized
init|(
name|ibrManager
init|)
block|{
name|scheduler
operator|.
name|scheduleHeartbeat
argument_list|()
expr_stmt|;
name|long
name|oldBlockReportTime
init|=
name|scheduler
operator|.
name|nextBlockReportTime
decl_stmt|;
name|scheduler
operator|.
name|forceFullBlockReportNow
argument_list|()
expr_stmt|;
name|ibrManager
operator|.
name|notifyAll
argument_list|()
expr_stmt|;
while|while
condition|(
name|oldBlockReportTime
operator|==
name|scheduler
operator|.
name|nextBlockReportTime
condition|)
block|{
try|try
block|{
name|ibrManager
operator|.
name|wait
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
return|return;
block|}
block|}
block|}
block|}
annotation|@
name|VisibleForTesting
DECL|method|triggerHeartbeatForTests ()
name|void
name|triggerHeartbeatForTests
parameter_list|()
block|{
synchronized|synchronized
init|(
name|ibrManager
init|)
block|{
specifier|final
name|long
name|nextHeartbeatTime
init|=
name|scheduler
operator|.
name|scheduleHeartbeat
argument_list|()
decl_stmt|;
name|ibrManager
operator|.
name|notifyAll
argument_list|()
expr_stmt|;
while|while
condition|(
name|nextHeartbeatTime
operator|-
name|scheduler
operator|.
name|nextHeartbeatTime
operator|>=
literal|0
condition|)
block|{
try|try
block|{
name|ibrManager
operator|.
name|wait
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
return|return;
block|}
block|}
block|}
block|}
DECL|method|getMaxBlockReportSize ()
specifier|private
name|int
name|getMaxBlockReportSize
parameter_list|()
block|{
name|int
name|maxBlockReportSize
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|blockReportSizes
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|maxBlockReportSize
operator|=
name|blockReportSizes
operator|.
name|last
argument_list|()
expr_stmt|;
block|}
return|return
name|maxBlockReportSize
return|;
block|}
DECL|method|generateUniqueBlockReportId ()
specifier|private
name|long
name|generateUniqueBlockReportId
parameter_list|()
block|{
comment|// Initialize the block report ID the first time through.
comment|// Note that 0 is used on the NN to indicate "uninitialized", so we should
comment|// not send a 0 value ourselves.
name|prevBlockReportId
operator|++
expr_stmt|;
while|while
condition|(
name|prevBlockReportId
operator|==
literal|0
condition|)
block|{
name|prevBlockReportId
operator|=
name|ThreadLocalRandom
operator|.
name|current
argument_list|()
operator|.
name|nextLong
argument_list|()
expr_stmt|;
block|}
return|return
name|prevBlockReportId
return|;
block|}
comment|/**    * Report the list blocks to the Namenode    * @return DatanodeCommands returned by the NN. May be null.    * @throws IOException    */
DECL|method|blockReport (long fullBrLeaseId)
name|List
argument_list|<
name|DatanodeCommand
argument_list|>
name|blockReport
parameter_list|(
name|long
name|fullBrLeaseId
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|ArrayList
argument_list|<
name|DatanodeCommand
argument_list|>
name|cmds
init|=
operator|new
name|ArrayList
argument_list|<
name|DatanodeCommand
argument_list|>
argument_list|()
decl_stmt|;
comment|// Flush any block information that precedes the block report. Otherwise
comment|// we have a chance that we will miss the delHint information
comment|// or we will report an RBW replica after the BlockReport already reports
comment|// a FINALIZED one.
name|ibrManager
operator|.
name|sendIBRs
argument_list|(
name|bpNamenode
argument_list|,
name|bpRegistration
argument_list|,
name|bpos
operator|.
name|getBlockPoolId
argument_list|()
argument_list|)
expr_stmt|;
name|long
name|brCreateStartTime
init|=
name|monotonicNow
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|DatanodeStorage
argument_list|,
name|BlockListAsLongs
argument_list|>
name|perVolumeBlockLists
init|=
name|dn
operator|.
name|getFSDataset
argument_list|()
operator|.
name|getBlockReports
argument_list|(
name|bpos
operator|.
name|getBlockPoolId
argument_list|()
argument_list|)
decl_stmt|;
comment|// Convert the reports to the format expected by the NN.
name|int
name|i
init|=
literal|0
decl_stmt|;
name|int
name|totalBlockCount
init|=
literal|0
decl_stmt|;
name|StorageBlockReport
name|reports
index|[]
init|=
operator|new
name|StorageBlockReport
index|[
name|perVolumeBlockLists
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|DatanodeStorage
argument_list|,
name|BlockListAsLongs
argument_list|>
name|kvPair
range|:
name|perVolumeBlockLists
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|BlockListAsLongs
name|blockList
init|=
name|kvPair
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|reports
index|[
name|i
operator|++
index|]
operator|=
operator|new
name|StorageBlockReport
argument_list|(
name|kvPair
operator|.
name|getKey
argument_list|()
argument_list|,
name|blockList
argument_list|)
expr_stmt|;
name|totalBlockCount
operator|+=
name|blockList
operator|.
name|getNumberOfBlocks
argument_list|()
expr_stmt|;
block|}
comment|// Send the reports to the NN.
name|int
name|numReportsSent
init|=
literal|0
decl_stmt|;
name|int
name|numRPCs
init|=
literal|0
decl_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
name|long
name|brSendStartTime
init|=
name|monotonicNow
argument_list|()
decl_stmt|;
name|long
name|reportId
init|=
name|generateUniqueBlockReportId
argument_list|()
decl_stmt|;
name|boolean
name|useBlocksBuffer
init|=
name|bpRegistration
operator|.
name|getNamespaceInfo
argument_list|()
operator|.
name|isCapabilitySupported
argument_list|(
name|NamespaceInfo
operator|.
name|Capability
operator|.
name|STORAGE_BLOCK_REPORT_BUFFERS
argument_list|)
decl_stmt|;
name|blockReportSizes
operator|.
name|clear
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
name|totalBlockCount
operator|<
name|dnConf
operator|.
name|blockReportSplitThreshold
condition|)
block|{
comment|// Below split threshold, send all reports in a single message.
name|DatanodeCommand
name|cmd
init|=
name|bpNamenode
operator|.
name|blockReport
argument_list|(
name|bpRegistration
argument_list|,
name|bpos
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|reports
argument_list|,
operator|new
name|BlockReportContext
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
name|reportId
argument_list|,
name|fullBrLeaseId
argument_list|,
literal|true
argument_list|)
argument_list|)
decl_stmt|;
name|blockReportSizes
operator|.
name|add
argument_list|(
name|calculateBlockReportPBSize
argument_list|(
name|useBlocksBuffer
argument_list|,
name|reports
argument_list|)
argument_list|)
expr_stmt|;
name|numRPCs
operator|=
literal|1
expr_stmt|;
name|numReportsSent
operator|=
name|reports
operator|.
name|length
expr_stmt|;
if|if
condition|(
name|cmd
operator|!=
literal|null
condition|)
block|{
name|cmds
operator|.
name|add
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// Send one block report per message.
for|for
control|(
name|int
name|r
init|=
literal|0
init|;
name|r
operator|<
name|reports
operator|.
name|length
condition|;
name|r
operator|++
control|)
block|{
name|StorageBlockReport
name|singleReport
index|[]
init|=
block|{
name|reports
index|[
name|r
index|]
block|}
decl_stmt|;
name|DatanodeCommand
name|cmd
init|=
name|bpNamenode
operator|.
name|blockReport
argument_list|(
name|bpRegistration
argument_list|,
name|bpos
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|singleReport
argument_list|,
operator|new
name|BlockReportContext
argument_list|(
name|reports
operator|.
name|length
argument_list|,
name|r
argument_list|,
name|reportId
argument_list|,
name|fullBrLeaseId
argument_list|,
literal|true
argument_list|)
argument_list|)
decl_stmt|;
name|blockReportSizes
operator|.
name|add
argument_list|(
name|calculateBlockReportPBSize
argument_list|(
name|useBlocksBuffer
argument_list|,
name|singleReport
argument_list|)
argument_list|)
expr_stmt|;
name|numReportsSent
operator|++
expr_stmt|;
name|numRPCs
operator|++
expr_stmt|;
if|if
condition|(
name|cmd
operator|!=
literal|null
condition|)
block|{
name|cmds
operator|.
name|add
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
comment|// Log the block report processing stats from Datanode perspective
name|long
name|brSendCost
init|=
name|monotonicNow
argument_list|()
operator|-
name|brSendStartTime
decl_stmt|;
name|long
name|brCreateCost
init|=
name|brSendStartTime
operator|-
name|brCreateStartTime
decl_stmt|;
name|dn
operator|.
name|getMetrics
argument_list|()
operator|.
name|addBlockReport
argument_list|(
name|brSendCost
argument_list|)
expr_stmt|;
specifier|final
name|int
name|nCmds
init|=
name|cmds
operator|.
name|size
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
operator|(
name|success
condition|?
literal|"S"
else|:
literal|"Uns"
operator|)
operator|+
literal|"uccessfully sent block report 0x"
operator|+
name|Long
operator|.
name|toHexString
argument_list|(
name|reportId
argument_list|)
operator|+
literal|",  containing "
operator|+
name|reports
operator|.
name|length
operator|+
literal|" storage report(s), of which we sent "
operator|+
name|numReportsSent
operator|+
literal|"."
operator|+
literal|" The reports had "
operator|+
name|totalBlockCount
operator|+
literal|" total blocks and used "
operator|+
name|numRPCs
operator|+
literal|" RPC(s). This took "
operator|+
name|brCreateCost
operator|+
literal|" msec to generate and "
operator|+
name|brSendCost
operator|+
literal|" msecs for RPC and NN processing."
operator|+
literal|" Got back "
operator|+
operator|(
operator|(
name|nCmds
operator|==
literal|0
operator|)
condition|?
literal|"no commands"
else|:
operator|(
operator|(
name|nCmds
operator|==
literal|1
operator|)
condition|?
literal|"one command: "
operator|+
name|cmds
operator|.
name|get
argument_list|(
literal|0
argument_list|)
else|:
operator|(
name|nCmds
operator|+
literal|" commands: "
operator|+
name|Joiner
operator|.
name|on
argument_list|(
literal|"; "
argument_list|)
operator|.
name|join
argument_list|(
name|cmds
argument_list|)
operator|)
operator|)
operator|)
operator|+
literal|"."
argument_list|)
expr_stmt|;
block|}
name|scheduler
operator|.
name|updateLastBlockReportTime
argument_list|(
name|monotonicNow
argument_list|()
argument_list|)
expr_stmt|;
name|scheduler
operator|.
name|scheduleNextBlockReport
argument_list|()
expr_stmt|;
return|return
name|cmds
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|?
literal|null
else|:
name|cmds
return|;
block|}
DECL|method|cacheReport ()
name|DatanodeCommand
name|cacheReport
parameter_list|()
throws|throws
name|IOException
block|{
comment|// If caching is disabled, do not send a cache report
if|if
condition|(
name|dn
operator|.
name|getFSDataset
argument_list|()
operator|.
name|getCacheCapacity
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
literal|null
return|;
block|}
comment|// send cache report if timer has expired.
name|DatanodeCommand
name|cmd
init|=
literal|null
decl_stmt|;
specifier|final
name|long
name|startTime
init|=
name|monotonicNow
argument_list|()
decl_stmt|;
if|if
condition|(
name|startTime
operator|-
name|lastCacheReport
operator|>
name|dnConf
operator|.
name|cacheReportInterval
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Sending cacheReport from service actor: "
operator|+
name|this
argument_list|)
expr_stmt|;
block|}
name|lastCacheReport
operator|=
name|startTime
expr_stmt|;
name|String
name|bpid
init|=
name|bpos
operator|.
name|getBlockPoolId
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Long
argument_list|>
name|blockIds
init|=
name|dn
operator|.
name|getFSDataset
argument_list|()
operator|.
name|getCacheReport
argument_list|(
name|bpid
argument_list|)
decl_stmt|;
name|long
name|createTime
init|=
name|monotonicNow
argument_list|()
decl_stmt|;
name|cmd
operator|=
name|bpNamenode
operator|.
name|cacheReport
argument_list|(
name|bpRegistration
argument_list|,
name|bpid
argument_list|,
name|blockIds
argument_list|)
expr_stmt|;
name|long
name|sendTime
init|=
name|monotonicNow
argument_list|()
decl_stmt|;
name|long
name|createCost
init|=
name|createTime
operator|-
name|startTime
decl_stmt|;
name|long
name|sendCost
init|=
name|sendTime
operator|-
name|createTime
decl_stmt|;
name|dn
operator|.
name|getMetrics
argument_list|()
operator|.
name|addCacheReport
argument_list|(
name|sendCost
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"CacheReport of "
operator|+
name|blockIds
operator|.
name|size
argument_list|()
operator|+
literal|" block(s) took "
operator|+
name|createCost
operator|+
literal|" msec to generate and "
operator|+
name|sendCost
operator|+
literal|" msecs for RPC and NN processing"
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|cmd
return|;
block|}
DECL|method|calculateBlockReportPBSize ( boolean useBlocksBuffer, StorageBlockReport[] reports)
specifier|private
name|int
name|calculateBlockReportPBSize
parameter_list|(
name|boolean
name|useBlocksBuffer
parameter_list|,
name|StorageBlockReport
index|[]
name|reports
parameter_list|)
block|{
name|int
name|reportSize
init|=
literal|0
decl_stmt|;
for|for
control|(
name|StorageBlockReport
name|r
range|:
name|reports
control|)
block|{
if|if
condition|(
name|useBlocksBuffer
condition|)
block|{
name|reportSize
operator|+=
name|r
operator|.
name|getBlocks
argument_list|()
operator|.
name|getBlocksBuffer
argument_list|()
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// each block costs 10 bytes in PB because of uint64
name|reportSize
operator|+=
literal|10
operator|*
name|r
operator|.
name|getBlocks
argument_list|()
operator|.
name|getBlockListAsLongs
argument_list|()
operator|.
name|length
expr_stmt|;
block|}
block|}
return|return
name|reportSize
return|;
block|}
DECL|method|sendHeartBeat (boolean requestBlockReportLease)
name|HeartbeatResponse
name|sendHeartBeat
parameter_list|(
name|boolean
name|requestBlockReportLease
parameter_list|)
throws|throws
name|IOException
block|{
name|scheduler
operator|.
name|scheduleNextHeartbeat
argument_list|()
expr_stmt|;
name|StorageReport
index|[]
name|reports
init|=
name|dn
operator|.
name|getFSDataset
argument_list|()
operator|.
name|getStorageReports
argument_list|(
name|bpos
operator|.
name|getBlockPoolId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Sending heartbeat with "
operator|+
name|reports
operator|.
name|length
operator|+
literal|" storage reports from service actor: "
operator|+
name|this
argument_list|)
expr_stmt|;
block|}
specifier|final
name|long
name|now
init|=
name|monotonicNow
argument_list|()
decl_stmt|;
name|scheduler
operator|.
name|updateLastHeartbeatTime
argument_list|(
name|now
argument_list|)
expr_stmt|;
name|VolumeFailureSummary
name|volumeFailureSummary
init|=
name|dn
operator|.
name|getFSDataset
argument_list|()
operator|.
name|getVolumeFailureSummary
argument_list|()
decl_stmt|;
name|int
name|numFailedVolumes
init|=
name|volumeFailureSummary
operator|!=
literal|null
condition|?
name|volumeFailureSummary
operator|.
name|getFailedStorageLocations
argument_list|()
operator|.
name|length
else|:
literal|0
decl_stmt|;
specifier|final
name|boolean
name|outliersReportDue
init|=
name|scheduler
operator|.
name|isOutliersReportDue
argument_list|(
name|now
argument_list|)
decl_stmt|;
specifier|final
name|SlowPeerReports
name|slowPeers
init|=
name|outliersReportDue
operator|&&
name|dn
operator|.
name|getPeerMetrics
argument_list|()
operator|!=
literal|null
condition|?
name|SlowPeerReports
operator|.
name|create
argument_list|(
name|dn
operator|.
name|getPeerMetrics
argument_list|()
operator|.
name|getOutliers
argument_list|()
argument_list|)
else|:
name|SlowPeerReports
operator|.
name|EMPTY_REPORT
decl_stmt|;
specifier|final
name|SlowDiskReports
name|slowDisks
init|=
name|outliersReportDue
operator|&&
name|dn
operator|.
name|getDiskMetrics
argument_list|()
operator|!=
literal|null
condition|?
name|SlowDiskReports
operator|.
name|create
argument_list|(
name|dn
operator|.
name|getDiskMetrics
argument_list|()
operator|.
name|getDiskOutliersStats
argument_list|()
argument_list|)
else|:
name|SlowDiskReports
operator|.
name|EMPTY_REPORT
decl_stmt|;
name|HeartbeatResponse
name|response
init|=
name|bpNamenode
operator|.
name|sendHeartbeat
argument_list|(
name|bpRegistration
argument_list|,
name|reports
argument_list|,
name|dn
operator|.
name|getFSDataset
argument_list|()
operator|.
name|getCacheCapacity
argument_list|()
argument_list|,
name|dn
operator|.
name|getFSDataset
argument_list|()
operator|.
name|getCacheUsed
argument_list|()
argument_list|,
name|dn
operator|.
name|getXmitsInProgress
argument_list|()
argument_list|,
name|dn
operator|.
name|getXceiverCount
argument_list|()
argument_list|,
name|numFailedVolumes
argument_list|,
name|volumeFailureSummary
argument_list|,
name|requestBlockReportLease
argument_list|,
name|slowPeers
argument_list|,
name|slowDisks
argument_list|)
decl_stmt|;
if|if
condition|(
name|outliersReportDue
condition|)
block|{
comment|// If the report was due and successfully sent, schedule the next one.
name|scheduler
operator|.
name|scheduleNextOutlierReport
argument_list|()
expr_stmt|;
block|}
return|return
name|response
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|sendLifelineForTests ()
name|void
name|sendLifelineForTests
parameter_list|()
throws|throws
name|IOException
block|{
name|lifelineSender
operator|.
name|sendLifeline
argument_list|()
expr_stmt|;
block|}
comment|//This must be called only by BPOfferService
DECL|method|start ()
name|void
name|start
parameter_list|()
block|{
if|if
condition|(
operator|(
name|bpThread
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|bpThread
operator|.
name|isAlive
argument_list|()
operator|)
condition|)
block|{
comment|//Thread is started already
return|return;
block|}
name|bpThread
operator|=
operator|new
name|Thread
argument_list|(
name|this
argument_list|,
name|formatThreadName
argument_list|(
literal|"heartbeating"
argument_list|,
name|nnAddr
argument_list|)
argument_list|)
expr_stmt|;
name|bpThread
operator|.
name|setDaemon
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|// needed for JUnit testing
name|bpThread
operator|.
name|start
argument_list|()
expr_stmt|;
if|if
condition|(
name|lifelineSender
operator|!=
literal|null
condition|)
block|{
name|lifelineSender
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|formatThreadName ( final String action, final InetSocketAddress addr)
specifier|private
name|String
name|formatThreadName
parameter_list|(
specifier|final
name|String
name|action
parameter_list|,
specifier|final
name|InetSocketAddress
name|addr
parameter_list|)
block|{
specifier|final
name|String
name|prefix
init|=
name|bpos
operator|.
name|getBlockPoolId
argument_list|()
operator|!=
literal|null
condition|?
name|bpos
operator|.
name|getBlockPoolId
argument_list|()
else|:
name|bpos
operator|.
name|getNameserviceId
argument_list|()
decl_stmt|;
return|return
name|prefix
operator|+
literal|" "
operator|+
name|action
operator|+
literal|" to "
operator|+
name|addr
return|;
block|}
comment|//This must be called only by blockPoolManager.
DECL|method|stop ()
name|void
name|stop
parameter_list|()
block|{
name|shouldServiceRun
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|lifelineSender
operator|!=
literal|null
condition|)
block|{
name|lifelineSender
operator|.
name|stop
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|bpThread
operator|!=
literal|null
condition|)
block|{
name|bpThread
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
block|}
comment|//This must be called only by blockPoolManager
DECL|method|join ()
name|void
name|join
parameter_list|()
block|{
try|try
block|{
if|if
condition|(
name|lifelineSender
operator|!=
literal|null
condition|)
block|{
name|lifelineSender
operator|.
name|join
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|bpThread
operator|!=
literal|null
condition|)
block|{
name|bpThread
operator|.
name|join
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{ }
block|}
comment|//Cleanup method to be called by current thread before exiting.
DECL|method|cleanUp ()
specifier|private
specifier|synchronized
name|void
name|cleanUp
parameter_list|()
block|{
name|shouldServiceRun
operator|=
literal|false
expr_stmt|;
name|IOUtils
operator|.
name|cleanup
argument_list|(
literal|null
argument_list|,
name|bpNamenode
argument_list|)
expr_stmt|;
name|IOUtils
operator|.
name|cleanup
argument_list|(
literal|null
argument_list|,
name|lifelineSender
argument_list|)
expr_stmt|;
name|bpos
operator|.
name|shutdownActor
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
DECL|method|handleRollingUpgradeStatus (HeartbeatResponse resp)
specifier|private
name|void
name|handleRollingUpgradeStatus
parameter_list|(
name|HeartbeatResponse
name|resp
parameter_list|)
throws|throws
name|IOException
block|{
name|RollingUpgradeStatus
name|rollingUpgradeStatus
init|=
name|resp
operator|.
name|getRollingUpdateStatus
argument_list|()
decl_stmt|;
if|if
condition|(
name|rollingUpgradeStatus
operator|!=
literal|null
operator|&&
name|rollingUpgradeStatus
operator|.
name|getBlockPoolId
argument_list|()
operator|.
name|compareTo
argument_list|(
name|bpos
operator|.
name|getBlockPoolId
argument_list|()
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|// Can this ever occur?
name|LOG
operator|.
name|error
argument_list|(
literal|"Invalid BlockPoolId "
operator|+
name|rollingUpgradeStatus
operator|.
name|getBlockPoolId
argument_list|()
operator|+
literal|" in HeartbeatResponse. Expected "
operator|+
name|bpos
operator|.
name|getBlockPoolId
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bpos
operator|.
name|signalRollingUpgrade
argument_list|(
name|rollingUpgradeStatus
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Main loop for each BP thread. Run until shutdown,    * forever calling remote NameNode functions.    */
DECL|method|offerService ()
specifier|private
name|void
name|offerService
parameter_list|()
throws|throws
name|Exception
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"For namenode "
operator|+
name|nnAddr
operator|+
literal|" using"
operator|+
literal|" BLOCKREPORT_INTERVAL of "
operator|+
name|dnConf
operator|.
name|blockReportInterval
operator|+
literal|"msec"
operator|+
literal|" CACHEREPORT_INTERVAL of "
operator|+
name|dnConf
operator|.
name|cacheReportInterval
operator|+
literal|"msec"
operator|+
literal|" Initial delay: "
operator|+
name|dnConf
operator|.
name|initialBlockReportDelayMs
operator|+
literal|"msec"
operator|+
literal|"; heartBeatInterval="
operator|+
name|dnConf
operator|.
name|heartBeatInterval
operator|+
operator|(
name|lifelineSender
operator|!=
literal|null
condition|?
literal|"; lifelineIntervalMs="
operator|+
name|dnConf
operator|.
name|getLifelineIntervalMs
argument_list|()
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
name|long
name|fullBlockReportLeaseId
init|=
literal|0
decl_stmt|;
comment|//
comment|// Now loop for a long time....
comment|//
while|while
condition|(
name|shouldRun
argument_list|()
condition|)
block|{
try|try
block|{
specifier|final
name|long
name|startTime
init|=
name|scheduler
operator|.
name|monotonicNow
argument_list|()
decl_stmt|;
comment|//
comment|// Every so often, send heartbeat or block-report
comment|//
specifier|final
name|boolean
name|sendHeartbeat
init|=
name|scheduler
operator|.
name|isHeartbeatDue
argument_list|(
name|startTime
argument_list|)
decl_stmt|;
name|HeartbeatResponse
name|resp
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|sendHeartbeat
condition|)
block|{
comment|//
comment|// All heartbeat messages include following info:
comment|// -- Datanode name
comment|// -- data transfer port
comment|// -- Total capacity
comment|// -- Bytes remaining
comment|//
name|boolean
name|requestBlockReportLease
init|=
operator|(
name|fullBlockReportLeaseId
operator|==
literal|0
operator|)
operator|&&
name|scheduler
operator|.
name|isBlockReportDue
argument_list|(
name|startTime
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|dn
operator|.
name|areHeartbeatsDisabledForTests
argument_list|()
condition|)
block|{
name|resp
operator|=
name|sendHeartBeat
argument_list|(
name|requestBlockReportLease
argument_list|)
expr_stmt|;
assert|assert
name|resp
operator|!=
literal|null
assert|;
if|if
condition|(
name|resp
operator|.
name|getFullBlockReportLeaseId
argument_list|()
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|fullBlockReportLeaseId
operator|!=
literal|0
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|nnAddr
operator|+
literal|" sent back a full block report lease "
operator|+
literal|"ID of 0x"
operator|+
name|Long
operator|.
name|toHexString
argument_list|(
name|resp
operator|.
name|getFullBlockReportLeaseId
argument_list|()
argument_list|)
operator|+
literal|", but we already have a lease ID of 0x"
operator|+
name|Long
operator|.
name|toHexString
argument_list|(
name|fullBlockReportLeaseId
argument_list|)
operator|+
literal|". "
operator|+
literal|"Overwriting old lease ID."
argument_list|)
expr_stmt|;
block|}
name|fullBlockReportLeaseId
operator|=
name|resp
operator|.
name|getFullBlockReportLeaseId
argument_list|()
expr_stmt|;
block|}
name|dn
operator|.
name|getMetrics
argument_list|()
operator|.
name|addHeartbeat
argument_list|(
name|scheduler
operator|.
name|monotonicNow
argument_list|()
operator|-
name|startTime
argument_list|)
expr_stmt|;
comment|// If the state of this NN has changed (eg STANDBY->ACTIVE)
comment|// then let the BPOfferService update itself.
comment|//
comment|// Important that this happens before processCommand below,
comment|// since the first heartbeat to a new active might have commands
comment|// that we should actually process.
name|bpos
operator|.
name|updateActorStatesFromHeartbeat
argument_list|(
name|this
argument_list|,
name|resp
operator|.
name|getNameNodeHaState
argument_list|()
argument_list|)
expr_stmt|;
name|state
operator|=
name|resp
operator|.
name|getNameNodeHaState
argument_list|()
operator|.
name|getState
argument_list|()
expr_stmt|;
if|if
condition|(
name|state
operator|==
name|HAServiceState
operator|.
name|ACTIVE
condition|)
block|{
name|handleRollingUpgradeStatus
argument_list|(
name|resp
argument_list|)
expr_stmt|;
block|}
name|long
name|startProcessCommands
init|=
name|monotonicNow
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|processCommand
argument_list|(
name|resp
operator|.
name|getCommands
argument_list|()
argument_list|)
condition|)
continue|continue;
name|long
name|endProcessCommands
init|=
name|monotonicNow
argument_list|()
decl_stmt|;
if|if
condition|(
name|endProcessCommands
operator|-
name|startProcessCommands
operator|>
literal|2000
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Took "
operator|+
operator|(
name|endProcessCommands
operator|-
name|startProcessCommands
operator|)
operator|+
literal|"ms to process "
operator|+
name|resp
operator|.
name|getCommands
argument_list|()
operator|.
name|length
operator|+
literal|" commands from NN"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|ibrManager
operator|.
name|sendImmediately
argument_list|()
operator|||
name|sendHeartbeat
condition|)
block|{
name|ibrManager
operator|.
name|sendIBRs
argument_list|(
name|bpNamenode
argument_list|,
name|bpRegistration
argument_list|,
name|bpos
operator|.
name|getBlockPoolId
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|DatanodeCommand
argument_list|>
name|cmds
init|=
literal|null
decl_stmt|;
name|boolean
name|forceFullBr
init|=
name|scheduler
operator|.
name|forceFullBlockReport
operator|.
name|getAndSet
argument_list|(
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|forceFullBr
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Forcing a full block report to "
operator|+
name|nnAddr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|fullBlockReportLeaseId
operator|!=
literal|0
operator|)
operator|||
name|forceFullBr
condition|)
block|{
name|cmds
operator|=
name|blockReport
argument_list|(
name|fullBlockReportLeaseId
argument_list|)
expr_stmt|;
name|fullBlockReportLeaseId
operator|=
literal|0
expr_stmt|;
block|}
name|processCommand
argument_list|(
name|cmds
operator|==
literal|null
condition|?
literal|null
else|:
name|cmds
operator|.
name|toArray
argument_list|(
operator|new
name|DatanodeCommand
index|[
name|cmds
operator|.
name|size
argument_list|()
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dn
operator|.
name|areCacheReportsDisabledForTests
argument_list|()
condition|)
block|{
name|DatanodeCommand
name|cmd
init|=
name|cacheReport
argument_list|()
decl_stmt|;
name|processCommand
argument_list|(
operator|new
name|DatanodeCommand
index|[]
block|{
name|cmd
block|}
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sendHeartbeat
condition|)
block|{
name|dn
operator|.
name|getMetrics
argument_list|()
operator|.
name|addHeartbeatTotal
argument_list|(
name|scheduler
operator|.
name|monotonicNow
argument_list|()
operator|-
name|startTime
argument_list|)
expr_stmt|;
block|}
comment|// There is no work to do;  sleep until hearbeat timer elapses,
comment|// or work arrives, and then iterate again.
name|ibrManager
operator|.
name|waitTillNextIBR
argument_list|(
name|scheduler
operator|.
name|getHeartbeatWaitTime
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RemoteException
name|re
parameter_list|)
block|{
name|String
name|reClass
init|=
name|re
operator|.
name|getClassName
argument_list|()
decl_stmt|;
if|if
condition|(
name|UnregisteredNodeException
operator|.
name|class
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|reClass
argument_list|)
operator|||
name|DisallowedDatanodeException
operator|.
name|class
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|reClass
argument_list|)
operator|||
name|IncorrectVersionException
operator|.
name|class
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|reClass
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|this
operator|+
literal|" is shutting down"
argument_list|,
name|re
argument_list|)
expr_stmt|;
name|shouldServiceRun
operator|=
literal|false
expr_stmt|;
return|return;
block|}
name|LOG
operator|.
name|warn
argument_list|(
literal|"RemoteException in offerService"
argument_list|,
name|re
argument_list|)
expr_stmt|;
name|sleepAfterException
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"IOException in offerService"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|sleepAfterException
argument_list|()
expr_stmt|;
block|}
name|processQueueMessages
argument_list|()
expr_stmt|;
block|}
comment|// while (shouldRun())
block|}
comment|// offerService
DECL|method|sleepAfterException ()
specifier|private
name|void
name|sleepAfterException
parameter_list|()
block|{
try|try
block|{
name|long
name|sleepTime
init|=
name|Math
operator|.
name|min
argument_list|(
literal|1000
argument_list|,
name|dnConf
operator|.
name|heartBeatInterval
argument_list|)
decl_stmt|;
name|Thread
operator|.
name|sleep
argument_list|(
name|sleepTime
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Register one bp with the corresponding NameNode    *<p>    * The bpDatanode needs to register with the namenode on startup in order    * 1) to report which storage it is serving now and     * 2) to receive a registrationID    *      * issued by the namenode to recognize registered datanodes.    *     * @param nsInfo current NamespaceInfo    * @see FSNamesystem#registerDatanode(DatanodeRegistration)    * @throws IOException    */
DECL|method|register (NamespaceInfo nsInfo)
name|void
name|register
parameter_list|(
name|NamespaceInfo
name|nsInfo
parameter_list|)
throws|throws
name|IOException
block|{
comment|// The handshake() phase loaded the block pool storage
comment|// off disk - so update the bpRegistration object from that info
name|DatanodeRegistration
name|newBpRegistration
init|=
name|bpos
operator|.
name|createRegistration
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|this
operator|+
literal|" beginning handshake with NN"
argument_list|)
expr_stmt|;
while|while
condition|(
name|shouldRun
argument_list|()
condition|)
block|{
try|try
block|{
comment|// Use returned registration from namenode with updated fields
name|newBpRegistration
operator|=
name|bpNamenode
operator|.
name|registerDatanode
argument_list|(
name|newBpRegistration
argument_list|)
expr_stmt|;
name|newBpRegistration
operator|.
name|setNamespaceInfo
argument_list|(
name|nsInfo
argument_list|)
expr_stmt|;
name|bpRegistration
operator|=
name|newBpRegistration
expr_stmt|;
break|break;
block|}
catch|catch
parameter_list|(
name|EOFException
name|e
parameter_list|)
block|{
comment|// namenode might have just restarted
name|LOG
operator|.
name|info
argument_list|(
literal|"Problem connecting to server: "
operator|+
name|nnAddr
operator|+
literal|" :"
operator|+
name|e
operator|.
name|getLocalizedMessage
argument_list|()
argument_list|)
expr_stmt|;
name|sleepAndLogInterrupts
argument_list|(
literal|1000
argument_list|,
literal|"connecting to server"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SocketTimeoutException
name|e
parameter_list|)
block|{
comment|// namenode is busy
name|LOG
operator|.
name|info
argument_list|(
literal|"Problem connecting to server: "
operator|+
name|nnAddr
argument_list|)
expr_stmt|;
name|sleepAndLogInterrupts
argument_list|(
literal|1000
argument_list|,
literal|"connecting to server"
argument_list|)
expr_stmt|;
block|}
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Block pool "
operator|+
name|this
operator|+
literal|" successfully registered with NN"
argument_list|)
expr_stmt|;
name|bpos
operator|.
name|registrationSucceeded
argument_list|(
name|this
argument_list|,
name|bpRegistration
argument_list|)
expr_stmt|;
comment|// random short delay - helps scatter the BR from all DNs
name|scheduler
operator|.
name|scheduleBlockReport
argument_list|(
name|dnConf
operator|.
name|initialBlockReportDelayMs
argument_list|)
expr_stmt|;
block|}
DECL|method|sleepAndLogInterrupts (int millis, String stateString)
specifier|private
name|void
name|sleepAndLogInterrupts
parameter_list|(
name|int
name|millis
parameter_list|,
name|String
name|stateString
parameter_list|)
block|{
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|millis
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"BPOfferService "
operator|+
name|this
operator|+
literal|" interrupted while "
operator|+
name|stateString
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * No matter what kind of exception we get, keep retrying to offerService().    * That's the loop that connects to the NameNode and provides basic DataNode    * functionality.    *    * Only stop when "shouldRun" or "shouldServiceRun" is turned off, which can    * happen either at shutdown or due to refreshNamenodes.    */
annotation|@
name|Override
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
name|LOG
operator|.
name|info
argument_list|(
name|this
operator|+
literal|" starting to offer service"
argument_list|)
expr_stmt|;
try|try
block|{
while|while
condition|(
literal|true
condition|)
block|{
comment|// init stuff
try|try
block|{
comment|// setup storage
name|connectToNNAndHandshake
argument_list|()
expr_stmt|;
break|break;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
comment|// Initial handshake, storage recovery or registration failed
name|runningState
operator|=
name|RunningState
operator|.
name|INIT_FAILED
expr_stmt|;
if|if
condition|(
name|shouldRetryInit
argument_list|()
condition|)
block|{
comment|// Retry until all namenode's of BPOS failed initialization
name|LOG
operator|.
name|error
argument_list|(
literal|"Initialization failed for "
operator|+
name|this
operator|+
literal|" "
operator|+
name|ioe
operator|.
name|getLocalizedMessage
argument_list|()
argument_list|)
expr_stmt|;
name|sleepAndLogInterrupts
argument_list|(
literal|5000
argument_list|,
literal|"initializing"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|runningState
operator|=
name|RunningState
operator|.
name|FAILED
expr_stmt|;
name|LOG
operator|.
name|error
argument_list|(
literal|"Initialization failed for "
operator|+
name|this
operator|+
literal|". Exiting. "
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
name|runningState
operator|=
name|RunningState
operator|.
name|RUNNING
expr_stmt|;
if|if
condition|(
name|initialRegistrationComplete
operator|!=
literal|null
condition|)
block|{
name|initialRegistrationComplete
operator|.
name|countDown
argument_list|()
expr_stmt|;
block|}
while|while
condition|(
name|shouldRun
argument_list|()
condition|)
block|{
try|try
block|{
name|offerService
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Exception in BPOfferService for "
operator|+
name|this
argument_list|,
name|ex
argument_list|)
expr_stmt|;
name|sleepAndLogInterrupts
argument_list|(
literal|5000
argument_list|,
literal|"offering service"
argument_list|)
expr_stmt|;
block|}
block|}
name|runningState
operator|=
name|RunningState
operator|.
name|EXITED
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Unexpected exception in block pool "
operator|+
name|this
argument_list|,
name|ex
argument_list|)
expr_stmt|;
name|runningState
operator|=
name|RunningState
operator|.
name|FAILED
expr_stmt|;
block|}
finally|finally
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Ending block pool service for: "
operator|+
name|this
argument_list|)
expr_stmt|;
name|cleanUp
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|shouldRetryInit ()
specifier|private
name|boolean
name|shouldRetryInit
parameter_list|()
block|{
return|return
name|shouldRun
argument_list|()
operator|&&
name|bpos
operator|.
name|shouldRetryInit
argument_list|()
return|;
block|}
DECL|method|shouldRun ()
specifier|private
name|boolean
name|shouldRun
parameter_list|()
block|{
return|return
name|shouldServiceRun
operator|&&
name|dn
operator|.
name|shouldRun
argument_list|()
return|;
block|}
comment|/**    * Process an array of datanode commands    *     * @param cmds an array of datanode commands    * @return true if further processing may be required or false otherwise.     */
DECL|method|processCommand (DatanodeCommand[] cmds)
name|boolean
name|processCommand
parameter_list|(
name|DatanodeCommand
index|[]
name|cmds
parameter_list|)
block|{
if|if
condition|(
name|cmds
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|DatanodeCommand
name|cmd
range|:
name|cmds
control|)
block|{
try|try
block|{
if|if
condition|(
name|bpos
operator|.
name|processCommandFromActor
argument_list|(
name|cmd
argument_list|,
name|this
argument_list|)
operator|==
literal|false
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Error processing datanode Command"
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Report a bad block from another DN in this cluster.    */
DECL|method|reportRemoteBadBlock (DatanodeInfo dnInfo, ExtendedBlock block)
name|void
name|reportRemoteBadBlock
parameter_list|(
name|DatanodeInfo
name|dnInfo
parameter_list|,
name|ExtendedBlock
name|block
parameter_list|)
throws|throws
name|IOException
block|{
name|LocatedBlock
name|lb
init|=
operator|new
name|LocatedBlock
argument_list|(
name|block
argument_list|,
operator|new
name|DatanodeInfo
index|[]
block|{
name|dnInfo
block|}
argument_list|)
decl_stmt|;
name|bpNamenode
operator|.
name|reportBadBlocks
argument_list|(
operator|new
name|LocatedBlock
index|[]
block|{
name|lb
block|}
argument_list|)
expr_stmt|;
block|}
DECL|method|reRegister ()
name|void
name|reRegister
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|shouldRun
argument_list|()
condition|)
block|{
comment|// re-retrieve namespace info to make sure that, if the NN
comment|// was restarted, we still match its version (HDFS-2120)
name|NamespaceInfo
name|nsInfo
init|=
name|retrieveNamespaceInfo
argument_list|()
decl_stmt|;
comment|// and re-register
name|register
argument_list|(
name|nsInfo
argument_list|)
expr_stmt|;
name|scheduler
operator|.
name|scheduleHeartbeat
argument_list|()
expr_stmt|;
comment|// HDFS-9917,Standby NN IBR can be very huge if standby namenode is down
comment|// for sometime.
if|if
condition|(
name|state
operator|==
name|HAServiceState
operator|.
name|STANDBY
condition|)
block|{
name|ibrManager
operator|.
name|clearIBRs
argument_list|()
expr_stmt|;
block|}
block|}
block|}
DECL|method|triggerBlockReport (BlockReportOptions options)
name|void
name|triggerBlockReport
parameter_list|(
name|BlockReportOptions
name|options
parameter_list|)
block|{
if|if
condition|(
name|options
operator|.
name|isIncremental
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
name|bpos
operator|.
name|toString
argument_list|()
operator|+
literal|": scheduling an incremental block report."
argument_list|)
expr_stmt|;
name|ibrManager
operator|.
name|triggerIBR
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|info
argument_list|(
name|bpos
operator|.
name|toString
argument_list|()
operator|+
literal|": scheduling a full block report."
argument_list|)
expr_stmt|;
synchronized|synchronized
init|(
name|ibrManager
init|)
block|{
name|scheduler
operator|.
name|forceFullBlockReportNow
argument_list|()
expr_stmt|;
name|ibrManager
operator|.
name|notifyAll
argument_list|()
expr_stmt|;
block|}
block|}
block|}
DECL|method|bpThreadEnqueue (BPServiceActorAction action)
specifier|public
name|void
name|bpThreadEnqueue
parameter_list|(
name|BPServiceActorAction
name|action
parameter_list|)
block|{
synchronized|synchronized
init|(
name|bpThreadQueue
init|)
block|{
if|if
condition|(
operator|!
name|bpThreadQueue
operator|.
name|contains
argument_list|(
name|action
argument_list|)
condition|)
block|{
name|bpThreadQueue
operator|.
name|add
argument_list|(
name|action
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|processQueueMessages ()
specifier|private
name|void
name|processQueueMessages
parameter_list|()
block|{
name|LinkedList
argument_list|<
name|BPServiceActorAction
argument_list|>
name|duplicateQueue
decl_stmt|;
synchronized|synchronized
init|(
name|bpThreadQueue
init|)
block|{
name|duplicateQueue
operator|=
operator|new
name|LinkedList
argument_list|<
name|BPServiceActorAction
argument_list|>
argument_list|(
name|bpThreadQueue
argument_list|)
expr_stmt|;
name|bpThreadQueue
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
while|while
condition|(
operator|!
name|duplicateQueue
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|BPServiceActorAction
name|actionItem
init|=
name|duplicateQueue
operator|.
name|remove
argument_list|()
decl_stmt|;
try|try
block|{
name|actionItem
operator|.
name|reportTo
argument_list|(
name|bpNamenode
argument_list|,
name|bpRegistration
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|BPServiceActorActionException
name|baae
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|baae
operator|.
name|getMessage
argument_list|()
operator|+
name|nnAddr
argument_list|,
name|baae
argument_list|)
expr_stmt|;
comment|// Adding it back to the queue if not present
name|bpThreadEnqueue
argument_list|(
name|actionItem
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|getScheduler ()
name|Scheduler
name|getScheduler
parameter_list|()
block|{
return|return
name|scheduler
return|;
block|}
DECL|class|LifelineSender
specifier|private
specifier|final
class|class
name|LifelineSender
implements|implements
name|Runnable
implements|,
name|Closeable
block|{
DECL|field|lifelineNnAddr
specifier|private
specifier|final
name|InetSocketAddress
name|lifelineNnAddr
decl_stmt|;
DECL|field|lifelineThread
specifier|private
name|Thread
name|lifelineThread
decl_stmt|;
DECL|field|lifelineNamenode
specifier|private
name|DatanodeLifelineProtocolClientSideTranslatorPB
name|lifelineNamenode
decl_stmt|;
DECL|method|LifelineSender (InetSocketAddress lifelineNnAddr)
specifier|public
name|LifelineSender
parameter_list|(
name|InetSocketAddress
name|lifelineNnAddr
parameter_list|)
block|{
name|this
operator|.
name|lifelineNnAddr
operator|=
name|lifelineNnAddr
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|close ()
specifier|public
name|void
name|close
parameter_list|()
block|{
name|stop
argument_list|()
expr_stmt|;
try|try
block|{
name|join
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
name|IOUtils
operator|.
name|cleanup
argument_list|(
literal|null
argument_list|,
name|lifelineNamenode
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
comment|// The lifeline RPC depends on registration with the NameNode, so wait for
comment|// initial registration to complete.
while|while
condition|(
name|shouldRun
argument_list|()
condition|)
block|{
try|try
block|{
name|initialRegistrationComplete
operator|.
name|await
argument_list|()
expr_stmt|;
break|break;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
comment|// The only way thread interruption can happen while waiting on this
comment|// latch is if the state of the actor has been updated to signal
comment|// shutdown.  The next loop's call to shouldRun() will return false,
comment|// and the thread will finish.
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
block|}
comment|// After initial NameNode registration has completed, execute the main
comment|// loop for sending periodic lifeline RPCs if needed.  This is done in a
comment|// second loop to avoid a pointless wait on the above latch in every
comment|// iteration of the main loop.
while|while
condition|(
name|shouldRun
argument_list|()
condition|)
block|{
try|try
block|{
if|if
condition|(
name|lifelineNamenode
operator|==
literal|null
condition|)
block|{
name|lifelineNamenode
operator|=
name|dn
operator|.
name|connectToLifelineNN
argument_list|(
name|lifelineNnAddr
argument_list|)
expr_stmt|;
block|}
name|sendLifelineIfDue
argument_list|()
expr_stmt|;
name|Thread
operator|.
name|sleep
argument_list|(
name|scheduler
operator|.
name|getLifelineWaitTime
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"IOException in LifelineSender for "
operator|+
name|BPServiceActor
operator|.
name|this
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"LifelineSender for "
operator|+
name|BPServiceActor
operator|.
name|this
operator|+
literal|" exiting."
argument_list|)
expr_stmt|;
block|}
DECL|method|start ()
specifier|public
name|void
name|start
parameter_list|()
block|{
name|lifelineThread
operator|=
operator|new
name|Thread
argument_list|(
name|this
argument_list|,
name|formatThreadName
argument_list|(
literal|"lifeline"
argument_list|,
name|lifelineNnAddr
argument_list|)
argument_list|)
expr_stmt|;
name|lifelineThread
operator|.
name|setDaemon
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|lifelineThread
operator|.
name|setUncaughtExceptionHandler
argument_list|(
operator|new
name|Thread
operator|.
name|UncaughtExceptionHandler
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|uncaughtException
parameter_list|(
name|Thread
name|thread
parameter_list|,
name|Throwable
name|t
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
name|thread
operator|+
literal|" terminating on unexpected exception"
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
name|lifelineThread
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
DECL|method|stop ()
specifier|public
name|void
name|stop
parameter_list|()
block|{
if|if
condition|(
name|lifelineThread
operator|!=
literal|null
condition|)
block|{
name|lifelineThread
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|join ()
specifier|public
name|void
name|join
parameter_list|()
throws|throws
name|InterruptedException
block|{
if|if
condition|(
name|lifelineThread
operator|!=
literal|null
condition|)
block|{
name|lifelineThread
operator|.
name|join
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|sendLifelineIfDue ()
specifier|private
name|void
name|sendLifelineIfDue
parameter_list|()
throws|throws
name|IOException
block|{
name|long
name|startTime
init|=
name|scheduler
operator|.
name|monotonicNow
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|scheduler
operator|.
name|isLifelineDue
argument_list|(
name|startTime
argument_list|)
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Skipping sending lifeline for "
operator|+
name|BPServiceActor
operator|.
name|this
operator|+
literal|", because it is not due."
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
name|dn
operator|.
name|areHeartbeatsDisabledForTests
argument_list|()
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Skipping sending lifeline for "
operator|+
name|BPServiceActor
operator|.
name|this
operator|+
literal|", because heartbeats are disabled for tests."
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
name|sendLifeline
argument_list|()
expr_stmt|;
name|dn
operator|.
name|getMetrics
argument_list|()
operator|.
name|addLifeline
argument_list|(
name|scheduler
operator|.
name|monotonicNow
argument_list|()
operator|-
name|startTime
argument_list|)
expr_stmt|;
name|scheduler
operator|.
name|scheduleNextLifeline
argument_list|(
name|scheduler
operator|.
name|monotonicNow
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|sendLifeline ()
specifier|private
name|void
name|sendLifeline
parameter_list|()
throws|throws
name|IOException
block|{
name|StorageReport
index|[]
name|reports
init|=
name|dn
operator|.
name|getFSDataset
argument_list|()
operator|.
name|getStorageReports
argument_list|(
name|bpos
operator|.
name|getBlockPoolId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Sending lifeline with "
operator|+
name|reports
operator|.
name|length
operator|+
literal|" storage "
operator|+
literal|" reports from service actor: "
operator|+
name|BPServiceActor
operator|.
name|this
argument_list|)
expr_stmt|;
block|}
name|VolumeFailureSummary
name|volumeFailureSummary
init|=
name|dn
operator|.
name|getFSDataset
argument_list|()
operator|.
name|getVolumeFailureSummary
argument_list|()
decl_stmt|;
name|int
name|numFailedVolumes
init|=
name|volumeFailureSummary
operator|!=
literal|null
condition|?
name|volumeFailureSummary
operator|.
name|getFailedStorageLocations
argument_list|()
operator|.
name|length
else|:
literal|0
decl_stmt|;
name|lifelineNamenode
operator|.
name|sendLifeline
argument_list|(
name|bpRegistration
argument_list|,
name|reports
argument_list|,
name|dn
operator|.
name|getFSDataset
argument_list|()
operator|.
name|getCacheCapacity
argument_list|()
argument_list|,
name|dn
operator|.
name|getFSDataset
argument_list|()
operator|.
name|getCacheUsed
argument_list|()
argument_list|,
name|dn
operator|.
name|getXmitsInProgress
argument_list|()
argument_list|,
name|dn
operator|.
name|getXceiverCount
argument_list|()
argument_list|,
name|numFailedVolumes
argument_list|,
name|volumeFailureSummary
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Utility class that wraps the timestamp computations for scheduling    * heartbeats and block reports.    */
DECL|class|Scheduler
specifier|static
class|class
name|Scheduler
block|{
comment|// nextBlockReportTime and nextHeartbeatTime may be assigned/read
comment|// by testing threads (through BPServiceActor#triggerXXX), while also
comment|// assigned/read by the actor thread.
annotation|@
name|VisibleForTesting
DECL|field|nextBlockReportTime
specifier|volatile
name|long
name|nextBlockReportTime
init|=
name|monotonicNow
argument_list|()
decl_stmt|;
annotation|@
name|VisibleForTesting
DECL|field|nextHeartbeatTime
specifier|volatile
name|long
name|nextHeartbeatTime
init|=
name|monotonicNow
argument_list|()
decl_stmt|;
annotation|@
name|VisibleForTesting
DECL|field|nextLifelineTime
specifier|volatile
name|long
name|nextLifelineTime
decl_stmt|;
annotation|@
name|VisibleForTesting
DECL|field|lastBlockReportTime
specifier|volatile
name|long
name|lastBlockReportTime
init|=
name|monotonicNow
argument_list|()
decl_stmt|;
annotation|@
name|VisibleForTesting
DECL|field|lastHeartbeatTime
specifier|volatile
name|long
name|lastHeartbeatTime
init|=
name|monotonicNow
argument_list|()
decl_stmt|;
annotation|@
name|VisibleForTesting
DECL|field|resetBlockReportTime
name|boolean
name|resetBlockReportTime
init|=
literal|true
decl_stmt|;
annotation|@
name|VisibleForTesting
DECL|field|nextOutliersReportTime
specifier|volatile
name|long
name|nextOutliersReportTime
init|=
name|monotonicNow
argument_list|()
decl_stmt|;
DECL|field|forceFullBlockReport
specifier|private
specifier|final
name|AtomicBoolean
name|forceFullBlockReport
init|=
operator|new
name|AtomicBoolean
argument_list|(
literal|false
argument_list|)
decl_stmt|;
DECL|field|heartbeatIntervalMs
specifier|private
specifier|final
name|long
name|heartbeatIntervalMs
decl_stmt|;
DECL|field|lifelineIntervalMs
specifier|private
specifier|final
name|long
name|lifelineIntervalMs
decl_stmt|;
DECL|field|blockReportIntervalMs
specifier|private
specifier|final
name|long
name|blockReportIntervalMs
decl_stmt|;
DECL|field|outliersReportIntervalMs
specifier|private
specifier|final
name|long
name|outliersReportIntervalMs
decl_stmt|;
DECL|method|Scheduler (long heartbeatIntervalMs, long lifelineIntervalMs, long blockReportIntervalMs, long outliersReportIntervalMs)
name|Scheduler
parameter_list|(
name|long
name|heartbeatIntervalMs
parameter_list|,
name|long
name|lifelineIntervalMs
parameter_list|,
name|long
name|blockReportIntervalMs
parameter_list|,
name|long
name|outliersReportIntervalMs
parameter_list|)
block|{
name|this
operator|.
name|heartbeatIntervalMs
operator|=
name|heartbeatIntervalMs
expr_stmt|;
name|this
operator|.
name|lifelineIntervalMs
operator|=
name|lifelineIntervalMs
expr_stmt|;
name|this
operator|.
name|blockReportIntervalMs
operator|=
name|blockReportIntervalMs
expr_stmt|;
name|this
operator|.
name|outliersReportIntervalMs
operator|=
name|outliersReportIntervalMs
expr_stmt|;
name|scheduleNextLifeline
argument_list|(
name|nextHeartbeatTime
argument_list|)
expr_stmt|;
block|}
comment|// This is useful to make sure NN gets Heartbeat before Blockreport
comment|// upon NN restart while DN keeps retrying Otherwise,
comment|// 1. NN restarts.
comment|// 2. Heartbeat RPC will retry and succeed. NN asks DN to reregister.
comment|// 3. After reregistration completes, DN will send Blockreport first.
comment|// 4. Given NN receives Blockreport after Heartbeat, it won't mark
comment|//    DatanodeStorageInfo#blockContentsStale to false until the next
comment|//    Blockreport.
DECL|method|scheduleHeartbeat ()
name|long
name|scheduleHeartbeat
parameter_list|()
block|{
name|nextHeartbeatTime
operator|=
name|monotonicNow
argument_list|()
expr_stmt|;
name|scheduleNextLifeline
argument_list|(
name|nextHeartbeatTime
argument_list|)
expr_stmt|;
return|return
name|nextHeartbeatTime
return|;
block|}
DECL|method|scheduleNextHeartbeat ()
name|long
name|scheduleNextHeartbeat
parameter_list|()
block|{
comment|// Numerical overflow is possible here and is okay.
name|nextHeartbeatTime
operator|=
name|monotonicNow
argument_list|()
operator|+
name|heartbeatIntervalMs
expr_stmt|;
name|scheduleNextLifeline
argument_list|(
name|nextHeartbeatTime
argument_list|)
expr_stmt|;
return|return
name|nextHeartbeatTime
return|;
block|}
DECL|method|updateLastHeartbeatTime (long heartbeatTime)
name|void
name|updateLastHeartbeatTime
parameter_list|(
name|long
name|heartbeatTime
parameter_list|)
block|{
name|lastHeartbeatTime
operator|=
name|heartbeatTime
expr_stmt|;
block|}
DECL|method|updateLastBlockReportTime (long blockReportTime)
name|void
name|updateLastBlockReportTime
parameter_list|(
name|long
name|blockReportTime
parameter_list|)
block|{
name|lastBlockReportTime
operator|=
name|blockReportTime
expr_stmt|;
block|}
DECL|method|scheduleNextOutlierReport ()
name|void
name|scheduleNextOutlierReport
parameter_list|()
block|{
name|nextOutliersReportTime
operator|=
name|monotonicNow
argument_list|()
operator|+
name|outliersReportIntervalMs
expr_stmt|;
block|}
DECL|method|getLastHearbeatTime ()
name|long
name|getLastHearbeatTime
parameter_list|()
block|{
return|return
operator|(
name|monotonicNow
argument_list|()
operator|-
name|lastHeartbeatTime
operator|)
operator|/
literal|1000
return|;
block|}
DECL|method|getLastBlockReportTime ()
name|long
name|getLastBlockReportTime
parameter_list|()
block|{
return|return
operator|(
name|monotonicNow
argument_list|()
operator|-
name|lastBlockReportTime
operator|)
operator|/
literal|1000
return|;
block|}
DECL|method|scheduleNextLifeline (long baseTime)
name|long
name|scheduleNextLifeline
parameter_list|(
name|long
name|baseTime
parameter_list|)
block|{
comment|// Numerical overflow is possible here and is okay.
name|nextLifelineTime
operator|=
name|baseTime
operator|+
name|lifelineIntervalMs
expr_stmt|;
return|return
name|nextLifelineTime
return|;
block|}
DECL|method|isHeartbeatDue (long startTime)
name|boolean
name|isHeartbeatDue
parameter_list|(
name|long
name|startTime
parameter_list|)
block|{
return|return
operator|(
name|nextHeartbeatTime
operator|-
name|startTime
operator|<=
literal|0
operator|)
return|;
block|}
DECL|method|isLifelineDue (long startTime)
name|boolean
name|isLifelineDue
parameter_list|(
name|long
name|startTime
parameter_list|)
block|{
return|return
operator|(
name|nextLifelineTime
operator|-
name|startTime
operator|<=
literal|0
operator|)
return|;
block|}
DECL|method|isBlockReportDue (long curTime)
name|boolean
name|isBlockReportDue
parameter_list|(
name|long
name|curTime
parameter_list|)
block|{
return|return
name|nextBlockReportTime
operator|-
name|curTime
operator|<=
literal|0
return|;
block|}
DECL|method|isOutliersReportDue (long curTime)
name|boolean
name|isOutliersReportDue
parameter_list|(
name|long
name|curTime
parameter_list|)
block|{
return|return
name|nextOutliersReportTime
operator|-
name|curTime
operator|<=
literal|0
return|;
block|}
DECL|method|forceFullBlockReportNow ()
name|void
name|forceFullBlockReportNow
parameter_list|()
block|{
name|forceFullBlockReport
operator|.
name|set
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|resetBlockReportTime
operator|=
literal|true
expr_stmt|;
block|}
comment|/**      * This methods  arranges for the data node to send the block report at      * the next heartbeat.      */
DECL|method|scheduleBlockReport (long delay)
name|long
name|scheduleBlockReport
parameter_list|(
name|long
name|delay
parameter_list|)
block|{
if|if
condition|(
name|delay
operator|>
literal|0
condition|)
block|{
comment|// send BR after random delay
comment|// Numerical overflow is possible here and is okay.
name|nextBlockReportTime
operator|=
name|monotonicNow
argument_list|()
operator|+
name|ThreadLocalRandom
operator|.
name|current
argument_list|()
operator|.
name|nextInt
argument_list|(
call|(
name|int
call|)
argument_list|(
name|delay
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// send at next heartbeat
name|nextBlockReportTime
operator|=
name|monotonicNow
argument_list|()
expr_stmt|;
block|}
name|resetBlockReportTime
operator|=
literal|true
expr_stmt|;
comment|// reset future BRs for randomness
return|return
name|nextBlockReportTime
return|;
block|}
comment|/**      * Schedule the next block report after the block report interval. If the      * current block report was delayed then the next block report is sent per      * the original schedule.      * Numerical overflow is possible here.      */
DECL|method|scheduleNextBlockReport ()
name|void
name|scheduleNextBlockReport
parameter_list|()
block|{
comment|// If we have sent the first set of block reports, then wait a random
comment|// time before we start the periodic block reports.
if|if
condition|(
name|resetBlockReportTime
condition|)
block|{
name|nextBlockReportTime
operator|=
name|monotonicNow
argument_list|()
operator|+
name|ThreadLocalRandom
operator|.
name|current
argument_list|()
operator|.
name|nextInt
argument_list|(
call|(
name|int
call|)
argument_list|(
name|blockReportIntervalMs
argument_list|)
argument_list|)
expr_stmt|;
name|resetBlockReportTime
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
comment|/* say the last block report was at 8:20:14. The current report          * should have started around 14:20:14 (default 6 hour interval).          * If current time is :          *   1) normal like 14:20:18, next report should be at 20:20:14.          *   2) unexpected like 21:35:43, next report should be at 2:20:14          *      on the next day.          */
name|nextBlockReportTime
operator|+=
operator|(
operator|(
operator|(
name|monotonicNow
argument_list|()
operator|-
name|nextBlockReportTime
operator|+
name|blockReportIntervalMs
operator|)
operator|/
name|blockReportIntervalMs
operator|)
operator|)
operator|*
name|blockReportIntervalMs
expr_stmt|;
block|}
block|}
DECL|method|getHeartbeatWaitTime ()
name|long
name|getHeartbeatWaitTime
parameter_list|()
block|{
return|return
name|nextHeartbeatTime
operator|-
name|monotonicNow
argument_list|()
return|;
block|}
DECL|method|getLifelineWaitTime ()
name|long
name|getLifelineWaitTime
parameter_list|()
block|{
return|return
name|nextLifelineTime
operator|-
name|monotonicNow
argument_list|()
return|;
block|}
comment|/**      * Wrapped for testing.      * @return      */
annotation|@
name|VisibleForTesting
DECL|method|monotonicNow ()
specifier|public
name|long
name|monotonicNow
parameter_list|()
block|{
return|return
name|Time
operator|.
name|monotonicNow
argument_list|()
return|;
block|}
block|}
block|}
end_class

end_unit

