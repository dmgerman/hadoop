begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdfs.server.datanode
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileNotFoundException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|cache
operator|.
name|Cache
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|cache
operator|.
name|CacheBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|Block
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|ExtendedBlock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|BlockScanner
operator|.
name|Conf
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|fsdataset
operator|.
name|FsVolumeReference
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|fsdataset
operator|.
name|FsVolumeSpi
operator|.
name|BlockIterator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|fsdataset
operator|.
name|FsVolumeSpi
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|util
operator|.
name|DataTransferThrottler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Time
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_comment
comment|/**  * VolumeScanner scans a single volume.  Each VolumeScanner has its own thread.<p/>  * They are all managed by the DataNode's BlockScanner.  */
end_comment

begin_class
DECL|class|VolumeScanner
specifier|public
class|class
name|VolumeScanner
extends|extends
name|Thread
block|{
DECL|field|LOG
specifier|public
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|VolumeScanner
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/**    * Number of seconds in a minute.    */
DECL|field|SECONDS_PER_MINUTE
specifier|private
specifier|final
specifier|static
name|int
name|SECONDS_PER_MINUTE
init|=
literal|60
decl_stmt|;
comment|/**    * Number of minutes in an hour.    */
DECL|field|MINUTES_PER_HOUR
specifier|private
specifier|final
specifier|static
name|int
name|MINUTES_PER_HOUR
init|=
literal|60
decl_stmt|;
comment|/**    * Name of the block iterator used by this scanner.    */
DECL|field|BLOCK_ITERATOR_NAME
specifier|private
specifier|final
specifier|static
name|String
name|BLOCK_ITERATOR_NAME
init|=
literal|"scanner"
decl_stmt|;
comment|/**    * The configuration.    */
DECL|field|conf
specifier|private
name|Conf
name|conf
decl_stmt|;
annotation|@
name|VisibleForTesting
DECL|method|setConf (Conf conf)
name|void
name|setConf
parameter_list|(
name|Conf
name|conf
parameter_list|)
block|{
name|this
operator|.
name|conf
operator|=
name|conf
expr_stmt|;
block|}
comment|/**    * The DataNode this VolumEscanner is associated with.    */
DECL|field|datanode
specifier|private
specifier|final
name|DataNode
name|datanode
decl_stmt|;
comment|/**    * A reference to the volume that we're scanning.    */
DECL|field|ref
specifier|private
specifier|final
name|FsVolumeReference
name|ref
decl_stmt|;
comment|/**    * The volume that we're scanning.    */
DECL|field|volume
specifier|final
name|FsVolumeSpi
name|volume
decl_stmt|;
comment|/**    * The number of scanned bytes in each minute of the last hour.<p/>    *    * This array is managed as a circular buffer.  We take the monotonic time and    * divide it up into one-minute periods.  Each entry in the array represents    * how many bytes were scanned during that period.    */
DECL|field|scannedBytes
specifier|private
specifier|final
name|long
name|scannedBytes
index|[]
init|=
operator|new
name|long
index|[
name|MINUTES_PER_HOUR
index|]
decl_stmt|;
comment|/**    * The sum of all the values of scannedBytes.    */
DECL|field|scannedBytesSum
specifier|private
name|long
name|scannedBytesSum
init|=
literal|0
decl_stmt|;
comment|/**    * The throttler to use with BlockSender objects.    */
DECL|field|throttler
specifier|private
specifier|final
name|DataTransferThrottler
name|throttler
init|=
operator|new
name|DataTransferThrottler
argument_list|(
literal|1
argument_list|)
decl_stmt|;
comment|/**    * The null output stream to use with BlockSender objects.    */
DECL|field|nullStream
specifier|private
specifier|final
name|DataOutputStream
name|nullStream
init|=
operator|new
name|DataOutputStream
argument_list|(
operator|new
name|IOUtils
operator|.
name|NullOutputStream
argument_list|()
argument_list|)
decl_stmt|;
comment|/**    * The block iterators associated with this VolumeScanner.<p/>    *    * Each block pool has its own BlockIterator.    */
DECL|field|blockIters
specifier|private
specifier|final
name|List
argument_list|<
name|BlockIterator
argument_list|>
name|blockIters
init|=
operator|new
name|LinkedList
argument_list|<
name|BlockIterator
argument_list|>
argument_list|()
decl_stmt|;
comment|/**    * Blocks which are suspect.    * The scanner prioritizes scanning these blocks.    */
DECL|field|suspectBlocks
specifier|private
specifier|final
name|LinkedHashSet
argument_list|<
name|ExtendedBlock
argument_list|>
name|suspectBlocks
init|=
operator|new
name|LinkedHashSet
argument_list|<
name|ExtendedBlock
argument_list|>
argument_list|()
decl_stmt|;
comment|/**    * Blocks which were suspect which we have scanned.    * This is used to avoid scanning the same suspect block over and over.    */
DECL|field|recentSuspectBlocks
specifier|private
specifier|final
name|Cache
argument_list|<
name|ExtendedBlock
argument_list|,
name|Boolean
argument_list|>
name|recentSuspectBlocks
init|=
name|CacheBuilder
operator|.
name|newBuilder
argument_list|()
operator|.
name|maximumSize
argument_list|(
literal|1000
argument_list|)
operator|.
name|expireAfterAccess
argument_list|(
literal|10
argument_list|,
name|TimeUnit
operator|.
name|MINUTES
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
comment|/**    * The current block iterator, or null if there is none.    */
DECL|field|curBlockIter
specifier|private
name|BlockIterator
name|curBlockIter
init|=
literal|null
decl_stmt|;
comment|/**    * True if the thread is stopping.<p/>    * Protected by this object's lock.    */
DECL|field|stopping
specifier|private
name|boolean
name|stopping
init|=
literal|false
decl_stmt|;
comment|/**    * The monotonic minute that the volume scanner was started on.    */
DECL|field|startMinute
specifier|private
name|long
name|startMinute
init|=
literal|0
decl_stmt|;
comment|/**    * The current minute, in monotonic terms.    */
DECL|field|curMinute
specifier|private
name|long
name|curMinute
init|=
literal|0
decl_stmt|;
comment|/**    * Handles scan results.    */
DECL|field|resultHandler
specifier|private
specifier|final
name|ScanResultHandler
name|resultHandler
decl_stmt|;
DECL|field|stats
specifier|private
specifier|final
name|Statistics
name|stats
init|=
operator|new
name|Statistics
argument_list|()
decl_stmt|;
DECL|class|Statistics
specifier|static
class|class
name|Statistics
block|{
DECL|field|bytesScannedInPastHour
name|long
name|bytesScannedInPastHour
init|=
literal|0
decl_stmt|;
DECL|field|blocksScannedInCurrentPeriod
name|long
name|blocksScannedInCurrentPeriod
init|=
literal|0
decl_stmt|;
DECL|field|blocksScannedSinceRestart
name|long
name|blocksScannedSinceRestart
init|=
literal|0
decl_stmt|;
DECL|field|scansSinceRestart
name|long
name|scansSinceRestart
init|=
literal|0
decl_stmt|;
DECL|field|scanErrorsSinceRestart
name|long
name|scanErrorsSinceRestart
init|=
literal|0
decl_stmt|;
DECL|field|nextBlockPoolScanStartMs
name|long
name|nextBlockPoolScanStartMs
init|=
operator|-
literal|1
decl_stmt|;
DECL|field|blockPoolPeriodEndsMs
name|long
name|blockPoolPeriodEndsMs
init|=
operator|-
literal|1
decl_stmt|;
DECL|field|lastBlockScanned
name|ExtendedBlock
name|lastBlockScanned
init|=
literal|null
decl_stmt|;
DECL|field|eof
name|boolean
name|eof
init|=
literal|false
decl_stmt|;
DECL|method|Statistics ()
name|Statistics
parameter_list|()
block|{     }
DECL|method|Statistics (Statistics other)
name|Statistics
parameter_list|(
name|Statistics
name|other
parameter_list|)
block|{
name|this
operator|.
name|bytesScannedInPastHour
operator|=
name|other
operator|.
name|bytesScannedInPastHour
expr_stmt|;
name|this
operator|.
name|blocksScannedInCurrentPeriod
operator|=
name|other
operator|.
name|blocksScannedInCurrentPeriod
expr_stmt|;
name|this
operator|.
name|blocksScannedSinceRestart
operator|=
name|other
operator|.
name|blocksScannedSinceRestart
expr_stmt|;
name|this
operator|.
name|scansSinceRestart
operator|=
name|other
operator|.
name|scansSinceRestart
expr_stmt|;
name|this
operator|.
name|scanErrorsSinceRestart
operator|=
name|other
operator|.
name|scanErrorsSinceRestart
expr_stmt|;
name|this
operator|.
name|nextBlockPoolScanStartMs
operator|=
name|other
operator|.
name|nextBlockPoolScanStartMs
expr_stmt|;
name|this
operator|.
name|blockPoolPeriodEndsMs
operator|=
name|other
operator|.
name|blockPoolPeriodEndsMs
expr_stmt|;
name|this
operator|.
name|lastBlockScanned
operator|=
name|other
operator|.
name|lastBlockScanned
expr_stmt|;
name|this
operator|.
name|eof
operator|=
name|other
operator|.
name|eof
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
operator|new
name|StringBuilder
argument_list|()
operator|.
name|append
argument_list|(
literal|"Statistics{"
argument_list|)
operator|.
name|append
argument_list|(
literal|"bytesScannedInPastHour="
argument_list|)
operator|.
name|append
argument_list|(
name|bytesScannedInPastHour
argument_list|)
operator|.
name|append
argument_list|(
literal|", blocksScannedInCurrentPeriod="
argument_list|)
operator|.
name|append
argument_list|(
name|blocksScannedInCurrentPeriod
argument_list|)
operator|.
name|append
argument_list|(
literal|", blocksScannedSinceRestart="
argument_list|)
operator|.
name|append
argument_list|(
name|blocksScannedSinceRestart
argument_list|)
operator|.
name|append
argument_list|(
literal|", scansSinceRestart="
argument_list|)
operator|.
name|append
argument_list|(
name|scansSinceRestart
argument_list|)
operator|.
name|append
argument_list|(
literal|", scanErrorsSinceRestart="
argument_list|)
operator|.
name|append
argument_list|(
name|scanErrorsSinceRestart
argument_list|)
operator|.
name|append
argument_list|(
literal|", nextBlockPoolScanStartMs="
argument_list|)
operator|.
name|append
argument_list|(
name|nextBlockPoolScanStartMs
argument_list|)
operator|.
name|append
argument_list|(
literal|", blockPoolPeriodEndsMs="
argument_list|)
operator|.
name|append
argument_list|(
name|blockPoolPeriodEndsMs
argument_list|)
operator|.
name|append
argument_list|(
literal|", lastBlockScanned="
argument_list|)
operator|.
name|append
argument_list|(
name|lastBlockScanned
argument_list|)
operator|.
name|append
argument_list|(
literal|", eof="
argument_list|)
operator|.
name|append
argument_list|(
name|eof
argument_list|)
operator|.
name|append
argument_list|(
literal|"}"
argument_list|)
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
DECL|method|positiveMsToHours (long ms)
specifier|private
specifier|static
name|double
name|positiveMsToHours
parameter_list|(
name|long
name|ms
parameter_list|)
block|{
if|if
condition|(
name|ms
operator|<=
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
else|else
block|{
return|return
name|TimeUnit
operator|.
name|HOURS
operator|.
name|convert
argument_list|(
name|ms
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
return|;
block|}
block|}
DECL|method|printStats (StringBuilder p)
specifier|public
name|void
name|printStats
parameter_list|(
name|StringBuilder
name|p
parameter_list|)
block|{
name|p
operator|.
name|append
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Block scanner information for volume %s with base"
operator|+
literal|" path %s%n"
argument_list|,
name|volume
operator|.
name|getStorageID
argument_list|()
argument_list|,
name|volume
argument_list|)
argument_list|)
expr_stmt|;
synchronized|synchronized
init|(
name|stats
init|)
block|{
name|p
operator|.
name|append
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Bytes verified in last hour       : %57d%n"
argument_list|,
name|stats
operator|.
name|bytesScannedInPastHour
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|.
name|append
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Blocks scanned in current period  : %57d%n"
argument_list|,
name|stats
operator|.
name|blocksScannedInCurrentPeriod
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|.
name|append
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Blocks scanned since restart      : %57d%n"
argument_list|,
name|stats
operator|.
name|blocksScannedSinceRestart
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|.
name|append
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Block pool scans since restart    : %57d%n"
argument_list|,
name|stats
operator|.
name|scansSinceRestart
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|.
name|append
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Block scan errors since restart   : %57d%n"
argument_list|,
name|stats
operator|.
name|scanErrorsSinceRestart
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|stats
operator|.
name|nextBlockPoolScanStartMs
operator|>
literal|0
condition|)
block|{
name|p
operator|.
name|append
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Hours until next block pool scan  : %57.3f%n"
argument_list|,
name|positiveMsToHours
argument_list|(
name|stats
operator|.
name|nextBlockPoolScanStartMs
operator|-
name|Time
operator|.
name|monotonicNow
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stats
operator|.
name|blockPoolPeriodEndsMs
operator|>
literal|0
condition|)
block|{
name|p
operator|.
name|append
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Hours until possible pool rescan  : %57.3f%n"
argument_list|,
name|positiveMsToHours
argument_list|(
name|stats
operator|.
name|blockPoolPeriodEndsMs
operator|-
name|Time
operator|.
name|now
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|p
operator|.
name|append
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Last block scanned                : %57s%n"
argument_list|,
operator|(
operator|(
name|stats
operator|.
name|lastBlockScanned
operator|==
literal|null
operator|)
condition|?
literal|"none"
else|:
name|stats
operator|.
name|lastBlockScanned
operator|.
name|toString
argument_list|()
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|.
name|append
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"More blocks to scan in period     : %57s%n"
argument_list|,
operator|!
name|stats
operator|.
name|eof
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|.
name|append
argument_list|(
name|System
operator|.
name|lineSeparator
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|class|ScanResultHandler
specifier|static
class|class
name|ScanResultHandler
block|{
DECL|field|scanner
specifier|private
name|VolumeScanner
name|scanner
decl_stmt|;
DECL|method|setup (VolumeScanner scanner)
specifier|public
name|void
name|setup
parameter_list|(
name|VolumeScanner
name|scanner
parameter_list|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Starting VolumeScanner {}"
argument_list|,
name|scanner
operator|.
name|volume
argument_list|)
expr_stmt|;
name|this
operator|.
name|scanner
operator|=
name|scanner
expr_stmt|;
block|}
DECL|method|handle (ExtendedBlock block, IOException e)
specifier|public
name|void
name|handle
parameter_list|(
name|ExtendedBlock
name|block
parameter_list|,
name|IOException
name|e
parameter_list|)
block|{
name|FsVolumeSpi
name|volume
init|=
name|scanner
operator|.
name|volume
decl_stmt|;
if|if
condition|(
name|e
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Successfully scanned {} on {}"
argument_list|,
name|block
argument_list|,
name|volume
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// If the block does not exist anymore, then it's not an error.
if|if
condition|(
operator|!
name|volume
operator|.
name|getDataset
argument_list|()
operator|.
name|contains
argument_list|(
name|block
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Volume {}: block {} is no longer in the dataset."
argument_list|,
name|volume
argument_list|,
name|block
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// If the block exists, the exception may due to a race with write:
comment|// The BlockSender got an old block path in rbw. BlockReceiver removed
comment|// the rbw block from rbw to finalized but BlockSender tried to open the
comment|// file before BlockReceiver updated the VolumeMap. The state of the
comment|// block can be changed again now, so ignore this error here. If there
comment|// is a block really deleted by mistake, DirectoryScan should catch it.
if|if
condition|(
name|e
operator|instanceof
name|FileNotFoundException
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Volume {}: verification failed for {} because of "
operator|+
literal|"FileNotFoundException.  This may be due to a race with write."
argument_list|,
name|volume
argument_list|,
name|block
argument_list|)
expr_stmt|;
return|return;
block|}
name|LOG
operator|.
name|warn
argument_list|(
literal|"Reporting bad {} on {}"
argument_list|,
name|block
argument_list|,
name|volume
argument_list|)
expr_stmt|;
try|try
block|{
name|scanner
operator|.
name|datanode
operator|.
name|reportBadBlocks
argument_list|(
name|block
argument_list|,
name|volume
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ie
parameter_list|)
block|{
comment|// This is bad, but not bad enough to shut down the scanner.
name|LOG
operator|.
name|warn
argument_list|(
literal|"Cannot report bad block "
operator|+
name|block
argument_list|,
name|ie
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|VolumeScanner (Conf conf, DataNode datanode, FsVolumeReference ref)
name|VolumeScanner
parameter_list|(
name|Conf
name|conf
parameter_list|,
name|DataNode
name|datanode
parameter_list|,
name|FsVolumeReference
name|ref
parameter_list|)
block|{
name|this
operator|.
name|conf
operator|=
name|conf
expr_stmt|;
name|this
operator|.
name|datanode
operator|=
name|datanode
expr_stmt|;
name|this
operator|.
name|ref
operator|=
name|ref
expr_stmt|;
name|this
operator|.
name|volume
operator|=
name|ref
operator|.
name|getVolume
argument_list|()
expr_stmt|;
name|ScanResultHandler
name|handler
decl_stmt|;
try|try
block|{
name|handler
operator|=
name|conf
operator|.
name|resultHandler
operator|.
name|newInstance
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"unable to instantiate {}"
argument_list|,
name|conf
operator|.
name|resultHandler
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|handler
operator|=
operator|new
name|ScanResultHandler
argument_list|()
expr_stmt|;
block|}
name|this
operator|.
name|resultHandler
operator|=
name|handler
expr_stmt|;
name|setName
argument_list|(
literal|"VolumeScannerThread("
operator|+
name|volume
operator|+
literal|")"
argument_list|)
expr_stmt|;
name|setDaemon
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
DECL|method|saveBlockIterator (BlockIterator iter)
specifier|private
name|void
name|saveBlockIterator
parameter_list|(
name|BlockIterator
name|iter
parameter_list|)
block|{
try|try
block|{
name|iter
operator|.
name|save
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"{}: error saving {}."
argument_list|,
name|this
argument_list|,
name|iter
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|expireOldScannedBytesRecords (long monotonicMs)
specifier|private
name|void
name|expireOldScannedBytesRecords
parameter_list|(
name|long
name|monotonicMs
parameter_list|)
block|{
name|long
name|newMinute
init|=
name|TimeUnit
operator|.
name|MINUTES
operator|.
name|convert
argument_list|(
name|monotonicMs
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
decl_stmt|;
if|if
condition|(
name|curMinute
operator|==
name|newMinute
condition|)
block|{
return|return;
block|}
comment|// If a minute or more has gone past since we last updated the scannedBytes
comment|// array, zero out the slots corresponding to those minutes.
for|for
control|(
name|long
name|m
init|=
name|curMinute
operator|+
literal|1
init|;
name|m
operator|<=
name|newMinute
condition|;
name|m
operator|++
control|)
block|{
name|int
name|slotIdx
init|=
call|(
name|int
call|)
argument_list|(
name|m
operator|%
name|MINUTES_PER_HOUR
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|trace
argument_list|(
literal|"{}: updateScannedBytes is zeroing out slotIdx {}.  "
operator|+
literal|"curMinute = {}; newMinute = {}"
argument_list|,
name|this
argument_list|,
name|slotIdx
argument_list|,
name|curMinute
argument_list|,
name|newMinute
argument_list|)
expr_stmt|;
name|scannedBytesSum
operator|-=
name|scannedBytes
index|[
name|slotIdx
index|]
expr_stmt|;
name|scannedBytes
index|[
name|slotIdx
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|curMinute
operator|=
name|newMinute
expr_stmt|;
block|}
comment|/**    * Find a usable block iterator.<p/>    *    * We will consider available block iterators in order.  This property is    * important so that we don't keep rescanning the same block pool id over    * and over, while other block pools stay unscanned.<p/>    *    * A block pool is always ready to scan if the iterator is not at EOF.  If    * the iterator is at EOF, the block pool will be ready to scan when    * conf.scanPeriodMs milliseconds have elapsed since the iterator was last    * rewound.<p/>    *    * @return                     0 if we found a usable block iterator; the    *                               length of time we should delay before    *                               checking again otherwise.    */
DECL|method|findNextUsableBlockIter ()
specifier|private
specifier|synchronized
name|long
name|findNextUsableBlockIter
parameter_list|()
block|{
name|int
name|numBlockIters
init|=
name|blockIters
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|numBlockIters
operator|==
literal|0
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"{}: no block pools are registered."
argument_list|,
name|this
argument_list|)
expr_stmt|;
return|return
name|Long
operator|.
name|MAX_VALUE
return|;
block|}
name|int
name|curIdx
decl_stmt|;
if|if
condition|(
name|curBlockIter
operator|==
literal|null
condition|)
block|{
name|curIdx
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|curIdx
operator|=
name|blockIters
operator|.
name|indexOf
argument_list|(
name|curBlockIter
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkState
argument_list|(
name|curIdx
operator|>=
literal|0
argument_list|)
expr_stmt|;
block|}
comment|// Note that this has to be wall-clock time, not monotonic time.  This is
comment|// because the time saved in the cursor file is a wall-clock time.  We do
comment|// not want to save a monotonic time in the cursor file, because it resets
comment|// every time the machine reboots (on most platforms).
name|long
name|nowMs
init|=
name|Time
operator|.
name|now
argument_list|()
decl_stmt|;
name|long
name|minTimeoutMs
init|=
name|Long
operator|.
name|MAX_VALUE
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numBlockIters
condition|;
name|i
operator|++
control|)
block|{
name|int
name|idx
init|=
operator|(
name|curIdx
operator|+
name|i
operator|+
literal|1
operator|)
operator|%
name|numBlockIters
decl_stmt|;
name|BlockIterator
name|iter
init|=
name|blockIters
operator|.
name|get
argument_list|(
name|idx
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|iter
operator|.
name|atEnd
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Now scanning bpid {} on volume {}"
argument_list|,
name|iter
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|volume
argument_list|)
expr_stmt|;
name|curBlockIter
operator|=
name|iter
expr_stmt|;
return|return
literal|0L
return|;
block|}
name|long
name|iterStartMs
init|=
name|iter
operator|.
name|getIterStartMs
argument_list|()
decl_stmt|;
name|long
name|waitMs
init|=
operator|(
name|iterStartMs
operator|+
name|conf
operator|.
name|scanPeriodMs
operator|)
operator|-
name|nowMs
decl_stmt|;
if|if
condition|(
name|waitMs
operator|<=
literal|0
condition|)
block|{
name|iter
operator|.
name|rewind
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Now rescanning bpid {} on volume {}, after more than "
operator|+
literal|"{} hour(s)"
argument_list|,
name|iter
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|volume
argument_list|,
name|TimeUnit
operator|.
name|HOURS
operator|.
name|convert
argument_list|(
name|conf
operator|.
name|scanPeriodMs
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
argument_list|)
expr_stmt|;
name|curBlockIter
operator|=
name|iter
expr_stmt|;
return|return
literal|0L
return|;
block|}
name|minTimeoutMs
operator|=
name|Math
operator|.
name|min
argument_list|(
name|minTimeoutMs
argument_list|,
name|waitMs
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"{}: no suitable block pools found to scan.  Waiting {} ms."
argument_list|,
name|this
argument_list|,
name|minTimeoutMs
argument_list|)
expr_stmt|;
return|return
name|minTimeoutMs
return|;
block|}
comment|/**    * Scan a block.    *    * @param cblock               The block to scan.    * @param bytesPerSec          The bytes per second to scan at.    *    * @return                     The length of the block that was scanned, or    *                               -1 if the block could not be scanned.    */
DECL|method|scanBlock (ExtendedBlock cblock, long bytesPerSec)
specifier|private
name|long
name|scanBlock
parameter_list|(
name|ExtendedBlock
name|cblock
parameter_list|,
name|long
name|bytesPerSec
parameter_list|)
block|{
comment|// 'cblock' has a valid blockId and block pool id, but we don't yet know the
comment|// genstamp the block is supposed to have.  Ask the FsDatasetImpl for this
comment|// information.
name|ExtendedBlock
name|block
init|=
literal|null
decl_stmt|;
try|try
block|{
name|Block
name|b
init|=
name|volume
operator|.
name|getDataset
argument_list|()
operator|.
name|getStoredBlock
argument_list|(
name|cblock
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|cblock
operator|.
name|getBlockId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|b
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Replica {} was not found in the VolumeMap for volume {}"
argument_list|,
name|cblock
argument_list|,
name|volume
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|block
operator|=
operator|new
name|ExtendedBlock
argument_list|(
name|cblock
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|b
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"FileNotFoundException while finding block {} on volume {}"
argument_list|,
name|cblock
argument_list|,
name|volume
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"I/O error while finding block {} on volume {}"
argument_list|,
name|cblock
argument_list|,
name|volume
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|block
operator|==
literal|null
condition|)
block|{
return|return
operator|-
literal|1
return|;
comment|// block not found.
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"start scanning block {}"
argument_list|,
name|block
argument_list|)
expr_stmt|;
name|BlockSender
name|blockSender
init|=
literal|null
decl_stmt|;
try|try
block|{
name|blockSender
operator|=
operator|new
name|BlockSender
argument_list|(
name|block
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|,
name|datanode
argument_list|,
literal|null
argument_list|,
name|CachingStrategy
operator|.
name|newDropBehind
argument_list|()
argument_list|)
expr_stmt|;
name|throttler
operator|.
name|setBandwidth
argument_list|(
name|bytesPerSec
argument_list|)
expr_stmt|;
name|long
name|bytesRead
init|=
name|blockSender
operator|.
name|sendBlock
argument_list|(
name|nullStream
argument_list|,
literal|null
argument_list|,
name|throttler
argument_list|)
decl_stmt|;
name|resultHandler
operator|.
name|handle
argument_list|(
name|block
argument_list|,
literal|null
argument_list|)
expr_stmt|;
return|return
name|bytesRead
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|resultHandler
operator|.
name|handle
argument_list|(
name|block
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|IOUtils
operator|.
name|cleanup
argument_list|(
literal|null
argument_list|,
name|blockSender
argument_list|)
expr_stmt|;
block|}
return|return
operator|-
literal|1
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|calculateShouldScan (String storageId, long targetBytesPerSec, long scannedBytesSum, long startMinute, long curMinute)
specifier|static
name|boolean
name|calculateShouldScan
parameter_list|(
name|String
name|storageId
parameter_list|,
name|long
name|targetBytesPerSec
parameter_list|,
name|long
name|scannedBytesSum
parameter_list|,
name|long
name|startMinute
parameter_list|,
name|long
name|curMinute
parameter_list|)
block|{
name|long
name|runMinutes
init|=
name|curMinute
operator|-
name|startMinute
decl_stmt|;
name|long
name|effectiveBytesPerSec
decl_stmt|;
if|if
condition|(
name|runMinutes
operator|<=
literal|0
condition|)
block|{
comment|// avoid division by zero
name|effectiveBytesPerSec
operator|=
name|scannedBytesSum
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|runMinutes
operator|>
name|MINUTES_PER_HOUR
condition|)
block|{
comment|// we only keep an hour's worth of rate information
name|runMinutes
operator|=
name|MINUTES_PER_HOUR
expr_stmt|;
block|}
name|effectiveBytesPerSec
operator|=
name|scannedBytesSum
operator|/
operator|(
name|SECONDS_PER_MINUTE
operator|*
name|runMinutes
operator|)
expr_stmt|;
block|}
name|boolean
name|shouldScan
init|=
name|effectiveBytesPerSec
operator|<=
name|targetBytesPerSec
decl_stmt|;
name|LOG
operator|.
name|trace
argument_list|(
literal|"{}: calculateShouldScan: effectiveBytesPerSec = {}, and "
operator|+
literal|"targetBytesPerSec = {}.  startMinute = {}, curMinute = {}, "
operator|+
literal|"shouldScan = {}"
argument_list|,
name|storageId
argument_list|,
name|effectiveBytesPerSec
argument_list|,
name|targetBytesPerSec
argument_list|,
name|startMinute
argument_list|,
name|curMinute
argument_list|,
name|shouldScan
argument_list|)
expr_stmt|;
return|return
name|shouldScan
return|;
block|}
comment|/**    * Run an iteration of the VolumeScanner loop.    *    * @param suspectBlock   A suspect block which we should scan, or null to    *                       scan the next regularly scheduled block.    *    * @return     The number of milliseconds to delay before running the loop    *               again, or 0 to re-run the loop immediately.    */
DECL|method|runLoop (ExtendedBlock suspectBlock)
specifier|private
name|long
name|runLoop
parameter_list|(
name|ExtendedBlock
name|suspectBlock
parameter_list|)
block|{
name|long
name|bytesScanned
init|=
operator|-
literal|1
decl_stmt|;
name|boolean
name|scanError
init|=
literal|false
decl_stmt|;
name|ExtendedBlock
name|block
init|=
literal|null
decl_stmt|;
try|try
block|{
name|long
name|monotonicMs
init|=
name|Time
operator|.
name|monotonicNow
argument_list|()
decl_stmt|;
name|expireOldScannedBytesRecords
argument_list|(
name|monotonicMs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|calculateShouldScan
argument_list|(
name|volume
operator|.
name|getStorageID
argument_list|()
argument_list|,
name|conf
operator|.
name|targetBytesPerSec
argument_list|,
name|scannedBytesSum
argument_list|,
name|startMinute
argument_list|,
name|curMinute
argument_list|)
condition|)
block|{
comment|// If neededBytesPerSec is too low, then wait few seconds for some old
comment|// scannedBytes records to expire.
return|return
literal|30000L
return|;
block|}
comment|// Find a usable block pool to scan.
if|if
condition|(
name|suspectBlock
operator|!=
literal|null
condition|)
block|{
name|block
operator|=
name|suspectBlock
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|curBlockIter
operator|==
literal|null
operator|)
operator|||
name|curBlockIter
operator|.
name|atEnd
argument_list|()
condition|)
block|{
name|long
name|timeout
init|=
name|findNextUsableBlockIter
argument_list|()
decl_stmt|;
if|if
condition|(
name|timeout
operator|>
literal|0
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"{}: no block pools are ready to scan yet.  Waiting "
operator|+
literal|"{} ms."
argument_list|,
name|this
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
synchronized|synchronized
init|(
name|stats
init|)
block|{
name|stats
operator|.
name|nextBlockPoolScanStartMs
operator|=
name|Time
operator|.
name|monotonicNow
argument_list|()
operator|+
name|timeout
expr_stmt|;
block|}
return|return
name|timeout
return|;
block|}
synchronized|synchronized
init|(
name|stats
init|)
block|{
name|stats
operator|.
name|scansSinceRestart
operator|++
expr_stmt|;
name|stats
operator|.
name|blocksScannedInCurrentPeriod
operator|=
literal|0
expr_stmt|;
name|stats
operator|.
name|nextBlockPoolScanStartMs
operator|=
operator|-
literal|1
expr_stmt|;
block|}
return|return
literal|0L
return|;
block|}
try|try
block|{
name|block
operator|=
name|curBlockIter
operator|.
name|nextBlock
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// There was an error listing the next block in the volume.  This is a
comment|// serious issue.
name|LOG
operator|.
name|warn
argument_list|(
literal|"{}: nextBlock error on {}"
argument_list|,
name|this
argument_list|,
name|curBlockIter
argument_list|)
expr_stmt|;
comment|// On the next loop iteration, curBlockIter#eof will be set to true, and
comment|// we will pick a different block iterator.
return|return
literal|0L
return|;
block|}
if|if
condition|(
name|block
operator|==
literal|null
condition|)
block|{
comment|// The BlockIterator is at EOF.
name|LOG
operator|.
name|info
argument_list|(
literal|"{}: finished scanning block pool {}"
argument_list|,
name|this
argument_list|,
name|curBlockIter
operator|.
name|getBlockPoolId
argument_list|()
argument_list|)
expr_stmt|;
name|saveBlockIterator
argument_list|(
name|curBlockIter
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
if|if
condition|(
name|curBlockIter
operator|!=
literal|null
condition|)
block|{
name|long
name|saveDelta
init|=
name|monotonicMs
operator|-
name|curBlockIter
operator|.
name|getLastSavedMs
argument_list|()
decl_stmt|;
if|if
condition|(
name|saveDelta
operator|>=
name|conf
operator|.
name|cursorSaveMs
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"{}: saving block iterator {} after {} ms."
argument_list|,
name|this
argument_list|,
name|curBlockIter
argument_list|,
name|saveDelta
argument_list|)
expr_stmt|;
name|saveBlockIterator
argument_list|(
name|curBlockIter
argument_list|)
expr_stmt|;
block|}
block|}
name|bytesScanned
operator|=
name|scanBlock
argument_list|(
name|block
argument_list|,
name|conf
operator|.
name|targetBytesPerSec
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytesScanned
operator|>=
literal|0
condition|)
block|{
name|scannedBytesSum
operator|+=
name|bytesScanned
expr_stmt|;
name|scannedBytes
index|[
call|(
name|int
call|)
argument_list|(
name|curMinute
operator|%
name|MINUTES_PER_HOUR
argument_list|)
index|]
operator|+=
name|bytesScanned
expr_stmt|;
block|}
else|else
block|{
name|scanError
operator|=
literal|true
expr_stmt|;
block|}
return|return
literal|0L
return|;
block|}
finally|finally
block|{
synchronized|synchronized
init|(
name|stats
init|)
block|{
name|stats
operator|.
name|bytesScannedInPastHour
operator|=
name|scannedBytesSum
expr_stmt|;
if|if
condition|(
name|bytesScanned
operator|>
literal|0
condition|)
block|{
name|stats
operator|.
name|blocksScannedInCurrentPeriod
operator|++
expr_stmt|;
name|stats
operator|.
name|blocksScannedSinceRestart
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|scanError
condition|)
block|{
name|stats
operator|.
name|scanErrorsSinceRestart
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|block
operator|!=
literal|null
condition|)
block|{
name|stats
operator|.
name|lastBlockScanned
operator|=
name|block
expr_stmt|;
block|}
if|if
condition|(
name|curBlockIter
operator|==
literal|null
condition|)
block|{
name|stats
operator|.
name|eof
operator|=
literal|true
expr_stmt|;
name|stats
operator|.
name|blockPoolPeriodEndsMs
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|stats
operator|.
name|eof
operator|=
name|curBlockIter
operator|.
name|atEnd
argument_list|()
expr_stmt|;
name|stats
operator|.
name|blockPoolPeriodEndsMs
operator|=
name|curBlockIter
operator|.
name|getIterStartMs
argument_list|()
operator|+
name|conf
operator|.
name|scanPeriodMs
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**    * If there are elements in the suspectBlocks list, removes    * and returns the first one.  Otherwise, returns null.    */
DECL|method|popNextSuspectBlock ()
specifier|private
specifier|synchronized
name|ExtendedBlock
name|popNextSuspectBlock
parameter_list|()
block|{
name|Iterator
argument_list|<
name|ExtendedBlock
argument_list|>
name|iter
init|=
name|suspectBlocks
operator|.
name|iterator
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|iter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
name|ExtendedBlock
name|block
init|=
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
name|iter
operator|.
name|remove
argument_list|()
expr_stmt|;
return|return
name|block
return|;
block|}
annotation|@
name|Override
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
comment|// Record the minute on which the scanner started.
name|this
operator|.
name|startMinute
operator|=
name|TimeUnit
operator|.
name|MINUTES
operator|.
name|convert
argument_list|(
name|Time
operator|.
name|monotonicNow
argument_list|()
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
expr_stmt|;
name|this
operator|.
name|curMinute
operator|=
name|startMinute
expr_stmt|;
try|try
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"{}: thread starting."
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|resultHandler
operator|.
name|setup
argument_list|(
name|this
argument_list|)
expr_stmt|;
try|try
block|{
name|long
name|timeout
init|=
literal|0
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|ExtendedBlock
name|suspectBlock
init|=
literal|null
decl_stmt|;
comment|// Take the lock to check if we should stop, and access the
comment|// suspect block list.
synchronized|synchronized
init|(
name|this
init|)
block|{
if|if
condition|(
name|stopping
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|timeout
operator|>
literal|0
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"{}: wait for {} milliseconds"
argument_list|,
name|this
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
name|wait
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|stopping
condition|)
block|{
break|break;
block|}
block|}
name|suspectBlock
operator|=
name|popNextSuspectBlock
argument_list|()
expr_stmt|;
block|}
name|timeout
operator|=
name|runLoop
argument_list|(
name|suspectBlock
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
comment|// We are exiting because of an InterruptedException,
comment|// probably sent by VolumeScanner#shutdown.
name|LOG
operator|.
name|trace
argument_list|(
literal|"{} exiting because of InterruptedException."
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"{} exiting because of exception "
argument_list|,
name|this
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"{} exiting."
argument_list|,
name|this
argument_list|)
expr_stmt|;
comment|// Save the current position of all block iterators and close them.
for|for
control|(
name|BlockIterator
name|iter
range|:
name|blockIters
control|)
block|{
name|saveBlockIterator
argument_list|(
name|iter
argument_list|)
expr_stmt|;
name|IOUtils
operator|.
name|cleanup
argument_list|(
literal|null
argument_list|,
name|iter
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
comment|// When the VolumeScanner exits, release the reference we were holding
comment|// on the volume.  This will allow the volume to be removed later.
name|IOUtils
operator|.
name|cleanup
argument_list|(
literal|null
argument_list|,
name|ref
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"VolumeScanner("
operator|+
name|volume
operator|+
literal|", "
operator|+
name|volume
operator|.
name|getStorageID
argument_list|()
operator|+
literal|")"
return|;
block|}
comment|/**    * Shut down this scanner.    */
DECL|method|shutdown ()
specifier|public
specifier|synchronized
name|void
name|shutdown
parameter_list|()
block|{
name|stopping
operator|=
literal|true
expr_stmt|;
name|notify
argument_list|()
expr_stmt|;
name|this
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
DECL|method|markSuspectBlock (ExtendedBlock block)
specifier|public
specifier|synchronized
name|void
name|markSuspectBlock
parameter_list|(
name|ExtendedBlock
name|block
parameter_list|)
block|{
if|if
condition|(
name|stopping
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"{}: Not scheduling suspect block {} for "
operator|+
literal|"rescanning, because this volume scanner is stopping."
argument_list|,
name|this
argument_list|,
name|block
argument_list|)
expr_stmt|;
return|return;
block|}
name|Boolean
name|recent
init|=
name|recentSuspectBlocks
operator|.
name|getIfPresent
argument_list|(
name|block
argument_list|)
decl_stmt|;
if|if
condition|(
name|recent
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"{}: Not scheduling suspect block {} for "
operator|+
literal|"rescanning, because we rescanned it recently."
argument_list|,
name|this
argument_list|,
name|block
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|suspectBlocks
operator|.
name|contains
argument_list|(
name|block
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"{}: suspect block {} is already queued for "
operator|+
literal|"rescanning."
argument_list|,
name|this
argument_list|,
name|block
argument_list|)
expr_stmt|;
return|return;
block|}
name|suspectBlocks
operator|.
name|add
argument_list|(
name|block
argument_list|)
expr_stmt|;
name|recentSuspectBlocks
operator|.
name|put
argument_list|(
name|block
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"{}: Scheduling suspect block {} for rescanning."
argument_list|,
name|this
argument_list|,
name|block
argument_list|)
expr_stmt|;
name|notify
argument_list|()
expr_stmt|;
comment|// wake scanner thread.
block|}
comment|/**    * Allow the scanner to scan the given block pool.    *    * @param bpid       The block pool id.    */
DECL|method|enableBlockPoolId (String bpid)
specifier|public
specifier|synchronized
name|void
name|enableBlockPoolId
parameter_list|(
name|String
name|bpid
parameter_list|)
block|{
for|for
control|(
name|BlockIterator
name|iter
range|:
name|blockIters
control|)
block|{
if|if
condition|(
name|iter
operator|.
name|getBlockPoolId
argument_list|()
operator|.
name|equals
argument_list|(
name|bpid
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"{}: already enabled scanning on block pool {}"
argument_list|,
name|this
argument_list|,
name|bpid
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|BlockIterator
name|iter
init|=
literal|null
decl_stmt|;
try|try
block|{
comment|// Load a block iterator for the next block pool on the volume.
name|iter
operator|=
name|volume
operator|.
name|loadBlockIterator
argument_list|(
name|bpid
argument_list|,
name|BLOCK_ITERATOR_NAME
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|trace
argument_list|(
literal|"{}: loaded block iterator for {}."
argument_list|,
name|this
argument_list|,
name|bpid
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"{}: failed to load block iterator: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"{}: failed to load block iterator."
argument_list|,
name|this
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|iter
operator|==
literal|null
condition|)
block|{
name|iter
operator|=
name|volume
operator|.
name|newBlockIterator
argument_list|(
name|bpid
argument_list|,
name|BLOCK_ITERATOR_NAME
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|trace
argument_list|(
literal|"{}: created new block iterator for {}."
argument_list|,
name|this
argument_list|,
name|bpid
argument_list|)
expr_stmt|;
block|}
name|iter
operator|.
name|setMaxStalenessMs
argument_list|(
name|conf
operator|.
name|maxStalenessMs
argument_list|)
expr_stmt|;
name|blockIters
operator|.
name|add
argument_list|(
name|iter
argument_list|)
expr_stmt|;
name|notify
argument_list|()
expr_stmt|;
block|}
comment|/**    * Disallow the scanner from scanning the given block pool.    *    * @param bpid       The block pool id.    */
DECL|method|disableBlockPoolId (String bpid)
specifier|public
specifier|synchronized
name|void
name|disableBlockPoolId
parameter_list|(
name|String
name|bpid
parameter_list|)
block|{
name|Iterator
argument_list|<
name|BlockIterator
argument_list|>
name|i
init|=
name|blockIters
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|i
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|BlockIterator
name|iter
init|=
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|iter
operator|.
name|getBlockPoolId
argument_list|()
operator|.
name|equals
argument_list|(
name|bpid
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"{}: disabling scanning on block pool {}"
argument_list|,
name|this
argument_list|,
name|bpid
argument_list|)
expr_stmt|;
name|i
operator|.
name|remove
argument_list|()
expr_stmt|;
name|IOUtils
operator|.
name|cleanup
argument_list|(
literal|null
argument_list|,
name|iter
argument_list|)
expr_stmt|;
if|if
condition|(
name|curBlockIter
operator|==
name|iter
condition|)
block|{
name|curBlockIter
operator|=
literal|null
expr_stmt|;
block|}
name|notify
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
name|LOG
operator|.
name|warn
argument_list|(
literal|"{}: can't remove block pool {}, because it was never "
operator|+
literal|"added."
argument_list|,
name|this
argument_list|,
name|bpid
argument_list|)
expr_stmt|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|getStatistics ()
name|Statistics
name|getStatistics
parameter_list|()
block|{
synchronized|synchronized
init|(
name|stats
init|)
block|{
return|return
operator|new
name|Statistics
argument_list|(
name|stats
argument_list|)
return|;
block|}
block|}
block|}
end_class

end_unit

