begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdfs.tools.offlineImageViewer
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|tools
operator|.
name|offlineImageViewer
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|FSImageFormatPBINode
operator|.
name|ACL_ENTRY_NAME_MASK
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|FSImageFormatPBINode
operator|.
name|ACL_ENTRY_NAME_OFFSET
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|FSImageFormatPBINode
operator|.
name|ACL_ENTRY_SCOPE_OFFSET
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|FSImageFormatPBINode
operator|.
name|ACL_ENTRY_TYPE_OFFSET
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|FSImageFormatPBINode
operator|.
name|XATTR_NAMESPACE_MASK
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|FSImageFormatPBINode
operator|.
name|XATTR_NAME_OFFSET
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|FSImageFormatPBINode
operator|.
name|XATTR_NAMESPACE_OFFSET
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|FSImageFormatPBINode
operator|.
name|XATTR_NAMESPACE_EXT_OFFSET
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|FSImageFormatPBINode
operator|.
name|XATTR_NAMESPACE_EXT_MASK
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|tools
operator|.
name|offlineImageViewer
operator|.
name|PBImageXmlWriter
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|BufferedOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStreamReader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|ByteBuffer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|Charset
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|Files
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|Paths
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|DigestOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|MessageDigest
import|;
end_import

begin_import
import|import
name|java
operator|.
name|text
operator|.
name|ParseException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|text
operator|.
name|SimpleDateFormat
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Date
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|io
operator|.
name|CountingOutputStream
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|primitives
operator|.
name|Ints
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|ByteString
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|TextFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceStability
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|permission
operator|.
name|AclEntry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|permission
operator|.
name|FsPermission
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|proto
operator|.
name|HdfsProtos
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|proto
operator|.
name|ClientNamenodeProtocolProtos
operator|.
name|CacheDirectiveInfoExpirationProto
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|proto
operator|.
name|ClientNamenodeProtocolProtos
operator|.
name|CacheDirectiveInfoProto
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|proto
operator|.
name|ClientNamenodeProtocolProtos
operator|.
name|CachePoolInfoProto
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|proto
operator|.
name|XAttrProtos
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|FSImageFormatProtobuf
operator|.
name|SectionName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|FSImageUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|FsImageProto
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|FsImageProto
operator|.
name|CacheManagerSection
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|FsImageProto
operator|.
name|FileSummary
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|FsImageProto
operator|.
name|FilesUnderConstructionSection
operator|.
name|FileUnderConstructionEntry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|FsImageProto
operator|.
name|INodeSection
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|FsImageProto
operator|.
name|INodeSection
operator|.
name|AclFeatureProto
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|FsImageProto
operator|.
name|NameSystemSection
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|FsImageProto
operator|.
name|SecretManagerSection
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|FsImageProto
operator|.
name|SnapshotDiffSection
operator|.
name|DiffEntry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|NameNodeLayoutVersion
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|util
operator|.
name|MD5FileUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|util
operator|.
name|XMLUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|MD5Hash
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|bind
operator|.
name|annotation
operator|.
name|adapters
operator|.
name|HexBinaryAdapter
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|stream
operator|.
name|XMLEventReader
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|stream
operator|.
name|XMLInputFactory
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|stream
operator|.
name|XMLStreamConstants
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|stream
operator|.
name|XMLStreamException
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|stream
operator|.
name|events
operator|.
name|XMLEvent
import|;
end_import

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
annotation|@
name|InterfaceStability
operator|.
name|Unstable
DECL|class|OfflineImageReconstructor
class|class
name|OfflineImageReconstructor
block|{
DECL|field|LOG
specifier|public
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|OfflineImageReconstructor
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/**    * The output stream.    */
DECL|field|out
specifier|private
specifier|final
name|CountingOutputStream
name|out
decl_stmt|;
comment|/**    * A source of XML events based on the input file.    */
DECL|field|events
specifier|private
specifier|final
name|XMLEventReader
name|events
decl_stmt|;
comment|/**    * A map of section names to section handler objects.    */
DECL|field|sections
specifier|private
specifier|final
name|HashMap
argument_list|<
name|String
argument_list|,
name|SectionProcessor
argument_list|>
name|sections
decl_stmt|;
comment|/**    * The offset of the start of the current section.    */
DECL|field|sectionStartOffset
specifier|private
name|long
name|sectionStartOffset
decl_stmt|;
comment|/**    * The FileSummary builder, where we gather information about each section    * we wrote.    */
DECL|field|fileSummaryBld
specifier|private
specifier|final
name|FileSummary
operator|.
name|Builder
name|fileSummaryBld
init|=
name|FileSummary
operator|.
name|newBuilder
argument_list|()
decl_stmt|;
comment|/**    * The string table.  See registerStringId for details.    */
DECL|field|stringTable
specifier|private
specifier|final
name|HashMap
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|stringTable
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|/**    * The date formatter to use with fsimage XML files.    */
DECL|field|isoDateFormat
specifier|private
specifier|final
name|SimpleDateFormat
name|isoDateFormat
decl_stmt|;
comment|/**    * The latest string ID.  See registerStringId for details.    */
DECL|field|latestStringId
specifier|private
name|int
name|latestStringId
init|=
literal|0
decl_stmt|;
DECL|field|EMPTY_STRING
specifier|private
specifier|static
specifier|final
name|String
name|EMPTY_STRING
init|=
literal|""
decl_stmt|;
DECL|method|OfflineImageReconstructor (CountingOutputStream out, InputStreamReader reader)
specifier|private
name|OfflineImageReconstructor
parameter_list|(
name|CountingOutputStream
name|out
parameter_list|,
name|InputStreamReader
name|reader
parameter_list|)
throws|throws
name|XMLStreamException
block|{
name|this
operator|.
name|out
operator|=
name|out
expr_stmt|;
name|XMLInputFactory
name|factory
init|=
name|XMLInputFactory
operator|.
name|newInstance
argument_list|()
decl_stmt|;
name|this
operator|.
name|events
operator|=
name|factory
operator|.
name|createXMLEventReader
argument_list|(
name|reader
argument_list|)
expr_stmt|;
name|this
operator|.
name|sections
operator|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
expr_stmt|;
name|this
operator|.
name|sections
operator|.
name|put
argument_list|(
name|NameSectionProcessor
operator|.
name|NAME
argument_list|,
operator|new
name|NameSectionProcessor
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|sections
operator|.
name|put
argument_list|(
name|INodeSectionProcessor
operator|.
name|NAME
argument_list|,
operator|new
name|INodeSectionProcessor
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|sections
operator|.
name|put
argument_list|(
name|SecretManagerSectionProcessor
operator|.
name|NAME
argument_list|,
operator|new
name|SecretManagerSectionProcessor
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|sections
operator|.
name|put
argument_list|(
name|CacheManagerSectionProcessor
operator|.
name|NAME
argument_list|,
operator|new
name|CacheManagerSectionProcessor
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|sections
operator|.
name|put
argument_list|(
name|SnapshotDiffSectionProcessor
operator|.
name|NAME
argument_list|,
operator|new
name|SnapshotDiffSectionProcessor
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|sections
operator|.
name|put
argument_list|(
name|INodeReferenceSectionProcessor
operator|.
name|NAME
argument_list|,
operator|new
name|INodeReferenceSectionProcessor
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|sections
operator|.
name|put
argument_list|(
name|INodeDirectorySectionProcessor
operator|.
name|NAME
argument_list|,
operator|new
name|INodeDirectorySectionProcessor
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|sections
operator|.
name|put
argument_list|(
name|FilesUnderConstructionSectionProcessor
operator|.
name|NAME
argument_list|,
operator|new
name|FilesUnderConstructionSectionProcessor
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|sections
operator|.
name|put
argument_list|(
name|SnapshotSectionProcessor
operator|.
name|NAME
argument_list|,
operator|new
name|SnapshotSectionProcessor
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|isoDateFormat
operator|=
name|PBImageXmlWriter
operator|.
name|createSimpleDateFormat
argument_list|()
expr_stmt|;
block|}
comment|/**    * Read the next tag start or end event.    *    * @param expected     The name of the next tag we expect.    *                     We will validate that the tag has this name,    *                     unless this string is enclosed in braces.    * @param allowEnd     If true, we will also end events.    *                     If false, end events cause an exception.    *    * @return             The next tag start or end event.    */
DECL|method|expectTag (String expected, boolean allowEnd)
specifier|private
name|XMLEvent
name|expectTag
parameter_list|(
name|String
name|expected
parameter_list|,
name|boolean
name|allowEnd
parameter_list|)
throws|throws
name|IOException
block|{
name|XMLEvent
name|ev
init|=
literal|null
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
try|try
block|{
name|ev
operator|=
name|events
operator|.
name|nextEvent
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|XMLStreamException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Expecting "
operator|+
name|expected
operator|+
literal|", but got XMLStreamException"
argument_list|,
name|e
argument_list|)
throw|;
block|}
switch|switch
condition|(
name|ev
operator|.
name|getEventType
argument_list|()
condition|)
block|{
case|case
name|XMLEvent
operator|.
name|ATTRIBUTE
case|:
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Got unexpected attribute: "
operator|+
name|ev
argument_list|)
throw|;
case|case
name|XMLEvent
operator|.
name|CHARACTERS
case|:
if|if
condition|(
operator|!
name|ev
operator|.
name|asCharacters
argument_list|()
operator|.
name|isWhiteSpace
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Got unxpected characters while "
operator|+
literal|"looking for "
operator|+
name|expected
operator|+
literal|": "
operator|+
name|ev
operator|.
name|asCharacters
argument_list|()
operator|.
name|getData
argument_list|()
argument_list|)
throw|;
block|}
break|break;
case|case
name|XMLEvent
operator|.
name|END_ELEMENT
case|:
if|if
condition|(
operator|!
name|allowEnd
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Got unexpected end event "
operator|+
literal|"while looking for "
operator|+
name|expected
argument_list|)
throw|;
block|}
return|return
name|ev
return|;
case|case
name|XMLEvent
operator|.
name|START_ELEMENT
case|:
if|if
condition|(
operator|!
name|expected
operator|.
name|startsWith
argument_list|(
literal|"["
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|ev
operator|.
name|asStartElement
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|getLocalPart
argument_list|()
operator|.
name|equals
argument_list|(
name|expected
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Failed to find<"
operator|+
name|expected
operator|+
literal|">; "
operator|+
literal|"got "
operator|+
name|ev
operator|.
name|asStartElement
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|getLocalPart
argument_list|()
operator|+
literal|" instead."
argument_list|)
throw|;
block|}
block|}
return|return
name|ev
return|;
default|default:
comment|// Ignore other event types like comment, etc.
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Skipping XMLEvent of type "
operator|+
name|ev
operator|.
name|getEventType
argument_list|()
operator|+
literal|"("
operator|+
name|ev
operator|+
literal|")"
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
DECL|method|expectTagEnd (String expected)
specifier|private
name|void
name|expectTagEnd
parameter_list|(
name|String
name|expected
parameter_list|)
throws|throws
name|IOException
block|{
name|XMLEvent
name|ev
init|=
name|expectTag
argument_list|(
name|expected
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|ev
operator|.
name|getEventType
argument_list|()
operator|!=
name|XMLStreamConstants
operator|.
name|END_ELEMENT
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Expected tag end event for "
operator|+
name|expected
operator|+
literal|", but got: "
operator|+
name|ev
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|expected
operator|.
name|startsWith
argument_list|(
literal|"["
argument_list|)
condition|)
block|{
name|String
name|tag
init|=
name|ev
operator|.
name|asEndElement
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|getLocalPart
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|tag
operator|.
name|equals
argument_list|(
name|expected
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Expected tag end event for "
operator|+
name|expected
operator|+
literal|", but got tag end event for "
operator|+
name|tag
argument_list|)
throw|;
block|}
block|}
block|}
DECL|class|Node
specifier|private
specifier|static
class|class
name|Node
block|{
DECL|field|EMPTY
specifier|private
specifier|static
specifier|final
name|String
name|EMPTY
init|=
literal|""
decl_stmt|;
DECL|field|children
name|HashMap
argument_list|<
name|String
argument_list|,
name|LinkedList
argument_list|<
name|Node
argument_list|>
argument_list|>
name|children
decl_stmt|;
DECL|field|val
name|String
name|val
init|=
name|EMPTY
decl_stmt|;
DECL|method|addChild (String key, Node node)
name|void
name|addChild
parameter_list|(
name|String
name|key
parameter_list|,
name|Node
name|node
parameter_list|)
block|{
if|if
condition|(
name|children
operator|==
literal|null
condition|)
block|{
name|children
operator|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
expr_stmt|;
block|}
name|LinkedList
argument_list|<
name|Node
argument_list|>
name|cur
init|=
name|children
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|cur
operator|==
literal|null
condition|)
block|{
name|cur
operator|=
operator|new
name|LinkedList
argument_list|<>
argument_list|()
expr_stmt|;
name|children
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|cur
argument_list|)
expr_stmt|;
block|}
name|cur
operator|.
name|add
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
DECL|method|removeChild (String key)
name|Node
name|removeChild
parameter_list|(
name|String
name|key
parameter_list|)
block|{
if|if
condition|(
name|children
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|LinkedList
argument_list|<
name|Node
argument_list|>
name|cur
init|=
name|children
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|cur
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|Node
name|node
init|=
name|cur
operator|.
name|remove
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|node
operator|==
literal|null
operator|)
operator|||
name|cur
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|children
operator|.
name|remove
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
return|return
name|node
return|;
block|}
DECL|method|removeChildStr (String key)
name|String
name|removeChildStr
parameter_list|(
name|String
name|key
parameter_list|)
block|{
name|Node
name|child
init|=
name|removeChild
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|child
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
operator|(
name|child
operator|.
name|children
operator|!=
literal|null
operator|)
operator|&&
operator|(
operator|!
name|child
operator|.
name|children
operator|.
name|isEmpty
argument_list|()
operator|)
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Node "
operator|+
name|key
operator|+
literal|" contains children "
operator|+
literal|"of its own."
argument_list|)
throw|;
block|}
return|return
name|child
operator|.
name|getVal
argument_list|()
return|;
block|}
DECL|method|removeChildInt (String key)
name|Integer
name|removeChildInt
parameter_list|(
name|String
name|key
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|str
init|=
name|removeChildStr
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|str
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|Integer
operator|.
name|valueOf
argument_list|(
name|str
argument_list|)
return|;
block|}
DECL|method|removeChildLong (String key)
name|Long
name|removeChildLong
parameter_list|(
name|String
name|key
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|str
init|=
name|removeChildStr
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|str
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|Long
operator|.
name|valueOf
argument_list|(
name|str
argument_list|)
return|;
block|}
DECL|method|removeChildBool (String key)
name|boolean
name|removeChildBool
parameter_list|(
name|String
name|key
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|str
init|=
name|removeChildStr
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|str
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
DECL|method|getRemainingKeyNames ()
name|String
name|getRemainingKeyNames
parameter_list|()
block|{
if|if
condition|(
name|children
operator|==
literal|null
condition|)
block|{
return|return
literal|""
return|;
block|}
return|return
name|StringUtils
operator|.
name|join
argument_list|(
literal|", "
argument_list|,
name|children
operator|.
name|keySet
argument_list|()
argument_list|)
return|;
block|}
DECL|method|verifyNoRemainingKeys (String sectionName)
name|void
name|verifyNoRemainingKeys
parameter_list|(
name|String
name|sectionName
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|remainingKeyNames
init|=
name|getRemainingKeyNames
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|remainingKeyNames
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Found unknown XML keys in "
operator|+
name|sectionName
operator|+
literal|": "
operator|+
name|remainingKeyNames
argument_list|)
throw|;
block|}
block|}
DECL|method|setVal (String val)
name|void
name|setVal
parameter_list|(
name|String
name|val
parameter_list|)
block|{
name|this
operator|.
name|val
operator|=
name|val
expr_stmt|;
block|}
DECL|method|getVal ()
name|String
name|getVal
parameter_list|()
block|{
return|return
name|val
return|;
block|}
DECL|method|dump ()
name|String
name|dump
parameter_list|()
block|{
name|StringBuilder
name|bld
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|children
operator|!=
literal|null
operator|)
operator|&&
operator|(
operator|!
name|children
operator|.
name|isEmpty
argument_list|()
operator|)
condition|)
block|{
name|bld
operator|.
name|append
argument_list|(
literal|"{"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|!=
literal|null
condition|)
block|{
name|bld
operator|.
name|append
argument_list|(
literal|"["
argument_list|)
operator|.
name|append
argument_list|(
name|val
argument_list|)
operator|.
name|append
argument_list|(
literal|"]"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|children
operator|!=
literal|null
operator|)
operator|&&
operator|(
operator|!
name|children
operator|.
name|isEmpty
argument_list|()
operator|)
condition|)
block|{
name|String
name|prefix
init|=
literal|""
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|LinkedList
argument_list|<
name|Node
argument_list|>
argument_list|>
name|entry
range|:
name|children
operator|.
name|entrySet
argument_list|()
control|)
block|{
for|for
control|(
name|Node
name|n
range|:
name|entry
operator|.
name|getValue
argument_list|()
control|)
block|{
name|bld
operator|.
name|append
argument_list|(
name|prefix
argument_list|)
expr_stmt|;
name|bld
operator|.
name|append
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|": "
argument_list|)
expr_stmt|;
name|bld
operator|.
name|append
argument_list|(
name|n
operator|.
name|dump
argument_list|()
argument_list|)
expr_stmt|;
name|prefix
operator|=
literal|", "
expr_stmt|;
block|}
block|}
name|bld
operator|.
name|append
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
block|}
return|return
name|bld
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
DECL|method|loadNodeChildrenHelper (Node parent, String expected, String terminators[])
specifier|private
name|void
name|loadNodeChildrenHelper
parameter_list|(
name|Node
name|parent
parameter_list|,
name|String
name|expected
parameter_list|,
name|String
name|terminators
index|[]
parameter_list|)
throws|throws
name|IOException
block|{
name|XMLEvent
name|ev
init|=
literal|null
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
try|try
block|{
name|ev
operator|=
name|events
operator|.
name|peek
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|ev
operator|.
name|getEventType
argument_list|()
condition|)
block|{
case|case
name|XMLEvent
operator|.
name|END_ELEMENT
case|:
if|if
condition|(
name|terminators
operator|.
name|length
operator|!=
literal|0
condition|)
block|{
return|return;
block|}
name|events
operator|.
name|nextEvent
argument_list|()
expr_stmt|;
return|return;
case|case
name|XMLEvent
operator|.
name|START_ELEMENT
case|:
name|String
name|key
init|=
name|ev
operator|.
name|asStartElement
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|getLocalPart
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|terminator
range|:
name|terminators
control|)
block|{
if|if
condition|(
name|terminator
operator|.
name|equals
argument_list|(
name|key
argument_list|)
condition|)
block|{
return|return;
block|}
block|}
name|events
operator|.
name|nextEvent
argument_list|()
expr_stmt|;
name|Node
name|node
init|=
operator|new
name|Node
argument_list|()
decl_stmt|;
name|parent
operator|.
name|addChild
argument_list|(
name|key
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|loadNodeChildrenHelper
argument_list|(
name|node
argument_list|,
name|expected
argument_list|,
operator|new
name|String
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|XMLEvent
operator|.
name|CHARACTERS
case|:
name|String
name|val
init|=
name|XMLUtils
operator|.
name|unmangleXmlString
argument_list|(
name|ev
operator|.
name|asCharacters
argument_list|()
operator|.
name|getData
argument_list|()
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|parent
operator|.
name|setVal
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|events
operator|.
name|nextEvent
argument_list|()
expr_stmt|;
break|break;
case|case
name|XMLEvent
operator|.
name|ATTRIBUTE
case|:
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unexpected XML event "
operator|+
name|ev
argument_list|)
throw|;
default|default:
comment|// Ignore other event types like comment, etc.
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Skipping XMLEvent "
operator|+
name|ev
argument_list|)
expr_stmt|;
block|}
name|events
operator|.
name|nextEvent
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
catch|catch
parameter_list|(
name|XMLStreamException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Expecting "
operator|+
name|expected
operator|+
literal|", but got XMLStreamException"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
block|}
comment|/**    * Load a subtree of the XML into a Node structure.    * We will keep consuming XML events until we exit the current subtree.    * If there are any terminators specified, we will always leave the    * terminating end tag event in the stream.    *    * @param parent         The node to fill in.    * @param expected       A string to display in exceptions.    * @param terminators    Entering any one of these XML tags terminates our    *                       traversal.    * @throws IOException    */
DECL|method|loadNodeChildren (Node parent, String expected, String... terminators)
specifier|private
name|void
name|loadNodeChildren
parameter_list|(
name|Node
name|parent
parameter_list|,
name|String
name|expected
parameter_list|,
name|String
modifier|...
name|terminators
parameter_list|)
throws|throws
name|IOException
block|{
name|loadNodeChildrenHelper
argument_list|(
name|parent
argument_list|,
name|expected
argument_list|,
name|terminators
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"loadNodeChildren(expected="
operator|+
name|expected
operator|+
literal|", terminators=["
operator|+
name|StringUtils
operator|.
name|join
argument_list|(
literal|","
argument_list|,
name|terminators
argument_list|)
operator|+
literal|"]):"
operator|+
name|parent
operator|.
name|dump
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * A processor for an FSImage XML section.    */
DECL|interface|SectionProcessor
specifier|private
interface|interface
name|SectionProcessor
block|{
comment|/**      * Process this section.      */
DECL|method|process ()
name|void
name|process
parameter_list|()
throws|throws
name|IOException
function_decl|;
block|}
comment|/**    * Processes the NameSection containing last allocated block ID, etc.    */
DECL|class|NameSectionProcessor
specifier|private
class|class
name|NameSectionProcessor
implements|implements
name|SectionProcessor
block|{
DECL|field|NAME
specifier|static
specifier|final
name|String
name|NAME
init|=
literal|"NameSection"
decl_stmt|;
annotation|@
name|Override
DECL|method|process ()
specifier|public
name|void
name|process
parameter_list|()
throws|throws
name|IOException
block|{
name|Node
name|node
init|=
operator|new
name|Node
argument_list|()
decl_stmt|;
name|loadNodeChildren
argument_list|(
name|node
argument_list|,
literal|"NameSection fields"
argument_list|)
expr_stmt|;
name|NameSystemSection
operator|.
name|Builder
name|b
init|=
name|NameSystemSection
operator|.
name|newBuilder
argument_list|()
decl_stmt|;
name|Integer
name|namespaceId
init|=
name|node
operator|.
name|removeChildInt
argument_list|(
name|NAME_SECTION_NAMESPACE_ID
argument_list|)
decl_stmt|;
if|if
condition|(
name|namespaceId
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"<NameSection> is missing<namespaceId>"
argument_list|)
throw|;
block|}
name|b
operator|.
name|setNamespaceId
argument_list|(
name|namespaceId
argument_list|)
expr_stmt|;
name|Long
name|lval
init|=
name|node
operator|.
name|removeChildLong
argument_list|(
name|NAME_SECTION_GENSTAMPV1
argument_list|)
decl_stmt|;
if|if
condition|(
name|lval
operator|!=
literal|null
condition|)
block|{
name|b
operator|.
name|setGenstampV1
argument_list|(
name|lval
argument_list|)
expr_stmt|;
block|}
name|lval
operator|=
name|node
operator|.
name|removeChildLong
argument_list|(
name|NAME_SECTION_GENSTAMPV2
argument_list|)
expr_stmt|;
if|if
condition|(
name|lval
operator|!=
literal|null
condition|)
block|{
name|b
operator|.
name|setGenstampV2
argument_list|(
name|lval
argument_list|)
expr_stmt|;
block|}
name|lval
operator|=
name|node
operator|.
name|removeChildLong
argument_list|(
name|NAME_SECTION_GENSTAMPV1_LIMIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|lval
operator|!=
literal|null
condition|)
block|{
name|b
operator|.
name|setGenstampV1Limit
argument_list|(
name|lval
argument_list|)
expr_stmt|;
block|}
name|lval
operator|=
name|node
operator|.
name|removeChildLong
argument_list|(
name|NAME_SECTION_LAST_ALLOCATED_BLOCK_ID
argument_list|)
expr_stmt|;
if|if
condition|(
name|lval
operator|!=
literal|null
condition|)
block|{
name|b
operator|.
name|setLastAllocatedBlockId
argument_list|(
name|lval
argument_list|)
expr_stmt|;
block|}
name|lval
operator|=
name|node
operator|.
name|removeChildLong
argument_list|(
name|NAME_SECTION_TXID
argument_list|)
expr_stmt|;
if|if
condition|(
name|lval
operator|!=
literal|null
condition|)
block|{
name|b
operator|.
name|setTransactionId
argument_list|(
name|lval
argument_list|)
expr_stmt|;
block|}
name|lval
operator|=
name|node
operator|.
name|removeChildLong
argument_list|(
name|NAME_SECTION_ROLLING_UPGRADE_START_TIME
argument_list|)
expr_stmt|;
if|if
condition|(
name|lval
operator|!=
literal|null
condition|)
block|{
name|b
operator|.
name|setRollingUpgradeStartTime
argument_list|(
name|lval
argument_list|)
expr_stmt|;
block|}
name|lval
operator|=
name|node
operator|.
name|removeChildLong
argument_list|(
name|NAME_SECTION_LAST_ALLOCATED_STRIPED_BLOCK_ID
argument_list|)
expr_stmt|;
if|if
condition|(
name|lval
operator|!=
literal|null
condition|)
block|{
name|b
operator|.
name|setLastAllocatedStripedBlockId
argument_list|(
name|lval
argument_list|)
expr_stmt|;
block|}
name|node
operator|.
name|verifyNoRemainingKeys
argument_list|(
literal|"NameSection"
argument_list|)
expr_stmt|;
name|NameSystemSection
name|s
init|=
name|b
operator|.
name|build
argument_list|()
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|SectionName
operator|.
name|NS_INFO
operator|.
name|name
argument_list|()
operator|+
literal|" writing header: {"
operator|+
name|TextFormat
operator|.
name|printToString
argument_list|(
name|s
argument_list|)
operator|+
literal|"}"
argument_list|)
expr_stmt|;
block|}
name|s
operator|.
name|writeDelimitedTo
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|recordSectionLength
argument_list|(
name|SectionName
operator|.
name|NS_INFO
operator|.
name|name
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|class|INodeSectionProcessor
specifier|private
class|class
name|INodeSectionProcessor
implements|implements
name|SectionProcessor
block|{
DECL|field|NAME
specifier|static
specifier|final
name|String
name|NAME
init|=
literal|"INodeSection"
decl_stmt|;
annotation|@
name|Override
DECL|method|process ()
specifier|public
name|void
name|process
parameter_list|()
throws|throws
name|IOException
block|{
name|Node
name|headerNode
init|=
operator|new
name|Node
argument_list|()
decl_stmt|;
name|loadNodeChildren
argument_list|(
name|headerNode
argument_list|,
literal|"INodeSection fields"
argument_list|,
literal|"inode"
argument_list|)
expr_stmt|;
name|INodeSection
operator|.
name|Builder
name|b
init|=
name|INodeSection
operator|.
name|newBuilder
argument_list|()
decl_stmt|;
name|Long
name|lval
init|=
name|headerNode
operator|.
name|removeChildLong
argument_list|(
name|INODE_SECTION_LAST_INODE_ID
argument_list|)
decl_stmt|;
if|if
condition|(
name|lval
operator|!=
literal|null
condition|)
block|{
name|b
operator|.
name|setLastInodeId
argument_list|(
name|lval
argument_list|)
expr_stmt|;
block|}
name|Integer
name|expectedNumINodes
init|=
name|headerNode
operator|.
name|removeChildInt
argument_list|(
name|INODE_SECTION_NUM_INODES
argument_list|)
decl_stmt|;
if|if
condition|(
name|expectedNumINodes
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Failed to find<numInodes> in INodeSection."
argument_list|)
throw|;
block|}
name|b
operator|.
name|setNumInodes
argument_list|(
name|expectedNumINodes
argument_list|)
expr_stmt|;
name|INodeSection
name|s
init|=
name|b
operator|.
name|build
argument_list|()
decl_stmt|;
name|s
operator|.
name|writeDelimitedTo
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|headerNode
operator|.
name|verifyNoRemainingKeys
argument_list|(
literal|"INodeSection"
argument_list|)
expr_stmt|;
name|int
name|actualNumINodes
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|actualNumINodes
operator|<
name|expectedNumINodes
condition|)
block|{
try|try
block|{
name|expectTag
argument_list|(
name|INODE_SECTION_INODE
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Only found "
operator|+
name|actualNumINodes
operator|+
literal|"<inode> entries out of "
operator|+
name|expectedNumINodes
argument_list|,
name|e
argument_list|)
throw|;
block|}
name|actualNumINodes
operator|++
expr_stmt|;
name|Node
name|inode
init|=
operator|new
name|Node
argument_list|()
decl_stmt|;
name|loadNodeChildren
argument_list|(
name|inode
argument_list|,
literal|"INode fields"
argument_list|)
expr_stmt|;
name|INodeSection
operator|.
name|INode
operator|.
name|Builder
name|inodeBld
init|=
name|processINodeXml
argument_list|(
name|inode
argument_list|)
decl_stmt|;
name|inodeBld
operator|.
name|build
argument_list|()
operator|.
name|writeDelimitedTo
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|}
name|expectTagEnd
argument_list|(
name|INODE_SECTION_NAME
argument_list|)
expr_stmt|;
name|recordSectionLength
argument_list|(
name|SectionName
operator|.
name|INODE
operator|.
name|name
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|processINodeXml (Node node)
specifier|private
name|INodeSection
operator|.
name|INode
operator|.
name|Builder
name|processINodeXml
parameter_list|(
name|Node
name|node
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|type
init|=
name|node
operator|.
name|removeChildStr
argument_list|(
name|INODE_SECTION_TYPE
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"INode XML found with no<type> tag."
argument_list|)
throw|;
block|}
name|INodeSection
operator|.
name|INode
operator|.
name|Builder
name|inodeBld
init|=
name|INodeSection
operator|.
name|INode
operator|.
name|newBuilder
argument_list|()
decl_stmt|;
name|Long
name|id
init|=
name|node
operator|.
name|removeChildLong
argument_list|(
name|SECTION_ID
argument_list|)
decl_stmt|;
if|if
condition|(
name|id
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"<inode> found without<id>"
argument_list|)
throw|;
block|}
name|inodeBld
operator|.
name|setId
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|String
name|name
init|=
name|node
operator|.
name|removeChildStr
argument_list|(
name|SECTION_NAME
argument_list|)
decl_stmt|;
if|if
condition|(
name|name
operator|!=
literal|null
condition|)
block|{
name|inodeBld
operator|.
name|setName
argument_list|(
name|ByteString
operator|.
name|copyFrom
argument_list|(
name|name
argument_list|,
literal|"UTF8"
argument_list|)
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|"FILE"
case|:
name|processFileXml
argument_list|(
name|node
argument_list|,
name|inodeBld
argument_list|)
expr_stmt|;
break|break;
case|case
literal|"DIRECTORY"
case|:
name|processDirectoryXml
argument_list|(
name|node
argument_list|,
name|inodeBld
argument_list|)
expr_stmt|;
break|break;
case|case
literal|"SYMLINK"
case|:
name|processSymlinkXml
argument_list|(
name|node
argument_list|,
name|inodeBld
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|IOException
argument_list|(
literal|"INode XML found with unknown<type> "
operator|+
literal|"tag "
operator|+
name|type
argument_list|)
throw|;
block|}
name|node
operator|.
name|verifyNoRemainingKeys
argument_list|(
literal|"inode"
argument_list|)
expr_stmt|;
return|return
name|inodeBld
return|;
block|}
DECL|method|processFileXml (Node node, INodeSection.INode.Builder inodeBld)
specifier|private
name|void
name|processFileXml
parameter_list|(
name|Node
name|node
parameter_list|,
name|INodeSection
operator|.
name|INode
operator|.
name|Builder
name|inodeBld
parameter_list|)
throws|throws
name|IOException
block|{
name|inodeBld
operator|.
name|setType
argument_list|(
name|INodeSection
operator|.
name|INode
operator|.
name|Type
operator|.
name|FILE
argument_list|)
expr_stmt|;
name|INodeSection
operator|.
name|INodeFile
operator|.
name|Builder
name|bld
init|=
name|createINodeFileBuilder
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|inodeBld
operator|.
name|setFile
argument_list|(
name|bld
argument_list|)
expr_stmt|;
comment|// Will check remaining keys and serialize in processINodeXml
block|}
DECL|method|createINodeFileBuilder (Node node)
specifier|private
name|INodeSection
operator|.
name|INodeFile
operator|.
name|Builder
name|createINodeFileBuilder
parameter_list|(
name|Node
name|node
parameter_list|)
throws|throws
name|IOException
block|{
name|INodeSection
operator|.
name|INodeFile
operator|.
name|Builder
name|bld
init|=
name|INodeSection
operator|.
name|INodeFile
operator|.
name|newBuilder
argument_list|()
decl_stmt|;
name|Integer
name|ival
init|=
name|node
operator|.
name|removeChildInt
argument_list|(
name|SECTION_REPLICATION
argument_list|)
decl_stmt|;
if|if
condition|(
name|ival
operator|!=
literal|null
condition|)
block|{
name|bld
operator|.
name|setReplication
argument_list|(
name|ival
argument_list|)
expr_stmt|;
block|}
name|Long
name|lval
init|=
name|node
operator|.
name|removeChildLong
argument_list|(
name|INODE_SECTION_MTIME
argument_list|)
decl_stmt|;
if|if
condition|(
name|lval
operator|!=
literal|null
condition|)
block|{
name|bld
operator|.
name|setModificationTime
argument_list|(
name|lval
argument_list|)
expr_stmt|;
block|}
name|lval
operator|=
name|node
operator|.
name|removeChildLong
argument_list|(
name|INODE_SECTION_ATIME
argument_list|)
expr_stmt|;
if|if
condition|(
name|lval
operator|!=
literal|null
condition|)
block|{
name|bld
operator|.
name|setAccessTime
argument_list|(
name|lval
argument_list|)
expr_stmt|;
block|}
name|lval
operator|=
name|node
operator|.
name|removeChildLong
argument_list|(
name|INODE_SECTION_PREFERRED_BLOCK_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|lval
operator|!=
literal|null
condition|)
block|{
name|bld
operator|.
name|setPreferredBlockSize
argument_list|(
name|lval
argument_list|)
expr_stmt|;
block|}
name|String
name|perm
init|=
name|node
operator|.
name|removeChildStr
argument_list|(
name|INODE_SECTION_PERMISSION
argument_list|)
decl_stmt|;
if|if
condition|(
name|perm
operator|!=
literal|null
condition|)
block|{
name|bld
operator|.
name|setPermission
argument_list|(
name|permissionXmlToU64
argument_list|(
name|perm
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Node
name|blocks
init|=
name|node
operator|.
name|removeChild
argument_list|(
name|INODE_SECTION_BLOCKS
argument_list|)
decl_stmt|;
if|if
condition|(
name|blocks
operator|!=
literal|null
condition|)
block|{
while|while
condition|(
literal|true
condition|)
block|{
name|Node
name|block
init|=
name|blocks
operator|.
name|removeChild
argument_list|(
name|INODE_SECTION_BLOCK
argument_list|)
decl_stmt|;
if|if
condition|(
name|block
operator|==
literal|null
condition|)
block|{
break|break;
block|}
name|bld
operator|.
name|addBlocks
argument_list|(
name|createBlockBuilder
argument_list|(
name|block
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|Node
name|fileUnderConstruction
init|=
name|node
operator|.
name|removeChild
argument_list|(
name|INODE_SECTION_FILE_UNDER_CONSTRUCTION
argument_list|)
decl_stmt|;
if|if
condition|(
name|fileUnderConstruction
operator|!=
literal|null
condition|)
block|{
name|INodeSection
operator|.
name|FileUnderConstructionFeature
operator|.
name|Builder
name|fb
init|=
name|INodeSection
operator|.
name|FileUnderConstructionFeature
operator|.
name|newBuilder
argument_list|()
decl_stmt|;
name|String
name|clientName
init|=
name|fileUnderConstruction
operator|.
name|removeChildStr
argument_list|(
name|INODE_SECTION_CLIENT_NAME
argument_list|)
decl_stmt|;
if|if
condition|(
name|clientName
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"<file-under-construction> found without "
operator|+
literal|"<clientName>"
argument_list|)
throw|;
block|}
name|fb
operator|.
name|setClientName
argument_list|(
name|clientName
argument_list|)
expr_stmt|;
name|String
name|clientMachine
init|=
name|fileUnderConstruction
operator|.
name|removeChildStr
argument_list|(
name|INODE_SECTION_CLIENT_MACHINE
argument_list|)
decl_stmt|;
if|if
condition|(
name|clientMachine
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"<file-under-construction> found without "
operator|+
literal|"<clientMachine>"
argument_list|)
throw|;
block|}
name|fb
operator|.
name|setClientMachine
argument_list|(
name|clientMachine
argument_list|)
expr_stmt|;
name|bld
operator|.
name|setFileUC
argument_list|(
name|fb
argument_list|)
expr_stmt|;
block|}
name|Node
name|acls
init|=
name|node
operator|.
name|removeChild
argument_list|(
name|INODE_SECTION_ACLS
argument_list|)
decl_stmt|;
if|if
condition|(
name|acls
operator|!=
literal|null
condition|)
block|{
name|bld
operator|.
name|setAcl
argument_list|(
name|aclXmlToProto
argument_list|(
name|acls
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Node
name|xattrs
init|=
name|node
operator|.
name|removeChild
argument_list|(
name|INODE_SECTION_XATTRS
argument_list|)
decl_stmt|;
if|if
condition|(
name|xattrs
operator|!=
literal|null
condition|)
block|{
name|bld
operator|.
name|setXAttrs
argument_list|(
name|xattrsXmlToProto
argument_list|(
name|xattrs
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ival
operator|=
name|node
operator|.
name|removeChildInt
argument_list|(
name|INODE_SECTION_STORAGE_POLICY_ID
argument_list|)
expr_stmt|;
if|if
condition|(
name|ival
operator|!=
literal|null
condition|)
block|{
name|bld
operator|.
name|setStoragePolicyID
argument_list|(
name|ival
argument_list|)
expr_stmt|;
block|}
name|String
name|blockType
init|=
name|node
operator|.
name|removeChildStr
argument_list|(
name|INODE_SECTION_BLOCK_TYPE
argument_list|)
decl_stmt|;
if|if
condition|(
name|blockType
operator|!=
literal|null
condition|)
block|{
switch|switch
condition|(
name|blockType
condition|)
block|{
case|case
literal|"CONTIGUOUS"
case|:
name|bld
operator|.
name|setBlockType
argument_list|(
name|HdfsProtos
operator|.
name|BlockTypeProto
operator|.
name|CONTIGUOUS
argument_list|)
expr_stmt|;
break|break;
case|case
literal|"STRIPED"
case|:
name|bld
operator|.
name|setBlockType
argument_list|(
name|HdfsProtos
operator|.
name|BlockTypeProto
operator|.
name|STRIPED
argument_list|)
expr_stmt|;
name|ival
operator|=
name|node
operator|.
name|removeChildInt
argument_list|(
name|INODE_SECTION_EC_POLICY_ID
argument_list|)
expr_stmt|;
if|if
condition|(
name|ival
operator|!=
literal|null
condition|)
block|{
name|bld
operator|.
name|setErasureCodingPolicyID
argument_list|(
name|ival
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
throw|throw
operator|new
name|IOException
argument_list|(
literal|"INode XML found with unknown<blocktype> "
operator|+
name|blockType
argument_list|)
throw|;
block|}
block|}
return|return
name|bld
return|;
block|}
DECL|method|createBlockBuilder (Node block)
specifier|private
name|HdfsProtos
operator|.
name|BlockProto
operator|.
name|Builder
name|createBlockBuilder
parameter_list|(
name|Node
name|block
parameter_list|)
throws|throws
name|IOException
block|{
name|HdfsProtos
operator|.
name|BlockProto
operator|.
name|Builder
name|blockBld
init|=
name|HdfsProtos
operator|.
name|BlockProto
operator|.
name|newBuilder
argument_list|()
decl_stmt|;
name|Long
name|id
init|=
name|block
operator|.
name|removeChildLong
argument_list|(
name|SECTION_ID
argument_list|)
decl_stmt|;
if|if
condition|(
name|id
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"<block> found without<id>"
argument_list|)
throw|;
block|}
name|blockBld
operator|.
name|setBlockId
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|Long
name|genstamp
init|=
name|block
operator|.
name|removeChildLong
argument_list|(
name|INODE_SECTION_GEMSTAMP
argument_list|)
decl_stmt|;
if|if
condition|(
name|genstamp
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"<block> found without<genstamp>"
argument_list|)
throw|;
block|}
name|blockBld
operator|.
name|setGenStamp
argument_list|(
name|genstamp
argument_list|)
expr_stmt|;
name|Long
name|numBytes
init|=
name|block
operator|.
name|removeChildLong
argument_list|(
name|INODE_SECTION_NUM_BYTES
argument_list|)
decl_stmt|;
if|if
condition|(
name|numBytes
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"<block> found without<numBytes>"
argument_list|)
throw|;
block|}
name|blockBld
operator|.
name|setNumBytes
argument_list|(
name|numBytes
argument_list|)
expr_stmt|;
return|return
name|blockBld
return|;
block|}
DECL|method|processDirectoryXml (Node node, INodeSection.INode.Builder inodeBld)
specifier|private
name|void
name|processDirectoryXml
parameter_list|(
name|Node
name|node
parameter_list|,
name|INodeSection
operator|.
name|INode
operator|.
name|Builder
name|inodeBld
parameter_list|)
throws|throws
name|IOException
block|{
name|inodeBld
operator|.
name|setType
argument_list|(
name|INodeSection
operator|.
name|INode
operator|.
name|Type
operator|.
name|DIRECTORY
argument_list|)
expr_stmt|;
name|INodeSection
operator|.
name|INodeDirectory
operator|.
name|Builder
name|bld
init|=
name|createINodeDirectoryBuilder
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|inodeBld
operator|.
name|setDirectory
argument_list|(
name|bld
argument_list|)
expr_stmt|;
comment|// Will check remaining keys and serialize in processINodeXml
block|}
specifier|private
name|INodeSection
operator|.
name|INodeDirectory
operator|.
name|Builder
DECL|method|createINodeDirectoryBuilder (Node node)
name|createINodeDirectoryBuilder
parameter_list|(
name|Node
name|node
parameter_list|)
throws|throws
name|IOException
block|{
name|INodeSection
operator|.
name|INodeDirectory
operator|.
name|Builder
name|bld
init|=
name|INodeSection
operator|.
name|INodeDirectory
operator|.
name|newBuilder
argument_list|()
decl_stmt|;
name|Long
name|lval
init|=
name|node
operator|.
name|removeChildLong
argument_list|(
name|INODE_SECTION_MTIME
argument_list|)
decl_stmt|;
if|if
condition|(
name|lval
operator|!=
literal|null
condition|)
block|{
name|bld
operator|.
name|setModificationTime
argument_list|(
name|lval
argument_list|)
expr_stmt|;
block|}
name|lval
operator|=
name|node
operator|.
name|removeChildLong
argument_list|(
name|INODE_SECTION_NS_QUOTA
argument_list|)
expr_stmt|;
if|if
condition|(
name|lval
operator|!=
literal|null
condition|)
block|{
name|bld
operator|.
name|setNsQuota
argument_list|(
name|lval
argument_list|)
expr_stmt|;
block|}
name|lval
operator|=
name|node
operator|.
name|removeChildLong
argument_list|(
name|INODE_SECTION_DS_QUOTA
argument_list|)
expr_stmt|;
if|if
condition|(
name|lval
operator|!=
literal|null
condition|)
block|{
name|bld
operator|.
name|setDsQuota
argument_list|(
name|lval
argument_list|)
expr_stmt|;
block|}
name|String
name|perm
init|=
name|node
operator|.
name|removeChildStr
argument_list|(
name|INODE_SECTION_PERMISSION
argument_list|)
decl_stmt|;
if|if
condition|(
name|perm
operator|!=
literal|null
condition|)
block|{
name|bld
operator|.
name|setPermission
argument_list|(
name|permissionXmlToU64
argument_list|(
name|perm
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Node
name|acls
init|=
name|node
operator|.
name|removeChild
argument_list|(
name|INODE_SECTION_ACLS
argument_list|)
decl_stmt|;
if|if
condition|(
name|acls
operator|!=
literal|null
condition|)
block|{
name|bld
operator|.
name|setAcl
argument_list|(
name|aclXmlToProto
argument_list|(
name|acls
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Node
name|xattrs
init|=
name|node
operator|.
name|removeChild
argument_list|(
name|INODE_SECTION_XATTRS
argument_list|)
decl_stmt|;
if|if
condition|(
name|xattrs
operator|!=
literal|null
condition|)
block|{
name|bld
operator|.
name|setXAttrs
argument_list|(
name|xattrsXmlToProto
argument_list|(
name|xattrs
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|INodeSection
operator|.
name|QuotaByStorageTypeFeatureProto
operator|.
name|Builder
name|qf
init|=
name|INodeSection
operator|.
name|QuotaByStorageTypeFeatureProto
operator|.
name|newBuilder
argument_list|()
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|Node
name|typeQuota
init|=
name|node
operator|.
name|removeChild
argument_list|(
name|INODE_SECTION_TYPE_QUOTA
argument_list|)
decl_stmt|;
if|if
condition|(
name|typeQuota
operator|==
literal|null
condition|)
block|{
break|break;
block|}
name|INodeSection
operator|.
name|QuotaByStorageTypeEntryProto
operator|.
name|Builder
name|qbld
init|=
name|INodeSection
operator|.
name|QuotaByStorageTypeEntryProto
operator|.
name|newBuilder
argument_list|()
decl_stmt|;
name|String
name|type
init|=
name|typeQuota
operator|.
name|removeChildStr
argument_list|(
name|INODE_SECTION_TYPE
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"<typeQuota> was missing<type>"
argument_list|)
throw|;
block|}
name|HdfsProtos
operator|.
name|StorageTypeProto
name|storageType
init|=
name|HdfsProtos
operator|.
name|StorageTypeProto
operator|.
name|valueOf
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|storageType
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"<typeQuota> had unknown<type> "
operator|+
name|type
argument_list|)
throw|;
block|}
name|qbld
operator|.
name|setStorageType
argument_list|(
name|storageType
argument_list|)
expr_stmt|;
name|Long
name|quota
init|=
name|typeQuota
operator|.
name|removeChildLong
argument_list|(
name|INODE_SECTION_QUOTA
argument_list|)
decl_stmt|;
if|if
condition|(
name|quota
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"<typeQuota> was missing<quota>"
argument_list|)
throw|;
block|}
name|qbld
operator|.
name|setQuota
argument_list|(
name|quota
argument_list|)
expr_stmt|;
name|qf
operator|.
name|addQuotas
argument_list|(
name|qbld
argument_list|)
expr_stmt|;
block|}
name|bld
operator|.
name|setTypeQuotas
argument_list|(
name|qf
argument_list|)
expr_stmt|;
return|return
name|bld
return|;
block|}
DECL|method|processSymlinkXml (Node node, INodeSection.INode.Builder inodeBld)
specifier|private
name|void
name|processSymlinkXml
parameter_list|(
name|Node
name|node
parameter_list|,
name|INodeSection
operator|.
name|INode
operator|.
name|Builder
name|inodeBld
parameter_list|)
throws|throws
name|IOException
block|{
name|inodeBld
operator|.
name|setType
argument_list|(
name|INodeSection
operator|.
name|INode
operator|.
name|Type
operator|.
name|SYMLINK
argument_list|)
expr_stmt|;
name|INodeSection
operator|.
name|INodeSymlink
operator|.
name|Builder
name|bld
init|=
name|INodeSection
operator|.
name|INodeSymlink
operator|.
name|newBuilder
argument_list|()
decl_stmt|;
name|String
name|perm
init|=
name|node
operator|.
name|removeChildStr
argument_list|(
name|INODE_SECTION_PERMISSION
argument_list|)
decl_stmt|;
if|if
condition|(
name|perm
operator|!=
literal|null
condition|)
block|{
name|bld
operator|.
name|setPermission
argument_list|(
name|permissionXmlToU64
argument_list|(
name|perm
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|String
name|target
init|=
name|node
operator|.
name|removeChildStr
argument_list|(
name|INODE_SECTION_TARGET
argument_list|)
decl_stmt|;
if|if
condition|(
name|target
operator|!=
literal|null
condition|)
block|{
name|bld
operator|.
name|setTarget
argument_list|(
name|ByteString
operator|.
name|copyFrom
argument_list|(
name|target
argument_list|,
literal|"UTF8"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Long
name|lval
init|=
name|node
operator|.
name|removeChildLong
argument_list|(
name|INODE_SECTION_MTIME
argument_list|)
decl_stmt|;
if|if
condition|(
name|lval
operator|!=
literal|null
condition|)
block|{
name|bld
operator|.
name|setModificationTime
argument_list|(
name|lval
argument_list|)
expr_stmt|;
block|}
name|lval
operator|=
name|node
operator|.
name|removeChildLong
argument_list|(
name|INODE_SECTION_ATIME
argument_list|)
expr_stmt|;
if|if
condition|(
name|lval
operator|!=
literal|null
condition|)
block|{
name|bld
operator|.
name|setAccessTime
argument_list|(
name|lval
argument_list|)
expr_stmt|;
block|}
name|inodeBld
operator|.
name|setSymlink
argument_list|(
name|bld
argument_list|)
expr_stmt|;
comment|// Will check remaining keys and serialize in processINodeXml
block|}
DECL|method|aclXmlToProto (Node acls)
specifier|private
name|INodeSection
operator|.
name|AclFeatureProto
operator|.
name|Builder
name|aclXmlToProto
parameter_list|(
name|Node
name|acls
parameter_list|)
throws|throws
name|IOException
block|{
name|AclFeatureProto
operator|.
name|Builder
name|b
init|=
name|AclFeatureProto
operator|.
name|newBuilder
argument_list|()
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|Node
name|acl
init|=
name|acls
operator|.
name|removeChild
argument_list|(
name|INODE_SECTION_ACL
argument_list|)
decl_stmt|;
if|if
condition|(
name|acl
operator|==
literal|null
condition|)
block|{
break|break;
block|}
name|String
name|val
init|=
name|acl
operator|.
name|getVal
argument_list|()
decl_stmt|;
name|AclEntry
name|entry
init|=
name|AclEntry
operator|.
name|parseAclEntry
argument_list|(
name|val
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|int
name|nameId
init|=
name|registerStringId
argument_list|(
name|entry
operator|.
name|getName
argument_list|()
operator|==
literal|null
condition|?
name|EMPTY_STRING
else|:
name|entry
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|v
init|=
operator|(
operator|(
name|nameId
operator|&
name|ACL_ENTRY_NAME_MASK
operator|)
operator|<<
name|ACL_ENTRY_NAME_OFFSET
operator|)
operator||
operator|(
name|entry
operator|.
name|getType
argument_list|()
operator|.
name|ordinal
argument_list|()
operator|<<
name|ACL_ENTRY_TYPE_OFFSET
operator|)
operator||
operator|(
name|entry
operator|.
name|getScope
argument_list|()
operator|.
name|ordinal
argument_list|()
operator|<<
name|ACL_ENTRY_SCOPE_OFFSET
operator|)
operator||
operator|(
name|entry
operator|.
name|getPermission
argument_list|()
operator|.
name|ordinal
argument_list|()
operator|)
decl_stmt|;
name|b
operator|.
name|addEntries
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
return|return
name|b
return|;
block|}
DECL|method|xattrsXmlToProto (Node xattrs)
specifier|private
name|INodeSection
operator|.
name|XAttrFeatureProto
operator|.
name|Builder
name|xattrsXmlToProto
parameter_list|(
name|Node
name|xattrs
parameter_list|)
throws|throws
name|IOException
block|{
name|INodeSection
operator|.
name|XAttrFeatureProto
operator|.
name|Builder
name|bld
init|=
name|INodeSection
operator|.
name|XAttrFeatureProto
operator|.
name|newBuilder
argument_list|()
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|Node
name|xattr
init|=
name|xattrs
operator|.
name|removeChild
argument_list|(
name|INODE_SECTION_XATTR
argument_list|)
decl_stmt|;
if|if
condition|(
name|xattr
operator|==
literal|null
condition|)
block|{
break|break;
block|}
name|INodeSection
operator|.
name|XAttrCompactProto
operator|.
name|Builder
name|b
init|=
name|INodeSection
operator|.
name|XAttrCompactProto
operator|.
name|newBuilder
argument_list|()
decl_stmt|;
name|String
name|ns
init|=
name|xattr
operator|.
name|removeChildStr
argument_list|(
name|INODE_SECTION_NS
argument_list|)
decl_stmt|;
if|if
condition|(
name|ns
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"<xattr> had no<ns> entry."
argument_list|)
throw|;
block|}
name|int
name|nsIdx
init|=
name|XAttrProtos
operator|.
name|XAttrProto
operator|.
name|XAttrNamespaceProto
operator|.
name|valueOf
argument_list|(
name|ns
argument_list|)
operator|.
name|ordinal
argument_list|()
decl_stmt|;
name|String
name|name
init|=
name|xattr
operator|.
name|removeChildStr
argument_list|(
name|SECTION_NAME
argument_list|)
decl_stmt|;
name|String
name|valStr
init|=
name|xattr
operator|.
name|removeChildStr
argument_list|(
name|INODE_SECTION_VAL
argument_list|)
decl_stmt|;
name|byte
index|[]
name|val
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|valStr
operator|==
literal|null
condition|)
block|{
name|String
name|valHex
init|=
name|xattr
operator|.
name|removeChildStr
argument_list|(
name|INODE_SECTION_VAL_HEX
argument_list|)
decl_stmt|;
if|if
condition|(
name|valHex
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"<xattr> had no<val> or<valHex> entry."
argument_list|)
throw|;
block|}
name|val
operator|=
operator|new
name|HexBinaryAdapter
argument_list|()
operator|.
name|unmarshal
argument_list|(
name|valHex
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|val
operator|=
name|valStr
operator|.
name|getBytes
argument_list|(
literal|"UTF8"
argument_list|)
expr_stmt|;
block|}
name|b
operator|.
name|setValue
argument_list|(
name|ByteString
operator|.
name|copyFrom
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
comment|// The XAttrCompactProto name field uses a fairly complex format
comment|// to encode both the string table ID of the xattr name and the
comment|// namespace ID.  See the protobuf file for details.
name|int
name|nameId
init|=
name|registerStringId
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|int
name|encodedName
init|=
operator|(
name|nameId
operator|<<
name|XATTR_NAME_OFFSET
operator|)
operator||
operator|(
operator|(
name|nsIdx
operator|&
name|XATTR_NAMESPACE_MASK
operator|)
operator|<<
name|XATTR_NAMESPACE_OFFSET
operator|)
operator||
operator|(
operator|(
operator|(
name|nsIdx
operator|>>
literal|2
operator|)
operator|&
name|XATTR_NAMESPACE_EXT_MASK
operator|)
operator|<<
name|XATTR_NAMESPACE_EXT_OFFSET
operator|)
decl_stmt|;
name|b
operator|.
name|setName
argument_list|(
name|encodedName
argument_list|)
expr_stmt|;
name|xattr
operator|.
name|verifyNoRemainingKeys
argument_list|(
literal|"xattr"
argument_list|)
expr_stmt|;
name|bld
operator|.
name|addXAttrs
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
name|xattrs
operator|.
name|verifyNoRemainingKeys
argument_list|(
literal|"xattrs"
argument_list|)
expr_stmt|;
return|return
name|bld
return|;
block|}
DECL|class|SecretManagerSectionProcessor
specifier|private
class|class
name|SecretManagerSectionProcessor
implements|implements
name|SectionProcessor
block|{
DECL|field|NAME
specifier|static
specifier|final
name|String
name|NAME
init|=
literal|"SecretManagerSection"
decl_stmt|;
annotation|@
name|Override
DECL|method|process ()
specifier|public
name|void
name|process
parameter_list|()
throws|throws
name|IOException
block|{
name|Node
name|secretHeader
init|=
operator|new
name|Node
argument_list|()
decl_stmt|;
name|loadNodeChildren
argument_list|(
name|secretHeader
argument_list|,
literal|"SecretManager fields"
argument_list|,
literal|"delegationKey"
argument_list|,
literal|"token"
argument_list|)
expr_stmt|;
name|SecretManagerSection
operator|.
name|Builder
name|b
init|=
name|SecretManagerSection
operator|.
name|newBuilder
argument_list|()
decl_stmt|;
name|Integer
name|currentId
init|=
name|secretHeader
operator|.
name|removeChildInt
argument_list|(
name|SECRET_MANAGER_SECTION_CURRENT_ID
argument_list|)
decl_stmt|;
if|if
condition|(
name|currentId
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"SecretManager section had no<currentId>"
argument_list|)
throw|;
block|}
name|b
operator|.
name|setCurrentId
argument_list|(
name|currentId
argument_list|)
expr_stmt|;
name|Integer
name|tokenSequenceNumber
init|=
name|secretHeader
operator|.
name|removeChildInt
argument_list|(
name|SECRET_MANAGER_SECTION_TOKEN_SEQUENCE_NUMBER
argument_list|)
decl_stmt|;
if|if
condition|(
name|tokenSequenceNumber
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"SecretManager section had no "
operator|+
literal|"<tokenSequenceNumber>"
argument_list|)
throw|;
block|}
name|b
operator|.
name|setTokenSequenceNumber
argument_list|(
name|tokenSequenceNumber
argument_list|)
expr_stmt|;
name|Integer
name|expectedNumKeys
init|=
name|secretHeader
operator|.
name|removeChildInt
argument_list|(
name|SECRET_MANAGER_SECTION_NUM_DELEGATION_KEYS
argument_list|)
decl_stmt|;
if|if
condition|(
name|expectedNumKeys
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"SecretManager section had no "
operator|+
literal|"<numDelegationKeys>"
argument_list|)
throw|;
block|}
name|b
operator|.
name|setNumKeys
argument_list|(
name|expectedNumKeys
argument_list|)
expr_stmt|;
name|Integer
name|expectedNumTokens
init|=
name|secretHeader
operator|.
name|removeChildInt
argument_list|(
name|SECRET_MANAGER_SECTION_NUM_TOKENS
argument_list|)
decl_stmt|;
if|if
condition|(
name|expectedNumTokens
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"SecretManager section had no "
operator|+
literal|"<numTokens>"
argument_list|)
throw|;
block|}
name|b
operator|.
name|setNumTokens
argument_list|(
name|expectedNumTokens
argument_list|)
expr_stmt|;
name|secretHeader
operator|.
name|verifyNoRemainingKeys
argument_list|(
literal|"SecretManager"
argument_list|)
expr_stmt|;
name|b
operator|.
name|build
argument_list|()
operator|.
name|writeDelimitedTo
argument_list|(
name|out
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|actualNumKeys
init|=
literal|0
init|;
name|actualNumKeys
operator|<
name|expectedNumKeys
condition|;
name|actualNumKeys
operator|++
control|)
block|{
try|try
block|{
name|expectTag
argument_list|(
name|SECRET_MANAGER_SECTION_DELEGATION_KEY
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Only read "
operator|+
name|actualNumKeys
operator|+
literal|" delegation keys out of "
operator|+
name|expectedNumKeys
argument_list|,
name|e
argument_list|)
throw|;
block|}
name|SecretManagerSection
operator|.
name|DelegationKey
operator|.
name|Builder
name|dbld
init|=
name|SecretManagerSection
operator|.
name|DelegationKey
operator|.
name|newBuilder
argument_list|()
decl_stmt|;
name|Node
name|dkey
init|=
operator|new
name|Node
argument_list|()
decl_stmt|;
name|loadNodeChildren
argument_list|(
name|dkey
argument_list|,
literal|"Delegation key fields"
argument_list|)
expr_stmt|;
name|Integer
name|id
init|=
name|dkey
operator|.
name|removeChildInt
argument_list|(
name|SECTION_ID
argument_list|)
decl_stmt|;
if|if
condition|(
name|id
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Delegation key stanza<delegationKey> "
operator|+
literal|"lacked an<id> field."
argument_list|)
throw|;
block|}
name|dbld
operator|.
name|setId
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|String
name|expiry
init|=
name|dkey
operator|.
name|removeChildStr
argument_list|(
name|SECRET_MANAGER_SECTION_EXPIRY
argument_list|)
decl_stmt|;
if|if
condition|(
name|expiry
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Delegation key stanza<delegationKey> "
operator|+
literal|"lacked an<expiry> field."
argument_list|)
throw|;
block|}
name|dbld
operator|.
name|setExpiryDate
argument_list|(
name|dateStrToLong
argument_list|(
name|expiry
argument_list|)
argument_list|)
expr_stmt|;
name|String
name|keyHex
init|=
name|dkey
operator|.
name|removeChildStr
argument_list|(
name|SECRET_MANAGER_SECTION_KEY
argument_list|)
decl_stmt|;
if|if
condition|(
name|keyHex
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Delegation key stanza<delegationKey> "
operator|+
literal|"lacked a<key> field."
argument_list|)
throw|;
block|}
name|byte
index|[]
name|key
init|=
operator|new
name|HexBinaryAdapter
argument_list|()
operator|.
name|unmarshal
argument_list|(
name|keyHex
argument_list|)
decl_stmt|;
name|dkey
operator|.
name|verifyNoRemainingKeys
argument_list|(
name|SECRET_MANAGER_SECTION_DELEGATION_KEY
argument_list|)
expr_stmt|;
name|dbld
operator|.
name|setKey
argument_list|(
name|ByteString
operator|.
name|copyFrom
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
name|dbld
operator|.
name|build
argument_list|()
operator|.
name|writeDelimitedTo
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|actualNumTokens
init|=
literal|0
init|;
name|actualNumTokens
operator|<
name|expectedNumTokens
condition|;
name|actualNumTokens
operator|++
control|)
block|{
try|try
block|{
name|expectTag
argument_list|(
name|SECRET_MANAGER_SECTION_TOKEN
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Only read "
operator|+
name|actualNumTokens
operator|+
literal|" tokens out of "
operator|+
name|expectedNumTokens
argument_list|,
name|e
argument_list|)
throw|;
block|}
name|SecretManagerSection
operator|.
name|PersistToken
operator|.
name|Builder
name|tbld
init|=
name|SecretManagerSection
operator|.
name|PersistToken
operator|.
name|newBuilder
argument_list|()
decl_stmt|;
name|Node
name|token
init|=
operator|new
name|Node
argument_list|()
decl_stmt|;
name|loadNodeChildren
argument_list|(
name|token
argument_list|,
literal|"PersistToken key fields"
argument_list|)
expr_stmt|;
name|Integer
name|version
init|=
name|token
operator|.
name|removeChildInt
argument_list|(
name|SECRET_MANAGER_SECTION_VERSION
argument_list|)
decl_stmt|;
if|if
condition|(
name|version
operator|!=
literal|null
condition|)
block|{
name|tbld
operator|.
name|setVersion
argument_list|(
name|version
argument_list|)
expr_stmt|;
block|}
name|String
name|owner
init|=
name|token
operator|.
name|removeChildStr
argument_list|(
name|SECRET_MANAGER_SECTION_OWNER
argument_list|)
decl_stmt|;
if|if
condition|(
name|owner
operator|!=
literal|null
condition|)
block|{
name|tbld
operator|.
name|setOwner
argument_list|(
name|owner
argument_list|)
expr_stmt|;
block|}
name|String
name|renewer
init|=
name|token
operator|.
name|removeChildStr
argument_list|(
name|SECRET_MANAGER_SECTION_RENEWER
argument_list|)
decl_stmt|;
if|if
condition|(
name|renewer
operator|!=
literal|null
condition|)
block|{
name|tbld
operator|.
name|setRenewer
argument_list|(
name|renewer
argument_list|)
expr_stmt|;
block|}
name|String
name|realUser
init|=
name|token
operator|.
name|removeChildStr
argument_list|(
name|SECRET_MANAGER_SECTION_REAL_USER
argument_list|)
decl_stmt|;
if|if
condition|(
name|realUser
operator|!=
literal|null
condition|)
block|{
name|tbld
operator|.
name|setRealUser
argument_list|(
name|realUser
argument_list|)
expr_stmt|;
block|}
name|String
name|issueDateStr
init|=
name|token
operator|.
name|removeChildStr
argument_list|(
name|SECRET_MANAGER_SECTION_ISSUE_DATE
argument_list|)
decl_stmt|;
if|if
condition|(
name|issueDateStr
operator|!=
literal|null
condition|)
block|{
name|tbld
operator|.
name|setIssueDate
argument_list|(
name|dateStrToLong
argument_list|(
name|issueDateStr
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|String
name|maxDateStr
init|=
name|token
operator|.
name|removeChildStr
argument_list|(
name|SECRET_MANAGER_SECTION_MAX_DATE
argument_list|)
decl_stmt|;
if|if
condition|(
name|maxDateStr
operator|!=
literal|null
condition|)
block|{
name|tbld
operator|.
name|setMaxDate
argument_list|(
name|dateStrToLong
argument_list|(
name|maxDateStr
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Integer
name|seqNo
init|=
name|token
operator|.
name|removeChildInt
argument_list|(
name|SECRET_MANAGER_SECTION_SEQUENCE_NUMBER
argument_list|)
decl_stmt|;
if|if
condition|(
name|seqNo
operator|!=
literal|null
condition|)
block|{
name|tbld
operator|.
name|setSequenceNumber
argument_list|(
name|seqNo
argument_list|)
expr_stmt|;
block|}
name|Integer
name|masterKeyId
init|=
name|token
operator|.
name|removeChildInt
argument_list|(
name|SECRET_MANAGER_SECTION_MASTER_KEY_ID
argument_list|)
decl_stmt|;
if|if
condition|(
name|masterKeyId
operator|!=
literal|null
condition|)
block|{
name|tbld
operator|.
name|setMasterKeyId
argument_list|(
name|masterKeyId
argument_list|)
expr_stmt|;
block|}
name|String
name|expiryDateStr
init|=
name|token
operator|.
name|removeChildStr
argument_list|(
name|SECRET_MANAGER_SECTION_EXPIRY_DATE
argument_list|)
decl_stmt|;
if|if
condition|(
name|expiryDateStr
operator|!=
literal|null
condition|)
block|{
name|tbld
operator|.
name|setExpiryDate
argument_list|(
name|dateStrToLong
argument_list|(
name|expiryDateStr
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|token
operator|.
name|verifyNoRemainingKeys
argument_list|(
literal|"token"
argument_list|)
expr_stmt|;
name|tbld
operator|.
name|build
argument_list|()
operator|.
name|writeDelimitedTo
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|}
name|expectTagEnd
argument_list|(
name|SECRET_MANAGER_SECTION_NAME
argument_list|)
expr_stmt|;
name|recordSectionLength
argument_list|(
name|SectionName
operator|.
name|SECRET_MANAGER
operator|.
name|name
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|dateStrToLong (String dateStr)
specifier|private
name|long
name|dateStrToLong
parameter_list|(
name|String
name|dateStr
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
name|Date
name|date
init|=
name|isoDateFormat
operator|.
name|parse
argument_list|(
name|dateStr
argument_list|)
decl_stmt|;
return|return
name|date
operator|.
name|getTime
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|ParseException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Failed to parse ISO date string "
operator|+
name|dateStr
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
block|}
DECL|class|CacheManagerSectionProcessor
specifier|private
class|class
name|CacheManagerSectionProcessor
implements|implements
name|SectionProcessor
block|{
DECL|field|NAME
specifier|static
specifier|final
name|String
name|NAME
init|=
literal|"CacheManagerSection"
decl_stmt|;
annotation|@
name|Override
DECL|method|process ()
specifier|public
name|void
name|process
parameter_list|()
throws|throws
name|IOException
block|{
name|Node
name|node
init|=
operator|new
name|Node
argument_list|()
decl_stmt|;
name|loadNodeChildren
argument_list|(
name|node
argument_list|,
literal|"CacheManager fields"
argument_list|,
literal|"pool"
argument_list|,
literal|"directive"
argument_list|)
expr_stmt|;
name|CacheManagerSection
operator|.
name|Builder
name|b
init|=
name|CacheManagerSection
operator|.
name|newBuilder
argument_list|()
decl_stmt|;
name|Long
name|nextDirectiveId
init|=
name|node
operator|.
name|removeChildLong
argument_list|(
name|CACHE_MANAGER_SECTION_NEXT_DIRECTIVE_ID
argument_list|)
decl_stmt|;
if|if
condition|(
name|nextDirectiveId
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"CacheManager section had no<nextDirectiveId>"
argument_list|)
throw|;
block|}
name|b
operator|.
name|setNextDirectiveId
argument_list|(
name|nextDirectiveId
argument_list|)
expr_stmt|;
name|Integer
name|expectedNumPools
init|=
name|node
operator|.
name|removeChildInt
argument_list|(
name|CACHE_MANAGER_SECTION_NUM_POOLS
argument_list|)
decl_stmt|;
if|if
condition|(
name|expectedNumPools
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"CacheManager section had no<numPools>"
argument_list|)
throw|;
block|}
name|b
operator|.
name|setNumPools
argument_list|(
name|expectedNumPools
argument_list|)
expr_stmt|;
name|Integer
name|expectedNumDirectives
init|=
name|node
operator|.
name|removeChildInt
argument_list|(
name|CACHE_MANAGER_SECTION_NUM_DIRECTIVES
argument_list|)
decl_stmt|;
if|if
condition|(
name|expectedNumDirectives
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"CacheManager section had no<numDirectives>"
argument_list|)
throw|;
block|}
name|b
operator|.
name|setNumDirectives
argument_list|(
name|expectedNumDirectives
argument_list|)
expr_stmt|;
name|b
operator|.
name|build
argument_list|()
operator|.
name|writeDelimitedTo
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|long
name|actualNumPools
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|actualNumPools
operator|<
name|expectedNumPools
condition|)
block|{
try|try
block|{
name|expectTag
argument_list|(
name|CACHE_MANAGER_SECTION_POOL
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Only read "
operator|+
name|actualNumPools
operator|+
literal|" cache pools out of "
operator|+
name|expectedNumPools
argument_list|,
name|e
argument_list|)
throw|;
block|}
name|actualNumPools
operator|++
expr_stmt|;
name|Node
name|pool
init|=
operator|new
name|Node
argument_list|()
decl_stmt|;
name|loadNodeChildren
argument_list|(
name|pool
argument_list|,
literal|"pool fields"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|processPoolXml
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
name|long
name|actualNumDirectives
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|actualNumDirectives
operator|<
name|expectedNumDirectives
condition|)
block|{
try|try
block|{
name|expectTag
argument_list|(
name|CACHE_MANAGER_SECTION_DIRECTIVE
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Only read "
operator|+
name|actualNumDirectives
operator|+
literal|" cache pools out of "
operator|+
name|expectedNumDirectives
argument_list|,
name|e
argument_list|)
throw|;
block|}
name|actualNumDirectives
operator|++
expr_stmt|;
name|Node
name|pool
init|=
operator|new
name|Node
argument_list|()
decl_stmt|;
name|loadNodeChildren
argument_list|(
name|pool
argument_list|,
literal|"directive fields"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|processDirectiveXml
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
name|expectTagEnd
argument_list|(
name|CACHE_MANAGER_SECTION_NAME
argument_list|)
expr_stmt|;
name|recordSectionLength
argument_list|(
name|SectionName
operator|.
name|CACHE_MANAGER
operator|.
name|name
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|processPoolXml (Node pool)
specifier|private
name|void
name|processPoolXml
parameter_list|(
name|Node
name|pool
parameter_list|)
throws|throws
name|IOException
block|{
name|CachePoolInfoProto
operator|.
name|Builder
name|bld
init|=
name|CachePoolInfoProto
operator|.
name|newBuilder
argument_list|()
decl_stmt|;
name|String
name|poolName
init|=
name|pool
operator|.
name|removeChildStr
argument_list|(
name|CACHE_MANAGER_SECTION_POOL_NAME
argument_list|)
decl_stmt|;
if|if
condition|(
name|poolName
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"<pool> found without<poolName>"
argument_list|)
throw|;
block|}
name|bld
operator|.
name|setPoolName
argument_list|(
name|poolName
argument_list|)
expr_stmt|;
name|String
name|ownerName
init|=
name|pool
operator|.
name|removeChildStr
argument_list|(
name|CACHE_MANAGER_SECTION_OWNER_NAME
argument_list|)
decl_stmt|;
if|if
condition|(
name|ownerName
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"<pool> found without<ownerName>"
argument_list|)
throw|;
block|}
name|bld
operator|.
name|setOwnerName
argument_list|(
name|ownerName
argument_list|)
expr_stmt|;
name|String
name|groupName
init|=
name|pool
operator|.
name|removeChildStr
argument_list|(
name|CACHE_MANAGER_SECTION_GROUP_NAME
argument_list|)
decl_stmt|;
if|if
condition|(
name|groupName
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"<pool> found without<groupName>"
argument_list|)
throw|;
block|}
name|bld
operator|.
name|setGroupName
argument_list|(
name|groupName
argument_list|)
expr_stmt|;
name|Integer
name|mode
init|=
name|pool
operator|.
name|removeChildInt
argument_list|(
name|CACHE_MANAGER_SECTION_MODE
argument_list|)
decl_stmt|;
if|if
condition|(
name|mode
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"<pool> found without<mode>"
argument_list|)
throw|;
block|}
name|bld
operator|.
name|setMode
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|Long
name|limit
init|=
name|pool
operator|.
name|removeChildLong
argument_list|(
name|CACHE_MANAGER_SECTION_LIMIT
argument_list|)
decl_stmt|;
if|if
condition|(
name|limit
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"<pool> found without<limit>"
argument_list|)
throw|;
block|}
name|bld
operator|.
name|setLimit
argument_list|(
name|limit
argument_list|)
expr_stmt|;
name|Long
name|maxRelativeExpiry
init|=
name|pool
operator|.
name|removeChildLong
argument_list|(
name|CACHE_MANAGER_SECTION_MAX_RELATIVE_EXPIRY
argument_list|)
decl_stmt|;
if|if
condition|(
name|maxRelativeExpiry
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"<pool> found without<maxRelativeExpiry>"
argument_list|)
throw|;
block|}
name|bld
operator|.
name|setMaxRelativeExpiry
argument_list|(
name|maxRelativeExpiry
argument_list|)
expr_stmt|;
name|pool
operator|.
name|verifyNoRemainingKeys
argument_list|(
literal|"pool"
argument_list|)
expr_stmt|;
name|bld
operator|.
name|build
argument_list|()
operator|.
name|writeDelimitedTo
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|}
DECL|method|processDirectiveXml (Node directive)
specifier|private
name|void
name|processDirectiveXml
parameter_list|(
name|Node
name|directive
parameter_list|)
throws|throws
name|IOException
block|{
name|CacheDirectiveInfoProto
operator|.
name|Builder
name|bld
init|=
name|CacheDirectiveInfoProto
operator|.
name|newBuilder
argument_list|()
decl_stmt|;
name|Long
name|id
init|=
name|directive
operator|.
name|removeChildLong
argument_list|(
name|SECTION_ID
argument_list|)
decl_stmt|;
if|if
condition|(
name|id
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"<directive> found without<id>"
argument_list|)
throw|;
block|}
name|bld
operator|.
name|setId
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|String
name|path
init|=
name|directive
operator|.
name|removeChildStr
argument_list|(
name|SECTION_PATH
argument_list|)
decl_stmt|;
if|if
condition|(
name|path
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"<directive> found without<path>"
argument_list|)
throw|;
block|}
name|bld
operator|.
name|setPath
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|Integer
name|replication
init|=
name|directive
operator|.
name|removeChildInt
argument_list|(
name|SECTION_REPLICATION
argument_list|)
decl_stmt|;
if|if
condition|(
name|replication
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"<directive> found without<replication>"
argument_list|)
throw|;
block|}
name|bld
operator|.
name|setReplication
argument_list|(
name|replication
argument_list|)
expr_stmt|;
name|String
name|pool
init|=
name|directive
operator|.
name|removeChildStr
argument_list|(
name|CACHE_MANAGER_SECTION_POOL
argument_list|)
decl_stmt|;
if|if
condition|(
name|path
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"<directive> found without<pool>"
argument_list|)
throw|;
block|}
name|bld
operator|.
name|setPool
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|Node
name|expiration
init|=
name|directive
operator|.
name|removeChild
argument_list|(
name|CACHE_MANAGER_SECTION_EXPIRATION
argument_list|)
decl_stmt|;
if|if
condition|(
name|expiration
operator|!=
literal|null
condition|)
block|{
name|CacheDirectiveInfoExpirationProto
operator|.
name|Builder
name|ebld
init|=
name|CacheDirectiveInfoExpirationProto
operator|.
name|newBuilder
argument_list|()
decl_stmt|;
name|Long
name|millis
init|=
name|expiration
operator|.
name|removeChildLong
argument_list|(
name|CACHE_MANAGER_SECTION_MILLIS
argument_list|)
decl_stmt|;
if|if
condition|(
name|millis
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"cache directive<expiration> found "
operator|+
literal|"without<millis>"
argument_list|)
throw|;
block|}
name|ebld
operator|.
name|setMillis
argument_list|(
name|millis
argument_list|)
expr_stmt|;
if|if
condition|(
name|expiration
operator|.
name|removeChildBool
argument_list|(
name|CACHE_MANAGER_SECTION_RELATIVE
argument_list|)
condition|)
block|{
name|ebld
operator|.
name|setIsRelative
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ebld
operator|.
name|setIsRelative
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
name|bld
operator|.
name|setExpiration
argument_list|(
name|ebld
argument_list|)
expr_stmt|;
block|}
name|directive
operator|.
name|verifyNoRemainingKeys
argument_list|(
literal|"directive"
argument_list|)
expr_stmt|;
name|bld
operator|.
name|build
argument_list|()
operator|.
name|writeDelimitedTo
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|}
block|}
DECL|class|INodeReferenceSectionProcessor
specifier|private
class|class
name|INodeReferenceSectionProcessor
implements|implements
name|SectionProcessor
block|{
DECL|field|NAME
specifier|static
specifier|final
name|String
name|NAME
init|=
literal|"INodeReferenceSection"
decl_stmt|;
annotation|@
name|Override
DECL|method|process ()
specifier|public
name|void
name|process
parameter_list|()
throws|throws
name|IOException
block|{
comment|// There is no header for this section.
comment|// We process the repeated<ref> elements.
while|while
condition|(
literal|true
condition|)
block|{
name|XMLEvent
name|ev
init|=
name|expectTag
argument_list|(
name|INODE_REFERENCE_SECTION_REF
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|ev
operator|.
name|isEndElement
argument_list|()
condition|)
block|{
break|break;
block|}
name|Node
name|inodeRef
init|=
operator|new
name|Node
argument_list|()
decl_stmt|;
name|FsImageProto
operator|.
name|INodeReferenceSection
operator|.
name|INodeReference
operator|.
name|Builder
name|bld
init|=
name|FsImageProto
operator|.
name|INodeReferenceSection
operator|.
name|INodeReference
operator|.
name|newBuilder
argument_list|()
decl_stmt|;
name|loadNodeChildren
argument_list|(
name|inodeRef
argument_list|,
literal|"INodeReference"
argument_list|)
expr_stmt|;
name|Long
name|referredId
init|=
name|inodeRef
operator|.
name|removeChildLong
argument_list|(
name|INODE_REFERENCE_SECTION_REFERRED_ID
argument_list|)
decl_stmt|;
if|if
condition|(
name|referredId
operator|!=
literal|null
condition|)
block|{
name|bld
operator|.
name|setReferredId
argument_list|(
name|referredId
argument_list|)
expr_stmt|;
block|}
name|String
name|name
init|=
name|inodeRef
operator|.
name|removeChildStr
argument_list|(
literal|"name"
argument_list|)
decl_stmt|;
if|if
condition|(
name|name
operator|!=
literal|null
condition|)
block|{
name|bld
operator|.
name|setName
argument_list|(
name|ByteString
operator|.
name|copyFrom
argument_list|(
name|name
argument_list|,
literal|"UTF8"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Integer
name|dstSnapshotId
init|=
name|inodeRef
operator|.
name|removeChildInt
argument_list|(
name|INODE_REFERENCE_SECTION_DST_SNAPSHOT_ID
argument_list|)
decl_stmt|;
if|if
condition|(
name|dstSnapshotId
operator|!=
literal|null
condition|)
block|{
name|bld
operator|.
name|setDstSnapshotId
argument_list|(
name|dstSnapshotId
argument_list|)
expr_stmt|;
block|}
name|Integer
name|lastSnapshotId
init|=
name|inodeRef
operator|.
name|removeChildInt
argument_list|(
name|INODE_REFERENCE_SECTION_LAST_SNAPSHOT_ID
argument_list|)
decl_stmt|;
if|if
condition|(
name|lastSnapshotId
operator|!=
literal|null
condition|)
block|{
name|bld
operator|.
name|setLastSnapshotId
argument_list|(
name|lastSnapshotId
argument_list|)
expr_stmt|;
block|}
name|inodeRef
operator|.
name|verifyNoRemainingKeys
argument_list|(
literal|"ref"
argument_list|)
expr_stmt|;
name|bld
operator|.
name|build
argument_list|()
operator|.
name|writeDelimitedTo
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|}
name|recordSectionLength
argument_list|(
name|SectionName
operator|.
name|INODE_REFERENCE
operator|.
name|name
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|class|INodeDirectorySectionProcessor
specifier|private
class|class
name|INodeDirectorySectionProcessor
implements|implements
name|SectionProcessor
block|{
DECL|field|NAME
specifier|static
specifier|final
name|String
name|NAME
init|=
literal|"INodeDirectorySection"
decl_stmt|;
annotation|@
name|Override
DECL|method|process ()
specifier|public
name|void
name|process
parameter_list|()
throws|throws
name|IOException
block|{
comment|// No header for this section
comment|// Process the repeated<directory> elements.
while|while
condition|(
literal|true
condition|)
block|{
name|XMLEvent
name|ev
init|=
name|expectTag
argument_list|(
name|INODE_DIRECTORY_SECTION_DIRECTORY
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|ev
operator|.
name|isEndElement
argument_list|()
condition|)
block|{
break|break;
block|}
name|Node
name|directory
init|=
operator|new
name|Node
argument_list|()
decl_stmt|;
name|FsImageProto
operator|.
name|INodeDirectorySection
operator|.
name|DirEntry
operator|.
name|Builder
name|bld
init|=
name|FsImageProto
operator|.
name|INodeDirectorySection
operator|.
name|DirEntry
operator|.
name|newBuilder
argument_list|()
decl_stmt|;
name|loadNodeChildren
argument_list|(
name|directory
argument_list|,
literal|"directory"
argument_list|)
expr_stmt|;
name|Long
name|parent
init|=
name|directory
operator|.
name|removeChildLong
argument_list|(
name|INODE_DIRECTORY_SECTION_PARENT
argument_list|)
decl_stmt|;
if|if
condition|(
name|parent
operator|!=
literal|null
condition|)
block|{
name|bld
operator|.
name|setParent
argument_list|(
name|parent
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
literal|true
condition|)
block|{
name|Node
name|child
init|=
name|directory
operator|.
name|removeChild
argument_list|(
name|INODE_DIRECTORY_SECTION_CHILD
argument_list|)
decl_stmt|;
if|if
condition|(
name|child
operator|==
literal|null
condition|)
block|{
break|break;
block|}
name|bld
operator|.
name|addChildren
argument_list|(
name|Long
operator|.
name|parseLong
argument_list|(
name|child
operator|.
name|getVal
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
literal|true
condition|)
block|{
name|Node
name|refChild
init|=
name|directory
operator|.
name|removeChild
argument_list|(
name|INODE_DIRECTORY_SECTION_REF_CHILD
argument_list|)
decl_stmt|;
if|if
condition|(
name|refChild
operator|==
literal|null
condition|)
block|{
break|break;
block|}
name|bld
operator|.
name|addRefChildren
argument_list|(
name|Integer
operator|.
name|parseInt
argument_list|(
name|refChild
operator|.
name|getVal
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|directory
operator|.
name|verifyNoRemainingKeys
argument_list|(
literal|"directory"
argument_list|)
expr_stmt|;
name|bld
operator|.
name|build
argument_list|()
operator|.
name|writeDelimitedTo
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|}
name|recordSectionLength
argument_list|(
name|SectionName
operator|.
name|INODE_DIR
operator|.
name|name
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|class|FilesUnderConstructionSectionProcessor
specifier|private
class|class
name|FilesUnderConstructionSectionProcessor
implements|implements
name|SectionProcessor
block|{
DECL|field|NAME
specifier|static
specifier|final
name|String
name|NAME
init|=
literal|"FileUnderConstructionSection"
decl_stmt|;
annotation|@
name|Override
DECL|method|process ()
specifier|public
name|void
name|process
parameter_list|()
throws|throws
name|IOException
block|{
comment|// No header for this section type.
comment|// Process the repeated files under construction elements.
while|while
condition|(
literal|true
condition|)
block|{
name|XMLEvent
name|ev
init|=
name|expectTag
argument_list|(
name|INODE_SECTION_INODE
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|ev
operator|.
name|isEndElement
argument_list|()
condition|)
block|{
break|break;
block|}
name|Node
name|fileUnderConstruction
init|=
operator|new
name|Node
argument_list|()
decl_stmt|;
name|loadNodeChildren
argument_list|(
name|fileUnderConstruction
argument_list|,
literal|"file under construction"
argument_list|)
expr_stmt|;
name|FileUnderConstructionEntry
operator|.
name|Builder
name|bld
init|=
name|FileUnderConstructionEntry
operator|.
name|newBuilder
argument_list|()
decl_stmt|;
name|Long
name|id
init|=
name|fileUnderConstruction
operator|.
name|removeChildLong
argument_list|(
name|SECTION_ID
argument_list|)
decl_stmt|;
if|if
condition|(
name|id
operator|!=
literal|null
condition|)
block|{
name|bld
operator|.
name|setInodeId
argument_list|(
name|id
argument_list|)
expr_stmt|;
block|}
name|String
name|fullpath
init|=
name|fileUnderConstruction
operator|.
name|removeChildStr
argument_list|(
name|SECTION_PATH
argument_list|)
decl_stmt|;
if|if
condition|(
name|fullpath
operator|!=
literal|null
condition|)
block|{
name|bld
operator|.
name|setFullPath
argument_list|(
name|fullpath
argument_list|)
expr_stmt|;
block|}
name|fileUnderConstruction
operator|.
name|verifyNoRemainingKeys
argument_list|(
literal|"inode"
argument_list|)
expr_stmt|;
name|bld
operator|.
name|build
argument_list|()
operator|.
name|writeDelimitedTo
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|}
name|recordSectionLength
argument_list|(
name|SectionName
operator|.
name|FILES_UNDERCONSTRUCTION
operator|.
name|name
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|class|SnapshotSectionProcessor
specifier|private
class|class
name|SnapshotSectionProcessor
implements|implements
name|SectionProcessor
block|{
DECL|field|NAME
specifier|static
specifier|final
name|String
name|NAME
init|=
literal|"SnapshotSection"
decl_stmt|;
annotation|@
name|Override
DECL|method|process ()
specifier|public
name|void
name|process
parameter_list|()
throws|throws
name|IOException
block|{
name|FsImageProto
operator|.
name|SnapshotSection
operator|.
name|Builder
name|bld
init|=
name|FsImageProto
operator|.
name|SnapshotSection
operator|.
name|newBuilder
argument_list|()
decl_stmt|;
name|Node
name|header
init|=
operator|new
name|Node
argument_list|()
decl_stmt|;
name|loadNodeChildren
argument_list|(
name|header
argument_list|,
literal|"SnapshotSection fields"
argument_list|,
literal|"snapshot"
argument_list|)
expr_stmt|;
name|Integer
name|snapshotCounter
init|=
name|header
operator|.
name|removeChildInt
argument_list|(
name|SNAPSHOT_SECTION_SNAPSHOT_COUNTER
argument_list|)
decl_stmt|;
if|if
condition|(
name|snapshotCounter
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"No<snapshotCounter> entry found in "
operator|+
literal|"SnapshotSection header"
argument_list|)
throw|;
block|}
name|bld
operator|.
name|setSnapshotCounter
argument_list|(
name|snapshotCounter
argument_list|)
expr_stmt|;
name|Integer
name|expectedNumSnapshots
init|=
name|header
operator|.
name|removeChildInt
argument_list|(
name|SNAPSHOT_SECTION_NUM_SNAPSHOTS
argument_list|)
decl_stmt|;
if|if
condition|(
name|expectedNumSnapshots
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"No<numSnapshots> entry found in "
operator|+
literal|"SnapshotSection header"
argument_list|)
throw|;
block|}
name|bld
operator|.
name|setNumSnapshots
argument_list|(
name|expectedNumSnapshots
argument_list|)
expr_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|Node
name|sd
init|=
name|header
operator|.
name|removeChild
argument_list|(
name|SNAPSHOT_SECTION_SNAPSHOT_TABLE_DIR
argument_list|)
decl_stmt|;
if|if
condition|(
name|sd
operator|==
literal|null
condition|)
block|{
break|break;
block|}
name|Long
name|dir
init|=
name|sd
operator|.
name|removeChildLong
argument_list|(
name|SNAPSHOT_SECTION_DIR
argument_list|)
decl_stmt|;
name|sd
operator|.
name|verifyNoRemainingKeys
argument_list|(
literal|"<dir>"
argument_list|)
expr_stmt|;
name|bld
operator|.
name|addSnapshottableDir
argument_list|(
name|dir
argument_list|)
expr_stmt|;
block|}
name|header
operator|.
name|verifyNoRemainingKeys
argument_list|(
literal|"SnapshotSection"
argument_list|)
expr_stmt|;
name|bld
operator|.
name|build
argument_list|()
operator|.
name|writeDelimitedTo
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|int
name|actualNumSnapshots
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|actualNumSnapshots
operator|<
name|expectedNumSnapshots
condition|)
block|{
try|try
block|{
name|expectTag
argument_list|(
name|SNAPSHOT_SECTION_SNAPSHOT
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Only read "
operator|+
name|actualNumSnapshots
operator|+
literal|"<snapshot> entries out of "
operator|+
name|expectedNumSnapshots
argument_list|,
name|e
argument_list|)
throw|;
block|}
name|actualNumSnapshots
operator|++
expr_stmt|;
name|Node
name|snapshot
init|=
operator|new
name|Node
argument_list|()
decl_stmt|;
name|loadNodeChildren
argument_list|(
name|snapshot
argument_list|,
literal|"snapshot fields"
argument_list|)
expr_stmt|;
name|FsImageProto
operator|.
name|SnapshotSection
operator|.
name|Snapshot
operator|.
name|Builder
name|s
init|=
name|FsImageProto
operator|.
name|SnapshotSection
operator|.
name|Snapshot
operator|.
name|newBuilder
argument_list|()
decl_stmt|;
name|Integer
name|snapshotId
init|=
name|snapshot
operator|.
name|removeChildInt
argument_list|(
name|SECTION_ID
argument_list|)
decl_stmt|;
if|if
condition|(
name|snapshotId
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"<snapshot> section was missing<id>"
argument_list|)
throw|;
block|}
name|s
operator|.
name|setSnapshotId
argument_list|(
name|snapshotId
argument_list|)
expr_stmt|;
name|Node
name|snapshotRoot
init|=
name|snapshot
operator|.
name|removeChild
argument_list|(
name|SNAPSHOT_SECTION_ROOT
argument_list|)
decl_stmt|;
name|INodeSection
operator|.
name|INode
operator|.
name|Builder
name|inodeBld
init|=
name|processINodeXml
argument_list|(
name|snapshotRoot
argument_list|)
decl_stmt|;
name|s
operator|.
name|setRoot
argument_list|(
name|inodeBld
argument_list|)
expr_stmt|;
name|s
operator|.
name|build
argument_list|()
operator|.
name|writeDelimitedTo
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|}
name|expectTagEnd
argument_list|(
name|SNAPSHOT_SECTION_NAME
argument_list|)
expr_stmt|;
name|recordSectionLength
argument_list|(
name|SectionName
operator|.
name|SNAPSHOT
operator|.
name|name
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|class|SnapshotDiffSectionProcessor
specifier|private
class|class
name|SnapshotDiffSectionProcessor
implements|implements
name|SectionProcessor
block|{
DECL|field|NAME
specifier|static
specifier|final
name|String
name|NAME
init|=
literal|"SnapshotDiffSection"
decl_stmt|;
annotation|@
name|Override
DECL|method|process ()
specifier|public
name|void
name|process
parameter_list|()
throws|throws
name|IOException
block|{
comment|// No header for this section type.
name|LOG
operator|.
name|debug
argument_list|(
literal|"Processing SnapshotDiffSection"
argument_list|)
expr_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|XMLEvent
name|ev
init|=
name|expectTag
argument_list|(
literal|"[diff start tag]"
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|ev
operator|.
name|isEndElement
argument_list|()
condition|)
block|{
name|String
name|name
init|=
name|ev
operator|.
name|asEndElement
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|getLocalPart
argument_list|()
decl_stmt|;
if|if
condition|(
name|name
operator|.
name|equals
argument_list|(
name|SNAPSHOT_DIFF_SECTION_NAME
argument_list|)
condition|)
block|{
break|break;
block|}
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Got unexpected end tag for "
operator|+
name|name
argument_list|)
throw|;
block|}
name|String
name|tagName
init|=
name|ev
operator|.
name|asStartElement
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|getLocalPart
argument_list|()
decl_stmt|;
if|if
condition|(
name|tagName
operator|.
name|equals
argument_list|(
name|SNAPSHOT_DIFF_SECTION_DIR_DIFF_ENTRY
argument_list|)
condition|)
block|{
name|processDirDiffEntry
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tagName
operator|.
name|equals
argument_list|(
name|SNAPSHOT_DIFF_SECTION_FILE_DIFF_ENTRY
argument_list|)
condition|)
block|{
name|processFileDiffEntry
argument_list|()
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"SnapshotDiffSection contained unexpected "
operator|+
literal|"tag "
operator|+
name|tagName
argument_list|)
throw|;
block|}
block|}
name|recordSectionLength
argument_list|(
name|SectionName
operator|.
name|SNAPSHOT_DIFF
operator|.
name|name
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|processDirDiffEntry ()
specifier|private
name|void
name|processDirDiffEntry
parameter_list|()
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Processing dirDiffEntry"
argument_list|)
expr_stmt|;
name|DiffEntry
operator|.
name|Builder
name|headerBld
init|=
name|DiffEntry
operator|.
name|newBuilder
argument_list|()
decl_stmt|;
name|headerBld
operator|.
name|setType
argument_list|(
name|DiffEntry
operator|.
name|Type
operator|.
name|DIRECTORYDIFF
argument_list|)
expr_stmt|;
name|Node
name|dirDiffHeader
init|=
operator|new
name|Node
argument_list|()
decl_stmt|;
name|loadNodeChildren
argument_list|(
name|dirDiffHeader
argument_list|,
literal|"dirDiffEntry fields"
argument_list|,
literal|"dirDiff"
argument_list|)
expr_stmt|;
name|Long
name|inodeId
init|=
name|dirDiffHeader
operator|.
name|removeChildLong
argument_list|(
name|SNAPSHOT_DIFF_SECTION_INODE_ID
argument_list|)
decl_stmt|;
if|if
condition|(
name|inodeId
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"<dirDiffEntry> contained no<inodeId> entry."
argument_list|)
throw|;
block|}
name|headerBld
operator|.
name|setInodeId
argument_list|(
name|inodeId
argument_list|)
expr_stmt|;
name|Integer
name|expectedDiffs
init|=
name|dirDiffHeader
operator|.
name|removeChildInt
argument_list|(
name|SNAPSHOT_DIFF_SECTION_COUNT
argument_list|)
decl_stmt|;
if|if
condition|(
name|expectedDiffs
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"<dirDiffEntry> contained no<count> entry."
argument_list|)
throw|;
block|}
name|headerBld
operator|.
name|setNumOfDiff
argument_list|(
name|expectedDiffs
argument_list|)
expr_stmt|;
name|dirDiffHeader
operator|.
name|verifyNoRemainingKeys
argument_list|(
literal|"dirDiffEntry"
argument_list|)
expr_stmt|;
name|headerBld
operator|.
name|build
argument_list|()
operator|.
name|writeDelimitedTo
argument_list|(
name|out
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|actualDiffs
init|=
literal|0
init|;
name|actualDiffs
operator|<
name|expectedDiffs
condition|;
name|actualDiffs
operator|++
control|)
block|{
try|try
block|{
name|expectTag
argument_list|(
name|SNAPSHOT_DIFF_SECTION_DIR_DIFF
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Only read "
operator|+
operator|(
name|actualDiffs
operator|+
literal|1
operator|)
operator|+
literal|" diffs out of "
operator|+
name|expectedDiffs
argument_list|,
name|e
argument_list|)
throw|;
block|}
name|Node
name|dirDiff
init|=
operator|new
name|Node
argument_list|()
decl_stmt|;
name|loadNodeChildren
argument_list|(
name|dirDiff
argument_list|,
literal|"dirDiff fields"
argument_list|)
expr_stmt|;
name|FsImageProto
operator|.
name|SnapshotDiffSection
operator|.
name|DirectoryDiff
operator|.
name|Builder
name|bld
init|=
name|FsImageProto
operator|.
name|SnapshotDiffSection
operator|.
name|DirectoryDiff
operator|.
name|newBuilder
argument_list|()
decl_stmt|;
name|Integer
name|snapshotId
init|=
name|dirDiff
operator|.
name|removeChildInt
argument_list|(
name|SNAPSHOT_DIFF_SECTION_SNAPSHOT_ID
argument_list|)
decl_stmt|;
if|if
condition|(
name|snapshotId
operator|!=
literal|null
condition|)
block|{
name|bld
operator|.
name|setSnapshotId
argument_list|(
name|snapshotId
argument_list|)
expr_stmt|;
block|}
name|Integer
name|childrenSize
init|=
name|dirDiff
operator|.
name|removeChildInt
argument_list|(
name|SNAPSHOT_DIFF_SECTION_CHILDREN_SIZE
argument_list|)
decl_stmt|;
if|if
condition|(
name|childrenSize
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Expected to find<childrenSize> in "
operator|+
literal|"<dirDiff> section."
argument_list|)
throw|;
block|}
name|bld
operator|.
name|setIsSnapshotRoot
argument_list|(
name|dirDiff
operator|.
name|removeChildBool
argument_list|(
name|SNAPSHOT_DIFF_SECTION_IS_SNAPSHOT_ROOT
argument_list|)
argument_list|)
expr_stmt|;
name|bld
operator|.
name|setChildrenSize
argument_list|(
name|childrenSize
argument_list|)
expr_stmt|;
name|String
name|name
init|=
name|dirDiff
operator|.
name|removeChildStr
argument_list|(
name|SECTION_NAME
argument_list|)
decl_stmt|;
if|if
condition|(
name|name
operator|!=
literal|null
condition|)
block|{
name|bld
operator|.
name|setName
argument_list|(
name|ByteString
operator|.
name|copyFrom
argument_list|(
name|name
argument_list|,
literal|"UTF8"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Node
name|snapshotCopy
init|=
name|dirDiff
operator|.
name|removeChild
argument_list|(
name|SNAPSHOT_DIFF_SECTION_SNAPSHOT_COPY
argument_list|)
decl_stmt|;
if|if
condition|(
name|snapshotCopy
operator|!=
literal|null
condition|)
block|{
name|bld
operator|.
name|setSnapshotCopy
argument_list|(
name|createINodeDirectoryBuilder
argument_list|(
name|snapshotCopy
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Integer
name|expectedCreatedListSize
init|=
name|dirDiff
operator|.
name|removeChildInt
argument_list|(
name|SNAPSHOT_DIFF_SECTION_CREATED_LIST_SIZE
argument_list|)
decl_stmt|;
if|if
condition|(
name|expectedCreatedListSize
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Expected to find<createdListSize> in "
operator|+
literal|"<dirDiff> section."
argument_list|)
throw|;
block|}
name|bld
operator|.
name|setCreatedListSize
argument_list|(
name|expectedCreatedListSize
argument_list|)
expr_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|Node
name|deleted
init|=
name|dirDiff
operator|.
name|removeChild
argument_list|(
name|SNAPSHOT_DIFF_SECTION_DELETED_INODE
argument_list|)
decl_stmt|;
if|if
condition|(
name|deleted
operator|==
literal|null
condition|)
block|{
break|break;
block|}
name|bld
operator|.
name|addDeletedINode
argument_list|(
name|Long
operator|.
name|parseLong
argument_list|(
name|deleted
operator|.
name|getVal
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
literal|true
condition|)
block|{
name|Node
name|deleted
init|=
name|dirDiff
operator|.
name|removeChild
argument_list|(
name|SNAPSHOT_DIFF_SECTION_DELETED_INODE_REF
argument_list|)
decl_stmt|;
if|if
condition|(
name|deleted
operator|==
literal|null
condition|)
block|{
break|break;
block|}
name|bld
operator|.
name|addDeletedINodeRef
argument_list|(
name|Integer
operator|.
name|parseInt
argument_list|(
name|deleted
operator|.
name|getVal
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|bld
operator|.
name|build
argument_list|()
operator|.
name|writeDelimitedTo
argument_list|(
name|out
argument_list|)
expr_stmt|;
comment|// After the DirectoryDiff header comes a list of CreatedListEntry PBs.
name|int
name|actualCreatedListSize
init|=
literal|0
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|Node
name|created
init|=
name|dirDiff
operator|.
name|removeChild
argument_list|(
name|SNAPSHOT_DIFF_SECTION_CREATED
argument_list|)
decl_stmt|;
if|if
condition|(
name|created
operator|==
literal|null
condition|)
block|{
break|break;
block|}
name|String
name|cleName
init|=
name|created
operator|.
name|removeChildStr
argument_list|(
name|SECTION_NAME
argument_list|)
decl_stmt|;
if|if
condition|(
name|cleName
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Expected<created> entry to have "
operator|+
literal|"a<name> field"
argument_list|)
throw|;
block|}
name|created
operator|.
name|verifyNoRemainingKeys
argument_list|(
literal|"created"
argument_list|)
expr_stmt|;
name|FsImageProto
operator|.
name|SnapshotDiffSection
operator|.
name|CreatedListEntry
operator|.
name|newBuilder
argument_list|()
operator|.
name|setName
argument_list|(
name|ByteString
operator|.
name|copyFrom
argument_list|(
name|cleName
argument_list|,
literal|"UTF8"
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
operator|.
name|writeDelimitedTo
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|actualCreatedListSize
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|actualCreatedListSize
operator|!=
name|expectedCreatedListSize
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"<createdListSize> was "
operator|+
name|expectedCreatedListSize
operator|+
literal|", but there were "
operator|+
name|actualCreatedListSize
operator|+
literal|"<created> entries."
argument_list|)
throw|;
block|}
name|dirDiff
operator|.
name|verifyNoRemainingKeys
argument_list|(
literal|"dirDiff"
argument_list|)
expr_stmt|;
block|}
name|expectTagEnd
argument_list|(
name|SNAPSHOT_DIFF_SECTION_DIR_DIFF_ENTRY
argument_list|)
expr_stmt|;
block|}
DECL|method|processFileDiffEntry ()
specifier|private
name|void
name|processFileDiffEntry
parameter_list|()
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Processing fileDiffEntry"
argument_list|)
expr_stmt|;
name|DiffEntry
operator|.
name|Builder
name|headerBld
init|=
name|DiffEntry
operator|.
name|newBuilder
argument_list|()
decl_stmt|;
name|headerBld
operator|.
name|setType
argument_list|(
name|DiffEntry
operator|.
name|Type
operator|.
name|FILEDIFF
argument_list|)
expr_stmt|;
name|Node
name|fileDiffHeader
init|=
operator|new
name|Node
argument_list|()
decl_stmt|;
name|loadNodeChildren
argument_list|(
name|fileDiffHeader
argument_list|,
literal|"fileDiffEntry fields"
argument_list|,
literal|"fileDiff"
argument_list|)
expr_stmt|;
name|Long
name|inodeId
init|=
name|fileDiffHeader
operator|.
name|removeChildLong
argument_list|(
name|SNAPSHOT_DIFF_SECTION_INODE_ID
argument_list|)
decl_stmt|;
if|if
condition|(
name|inodeId
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"<fileDiffEntry> contained no<inodeid> entry."
argument_list|)
throw|;
block|}
name|headerBld
operator|.
name|setInodeId
argument_list|(
name|inodeId
argument_list|)
expr_stmt|;
name|Integer
name|expectedDiffs
init|=
name|fileDiffHeader
operator|.
name|removeChildInt
argument_list|(
name|SNAPSHOT_DIFF_SECTION_COUNT
argument_list|)
decl_stmt|;
if|if
condition|(
name|expectedDiffs
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"<fileDiffEntry> contained no<count> entry."
argument_list|)
throw|;
block|}
name|headerBld
operator|.
name|setNumOfDiff
argument_list|(
name|expectedDiffs
argument_list|)
expr_stmt|;
name|fileDiffHeader
operator|.
name|verifyNoRemainingKeys
argument_list|(
literal|"fileDiffEntry"
argument_list|)
expr_stmt|;
name|headerBld
operator|.
name|build
argument_list|()
operator|.
name|writeDelimitedTo
argument_list|(
name|out
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|actualDiffs
init|=
literal|0
init|;
name|actualDiffs
operator|<
name|expectedDiffs
condition|;
name|actualDiffs
operator|++
control|)
block|{
try|try
block|{
name|expectTag
argument_list|(
name|SNAPSHOT_DIFF_SECTION_FILE_DIFF
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Only read "
operator|+
operator|(
name|actualDiffs
operator|+
literal|1
operator|)
operator|+
literal|" diffs out of "
operator|+
name|expectedDiffs
argument_list|,
name|e
argument_list|)
throw|;
block|}
name|Node
name|fileDiff
init|=
operator|new
name|Node
argument_list|()
decl_stmt|;
name|loadNodeChildren
argument_list|(
name|fileDiff
argument_list|,
literal|"fileDiff fields"
argument_list|)
expr_stmt|;
name|FsImageProto
operator|.
name|SnapshotDiffSection
operator|.
name|FileDiff
operator|.
name|Builder
name|bld
init|=
name|FsImageProto
operator|.
name|SnapshotDiffSection
operator|.
name|FileDiff
operator|.
name|newBuilder
argument_list|()
decl_stmt|;
name|Integer
name|snapshotId
init|=
name|fileDiff
operator|.
name|removeChildInt
argument_list|(
name|SNAPSHOT_DIFF_SECTION_SNAPSHOT_ID
argument_list|)
decl_stmt|;
if|if
condition|(
name|snapshotId
operator|!=
literal|null
condition|)
block|{
name|bld
operator|.
name|setSnapshotId
argument_list|(
name|snapshotId
argument_list|)
expr_stmt|;
block|}
name|Long
name|size
init|=
name|fileDiff
operator|.
name|removeChildLong
argument_list|(
name|SNAPSHOT_DIFF_SECTION_SIZE
argument_list|)
decl_stmt|;
if|if
condition|(
name|size
operator|!=
literal|null
condition|)
block|{
name|bld
operator|.
name|setFileSize
argument_list|(
name|size
argument_list|)
expr_stmt|;
block|}
name|String
name|name
init|=
name|fileDiff
operator|.
name|removeChildStr
argument_list|(
name|SECTION_NAME
argument_list|)
decl_stmt|;
if|if
condition|(
name|name
operator|!=
literal|null
condition|)
block|{
name|bld
operator|.
name|setName
argument_list|(
name|ByteString
operator|.
name|copyFrom
argument_list|(
name|name
argument_list|,
literal|"UTF8"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Node
name|snapshotCopy
init|=
name|fileDiff
operator|.
name|removeChild
argument_list|(
name|SNAPSHOT_DIFF_SECTION_SNAPSHOT_COPY
argument_list|)
decl_stmt|;
if|if
condition|(
name|snapshotCopy
operator|!=
literal|null
condition|)
block|{
name|bld
operator|.
name|setSnapshotCopy
argument_list|(
name|createINodeFileBuilder
argument_list|(
name|snapshotCopy
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Node
name|blocks
init|=
name|fileDiff
operator|.
name|removeChild
argument_list|(
name|INODE_SECTION_BLOCKS
argument_list|)
decl_stmt|;
if|if
condition|(
name|blocks
operator|!=
literal|null
condition|)
block|{
while|while
condition|(
literal|true
condition|)
block|{
name|Node
name|block
init|=
name|blocks
operator|.
name|removeChild
argument_list|(
name|INODE_SECTION_BLOCK
argument_list|)
decl_stmt|;
if|if
condition|(
name|block
operator|==
literal|null
condition|)
block|{
break|break;
block|}
name|bld
operator|.
name|addBlocks
argument_list|(
name|createBlockBuilder
argument_list|(
name|block
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|fileDiff
operator|.
name|verifyNoRemainingKeys
argument_list|(
literal|"fileDiff"
argument_list|)
expr_stmt|;
name|bld
operator|.
name|build
argument_list|()
operator|.
name|writeDelimitedTo
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|}
name|expectTagEnd
argument_list|(
name|SNAPSHOT_DIFF_SECTION_FILE_DIFF_ENTRY
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Permission is serialized as a 64-bit long. [0:24):[25:48):[48:64)    * (in Big Endian).  The first and the second parts are the string ids    * of the user and group name, and the last 16 bits are the permission bits.    *    * @param perm           The permission string from the XML.    * @return               The 64-bit value to use in the fsimage for permission.    * @throws IOException   If we run out of string IDs in the string table.    */
DECL|method|permissionXmlToU64 (String perm)
specifier|private
name|long
name|permissionXmlToU64
parameter_list|(
name|String
name|perm
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|components
index|[]
init|=
name|perm
operator|.
name|split
argument_list|(
literal|":"
argument_list|)
decl_stmt|;
if|if
condition|(
name|components
operator|.
name|length
operator|!=
literal|3
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unable to parse permission string "
operator|+
name|perm
operator|+
literal|": expected 3 components, but only had "
operator|+
name|components
operator|.
name|length
argument_list|)
throw|;
block|}
name|String
name|userName
init|=
name|components
index|[
literal|0
index|]
decl_stmt|;
name|String
name|groupName
init|=
name|components
index|[
literal|1
index|]
decl_stmt|;
name|String
name|modeString
init|=
name|components
index|[
literal|2
index|]
decl_stmt|;
name|long
name|userNameId
init|=
name|registerStringId
argument_list|(
name|userName
argument_list|)
decl_stmt|;
name|long
name|groupNameId
init|=
name|registerStringId
argument_list|(
name|groupName
argument_list|)
decl_stmt|;
name|long
name|mode
init|=
operator|new
name|FsPermission
argument_list|(
name|modeString
argument_list|)
operator|.
name|toShort
argument_list|()
decl_stmt|;
return|return
operator|(
name|userNameId
operator|<<
literal|40
operator|)
operator||
operator|(
name|groupNameId
operator|<<
literal|16
operator|)
operator||
name|mode
return|;
block|}
comment|/**    * The FSImage contains a string table which maps strings to IDs.    * This is a simple form of compression which takes advantage of the fact    * that the same strings tend to occur over and over again.    * This function will return an ID which we can use to represent the given    * string.  If the string already exists in the string table, we will use    * that ID; otherwise, we will allocate a new one.    *    * @param str           The string.    * @return              The ID in the string table.    * @throws IOException  If we run out of bits in the string table.  We only    *                      have 25 bits.    */
DECL|method|registerStringId (String str)
name|int
name|registerStringId
parameter_list|(
name|String
name|str
parameter_list|)
throws|throws
name|IOException
block|{
name|Integer
name|id
init|=
name|stringTable
operator|.
name|get
argument_list|(
name|str
argument_list|)
decl_stmt|;
if|if
condition|(
name|id
operator|!=
literal|null
condition|)
block|{
return|return
name|id
return|;
block|}
name|int
name|latestId
init|=
name|latestStringId
decl_stmt|;
if|if
condition|(
name|latestId
operator|>=
literal|0x1ffffff
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Cannot have more than 2**25 "
operator|+
literal|"strings in the fsimage, because of the limitation on "
operator|+
literal|"the size of string table IDs."
argument_list|)
throw|;
block|}
name|stringTable
operator|.
name|put
argument_list|(
name|str
argument_list|,
name|latestId
argument_list|)
expr_stmt|;
name|latestStringId
operator|++
expr_stmt|;
return|return
name|latestId
return|;
block|}
comment|/**    * Record the length of a section of the FSImage in our FileSummary object.    * The FileSummary appears at the end of the FSImage and acts as a table of    * contents for the file.    *    * @param sectionNamePb  The name of the section as it should appear in    *                       the fsimage.  (This is different than the XML    *                       name.)    * @throws IOException    */
DECL|method|recordSectionLength (String sectionNamePb)
name|void
name|recordSectionLength
parameter_list|(
name|String
name|sectionNamePb
parameter_list|)
throws|throws
name|IOException
block|{
name|long
name|curSectionStartOffset
init|=
name|sectionStartOffset
decl_stmt|;
name|long
name|curPos
init|=
name|out
operator|.
name|getCount
argument_list|()
decl_stmt|;
comment|//if (sectionNamePb.equals(SectionName.STRING_TABLE.name())) {
name|fileSummaryBld
operator|.
name|addSections
argument_list|(
name|FileSummary
operator|.
name|Section
operator|.
name|newBuilder
argument_list|()
operator|.
name|setName
argument_list|(
name|sectionNamePb
argument_list|)
operator|.
name|setLength
argument_list|(
name|curPos
operator|-
name|curSectionStartOffset
argument_list|)
operator|.
name|setOffset
argument_list|(
name|curSectionStartOffset
argument_list|)
argument_list|)
expr_stmt|;
comment|//}
name|sectionStartOffset
operator|=
name|curPos
expr_stmt|;
block|}
comment|/**    * Read the version tag which starts the XML file.    */
DECL|method|readVersion ()
specifier|private
name|void
name|readVersion
parameter_list|()
throws|throws
name|IOException
block|{
try|try
block|{
name|expectTag
argument_list|(
literal|"version"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// Handle the case where<version> does not exist.
comment|// Note: fsimage XML files which are missing<version> are also missing
comment|// many other fields that ovi needs to accurately reconstruct the
comment|// fsimage.
throw|throw
operator|new
name|IOException
argument_list|(
literal|"No<version> section found at the top of "
operator|+
literal|"the fsimage XML.  This XML file is too old to be processed "
operator|+
literal|"by ovi."
argument_list|,
name|e
argument_list|)
throw|;
block|}
name|Node
name|version
init|=
operator|new
name|Node
argument_list|()
decl_stmt|;
name|loadNodeChildren
argument_list|(
name|version
argument_list|,
literal|"version fields"
argument_list|)
expr_stmt|;
name|Integer
name|onDiskVersion
init|=
name|version
operator|.
name|removeChildInt
argument_list|(
literal|"onDiskVersion"
argument_list|)
decl_stmt|;
if|if
condition|(
name|onDiskVersion
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"The<version> section doesn't contain "
operator|+
literal|"the onDiskVersion."
argument_list|)
throw|;
block|}
name|Integer
name|layoutVersion
init|=
name|version
operator|.
name|removeChildInt
argument_list|(
literal|"layoutVersion"
argument_list|)
decl_stmt|;
if|if
condition|(
name|layoutVersion
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"The<version> section doesn't contain "
operator|+
literal|"the layoutVersion."
argument_list|)
throw|;
block|}
if|if
condition|(
name|layoutVersion
operator|.
name|intValue
argument_list|()
operator|!=
name|NameNodeLayoutVersion
operator|.
name|CURRENT_LAYOUT_VERSION
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Layout version mismatch.  This oiv tool "
operator|+
literal|"handles layout version "
operator|+
name|NameNodeLayoutVersion
operator|.
name|CURRENT_LAYOUT_VERSION
operator|+
literal|", but the "
operator|+
literal|"XML file has<layoutVersion> "
operator|+
name|layoutVersion
operator|+
literal|".  Please "
operator|+
literal|"either re-generate the XML file with the proper layout version, "
operator|+
literal|"or manually edit the XML file to be usable with this version "
operator|+
literal|"of the oiv tool."
argument_list|)
throw|;
block|}
name|fileSummaryBld
operator|.
name|setOndiskVersion
argument_list|(
name|onDiskVersion
argument_list|)
expr_stmt|;
name|fileSummaryBld
operator|.
name|setLayoutVersion
argument_list|(
name|layoutVersion
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Loaded<version> with onDiskVersion="
operator|+
name|onDiskVersion
operator|+
literal|", layoutVersion="
operator|+
name|layoutVersion
operator|+
literal|"."
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Write the string table to the fsimage.    * @throws IOException    */
DECL|method|writeStringTableSection ()
specifier|private
name|void
name|writeStringTableSection
parameter_list|()
throws|throws
name|IOException
block|{
name|FsImageProto
operator|.
name|StringTableSection
name|sectionHeader
init|=
name|FsImageProto
operator|.
name|StringTableSection
operator|.
name|newBuilder
argument_list|()
operator|.
name|setNumEntry
argument_list|(
name|stringTable
operator|.
name|size
argument_list|()
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|SectionName
operator|.
name|STRING_TABLE
operator|.
name|name
argument_list|()
operator|+
literal|" writing header: {"
operator|+
name|TextFormat
operator|.
name|printToString
argument_list|(
name|sectionHeader
argument_list|)
operator|+
literal|"}"
argument_list|)
expr_stmt|;
block|}
name|sectionHeader
operator|.
name|writeDelimitedTo
argument_list|(
name|out
argument_list|)
expr_stmt|;
comment|// The entries don't have to be in any particular order, so iterating
comment|// over the hash table is fine.
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|entry
range|:
name|stringTable
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|FsImageProto
operator|.
name|StringTableSection
operator|.
name|Entry
name|stEntry
init|=
name|FsImageProto
operator|.
name|StringTableSection
operator|.
name|Entry
operator|.
name|newBuilder
argument_list|()
operator|.
name|setStr
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
operator|.
name|setId
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Writing string table entry: {"
operator|+
name|TextFormat
operator|.
name|printToString
argument_list|(
name|stEntry
argument_list|)
operator|+
literal|"}"
argument_list|)
expr_stmt|;
block|}
name|stEntry
operator|.
name|writeDelimitedTo
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|}
name|recordSectionLength
argument_list|(
name|SectionName
operator|.
name|STRING_TABLE
operator|.
name|name
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Processes the XML file back into an fsimage.    */
DECL|method|processXml ()
specifier|private
name|void
name|processXml
parameter_list|()
throws|throws
name|Exception
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Loading<fsimage>."
argument_list|)
expr_stmt|;
name|expectTag
argument_list|(
literal|"fsimage"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
comment|// Read the<version> tag.
name|readVersion
argument_list|()
expr_stmt|;
comment|// Write the HDFSIMG1 magic number which begins the fsimage file.
name|out
operator|.
name|write
argument_list|(
name|FSImageUtil
operator|.
name|MAGIC_HEADER
argument_list|)
expr_stmt|;
comment|// Write a series of fsimage sections.
name|sectionStartOffset
operator|=
name|FSImageUtil
operator|.
name|MAGIC_HEADER
operator|.
name|length
expr_stmt|;
specifier|final
name|HashSet
argument_list|<
name|String
argument_list|>
name|unprocessedSections
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|(
name|sections
operator|.
name|keySet
argument_list|()
argument_list|)
decl_stmt|;
while|while
condition|(
operator|!
name|unprocessedSections
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|XMLEvent
name|ev
init|=
name|expectTag
argument_list|(
literal|"[section header]"
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|ev
operator|.
name|getEventType
argument_list|()
operator|==
name|XMLStreamConstants
operator|.
name|END_ELEMENT
condition|)
block|{
if|if
condition|(
name|ev
operator|.
name|asEndElement
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|getLocalPart
argument_list|()
operator|.
name|equals
argument_list|(
literal|"fsimage"
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"FSImage XML ended prematurely, without "
operator|+
literal|"including section(s) "
operator|+
name|StringUtils
operator|.
name|join
argument_list|(
literal|", "
argument_list|,
name|unprocessedSections
argument_list|)
argument_list|)
throw|;
block|}
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Got unexpected tag end event for "
operator|+
name|ev
operator|.
name|asEndElement
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|getLocalPart
argument_list|()
operator|+
literal|" while looking "
operator|+
literal|"for section header tag."
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|ev
operator|.
name|getEventType
argument_list|()
operator|!=
name|XMLStreamConstants
operator|.
name|START_ELEMENT
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Expected section header START_ELEMENT; "
operator|+
literal|"got event of type "
operator|+
name|ev
operator|.
name|getEventType
argument_list|()
argument_list|)
throw|;
block|}
name|String
name|sectionName
init|=
name|ev
operator|.
name|asStartElement
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|getLocalPart
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|unprocessedSections
operator|.
name|contains
argument_list|(
name|sectionName
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unknown or duplicate section found for "
operator|+
name|sectionName
argument_list|)
throw|;
block|}
name|SectionProcessor
name|sectionProcessor
init|=
name|sections
operator|.
name|get
argument_list|(
name|sectionName
argument_list|)
decl_stmt|;
if|if
condition|(
name|sectionProcessor
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unknown FSImage section "
operator|+
name|sectionName
operator|+
literal|".  Valid section names are ["
operator|+
name|StringUtils
operator|.
name|join
argument_list|(
literal|", "
argument_list|,
name|sections
operator|.
name|keySet
argument_list|()
argument_list|)
operator|+
literal|"]"
argument_list|)
throw|;
block|}
name|unprocessedSections
operator|.
name|remove
argument_list|(
name|sectionName
argument_list|)
expr_stmt|;
name|sectionProcessor
operator|.
name|process
argument_list|()
expr_stmt|;
block|}
comment|// Write the StringTable section to disk.
comment|// This has to be done after the other sections, since some of them
comment|// add entries to the string table.
name|writeStringTableSection
argument_list|()
expr_stmt|;
comment|// Write the FileSummary section to disk.
comment|// This section is always last.
name|long
name|prevOffset
init|=
name|out
operator|.
name|getCount
argument_list|()
decl_stmt|;
name|FileSummary
name|fileSummary
init|=
name|fileSummaryBld
operator|.
name|build
argument_list|()
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Writing FileSummary: {"
operator|+
name|TextFormat
operator|.
name|printToString
argument_list|(
name|fileSummary
argument_list|)
operator|+
literal|"}"
argument_list|)
expr_stmt|;
block|}
comment|// Even though the last 4 bytes of the file gives the FileSummary length,
comment|// we still write a varint first that also contains the length.
name|fileSummary
operator|.
name|writeDelimitedTo
argument_list|(
name|out
argument_list|)
expr_stmt|;
comment|// Write the length of the FileSummary section as a fixed-size big
comment|// endian 4-byte quantity.
name|int
name|summaryLen
init|=
name|Ints
operator|.
name|checkedCast
argument_list|(
name|out
operator|.
name|getCount
argument_list|()
operator|-
name|prevOffset
argument_list|)
decl_stmt|;
name|byte
index|[]
name|summaryLenBytes
init|=
operator|new
name|byte
index|[
literal|4
index|]
decl_stmt|;
name|ByteBuffer
operator|.
name|wrap
argument_list|(
name|summaryLenBytes
argument_list|)
operator|.
name|asIntBuffer
argument_list|()
operator|.
name|put
argument_list|(
name|summaryLen
argument_list|)
expr_stmt|;
name|out
operator|.
name|write
argument_list|(
name|summaryLenBytes
argument_list|)
expr_stmt|;
block|}
comment|/**    * Run the OfflineImageReconstructor.    *    * @param inputPath         The input path to use.    * @param outputPath        The output path to use.    *    * @throws Exception        On error.    */
DECL|method|run (String inputPath, String outputPath)
specifier|public
specifier|static
name|void
name|run
parameter_list|(
name|String
name|inputPath
parameter_list|,
name|String
name|outputPath
parameter_list|)
throws|throws
name|Exception
block|{
name|MessageDigest
name|digester
init|=
name|MD5Hash
operator|.
name|getDigester
argument_list|()
decl_stmt|;
name|FileOutputStream
name|fout
init|=
literal|null
decl_stmt|;
name|File
name|foutHash
init|=
operator|new
name|File
argument_list|(
name|outputPath
operator|+
literal|".md5"
argument_list|)
decl_stmt|;
name|Files
operator|.
name|deleteIfExists
argument_list|(
name|foutHash
operator|.
name|toPath
argument_list|()
argument_list|)
expr_stmt|;
comment|// delete any .md5 file that exists
name|CountingOutputStream
name|out
init|=
literal|null
decl_stmt|;
name|FileInputStream
name|fis
init|=
literal|null
decl_stmt|;
name|InputStreamReader
name|reader
init|=
literal|null
decl_stmt|;
try|try
block|{
name|Files
operator|.
name|deleteIfExists
argument_list|(
name|Paths
operator|.
name|get
argument_list|(
name|outputPath
argument_list|)
argument_list|)
expr_stmt|;
name|fout
operator|=
operator|new
name|FileOutputStream
argument_list|(
name|outputPath
argument_list|)
expr_stmt|;
name|fis
operator|=
operator|new
name|FileInputStream
argument_list|(
name|inputPath
argument_list|)
expr_stmt|;
name|reader
operator|=
operator|new
name|InputStreamReader
argument_list|(
name|fis
argument_list|,
name|Charset
operator|.
name|forName
argument_list|(
literal|"UTF-8"
argument_list|)
argument_list|)
expr_stmt|;
name|out
operator|=
operator|new
name|CountingOutputStream
argument_list|(
operator|new
name|DigestOutputStream
argument_list|(
operator|new
name|BufferedOutputStream
argument_list|(
name|fout
argument_list|)
argument_list|,
name|digester
argument_list|)
argument_list|)
expr_stmt|;
name|OfflineImageReconstructor
name|oir
init|=
operator|new
name|OfflineImageReconstructor
argument_list|(
name|out
argument_list|,
name|reader
argument_list|)
decl_stmt|;
name|oir
operator|.
name|processXml
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|IOUtils
operator|.
name|cleanup
argument_list|(
name|LOG
argument_list|,
name|reader
argument_list|,
name|fis
argument_list|,
name|out
argument_list|,
name|fout
argument_list|)
expr_stmt|;
block|}
comment|// Write the md5 file
name|MD5FileUtils
operator|.
name|saveMD5File
argument_list|(
operator|new
name|File
argument_list|(
name|outputPath
argument_list|)
argument_list|,
operator|new
name|MD5Hash
argument_list|(
name|digester
operator|.
name|digest
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_class

end_unit

