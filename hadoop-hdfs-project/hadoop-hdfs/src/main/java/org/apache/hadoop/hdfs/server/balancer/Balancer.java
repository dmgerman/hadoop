begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdfs.server.balancer
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|balancer
package|;
end_package

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkArgument
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|BlockType
operator|.
name|CONTIGUOUS
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|PrintStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|InetSocketAddress
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URI
import|;
end_import

begin_import
import|import
name|java
operator|.
name|text
operator|.
name|DateFormat
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Date
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|HadoopIllegalArgumentException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configured
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|StorageType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|HdfsConfiguration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|balancer
operator|.
name|Dispatcher
operator|.
name|DDatanode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|balancer
operator|.
name|Dispatcher
operator|.
name|DDatanode
operator|.
name|StorageGroup
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|balancer
operator|.
name|Dispatcher
operator|.
name|Source
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|balancer
operator|.
name|Dispatcher
operator|.
name|Task
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|balancer
operator|.
name|Dispatcher
operator|.
name|Util
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|blockmanagement
operator|.
name|BlockPlacementPolicyDefault
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|blockmanagement
operator|.
name|BlockPlacementPolicies
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|UnsupportedActionException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|DatanodeStorageReport
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|StorageReport
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|net
operator|.
name|NetUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|SecurityUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|UserGroupInformation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|HostsFileReader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Time
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Tool
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|ToolRunner
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_comment
comment|/**<p>The balancer is a tool that balances disk space usage on an HDFS cluster  * when some datanodes become full or when new empty nodes join the cluster.  * The tool is deployed as an application program that can be run by the   * cluster administrator on a live HDFS cluster while applications  * adding and deleting files.  *   *<p>SYNOPSIS  *<pre>  * To start:  *      bin/start-balancer.sh [-threshold {@literal<threshold>}]  *      Example: bin/ start-balancer.sh   *                     start the balancer with a default threshold of 10%  *               bin/ start-balancer.sh -threshold 5  *                     start the balancer with a threshold of 5%  *               bin/ start-balancer.sh -idleiterations 20  *                     start the balancer with maximum 20 consecutive idle iterations  *               bin/ start-balancer.sh -idleiterations -1  *                     run the balancer with default threshold infinitely  * To stop:  *      bin/ stop-balancer.sh  *</pre>  *   *<p>DESCRIPTION  *<p>The threshold parameter is a fraction in the range of (1%, 100%) with a   * default value of 10%. The threshold sets a target for whether the cluster   * is balanced. A cluster is balanced if for each datanode, the utilization   * of the node (ratio of used space at the node to total capacity of the node)   * differs from the utilization of the (ratio of used space in the cluster   * to total capacity of the cluster) by no more than the threshold value.   * The smaller the threshold, the more balanced a cluster will become.   * It takes more time to run the balancer for small threshold values.   * Also for a very small threshold the cluster may not be able to reach the   * balanced state when applications write and delete files concurrently.  *   *<p>The tool moves blocks from highly utilized datanodes to poorly   * utilized datanodes iteratively. In each iteration a datanode moves or   * receives no more than the lesser of 10G bytes or the threshold fraction   * of its capacity. Each iteration runs no more than 20 minutes.  * At the end of each iteration, the balancer obtains updated datanodes  * information from the namenode.  *   *<p>A system property that limits the balancer's use of bandwidth is   * defined in the default configuration file:  *<pre>  *&lt;property&gt;  *&lt;name&gt;dfs.datanode.balance.bandwidthPerSec&lt;/name&gt;  *&lt;value&gt;1048576&lt;/value&gt;  *&lt;description&gt;  Specifies the maximum bandwidth that each datanode  * can utilize for the balancing purpose in term of the number of bytes   * per second.  *&lt;/description&gt;  *&lt;/property&gt;  *</pre>  *   *<p>This property determines the maximum speed at which a block will be   * moved from one datanode to another. The default value is 1MB/s. The higher   * the bandwidth, the faster a cluster can reach the balanced state,   * but with greater competition with application processes. If an   * administrator changes the value of this property in the configuration   * file, the change is observed when HDFS is next restarted.  *   *<p>MONITERING BALANCER PROGRESS  *<p>After the balancer is started, an output file name where the balancer   * progress will be recorded is printed on the screen.  The administrator   * can monitor the running of the balancer by reading the output file.   * The output shows the balancer's status iteration by iteration. In each   * iteration it prints the starting time, the iteration number, the total   * number of bytes that have been moved in the previous iterations,   * the total number of bytes that are left to move in order for the cluster   * to be balanced, and the number of bytes that are being moved in this   * iteration. Normally "Bytes Already Moved" is increasing while "Bytes Left   * To Move" is decreasing.  *   *<p>Running multiple instances of the balancer in an HDFS cluster is   * prohibited by the tool.  *   *<p>The balancer automatically exits when any of the following five   * conditions is satisfied:  *<ol>  *<li>The cluster is balanced;  *<li>No block can be moved;  *<li>No block has been moved for specified consecutive iterations (5 by default);  *<li>An IOException occurs while communicating with the namenode;  *<li>Another balancer is running.  *</ol>  *   *<p>Upon exit, a balancer returns an exit code and prints one of the   * following messages to the output file in corresponding to the above exit   * reasons:  *<ol>  *<li>The cluster is balanced. Exiting  *<li>No block can be moved. Exiting...  *<li>No block has been moved for specified iterations (5 by default). Exiting...  *<li>Received an IO exception: failure reason. Exiting...  *<li>Another balancer is running. Exiting...  *</ol>  *   *<p>The administrator can interrupt the execution of the balancer at any   * time by running the command "stop-balancer.sh" on the machine where the   * balancer is running.  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
DECL|class|Balancer
specifier|public
class|class
name|Balancer
block|{
DECL|field|LOG
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|Balancer
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|BALANCER_ID_PATH
specifier|static
specifier|final
name|Path
name|BALANCER_ID_PATH
init|=
operator|new
name|Path
argument_list|(
literal|"/system/balancer.id"
argument_list|)
decl_stmt|;
DECL|field|USAGE
specifier|private
specifier|static
specifier|final
name|String
name|USAGE
init|=
literal|"Usage: hdfs balancer"
operator|+
literal|"\n\t[-policy<policy>]\tthe balancing policy: "
operator|+
name|BalancingPolicy
operator|.
name|Node
operator|.
name|INSTANCE
operator|.
name|getName
argument_list|()
operator|+
literal|" or "
operator|+
name|BalancingPolicy
operator|.
name|Pool
operator|.
name|INSTANCE
operator|.
name|getName
argument_list|()
operator|+
literal|"\n\t[-threshold<threshold>]\tPercentage of disk capacity"
operator|+
literal|"\n\t[-exclude [-f<hosts-file> |<comma-separated list of hosts>]]"
operator|+
literal|"\tExcludes the specified datanodes."
operator|+
literal|"\n\t[-include [-f<hosts-file> |<comma-separated list of hosts>]]"
operator|+
literal|"\tIncludes only the specified datanodes."
operator|+
literal|"\n\t[-source [-f<hosts-file> |<comma-separated list of hosts>]]"
operator|+
literal|"\tPick only the specified datanodes as source nodes."
operator|+
literal|"\n\t[-blockpools<comma-separated list of blockpool ids>]"
operator|+
literal|"\tThe balancer will only run on blockpools included in this list."
operator|+
literal|"\n\t[-idleiterations<idleiterations>]"
operator|+
literal|"\tNumber of consecutive idle iterations (-1 for Infinite) before "
operator|+
literal|"exit."
operator|+
literal|"\n\t[-runDuringUpgrade]"
operator|+
literal|"\tWhether to run the balancer during an ongoing HDFS upgrade."
operator|+
literal|"This is usually not desired since it will not affect used space "
operator|+
literal|"on over-utilized machines."
decl_stmt|;
DECL|field|dispatcher
specifier|private
specifier|final
name|Dispatcher
name|dispatcher
decl_stmt|;
DECL|field|nnc
specifier|private
specifier|final
name|NameNodeConnector
name|nnc
decl_stmt|;
DECL|field|policy
specifier|private
specifier|final
name|BalancingPolicy
name|policy
decl_stmt|;
DECL|field|sourceNodes
specifier|private
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|sourceNodes
decl_stmt|;
DECL|field|runDuringUpgrade
specifier|private
specifier|final
name|boolean
name|runDuringUpgrade
decl_stmt|;
DECL|field|threshold
specifier|private
specifier|final
name|double
name|threshold
decl_stmt|;
DECL|field|maxSizeToMove
specifier|private
specifier|final
name|long
name|maxSizeToMove
decl_stmt|;
DECL|field|defaultBlockSize
specifier|private
specifier|final
name|long
name|defaultBlockSize
decl_stmt|;
comment|// all data node lists
DECL|field|overUtilized
specifier|private
specifier|final
name|Collection
argument_list|<
name|Source
argument_list|>
name|overUtilized
init|=
operator|new
name|LinkedList
argument_list|<
name|Source
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|aboveAvgUtilized
specifier|private
specifier|final
name|Collection
argument_list|<
name|Source
argument_list|>
name|aboveAvgUtilized
init|=
operator|new
name|LinkedList
argument_list|<
name|Source
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|belowAvgUtilized
specifier|private
specifier|final
name|Collection
argument_list|<
name|StorageGroup
argument_list|>
name|belowAvgUtilized
init|=
operator|new
name|LinkedList
argument_list|<
name|StorageGroup
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|underUtilized
specifier|private
specifier|final
name|Collection
argument_list|<
name|StorageGroup
argument_list|>
name|underUtilized
init|=
operator|new
name|LinkedList
argument_list|<
name|StorageGroup
argument_list|>
argument_list|()
decl_stmt|;
comment|/* Check that this Balancer is compatible with the Block Placement Policy    * used by the Namenode.    */
DECL|method|checkReplicationPolicyCompatibility (Configuration conf )
specifier|private
specifier|static
name|void
name|checkReplicationPolicyCompatibility
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|UnsupportedActionException
block|{
name|BlockPlacementPolicies
name|placementPolicies
init|=
operator|new
name|BlockPlacementPolicies
argument_list|(
name|conf
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|placementPolicies
operator|.
name|getPolicy
argument_list|(
name|CONTIGUOUS
argument_list|)
operator|instanceof
name|BlockPlacementPolicyDefault
operator|)
condition|)
block|{
throw|throw
operator|new
name|UnsupportedActionException
argument_list|(
literal|"Balancer without BlockPlacementPolicyDefault"
argument_list|)
throw|;
block|}
block|}
DECL|method|getLong (Configuration conf, String key, long defaultValue)
specifier|static
name|long
name|getLong
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|String
name|key
parameter_list|,
name|long
name|defaultValue
parameter_list|)
block|{
specifier|final
name|long
name|v
init|=
name|conf
operator|.
name|getLong
argument_list|(
name|key
argument_list|,
name|defaultValue
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|key
operator|+
literal|" = "
operator|+
name|v
operator|+
literal|" (default="
operator|+
name|defaultValue
operator|+
literal|")"
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|<=
literal|0
condition|)
block|{
throw|throw
operator|new
name|HadoopIllegalArgumentException
argument_list|(
name|key
operator|+
literal|" = "
operator|+
name|v
operator|+
literal|"<= "
operator|+
literal|0
argument_list|)
throw|;
block|}
return|return
name|v
return|;
block|}
DECL|method|getLongBytes (Configuration conf, String key, long defaultValue)
specifier|static
name|long
name|getLongBytes
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|String
name|key
parameter_list|,
name|long
name|defaultValue
parameter_list|)
block|{
specifier|final
name|long
name|v
init|=
name|conf
operator|.
name|getLongBytes
argument_list|(
name|key
argument_list|,
name|defaultValue
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|key
operator|+
literal|" = "
operator|+
name|v
operator|+
literal|" (default="
operator|+
name|defaultValue
operator|+
literal|")"
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|<=
literal|0
condition|)
block|{
throw|throw
operator|new
name|HadoopIllegalArgumentException
argument_list|(
name|key
operator|+
literal|" = "
operator|+
name|v
operator|+
literal|"<= "
operator|+
literal|0
argument_list|)
throw|;
block|}
return|return
name|v
return|;
block|}
DECL|method|getInt (Configuration conf, String key, int defaultValue)
specifier|static
name|int
name|getInt
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|String
name|key
parameter_list|,
name|int
name|defaultValue
parameter_list|)
block|{
specifier|final
name|int
name|v
init|=
name|conf
operator|.
name|getInt
argument_list|(
name|key
argument_list|,
name|defaultValue
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|key
operator|+
literal|" = "
operator|+
name|v
operator|+
literal|" (default="
operator|+
name|defaultValue
operator|+
literal|")"
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|<=
literal|0
condition|)
block|{
throw|throw
operator|new
name|HadoopIllegalArgumentException
argument_list|(
name|key
operator|+
literal|" = "
operator|+
name|v
operator|+
literal|"<= "
operator|+
literal|0
argument_list|)
throw|;
block|}
return|return
name|v
return|;
block|}
comment|/**    * Construct a balancer.    * Initialize balancer. It sets the value of the threshold, and     * builds the communication proxies to    * namenode as a client and a secondary namenode and retry proxies    * when connection fails.    */
DECL|method|Balancer (NameNodeConnector theblockpool, BalancerParameters p, Configuration conf)
name|Balancer
parameter_list|(
name|NameNodeConnector
name|theblockpool
parameter_list|,
name|BalancerParameters
name|p
parameter_list|,
name|Configuration
name|conf
parameter_list|)
block|{
specifier|final
name|long
name|movedWinWidth
init|=
name|getLong
argument_list|(
name|conf
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_BALANCER_MOVEDWINWIDTH_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_BALANCER_MOVEDWINWIDTH_DEFAULT
argument_list|)
decl_stmt|;
specifier|final
name|int
name|moverThreads
init|=
name|getInt
argument_list|(
name|conf
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_BALANCER_MOVERTHREADS_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_BALANCER_MOVERTHREADS_DEFAULT
argument_list|)
decl_stmt|;
specifier|final
name|int
name|dispatcherThreads
init|=
name|getInt
argument_list|(
name|conf
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_BALANCER_DISPATCHERTHREADS_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_BALANCER_DISPATCHERTHREADS_DEFAULT
argument_list|)
decl_stmt|;
specifier|final
name|int
name|maxConcurrentMovesPerNode
init|=
name|getInt
argument_list|(
name|conf
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_DATANODE_BALANCE_MAX_NUM_CONCURRENT_MOVES_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_DATANODE_BALANCE_MAX_NUM_CONCURRENT_MOVES_DEFAULT
argument_list|)
decl_stmt|;
specifier|final
name|long
name|getBlocksSize
init|=
name|getLongBytes
argument_list|(
name|conf
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_BALANCER_GETBLOCKS_SIZE_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_BALANCER_GETBLOCKS_SIZE_DEFAULT
argument_list|)
decl_stmt|;
specifier|final
name|long
name|getBlocksMinBlockSize
init|=
name|getLongBytes
argument_list|(
name|conf
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_BALANCER_GETBLOCKS_MIN_BLOCK_SIZE_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_BALANCER_GETBLOCKS_MIN_BLOCK_SIZE_DEFAULT
argument_list|)
decl_stmt|;
specifier|final
name|int
name|blockMoveTimeout
init|=
name|conf
operator|.
name|getInt
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_BALANCER_BLOCK_MOVE_TIMEOUT
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_BALANCER_BLOCK_MOVE_TIMEOUT_DEFAULT
argument_list|)
decl_stmt|;
specifier|final
name|int
name|maxNoMoveInterval
init|=
name|conf
operator|.
name|getInt
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_BALANCER_MAX_NO_MOVE_INTERVAL_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_BALANCER_MAX_NO_MOVE_INTERVAL_DEFAULT
argument_list|)
decl_stmt|;
specifier|final
name|long
name|maxIterationTime
init|=
name|conf
operator|.
name|getLong
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_BALANCER_MAX_ITERATION_TIME_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_BALANCER_MAX_ITERATION_TIME_DEFAULT
argument_list|)
decl_stmt|;
name|this
operator|.
name|nnc
operator|=
name|theblockpool
expr_stmt|;
name|this
operator|.
name|dispatcher
operator|=
operator|new
name|Dispatcher
argument_list|(
name|theblockpool
argument_list|,
name|p
operator|.
name|getIncludedNodes
argument_list|()
argument_list|,
name|p
operator|.
name|getExcludedNodes
argument_list|()
argument_list|,
name|movedWinWidth
argument_list|,
name|moverThreads
argument_list|,
name|dispatcherThreads
argument_list|,
name|maxConcurrentMovesPerNode
argument_list|,
name|getBlocksSize
argument_list|,
name|getBlocksMinBlockSize
argument_list|,
name|blockMoveTimeout
argument_list|,
name|maxNoMoveInterval
argument_list|,
name|maxIterationTime
argument_list|,
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|threshold
operator|=
name|p
operator|.
name|getThreshold
argument_list|()
expr_stmt|;
name|this
operator|.
name|policy
operator|=
name|p
operator|.
name|getBalancingPolicy
argument_list|()
expr_stmt|;
name|this
operator|.
name|sourceNodes
operator|=
name|p
operator|.
name|getSourceNodes
argument_list|()
expr_stmt|;
name|this
operator|.
name|runDuringUpgrade
operator|=
name|p
operator|.
name|getRunDuringUpgrade
argument_list|()
expr_stmt|;
name|this
operator|.
name|maxSizeToMove
operator|=
name|getLongBytes
argument_list|(
name|conf
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_BALANCER_MAX_SIZE_TO_MOVE_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_BALANCER_MAX_SIZE_TO_MOVE_DEFAULT
argument_list|)
expr_stmt|;
name|this
operator|.
name|defaultBlockSize
operator|=
name|getLongBytes
argument_list|(
name|conf
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_BLOCK_SIZE_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_BLOCK_SIZE_DEFAULT
argument_list|)
expr_stmt|;
block|}
DECL|method|getCapacity (DatanodeStorageReport report, StorageType t)
specifier|private
specifier|static
name|long
name|getCapacity
parameter_list|(
name|DatanodeStorageReport
name|report
parameter_list|,
name|StorageType
name|t
parameter_list|)
block|{
name|long
name|capacity
init|=
literal|0L
decl_stmt|;
for|for
control|(
name|StorageReport
name|r
range|:
name|report
operator|.
name|getStorageReports
argument_list|()
control|)
block|{
if|if
condition|(
name|r
operator|.
name|getStorage
argument_list|()
operator|.
name|getStorageType
argument_list|()
operator|==
name|t
condition|)
block|{
name|capacity
operator|+=
name|r
operator|.
name|getCapacity
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|capacity
return|;
block|}
DECL|method|getRemaining (DatanodeStorageReport report, StorageType t)
specifier|private
name|long
name|getRemaining
parameter_list|(
name|DatanodeStorageReport
name|report
parameter_list|,
name|StorageType
name|t
parameter_list|)
block|{
name|long
name|remaining
init|=
literal|0L
decl_stmt|;
for|for
control|(
name|StorageReport
name|r
range|:
name|report
operator|.
name|getStorageReports
argument_list|()
control|)
block|{
if|if
condition|(
name|r
operator|.
name|getStorage
argument_list|()
operator|.
name|getStorageType
argument_list|()
operator|==
name|t
condition|)
block|{
if|if
condition|(
name|r
operator|.
name|getRemaining
argument_list|()
operator|>=
name|defaultBlockSize
condition|)
block|{
name|remaining
operator|+=
name|r
operator|.
name|getRemaining
argument_list|()
expr_stmt|;
block|}
block|}
block|}
return|return
name|remaining
return|;
block|}
comment|/**    * Given a datanode storage set, build a network topology and decide    * over-utilized storages, above average utilized storages,     * below average utilized storages, and underutilized storages.     * The input datanode storage set is shuffled in order to randomize    * to the storage matching later on.    *    * @return the number of bytes needed to move in order to balance the cluster.    */
DECL|method|init (List<DatanodeStorageReport> reports)
specifier|private
name|long
name|init
parameter_list|(
name|List
argument_list|<
name|DatanodeStorageReport
argument_list|>
name|reports
parameter_list|)
block|{
comment|// compute average utilization
for|for
control|(
name|DatanodeStorageReport
name|r
range|:
name|reports
control|)
block|{
name|policy
operator|.
name|accumulateSpaces
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
name|policy
operator|.
name|initAvgUtilization
argument_list|()
expr_stmt|;
comment|// create network topology and classify utilization collections:
comment|//   over-utilized, above-average, below-average and under-utilized.
name|long
name|overLoadedBytes
init|=
literal|0L
decl_stmt|,
name|underLoadedBytes
init|=
literal|0L
decl_stmt|;
for|for
control|(
name|DatanodeStorageReport
name|r
range|:
name|reports
control|)
block|{
specifier|final
name|DDatanode
name|dn
init|=
name|dispatcher
operator|.
name|newDatanode
argument_list|(
name|r
operator|.
name|getDatanodeInfo
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|boolean
name|isSource
init|=
name|Util
operator|.
name|isIncluded
argument_list|(
name|sourceNodes
argument_list|,
name|dn
operator|.
name|getDatanodeInfo
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|StorageType
name|t
range|:
name|StorageType
operator|.
name|getMovableTypes
argument_list|()
control|)
block|{
specifier|final
name|Double
name|utilization
init|=
name|policy
operator|.
name|getUtilization
argument_list|(
name|r
argument_list|,
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|utilization
operator|==
literal|null
condition|)
block|{
comment|// datanode does not have such storage type
continue|continue;
block|}
specifier|final
name|double
name|average
init|=
name|policy
operator|.
name|getAvgUtilization
argument_list|(
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|utilization
operator|>=
name|average
operator|&&
operator|!
name|isSource
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
name|dn
operator|+
literal|"["
operator|+
name|t
operator|+
literal|"] has utilization="
operator|+
name|utilization
operator|+
literal|">= average="
operator|+
name|average
operator|+
literal|" but it is not specified as a source; skipping it."
argument_list|)
expr_stmt|;
continue|continue;
block|}
specifier|final
name|double
name|utilizationDiff
init|=
name|utilization
operator|-
name|average
decl_stmt|;
specifier|final
name|long
name|capacity
init|=
name|getCapacity
argument_list|(
name|r
argument_list|,
name|t
argument_list|)
decl_stmt|;
specifier|final
name|double
name|thresholdDiff
init|=
name|Math
operator|.
name|abs
argument_list|(
name|utilizationDiff
argument_list|)
operator|-
name|threshold
decl_stmt|;
specifier|final
name|long
name|maxSize2Move
init|=
name|computeMaxSize2Move
argument_list|(
name|capacity
argument_list|,
name|getRemaining
argument_list|(
name|r
argument_list|,
name|t
argument_list|)
argument_list|,
name|utilizationDiff
argument_list|,
name|maxSizeToMove
argument_list|)
decl_stmt|;
specifier|final
name|StorageGroup
name|g
decl_stmt|;
if|if
condition|(
name|utilizationDiff
operator|>
literal|0
condition|)
block|{
specifier|final
name|Source
name|s
init|=
name|dn
operator|.
name|addSource
argument_list|(
name|t
argument_list|,
name|maxSize2Move
argument_list|,
name|dispatcher
argument_list|)
decl_stmt|;
if|if
condition|(
name|thresholdDiff
operator|<=
literal|0
condition|)
block|{
comment|// within threshold
name|aboveAvgUtilized
operator|.
name|add
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|overLoadedBytes
operator|+=
name|percentage2bytes
argument_list|(
name|thresholdDiff
argument_list|,
name|capacity
argument_list|)
expr_stmt|;
name|overUtilized
operator|.
name|add
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|g
operator|=
name|s
expr_stmt|;
block|}
else|else
block|{
name|g
operator|=
name|dn
operator|.
name|addTarget
argument_list|(
name|t
argument_list|,
name|maxSize2Move
argument_list|)
expr_stmt|;
if|if
condition|(
name|thresholdDiff
operator|<=
literal|0
condition|)
block|{
comment|// within threshold
name|belowAvgUtilized
operator|.
name|add
argument_list|(
name|g
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|underLoadedBytes
operator|+=
name|percentage2bytes
argument_list|(
name|thresholdDiff
argument_list|,
name|capacity
argument_list|)
expr_stmt|;
name|underUtilized
operator|.
name|add
argument_list|(
name|g
argument_list|)
expr_stmt|;
block|}
block|}
name|dispatcher
operator|.
name|getStorageGroupMap
argument_list|()
operator|.
name|put
argument_list|(
name|g
argument_list|)
expr_stmt|;
block|}
block|}
name|logUtilizationCollections
argument_list|()
expr_stmt|;
name|Preconditions
operator|.
name|checkState
argument_list|(
name|dispatcher
operator|.
name|getStorageGroupMap
argument_list|()
operator|.
name|size
argument_list|()
operator|==
name|overUtilized
operator|.
name|size
argument_list|()
operator|+
name|underUtilized
operator|.
name|size
argument_list|()
operator|+
name|aboveAvgUtilized
operator|.
name|size
argument_list|()
operator|+
name|belowAvgUtilized
operator|.
name|size
argument_list|()
argument_list|,
literal|"Mismatched number of storage groups"
argument_list|)
expr_stmt|;
comment|// return number of bytes to be moved in order to make the cluster balanced
return|return
name|Math
operator|.
name|max
argument_list|(
name|overLoadedBytes
argument_list|,
name|underLoadedBytes
argument_list|)
return|;
block|}
DECL|method|computeMaxSize2Move (final long capacity, final long remaining, final double utilizationDiff, final long max)
specifier|private
specifier|static
name|long
name|computeMaxSize2Move
parameter_list|(
specifier|final
name|long
name|capacity
parameter_list|,
specifier|final
name|long
name|remaining
parameter_list|,
specifier|final
name|double
name|utilizationDiff
parameter_list|,
specifier|final
name|long
name|max
parameter_list|)
block|{
specifier|final
name|double
name|diff
init|=
name|Math
operator|.
name|abs
argument_list|(
name|utilizationDiff
argument_list|)
decl_stmt|;
name|long
name|maxSizeToMove
init|=
name|percentage2bytes
argument_list|(
name|diff
argument_list|,
name|capacity
argument_list|)
decl_stmt|;
if|if
condition|(
name|utilizationDiff
operator|<
literal|0
condition|)
block|{
name|maxSizeToMove
operator|=
name|Math
operator|.
name|min
argument_list|(
name|remaining
argument_list|,
name|maxSizeToMove
argument_list|)
expr_stmt|;
block|}
return|return
name|Math
operator|.
name|min
argument_list|(
name|max
argument_list|,
name|maxSizeToMove
argument_list|)
return|;
block|}
DECL|method|percentage2bytes (double percentage, long capacity)
specifier|private
specifier|static
name|long
name|percentage2bytes
parameter_list|(
name|double
name|percentage
parameter_list|,
name|long
name|capacity
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|percentage
operator|>=
literal|0
argument_list|,
literal|"percentage = %s< 0"
argument_list|,
name|percentage
argument_list|)
expr_stmt|;
return|return
call|(
name|long
call|)
argument_list|(
name|percentage
operator|*
name|capacity
operator|/
literal|100.0
argument_list|)
return|;
block|}
comment|/* log the over utilized& under utilized nodes */
DECL|method|logUtilizationCollections ()
specifier|private
name|void
name|logUtilizationCollections
parameter_list|()
block|{
name|logUtilizationCollection
argument_list|(
literal|"over-utilized"
argument_list|,
name|overUtilized
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|logUtilizationCollection
argument_list|(
literal|"above-average"
argument_list|,
name|aboveAvgUtilized
argument_list|)
expr_stmt|;
name|logUtilizationCollection
argument_list|(
literal|"below-average"
argument_list|,
name|belowAvgUtilized
argument_list|)
expr_stmt|;
block|}
name|logUtilizationCollection
argument_list|(
literal|"underutilized"
argument_list|,
name|underUtilized
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|static
parameter_list|<
name|T
extends|extends
name|StorageGroup
parameter_list|>
DECL|method|logUtilizationCollection (String name, Collection<T> items)
name|void
name|logUtilizationCollection
parameter_list|(
name|String
name|name
parameter_list|,
name|Collection
argument_list|<
name|T
argument_list|>
name|items
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
name|items
operator|.
name|size
argument_list|()
operator|+
literal|" "
operator|+
name|name
operator|+
literal|": "
operator|+
name|items
argument_list|)
expr_stmt|;
block|}
comment|/**    * Decide all<source, target> pairs and    * the number of bytes to move from a source to a target    * Maximum bytes to be moved per storage group is    * min(1 Band worth of bytes,  MAX_SIZE_TO_MOVE).    * @return total number of bytes to move in this iteration    */
DECL|method|chooseStorageGroups ()
specifier|private
name|long
name|chooseStorageGroups
parameter_list|()
block|{
comment|// First, match nodes on the same node group if cluster is node group aware
if|if
condition|(
name|dispatcher
operator|.
name|getCluster
argument_list|()
operator|.
name|isNodeGroupAware
argument_list|()
condition|)
block|{
name|chooseStorageGroups
argument_list|(
name|Matcher
operator|.
name|SAME_NODE_GROUP
argument_list|)
expr_stmt|;
block|}
comment|// Then, match nodes on the same rack
name|chooseStorageGroups
argument_list|(
name|Matcher
operator|.
name|SAME_RACK
argument_list|)
expr_stmt|;
comment|// At last, match all remaining nodes
name|chooseStorageGroups
argument_list|(
name|Matcher
operator|.
name|ANY_OTHER
argument_list|)
expr_stmt|;
return|return
name|dispatcher
operator|.
name|bytesToMove
argument_list|()
return|;
block|}
comment|/** Decide all<source, target> pairs according to the matcher. */
DECL|method|chooseStorageGroups (final Matcher matcher)
specifier|private
name|void
name|chooseStorageGroups
parameter_list|(
specifier|final
name|Matcher
name|matcher
parameter_list|)
block|{
comment|/* first step: match each overUtilized datanode (source) to      * one or more underUtilized datanodes (targets).      */
name|LOG
operator|.
name|info
argument_list|(
literal|"chooseStorageGroups for "
operator|+
name|matcher
operator|+
literal|": overUtilized => underUtilized"
argument_list|)
expr_stmt|;
name|chooseStorageGroups
argument_list|(
name|overUtilized
argument_list|,
name|underUtilized
argument_list|,
name|matcher
argument_list|)
expr_stmt|;
comment|/* match each remaining overutilized datanode (source) to       * below average utilized datanodes (targets).      * Note only overutilized datanodes that haven't had that max bytes to move      * satisfied in step 1 are selected      */
name|LOG
operator|.
name|info
argument_list|(
literal|"chooseStorageGroups for "
operator|+
name|matcher
operator|+
literal|": overUtilized => belowAvgUtilized"
argument_list|)
expr_stmt|;
name|chooseStorageGroups
argument_list|(
name|overUtilized
argument_list|,
name|belowAvgUtilized
argument_list|,
name|matcher
argument_list|)
expr_stmt|;
comment|/* match each remaining underutilized datanode (target) to       * above average utilized datanodes (source).      * Note only underutilized datanodes that have not had that max bytes to      * move satisfied in step 1 are selected.      */
name|LOG
operator|.
name|info
argument_list|(
literal|"chooseStorageGroups for "
operator|+
name|matcher
operator|+
literal|": underUtilized => aboveAvgUtilized"
argument_list|)
expr_stmt|;
name|chooseStorageGroups
argument_list|(
name|underUtilized
argument_list|,
name|aboveAvgUtilized
argument_list|,
name|matcher
argument_list|)
expr_stmt|;
block|}
comment|/**    * For each datanode, choose matching nodes from the candidates. Either the    * datanodes or the candidates are source nodes with (utilization> Avg), and    * the others are target nodes with (utilization< Avg).    */
specifier|private
parameter_list|<
name|G
extends|extends
name|StorageGroup
parameter_list|,
name|C
extends|extends
name|StorageGroup
parameter_list|>
DECL|method|chooseStorageGroups (Collection<G> groups, Collection<C> candidates, Matcher matcher)
name|void
name|chooseStorageGroups
parameter_list|(
name|Collection
argument_list|<
name|G
argument_list|>
name|groups
parameter_list|,
name|Collection
argument_list|<
name|C
argument_list|>
name|candidates
parameter_list|,
name|Matcher
name|matcher
parameter_list|)
block|{
for|for
control|(
specifier|final
name|Iterator
argument_list|<
name|G
argument_list|>
name|i
init|=
name|groups
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
specifier|final
name|G
name|g
init|=
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
for|for
control|(
init|;
name|choose4One
argument_list|(
name|g
argument_list|,
name|candidates
argument_list|,
name|matcher
argument_list|)
condition|;
control|)
empty_stmt|;
if|if
condition|(
operator|!
name|g
operator|.
name|hasSpaceForScheduling
argument_list|()
condition|)
block|{
name|i
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**    * For the given datanode, choose a candidate and then schedule it.    * @return true if a candidate is chosen; false if no candidates is chosen.    */
DECL|method|choose4One (StorageGroup g, Collection<C> candidates, Matcher matcher)
specifier|private
parameter_list|<
name|C
extends|extends
name|StorageGroup
parameter_list|>
name|boolean
name|choose4One
parameter_list|(
name|StorageGroup
name|g
parameter_list|,
name|Collection
argument_list|<
name|C
argument_list|>
name|candidates
parameter_list|,
name|Matcher
name|matcher
parameter_list|)
block|{
specifier|final
name|Iterator
argument_list|<
name|C
argument_list|>
name|i
init|=
name|candidates
operator|.
name|iterator
argument_list|()
decl_stmt|;
specifier|final
name|C
name|chosen
init|=
name|chooseCandidate
argument_list|(
name|g
argument_list|,
name|i
argument_list|,
name|matcher
argument_list|)
decl_stmt|;
if|if
condition|(
name|chosen
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|g
operator|instanceof
name|Source
condition|)
block|{
name|matchSourceWithTargetToMove
argument_list|(
operator|(
name|Source
operator|)
name|g
argument_list|,
name|chosen
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|matchSourceWithTargetToMove
argument_list|(
operator|(
name|Source
operator|)
name|chosen
argument_list|,
name|g
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|chosen
operator|.
name|hasSpaceForScheduling
argument_list|()
condition|)
block|{
name|i
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
DECL|method|matchSourceWithTargetToMove (Source source, StorageGroup target)
specifier|private
name|void
name|matchSourceWithTargetToMove
parameter_list|(
name|Source
name|source
parameter_list|,
name|StorageGroup
name|target
parameter_list|)
block|{
name|long
name|size
init|=
name|Math
operator|.
name|min
argument_list|(
name|source
operator|.
name|availableSizeToMove
argument_list|()
argument_list|,
name|target
operator|.
name|availableSizeToMove
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|Task
name|task
init|=
operator|new
name|Task
argument_list|(
name|target
argument_list|,
name|size
argument_list|)
decl_stmt|;
name|source
operator|.
name|addTask
argument_list|(
name|task
argument_list|)
expr_stmt|;
name|target
operator|.
name|incScheduledSize
argument_list|(
name|task
operator|.
name|getSize
argument_list|()
argument_list|)
expr_stmt|;
name|dispatcher
operator|.
name|add
argument_list|(
name|source
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Decided to move "
operator|+
name|StringUtils
operator|.
name|byteDesc
argument_list|(
name|size
argument_list|)
operator|+
literal|" bytes from "
operator|+
name|source
operator|.
name|getDisplayName
argument_list|()
operator|+
literal|" to "
operator|+
name|target
operator|.
name|getDisplayName
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/** Choose a candidate for the given datanode. */
specifier|private
parameter_list|<
name|G
extends|extends
name|StorageGroup
parameter_list|,
name|C
extends|extends
name|StorageGroup
parameter_list|>
DECL|method|chooseCandidate (G g, Iterator<C> candidates, Matcher matcher)
name|C
name|chooseCandidate
parameter_list|(
name|G
name|g
parameter_list|,
name|Iterator
argument_list|<
name|C
argument_list|>
name|candidates
parameter_list|,
name|Matcher
name|matcher
parameter_list|)
block|{
if|if
condition|(
name|g
operator|.
name|hasSpaceForScheduling
argument_list|()
condition|)
block|{
for|for
control|(
init|;
name|candidates
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
specifier|final
name|C
name|c
init|=
name|candidates
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|c
operator|.
name|hasSpaceForScheduling
argument_list|()
condition|)
block|{
name|candidates
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|matchStorageGroups
argument_list|(
name|c
argument_list|,
name|g
argument_list|,
name|matcher
argument_list|)
condition|)
block|{
return|return
name|c
return|;
block|}
block|}
block|}
return|return
literal|null
return|;
block|}
DECL|method|matchStorageGroups (StorageGroup left, StorageGroup right, Matcher matcher)
specifier|private
name|boolean
name|matchStorageGroups
parameter_list|(
name|StorageGroup
name|left
parameter_list|,
name|StorageGroup
name|right
parameter_list|,
name|Matcher
name|matcher
parameter_list|)
block|{
return|return
name|left
operator|.
name|getStorageType
argument_list|()
operator|==
name|right
operator|.
name|getStorageType
argument_list|()
operator|&&
name|matcher
operator|.
name|match
argument_list|(
name|dispatcher
operator|.
name|getCluster
argument_list|()
argument_list|,
name|left
operator|.
name|getDatanodeInfo
argument_list|()
argument_list|,
name|right
operator|.
name|getDatanodeInfo
argument_list|()
argument_list|)
return|;
block|}
comment|/* reset all fields in a balancer preparing for the next iteration */
DECL|method|resetData (Configuration conf)
name|void
name|resetData
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
name|this
operator|.
name|overUtilized
operator|.
name|clear
argument_list|()
expr_stmt|;
name|this
operator|.
name|aboveAvgUtilized
operator|.
name|clear
argument_list|()
expr_stmt|;
name|this
operator|.
name|belowAvgUtilized
operator|.
name|clear
argument_list|()
expr_stmt|;
name|this
operator|.
name|underUtilized
operator|.
name|clear
argument_list|()
expr_stmt|;
name|this
operator|.
name|policy
operator|.
name|reset
argument_list|()
expr_stmt|;
name|dispatcher
operator|.
name|reset
argument_list|(
name|conf
argument_list|)
expr_stmt|;
empty_stmt|;
block|}
DECL|class|Result
specifier|static
class|class
name|Result
block|{
DECL|field|exitStatus
specifier|final
name|ExitStatus
name|exitStatus
decl_stmt|;
DECL|field|bytesLeftToMove
specifier|final
name|long
name|bytesLeftToMove
decl_stmt|;
DECL|field|bytesBeingMoved
specifier|final
name|long
name|bytesBeingMoved
decl_stmt|;
DECL|field|bytesAlreadyMoved
specifier|final
name|long
name|bytesAlreadyMoved
decl_stmt|;
DECL|method|Result (ExitStatus exitStatus, long bytesLeftToMove, long bytesBeingMoved, long bytesAlreadyMoved)
name|Result
parameter_list|(
name|ExitStatus
name|exitStatus
parameter_list|,
name|long
name|bytesLeftToMove
parameter_list|,
name|long
name|bytesBeingMoved
parameter_list|,
name|long
name|bytesAlreadyMoved
parameter_list|)
block|{
name|this
operator|.
name|exitStatus
operator|=
name|exitStatus
expr_stmt|;
name|this
operator|.
name|bytesLeftToMove
operator|=
name|bytesLeftToMove
expr_stmt|;
name|this
operator|.
name|bytesBeingMoved
operator|=
name|bytesBeingMoved
expr_stmt|;
name|this
operator|.
name|bytesAlreadyMoved
operator|=
name|bytesAlreadyMoved
expr_stmt|;
block|}
DECL|method|print (int iteration, PrintStream out)
name|void
name|print
parameter_list|(
name|int
name|iteration
parameter_list|,
name|PrintStream
name|out
parameter_list|)
block|{
name|out
operator|.
name|printf
argument_list|(
literal|"%-24s %10d  %19s  %18s  %17s%n"
argument_list|,
name|DateFormat
operator|.
name|getDateTimeInstance
argument_list|()
operator|.
name|format
argument_list|(
operator|new
name|Date
argument_list|()
argument_list|)
argument_list|,
name|iteration
argument_list|,
name|StringUtils
operator|.
name|byteDesc
argument_list|(
name|bytesAlreadyMoved
argument_list|)
argument_list|,
name|StringUtils
operator|.
name|byteDesc
argument_list|(
name|bytesLeftToMove
argument_list|)
argument_list|,
name|StringUtils
operator|.
name|byteDesc
argument_list|(
name|bytesBeingMoved
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|newResult (ExitStatus exitStatus, long bytesLeftToMove, long bytesBeingMoved)
name|Result
name|newResult
parameter_list|(
name|ExitStatus
name|exitStatus
parameter_list|,
name|long
name|bytesLeftToMove
parameter_list|,
name|long
name|bytesBeingMoved
parameter_list|)
block|{
return|return
operator|new
name|Result
argument_list|(
name|exitStatus
argument_list|,
name|bytesLeftToMove
argument_list|,
name|bytesBeingMoved
argument_list|,
name|dispatcher
operator|.
name|getBytesMoved
argument_list|()
argument_list|)
return|;
block|}
DECL|method|newResult (ExitStatus exitStatus)
name|Result
name|newResult
parameter_list|(
name|ExitStatus
name|exitStatus
parameter_list|)
block|{
return|return
operator|new
name|Result
argument_list|(
name|exitStatus
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
name|dispatcher
operator|.
name|getBytesMoved
argument_list|()
argument_list|)
return|;
block|}
comment|/** Run an iteration for all datanodes. */
DECL|method|runOneIteration ()
name|Result
name|runOneIteration
parameter_list|()
block|{
try|try
block|{
specifier|final
name|List
argument_list|<
name|DatanodeStorageReport
argument_list|>
name|reports
init|=
name|dispatcher
operator|.
name|init
argument_list|()
decl_stmt|;
specifier|final
name|long
name|bytesLeftToMove
init|=
name|init
argument_list|(
name|reports
argument_list|)
decl_stmt|;
if|if
condition|(
name|bytesLeftToMove
operator|==
literal|0
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"The cluster is balanced. Exiting..."
argument_list|)
expr_stmt|;
return|return
name|newResult
argument_list|(
name|ExitStatus
operator|.
name|SUCCESS
argument_list|,
name|bytesLeftToMove
argument_list|,
literal|0
argument_list|)
return|;
block|}
else|else
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Need to move "
operator|+
name|StringUtils
operator|.
name|byteDesc
argument_list|(
name|bytesLeftToMove
argument_list|)
operator|+
literal|" to make the cluster balanced."
argument_list|)
expr_stmt|;
block|}
comment|// Should not run the balancer during an unfinalized upgrade, since moved
comment|// blocks are not deleted on the source datanode.
if|if
condition|(
operator|!
name|runDuringUpgrade
operator|&&
name|nnc
operator|.
name|isUpgrading
argument_list|()
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Balancer exiting as upgrade is not finalized, "
operator|+
literal|"please finalize the HDFS upgrade before running the balancer."
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|error
argument_list|(
literal|"Balancer exiting as upgrade is not finalized, "
operator|+
literal|"please finalize the HDFS upgrade before running the balancer."
argument_list|)
expr_stmt|;
return|return
name|newResult
argument_list|(
name|ExitStatus
operator|.
name|UNFINALIZED_UPGRADE
argument_list|,
name|bytesLeftToMove
argument_list|,
operator|-
literal|1
argument_list|)
return|;
block|}
comment|/* Decide all the nodes that will participate in the block move and        * the number of bytes that need to be moved from one node to another        * in this iteration. Maximum bytes to be moved per node is        * Min(1 Band worth of bytes,  MAX_SIZE_TO_MOVE).        */
specifier|final
name|long
name|bytesBeingMoved
init|=
name|chooseStorageGroups
argument_list|()
decl_stmt|;
if|if
condition|(
name|bytesBeingMoved
operator|==
literal|0
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"No block can be moved. Exiting..."
argument_list|)
expr_stmt|;
return|return
name|newResult
argument_list|(
name|ExitStatus
operator|.
name|NO_MOVE_BLOCK
argument_list|,
name|bytesLeftToMove
argument_list|,
name|bytesBeingMoved
argument_list|)
return|;
block|}
else|else
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Will move "
operator|+
name|StringUtils
operator|.
name|byteDesc
argument_list|(
name|bytesBeingMoved
argument_list|)
operator|+
literal|" in this iteration"
argument_list|)
expr_stmt|;
block|}
comment|/* For each pair of<source, target>, start a thread that repeatedly         * decide a block to be moved and its proxy source,         * then initiates the move until all bytes are moved or no more block        * available to move.        * Exit no byte has been moved for 5 consecutive iterations.        */
if|if
condition|(
operator|!
name|dispatcher
operator|.
name|dispatchAndCheckContinue
argument_list|()
condition|)
block|{
return|return
name|newResult
argument_list|(
name|ExitStatus
operator|.
name|NO_MOVE_PROGRESS
argument_list|,
name|bytesLeftToMove
argument_list|,
name|bytesBeingMoved
argument_list|)
return|;
block|}
return|return
name|newResult
argument_list|(
name|ExitStatus
operator|.
name|IN_PROGRESS
argument_list|,
name|bytesLeftToMove
argument_list|,
name|bytesBeingMoved
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|e
operator|+
literal|".  Exiting ..."
argument_list|)
expr_stmt|;
return|return
name|newResult
argument_list|(
name|ExitStatus
operator|.
name|ILLEGAL_ARGUMENTS
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|e
operator|+
literal|".  Exiting ..."
argument_list|)
expr_stmt|;
return|return
name|newResult
argument_list|(
name|ExitStatus
operator|.
name|IO_EXCEPTION
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|e
operator|+
literal|".  Exiting ..."
argument_list|)
expr_stmt|;
return|return
name|newResult
argument_list|(
name|ExitStatus
operator|.
name|INTERRUPTED
argument_list|)
return|;
block|}
finally|finally
block|{
name|dispatcher
operator|.
name|shutdownNow
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Balance all namenodes.    * For each iteration,    * for each namenode,    * execute a {@link Balancer} to work through all datanodes once.      */
DECL|method|run (Collection<URI> namenodes, final BalancerParameters p, Configuration conf)
specifier|static
name|int
name|run
parameter_list|(
name|Collection
argument_list|<
name|URI
argument_list|>
name|namenodes
parameter_list|,
specifier|final
name|BalancerParameters
name|p
parameter_list|,
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
specifier|final
name|long
name|sleeptime
init|=
name|conf
operator|.
name|getTimeDuration
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_HEARTBEAT_INTERVAL_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_HEARTBEAT_INTERVAL_DEFAULT
argument_list|,
name|TimeUnit
operator|.
name|SECONDS
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
operator|*
literal|2
operator|+
name|conf
operator|.
name|getTimeDuration
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_REDUNDANCY_INTERVAL_SECONDS_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_REDUNDANCY_INTERVAL_SECONDS_DEFAULT
argument_list|,
name|TimeUnit
operator|.
name|SECONDS
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"namenodes  = "
operator|+
name|namenodes
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"parameters = "
operator|+
name|p
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"included nodes = "
operator|+
name|p
operator|.
name|getIncludedNodes
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"excluded nodes = "
operator|+
name|p
operator|.
name|getExcludedNodes
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"source nodes = "
operator|+
name|p
operator|.
name|getSourceNodes
argument_list|()
argument_list|)
expr_stmt|;
name|checkKeytabAndInit
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Time Stamp               Iteration#  Bytes Already Moved  Bytes Left To Move  Bytes Being Moved"
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|NameNodeConnector
argument_list|>
name|connectors
init|=
name|Collections
operator|.
name|emptyList
argument_list|()
decl_stmt|;
try|try
block|{
name|connectors
operator|=
name|NameNodeConnector
operator|.
name|newNameNodeConnectors
argument_list|(
name|namenodes
argument_list|,
name|Balancer
operator|.
name|class
operator|.
name|getSimpleName
argument_list|()
argument_list|,
name|BALANCER_ID_PATH
argument_list|,
name|conf
argument_list|,
name|p
operator|.
name|getMaxIdleIteration
argument_list|()
argument_list|)
expr_stmt|;
name|boolean
name|done
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|iteration
init|=
literal|0
init|;
operator|!
name|done
condition|;
name|iteration
operator|++
control|)
block|{
name|done
operator|=
literal|true
expr_stmt|;
name|Collections
operator|.
name|shuffle
argument_list|(
name|connectors
argument_list|)
expr_stmt|;
for|for
control|(
name|NameNodeConnector
name|nnc
range|:
name|connectors
control|)
block|{
if|if
condition|(
name|p
operator|.
name|getBlockPools
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|0
operator|||
name|p
operator|.
name|getBlockPools
argument_list|()
operator|.
name|contains
argument_list|(
name|nnc
operator|.
name|getBlockpoolID
argument_list|()
argument_list|)
condition|)
block|{
specifier|final
name|Balancer
name|b
init|=
operator|new
name|Balancer
argument_list|(
name|nnc
argument_list|,
name|p
argument_list|,
name|conf
argument_list|)
decl_stmt|;
specifier|final
name|Result
name|r
init|=
name|b
operator|.
name|runOneIteration
argument_list|()
decl_stmt|;
name|r
operator|.
name|print
argument_list|(
name|iteration
argument_list|,
name|System
operator|.
name|out
argument_list|)
expr_stmt|;
comment|// clean all lists
name|b
operator|.
name|resetData
argument_list|(
name|conf
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|.
name|exitStatus
operator|==
name|ExitStatus
operator|.
name|IN_PROGRESS
condition|)
block|{
name|done
operator|=
literal|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|r
operator|.
name|exitStatus
operator|!=
name|ExitStatus
operator|.
name|SUCCESS
condition|)
block|{
comment|// must be an error statue, return.
return|return
name|r
operator|.
name|exitStatus
operator|.
name|getExitCode
argument_list|()
return|;
block|}
block|}
else|else
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Skipping blockpool "
operator|+
name|nnc
operator|.
name|getBlockpoolID
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|done
condition|)
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|sleeptime
argument_list|)
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
for|for
control|(
name|NameNodeConnector
name|nnc
range|:
name|connectors
control|)
block|{
name|IOUtils
operator|.
name|cleanupWithLogger
argument_list|(
name|LOG
argument_list|,
name|nnc
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|ExitStatus
operator|.
name|SUCCESS
operator|.
name|getExitCode
argument_list|()
return|;
block|}
DECL|method|checkKeytabAndInit (Configuration conf)
specifier|private
specifier|static
name|void
name|checkKeytabAndInit
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|conf
operator|.
name|getBoolean
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_BALANCER_KEYTAB_ENABLED_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_BALANCER_KEYTAB_ENABLED_DEFAULT
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Keytab is configured, will login using keytab."
argument_list|)
expr_stmt|;
name|UserGroupInformation
operator|.
name|setConfiguration
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|String
name|addr
init|=
name|conf
operator|.
name|get
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_BALANCER_ADDRESS_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_BALANCER_ADDRESS_DEFAULT
argument_list|)
decl_stmt|;
name|InetSocketAddress
name|socAddr
init|=
name|NetUtils
operator|.
name|createSocketAddr
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_BALANCER_ADDRESS_KEY
argument_list|)
decl_stmt|;
name|SecurityUtil
operator|.
name|login
argument_list|(
name|conf
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_BALANCER_KEYTAB_FILE_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_BALANCER_KERBEROS_PRINCIPAL_KEY
argument_list|,
name|socAddr
operator|.
name|getHostName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Given elaspedTime in ms, return a printable string */
DECL|method|time2Str (long elapsedTime)
specifier|private
specifier|static
name|String
name|time2Str
parameter_list|(
name|long
name|elapsedTime
parameter_list|)
block|{
name|String
name|unit
decl_stmt|;
name|double
name|time
init|=
name|elapsedTime
decl_stmt|;
if|if
condition|(
name|elapsedTime
operator|<
literal|1000
condition|)
block|{
name|unit
operator|=
literal|"milliseconds"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|elapsedTime
operator|<
literal|60
operator|*
literal|1000
condition|)
block|{
name|unit
operator|=
literal|"seconds"
expr_stmt|;
name|time
operator|=
name|time
operator|/
literal|1000
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|elapsedTime
operator|<
literal|3600
operator|*
literal|1000
condition|)
block|{
name|unit
operator|=
literal|"minutes"
expr_stmt|;
name|time
operator|=
name|time
operator|/
operator|(
literal|60
operator|*
literal|1000
operator|)
expr_stmt|;
block|}
else|else
block|{
name|unit
operator|=
literal|"hours"
expr_stmt|;
name|time
operator|=
name|time
operator|/
operator|(
literal|3600
operator|*
literal|1000
operator|)
expr_stmt|;
block|}
return|return
name|time
operator|+
literal|" "
operator|+
name|unit
return|;
block|}
DECL|class|Cli
specifier|static
class|class
name|Cli
extends|extends
name|Configured
implements|implements
name|Tool
block|{
comment|/**      * Parse arguments and then run Balancer.      *       * @param args command specific arguments.      * @return exit code. 0 indicates success, non-zero indicates failure.      */
annotation|@
name|Override
DECL|method|run (String[] args)
specifier|public
name|int
name|run
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
block|{
specifier|final
name|long
name|startTime
init|=
name|Time
operator|.
name|monotonicNow
argument_list|()
decl_stmt|;
specifier|final
name|Configuration
name|conf
init|=
name|getConf
argument_list|()
decl_stmt|;
try|try
block|{
name|checkReplicationPolicyCompatibility
argument_list|(
name|conf
argument_list|)
expr_stmt|;
specifier|final
name|Collection
argument_list|<
name|URI
argument_list|>
name|namenodes
init|=
name|DFSUtil
operator|.
name|getInternalNsRpcUris
argument_list|(
name|conf
argument_list|)
decl_stmt|;
return|return
name|Balancer
operator|.
name|run
argument_list|(
name|namenodes
argument_list|,
name|parse
argument_list|(
name|args
argument_list|)
argument_list|,
name|conf
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|e
operator|+
literal|".  Exiting ..."
argument_list|)
expr_stmt|;
return|return
name|ExitStatus
operator|.
name|IO_EXCEPTION
operator|.
name|getExitCode
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|e
operator|+
literal|".  Exiting ..."
argument_list|)
expr_stmt|;
return|return
name|ExitStatus
operator|.
name|INTERRUPTED
operator|.
name|getExitCode
argument_list|()
return|;
block|}
finally|finally
block|{
name|System
operator|.
name|out
operator|.
name|format
argument_list|(
literal|"%-24s "
argument_list|,
name|DateFormat
operator|.
name|getDateTimeInstance
argument_list|()
operator|.
name|format
argument_list|(
operator|new
name|Date
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Balancing took "
operator|+
name|time2Str
argument_list|(
name|Time
operator|.
name|monotonicNow
argument_list|()
operator|-
name|startTime
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** parse command line arguments */
DECL|method|parse (String[] args)
specifier|static
name|BalancerParameters
name|parse
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|excludedNodes
init|=
literal|null
decl_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|includedNodes
init|=
literal|null
decl_stmt|;
name|BalancerParameters
operator|.
name|Builder
name|b
init|=
operator|new
name|BalancerParameters
operator|.
name|Builder
argument_list|()
decl_stmt|;
if|if
condition|(
name|args
operator|!=
literal|null
condition|)
block|{
try|try
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|args
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
literal|"-threshold"
operator|.
name|equalsIgnoreCase
argument_list|(
name|args
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|checkArgument
argument_list|(
operator|++
name|i
operator|<
name|args
operator|.
name|length
argument_list|,
literal|"Threshold value is missing: args = "
operator|+
name|Arrays
operator|.
name|toString
argument_list|(
name|args
argument_list|)
argument_list|)
expr_stmt|;
try|try
block|{
name|double
name|threshold
init|=
name|Double
operator|.
name|parseDouble
argument_list|(
name|args
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|threshold
argument_list|<
literal|1
operator|||
name|threshold
argument_list|>
literal|100
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Number out of range: threshold = "
operator|+
name|threshold
argument_list|)
throw|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Using a threshold of "
operator|+
name|threshold
argument_list|)
expr_stmt|;
name|b
operator|.
name|setThreshold
argument_list|(
name|threshold
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Expecting a number in the range of [1.0, 100.0]: "
operator|+
name|args
index|[
name|i
index|]
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
elseif|else
if|if
condition|(
literal|"-policy"
operator|.
name|equalsIgnoreCase
argument_list|(
name|args
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|checkArgument
argument_list|(
operator|++
name|i
operator|<
name|args
operator|.
name|length
argument_list|,
literal|"Policy value is missing: args = "
operator|+
name|Arrays
operator|.
name|toString
argument_list|(
name|args
argument_list|)
argument_list|)
expr_stmt|;
try|try
block|{
name|b
operator|.
name|setBalancingPolicy
argument_list|(
name|BalancingPolicy
operator|.
name|parse
argument_list|(
name|args
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Illegal policy name: "
operator|+
name|args
index|[
name|i
index|]
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
elseif|else
if|if
condition|(
literal|"-exclude"
operator|.
name|equalsIgnoreCase
argument_list|(
name|args
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|excludedNodes
operator|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
expr_stmt|;
name|i
operator|=
name|processHostList
argument_list|(
name|args
argument_list|,
name|i
argument_list|,
literal|"exclude"
argument_list|,
name|excludedNodes
argument_list|)
expr_stmt|;
name|b
operator|.
name|setExcludedNodes
argument_list|(
name|excludedNodes
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|"-include"
operator|.
name|equalsIgnoreCase
argument_list|(
name|args
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|includedNodes
operator|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
expr_stmt|;
name|i
operator|=
name|processHostList
argument_list|(
name|args
argument_list|,
name|i
argument_list|,
literal|"include"
argument_list|,
name|includedNodes
argument_list|)
expr_stmt|;
name|b
operator|.
name|setIncludedNodes
argument_list|(
name|includedNodes
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|"-source"
operator|.
name|equalsIgnoreCase
argument_list|(
name|args
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|sourceNodes
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
name|i
operator|=
name|processHostList
argument_list|(
name|args
argument_list|,
name|i
argument_list|,
literal|"source"
argument_list|,
name|sourceNodes
argument_list|)
expr_stmt|;
name|b
operator|.
name|setSourceNodes
argument_list|(
name|sourceNodes
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|"-blockpools"
operator|.
name|equalsIgnoreCase
argument_list|(
name|args
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|checkArgument
argument_list|(
operator|++
name|i
operator|<
name|args
operator|.
name|length
argument_list|,
literal|"blockpools value is missing: args = "
operator|+
name|Arrays
operator|.
name|toString
argument_list|(
name|args
argument_list|)
argument_list|)
expr_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|blockpools
init|=
name|parseBlockPoolList
argument_list|(
name|args
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Balancer will run on the following blockpools: "
operator|+
name|blockpools
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|b
operator|.
name|setBlockpools
argument_list|(
name|blockpools
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|"-idleiterations"
operator|.
name|equalsIgnoreCase
argument_list|(
name|args
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|checkArgument
argument_list|(
operator|++
name|i
operator|<
name|args
operator|.
name|length
argument_list|,
literal|"idleiterations value is missing: args = "
operator|+
name|Arrays
operator|.
name|toString
argument_list|(
name|args
argument_list|)
argument_list|)
expr_stmt|;
name|int
name|maxIdleIteration
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|args
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Using a idleiterations of "
operator|+
name|maxIdleIteration
argument_list|)
expr_stmt|;
name|b
operator|.
name|setMaxIdleIteration
argument_list|(
name|maxIdleIteration
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|"-runDuringUpgrade"
operator|.
name|equalsIgnoreCase
argument_list|(
name|args
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|b
operator|.
name|setRunDuringUpgrade
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Will run the balancer even during an ongoing HDFS "
operator|+
literal|"upgrade. Most users will not want to run the balancer "
operator|+
literal|"during an upgrade since it will not affect used space "
operator|+
literal|"on over-utilized machines."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"args = "
operator|+
name|Arrays
operator|.
name|toString
argument_list|(
name|args
argument_list|)
argument_list|)
throw|;
block|}
block|}
name|checkArgument
argument_list|(
name|excludedNodes
operator|==
literal|null
operator|||
name|includedNodes
operator|==
literal|null
argument_list|,
literal|"-exclude and -include options cannot be specified together."
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RuntimeException
name|e
parameter_list|)
block|{
name|printUsage
argument_list|(
name|System
operator|.
name|err
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
return|return
name|b
operator|.
name|build
argument_list|()
return|;
block|}
DECL|method|processHostList (String[] args, int i, String type, Set<String> nodes)
specifier|private
specifier|static
name|int
name|processHostList
parameter_list|(
name|String
index|[]
name|args
parameter_list|,
name|int
name|i
parameter_list|,
name|String
name|type
parameter_list|,
name|Set
argument_list|<
name|String
argument_list|>
name|nodes
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
operator|++
name|i
operator|<
name|args
operator|.
name|length
argument_list|,
literal|"List of %s nodes | -f<filename> is missing: args=%s"
argument_list|,
name|type
argument_list|,
name|Arrays
operator|.
name|toString
argument_list|(
name|args
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
literal|"-f"
operator|.
name|equalsIgnoreCase
argument_list|(
name|args
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
operator|++
name|i
operator|<
name|args
operator|.
name|length
argument_list|,
literal|"File containing %s nodes is not specified: args=%s"
argument_list|,
name|type
argument_list|,
name|Arrays
operator|.
name|toString
argument_list|(
name|args
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|String
name|filename
init|=
name|args
index|[
name|i
index|]
decl_stmt|;
try|try
block|{
name|HostsFileReader
operator|.
name|readFileToSet
argument_list|(
name|type
argument_list|,
name|filename
argument_list|,
name|nodes
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Failed to read "
operator|+
name|type
operator|+
literal|" node list from file: "
operator|+
name|filename
argument_list|)
throw|;
block|}
block|}
else|else
block|{
specifier|final
name|String
index|[]
name|addresses
init|=
name|StringUtils
operator|.
name|getTrimmedStrings
argument_list|(
name|args
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|nodes
operator|.
name|addAll
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|addresses
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|i
return|;
block|}
DECL|method|parseBlockPoolList (String string)
specifier|private
specifier|static
name|Set
argument_list|<
name|String
argument_list|>
name|parseBlockPoolList
parameter_list|(
name|String
name|string
parameter_list|)
block|{
name|String
index|[]
name|addrs
init|=
name|StringUtils
operator|.
name|getTrimmedStrings
argument_list|(
name|string
argument_list|)
decl_stmt|;
return|return
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|addrs
argument_list|)
argument_list|)
return|;
block|}
DECL|method|printUsage (PrintStream out)
specifier|private
specifier|static
name|void
name|printUsage
parameter_list|(
name|PrintStream
name|out
parameter_list|)
block|{
name|out
operator|.
name|println
argument_list|(
name|USAGE
operator|+
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Run a balancer    * @param args Command line arguments    */
DECL|method|main (String[] args)
specifier|public
specifier|static
name|void
name|main
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
block|{
if|if
condition|(
name|DFSUtil
operator|.
name|parseHelpArgument
argument_list|(
name|args
argument_list|,
name|USAGE
argument_list|,
name|System
operator|.
name|out
argument_list|,
literal|true
argument_list|)
condition|)
block|{
name|System
operator|.
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|System
operator|.
name|exit
argument_list|(
name|ToolRunner
operator|.
name|run
argument_list|(
operator|new
name|HdfsConfiguration
argument_list|()
argument_list|,
operator|new
name|Cli
argument_list|()
argument_list|,
name|args
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Exiting balancer due an exception"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|System
operator|.
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

