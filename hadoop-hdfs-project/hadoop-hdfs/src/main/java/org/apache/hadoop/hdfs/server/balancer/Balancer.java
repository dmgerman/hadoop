begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdfs.server.balancer
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|balancer
package|;
end_package

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkArgument
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocolPB
operator|.
name|PBHelper
operator|.
name|vintPrefixed
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|BufferedInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|BufferedOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|PrintStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|Socket
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URI
import|;
end_import

begin_import
import|import
name|java
operator|.
name|text
operator|.
name|DateFormat
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Date
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Formatter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutionException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutorService
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Executors
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Future
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configured
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|HdfsConfiguration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|Block
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|DatanodeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|ExtendedBlock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|HdfsConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|HdfsConstants
operator|.
name|DatanodeReportType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|datatransfer
operator|.
name|DataTransferEncryptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|datatransfer
operator|.
name|IOStreamPair
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|datatransfer
operator|.
name|Sender
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|proto
operator|.
name|DataTransferProtos
operator|.
name|BlockOpResponseProto
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|proto
operator|.
name|DataTransferProtos
operator|.
name|Status
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|security
operator|.
name|token
operator|.
name|block
operator|.
name|BlockTokenIdentifier
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|blockmanagement
operator|.
name|BlockPlacementPolicy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|blockmanagement
operator|.
name|BlockPlacementPolicyDefault
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|HdfsServerConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|UnsupportedActionException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|BlocksWithLocations
operator|.
name|BlockWithLocations
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|net
operator|.
name|NetUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|net
operator|.
name|NetworkTopology
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|net
operator|.
name|Node
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|token
operator|.
name|Token
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Time
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Tool
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|ToolRunner
import|;
end_import

begin_comment
comment|/**<p>The balancer is a tool that balances disk space usage on an HDFS cluster  * when some datanodes become full or when new empty nodes join the cluster.  * The tool is deployed as an application program that can be run by the   * cluster administrator on a live HDFS cluster while applications  * adding and deleting files.  *   *<p>SYNOPSIS  *<pre>  * To start:  *      bin/start-balancer.sh [-threshold<threshold>]  *      Example: bin/ start-balancer.sh   *                     start the balancer with a default threshold of 10%  *               bin/ start-balancer.sh -threshold 5  *                     start the balancer with a threshold of 5%  * To stop:  *      bin/ stop-balancer.sh  *</pre>  *   *<p>DESCRIPTION  *<p>The threshold parameter is a fraction in the range of (1%, 100%) with a   * default value of 10%. The threshold sets a target for whether the cluster   * is balanced. A cluster is balanced if for each datanode, the utilization   * of the node (ratio of used space at the node to total capacity of the node)   * differs from the utilization of the (ratio of used space in the cluster   * to total capacity of the cluster) by no more than the threshold value.   * The smaller the threshold, the more balanced a cluster will become.   * It takes more time to run the balancer for small threshold values.   * Also for a very small threshold the cluster may not be able to reach the   * balanced state when applications write and delete files concurrently.  *   *<p>The tool moves blocks from highly utilized datanodes to poorly   * utilized datanodes iteratively. In each iteration a datanode moves or   * receives no more than the lesser of 10G bytes or the threshold fraction   * of its capacity. Each iteration runs no more than 20 minutes.  * At the end of each iteration, the balancer obtains updated datanodes  * information from the namenode.  *   *<p>A system property that limits the balancer's use of bandwidth is   * defined in the default configuration file:  *<pre>  *<property>  *<name>dfs.balance.bandwidthPerSec</name>  *<value>1048576</value>  *<description>  Specifies the maximum bandwidth that each datanode   * can utilize for the balancing purpose in term of the number of bytes   * per second.</description>  *</property>  *</pre>  *   *<p>This property determines the maximum speed at which a block will be   * moved from one datanode to another. The default value is 1MB/s. The higher   * the bandwidth, the faster a cluster can reach the balanced state,   * but with greater competition with application processes. If an   * administrator changes the value of this property in the configuration   * file, the change is observed when HDFS is next restarted.  *   *<p>MONITERING BALANCER PROGRESS  *<p>After the balancer is started, an output file name where the balancer   * progress will be recorded is printed on the screen.  The administrator   * can monitor the running of the balancer by reading the output file.   * The output shows the balancer's status iteration by iteration. In each   * iteration it prints the starting time, the iteration number, the total   * number of bytes that have been moved in the previous iterations,   * the total number of bytes that are left to move in order for the cluster   * to be balanced, and the number of bytes that are being moved in this   * iteration. Normally "Bytes Already Moved" is increasing while "Bytes Left   * To Move" is decreasing.  *   *<p>Running multiple instances of the balancer in an HDFS cluster is   * prohibited by the tool.  *   *<p>The balancer automatically exits when any of the following five   * conditions is satisfied:  *<ol>  *<li>The cluster is balanced;  *<li>No block can be moved;  *<li>No block has been moved for five consecutive iterations;  *<li>An IOException occurs while communicating with the namenode;  *<li>Another balancer is running.  *</ol>  *   *<p>Upon exit, a balancer returns an exit code and prints one of the   * following messages to the output file in corresponding to the above exit   * reasons:  *<ol>  *<li>The cluster is balanced. Exiting  *<li>No block can be moved. Exiting...  *<li>No block has been moved for 5 iterations. Exiting...  *<li>Received an IO exception: failure reason. Exiting...  *<li>Another balancer is running. Exiting...  *</ol>  *   *<p>The administrator can interrupt the execution of the balancer at any   * time by running the command "stop-balancer.sh" on the machine where the   * balancer is running.  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
DECL|class|Balancer
specifier|public
class|class
name|Balancer
block|{
DECL|field|LOG
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|Balancer
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|MAX_BLOCKS_SIZE_TO_FETCH
specifier|final
specifier|private
specifier|static
name|long
name|MAX_BLOCKS_SIZE_TO_FETCH
init|=
literal|2
operator|*
literal|1024
operator|*
literal|1024
operator|*
literal|1024L
decl_stmt|;
comment|//2GB
DECL|field|WIN_WIDTH
specifier|private
specifier|static
name|long
name|WIN_WIDTH
init|=
literal|5400
operator|*
literal|1000L
decl_stmt|;
comment|// 1.5 hour
comment|/** The maximum number of concurrent blocks moves for     * balancing purpose at a datanode    */
DECL|field|MAX_NUM_CONCURRENT_MOVES
specifier|public
specifier|static
specifier|final
name|int
name|MAX_NUM_CONCURRENT_MOVES
init|=
literal|5
decl_stmt|;
DECL|field|MAX_NO_PENDING_BLOCK_ITERATIONS
specifier|private
specifier|static
specifier|final
name|int
name|MAX_NO_PENDING_BLOCK_ITERATIONS
init|=
literal|5
decl_stmt|;
DECL|field|USAGE
specifier|private
specifier|static
specifier|final
name|String
name|USAGE
init|=
literal|"Usage: java "
operator|+
name|Balancer
operator|.
name|class
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|"\n\t[-policy<policy>]\tthe balancing policy: "
operator|+
name|BalancingPolicy
operator|.
name|Node
operator|.
name|INSTANCE
operator|.
name|getName
argument_list|()
operator|+
literal|" or "
operator|+
name|BalancingPolicy
operator|.
name|Pool
operator|.
name|INSTANCE
operator|.
name|getName
argument_list|()
operator|+
literal|"\n\t[-threshold<threshold>]\tPercentage of disk capacity"
decl_stmt|;
DECL|field|nnc
specifier|private
specifier|final
name|NameNodeConnector
name|nnc
decl_stmt|;
DECL|field|policy
specifier|private
specifier|final
name|BalancingPolicy
name|policy
decl_stmt|;
DECL|field|threshold
specifier|private
specifier|final
name|double
name|threshold
decl_stmt|;
comment|// all data node lists
DECL|field|overUtilizedDatanodes
specifier|private
name|Collection
argument_list|<
name|Source
argument_list|>
name|overUtilizedDatanodes
init|=
operator|new
name|LinkedList
argument_list|<
name|Source
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|aboveAvgUtilizedDatanodes
specifier|private
name|Collection
argument_list|<
name|Source
argument_list|>
name|aboveAvgUtilizedDatanodes
init|=
operator|new
name|LinkedList
argument_list|<
name|Source
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|belowAvgUtilizedDatanodes
specifier|private
name|Collection
argument_list|<
name|BalancerDatanode
argument_list|>
name|belowAvgUtilizedDatanodes
init|=
operator|new
name|LinkedList
argument_list|<
name|BalancerDatanode
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|underUtilizedDatanodes
specifier|private
name|Collection
argument_list|<
name|BalancerDatanode
argument_list|>
name|underUtilizedDatanodes
init|=
operator|new
name|LinkedList
argument_list|<
name|BalancerDatanode
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|sources
specifier|private
name|Collection
argument_list|<
name|Source
argument_list|>
name|sources
init|=
operator|new
name|HashSet
argument_list|<
name|Source
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|targets
specifier|private
name|Collection
argument_list|<
name|BalancerDatanode
argument_list|>
name|targets
init|=
operator|new
name|HashSet
argument_list|<
name|BalancerDatanode
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|globalBlockList
specifier|private
name|Map
argument_list|<
name|Block
argument_list|,
name|BalancerBlock
argument_list|>
name|globalBlockList
init|=
operator|new
name|HashMap
argument_list|<
name|Block
argument_list|,
name|BalancerBlock
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|movedBlocks
specifier|private
name|MovedBlocks
name|movedBlocks
init|=
operator|new
name|MovedBlocks
argument_list|()
decl_stmt|;
comment|/** Map (datanodeUuid -> BalancerDatanodes) */
DECL|field|datanodeMap
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|BalancerDatanode
argument_list|>
name|datanodeMap
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|BalancerDatanode
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|cluster
specifier|private
name|NetworkTopology
name|cluster
decl_stmt|;
DECL|field|moverExecutor
specifier|private
specifier|final
name|ExecutorService
name|moverExecutor
decl_stmt|;
DECL|field|dispatcherExecutor
specifier|private
specifier|final
name|ExecutorService
name|dispatcherExecutor
decl_stmt|;
comment|/* This class keeps track of a scheduled block move */
DECL|class|PendingBlockMove
specifier|private
class|class
name|PendingBlockMove
block|{
DECL|field|block
specifier|private
name|BalancerBlock
name|block
decl_stmt|;
DECL|field|source
specifier|private
name|Source
name|source
decl_stmt|;
DECL|field|proxySource
specifier|private
name|BalancerDatanode
name|proxySource
decl_stmt|;
DECL|field|target
specifier|private
name|BalancerDatanode
name|target
decl_stmt|;
comment|/** constructor */
DECL|method|PendingBlockMove ()
specifier|private
name|PendingBlockMove
parameter_list|()
block|{     }
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
specifier|final
name|Block
name|b
init|=
name|block
operator|.
name|getBlock
argument_list|()
decl_stmt|;
return|return
name|b
operator|+
literal|" with size="
operator|+
name|b
operator|.
name|getNumBytes
argument_list|()
operator|+
literal|" from "
operator|+
name|source
operator|.
name|getDisplayName
argument_list|()
operator|+
literal|" to "
operator|+
name|target
operator|.
name|getDisplayName
argument_list|()
operator|+
literal|" through "
operator|+
name|proxySource
operator|.
name|getDisplayName
argument_list|()
return|;
block|}
comment|/* choose a block& a proxy source for this pendingMove       * whose source& target have already been chosen.      *       * Return true if a block and its proxy are chosen; false otherwise      */
DECL|method|chooseBlockAndProxy ()
specifier|private
name|boolean
name|chooseBlockAndProxy
parameter_list|()
block|{
comment|// iterate all source's blocks until find a good one
for|for
control|(
name|Iterator
argument_list|<
name|BalancerBlock
argument_list|>
name|blocks
init|=
name|source
operator|.
name|getBlockIterator
argument_list|()
init|;
name|blocks
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
if|if
condition|(
name|markMovedIfGoodBlock
argument_list|(
name|blocks
operator|.
name|next
argument_list|()
argument_list|)
condition|)
block|{
name|blocks
operator|.
name|remove
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/* Return true if the given block is good for the tentative move;      * If it is good, add it to the moved list to marked as "Moved".      * A block is good if      * 1. it is a good candidate; see isGoodBlockCandidate      * 2. can find a proxy source that's not busy for this move      */
DECL|method|markMovedIfGoodBlock (BalancerBlock block)
specifier|private
name|boolean
name|markMovedIfGoodBlock
parameter_list|(
name|BalancerBlock
name|block
parameter_list|)
block|{
synchronized|synchronized
init|(
name|block
init|)
block|{
synchronized|synchronized
init|(
name|movedBlocks
init|)
block|{
if|if
condition|(
name|isGoodBlockCandidate
argument_list|(
name|source
argument_list|,
name|target
argument_list|,
name|block
argument_list|)
condition|)
block|{
name|this
operator|.
name|block
operator|=
name|block
expr_stmt|;
if|if
condition|(
name|chooseProxySource
argument_list|()
condition|)
block|{
name|movedBlocks
operator|.
name|add
argument_list|(
name|block
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Decided to move "
operator|+
name|this
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
block|}
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/* Now we find out source, target, and block, we need to find a proxy      *       * @return true if a proxy is found; otherwise false      */
DECL|method|chooseProxySource ()
specifier|private
name|boolean
name|chooseProxySource
parameter_list|()
block|{
specifier|final
name|DatanodeInfo
name|targetDN
init|=
name|target
operator|.
name|getDatanode
argument_list|()
decl_stmt|;
name|boolean
name|find
init|=
literal|false
decl_stmt|;
for|for
control|(
name|BalancerDatanode
name|loc
range|:
name|block
operator|.
name|getLocations
argument_list|()
control|)
block|{
comment|// check if there is replica which is on the same rack with the target
if|if
condition|(
name|cluster
operator|.
name|isOnSameRack
argument_list|(
name|loc
operator|.
name|getDatanode
argument_list|()
argument_list|,
name|targetDN
argument_list|)
operator|&&
name|addTo
argument_list|(
name|loc
argument_list|)
condition|)
block|{
name|find
operator|=
literal|true
expr_stmt|;
comment|// if cluster is not nodegroup aware or the proxy is on the same
comment|// nodegroup with target, then we already find the nearest proxy
if|if
condition|(
operator|!
name|cluster
operator|.
name|isNodeGroupAware
argument_list|()
operator|||
name|cluster
operator|.
name|isOnSameNodeGroup
argument_list|(
name|loc
operator|.
name|getDatanode
argument_list|()
argument_list|,
name|targetDN
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
if|if
condition|(
operator|!
name|find
condition|)
block|{
comment|// find out a non-busy replica out of rack of target
name|find
operator|=
name|addTo
argument_list|(
name|loc
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|find
return|;
block|}
comment|// add a BalancerDatanode as proxy source for specific block movement
DECL|method|addTo (BalancerDatanode bdn)
specifier|private
name|boolean
name|addTo
parameter_list|(
name|BalancerDatanode
name|bdn
parameter_list|)
block|{
if|if
condition|(
name|bdn
operator|.
name|addPendingBlock
argument_list|(
name|this
argument_list|)
condition|)
block|{
name|proxySource
operator|=
name|bdn
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
comment|/* Dispatch the block move task to the proxy source& wait for the response      */
DECL|method|dispatch ()
specifier|private
name|void
name|dispatch
parameter_list|()
block|{
name|Socket
name|sock
init|=
operator|new
name|Socket
argument_list|()
decl_stmt|;
name|DataOutputStream
name|out
init|=
literal|null
decl_stmt|;
name|DataInputStream
name|in
init|=
literal|null
decl_stmt|;
try|try
block|{
name|sock
operator|.
name|connect
argument_list|(
name|NetUtils
operator|.
name|createSocketAddr
argument_list|(
name|target
operator|.
name|datanode
operator|.
name|getXferAddr
argument_list|()
argument_list|)
argument_list|,
name|HdfsServerConstants
operator|.
name|READ_TIMEOUT
argument_list|)
expr_stmt|;
name|sock
operator|.
name|setKeepAlive
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|OutputStream
name|unbufOut
init|=
name|sock
operator|.
name|getOutputStream
argument_list|()
decl_stmt|;
name|InputStream
name|unbufIn
init|=
name|sock
operator|.
name|getInputStream
argument_list|()
decl_stmt|;
if|if
condition|(
name|nnc
operator|.
name|getDataEncryptionKey
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|IOStreamPair
name|encryptedStreams
init|=
name|DataTransferEncryptor
operator|.
name|getEncryptedStreams
argument_list|(
name|unbufOut
argument_list|,
name|unbufIn
argument_list|,
name|nnc
operator|.
name|getDataEncryptionKey
argument_list|()
argument_list|)
decl_stmt|;
name|unbufOut
operator|=
name|encryptedStreams
operator|.
name|out
expr_stmt|;
name|unbufIn
operator|=
name|encryptedStreams
operator|.
name|in
expr_stmt|;
block|}
name|out
operator|=
operator|new
name|DataOutputStream
argument_list|(
operator|new
name|BufferedOutputStream
argument_list|(
name|unbufOut
argument_list|,
name|HdfsConstants
operator|.
name|IO_FILE_BUFFER_SIZE
argument_list|)
argument_list|)
expr_stmt|;
name|in
operator|=
operator|new
name|DataInputStream
argument_list|(
operator|new
name|BufferedInputStream
argument_list|(
name|unbufIn
argument_list|,
name|HdfsConstants
operator|.
name|IO_FILE_BUFFER_SIZE
argument_list|)
argument_list|)
expr_stmt|;
name|sendRequest
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|receiveResponse
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|bytesMoved
operator|.
name|inc
argument_list|(
name|block
operator|.
name|getNumBytes
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Successfully moved "
operator|+
name|this
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to move "
operator|+
name|this
operator|+
literal|": "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|IOUtils
operator|.
name|closeStream
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|IOUtils
operator|.
name|closeStream
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|IOUtils
operator|.
name|closeSocket
argument_list|(
name|sock
argument_list|)
expr_stmt|;
name|proxySource
operator|.
name|removePendingBlock
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|target
operator|.
name|removePendingBlock
argument_list|(
name|this
argument_list|)
expr_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
name|reset
argument_list|()
expr_stmt|;
block|}
synchronized|synchronized
init|(
name|Balancer
operator|.
name|this
init|)
block|{
name|Balancer
operator|.
name|this
operator|.
name|notifyAll
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/* Send a block replace request to the output stream*/
DECL|method|sendRequest (DataOutputStream out)
specifier|private
name|void
name|sendRequest
parameter_list|(
name|DataOutputStream
name|out
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|ExtendedBlock
name|eb
init|=
operator|new
name|ExtendedBlock
argument_list|(
name|nnc
operator|.
name|blockpoolID
argument_list|,
name|block
operator|.
name|getBlock
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|Token
argument_list|<
name|BlockTokenIdentifier
argument_list|>
name|accessToken
init|=
name|nnc
operator|.
name|getAccessToken
argument_list|(
name|eb
argument_list|)
decl_stmt|;
operator|new
name|Sender
argument_list|(
name|out
argument_list|)
operator|.
name|replaceBlock
argument_list|(
name|eb
argument_list|,
name|accessToken
argument_list|,
name|source
operator|.
name|getStorageID
argument_list|()
argument_list|,
name|proxySource
operator|.
name|getDatanode
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/* Receive a block copy response from the input stream */
DECL|method|receiveResponse (DataInputStream in)
specifier|private
name|void
name|receiveResponse
parameter_list|(
name|DataInputStream
name|in
parameter_list|)
throws|throws
name|IOException
block|{
name|BlockOpResponseProto
name|response
init|=
name|BlockOpResponseProto
operator|.
name|parseFrom
argument_list|(
name|vintPrefixed
argument_list|(
name|in
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|response
operator|.
name|getStatus
argument_list|()
operator|!=
name|Status
operator|.
name|SUCCESS
condition|)
block|{
if|if
condition|(
name|response
operator|.
name|getStatus
argument_list|()
operator|==
name|Status
operator|.
name|ERROR_ACCESS_TOKEN
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"block move failed due to access token error"
argument_list|)
throw|;
throw|throw
operator|new
name|IOException
argument_list|(
literal|"block move is failed: "
operator|+
name|response
operator|.
name|getMessage
argument_list|()
argument_list|)
throw|;
block|}
block|}
comment|/* reset the object */
DECL|method|reset ()
specifier|private
name|void
name|reset
parameter_list|()
block|{
name|block
operator|=
literal|null
expr_stmt|;
name|source
operator|=
literal|null
expr_stmt|;
name|proxySource
operator|=
literal|null
expr_stmt|;
name|target
operator|=
literal|null
expr_stmt|;
block|}
comment|/* start a thread to dispatch the block move */
DECL|method|scheduleBlockMove ()
specifier|private
name|void
name|scheduleBlockMove
parameter_list|()
block|{
name|moverExecutor
operator|.
name|execute
argument_list|(
operator|new
name|Runnable
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Start moving "
operator|+
name|PendingBlockMove
operator|.
name|this
argument_list|)
expr_stmt|;
block|}
name|dispatch
argument_list|()
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* A class for keeping track of blocks in the Balancer */
DECL|class|BalancerBlock
specifier|static
specifier|private
class|class
name|BalancerBlock
block|{
DECL|field|block
specifier|private
name|Block
name|block
decl_stmt|;
comment|// the block
DECL|field|locations
specifier|private
name|List
argument_list|<
name|BalancerDatanode
argument_list|>
name|locations
init|=
operator|new
name|ArrayList
argument_list|<
name|BalancerDatanode
argument_list|>
argument_list|(
literal|3
argument_list|)
decl_stmt|;
comment|// its locations
comment|/* Constructor */
DECL|method|BalancerBlock (Block block)
specifier|private
name|BalancerBlock
parameter_list|(
name|Block
name|block
parameter_list|)
block|{
name|this
operator|.
name|block
operator|=
name|block
expr_stmt|;
block|}
comment|/* clean block locations */
DECL|method|clearLocations ()
specifier|private
specifier|synchronized
name|void
name|clearLocations
parameter_list|()
block|{
name|locations
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
comment|/* add a location */
DECL|method|addLocation (BalancerDatanode datanode)
specifier|private
specifier|synchronized
name|void
name|addLocation
parameter_list|(
name|BalancerDatanode
name|datanode
parameter_list|)
block|{
if|if
condition|(
operator|!
name|locations
operator|.
name|contains
argument_list|(
name|datanode
argument_list|)
condition|)
block|{
name|locations
operator|.
name|add
argument_list|(
name|datanode
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Return if the block is located on<code>datanode</code> */
DECL|method|isLocatedOnDatanode ( BalancerDatanode datanode)
specifier|private
specifier|synchronized
name|boolean
name|isLocatedOnDatanode
parameter_list|(
name|BalancerDatanode
name|datanode
parameter_list|)
block|{
return|return
name|locations
operator|.
name|contains
argument_list|(
name|datanode
argument_list|)
return|;
block|}
comment|/* Return its locations */
DECL|method|getLocations ()
specifier|private
specifier|synchronized
name|List
argument_list|<
name|BalancerDatanode
argument_list|>
name|getLocations
parameter_list|()
block|{
return|return
name|locations
return|;
block|}
comment|/* Return the block */
DECL|method|getBlock ()
specifier|private
name|Block
name|getBlock
parameter_list|()
block|{
return|return
name|block
return|;
block|}
comment|/* Return the length of the block */
DECL|method|getNumBytes ()
specifier|private
name|long
name|getNumBytes
parameter_list|()
block|{
return|return
name|block
operator|.
name|getNumBytes
argument_list|()
return|;
block|}
block|}
comment|/* The class represents a desired move of bytes between two nodes     * and the target.    * An object of this class is stored in a source node.     */
DECL|class|NodeTask
specifier|static
specifier|private
class|class
name|NodeTask
block|{
DECL|field|datanode
specifier|private
name|BalancerDatanode
name|datanode
decl_stmt|;
comment|//target node
DECL|field|size
specifier|private
name|long
name|size
decl_stmt|;
comment|//bytes scheduled to move
comment|/* constructor */
DECL|method|NodeTask (BalancerDatanode datanode, long size)
specifier|private
name|NodeTask
parameter_list|(
name|BalancerDatanode
name|datanode
parameter_list|,
name|long
name|size
parameter_list|)
block|{
name|this
operator|.
name|datanode
operator|=
name|datanode
expr_stmt|;
name|this
operator|.
name|size
operator|=
name|size
expr_stmt|;
block|}
comment|/* Get the node */
DECL|method|getDatanode ()
specifier|private
name|BalancerDatanode
name|getDatanode
parameter_list|()
block|{
return|return
name|datanode
return|;
block|}
comment|/* Get the number of bytes that need to be moved */
DECL|method|getSize ()
specifier|private
name|long
name|getSize
parameter_list|()
block|{
return|return
name|size
return|;
block|}
block|}
comment|/* A class that keeps track of a datanode in Balancer */
DECL|class|BalancerDatanode
specifier|private
specifier|static
class|class
name|BalancerDatanode
block|{
DECL|field|MAX_SIZE_TO_MOVE
specifier|final
specifier|private
specifier|static
name|long
name|MAX_SIZE_TO_MOVE
init|=
literal|10
operator|*
literal|1024
operator|*
literal|1024
operator|*
literal|1024L
decl_stmt|;
comment|//10GB
DECL|field|datanode
specifier|final
name|DatanodeInfo
name|datanode
decl_stmt|;
DECL|field|utilization
specifier|final
name|double
name|utilization
decl_stmt|;
DECL|field|maxSize2Move
specifier|final
name|long
name|maxSize2Move
decl_stmt|;
DECL|field|scheduledSize
specifier|private
name|long
name|scheduledSize
init|=
literal|0L
decl_stmt|;
comment|//  blocks being moved but not confirmed yet
DECL|field|pendingBlocks
specifier|private
name|List
argument_list|<
name|PendingBlockMove
argument_list|>
name|pendingBlocks
init|=
operator|new
name|ArrayList
argument_list|<
name|PendingBlockMove
argument_list|>
argument_list|(
name|MAX_NUM_CONCURRENT_MOVES
argument_list|)
decl_stmt|;
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|"["
operator|+
name|datanode
operator|+
literal|", utilization="
operator|+
name|utilization
operator|+
literal|"]"
return|;
block|}
comment|/* Constructor       * Depending on avgutil& threshold, calculate maximum bytes to move       */
DECL|method|BalancerDatanode (DatanodeInfo node, BalancingPolicy policy, double threshold)
specifier|private
name|BalancerDatanode
parameter_list|(
name|DatanodeInfo
name|node
parameter_list|,
name|BalancingPolicy
name|policy
parameter_list|,
name|double
name|threshold
parameter_list|)
block|{
name|datanode
operator|=
name|node
expr_stmt|;
name|utilization
operator|=
name|policy
operator|.
name|getUtilization
argument_list|(
name|node
argument_list|)
expr_stmt|;
specifier|final
name|double
name|avgUtil
init|=
name|policy
operator|.
name|getAvgUtilization
argument_list|()
decl_stmt|;
name|long
name|maxSizeToMove
decl_stmt|;
if|if
condition|(
name|utilization
operator|>=
name|avgUtil
operator|+
name|threshold
operator|||
name|utilization
operator|<=
name|avgUtil
operator|-
name|threshold
condition|)
block|{
name|maxSizeToMove
operator|=
call|(
name|long
call|)
argument_list|(
name|threshold
operator|*
name|datanode
operator|.
name|getCapacity
argument_list|()
operator|/
literal|100
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|maxSizeToMove
operator|=
call|(
name|long
call|)
argument_list|(
name|Math
operator|.
name|abs
argument_list|(
name|avgUtil
operator|-
name|utilization
argument_list|)
operator|*
name|datanode
operator|.
name|getCapacity
argument_list|()
operator|/
literal|100
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|utilization
operator|<
name|avgUtil
condition|)
block|{
name|maxSizeToMove
operator|=
name|Math
operator|.
name|min
argument_list|(
name|datanode
operator|.
name|getRemaining
argument_list|()
argument_list|,
name|maxSizeToMove
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|maxSize2Move
operator|=
name|Math
operator|.
name|min
argument_list|(
name|MAX_SIZE_TO_MOVE
argument_list|,
name|maxSizeToMove
argument_list|)
expr_stmt|;
block|}
comment|/** Get the datanode */
DECL|method|getDatanode ()
specifier|protected
name|DatanodeInfo
name|getDatanode
parameter_list|()
block|{
return|return
name|datanode
return|;
block|}
comment|/** Get the name of the datanode */
DECL|method|getDisplayName ()
specifier|protected
name|String
name|getDisplayName
parameter_list|()
block|{
return|return
name|datanode
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/* Get the storage id of the datanode */
DECL|method|getStorageID ()
specifier|protected
name|String
name|getStorageID
parameter_list|()
block|{
return|return
name|datanode
operator|.
name|getDatanodeUuid
argument_list|()
return|;
block|}
comment|/** Decide if still need to move more bytes */
DECL|method|hasSpaceForScheduling ()
specifier|protected
specifier|synchronized
name|boolean
name|hasSpaceForScheduling
parameter_list|()
block|{
return|return
name|scheduledSize
operator|<
name|maxSize2Move
return|;
block|}
comment|/** Return the total number of bytes that need to be moved */
DECL|method|availableSizeToMove ()
specifier|protected
specifier|synchronized
name|long
name|availableSizeToMove
parameter_list|()
block|{
return|return
name|maxSize2Move
operator|-
name|scheduledSize
return|;
block|}
comment|/** increment scheduled size */
DECL|method|incScheduledSize (long size)
specifier|protected
specifier|synchronized
name|void
name|incScheduledSize
parameter_list|(
name|long
name|size
parameter_list|)
block|{
name|scheduledSize
operator|+=
name|size
expr_stmt|;
block|}
comment|/** decrement scheduled size */
DECL|method|decScheduledSize (long size)
specifier|protected
specifier|synchronized
name|void
name|decScheduledSize
parameter_list|(
name|long
name|size
parameter_list|)
block|{
name|scheduledSize
operator|-=
name|size
expr_stmt|;
block|}
comment|/** get scheduled size */
DECL|method|getScheduledSize ()
specifier|protected
specifier|synchronized
name|long
name|getScheduledSize
parameter_list|()
block|{
return|return
name|scheduledSize
return|;
block|}
comment|/** get scheduled size */
DECL|method|setScheduledSize (long size)
specifier|protected
specifier|synchronized
name|void
name|setScheduledSize
parameter_list|(
name|long
name|size
parameter_list|)
block|{
name|scheduledSize
operator|=
name|size
expr_stmt|;
block|}
comment|/* Check if the node can schedule more blocks to move */
DECL|method|isPendingQNotFull ()
specifier|synchronized
specifier|private
name|boolean
name|isPendingQNotFull
parameter_list|()
block|{
if|if
condition|(
name|pendingBlocks
operator|.
name|size
argument_list|()
operator|<
name|MAX_NUM_CONCURRENT_MOVES
condition|)
block|{
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
comment|/* Check if all the dispatched moves are done */
DECL|method|isPendingQEmpty ()
specifier|synchronized
specifier|private
name|boolean
name|isPendingQEmpty
parameter_list|()
block|{
return|return
name|pendingBlocks
operator|.
name|isEmpty
argument_list|()
return|;
block|}
comment|/* Add a scheduled block move to the node */
DECL|method|addPendingBlock ( PendingBlockMove pendingBlock)
specifier|private
specifier|synchronized
name|boolean
name|addPendingBlock
parameter_list|(
name|PendingBlockMove
name|pendingBlock
parameter_list|)
block|{
if|if
condition|(
name|isPendingQNotFull
argument_list|()
condition|)
block|{
return|return
name|pendingBlocks
operator|.
name|add
argument_list|(
name|pendingBlock
argument_list|)
return|;
block|}
return|return
literal|false
return|;
block|}
comment|/* Remove a scheduled block move from the node */
DECL|method|removePendingBlock ( PendingBlockMove pendingBlock)
specifier|private
specifier|synchronized
name|boolean
name|removePendingBlock
parameter_list|(
name|PendingBlockMove
name|pendingBlock
parameter_list|)
block|{
return|return
name|pendingBlocks
operator|.
name|remove
argument_list|(
name|pendingBlock
argument_list|)
return|;
block|}
block|}
comment|/** A node that can be the sources of a block move */
DECL|class|Source
specifier|private
class|class
name|Source
extends|extends
name|BalancerDatanode
block|{
comment|/* A thread that initiates a block move       * and waits for block move to complete */
DECL|class|BlockMoveDispatcher
specifier|private
class|class
name|BlockMoveDispatcher
implements|implements
name|Runnable
block|{
annotation|@
name|Override
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
name|dispatchBlocks
argument_list|()
expr_stmt|;
block|}
block|}
DECL|field|nodeTasks
specifier|private
name|ArrayList
argument_list|<
name|NodeTask
argument_list|>
name|nodeTasks
init|=
operator|new
name|ArrayList
argument_list|<
name|NodeTask
argument_list|>
argument_list|(
literal|2
argument_list|)
decl_stmt|;
DECL|field|blocksToReceive
specifier|private
name|long
name|blocksToReceive
init|=
literal|0L
decl_stmt|;
comment|/* source blocks point to balancerBlocks in the global list because      * we want to keep one copy of a block in balancer and be aware that      * the locations are changing over time.      */
DECL|field|srcBlockList
specifier|private
name|List
argument_list|<
name|BalancerBlock
argument_list|>
name|srcBlockList
init|=
operator|new
name|ArrayList
argument_list|<
name|BalancerBlock
argument_list|>
argument_list|()
decl_stmt|;
comment|/* constructor */
DECL|method|Source (DatanodeInfo node, BalancingPolicy policy, double threshold)
specifier|private
name|Source
parameter_list|(
name|DatanodeInfo
name|node
parameter_list|,
name|BalancingPolicy
name|policy
parameter_list|,
name|double
name|threshold
parameter_list|)
block|{
name|super
argument_list|(
name|node
argument_list|,
name|policy
argument_list|,
name|threshold
argument_list|)
expr_stmt|;
block|}
comment|/** Add a node task */
DECL|method|addNodeTask (NodeTask task)
specifier|private
name|void
name|addNodeTask
parameter_list|(
name|NodeTask
name|task
parameter_list|)
block|{
assert|assert
operator|(
name|task
operator|.
name|datanode
operator|!=
name|this
operator|)
operator|:
literal|"Source and target are the same "
operator|+
name|datanode
assert|;
name|incScheduledSize
argument_list|(
name|task
operator|.
name|getSize
argument_list|()
argument_list|)
expr_stmt|;
name|nodeTasks
operator|.
name|add
argument_list|(
name|task
argument_list|)
expr_stmt|;
block|}
comment|/* Return an iterator to this source's blocks */
DECL|method|getBlockIterator ()
specifier|private
name|Iterator
argument_list|<
name|BalancerBlock
argument_list|>
name|getBlockIterator
parameter_list|()
block|{
return|return
name|srcBlockList
operator|.
name|iterator
argument_list|()
return|;
block|}
comment|/* fetch new blocks of this source from namenode and      * update this source's block list& the global block list      * Return the total size of the received blocks in the number of bytes.      */
DECL|method|getBlockList ()
specifier|private
name|long
name|getBlockList
parameter_list|()
throws|throws
name|IOException
block|{
name|BlockWithLocations
index|[]
name|newBlocks
init|=
name|nnc
operator|.
name|namenode
operator|.
name|getBlocks
argument_list|(
name|datanode
argument_list|,
name|Math
operator|.
name|min
argument_list|(
name|MAX_BLOCKS_SIZE_TO_FETCH
argument_list|,
name|blocksToReceive
argument_list|)
argument_list|)
operator|.
name|getBlocks
argument_list|()
decl_stmt|;
name|long
name|bytesReceived
init|=
literal|0
decl_stmt|;
for|for
control|(
name|BlockWithLocations
name|blk
range|:
name|newBlocks
control|)
block|{
name|bytesReceived
operator|+=
name|blk
operator|.
name|getBlock
argument_list|()
operator|.
name|getNumBytes
argument_list|()
expr_stmt|;
name|BalancerBlock
name|block
decl_stmt|;
synchronized|synchronized
init|(
name|globalBlockList
init|)
block|{
name|block
operator|=
name|globalBlockList
operator|.
name|get
argument_list|(
name|blk
operator|.
name|getBlock
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|block
operator|==
literal|null
condition|)
block|{
name|block
operator|=
operator|new
name|BalancerBlock
argument_list|(
name|blk
operator|.
name|getBlock
argument_list|()
argument_list|)
expr_stmt|;
name|globalBlockList
operator|.
name|put
argument_list|(
name|blk
operator|.
name|getBlock
argument_list|()
argument_list|,
name|block
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|block
operator|.
name|clearLocations
argument_list|()
expr_stmt|;
block|}
synchronized|synchronized
init|(
name|block
init|)
block|{
comment|// update locations
for|for
control|(
name|String
name|datanodeUuid
range|:
name|blk
operator|.
name|getDatanodeUuids
argument_list|()
control|)
block|{
specifier|final
name|BalancerDatanode
name|d
init|=
name|datanodeMap
operator|.
name|get
argument_list|(
name|datanodeUuid
argument_list|)
decl_stmt|;
if|if
condition|(
name|datanode
operator|!=
literal|null
condition|)
block|{
comment|// not an unknown datanode
name|block
operator|.
name|addLocation
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|srcBlockList
operator|.
name|contains
argument_list|(
name|block
argument_list|)
operator|&&
name|isGoodBlockCandidate
argument_list|(
name|block
argument_list|)
condition|)
block|{
comment|// filter bad candidates
name|srcBlockList
operator|.
name|add
argument_list|(
name|block
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|bytesReceived
return|;
block|}
comment|/* Decide if the given block is a good candidate to move or not */
DECL|method|isGoodBlockCandidate (BalancerBlock block)
specifier|private
name|boolean
name|isGoodBlockCandidate
parameter_list|(
name|BalancerBlock
name|block
parameter_list|)
block|{
for|for
control|(
name|NodeTask
name|nodeTask
range|:
name|nodeTasks
control|)
block|{
if|if
condition|(
name|Balancer
operator|.
name|this
operator|.
name|isGoodBlockCandidate
argument_list|(
name|this
argument_list|,
name|nodeTask
operator|.
name|datanode
argument_list|,
name|block
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/* Return a block that's good for the source thread to dispatch immediately      * The block's source, target, and proxy source are determined too.      * When choosing proxy and target, source& target throttling      * has been considered. They are chosen only when they have the capacity      * to support this block move.      * The block should be dispatched immediately after this method is returned.      */
DECL|method|chooseNextBlockToMove ()
specifier|private
name|PendingBlockMove
name|chooseNextBlockToMove
parameter_list|()
block|{
for|for
control|(
name|Iterator
argument_list|<
name|NodeTask
argument_list|>
name|tasks
init|=
name|nodeTasks
operator|.
name|iterator
argument_list|()
init|;
name|tasks
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|NodeTask
name|task
init|=
name|tasks
operator|.
name|next
argument_list|()
decl_stmt|;
name|BalancerDatanode
name|target
init|=
name|task
operator|.
name|getDatanode
argument_list|()
decl_stmt|;
name|PendingBlockMove
name|pendingBlock
init|=
operator|new
name|PendingBlockMove
argument_list|()
decl_stmt|;
if|if
condition|(
name|target
operator|.
name|addPendingBlock
argument_list|(
name|pendingBlock
argument_list|)
condition|)
block|{
comment|// target is not busy, so do a tentative block allocation
name|pendingBlock
operator|.
name|source
operator|=
name|this
expr_stmt|;
name|pendingBlock
operator|.
name|target
operator|=
name|target
expr_stmt|;
if|if
condition|(
name|pendingBlock
operator|.
name|chooseBlockAndProxy
argument_list|()
condition|)
block|{
name|long
name|blockSize
init|=
name|pendingBlock
operator|.
name|block
operator|.
name|getNumBytes
argument_list|()
decl_stmt|;
name|decScheduledSize
argument_list|(
name|blockSize
argument_list|)
expr_stmt|;
name|task
operator|.
name|size
operator|-=
name|blockSize
expr_stmt|;
if|if
condition|(
name|task
operator|.
name|size
operator|==
literal|0
condition|)
block|{
name|tasks
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
return|return
name|pendingBlock
return|;
block|}
else|else
block|{
comment|// cancel the tentative move
name|target
operator|.
name|removePendingBlock
argument_list|(
name|pendingBlock
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/* iterate all source's blocks to remove moved ones */
DECL|method|filterMovedBlocks ()
specifier|private
name|void
name|filterMovedBlocks
parameter_list|()
block|{
for|for
control|(
name|Iterator
argument_list|<
name|BalancerBlock
argument_list|>
name|blocks
init|=
name|getBlockIterator
argument_list|()
init|;
name|blocks
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
if|if
condition|(
name|movedBlocks
operator|.
name|contains
argument_list|(
name|blocks
operator|.
name|next
argument_list|()
argument_list|)
condition|)
block|{
name|blocks
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
block|}
DECL|field|SOURCE_BLOCK_LIST_MIN_SIZE
specifier|private
specifier|static
specifier|final
name|int
name|SOURCE_BLOCK_LIST_MIN_SIZE
init|=
literal|5
decl_stmt|;
comment|/* Return if should fetch more blocks from namenode */
DECL|method|shouldFetchMoreBlocks ()
specifier|private
name|boolean
name|shouldFetchMoreBlocks
parameter_list|()
block|{
return|return
name|srcBlockList
operator|.
name|size
argument_list|()
operator|<
name|SOURCE_BLOCK_LIST_MIN_SIZE
operator|&&
name|blocksToReceive
operator|>
literal|0
return|;
block|}
comment|/* This method iteratively does the following:      * it first selects a block to move,      * then sends a request to the proxy source to start the block move      * when the source's block list falls below a threshold, it asks      * the namenode for more blocks.      * It terminates when it has dispatch enough block move tasks or      * it has received enough blocks from the namenode, or       * the elapsed time of the iteration has exceeded the max time limit.      */
DECL|field|MAX_ITERATION_TIME
specifier|private
specifier|static
specifier|final
name|long
name|MAX_ITERATION_TIME
init|=
literal|20
operator|*
literal|60
operator|*
literal|1000L
decl_stmt|;
comment|//20 mins
DECL|method|dispatchBlocks ()
specifier|private
name|void
name|dispatchBlocks
parameter_list|()
block|{
name|long
name|startTime
init|=
name|Time
operator|.
name|now
argument_list|()
decl_stmt|;
name|long
name|scheduledSize
init|=
name|getScheduledSize
argument_list|()
decl_stmt|;
name|this
operator|.
name|blocksToReceive
operator|=
literal|2
operator|*
name|scheduledSize
expr_stmt|;
name|boolean
name|isTimeUp
init|=
literal|false
decl_stmt|;
name|int
name|noPendingBlockIteration
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|!
name|isTimeUp
operator|&&
name|getScheduledSize
argument_list|()
operator|>
literal|0
operator|&&
operator|(
operator|!
name|srcBlockList
operator|.
name|isEmpty
argument_list|()
operator|||
name|blocksToReceive
operator|>
literal|0
operator|)
condition|)
block|{
name|PendingBlockMove
name|pendingBlock
init|=
name|chooseNextBlockToMove
argument_list|()
decl_stmt|;
if|if
condition|(
name|pendingBlock
operator|!=
literal|null
condition|)
block|{
comment|// move the block
name|pendingBlock
operator|.
name|scheduleBlockMove
argument_list|()
expr_stmt|;
continue|continue;
block|}
comment|/* Since we can not schedule any block to move,          * filter any moved blocks from the source block list and          * check if we should fetch more blocks from the namenode          */
name|filterMovedBlocks
argument_list|()
expr_stmt|;
comment|// filter already moved blocks
if|if
condition|(
name|shouldFetchMoreBlocks
argument_list|()
condition|)
block|{
comment|// fetch new blocks
try|try
block|{
name|blocksToReceive
operator|-=
name|getBlockList
argument_list|()
expr_stmt|;
continue|continue;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Exception while getting block list"
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
comment|// source node cannot find a pendingBlockToMove, iteration +1
name|noPendingBlockIteration
operator|++
expr_stmt|;
comment|// in case no blocks can be moved for source node's task,
comment|// jump out of while-loop after 5 iterations.
if|if
condition|(
name|noPendingBlockIteration
operator|>=
name|MAX_NO_PENDING_BLOCK_ITERATIONS
condition|)
block|{
name|setScheduledSize
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|// check if time is up or not
if|if
condition|(
name|Time
operator|.
name|now
argument_list|()
operator|-
name|startTime
operator|>
name|MAX_ITERATION_TIME
condition|)
block|{
name|isTimeUp
operator|=
literal|true
expr_stmt|;
continue|continue;
block|}
comment|/* Now we can not schedule any block to move and there are          * no new blocks added to the source block list, so we wait.           */
try|try
block|{
synchronized|synchronized
init|(
name|Balancer
operator|.
name|this
init|)
block|{
name|Balancer
operator|.
name|this
operator|.
name|wait
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
comment|// wait for targets/sources to be idle
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ignored
parameter_list|)
block|{         }
block|}
block|}
block|}
comment|/* Check that this Balancer is compatible with the Block Placement Policy    * used by the Namenode.    */
DECL|method|checkReplicationPolicyCompatibility (Configuration conf )
specifier|private
specifier|static
name|void
name|checkReplicationPolicyCompatibility
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|UnsupportedActionException
block|{
if|if
condition|(
operator|!
operator|(
name|BlockPlacementPolicy
operator|.
name|getInstance
argument_list|(
name|conf
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
operator|instanceof
name|BlockPlacementPolicyDefault
operator|)
condition|)
block|{
throw|throw
operator|new
name|UnsupportedActionException
argument_list|(
literal|"Balancer without BlockPlacementPolicyDefault"
argument_list|)
throw|;
block|}
block|}
comment|/**    * Construct a balancer.    * Initialize balancer. It sets the value of the threshold, and     * builds the communication proxies to    * namenode as a client and a secondary namenode and retry proxies    * when connection fails.    */
DECL|method|Balancer (NameNodeConnector theblockpool, Parameters p, Configuration conf)
name|Balancer
parameter_list|(
name|NameNodeConnector
name|theblockpool
parameter_list|,
name|Parameters
name|p
parameter_list|,
name|Configuration
name|conf
parameter_list|)
block|{
name|this
operator|.
name|threshold
operator|=
name|p
operator|.
name|threshold
expr_stmt|;
name|this
operator|.
name|policy
operator|=
name|p
operator|.
name|policy
expr_stmt|;
name|this
operator|.
name|nnc
operator|=
name|theblockpool
expr_stmt|;
name|cluster
operator|=
name|NetworkTopology
operator|.
name|getInstance
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|moverExecutor
operator|=
name|Executors
operator|.
name|newFixedThreadPool
argument_list|(
name|conf
operator|.
name|getInt
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_BALANCER_MOVERTHREADS_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_BALANCER_MOVERTHREADS_DEFAULT
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|dispatcherExecutor
operator|=
name|Executors
operator|.
name|newFixedThreadPool
argument_list|(
name|conf
operator|.
name|getInt
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_BALANCER_DISPATCHERTHREADS_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_BALANCER_DISPATCHERTHREADS_DEFAULT
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Given a data node set, build a network topology and decide    * over-utilized datanodes, above average utilized datanodes,     * below average utilized datanodes, and underutilized datanodes.     * The input data node set is shuffled before the datanodes     * are put into the over-utilized datanodes, above average utilized    * datanodes, below average utilized datanodes, and    * underutilized datanodes lists. This will add some randomness    * to the node matching later on.    *     * @return the total number of bytes that are     *                needed to move to make the cluster balanced.    * @param datanodes a set of datanodes    */
DECL|method|initNodes (DatanodeInfo[] datanodes)
specifier|private
name|long
name|initNodes
parameter_list|(
name|DatanodeInfo
index|[]
name|datanodes
parameter_list|)
block|{
comment|// compute average utilization
for|for
control|(
name|DatanodeInfo
name|datanode
range|:
name|datanodes
control|)
block|{
if|if
condition|(
name|datanode
operator|.
name|isDecommissioned
argument_list|()
operator|||
name|datanode
operator|.
name|isDecommissionInProgress
argument_list|()
condition|)
block|{
continue|continue;
comment|// ignore decommissioning or decommissioned nodes
block|}
name|policy
operator|.
name|accumulateSpaces
argument_list|(
name|datanode
argument_list|)
expr_stmt|;
block|}
name|policy
operator|.
name|initAvgUtilization
argument_list|()
expr_stmt|;
comment|/*create network topology and all data node lists:       * overloaded, above-average, below-average, and underloaded      * we alternates the accessing of the given datanodes array either by      * an increasing order or a decreasing order.      */
name|long
name|overLoadedBytes
init|=
literal|0L
decl_stmt|,
name|underLoadedBytes
init|=
literal|0L
decl_stmt|;
for|for
control|(
name|DatanodeInfo
name|datanode
range|:
name|DFSUtil
operator|.
name|shuffle
argument_list|(
name|datanodes
argument_list|)
control|)
block|{
if|if
condition|(
name|datanode
operator|.
name|isDecommissioned
argument_list|()
operator|||
name|datanode
operator|.
name|isDecommissionInProgress
argument_list|()
condition|)
block|{
continue|continue;
comment|// ignore decommissioning or decommissioned nodes
block|}
name|cluster
operator|.
name|add
argument_list|(
name|datanode
argument_list|)
expr_stmt|;
name|BalancerDatanode
name|datanodeS
decl_stmt|;
specifier|final
name|double
name|avg
init|=
name|policy
operator|.
name|getAvgUtilization
argument_list|()
decl_stmt|;
if|if
condition|(
name|policy
operator|.
name|getUtilization
argument_list|(
name|datanode
argument_list|)
operator|>=
name|avg
condition|)
block|{
name|datanodeS
operator|=
operator|new
name|Source
argument_list|(
name|datanode
argument_list|,
name|policy
argument_list|,
name|threshold
argument_list|)
expr_stmt|;
if|if
condition|(
name|isAboveAvgUtilized
argument_list|(
name|datanodeS
argument_list|)
condition|)
block|{
name|this
operator|.
name|aboveAvgUtilizedDatanodes
operator|.
name|add
argument_list|(
operator|(
name|Source
operator|)
name|datanodeS
argument_list|)
expr_stmt|;
block|}
else|else
block|{
assert|assert
operator|(
name|isOverUtilized
argument_list|(
name|datanodeS
argument_list|)
operator|)
operator|:
name|datanodeS
operator|.
name|getDisplayName
argument_list|()
operator|+
literal|"is not an overUtilized node"
assert|;
name|this
operator|.
name|overUtilizedDatanodes
operator|.
name|add
argument_list|(
operator|(
name|Source
operator|)
name|datanodeS
argument_list|)
expr_stmt|;
name|overLoadedBytes
operator|+=
call|(
name|long
call|)
argument_list|(
operator|(
name|datanodeS
operator|.
name|utilization
operator|-
name|avg
operator|-
name|threshold
operator|)
operator|*
name|datanodeS
operator|.
name|datanode
operator|.
name|getCapacity
argument_list|()
operator|/
literal|100.0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|datanodeS
operator|=
operator|new
name|BalancerDatanode
argument_list|(
name|datanode
argument_list|,
name|policy
argument_list|,
name|threshold
argument_list|)
expr_stmt|;
if|if
condition|(
name|isBelowOrEqualAvgUtilized
argument_list|(
name|datanodeS
argument_list|)
condition|)
block|{
name|this
operator|.
name|belowAvgUtilizedDatanodes
operator|.
name|add
argument_list|(
name|datanodeS
argument_list|)
expr_stmt|;
block|}
else|else
block|{
assert|assert
name|isUnderUtilized
argument_list|(
name|datanodeS
argument_list|)
operator|:
literal|"isUnderUtilized("
operator|+
name|datanodeS
operator|.
name|getDisplayName
argument_list|()
operator|+
literal|")="
operator|+
name|isUnderUtilized
argument_list|(
name|datanodeS
argument_list|)
operator|+
literal|", utilization="
operator|+
name|datanodeS
operator|.
name|utilization
assert|;
name|this
operator|.
name|underUtilizedDatanodes
operator|.
name|add
argument_list|(
name|datanodeS
argument_list|)
expr_stmt|;
name|underLoadedBytes
operator|+=
call|(
name|long
call|)
argument_list|(
operator|(
name|avg
operator|-
name|threshold
operator|-
name|datanodeS
operator|.
name|utilization
operator|)
operator|*
name|datanodeS
operator|.
name|datanode
operator|.
name|getCapacity
argument_list|()
operator|/
literal|100.0
argument_list|)
expr_stmt|;
block|}
block|}
name|datanodeMap
operator|.
name|put
argument_list|(
name|datanode
operator|.
name|getDatanodeUuid
argument_list|()
argument_list|,
name|datanodeS
argument_list|)
expr_stmt|;
block|}
comment|//logging
name|logNodes
argument_list|()
expr_stmt|;
assert|assert
operator|(
name|this
operator|.
name|datanodeMap
operator|.
name|size
argument_list|()
operator|==
name|overUtilizedDatanodes
operator|.
name|size
argument_list|()
operator|+
name|underUtilizedDatanodes
operator|.
name|size
argument_list|()
operator|+
name|aboveAvgUtilizedDatanodes
operator|.
name|size
argument_list|()
operator|+
name|belowAvgUtilizedDatanodes
operator|.
name|size
argument_list|()
operator|)
operator|:
literal|"Mismatched number of datanodes"
assert|;
comment|// return number of bytes to be moved in order to make the cluster balanced
return|return
name|Math
operator|.
name|max
argument_list|(
name|overLoadedBytes
argument_list|,
name|underLoadedBytes
argument_list|)
return|;
block|}
comment|/* log the over utilized& under utilized nodes */
DECL|method|logNodes ()
specifier|private
name|void
name|logNodes
parameter_list|()
block|{
name|logNodes
argument_list|(
literal|"over-utilized"
argument_list|,
name|overUtilizedDatanodes
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|logNodes
argument_list|(
literal|"above-average"
argument_list|,
name|aboveAvgUtilizedDatanodes
argument_list|)
expr_stmt|;
name|logNodes
argument_list|(
literal|"below-average"
argument_list|,
name|belowAvgUtilizedDatanodes
argument_list|)
expr_stmt|;
block|}
name|logNodes
argument_list|(
literal|"underutilized"
argument_list|,
name|underUtilizedDatanodes
argument_list|)
expr_stmt|;
block|}
DECL|method|logNodes ( String name, Collection<T> nodes)
specifier|private
specifier|static
parameter_list|<
name|T
extends|extends
name|BalancerDatanode
parameter_list|>
name|void
name|logNodes
parameter_list|(
name|String
name|name
parameter_list|,
name|Collection
argument_list|<
name|T
argument_list|>
name|nodes
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
name|nodes
operator|.
name|size
argument_list|()
operator|+
literal|" "
operator|+
name|name
operator|+
literal|": "
operator|+
name|nodes
argument_list|)
expr_stmt|;
block|}
comment|/** A matcher interface for matching nodes. */
DECL|interface|Matcher
specifier|private
interface|interface
name|Matcher
block|{
comment|/** Given the cluster topology, does the left node match the right node? */
DECL|method|match (NetworkTopology cluster, Node left, Node right)
name|boolean
name|match
parameter_list|(
name|NetworkTopology
name|cluster
parameter_list|,
name|Node
name|left
parameter_list|,
name|Node
name|right
parameter_list|)
function_decl|;
block|}
comment|/** Match datanodes in the same node group. */
DECL|field|SAME_NODE_GROUP
specifier|static
specifier|final
name|Matcher
name|SAME_NODE_GROUP
init|=
operator|new
name|Matcher
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|match
parameter_list|(
name|NetworkTopology
name|cluster
parameter_list|,
name|Node
name|left
parameter_list|,
name|Node
name|right
parameter_list|)
block|{
return|return
name|cluster
operator|.
name|isOnSameNodeGroup
argument_list|(
name|left
argument_list|,
name|right
argument_list|)
return|;
block|}
block|}
decl_stmt|;
comment|/** Match datanodes in the same rack. */
DECL|field|SAME_RACK
specifier|static
specifier|final
name|Matcher
name|SAME_RACK
init|=
operator|new
name|Matcher
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|match
parameter_list|(
name|NetworkTopology
name|cluster
parameter_list|,
name|Node
name|left
parameter_list|,
name|Node
name|right
parameter_list|)
block|{
return|return
name|cluster
operator|.
name|isOnSameRack
argument_list|(
name|left
argument_list|,
name|right
argument_list|)
return|;
block|}
block|}
decl_stmt|;
comment|/** Match any datanode with any other datanode. */
DECL|field|ANY_OTHER
specifier|static
specifier|final
name|Matcher
name|ANY_OTHER
init|=
operator|new
name|Matcher
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|match
parameter_list|(
name|NetworkTopology
name|cluster
parameter_list|,
name|Node
name|left
parameter_list|,
name|Node
name|right
parameter_list|)
block|{
return|return
name|left
operator|!=
name|right
return|;
block|}
block|}
decl_stmt|;
comment|/**    * Decide all<source, target> pairs and    * the number of bytes to move from a source to a target    * Maximum bytes to be moved per node is    * Min(1 Band worth of bytes,  MAX_SIZE_TO_MOVE).    * Return total number of bytes to move in this iteration    */
DECL|method|chooseNodes ()
specifier|private
name|long
name|chooseNodes
parameter_list|()
block|{
comment|// First, match nodes on the same node group if cluster is node group aware
if|if
condition|(
name|cluster
operator|.
name|isNodeGroupAware
argument_list|()
condition|)
block|{
name|chooseNodes
argument_list|(
name|SAME_NODE_GROUP
argument_list|)
expr_stmt|;
block|}
comment|// Then, match nodes on the same rack
name|chooseNodes
argument_list|(
name|SAME_RACK
argument_list|)
expr_stmt|;
comment|// At last, match all remaining nodes
name|chooseNodes
argument_list|(
name|ANY_OTHER
argument_list|)
expr_stmt|;
assert|assert
operator|(
name|datanodeMap
operator|.
name|size
argument_list|()
operator|>=
name|sources
operator|.
name|size
argument_list|()
operator|+
name|targets
operator|.
name|size
argument_list|()
operator|)
operator|:
literal|"Mismatched number of datanodes ("
operator|+
name|datanodeMap
operator|.
name|size
argument_list|()
operator|+
literal|" total, "
operator|+
name|sources
operator|.
name|size
argument_list|()
operator|+
literal|" sources, "
operator|+
name|targets
operator|.
name|size
argument_list|()
operator|+
literal|" targets)"
assert|;
name|long
name|bytesToMove
init|=
literal|0L
decl_stmt|;
for|for
control|(
name|Source
name|src
range|:
name|sources
control|)
block|{
name|bytesToMove
operator|+=
name|src
operator|.
name|getScheduledSize
argument_list|()
expr_stmt|;
block|}
return|return
name|bytesToMove
return|;
block|}
comment|/** Decide all<source, target> pairs according to the matcher. */
DECL|method|chooseNodes (final Matcher matcher)
specifier|private
name|void
name|chooseNodes
parameter_list|(
specifier|final
name|Matcher
name|matcher
parameter_list|)
block|{
comment|/* first step: match each overUtilized datanode (source) to      * one or more underUtilized datanodes (targets).      */
name|chooseDatanodes
argument_list|(
name|overUtilizedDatanodes
argument_list|,
name|underUtilizedDatanodes
argument_list|,
name|matcher
argument_list|)
expr_stmt|;
comment|/* match each remaining overutilized datanode (source) to       * below average utilized datanodes (targets).      * Note only overutilized datanodes that haven't had that max bytes to move      * satisfied in step 1 are selected      */
name|chooseDatanodes
argument_list|(
name|overUtilizedDatanodes
argument_list|,
name|belowAvgUtilizedDatanodes
argument_list|,
name|matcher
argument_list|)
expr_stmt|;
comment|/* match each remaining underutilized datanode (target) to       * above average utilized datanodes (source).      * Note only underutilized datanodes that have not had that max bytes to      * move satisfied in step 1 are selected.      */
name|chooseDatanodes
argument_list|(
name|underUtilizedDatanodes
argument_list|,
name|aboveAvgUtilizedDatanodes
argument_list|,
name|matcher
argument_list|)
expr_stmt|;
block|}
comment|/**    * For each datanode, choose matching nodes from the candidates. Either the    * datanodes or the candidates are source nodes with (utilization> Avg), and    * the others are target nodes with (utilization< Avg).    */
specifier|private
parameter_list|<
name|D
extends|extends
name|BalancerDatanode
parameter_list|,
name|C
extends|extends
name|BalancerDatanode
parameter_list|>
name|void
DECL|method|chooseDatanodes (Collection<D> datanodes, Collection<C> candidates, Matcher matcher)
name|chooseDatanodes
parameter_list|(
name|Collection
argument_list|<
name|D
argument_list|>
name|datanodes
parameter_list|,
name|Collection
argument_list|<
name|C
argument_list|>
name|candidates
parameter_list|,
name|Matcher
name|matcher
parameter_list|)
block|{
for|for
control|(
name|Iterator
argument_list|<
name|D
argument_list|>
name|i
init|=
name|datanodes
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
specifier|final
name|D
name|datanode
init|=
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
for|for
control|(
init|;
name|chooseForOneDatanode
argument_list|(
name|datanode
argument_list|,
name|candidates
argument_list|,
name|matcher
argument_list|)
condition|;
control|)
empty_stmt|;
if|if
condition|(
operator|!
name|datanode
operator|.
name|hasSpaceForScheduling
argument_list|()
condition|)
block|{
name|i
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**    * For the given datanode, choose a candidate and then schedule it.    * @return true if a candidate is chosen; false if no candidates is chosen.    */
DECL|method|chooseForOneDatanode ( BalancerDatanode dn, Collection<C> candidates, Matcher matcher)
specifier|private
parameter_list|<
name|C
extends|extends
name|BalancerDatanode
parameter_list|>
name|boolean
name|chooseForOneDatanode
parameter_list|(
name|BalancerDatanode
name|dn
parameter_list|,
name|Collection
argument_list|<
name|C
argument_list|>
name|candidates
parameter_list|,
name|Matcher
name|matcher
parameter_list|)
block|{
specifier|final
name|Iterator
argument_list|<
name|C
argument_list|>
name|i
init|=
name|candidates
operator|.
name|iterator
argument_list|()
decl_stmt|;
specifier|final
name|C
name|chosen
init|=
name|chooseCandidate
argument_list|(
name|dn
argument_list|,
name|i
argument_list|,
name|matcher
argument_list|)
decl_stmt|;
if|if
condition|(
name|chosen
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|dn
operator|instanceof
name|Source
condition|)
block|{
name|matchSourceWithTargetToMove
argument_list|(
operator|(
name|Source
operator|)
name|dn
argument_list|,
name|chosen
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|matchSourceWithTargetToMove
argument_list|(
operator|(
name|Source
operator|)
name|chosen
argument_list|,
name|dn
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|chosen
operator|.
name|hasSpaceForScheduling
argument_list|()
condition|)
block|{
name|i
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
DECL|method|matchSourceWithTargetToMove ( Source source, BalancerDatanode target)
specifier|private
name|void
name|matchSourceWithTargetToMove
parameter_list|(
name|Source
name|source
parameter_list|,
name|BalancerDatanode
name|target
parameter_list|)
block|{
name|long
name|size
init|=
name|Math
operator|.
name|min
argument_list|(
name|source
operator|.
name|availableSizeToMove
argument_list|()
argument_list|,
name|target
operator|.
name|availableSizeToMove
argument_list|()
argument_list|)
decl_stmt|;
name|NodeTask
name|nodeTask
init|=
operator|new
name|NodeTask
argument_list|(
name|target
argument_list|,
name|size
argument_list|)
decl_stmt|;
name|source
operator|.
name|addNodeTask
argument_list|(
name|nodeTask
argument_list|)
expr_stmt|;
name|target
operator|.
name|incScheduledSize
argument_list|(
name|nodeTask
operator|.
name|getSize
argument_list|()
argument_list|)
expr_stmt|;
name|sources
operator|.
name|add
argument_list|(
name|source
argument_list|)
expr_stmt|;
name|targets
operator|.
name|add
argument_list|(
name|target
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Decided to move "
operator|+
name|StringUtils
operator|.
name|byteDesc
argument_list|(
name|size
argument_list|)
operator|+
literal|" bytes from "
operator|+
name|source
operator|.
name|datanode
operator|.
name|getName
argument_list|()
operator|+
literal|" to "
operator|+
name|target
operator|.
name|datanode
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/** Choose a candidate for the given datanode. */
specifier|private
parameter_list|<
name|D
extends|extends
name|BalancerDatanode
parameter_list|,
name|C
extends|extends
name|BalancerDatanode
parameter_list|>
DECL|method|chooseCandidate (D dn, Iterator<C> candidates, Matcher matcher)
name|C
name|chooseCandidate
parameter_list|(
name|D
name|dn
parameter_list|,
name|Iterator
argument_list|<
name|C
argument_list|>
name|candidates
parameter_list|,
name|Matcher
name|matcher
parameter_list|)
block|{
if|if
condition|(
name|dn
operator|.
name|hasSpaceForScheduling
argument_list|()
condition|)
block|{
for|for
control|(
init|;
name|candidates
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
specifier|final
name|C
name|c
init|=
name|candidates
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|c
operator|.
name|hasSpaceForScheduling
argument_list|()
condition|)
block|{
name|candidates
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|matcher
operator|.
name|match
argument_list|(
name|cluster
argument_list|,
name|dn
operator|.
name|getDatanode
argument_list|()
argument_list|,
name|c
operator|.
name|getDatanode
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|c
return|;
block|}
block|}
block|}
return|return
literal|null
return|;
block|}
DECL|class|BytesMoved
specifier|private
specifier|static
class|class
name|BytesMoved
block|{
DECL|field|bytesMoved
specifier|private
name|long
name|bytesMoved
init|=
literal|0L
decl_stmt|;
empty_stmt|;
DECL|method|inc ( long bytes )
specifier|private
specifier|synchronized
name|void
name|inc
parameter_list|(
name|long
name|bytes
parameter_list|)
block|{
name|bytesMoved
operator|+=
name|bytes
expr_stmt|;
block|}
DECL|method|get ()
specifier|private
specifier|synchronized
name|long
name|get
parameter_list|()
block|{
return|return
name|bytesMoved
return|;
block|}
block|}
empty_stmt|;
DECL|field|bytesMoved
specifier|private
name|BytesMoved
name|bytesMoved
init|=
operator|new
name|BytesMoved
argument_list|()
decl_stmt|;
comment|/* Start a thread to dispatch block moves for each source.     * The thread selects blocks to move& sends request to proxy source to    * initiate block move. The process is flow controlled. Block selection is    * blocked if there are too many un-confirmed block moves.    * Return the total number of bytes successfully moved in this iteration.    */
DECL|method|dispatchBlockMoves ()
specifier|private
name|long
name|dispatchBlockMoves
parameter_list|()
throws|throws
name|InterruptedException
block|{
name|long
name|bytesLastMoved
init|=
name|bytesMoved
operator|.
name|get
argument_list|()
decl_stmt|;
name|Future
argument_list|<
name|?
argument_list|>
index|[]
name|futures
init|=
operator|new
name|Future
argument_list|<
name|?
argument_list|>
index|[
name|sources
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Source
name|source
range|:
name|sources
control|)
block|{
name|futures
index|[
name|i
operator|++
index|]
operator|=
name|dispatcherExecutor
operator|.
name|submit
argument_list|(
name|source
operator|.
expr|new
name|BlockMoveDispatcher
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// wait for all dispatcher threads to finish
for|for
control|(
name|Future
argument_list|<
name|?
argument_list|>
name|future
range|:
name|futures
control|)
block|{
try|try
block|{
name|future
operator|.
name|get
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ExecutionException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Dispatcher thread failed"
argument_list|,
name|e
operator|.
name|getCause
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|// wait for all block moving to be done
name|waitForMoveCompletion
argument_list|()
expr_stmt|;
return|return
name|bytesMoved
operator|.
name|get
argument_list|()
operator|-
name|bytesLastMoved
return|;
block|}
comment|// The sleeping period before checking if block move is completed again
DECL|field|blockMoveWaitTime
specifier|static
specifier|private
name|long
name|blockMoveWaitTime
init|=
literal|30000L
decl_stmt|;
comment|/** set the sleeping period for block move completion check */
DECL|method|setBlockMoveWaitTime (long time)
specifier|static
name|void
name|setBlockMoveWaitTime
parameter_list|(
name|long
name|time
parameter_list|)
block|{
name|blockMoveWaitTime
operator|=
name|time
expr_stmt|;
block|}
comment|/* wait for all block move confirmations     * by checking each target's pendingMove queue     */
DECL|method|waitForMoveCompletion ()
specifier|private
name|void
name|waitForMoveCompletion
parameter_list|()
block|{
name|boolean
name|shouldWait
decl_stmt|;
do|do
block|{
name|shouldWait
operator|=
literal|false
expr_stmt|;
for|for
control|(
name|BalancerDatanode
name|target
range|:
name|targets
control|)
block|{
if|if
condition|(
operator|!
name|target
operator|.
name|isPendingQEmpty
argument_list|()
condition|)
block|{
name|shouldWait
operator|=
literal|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|shouldWait
condition|)
block|{
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|blockMoveWaitTime
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ignored
parameter_list|)
block|{         }
block|}
block|}
do|while
condition|(
name|shouldWait
condition|)
do|;
block|}
comment|/** This window makes sure to keep blocks that have been moved within 1.5 hour.    * Old window has blocks that are older;    * Current window has blocks that are more recent;    * Cleanup method triggers the check if blocks in the old window are    * more than 1.5 hour old. If yes, purge the old window and then    * move blocks in current window to old window.    */
DECL|class|MovedBlocks
specifier|private
specifier|static
class|class
name|MovedBlocks
block|{
DECL|field|lastCleanupTime
specifier|private
name|long
name|lastCleanupTime
init|=
name|Time
operator|.
name|now
argument_list|()
decl_stmt|;
DECL|field|CUR_WIN
specifier|final
specifier|private
specifier|static
name|int
name|CUR_WIN
init|=
literal|0
decl_stmt|;
DECL|field|OLD_WIN
specifier|final
specifier|private
specifier|static
name|int
name|OLD_WIN
init|=
literal|1
decl_stmt|;
DECL|field|NUM_WINS
specifier|final
specifier|private
specifier|static
name|int
name|NUM_WINS
init|=
literal|2
decl_stmt|;
DECL|field|movedBlocks
specifier|final
specifier|private
name|List
argument_list|<
name|HashMap
argument_list|<
name|Block
argument_list|,
name|BalancerBlock
argument_list|>
argument_list|>
name|movedBlocks
init|=
operator|new
name|ArrayList
argument_list|<
name|HashMap
argument_list|<
name|Block
argument_list|,
name|BalancerBlock
argument_list|>
argument_list|>
argument_list|(
name|NUM_WINS
argument_list|)
decl_stmt|;
comment|/* initialize the moved blocks collection */
DECL|method|MovedBlocks ()
specifier|private
name|MovedBlocks
parameter_list|()
block|{
name|movedBlocks
operator|.
name|add
argument_list|(
operator|new
name|HashMap
argument_list|<
name|Block
argument_list|,
name|BalancerBlock
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
name|movedBlocks
operator|.
name|add
argument_list|(
operator|new
name|HashMap
argument_list|<
name|Block
argument_list|,
name|BalancerBlock
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/* add a block thus marking a block to be moved */
DECL|method|add (BalancerBlock block)
specifier|synchronized
specifier|private
name|void
name|add
parameter_list|(
name|BalancerBlock
name|block
parameter_list|)
block|{
name|movedBlocks
operator|.
name|get
argument_list|(
name|CUR_WIN
argument_list|)
operator|.
name|put
argument_list|(
name|block
operator|.
name|getBlock
argument_list|()
argument_list|,
name|block
argument_list|)
expr_stmt|;
block|}
comment|/* check if a block is marked as moved */
DECL|method|contains (BalancerBlock block)
specifier|synchronized
specifier|private
name|boolean
name|contains
parameter_list|(
name|BalancerBlock
name|block
parameter_list|)
block|{
return|return
name|contains
argument_list|(
name|block
operator|.
name|getBlock
argument_list|()
argument_list|)
return|;
block|}
comment|/* check if a block is marked as moved */
DECL|method|contains (Block block)
specifier|synchronized
specifier|private
name|boolean
name|contains
parameter_list|(
name|Block
name|block
parameter_list|)
block|{
return|return
name|movedBlocks
operator|.
name|get
argument_list|(
name|CUR_WIN
argument_list|)
operator|.
name|containsKey
argument_list|(
name|block
argument_list|)
operator|||
name|movedBlocks
operator|.
name|get
argument_list|(
name|OLD_WIN
argument_list|)
operator|.
name|containsKey
argument_list|(
name|block
argument_list|)
return|;
block|}
comment|/* remove old blocks */
DECL|method|cleanup ()
specifier|synchronized
specifier|private
name|void
name|cleanup
parameter_list|()
block|{
name|long
name|curTime
init|=
name|Time
operator|.
name|now
argument_list|()
decl_stmt|;
comment|// check if old win is older than winWidth
if|if
condition|(
name|lastCleanupTime
operator|+
name|WIN_WIDTH
operator|<=
name|curTime
condition|)
block|{
comment|// purge the old window
name|movedBlocks
operator|.
name|set
argument_list|(
name|OLD_WIN
argument_list|,
name|movedBlocks
operator|.
name|get
argument_list|(
name|CUR_WIN
argument_list|)
argument_list|)
expr_stmt|;
name|movedBlocks
operator|.
name|set
argument_list|(
name|CUR_WIN
argument_list|,
operator|new
name|HashMap
argument_list|<
name|Block
argument_list|,
name|BalancerBlock
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
name|lastCleanupTime
operator|=
name|curTime
expr_stmt|;
block|}
block|}
block|}
comment|/* Decide if it is OK to move the given block from source to target    * A block is a good candidate if    * 1. the block is not in the process of being moved/has not been moved;    * 2. the block does not have a replica on the target;    * 3. doing the move does not reduce the number of racks that the block has    */
DECL|method|isGoodBlockCandidate (Source source, BalancerDatanode target, BalancerBlock block)
specifier|private
name|boolean
name|isGoodBlockCandidate
parameter_list|(
name|Source
name|source
parameter_list|,
name|BalancerDatanode
name|target
parameter_list|,
name|BalancerBlock
name|block
parameter_list|)
block|{
comment|// check if the block is moved or not
if|if
condition|(
name|movedBlocks
operator|.
name|contains
argument_list|(
name|block
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|block
operator|.
name|isLocatedOnDatanode
argument_list|(
name|target
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|cluster
operator|.
name|isNodeGroupAware
argument_list|()
operator|&&
name|isOnSameNodeGroupWithReplicas
argument_list|(
name|target
argument_list|,
name|block
argument_list|,
name|source
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|boolean
name|goodBlock
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|cluster
operator|.
name|isOnSameRack
argument_list|(
name|source
operator|.
name|getDatanode
argument_list|()
argument_list|,
name|target
operator|.
name|getDatanode
argument_list|()
argument_list|)
condition|)
block|{
comment|// good if source and target are on the same rack
name|goodBlock
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|boolean
name|notOnSameRack
init|=
literal|true
decl_stmt|;
synchronized|synchronized
init|(
name|block
init|)
block|{
for|for
control|(
name|BalancerDatanode
name|loc
range|:
name|block
operator|.
name|locations
control|)
block|{
if|if
condition|(
name|cluster
operator|.
name|isOnSameRack
argument_list|(
name|loc
operator|.
name|datanode
argument_list|,
name|target
operator|.
name|datanode
argument_list|)
condition|)
block|{
name|notOnSameRack
operator|=
literal|false
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|notOnSameRack
condition|)
block|{
comment|// good if target is target is not on the same rack as any replica
name|goodBlock
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
comment|// good if source is on the same rack as on of the replicas
for|for
control|(
name|BalancerDatanode
name|loc
range|:
name|block
operator|.
name|locations
control|)
block|{
if|if
condition|(
name|loc
operator|!=
name|source
operator|&&
name|cluster
operator|.
name|isOnSameRack
argument_list|(
name|loc
operator|.
name|datanode
argument_list|,
name|source
operator|.
name|datanode
argument_list|)
condition|)
block|{
name|goodBlock
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
return|return
name|goodBlock
return|;
block|}
comment|/**    * Check if there are any replica (other than source) on the same node group    * with target. If true, then target is not a good candidate for placing     * specific block replica as we don't want 2 replicas under the same nodegroup     * after balance.    * @param target targetDataNode    * @param block dataBlock    * @param source sourceDataNode    * @return true if there are any replica (other than source) on the same node    * group with target    */
DECL|method|isOnSameNodeGroupWithReplicas (BalancerDatanode target, BalancerBlock block, Source source)
specifier|private
name|boolean
name|isOnSameNodeGroupWithReplicas
parameter_list|(
name|BalancerDatanode
name|target
parameter_list|,
name|BalancerBlock
name|block
parameter_list|,
name|Source
name|source
parameter_list|)
block|{
for|for
control|(
name|BalancerDatanode
name|loc
range|:
name|block
operator|.
name|locations
control|)
block|{
if|if
condition|(
name|loc
operator|!=
name|source
operator|&&
name|cluster
operator|.
name|isOnSameNodeGroup
argument_list|(
name|loc
operator|.
name|getDatanode
argument_list|()
argument_list|,
name|target
operator|.
name|getDatanode
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/* reset all fields in a balancer preparing for the next iteration */
DECL|method|resetData (Configuration conf)
specifier|private
name|void
name|resetData
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
name|this
operator|.
name|cluster
operator|=
name|NetworkTopology
operator|.
name|getInstance
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|overUtilizedDatanodes
operator|.
name|clear
argument_list|()
expr_stmt|;
name|this
operator|.
name|aboveAvgUtilizedDatanodes
operator|.
name|clear
argument_list|()
expr_stmt|;
name|this
operator|.
name|belowAvgUtilizedDatanodes
operator|.
name|clear
argument_list|()
expr_stmt|;
name|this
operator|.
name|underUtilizedDatanodes
operator|.
name|clear
argument_list|()
expr_stmt|;
name|this
operator|.
name|datanodeMap
operator|.
name|clear
argument_list|()
expr_stmt|;
name|this
operator|.
name|sources
operator|.
name|clear
argument_list|()
expr_stmt|;
name|this
operator|.
name|targets
operator|.
name|clear
argument_list|()
expr_stmt|;
name|this
operator|.
name|policy
operator|.
name|reset
argument_list|()
expr_stmt|;
name|cleanGlobalBlockList
argument_list|()
expr_stmt|;
name|this
operator|.
name|movedBlocks
operator|.
name|cleanup
argument_list|()
expr_stmt|;
block|}
comment|/* Remove all blocks from the global block list except for the ones in the    * moved list.    */
DECL|method|cleanGlobalBlockList ()
specifier|private
name|void
name|cleanGlobalBlockList
parameter_list|()
block|{
for|for
control|(
name|Iterator
argument_list|<
name|Block
argument_list|>
name|globalBlockListIterator
init|=
name|globalBlockList
operator|.
name|keySet
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|globalBlockListIterator
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Block
name|block
init|=
name|globalBlockListIterator
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|movedBlocks
operator|.
name|contains
argument_list|(
name|block
argument_list|)
condition|)
block|{
name|globalBlockListIterator
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/* Return true if the given datanode is overUtilized */
DECL|method|isOverUtilized (BalancerDatanode datanode)
specifier|private
name|boolean
name|isOverUtilized
parameter_list|(
name|BalancerDatanode
name|datanode
parameter_list|)
block|{
return|return
name|datanode
operator|.
name|utilization
operator|>
operator|(
name|policy
operator|.
name|getAvgUtilization
argument_list|()
operator|+
name|threshold
operator|)
return|;
block|}
comment|/* Return true if the given datanode is above or equal to average utilized    * but not overUtilized */
DECL|method|isAboveAvgUtilized (BalancerDatanode datanode)
specifier|private
name|boolean
name|isAboveAvgUtilized
parameter_list|(
name|BalancerDatanode
name|datanode
parameter_list|)
block|{
specifier|final
name|double
name|avg
init|=
name|policy
operator|.
name|getAvgUtilization
argument_list|()
decl_stmt|;
return|return
operator|(
name|datanode
operator|.
name|utilization
operator|<=
operator|(
name|avg
operator|+
name|threshold
operator|)
operator|)
operator|&&
operator|(
name|datanode
operator|.
name|utilization
operator|>=
name|avg
operator|)
return|;
block|}
comment|/* Return true if the given datanode is underUtilized */
DECL|method|isUnderUtilized (BalancerDatanode datanode)
specifier|private
name|boolean
name|isUnderUtilized
parameter_list|(
name|BalancerDatanode
name|datanode
parameter_list|)
block|{
return|return
name|datanode
operator|.
name|utilization
operator|<
operator|(
name|policy
operator|.
name|getAvgUtilization
argument_list|()
operator|-
name|threshold
operator|)
return|;
block|}
comment|/* Return true if the given datanode is below average utilized     * but not underUtilized */
DECL|method|isBelowOrEqualAvgUtilized (BalancerDatanode datanode)
specifier|private
name|boolean
name|isBelowOrEqualAvgUtilized
parameter_list|(
name|BalancerDatanode
name|datanode
parameter_list|)
block|{
specifier|final
name|double
name|avg
init|=
name|policy
operator|.
name|getAvgUtilization
argument_list|()
decl_stmt|;
return|return
operator|(
name|datanode
operator|.
name|utilization
operator|>=
operator|(
name|avg
operator|-
name|threshold
operator|)
operator|)
operator|&&
operator|(
name|datanode
operator|.
name|utilization
operator|<=
name|avg
operator|)
return|;
block|}
comment|// Exit status
DECL|enum|ReturnStatus
enum|enum
name|ReturnStatus
block|{
comment|// These int values will map directly to the balancer process's exit code.
DECL|enumConstant|SUCCESS
name|SUCCESS
argument_list|(
literal|0
argument_list|)
block|,
DECL|enumConstant|IN_PROGRESS
name|IN_PROGRESS
argument_list|(
literal|1
argument_list|)
block|,
DECL|enumConstant|ALREADY_RUNNING
name|ALREADY_RUNNING
argument_list|(
operator|-
literal|1
argument_list|)
block|,
DECL|enumConstant|NO_MOVE_BLOCK
name|NO_MOVE_BLOCK
argument_list|(
operator|-
literal|2
argument_list|)
block|,
DECL|enumConstant|NO_MOVE_PROGRESS
name|NO_MOVE_PROGRESS
argument_list|(
operator|-
literal|3
argument_list|)
block|,
DECL|enumConstant|IO_EXCEPTION
name|IO_EXCEPTION
argument_list|(
operator|-
literal|4
argument_list|)
block|,
DECL|enumConstant|ILLEGAL_ARGS
name|ILLEGAL_ARGS
argument_list|(
operator|-
literal|5
argument_list|)
block|,
DECL|enumConstant|INTERRUPTED
name|INTERRUPTED
argument_list|(
operator|-
literal|6
argument_list|)
block|;
DECL|field|code
specifier|final
name|int
name|code
decl_stmt|;
DECL|method|ReturnStatus (int code)
name|ReturnStatus
parameter_list|(
name|int
name|code
parameter_list|)
block|{
name|this
operator|.
name|code
operator|=
name|code
expr_stmt|;
block|}
block|}
comment|/** Run an iteration for all datanodes. */
DECL|method|run (int iteration, Formatter formatter, Configuration conf)
specifier|private
name|ReturnStatus
name|run
parameter_list|(
name|int
name|iteration
parameter_list|,
name|Formatter
name|formatter
parameter_list|,
name|Configuration
name|conf
parameter_list|)
block|{
try|try
block|{
comment|/* get all live datanodes of a cluster and their disk usage        * decide the number of bytes need to be moved        */
specifier|final
name|long
name|bytesLeftToMove
init|=
name|initNodes
argument_list|(
name|nnc
operator|.
name|client
operator|.
name|getDatanodeReport
argument_list|(
name|DatanodeReportType
operator|.
name|LIVE
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|bytesLeftToMove
operator|==
literal|0
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"The cluster is balanced. Exiting..."
argument_list|)
expr_stmt|;
return|return
name|ReturnStatus
operator|.
name|SUCCESS
return|;
block|}
else|else
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Need to move "
operator|+
name|StringUtils
operator|.
name|byteDesc
argument_list|(
name|bytesLeftToMove
argument_list|)
operator|+
literal|" to make the cluster balanced."
argument_list|)
expr_stmt|;
block|}
comment|/* Decide all the nodes that will participate in the block move and        * the number of bytes that need to be moved from one node to another        * in this iteration. Maximum bytes to be moved per node is        * Min(1 Band worth of bytes,  MAX_SIZE_TO_MOVE).        */
specifier|final
name|long
name|bytesToMove
init|=
name|chooseNodes
argument_list|()
decl_stmt|;
if|if
condition|(
name|bytesToMove
operator|==
literal|0
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"No block can be moved. Exiting..."
argument_list|)
expr_stmt|;
return|return
name|ReturnStatus
operator|.
name|NO_MOVE_BLOCK
return|;
block|}
else|else
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Will move "
operator|+
name|StringUtils
operator|.
name|byteDesc
argument_list|(
name|bytesToMove
argument_list|)
operator|+
literal|" in this iteration"
argument_list|)
expr_stmt|;
block|}
name|formatter
operator|.
name|format
argument_list|(
literal|"%-24s %10d  %19s  %18s  %17s%n"
argument_list|,
name|DateFormat
operator|.
name|getDateTimeInstance
argument_list|()
operator|.
name|format
argument_list|(
operator|new
name|Date
argument_list|()
argument_list|)
argument_list|,
name|iteration
argument_list|,
name|StringUtils
operator|.
name|byteDesc
argument_list|(
name|bytesMoved
operator|.
name|get
argument_list|()
argument_list|)
argument_list|,
name|StringUtils
operator|.
name|byteDesc
argument_list|(
name|bytesLeftToMove
argument_list|)
argument_list|,
name|StringUtils
operator|.
name|byteDesc
argument_list|(
name|bytesToMove
argument_list|)
argument_list|)
expr_stmt|;
comment|/* For each pair of<source, target>, start a thread that repeatedly         * decide a block to be moved and its proxy source,         * then initiates the move until all bytes are moved or no more block        * available to move.        * Exit no byte has been moved for 5 consecutive iterations.        */
if|if
condition|(
operator|!
name|this
operator|.
name|nnc
operator|.
name|shouldContinue
argument_list|(
name|dispatchBlockMoves
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|ReturnStatus
operator|.
name|NO_MOVE_PROGRESS
return|;
block|}
return|return
name|ReturnStatus
operator|.
name|IN_PROGRESS
return|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|e
operator|+
literal|".  Exiting ..."
argument_list|)
expr_stmt|;
return|return
name|ReturnStatus
operator|.
name|ILLEGAL_ARGS
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|e
operator|+
literal|".  Exiting ..."
argument_list|)
expr_stmt|;
return|return
name|ReturnStatus
operator|.
name|IO_EXCEPTION
return|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|e
operator|+
literal|".  Exiting ..."
argument_list|)
expr_stmt|;
return|return
name|ReturnStatus
operator|.
name|INTERRUPTED
return|;
block|}
finally|finally
block|{
comment|// shutdown thread pools
name|dispatcherExecutor
operator|.
name|shutdownNow
argument_list|()
expr_stmt|;
name|moverExecutor
operator|.
name|shutdownNow
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Balance all namenodes.    * For each iteration,    * for each namenode,    * execute a {@link Balancer} to work through all datanodes once.      */
DECL|method|run (Collection<URI> namenodes, final Parameters p, Configuration conf)
specifier|static
name|int
name|run
parameter_list|(
name|Collection
argument_list|<
name|URI
argument_list|>
name|namenodes
parameter_list|,
specifier|final
name|Parameters
name|p
parameter_list|,
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
specifier|final
name|long
name|sleeptime
init|=
literal|2000
operator|*
name|conf
operator|.
name|getLong
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_HEARTBEAT_INTERVAL_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_HEARTBEAT_INTERVAL_DEFAULT
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"namenodes = "
operator|+
name|namenodes
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"p         = "
operator|+
name|p
argument_list|)
expr_stmt|;
specifier|final
name|Formatter
name|formatter
init|=
operator|new
name|Formatter
argument_list|(
name|System
operator|.
name|out
argument_list|)
decl_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Time Stamp               Iteration#  Bytes Already Moved  Bytes Left To Move  Bytes Being Moved"
argument_list|)
expr_stmt|;
specifier|final
name|List
argument_list|<
name|NameNodeConnector
argument_list|>
name|connectors
init|=
operator|new
name|ArrayList
argument_list|<
name|NameNodeConnector
argument_list|>
argument_list|(
name|namenodes
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
try|try
block|{
for|for
control|(
name|URI
name|uri
range|:
name|namenodes
control|)
block|{
name|connectors
operator|.
name|add
argument_list|(
operator|new
name|NameNodeConnector
argument_list|(
name|uri
argument_list|,
name|conf
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|boolean
name|done
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|iteration
init|=
literal|0
init|;
operator|!
name|done
condition|;
name|iteration
operator|++
control|)
block|{
name|done
operator|=
literal|true
expr_stmt|;
name|Collections
operator|.
name|shuffle
argument_list|(
name|connectors
argument_list|)
expr_stmt|;
for|for
control|(
name|NameNodeConnector
name|nnc
range|:
name|connectors
control|)
block|{
specifier|final
name|Balancer
name|b
init|=
operator|new
name|Balancer
argument_list|(
name|nnc
argument_list|,
name|p
argument_list|,
name|conf
argument_list|)
decl_stmt|;
specifier|final
name|ReturnStatus
name|r
init|=
name|b
operator|.
name|run
argument_list|(
name|iteration
argument_list|,
name|formatter
argument_list|,
name|conf
argument_list|)
decl_stmt|;
comment|// clean all lists
name|b
operator|.
name|resetData
argument_list|(
name|conf
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|ReturnStatus
operator|.
name|IN_PROGRESS
condition|)
block|{
name|done
operator|=
literal|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|r
operator|!=
name|ReturnStatus
operator|.
name|SUCCESS
condition|)
block|{
comment|//must be an error statue, return.
return|return
name|r
operator|.
name|code
return|;
block|}
block|}
if|if
condition|(
operator|!
name|done
condition|)
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|sleeptime
argument_list|)
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
for|for
control|(
name|NameNodeConnector
name|nnc
range|:
name|connectors
control|)
block|{
name|nnc
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|ReturnStatus
operator|.
name|SUCCESS
operator|.
name|code
return|;
block|}
comment|/* Given elaspedTime in ms, return a printable string */
DECL|method|time2Str (long elapsedTime)
specifier|private
specifier|static
name|String
name|time2Str
parameter_list|(
name|long
name|elapsedTime
parameter_list|)
block|{
name|String
name|unit
decl_stmt|;
name|double
name|time
init|=
name|elapsedTime
decl_stmt|;
if|if
condition|(
name|elapsedTime
operator|<
literal|1000
condition|)
block|{
name|unit
operator|=
literal|"milliseconds"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|elapsedTime
operator|<
literal|60
operator|*
literal|1000
condition|)
block|{
name|unit
operator|=
literal|"seconds"
expr_stmt|;
name|time
operator|=
name|time
operator|/
literal|1000
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|elapsedTime
operator|<
literal|3600
operator|*
literal|1000
condition|)
block|{
name|unit
operator|=
literal|"minutes"
expr_stmt|;
name|time
operator|=
name|time
operator|/
operator|(
literal|60
operator|*
literal|1000
operator|)
expr_stmt|;
block|}
else|else
block|{
name|unit
operator|=
literal|"hours"
expr_stmt|;
name|time
operator|=
name|time
operator|/
operator|(
literal|3600
operator|*
literal|1000
operator|)
expr_stmt|;
block|}
return|return
name|time
operator|+
literal|" "
operator|+
name|unit
return|;
block|}
DECL|class|Parameters
specifier|static
class|class
name|Parameters
block|{
DECL|field|DEFALUT
specifier|static
specifier|final
name|Parameters
name|DEFALUT
init|=
operator|new
name|Parameters
argument_list|(
name|BalancingPolicy
operator|.
name|Node
operator|.
name|INSTANCE
argument_list|,
literal|10.0
argument_list|)
decl_stmt|;
DECL|field|policy
specifier|final
name|BalancingPolicy
name|policy
decl_stmt|;
DECL|field|threshold
specifier|final
name|double
name|threshold
decl_stmt|;
DECL|method|Parameters (BalancingPolicy policy, double threshold)
name|Parameters
parameter_list|(
name|BalancingPolicy
name|policy
parameter_list|,
name|double
name|threshold
parameter_list|)
block|{
name|this
operator|.
name|policy
operator|=
name|policy
expr_stmt|;
name|this
operator|.
name|threshold
operator|=
name|threshold
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|Balancer
operator|.
name|class
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|"."
operator|+
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|"["
operator|+
name|policy
operator|+
literal|", threshold="
operator|+
name|threshold
operator|+
literal|"]"
return|;
block|}
block|}
DECL|class|Cli
specifier|static
class|class
name|Cli
extends|extends
name|Configured
implements|implements
name|Tool
block|{
comment|/**      * Parse arguments and then run Balancer.      *       * @param args command specific arguments.      * @return exit code. 0 indicates success, non-zero indicates failure.      */
annotation|@
name|Override
DECL|method|run (String[] args)
specifier|public
name|int
name|run
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
block|{
specifier|final
name|long
name|startTime
init|=
name|Time
operator|.
name|now
argument_list|()
decl_stmt|;
specifier|final
name|Configuration
name|conf
init|=
name|getConf
argument_list|()
decl_stmt|;
name|WIN_WIDTH
operator|=
name|conf
operator|.
name|getLong
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_BALANCER_MOVEDWINWIDTH_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_BALANCER_MOVEDWINWIDTH_DEFAULT
argument_list|)
expr_stmt|;
try|try
block|{
name|checkReplicationPolicyCompatibility
argument_list|(
name|conf
argument_list|)
expr_stmt|;
specifier|final
name|Collection
argument_list|<
name|URI
argument_list|>
name|namenodes
init|=
name|DFSUtil
operator|.
name|getNsServiceRpcUris
argument_list|(
name|conf
argument_list|)
decl_stmt|;
return|return
name|Balancer
operator|.
name|run
argument_list|(
name|namenodes
argument_list|,
name|parse
argument_list|(
name|args
argument_list|)
argument_list|,
name|conf
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|e
operator|+
literal|".  Exiting ..."
argument_list|)
expr_stmt|;
return|return
name|ReturnStatus
operator|.
name|IO_EXCEPTION
operator|.
name|code
return|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|e
operator|+
literal|".  Exiting ..."
argument_list|)
expr_stmt|;
return|return
name|ReturnStatus
operator|.
name|INTERRUPTED
operator|.
name|code
return|;
block|}
finally|finally
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Balancing took "
operator|+
name|time2Str
argument_list|(
name|Time
operator|.
name|now
argument_list|()
operator|-
name|startTime
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** parse command line arguments */
DECL|method|parse (String[] args)
specifier|static
name|Parameters
name|parse
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
block|{
name|BalancingPolicy
name|policy
init|=
name|Parameters
operator|.
name|DEFALUT
operator|.
name|policy
decl_stmt|;
name|double
name|threshold
init|=
name|Parameters
operator|.
name|DEFALUT
operator|.
name|threshold
decl_stmt|;
if|if
condition|(
name|args
operator|!=
literal|null
condition|)
block|{
try|try
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|args
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|checkArgument
argument_list|(
name|args
operator|.
name|length
operator|>=
literal|2
argument_list|,
literal|"args = "
operator|+
name|Arrays
operator|.
name|toString
argument_list|(
name|args
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
literal|"-threshold"
operator|.
name|equalsIgnoreCase
argument_list|(
name|args
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|i
operator|++
expr_stmt|;
try|try
block|{
name|threshold
operator|=
name|Double
operator|.
name|parseDouble
argument_list|(
name|args
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|threshold
argument_list|<
literal|1
operator|||
name|threshold
argument_list|>
literal|100
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Number out of range: threshold = "
operator|+
name|threshold
argument_list|)
throw|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Using a threshold of "
operator|+
name|threshold
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Expecting a number in the range of [1.0, 100.0]: "
operator|+
name|args
index|[
name|i
index|]
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
elseif|else
if|if
condition|(
literal|"-policy"
operator|.
name|equalsIgnoreCase
argument_list|(
name|args
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|i
operator|++
expr_stmt|;
try|try
block|{
name|policy
operator|=
name|BalancingPolicy
operator|.
name|parse
argument_list|(
name|args
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Illegal policy name: "
operator|+
name|args
index|[
name|i
index|]
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"args = "
operator|+
name|Arrays
operator|.
name|toString
argument_list|(
name|args
argument_list|)
argument_list|)
throw|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|RuntimeException
name|e
parameter_list|)
block|{
name|printUsage
argument_list|(
name|System
operator|.
name|err
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
return|return
operator|new
name|Parameters
argument_list|(
name|policy
argument_list|,
name|threshold
argument_list|)
return|;
block|}
DECL|method|printUsage (PrintStream out)
specifier|private
specifier|static
name|void
name|printUsage
parameter_list|(
name|PrintStream
name|out
parameter_list|)
block|{
name|out
operator|.
name|println
argument_list|(
name|USAGE
operator|+
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Run a balancer    * @param args Command line arguments    */
DECL|method|main (String[] args)
specifier|public
specifier|static
name|void
name|main
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
block|{
if|if
condition|(
name|DFSUtil
operator|.
name|parseHelpArgument
argument_list|(
name|args
argument_list|,
name|USAGE
argument_list|,
name|System
operator|.
name|out
argument_list|,
literal|true
argument_list|)
condition|)
block|{
name|System
operator|.
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|System
operator|.
name|exit
argument_list|(
name|ToolRunner
operator|.
name|run
argument_list|(
operator|new
name|HdfsConfiguration
argument_list|()
argument_list|,
operator|new
name|Cli
argument_list|()
argument_list|,
name|args
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Exiting balancer due an exception"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|System
operator|.
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

