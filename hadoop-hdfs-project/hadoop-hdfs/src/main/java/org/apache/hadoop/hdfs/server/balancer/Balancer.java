begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdfs.server.balancer
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|balancer
package|;
end_package

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkArgument
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|CommonConfigurationKeys
operator|.
name|IPC_CLIENT_FALLBACK_TO_SIMPLE_AUTH_ALLOWED_DEFAULT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|CommonConfigurationKeys
operator|.
name|IPC_CLIENT_FALLBACK_TO_SIMPLE_AUTH_ALLOWED_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocolPB
operator|.
name|PBHelper
operator|.
name|vintPrefixed
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|BufferedInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|BufferedOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|PrintStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|Socket
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URI
import|;
end_import

begin_import
import|import
name|java
operator|.
name|text
operator|.
name|DateFormat
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Date
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|EnumMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Formatter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutionException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutorService
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Executors
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Future
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicLong
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configured
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|HdfsConfiguration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|StorageType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|Block
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|DatanodeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|ExtendedBlock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|HdfsConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|HdfsConstants
operator|.
name|DatanodeReportType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|datatransfer
operator|.
name|IOStreamPair
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|datatransfer
operator|.
name|Sender
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|datatransfer
operator|.
name|TrustedChannelResolver
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|datatransfer
operator|.
name|sasl
operator|.
name|DataTransferSaslUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|datatransfer
operator|.
name|sasl
operator|.
name|SaslDataTransferClient
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|proto
operator|.
name|DataTransferProtos
operator|.
name|BlockOpResponseProto
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|proto
operator|.
name|DataTransferProtos
operator|.
name|Status
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|security
operator|.
name|token
operator|.
name|block
operator|.
name|BlockTokenIdentifier
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|blockmanagement
operator|.
name|BlockPlacementPolicy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|blockmanagement
operator|.
name|BlockPlacementPolicyDefault
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|HdfsServerConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|UnsupportedActionException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|BlocksWithLocations
operator|.
name|BlockWithLocations
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|DatanodeStorageReport
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|StorageReport
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|net
operator|.
name|NetUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|net
operator|.
name|NetworkTopology
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|net
operator|.
name|Node
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|token
operator|.
name|Token
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|HostsFileReader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Time
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Tool
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|ToolRunner
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_comment
comment|/**<p>The balancer is a tool that balances disk space usage on an HDFS cluster  * when some datanodes become full or when new empty nodes join the cluster.  * The tool is deployed as an application program that can be run by the   * cluster administrator on a live HDFS cluster while applications  * adding and deleting files.  *   *<p>SYNOPSIS  *<pre>  * To start:  *      bin/start-balancer.sh [-threshold<threshold>]  *      Example: bin/ start-balancer.sh   *                     start the balancer with a default threshold of 10%  *               bin/ start-balancer.sh -threshold 5  *                     start the balancer with a threshold of 5%  * To stop:  *      bin/ stop-balancer.sh  *</pre>  *   *<p>DESCRIPTION  *<p>The threshold parameter is a fraction in the range of (1%, 100%) with a   * default value of 10%. The threshold sets a target for whether the cluster   * is balanced. A cluster is balanced if for each datanode, the utilization   * of the node (ratio of used space at the node to total capacity of the node)   * differs from the utilization of the (ratio of used space in the cluster   * to total capacity of the cluster) by no more than the threshold value.   * The smaller the threshold, the more balanced a cluster will become.   * It takes more time to run the balancer for small threshold values.   * Also for a very small threshold the cluster may not be able to reach the   * balanced state when applications write and delete files concurrently.  *   *<p>The tool moves blocks from highly utilized datanodes to poorly   * utilized datanodes iteratively. In each iteration a datanode moves or   * receives no more than the lesser of 10G bytes or the threshold fraction   * of its capacity. Each iteration runs no more than 20 minutes.  * At the end of each iteration, the balancer obtains updated datanodes  * information from the namenode.  *   *<p>A system property that limits the balancer's use of bandwidth is   * defined in the default configuration file:  *<pre>  *<property>  *<name>dfs.balance.bandwidthPerSec</name>  *<value>1048576</value>  *<description>  Specifies the maximum bandwidth that each datanode   * can utilize for the balancing purpose in term of the number of bytes   * per second.</description>  *</property>  *</pre>  *   *<p>This property determines the maximum speed at which a block will be   * moved from one datanode to another. The default value is 1MB/s. The higher   * the bandwidth, the faster a cluster can reach the balanced state,   * but with greater competition with application processes. If an   * administrator changes the value of this property in the configuration   * file, the change is observed when HDFS is next restarted.  *   *<p>MONITERING BALANCER PROGRESS  *<p>After the balancer is started, an output file name where the balancer   * progress will be recorded is printed on the screen.  The administrator   * can monitor the running of the balancer by reading the output file.   * The output shows the balancer's status iteration by iteration. In each   * iteration it prints the starting time, the iteration number, the total   * number of bytes that have been moved in the previous iterations,   * the total number of bytes that are left to move in order for the cluster   * to be balanced, and the number of bytes that are being moved in this   * iteration. Normally "Bytes Already Moved" is increasing while "Bytes Left   * To Move" is decreasing.  *   *<p>Running multiple instances of the balancer in an HDFS cluster is   * prohibited by the tool.  *   *<p>The balancer automatically exits when any of the following five   * conditions is satisfied:  *<ol>  *<li>The cluster is balanced;  *<li>No block can be moved;  *<li>No block has been moved for five consecutive iterations;  *<li>An IOException occurs while communicating with the namenode;  *<li>Another balancer is running.  *</ol>  *   *<p>Upon exit, a balancer returns an exit code and prints one of the   * following messages to the output file in corresponding to the above exit   * reasons:  *<ol>  *<li>The cluster is balanced. Exiting  *<li>No block can be moved. Exiting...  *<li>No block has been moved for 5 iterations. Exiting...  *<li>Received an IO exception: failure reason. Exiting...  *<li>Another balancer is running. Exiting...  *</ol>  *   *<p>The administrator can interrupt the execution of the balancer at any   * time by running the command "stop-balancer.sh" on the machine where the   * balancer is running.  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
DECL|class|Balancer
specifier|public
class|class
name|Balancer
block|{
DECL|field|LOG
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|Balancer
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|GB
specifier|final
specifier|private
specifier|static
name|long
name|GB
init|=
literal|1L
operator|<<
literal|30
decl_stmt|;
comment|//1GB
DECL|field|MAX_SIZE_TO_MOVE
specifier|final
specifier|private
specifier|static
name|long
name|MAX_SIZE_TO_MOVE
init|=
literal|10
operator|*
name|GB
decl_stmt|;
DECL|field|MAX_BLOCKS_SIZE_TO_FETCH
specifier|final
specifier|private
specifier|static
name|long
name|MAX_BLOCKS_SIZE_TO_FETCH
init|=
literal|2
operator|*
name|GB
decl_stmt|;
DECL|field|WIN_WIDTH
specifier|private
specifier|static
name|long
name|WIN_WIDTH
init|=
literal|5400
operator|*
literal|1000L
decl_stmt|;
comment|// 1.5 hour
comment|/** The maximum number of concurrent blocks moves for     * balancing purpose at a datanode    */
DECL|field|MAX_NO_PENDING_BLOCK_ITERATIONS
specifier|private
specifier|static
specifier|final
name|int
name|MAX_NO_PENDING_BLOCK_ITERATIONS
init|=
literal|5
decl_stmt|;
DECL|field|DELAY_AFTER_ERROR
specifier|public
specifier|static
specifier|final
name|long
name|DELAY_AFTER_ERROR
init|=
literal|10
operator|*
literal|1000L
decl_stmt|;
comment|//10 seconds
DECL|field|BLOCK_MOVE_READ_TIMEOUT
specifier|public
specifier|static
specifier|final
name|int
name|BLOCK_MOVE_READ_TIMEOUT
init|=
literal|20
operator|*
literal|60
operator|*
literal|1000
decl_stmt|;
comment|// 20 minutes
DECL|field|USAGE
specifier|private
specifier|static
specifier|final
name|String
name|USAGE
init|=
literal|"Usage: java "
operator|+
name|Balancer
operator|.
name|class
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|"\n\t[-policy<policy>]\tthe balancing policy: "
operator|+
name|BalancingPolicy
operator|.
name|Node
operator|.
name|INSTANCE
operator|.
name|getName
argument_list|()
operator|+
literal|" or "
operator|+
name|BalancingPolicy
operator|.
name|Pool
operator|.
name|INSTANCE
operator|.
name|getName
argument_list|()
operator|+
literal|"\n\t[-threshold<threshold>]\tPercentage of disk capacity"
operator|+
literal|"\n\t[-exclude [-f<hosts-file> | comma-sperated list of hosts]]"
operator|+
literal|"\tExcludes the specified datanodes."
operator|+
literal|"\n\t[-include [-f<hosts-file> | comma-sperated list of hosts]]"
operator|+
literal|"\tIncludes only the specified datanodes."
decl_stmt|;
DECL|field|nnc
specifier|private
specifier|final
name|NameNodeConnector
name|nnc
decl_stmt|;
DECL|field|policy
specifier|private
specifier|final
name|BalancingPolicy
name|policy
decl_stmt|;
DECL|field|saslClient
specifier|private
specifier|final
name|SaslDataTransferClient
name|saslClient
decl_stmt|;
DECL|field|threshold
specifier|private
specifier|final
name|double
name|threshold
decl_stmt|;
comment|// set of data nodes to be excluded from balancing operations.
DECL|field|nodesToBeExcluded
name|Set
argument_list|<
name|String
argument_list|>
name|nodesToBeExcluded
decl_stmt|;
comment|//Restrict balancing to the following nodes.
DECL|field|nodesToBeIncluded
name|Set
argument_list|<
name|String
argument_list|>
name|nodesToBeIncluded
decl_stmt|;
comment|// all data node lists
DECL|field|overUtilized
specifier|private
specifier|final
name|Collection
argument_list|<
name|Source
argument_list|>
name|overUtilized
init|=
operator|new
name|LinkedList
argument_list|<
name|Source
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|aboveAvgUtilized
specifier|private
specifier|final
name|Collection
argument_list|<
name|Source
argument_list|>
name|aboveAvgUtilized
init|=
operator|new
name|LinkedList
argument_list|<
name|Source
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|belowAvgUtilized
specifier|private
specifier|final
name|Collection
argument_list|<
name|BalancerDatanode
operator|.
name|StorageGroup
argument_list|>
name|belowAvgUtilized
init|=
operator|new
name|LinkedList
argument_list|<
name|BalancerDatanode
operator|.
name|StorageGroup
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|underUtilized
specifier|private
specifier|final
name|Collection
argument_list|<
name|BalancerDatanode
operator|.
name|StorageGroup
argument_list|>
name|underUtilized
init|=
operator|new
name|LinkedList
argument_list|<
name|BalancerDatanode
operator|.
name|StorageGroup
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|sources
specifier|private
specifier|final
name|Collection
argument_list|<
name|Source
argument_list|>
name|sources
init|=
operator|new
name|HashSet
argument_list|<
name|Source
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|targets
specifier|private
specifier|final
name|Collection
argument_list|<
name|BalancerDatanode
operator|.
name|StorageGroup
argument_list|>
name|targets
init|=
operator|new
name|HashSet
argument_list|<
name|BalancerDatanode
operator|.
name|StorageGroup
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|globalBlockList
specifier|private
specifier|final
name|Map
argument_list|<
name|Block
argument_list|,
name|BalancerBlock
argument_list|>
name|globalBlockList
init|=
operator|new
name|HashMap
argument_list|<
name|Block
argument_list|,
name|BalancerBlock
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|movedBlocks
specifier|private
specifier|final
name|MovedBlocks
name|movedBlocks
init|=
operator|new
name|MovedBlocks
argument_list|()
decl_stmt|;
comment|/** Map (datanodeUuid,storageType -> StorageGroup) */
DECL|field|storageGroupMap
specifier|private
specifier|final
name|StorageGroupMap
name|storageGroupMap
init|=
operator|new
name|StorageGroupMap
argument_list|()
decl_stmt|;
DECL|field|cluster
specifier|private
name|NetworkTopology
name|cluster
decl_stmt|;
DECL|field|moverExecutor
specifier|private
specifier|final
name|ExecutorService
name|moverExecutor
decl_stmt|;
DECL|field|dispatcherExecutor
specifier|private
specifier|final
name|ExecutorService
name|dispatcherExecutor
decl_stmt|;
DECL|field|maxConcurrentMovesPerNode
specifier|private
specifier|final
name|int
name|maxConcurrentMovesPerNode
decl_stmt|;
DECL|class|StorageGroupMap
specifier|private
specifier|static
class|class
name|StorageGroupMap
block|{
DECL|method|toKey (String datanodeUuid, StorageType storageType)
specifier|private
specifier|static
name|String
name|toKey
parameter_list|(
name|String
name|datanodeUuid
parameter_list|,
name|StorageType
name|storageType
parameter_list|)
block|{
return|return
name|datanodeUuid
operator|+
literal|":"
operator|+
name|storageType
return|;
block|}
DECL|field|map
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|BalancerDatanode
operator|.
name|StorageGroup
argument_list|>
name|map
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|BalancerDatanode
operator|.
name|StorageGroup
argument_list|>
argument_list|()
decl_stmt|;
DECL|method|get (String datanodeUuid, StorageType storageType)
name|BalancerDatanode
operator|.
name|StorageGroup
name|get
parameter_list|(
name|String
name|datanodeUuid
parameter_list|,
name|StorageType
name|storageType
parameter_list|)
block|{
return|return
name|map
operator|.
name|get
argument_list|(
name|toKey
argument_list|(
name|datanodeUuid
argument_list|,
name|storageType
argument_list|)
argument_list|)
return|;
block|}
DECL|method|put (BalancerDatanode.StorageGroup g)
name|void
name|put
parameter_list|(
name|BalancerDatanode
operator|.
name|StorageGroup
name|g
parameter_list|)
block|{
specifier|final
name|String
name|key
init|=
name|toKey
argument_list|(
name|g
operator|.
name|getDatanode
argument_list|()
operator|.
name|getDatanodeUuid
argument_list|()
argument_list|,
name|g
operator|.
name|storageType
argument_list|)
decl_stmt|;
specifier|final
name|BalancerDatanode
operator|.
name|StorageGroup
name|existing
init|=
name|map
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|g
argument_list|)
decl_stmt|;
name|Preconditions
operator|.
name|checkState
argument_list|(
name|existing
operator|==
literal|null
argument_list|)
expr_stmt|;
block|}
DECL|method|size ()
name|int
name|size
parameter_list|()
block|{
return|return
name|map
operator|.
name|size
argument_list|()
return|;
block|}
DECL|method|clear ()
name|void
name|clear
parameter_list|()
block|{
name|map
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* This class keeps track of a scheduled block move */
DECL|class|PendingBlockMove
specifier|private
class|class
name|PendingBlockMove
block|{
DECL|field|block
specifier|private
name|BalancerBlock
name|block
decl_stmt|;
DECL|field|source
specifier|private
name|Source
name|source
decl_stmt|;
DECL|field|proxySource
specifier|private
name|BalancerDatanode
name|proxySource
decl_stmt|;
DECL|field|target
specifier|private
name|BalancerDatanode
operator|.
name|StorageGroup
name|target
decl_stmt|;
comment|/** constructor */
DECL|method|PendingBlockMove ()
specifier|private
name|PendingBlockMove
parameter_list|()
block|{     }
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
specifier|final
name|Block
name|b
init|=
name|block
operator|.
name|getBlock
argument_list|()
decl_stmt|;
return|return
name|b
operator|+
literal|" with size="
operator|+
name|b
operator|.
name|getNumBytes
argument_list|()
operator|+
literal|" from "
operator|+
name|source
operator|.
name|getDisplayName
argument_list|()
operator|+
literal|" to "
operator|+
name|target
operator|.
name|getDisplayName
argument_list|()
operator|+
literal|" through "
operator|+
name|proxySource
operator|.
name|datanode
return|;
block|}
comment|/* choose a block& a proxy source for this pendingMove       * whose source& target have already been chosen.      *       * Return true if a block and its proxy are chosen; false otherwise      */
DECL|method|chooseBlockAndProxy ()
specifier|private
name|boolean
name|chooseBlockAndProxy
parameter_list|()
block|{
comment|// iterate all source's blocks until find a good one
for|for
control|(
name|Iterator
argument_list|<
name|BalancerBlock
argument_list|>
name|blocks
init|=
name|source
operator|.
name|getBlockIterator
argument_list|()
init|;
name|blocks
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
if|if
condition|(
name|markMovedIfGoodBlock
argument_list|(
name|blocks
operator|.
name|next
argument_list|()
argument_list|)
condition|)
block|{
name|blocks
operator|.
name|remove
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/* Return true if the given block is good for the tentative move;      * If it is good, add it to the moved list to marked as "Moved".      * A block is good if      * 1. it is a good candidate; see isGoodBlockCandidate      * 2. can find a proxy source that's not busy for this move      */
DECL|method|markMovedIfGoodBlock (BalancerBlock block)
specifier|private
name|boolean
name|markMovedIfGoodBlock
parameter_list|(
name|BalancerBlock
name|block
parameter_list|)
block|{
synchronized|synchronized
init|(
name|block
init|)
block|{
synchronized|synchronized
init|(
name|movedBlocks
init|)
block|{
if|if
condition|(
name|isGoodBlockCandidate
argument_list|(
name|source
argument_list|,
name|target
argument_list|,
name|block
argument_list|)
condition|)
block|{
name|this
operator|.
name|block
operator|=
name|block
expr_stmt|;
if|if
condition|(
name|chooseProxySource
argument_list|()
condition|)
block|{
name|movedBlocks
operator|.
name|add
argument_list|(
name|block
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Decided to move "
operator|+
name|this
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
block|}
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/* Now we find out source, target, and block, we need to find a proxy      *       * @return true if a proxy is found; otherwise false      */
DECL|method|chooseProxySource ()
specifier|private
name|boolean
name|chooseProxySource
parameter_list|()
block|{
specifier|final
name|DatanodeInfo
name|targetDN
init|=
name|target
operator|.
name|getDatanode
argument_list|()
decl_stmt|;
comment|// if node group is supported, first try add nodes in the same node group
if|if
condition|(
name|cluster
operator|.
name|isNodeGroupAware
argument_list|()
condition|)
block|{
for|for
control|(
name|BalancerDatanode
operator|.
name|StorageGroup
name|loc
range|:
name|block
operator|.
name|getLocations
argument_list|()
control|)
block|{
if|if
condition|(
name|cluster
operator|.
name|isOnSameNodeGroup
argument_list|(
name|loc
operator|.
name|getDatanode
argument_list|()
argument_list|,
name|targetDN
argument_list|)
operator|&&
name|addTo
argument_list|(
name|loc
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
block|}
comment|// check if there is replica which is on the same rack with the target
for|for
control|(
name|BalancerDatanode
operator|.
name|StorageGroup
name|loc
range|:
name|block
operator|.
name|getLocations
argument_list|()
control|)
block|{
if|if
condition|(
name|cluster
operator|.
name|isOnSameRack
argument_list|(
name|loc
operator|.
name|getDatanode
argument_list|()
argument_list|,
name|targetDN
argument_list|)
operator|&&
name|addTo
argument_list|(
name|loc
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
comment|// find out a non-busy replica
for|for
control|(
name|BalancerDatanode
operator|.
name|StorageGroup
name|loc
range|:
name|block
operator|.
name|getLocations
argument_list|()
control|)
block|{
if|if
condition|(
name|addTo
argument_list|(
name|loc
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/** add to a proxy source for specific block movement */
DECL|method|addTo (BalancerDatanode.StorageGroup g)
specifier|private
name|boolean
name|addTo
parameter_list|(
name|BalancerDatanode
operator|.
name|StorageGroup
name|g
parameter_list|)
block|{
specifier|final
name|BalancerDatanode
name|bdn
init|=
name|g
operator|.
name|getBalancerDatanode
argument_list|()
decl_stmt|;
if|if
condition|(
name|bdn
operator|.
name|addPendingBlock
argument_list|(
name|this
argument_list|)
condition|)
block|{
name|proxySource
operator|=
name|bdn
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
comment|/* Dispatch the block move task to the proxy source& wait for the response      */
DECL|method|dispatch ()
specifier|private
name|void
name|dispatch
parameter_list|()
block|{
name|Socket
name|sock
init|=
operator|new
name|Socket
argument_list|()
decl_stmt|;
name|DataOutputStream
name|out
init|=
literal|null
decl_stmt|;
name|DataInputStream
name|in
init|=
literal|null
decl_stmt|;
try|try
block|{
name|sock
operator|.
name|connect
argument_list|(
name|NetUtils
operator|.
name|createSocketAddr
argument_list|(
name|target
operator|.
name|getDatanode
argument_list|()
operator|.
name|getXferAddr
argument_list|()
argument_list|)
argument_list|,
name|HdfsServerConstants
operator|.
name|READ_TIMEOUT
argument_list|)
expr_stmt|;
comment|/* Unfortunately we don't have a good way to know if the Datanode is          * taking a really long time to move a block, OR something has          * gone wrong and it's never going to finish. To deal with this           * scenario, we set a long timeout (20 minutes) to avoid hanging          * the balancer indefinitely.          */
name|sock
operator|.
name|setSoTimeout
argument_list|(
name|BLOCK_MOVE_READ_TIMEOUT
argument_list|)
expr_stmt|;
name|sock
operator|.
name|setKeepAlive
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|OutputStream
name|unbufOut
init|=
name|sock
operator|.
name|getOutputStream
argument_list|()
decl_stmt|;
name|InputStream
name|unbufIn
init|=
name|sock
operator|.
name|getInputStream
argument_list|()
decl_stmt|;
name|ExtendedBlock
name|eb
init|=
operator|new
name|ExtendedBlock
argument_list|(
name|nnc
operator|.
name|blockpoolID
argument_list|,
name|block
operator|.
name|getBlock
argument_list|()
argument_list|)
decl_stmt|;
name|Token
argument_list|<
name|BlockTokenIdentifier
argument_list|>
name|accessToken
init|=
name|nnc
operator|.
name|getAccessToken
argument_list|(
name|eb
argument_list|)
decl_stmt|;
name|IOStreamPair
name|saslStreams
init|=
name|saslClient
operator|.
name|socketSend
argument_list|(
name|sock
argument_list|,
name|unbufOut
argument_list|,
name|unbufIn
argument_list|,
name|nnc
argument_list|,
name|accessToken
argument_list|,
name|target
operator|.
name|getDatanode
argument_list|()
argument_list|)
decl_stmt|;
name|unbufOut
operator|=
name|saslStreams
operator|.
name|out
expr_stmt|;
name|unbufIn
operator|=
name|saslStreams
operator|.
name|in
expr_stmt|;
name|out
operator|=
operator|new
name|DataOutputStream
argument_list|(
operator|new
name|BufferedOutputStream
argument_list|(
name|unbufOut
argument_list|,
name|HdfsConstants
operator|.
name|IO_FILE_BUFFER_SIZE
argument_list|)
argument_list|)
expr_stmt|;
name|in
operator|=
operator|new
name|DataInputStream
argument_list|(
operator|new
name|BufferedInputStream
argument_list|(
name|unbufIn
argument_list|,
name|HdfsConstants
operator|.
name|IO_FILE_BUFFER_SIZE
argument_list|)
argument_list|)
expr_stmt|;
name|sendRequest
argument_list|(
name|out
argument_list|,
name|eb
argument_list|,
name|StorageType
operator|.
name|DEFAULT
argument_list|,
name|accessToken
argument_list|)
expr_stmt|;
name|receiveResponse
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|bytesMoved
operator|.
name|addAndGet
argument_list|(
name|block
operator|.
name|getNumBytes
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Successfully moved "
operator|+
name|this
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to move "
operator|+
name|this
operator|+
literal|": "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
comment|/* proxy or target may have an issue, insert a small delay          * before using these nodes further. This avoids a potential storm          * of "threads quota exceeded" Warnings when the balancer          * gets out of sync with work going on in datanode.          */
name|proxySource
operator|.
name|activateDelay
argument_list|(
name|DELAY_AFTER_ERROR
argument_list|)
expr_stmt|;
name|target
operator|.
name|getBalancerDatanode
argument_list|()
operator|.
name|activateDelay
argument_list|(
name|DELAY_AFTER_ERROR
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|IOUtils
operator|.
name|closeStream
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|IOUtils
operator|.
name|closeStream
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|IOUtils
operator|.
name|closeSocket
argument_list|(
name|sock
argument_list|)
expr_stmt|;
name|proxySource
operator|.
name|removePendingBlock
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|target
operator|.
name|getBalancerDatanode
argument_list|()
operator|.
name|removePendingBlock
argument_list|(
name|this
argument_list|)
expr_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
name|reset
argument_list|()
expr_stmt|;
block|}
synchronized|synchronized
init|(
name|Balancer
operator|.
name|this
init|)
block|{
name|Balancer
operator|.
name|this
operator|.
name|notifyAll
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/* Send a block replace request to the output stream*/
DECL|method|sendRequest (DataOutputStream out, ExtendedBlock eb, StorageType storageType, Token<BlockTokenIdentifier> accessToken)
specifier|private
name|void
name|sendRequest
parameter_list|(
name|DataOutputStream
name|out
parameter_list|,
name|ExtendedBlock
name|eb
parameter_list|,
name|StorageType
name|storageType
parameter_list|,
name|Token
argument_list|<
name|BlockTokenIdentifier
argument_list|>
name|accessToken
parameter_list|)
throws|throws
name|IOException
block|{
operator|new
name|Sender
argument_list|(
name|out
argument_list|)
operator|.
name|replaceBlock
argument_list|(
name|eb
argument_list|,
name|storageType
argument_list|,
name|accessToken
argument_list|,
name|source
operator|.
name|getDatanode
argument_list|()
operator|.
name|getDatanodeUuid
argument_list|()
argument_list|,
name|proxySource
operator|.
name|datanode
argument_list|)
expr_stmt|;
block|}
comment|/* Receive a block copy response from the input stream */
DECL|method|receiveResponse (DataInputStream in)
specifier|private
name|void
name|receiveResponse
parameter_list|(
name|DataInputStream
name|in
parameter_list|)
throws|throws
name|IOException
block|{
name|BlockOpResponseProto
name|response
init|=
name|BlockOpResponseProto
operator|.
name|parseFrom
argument_list|(
name|vintPrefixed
argument_list|(
name|in
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|response
operator|.
name|getStatus
argument_list|()
operator|!=
name|Status
operator|.
name|SUCCESS
condition|)
block|{
if|if
condition|(
name|response
operator|.
name|getStatus
argument_list|()
operator|==
name|Status
operator|.
name|ERROR_ACCESS_TOKEN
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"block move failed due to access token error"
argument_list|)
throw|;
throw|throw
operator|new
name|IOException
argument_list|(
literal|"block move is failed: "
operator|+
name|response
operator|.
name|getMessage
argument_list|()
argument_list|)
throw|;
block|}
block|}
comment|/* reset the object */
DECL|method|reset ()
specifier|private
name|void
name|reset
parameter_list|()
block|{
name|block
operator|=
literal|null
expr_stmt|;
name|source
operator|=
literal|null
expr_stmt|;
name|proxySource
operator|=
literal|null
expr_stmt|;
name|target
operator|=
literal|null
expr_stmt|;
block|}
comment|/* start a thread to dispatch the block move */
DECL|method|scheduleBlockMove ()
specifier|private
name|void
name|scheduleBlockMove
parameter_list|()
block|{
name|moverExecutor
operator|.
name|execute
argument_list|(
operator|new
name|Runnable
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Start moving "
operator|+
name|PendingBlockMove
operator|.
name|this
argument_list|)
expr_stmt|;
block|}
name|dispatch
argument_list|()
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* A class for keeping track of blocks in the Balancer */
DECL|class|BalancerBlock
specifier|static
specifier|private
class|class
name|BalancerBlock
block|{
DECL|field|block
specifier|private
specifier|final
name|Block
name|block
decl_stmt|;
comment|// the block
comment|/** The locations of the replicas of the block. */
DECL|field|locations
specifier|private
specifier|final
name|List
argument_list|<
name|BalancerDatanode
operator|.
name|StorageGroup
argument_list|>
name|locations
init|=
operator|new
name|ArrayList
argument_list|<
name|BalancerDatanode
operator|.
name|StorageGroup
argument_list|>
argument_list|(
literal|3
argument_list|)
decl_stmt|;
comment|/* Constructor */
DECL|method|BalancerBlock (Block block)
specifier|private
name|BalancerBlock
parameter_list|(
name|Block
name|block
parameter_list|)
block|{
name|this
operator|.
name|block
operator|=
name|block
expr_stmt|;
block|}
comment|/* clean block locations */
DECL|method|clearLocations ()
specifier|private
specifier|synchronized
name|void
name|clearLocations
parameter_list|()
block|{
name|locations
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
comment|/* add a location */
DECL|method|addLocation (BalancerDatanode.StorageGroup g)
specifier|private
specifier|synchronized
name|void
name|addLocation
parameter_list|(
name|BalancerDatanode
operator|.
name|StorageGroup
name|g
parameter_list|)
block|{
if|if
condition|(
operator|!
name|locations
operator|.
name|contains
argument_list|(
name|g
argument_list|)
condition|)
block|{
name|locations
operator|.
name|add
argument_list|(
name|g
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** @return if the block is located on the given storage group. */
DECL|method|isLocatedOn (BalancerDatanode.StorageGroup g)
specifier|private
specifier|synchronized
name|boolean
name|isLocatedOn
parameter_list|(
name|BalancerDatanode
operator|.
name|StorageGroup
name|g
parameter_list|)
block|{
return|return
name|locations
operator|.
name|contains
argument_list|(
name|g
argument_list|)
return|;
block|}
comment|/* Return its locations */
DECL|method|getLocations ()
specifier|private
specifier|synchronized
name|List
argument_list|<
name|BalancerDatanode
operator|.
name|StorageGroup
argument_list|>
name|getLocations
parameter_list|()
block|{
return|return
name|locations
return|;
block|}
comment|/* Return the block */
DECL|method|getBlock ()
specifier|private
name|Block
name|getBlock
parameter_list|()
block|{
return|return
name|block
return|;
block|}
comment|/* Return the length of the block */
DECL|method|getNumBytes ()
specifier|private
name|long
name|getNumBytes
parameter_list|()
block|{
return|return
name|block
operator|.
name|getNumBytes
argument_list|()
return|;
block|}
block|}
comment|/* The class represents a desired move of bytes between two nodes     * and the target.    * An object of this class is stored in a source.     */
DECL|class|Task
specifier|static
specifier|private
class|class
name|Task
block|{
DECL|field|target
specifier|private
specifier|final
name|BalancerDatanode
operator|.
name|StorageGroup
name|target
decl_stmt|;
DECL|field|size
specifier|private
name|long
name|size
decl_stmt|;
comment|//bytes scheduled to move
comment|/* constructor */
DECL|method|Task (BalancerDatanode.StorageGroup target, long size)
specifier|private
name|Task
parameter_list|(
name|BalancerDatanode
operator|.
name|StorageGroup
name|target
parameter_list|,
name|long
name|size
parameter_list|)
block|{
name|this
operator|.
name|target
operator|=
name|target
expr_stmt|;
name|this
operator|.
name|size
operator|=
name|size
expr_stmt|;
block|}
block|}
comment|/* A class that keeps track of a datanode in Balancer */
DECL|class|BalancerDatanode
specifier|private
specifier|static
class|class
name|BalancerDatanode
block|{
comment|/** A group of storages in a datanode with the same storage type. */
DECL|class|StorageGroup
specifier|private
class|class
name|StorageGroup
block|{
DECL|field|storageType
specifier|final
name|StorageType
name|storageType
decl_stmt|;
DECL|field|utilization
specifier|final
name|double
name|utilization
decl_stmt|;
DECL|field|maxSize2Move
specifier|final
name|long
name|maxSize2Move
decl_stmt|;
DECL|field|scheduledSize
specifier|private
name|long
name|scheduledSize
init|=
literal|0L
decl_stmt|;
DECL|method|StorageGroup (StorageType storageType, double utilization, long maxSize2Move)
specifier|private
name|StorageGroup
parameter_list|(
name|StorageType
name|storageType
parameter_list|,
name|double
name|utilization
parameter_list|,
name|long
name|maxSize2Move
parameter_list|)
block|{
name|this
operator|.
name|storageType
operator|=
name|storageType
expr_stmt|;
name|this
operator|.
name|utilization
operator|=
name|utilization
expr_stmt|;
name|this
operator|.
name|maxSize2Move
operator|=
name|maxSize2Move
expr_stmt|;
block|}
DECL|method|getBalancerDatanode ()
name|BalancerDatanode
name|getBalancerDatanode
parameter_list|()
block|{
return|return
name|BalancerDatanode
operator|.
name|this
return|;
block|}
DECL|method|getDatanode ()
name|DatanodeInfo
name|getDatanode
parameter_list|()
block|{
return|return
name|BalancerDatanode
operator|.
name|this
operator|.
name|datanode
return|;
block|}
comment|/** Decide if still need to move more bytes */
DECL|method|hasSpaceForScheduling ()
specifier|protected
specifier|synchronized
name|boolean
name|hasSpaceForScheduling
parameter_list|()
block|{
return|return
name|availableSizeToMove
argument_list|()
operator|>
literal|0L
return|;
block|}
comment|/** @return the total number of bytes that need to be moved */
DECL|method|availableSizeToMove ()
specifier|synchronized
name|long
name|availableSizeToMove
parameter_list|()
block|{
return|return
name|maxSize2Move
operator|-
name|scheduledSize
return|;
block|}
comment|/** increment scheduled size */
DECL|method|incScheduledSize (long size)
specifier|synchronized
name|void
name|incScheduledSize
parameter_list|(
name|long
name|size
parameter_list|)
block|{
name|scheduledSize
operator|+=
name|size
expr_stmt|;
block|}
comment|/** @return scheduled size */
DECL|method|getScheduledSize ()
specifier|synchronized
name|long
name|getScheduledSize
parameter_list|()
block|{
return|return
name|scheduledSize
return|;
block|}
comment|/** Reset scheduled size to zero. */
DECL|method|resetScheduledSize ()
specifier|synchronized
name|void
name|resetScheduledSize
parameter_list|()
block|{
name|scheduledSize
operator|=
literal|0L
expr_stmt|;
block|}
comment|/** @return the name for display */
DECL|method|getDisplayName ()
name|String
name|getDisplayName
parameter_list|()
block|{
return|return
name|datanode
operator|+
literal|":"
operator|+
name|storageType
return|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|""
operator|+
name|utilization
return|;
block|}
block|}
DECL|field|datanode
specifier|final
name|DatanodeInfo
name|datanode
decl_stmt|;
DECL|field|storageMap
specifier|final
name|EnumMap
argument_list|<
name|StorageType
argument_list|,
name|StorageGroup
argument_list|>
name|storageMap
init|=
operator|new
name|EnumMap
argument_list|<
name|StorageType
argument_list|,
name|StorageGroup
argument_list|>
argument_list|(
name|StorageType
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|delayUntil
specifier|protected
name|long
name|delayUntil
init|=
literal|0L
decl_stmt|;
comment|//  blocks being moved but not confirmed yet
DECL|field|pendingBlocks
specifier|private
specifier|final
name|List
argument_list|<
name|PendingBlockMove
argument_list|>
name|pendingBlocks
decl_stmt|;
DECL|field|maxConcurrentMoves
specifier|private
specifier|final
name|int
name|maxConcurrentMoves
decl_stmt|;
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|":"
operator|+
name|datanode
operator|+
literal|":"
operator|+
name|storageMap
return|;
block|}
comment|/* Constructor       * Depending on avgutil& threshold, calculate maximum bytes to move       */
DECL|method|BalancerDatanode (DatanodeStorageReport report, double threshold, int maxConcurrentMoves)
specifier|private
name|BalancerDatanode
parameter_list|(
name|DatanodeStorageReport
name|report
parameter_list|,
name|double
name|threshold
parameter_list|,
name|int
name|maxConcurrentMoves
parameter_list|)
block|{
name|this
operator|.
name|datanode
operator|=
name|report
operator|.
name|getDatanodeInfo
argument_list|()
expr_stmt|;
name|this
operator|.
name|maxConcurrentMoves
operator|=
name|maxConcurrentMoves
expr_stmt|;
name|this
operator|.
name|pendingBlocks
operator|=
operator|new
name|ArrayList
argument_list|<
name|PendingBlockMove
argument_list|>
argument_list|(
name|maxConcurrentMoves
argument_list|)
expr_stmt|;
block|}
DECL|method|put (StorageType storageType, StorageGroup g)
specifier|private
name|void
name|put
parameter_list|(
name|StorageType
name|storageType
parameter_list|,
name|StorageGroup
name|g
parameter_list|)
block|{
specifier|final
name|StorageGroup
name|existing
init|=
name|storageMap
operator|.
name|put
argument_list|(
name|storageType
argument_list|,
name|g
argument_list|)
decl_stmt|;
name|Preconditions
operator|.
name|checkState
argument_list|(
name|existing
operator|==
literal|null
argument_list|)
expr_stmt|;
block|}
DECL|method|addStorageGroup (StorageType storageType, double utilization, long maxSize2Move)
name|StorageGroup
name|addStorageGroup
parameter_list|(
name|StorageType
name|storageType
parameter_list|,
name|double
name|utilization
parameter_list|,
name|long
name|maxSize2Move
parameter_list|)
block|{
specifier|final
name|StorageGroup
name|g
init|=
operator|new
name|StorageGroup
argument_list|(
name|storageType
argument_list|,
name|utilization
argument_list|,
name|maxSize2Move
argument_list|)
decl_stmt|;
name|put
argument_list|(
name|storageType
argument_list|,
name|g
argument_list|)
expr_stmt|;
return|return
name|g
return|;
block|}
DECL|method|addSource (StorageType storageType, double utilization, long maxSize2Move, Balancer balancer)
name|Source
name|addSource
parameter_list|(
name|StorageType
name|storageType
parameter_list|,
name|double
name|utilization
parameter_list|,
name|long
name|maxSize2Move
parameter_list|,
name|Balancer
name|balancer
parameter_list|)
block|{
specifier|final
name|Source
name|s
init|=
name|balancer
operator|.
expr|new
name|Source
argument_list|(
name|storageType
argument_list|,
name|utilization
argument_list|,
name|maxSize2Move
argument_list|,
name|this
argument_list|)
decl_stmt|;
name|put
argument_list|(
name|storageType
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
DECL|method|activateDelay (long delta)
specifier|synchronized
specifier|private
name|void
name|activateDelay
parameter_list|(
name|long
name|delta
parameter_list|)
block|{
name|delayUntil
operator|=
name|Time
operator|.
name|now
argument_list|()
operator|+
name|delta
expr_stmt|;
block|}
DECL|method|isDelayActive ()
specifier|synchronized
specifier|private
name|boolean
name|isDelayActive
parameter_list|()
block|{
if|if
condition|(
name|delayUntil
operator|==
literal|0
operator|||
name|Time
operator|.
name|now
argument_list|()
operator|>
name|delayUntil
condition|)
block|{
name|delayUntil
operator|=
literal|0
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
comment|/* Check if the node can schedule more blocks to move */
DECL|method|isPendingQNotFull ()
specifier|synchronized
specifier|private
name|boolean
name|isPendingQNotFull
parameter_list|()
block|{
if|if
condition|(
name|pendingBlocks
operator|.
name|size
argument_list|()
operator|<
name|this
operator|.
name|maxConcurrentMoves
condition|)
block|{
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
comment|/* Check if all the dispatched moves are done */
DECL|method|isPendingQEmpty ()
specifier|synchronized
specifier|private
name|boolean
name|isPendingQEmpty
parameter_list|()
block|{
return|return
name|pendingBlocks
operator|.
name|isEmpty
argument_list|()
return|;
block|}
comment|/* Add a scheduled block move to the node */
DECL|method|addPendingBlock ( PendingBlockMove pendingBlock)
specifier|private
specifier|synchronized
name|boolean
name|addPendingBlock
parameter_list|(
name|PendingBlockMove
name|pendingBlock
parameter_list|)
block|{
if|if
condition|(
operator|!
name|isDelayActive
argument_list|()
operator|&&
name|isPendingQNotFull
argument_list|()
condition|)
block|{
return|return
name|pendingBlocks
operator|.
name|add
argument_list|(
name|pendingBlock
argument_list|)
return|;
block|}
return|return
literal|false
return|;
block|}
comment|/* Remove a scheduled block move from the node */
DECL|method|removePendingBlock ( PendingBlockMove pendingBlock)
specifier|private
specifier|synchronized
name|boolean
name|removePendingBlock
parameter_list|(
name|PendingBlockMove
name|pendingBlock
parameter_list|)
block|{
return|return
name|pendingBlocks
operator|.
name|remove
argument_list|(
name|pendingBlock
argument_list|)
return|;
block|}
block|}
comment|/** A node that can be the sources of a block move */
DECL|class|Source
specifier|private
class|class
name|Source
extends|extends
name|BalancerDatanode
operator|.
name|StorageGroup
block|{
comment|/* A thread that initiates a block move       * and waits for block move to complete */
DECL|class|BlockMoveDispatcher
specifier|private
class|class
name|BlockMoveDispatcher
implements|implements
name|Runnable
block|{
annotation|@
name|Override
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
name|dispatchBlocks
argument_list|()
expr_stmt|;
block|}
block|}
DECL|field|tasks
specifier|private
specifier|final
name|List
argument_list|<
name|Task
argument_list|>
name|tasks
init|=
operator|new
name|ArrayList
argument_list|<
name|Task
argument_list|>
argument_list|(
literal|2
argument_list|)
decl_stmt|;
DECL|field|blocksToReceive
specifier|private
name|long
name|blocksToReceive
init|=
literal|0L
decl_stmt|;
comment|/* source blocks point to balancerBlocks in the global list because      * we want to keep one copy of a block in balancer and be aware that      * the locations are changing over time.      */
DECL|field|srcBlockList
specifier|private
specifier|final
name|List
argument_list|<
name|BalancerBlock
argument_list|>
name|srcBlockList
init|=
operator|new
name|ArrayList
argument_list|<
name|BalancerBlock
argument_list|>
argument_list|()
decl_stmt|;
comment|/* constructor */
DECL|method|Source (StorageType storageType, double utilization, long maxSize2Move, BalancerDatanode dn)
specifier|private
name|Source
parameter_list|(
name|StorageType
name|storageType
parameter_list|,
name|double
name|utilization
parameter_list|,
name|long
name|maxSize2Move
parameter_list|,
name|BalancerDatanode
name|dn
parameter_list|)
block|{
name|dn
operator|.
name|super
argument_list|(
name|storageType
argument_list|,
name|utilization
argument_list|,
name|maxSize2Move
argument_list|)
expr_stmt|;
block|}
comment|/** Add a task */
DECL|method|addTask (Task task)
specifier|private
name|void
name|addTask
parameter_list|(
name|Task
name|task
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkState
argument_list|(
name|task
operator|.
name|target
operator|!=
name|this
argument_list|,
literal|"Source and target are the same storage group "
operator|+
name|getDisplayName
argument_list|()
argument_list|)
expr_stmt|;
name|incScheduledSize
argument_list|(
name|task
operator|.
name|size
argument_list|)
expr_stmt|;
name|tasks
operator|.
name|add
argument_list|(
name|task
argument_list|)
expr_stmt|;
block|}
comment|/* Return an iterator to this source's blocks */
DECL|method|getBlockIterator ()
specifier|private
name|Iterator
argument_list|<
name|BalancerBlock
argument_list|>
name|getBlockIterator
parameter_list|()
block|{
return|return
name|srcBlockList
operator|.
name|iterator
argument_list|()
return|;
block|}
comment|/* fetch new blocks of this source from namenode and      * update this source's block list& the global block list      * Return the total size of the received blocks in the number of bytes.      */
DECL|method|getBlockList ()
specifier|private
name|long
name|getBlockList
parameter_list|()
throws|throws
name|IOException
block|{
specifier|final
name|long
name|size
init|=
name|Math
operator|.
name|min
argument_list|(
name|MAX_BLOCKS_SIZE_TO_FETCH
argument_list|,
name|blocksToReceive
argument_list|)
decl_stmt|;
specifier|final
name|BlockWithLocations
index|[]
name|newBlocks
init|=
name|nnc
operator|.
name|namenode
operator|.
name|getBlocks
argument_list|(
name|getDatanode
argument_list|()
argument_list|,
name|size
argument_list|)
operator|.
name|getBlocks
argument_list|()
decl_stmt|;
name|long
name|bytesReceived
init|=
literal|0
decl_stmt|;
for|for
control|(
name|BlockWithLocations
name|blk
range|:
name|newBlocks
control|)
block|{
name|bytesReceived
operator|+=
name|blk
operator|.
name|getBlock
argument_list|()
operator|.
name|getNumBytes
argument_list|()
expr_stmt|;
name|BalancerBlock
name|block
decl_stmt|;
synchronized|synchronized
init|(
name|globalBlockList
init|)
block|{
name|block
operator|=
name|globalBlockList
operator|.
name|get
argument_list|(
name|blk
operator|.
name|getBlock
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|block
operator|==
literal|null
condition|)
block|{
name|block
operator|=
operator|new
name|BalancerBlock
argument_list|(
name|blk
operator|.
name|getBlock
argument_list|()
argument_list|)
expr_stmt|;
name|globalBlockList
operator|.
name|put
argument_list|(
name|blk
operator|.
name|getBlock
argument_list|()
argument_list|,
name|block
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|block
operator|.
name|clearLocations
argument_list|()
expr_stmt|;
block|}
synchronized|synchronized
init|(
name|block
init|)
block|{
comment|// update locations
specifier|final
name|String
index|[]
name|datanodeUuids
init|=
name|blk
operator|.
name|getDatanodeUuids
argument_list|()
decl_stmt|;
specifier|final
name|StorageType
index|[]
name|storageTypes
init|=
name|blk
operator|.
name|getStorageTypes
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|datanodeUuids
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|BalancerDatanode
operator|.
name|StorageGroup
name|g
init|=
name|storageGroupMap
operator|.
name|get
argument_list|(
name|datanodeUuids
index|[
name|i
index|]
argument_list|,
name|storageTypes
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|g
operator|!=
literal|null
condition|)
block|{
comment|// not unknown
name|block
operator|.
name|addLocation
argument_list|(
name|g
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|srcBlockList
operator|.
name|contains
argument_list|(
name|block
argument_list|)
operator|&&
name|isGoodBlockCandidate
argument_list|(
name|block
argument_list|)
condition|)
block|{
comment|// filter bad candidates
name|srcBlockList
operator|.
name|add
argument_list|(
name|block
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|bytesReceived
return|;
block|}
comment|/* Decide if the given block is a good candidate to move or not */
DECL|method|isGoodBlockCandidate (BalancerBlock block)
specifier|private
name|boolean
name|isGoodBlockCandidate
parameter_list|(
name|BalancerBlock
name|block
parameter_list|)
block|{
for|for
control|(
name|Task
name|t
range|:
name|tasks
control|)
block|{
if|if
condition|(
name|Balancer
operator|.
name|this
operator|.
name|isGoodBlockCandidate
argument_list|(
name|this
argument_list|,
name|t
operator|.
name|target
argument_list|,
name|block
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/* Return a block that's good for the source thread to dispatch immediately      * The block's source, target, and proxy source are determined too.      * When choosing proxy and target, source& target throttling      * has been considered. They are chosen only when they have the capacity      * to support this block move.      * The block should be dispatched immediately after this method is returned.      */
DECL|method|chooseNextBlockToMove ()
specifier|private
name|PendingBlockMove
name|chooseNextBlockToMove
parameter_list|()
block|{
for|for
control|(
name|Iterator
argument_list|<
name|Task
argument_list|>
name|i
init|=
name|tasks
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
specifier|final
name|Task
name|task
init|=
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
specifier|final
name|BalancerDatanode
name|target
init|=
name|task
operator|.
name|target
operator|.
name|getBalancerDatanode
argument_list|()
decl_stmt|;
name|PendingBlockMove
name|pendingBlock
init|=
operator|new
name|PendingBlockMove
argument_list|()
decl_stmt|;
if|if
condition|(
name|target
operator|.
name|addPendingBlock
argument_list|(
name|pendingBlock
argument_list|)
condition|)
block|{
comment|// target is not busy, so do a tentative block allocation
name|pendingBlock
operator|.
name|source
operator|=
name|this
expr_stmt|;
name|pendingBlock
operator|.
name|target
operator|=
name|task
operator|.
name|target
expr_stmt|;
if|if
condition|(
name|pendingBlock
operator|.
name|chooseBlockAndProxy
argument_list|()
condition|)
block|{
name|long
name|blockSize
init|=
name|pendingBlock
operator|.
name|block
operator|.
name|getNumBytes
argument_list|()
decl_stmt|;
name|incScheduledSize
argument_list|(
operator|-
name|blockSize
argument_list|)
expr_stmt|;
name|task
operator|.
name|size
operator|-=
name|blockSize
expr_stmt|;
if|if
condition|(
name|task
operator|.
name|size
operator|==
literal|0
condition|)
block|{
name|i
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
return|return
name|pendingBlock
return|;
block|}
else|else
block|{
comment|// cancel the tentative move
name|target
operator|.
name|removePendingBlock
argument_list|(
name|pendingBlock
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/* iterate all source's blocks to remove moved ones */
DECL|method|filterMovedBlocks ()
specifier|private
name|void
name|filterMovedBlocks
parameter_list|()
block|{
for|for
control|(
name|Iterator
argument_list|<
name|BalancerBlock
argument_list|>
name|blocks
init|=
name|getBlockIterator
argument_list|()
init|;
name|blocks
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
if|if
condition|(
name|movedBlocks
operator|.
name|contains
argument_list|(
name|blocks
operator|.
name|next
argument_list|()
argument_list|)
condition|)
block|{
name|blocks
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
block|}
DECL|field|SOURCE_BLOCK_LIST_MIN_SIZE
specifier|private
specifier|static
specifier|final
name|int
name|SOURCE_BLOCK_LIST_MIN_SIZE
init|=
literal|5
decl_stmt|;
comment|/* Return if should fetch more blocks from namenode */
DECL|method|shouldFetchMoreBlocks ()
specifier|private
name|boolean
name|shouldFetchMoreBlocks
parameter_list|()
block|{
return|return
name|srcBlockList
operator|.
name|size
argument_list|()
operator|<
name|SOURCE_BLOCK_LIST_MIN_SIZE
operator|&&
name|blocksToReceive
operator|>
literal|0
return|;
block|}
comment|/* This method iteratively does the following:      * it first selects a block to move,      * then sends a request to the proxy source to start the block move      * when the source's block list falls below a threshold, it asks      * the namenode for more blocks.      * It terminates when it has dispatch enough block move tasks or      * it has received enough blocks from the namenode, or       * the elapsed time of the iteration has exceeded the max time limit.      */
DECL|field|MAX_ITERATION_TIME
specifier|private
specifier|static
specifier|final
name|long
name|MAX_ITERATION_TIME
init|=
literal|20
operator|*
literal|60
operator|*
literal|1000L
decl_stmt|;
comment|//20 mins
DECL|method|dispatchBlocks ()
specifier|private
name|void
name|dispatchBlocks
parameter_list|()
block|{
name|long
name|startTime
init|=
name|Time
operator|.
name|now
argument_list|()
decl_stmt|;
name|long
name|scheduledSize
init|=
name|getScheduledSize
argument_list|()
decl_stmt|;
name|this
operator|.
name|blocksToReceive
operator|=
literal|2
operator|*
name|scheduledSize
expr_stmt|;
name|boolean
name|isTimeUp
init|=
literal|false
decl_stmt|;
name|int
name|noPendingBlockIteration
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|!
name|isTimeUp
operator|&&
name|getScheduledSize
argument_list|()
operator|>
literal|0
operator|&&
operator|(
operator|!
name|srcBlockList
operator|.
name|isEmpty
argument_list|()
operator|||
name|blocksToReceive
operator|>
literal|0
operator|)
condition|)
block|{
name|PendingBlockMove
name|pendingBlock
init|=
name|chooseNextBlockToMove
argument_list|()
decl_stmt|;
if|if
condition|(
name|pendingBlock
operator|!=
literal|null
condition|)
block|{
comment|// move the block
name|pendingBlock
operator|.
name|scheduleBlockMove
argument_list|()
expr_stmt|;
continue|continue;
block|}
comment|/* Since we can not schedule any block to move,          * filter any moved blocks from the source block list and          * check if we should fetch more blocks from the namenode          */
name|filterMovedBlocks
argument_list|()
expr_stmt|;
comment|// filter already moved blocks
if|if
condition|(
name|shouldFetchMoreBlocks
argument_list|()
condition|)
block|{
comment|// fetch new blocks
try|try
block|{
name|blocksToReceive
operator|-=
name|getBlockList
argument_list|()
expr_stmt|;
continue|continue;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Exception while getting block list"
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
comment|// source node cannot find a pendingBlockToMove, iteration +1
name|noPendingBlockIteration
operator|++
expr_stmt|;
comment|// in case no blocks can be moved for source node's task,
comment|// jump out of while-loop after 5 iterations.
if|if
condition|(
name|noPendingBlockIteration
operator|>=
name|MAX_NO_PENDING_BLOCK_ITERATIONS
condition|)
block|{
name|resetScheduledSize
argument_list|()
expr_stmt|;
block|}
block|}
comment|// check if time is up or not
if|if
condition|(
name|Time
operator|.
name|now
argument_list|()
operator|-
name|startTime
operator|>
name|MAX_ITERATION_TIME
condition|)
block|{
name|isTimeUp
operator|=
literal|true
expr_stmt|;
continue|continue;
block|}
comment|/* Now we can not schedule any block to move and there are          * no new blocks added to the source block list, so we wait.           */
try|try
block|{
synchronized|synchronized
init|(
name|Balancer
operator|.
name|this
init|)
block|{
name|Balancer
operator|.
name|this
operator|.
name|wait
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
comment|// wait for targets/sources to be idle
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ignored
parameter_list|)
block|{         }
block|}
block|}
block|}
comment|/* Check that this Balancer is compatible with the Block Placement Policy    * used by the Namenode.    */
DECL|method|checkReplicationPolicyCompatibility (Configuration conf )
specifier|private
specifier|static
name|void
name|checkReplicationPolicyCompatibility
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|UnsupportedActionException
block|{
if|if
condition|(
operator|!
operator|(
name|BlockPlacementPolicy
operator|.
name|getInstance
argument_list|(
name|conf
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
operator|instanceof
name|BlockPlacementPolicyDefault
operator|)
condition|)
block|{
throw|throw
operator|new
name|UnsupportedActionException
argument_list|(
literal|"Balancer without BlockPlacementPolicyDefault"
argument_list|)
throw|;
block|}
block|}
comment|/**    * Construct a balancer.    * Initialize balancer. It sets the value of the threshold, and     * builds the communication proxies to    * namenode as a client and a secondary namenode and retry proxies    * when connection fails.    */
DECL|method|Balancer (NameNodeConnector theblockpool, Parameters p, Configuration conf)
name|Balancer
parameter_list|(
name|NameNodeConnector
name|theblockpool
parameter_list|,
name|Parameters
name|p
parameter_list|,
name|Configuration
name|conf
parameter_list|)
block|{
name|this
operator|.
name|threshold
operator|=
name|p
operator|.
name|threshold
expr_stmt|;
name|this
operator|.
name|policy
operator|=
name|p
operator|.
name|policy
expr_stmt|;
name|this
operator|.
name|nodesToBeExcluded
operator|=
name|p
operator|.
name|nodesToBeExcluded
expr_stmt|;
name|this
operator|.
name|nodesToBeIncluded
operator|=
name|p
operator|.
name|nodesToBeIncluded
expr_stmt|;
name|this
operator|.
name|nnc
operator|=
name|theblockpool
expr_stmt|;
name|cluster
operator|=
name|NetworkTopology
operator|.
name|getInstance
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|moverExecutor
operator|=
name|Executors
operator|.
name|newFixedThreadPool
argument_list|(
name|conf
operator|.
name|getInt
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_BALANCER_MOVERTHREADS_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_BALANCER_MOVERTHREADS_DEFAULT
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|dispatcherExecutor
operator|=
name|Executors
operator|.
name|newFixedThreadPool
argument_list|(
name|conf
operator|.
name|getInt
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_BALANCER_DISPATCHERTHREADS_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_BALANCER_DISPATCHERTHREADS_DEFAULT
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|maxConcurrentMovesPerNode
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_DATANODE_BALANCE_MAX_NUM_CONCURRENT_MOVES_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_DATANODE_BALANCE_MAX_NUM_CONCURRENT_MOVES_DEFAULT
argument_list|)
expr_stmt|;
name|this
operator|.
name|saslClient
operator|=
operator|new
name|SaslDataTransferClient
argument_list|(
name|DataTransferSaslUtil
operator|.
name|getSaslPropertiesResolver
argument_list|(
name|conf
argument_list|)
argument_list|,
name|TrustedChannelResolver
operator|.
name|getInstance
argument_list|(
name|conf
argument_list|)
argument_list|,
name|conf
operator|.
name|getBoolean
argument_list|(
name|IPC_CLIENT_FALLBACK_TO_SIMPLE_AUTH_ALLOWED_KEY
argument_list|,
name|IPC_CLIENT_FALLBACK_TO_SIMPLE_AUTH_ALLOWED_DEFAULT
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|getCapacity (DatanodeStorageReport report, StorageType t)
specifier|private
specifier|static
name|long
name|getCapacity
parameter_list|(
name|DatanodeStorageReport
name|report
parameter_list|,
name|StorageType
name|t
parameter_list|)
block|{
name|long
name|capacity
init|=
literal|0L
decl_stmt|;
for|for
control|(
name|StorageReport
name|r
range|:
name|report
operator|.
name|getStorageReports
argument_list|()
control|)
block|{
if|if
condition|(
name|r
operator|.
name|getStorage
argument_list|()
operator|.
name|getStorageType
argument_list|()
operator|==
name|t
condition|)
block|{
name|capacity
operator|+=
name|r
operator|.
name|getCapacity
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|capacity
return|;
block|}
DECL|method|getRemaining (DatanodeStorageReport report, StorageType t)
specifier|private
specifier|static
name|long
name|getRemaining
parameter_list|(
name|DatanodeStorageReport
name|report
parameter_list|,
name|StorageType
name|t
parameter_list|)
block|{
name|long
name|remaining
init|=
literal|0L
decl_stmt|;
for|for
control|(
name|StorageReport
name|r
range|:
name|report
operator|.
name|getStorageReports
argument_list|()
control|)
block|{
if|if
condition|(
name|r
operator|.
name|getStorage
argument_list|()
operator|.
name|getStorageType
argument_list|()
operator|==
name|t
condition|)
block|{
name|remaining
operator|+=
name|r
operator|.
name|getRemaining
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|remaining
return|;
block|}
DECL|method|shouldIgnore (DatanodeInfo dn)
specifier|private
name|boolean
name|shouldIgnore
parameter_list|(
name|DatanodeInfo
name|dn
parameter_list|)
block|{
comment|//ignore decommissioned nodes
specifier|final
name|boolean
name|decommissioned
init|=
name|dn
operator|.
name|isDecommissioned
argument_list|()
decl_stmt|;
comment|//ignore decommissioning nodes
specifier|final
name|boolean
name|decommissioning
init|=
name|dn
operator|.
name|isDecommissionInProgress
argument_list|()
decl_stmt|;
comment|// ignore nodes in exclude list
specifier|final
name|boolean
name|excluded
init|=
name|Util
operator|.
name|shouldBeExcluded
argument_list|(
name|nodesToBeExcluded
argument_list|,
name|dn
argument_list|)
decl_stmt|;
comment|// ignore nodes not in the include list (if include list is not empty)
specifier|final
name|boolean
name|notIncluded
init|=
operator|!
name|Util
operator|.
name|shouldBeIncluded
argument_list|(
name|nodesToBeIncluded
argument_list|,
name|dn
argument_list|)
decl_stmt|;
if|if
condition|(
name|decommissioned
operator|||
name|decommissioning
operator|||
name|excluded
operator|||
name|notIncluded
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Excluding datanode "
operator|+
name|dn
operator|+
literal|": "
operator|+
name|decommissioned
operator|+
literal|", "
operator|+
name|decommissioning
operator|+
literal|", "
operator|+
name|excluded
operator|+
literal|", "
operator|+
name|notIncluded
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
comment|/**    * Given a datanode storage set, build a network topology and decide    * over-utilized storages, above average utilized storages,     * below average utilized storages, and underutilized storages.     * The input datanode storage set is shuffled in order to randomize    * to the storage matching later on.    *    * @return the total number of bytes that are     *                needed to move to make the cluster balanced.    * @param reports a set of datanode storage reports    */
DECL|method|init (DatanodeStorageReport[] reports)
specifier|private
name|long
name|init
parameter_list|(
name|DatanodeStorageReport
index|[]
name|reports
parameter_list|)
block|{
comment|// compute average utilization
for|for
control|(
name|DatanodeStorageReport
name|r
range|:
name|reports
control|)
block|{
if|if
condition|(
name|shouldIgnore
argument_list|(
name|r
operator|.
name|getDatanodeInfo
argument_list|()
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|policy
operator|.
name|accumulateSpaces
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
name|policy
operator|.
name|initAvgUtilization
argument_list|()
expr_stmt|;
comment|// create network topology and classify utilization collections:
comment|//   over-utilized, above-average, below-average and under-utilized.
name|long
name|overLoadedBytes
init|=
literal|0L
decl_stmt|,
name|underLoadedBytes
init|=
literal|0L
decl_stmt|;
for|for
control|(
name|DatanodeStorageReport
name|r
range|:
name|DFSUtil
operator|.
name|shuffle
argument_list|(
name|reports
argument_list|)
control|)
block|{
specifier|final
name|DatanodeInfo
name|datanode
init|=
name|r
operator|.
name|getDatanodeInfo
argument_list|()
decl_stmt|;
if|if
condition|(
name|shouldIgnore
argument_list|(
name|datanode
argument_list|)
condition|)
block|{
continue|continue;
comment|// ignore decommissioning or decommissioned nodes
block|}
name|cluster
operator|.
name|add
argument_list|(
name|datanode
argument_list|)
expr_stmt|;
specifier|final
name|BalancerDatanode
name|dn
init|=
operator|new
name|BalancerDatanode
argument_list|(
name|r
argument_list|,
name|underLoadedBytes
argument_list|,
name|maxConcurrentMovesPerNode
argument_list|)
decl_stmt|;
for|for
control|(
name|StorageType
name|t
range|:
name|StorageType
operator|.
name|asList
argument_list|()
control|)
block|{
specifier|final
name|Double
name|utilization
init|=
name|policy
operator|.
name|getUtilization
argument_list|(
name|r
argument_list|,
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|utilization
operator|==
literal|null
condition|)
block|{
comment|// datanode does not have such storage type
continue|continue;
block|}
specifier|final
name|long
name|capacity
init|=
name|getCapacity
argument_list|(
name|r
argument_list|,
name|t
argument_list|)
decl_stmt|;
specifier|final
name|double
name|utilizationDiff
init|=
name|utilization
operator|-
name|policy
operator|.
name|getAvgUtilization
argument_list|(
name|t
argument_list|)
decl_stmt|;
specifier|final
name|double
name|thresholdDiff
init|=
name|Math
operator|.
name|abs
argument_list|(
name|utilizationDiff
argument_list|)
operator|-
name|threshold
decl_stmt|;
specifier|final
name|long
name|maxSize2Move
init|=
name|computeMaxSize2Move
argument_list|(
name|capacity
argument_list|,
name|getRemaining
argument_list|(
name|r
argument_list|,
name|t
argument_list|)
argument_list|,
name|utilizationDiff
argument_list|,
name|threshold
argument_list|)
decl_stmt|;
specifier|final
name|BalancerDatanode
operator|.
name|StorageGroup
name|g
decl_stmt|;
if|if
condition|(
name|utilizationDiff
operator|>
literal|0
condition|)
block|{
specifier|final
name|Source
name|s
init|=
name|dn
operator|.
name|addSource
argument_list|(
name|t
argument_list|,
name|utilization
argument_list|,
name|maxSize2Move
argument_list|,
name|this
argument_list|)
decl_stmt|;
if|if
condition|(
name|thresholdDiff
operator|<=
literal|0
condition|)
block|{
comment|// within threshold
name|aboveAvgUtilized
operator|.
name|add
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|overLoadedBytes
operator|+=
name|precentage2bytes
argument_list|(
name|thresholdDiff
argument_list|,
name|capacity
argument_list|)
expr_stmt|;
name|overUtilized
operator|.
name|add
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|g
operator|=
name|s
expr_stmt|;
block|}
else|else
block|{
name|g
operator|=
name|dn
operator|.
name|addStorageGroup
argument_list|(
name|t
argument_list|,
name|utilization
argument_list|,
name|maxSize2Move
argument_list|)
expr_stmt|;
if|if
condition|(
name|thresholdDiff
operator|<=
literal|0
condition|)
block|{
comment|// within threshold
name|belowAvgUtilized
operator|.
name|add
argument_list|(
name|g
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|underLoadedBytes
operator|+=
name|precentage2bytes
argument_list|(
name|thresholdDiff
argument_list|,
name|capacity
argument_list|)
expr_stmt|;
name|underUtilized
operator|.
name|add
argument_list|(
name|g
argument_list|)
expr_stmt|;
block|}
block|}
name|storageGroupMap
operator|.
name|put
argument_list|(
name|g
argument_list|)
expr_stmt|;
block|}
block|}
name|logUtilizationCollections
argument_list|()
expr_stmt|;
name|Preconditions
operator|.
name|checkState
argument_list|(
name|storageGroupMap
operator|.
name|size
argument_list|()
operator|==
name|overUtilized
operator|.
name|size
argument_list|()
operator|+
name|underUtilized
operator|.
name|size
argument_list|()
operator|+
name|aboveAvgUtilized
operator|.
name|size
argument_list|()
operator|+
name|belowAvgUtilized
operator|.
name|size
argument_list|()
argument_list|,
literal|"Mismatched number of storage groups"
argument_list|)
expr_stmt|;
comment|// return number of bytes to be moved in order to make the cluster balanced
return|return
name|Math
operator|.
name|max
argument_list|(
name|overLoadedBytes
argument_list|,
name|underLoadedBytes
argument_list|)
return|;
block|}
DECL|method|computeMaxSize2Move (final long capacity, final long remaining, final double utilizationDiff, final double threshold)
specifier|private
specifier|static
name|long
name|computeMaxSize2Move
parameter_list|(
specifier|final
name|long
name|capacity
parameter_list|,
specifier|final
name|long
name|remaining
parameter_list|,
specifier|final
name|double
name|utilizationDiff
parameter_list|,
specifier|final
name|double
name|threshold
parameter_list|)
block|{
specifier|final
name|double
name|diff
init|=
name|Math
operator|.
name|min
argument_list|(
name|threshold
argument_list|,
name|Math
operator|.
name|abs
argument_list|(
name|utilizationDiff
argument_list|)
argument_list|)
decl_stmt|;
name|long
name|maxSizeToMove
init|=
name|precentage2bytes
argument_list|(
name|diff
argument_list|,
name|capacity
argument_list|)
decl_stmt|;
if|if
condition|(
name|utilizationDiff
operator|<
literal|0
condition|)
block|{
name|maxSizeToMove
operator|=
name|Math
operator|.
name|min
argument_list|(
name|remaining
argument_list|,
name|maxSizeToMove
argument_list|)
expr_stmt|;
block|}
return|return
name|Math
operator|.
name|min
argument_list|(
name|MAX_SIZE_TO_MOVE
argument_list|,
name|maxSizeToMove
argument_list|)
return|;
block|}
DECL|method|precentage2bytes (double precentage, long capacity)
specifier|private
specifier|static
name|long
name|precentage2bytes
parameter_list|(
name|double
name|precentage
parameter_list|,
name|long
name|capacity
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|precentage
operator|>=
literal|0
argument_list|,
literal|"precentage = "
operator|+
name|precentage
operator|+
literal|"< 0"
argument_list|)
expr_stmt|;
return|return
call|(
name|long
call|)
argument_list|(
name|precentage
operator|*
name|capacity
operator|/
literal|100.0
argument_list|)
return|;
block|}
comment|/* log the over utilized& under utilized nodes */
DECL|method|logUtilizationCollections ()
specifier|private
name|void
name|logUtilizationCollections
parameter_list|()
block|{
name|logUtilizationCollection
argument_list|(
literal|"over-utilized"
argument_list|,
name|overUtilized
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|logUtilizationCollection
argument_list|(
literal|"above-average"
argument_list|,
name|aboveAvgUtilized
argument_list|)
expr_stmt|;
name|logUtilizationCollection
argument_list|(
literal|"below-average"
argument_list|,
name|belowAvgUtilized
argument_list|)
expr_stmt|;
block|}
name|logUtilizationCollection
argument_list|(
literal|"underutilized"
argument_list|,
name|underUtilized
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|static
parameter_list|<
name|T
extends|extends
name|BalancerDatanode
operator|.
name|StorageGroup
parameter_list|>
DECL|method|logUtilizationCollection (String name, Collection<T> items)
name|void
name|logUtilizationCollection
parameter_list|(
name|String
name|name
parameter_list|,
name|Collection
argument_list|<
name|T
argument_list|>
name|items
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
name|items
operator|.
name|size
argument_list|()
operator|+
literal|" "
operator|+
name|name
operator|+
literal|": "
operator|+
name|items
argument_list|)
expr_stmt|;
block|}
comment|/** A matcher interface for matching nodes. */
DECL|interface|Matcher
specifier|private
interface|interface
name|Matcher
block|{
comment|/** Given the cluster topology, does the left node match the right node? */
DECL|method|match (NetworkTopology cluster, Node left, Node right)
name|boolean
name|match
parameter_list|(
name|NetworkTopology
name|cluster
parameter_list|,
name|Node
name|left
parameter_list|,
name|Node
name|right
parameter_list|)
function_decl|;
block|}
comment|/** Match datanodes in the same node group. */
DECL|field|SAME_NODE_GROUP
specifier|static
specifier|final
name|Matcher
name|SAME_NODE_GROUP
init|=
operator|new
name|Matcher
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|match
parameter_list|(
name|NetworkTopology
name|cluster
parameter_list|,
name|Node
name|left
parameter_list|,
name|Node
name|right
parameter_list|)
block|{
return|return
name|cluster
operator|.
name|isOnSameNodeGroup
argument_list|(
name|left
argument_list|,
name|right
argument_list|)
return|;
block|}
block|}
decl_stmt|;
comment|/** Match datanodes in the same rack. */
DECL|field|SAME_RACK
specifier|static
specifier|final
name|Matcher
name|SAME_RACK
init|=
operator|new
name|Matcher
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|match
parameter_list|(
name|NetworkTopology
name|cluster
parameter_list|,
name|Node
name|left
parameter_list|,
name|Node
name|right
parameter_list|)
block|{
return|return
name|cluster
operator|.
name|isOnSameRack
argument_list|(
name|left
argument_list|,
name|right
argument_list|)
return|;
block|}
block|}
decl_stmt|;
comment|/** Match any datanode with any other datanode. */
DECL|field|ANY_OTHER
specifier|static
specifier|final
name|Matcher
name|ANY_OTHER
init|=
operator|new
name|Matcher
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|match
parameter_list|(
name|NetworkTopology
name|cluster
parameter_list|,
name|Node
name|left
parameter_list|,
name|Node
name|right
parameter_list|)
block|{
return|return
name|left
operator|!=
name|right
return|;
block|}
block|}
decl_stmt|;
comment|/**    * Decide all<source, target> pairs and    * the number of bytes to move from a source to a target    * Maximum bytes to be moved per storage group is    * min(1 Band worth of bytes,  MAX_SIZE_TO_MOVE).    * @return total number of bytes to move in this iteration    */
DECL|method|chooseStorageGroups ()
specifier|private
name|long
name|chooseStorageGroups
parameter_list|()
block|{
comment|// First, match nodes on the same node group if cluster is node group aware
if|if
condition|(
name|cluster
operator|.
name|isNodeGroupAware
argument_list|()
condition|)
block|{
name|chooseStorageGroups
argument_list|(
name|SAME_NODE_GROUP
argument_list|)
expr_stmt|;
block|}
comment|// Then, match nodes on the same rack
name|chooseStorageGroups
argument_list|(
name|SAME_RACK
argument_list|)
expr_stmt|;
comment|// At last, match all remaining nodes
name|chooseStorageGroups
argument_list|(
name|ANY_OTHER
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkState
argument_list|(
name|storageGroupMap
operator|.
name|size
argument_list|()
operator|>=
name|sources
operator|.
name|size
argument_list|()
operator|+
name|targets
operator|.
name|size
argument_list|()
argument_list|,
literal|"Mismatched number of datanodes ("
operator|+
name|storageGroupMap
operator|.
name|size
argument_list|()
operator|+
literal|"< "
operator|+
name|sources
operator|.
name|size
argument_list|()
operator|+
literal|" sources, "
operator|+
name|targets
operator|.
name|size
argument_list|()
operator|+
literal|" targets)"
argument_list|)
expr_stmt|;
name|long
name|bytesToMove
init|=
literal|0L
decl_stmt|;
for|for
control|(
name|Source
name|src
range|:
name|sources
control|)
block|{
name|bytesToMove
operator|+=
name|src
operator|.
name|getScheduledSize
argument_list|()
expr_stmt|;
block|}
return|return
name|bytesToMove
return|;
block|}
comment|/** Decide all<source, target> pairs according to the matcher. */
DECL|method|chooseStorageGroups (final Matcher matcher)
specifier|private
name|void
name|chooseStorageGroups
parameter_list|(
specifier|final
name|Matcher
name|matcher
parameter_list|)
block|{
comment|/* first step: match each overUtilized datanode (source) to      * one or more underUtilized datanodes (targets).      */
name|chooseStorageGroups
argument_list|(
name|overUtilized
argument_list|,
name|underUtilized
argument_list|,
name|matcher
argument_list|)
expr_stmt|;
comment|/* match each remaining overutilized datanode (source) to       * below average utilized datanodes (targets).      * Note only overutilized datanodes that haven't had that max bytes to move      * satisfied in step 1 are selected      */
name|chooseStorageGroups
argument_list|(
name|overUtilized
argument_list|,
name|belowAvgUtilized
argument_list|,
name|matcher
argument_list|)
expr_stmt|;
comment|/* match each remaining underutilized datanode (target) to       * above average utilized datanodes (source).      * Note only underutilized datanodes that have not had that max bytes to      * move satisfied in step 1 are selected.      */
name|chooseStorageGroups
argument_list|(
name|underUtilized
argument_list|,
name|aboveAvgUtilized
argument_list|,
name|matcher
argument_list|)
expr_stmt|;
block|}
comment|/**    * For each datanode, choose matching nodes from the candidates. Either the    * datanodes or the candidates are source nodes with (utilization> Avg), and    * the others are target nodes with (utilization< Avg).    */
specifier|private
parameter_list|<
name|G
extends|extends
name|BalancerDatanode
operator|.
name|StorageGroup
parameter_list|,
name|C
extends|extends
name|BalancerDatanode
operator|.
name|StorageGroup
parameter_list|>
DECL|method|chooseStorageGroups (Collection<G> groups, Collection<C> candidates, Matcher matcher)
name|void
name|chooseStorageGroups
parameter_list|(
name|Collection
argument_list|<
name|G
argument_list|>
name|groups
parameter_list|,
name|Collection
argument_list|<
name|C
argument_list|>
name|candidates
parameter_list|,
name|Matcher
name|matcher
parameter_list|)
block|{
for|for
control|(
specifier|final
name|Iterator
argument_list|<
name|G
argument_list|>
name|i
init|=
name|groups
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
specifier|final
name|G
name|g
init|=
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
for|for
control|(
init|;
name|choose4One
argument_list|(
name|g
argument_list|,
name|candidates
argument_list|,
name|matcher
argument_list|)
condition|;
control|)
empty_stmt|;
if|if
condition|(
operator|!
name|g
operator|.
name|hasSpaceForScheduling
argument_list|()
condition|)
block|{
name|i
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**    * For the given datanode, choose a candidate and then schedule it.    * @return true if a candidate is chosen; false if no candidates is chosen.    */
specifier|private
parameter_list|<
name|C
extends|extends
name|BalancerDatanode
operator|.
name|StorageGroup
parameter_list|>
DECL|method|choose4One (BalancerDatanode.StorageGroup g, Collection<C> candidates, Matcher matcher)
name|boolean
name|choose4One
parameter_list|(
name|BalancerDatanode
operator|.
name|StorageGroup
name|g
parameter_list|,
name|Collection
argument_list|<
name|C
argument_list|>
name|candidates
parameter_list|,
name|Matcher
name|matcher
parameter_list|)
block|{
specifier|final
name|Iterator
argument_list|<
name|C
argument_list|>
name|i
init|=
name|candidates
operator|.
name|iterator
argument_list|()
decl_stmt|;
specifier|final
name|C
name|chosen
init|=
name|chooseCandidate
argument_list|(
name|g
argument_list|,
name|i
argument_list|,
name|matcher
argument_list|)
decl_stmt|;
if|if
condition|(
name|chosen
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|g
operator|instanceof
name|Source
condition|)
block|{
name|matchSourceWithTargetToMove
argument_list|(
operator|(
name|Source
operator|)
name|g
argument_list|,
name|chosen
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|matchSourceWithTargetToMove
argument_list|(
operator|(
name|Source
operator|)
name|chosen
argument_list|,
name|g
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|chosen
operator|.
name|hasSpaceForScheduling
argument_list|()
condition|)
block|{
name|i
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
DECL|method|matchSourceWithTargetToMove (Source source, BalancerDatanode.StorageGroup target)
specifier|private
name|void
name|matchSourceWithTargetToMove
parameter_list|(
name|Source
name|source
parameter_list|,
name|BalancerDatanode
operator|.
name|StorageGroup
name|target
parameter_list|)
block|{
name|long
name|size
init|=
name|Math
operator|.
name|min
argument_list|(
name|source
operator|.
name|availableSizeToMove
argument_list|()
argument_list|,
name|target
operator|.
name|availableSizeToMove
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|Task
name|task
init|=
operator|new
name|Task
argument_list|(
name|target
argument_list|,
name|size
argument_list|)
decl_stmt|;
name|source
operator|.
name|addTask
argument_list|(
name|task
argument_list|)
expr_stmt|;
name|target
operator|.
name|incScheduledSize
argument_list|(
name|task
operator|.
name|size
argument_list|)
expr_stmt|;
name|sources
operator|.
name|add
argument_list|(
name|source
argument_list|)
expr_stmt|;
name|targets
operator|.
name|add
argument_list|(
name|target
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Decided to move "
operator|+
name|StringUtils
operator|.
name|byteDesc
argument_list|(
name|size
argument_list|)
operator|+
literal|" bytes from "
operator|+
name|source
operator|.
name|getDisplayName
argument_list|()
operator|+
literal|" to "
operator|+
name|target
operator|.
name|getDisplayName
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/** Choose a candidate for the given datanode. */
specifier|private
parameter_list|<
name|G
extends|extends
name|BalancerDatanode
operator|.
name|StorageGroup
parameter_list|,
name|C
extends|extends
name|BalancerDatanode
operator|.
name|StorageGroup
parameter_list|>
DECL|method|chooseCandidate (G g, Iterator<C> candidates, Matcher matcher)
name|C
name|chooseCandidate
parameter_list|(
name|G
name|g
parameter_list|,
name|Iterator
argument_list|<
name|C
argument_list|>
name|candidates
parameter_list|,
name|Matcher
name|matcher
parameter_list|)
block|{
if|if
condition|(
name|g
operator|.
name|hasSpaceForScheduling
argument_list|()
condition|)
block|{
for|for
control|(
init|;
name|candidates
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
specifier|final
name|C
name|c
init|=
name|candidates
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|c
operator|.
name|hasSpaceForScheduling
argument_list|()
condition|)
block|{
name|candidates
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|matcher
operator|.
name|match
argument_list|(
name|cluster
argument_list|,
name|g
operator|.
name|getDatanode
argument_list|()
argument_list|,
name|c
operator|.
name|getDatanode
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|c
return|;
block|}
block|}
block|}
return|return
literal|null
return|;
block|}
DECL|field|bytesMoved
specifier|private
specifier|final
name|AtomicLong
name|bytesMoved
init|=
operator|new
name|AtomicLong
argument_list|()
decl_stmt|;
comment|/* Start a thread to dispatch block moves for each source.     * The thread selects blocks to move& sends request to proxy source to    * initiate block move. The process is flow controlled. Block selection is    * blocked if there are too many un-confirmed block moves.    * Return the total number of bytes successfully moved in this iteration.    */
DECL|method|dispatchBlockMoves ()
specifier|private
name|long
name|dispatchBlockMoves
parameter_list|()
throws|throws
name|InterruptedException
block|{
name|long
name|bytesLastMoved
init|=
name|bytesMoved
operator|.
name|get
argument_list|()
decl_stmt|;
name|Future
argument_list|<
name|?
argument_list|>
index|[]
name|futures
init|=
operator|new
name|Future
argument_list|<
name|?
argument_list|>
index|[
name|sources
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Source
name|source
range|:
name|sources
control|)
block|{
name|futures
index|[
name|i
operator|++
index|]
operator|=
name|dispatcherExecutor
operator|.
name|submit
argument_list|(
name|source
operator|.
expr|new
name|BlockMoveDispatcher
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// wait for all dispatcher threads to finish
for|for
control|(
name|Future
argument_list|<
name|?
argument_list|>
name|future
range|:
name|futures
control|)
block|{
try|try
block|{
name|future
operator|.
name|get
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ExecutionException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Dispatcher thread failed"
argument_list|,
name|e
operator|.
name|getCause
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|// wait for all block moving to be done
name|waitForMoveCompletion
argument_list|()
expr_stmt|;
return|return
name|bytesMoved
operator|.
name|get
argument_list|()
operator|-
name|bytesLastMoved
return|;
block|}
comment|// The sleeping period before checking if block move is completed again
DECL|field|blockMoveWaitTime
specifier|static
specifier|private
name|long
name|blockMoveWaitTime
init|=
literal|30000L
decl_stmt|;
comment|/** set the sleeping period for block move completion check */
DECL|method|setBlockMoveWaitTime (long time)
specifier|static
name|void
name|setBlockMoveWaitTime
parameter_list|(
name|long
name|time
parameter_list|)
block|{
name|blockMoveWaitTime
operator|=
name|time
expr_stmt|;
block|}
comment|/* wait for all block move confirmations     * by checking each target's pendingMove queue     */
DECL|method|waitForMoveCompletion ()
specifier|private
name|void
name|waitForMoveCompletion
parameter_list|()
block|{
name|boolean
name|shouldWait
decl_stmt|;
do|do
block|{
name|shouldWait
operator|=
literal|false
expr_stmt|;
for|for
control|(
name|BalancerDatanode
operator|.
name|StorageGroup
name|target
range|:
name|targets
control|)
block|{
if|if
condition|(
operator|!
name|target
operator|.
name|getBalancerDatanode
argument_list|()
operator|.
name|isPendingQEmpty
argument_list|()
condition|)
block|{
name|shouldWait
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|shouldWait
condition|)
block|{
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|blockMoveWaitTime
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ignored
parameter_list|)
block|{         }
block|}
block|}
do|while
condition|(
name|shouldWait
condition|)
do|;
block|}
comment|/** This window makes sure to keep blocks that have been moved within 1.5 hour.    * Old window has blocks that are older;    * Current window has blocks that are more recent;    * Cleanup method triggers the check if blocks in the old window are    * more than 1.5 hour old. If yes, purge the old window and then    * move blocks in current window to old window.    */
DECL|class|MovedBlocks
specifier|private
specifier|static
class|class
name|MovedBlocks
block|{
DECL|field|lastCleanupTime
specifier|private
name|long
name|lastCleanupTime
init|=
name|Time
operator|.
name|now
argument_list|()
decl_stmt|;
DECL|field|CUR_WIN
specifier|final
specifier|private
specifier|static
name|int
name|CUR_WIN
init|=
literal|0
decl_stmt|;
DECL|field|OLD_WIN
specifier|final
specifier|private
specifier|static
name|int
name|OLD_WIN
init|=
literal|1
decl_stmt|;
DECL|field|NUM_WINS
specifier|final
specifier|private
specifier|static
name|int
name|NUM_WINS
init|=
literal|2
decl_stmt|;
DECL|field|movedBlocks
specifier|final
specifier|private
name|List
argument_list|<
name|HashMap
argument_list|<
name|Block
argument_list|,
name|BalancerBlock
argument_list|>
argument_list|>
name|movedBlocks
init|=
operator|new
name|ArrayList
argument_list|<
name|HashMap
argument_list|<
name|Block
argument_list|,
name|BalancerBlock
argument_list|>
argument_list|>
argument_list|(
name|NUM_WINS
argument_list|)
decl_stmt|;
comment|/* initialize the moved blocks collection */
DECL|method|MovedBlocks ()
specifier|private
name|MovedBlocks
parameter_list|()
block|{
name|movedBlocks
operator|.
name|add
argument_list|(
operator|new
name|HashMap
argument_list|<
name|Block
argument_list|,
name|BalancerBlock
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
name|movedBlocks
operator|.
name|add
argument_list|(
operator|new
name|HashMap
argument_list|<
name|Block
argument_list|,
name|BalancerBlock
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/* add a block thus marking a block to be moved */
DECL|method|add (BalancerBlock block)
specifier|synchronized
specifier|private
name|void
name|add
parameter_list|(
name|BalancerBlock
name|block
parameter_list|)
block|{
name|movedBlocks
operator|.
name|get
argument_list|(
name|CUR_WIN
argument_list|)
operator|.
name|put
argument_list|(
name|block
operator|.
name|getBlock
argument_list|()
argument_list|,
name|block
argument_list|)
expr_stmt|;
block|}
comment|/* check if a block is marked as moved */
DECL|method|contains (BalancerBlock block)
specifier|synchronized
specifier|private
name|boolean
name|contains
parameter_list|(
name|BalancerBlock
name|block
parameter_list|)
block|{
return|return
name|contains
argument_list|(
name|block
operator|.
name|getBlock
argument_list|()
argument_list|)
return|;
block|}
comment|/* check if a block is marked as moved */
DECL|method|contains (Block block)
specifier|synchronized
specifier|private
name|boolean
name|contains
parameter_list|(
name|Block
name|block
parameter_list|)
block|{
return|return
name|movedBlocks
operator|.
name|get
argument_list|(
name|CUR_WIN
argument_list|)
operator|.
name|containsKey
argument_list|(
name|block
argument_list|)
operator|||
name|movedBlocks
operator|.
name|get
argument_list|(
name|OLD_WIN
argument_list|)
operator|.
name|containsKey
argument_list|(
name|block
argument_list|)
return|;
block|}
comment|/* remove old blocks */
DECL|method|cleanup ()
specifier|synchronized
specifier|private
name|void
name|cleanup
parameter_list|()
block|{
name|long
name|curTime
init|=
name|Time
operator|.
name|now
argument_list|()
decl_stmt|;
comment|// check if old win is older than winWidth
if|if
condition|(
name|lastCleanupTime
operator|+
name|WIN_WIDTH
operator|<=
name|curTime
condition|)
block|{
comment|// purge the old window
name|movedBlocks
operator|.
name|set
argument_list|(
name|OLD_WIN
argument_list|,
name|movedBlocks
operator|.
name|get
argument_list|(
name|CUR_WIN
argument_list|)
argument_list|)
expr_stmt|;
name|movedBlocks
operator|.
name|set
argument_list|(
name|CUR_WIN
argument_list|,
operator|new
name|HashMap
argument_list|<
name|Block
argument_list|,
name|BalancerBlock
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
name|lastCleanupTime
operator|=
name|curTime
expr_stmt|;
block|}
block|}
block|}
comment|/* Decide if it is OK to move the given block from source to target    * A block is a good candidate if    * 1. the block is not in the process of being moved/has not been moved;    * 2. the block does not have a replica on the target;    * 3. doing the move does not reduce the number of racks that the block has    */
DECL|method|isGoodBlockCandidate (Source source, BalancerDatanode.StorageGroup target, BalancerBlock block)
specifier|private
name|boolean
name|isGoodBlockCandidate
parameter_list|(
name|Source
name|source
parameter_list|,
name|BalancerDatanode
operator|.
name|StorageGroup
name|target
parameter_list|,
name|BalancerBlock
name|block
parameter_list|)
block|{
if|if
condition|(
name|source
operator|.
name|storageType
operator|!=
name|target
operator|.
name|storageType
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// check if the block is moved or not
if|if
condition|(
name|movedBlocks
operator|.
name|contains
argument_list|(
name|block
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|block
operator|.
name|isLocatedOn
argument_list|(
name|target
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|cluster
operator|.
name|isNodeGroupAware
argument_list|()
operator|&&
name|isOnSameNodeGroupWithReplicas
argument_list|(
name|target
argument_list|,
name|block
argument_list|,
name|source
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|boolean
name|goodBlock
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|cluster
operator|.
name|isOnSameRack
argument_list|(
name|source
operator|.
name|getDatanode
argument_list|()
argument_list|,
name|target
operator|.
name|getDatanode
argument_list|()
argument_list|)
condition|)
block|{
comment|// good if source and target are on the same rack
name|goodBlock
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|boolean
name|notOnSameRack
init|=
literal|true
decl_stmt|;
synchronized|synchronized
init|(
name|block
init|)
block|{
for|for
control|(
name|BalancerDatanode
operator|.
name|StorageGroup
name|loc
range|:
name|block
operator|.
name|locations
control|)
block|{
if|if
condition|(
name|cluster
operator|.
name|isOnSameRack
argument_list|(
name|loc
operator|.
name|getDatanode
argument_list|()
argument_list|,
name|target
operator|.
name|getDatanode
argument_list|()
argument_list|)
condition|)
block|{
name|notOnSameRack
operator|=
literal|false
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|notOnSameRack
condition|)
block|{
comment|// good if target is target is not on the same rack as any replica
name|goodBlock
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
comment|// good if source is on the same rack as on of the replicas
for|for
control|(
name|BalancerDatanode
operator|.
name|StorageGroup
name|loc
range|:
name|block
operator|.
name|locations
control|)
block|{
if|if
condition|(
name|loc
operator|!=
name|source
operator|&&
name|cluster
operator|.
name|isOnSameRack
argument_list|(
name|loc
operator|.
name|getDatanode
argument_list|()
argument_list|,
name|source
operator|.
name|getDatanode
argument_list|()
argument_list|)
condition|)
block|{
name|goodBlock
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
return|return
name|goodBlock
return|;
block|}
comment|/**    * Check if there are any replica (other than source) on the same node group    * with target. If true, then target is not a good candidate for placing     * specific block replica as we don't want 2 replicas under the same nodegroup     * after balance.    * @param target targetDataNode    * @param block dataBlock    * @param source sourceDataNode    * @return true if there are any replica (other than source) on the same node    * group with target    */
DECL|method|isOnSameNodeGroupWithReplicas (BalancerDatanode.StorageGroup target, BalancerBlock block, Source source)
specifier|private
name|boolean
name|isOnSameNodeGroupWithReplicas
parameter_list|(
name|BalancerDatanode
operator|.
name|StorageGroup
name|target
parameter_list|,
name|BalancerBlock
name|block
parameter_list|,
name|Source
name|source
parameter_list|)
block|{
specifier|final
name|DatanodeInfo
name|targetDn
init|=
name|target
operator|.
name|getDatanode
argument_list|()
decl_stmt|;
for|for
control|(
name|BalancerDatanode
operator|.
name|StorageGroup
name|loc
range|:
name|block
operator|.
name|locations
control|)
block|{
if|if
condition|(
name|loc
operator|!=
name|source
operator|&&
name|cluster
operator|.
name|isOnSameNodeGroup
argument_list|(
name|loc
operator|.
name|getDatanode
argument_list|()
argument_list|,
name|targetDn
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/* reset all fields in a balancer preparing for the next iteration */
DECL|method|resetData (Configuration conf)
specifier|private
name|void
name|resetData
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
name|this
operator|.
name|cluster
operator|=
name|NetworkTopology
operator|.
name|getInstance
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|overUtilized
operator|.
name|clear
argument_list|()
expr_stmt|;
name|this
operator|.
name|aboveAvgUtilized
operator|.
name|clear
argument_list|()
expr_stmt|;
name|this
operator|.
name|belowAvgUtilized
operator|.
name|clear
argument_list|()
expr_stmt|;
name|this
operator|.
name|underUtilized
operator|.
name|clear
argument_list|()
expr_stmt|;
name|this
operator|.
name|storageGroupMap
operator|.
name|clear
argument_list|()
expr_stmt|;
name|this
operator|.
name|sources
operator|.
name|clear
argument_list|()
expr_stmt|;
name|this
operator|.
name|targets
operator|.
name|clear
argument_list|()
expr_stmt|;
name|this
operator|.
name|policy
operator|.
name|reset
argument_list|()
expr_stmt|;
name|cleanGlobalBlockList
argument_list|()
expr_stmt|;
name|this
operator|.
name|movedBlocks
operator|.
name|cleanup
argument_list|()
expr_stmt|;
block|}
comment|/* Remove all blocks from the global block list except for the ones in the    * moved list.    */
DECL|method|cleanGlobalBlockList ()
specifier|private
name|void
name|cleanGlobalBlockList
parameter_list|()
block|{
for|for
control|(
name|Iterator
argument_list|<
name|Block
argument_list|>
name|globalBlockListIterator
init|=
name|globalBlockList
operator|.
name|keySet
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|globalBlockListIterator
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Block
name|block
init|=
name|globalBlockListIterator
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|movedBlocks
operator|.
name|contains
argument_list|(
name|block
argument_list|)
condition|)
block|{
name|globalBlockListIterator
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|// Exit status
DECL|enum|ReturnStatus
enum|enum
name|ReturnStatus
block|{
comment|// These int values will map directly to the balancer process's exit code.
DECL|enumConstant|SUCCESS
name|SUCCESS
argument_list|(
literal|0
argument_list|)
block|,
DECL|enumConstant|IN_PROGRESS
name|IN_PROGRESS
argument_list|(
literal|1
argument_list|)
block|,
DECL|enumConstant|ALREADY_RUNNING
name|ALREADY_RUNNING
argument_list|(
operator|-
literal|1
argument_list|)
block|,
DECL|enumConstant|NO_MOVE_BLOCK
name|NO_MOVE_BLOCK
argument_list|(
operator|-
literal|2
argument_list|)
block|,
DECL|enumConstant|NO_MOVE_PROGRESS
name|NO_MOVE_PROGRESS
argument_list|(
operator|-
literal|3
argument_list|)
block|,
DECL|enumConstant|IO_EXCEPTION
name|IO_EXCEPTION
argument_list|(
operator|-
literal|4
argument_list|)
block|,
DECL|enumConstant|ILLEGAL_ARGS
name|ILLEGAL_ARGS
argument_list|(
operator|-
literal|5
argument_list|)
block|,
DECL|enumConstant|INTERRUPTED
name|INTERRUPTED
argument_list|(
operator|-
literal|6
argument_list|)
block|;
DECL|field|code
specifier|final
name|int
name|code
decl_stmt|;
DECL|method|ReturnStatus (int code)
name|ReturnStatus
parameter_list|(
name|int
name|code
parameter_list|)
block|{
name|this
operator|.
name|code
operator|=
name|code
expr_stmt|;
block|}
block|}
comment|/** Run an iteration for all datanodes. */
DECL|method|run (int iteration, Formatter formatter, Configuration conf)
specifier|private
name|ReturnStatus
name|run
parameter_list|(
name|int
name|iteration
parameter_list|,
name|Formatter
name|formatter
parameter_list|,
name|Configuration
name|conf
parameter_list|)
block|{
try|try
block|{
comment|/* get all live datanodes of a cluster and their disk usage        * decide the number of bytes need to be moved        */
specifier|final
name|long
name|bytesLeftToMove
init|=
name|init
argument_list|(
name|nnc
operator|.
name|client
operator|.
name|getDatanodeStorageReport
argument_list|(
name|DatanodeReportType
operator|.
name|LIVE
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|bytesLeftToMove
operator|==
literal|0
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"The cluster is balanced. Exiting..."
argument_list|)
expr_stmt|;
return|return
name|ReturnStatus
operator|.
name|SUCCESS
return|;
block|}
else|else
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Need to move "
operator|+
name|StringUtils
operator|.
name|byteDesc
argument_list|(
name|bytesLeftToMove
argument_list|)
operator|+
literal|" to make the cluster balanced."
argument_list|)
expr_stmt|;
block|}
comment|/* Decide all the nodes that will participate in the block move and        * the number of bytes that need to be moved from one node to another        * in this iteration. Maximum bytes to be moved per node is        * Min(1 Band worth of bytes,  MAX_SIZE_TO_MOVE).        */
specifier|final
name|long
name|bytesToMove
init|=
name|chooseStorageGroups
argument_list|()
decl_stmt|;
if|if
condition|(
name|bytesToMove
operator|==
literal|0
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"No block can be moved. Exiting..."
argument_list|)
expr_stmt|;
return|return
name|ReturnStatus
operator|.
name|NO_MOVE_BLOCK
return|;
block|}
else|else
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Will move "
operator|+
name|StringUtils
operator|.
name|byteDesc
argument_list|(
name|bytesToMove
argument_list|)
operator|+
literal|" in this iteration"
argument_list|)
expr_stmt|;
block|}
name|formatter
operator|.
name|format
argument_list|(
literal|"%-24s %10d  %19s  %18s  %17s%n"
argument_list|,
name|DateFormat
operator|.
name|getDateTimeInstance
argument_list|()
operator|.
name|format
argument_list|(
operator|new
name|Date
argument_list|()
argument_list|)
argument_list|,
name|iteration
argument_list|,
name|StringUtils
operator|.
name|byteDesc
argument_list|(
name|bytesMoved
operator|.
name|get
argument_list|()
argument_list|)
argument_list|,
name|StringUtils
operator|.
name|byteDesc
argument_list|(
name|bytesLeftToMove
argument_list|)
argument_list|,
name|StringUtils
operator|.
name|byteDesc
argument_list|(
name|bytesToMove
argument_list|)
argument_list|)
expr_stmt|;
comment|/* For each pair of<source, target>, start a thread that repeatedly         * decide a block to be moved and its proxy source,         * then initiates the move until all bytes are moved or no more block        * available to move.        * Exit no byte has been moved for 5 consecutive iterations.        */
if|if
condition|(
operator|!
name|this
operator|.
name|nnc
operator|.
name|shouldContinue
argument_list|(
name|dispatchBlockMoves
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|ReturnStatus
operator|.
name|NO_MOVE_PROGRESS
return|;
block|}
return|return
name|ReturnStatus
operator|.
name|IN_PROGRESS
return|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|e
operator|+
literal|".  Exiting ..."
argument_list|)
expr_stmt|;
return|return
name|ReturnStatus
operator|.
name|ILLEGAL_ARGS
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|e
operator|+
literal|".  Exiting ..."
argument_list|)
expr_stmt|;
return|return
name|ReturnStatus
operator|.
name|IO_EXCEPTION
return|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|e
operator|+
literal|".  Exiting ..."
argument_list|)
expr_stmt|;
return|return
name|ReturnStatus
operator|.
name|INTERRUPTED
return|;
block|}
finally|finally
block|{
comment|// shutdown thread pools
name|dispatcherExecutor
operator|.
name|shutdownNow
argument_list|()
expr_stmt|;
name|moverExecutor
operator|.
name|shutdownNow
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Balance all namenodes.    * For each iteration,    * for each namenode,    * execute a {@link Balancer} to work through all datanodes once.      */
DECL|method|run (Collection<URI> namenodes, final Parameters p, Configuration conf)
specifier|static
name|int
name|run
parameter_list|(
name|Collection
argument_list|<
name|URI
argument_list|>
name|namenodes
parameter_list|,
specifier|final
name|Parameters
name|p
parameter_list|,
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
specifier|final
name|long
name|sleeptime
init|=
literal|2000
operator|*
name|conf
operator|.
name|getLong
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_HEARTBEAT_INTERVAL_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_HEARTBEAT_INTERVAL_DEFAULT
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"namenodes = "
operator|+
name|namenodes
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"p         = "
operator|+
name|p
argument_list|)
expr_stmt|;
specifier|final
name|Formatter
name|formatter
init|=
operator|new
name|Formatter
argument_list|(
name|System
operator|.
name|out
argument_list|)
decl_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Time Stamp               Iteration#  Bytes Already Moved  Bytes Left To Move  Bytes Being Moved"
argument_list|)
expr_stmt|;
specifier|final
name|List
argument_list|<
name|NameNodeConnector
argument_list|>
name|connectors
init|=
operator|new
name|ArrayList
argument_list|<
name|NameNodeConnector
argument_list|>
argument_list|(
name|namenodes
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
try|try
block|{
for|for
control|(
name|URI
name|uri
range|:
name|namenodes
control|)
block|{
name|connectors
operator|.
name|add
argument_list|(
operator|new
name|NameNodeConnector
argument_list|(
name|uri
argument_list|,
name|conf
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|boolean
name|done
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|iteration
init|=
literal|0
init|;
operator|!
name|done
condition|;
name|iteration
operator|++
control|)
block|{
name|done
operator|=
literal|true
expr_stmt|;
name|Collections
operator|.
name|shuffle
argument_list|(
name|connectors
argument_list|)
expr_stmt|;
for|for
control|(
name|NameNodeConnector
name|nnc
range|:
name|connectors
control|)
block|{
specifier|final
name|Balancer
name|b
init|=
operator|new
name|Balancer
argument_list|(
name|nnc
argument_list|,
name|p
argument_list|,
name|conf
argument_list|)
decl_stmt|;
specifier|final
name|ReturnStatus
name|r
init|=
name|b
operator|.
name|run
argument_list|(
name|iteration
argument_list|,
name|formatter
argument_list|,
name|conf
argument_list|)
decl_stmt|;
comment|// clean all lists
name|b
operator|.
name|resetData
argument_list|(
name|conf
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|ReturnStatus
operator|.
name|IN_PROGRESS
condition|)
block|{
name|done
operator|=
literal|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|r
operator|!=
name|ReturnStatus
operator|.
name|SUCCESS
condition|)
block|{
comment|//must be an error statue, return.
return|return
name|r
operator|.
name|code
return|;
block|}
block|}
if|if
condition|(
operator|!
name|done
condition|)
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|sleeptime
argument_list|)
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
for|for
control|(
name|NameNodeConnector
name|nnc
range|:
name|connectors
control|)
block|{
name|nnc
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|ReturnStatus
operator|.
name|SUCCESS
operator|.
name|code
return|;
block|}
comment|/* Given elaspedTime in ms, return a printable string */
DECL|method|time2Str (long elapsedTime)
specifier|private
specifier|static
name|String
name|time2Str
parameter_list|(
name|long
name|elapsedTime
parameter_list|)
block|{
name|String
name|unit
decl_stmt|;
name|double
name|time
init|=
name|elapsedTime
decl_stmt|;
if|if
condition|(
name|elapsedTime
operator|<
literal|1000
condition|)
block|{
name|unit
operator|=
literal|"milliseconds"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|elapsedTime
operator|<
literal|60
operator|*
literal|1000
condition|)
block|{
name|unit
operator|=
literal|"seconds"
expr_stmt|;
name|time
operator|=
name|time
operator|/
literal|1000
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|elapsedTime
operator|<
literal|3600
operator|*
literal|1000
condition|)
block|{
name|unit
operator|=
literal|"minutes"
expr_stmt|;
name|time
operator|=
name|time
operator|/
operator|(
literal|60
operator|*
literal|1000
operator|)
expr_stmt|;
block|}
else|else
block|{
name|unit
operator|=
literal|"hours"
expr_stmt|;
name|time
operator|=
name|time
operator|/
operator|(
literal|3600
operator|*
literal|1000
operator|)
expr_stmt|;
block|}
return|return
name|time
operator|+
literal|" "
operator|+
name|unit
return|;
block|}
DECL|class|Parameters
specifier|static
class|class
name|Parameters
block|{
DECL|field|DEFAULT
specifier|static
specifier|final
name|Parameters
name|DEFAULT
init|=
operator|new
name|Parameters
argument_list|(
name|BalancingPolicy
operator|.
name|Node
operator|.
name|INSTANCE
argument_list|,
literal|10.0
argument_list|,
name|Collections
operator|.
expr|<
name|String
operator|>
name|emptySet
argument_list|()
argument_list|,
name|Collections
operator|.
expr|<
name|String
operator|>
name|emptySet
argument_list|()
argument_list|)
decl_stmt|;
DECL|field|policy
specifier|final
name|BalancingPolicy
name|policy
decl_stmt|;
DECL|field|threshold
specifier|final
name|double
name|threshold
decl_stmt|;
comment|// exclude the nodes in this set from balancing operations
DECL|field|nodesToBeExcluded
name|Set
argument_list|<
name|String
argument_list|>
name|nodesToBeExcluded
decl_stmt|;
comment|//include only these nodes in balancing operations
DECL|field|nodesToBeIncluded
name|Set
argument_list|<
name|String
argument_list|>
name|nodesToBeIncluded
decl_stmt|;
DECL|method|Parameters (BalancingPolicy policy, double threshold, Set<String> nodesToBeExcluded, Set<String> nodesToBeIncluded)
name|Parameters
parameter_list|(
name|BalancingPolicy
name|policy
parameter_list|,
name|double
name|threshold
parameter_list|,
name|Set
argument_list|<
name|String
argument_list|>
name|nodesToBeExcluded
parameter_list|,
name|Set
argument_list|<
name|String
argument_list|>
name|nodesToBeIncluded
parameter_list|)
block|{
name|this
operator|.
name|policy
operator|=
name|policy
expr_stmt|;
name|this
operator|.
name|threshold
operator|=
name|threshold
expr_stmt|;
name|this
operator|.
name|nodesToBeExcluded
operator|=
name|nodesToBeExcluded
expr_stmt|;
name|this
operator|.
name|nodesToBeIncluded
operator|=
name|nodesToBeIncluded
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|Balancer
operator|.
name|class
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|"."
operator|+
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|"["
operator|+
name|policy
operator|+
literal|", threshold="
operator|+
name|threshold
operator|+
literal|", number of nodes to be excluded = "
operator|+
name|nodesToBeExcluded
operator|.
name|size
argument_list|()
operator|+
literal|", number of nodes to be included = "
operator|+
name|nodesToBeIncluded
operator|.
name|size
argument_list|()
operator|+
literal|"]"
return|;
block|}
block|}
DECL|class|Util
specifier|static
class|class
name|Util
block|{
comment|/**      * @param datanode      * @return returns true if data node is part of the excludedNodes.      */
DECL|method|shouldBeExcluded (Set<String> excludedNodes, DatanodeInfo datanode)
specifier|static
name|boolean
name|shouldBeExcluded
parameter_list|(
name|Set
argument_list|<
name|String
argument_list|>
name|excludedNodes
parameter_list|,
name|DatanodeInfo
name|datanode
parameter_list|)
block|{
return|return
name|isIn
argument_list|(
name|excludedNodes
argument_list|,
name|datanode
argument_list|)
return|;
block|}
comment|/**      * @param datanode      * @return returns true if includedNodes is empty or data node is part of the includedNodes.      */
DECL|method|shouldBeIncluded (Set<String> includedNodes, DatanodeInfo datanode)
specifier|static
name|boolean
name|shouldBeIncluded
parameter_list|(
name|Set
argument_list|<
name|String
argument_list|>
name|includedNodes
parameter_list|,
name|DatanodeInfo
name|datanode
parameter_list|)
block|{
return|return
operator|(
name|includedNodes
operator|.
name|isEmpty
argument_list|()
operator|||
name|isIn
argument_list|(
name|includedNodes
argument_list|,
name|datanode
argument_list|)
operator|)
return|;
block|}
comment|/**      * Match is checked using host name , ip address with and without port number.      * @param datanodeSet      * @param datanode      * @return true if the datanode's transfer address matches the set of nodes.      */
DECL|method|isIn (Set<String> datanodeSet, DatanodeInfo datanode)
specifier|private
specifier|static
name|boolean
name|isIn
parameter_list|(
name|Set
argument_list|<
name|String
argument_list|>
name|datanodeSet
parameter_list|,
name|DatanodeInfo
name|datanode
parameter_list|)
block|{
return|return
name|isIn
argument_list|(
name|datanodeSet
argument_list|,
name|datanode
operator|.
name|getPeerHostName
argument_list|()
argument_list|,
name|datanode
operator|.
name|getXferPort
argument_list|()
argument_list|)
operator|||
name|isIn
argument_list|(
name|datanodeSet
argument_list|,
name|datanode
operator|.
name|getIpAddr
argument_list|()
argument_list|,
name|datanode
operator|.
name|getXferPort
argument_list|()
argument_list|)
operator|||
name|isIn
argument_list|(
name|datanodeSet
argument_list|,
name|datanode
operator|.
name|getHostName
argument_list|()
argument_list|,
name|datanode
operator|.
name|getXferPort
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * returns true if nodes contains host or host:port      * @param nodes      * @param host      * @param port      * @return      */
DECL|method|isIn (Set<String> nodes, String host, int port)
specifier|private
specifier|static
name|boolean
name|isIn
parameter_list|(
name|Set
argument_list|<
name|String
argument_list|>
name|nodes
parameter_list|,
name|String
name|host
parameter_list|,
name|int
name|port
parameter_list|)
block|{
if|if
condition|(
name|host
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
operator|(
name|nodes
operator|.
name|contains
argument_list|(
name|host
argument_list|)
operator|||
name|nodes
operator|.
name|contains
argument_list|(
name|host
operator|+
literal|":"
operator|+
name|port
argument_list|)
operator|)
return|;
block|}
comment|/**      * parse a comma separated string to obtain set of host names      * @param string      * @return      */
DECL|method|parseHostList (String string)
specifier|static
name|Set
argument_list|<
name|String
argument_list|>
name|parseHostList
parameter_list|(
name|String
name|string
parameter_list|)
block|{
name|String
index|[]
name|addrs
init|=
name|StringUtils
operator|.
name|getTrimmedStrings
argument_list|(
name|string
argument_list|)
decl_stmt|;
return|return
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|addrs
argument_list|)
argument_list|)
return|;
block|}
comment|/**      * read set of host names from a file      * @param fileName      * @return      */
DECL|method|getHostListFromFile (String fileName)
specifier|static
name|Set
argument_list|<
name|String
argument_list|>
name|getHostListFromFile
parameter_list|(
name|String
name|fileName
parameter_list|)
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|nodes
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
try|try
block|{
name|HostsFileReader
operator|.
name|readFileToSet
argument_list|(
literal|"nodes"
argument_list|,
name|fileName
argument_list|,
name|nodes
argument_list|)
expr_stmt|;
return|return
name|StringUtils
operator|.
name|getTrimmedStrings
argument_list|(
name|nodes
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Unable to open file: "
operator|+
name|fileName
argument_list|)
throw|;
block|}
block|}
block|}
DECL|class|Cli
specifier|static
class|class
name|Cli
extends|extends
name|Configured
implements|implements
name|Tool
block|{
comment|/**      * Parse arguments and then run Balancer.      *       * @param args command specific arguments.      * @return exit code. 0 indicates success, non-zero indicates failure.      */
annotation|@
name|Override
DECL|method|run (String[] args)
specifier|public
name|int
name|run
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
block|{
specifier|final
name|long
name|startTime
init|=
name|Time
operator|.
name|now
argument_list|()
decl_stmt|;
specifier|final
name|Configuration
name|conf
init|=
name|getConf
argument_list|()
decl_stmt|;
name|WIN_WIDTH
operator|=
name|conf
operator|.
name|getLong
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_BALANCER_MOVEDWINWIDTH_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_BALANCER_MOVEDWINWIDTH_DEFAULT
argument_list|)
expr_stmt|;
try|try
block|{
name|checkReplicationPolicyCompatibility
argument_list|(
name|conf
argument_list|)
expr_stmt|;
specifier|final
name|Collection
argument_list|<
name|URI
argument_list|>
name|namenodes
init|=
name|DFSUtil
operator|.
name|getNsServiceRpcUris
argument_list|(
name|conf
argument_list|)
decl_stmt|;
return|return
name|Balancer
operator|.
name|run
argument_list|(
name|namenodes
argument_list|,
name|parse
argument_list|(
name|args
argument_list|)
argument_list|,
name|conf
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|e
operator|+
literal|".  Exiting ..."
argument_list|)
expr_stmt|;
return|return
name|ReturnStatus
operator|.
name|IO_EXCEPTION
operator|.
name|code
return|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|e
operator|+
literal|".  Exiting ..."
argument_list|)
expr_stmt|;
return|return
name|ReturnStatus
operator|.
name|INTERRUPTED
operator|.
name|code
return|;
block|}
finally|finally
block|{
name|System
operator|.
name|out
operator|.
name|format
argument_list|(
literal|"%-24s "
argument_list|,
name|DateFormat
operator|.
name|getDateTimeInstance
argument_list|()
operator|.
name|format
argument_list|(
operator|new
name|Date
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Balancing took "
operator|+
name|time2Str
argument_list|(
name|Time
operator|.
name|now
argument_list|()
operator|-
name|startTime
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** parse command line arguments */
DECL|method|parse (String[] args)
specifier|static
name|Parameters
name|parse
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
block|{
name|BalancingPolicy
name|policy
init|=
name|Parameters
operator|.
name|DEFAULT
operator|.
name|policy
decl_stmt|;
name|double
name|threshold
init|=
name|Parameters
operator|.
name|DEFAULT
operator|.
name|threshold
decl_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|nodesTobeExcluded
init|=
name|Parameters
operator|.
name|DEFAULT
operator|.
name|nodesToBeExcluded
decl_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|nodesTobeIncluded
init|=
name|Parameters
operator|.
name|DEFAULT
operator|.
name|nodesToBeIncluded
decl_stmt|;
if|if
condition|(
name|args
operator|!=
literal|null
condition|)
block|{
try|try
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|args
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|checkArgument
argument_list|(
name|args
operator|.
name|length
operator|>=
literal|2
argument_list|,
literal|"args = "
operator|+
name|Arrays
operator|.
name|toString
argument_list|(
name|args
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
literal|"-threshold"
operator|.
name|equalsIgnoreCase
argument_list|(
name|args
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|i
operator|++
expr_stmt|;
try|try
block|{
name|threshold
operator|=
name|Double
operator|.
name|parseDouble
argument_list|(
name|args
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|threshold
argument_list|<
literal|1
operator|||
name|threshold
argument_list|>
literal|100
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Number out of range: threshold = "
operator|+
name|threshold
argument_list|)
throw|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Using a threshold of "
operator|+
name|threshold
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Expecting a number in the range of [1.0, 100.0]: "
operator|+
name|args
index|[
name|i
index|]
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
elseif|else
if|if
condition|(
literal|"-policy"
operator|.
name|equalsIgnoreCase
argument_list|(
name|args
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|i
operator|++
expr_stmt|;
try|try
block|{
name|policy
operator|=
name|BalancingPolicy
operator|.
name|parse
argument_list|(
name|args
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Illegal policy name: "
operator|+
name|args
index|[
name|i
index|]
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
elseif|else
if|if
condition|(
literal|"-exclude"
operator|.
name|equalsIgnoreCase
argument_list|(
name|args
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|i
operator|++
expr_stmt|;
if|if
condition|(
literal|"-f"
operator|.
name|equalsIgnoreCase
argument_list|(
name|args
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|nodesTobeExcluded
operator|=
name|Util
operator|.
name|getHostListFromFile
argument_list|(
name|args
index|[
operator|++
name|i
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nodesTobeExcluded
operator|=
name|Util
operator|.
name|parseHostList
argument_list|(
name|args
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
literal|"-include"
operator|.
name|equalsIgnoreCase
argument_list|(
name|args
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|i
operator|++
expr_stmt|;
if|if
condition|(
literal|"-f"
operator|.
name|equalsIgnoreCase
argument_list|(
name|args
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|nodesTobeIncluded
operator|=
name|Util
operator|.
name|getHostListFromFile
argument_list|(
name|args
index|[
operator|++
name|i
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nodesTobeIncluded
operator|=
name|Util
operator|.
name|parseHostList
argument_list|(
name|args
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"args = "
operator|+
name|Arrays
operator|.
name|toString
argument_list|(
name|args
argument_list|)
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
operator|!
name|nodesTobeExcluded
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|nodesTobeIncluded
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"-exclude and -include options cannot be specified together."
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"-exclude and -include options cannot be specified together."
argument_list|)
throw|;
block|}
block|}
catch|catch
parameter_list|(
name|RuntimeException
name|e
parameter_list|)
block|{
name|printUsage
argument_list|(
name|System
operator|.
name|err
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
return|return
operator|new
name|Parameters
argument_list|(
name|policy
argument_list|,
name|threshold
argument_list|,
name|nodesTobeExcluded
argument_list|,
name|nodesTobeIncluded
argument_list|)
return|;
block|}
DECL|method|printUsage (PrintStream out)
specifier|private
specifier|static
name|void
name|printUsage
parameter_list|(
name|PrintStream
name|out
parameter_list|)
block|{
name|out
operator|.
name|println
argument_list|(
name|USAGE
operator|+
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Run a balancer    * @param args Command line arguments    */
DECL|method|main (String[] args)
specifier|public
specifier|static
name|void
name|main
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
block|{
if|if
condition|(
name|DFSUtil
operator|.
name|parseHelpArgument
argument_list|(
name|args
argument_list|,
name|USAGE
argument_list|,
name|System
operator|.
name|out
argument_list|,
literal|true
argument_list|)
condition|)
block|{
name|System
operator|.
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|System
operator|.
name|exit
argument_list|(
name|ToolRunner
operator|.
name|run
argument_list|(
operator|new
name|HdfsConfiguration
argument_list|()
argument_list|,
operator|new
name|Cli
argument_list|()
argument_list|,
name|args
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Exiting balancer due an exception"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|System
operator|.
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

