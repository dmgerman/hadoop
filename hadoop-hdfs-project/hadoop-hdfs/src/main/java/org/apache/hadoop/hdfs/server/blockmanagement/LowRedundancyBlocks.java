begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdfs.server.blockmanagement
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|blockmanagement
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|LongAdder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|NameNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|util
operator|.
name|LightWeightLinkedSet
import|;
end_import

begin_comment
comment|/**  * Keep prioritized queues of low redundant blocks.  * Blocks have redundancy priority, with priority  * {@link #QUEUE_HIGHEST_PRIORITY} indicating the highest priority.  *</p>  * Having a prioritised queue allows the {@link BlockManager} to select  * which blocks to replicate first -it tries to give priority to data  * that is most at risk or considered most valuable.  *  *<p/>  * The policy for choosing which priority to give added blocks  * is implemented in {@link #getPriority(BlockInfo, int, int, int, int)}.  *</p>  *<p>The queue order is as follows:</p>  *<ol>  *<li>{@link #QUEUE_HIGHEST_PRIORITY}: the blocks that should be redundant  *   first. That is blocks with only one copy, or blocks with zero live  *   copies but a copy in a node being decommissioned. These blocks  *   are at risk of loss if the disk or server on which they  *   remain fails.</li>  *<li>{@link #QUEUE_VERY_LOW_REDUNDANCY}: blocks that are very  *   under-replicated compared to their expected values. Currently  *   that means the ratio of the ratio of actual:expected means that  *   there is<i>less than</i> 1:3.</li>. These blocks may not be at risk,  *   but they are clearly considered "important".  *<li>{@link #QUEUE_LOW_REDUNDANCY}: blocks that are also under  *   replicated, and the ratio of actual:expected is good enough that  *   they do not need to go into the {@link #QUEUE_VERY_LOW_REDUNDANCY}  *   queue.</li>  *<li>{@link #QUEUE_REPLICAS_BADLY_DISTRIBUTED}: there are as least as  *   many copies of a block as required, but the blocks are not adequately  *   distributed. Loss of a rack/switch could take all copies off-line.</li>  *<li>{@link #QUEUE_WITH_CORRUPT_BLOCKS} This is for blocks that are corrupt  *   and for which there are no-non-corrupt copies (currently) available.  *   The policy here is to keep those corrupt blocks replicated, but give  *   blocks that are not corrupt higher priority.</li>  *</ol>  */
end_comment

begin_class
DECL|class|LowRedundancyBlocks
class|class
name|LowRedundancyBlocks
implements|implements
name|Iterable
argument_list|<
name|BlockInfo
argument_list|>
block|{
comment|/** The total number of queues : {@value} */
DECL|field|LEVEL
specifier|static
specifier|final
name|int
name|LEVEL
init|=
literal|5
decl_stmt|;
comment|/** The queue with the highest priority: {@value} */
DECL|field|QUEUE_HIGHEST_PRIORITY
specifier|static
specifier|final
name|int
name|QUEUE_HIGHEST_PRIORITY
init|=
literal|0
decl_stmt|;
comment|/** The queue for blocks that are way below their expected value : {@value} */
DECL|field|QUEUE_VERY_LOW_REDUNDANCY
specifier|static
specifier|final
name|int
name|QUEUE_VERY_LOW_REDUNDANCY
init|=
literal|1
decl_stmt|;
comment|/**    * The queue for "normally" without sufficient redundancy blocks : {@value}.    */
DECL|field|QUEUE_LOW_REDUNDANCY
specifier|static
specifier|final
name|int
name|QUEUE_LOW_REDUNDANCY
init|=
literal|2
decl_stmt|;
comment|/** The queue for blocks that have the right number of replicas,    * but which the block manager felt were badly distributed: {@value}    */
DECL|field|QUEUE_REPLICAS_BADLY_DISTRIBUTED
specifier|static
specifier|final
name|int
name|QUEUE_REPLICAS_BADLY_DISTRIBUTED
init|=
literal|3
decl_stmt|;
comment|/** The queue for corrupt blocks: {@value} */
DECL|field|QUEUE_WITH_CORRUPT_BLOCKS
specifier|static
specifier|final
name|int
name|QUEUE_WITH_CORRUPT_BLOCKS
init|=
literal|4
decl_stmt|;
comment|/** the queues themselves */
DECL|field|priorityQueues
specifier|private
specifier|final
name|List
argument_list|<
name|LightWeightLinkedSet
argument_list|<
name|BlockInfo
argument_list|>
argument_list|>
name|priorityQueues
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|LEVEL
argument_list|)
decl_stmt|;
comment|/** The number of corrupt blocks with replication factor 1 */
DECL|field|lowRedundancyBlocks
specifier|private
specifier|final
name|LongAdder
name|lowRedundancyBlocks
init|=
operator|new
name|LongAdder
argument_list|()
decl_stmt|;
DECL|field|corruptBlocks
specifier|private
specifier|final
name|LongAdder
name|corruptBlocks
init|=
operator|new
name|LongAdder
argument_list|()
decl_stmt|;
DECL|field|corruptReplicationOneBlocks
specifier|private
specifier|final
name|LongAdder
name|corruptReplicationOneBlocks
init|=
operator|new
name|LongAdder
argument_list|()
decl_stmt|;
DECL|field|lowRedundancyECBlockGroups
specifier|private
specifier|final
name|LongAdder
name|lowRedundancyECBlockGroups
init|=
operator|new
name|LongAdder
argument_list|()
decl_stmt|;
DECL|field|corruptECBlockGroups
specifier|private
specifier|final
name|LongAdder
name|corruptECBlockGroups
init|=
operator|new
name|LongAdder
argument_list|()
decl_stmt|;
comment|/** Create an object. */
DECL|method|LowRedundancyBlocks ()
name|LowRedundancyBlocks
parameter_list|()
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|LEVEL
condition|;
name|i
operator|++
control|)
block|{
name|priorityQueues
operator|.
name|add
argument_list|(
operator|new
name|LightWeightLinkedSet
argument_list|<
name|BlockInfo
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Empty the queues.    */
DECL|method|clear ()
specifier|synchronized
name|void
name|clear
parameter_list|()
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|LEVEL
condition|;
name|i
operator|++
control|)
block|{
name|priorityQueues
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
name|lowRedundancyBlocks
operator|.
name|reset
argument_list|()
expr_stmt|;
name|corruptBlocks
operator|.
name|reset
argument_list|()
expr_stmt|;
name|corruptReplicationOneBlocks
operator|.
name|reset
argument_list|()
expr_stmt|;
name|lowRedundancyECBlockGroups
operator|.
name|reset
argument_list|()
expr_stmt|;
name|corruptECBlockGroups
operator|.
name|reset
argument_list|()
expr_stmt|;
block|}
comment|/** Return the total number of insufficient redundancy blocks. */
DECL|method|size ()
specifier|synchronized
name|int
name|size
parameter_list|()
block|{
name|int
name|size
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|LEVEL
condition|;
name|i
operator|++
control|)
block|{
name|size
operator|+=
name|priorityQueues
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
return|return
name|size
return|;
block|}
comment|/**    * Return the number of insufficiently redundant blocks excluding corrupt    * blocks.    */
DECL|method|getLowRedundancyBlockCount ()
specifier|synchronized
name|int
name|getLowRedundancyBlockCount
parameter_list|()
block|{
name|int
name|size
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|LEVEL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|!=
name|QUEUE_WITH_CORRUPT_BLOCKS
condition|)
block|{
name|size
operator|+=
name|priorityQueues
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|size
return|;
block|}
comment|/** Return the number of corrupt blocks */
DECL|method|getCorruptBlockSize ()
specifier|synchronized
name|int
name|getCorruptBlockSize
parameter_list|()
block|{
return|return
name|priorityQueues
operator|.
name|get
argument_list|(
name|QUEUE_WITH_CORRUPT_BLOCKS
argument_list|)
operator|.
name|size
argument_list|()
return|;
block|}
comment|/** Return the number of corrupt blocks with replication factor 1 */
DECL|method|getCorruptReplicationOneBlockSize ()
name|long
name|getCorruptReplicationOneBlockSize
parameter_list|()
block|{
return|return
name|getCorruptReplicationOneBlocks
argument_list|()
return|;
block|}
comment|/**    * Return under replicated block count excluding corrupt replicas.    */
DECL|method|getLowRedundancyBlocks ()
name|long
name|getLowRedundancyBlocks
parameter_list|()
block|{
return|return
name|lowRedundancyBlocks
operator|.
name|longValue
argument_list|()
operator|-
name|getCorruptBlocks
argument_list|()
return|;
block|}
DECL|method|getCorruptBlocks ()
name|long
name|getCorruptBlocks
parameter_list|()
block|{
return|return
name|corruptBlocks
operator|.
name|longValue
argument_list|()
return|;
block|}
DECL|method|getCorruptReplicationOneBlocks ()
name|long
name|getCorruptReplicationOneBlocks
parameter_list|()
block|{
return|return
name|corruptReplicationOneBlocks
operator|.
name|longValue
argument_list|()
return|;
block|}
comment|/**    *  Return low redundancy striped blocks excluding corrupt blocks.    */
DECL|method|getLowRedundancyECBlockGroups ()
name|long
name|getLowRedundancyECBlockGroups
parameter_list|()
block|{
return|return
name|lowRedundancyECBlockGroups
operator|.
name|longValue
argument_list|()
operator|-
name|getCorruptECBlockGroups
argument_list|()
return|;
block|}
DECL|method|getCorruptECBlockGroups ()
name|long
name|getCorruptECBlockGroups
parameter_list|()
block|{
return|return
name|corruptECBlockGroups
operator|.
name|longValue
argument_list|()
return|;
block|}
comment|/** Check if a block is in the neededReconstruction queue. */
DECL|method|contains (BlockInfo block)
specifier|synchronized
name|boolean
name|contains
parameter_list|(
name|BlockInfo
name|block
parameter_list|)
block|{
for|for
control|(
name|LightWeightLinkedSet
argument_list|<
name|BlockInfo
argument_list|>
name|set
range|:
name|priorityQueues
control|)
block|{
if|if
condition|(
name|set
operator|.
name|contains
argument_list|(
name|block
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/** Return the priority of a block    * @param curReplicas current number of replicas of the block    * @param expectedReplicas expected number of replicas of the block    * @return the priority for the blocks, between 0 and ({@link #LEVEL}-1)    */
DECL|method|getPriority (BlockInfo block, int curReplicas, int readOnlyReplicas, int outOfServiceReplicas, int expectedReplicas)
specifier|private
name|int
name|getPriority
parameter_list|(
name|BlockInfo
name|block
parameter_list|,
name|int
name|curReplicas
parameter_list|,
name|int
name|readOnlyReplicas
parameter_list|,
name|int
name|outOfServiceReplicas
parameter_list|,
name|int
name|expectedReplicas
parameter_list|)
block|{
assert|assert
name|curReplicas
operator|>=
literal|0
operator|:
literal|"Negative replicas!"
assert|;
if|if
condition|(
name|curReplicas
operator|>=
name|expectedReplicas
condition|)
block|{
comment|// Block has enough copies, but not enough racks
return|return
name|QUEUE_REPLICAS_BADLY_DISTRIBUTED
return|;
block|}
if|if
condition|(
name|block
operator|.
name|isStriped
argument_list|()
condition|)
block|{
name|BlockInfoStriped
name|sblk
init|=
operator|(
name|BlockInfoStriped
operator|)
name|block
decl_stmt|;
return|return
name|getPriorityStriped
argument_list|(
name|curReplicas
argument_list|,
name|outOfServiceReplicas
argument_list|,
name|sblk
operator|.
name|getRealDataBlockNum
argument_list|()
argument_list|,
name|sblk
operator|.
name|getParityBlockNum
argument_list|()
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|getPriorityContiguous
argument_list|(
name|curReplicas
argument_list|,
name|readOnlyReplicas
argument_list|,
name|outOfServiceReplicas
argument_list|,
name|expectedReplicas
argument_list|)
return|;
block|}
block|}
DECL|method|getPriorityContiguous (int curReplicas, int readOnlyReplicas, int outOfServiceReplicas, int expectedReplicas)
specifier|private
name|int
name|getPriorityContiguous
parameter_list|(
name|int
name|curReplicas
parameter_list|,
name|int
name|readOnlyReplicas
parameter_list|,
name|int
name|outOfServiceReplicas
parameter_list|,
name|int
name|expectedReplicas
parameter_list|)
block|{
if|if
condition|(
name|curReplicas
operator|==
literal|0
condition|)
block|{
comment|// If there are zero non-decommissioned replicas but there are
comment|// some out of service replicas, then assign them highest priority
if|if
condition|(
name|outOfServiceReplicas
operator|>
literal|0
condition|)
block|{
return|return
name|QUEUE_HIGHEST_PRIORITY
return|;
block|}
if|if
condition|(
name|readOnlyReplicas
operator|>
literal|0
condition|)
block|{
comment|// only has read-only replicas, highest risk
comment|// since the read-only replicas may go down all together.
return|return
name|QUEUE_HIGHEST_PRIORITY
return|;
block|}
comment|//all we have are corrupt blocks
return|return
name|QUEUE_WITH_CORRUPT_BLOCKS
return|;
block|}
elseif|else
if|if
condition|(
name|curReplicas
operator|==
literal|1
condition|)
block|{
comment|// only one replica, highest risk of loss
comment|// highest priority
return|return
name|QUEUE_HIGHEST_PRIORITY
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|curReplicas
operator|*
literal|3
operator|)
operator|<
name|expectedReplicas
condition|)
block|{
comment|//can only afford one replica loss
comment|//this is considered very insufficiently redundant blocks.
return|return
name|QUEUE_VERY_LOW_REDUNDANCY
return|;
block|}
else|else
block|{
comment|//add to the normal queue for insufficiently redundant blocks
return|return
name|QUEUE_LOW_REDUNDANCY
return|;
block|}
block|}
DECL|method|getPriorityStriped (int curReplicas, int outOfServiceReplicas, short dataBlkNum, short parityBlkNum)
specifier|private
name|int
name|getPriorityStriped
parameter_list|(
name|int
name|curReplicas
parameter_list|,
name|int
name|outOfServiceReplicas
parameter_list|,
name|short
name|dataBlkNum
parameter_list|,
name|short
name|parityBlkNum
parameter_list|)
block|{
if|if
condition|(
name|curReplicas
operator|<
name|dataBlkNum
condition|)
block|{
comment|// There are some replicas on decommissioned nodes so it's not corrupted
if|if
condition|(
name|curReplicas
operator|+
name|outOfServiceReplicas
operator|>=
name|dataBlkNum
condition|)
block|{
return|return
name|QUEUE_HIGHEST_PRIORITY
return|;
block|}
return|return
name|QUEUE_WITH_CORRUPT_BLOCKS
return|;
block|}
elseif|else
if|if
condition|(
name|curReplicas
operator|==
name|dataBlkNum
condition|)
block|{
comment|// highest risk of loss, highest priority
return|return
name|QUEUE_HIGHEST_PRIORITY
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|curReplicas
operator|-
name|dataBlkNum
operator|)
operator|*
literal|3
operator|<
name|parityBlkNum
operator|+
literal|1
condition|)
block|{
comment|// can only afford one replica loss
comment|// this is considered very insufficiently redundant blocks.
return|return
name|QUEUE_VERY_LOW_REDUNDANCY
return|;
block|}
else|else
block|{
comment|// add to the normal queue for insufficiently redundant blocks.
return|return
name|QUEUE_LOW_REDUNDANCY
return|;
block|}
block|}
comment|/**    * Add a block to insufficiently redundant queue according to its priority.    *    * @param block a low redundancy block    * @param curReplicas current number of replicas of the block    * @param outOfServiceReplicas the number of out-of-service replicas    * @param expectedReplicas expected number of replicas of the block    * @return true if the block was added to a queue.    */
DECL|method|add (BlockInfo block, int curReplicas, int readOnlyReplicas, int outOfServiceReplicas, int expectedReplicas)
specifier|synchronized
name|boolean
name|add
parameter_list|(
name|BlockInfo
name|block
parameter_list|,
name|int
name|curReplicas
parameter_list|,
name|int
name|readOnlyReplicas
parameter_list|,
name|int
name|outOfServiceReplicas
parameter_list|,
name|int
name|expectedReplicas
parameter_list|)
block|{
specifier|final
name|int
name|priLevel
init|=
name|getPriority
argument_list|(
name|block
argument_list|,
name|curReplicas
argument_list|,
name|readOnlyReplicas
argument_list|,
name|outOfServiceReplicas
argument_list|,
name|expectedReplicas
argument_list|)
decl_stmt|;
if|if
condition|(
name|add
argument_list|(
name|block
argument_list|,
name|priLevel
argument_list|,
name|expectedReplicas
argument_list|)
condition|)
block|{
name|NameNode
operator|.
name|blockStateChangeLog
operator|.
name|debug
argument_list|(
literal|"BLOCK* NameSystem.LowRedundancyBlock.add: {}"
operator|+
literal|" has only {} replicas and need {} replicas so is added to"
operator|+
literal|" neededReconstructions at priority level {}"
argument_list|,
name|block
argument_list|,
name|curReplicas
argument_list|,
name|expectedReplicas
argument_list|,
name|priLevel
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
DECL|method|add (BlockInfo blockInfo, int priLevel, int expectedReplicas)
specifier|private
name|boolean
name|add
parameter_list|(
name|BlockInfo
name|blockInfo
parameter_list|,
name|int
name|priLevel
parameter_list|,
name|int
name|expectedReplicas
parameter_list|)
block|{
if|if
condition|(
name|priorityQueues
operator|.
name|get
argument_list|(
name|priLevel
argument_list|)
operator|.
name|add
argument_list|(
name|blockInfo
argument_list|)
condition|)
block|{
name|incrementBlockStat
argument_list|(
name|blockInfo
argument_list|,
name|priLevel
argument_list|,
name|expectedReplicas
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
DECL|method|incrementBlockStat (BlockInfo blockInfo, int priLevel, int expectedReplicas)
specifier|private
name|void
name|incrementBlockStat
parameter_list|(
name|BlockInfo
name|blockInfo
parameter_list|,
name|int
name|priLevel
parameter_list|,
name|int
name|expectedReplicas
parameter_list|)
block|{
if|if
condition|(
name|blockInfo
operator|.
name|isStriped
argument_list|()
condition|)
block|{
name|lowRedundancyECBlockGroups
operator|.
name|increment
argument_list|()
expr_stmt|;
if|if
condition|(
name|priLevel
operator|==
name|QUEUE_WITH_CORRUPT_BLOCKS
condition|)
block|{
name|corruptECBlockGroups
operator|.
name|increment
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
name|lowRedundancyBlocks
operator|.
name|increment
argument_list|()
expr_stmt|;
if|if
condition|(
name|priLevel
operator|==
name|QUEUE_WITH_CORRUPT_BLOCKS
condition|)
block|{
name|corruptBlocks
operator|.
name|increment
argument_list|()
expr_stmt|;
if|if
condition|(
name|expectedReplicas
operator|==
literal|1
condition|)
block|{
name|corruptReplicationOneBlocks
operator|.
name|increment
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/** Remove a block from a low redundancy queue. */
DECL|method|remove (BlockInfo block, int oldReplicas, int oldReadOnlyReplicas, int outOfServiceReplicas, int oldExpectedReplicas)
specifier|synchronized
name|boolean
name|remove
parameter_list|(
name|BlockInfo
name|block
parameter_list|,
name|int
name|oldReplicas
parameter_list|,
name|int
name|oldReadOnlyReplicas
parameter_list|,
name|int
name|outOfServiceReplicas
parameter_list|,
name|int
name|oldExpectedReplicas
parameter_list|)
block|{
specifier|final
name|int
name|priLevel
init|=
name|getPriority
argument_list|(
name|block
argument_list|,
name|oldReplicas
argument_list|,
name|oldReadOnlyReplicas
argument_list|,
name|outOfServiceReplicas
argument_list|,
name|oldExpectedReplicas
argument_list|)
decl_stmt|;
name|boolean
name|removedBlock
init|=
name|remove
argument_list|(
name|block
argument_list|,
name|priLevel
argument_list|,
name|oldExpectedReplicas
argument_list|)
decl_stmt|;
if|if
condition|(
name|priLevel
operator|==
name|QUEUE_WITH_CORRUPT_BLOCKS
operator|&&
name|oldExpectedReplicas
operator|==
literal|1
operator|&&
name|removedBlock
condition|)
block|{
assert|assert
name|corruptReplicationOneBlocks
operator|.
name|longValue
argument_list|()
operator|>=
literal|0
operator|:
literal|"Number of corrupt blocks with replication factor 1 "
operator|+
literal|"should be non-negative"
assert|;
block|}
return|return
name|removedBlock
return|;
block|}
comment|/**    * Remove a block from the low redundancy queues.    *    * The priLevel parameter is a hint of which queue to query    * first: if negative or&gt;= {@link #LEVEL} this shortcutting    * is not attmpted.    *    * If the block is not found in the nominated queue, an attempt is made to    * remove it from all queues.    *    *<i>Warning:</i> This is not a synchronized method.    * @param block block to remove    * @param priLevel expected privilege level    * @return true if the block was found and removed from one of the priority    *         queues    */
DECL|method|remove (BlockInfo block, int priLevel)
name|boolean
name|remove
parameter_list|(
name|BlockInfo
name|block
parameter_list|,
name|int
name|priLevel
parameter_list|)
block|{
return|return
name|remove
argument_list|(
name|block
argument_list|,
name|priLevel
argument_list|,
name|block
operator|.
name|getReplication
argument_list|()
argument_list|)
return|;
block|}
DECL|method|remove (BlockInfo block, int priLevel, int oldExpectedReplicas)
name|boolean
name|remove
parameter_list|(
name|BlockInfo
name|block
parameter_list|,
name|int
name|priLevel
parameter_list|,
name|int
name|oldExpectedReplicas
parameter_list|)
block|{
if|if
condition|(
name|priLevel
operator|>=
literal|0
operator|&&
name|priLevel
operator|<
name|LEVEL
operator|&&
name|priorityQueues
operator|.
name|get
argument_list|(
name|priLevel
argument_list|)
operator|.
name|remove
argument_list|(
name|block
argument_list|)
condition|)
block|{
name|NameNode
operator|.
name|blockStateChangeLog
operator|.
name|debug
argument_list|(
literal|"BLOCK* NameSystem.LowRedundancyBlock.remove: Removing block {}"
operator|+
literal|" from priority queue {}"
argument_list|,
name|block
argument_list|,
name|priLevel
argument_list|)
expr_stmt|;
name|decrementBlockStat
argument_list|(
name|block
argument_list|,
name|priLevel
argument_list|,
name|oldExpectedReplicas
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
else|else
block|{
comment|// Try to remove the block from all queues if the block was
comment|// not found in the queue for the given priority level.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|LEVEL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|!=
name|priLevel
operator|&&
name|priorityQueues
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|remove
argument_list|(
name|block
argument_list|)
condition|)
block|{
name|NameNode
operator|.
name|blockStateChangeLog
operator|.
name|debug
argument_list|(
literal|"BLOCK* NameSystem.LowRedundancyBlock.remove: Removing block"
operator|+
literal|" {} from priority queue {}"
argument_list|,
name|block
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|decrementBlockStat
argument_list|(
name|block
argument_list|,
name|priLevel
argument_list|,
name|oldExpectedReplicas
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
block|}
return|return
literal|false
return|;
block|}
DECL|method|decrementBlockStat (BlockInfo blockInfo, int priLevel, int oldExpectedReplicas)
specifier|private
name|void
name|decrementBlockStat
parameter_list|(
name|BlockInfo
name|blockInfo
parameter_list|,
name|int
name|priLevel
parameter_list|,
name|int
name|oldExpectedReplicas
parameter_list|)
block|{
if|if
condition|(
name|blockInfo
operator|.
name|isStriped
argument_list|()
condition|)
block|{
name|lowRedundancyECBlockGroups
operator|.
name|decrement
argument_list|()
expr_stmt|;
if|if
condition|(
name|priLevel
operator|==
name|QUEUE_WITH_CORRUPT_BLOCKS
condition|)
block|{
name|corruptECBlockGroups
operator|.
name|decrement
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
name|lowRedundancyBlocks
operator|.
name|decrement
argument_list|()
expr_stmt|;
if|if
condition|(
name|priLevel
operator|==
name|QUEUE_WITH_CORRUPT_BLOCKS
condition|)
block|{
name|corruptBlocks
operator|.
name|decrement
argument_list|()
expr_stmt|;
if|if
condition|(
name|oldExpectedReplicas
operator|==
literal|1
condition|)
block|{
name|corruptReplicationOneBlocks
operator|.
name|decrement
argument_list|()
expr_stmt|;
assert|assert
name|corruptReplicationOneBlocks
operator|.
name|longValue
argument_list|()
operator|>=
literal|0
operator|:
literal|"Number of corrupt blocks with replication factor 1 "
operator|+
literal|"should be non-negative"
assert|;
block|}
block|}
block|}
block|}
comment|/**    * Recalculate and potentially update the priority level of a block.    *    * If the block priority has changed from before an attempt is made to    * remove it from the block queue. Regardless of whether or not the block    * is in the block queue of (recalculate) priority, an attempt is made    * to add it to that queue. This ensures that the block will be    * in its expected priority queue (and only that queue) by the end of the    * method call.    * @param block a low redundancy block    * @param curReplicas current number of replicas of the block    * @param outOfServiceReplicas  the number of out-of-service replicas    * @param curExpectedReplicas expected number of replicas of the block    * @param curReplicasDelta the change in the replicate count from before    * @param expectedReplicasDelta the change in the expected replica count    *        from before    */
DECL|method|update (BlockInfo block, int curReplicas, int readOnlyReplicas, int outOfServiceReplicas, int curExpectedReplicas, int curReplicasDelta, int expectedReplicasDelta)
specifier|synchronized
name|void
name|update
parameter_list|(
name|BlockInfo
name|block
parameter_list|,
name|int
name|curReplicas
parameter_list|,
name|int
name|readOnlyReplicas
parameter_list|,
name|int
name|outOfServiceReplicas
parameter_list|,
name|int
name|curExpectedReplicas
parameter_list|,
name|int
name|curReplicasDelta
parameter_list|,
name|int
name|expectedReplicasDelta
parameter_list|)
block|{
name|int
name|oldReplicas
init|=
name|curReplicas
operator|-
name|curReplicasDelta
decl_stmt|;
name|int
name|oldExpectedReplicas
init|=
name|curExpectedReplicas
operator|-
name|expectedReplicasDelta
decl_stmt|;
name|int
name|curPri
init|=
name|getPriority
argument_list|(
name|block
argument_list|,
name|curReplicas
argument_list|,
name|readOnlyReplicas
argument_list|,
name|outOfServiceReplicas
argument_list|,
name|curExpectedReplicas
argument_list|)
decl_stmt|;
name|int
name|oldPri
init|=
name|getPriority
argument_list|(
name|block
argument_list|,
name|oldReplicas
argument_list|,
name|readOnlyReplicas
argument_list|,
name|outOfServiceReplicas
argument_list|,
name|oldExpectedReplicas
argument_list|)
decl_stmt|;
if|if
condition|(
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|debug
argument_list|(
literal|"LowRedundancyBlocks.update "
operator|+
name|block
operator|+
literal|" curReplicas "
operator|+
name|curReplicas
operator|+
literal|" curExpectedReplicas "
operator|+
name|curExpectedReplicas
operator|+
literal|" oldReplicas "
operator|+
name|oldReplicas
operator|+
literal|" oldExpectedReplicas  "
operator|+
name|oldExpectedReplicas
operator|+
literal|" curPri  "
operator|+
name|curPri
operator|+
literal|" oldPri  "
operator|+
name|oldPri
argument_list|)
expr_stmt|;
block|}
comment|// oldPri is mostly correct, but not always. If not found with oldPri,
comment|// other levels will be searched until the block is found& removed.
name|remove
argument_list|(
name|block
argument_list|,
name|oldPri
argument_list|,
name|oldExpectedReplicas
argument_list|)
expr_stmt|;
if|if
condition|(
name|add
argument_list|(
name|block
argument_list|,
name|curPri
argument_list|,
name|curExpectedReplicas
argument_list|)
condition|)
block|{
name|NameNode
operator|.
name|blockStateChangeLog
operator|.
name|debug
argument_list|(
literal|"BLOCK* NameSystem.LowRedundancyBlock.update: {} has only {} "
operator|+
literal|"replicas and needs {} replicas so is added to "
operator|+
literal|"neededReconstructions at priority level {}"
argument_list|,
name|block
argument_list|,
name|curReplicas
argument_list|,
name|curExpectedReplicas
argument_list|,
name|curPri
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Get a list of block lists without sufficient redundancy. The index of    * block lists represents its replication priority. Iterates each block list    * in priority order beginning with the highest priority list. Iterators use    * a bookmark to resume where the previous iteration stopped. Returns when    * the block count is met or iteration reaches the end of the lowest priority    * list, in which case bookmarks for each block list are reset to the heads    * of their respective lists.    *    * @param blocksToProcess - number of blocks to fetch from low redundancy    *          blocks.    * @return Return a list of block lists to be replicated. The block list    *         index represents its redundancy priority.    */
DECL|method|chooseLowRedundancyBlocks ( int blocksToProcess)
specifier|synchronized
name|List
argument_list|<
name|List
argument_list|<
name|BlockInfo
argument_list|>
argument_list|>
name|chooseLowRedundancyBlocks
parameter_list|(
name|int
name|blocksToProcess
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|List
argument_list|<
name|BlockInfo
argument_list|>
argument_list|>
name|blocksToReconstruct
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|LEVEL
argument_list|)
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
name|int
name|priority
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
name|count
operator|<
name|blocksToProcess
operator|&&
name|priority
operator|<
name|LEVEL
condition|;
name|priority
operator|++
control|)
block|{
if|if
condition|(
name|priority
operator|==
name|QUEUE_WITH_CORRUPT_BLOCKS
condition|)
block|{
comment|// do not choose corrupted blocks.
continue|continue;
block|}
comment|// Go through all blocks that need reconstructions with current priority.
comment|// Set the iterator to the first unprocessed block at this priority level
specifier|final
name|Iterator
argument_list|<
name|BlockInfo
argument_list|>
name|i
init|=
name|priorityQueues
operator|.
name|get
argument_list|(
name|priority
argument_list|)
operator|.
name|getBookmark
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|BlockInfo
argument_list|>
name|blocks
init|=
operator|new
name|LinkedList
argument_list|<>
argument_list|()
decl_stmt|;
name|blocksToReconstruct
operator|.
name|add
argument_list|(
name|blocks
argument_list|)
expr_stmt|;
comment|// Loop through all remaining blocks in the list.
for|for
control|(
init|;
name|count
operator|<
name|blocksToProcess
operator|&&
name|i
operator|.
name|hasNext
argument_list|()
condition|;
name|count
operator|++
control|)
block|{
name|blocks
operator|.
name|add
argument_list|(
name|i
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|priority
operator|==
name|LEVEL
condition|)
block|{
comment|// Reset all bookmarks because there were no recently added blocks.
for|for
control|(
name|LightWeightLinkedSet
argument_list|<
name|BlockInfo
argument_list|>
name|q
range|:
name|priorityQueues
control|)
block|{
name|q
operator|.
name|resetBookmark
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|blocksToReconstruct
return|;
block|}
comment|/** Returns an iterator of all blocks in a given priority queue. */
DECL|method|iterator (int level)
specifier|synchronized
name|Iterator
argument_list|<
name|BlockInfo
argument_list|>
name|iterator
parameter_list|(
name|int
name|level
parameter_list|)
block|{
return|return
name|priorityQueues
operator|.
name|get
argument_list|(
name|level
argument_list|)
operator|.
name|iterator
argument_list|()
return|;
block|}
comment|/** Return an iterator of all the low redundancy blocks. */
annotation|@
name|Override
DECL|method|iterator ()
specifier|public
specifier|synchronized
name|Iterator
argument_list|<
name|BlockInfo
argument_list|>
name|iterator
parameter_list|()
block|{
specifier|final
name|Iterator
argument_list|<
name|LightWeightLinkedSet
argument_list|<
name|BlockInfo
argument_list|>
argument_list|>
name|q
init|=
name|priorityQueues
operator|.
name|iterator
argument_list|()
decl_stmt|;
return|return
operator|new
name|Iterator
argument_list|<
name|BlockInfo
argument_list|>
argument_list|()
block|{
specifier|private
name|Iterator
argument_list|<
name|BlockInfo
argument_list|>
name|b
init|=
name|q
operator|.
name|next
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
annotation|@
name|Override
specifier|public
name|BlockInfo
name|next
parameter_list|()
block|{
name|hasNext
argument_list|()
expr_stmt|;
return|return
name|b
operator|.
name|next
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
for|for
control|(
init|;
operator|!
name|b
operator|.
name|hasNext
argument_list|()
operator|&&
name|q
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|b
operator|=
name|q
operator|.
name|next
argument_list|()
operator|.
name|iterator
argument_list|()
expr_stmt|;
block|}
return|return
name|b
operator|.
name|hasNext
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|remove
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
block|}
return|;
block|}
block|}
end_class

end_unit

