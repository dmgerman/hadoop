begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdfs.server.datanode
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|BufferedReader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Closeable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileNotFoundException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileReader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|PrintStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|text
operator|.
name|DateFormat
import|;
end_import

begin_import
import|import
name|java
operator|.
name|text
operator|.
name|SimpleDateFormat
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Date
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Random
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Matcher
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Pattern
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|Block
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|ExtendedBlock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|GenerationStamp
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|FSDataset
operator|.
name|FSVolume
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|util
operator|.
name|DataTransferThrottler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|IOUtils
import|;
end_import

begin_comment
comment|/**  * Performs two types of scanning:  *<li> Gets block files from the data directories and reconciles the  * difference between the blocks on the disk and in memory in  * {@link FSDataset}</li>  *<li> Scans the data directories for block files under a block pool  * and verifies that the files are not corrupt</li>  * This keeps track of blocks and their last verification times.  * Currently it does not modify the metadata for block.  */
end_comment

begin_class
DECL|class|BlockPoolSliceScanner
class|class
name|BlockPoolSliceScanner
block|{
DECL|field|LOG
specifier|public
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|BlockPoolSliceScanner
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|MAX_SCAN_RATE
specifier|private
specifier|static
specifier|final
name|int
name|MAX_SCAN_RATE
init|=
literal|8
operator|*
literal|1024
operator|*
literal|1024
decl_stmt|;
comment|// 8MB per sec
DECL|field|MIN_SCAN_RATE
specifier|private
specifier|static
specifier|final
name|int
name|MIN_SCAN_RATE
init|=
literal|1
operator|*
literal|1024
operator|*
literal|1024
decl_stmt|;
comment|// 1MB per sec
DECL|field|DEFAULT_SCAN_PERIOD_HOURS
specifier|static
specifier|final
name|long
name|DEFAULT_SCAN_PERIOD_HOURS
init|=
literal|21
operator|*
literal|24L
decl_stmt|;
comment|// three weeks
DECL|field|blockPoolId
specifier|private
specifier|final
name|String
name|blockPoolId
decl_stmt|;
DECL|field|dateFormatString
specifier|private
specifier|static
specifier|final
name|String
name|dateFormatString
init|=
literal|"yyyy-MM-dd HH:mm:ss,SSS"
decl_stmt|;
DECL|field|verificationLogFile
specifier|static
specifier|final
name|String
name|verificationLogFile
init|=
literal|"dncp_block_verification.log"
decl_stmt|;
DECL|field|verficationLogLimit
specifier|static
specifier|final
name|int
name|verficationLogLimit
init|=
literal|5
decl_stmt|;
comment|// * numBlocks.
DECL|field|scanPeriod
specifier|private
name|long
name|scanPeriod
init|=
name|DEFAULT_SCAN_PERIOD_HOURS
operator|*
literal|3600
operator|*
literal|1000
decl_stmt|;
DECL|field|datanode
specifier|private
name|DataNode
name|datanode
decl_stmt|;
DECL|field|dataset
specifier|private
name|FSDataset
name|dataset
decl_stmt|;
comment|// sorted set
DECL|field|blockInfoSet
specifier|private
name|TreeSet
argument_list|<
name|BlockScanInfo
argument_list|>
name|blockInfoSet
decl_stmt|;
DECL|field|blockMap
specifier|private
name|HashMap
argument_list|<
name|Block
argument_list|,
name|BlockScanInfo
argument_list|>
name|blockMap
decl_stmt|;
comment|// processedBlocks keeps track of which blocks are scanned
comment|// since the last run.
DECL|field|processedBlocks
specifier|private
name|HashMap
argument_list|<
name|Long
argument_list|,
name|Integer
argument_list|>
name|processedBlocks
decl_stmt|;
DECL|field|totalScans
specifier|private
name|long
name|totalScans
init|=
literal|0
decl_stmt|;
DECL|field|totalScanErrors
specifier|private
name|long
name|totalScanErrors
init|=
literal|0
decl_stmt|;
DECL|field|totalTransientErrors
specifier|private
name|long
name|totalTransientErrors
init|=
literal|0
decl_stmt|;
DECL|field|totalBlocksScannedInLastRun
specifier|private
name|long
name|totalBlocksScannedInLastRun
init|=
literal|0
decl_stmt|;
comment|// Used for test only
DECL|field|currentPeriodStart
specifier|private
name|long
name|currentPeriodStart
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
DECL|field|bytesLeft
specifier|private
name|long
name|bytesLeft
init|=
literal|0
decl_stmt|;
comment|// Bytes to scan in this period
DECL|field|totalBytesToScan
specifier|private
name|long
name|totalBytesToScan
init|=
literal|0
decl_stmt|;
DECL|field|verificationLog
specifier|private
name|LogFileHandler
name|verificationLog
decl_stmt|;
DECL|field|throttler
specifier|private
name|DataTransferThrottler
name|throttler
init|=
literal|null
decl_stmt|;
DECL|enum|ScanType
specifier|private
specifier|static
enum|enum
name|ScanType
block|{
DECL|enumConstant|VERIFICATION_SCAN
name|VERIFICATION_SCAN
block|,
comment|// scanned as part of periodic verfication
DECL|enumConstant|NONE
name|NONE
block|,   }
DECL|class|BlockScanInfo
specifier|static
class|class
name|BlockScanInfo
implements|implements
name|Comparable
argument_list|<
name|BlockScanInfo
argument_list|>
block|{
DECL|field|block
name|Block
name|block
decl_stmt|;
DECL|field|lastScanTime
name|long
name|lastScanTime
init|=
literal|0
decl_stmt|;
DECL|field|lastScanType
name|ScanType
name|lastScanType
init|=
name|ScanType
operator|.
name|NONE
decl_stmt|;
DECL|field|lastScanOk
name|boolean
name|lastScanOk
init|=
literal|true
decl_stmt|;
DECL|method|BlockScanInfo (Block block)
name|BlockScanInfo
parameter_list|(
name|Block
name|block
parameter_list|)
block|{
name|this
operator|.
name|block
operator|=
name|block
expr_stmt|;
block|}
DECL|method|hashCode ()
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|block
operator|.
name|hashCode
argument_list|()
return|;
block|}
DECL|method|equals (Object other)
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|other
parameter_list|)
block|{
return|return
name|other
operator|instanceof
name|BlockScanInfo
operator|&&
name|compareTo
argument_list|(
operator|(
name|BlockScanInfo
operator|)
name|other
argument_list|)
operator|==
literal|0
return|;
block|}
DECL|method|getLastScanTime ()
name|long
name|getLastScanTime
parameter_list|()
block|{
return|return
operator|(
name|lastScanType
operator|==
name|ScanType
operator|.
name|NONE
operator|)
condition|?
literal|0
else|:
name|lastScanTime
return|;
block|}
DECL|method|compareTo (BlockScanInfo other)
specifier|public
name|int
name|compareTo
parameter_list|(
name|BlockScanInfo
name|other
parameter_list|)
block|{
name|long
name|t1
init|=
name|lastScanTime
decl_stmt|;
name|long
name|t2
init|=
name|other
operator|.
name|lastScanTime
decl_stmt|;
return|return
operator|(
name|t1
operator|<
name|t2
operator|)
condition|?
operator|-
literal|1
else|:
operator|(
operator|(
name|t1
operator|>
name|t2
operator|)
condition|?
literal|1
else|:
name|block
operator|.
name|compareTo
argument_list|(
name|other
operator|.
name|block
argument_list|)
operator|)
return|;
block|}
block|}
DECL|method|BlockPoolSliceScanner (DataNode datanode, FSDataset dataset, Configuration conf, String bpid)
name|BlockPoolSliceScanner
parameter_list|(
name|DataNode
name|datanode
parameter_list|,
name|FSDataset
name|dataset
parameter_list|,
name|Configuration
name|conf
parameter_list|,
name|String
name|bpid
parameter_list|)
block|{
name|this
operator|.
name|datanode
operator|=
name|datanode
expr_stmt|;
name|this
operator|.
name|dataset
operator|=
name|dataset
expr_stmt|;
name|this
operator|.
name|blockPoolId
operator|=
name|bpid
expr_stmt|;
name|scanPeriod
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_DATANODE_SCAN_PERIOD_HOURS_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_DATANODE_SCAN_PERIOD_HOURS_DEFAULT
argument_list|)
expr_stmt|;
if|if
condition|(
name|scanPeriod
operator|<=
literal|0
condition|)
block|{
name|scanPeriod
operator|=
name|DEFAULT_SCAN_PERIOD_HOURS
expr_stmt|;
block|}
name|scanPeriod
operator|*=
literal|3600
operator|*
literal|1000
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Periodic Block Verification scan initialized with interval "
operator|+
name|scanPeriod
operator|+
literal|"."
argument_list|)
expr_stmt|;
block|}
DECL|method|getBlockPoolId ()
name|String
name|getBlockPoolId
parameter_list|()
block|{
return|return
name|blockPoolId
return|;
block|}
DECL|method|isInitialized ()
specifier|synchronized
name|boolean
name|isInitialized
parameter_list|()
block|{
return|return
name|throttler
operator|!=
literal|null
return|;
block|}
DECL|method|updateBytesToScan (long len, long lastScanTime)
specifier|private
name|void
name|updateBytesToScan
parameter_list|(
name|long
name|len
parameter_list|,
name|long
name|lastScanTime
parameter_list|)
block|{
comment|// len could be negative when a block is deleted.
name|totalBytesToScan
operator|+=
name|len
expr_stmt|;
if|if
condition|(
name|lastScanTime
operator|<
name|currentPeriodStart
condition|)
block|{
name|bytesLeft
operator|+=
name|len
expr_stmt|;
block|}
comment|// Should we change throttler bandwidth every time bytesLeft changes?
comment|// not really required.
block|}
DECL|method|addBlockInfo (BlockScanInfo info)
specifier|private
specifier|synchronized
name|void
name|addBlockInfo
parameter_list|(
name|BlockScanInfo
name|info
parameter_list|)
block|{
name|boolean
name|added
init|=
name|blockInfoSet
operator|.
name|add
argument_list|(
name|info
argument_list|)
decl_stmt|;
name|blockMap
operator|.
name|put
argument_list|(
name|info
operator|.
name|block
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|added
condition|)
block|{
name|updateBytesToScan
argument_list|(
name|info
operator|.
name|block
operator|.
name|getNumBytes
argument_list|()
argument_list|,
name|info
operator|.
name|lastScanTime
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|delBlockInfo (BlockScanInfo info)
specifier|private
specifier|synchronized
name|void
name|delBlockInfo
parameter_list|(
name|BlockScanInfo
name|info
parameter_list|)
block|{
name|boolean
name|exists
init|=
name|blockInfoSet
operator|.
name|remove
argument_list|(
name|info
argument_list|)
decl_stmt|;
name|blockMap
operator|.
name|remove
argument_list|(
name|info
operator|.
name|block
argument_list|)
expr_stmt|;
if|if
condition|(
name|exists
condition|)
block|{
name|updateBytesToScan
argument_list|(
operator|-
name|info
operator|.
name|block
operator|.
name|getNumBytes
argument_list|()
argument_list|,
name|info
operator|.
name|lastScanTime
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Update blockMap by the given LogEntry */
DECL|method|updateBlockInfo (LogEntry e)
specifier|private
specifier|synchronized
name|void
name|updateBlockInfo
parameter_list|(
name|LogEntry
name|e
parameter_list|)
block|{
name|BlockScanInfo
name|info
init|=
name|blockMap
operator|.
name|get
argument_list|(
operator|new
name|Block
argument_list|(
name|e
operator|.
name|blockId
argument_list|,
literal|0
argument_list|,
name|e
operator|.
name|genStamp
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|info
operator|!=
literal|null
operator|&&
name|e
operator|.
name|verificationTime
operator|>
literal|0
operator|&&
name|info
operator|.
name|lastScanTime
operator|<
name|e
operator|.
name|verificationTime
condition|)
block|{
name|delBlockInfo
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|info
operator|.
name|lastScanTime
operator|=
name|e
operator|.
name|verificationTime
expr_stmt|;
name|info
operator|.
name|lastScanType
operator|=
name|ScanType
operator|.
name|VERIFICATION_SCAN
expr_stmt|;
name|addBlockInfo
argument_list|(
name|info
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|init ()
name|void
name|init
parameter_list|()
throws|throws
name|IOException
block|{
comment|// get the list of blocks and arrange them in random order
name|List
argument_list|<
name|Block
argument_list|>
name|arr
init|=
name|dataset
operator|.
name|getFinalizedBlocks
argument_list|(
name|blockPoolId
argument_list|)
decl_stmt|;
name|Collections
operator|.
name|shuffle
argument_list|(
name|arr
argument_list|)
expr_stmt|;
name|blockInfoSet
operator|=
operator|new
name|TreeSet
argument_list|<
name|BlockScanInfo
argument_list|>
argument_list|()
expr_stmt|;
name|blockMap
operator|=
operator|new
name|HashMap
argument_list|<
name|Block
argument_list|,
name|BlockScanInfo
argument_list|>
argument_list|()
expr_stmt|;
name|long
name|scanTime
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|Block
name|block
range|:
name|arr
control|)
block|{
name|BlockScanInfo
name|info
init|=
operator|new
name|BlockScanInfo
argument_list|(
name|block
argument_list|)
decl_stmt|;
name|info
operator|.
name|lastScanTime
operator|=
name|scanTime
operator|--
expr_stmt|;
comment|//still keep 'info.lastScanType' to NONE.
name|addBlockInfo
argument_list|(
name|info
argument_list|)
expr_stmt|;
block|}
comment|/* Pick the first directory that has any existing scanner log.      * otherwise, pick the first directory.      */
name|File
name|dir
init|=
literal|null
decl_stmt|;
name|List
argument_list|<
name|FSVolume
argument_list|>
name|volumes
init|=
name|dataset
operator|.
name|volumes
operator|.
name|getVolumes
argument_list|()
decl_stmt|;
for|for
control|(
name|FSDataset
operator|.
name|FSVolume
name|vol
range|:
name|dataset
operator|.
name|volumes
operator|.
name|getVolumes
argument_list|()
control|)
block|{
name|File
name|bpDir
init|=
name|vol
operator|.
name|getBlockPoolSlice
argument_list|(
name|blockPoolId
argument_list|)
operator|.
name|getDirectory
argument_list|()
decl_stmt|;
if|if
condition|(
name|LogFileHandler
operator|.
name|isFilePresent
argument_list|(
name|bpDir
argument_list|,
name|verificationLogFile
argument_list|)
condition|)
block|{
name|dir
operator|=
name|bpDir
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|dir
operator|==
literal|null
condition|)
block|{
name|dir
operator|=
name|volumes
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getBlockPoolSlice
argument_list|(
name|blockPoolId
argument_list|)
operator|.
name|getDirectory
argument_list|()
expr_stmt|;
block|}
try|try
block|{
comment|// max lines will be updated later during initialization.
name|verificationLog
operator|=
operator|new
name|LogFileHandler
argument_list|(
name|dir
argument_list|,
name|verificationLogFile
argument_list|,
literal|100
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Could not open verfication log. "
operator|+
literal|"Verification times are not stored."
argument_list|)
expr_stmt|;
block|}
synchronized|synchronized
init|(
name|this
init|)
block|{
name|throttler
operator|=
operator|new
name|DataTransferThrottler
argument_list|(
literal|200
argument_list|,
name|MAX_SCAN_RATE
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|getNewBlockScanTime ()
specifier|private
specifier|synchronized
name|long
name|getNewBlockScanTime
parameter_list|()
block|{
comment|/* If there are a lot of blocks, this returns a random time with in       * the scan period. Otherwise something sooner.      */
name|long
name|period
init|=
name|Math
operator|.
name|min
argument_list|(
name|scanPeriod
argument_list|,
name|Math
operator|.
name|max
argument_list|(
name|blockMap
operator|.
name|size
argument_list|()
argument_list|,
literal|1
argument_list|)
operator|*
literal|600
operator|*
literal|1000L
argument_list|)
decl_stmt|;
return|return
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|scanPeriod
operator|+
name|DFSUtil
operator|.
name|getRandom
argument_list|()
operator|.
name|nextInt
argument_list|(
operator|(
name|int
operator|)
name|period
argument_list|)
return|;
block|}
comment|/** Adds block to list of blocks */
DECL|method|addBlock (ExtendedBlock block)
specifier|synchronized
name|void
name|addBlock
parameter_list|(
name|ExtendedBlock
name|block
parameter_list|)
block|{
if|if
condition|(
operator|!
name|isInitialized
argument_list|()
condition|)
block|{
return|return;
block|}
name|BlockScanInfo
name|info
init|=
name|blockMap
operator|.
name|get
argument_list|(
name|block
operator|.
name|getLocalBlock
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|info
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Adding an already existing block "
operator|+
name|block
argument_list|)
expr_stmt|;
name|delBlockInfo
argument_list|(
name|info
argument_list|)
expr_stmt|;
block|}
name|info
operator|=
operator|new
name|BlockScanInfo
argument_list|(
name|block
operator|.
name|getLocalBlock
argument_list|()
argument_list|)
expr_stmt|;
name|info
operator|.
name|lastScanTime
operator|=
name|getNewBlockScanTime
argument_list|()
expr_stmt|;
name|addBlockInfo
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|adjustThrottler
argument_list|()
expr_stmt|;
block|}
comment|/** Deletes the block from internal structures */
DECL|method|deleteBlock (Block block)
specifier|synchronized
name|void
name|deleteBlock
parameter_list|(
name|Block
name|block
parameter_list|)
block|{
if|if
condition|(
operator|!
name|isInitialized
argument_list|()
condition|)
block|{
return|return;
block|}
name|BlockScanInfo
name|info
init|=
name|blockMap
operator|.
name|get
argument_list|(
name|block
argument_list|)
decl_stmt|;
if|if
condition|(
name|info
operator|!=
literal|null
condition|)
block|{
name|delBlockInfo
argument_list|(
name|info
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** @return the last scan time */
DECL|method|getLastScanTime (Block block)
specifier|synchronized
name|long
name|getLastScanTime
parameter_list|(
name|Block
name|block
parameter_list|)
block|{
if|if
condition|(
operator|!
name|isInitialized
argument_list|()
condition|)
block|{
return|return
literal|0
return|;
block|}
name|BlockScanInfo
name|info
init|=
name|blockMap
operator|.
name|get
argument_list|(
name|block
argument_list|)
decl_stmt|;
return|return
name|info
operator|==
literal|null
condition|?
literal|0
else|:
name|info
operator|.
name|lastScanTime
return|;
block|}
comment|/** Deletes blocks from internal structures */
DECL|method|deleteBlocks (Block[] blocks)
name|void
name|deleteBlocks
parameter_list|(
name|Block
index|[]
name|blocks
parameter_list|)
block|{
for|for
control|(
name|Block
name|b
range|:
name|blocks
control|)
block|{
name|deleteBlock
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|updateScanStatus (Block block, ScanType type, boolean scanOk)
specifier|private
specifier|synchronized
name|void
name|updateScanStatus
parameter_list|(
name|Block
name|block
parameter_list|,
name|ScanType
name|type
parameter_list|,
name|boolean
name|scanOk
parameter_list|)
block|{
if|if
condition|(
operator|!
name|isInitialized
argument_list|()
condition|)
block|{
return|return;
block|}
name|BlockScanInfo
name|info
init|=
name|blockMap
operator|.
name|get
argument_list|(
name|block
argument_list|)
decl_stmt|;
if|if
condition|(
name|info
operator|!=
literal|null
condition|)
block|{
name|delBlockInfo
argument_list|(
name|info
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// It might already be removed. Thats ok, it will be caught next time.
name|info
operator|=
operator|new
name|BlockScanInfo
argument_list|(
name|block
argument_list|)
expr_stmt|;
block|}
name|long
name|now
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|info
operator|.
name|lastScanType
operator|=
name|type
expr_stmt|;
name|info
operator|.
name|lastScanTime
operator|=
name|now
expr_stmt|;
name|info
operator|.
name|lastScanOk
operator|=
name|scanOk
expr_stmt|;
name|addBlockInfo
argument_list|(
name|info
argument_list|)
expr_stmt|;
comment|// Don't update meta data if the verification failed.
if|if
condition|(
operator|!
name|scanOk
condition|)
block|{
return|return;
block|}
name|LogFileHandler
name|log
init|=
name|verificationLog
decl_stmt|;
if|if
condition|(
name|log
operator|!=
literal|null
condition|)
block|{
name|log
operator|.
name|appendLine
argument_list|(
name|now
argument_list|,
name|block
operator|.
name|getGenerationStamp
argument_list|()
argument_list|,
name|block
operator|.
name|getBlockId
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|handleScanFailure (ExtendedBlock block)
specifier|private
name|void
name|handleScanFailure
parameter_list|(
name|ExtendedBlock
name|block
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Reporting bad block "
operator|+
name|block
argument_list|)
expr_stmt|;
try|try
block|{
name|datanode
operator|.
name|reportBadBlocks
argument_list|(
name|block
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ie
parameter_list|)
block|{
comment|// it is bad, but not bad enough to shutdown the scanner
name|LOG
operator|.
name|warn
argument_list|(
literal|"Cannot report bad block="
operator|+
name|block
operator|.
name|getBlockId
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|class|LogEntry
specifier|static
specifier|private
class|class
name|LogEntry
block|{
DECL|field|blockId
name|long
name|blockId
init|=
operator|-
literal|1
decl_stmt|;
DECL|field|verificationTime
name|long
name|verificationTime
init|=
operator|-
literal|1
decl_stmt|;
DECL|field|genStamp
name|long
name|genStamp
init|=
name|GenerationStamp
operator|.
name|GRANDFATHER_GENERATION_STAMP
decl_stmt|;
comment|/**      * The format consists of single line with multiple entries. each       * entry is in the form : name="value".      * This simple text and easily extendable and easily parseable with a      * regex.      */
DECL|field|entryPattern
specifier|private
specifier|static
name|Pattern
name|entryPattern
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"\\G\\s*([^=\\p{Space}]+)=\"(.*?)\"\\s*"
argument_list|)
decl_stmt|;
DECL|method|parseEntry (String line)
specifier|static
name|LogEntry
name|parseEntry
parameter_list|(
name|String
name|line
parameter_list|)
block|{
name|LogEntry
name|entry
init|=
operator|new
name|LogEntry
argument_list|()
decl_stmt|;
name|Matcher
name|matcher
init|=
name|entryPattern
operator|.
name|matcher
argument_list|(
name|line
argument_list|)
decl_stmt|;
while|while
condition|(
name|matcher
operator|.
name|find
argument_list|()
condition|)
block|{
name|String
name|name
init|=
name|matcher
operator|.
name|group
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|String
name|value
init|=
name|matcher
operator|.
name|group
argument_list|(
literal|2
argument_list|)
decl_stmt|;
try|try
block|{
if|if
condition|(
name|name
operator|.
name|equals
argument_list|(
literal|"id"
argument_list|)
condition|)
block|{
name|entry
operator|.
name|blockId
operator|=
name|Long
operator|.
name|valueOf
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|name
operator|.
name|equals
argument_list|(
literal|"time"
argument_list|)
condition|)
block|{
name|entry
operator|.
name|verificationTime
operator|=
name|Long
operator|.
name|valueOf
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|name
operator|.
name|equals
argument_list|(
literal|"genstamp"
argument_list|)
condition|)
block|{
name|entry
operator|.
name|genStamp
operator|=
name|Long
operator|.
name|valueOf
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|nfe
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Cannot parse line: "
operator|+
name|line
argument_list|,
name|nfe
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
return|return
name|entry
return|;
block|}
block|}
DECL|method|adjustThrottler ()
specifier|private
specifier|synchronized
name|void
name|adjustThrottler
parameter_list|()
block|{
name|long
name|timeLeft
init|=
name|currentPeriodStart
operator|+
name|scanPeriod
operator|-
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|long
name|bw
init|=
name|Math
operator|.
name|max
argument_list|(
name|bytesLeft
operator|*
literal|1000
operator|/
name|timeLeft
argument_list|,
name|MIN_SCAN_RATE
argument_list|)
decl_stmt|;
name|throttler
operator|.
name|setBandwidth
argument_list|(
name|Math
operator|.
name|min
argument_list|(
name|bw
argument_list|,
name|MAX_SCAN_RATE
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|verifyBlock (ExtendedBlock block)
specifier|private
name|void
name|verifyBlock
parameter_list|(
name|ExtendedBlock
name|block
parameter_list|)
block|{
name|BlockSender
name|blockSender
init|=
literal|null
decl_stmt|;
comment|/* In case of failure, attempt to read second time to reduce      * transient errors. How do we flush block data from kernel       * buffers before the second read?       */
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|boolean
name|second
init|=
operator|(
name|i
operator|>
literal|0
operator|)
decl_stmt|;
try|try
block|{
name|adjustThrottler
argument_list|()
expr_stmt|;
name|blockSender
operator|=
operator|new
name|BlockSender
argument_list|(
name|block
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|,
name|datanode
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|DataOutputStream
name|out
init|=
operator|new
name|DataOutputStream
argument_list|(
operator|new
name|IOUtils
operator|.
name|NullOutputStream
argument_list|()
argument_list|)
decl_stmt|;
name|blockSender
operator|.
name|sendBlock
argument_list|(
name|out
argument_list|,
literal|null
argument_list|,
name|throttler
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
operator|(
name|second
condition|?
literal|"Second "
else|:
literal|""
operator|)
operator|+
literal|"Verification succeeded for "
operator|+
name|block
argument_list|)
expr_stmt|;
if|if
condition|(
name|second
condition|)
block|{
name|totalTransientErrors
operator|++
expr_stmt|;
block|}
name|updateScanStatus
argument_list|(
name|block
operator|.
name|getLocalBlock
argument_list|()
argument_list|,
name|ScanType
operator|.
name|VERIFICATION_SCAN
argument_list|,
literal|true
argument_list|)
expr_stmt|;
return|return;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|updateScanStatus
argument_list|(
name|block
operator|.
name|getLocalBlock
argument_list|()
argument_list|,
name|ScanType
operator|.
name|VERIFICATION_SCAN
argument_list|,
literal|false
argument_list|)
expr_stmt|;
comment|// If the block does not exists anymore, then its not an error
if|if
condition|(
name|dataset
operator|.
name|getFile
argument_list|(
name|block
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|block
operator|.
name|getLocalBlock
argument_list|()
argument_list|)
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Verification failed for "
operator|+
name|block
operator|+
literal|". Its ok since "
operator|+
literal|"it not in datanode dataset anymore."
argument_list|)
expr_stmt|;
name|deleteBlock
argument_list|(
name|block
operator|.
name|getLocalBlock
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
name|LOG
operator|.
name|warn
argument_list|(
operator|(
name|second
condition|?
literal|"Second "
else|:
literal|"First "
operator|)
operator|+
literal|"Verification failed for "
operator|+
name|block
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|second
condition|)
block|{
name|totalScanErrors
operator|++
expr_stmt|;
name|datanode
operator|.
name|getMetrics
argument_list|()
operator|.
name|incrBlockVerificationFailures
argument_list|()
expr_stmt|;
name|handleScanFailure
argument_list|(
name|block
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
finally|finally
block|{
name|IOUtils
operator|.
name|closeStream
argument_list|(
name|blockSender
argument_list|)
expr_stmt|;
name|datanode
operator|.
name|getMetrics
argument_list|()
operator|.
name|incrBlocksVerified
argument_list|()
expr_stmt|;
name|totalScans
operator|++
expr_stmt|;
block|}
block|}
block|}
DECL|method|getEarliestScanTime ()
specifier|private
specifier|synchronized
name|long
name|getEarliestScanTime
parameter_list|()
block|{
if|if
condition|(
name|blockInfoSet
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
return|return
name|blockInfoSet
operator|.
name|first
argument_list|()
operator|.
name|lastScanTime
return|;
block|}
return|return
name|Long
operator|.
name|MAX_VALUE
return|;
block|}
DECL|method|isFirstBlockProcessed ()
specifier|private
specifier|synchronized
name|boolean
name|isFirstBlockProcessed
parameter_list|()
block|{
if|if
condition|(
name|blockInfoSet
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|long
name|blockId
init|=
name|blockInfoSet
operator|.
name|first
argument_list|()
operator|.
name|block
operator|.
name|getBlockId
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|processedBlocks
operator|.
name|get
argument_list|(
name|blockId
argument_list|)
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|processedBlocks
operator|.
name|get
argument_list|(
name|blockId
argument_list|)
operator|==
literal|1
operator|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|// Picks one block and verifies it
DECL|method|verifyFirstBlock ()
specifier|private
name|void
name|verifyFirstBlock
parameter_list|()
block|{
name|Block
name|block
init|=
literal|null
decl_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
if|if
condition|(
name|blockInfoSet
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|block
operator|=
name|blockInfoSet
operator|.
name|first
argument_list|()
operator|.
name|block
expr_stmt|;
block|}
block|}
if|if
condition|(
name|block
operator|!=
literal|null
condition|)
block|{
name|verifyBlock
argument_list|(
operator|new
name|ExtendedBlock
argument_list|(
name|blockPoolId
argument_list|,
name|block
argument_list|)
argument_list|)
expr_stmt|;
name|processedBlocks
operator|.
name|put
argument_list|(
name|block
operator|.
name|getBlockId
argument_list|()
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Used for tests only
DECL|method|getBlocksScannedInLastRun ()
name|long
name|getBlocksScannedInLastRun
parameter_list|()
block|{
return|return
name|totalBlocksScannedInLastRun
return|;
block|}
comment|/**    * Reads the current and previous log files (if any) and marks the blocks    * processed if they were processed within last scan period. Copies the log    * records of recently scanned blocks from previous to current file.     * Returns false if the process was interrupted because the thread is marked     * to exit.    */
DECL|method|assignInitialVerificationTimes ()
specifier|private
name|boolean
name|assignInitialVerificationTimes
parameter_list|()
block|{
name|int
name|numBlocks
init|=
literal|1
decl_stmt|;
name|LogFileHandler
name|log
init|=
literal|null
decl_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
name|log
operator|=
name|verificationLog
expr_stmt|;
name|numBlocks
operator|=
name|Math
operator|.
name|max
argument_list|(
name|blockMap
operator|.
name|size
argument_list|()
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|long
name|now
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|LogFileHandler
operator|.
name|Reader
name|logReader
index|[]
init|=
operator|new
name|LogFileHandler
operator|.
name|Reader
index|[
literal|2
index|]
decl_stmt|;
try|try
block|{
if|if
condition|(
name|log
operator|!=
literal|null
condition|)
block|{
name|logReader
index|[
literal|0
index|]
operator|=
name|log
operator|.
name|getCurrentFileReader
argument_list|()
expr_stmt|;
name|logReader
index|[
literal|1
index|]
operator|=
name|log
operator|.
name|getPreviousFileReader
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Could not read previous verification times"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
try|try
block|{
for|for
control|(
name|LogFileHandler
operator|.
name|Reader
name|reader
range|:
name|logReader
control|)
block|{
comment|// update verification times from the verificationLog.
while|while
condition|(
name|logReader
operator|!=
literal|null
operator|&&
name|reader
operator|.
name|hasNext
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|datanode
operator|.
name|shouldRun
operator|||
name|datanode
operator|.
name|blockScanner
operator|.
name|blockScannerThread
operator|.
name|isInterrupted
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
name|LogEntry
name|entry
init|=
name|LogEntry
operator|.
name|parseEntry
argument_list|(
name|reader
operator|.
name|next
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|entry
operator|!=
literal|null
condition|)
block|{
name|updateBlockInfo
argument_list|(
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|now
operator|-
name|entry
operator|.
name|verificationTime
operator|<
name|scanPeriod
condition|)
block|{
name|BlockScanInfo
name|info
init|=
name|blockMap
operator|.
name|get
argument_list|(
operator|new
name|Block
argument_list|(
name|entry
operator|.
name|blockId
argument_list|,
literal|0
argument_list|,
name|entry
operator|.
name|genStamp
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|info
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|processedBlocks
operator|.
name|get
argument_list|(
name|entry
operator|.
name|blockId
argument_list|)
operator|==
literal|null
condition|)
block|{
name|updateBytesLeft
argument_list|(
operator|-
name|info
operator|.
name|block
operator|.
name|getNumBytes
argument_list|()
argument_list|)
expr_stmt|;
name|processedBlocks
operator|.
name|put
argument_list|(
name|entry
operator|.
name|blockId
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|reader
operator|.
name|file
operator|==
name|log
operator|.
name|prevFile
condition|)
block|{
comment|// write the log entry to current file
comment|// so that the entry is preserved for later runs.
name|log
operator|.
name|appendLine
argument_list|(
name|entry
operator|.
name|verificationTime
argument_list|,
name|entry
operator|.
name|genStamp
argument_list|,
name|entry
operator|.
name|blockId
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
block|}
finally|finally
block|{
name|IOUtils
operator|.
name|closeStream
argument_list|(
name|logReader
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|IOUtils
operator|.
name|closeStream
argument_list|(
name|logReader
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Initially spread the block reads over half of       * MIN_SCAN_PERIOD so that we don't keep scanning the       * blocks too quickly when restarted.      */
name|long
name|verifyInterval
init|=
call|(
name|long
call|)
argument_list|(
name|Math
operator|.
name|min
argument_list|(
name|scanPeriod
operator|/
literal|2.0
operator|/
name|numBlocks
argument_list|,
literal|10
operator|*
literal|60
operator|*
literal|1000
argument_list|)
argument_list|)
decl_stmt|;
name|long
name|lastScanTime
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|scanPeriod
decl_stmt|;
comment|/* Before this loop, entries in blockInfoSet that are not      * updated above have lastScanTime of<= 0 . Loop until first entry has      * lastModificationTime> 0.      */
synchronized|synchronized
init|(
name|this
init|)
block|{
if|if
condition|(
name|blockInfoSet
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|BlockScanInfo
name|info
decl_stmt|;
while|while
condition|(
operator|(
name|info
operator|=
name|blockInfoSet
operator|.
name|first
argument_list|()
operator|)
operator|.
name|lastScanTime
operator|<
literal|0
condition|)
block|{
name|delBlockInfo
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|info
operator|.
name|lastScanTime
operator|=
name|lastScanTime
expr_stmt|;
name|lastScanTime
operator|+=
name|verifyInterval
expr_stmt|;
name|addBlockInfo
argument_list|(
name|info
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
literal|true
return|;
block|}
DECL|method|updateBytesLeft (long len)
specifier|private
specifier|synchronized
name|void
name|updateBytesLeft
parameter_list|(
name|long
name|len
parameter_list|)
block|{
name|bytesLeft
operator|+=
name|len
expr_stmt|;
block|}
DECL|method|getCurrentFile (FSVolume vol, String bpid)
specifier|static
name|File
name|getCurrentFile
parameter_list|(
name|FSVolume
name|vol
parameter_list|,
name|String
name|bpid
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|LogFileHandler
operator|.
name|getCurrentFile
argument_list|(
name|vol
operator|.
name|getBlockPoolSlice
argument_list|(
name|bpid
argument_list|)
operator|.
name|getDirectory
argument_list|()
argument_list|,
name|BlockPoolSliceScanner
operator|.
name|verificationLogFile
argument_list|)
return|;
block|}
DECL|method|startNewPeriod ()
specifier|private
specifier|synchronized
name|void
name|startNewPeriod
parameter_list|()
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Starting a new period : work left in prev period : "
operator|+
name|String
operator|.
name|format
argument_list|(
literal|"%.2f%%"
argument_list|,
name|totalBytesToScan
operator|==
literal|0
condition|?
literal|0
else|:
operator|(
name|bytesLeft
operator|*
literal|100.0
operator|)
operator|/
name|totalBytesToScan
argument_list|)
argument_list|)
expr_stmt|;
comment|// reset the byte counts :
name|bytesLeft
operator|=
name|totalBytesToScan
expr_stmt|;
name|currentPeriodStart
operator|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
expr_stmt|;
block|}
DECL|method|scanBlockPoolSlice ()
name|void
name|scanBlockPoolSlice
parameter_list|()
block|{
name|startNewPeriod
argument_list|()
expr_stmt|;
if|if
condition|(
name|processedBlocks
operator|!=
literal|null
condition|)
block|{
name|totalBlocksScannedInLastRun
operator|=
name|processedBlocks
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
comment|// Create a new processedBlocks structure
name|processedBlocks
operator|=
operator|new
name|HashMap
argument_list|<
name|Long
argument_list|,
name|Integer
argument_list|>
argument_list|()
expr_stmt|;
if|if
condition|(
name|verificationLog
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|verificationLog
operator|.
name|openCurFile
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Could not open current file"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|assignInitialVerificationTimes
argument_list|()
condition|)
block|{
return|return;
block|}
comment|// Start scanning
name|scan
argument_list|()
expr_stmt|;
block|}
DECL|method|scan ()
specifier|public
name|void
name|scan
parameter_list|()
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Starting to scan blockpool: "
operator|+
name|blockPoolId
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|adjustThrottler
argument_list|()
expr_stmt|;
while|while
condition|(
name|datanode
operator|.
name|shouldRun
operator|&&
operator|!
name|Thread
operator|.
name|interrupted
argument_list|()
operator|&&
name|datanode
operator|.
name|isBPServiceAlive
argument_list|(
name|blockPoolId
argument_list|)
condition|)
block|{
name|long
name|now
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
if|if
condition|(
name|now
operator|>=
operator|(
name|currentPeriodStart
operator|+
name|scanPeriod
operator|)
condition|)
block|{
name|startNewPeriod
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
operator|(
name|now
operator|-
name|getEarliestScanTime
argument_list|()
operator|)
operator|>=
name|scanPeriod
operator|)
operator|||
operator|(
operator|!
operator|(
name|this
operator|.
name|isFirstBlockProcessed
argument_list|()
operator|)
operator|)
condition|)
block|{
name|verifyFirstBlock
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"All remaining blocks were processed recently, "
operator|+
literal|"so this run is complete"
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|RuntimeException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"RuntimeException during BlockPoolScanner.scan()"
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
finally|finally
block|{
name|cleanUp
argument_list|()
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Done scanning block pool: "
operator|+
name|blockPoolId
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|cleanUp ()
specifier|private
specifier|synchronized
name|void
name|cleanUp
parameter_list|()
block|{
if|if
condition|(
name|verificationLog
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|verificationLog
operator|.
name|roll
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Received exception: "
argument_list|,
name|ex
argument_list|)
expr_stmt|;
name|verificationLog
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
block|}
DECL|method|printBlockReport (StringBuilder buffer, boolean summaryOnly)
specifier|synchronized
name|void
name|printBlockReport
parameter_list|(
name|StringBuilder
name|buffer
parameter_list|,
name|boolean
name|summaryOnly
parameter_list|)
block|{
name|long
name|oneHour
init|=
literal|3600
operator|*
literal|1000
decl_stmt|;
name|long
name|oneDay
init|=
literal|24
operator|*
name|oneHour
decl_stmt|;
name|long
name|oneWeek
init|=
literal|7
operator|*
name|oneDay
decl_stmt|;
name|long
name|fourWeeks
init|=
literal|4
operator|*
name|oneWeek
decl_stmt|;
name|int
name|inOneHour
init|=
literal|0
decl_stmt|;
name|int
name|inOneDay
init|=
literal|0
decl_stmt|;
name|int
name|inOneWeek
init|=
literal|0
decl_stmt|;
name|int
name|inFourWeeks
init|=
literal|0
decl_stmt|;
name|int
name|inScanPeriod
init|=
literal|0
decl_stmt|;
name|int
name|neverScanned
init|=
literal|0
decl_stmt|;
name|DateFormat
name|dateFormat
init|=
operator|new
name|SimpleDateFormat
argument_list|(
name|dateFormatString
argument_list|)
decl_stmt|;
name|int
name|total
init|=
name|blockInfoSet
operator|.
name|size
argument_list|()
decl_stmt|;
name|long
name|now
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|Date
name|date
init|=
operator|new
name|Date
argument_list|()
decl_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|BlockScanInfo
argument_list|>
name|it
init|=
name|blockInfoSet
operator|.
name|iterator
argument_list|()
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|BlockScanInfo
name|info
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|long
name|scanTime
init|=
name|info
operator|.
name|getLastScanTime
argument_list|()
decl_stmt|;
name|long
name|diff
init|=
name|now
operator|-
name|scanTime
decl_stmt|;
if|if
condition|(
name|diff
operator|<=
name|oneHour
condition|)
name|inOneHour
operator|++
expr_stmt|;
if|if
condition|(
name|diff
operator|<=
name|oneDay
condition|)
name|inOneDay
operator|++
expr_stmt|;
if|if
condition|(
name|diff
operator|<=
name|oneWeek
condition|)
name|inOneWeek
operator|++
expr_stmt|;
if|if
condition|(
name|diff
operator|<=
name|fourWeeks
condition|)
name|inFourWeeks
operator|++
expr_stmt|;
if|if
condition|(
name|diff
operator|<=
name|scanPeriod
condition|)
name|inScanPeriod
operator|++
expr_stmt|;
if|if
condition|(
name|scanTime
operator|<=
literal|0
condition|)
name|neverScanned
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|summaryOnly
condition|)
block|{
name|date
operator|.
name|setTime
argument_list|(
name|scanTime
argument_list|)
expr_stmt|;
name|String
name|scanType
init|=
operator|(
name|info
operator|.
name|lastScanType
operator|==
name|ScanType
operator|.
name|VERIFICATION_SCAN
operator|)
condition|?
literal|"local"
else|:
literal|"none"
decl_stmt|;
name|buffer
operator|.
name|append
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"%-26s : status : %-6s type : %-6s"
operator|+
literal|" scan time : "
operator|+
literal|"%-15d %s\n"
argument_list|,
name|info
operator|.
name|block
argument_list|,
operator|(
name|info
operator|.
name|lastScanOk
condition|?
literal|"ok"
else|:
literal|"failed"
operator|)
argument_list|,
name|scanType
argument_list|,
name|scanTime
argument_list|,
operator|(
name|scanTime
operator|<=
literal|0
operator|)
condition|?
literal|"not yet verified"
else|:
name|dateFormat
operator|.
name|format
argument_list|(
name|date
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|double
name|pctPeriodLeft
init|=
operator|(
name|scanPeriod
operator|+
name|currentPeriodStart
operator|-
name|now
operator|)
operator|*
literal|100.0
operator|/
name|scanPeriod
decl_stmt|;
name|double
name|pctProgress
init|=
operator|(
name|totalBytesToScan
operator|==
literal|0
operator|)
condition|?
literal|100
else|:
operator|(
name|totalBytesToScan
operator|-
name|bytesLeft
operator|)
operator|*
literal|100.0
operator|/
name|totalBytesToScan
decl_stmt|;
name|buffer
operator|.
name|append
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"\nTotal Blocks                 : %6d"
operator|+
literal|"\nVerified in last hour        : %6d"
operator|+
literal|"\nVerified in last day         : %6d"
operator|+
literal|"\nVerified in last week        : %6d"
operator|+
literal|"\nVerified in last four weeks  : %6d"
operator|+
literal|"\nVerified in SCAN_PERIOD      : %6d"
operator|+
literal|"\nNot yet verified             : %6d"
operator|+
literal|"\nVerified since restart       : %6d"
operator|+
literal|"\nScans since restart          : %6d"
operator|+
literal|"\nScan errors since restart    : %6d"
operator|+
literal|"\nTransient scan errors        : %6d"
operator|+
literal|"\nCurrent scan rate limit KBps : %6d"
operator|+
literal|"\nProgress this period         : %6.0f%%"
operator|+
literal|"\nTime left in cur period      : %6.2f%%"
operator|+
literal|"\n"
argument_list|,
name|total
argument_list|,
name|inOneHour
argument_list|,
name|inOneDay
argument_list|,
name|inOneWeek
argument_list|,
name|inFourWeeks
argument_list|,
name|inScanPeriod
argument_list|,
name|neverScanned
argument_list|,
name|totalScans
argument_list|,
name|totalScans
argument_list|,
name|totalScanErrors
argument_list|,
name|totalTransientErrors
argument_list|,
name|Math
operator|.
name|round
argument_list|(
name|throttler
operator|.
name|getBandwidth
argument_list|()
operator|/
literal|1024.0
argument_list|)
argument_list|,
name|pctProgress
argument_list|,
name|pctPeriodLeft
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * This class takes care of log file used to store the last verification    * times of the blocks. It rolls the current file when it is too big etc.    * If there is an error while writing, it stops updating with an error    * message.    */
DECL|class|LogFileHandler
specifier|private
specifier|static
class|class
name|LogFileHandler
block|{
DECL|field|curFileSuffix
specifier|private
specifier|static
specifier|final
name|String
name|curFileSuffix
init|=
literal|".curr"
decl_stmt|;
DECL|field|prevFileSuffix
specifier|private
specifier|static
specifier|final
name|String
name|prevFileSuffix
init|=
literal|".prev"
decl_stmt|;
DECL|field|dateFormat
specifier|private
specifier|final
name|DateFormat
name|dateFormat
init|=
operator|new
name|SimpleDateFormat
argument_list|(
name|dateFormatString
argument_list|)
decl_stmt|;
DECL|method|getCurrentFile (File dir, String filePrefix)
specifier|static
name|File
name|getCurrentFile
parameter_list|(
name|File
name|dir
parameter_list|,
name|String
name|filePrefix
parameter_list|)
block|{
return|return
operator|new
name|File
argument_list|(
name|dir
argument_list|,
name|filePrefix
operator|+
name|curFileSuffix
argument_list|)
return|;
block|}
DECL|method|getPreviousFileReader ()
specifier|public
name|Reader
name|getPreviousFileReader
parameter_list|()
throws|throws
name|IOException
block|{
return|return
operator|new
name|Reader
argument_list|(
name|prevFile
argument_list|)
return|;
block|}
DECL|method|getCurrentFileReader ()
specifier|public
name|Reader
name|getCurrentFileReader
parameter_list|()
throws|throws
name|IOException
block|{
return|return
operator|new
name|Reader
argument_list|(
name|curFile
argument_list|)
return|;
block|}
DECL|method|isFilePresent (File dir, String filePrefix)
specifier|static
name|boolean
name|isFilePresent
parameter_list|(
name|File
name|dir
parameter_list|,
name|String
name|filePrefix
parameter_list|)
block|{
return|return
operator|new
name|File
argument_list|(
name|dir
argument_list|,
name|filePrefix
operator|+
name|curFileSuffix
argument_list|)
operator|.
name|exists
argument_list|()
operator|||
operator|new
name|File
argument_list|(
name|dir
argument_list|,
name|filePrefix
operator|+
name|prevFileSuffix
argument_list|)
operator|.
name|exists
argument_list|()
return|;
block|}
DECL|field|curFile
specifier|private
name|File
name|curFile
decl_stmt|;
DECL|field|prevFile
specifier|private
name|File
name|prevFile
decl_stmt|;
DECL|field|out
specifier|private
name|PrintStream
name|out
decl_stmt|;
comment|/**      * Opens the log file for appending.      * Note that rolling will happen only after "updateLineCount()" is       * called. This is so that line count could be updated in a separate      * thread without delaying start up.      *       * @param dir where the logs files are located.      * @param filePrefix prefix of the file.      * @param maxNumLines max lines in a file (its a soft limit).      * @throws IOException      */
DECL|method|LogFileHandler (File dir, String filePrefix, int maxNumLines)
name|LogFileHandler
parameter_list|(
name|File
name|dir
parameter_list|,
name|String
name|filePrefix
parameter_list|,
name|int
name|maxNumLines
parameter_list|)
throws|throws
name|IOException
block|{
name|curFile
operator|=
operator|new
name|File
argument_list|(
name|dir
argument_list|,
name|filePrefix
operator|+
name|curFileSuffix
argument_list|)
expr_stmt|;
name|prevFile
operator|=
operator|new
name|File
argument_list|(
name|dir
argument_list|,
name|filePrefix
operator|+
name|prevFileSuffix
argument_list|)
expr_stmt|;
block|}
comment|/**      * Append "\n" + line.      * If the log file need to be rolled, it will done after       * appending the text.      * This does not throw IOException when there is an error while       * appending. Currently does not throw an error even if rolling       * fails (may be it should?).      * return true if append was successful.      */
DECL|method|appendLine (String line)
specifier|synchronized
name|boolean
name|appendLine
parameter_list|(
name|String
name|line
parameter_list|)
block|{
if|if
condition|(
name|out
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
name|out
operator|.
name|println
argument_list|()
expr_stmt|;
name|out
operator|.
name|print
argument_list|(
name|line
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
DECL|method|appendLine (long verificationTime, long genStamp, long blockId)
name|boolean
name|appendLine
parameter_list|(
name|long
name|verificationTime
parameter_list|,
name|long
name|genStamp
parameter_list|,
name|long
name|blockId
parameter_list|)
block|{
return|return
name|appendLine
argument_list|(
literal|"date=\""
operator|+
name|dateFormat
operator|.
name|format
argument_list|(
operator|new
name|Date
argument_list|(
name|verificationTime
argument_list|)
argument_list|)
operator|+
literal|"\"\t "
operator|+
literal|"time=\""
operator|+
name|verificationTime
operator|+
literal|"\"\t "
operator|+
literal|"genstamp=\""
operator|+
name|genStamp
operator|+
literal|"\"\t "
operator|+
literal|"id=\""
operator|+
name|blockId
operator|+
literal|"\""
argument_list|)
return|;
block|}
DECL|method|openCurFile ()
specifier|private
specifier|synchronized
name|void
name|openCurFile
parameter_list|()
throws|throws
name|FileNotFoundException
block|{
name|close
argument_list|()
expr_stmt|;
name|out
operator|=
operator|new
name|PrintStream
argument_list|(
operator|new
name|FileOutputStream
argument_list|(
name|curFile
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|roll ()
specifier|private
name|void
name|roll
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Rolling current file: "
operator|+
name|curFile
operator|.
name|getAbsolutePath
argument_list|()
operator|+
literal|" to previous file: "
operator|+
name|prevFile
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|prevFile
operator|.
name|delete
argument_list|()
operator|&&
name|prevFile
operator|.
name|exists
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Could not delete "
operator|+
name|prevFile
argument_list|)
throw|;
block|}
name|close
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|curFile
operator|.
name|renameTo
argument_list|(
name|prevFile
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Could not rename "
operator|+
name|curFile
operator|+
literal|" to "
operator|+
name|prevFile
argument_list|)
throw|;
block|}
block|}
DECL|method|close ()
specifier|synchronized
name|void
name|close
parameter_list|()
block|{
if|if
condition|(
name|out
operator|!=
literal|null
condition|)
block|{
name|out
operator|.
name|close
argument_list|()
expr_stmt|;
name|out
operator|=
literal|null
expr_stmt|;
block|}
block|}
comment|/**      * This is used to read the lines in order.      * If the data is not read completely (i.e, untill hasNext() returns      * false), it needs to be explicitly       */
DECL|class|Reader
specifier|private
specifier|static
class|class
name|Reader
implements|implements
name|Iterator
argument_list|<
name|String
argument_list|>
implements|,
name|Closeable
block|{
DECL|field|reader
name|BufferedReader
name|reader
decl_stmt|;
DECL|field|file
name|File
name|file
decl_stmt|;
DECL|field|line
name|String
name|line
decl_stmt|;
DECL|field|closed
name|boolean
name|closed
init|=
literal|false
decl_stmt|;
DECL|method|Reader (File file)
specifier|private
name|Reader
parameter_list|(
name|File
name|file
parameter_list|)
throws|throws
name|IOException
block|{
name|reader
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|file
operator|=
name|file
expr_stmt|;
name|readNext
argument_list|()
expr_stmt|;
block|}
DECL|method|openFile ()
specifier|private
name|boolean
name|openFile
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|file
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|reader
operator|!=
literal|null
condition|)
block|{
name|reader
operator|.
name|close
argument_list|()
expr_stmt|;
name|reader
operator|=
literal|null
expr_stmt|;
block|}
if|if
condition|(
name|file
operator|.
name|exists
argument_list|()
condition|)
block|{
name|reader
operator|=
operator|new
name|BufferedReader
argument_list|(
operator|new
name|FileReader
argument_list|(
name|file
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
comment|// read next line if possible.
DECL|method|readNext ()
specifier|private
name|void
name|readNext
parameter_list|()
throws|throws
name|IOException
block|{
name|line
operator|=
literal|null
expr_stmt|;
if|if
condition|(
name|reader
operator|==
literal|null
condition|)
block|{
name|openFile
argument_list|()
expr_stmt|;
block|}
try|try
block|{
if|if
condition|(
name|reader
operator|!=
literal|null
operator|&&
operator|(
name|line
operator|=
name|reader
operator|.
name|readLine
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
return|return;
block|}
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|hasNext
argument_list|()
condition|)
block|{
name|close
argument_list|()
expr_stmt|;
block|}
block|}
block|}
DECL|method|hasNext ()
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|line
operator|!=
literal|null
return|;
block|}
DECL|method|next ()
specifier|public
name|String
name|next
parameter_list|()
block|{
name|String
name|curLine
init|=
name|line
decl_stmt|;
try|try
block|{
name|readNext
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Could not read next line in LogHandler"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
name|curLine
return|;
block|}
DECL|method|remove ()
specifier|public
name|void
name|remove
parameter_list|()
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"remove() is not supported."
argument_list|)
throw|;
block|}
DECL|method|close ()
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|closed
condition|)
block|{
try|try
block|{
if|if
condition|(
name|reader
operator|!=
literal|null
condition|)
block|{
name|reader
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|file
operator|=
literal|null
expr_stmt|;
name|reader
operator|=
literal|null
expr_stmt|;
name|closed
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
end_class

end_unit

