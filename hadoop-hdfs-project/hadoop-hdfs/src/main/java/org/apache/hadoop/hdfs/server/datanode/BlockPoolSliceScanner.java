begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdfs.server.datanode
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileNotFoundException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|text
operator|.
name|DateFormat
import|;
end_import

begin_import
import|import
name|java
operator|.
name|text
operator|.
name|SimpleDateFormat
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Date
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|SortedSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicLong
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Matcher
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Pattern
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|Block
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|ExtendedBlock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|GenerationStamp
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|fsdataset
operator|.
name|FsDatasetSpi
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|fsdataset
operator|.
name|FsVolumeSpi
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|fsdataset
operator|.
name|RollingLogs
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|util
operator|.
name|DataTransferThrottler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|GSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|LightWeightGSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|LightWeightGSet
operator|.
name|LinkedElement
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Time
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_comment
comment|/**  * Scans the block files under a block pool and verifies that the  * files are not corrupt.  * This keeps track of blocks and their last verification times.  * Currently it does not modify the metadata for block.  */
end_comment

begin_class
DECL|class|BlockPoolSliceScanner
class|class
name|BlockPoolSliceScanner
block|{
DECL|field|LOG
specifier|public
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|BlockPoolSliceScanner
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|DATA_FORMAT
specifier|private
specifier|static
specifier|final
name|String
name|DATA_FORMAT
init|=
literal|"yyyy-MM-dd HH:mm:ss,SSS"
decl_stmt|;
DECL|field|MAX_SCAN_RATE
specifier|private
specifier|static
specifier|final
name|int
name|MAX_SCAN_RATE
init|=
literal|8
operator|*
literal|1024
operator|*
literal|1024
decl_stmt|;
comment|// 8MB per sec
DECL|field|MIN_SCAN_RATE
specifier|private
specifier|static
specifier|final
name|int
name|MIN_SCAN_RATE
init|=
literal|1
operator|*
literal|1024
operator|*
literal|1024
decl_stmt|;
comment|// 1MB per sec
DECL|field|DEFAULT_SCAN_PERIOD_HOURS
specifier|private
specifier|static
specifier|final
name|long
name|DEFAULT_SCAN_PERIOD_HOURS
init|=
literal|21
operator|*
literal|24L
decl_stmt|;
comment|// three weeks
DECL|field|VERIFICATION_PREFIX
specifier|private
specifier|static
specifier|final
name|String
name|VERIFICATION_PREFIX
init|=
literal|"dncp_block_verification.log"
decl_stmt|;
DECL|field|blockPoolId
specifier|private
specifier|final
name|String
name|blockPoolId
decl_stmt|;
DECL|field|scanPeriod
specifier|private
specifier|final
name|long
name|scanPeriod
decl_stmt|;
DECL|field|lastScanTime
specifier|private
specifier|final
name|AtomicLong
name|lastScanTime
init|=
operator|new
name|AtomicLong
argument_list|()
decl_stmt|;
DECL|field|datanode
specifier|private
specifier|final
name|DataNode
name|datanode
decl_stmt|;
DECL|field|dataset
specifier|private
specifier|final
name|FsDatasetSpi
argument_list|<
name|?
extends|extends
name|FsVolumeSpi
argument_list|>
name|dataset
decl_stmt|;
DECL|field|blockInfoSet
specifier|private
specifier|final
name|SortedSet
argument_list|<
name|BlockScanInfo
argument_list|>
name|blockInfoSet
init|=
operator|new
name|TreeSet
argument_list|<
name|BlockScanInfo
argument_list|>
argument_list|(
name|BlockScanInfo
operator|.
name|LAST_SCAN_TIME_COMPARATOR
argument_list|)
decl_stmt|;
DECL|field|blockMap
specifier|private
specifier|final
name|GSet
argument_list|<
name|Block
argument_list|,
name|BlockScanInfo
argument_list|>
name|blockMap
init|=
operator|new
name|LightWeightGSet
argument_list|<
name|Block
argument_list|,
name|BlockScanInfo
argument_list|>
argument_list|(
name|LightWeightGSet
operator|.
name|computeCapacity
argument_list|(
literal|0.5
argument_list|,
literal|"BlockMap"
argument_list|)
argument_list|)
decl_stmt|;
comment|// processedBlocks keeps track of which blocks are scanned
comment|// since the last run.
DECL|field|processedBlocks
specifier|private
specifier|volatile
name|HashMap
argument_list|<
name|Long
argument_list|,
name|Integer
argument_list|>
name|processedBlocks
decl_stmt|;
DECL|field|totalScans
specifier|private
name|long
name|totalScans
init|=
literal|0
decl_stmt|;
DECL|field|totalScanErrors
specifier|private
name|long
name|totalScanErrors
init|=
literal|0
decl_stmt|;
DECL|field|totalTransientErrors
specifier|private
name|long
name|totalTransientErrors
init|=
literal|0
decl_stmt|;
DECL|field|totalBlocksScannedInLastRun
specifier|private
specifier|final
name|AtomicInteger
name|totalBlocksScannedInLastRun
init|=
operator|new
name|AtomicInteger
argument_list|()
decl_stmt|;
comment|// Used for test only
DECL|field|currentPeriodStart
specifier|private
name|long
name|currentPeriodStart
init|=
name|Time
operator|.
name|now
argument_list|()
decl_stmt|;
DECL|field|bytesLeft
specifier|private
name|long
name|bytesLeft
init|=
literal|0
decl_stmt|;
comment|// Bytes to scan in this period
DECL|field|totalBytesToScan
specifier|private
name|long
name|totalBytesToScan
init|=
literal|0
decl_stmt|;
DECL|field|isNewPeriod
specifier|private
name|boolean
name|isNewPeriod
init|=
literal|true
decl_stmt|;
DECL|field|verificationLog
specifier|private
specifier|final
name|LogFileHandler
name|verificationLog
decl_stmt|;
DECL|field|throttler
specifier|private
specifier|final
name|DataTransferThrottler
name|throttler
init|=
operator|new
name|DataTransferThrottler
argument_list|(
literal|200
argument_list|,
name|MAX_SCAN_RATE
argument_list|)
decl_stmt|;
DECL|enum|ScanType
specifier|private
specifier|static
enum|enum
name|ScanType
block|{
DECL|enumConstant|VERIFICATION_SCAN
name|VERIFICATION_SCAN
block|,
comment|// scanned as part of periodic verfication
DECL|enumConstant|NONE
name|NONE
block|,   }
comment|// Extend Block because in the DN process there's a 1-to-1 correspondence of
comment|// BlockScanInfo to Block instances, so by extending rather than containing
comment|// Block, we can save a bit of Object overhead (about 24 bytes per block
comment|// replica.)
DECL|class|BlockScanInfo
specifier|static
class|class
name|BlockScanInfo
extends|extends
name|Block
implements|implements
name|LightWeightGSet
operator|.
name|LinkedElement
block|{
comment|/** Compare the info by the last scan time. */
DECL|field|LAST_SCAN_TIME_COMPARATOR
specifier|static
specifier|final
name|Comparator
argument_list|<
name|BlockScanInfo
argument_list|>
name|LAST_SCAN_TIME_COMPARATOR
init|=
operator|new
name|Comparator
argument_list|<
name|BlockPoolSliceScanner
operator|.
name|BlockScanInfo
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|int
name|compare
parameter_list|(
name|BlockScanInfo
name|left
parameter_list|,
name|BlockScanInfo
name|right
parameter_list|)
block|{
specifier|final
name|long
name|l
init|=
name|left
operator|.
name|lastScanTime
decl_stmt|;
specifier|final
name|long
name|r
init|=
name|right
operator|.
name|lastScanTime
decl_stmt|;
comment|// compare blocks itself if scantimes are same to avoid.
comment|// because TreeMap uses comparator if available to check existence of
comment|// the object.
return|return
name|l
operator|<
name|r
condition|?
operator|-
literal|1
else|:
name|l
operator|>
name|r
condition|?
literal|1
else|:
name|left
operator|.
name|compareTo
argument_list|(
name|right
argument_list|)
return|;
block|}
block|}
decl_stmt|;
DECL|field|lastScanTime
name|long
name|lastScanTime
init|=
literal|0
decl_stmt|;
DECL|field|lastScanType
name|ScanType
name|lastScanType
init|=
name|ScanType
operator|.
name|NONE
decl_stmt|;
DECL|field|lastScanOk
name|boolean
name|lastScanOk
init|=
literal|true
decl_stmt|;
DECL|field|next
specifier|private
name|LinkedElement
name|next
decl_stmt|;
DECL|method|BlockScanInfo (Block block)
name|BlockScanInfo
parameter_list|(
name|Block
name|block
parameter_list|)
block|{
name|super
argument_list|(
name|block
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|hashCode ()
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|super
operator|.
name|hashCode
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|equals (Object that)
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|that
parameter_list|)
block|{
if|if
condition|(
name|this
operator|==
name|that
condition|)
block|{
return|return
literal|true
return|;
block|}
return|return
name|super
operator|.
name|equals
argument_list|(
name|that
argument_list|)
return|;
block|}
DECL|method|getLastScanTime ()
name|long
name|getLastScanTime
parameter_list|()
block|{
return|return
operator|(
name|lastScanType
operator|==
name|ScanType
operator|.
name|NONE
operator|)
condition|?
literal|0
else|:
name|lastScanTime
return|;
block|}
annotation|@
name|Override
DECL|method|setNext (LinkedElement next)
specifier|public
name|void
name|setNext
parameter_list|(
name|LinkedElement
name|next
parameter_list|)
block|{
name|this
operator|.
name|next
operator|=
name|next
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getNext ()
specifier|public
name|LinkedElement
name|getNext
parameter_list|()
block|{
return|return
name|next
return|;
block|}
block|}
DECL|method|BlockPoolSliceScanner (String bpid, DataNode datanode, FsDatasetSpi<? extends FsVolumeSpi> dataset, Configuration conf)
name|BlockPoolSliceScanner
parameter_list|(
name|String
name|bpid
parameter_list|,
name|DataNode
name|datanode
parameter_list|,
name|FsDatasetSpi
argument_list|<
name|?
extends|extends
name|FsVolumeSpi
argument_list|>
name|dataset
parameter_list|,
name|Configuration
name|conf
parameter_list|)
block|{
name|this
operator|.
name|datanode
operator|=
name|datanode
expr_stmt|;
name|this
operator|.
name|dataset
operator|=
name|dataset
expr_stmt|;
name|this
operator|.
name|blockPoolId
operator|=
name|bpid
expr_stmt|;
name|long
name|hours
init|=
name|conf
operator|.
name|getInt
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_DATANODE_SCAN_PERIOD_HOURS_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_DATANODE_SCAN_PERIOD_HOURS_DEFAULT
argument_list|)
decl_stmt|;
if|if
condition|(
name|hours
operator|<=
literal|0
condition|)
block|{
name|hours
operator|=
name|DEFAULT_SCAN_PERIOD_HOURS
expr_stmt|;
block|}
name|this
operator|.
name|scanPeriod
operator|=
name|hours
operator|*
literal|3600
operator|*
literal|1000
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Periodic Block Verification Scanner initialized with interval "
operator|+
name|hours
operator|+
literal|" hours for block pool "
operator|+
name|bpid
argument_list|)
expr_stmt|;
comment|// get the list of blocks and arrange them in random order
name|List
argument_list|<
name|FinalizedReplica
argument_list|>
name|arr
init|=
name|dataset
operator|.
name|getFinalizedBlocks
argument_list|(
name|blockPoolId
argument_list|)
decl_stmt|;
name|Collections
operator|.
name|shuffle
argument_list|(
name|arr
argument_list|)
expr_stmt|;
name|long
name|scanTime
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|Block
name|block
range|:
name|arr
control|)
block|{
name|BlockScanInfo
name|info
init|=
operator|new
name|BlockScanInfo
argument_list|(
name|block
argument_list|)
decl_stmt|;
name|info
operator|.
name|lastScanTime
operator|=
name|scanTime
operator|--
expr_stmt|;
comment|//still keep 'info.lastScanType' to NONE.
name|addBlockInfo
argument_list|(
name|info
argument_list|)
expr_stmt|;
block|}
name|RollingLogs
name|rollingLogs
init|=
literal|null
decl_stmt|;
try|try
block|{
name|rollingLogs
operator|=
name|dataset
operator|.
name|createRollingLogs
argument_list|(
name|blockPoolId
argument_list|,
name|VERIFICATION_PREFIX
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Could not open verfication log. "
operator|+
literal|"Verification times are not stored."
argument_list|)
expr_stmt|;
block|}
name|verificationLog
operator|=
name|rollingLogs
operator|==
literal|null
condition|?
literal|null
else|:
operator|new
name|LogFileHandler
argument_list|(
name|rollingLogs
argument_list|)
expr_stmt|;
block|}
DECL|method|getBlockPoolId ()
name|String
name|getBlockPoolId
parameter_list|()
block|{
return|return
name|blockPoolId
return|;
block|}
DECL|method|updateBytesToScan (long len, long lastScanTime)
specifier|private
name|void
name|updateBytesToScan
parameter_list|(
name|long
name|len
parameter_list|,
name|long
name|lastScanTime
parameter_list|)
block|{
comment|// len could be negative when a block is deleted.
name|totalBytesToScan
operator|+=
name|len
expr_stmt|;
if|if
condition|(
name|lastScanTime
operator|<
name|currentPeriodStart
condition|)
block|{
name|bytesLeft
operator|+=
name|len
expr_stmt|;
block|}
comment|// Should we change throttler bandwidth every time bytesLeft changes?
comment|// not really required.
block|}
DECL|method|addBlockInfo (BlockScanInfo info)
specifier|private
specifier|synchronized
name|void
name|addBlockInfo
parameter_list|(
name|BlockScanInfo
name|info
parameter_list|)
block|{
name|boolean
name|added
init|=
name|blockInfoSet
operator|.
name|add
argument_list|(
name|info
argument_list|)
decl_stmt|;
name|blockMap
operator|.
name|put
argument_list|(
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|added
condition|)
block|{
name|updateBytesToScan
argument_list|(
name|info
operator|.
name|getNumBytes
argument_list|()
argument_list|,
name|info
operator|.
name|lastScanTime
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|delBlockInfo (BlockScanInfo info)
specifier|private
specifier|synchronized
name|void
name|delBlockInfo
parameter_list|(
name|BlockScanInfo
name|info
parameter_list|)
block|{
name|boolean
name|exists
init|=
name|blockInfoSet
operator|.
name|remove
argument_list|(
name|info
argument_list|)
decl_stmt|;
name|blockMap
operator|.
name|remove
argument_list|(
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|exists
condition|)
block|{
name|updateBytesToScan
argument_list|(
operator|-
name|info
operator|.
name|getNumBytes
argument_list|()
argument_list|,
name|info
operator|.
name|lastScanTime
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Update blockMap by the given LogEntry */
DECL|method|updateBlockInfo (LogEntry e)
specifier|private
specifier|synchronized
name|void
name|updateBlockInfo
parameter_list|(
name|LogEntry
name|e
parameter_list|)
block|{
name|BlockScanInfo
name|info
init|=
name|blockMap
operator|.
name|get
argument_list|(
operator|new
name|Block
argument_list|(
name|e
operator|.
name|blockId
argument_list|,
literal|0
argument_list|,
name|e
operator|.
name|genStamp
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|info
operator|!=
literal|null
operator|&&
name|e
operator|.
name|verificationTime
operator|>
literal|0
operator|&&
name|info
operator|.
name|lastScanTime
operator|<
name|e
operator|.
name|verificationTime
condition|)
block|{
name|delBlockInfo
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|info
operator|.
name|lastScanTime
operator|=
name|e
operator|.
name|verificationTime
expr_stmt|;
name|info
operator|.
name|lastScanType
operator|=
name|ScanType
operator|.
name|VERIFICATION_SCAN
expr_stmt|;
name|addBlockInfo
argument_list|(
name|info
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|getNewBlockScanTime ()
specifier|private
specifier|synchronized
name|long
name|getNewBlockScanTime
parameter_list|()
block|{
comment|/* If there are a lot of blocks, this returns a random time with in       * the scan period. Otherwise something sooner.      */
name|long
name|period
init|=
name|Math
operator|.
name|min
argument_list|(
name|scanPeriod
argument_list|,
name|Math
operator|.
name|max
argument_list|(
name|blockMap
operator|.
name|size
argument_list|()
argument_list|,
literal|1
argument_list|)
operator|*
literal|600
operator|*
literal|1000L
argument_list|)
decl_stmt|;
name|int
name|periodInt
init|=
name|Math
operator|.
name|abs
argument_list|(
operator|(
name|int
operator|)
name|period
argument_list|)
decl_stmt|;
return|return
name|Time
operator|.
name|now
argument_list|()
operator|-
name|scanPeriod
operator|+
name|DFSUtil
operator|.
name|getRandom
argument_list|()
operator|.
name|nextInt
argument_list|(
name|periodInt
argument_list|)
return|;
block|}
comment|/** Adds block to list of blocks */
DECL|method|addBlock (ExtendedBlock block)
specifier|synchronized
name|void
name|addBlock
parameter_list|(
name|ExtendedBlock
name|block
parameter_list|)
block|{
name|BlockScanInfo
name|info
init|=
name|blockMap
operator|.
name|get
argument_list|(
name|block
operator|.
name|getLocalBlock
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|info
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Adding an already existing block "
operator|+
name|block
argument_list|)
expr_stmt|;
name|delBlockInfo
argument_list|(
name|info
argument_list|)
expr_stmt|;
block|}
name|info
operator|=
operator|new
name|BlockScanInfo
argument_list|(
name|block
operator|.
name|getLocalBlock
argument_list|()
argument_list|)
expr_stmt|;
name|info
operator|.
name|lastScanTime
operator|=
name|getNewBlockScanTime
argument_list|()
expr_stmt|;
name|addBlockInfo
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|adjustThrottler
argument_list|()
expr_stmt|;
block|}
comment|/** Deletes the block from internal structures */
DECL|method|deleteBlock (Block block)
specifier|synchronized
name|void
name|deleteBlock
parameter_list|(
name|Block
name|block
parameter_list|)
block|{
name|BlockScanInfo
name|info
init|=
name|blockMap
operator|.
name|get
argument_list|(
name|block
argument_list|)
decl_stmt|;
if|if
condition|(
name|info
operator|!=
literal|null
condition|)
block|{
name|delBlockInfo
argument_list|(
name|info
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|VisibleForTesting
DECL|method|getTotalScans ()
name|long
name|getTotalScans
parameter_list|()
block|{
return|return
name|totalScans
return|;
block|}
comment|/** @return the last scan time for the block pool. */
DECL|method|getLastScanTime ()
name|long
name|getLastScanTime
parameter_list|()
block|{
return|return
name|lastScanTime
operator|.
name|get
argument_list|()
return|;
block|}
comment|/** @return the last scan time the given block. */
DECL|method|getLastScanTime (Block block)
specifier|synchronized
name|long
name|getLastScanTime
parameter_list|(
name|Block
name|block
parameter_list|)
block|{
name|BlockScanInfo
name|info
init|=
name|blockMap
operator|.
name|get
argument_list|(
name|block
argument_list|)
decl_stmt|;
return|return
name|info
operator|==
literal|null
condition|?
literal|0
else|:
name|info
operator|.
name|lastScanTime
return|;
block|}
comment|/** Deletes blocks from internal structures */
DECL|method|deleteBlocks (Block[] blocks)
name|void
name|deleteBlocks
parameter_list|(
name|Block
index|[]
name|blocks
parameter_list|)
block|{
for|for
control|(
name|Block
name|b
range|:
name|blocks
control|)
block|{
name|deleteBlock
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|updateScanStatus (Block block, ScanType type, boolean scanOk)
specifier|private
specifier|synchronized
name|void
name|updateScanStatus
parameter_list|(
name|Block
name|block
parameter_list|,
name|ScanType
name|type
parameter_list|,
name|boolean
name|scanOk
parameter_list|)
block|{
name|BlockScanInfo
name|info
init|=
name|blockMap
operator|.
name|get
argument_list|(
name|block
argument_list|)
decl_stmt|;
if|if
condition|(
name|info
operator|!=
literal|null
condition|)
block|{
name|delBlockInfo
argument_list|(
name|info
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// It might already be removed. Thats ok, it will be caught next time.
name|info
operator|=
operator|new
name|BlockScanInfo
argument_list|(
name|block
argument_list|)
expr_stmt|;
block|}
name|long
name|now
init|=
name|Time
operator|.
name|now
argument_list|()
decl_stmt|;
name|info
operator|.
name|lastScanType
operator|=
name|type
expr_stmt|;
name|info
operator|.
name|lastScanTime
operator|=
name|now
expr_stmt|;
name|info
operator|.
name|lastScanOk
operator|=
name|scanOk
expr_stmt|;
name|addBlockInfo
argument_list|(
name|info
argument_list|)
expr_stmt|;
comment|// Don't update meta data if the verification failed.
if|if
condition|(
operator|!
name|scanOk
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|verificationLog
operator|!=
literal|null
condition|)
block|{
name|verificationLog
operator|.
name|append
argument_list|(
name|now
argument_list|,
name|block
operator|.
name|getGenerationStamp
argument_list|()
argument_list|,
name|block
operator|.
name|getBlockId
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|handleScanFailure (ExtendedBlock block)
specifier|private
name|void
name|handleScanFailure
parameter_list|(
name|ExtendedBlock
name|block
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Reporting bad "
operator|+
name|block
argument_list|)
expr_stmt|;
try|try
block|{
name|datanode
operator|.
name|reportBadBlocks
argument_list|(
name|block
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ie
parameter_list|)
block|{
comment|// it is bad, but not bad enough to shutdown the scanner
name|LOG
operator|.
name|warn
argument_list|(
literal|"Cannot report bad "
operator|+
name|block
operator|.
name|getBlockId
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|class|LogEntry
specifier|static
specifier|private
class|class
name|LogEntry
block|{
DECL|field|blockId
name|long
name|blockId
init|=
operator|-
literal|1
decl_stmt|;
DECL|field|verificationTime
name|long
name|verificationTime
init|=
operator|-
literal|1
decl_stmt|;
DECL|field|genStamp
name|long
name|genStamp
init|=
name|GenerationStamp
operator|.
name|GRANDFATHER_GENERATION_STAMP
decl_stmt|;
comment|/**      * The format consists of single line with multiple entries. each       * entry is in the form : name="value".      * This simple text and easily extendable and easily parseable with a      * regex.      */
DECL|field|entryPattern
specifier|private
specifier|static
name|Pattern
name|entryPattern
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"\\G\\s*([^=\\p{Space}]+)=\"(.*?)\"\\s*"
argument_list|)
decl_stmt|;
DECL|method|toString (long verificationTime, long genStamp, long blockId, DateFormat dateFormat)
specifier|static
name|String
name|toString
parameter_list|(
name|long
name|verificationTime
parameter_list|,
name|long
name|genStamp
parameter_list|,
name|long
name|blockId
parameter_list|,
name|DateFormat
name|dateFormat
parameter_list|)
block|{
return|return
literal|"\ndate=\""
operator|+
name|dateFormat
operator|.
name|format
argument_list|(
operator|new
name|Date
argument_list|(
name|verificationTime
argument_list|)
argument_list|)
operator|+
literal|"\"\t time=\""
operator|+
name|verificationTime
operator|+
literal|"\"\t genstamp=\""
operator|+
name|genStamp
operator|+
literal|"\"\t id=\""
operator|+
name|blockId
operator|+
literal|"\""
return|;
block|}
DECL|method|parseEntry (String line)
specifier|static
name|LogEntry
name|parseEntry
parameter_list|(
name|String
name|line
parameter_list|)
block|{
name|LogEntry
name|entry
init|=
operator|new
name|LogEntry
argument_list|()
decl_stmt|;
name|Matcher
name|matcher
init|=
name|entryPattern
operator|.
name|matcher
argument_list|(
name|line
argument_list|)
decl_stmt|;
while|while
condition|(
name|matcher
operator|.
name|find
argument_list|()
condition|)
block|{
name|String
name|name
init|=
name|matcher
operator|.
name|group
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|String
name|value
init|=
name|matcher
operator|.
name|group
argument_list|(
literal|2
argument_list|)
decl_stmt|;
try|try
block|{
if|if
condition|(
name|name
operator|.
name|equals
argument_list|(
literal|"id"
argument_list|)
condition|)
block|{
name|entry
operator|.
name|blockId
operator|=
name|Long
operator|.
name|valueOf
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|name
operator|.
name|equals
argument_list|(
literal|"time"
argument_list|)
condition|)
block|{
name|entry
operator|.
name|verificationTime
operator|=
name|Long
operator|.
name|valueOf
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|name
operator|.
name|equals
argument_list|(
literal|"genstamp"
argument_list|)
condition|)
block|{
name|entry
operator|.
name|genStamp
operator|=
name|Long
operator|.
name|valueOf
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|nfe
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Cannot parse line: "
operator|+
name|line
argument_list|,
name|nfe
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
return|return
name|entry
return|;
block|}
block|}
DECL|method|adjustThrottler ()
specifier|private
specifier|synchronized
name|void
name|adjustThrottler
parameter_list|()
block|{
name|long
name|timeLeft
init|=
name|currentPeriodStart
operator|+
name|scanPeriod
operator|-
name|Time
operator|.
name|now
argument_list|()
decl_stmt|;
name|long
name|bw
init|=
name|Math
operator|.
name|max
argument_list|(
name|bytesLeft
operator|*
literal|1000
operator|/
name|timeLeft
argument_list|,
name|MIN_SCAN_RATE
argument_list|)
decl_stmt|;
name|throttler
operator|.
name|setBandwidth
argument_list|(
name|Math
operator|.
name|min
argument_list|(
name|bw
argument_list|,
name|MAX_SCAN_RATE
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|verifyBlock (ExtendedBlock block)
name|void
name|verifyBlock
parameter_list|(
name|ExtendedBlock
name|block
parameter_list|)
block|{
name|BlockSender
name|blockSender
init|=
literal|null
decl_stmt|;
comment|/* In case of failure, attempt to read second time to reduce      * transient errors. How do we flush block data from kernel       * buffers before the second read?       */
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|boolean
name|second
init|=
operator|(
name|i
operator|>
literal|0
operator|)
decl_stmt|;
try|try
block|{
name|adjustThrottler
argument_list|()
expr_stmt|;
name|blockSender
operator|=
operator|new
name|BlockSender
argument_list|(
name|block
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|,
name|datanode
argument_list|,
literal|null
argument_list|,
name|CachingStrategy
operator|.
name|newDropBehind
argument_list|()
argument_list|)
expr_stmt|;
name|DataOutputStream
name|out
init|=
operator|new
name|DataOutputStream
argument_list|(
operator|new
name|IOUtils
operator|.
name|NullOutputStream
argument_list|()
argument_list|)
decl_stmt|;
name|blockSender
operator|.
name|sendBlock
argument_list|(
name|out
argument_list|,
literal|null
argument_list|,
name|throttler
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
operator|(
name|second
condition|?
literal|"Second "
else|:
literal|""
operator|)
operator|+
literal|"Verification succeeded for "
operator|+
name|block
argument_list|)
expr_stmt|;
if|if
condition|(
name|second
condition|)
block|{
name|totalTransientErrors
operator|++
expr_stmt|;
block|}
name|updateScanStatus
argument_list|(
name|block
operator|.
name|getLocalBlock
argument_list|()
argument_list|,
name|ScanType
operator|.
name|VERIFICATION_SCAN
argument_list|,
literal|true
argument_list|)
expr_stmt|;
return|return;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|updateScanStatus
argument_list|(
name|block
operator|.
name|getLocalBlock
argument_list|()
argument_list|,
name|ScanType
operator|.
name|VERIFICATION_SCAN
argument_list|,
literal|false
argument_list|)
expr_stmt|;
comment|// If the block does not exists anymore, then its not an error
if|if
condition|(
operator|!
name|dataset
operator|.
name|contains
argument_list|(
name|block
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
name|block
operator|+
literal|" is no longer in the dataset"
argument_list|)
expr_stmt|;
name|deleteBlock
argument_list|(
name|block
operator|.
name|getLocalBlock
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// If the block exists, the exception may due to a race with write:
comment|// The BlockSender got an old block path in rbw. BlockReceiver removed
comment|// the rbw block from rbw to finalized but BlockSender tried to open the
comment|// file before BlockReceiver updated the VolumeMap. The state of the
comment|// block can be changed again now, so ignore this error here. If there
comment|// is a block really deleted by mistake, DirectoryScan should catch it.
if|if
condition|(
name|e
operator|instanceof
name|FileNotFoundException
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Verification failed for "
operator|+
name|block
operator|+
literal|" - may be due to race with write"
argument_list|)
expr_stmt|;
name|deleteBlock
argument_list|(
name|block
operator|.
name|getLocalBlock
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
name|LOG
operator|.
name|warn
argument_list|(
operator|(
name|second
condition|?
literal|"Second "
else|:
literal|"First "
operator|)
operator|+
literal|"Verification failed for "
operator|+
name|block
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|second
condition|)
block|{
name|totalScanErrors
operator|++
expr_stmt|;
name|datanode
operator|.
name|getMetrics
argument_list|()
operator|.
name|incrBlockVerificationFailures
argument_list|()
expr_stmt|;
name|handleScanFailure
argument_list|(
name|block
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
finally|finally
block|{
name|IOUtils
operator|.
name|closeStream
argument_list|(
name|blockSender
argument_list|)
expr_stmt|;
name|datanode
operator|.
name|getMetrics
argument_list|()
operator|.
name|incrBlocksVerified
argument_list|()
expr_stmt|;
name|totalScans
operator|++
expr_stmt|;
block|}
block|}
block|}
DECL|method|getEarliestScanTime ()
specifier|private
specifier|synchronized
name|long
name|getEarliestScanTime
parameter_list|()
block|{
if|if
condition|(
operator|!
name|blockInfoSet
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|blockInfoSet
operator|.
name|first
argument_list|()
operator|.
name|lastScanTime
return|;
block|}
return|return
name|Long
operator|.
name|MAX_VALUE
return|;
block|}
DECL|method|isFirstBlockProcessed ()
specifier|private
specifier|synchronized
name|boolean
name|isFirstBlockProcessed
parameter_list|()
block|{
if|if
condition|(
operator|!
name|blockInfoSet
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|long
name|blockId
init|=
name|blockInfoSet
operator|.
name|first
argument_list|()
operator|.
name|getBlockId
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|processedBlocks
operator|.
name|get
argument_list|(
name|blockId
argument_list|)
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|processedBlocks
operator|.
name|get
argument_list|(
name|blockId
argument_list|)
operator|==
literal|1
operator|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|// Picks one block and verifies it
DECL|method|verifyFirstBlock ()
specifier|private
name|void
name|verifyFirstBlock
parameter_list|()
block|{
name|Block
name|block
init|=
literal|null
decl_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
if|if
condition|(
operator|!
name|blockInfoSet
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|block
operator|=
name|blockInfoSet
operator|.
name|first
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|block
operator|!=
literal|null
condition|)
block|{
name|verifyBlock
argument_list|(
operator|new
name|ExtendedBlock
argument_list|(
name|blockPoolId
argument_list|,
name|block
argument_list|)
argument_list|)
expr_stmt|;
name|processedBlocks
operator|.
name|put
argument_list|(
name|block
operator|.
name|getBlockId
argument_list|()
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Used for tests only
DECL|method|getBlocksScannedInLastRun ()
name|int
name|getBlocksScannedInLastRun
parameter_list|()
block|{
return|return
name|totalBlocksScannedInLastRun
operator|.
name|get
argument_list|()
return|;
block|}
comment|/**    * Reads the current and previous log files (if any) and marks the blocks    * processed if they were processed within last scan period. Copies the log    * records of recently scanned blocks from previous to current file.     * Returns false if the process was interrupted because the thread is marked     * to exit.    */
DECL|method|assignInitialVerificationTimes ()
specifier|private
name|boolean
name|assignInitialVerificationTimes
parameter_list|()
block|{
comment|//First updates the last verification times from the log file.
if|if
condition|(
name|verificationLog
operator|!=
literal|null
condition|)
block|{
name|long
name|now
init|=
name|Time
operator|.
name|now
argument_list|()
decl_stmt|;
name|RollingLogs
operator|.
name|LineIterator
name|logIterator
init|=
literal|null
decl_stmt|;
try|try
block|{
name|logIterator
operator|=
name|verificationLog
operator|.
name|logs
operator|.
name|iterator
argument_list|(
literal|false
argument_list|)
expr_stmt|;
comment|// update verification times from the verificationLog.
while|while
condition|(
name|logIterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|datanode
operator|.
name|shouldRun
operator|||
name|datanode
operator|.
name|blockScanner
operator|.
name|blockScannerThread
operator|.
name|isInterrupted
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
name|LogEntry
name|entry
init|=
name|LogEntry
operator|.
name|parseEntry
argument_list|(
name|logIterator
operator|.
name|next
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|entry
operator|!=
literal|null
condition|)
block|{
name|updateBlockInfo
argument_list|(
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|now
operator|-
name|entry
operator|.
name|verificationTime
operator|<
name|scanPeriod
condition|)
block|{
name|BlockScanInfo
name|info
init|=
name|blockMap
operator|.
name|get
argument_list|(
operator|new
name|Block
argument_list|(
name|entry
operator|.
name|blockId
argument_list|,
literal|0
argument_list|,
name|entry
operator|.
name|genStamp
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|info
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|processedBlocks
operator|.
name|get
argument_list|(
name|entry
operator|.
name|blockId
argument_list|)
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|isNewPeriod
condition|)
block|{
name|updateBytesLeft
argument_list|(
operator|-
name|info
operator|.
name|getNumBytes
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|processedBlocks
operator|.
name|put
argument_list|(
name|entry
operator|.
name|blockId
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|logIterator
operator|.
name|isLastReadFromPrevious
argument_list|()
condition|)
block|{
comment|// write the log entry to current file
comment|// so that the entry is preserved for later runs.
name|verificationLog
operator|.
name|append
argument_list|(
name|entry
operator|.
name|verificationTime
argument_list|,
name|entry
operator|.
name|genStamp
argument_list|,
name|entry
operator|.
name|blockId
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to read previous verification times."
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|IOUtils
operator|.
name|closeStream
argument_list|(
name|logIterator
argument_list|)
expr_stmt|;
block|}
name|isNewPeriod
operator|=
literal|false
expr_stmt|;
block|}
comment|/* Before this loop, entries in blockInfoSet that are not      * updated above have lastScanTime of<= 0 . Loop until first entry has      * lastModificationTime> 0.      */
synchronized|synchronized
init|(
name|this
init|)
block|{
specifier|final
name|int
name|numBlocks
init|=
name|Math
operator|.
name|max
argument_list|(
name|blockMap
operator|.
name|size
argument_list|()
argument_list|,
literal|1
argument_list|)
decl_stmt|;
comment|// Initially spread the block reads over half of scan period
comment|// so that we don't keep scanning the blocks too quickly when restarted.
name|long
name|verifyInterval
init|=
name|Math
operator|.
name|min
argument_list|(
name|scanPeriod
operator|/
operator|(
literal|2L
operator|*
name|numBlocks
operator|)
argument_list|,
literal|10
operator|*
literal|60
operator|*
literal|1000L
argument_list|)
decl_stmt|;
name|long
name|lastScanTime
init|=
name|Time
operator|.
name|now
argument_list|()
operator|-
name|scanPeriod
decl_stmt|;
if|if
condition|(
operator|!
name|blockInfoSet
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|BlockScanInfo
name|info
decl_stmt|;
while|while
condition|(
operator|(
name|info
operator|=
name|blockInfoSet
operator|.
name|first
argument_list|()
operator|)
operator|.
name|lastScanTime
operator|<
literal|0
condition|)
block|{
name|delBlockInfo
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|info
operator|.
name|lastScanTime
operator|=
name|lastScanTime
expr_stmt|;
name|lastScanTime
operator|+=
name|verifyInterval
expr_stmt|;
name|addBlockInfo
argument_list|(
name|info
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
literal|true
return|;
block|}
DECL|method|updateBytesLeft (long len)
specifier|private
specifier|synchronized
name|void
name|updateBytesLeft
parameter_list|(
name|long
name|len
parameter_list|)
block|{
name|bytesLeft
operator|+=
name|len
expr_stmt|;
block|}
DECL|method|startNewPeriod ()
specifier|private
specifier|synchronized
name|void
name|startNewPeriod
parameter_list|()
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Starting a new period : work left in prev period : "
operator|+
name|String
operator|.
name|format
argument_list|(
literal|"%.2f%%"
argument_list|,
name|totalBytesToScan
operator|==
literal|0
condition|?
literal|0
else|:
operator|(
name|bytesLeft
operator|*
literal|100.0
operator|)
operator|/
name|totalBytesToScan
argument_list|)
argument_list|)
expr_stmt|;
comment|// reset the byte counts :
name|bytesLeft
operator|=
name|totalBytesToScan
expr_stmt|;
name|currentPeriodStart
operator|=
name|Time
operator|.
name|now
argument_list|()
expr_stmt|;
name|isNewPeriod
operator|=
literal|true
expr_stmt|;
block|}
DECL|method|workRemainingInCurrentPeriod ()
specifier|private
specifier|synchronized
name|boolean
name|workRemainingInCurrentPeriod
parameter_list|()
block|{
if|if
condition|(
name|bytesLeft
operator|<=
literal|0
operator|&&
name|Time
operator|.
name|now
argument_list|()
operator|<
name|currentPeriodStart
operator|+
name|scanPeriod
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Skipping scan since bytesLeft="
operator|+
name|bytesLeft
operator|+
literal|", Start="
operator|+
name|currentPeriodStart
operator|+
literal|", period="
operator|+
name|scanPeriod
operator|+
literal|", now="
operator|+
name|Time
operator|.
name|now
argument_list|()
operator|+
literal|" "
operator|+
name|blockPoolId
argument_list|)
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
else|else
block|{
return|return
literal|true
return|;
block|}
block|}
DECL|method|scanBlockPoolSlice ()
name|void
name|scanBlockPoolSlice
parameter_list|()
block|{
if|if
condition|(
operator|!
name|workRemainingInCurrentPeriod
argument_list|()
condition|)
block|{
return|return;
block|}
comment|// Create a new processedBlocks structure
name|processedBlocks
operator|=
operator|new
name|HashMap
argument_list|<
name|Long
argument_list|,
name|Integer
argument_list|>
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|assignInitialVerificationTimes
argument_list|()
condition|)
block|{
return|return;
block|}
comment|// Start scanning
try|try
block|{
name|scan
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|totalBlocksScannedInLastRun
operator|.
name|set
argument_list|(
name|processedBlocks
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|lastScanTime
operator|.
name|set
argument_list|(
name|Time
operator|.
name|now
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Shuts down this BlockPoolSliceScanner and releases any internal resources.    */
DECL|method|shutdown ()
name|void
name|shutdown
parameter_list|()
block|{
if|if
condition|(
name|verificationLog
operator|!=
literal|null
condition|)
block|{
name|verificationLog
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|scan ()
specifier|private
name|void
name|scan
parameter_list|()
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Starting to scan blockpool: "
operator|+
name|blockPoolId
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|adjustThrottler
argument_list|()
expr_stmt|;
while|while
condition|(
name|datanode
operator|.
name|shouldRun
operator|&&
operator|!
name|datanode
operator|.
name|blockScanner
operator|.
name|blockScannerThread
operator|.
name|isInterrupted
argument_list|()
operator|&&
name|datanode
operator|.
name|isBPServiceAlive
argument_list|(
name|blockPoolId
argument_list|)
condition|)
block|{
name|long
name|now
init|=
name|Time
operator|.
name|now
argument_list|()
decl_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
if|if
condition|(
name|now
operator|>=
operator|(
name|currentPeriodStart
operator|+
name|scanPeriod
operator|)
condition|)
block|{
name|startNewPeriod
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
operator|(
name|now
operator|-
name|getEarliestScanTime
argument_list|()
operator|)
operator|>=
name|scanPeriod
operator|)
operator|||
operator|(
operator|(
operator|!
name|blockInfoSet
operator|.
name|isEmpty
argument_list|()
operator|)
operator|&&
operator|!
operator|(
name|this
operator|.
name|isFirstBlockProcessed
argument_list|()
operator|)
operator|)
condition|)
block|{
name|verifyFirstBlock
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"All remaining blocks were processed recently, "
operator|+
literal|"so this run is complete"
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|RuntimeException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"RuntimeException during BlockPoolScanner.scan()"
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
finally|finally
block|{
name|rollVerificationLogs
argument_list|()
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Done scanning block pool: "
operator|+
name|blockPoolId
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|rollVerificationLogs ()
specifier|private
specifier|synchronized
name|void
name|rollVerificationLogs
parameter_list|()
block|{
if|if
condition|(
name|verificationLog
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|verificationLog
operator|.
name|logs
operator|.
name|roll
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Received exception: "
argument_list|,
name|ex
argument_list|)
expr_stmt|;
name|verificationLog
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
block|}
DECL|method|printBlockReport (StringBuilder buffer, boolean summaryOnly)
specifier|synchronized
name|void
name|printBlockReport
parameter_list|(
name|StringBuilder
name|buffer
parameter_list|,
name|boolean
name|summaryOnly
parameter_list|)
block|{
name|long
name|oneHour
init|=
literal|3600
operator|*
literal|1000
decl_stmt|;
name|long
name|oneDay
init|=
literal|24
operator|*
name|oneHour
decl_stmt|;
name|long
name|oneWeek
init|=
literal|7
operator|*
name|oneDay
decl_stmt|;
name|long
name|fourWeeks
init|=
literal|4
operator|*
name|oneWeek
decl_stmt|;
name|int
name|inOneHour
init|=
literal|0
decl_stmt|;
name|int
name|inOneDay
init|=
literal|0
decl_stmt|;
name|int
name|inOneWeek
init|=
literal|0
decl_stmt|;
name|int
name|inFourWeeks
init|=
literal|0
decl_stmt|;
name|int
name|inScanPeriod
init|=
literal|0
decl_stmt|;
name|int
name|neverScanned
init|=
literal|0
decl_stmt|;
name|DateFormat
name|dateFormat
init|=
operator|new
name|SimpleDateFormat
argument_list|(
name|DATA_FORMAT
argument_list|)
decl_stmt|;
name|int
name|total
init|=
name|blockInfoSet
operator|.
name|size
argument_list|()
decl_stmt|;
name|long
name|now
init|=
name|Time
operator|.
name|now
argument_list|()
decl_stmt|;
name|Date
name|date
init|=
operator|new
name|Date
argument_list|()
decl_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|BlockScanInfo
argument_list|>
name|it
init|=
name|blockInfoSet
operator|.
name|iterator
argument_list|()
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|BlockScanInfo
name|info
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|long
name|scanTime
init|=
name|info
operator|.
name|getLastScanTime
argument_list|()
decl_stmt|;
name|long
name|diff
init|=
name|now
operator|-
name|scanTime
decl_stmt|;
if|if
condition|(
name|diff
operator|<=
name|oneHour
condition|)
name|inOneHour
operator|++
expr_stmt|;
if|if
condition|(
name|diff
operator|<=
name|oneDay
condition|)
name|inOneDay
operator|++
expr_stmt|;
if|if
condition|(
name|diff
operator|<=
name|oneWeek
condition|)
name|inOneWeek
operator|++
expr_stmt|;
if|if
condition|(
name|diff
operator|<=
name|fourWeeks
condition|)
name|inFourWeeks
operator|++
expr_stmt|;
if|if
condition|(
name|diff
operator|<=
name|scanPeriod
condition|)
name|inScanPeriod
operator|++
expr_stmt|;
if|if
condition|(
name|scanTime
operator|<=
literal|0
condition|)
name|neverScanned
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|summaryOnly
condition|)
block|{
name|date
operator|.
name|setTime
argument_list|(
name|scanTime
argument_list|)
expr_stmt|;
name|String
name|scanType
init|=
operator|(
name|info
operator|.
name|lastScanType
operator|==
name|ScanType
operator|.
name|VERIFICATION_SCAN
operator|)
condition|?
literal|"local"
else|:
literal|"none"
decl_stmt|;
name|buffer
operator|.
name|append
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"%-26s : status : %-6s type : %-6s"
operator|+
literal|" scan time : "
operator|+
literal|"%-15d %s%n"
argument_list|,
name|info
argument_list|,
operator|(
name|info
operator|.
name|lastScanOk
condition|?
literal|"ok"
else|:
literal|"failed"
operator|)
argument_list|,
name|scanType
argument_list|,
name|scanTime
argument_list|,
operator|(
name|scanTime
operator|<=
literal|0
operator|)
condition|?
literal|"not yet verified"
else|:
name|dateFormat
operator|.
name|format
argument_list|(
name|date
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|double
name|pctPeriodLeft
init|=
operator|(
name|scanPeriod
operator|+
name|currentPeriodStart
operator|-
name|now
operator|)
operator|*
literal|100.0
operator|/
name|scanPeriod
decl_stmt|;
name|double
name|pctProgress
init|=
operator|(
name|totalBytesToScan
operator|==
literal|0
operator|)
condition|?
literal|100
else|:
operator|(
name|totalBytesToScan
operator|-
name|bytesLeft
operator|)
operator|*
literal|100.0
operator|/
name|totalBytesToScan
decl_stmt|;
name|buffer
operator|.
name|append
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"%nTotal Blocks                 : %6d"
operator|+
literal|"%nVerified in last hour        : %6d"
operator|+
literal|"%nVerified in last day         : %6d"
operator|+
literal|"%nVerified in last week        : %6d"
operator|+
literal|"%nVerified in last four weeks  : %6d"
operator|+
literal|"%nVerified in SCAN_PERIOD      : %6d"
operator|+
literal|"%nNot yet verified             : %6d"
operator|+
literal|"%nVerified since restart       : %6d"
operator|+
literal|"%nScans since restart          : %6d"
operator|+
literal|"%nScan errors since restart    : %6d"
operator|+
literal|"%nTransient scan errors        : %6d"
operator|+
literal|"%nCurrent scan rate limit KBps : %6d"
operator|+
literal|"%nProgress this period         : %6.0f%%"
operator|+
literal|"%nTime left in cur period      : %6.2f%%"
operator|+
literal|"%n"
argument_list|,
name|total
argument_list|,
name|inOneHour
argument_list|,
name|inOneDay
argument_list|,
name|inOneWeek
argument_list|,
name|inFourWeeks
argument_list|,
name|inScanPeriod
argument_list|,
name|neverScanned
argument_list|,
name|totalScans
argument_list|,
name|totalScans
argument_list|,
name|totalScanErrors
argument_list|,
name|totalTransientErrors
argument_list|,
name|Math
operator|.
name|round
argument_list|(
name|throttler
operator|.
name|getBandwidth
argument_list|()
operator|/
literal|1024.0
argument_list|)
argument_list|,
name|pctProgress
argument_list|,
name|pctPeriodLeft
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * This class takes care of log file used to store the last verification    * times of the blocks.    */
DECL|class|LogFileHandler
specifier|private
specifier|static
class|class
name|LogFileHandler
block|{
DECL|field|dateFormat
specifier|private
specifier|final
name|DateFormat
name|dateFormat
init|=
operator|new
name|SimpleDateFormat
argument_list|(
name|DATA_FORMAT
argument_list|)
decl_stmt|;
DECL|field|logs
specifier|private
specifier|final
name|RollingLogs
name|logs
decl_stmt|;
DECL|method|LogFileHandler (RollingLogs logs)
specifier|private
name|LogFileHandler
parameter_list|(
name|RollingLogs
name|logs
parameter_list|)
block|{
name|this
operator|.
name|logs
operator|=
name|logs
expr_stmt|;
block|}
DECL|method|append (long verificationTime, long genStamp, long blockId)
name|void
name|append
parameter_list|(
name|long
name|verificationTime
parameter_list|,
name|long
name|genStamp
parameter_list|,
name|long
name|blockId
parameter_list|)
block|{
specifier|final
name|String
name|m
init|=
name|LogEntry
operator|.
name|toString
argument_list|(
name|verificationTime
argument_list|,
name|genStamp
argument_list|,
name|blockId
argument_list|,
name|dateFormat
argument_list|)
decl_stmt|;
try|try
block|{
name|logs
operator|.
name|appender
argument_list|()
operator|.
name|append
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to append to "
operator|+
name|logs
operator|+
literal|", m="
operator|+
name|m
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|close ()
name|void
name|close
parameter_list|()
block|{
try|try
block|{
name|logs
operator|.
name|appender
argument_list|()
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to close the appender of "
operator|+
name|logs
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_class

end_unit

