begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  *  with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *  Unless required by applicable law or agreed to in writing, software  *  distributed under the License is distributed on an "AS IS" BASIS,  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  *  See the License for the specific language governing permissions and  *  limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.ozone.container.common.impl
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ozone
operator|.
name|container
operator|.
name|common
operator|.
name|impl
package|;
end_package

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|codec
operator|.
name|digest
operator|.
name|DigestUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileAlreadyExistsException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|ozone
operator|.
name|protocol
operator|.
name|proto
operator|.
name|ContainerProtos
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|fsdataset
operator|.
name|FsDatasetSpi
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ozone
operator|.
name|OzoneConsts
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ozone
operator|.
name|container
operator|.
name|common
operator|.
name|helpers
operator|.
name|ContainerData
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ozone
operator|.
name|container
operator|.
name|common
operator|.
name|helpers
operator|.
name|ContainerUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ozone
operator|.
name|container
operator|.
name|common
operator|.
name|helpers
operator|.
name|Pipeline
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ozone
operator|.
name|container
operator|.
name|common
operator|.
name|interfaces
operator|.
name|ChunkManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ozone
operator|.
name|container
operator|.
name|common
operator|.
name|interfaces
operator|.
name|ContainerLocationManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ozone
operator|.
name|container
operator|.
name|common
operator|.
name|interfaces
operator|.
name|ContainerManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ozone
operator|.
name|container
operator|.
name|common
operator|.
name|interfaces
operator|.
name|KeyManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FilenameFilter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|Paths
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|DigestInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|DigestOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|MessageDigest
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|NoSuchAlgorithmException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentNavigableMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentSkipListMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|ReentrantReadWriteLock
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ozone
operator|.
name|OzoneConsts
operator|.
name|CONTAINER_EXTENSION
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ozone
operator|.
name|OzoneConsts
operator|.
name|CONTAINER_META
import|;
end_import

begin_comment
comment|/**  * A Generic ContainerManagerImpl that will be called from Ozone  * ContainerManagerImpl. This allows us to support delta changes to ozone  * version without having to rewrite the containerManager.  */
end_comment

begin_class
DECL|class|ContainerManagerImpl
specifier|public
class|class
name|ContainerManagerImpl
implements|implements
name|ContainerManager
block|{
DECL|field|LOG
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|ContainerManagerImpl
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
specifier|final
name|ConcurrentSkipListMap
argument_list|<
name|String
argument_list|,
name|ContainerStatus
argument_list|>
DECL|field|containerMap
name|containerMap
init|=
operator|new
name|ConcurrentSkipListMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|// This lock follows fair locking policy of first-come first-serve
comment|// for waiting threads.
DECL|field|lock
specifier|private
specifier|final
name|ReentrantReadWriteLock
name|lock
init|=
operator|new
name|ReentrantReadWriteLock
argument_list|(
literal|true
argument_list|)
decl_stmt|;
DECL|field|locationManager
specifier|private
name|ContainerLocationManager
name|locationManager
decl_stmt|;
DECL|field|chunkManager
specifier|private
name|ChunkManager
name|chunkManager
decl_stmt|;
DECL|field|keyManager
specifier|private
name|KeyManager
name|keyManager
decl_stmt|;
comment|/**    * Init call that sets up a container Manager.    *    * @param config        - Configuration.    * @param containerDirs - List of Metadata Container locations.    * @throws IOException    */
annotation|@
name|Override
DECL|method|init (Configuration config, List<Path> containerDirs, FsDatasetSpi dataset)
specifier|public
name|void
name|init
parameter_list|(
name|Configuration
name|config
parameter_list|,
name|List
argument_list|<
name|Path
argument_list|>
name|containerDirs
parameter_list|,
name|FsDatasetSpi
name|dataset
parameter_list|)
throws|throws
name|IOException
block|{
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|config
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|containerDirs
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkState
argument_list|(
name|containerDirs
operator|.
name|size
argument_list|()
operator|>
literal|0
argument_list|)
expr_stmt|;
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
for|for
control|(
name|Path
name|path
range|:
name|containerDirs
control|)
block|{
name|File
name|directory
init|=
name|path
operator|.
name|toFile
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|directory
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Invalid path to container metadata directory. path: {}"
argument_list|,
name|path
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Invalid path to container metadata directory"
operator|+
literal|". "
operator|+
name|path
argument_list|)
throw|;
block|}
name|File
index|[]
name|files
init|=
name|directory
operator|.
name|listFiles
argument_list|(
operator|new
name|ContainerFilter
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|files
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|File
name|containerFile
range|:
name|files
control|)
block|{
name|String
name|containerPath
init|=
name|ContainerUtils
operator|.
name|getContainerNameFromFile
argument_list|(
name|containerFile
argument_list|)
decl_stmt|;
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|containerPath
argument_list|)
expr_stmt|;
name|readContainerInfo
argument_list|(
name|containerPath
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|this
operator|.
name|locationManager
operator|=
operator|new
name|ContainerLocationManagerImpl
argument_list|(
name|config
argument_list|,
name|containerDirs
argument_list|,
name|dataset
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Reads the Container Info from a file and verifies that checksum match. If    * the checksums match, then that file is added to containerMap.    *    * @param containerName - Name which points to the persisted container.    */
DECL|method|readContainerInfo (String containerName)
specifier|private
name|void
name|readContainerInfo
parameter_list|(
name|String
name|containerName
parameter_list|)
throws|throws
name|IOException
block|{
name|Preconditions
operator|.
name|checkState
argument_list|(
name|containerName
operator|.
name|length
argument_list|()
operator|>
literal|0
argument_list|)
expr_stmt|;
name|FileInputStream
name|containerStream
init|=
literal|null
decl_stmt|;
name|DigestInputStream
name|dis
init|=
literal|null
decl_stmt|;
name|FileInputStream
name|metaStream
init|=
literal|null
decl_stmt|;
name|Path
name|cPath
init|=
name|Paths
operator|.
name|get
argument_list|(
name|containerName
argument_list|)
operator|.
name|getFileName
argument_list|()
decl_stmt|;
name|String
name|keyName
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|cPath
operator|!=
literal|null
condition|)
block|{
name|keyName
operator|=
name|cPath
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|keyName
argument_list|)
expr_stmt|;
try|try
block|{
name|String
name|containerFileName
init|=
name|containerName
operator|.
name|concat
argument_list|(
name|CONTAINER_EXTENSION
argument_list|)
decl_stmt|;
name|String
name|metaFileName
init|=
name|containerName
operator|.
name|concat
argument_list|(
name|CONTAINER_META
argument_list|)
decl_stmt|;
name|containerStream
operator|=
operator|new
name|FileInputStream
argument_list|(
name|containerFileName
argument_list|)
expr_stmt|;
name|metaStream
operator|=
operator|new
name|FileInputStream
argument_list|(
name|metaFileName
argument_list|)
expr_stmt|;
name|MessageDigest
name|sha
init|=
name|MessageDigest
operator|.
name|getInstance
argument_list|(
name|OzoneConsts
operator|.
name|FILE_HASH
argument_list|)
decl_stmt|;
name|dis
operator|=
operator|new
name|DigestInputStream
argument_list|(
name|containerStream
argument_list|,
name|sha
argument_list|)
expr_stmt|;
name|ContainerData
name|containerData
init|=
name|ContainerData
operator|.
name|getFromProtBuf
argument_list|(
name|ContainerProtos
operator|.
name|ContainerData
operator|.
name|parseDelimitedFrom
argument_list|(
name|dis
argument_list|)
argument_list|)
decl_stmt|;
name|ContainerProtos
operator|.
name|ContainerMeta
name|meta
init|=
name|ContainerProtos
operator|.
name|ContainerMeta
operator|.
name|parseDelimitedFrom
argument_list|(
name|metaStream
argument_list|)
decl_stmt|;
if|if
condition|(
name|meta
operator|!=
literal|null
operator|&&
operator|!
name|DigestUtils
operator|.
name|sha256Hex
argument_list|(
name|sha
operator|.
name|digest
argument_list|()
argument_list|)
operator|.
name|equals
argument_list|(
name|meta
operator|.
name|getHash
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Invalid SHA found for file."
argument_list|)
throw|;
block|}
name|containerMap
operator|.
name|put
argument_list|(
name|keyName
argument_list|,
operator|new
name|ContainerStatus
argument_list|(
name|containerData
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
decl||
name|NoSuchAlgorithmException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"read failed for file: {} ex: {}"
argument_list|,
name|containerName
argument_list|,
name|ex
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
comment|// TODO : Add this file to a recovery Queue.
comment|// Remember that this container is busted and we cannot use it.
name|containerMap
operator|.
name|put
argument_list|(
name|keyName
argument_list|,
operator|new
name|ContainerStatus
argument_list|(
literal|null
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|IOUtils
operator|.
name|closeStream
argument_list|(
name|dis
argument_list|)
expr_stmt|;
name|IOUtils
operator|.
name|closeStream
argument_list|(
name|containerStream
argument_list|)
expr_stmt|;
name|IOUtils
operator|.
name|closeStream
argument_list|(
name|metaStream
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Creates a container with the given name.    *    * @param pipeline      -- Nodes which make up this container.    * @param containerData - Container Name and metadata.    * @throws IOException    */
annotation|@
name|Override
DECL|method|createContainer (Pipeline pipeline, ContainerData containerData)
specifier|public
name|void
name|createContainer
parameter_list|(
name|Pipeline
name|pipeline
parameter_list|,
name|ContainerData
name|containerData
parameter_list|)
throws|throws
name|IOException
block|{
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|containerData
argument_list|)
expr_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
name|containerMap
operator|.
name|containsKey
argument_list|(
name|containerData
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|FileAlreadyExistsException
argument_list|(
literal|"container already exists."
argument_list|)
throw|;
block|}
comment|// This is by design. We first write and close the
comment|// container Info and metadata to a directory.
comment|// Then read back and put that info into the containerMap.
comment|// This allows us to make sure that our write is consistent.
name|writeContainerInfo
argument_list|(
name|containerData
argument_list|)
expr_stmt|;
name|File
name|cFile
init|=
operator|new
name|File
argument_list|(
name|containerData
operator|.
name|getContainerPath
argument_list|()
argument_list|)
decl_stmt|;
name|readContainerInfo
argument_list|(
name|ContainerUtils
operator|.
name|getContainerNameFromFile
argument_list|(
name|cFile
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NoSuchAlgorithmException
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"failed to create container"
argument_list|,
name|ex
argument_list|)
throw|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Writes a container to a chosen location and updates the container Map.    *    * The file formats of ContainerData and Container Meta is the following.    *    * message ContainerData {    * required string name = 1;    * repeated KeyValue metadata = 2;    * optional string dbPath = 3;    * optional string containerPath = 4;    * }    *    * message ContainerMeta {    * required string fileName = 1;    * required string hash = 2;    * }    *    * @param containerData - container Data    */
DECL|method|writeContainerInfo (ContainerData containerData)
specifier|private
name|void
name|writeContainerInfo
parameter_list|(
name|ContainerData
name|containerData
parameter_list|)
throws|throws
name|IOException
throws|,
name|NoSuchAlgorithmException
block|{
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|this
operator|.
name|locationManager
argument_list|)
expr_stmt|;
name|FileOutputStream
name|containerStream
init|=
literal|null
decl_stmt|;
name|DigestOutputStream
name|dos
init|=
literal|null
decl_stmt|;
name|FileOutputStream
name|metaStream
init|=
literal|null
decl_stmt|;
name|Path
name|location
init|=
name|locationManager
operator|.
name|getContainerPath
argument_list|()
decl_stmt|;
name|File
name|containerFile
init|=
name|ContainerUtils
operator|.
name|getContainerFile
argument_list|(
name|containerData
argument_list|,
name|location
argument_list|)
decl_stmt|;
name|File
name|metadataFile
init|=
name|ContainerUtils
operator|.
name|getMetadataFile
argument_list|(
name|containerData
argument_list|,
name|location
argument_list|)
decl_stmt|;
try|try
block|{
name|ContainerUtils
operator|.
name|verifyIsNewContainer
argument_list|(
name|containerFile
argument_list|,
name|metadataFile
argument_list|)
expr_stmt|;
name|Path
name|metadataPath
init|=
name|this
operator|.
name|locationManager
operator|.
name|getDataPath
argument_list|(
name|containerData
operator|.
name|getContainerName
argument_list|()
argument_list|)
decl_stmt|;
name|metadataPath
operator|=
name|ContainerUtils
operator|.
name|createMetadata
argument_list|(
name|metadataPath
argument_list|)
expr_stmt|;
name|containerStream
operator|=
operator|new
name|FileOutputStream
argument_list|(
name|containerFile
argument_list|)
expr_stmt|;
name|metaStream
operator|=
operator|new
name|FileOutputStream
argument_list|(
name|metadataFile
argument_list|)
expr_stmt|;
name|MessageDigest
name|sha
init|=
name|MessageDigest
operator|.
name|getInstance
argument_list|(
name|OzoneConsts
operator|.
name|FILE_HASH
argument_list|)
decl_stmt|;
name|dos
operator|=
operator|new
name|DigestOutputStream
argument_list|(
name|containerStream
argument_list|,
name|sha
argument_list|)
expr_stmt|;
name|containerData
operator|.
name|setDBPath
argument_list|(
name|metadataPath
operator|.
name|resolve
argument_list|(
name|OzoneConsts
operator|.
name|CONTAINER_DB
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|containerData
operator|.
name|setContainerPath
argument_list|(
name|containerFile
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|ContainerProtos
operator|.
name|ContainerData
name|protoData
init|=
name|containerData
operator|.
name|getProtoBufMessage
argument_list|()
decl_stmt|;
name|protoData
operator|.
name|writeDelimitedTo
argument_list|(
name|dos
argument_list|)
expr_stmt|;
name|ContainerProtos
operator|.
name|ContainerMeta
name|protoMeta
init|=
name|ContainerProtos
operator|.
name|ContainerMeta
operator|.
name|newBuilder
argument_list|()
operator|.
name|setFileName
argument_list|(
name|containerFile
operator|.
name|toString
argument_list|()
argument_list|)
operator|.
name|setHash
argument_list|(
name|DigestUtils
operator|.
name|sha256Hex
argument_list|(
name|sha
operator|.
name|digest
argument_list|()
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|protoMeta
operator|.
name|writeDelimitedTo
argument_list|(
name|metaStream
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
comment|// TODO : we need to clean up partially constructed files
comment|// The proper way to do would be for a thread
comment|// to read all these 3 artifacts and make sure they are
comment|// sane. That info needs to come from the replication
comment|// pipeline, and if not consistent delete these file.
comment|// In case of ozone this is *not* a deal breaker since
comment|// SCM is guaranteed to generate unique container names.
name|LOG
operator|.
name|error
argument_list|(
literal|"creation of container failed. Name: {} "
argument_list|,
name|containerData
operator|.
name|getContainerName
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
name|ex
throw|;
block|}
finally|finally
block|{
name|IOUtils
operator|.
name|closeStream
argument_list|(
name|dos
argument_list|)
expr_stmt|;
name|IOUtils
operator|.
name|closeStream
argument_list|(
name|containerStream
argument_list|)
expr_stmt|;
name|IOUtils
operator|.
name|closeStream
argument_list|(
name|metaStream
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Deletes an existing container.    *    * @param pipeline      - nodes that make this container.    * @param containerName - name of the container.    * @throws IOException    */
annotation|@
name|Override
DECL|method|deleteContainer (Pipeline pipeline, String containerName)
specifier|public
name|void
name|deleteContainer
parameter_list|(
name|Pipeline
name|pipeline
parameter_list|,
name|String
name|containerName
parameter_list|)
throws|throws
name|IOException
block|{
name|Preconditions
operator|.
name|checkState
argument_list|(
name|containerName
operator|.
name|length
argument_list|()
operator|>
literal|0
argument_list|)
expr_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|ContainerStatus
name|status
init|=
name|containerMap
operator|.
name|get
argument_list|(
name|containerName
argument_list|)
decl_stmt|;
if|if
condition|(
name|status
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"No such container. Name: {}"
argument_list|,
name|containerName
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
literal|"No such container. Name : "
operator|+
name|containerName
argument_list|)
throw|;
block|}
name|ContainerUtils
operator|.
name|removeContainer
argument_list|(
name|status
operator|.
name|containerData
argument_list|)
expr_stmt|;
name|containerMap
operator|.
name|remove
argument_list|(
name|containerName
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * A simple interface for container Iterations.    *<p/>    * This call make no guarantees about consistency of the data between    * different list calls. It just returns the best known data at that point of    * time. It is possible that using this iteration you can miss certain    * container from the listing.    *    * @param prefix  -  Return keys that match this prefix.    * @param count   - how many to return    * @param prevKey - Previous Key Value or empty String.    * @param data    - Actual containerData    * @throws IOException    */
annotation|@
name|Override
DECL|method|listContainer (String prefix, long count, String prevKey, List<ContainerData> data)
specifier|public
name|void
name|listContainer
parameter_list|(
name|String
name|prefix
parameter_list|,
name|long
name|count
parameter_list|,
name|String
name|prevKey
parameter_list|,
name|List
argument_list|<
name|ContainerData
argument_list|>
name|data
parameter_list|)
throws|throws
name|IOException
block|{
comment|// TODO : Support list with Prefix and PrevKey
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
name|ConcurrentNavigableMap
argument_list|<
name|String
argument_list|,
name|ContainerStatus
argument_list|>
name|map
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|prevKey
operator|==
literal|null
operator|||
name|prevKey
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|map
operator|=
name|containerMap
operator|.
name|tailMap
argument_list|(
name|containerMap
operator|.
name|firstKey
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|map
operator|=
name|containerMap
operator|.
name|tailMap
argument_list|(
name|prevKey
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
name|int
name|currentCount
init|=
literal|0
decl_stmt|;
for|for
control|(
name|ContainerStatus
name|entry
range|:
name|map
operator|.
name|values
argument_list|()
control|)
block|{
if|if
condition|(
name|currentCount
operator|<
name|count
condition|)
block|{
name|data
operator|.
name|add
argument_list|(
name|entry
operator|.
name|getContainer
argument_list|()
argument_list|)
expr_stmt|;
name|currentCount
operator|++
expr_stmt|;
block|}
else|else
block|{
return|return;
block|}
block|}
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Get metadata about a specific container.    *    * @param containerName - Name of the container    * @return ContainerData - Container Data.    * @throws IOException    */
annotation|@
name|Override
DECL|method|readContainer (String containerName)
specifier|public
name|ContainerData
name|readContainer
parameter_list|(
name|String
name|containerName
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|containerMap
operator|.
name|containsKey
argument_list|(
name|containerName
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unable to find the container. Name: "
operator|+
name|containerName
argument_list|)
throw|;
block|}
return|return
name|containerMap
operator|.
name|get
argument_list|(
name|containerName
argument_list|)
operator|.
name|getContainer
argument_list|()
return|;
block|}
comment|/**    * Supports clean shutdown of container.    *    * @throws IOException    */
annotation|@
name|Override
DECL|method|shutdown ()
specifier|public
name|void
name|shutdown
parameter_list|()
block|{
name|Preconditions
operator|.
name|checkState
argument_list|(
name|this
operator|.
name|hasWriteLock
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|containerMap
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|getContainerMap ()
name|ConcurrentSkipListMap
argument_list|<
name|String
argument_list|,
name|ContainerStatus
argument_list|>
name|getContainerMap
parameter_list|()
block|{
return|return
name|containerMap
return|;
block|}
comment|/**    * Acquire read lock.    */
annotation|@
name|Override
DECL|method|readLock ()
specifier|public
name|void
name|readLock
parameter_list|()
block|{
name|this
operator|.
name|lock
operator|.
name|readLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
block|}
comment|/**    * Release read lock.    */
annotation|@
name|Override
DECL|method|readUnlock ()
specifier|public
name|void
name|readUnlock
parameter_list|()
block|{
name|this
operator|.
name|lock
operator|.
name|readLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
comment|/**    * Check if the current thread holds read lock.    */
annotation|@
name|Override
DECL|method|hasReadLock ()
specifier|public
name|boolean
name|hasReadLock
parameter_list|()
block|{
return|return
name|this
operator|.
name|lock
operator|.
name|readLock
argument_list|()
operator|.
name|tryLock
argument_list|()
return|;
block|}
comment|/**    * Acquire write lock.    */
annotation|@
name|Override
DECL|method|writeLock ()
specifier|public
name|void
name|writeLock
parameter_list|()
block|{
name|this
operator|.
name|lock
operator|.
name|writeLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
block|}
comment|/**    * Acquire write lock, unless interrupted while waiting.    */
annotation|@
name|Override
DECL|method|writeLockInterruptibly ()
specifier|public
name|void
name|writeLockInterruptibly
parameter_list|()
throws|throws
name|InterruptedException
block|{
name|this
operator|.
name|lock
operator|.
name|writeLock
argument_list|()
operator|.
name|lockInterruptibly
argument_list|()
expr_stmt|;
block|}
comment|/**    * Release write lock.    */
annotation|@
name|Override
DECL|method|writeUnlock ()
specifier|public
name|void
name|writeUnlock
parameter_list|()
block|{
name|this
operator|.
name|lock
operator|.
name|writeLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
comment|/**    * Check if the current thread holds write lock.    */
annotation|@
name|Override
DECL|method|hasWriteLock ()
specifier|public
name|boolean
name|hasWriteLock
parameter_list|()
block|{
return|return
name|this
operator|.
name|lock
operator|.
name|writeLock
argument_list|()
operator|.
name|isHeldByCurrentThread
argument_list|()
return|;
block|}
comment|/**    * Sets the chunk Manager.    * @param chunkManager    */
DECL|method|setChunkManager (ChunkManager chunkManager)
specifier|public
name|void
name|setChunkManager
parameter_list|(
name|ChunkManager
name|chunkManager
parameter_list|)
block|{
name|this
operator|.
name|chunkManager
operator|=
name|chunkManager
expr_stmt|;
block|}
DECL|method|getChunkManager ()
specifier|public
name|ChunkManager
name|getChunkManager
parameter_list|()
block|{
return|return
name|this
operator|.
name|chunkManager
return|;
block|}
comment|/**    * Sets the Key Manager.    *    * @param keyManager - Key Manager.    */
annotation|@
name|Override
DECL|method|setKeyManager (KeyManager keyManager)
specifier|public
name|void
name|setKeyManager
parameter_list|(
name|KeyManager
name|keyManager
parameter_list|)
block|{
name|this
operator|.
name|keyManager
operator|=
name|keyManager
expr_stmt|;
block|}
comment|/**    * Gets the Key Manager.    *    * @return KeyManager.    */
annotation|@
name|Override
DECL|method|getKeyManager ()
specifier|public
name|KeyManager
name|getKeyManager
parameter_list|()
block|{
return|return
name|this
operator|.
name|keyManager
return|;
block|}
comment|/**    * Filter out only container files from the container metadata dir.    */
DECL|class|ContainerFilter
specifier|private
specifier|static
class|class
name|ContainerFilter
implements|implements
name|FilenameFilter
block|{
comment|/**      * Tests if a specified file should be included in a file list.      *      * @param dir  the directory in which the file was found.      * @param name the name of the file.      * @return<code>true</code> if and only if the name should be included in      * the file list;<code>false</code> otherwise.      */
annotation|@
name|Override
DECL|method|accept (File dir, String name)
specifier|public
name|boolean
name|accept
parameter_list|(
name|File
name|dir
parameter_list|,
name|String
name|name
parameter_list|)
block|{
return|return
name|name
operator|.
name|endsWith
argument_list|(
name|CONTAINER_EXTENSION
argument_list|)
return|;
block|}
block|}
comment|/**    * This is an immutable class that represents the state of a container. if the    * container reading encountered an error when we boot up we will post that    * info to a recovery queue and keep the info in the containerMap.    *<p/>    * if and when the issue is fixed, the expectation is that this entry will be    * deleted by the recovery thread from the containerMap and will insert entry    * instead of modifying this class.    */
annotation|@
name|VisibleForTesting
DECL|class|ContainerStatus
specifier|static
class|class
name|ContainerStatus
block|{
DECL|field|containerData
specifier|private
specifier|final
name|ContainerData
name|containerData
decl_stmt|;
DECL|field|active
specifier|private
specifier|final
name|boolean
name|active
decl_stmt|;
comment|/**      * Creates a Container Status class.      *      * @param containerData - ContainerData.      * @param active        - Active or not active.      */
DECL|method|ContainerStatus (ContainerData containerData, boolean active)
specifier|public
name|ContainerStatus
parameter_list|(
name|ContainerData
name|containerData
parameter_list|,
name|boolean
name|active
parameter_list|)
block|{
name|this
operator|.
name|containerData
operator|=
name|containerData
expr_stmt|;
name|this
operator|.
name|active
operator|=
name|active
expr_stmt|;
block|}
comment|/**      * Returns container if it is active. It is not active if we have had an      * error and we are waiting for the background threads to fix the issue.      *      * @return ContainerData.      */
DECL|method|getContainer ()
specifier|public
name|ContainerData
name|getContainer
parameter_list|()
block|{
if|if
condition|(
name|active
condition|)
block|{
return|return
name|containerData
return|;
block|}
return|return
literal|null
return|;
block|}
comment|/**      * Indicates if a container is Active.      *      * @return      */
DECL|method|isActive ()
specifier|public
name|boolean
name|isActive
parameter_list|()
block|{
return|return
name|active
return|;
block|}
block|}
block|}
end_class

end_unit

