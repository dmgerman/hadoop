begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdfs.server.namenode
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceStability
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|HdfsConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|Storage
operator|.
name|StorageDirectory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|NNStorage
operator|.
name|NameNodeDirType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|NNStorage
operator|.
name|NameNodeFile
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|IOUtils
import|;
end_import

begin_comment
comment|/**  * Inspects a FSImage storage directory in the "old" (pre-HDFS-1073) format.  * This format has the following data files:  *   - fsimage  *   - fsimage.ckpt (when checkpoint is being uploaded)  *   - edits  *   - edits.new (when logs are "rolled")  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
annotation|@
name|InterfaceStability
operator|.
name|Unstable
DECL|class|FSImagePreTransactionalStorageInspector
class|class
name|FSImagePreTransactionalStorageInspector
extends|extends
name|FSImageStorageInspector
block|{
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|FSImagePreTransactionalStorageInspector
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/* Flag if there is at least one storage dir that doesn't contain the newest    * fstime */
DECL|field|hasOutOfDateStorageDirs
specifier|private
name|boolean
name|hasOutOfDateStorageDirs
init|=
literal|false
decl_stmt|;
comment|/* Flag set false if there are any "previous" directories found */
DECL|field|isUpgradeFinalized
specifier|private
name|boolean
name|isUpgradeFinalized
init|=
literal|true
decl_stmt|;
DECL|field|needToSaveAfterRecovery
specifier|private
name|boolean
name|needToSaveAfterRecovery
init|=
literal|false
decl_stmt|;
comment|// Track the name and edits dir with the latest times
DECL|field|latestNameCheckpointTime
specifier|private
name|long
name|latestNameCheckpointTime
init|=
name|Long
operator|.
name|MIN_VALUE
decl_stmt|;
DECL|field|latestEditsCheckpointTime
specifier|private
name|long
name|latestEditsCheckpointTime
init|=
name|Long
operator|.
name|MIN_VALUE
decl_stmt|;
DECL|field|latestNameSD
specifier|private
name|StorageDirectory
name|latestNameSD
init|=
literal|null
decl_stmt|;
DECL|field|latestEditsSD
specifier|private
name|StorageDirectory
name|latestEditsSD
init|=
literal|null
decl_stmt|;
comment|/** Set to determine if all of storageDirectories share the same checkpoint */
DECL|field|checkpointTimes
name|Set
argument_list|<
name|Long
argument_list|>
name|checkpointTimes
init|=
operator|new
name|HashSet
argument_list|<
name|Long
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|imageDirs
specifier|private
name|List
argument_list|<
name|String
argument_list|>
name|imageDirs
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|editsDirs
specifier|private
name|List
argument_list|<
name|String
argument_list|>
name|editsDirs
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
annotation|@
name|Override
DECL|method|inspectDirectory (StorageDirectory sd)
name|void
name|inspectDirectory
parameter_list|(
name|StorageDirectory
name|sd
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Was the file just formatted?
if|if
condition|(
operator|!
name|sd
operator|.
name|getVersionFile
argument_list|()
operator|.
name|exists
argument_list|()
condition|)
block|{
name|hasOutOfDateStorageDirs
operator|=
literal|true
expr_stmt|;
return|return;
block|}
name|boolean
name|imageExists
init|=
literal|false
decl_stmt|;
name|boolean
name|editsExists
init|=
literal|false
decl_stmt|;
comment|// Determine if sd is image, edits or both
if|if
condition|(
name|sd
operator|.
name|getStorageDirType
argument_list|()
operator|.
name|isOfType
argument_list|(
name|NameNodeDirType
operator|.
name|IMAGE
argument_list|)
condition|)
block|{
name|imageExists
operator|=
name|NNStorage
operator|.
name|getStorageFile
argument_list|(
name|sd
argument_list|,
name|NameNodeFile
operator|.
name|IMAGE
argument_list|)
operator|.
name|exists
argument_list|()
expr_stmt|;
name|imageDirs
operator|.
name|add
argument_list|(
name|sd
operator|.
name|getRoot
argument_list|()
operator|.
name|getCanonicalPath
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sd
operator|.
name|getStorageDirType
argument_list|()
operator|.
name|isOfType
argument_list|(
name|NameNodeDirType
operator|.
name|EDITS
argument_list|)
condition|)
block|{
name|editsExists
operator|=
name|NNStorage
operator|.
name|getStorageFile
argument_list|(
name|sd
argument_list|,
name|NameNodeFile
operator|.
name|EDITS
argument_list|)
operator|.
name|exists
argument_list|()
expr_stmt|;
name|editsDirs
operator|.
name|add
argument_list|(
name|sd
operator|.
name|getRoot
argument_list|()
operator|.
name|getCanonicalPath
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|long
name|checkpointTime
init|=
name|readCheckpointTime
argument_list|(
name|sd
argument_list|)
decl_stmt|;
name|checkpointTimes
operator|.
name|add
argument_list|(
name|checkpointTime
argument_list|)
expr_stmt|;
if|if
condition|(
name|sd
operator|.
name|getStorageDirType
argument_list|()
operator|.
name|isOfType
argument_list|(
name|NameNodeDirType
operator|.
name|IMAGE
argument_list|)
operator|&&
operator|(
name|latestNameCheckpointTime
operator|<
name|checkpointTime
operator|)
operator|&&
name|imageExists
condition|)
block|{
name|latestNameCheckpointTime
operator|=
name|checkpointTime
expr_stmt|;
name|latestNameSD
operator|=
name|sd
expr_stmt|;
block|}
if|if
condition|(
name|sd
operator|.
name|getStorageDirType
argument_list|()
operator|.
name|isOfType
argument_list|(
name|NameNodeDirType
operator|.
name|EDITS
argument_list|)
operator|&&
operator|(
name|latestEditsCheckpointTime
operator|<
name|checkpointTime
operator|)
operator|&&
name|editsExists
condition|)
block|{
name|latestEditsCheckpointTime
operator|=
name|checkpointTime
expr_stmt|;
name|latestEditsSD
operator|=
name|sd
expr_stmt|;
block|}
comment|// check that we have a valid, non-default checkpointTime
if|if
condition|(
name|checkpointTime
operator|<=
literal|0L
condition|)
name|hasOutOfDateStorageDirs
operator|=
literal|true
expr_stmt|;
comment|// set finalized flag
name|isUpgradeFinalized
operator|=
name|isUpgradeFinalized
operator|&&
operator|!
name|sd
operator|.
name|getPreviousDir
argument_list|()
operator|.
name|exists
argument_list|()
expr_stmt|;
block|}
comment|/**    * Determine the checkpoint time of the specified StorageDirectory    *    * @param sd StorageDirectory to check    * @return If file exists and can be read, last checkpoint time. If not, 0L.    * @throws IOException On errors processing file pointed to by sd    */
DECL|method|readCheckpointTime (StorageDirectory sd)
specifier|static
name|long
name|readCheckpointTime
parameter_list|(
name|StorageDirectory
name|sd
parameter_list|)
throws|throws
name|IOException
block|{
name|File
name|timeFile
init|=
name|NNStorage
operator|.
name|getStorageFile
argument_list|(
name|sd
argument_list|,
name|NameNodeFile
operator|.
name|TIME
argument_list|)
decl_stmt|;
name|long
name|timeStamp
init|=
literal|0L
decl_stmt|;
if|if
condition|(
name|timeFile
operator|.
name|exists
argument_list|()
operator|&&
name|FileUtil
operator|.
name|canRead
argument_list|(
name|timeFile
argument_list|)
condition|)
block|{
name|DataInputStream
name|in
init|=
operator|new
name|DataInputStream
argument_list|(
operator|new
name|FileInputStream
argument_list|(
name|timeFile
argument_list|)
argument_list|)
decl_stmt|;
try|try
block|{
name|timeStamp
operator|=
name|in
operator|.
name|readLong
argument_list|()
expr_stmt|;
name|in
operator|.
name|close
argument_list|()
expr_stmt|;
name|in
operator|=
literal|null
expr_stmt|;
block|}
finally|finally
block|{
name|IOUtils
operator|.
name|cleanup
argument_list|(
name|LOG
argument_list|,
name|in
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|timeStamp
return|;
block|}
annotation|@
name|Override
DECL|method|isUpgradeFinalized ()
name|boolean
name|isUpgradeFinalized
parameter_list|()
block|{
return|return
name|isUpgradeFinalized
return|;
block|}
annotation|@
name|Override
DECL|method|getLatestImages ()
name|List
argument_list|<
name|FSImageFile
argument_list|>
name|getLatestImages
parameter_list|()
throws|throws
name|IOException
block|{
comment|// We should have at least one image and one edits dirs
if|if
condition|(
name|latestNameSD
operator|==
literal|null
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Image file is not found in "
operator|+
name|imageDirs
argument_list|)
throw|;
if|if
condition|(
name|latestEditsSD
operator|==
literal|null
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Edits file is not found in "
operator|+
name|editsDirs
argument_list|)
throw|;
comment|// Make sure we are loading image and edits from same checkpoint
if|if
condition|(
name|latestNameCheckpointTime
operator|>
name|latestEditsCheckpointTime
operator|&&
name|latestNameSD
operator|!=
name|latestEditsSD
operator|&&
name|latestNameSD
operator|.
name|getStorageDirType
argument_list|()
operator|==
name|NameNodeDirType
operator|.
name|IMAGE
operator|&&
name|latestEditsSD
operator|.
name|getStorageDirType
argument_list|()
operator|==
name|NameNodeDirType
operator|.
name|EDITS
condition|)
block|{
comment|// This is a rare failure when NN has image-only and edits-only
comment|// storage directories, and fails right after saving images,
comment|// in some of the storage directories, but before purging edits.
comment|// See -NOTE- in saveNamespace().
name|LOG
operator|.
name|error
argument_list|(
literal|"This is a rare failure scenario!!!"
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|error
argument_list|(
literal|"Image checkpoint time "
operator|+
name|latestNameCheckpointTime
operator|+
literal|"> edits checkpoint time "
operator|+
name|latestEditsCheckpointTime
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|error
argument_list|(
literal|"Name-node will treat the image as the latest state of "
operator|+
literal|"the namespace. Old edits will be discarded."
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|latestNameCheckpointTime
operator|!=
name|latestEditsCheckpointTime
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Inconsistent storage detected, "
operator|+
literal|"image and edits checkpoint times do not match. "
operator|+
literal|"image checkpoint time = "
operator|+
name|latestNameCheckpointTime
operator|+
literal|"edits checkpoint time = "
operator|+
name|latestEditsCheckpointTime
argument_list|)
throw|;
block|}
name|needToSaveAfterRecovery
operator|=
name|doRecovery
argument_list|()
expr_stmt|;
name|FSImageFile
name|file
init|=
operator|new
name|FSImageFile
argument_list|(
name|latestNameSD
argument_list|,
name|NNStorage
operator|.
name|getStorageFile
argument_list|(
name|latestNameSD
argument_list|,
name|NameNodeFile
operator|.
name|IMAGE
argument_list|)
argument_list|,
name|HdfsConstants
operator|.
name|INVALID_TXID
argument_list|)
decl_stmt|;
name|LinkedList
argument_list|<
name|FSImageFile
argument_list|>
name|ret
init|=
operator|new
name|LinkedList
argument_list|<
name|FSImageFile
argument_list|>
argument_list|()
decl_stmt|;
name|ret
operator|.
name|add
argument_list|(
name|file
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
annotation|@
name|Override
DECL|method|needToSave ()
name|boolean
name|needToSave
parameter_list|()
block|{
return|return
name|hasOutOfDateStorageDirs
operator|||
name|checkpointTimes
operator|.
name|size
argument_list|()
operator|!=
literal|1
operator|||
name|latestNameCheckpointTime
operator|>
name|latestEditsCheckpointTime
operator|||
name|needToSaveAfterRecovery
return|;
block|}
DECL|method|doRecovery ()
name|boolean
name|doRecovery
parameter_list|()
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Performing recovery in "
operator|+
name|latestNameSD
operator|+
literal|" and "
operator|+
name|latestEditsSD
argument_list|)
expr_stmt|;
name|boolean
name|needToSave
init|=
literal|false
decl_stmt|;
name|File
name|curFile
init|=
name|NNStorage
operator|.
name|getStorageFile
argument_list|(
name|latestNameSD
argument_list|,
name|NameNodeFile
operator|.
name|IMAGE
argument_list|)
decl_stmt|;
name|File
name|ckptFile
init|=
name|NNStorage
operator|.
name|getStorageFile
argument_list|(
name|latestNameSD
argument_list|,
name|NameNodeFile
operator|.
name|IMAGE_NEW
argument_list|)
decl_stmt|;
comment|//
comment|// If we were in the midst of a checkpoint
comment|//
if|if
condition|(
name|ckptFile
operator|.
name|exists
argument_list|()
condition|)
block|{
name|needToSave
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|NNStorage
operator|.
name|getStorageFile
argument_list|(
name|latestEditsSD
argument_list|,
name|NameNodeFile
operator|.
name|EDITS_NEW
argument_list|)
operator|.
name|exists
argument_list|()
condition|)
block|{
comment|//
comment|// checkpointing migth have uploaded a new
comment|// merged image, but we discard it here because we are
comment|// not sure whether the entire merged image was uploaded
comment|// before the namenode crashed.
comment|//
if|if
condition|(
operator|!
name|ckptFile
operator|.
name|delete
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unable to delete "
operator|+
name|ckptFile
argument_list|)
throw|;
block|}
block|}
else|else
block|{
comment|//
comment|// checkpointing was in progress when the namenode
comment|// shutdown. The fsimage.ckpt was created and the edits.new
comment|// file was moved to edits. We complete that checkpoint by
comment|// moving fsimage.new to fsimage. There is no need to
comment|// update the fstime file here. renameTo fails on Windows
comment|// if the destination file already exists.
comment|//
if|if
condition|(
operator|!
name|ckptFile
operator|.
name|renameTo
argument_list|(
name|curFile
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|curFile
operator|.
name|delete
argument_list|()
condition|)
name|LOG
operator|.
name|warn
argument_list|(
literal|"Unable to delete dir "
operator|+
name|curFile
operator|+
literal|" before rename"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ckptFile
operator|.
name|renameTo
argument_list|(
name|curFile
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unable to rename "
operator|+
name|ckptFile
operator|+
literal|" to "
operator|+
name|curFile
argument_list|)
throw|;
block|}
block|}
block|}
block|}
return|return
name|needToSave
return|;
block|}
comment|/**    * @return a list with the paths to EDITS and EDITS_NEW (if it exists)    * in a given storage directory.    */
DECL|method|getEditsInStorageDir (StorageDirectory sd)
specifier|static
name|List
argument_list|<
name|File
argument_list|>
name|getEditsInStorageDir
parameter_list|(
name|StorageDirectory
name|sd
parameter_list|)
block|{
name|ArrayList
argument_list|<
name|File
argument_list|>
name|files
init|=
operator|new
name|ArrayList
argument_list|<
name|File
argument_list|>
argument_list|()
decl_stmt|;
name|File
name|edits
init|=
name|NNStorage
operator|.
name|getStorageFile
argument_list|(
name|sd
argument_list|,
name|NameNodeFile
operator|.
name|EDITS
argument_list|)
decl_stmt|;
assert|assert
name|edits
operator|.
name|exists
argument_list|()
operator|:
literal|"Expected edits file at "
operator|+
name|edits
assert|;
name|files
operator|.
name|add
argument_list|(
name|edits
argument_list|)
expr_stmt|;
name|File
name|editsNew
init|=
name|NNStorage
operator|.
name|getStorageFile
argument_list|(
name|sd
argument_list|,
name|NameNodeFile
operator|.
name|EDITS_NEW
argument_list|)
decl_stmt|;
if|if
condition|(
name|editsNew
operator|.
name|exists
argument_list|()
condition|)
block|{
name|files
operator|.
name|add
argument_list|(
name|editsNew
argument_list|)
expr_stmt|;
block|}
return|return
name|files
return|;
block|}
DECL|method|getLatestEditsFiles ()
specifier|private
name|List
argument_list|<
name|File
argument_list|>
name|getLatestEditsFiles
parameter_list|()
block|{
if|if
condition|(
name|latestNameCheckpointTime
operator|>
name|latestEditsCheckpointTime
condition|)
block|{
comment|// the image is already current, discard edits
name|LOG
operator|.
name|debug
argument_list|(
literal|"Name checkpoint time is newer than edits, not loading edits."
argument_list|)
expr_stmt|;
return|return
name|Collections
operator|.
expr|<
name|File
operator|>
name|emptyList
argument_list|()
return|;
block|}
return|return
name|getEditsInStorageDir
argument_list|(
name|latestEditsSD
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|getMaxSeenTxId ()
name|long
name|getMaxSeenTxId
parameter_list|()
block|{
return|return
literal|0L
return|;
block|}
DECL|method|getEditLogStreams (NNStorage storage)
specifier|static
name|Iterable
argument_list|<
name|EditLogInputStream
argument_list|>
name|getEditLogStreams
parameter_list|(
name|NNStorage
name|storage
parameter_list|)
throws|throws
name|IOException
block|{
name|FSImagePreTransactionalStorageInspector
name|inspector
init|=
operator|new
name|FSImagePreTransactionalStorageInspector
argument_list|()
decl_stmt|;
name|storage
operator|.
name|inspectStorageDirs
argument_list|(
name|inspector
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|EditLogInputStream
argument_list|>
name|editStreams
init|=
operator|new
name|ArrayList
argument_list|<
name|EditLogInputStream
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|File
name|f
range|:
name|inspector
operator|.
name|getLatestEditsFiles
argument_list|()
control|)
block|{
name|editStreams
operator|.
name|add
argument_list|(
operator|new
name|EditLogFileInputStream
argument_list|(
name|f
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|editStreams
return|;
block|}
block|}
end_class

end_unit

