begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdfs.server.namenode
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Time
operator|.
name|now
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Constructor
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URI
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceStability
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Options
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|permission
operator|.
name|FsPermission
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|HdfsConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|security
operator|.
name|token
operator|.
name|delegation
operator|.
name|DelegationTokenIdentifier
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|ExitUtil
operator|.
name|terminate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|HdfsServerConstants
operator|.
name|NamenodeRole
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|Storage
operator|.
name|FormatConfirmable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|Storage
operator|.
name|StorageDirectory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|FSEditLogOp
operator|.
name|AddOp
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|FSEditLogOp
operator|.
name|CancelDelegationTokenOp
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|FSEditLogOp
operator|.
name|CloseOp
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|FSEditLogOp
operator|.
name|ConcatDeleteOp
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|FSEditLogOp
operator|.
name|DeleteOp
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|FSEditLogOp
operator|.
name|GetDelegationTokenOp
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|FSEditLogOp
operator|.
name|LogSegmentOp
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|FSEditLogOp
operator|.
name|MkdirOp
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|FSEditLogOp
operator|.
name|OpInstanceCache
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|FSEditLogOp
operator|.
name|ReassignLeaseOp
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|FSEditLogOp
operator|.
name|RenameOldOp
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|FSEditLogOp
operator|.
name|RenameOp
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|FSEditLogOp
operator|.
name|RenewDelegationTokenOp
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|FSEditLogOp
operator|.
name|SetGenstampOp
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|FSEditLogOp
operator|.
name|SetOwnerOp
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|FSEditLogOp
operator|.
name|SetPermissionsOp
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|FSEditLogOp
operator|.
name|SetQuotaOp
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|FSEditLogOp
operator|.
name|SetReplicationOp
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|FSEditLogOp
operator|.
name|SymlinkOp
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|FSEditLogOp
operator|.
name|TimesOp
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|FSEditLogOp
operator|.
name|UpdateBlocksOp
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|FSEditLogOp
operator|.
name|UpdateMasterKeyOp
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|JournalSet
operator|.
name|JournalAndStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|metrics
operator|.
name|NameNodeMetrics
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|NamenodeRegistration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|NamespaceInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|RemoteEditLogManifest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|token
operator|.
name|delegation
operator|.
name|DelegationKey
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_comment
comment|/**  * FSEditLog maintains a log of the namespace modifications.  *   */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
annotation|@
name|InterfaceStability
operator|.
name|Evolving
DECL|class|FSEditLog
specifier|public
class|class
name|FSEditLog
block|{
DECL|field|LOG
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|FSEditLog
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/**    * State machine for edit log.    *     * In a non-HA setup:    *     * The log starts in UNITIALIZED state upon construction. Once it's    * initialized, it is usually in IN_SEGMENT state, indicating that edits may    * be written. In the middle of a roll, or while saving the namespace, it    * briefly enters the BETWEEN_LOG_SEGMENTS state, indicating that the previous    * segment has been closed, but the new one has not yet been opened.    *     * In an HA setup:    *     * The log starts in UNINITIALIZED state upon construction. Once it's    * initialized, it sits in the OPEN_FOR_READING state the entire time that the    * NN is in standby. Upon the NN transition to active, the log will be CLOSED,    * and then move to being BETWEEN_LOG_SEGMENTS, much as if the NN had just    * started up, and then will move to IN_SEGMENT so it can begin writing to the    * log. The log states will then revert to behaving as they do in a non-HA    * setup.    */
DECL|enum|State
specifier|private
enum|enum
name|State
block|{
DECL|enumConstant|UNINITIALIZED
name|UNINITIALIZED
block|,
DECL|enumConstant|BETWEEN_LOG_SEGMENTS
name|BETWEEN_LOG_SEGMENTS
block|,
DECL|enumConstant|IN_SEGMENT
name|IN_SEGMENT
block|,
DECL|enumConstant|OPEN_FOR_READING
name|OPEN_FOR_READING
block|,
DECL|enumConstant|CLOSED
name|CLOSED
block|;   }
DECL|field|state
specifier|private
name|State
name|state
init|=
name|State
operator|.
name|UNINITIALIZED
decl_stmt|;
comment|//initialize
DECL|field|journalSet
specifier|private
name|JournalSet
name|journalSet
init|=
literal|null
decl_stmt|;
DECL|field|editLogStream
specifier|private
name|EditLogOutputStream
name|editLogStream
init|=
literal|null
decl_stmt|;
comment|// a monotonically increasing counter that represents transactionIds.
DECL|field|txid
specifier|private
name|long
name|txid
init|=
literal|0
decl_stmt|;
comment|// stores the last synced transactionId.
DECL|field|synctxid
specifier|private
name|long
name|synctxid
init|=
literal|0
decl_stmt|;
comment|// the first txid of the log that's currently open for writing.
comment|// If this value is N, we are currently writing to edits_inprogress_N
DECL|field|curSegmentTxId
specifier|private
name|long
name|curSegmentTxId
init|=
name|HdfsConstants
operator|.
name|INVALID_TXID
decl_stmt|;
comment|// the time of printing the statistics to the log file.
DECL|field|lastPrintTime
specifier|private
name|long
name|lastPrintTime
decl_stmt|;
comment|// is a sync currently running?
DECL|field|isSyncRunning
specifier|private
specifier|volatile
name|boolean
name|isSyncRunning
decl_stmt|;
comment|// is an automatic sync scheduled?
DECL|field|isAutoSyncScheduled
specifier|private
specifier|volatile
name|boolean
name|isAutoSyncScheduled
init|=
literal|false
decl_stmt|;
comment|// these are statistics counters.
DECL|field|numTransactions
specifier|private
name|long
name|numTransactions
decl_stmt|;
comment|// number of transactions
DECL|field|numTransactionsBatchedInSync
specifier|private
name|long
name|numTransactionsBatchedInSync
decl_stmt|;
DECL|field|totalTimeTransactions
specifier|private
name|long
name|totalTimeTransactions
decl_stmt|;
comment|// total time for all transactions
DECL|field|metrics
specifier|private
name|NameNodeMetrics
name|metrics
decl_stmt|;
DECL|field|storage
specifier|private
name|NNStorage
name|storage
decl_stmt|;
DECL|field|conf
specifier|private
name|Configuration
name|conf
decl_stmt|;
DECL|field|editsDirs
specifier|private
name|List
argument_list|<
name|URI
argument_list|>
name|editsDirs
decl_stmt|;
DECL|field|cache
specifier|private
name|ThreadLocal
argument_list|<
name|OpInstanceCache
argument_list|>
name|cache
init|=
operator|new
name|ThreadLocal
argument_list|<
name|OpInstanceCache
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|protected
name|OpInstanceCache
name|initialValue
parameter_list|()
block|{
return|return
operator|new
name|OpInstanceCache
argument_list|()
return|;
block|}
block|}
decl_stmt|;
comment|/**    * The edit directories that are shared between primary and secondary.    */
DECL|field|sharedEditsDirs
specifier|private
name|List
argument_list|<
name|URI
argument_list|>
name|sharedEditsDirs
decl_stmt|;
DECL|class|TransactionId
specifier|private
specifier|static
class|class
name|TransactionId
block|{
DECL|field|txid
specifier|public
name|long
name|txid
decl_stmt|;
DECL|method|TransactionId (long value)
name|TransactionId
parameter_list|(
name|long
name|value
parameter_list|)
block|{
name|this
operator|.
name|txid
operator|=
name|value
expr_stmt|;
block|}
block|}
comment|// stores the most current transactionId of this thread.
DECL|field|myTransactionId
specifier|private
specifier|static
specifier|final
name|ThreadLocal
argument_list|<
name|TransactionId
argument_list|>
name|myTransactionId
init|=
operator|new
name|ThreadLocal
argument_list|<
name|TransactionId
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|protected
specifier|synchronized
name|TransactionId
name|initialValue
parameter_list|()
block|{
return|return
operator|new
name|TransactionId
argument_list|(
name|Long
operator|.
name|MAX_VALUE
argument_list|)
return|;
block|}
block|}
decl_stmt|;
comment|/**    * Constructor for FSEditLog. Underlying journals are constructed, but     * no streams are opened until open() is called.    *     * @param conf The namenode configuration    * @param storage Storage object used by namenode    * @param editsDirs List of journals to use    */
DECL|method|FSEditLog (Configuration conf, NNStorage storage, List<URI> editsDirs)
name|FSEditLog
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|NNStorage
name|storage
parameter_list|,
name|List
argument_list|<
name|URI
argument_list|>
name|editsDirs
parameter_list|)
block|{
name|init
argument_list|(
name|conf
argument_list|,
name|storage
argument_list|,
name|editsDirs
argument_list|)
expr_stmt|;
block|}
DECL|method|init (Configuration conf, NNStorage storage, List<URI> editsDirs)
specifier|private
name|void
name|init
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|NNStorage
name|storage
parameter_list|,
name|List
argument_list|<
name|URI
argument_list|>
name|editsDirs
parameter_list|)
block|{
name|isSyncRunning
operator|=
literal|false
expr_stmt|;
name|this
operator|.
name|conf
operator|=
name|conf
expr_stmt|;
name|this
operator|.
name|storage
operator|=
name|storage
expr_stmt|;
name|metrics
operator|=
name|NameNode
operator|.
name|getNameNodeMetrics
argument_list|()
expr_stmt|;
name|lastPrintTime
operator|=
name|now
argument_list|()
expr_stmt|;
comment|// If this list is empty, an error will be thrown on first use
comment|// of the editlog, as no journals will exist
name|this
operator|.
name|editsDirs
operator|=
name|Lists
operator|.
name|newArrayList
argument_list|(
name|editsDirs
argument_list|)
expr_stmt|;
name|this
operator|.
name|sharedEditsDirs
operator|=
name|FSNamesystem
operator|.
name|getSharedEditsDirs
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
DECL|method|initJournalsForWrite ()
specifier|public
specifier|synchronized
name|void
name|initJournalsForWrite
parameter_list|()
block|{
name|Preconditions
operator|.
name|checkState
argument_list|(
name|state
operator|==
name|State
operator|.
name|UNINITIALIZED
operator|||
name|state
operator|==
name|State
operator|.
name|CLOSED
argument_list|,
literal|"Unexpected state: %s"
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|initJournals
argument_list|(
name|this
operator|.
name|editsDirs
argument_list|)
expr_stmt|;
name|state
operator|=
name|State
operator|.
name|BETWEEN_LOG_SEGMENTS
expr_stmt|;
block|}
DECL|method|initSharedJournalsForRead ()
specifier|public
specifier|synchronized
name|void
name|initSharedJournalsForRead
parameter_list|()
block|{
if|if
condition|(
name|state
operator|==
name|State
operator|.
name|OPEN_FOR_READING
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Initializing shared journals for READ, already open for READ"
argument_list|,
operator|new
name|Exception
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
name|Preconditions
operator|.
name|checkState
argument_list|(
name|state
operator|==
name|State
operator|.
name|UNINITIALIZED
operator|||
name|state
operator|==
name|State
operator|.
name|CLOSED
argument_list|)
expr_stmt|;
name|initJournals
argument_list|(
name|this
operator|.
name|sharedEditsDirs
argument_list|)
expr_stmt|;
name|state
operator|=
name|State
operator|.
name|OPEN_FOR_READING
expr_stmt|;
block|}
DECL|method|initJournals (List<URI> dirs)
specifier|private
specifier|synchronized
name|void
name|initJournals
parameter_list|(
name|List
argument_list|<
name|URI
argument_list|>
name|dirs
parameter_list|)
block|{
name|int
name|minimumRedundantJournals
init|=
name|conf
operator|.
name|getInt
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_EDITS_DIR_MINIMUM_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_EDITS_DIR_MINIMUM_DEFAULT
argument_list|)
decl_stmt|;
name|journalSet
operator|=
operator|new
name|JournalSet
argument_list|(
name|minimumRedundantJournals
argument_list|)
expr_stmt|;
for|for
control|(
name|URI
name|u
range|:
name|dirs
control|)
block|{
name|boolean
name|required
init|=
name|FSNamesystem
operator|.
name|getRequiredNamespaceEditsDirs
argument_list|(
name|conf
argument_list|)
operator|.
name|contains
argument_list|(
name|u
argument_list|)
decl_stmt|;
if|if
condition|(
name|u
operator|.
name|getScheme
argument_list|()
operator|.
name|equals
argument_list|(
name|NNStorage
operator|.
name|LOCAL_URI_SCHEME
argument_list|)
condition|)
block|{
name|StorageDirectory
name|sd
init|=
name|storage
operator|.
name|getStorageDirectory
argument_list|(
name|u
argument_list|)
decl_stmt|;
if|if
condition|(
name|sd
operator|!=
literal|null
condition|)
block|{
name|journalSet
operator|.
name|add
argument_list|(
operator|new
name|FileJournalManager
argument_list|(
name|sd
argument_list|,
name|storage
argument_list|)
argument_list|,
name|required
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|journalSet
operator|.
name|add
argument_list|(
name|createJournal
argument_list|(
name|u
argument_list|)
argument_list|,
name|required
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|journalSet
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"No edits directories configured!"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Get the list of URIs the editlog is using for storage    * @return collection of URIs in use by the edit log    */
DECL|method|getEditURIs ()
name|Collection
argument_list|<
name|URI
argument_list|>
name|getEditURIs
parameter_list|()
block|{
return|return
name|editsDirs
return|;
block|}
comment|/**    * Initialize the output stream for logging, opening the first    * log segment.    */
DECL|method|openForWrite ()
specifier|synchronized
name|void
name|openForWrite
parameter_list|()
throws|throws
name|IOException
block|{
name|Preconditions
operator|.
name|checkState
argument_list|(
name|state
operator|==
name|State
operator|.
name|BETWEEN_LOG_SEGMENTS
argument_list|,
literal|"Bad state: %s"
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|long
name|segmentTxId
init|=
name|getLastWrittenTxId
argument_list|()
operator|+
literal|1
decl_stmt|;
comment|// Safety check: we should never start a segment if there are
comment|// newer txids readable.
name|List
argument_list|<
name|EditLogInputStream
argument_list|>
name|streams
init|=
operator|new
name|ArrayList
argument_list|<
name|EditLogInputStream
argument_list|>
argument_list|()
decl_stmt|;
name|journalSet
operator|.
name|selectInputStreams
argument_list|(
name|streams
argument_list|,
name|segmentTxId
argument_list|,
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|streams
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|String
name|error
init|=
name|String
operator|.
name|format
argument_list|(
literal|"Cannot start writing at txid %s "
operator|+
literal|"when there is a stream available for read: %s"
argument_list|,
name|segmentTxId
argument_list|,
name|streams
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|IOUtils
operator|.
name|cleanup
argument_list|(
name|LOG
argument_list|,
name|streams
operator|.
name|toArray
argument_list|(
operator|new
name|EditLogInputStream
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|error
argument_list|)
throw|;
block|}
name|startLogSegmentAndWriteHeaderTxn
argument_list|(
name|segmentTxId
argument_list|)
expr_stmt|;
assert|assert
name|state
operator|==
name|State
operator|.
name|IN_SEGMENT
operator|:
literal|"Bad state: "
operator|+
name|state
assert|;
block|}
comment|/**    * @return true if the log is currently open in write mode, regardless    * of whether it actually has an open segment.    */
DECL|method|isOpenForWrite ()
specifier|synchronized
name|boolean
name|isOpenForWrite
parameter_list|()
block|{
return|return
name|state
operator|==
name|State
operator|.
name|IN_SEGMENT
operator|||
name|state
operator|==
name|State
operator|.
name|BETWEEN_LOG_SEGMENTS
return|;
block|}
comment|/**    * @return true if the log is open in write mode and has a segment open    * ready to take edits.    */
DECL|method|isSegmentOpen ()
specifier|synchronized
name|boolean
name|isSegmentOpen
parameter_list|()
block|{
return|return
name|state
operator|==
name|State
operator|.
name|IN_SEGMENT
return|;
block|}
comment|/**    * @return true if the log is open in read mode.    */
DECL|method|isOpenForRead ()
specifier|public
specifier|synchronized
name|boolean
name|isOpenForRead
parameter_list|()
block|{
return|return
name|state
operator|==
name|State
operator|.
name|OPEN_FOR_READING
return|;
block|}
comment|/**    * Shutdown the file store.    */
DECL|method|close ()
specifier|synchronized
name|void
name|close
parameter_list|()
block|{
if|if
condition|(
name|state
operator|==
name|State
operator|.
name|CLOSED
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Closing log when already closed"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|state
operator|==
name|State
operator|.
name|IN_SEGMENT
condition|)
block|{
assert|assert
name|editLogStream
operator|!=
literal|null
assert|;
name|waitForSyncToFinish
argument_list|()
expr_stmt|;
name|endCurrentLogSegment
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|journalSet
operator|!=
literal|null
operator|&&
operator|!
name|journalSet
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
try|try
block|{
name|journalSet
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Error closing journalSet"
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
block|}
block|}
name|state
operator|=
name|State
operator|.
name|CLOSED
expr_stmt|;
block|}
comment|/**    * Format all configured journals which are not file-based.    *     * File-based journals are skipped, since they are formatted by the    * Storage format code.    */
DECL|method|formatNonFileJournals (NamespaceInfo nsInfo)
name|void
name|formatNonFileJournals
parameter_list|(
name|NamespaceInfo
name|nsInfo
parameter_list|)
throws|throws
name|IOException
block|{
name|Preconditions
operator|.
name|checkState
argument_list|(
name|state
operator|==
name|State
operator|.
name|BETWEEN_LOG_SEGMENTS
argument_list|,
literal|"Bad state: %s"
argument_list|,
name|state
argument_list|)
expr_stmt|;
for|for
control|(
name|JournalManager
name|jm
range|:
name|journalSet
operator|.
name|getJournalManagers
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|jm
operator|instanceof
name|FileJournalManager
operator|)
condition|)
block|{
name|jm
operator|.
name|format
argument_list|(
name|nsInfo
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|getFormatConfirmables ()
name|List
argument_list|<
name|FormatConfirmable
argument_list|>
name|getFormatConfirmables
parameter_list|()
block|{
name|Preconditions
operator|.
name|checkState
argument_list|(
name|state
operator|==
name|State
operator|.
name|BETWEEN_LOG_SEGMENTS
argument_list|,
literal|"Bad state: %s"
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|FormatConfirmable
argument_list|>
name|ret
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
for|for
control|(
specifier|final
name|JournalManager
name|jm
range|:
name|journalSet
operator|.
name|getJournalManagers
argument_list|()
control|)
block|{
comment|// The FJMs are confirmed separately since they are also
comment|// StorageDirectories
if|if
condition|(
operator|!
operator|(
name|jm
operator|instanceof
name|FileJournalManager
operator|)
condition|)
block|{
name|ret
operator|.
name|add
argument_list|(
name|jm
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|ret
return|;
block|}
comment|/**    * Write an operation to the edit log. Do not sync to persistent    * store yet.    */
DECL|method|logEdit (final FSEditLogOp op)
name|void
name|logEdit
parameter_list|(
specifier|final
name|FSEditLogOp
name|op
parameter_list|)
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
assert|assert
name|isOpenForWrite
argument_list|()
operator|:
literal|"bad state: "
operator|+
name|state
assert|;
comment|// wait if an automatic sync is scheduled
name|waitIfAutoSyncScheduled
argument_list|()
expr_stmt|;
name|long
name|start
init|=
name|beginTransaction
argument_list|()
decl_stmt|;
name|op
operator|.
name|setTransactionId
argument_list|(
name|txid
argument_list|)
expr_stmt|;
try|try
block|{
name|editLogStream
operator|.
name|write
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
comment|// All journals failed, it is handled in logSync.
block|}
name|endTransaction
argument_list|(
name|start
argument_list|)
expr_stmt|;
comment|// check if it is time to schedule an automatic sync
if|if
condition|(
operator|!
name|shouldForceSync
argument_list|()
condition|)
block|{
return|return;
block|}
name|isAutoSyncScheduled
operator|=
literal|true
expr_stmt|;
block|}
comment|// sync buffered edit log entries to persistent store
name|logSync
argument_list|()
expr_stmt|;
block|}
comment|/**    * Wait if an automatic sync is scheduled    * @throws InterruptedException    */
DECL|method|waitIfAutoSyncScheduled ()
specifier|synchronized
name|void
name|waitIfAutoSyncScheduled
parameter_list|()
block|{
try|try
block|{
while|while
condition|(
name|isAutoSyncScheduled
condition|)
block|{
name|this
operator|.
name|wait
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{     }
block|}
comment|/**    * Signal that an automatic sync scheduling is done if it is scheduled    */
DECL|method|doneWithAutoSyncScheduling ()
specifier|synchronized
name|void
name|doneWithAutoSyncScheduling
parameter_list|()
block|{
if|if
condition|(
name|isAutoSyncScheduled
condition|)
block|{
name|isAutoSyncScheduled
operator|=
literal|false
expr_stmt|;
name|notifyAll
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Check if should automatically sync buffered edits to     * persistent store    *     * @return true if any of the edit stream says that it should sync    */
DECL|method|shouldForceSync ()
specifier|private
name|boolean
name|shouldForceSync
parameter_list|()
block|{
return|return
name|editLogStream
operator|.
name|shouldForceSync
argument_list|()
return|;
block|}
DECL|method|beginTransaction ()
specifier|private
name|long
name|beginTransaction
parameter_list|()
block|{
assert|assert
name|Thread
operator|.
name|holdsLock
argument_list|(
name|this
argument_list|)
assert|;
comment|// get a new transactionId
name|txid
operator|++
expr_stmt|;
comment|//
comment|// record the transactionId when new data was written to the edits log
comment|//
name|TransactionId
name|id
init|=
name|myTransactionId
operator|.
name|get
argument_list|()
decl_stmt|;
name|id
operator|.
name|txid
operator|=
name|txid
expr_stmt|;
return|return
name|now
argument_list|()
return|;
block|}
DECL|method|endTransaction (long start)
specifier|private
name|void
name|endTransaction
parameter_list|(
name|long
name|start
parameter_list|)
block|{
assert|assert
name|Thread
operator|.
name|holdsLock
argument_list|(
name|this
argument_list|)
assert|;
comment|// update statistics
name|long
name|end
init|=
name|now
argument_list|()
decl_stmt|;
name|numTransactions
operator|++
expr_stmt|;
name|totalTimeTransactions
operator|+=
operator|(
name|end
operator|-
name|start
operator|)
expr_stmt|;
if|if
condition|(
name|metrics
operator|!=
literal|null
condition|)
comment|// Metrics is non-null only when used inside name node
name|metrics
operator|.
name|addTransaction
argument_list|(
name|end
operator|-
name|start
argument_list|)
expr_stmt|;
block|}
comment|/**    * Return the transaction ID of the last transaction written to the log.    */
DECL|method|getLastWrittenTxId ()
specifier|public
specifier|synchronized
name|long
name|getLastWrittenTxId
parameter_list|()
block|{
return|return
name|txid
return|;
block|}
comment|/**    * @return the first transaction ID in the current log segment    */
DECL|method|getCurSegmentTxId ()
specifier|synchronized
name|long
name|getCurSegmentTxId
parameter_list|()
block|{
name|Preconditions
operator|.
name|checkState
argument_list|(
name|isSegmentOpen
argument_list|()
argument_list|,
literal|"Bad state: %s"
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
name|curSegmentTxId
return|;
block|}
comment|/**    * Set the transaction ID to use for the next transaction written.    */
DECL|method|setNextTxId (long nextTxId)
specifier|synchronized
name|void
name|setNextTxId
parameter_list|(
name|long
name|nextTxId
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|synctxid
operator|<=
name|txid
operator|&&
name|nextTxId
operator|>=
name|txid
argument_list|,
literal|"May not decrease txid."
operator|+
literal|" synctxid=%s txid=%s nextTxId=%s"
argument_list|,
name|synctxid
argument_list|,
name|txid
argument_list|,
name|nextTxId
argument_list|)
expr_stmt|;
name|txid
operator|=
name|nextTxId
operator|-
literal|1
expr_stmt|;
block|}
comment|/**    * Blocks until all ongoing edits have been synced to disk.    * This differs from logSync in that it waits for edits that have been    * written by other threads, not just edits from the calling thread.    *    * NOTE: this should be done while holding the FSNamesystem lock, or    * else more operations can start writing while this is in progress.    */
DECL|method|logSyncAll ()
name|void
name|logSyncAll
parameter_list|()
block|{
comment|// Record the most recent transaction ID as our own id
synchronized|synchronized
init|(
name|this
init|)
block|{
name|TransactionId
name|id
init|=
name|myTransactionId
operator|.
name|get
argument_list|()
decl_stmt|;
name|id
operator|.
name|txid
operator|=
name|txid
expr_stmt|;
block|}
comment|// Then make sure we're synced up to this point
name|logSync
argument_list|()
expr_stmt|;
block|}
comment|/**    * Sync all modifications done by this thread.    *    * The internal concurrency design of this class is as follows:    *   - Log items are written synchronized into an in-memory buffer,    *     and each assigned a transaction ID.    *   - When a thread (client) would like to sync all of its edits, logSync()    *     uses a ThreadLocal transaction ID to determine what edit number must    *     be synced to.    *   - The isSyncRunning volatile boolean tracks whether a sync is currently    *     under progress.    *    * The data is double-buffered within each edit log implementation so that    * in-memory writing can occur in parallel with the on-disk writing.    *    * Each sync occurs in three steps:    *   1. synchronized, it swaps the double buffer and sets the isSyncRunning    *      flag.    *   2. unsynchronized, it flushes the data to storage    *   3. synchronized, it resets the flag and notifies anyone waiting on the    *      sync.    *    * The lack of synchronization on step 2 allows other threads to continue    * to write into the memory buffer while the sync is in progress.    * Because this step is unsynchronized, actions that need to avoid    * concurrency with sync() should be synchronized and also call    * waitForSyncToFinish() before assuming they are running alone.    */
DECL|method|logSync ()
specifier|public
name|void
name|logSync
parameter_list|()
block|{
name|long
name|syncStart
init|=
literal|0
decl_stmt|;
comment|// Fetch the transactionId of this thread.
name|long
name|mytxid
init|=
name|myTransactionId
operator|.
name|get
argument_list|()
operator|.
name|txid
decl_stmt|;
name|boolean
name|sync
init|=
literal|false
decl_stmt|;
try|try
block|{
name|EditLogOutputStream
name|logStream
init|=
literal|null
decl_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
try|try
block|{
name|printStatistics
argument_list|(
literal|false
argument_list|)
expr_stmt|;
comment|// if somebody is already syncing, then wait
while|while
condition|(
name|mytxid
operator|>
name|synctxid
operator|&&
name|isSyncRunning
condition|)
block|{
try|try
block|{
name|wait
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{             }
block|}
comment|//
comment|// If this transaction was already flushed, then nothing to do
comment|//
if|if
condition|(
name|mytxid
operator|<=
name|synctxid
condition|)
block|{
name|numTransactionsBatchedInSync
operator|++
expr_stmt|;
if|if
condition|(
name|metrics
operator|!=
literal|null
condition|)
block|{
comment|// Metrics is non-null only when used inside name node
name|metrics
operator|.
name|incrTransactionsBatchedInSync
argument_list|()
expr_stmt|;
block|}
return|return;
block|}
comment|// now, this thread will do the sync
name|syncStart
operator|=
name|txid
expr_stmt|;
name|isSyncRunning
operator|=
literal|true
expr_stmt|;
name|sync
operator|=
literal|true
expr_stmt|;
comment|// swap buffers
try|try
block|{
if|if
condition|(
name|journalSet
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"No journals available to flush"
argument_list|)
throw|;
block|}
name|editLogStream
operator|.
name|setReadyToFlush
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
specifier|final
name|String
name|msg
init|=
literal|"Could not sync enough journals to persistent storage "
operator|+
literal|"due to "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
operator|+
literal|". "
operator|+
literal|"Unsynced transactions: "
operator|+
operator|(
name|txid
operator|-
name|synctxid
operator|)
decl_stmt|;
name|LOG
operator|.
name|fatal
argument_list|(
name|msg
argument_list|,
operator|new
name|Exception
argument_list|()
argument_list|)
expr_stmt|;
name|terminate
argument_list|(
literal|1
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
comment|// Prevent RuntimeException from blocking other log edit write
name|doneWithAutoSyncScheduling
argument_list|()
expr_stmt|;
block|}
comment|//editLogStream may become null,
comment|//so store a local variable for flush.
name|logStream
operator|=
name|editLogStream
expr_stmt|;
block|}
comment|// do the sync
name|long
name|start
init|=
name|now
argument_list|()
decl_stmt|;
try|try
block|{
if|if
condition|(
name|logStream
operator|!=
literal|null
condition|)
block|{
name|logStream
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
specifier|final
name|String
name|msg
init|=
literal|"Could not sync enough journals to persistent storage. "
operator|+
literal|"Unsynced transactions: "
operator|+
operator|(
name|txid
operator|-
name|synctxid
operator|)
decl_stmt|;
name|LOG
operator|.
name|fatal
argument_list|(
name|msg
argument_list|,
operator|new
name|Exception
argument_list|()
argument_list|)
expr_stmt|;
name|terminate
argument_list|(
literal|1
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
block|}
name|long
name|elapsed
init|=
name|now
argument_list|()
operator|-
name|start
decl_stmt|;
if|if
condition|(
name|metrics
operator|!=
literal|null
condition|)
block|{
comment|// Metrics non-null only when used inside name node
name|metrics
operator|.
name|addSync
argument_list|(
name|elapsed
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
comment|// Prevent RuntimeException from blocking other log edit sync
synchronized|synchronized
init|(
name|this
init|)
block|{
if|if
condition|(
name|sync
condition|)
block|{
name|synctxid
operator|=
name|syncStart
expr_stmt|;
name|isSyncRunning
operator|=
literal|false
expr_stmt|;
block|}
name|this
operator|.
name|notifyAll
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|//
comment|// print statistics every 1 minute.
comment|//
DECL|method|printStatistics (boolean force)
specifier|private
name|void
name|printStatistics
parameter_list|(
name|boolean
name|force
parameter_list|)
block|{
name|long
name|now
init|=
name|now
argument_list|()
decl_stmt|;
if|if
condition|(
name|lastPrintTime
operator|+
literal|60000
operator|>
name|now
operator|&&
operator|!
name|force
condition|)
block|{
return|return;
block|}
name|lastPrintTime
operator|=
name|now
expr_stmt|;
name|StringBuilder
name|buf
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|"Number of transactions: "
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|numTransactions
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|" Total time for transactions(ms): "
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|totalTimeTransactions
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|"Number of transactions batched in Syncs: "
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|numTransactionsBatchedInSync
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|" Number of syncs: "
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|editLogStream
operator|.
name|getNumSync
argument_list|()
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|" SyncTimes(ms): "
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|journalSet
operator|.
name|getSyncTimes
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
comment|/**     * Add open lease record to edit log.     * Records the block locations of the last block.    */
DECL|method|logOpenFile (String path, INodeFileUnderConstruction newNode)
specifier|public
name|void
name|logOpenFile
parameter_list|(
name|String
name|path
parameter_list|,
name|INodeFileUnderConstruction
name|newNode
parameter_list|)
block|{
name|AddOp
name|op
init|=
name|AddOp
operator|.
name|getInstance
argument_list|(
name|cache
operator|.
name|get
argument_list|()
argument_list|)
operator|.
name|setPath
argument_list|(
name|path
argument_list|)
operator|.
name|setReplication
argument_list|(
name|newNode
operator|.
name|getReplication
argument_list|()
argument_list|)
operator|.
name|setModificationTime
argument_list|(
name|newNode
operator|.
name|getModificationTime
argument_list|()
argument_list|)
operator|.
name|setAccessTime
argument_list|(
name|newNode
operator|.
name|getAccessTime
argument_list|()
argument_list|)
operator|.
name|setBlockSize
argument_list|(
name|newNode
operator|.
name|getPreferredBlockSize
argument_list|()
argument_list|)
operator|.
name|setBlocks
argument_list|(
name|newNode
operator|.
name|getBlocks
argument_list|()
argument_list|)
operator|.
name|setPermissionStatus
argument_list|(
name|newNode
operator|.
name|getPermissionStatus
argument_list|()
argument_list|)
operator|.
name|setClientName
argument_list|(
name|newNode
operator|.
name|getClientName
argument_list|()
argument_list|)
operator|.
name|setClientMachine
argument_list|(
name|newNode
operator|.
name|getClientMachine
argument_list|()
argument_list|)
decl_stmt|;
name|logEdit
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
comment|/**     * Add close lease record to edit log.    */
DECL|method|logCloseFile (String path, INodeFile newNode)
specifier|public
name|void
name|logCloseFile
parameter_list|(
name|String
name|path
parameter_list|,
name|INodeFile
name|newNode
parameter_list|)
block|{
name|CloseOp
name|op
init|=
name|CloseOp
operator|.
name|getInstance
argument_list|(
name|cache
operator|.
name|get
argument_list|()
argument_list|)
operator|.
name|setPath
argument_list|(
name|path
argument_list|)
operator|.
name|setReplication
argument_list|(
name|newNode
operator|.
name|getReplication
argument_list|()
argument_list|)
operator|.
name|setModificationTime
argument_list|(
name|newNode
operator|.
name|getModificationTime
argument_list|()
argument_list|)
operator|.
name|setAccessTime
argument_list|(
name|newNode
operator|.
name|getAccessTime
argument_list|()
argument_list|)
operator|.
name|setBlockSize
argument_list|(
name|newNode
operator|.
name|getPreferredBlockSize
argument_list|()
argument_list|)
operator|.
name|setBlocks
argument_list|(
name|newNode
operator|.
name|getBlocks
argument_list|()
argument_list|)
operator|.
name|setPermissionStatus
argument_list|(
name|newNode
operator|.
name|getPermissionStatus
argument_list|()
argument_list|)
decl_stmt|;
name|logEdit
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
DECL|method|logUpdateBlocks (String path, INodeFileUnderConstruction file)
specifier|public
name|void
name|logUpdateBlocks
parameter_list|(
name|String
name|path
parameter_list|,
name|INodeFileUnderConstruction
name|file
parameter_list|)
block|{
name|UpdateBlocksOp
name|op
init|=
name|UpdateBlocksOp
operator|.
name|getInstance
argument_list|(
name|cache
operator|.
name|get
argument_list|()
argument_list|)
operator|.
name|setPath
argument_list|(
name|path
argument_list|)
operator|.
name|setBlocks
argument_list|(
name|file
operator|.
name|getBlocks
argument_list|()
argument_list|)
decl_stmt|;
name|logEdit
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
comment|/**     * Add create directory record to edit log    */
DECL|method|logMkDir (String path, INode newNode)
specifier|public
name|void
name|logMkDir
parameter_list|(
name|String
name|path
parameter_list|,
name|INode
name|newNode
parameter_list|)
block|{
name|MkdirOp
name|op
init|=
name|MkdirOp
operator|.
name|getInstance
argument_list|(
name|cache
operator|.
name|get
argument_list|()
argument_list|)
operator|.
name|setPath
argument_list|(
name|path
argument_list|)
operator|.
name|setTimestamp
argument_list|(
name|newNode
operator|.
name|getModificationTime
argument_list|()
argument_list|)
operator|.
name|setPermissionStatus
argument_list|(
name|newNode
operator|.
name|getPermissionStatus
argument_list|()
argument_list|)
decl_stmt|;
name|logEdit
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
comment|/**     * Add rename record to edit log    * TODO: use String parameters until just before writing to disk    */
DECL|method|logRename (String src, String dst, long timestamp)
name|void
name|logRename
parameter_list|(
name|String
name|src
parameter_list|,
name|String
name|dst
parameter_list|,
name|long
name|timestamp
parameter_list|)
block|{
name|RenameOldOp
name|op
init|=
name|RenameOldOp
operator|.
name|getInstance
argument_list|(
name|cache
operator|.
name|get
argument_list|()
argument_list|)
operator|.
name|setSource
argument_list|(
name|src
argument_list|)
operator|.
name|setDestination
argument_list|(
name|dst
argument_list|)
operator|.
name|setTimestamp
argument_list|(
name|timestamp
argument_list|)
decl_stmt|;
name|logEdit
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
comment|/**     * Add rename record to edit log    */
DECL|method|logRename (String src, String dst, long timestamp, Options.Rename... options)
name|void
name|logRename
parameter_list|(
name|String
name|src
parameter_list|,
name|String
name|dst
parameter_list|,
name|long
name|timestamp
parameter_list|,
name|Options
operator|.
name|Rename
modifier|...
name|options
parameter_list|)
block|{
name|RenameOp
name|op
init|=
name|RenameOp
operator|.
name|getInstance
argument_list|(
name|cache
operator|.
name|get
argument_list|()
argument_list|)
operator|.
name|setSource
argument_list|(
name|src
argument_list|)
operator|.
name|setDestination
argument_list|(
name|dst
argument_list|)
operator|.
name|setTimestamp
argument_list|(
name|timestamp
argument_list|)
operator|.
name|setOptions
argument_list|(
name|options
argument_list|)
decl_stmt|;
name|logEdit
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
comment|/**     * Add set replication record to edit log    */
DECL|method|logSetReplication (String src, short replication)
name|void
name|logSetReplication
parameter_list|(
name|String
name|src
parameter_list|,
name|short
name|replication
parameter_list|)
block|{
name|SetReplicationOp
name|op
init|=
name|SetReplicationOp
operator|.
name|getInstance
argument_list|(
name|cache
operator|.
name|get
argument_list|()
argument_list|)
operator|.
name|setPath
argument_list|(
name|src
argument_list|)
operator|.
name|setReplication
argument_list|(
name|replication
argument_list|)
decl_stmt|;
name|logEdit
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
comment|/** Add set namespace quota record to edit log    *     * @param src the string representation of the path to a directory    * @param quota the directory size limit    */
DECL|method|logSetQuota (String src, long nsQuota, long dsQuota)
name|void
name|logSetQuota
parameter_list|(
name|String
name|src
parameter_list|,
name|long
name|nsQuota
parameter_list|,
name|long
name|dsQuota
parameter_list|)
block|{
name|SetQuotaOp
name|op
init|=
name|SetQuotaOp
operator|.
name|getInstance
argument_list|(
name|cache
operator|.
name|get
argument_list|()
argument_list|)
operator|.
name|setSource
argument_list|(
name|src
argument_list|)
operator|.
name|setNSQuota
argument_list|(
name|nsQuota
argument_list|)
operator|.
name|setDSQuota
argument_list|(
name|dsQuota
argument_list|)
decl_stmt|;
name|logEdit
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
comment|/**  Add set permissions record to edit log */
DECL|method|logSetPermissions (String src, FsPermission permissions)
name|void
name|logSetPermissions
parameter_list|(
name|String
name|src
parameter_list|,
name|FsPermission
name|permissions
parameter_list|)
block|{
name|SetPermissionsOp
name|op
init|=
name|SetPermissionsOp
operator|.
name|getInstance
argument_list|(
name|cache
operator|.
name|get
argument_list|()
argument_list|)
operator|.
name|setSource
argument_list|(
name|src
argument_list|)
operator|.
name|setPermissions
argument_list|(
name|permissions
argument_list|)
decl_stmt|;
name|logEdit
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
comment|/**  Add set owner record to edit log */
DECL|method|logSetOwner (String src, String username, String groupname)
name|void
name|logSetOwner
parameter_list|(
name|String
name|src
parameter_list|,
name|String
name|username
parameter_list|,
name|String
name|groupname
parameter_list|)
block|{
name|SetOwnerOp
name|op
init|=
name|SetOwnerOp
operator|.
name|getInstance
argument_list|(
name|cache
operator|.
name|get
argument_list|()
argument_list|)
operator|.
name|setSource
argument_list|(
name|src
argument_list|)
operator|.
name|setUser
argument_list|(
name|username
argument_list|)
operator|.
name|setGroup
argument_list|(
name|groupname
argument_list|)
decl_stmt|;
name|logEdit
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
comment|/**    * concat(trg,src..) log    */
DECL|method|logConcat (String trg, String [] srcs, long timestamp)
name|void
name|logConcat
parameter_list|(
name|String
name|trg
parameter_list|,
name|String
index|[]
name|srcs
parameter_list|,
name|long
name|timestamp
parameter_list|)
block|{
name|ConcatDeleteOp
name|op
init|=
name|ConcatDeleteOp
operator|.
name|getInstance
argument_list|(
name|cache
operator|.
name|get
argument_list|()
argument_list|)
operator|.
name|setTarget
argument_list|(
name|trg
argument_list|)
operator|.
name|setSources
argument_list|(
name|srcs
argument_list|)
operator|.
name|setTimestamp
argument_list|(
name|timestamp
argument_list|)
decl_stmt|;
name|logEdit
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
comment|/**     * Add delete file record to edit log    */
DECL|method|logDelete (String src, long timestamp)
name|void
name|logDelete
parameter_list|(
name|String
name|src
parameter_list|,
name|long
name|timestamp
parameter_list|)
block|{
name|DeleteOp
name|op
init|=
name|DeleteOp
operator|.
name|getInstance
argument_list|(
name|cache
operator|.
name|get
argument_list|()
argument_list|)
operator|.
name|setPath
argument_list|(
name|src
argument_list|)
operator|.
name|setTimestamp
argument_list|(
name|timestamp
argument_list|)
decl_stmt|;
name|logEdit
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
comment|/**     * Add generation stamp record to edit log    */
DECL|method|logGenerationStamp (long genstamp)
name|void
name|logGenerationStamp
parameter_list|(
name|long
name|genstamp
parameter_list|)
block|{
name|SetGenstampOp
name|op
init|=
name|SetGenstampOp
operator|.
name|getInstance
argument_list|(
name|cache
operator|.
name|get
argument_list|()
argument_list|)
operator|.
name|setGenerationStamp
argument_list|(
name|genstamp
argument_list|)
decl_stmt|;
name|logEdit
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
comment|/**     * Add access time record to edit log    */
DECL|method|logTimes (String src, long mtime, long atime)
name|void
name|logTimes
parameter_list|(
name|String
name|src
parameter_list|,
name|long
name|mtime
parameter_list|,
name|long
name|atime
parameter_list|)
block|{
name|TimesOp
name|op
init|=
name|TimesOp
operator|.
name|getInstance
argument_list|(
name|cache
operator|.
name|get
argument_list|()
argument_list|)
operator|.
name|setPath
argument_list|(
name|src
argument_list|)
operator|.
name|setModificationTime
argument_list|(
name|mtime
argument_list|)
operator|.
name|setAccessTime
argument_list|(
name|atime
argument_list|)
decl_stmt|;
name|logEdit
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
comment|/**     * Add a create symlink record.    */
DECL|method|logSymlink (String path, String value, long mtime, long atime, INodeSymlink node)
name|void
name|logSymlink
parameter_list|(
name|String
name|path
parameter_list|,
name|String
name|value
parameter_list|,
name|long
name|mtime
parameter_list|,
name|long
name|atime
parameter_list|,
name|INodeSymlink
name|node
parameter_list|)
block|{
name|SymlinkOp
name|op
init|=
name|SymlinkOp
operator|.
name|getInstance
argument_list|(
name|cache
operator|.
name|get
argument_list|()
argument_list|)
operator|.
name|setPath
argument_list|(
name|path
argument_list|)
operator|.
name|setValue
argument_list|(
name|value
argument_list|)
operator|.
name|setModificationTime
argument_list|(
name|mtime
argument_list|)
operator|.
name|setAccessTime
argument_list|(
name|atime
argument_list|)
operator|.
name|setPermissionStatus
argument_list|(
name|node
operator|.
name|getPermissionStatus
argument_list|()
argument_list|)
decl_stmt|;
name|logEdit
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
comment|/**    * log delegation token to edit log    * @param id DelegationTokenIdentifier    * @param expiryTime of the token    */
DECL|method|logGetDelegationToken (DelegationTokenIdentifier id, long expiryTime)
name|void
name|logGetDelegationToken
parameter_list|(
name|DelegationTokenIdentifier
name|id
parameter_list|,
name|long
name|expiryTime
parameter_list|)
block|{
name|GetDelegationTokenOp
name|op
init|=
name|GetDelegationTokenOp
operator|.
name|getInstance
argument_list|(
name|cache
operator|.
name|get
argument_list|()
argument_list|)
operator|.
name|setDelegationTokenIdentifier
argument_list|(
name|id
argument_list|)
operator|.
name|setExpiryTime
argument_list|(
name|expiryTime
argument_list|)
decl_stmt|;
name|logEdit
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
DECL|method|logRenewDelegationToken (DelegationTokenIdentifier id, long expiryTime)
name|void
name|logRenewDelegationToken
parameter_list|(
name|DelegationTokenIdentifier
name|id
parameter_list|,
name|long
name|expiryTime
parameter_list|)
block|{
name|RenewDelegationTokenOp
name|op
init|=
name|RenewDelegationTokenOp
operator|.
name|getInstance
argument_list|(
name|cache
operator|.
name|get
argument_list|()
argument_list|)
operator|.
name|setDelegationTokenIdentifier
argument_list|(
name|id
argument_list|)
operator|.
name|setExpiryTime
argument_list|(
name|expiryTime
argument_list|)
decl_stmt|;
name|logEdit
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
DECL|method|logCancelDelegationToken (DelegationTokenIdentifier id)
name|void
name|logCancelDelegationToken
parameter_list|(
name|DelegationTokenIdentifier
name|id
parameter_list|)
block|{
name|CancelDelegationTokenOp
name|op
init|=
name|CancelDelegationTokenOp
operator|.
name|getInstance
argument_list|(
name|cache
operator|.
name|get
argument_list|()
argument_list|)
operator|.
name|setDelegationTokenIdentifier
argument_list|(
name|id
argument_list|)
decl_stmt|;
name|logEdit
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
DECL|method|logUpdateMasterKey (DelegationKey key)
name|void
name|logUpdateMasterKey
parameter_list|(
name|DelegationKey
name|key
parameter_list|)
block|{
name|UpdateMasterKeyOp
name|op
init|=
name|UpdateMasterKeyOp
operator|.
name|getInstance
argument_list|(
name|cache
operator|.
name|get
argument_list|()
argument_list|)
operator|.
name|setDelegationKey
argument_list|(
name|key
argument_list|)
decl_stmt|;
name|logEdit
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
DECL|method|logReassignLease (String leaseHolder, String src, String newHolder)
name|void
name|logReassignLease
parameter_list|(
name|String
name|leaseHolder
parameter_list|,
name|String
name|src
parameter_list|,
name|String
name|newHolder
parameter_list|)
block|{
name|ReassignLeaseOp
name|op
init|=
name|ReassignLeaseOp
operator|.
name|getInstance
argument_list|(
name|cache
operator|.
name|get
argument_list|()
argument_list|)
operator|.
name|setLeaseHolder
argument_list|(
name|leaseHolder
argument_list|)
operator|.
name|setPath
argument_list|(
name|src
argument_list|)
operator|.
name|setNewHolder
argument_list|(
name|newHolder
argument_list|)
decl_stmt|;
name|logEdit
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
comment|/**    * Get all the journals this edit log is currently operating on.    */
DECL|method|getJournals ()
specifier|synchronized
name|List
argument_list|<
name|JournalAndStream
argument_list|>
name|getJournals
parameter_list|()
block|{
return|return
name|journalSet
operator|.
name|getAllJournalStreams
argument_list|()
return|;
block|}
comment|/**    * Used only by tests.    */
annotation|@
name|VisibleForTesting
DECL|method|getJournalSet ()
specifier|synchronized
specifier|public
name|JournalSet
name|getJournalSet
parameter_list|()
block|{
return|return
name|journalSet
return|;
block|}
comment|/**    * Used only by tests.    */
annotation|@
name|VisibleForTesting
DECL|method|setMetricsForTests (NameNodeMetrics metrics)
name|void
name|setMetricsForTests
parameter_list|(
name|NameNodeMetrics
name|metrics
parameter_list|)
block|{
name|this
operator|.
name|metrics
operator|=
name|metrics
expr_stmt|;
block|}
comment|/**    * Return a manifest of what finalized edit logs are available    */
DECL|method|getEditLogManifest (long fromTxId)
specifier|public
specifier|synchronized
name|RemoteEditLogManifest
name|getEditLogManifest
parameter_list|(
name|long
name|fromTxId
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|journalSet
operator|.
name|getEditLogManifest
argument_list|(
name|fromTxId
argument_list|)
return|;
block|}
comment|/**    * Finalizes the current edit log and opens a new log segment.    * @return the transaction id of the BEGIN_LOG_SEGMENT transaction    * in the new log.    */
DECL|method|rollEditLog ()
specifier|synchronized
name|long
name|rollEditLog
parameter_list|()
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Rolling edit logs."
argument_list|)
expr_stmt|;
name|endCurrentLogSegment
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|long
name|nextTxId
init|=
name|getLastWrittenTxId
argument_list|()
operator|+
literal|1
decl_stmt|;
name|startLogSegmentAndWriteHeaderTxn
argument_list|(
name|nextTxId
argument_list|)
expr_stmt|;
assert|assert
name|curSegmentTxId
operator|==
name|nextTxId
assert|;
return|return
name|nextTxId
return|;
block|}
comment|/**    * Remote namenode just has started a log segment, start log segment locally.    */
DECL|method|startLogSegment (long txid, boolean abortCurrentLogSegment)
specifier|public
specifier|synchronized
name|void
name|startLogSegment
parameter_list|(
name|long
name|txid
parameter_list|,
name|boolean
name|abortCurrentLogSegment
parameter_list|)
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Namenode started a new log segment at txid "
operator|+
name|txid
argument_list|)
expr_stmt|;
if|if
condition|(
name|isSegmentOpen
argument_list|()
condition|)
block|{
if|if
condition|(
name|getLastWrittenTxId
argument_list|()
operator|==
name|txid
operator|-
literal|1
condition|)
block|{
comment|//In sync with the NN, so end and finalize the current segment`
name|endCurrentLogSegment
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|//Missed some transactions: probably lost contact with NN temporarily.
specifier|final
name|String
name|mess
init|=
literal|"Cannot start a new log segment at txid "
operator|+
name|txid
operator|+
literal|" since only up to txid "
operator|+
name|getLastWrittenTxId
argument_list|()
operator|+
literal|" have been written in the log segment starting at "
operator|+
name|getCurSegmentTxId
argument_list|()
operator|+
literal|"."
decl_stmt|;
if|if
condition|(
name|abortCurrentLogSegment
condition|)
block|{
comment|//Mark the current segment as aborted.
name|LOG
operator|.
name|warn
argument_list|(
name|mess
argument_list|)
expr_stmt|;
name|abortCurrentLogSegment
argument_list|()
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|mess
argument_list|)
throw|;
block|}
block|}
block|}
name|setNextTxId
argument_list|(
name|txid
argument_list|)
expr_stmt|;
name|startLogSegment
argument_list|(
name|txid
argument_list|)
expr_stmt|;
block|}
comment|/**    * Start writing to the log segment with the given txid.    * Transitions from BETWEEN_LOG_SEGMENTS state to IN_LOG_SEGMENT state.     */
DECL|method|startLogSegment (final long segmentTxId)
specifier|private
name|void
name|startLogSegment
parameter_list|(
specifier|final
name|long
name|segmentTxId
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|Thread
operator|.
name|holdsLock
argument_list|(
name|this
argument_list|)
assert|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Starting log segment at "
operator|+
name|segmentTxId
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|segmentTxId
operator|>
literal|0
argument_list|,
literal|"Bad txid: %s"
argument_list|,
name|segmentTxId
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkState
argument_list|(
name|state
operator|==
name|State
operator|.
name|BETWEEN_LOG_SEGMENTS
argument_list|,
literal|"Bad state: %s"
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkState
argument_list|(
name|segmentTxId
operator|>
name|curSegmentTxId
argument_list|,
literal|"Cannot start writing to log segment "
operator|+
name|segmentTxId
operator|+
literal|" when previous log segment started at "
operator|+
name|curSegmentTxId
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|segmentTxId
operator|==
name|txid
operator|+
literal|1
argument_list|,
literal|"Cannot start log segment at txid %s when next expected "
operator|+
literal|"txid is %s"
argument_list|,
name|segmentTxId
argument_list|,
name|txid
operator|+
literal|1
argument_list|)
expr_stmt|;
name|numTransactions
operator|=
name|totalTimeTransactions
operator|=
name|numTransactionsBatchedInSync
operator|=
literal|0
expr_stmt|;
comment|// TODO no need to link this back to storage anymore!
comment|// See HDFS-2174.
name|storage
operator|.
name|attemptRestoreRemovedStorage
argument_list|()
expr_stmt|;
try|try
block|{
name|editLogStream
operator|=
name|journalSet
operator|.
name|startLogSegment
argument_list|(
name|segmentTxId
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unable to start log segment "
operator|+
name|segmentTxId
operator|+
literal|": too few journals successfully started."
argument_list|,
name|ex
argument_list|)
throw|;
block|}
name|curSegmentTxId
operator|=
name|segmentTxId
expr_stmt|;
name|state
operator|=
name|State
operator|.
name|IN_SEGMENT
expr_stmt|;
block|}
DECL|method|startLogSegmentAndWriteHeaderTxn (final long segmentTxId )
specifier|synchronized
name|void
name|startLogSegmentAndWriteHeaderTxn
parameter_list|(
specifier|final
name|long
name|segmentTxId
parameter_list|)
throws|throws
name|IOException
block|{
name|startLogSegment
argument_list|(
name|segmentTxId
argument_list|)
expr_stmt|;
name|logEdit
argument_list|(
name|LogSegmentOp
operator|.
name|getInstance
argument_list|(
name|cache
operator|.
name|get
argument_list|()
argument_list|,
name|FSEditLogOpCodes
operator|.
name|OP_START_LOG_SEGMENT
argument_list|)
argument_list|)
expr_stmt|;
name|logSync
argument_list|()
expr_stmt|;
block|}
comment|/**    * Finalize the current log segment.    * Transitions from IN_SEGMENT state to BETWEEN_LOG_SEGMENTS state.    */
DECL|method|endCurrentLogSegment (boolean writeEndTxn)
specifier|synchronized
name|void
name|endCurrentLogSegment
parameter_list|(
name|boolean
name|writeEndTxn
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Ending log segment "
operator|+
name|curSegmentTxId
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkState
argument_list|(
name|isSegmentOpen
argument_list|()
argument_list|,
literal|"Bad state: %s"
argument_list|,
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
name|writeEndTxn
condition|)
block|{
name|logEdit
argument_list|(
name|LogSegmentOp
operator|.
name|getInstance
argument_list|(
name|cache
operator|.
name|get
argument_list|()
argument_list|,
name|FSEditLogOpCodes
operator|.
name|OP_END_LOG_SEGMENT
argument_list|)
argument_list|)
expr_stmt|;
name|logSync
argument_list|()
expr_stmt|;
block|}
name|printStatistics
argument_list|(
literal|true
argument_list|)
expr_stmt|;
specifier|final
name|long
name|lastTxId
init|=
name|getLastWrittenTxId
argument_list|()
decl_stmt|;
try|try
block|{
name|journalSet
operator|.
name|finalizeLogSegment
argument_list|(
name|curSegmentTxId
argument_list|,
name|lastTxId
argument_list|)
expr_stmt|;
name|editLogStream
operator|=
literal|null
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|//All journals have failed, it will be handled in logSync.
block|}
name|state
operator|=
name|State
operator|.
name|BETWEEN_LOG_SEGMENTS
expr_stmt|;
block|}
comment|/**    * Abort all current logs. Called from the backup node.    */
DECL|method|abortCurrentLogSegment ()
specifier|synchronized
name|void
name|abortCurrentLogSegment
parameter_list|()
block|{
try|try
block|{
comment|//Check for null, as abort can be called any time.
if|if
condition|(
name|editLogStream
operator|!=
literal|null
condition|)
block|{
name|editLogStream
operator|.
name|abort
argument_list|()
expr_stmt|;
name|editLogStream
operator|=
literal|null
expr_stmt|;
name|state
operator|=
name|State
operator|.
name|BETWEEN_LOG_SEGMENTS
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"All journals failed to abort"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Archive any log files that are older than the given txid.    */
DECL|method|purgeLogsOlderThan (final long minTxIdToKeep)
specifier|public
specifier|synchronized
name|void
name|purgeLogsOlderThan
parameter_list|(
specifier|final
name|long
name|minTxIdToKeep
parameter_list|)
block|{
assert|assert
name|curSegmentTxId
operator|==
name|HdfsConstants
operator|.
name|INVALID_TXID
operator|||
comment|// on format this is no-op
name|minTxIdToKeep
operator|<=
name|curSegmentTxId
operator|:
literal|"cannot purge logs older than txid "
operator|+
name|minTxIdToKeep
operator|+
literal|" when current segment starts at "
operator|+
name|curSegmentTxId
assert|;
if|if
condition|(
name|minTxIdToKeep
operator|==
literal|0
condition|)
block|{
return|return;
block|}
comment|// This could be improved to not need synchronization. But currently,
comment|// journalSet is not threadsafe, so we need to synchronize this method.
try|try
block|{
name|journalSet
operator|.
name|purgeLogsOlderThan
argument_list|(
name|minTxIdToKeep
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
comment|//All journals have failed, it will be handled in logSync.
block|}
block|}
comment|/**    * The actual sync activity happens while not synchronized on this object.    * Thus, synchronized activities that require that they are not concurrent    * with file operations should wait for any running sync to finish.    */
DECL|method|waitForSyncToFinish ()
specifier|synchronized
name|void
name|waitForSyncToFinish
parameter_list|()
block|{
while|while
condition|(
name|isSyncRunning
condition|)
block|{
try|try
block|{
name|wait
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{}
block|}
block|}
comment|/**    * Return the txid of the last synced transaction.    * For test use only    */
DECL|method|getSyncTxId ()
specifier|synchronized
name|long
name|getSyncTxId
parameter_list|()
block|{
return|return
name|synctxid
return|;
block|}
comment|// sets the initial capacity of the flush buffer.
DECL|method|setOutputBufferCapacity (int size)
specifier|synchronized
name|void
name|setOutputBufferCapacity
parameter_list|(
name|int
name|size
parameter_list|)
block|{
name|journalSet
operator|.
name|setOutputBufferCapacity
argument_list|(
name|size
argument_list|)
expr_stmt|;
block|}
comment|/**    * Create (or find if already exists) an edit output stream, which    * streams journal records (edits) to the specified backup node.<br>    *     * The new BackupNode will start receiving edits the next time this    * NameNode's logs roll.    *     * @param bnReg the backup node registration information.    * @param nnReg this (active) name-node registration.    * @throws IOException    */
DECL|method|registerBackupNode ( NamenodeRegistration bnReg, NamenodeRegistration nnReg)
specifier|synchronized
name|void
name|registerBackupNode
parameter_list|(
name|NamenodeRegistration
name|bnReg
parameter_list|,
comment|// backup node
name|NamenodeRegistration
name|nnReg
parameter_list|)
comment|// active name-node
throws|throws
name|IOException
block|{
if|if
condition|(
name|bnReg
operator|.
name|isRole
argument_list|(
name|NamenodeRole
operator|.
name|CHECKPOINT
argument_list|)
condition|)
return|return;
comment|// checkpoint node does not stream edits
name|JournalManager
name|jas
init|=
name|findBackupJournal
argument_list|(
name|bnReg
argument_list|)
decl_stmt|;
if|if
condition|(
name|jas
operator|!=
literal|null
condition|)
block|{
comment|// already registered
name|LOG
operator|.
name|info
argument_list|(
literal|"Backup node "
operator|+
name|bnReg
operator|+
literal|" re-registers"
argument_list|)
expr_stmt|;
return|return;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Registering new backup node: "
operator|+
name|bnReg
argument_list|)
expr_stmt|;
name|BackupJournalManager
name|bjm
init|=
operator|new
name|BackupJournalManager
argument_list|(
name|bnReg
argument_list|,
name|nnReg
argument_list|)
decl_stmt|;
name|journalSet
operator|.
name|add
argument_list|(
name|bjm
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
DECL|method|releaseBackupStream (NamenodeRegistration registration)
specifier|synchronized
name|void
name|releaseBackupStream
parameter_list|(
name|NamenodeRegistration
name|registration
parameter_list|)
throws|throws
name|IOException
block|{
name|BackupJournalManager
name|bjm
init|=
name|this
operator|.
name|findBackupJournal
argument_list|(
name|registration
argument_list|)
decl_stmt|;
if|if
condition|(
name|bjm
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Removing backup journal "
operator|+
name|bjm
argument_list|)
expr_stmt|;
name|journalSet
operator|.
name|remove
argument_list|(
name|bjm
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Find the JournalAndStream associated with this BackupNode.    *     * @return null if it cannot be found    */
DECL|method|findBackupJournal ( NamenodeRegistration bnReg)
specifier|private
specifier|synchronized
name|BackupJournalManager
name|findBackupJournal
parameter_list|(
name|NamenodeRegistration
name|bnReg
parameter_list|)
block|{
for|for
control|(
name|JournalManager
name|bjm
range|:
name|journalSet
operator|.
name|getJournalManagers
argument_list|()
control|)
block|{
if|if
condition|(
operator|(
name|bjm
operator|instanceof
name|BackupJournalManager
operator|)
operator|&&
operator|(
operator|(
name|BackupJournalManager
operator|)
name|bjm
operator|)
operator|.
name|matchesRegistration
argument_list|(
name|bnReg
argument_list|)
condition|)
block|{
return|return
operator|(
name|BackupJournalManager
operator|)
name|bjm
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/** Write the batch of edits to edit log. */
DECL|method|journal (long firstTxId, int numTxns, byte[] data)
specifier|public
specifier|synchronized
name|void
name|journal
parameter_list|(
name|long
name|firstTxId
parameter_list|,
name|int
name|numTxns
parameter_list|,
name|byte
index|[]
name|data
parameter_list|)
block|{
specifier|final
name|long
name|expectedTxId
init|=
name|getLastWrittenTxId
argument_list|()
operator|+
literal|1
decl_stmt|;
name|Preconditions
operator|.
name|checkState
argument_list|(
name|firstTxId
operator|==
name|expectedTxId
argument_list|,
literal|"received txid batch starting at %s but expected txid %s"
argument_list|,
name|firstTxId
argument_list|,
name|expectedTxId
argument_list|)
expr_stmt|;
name|setNextTxId
argument_list|(
name|firstTxId
operator|+
name|numTxns
operator|-
literal|1
argument_list|)
expr_stmt|;
name|logEdit
argument_list|(
name|data
operator|.
name|length
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|logSync
argument_list|()
expr_stmt|;
block|}
comment|/**    * Write an operation to the edit log. Do not sync to persistent    * store yet.    */
DECL|method|logEdit (final int length, final byte[] data)
specifier|synchronized
name|void
name|logEdit
parameter_list|(
specifier|final
name|int
name|length
parameter_list|,
specifier|final
name|byte
index|[]
name|data
parameter_list|)
block|{
name|long
name|start
init|=
name|beginTransaction
argument_list|()
decl_stmt|;
try|try
block|{
name|editLogStream
operator|.
name|writeRaw
argument_list|(
name|data
argument_list|,
literal|0
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
comment|// All journals have failed, it will be handled in logSync.
block|}
name|endTransaction
argument_list|(
name|start
argument_list|)
expr_stmt|;
block|}
comment|/**    * Run recovery on all journals to recover any unclosed segments    */
DECL|method|recoverUnclosedStreams ()
specifier|synchronized
name|void
name|recoverUnclosedStreams
parameter_list|()
block|{
name|Preconditions
operator|.
name|checkState
argument_list|(
name|state
operator|==
name|State
operator|.
name|BETWEEN_LOG_SEGMENTS
argument_list|,
literal|"May not recover segments - wrong state: %s"
argument_list|,
name|state
argument_list|)
expr_stmt|;
try|try
block|{
name|journalSet
operator|.
name|recoverUnfinalizedSegments
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
comment|// All journals have failed, it is handled in logSync.
block|}
block|}
DECL|method|selectInputStreams ( long fromTxId, long toAtLeastTxId)
specifier|public
name|Collection
argument_list|<
name|EditLogInputStream
argument_list|>
name|selectInputStreams
parameter_list|(
name|long
name|fromTxId
parameter_list|,
name|long
name|toAtLeastTxId
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|selectInputStreams
argument_list|(
name|fromTxId
argument_list|,
name|toAtLeastTxId
argument_list|,
literal|null
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|/**    * Select a list of input streams to load.    *     * @param fromTxId first transaction in the selected streams    * @param toAtLeast the selected streams must contain this transaction    * @param inProgessOk set to true if in-progress streams are OK    */
DECL|method|selectInputStreams ( long fromTxId, long toAtLeastTxId, MetaRecoveryContext recovery, boolean inProgressOk)
specifier|public
specifier|synchronized
name|Collection
argument_list|<
name|EditLogInputStream
argument_list|>
name|selectInputStreams
parameter_list|(
name|long
name|fromTxId
parameter_list|,
name|long
name|toAtLeastTxId
parameter_list|,
name|MetaRecoveryContext
name|recovery
parameter_list|,
name|boolean
name|inProgressOk
parameter_list|)
throws|throws
name|IOException
block|{
name|List
argument_list|<
name|EditLogInputStream
argument_list|>
name|streams
init|=
operator|new
name|ArrayList
argument_list|<
name|EditLogInputStream
argument_list|>
argument_list|()
decl_stmt|;
name|journalSet
operator|.
name|selectInputStreams
argument_list|(
name|streams
argument_list|,
name|fromTxId
argument_list|,
name|inProgressOk
argument_list|)
expr_stmt|;
try|try
block|{
name|checkForGaps
argument_list|(
name|streams
argument_list|,
name|fromTxId
argument_list|,
name|toAtLeastTxId
argument_list|,
name|inProgressOk
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
if|if
condition|(
name|recovery
operator|!=
literal|null
condition|)
block|{
comment|// If recovery mode is enabled, continue loading even if we know we
comment|// can't load up to toAtLeastTxId.
name|LOG
operator|.
name|error
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|closeAllStreams
argument_list|(
name|streams
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
return|return
name|streams
return|;
block|}
comment|/**    * Check for gaps in the edit log input stream list.    * Note: we're assuming that the list is sorted and that txid ranges don't    * overlap.  This could be done better and with more generality with an    * interval tree.    */
DECL|method|checkForGaps (List<EditLogInputStream> streams, long fromTxId, long toAtLeastTxId, boolean inProgressOk)
specifier|private
name|void
name|checkForGaps
parameter_list|(
name|List
argument_list|<
name|EditLogInputStream
argument_list|>
name|streams
parameter_list|,
name|long
name|fromTxId
parameter_list|,
name|long
name|toAtLeastTxId
parameter_list|,
name|boolean
name|inProgressOk
parameter_list|)
throws|throws
name|IOException
block|{
name|Iterator
argument_list|<
name|EditLogInputStream
argument_list|>
name|iter
init|=
name|streams
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|long
name|txId
init|=
name|fromTxId
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
if|if
condition|(
name|txId
operator|>
name|toAtLeastTxId
condition|)
return|return;
if|if
condition|(
operator|!
name|iter
operator|.
name|hasNext
argument_list|()
condition|)
break|break;
name|EditLogInputStream
name|elis
init|=
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|elis
operator|.
name|getFirstTxId
argument_list|()
operator|>
name|txId
condition|)
break|break;
name|long
name|next
init|=
name|elis
operator|.
name|getLastTxId
argument_list|()
decl_stmt|;
if|if
condition|(
name|next
operator|==
name|HdfsConstants
operator|.
name|INVALID_TXID
condition|)
block|{
if|if
condition|(
operator|!
name|inProgressOk
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"inProgressOk = false, but "
operator|+
literal|"selectInputStreams returned an in-progress edit "
operator|+
literal|"log input stream ("
operator|+
name|elis
operator|+
literal|")"
argument_list|)
throw|;
block|}
comment|// We don't know where the in-progress stream ends.
comment|// It could certainly go all the way up to toAtLeastTxId.
return|return;
block|}
name|txId
operator|=
name|next
operator|+
literal|1
expr_stmt|;
block|}
throw|throw
operator|new
name|IOException
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Gap in transactions. Expected to "
operator|+
literal|"be able to read up until at least txid %d but unable to find any "
operator|+
literal|"edit logs containing txid %d"
argument_list|,
name|toAtLeastTxId
argument_list|,
name|txId
argument_list|)
argument_list|)
throw|;
block|}
comment|/**     * Close all the streams in a collection    * @param streams The list of streams to close    */
DECL|method|closeAllStreams (Iterable<EditLogInputStream> streams)
specifier|static
name|void
name|closeAllStreams
parameter_list|(
name|Iterable
argument_list|<
name|EditLogInputStream
argument_list|>
name|streams
parameter_list|)
block|{
for|for
control|(
name|EditLogInputStream
name|s
range|:
name|streams
control|)
block|{
name|IOUtils
operator|.
name|closeStream
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Retrieve the implementation class for a Journal scheme.    * @param conf The configuration to retrieve the information from    * @param uriScheme The uri scheme to look up.    * @return the class of the journal implementation    * @throws IllegalArgumentException if no class is configured for uri    */
DECL|method|getJournalClass (Configuration conf, String uriScheme)
specifier|static
name|Class
argument_list|<
name|?
extends|extends
name|JournalManager
argument_list|>
name|getJournalClass
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|String
name|uriScheme
parameter_list|)
block|{
name|String
name|key
init|=
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_EDITS_PLUGIN_PREFIX
operator|+
literal|"."
operator|+
name|uriScheme
decl_stmt|;
name|Class
argument_list|<
name|?
extends|extends
name|JournalManager
argument_list|>
name|clazz
init|=
literal|null
decl_stmt|;
try|try
block|{
name|clazz
operator|=
name|conf
operator|.
name|getClass
argument_list|(
name|key
argument_list|,
literal|null
argument_list|,
name|JournalManager
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RuntimeException
name|re
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Invalid class specified for "
operator|+
name|uriScheme
argument_list|,
name|re
argument_list|)
throw|;
block|}
if|if
condition|(
name|clazz
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"No class configured for "
operator|+
name|uriScheme
operator|+
literal|", "
operator|+
name|key
operator|+
literal|" is empty"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"No class configured for "
operator|+
name|uriScheme
argument_list|)
throw|;
block|}
return|return
name|clazz
return|;
block|}
comment|/**    * Construct a custom journal manager.    * The class to construct is taken from the configuration.    * @param uri Uri to construct    * @return The constructed journal manager    * @throws IllegalArgumentException if no class is configured for uri    */
DECL|method|createJournal (URI uri)
specifier|private
name|JournalManager
name|createJournal
parameter_list|(
name|URI
name|uri
parameter_list|)
block|{
name|Class
argument_list|<
name|?
extends|extends
name|JournalManager
argument_list|>
name|clazz
init|=
name|getJournalClass
argument_list|(
name|conf
argument_list|,
name|uri
operator|.
name|getScheme
argument_list|()
argument_list|)
decl_stmt|;
try|try
block|{
name|Constructor
argument_list|<
name|?
extends|extends
name|JournalManager
argument_list|>
name|cons
init|=
name|clazz
operator|.
name|getConstructor
argument_list|(
name|Configuration
operator|.
name|class
argument_list|,
name|URI
operator|.
name|class
argument_list|,
name|NamespaceInfo
operator|.
name|class
argument_list|)
decl_stmt|;
return|return
name|cons
operator|.
name|newInstance
argument_list|(
name|conf
argument_list|,
name|uri
argument_list|,
name|storage
operator|.
name|getNamespaceInfo
argument_list|()
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Unable to construct journal, "
operator|+
name|uri
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
block|}
end_class

end_unit

