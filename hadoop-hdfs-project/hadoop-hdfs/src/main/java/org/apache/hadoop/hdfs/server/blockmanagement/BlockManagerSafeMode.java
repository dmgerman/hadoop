begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdfs.server.blockmanagement
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|blockmanagement
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceStability
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|BlockListAsLongs
operator|.
name|BlockReportReplica
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|HdfsServerConstants
operator|.
name|RollingUpgradeStartupOption
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|HdfsServerConstants
operator|.
name|StartupOption
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|NameNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|Namesystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|startupprogress
operator|.
name|Phase
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|startupprogress
operator|.
name|StartupProgress
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|startupprogress
operator|.
name|StartupProgress
operator|.
name|Counter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|startupprogress
operator|.
name|Status
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|startupprogress
operator|.
name|Step
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|startupprogress
operator|.
name|StepType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|net
operator|.
name|NetworkTopology
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Daemon
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicLong
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_REPL_QUEUE_THRESHOLD_PCT_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_SAFEMODE_EXTENSION_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_SAFEMODE_MIN_DATANODES_DEFAULT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_SAFEMODE_MIN_DATANODES_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_SAFEMODE_THRESHOLD_PCT_DEFAULT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_SAFEMODE_THRESHOLD_PCT_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Time
operator|.
name|monotonicNow
import|;
end_import

begin_comment
comment|/**  * Block manager safe mode info.  *  * During name node startup, counts the number of<em>safe blocks</em>, those  * that have at least the minimal number of replicas, and calculates the ratio  * of safe blocks to the total number of blocks in the system, which is the size  * of blocks. When the ratio reaches the {@link #threshold} and enough live data  * nodes have registered, it needs to wait for the safe mode {@link #extension}  * interval. After the extension period has passed, it will not leave safe mode  * until the safe blocks ratio reaches the {@link #threshold} and enough live  * data node registered.  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
annotation|@
name|InterfaceStability
operator|.
name|Evolving
DECL|class|BlockManagerSafeMode
class|class
name|BlockManagerSafeMode
block|{
DECL|enum|BMSafeModeStatus
enum|enum
name|BMSafeModeStatus
block|{
DECL|enumConstant|PENDING_THRESHOLD
name|PENDING_THRESHOLD
block|,
comment|/** Pending on more safe blocks or live datanode. */
DECL|enumConstant|EXTENSION
name|EXTENSION
block|,
comment|/** In extension period. */
DECL|enumConstant|OFF
name|OFF
comment|/** Safe mode is off. */
block|}
DECL|field|LOG
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|BlockManagerSafeMode
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|STEP_AWAITING_REPORTED_BLOCKS
specifier|static
specifier|final
name|Step
name|STEP_AWAITING_REPORTED_BLOCKS
init|=
operator|new
name|Step
argument_list|(
name|StepType
operator|.
name|AWAITING_REPORTED_BLOCKS
argument_list|)
decl_stmt|;
DECL|field|blockManager
specifier|private
specifier|final
name|BlockManager
name|blockManager
decl_stmt|;
DECL|field|namesystem
specifier|private
specifier|final
name|Namesystem
name|namesystem
decl_stmt|;
DECL|field|haEnabled
specifier|private
specifier|final
name|boolean
name|haEnabled
decl_stmt|;
DECL|field|status
specifier|private
specifier|volatile
name|BMSafeModeStatus
name|status
init|=
name|BMSafeModeStatus
operator|.
name|OFF
decl_stmt|;
comment|/** Safe mode threshold condition %.*/
DECL|field|threshold
specifier|private
specifier|final
name|double
name|threshold
decl_stmt|;
comment|/** Number of blocks needed to satisfy safe mode threshold condition. */
DECL|field|blockThreshold
specifier|private
name|long
name|blockThreshold
decl_stmt|;
comment|/** Total number of blocks. */
DECL|field|blockTotal
specifier|private
name|long
name|blockTotal
decl_stmt|;
comment|/** Number of safe blocks. */
DECL|field|blockSafe
specifier|private
name|long
name|blockSafe
decl_stmt|;
comment|/** Safe mode minimum number of datanodes alive. */
DECL|field|datanodeThreshold
specifier|private
specifier|final
name|int
name|datanodeThreshold
decl_stmt|;
comment|/** Min replication required by safe mode. */
DECL|field|safeReplication
specifier|private
specifier|final
name|int
name|safeReplication
decl_stmt|;
comment|/** Threshold for populating needed replication queues. */
DECL|field|replQueueThreshold
specifier|private
specifier|final
name|double
name|replQueueThreshold
decl_stmt|;
comment|/** Number of blocks needed before populating replication queues. */
DECL|field|blockReplQueueThreshold
specifier|private
name|long
name|blockReplQueueThreshold
decl_stmt|;
comment|/** How long (in ms) is the extension period. */
DECL|field|extension
specifier|private
specifier|final
name|int
name|extension
decl_stmt|;
comment|/** Timestamp of the first time when thresholds are met. */
DECL|field|reachedTime
specifier|private
specifier|final
name|AtomicLong
name|reachedTime
init|=
operator|new
name|AtomicLong
argument_list|()
decl_stmt|;
comment|/** Timestamp of the safe mode initialized. */
DECL|field|startTime
specifier|private
name|long
name|startTime
decl_stmt|;
comment|/** the safe mode monitor thread. */
DECL|field|smmthread
specifier|private
specifier|final
name|Daemon
name|smmthread
init|=
operator|new
name|Daemon
argument_list|(
operator|new
name|SafeModeMonitor
argument_list|()
argument_list|)
decl_stmt|;
comment|/** time of the last status printout */
DECL|field|lastStatusReport
specifier|private
name|long
name|lastStatusReport
decl_stmt|;
comment|/** Counter for tracking startup progress of reported blocks. */
DECL|field|awaitingReportedBlocksCounter
specifier|private
name|Counter
name|awaitingReportedBlocksCounter
decl_stmt|;
comment|/** Keeps track of how many bytes are in Future Generation blocks. */
DECL|field|numberOfBytesInFutureBlocks
specifier|private
specifier|final
name|AtomicLong
name|numberOfBytesInFutureBlocks
init|=
operator|new
name|AtomicLong
argument_list|()
decl_stmt|;
comment|/** Reports if Name node was started with Rollback option. */
DECL|field|inRollBack
specifier|private
specifier|final
name|boolean
name|inRollBack
decl_stmt|;
DECL|method|BlockManagerSafeMode (BlockManager blockManager, Namesystem namesystem, boolean haEnabled, Configuration conf)
name|BlockManagerSafeMode
parameter_list|(
name|BlockManager
name|blockManager
parameter_list|,
name|Namesystem
name|namesystem
parameter_list|,
name|boolean
name|haEnabled
parameter_list|,
name|Configuration
name|conf
parameter_list|)
block|{
name|this
operator|.
name|blockManager
operator|=
name|blockManager
expr_stmt|;
name|this
operator|.
name|namesystem
operator|=
name|namesystem
expr_stmt|;
name|this
operator|.
name|haEnabled
operator|=
name|haEnabled
expr_stmt|;
name|this
operator|.
name|threshold
operator|=
name|conf
operator|.
name|getFloat
argument_list|(
name|DFS_NAMENODE_SAFEMODE_THRESHOLD_PCT_KEY
argument_list|,
name|DFS_NAMENODE_SAFEMODE_THRESHOLD_PCT_DEFAULT
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|threshold
operator|>
literal|1.0
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"The threshold value should't be greater than 1, threshold: {}"
argument_list|,
name|threshold
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|datanodeThreshold
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|DFS_NAMENODE_SAFEMODE_MIN_DATANODES_KEY
argument_list|,
name|DFS_NAMENODE_SAFEMODE_MIN_DATANODES_DEFAULT
argument_list|)
expr_stmt|;
name|int
name|minReplication
init|=
name|conf
operator|.
name|getInt
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_REPLICATION_MIN_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_REPLICATION_MIN_DEFAULT
argument_list|)
decl_stmt|;
comment|// DFS_NAMENODE_SAFEMODE_REPLICATION_MIN_KEY is an expert level setting,
comment|// setting this lower than the min replication is not recommended
comment|// and/or dangerous for production setups.
comment|// When it's unset, safeReplication will use dfs.namenode.replication.min
name|this
operator|.
name|safeReplication
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_SAFEMODE_REPLICATION_MIN_KEY
argument_list|,
name|minReplication
argument_list|)
expr_stmt|;
comment|// default to safe mode threshold (i.e., don't populate queues before
comment|// leaving safe mode)
name|this
operator|.
name|replQueueThreshold
operator|=
name|conf
operator|.
name|getFloat
argument_list|(
name|DFS_NAMENODE_REPL_QUEUE_THRESHOLD_PCT_KEY
argument_list|,
operator|(
name|float
operator|)
name|threshold
argument_list|)
expr_stmt|;
name|this
operator|.
name|extension
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|DFS_NAMENODE_SAFEMODE_EXTENSION_KEY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|this
operator|.
name|inRollBack
operator|=
name|isInRollBackMode
argument_list|(
name|NameNode
operator|.
name|getStartupOption
argument_list|(
name|conf
argument_list|)
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"{} = {}"
argument_list|,
name|DFS_NAMENODE_SAFEMODE_THRESHOLD_PCT_KEY
argument_list|,
name|threshold
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"{} = {}"
argument_list|,
name|DFS_NAMENODE_SAFEMODE_MIN_DATANODES_KEY
argument_list|,
name|datanodeThreshold
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"{} = {}"
argument_list|,
name|DFS_NAMENODE_SAFEMODE_EXTENSION_KEY
argument_list|,
name|extension
argument_list|)
expr_stmt|;
block|}
comment|/**    * Initialize the safe mode information.    * @param total initial total blocks    */
DECL|method|activate (long total)
name|void
name|activate
parameter_list|(
name|long
name|total
parameter_list|)
block|{
assert|assert
name|namesystem
operator|.
name|hasWriteLock
argument_list|()
assert|;
assert|assert
name|status
operator|==
name|BMSafeModeStatus
operator|.
name|OFF
assert|;
name|startTime
operator|=
name|monotonicNow
argument_list|()
expr_stmt|;
name|setBlockTotal
argument_list|(
name|total
argument_list|)
expr_stmt|;
if|if
condition|(
name|areThresholdsMet
argument_list|()
condition|)
block|{
name|leaveSafeMode
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// enter safe mode
name|status
operator|=
name|BMSafeModeStatus
operator|.
name|PENDING_THRESHOLD
expr_stmt|;
name|initializeReplQueuesIfNecessary
argument_list|()
expr_stmt|;
name|reportStatus
argument_list|(
literal|"STATE* Safe mode ON."
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|lastStatusReport
operator|=
name|monotonicNow
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * @return true if it stays in start up safe mode else false.    */
DECL|method|isInSafeMode ()
name|boolean
name|isInSafeMode
parameter_list|()
block|{
if|if
condition|(
name|status
operator|!=
name|BMSafeModeStatus
operator|.
name|OFF
condition|)
block|{
name|doConsistencyCheck
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
comment|/**    * The transition of the safe mode state machine.    * If safe mode is not currently on, this is a no-op.    */
DECL|method|checkSafeMode ()
name|void
name|checkSafeMode
parameter_list|()
block|{
assert|assert
name|namesystem
operator|.
name|hasWriteLock
argument_list|()
assert|;
if|if
condition|(
name|namesystem
operator|.
name|inTransitionToActive
argument_list|()
condition|)
block|{
return|return;
block|}
switch|switch
condition|(
name|status
condition|)
block|{
case|case
name|PENDING_THRESHOLD
case|:
if|if
condition|(
name|areThresholdsMet
argument_list|()
condition|)
block|{
if|if
condition|(
name|extension
operator|>
literal|0
condition|)
block|{
comment|// PENDING_THRESHOLD -> EXTENSION
name|status
operator|=
name|BMSafeModeStatus
operator|.
name|EXTENSION
expr_stmt|;
name|reachedTime
operator|.
name|set
argument_list|(
name|monotonicNow
argument_list|()
argument_list|)
expr_stmt|;
name|smmthread
operator|.
name|start
argument_list|()
expr_stmt|;
name|initializeReplQueuesIfNecessary
argument_list|()
expr_stmt|;
name|reportStatus
argument_list|(
literal|"STATE* Safe mode extension entered."
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// PENDING_THRESHOLD -> OFF
name|leaveSafeMode
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|initializeReplQueuesIfNecessary
argument_list|()
expr_stmt|;
name|reportStatus
argument_list|(
literal|"STATE* Safe mode ON."
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|EXTENSION
case|:
name|reportStatus
argument_list|(
literal|"STATE* Safe mode ON."
argument_list|,
literal|false
argument_list|)
expr_stmt|;
break|break;
case|case
name|OFF
case|:
break|break;
default|default:
assert|assert
literal|false
operator|:
literal|"Non-recognized block manager safe mode status: "
operator|+
name|status
assert|;
block|}
block|}
comment|/**    * Adjust the total number of blocks safe and expected during safe mode.    * If safe mode is not currently on, this is a no-op.    * @param deltaSafe  the change in number of safe blocks    * @param deltaTotal the change in number of total blocks expected    */
DECL|method|adjustBlockTotals (int deltaSafe, int deltaTotal)
name|void
name|adjustBlockTotals
parameter_list|(
name|int
name|deltaSafe
parameter_list|,
name|int
name|deltaTotal
parameter_list|)
block|{
assert|assert
name|namesystem
operator|.
name|hasWriteLock
argument_list|()
assert|;
if|if
condition|(
operator|!
name|isSafeModeTrackingBlocks
argument_list|()
condition|)
block|{
return|return;
block|}
name|long
name|newBlockTotal
decl_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Adjusting block totals from {}/{} to {}/{}"
argument_list|,
name|blockSafe
argument_list|,
name|blockTotal
argument_list|,
name|blockSafe
operator|+
name|deltaSafe
argument_list|,
name|blockTotal
operator|+
name|deltaTotal
argument_list|)
expr_stmt|;
assert|assert
name|blockSafe
operator|+
name|deltaSafe
operator|>=
literal|0
operator|:
literal|"Can't reduce blockSafe "
operator|+
name|blockSafe
operator|+
literal|" by "
operator|+
name|deltaSafe
operator|+
literal|": would be negative"
assert|;
assert|assert
name|blockTotal
operator|+
name|deltaTotal
operator|>=
literal|0
operator|:
literal|"Can't reduce blockTotal "
operator|+
name|blockTotal
operator|+
literal|" by "
operator|+
name|deltaTotal
operator|+
literal|": would be negative"
assert|;
name|blockSafe
operator|+=
name|deltaSafe
expr_stmt|;
name|newBlockTotal
operator|=
name|blockTotal
operator|+
name|deltaTotal
expr_stmt|;
block|}
name|setBlockTotal
argument_list|(
name|newBlockTotal
argument_list|)
expr_stmt|;
name|checkSafeMode
argument_list|()
expr_stmt|;
block|}
comment|/**    * Should we track blocks in safe mode.    *<p/>    * Never track blocks incrementally in non-HA code.    *<p/>    * In the HA case, the StandbyNode can be in safemode while the namespace    * is modified by the edit log tailer. In this case, the number of total    * blocks changes as edits are processed (eg blocks are added and deleted).    * However, we don't want to do the incremental tracking during the    * startup-time loading process -- only once the initial total has been    * set after the image has been loaded.    */
DECL|method|isSafeModeTrackingBlocks ()
name|boolean
name|isSafeModeTrackingBlocks
parameter_list|()
block|{
assert|assert
name|namesystem
operator|.
name|hasWriteLock
argument_list|()
assert|;
return|return
name|haEnabled
operator|&&
name|status
operator|!=
name|BMSafeModeStatus
operator|.
name|OFF
return|;
block|}
comment|/**    * Set total number of blocks.    */
DECL|method|setBlockTotal (long total)
name|void
name|setBlockTotal
parameter_list|(
name|long
name|total
parameter_list|)
block|{
assert|assert
name|namesystem
operator|.
name|hasWriteLock
argument_list|()
assert|;
synchronized|synchronized
init|(
name|this
init|)
block|{
name|this
operator|.
name|blockTotal
operator|=
name|total
expr_stmt|;
name|this
operator|.
name|blockThreshold
operator|=
call|(
name|long
call|)
argument_list|(
name|total
operator|*
name|threshold
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|blockReplQueueThreshold
operator|=
call|(
name|long
call|)
argument_list|(
name|total
operator|*
name|replQueueThreshold
argument_list|)
expr_stmt|;
block|}
DECL|method|getSafeModeTip ()
name|String
name|getSafeModeTip
parameter_list|()
block|{
name|String
name|msg
init|=
literal|""
decl_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
if|if
condition|(
name|blockSafe
operator|<
name|blockThreshold
condition|)
block|{
name|msg
operator|+=
name|String
operator|.
name|format
argument_list|(
literal|"The reported blocks %d needs additional %d"
operator|+
literal|" blocks to reach the threshold %.4f of total blocks %d.%n"
argument_list|,
name|blockSafe
argument_list|,
operator|(
name|blockThreshold
operator|-
name|blockSafe
operator|)
argument_list|,
name|threshold
argument_list|,
name|blockTotal
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|msg
operator|+=
name|String
operator|.
name|format
argument_list|(
literal|"The reported blocks %d has reached the threshold"
operator|+
literal|" %.4f of total blocks %d. "
argument_list|,
name|blockSafe
argument_list|,
name|threshold
argument_list|,
name|blockTotal
argument_list|)
expr_stmt|;
block|}
block|}
name|int
name|numLive
init|=
name|blockManager
operator|.
name|getDatanodeManager
argument_list|()
operator|.
name|getNumLiveDataNodes
argument_list|()
decl_stmt|;
if|if
condition|(
name|numLive
operator|<
name|datanodeThreshold
condition|)
block|{
name|msg
operator|+=
name|String
operator|.
name|format
argument_list|(
literal|"The number of live datanodes %d needs an additional %d live "
operator|+
literal|"datanodes to reach the minimum number %d.%n"
argument_list|,
name|numLive
argument_list|,
operator|(
name|datanodeThreshold
operator|-
name|numLive
operator|)
argument_list|,
name|datanodeThreshold
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|msg
operator|+=
name|String
operator|.
name|format
argument_list|(
literal|"The number of live datanodes %d has reached "
operator|+
literal|"the minimum number %d. "
argument_list|,
name|numLive
argument_list|,
name|datanodeThreshold
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|getBytesInFuture
argument_list|()
operator|>
literal|0
condition|)
block|{
name|msg
operator|+=
literal|"Name node detected blocks with generation stamps "
operator|+
literal|"in future. This means that Name node metadata is inconsistent. "
operator|+
literal|"This can happen if Name node metadata files have been manually "
operator|+
literal|"replaced. Exiting safe mode will cause loss of "
operator|+
name|getBytesInFuture
argument_list|()
operator|+
literal|" byte(s). Please restart name node with "
operator|+
literal|"right metadata or use \"hdfs dfsadmin -safemode forceExit\" "
operator|+
literal|"if you are certain that the NameNode was started with the "
operator|+
literal|"correct FsImage and edit logs. If you encountered this during "
operator|+
literal|"a rollback, it is safe to exit with -safemode forceExit."
expr_stmt|;
return|return
name|msg
return|;
block|}
specifier|final
name|String
name|turnOffTip
init|=
literal|"Safe mode will be turned off automatically "
decl_stmt|;
switch|switch
condition|(
name|status
condition|)
block|{
case|case
name|PENDING_THRESHOLD
case|:
name|msg
operator|+=
name|turnOffTip
operator|+
literal|"once the thresholds have been reached."
expr_stmt|;
break|break;
case|case
name|EXTENSION
case|:
name|msg
operator|+=
literal|"In safe mode extension. "
operator|+
name|turnOffTip
operator|+
literal|"in "
operator|+
name|timeToLeaveExtension
argument_list|()
operator|/
literal|1000
operator|+
literal|" seconds."
expr_stmt|;
break|break;
case|case
name|OFF
case|:
name|msg
operator|+=
name|turnOffTip
operator|+
literal|"soon."
expr_stmt|;
break|break;
default|default:
assert|assert
literal|false
operator|:
literal|"Non-recognized block manager safe mode status: "
operator|+
name|status
assert|;
block|}
return|return
name|msg
return|;
block|}
comment|/**    * Leave start up safe mode.    *    * @param force - true to force exit    * @return true if it leaves safe mode successfully else false    */
DECL|method|leaveSafeMode (boolean force)
name|boolean
name|leaveSafeMode
parameter_list|(
name|boolean
name|force
parameter_list|)
block|{
assert|assert
name|namesystem
operator|.
name|hasWriteLock
argument_list|()
operator|:
literal|"Leaving safe mode needs write lock!"
assert|;
specifier|final
name|long
name|bytesInFuture
init|=
name|numberOfBytesInFutureBlocks
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|bytesInFuture
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|force
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Leaving safe mode due to forceExit. This will cause a data "
operator|+
literal|"loss of {} byte(s)."
argument_list|,
name|bytesInFuture
argument_list|)
expr_stmt|;
name|numberOfBytesInFutureBlocks
operator|.
name|set
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Refusing to leave safe mode without a force flag. "
operator|+
literal|"Exiting safe mode will cause a deletion of {} byte(s). Please "
operator|+
literal|"use -forceExit flag to exit safe mode forcefully if data loss is"
operator|+
literal|" acceptable."
argument_list|,
name|bytesInFuture
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|force
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"forceExit used when normal exist would suffice. Treating "
operator|+
literal|"force exit as normal safe mode exit."
argument_list|)
expr_stmt|;
block|}
comment|// if not done yet, initialize replication queues.
comment|// In the standby, do not populate repl queues
if|if
condition|(
operator|!
name|blockManager
operator|.
name|isPopulatingReplQueues
argument_list|()
operator|&&
name|blockManager
operator|.
name|shouldPopulateReplQueues
argument_list|()
condition|)
block|{
name|blockManager
operator|.
name|initializeReplQueues
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|!=
name|BMSafeModeStatus
operator|.
name|OFF
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|info
argument_list|(
literal|"STATE* Safe mode is OFF"
argument_list|)
expr_stmt|;
block|}
name|status
operator|=
name|BMSafeModeStatus
operator|.
name|OFF
expr_stmt|;
specifier|final
name|long
name|timeInSafemode
init|=
name|monotonicNow
argument_list|()
operator|-
name|startTime
decl_stmt|;
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|info
argument_list|(
literal|"STATE* Leaving safe mode after {} secs"
argument_list|,
name|timeInSafemode
operator|/
literal|1000
argument_list|)
expr_stmt|;
name|NameNode
operator|.
name|getNameNodeMetrics
argument_list|()
operator|.
name|setSafeModeTime
argument_list|(
name|timeInSafemode
argument_list|)
expr_stmt|;
specifier|final
name|NetworkTopology
name|nt
init|=
name|blockManager
operator|.
name|getDatanodeManager
argument_list|()
operator|.
name|getNetworkTopology
argument_list|()
decl_stmt|;
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|info
argument_list|(
literal|"STATE* Network topology has {} racks and {}"
operator|+
literal|" datanodes"
argument_list|,
name|nt
operator|.
name|getNumOfRacks
argument_list|()
argument_list|,
name|nt
operator|.
name|getNumOfLeaves
argument_list|()
argument_list|)
expr_stmt|;
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|info
argument_list|(
literal|"STATE* UnderReplicatedBlocks has {} blocks"
argument_list|,
name|blockManager
operator|.
name|numOfUnderReplicatedBlocks
argument_list|()
argument_list|)
expr_stmt|;
name|namesystem
operator|.
name|startSecretManagerIfNecessary
argument_list|()
expr_stmt|;
comment|// If startup has not yet completed, end safemode phase.
name|StartupProgress
name|prog
init|=
name|NameNode
operator|.
name|getStartupProgress
argument_list|()
decl_stmt|;
if|if
condition|(
name|prog
operator|.
name|getStatus
argument_list|(
name|Phase
operator|.
name|SAFEMODE
argument_list|)
operator|!=
name|Status
operator|.
name|COMPLETE
condition|)
block|{
name|prog
operator|.
name|endStep
argument_list|(
name|Phase
operator|.
name|SAFEMODE
argument_list|,
name|BlockManagerSafeMode
operator|.
name|STEP_AWAITING_REPORTED_BLOCKS
argument_list|)
expr_stmt|;
name|prog
operator|.
name|endPhase
argument_list|(
name|Phase
operator|.
name|SAFEMODE
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Increment number of safe blocks if current block has reached minimal    * replication.    * If safe mode is not currently on, this is a no-op.    * @param storageNum  current number of replicas or number of internal blocks    *                    of a striped block group    * @param storedBlock current storedBlock which is either a    *                    BlockInfoContiguous or a BlockInfoStriped    */
DECL|method|incrementSafeBlockCount (int storageNum, BlockInfo storedBlock)
specifier|synchronized
name|void
name|incrementSafeBlockCount
parameter_list|(
name|int
name|storageNum
parameter_list|,
name|BlockInfo
name|storedBlock
parameter_list|)
block|{
assert|assert
name|namesystem
operator|.
name|hasWriteLock
argument_list|()
assert|;
if|if
condition|(
name|status
operator|==
name|BMSafeModeStatus
operator|.
name|OFF
condition|)
block|{
return|return;
block|}
specifier|final
name|int
name|safe
init|=
name|storedBlock
operator|.
name|isStriped
argument_list|()
condition|?
operator|(
operator|(
name|BlockInfoStriped
operator|)
name|storedBlock
operator|)
operator|.
name|getRealDataBlockNum
argument_list|()
else|:
name|safeReplication
decl_stmt|;
if|if
condition|(
name|storageNum
operator|==
name|safe
condition|)
block|{
name|this
operator|.
name|blockSafe
operator|++
expr_stmt|;
comment|// Report startup progress only if we haven't completed startup yet.
name|StartupProgress
name|prog
init|=
name|NameNode
operator|.
name|getStartupProgress
argument_list|()
decl_stmt|;
if|if
condition|(
name|prog
operator|.
name|getStatus
argument_list|(
name|Phase
operator|.
name|SAFEMODE
argument_list|)
operator|!=
name|Status
operator|.
name|COMPLETE
condition|)
block|{
if|if
condition|(
name|this
operator|.
name|awaitingReportedBlocksCounter
operator|==
literal|null
condition|)
block|{
name|this
operator|.
name|awaitingReportedBlocksCounter
operator|=
name|prog
operator|.
name|getCounter
argument_list|(
name|Phase
operator|.
name|SAFEMODE
argument_list|,
name|STEP_AWAITING_REPORTED_BLOCKS
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|awaitingReportedBlocksCounter
operator|.
name|increment
argument_list|()
expr_stmt|;
block|}
name|checkSafeMode
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Decrement number of safe blocks if current block has fallen below minimal    * replication.    * If safe mode is not currently on, this is a no-op.    */
DECL|method|decrementSafeBlockCount (BlockInfo b)
specifier|synchronized
name|void
name|decrementSafeBlockCount
parameter_list|(
name|BlockInfo
name|b
parameter_list|)
block|{
assert|assert
name|namesystem
operator|.
name|hasWriteLock
argument_list|()
assert|;
if|if
condition|(
name|status
operator|==
name|BMSafeModeStatus
operator|.
name|OFF
condition|)
block|{
return|return;
block|}
name|BlockInfo
name|storedBlock
init|=
name|blockManager
operator|.
name|getStoredBlock
argument_list|(
name|b
argument_list|)
decl_stmt|;
if|if
condition|(
name|storedBlock
operator|.
name|isComplete
argument_list|()
operator|&&
name|blockManager
operator|.
name|countNodes
argument_list|(
name|b
argument_list|)
operator|.
name|liveReplicas
argument_list|()
operator|==
name|safeReplication
operator|-
literal|1
condition|)
block|{
name|this
operator|.
name|blockSafe
operator|--
expr_stmt|;
assert|assert
name|blockSafe
operator|>=
literal|0
assert|;
name|checkSafeMode
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Check if the block report replica has a generation stamp (GS) in future.    * If safe mode is not currently on, this is a no-op.    *    * @param brr block report replica which belongs to no file in BlockManager    */
DECL|method|checkBlocksWithFutureGS (BlockReportReplica brr)
name|void
name|checkBlocksWithFutureGS
parameter_list|(
name|BlockReportReplica
name|brr
parameter_list|)
block|{
assert|assert
name|namesystem
operator|.
name|hasWriteLock
argument_list|()
assert|;
if|if
condition|(
name|status
operator|==
name|BMSafeModeStatus
operator|.
name|OFF
condition|)
block|{
return|return;
block|}
if|if
condition|(
operator|!
name|blockManager
operator|.
name|getShouldPostponeBlocksFromFuture
argument_list|()
operator|&&
operator|!
name|inRollBack
operator|&&
name|blockManager
operator|.
name|isGenStampInFuture
argument_list|(
name|brr
argument_list|)
condition|)
block|{
name|numberOfBytesInFutureBlocks
operator|.
name|addAndGet
argument_list|(
name|brr
operator|.
name|getBytesOnDisk
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Returns the number of bytes that reside in blocks with Generation Stamps    * greater than generation stamp known to Namenode.    *    * @return Bytes in future    */
DECL|method|getBytesInFuture ()
name|long
name|getBytesInFuture
parameter_list|()
block|{
return|return
name|numberOfBytesInFutureBlocks
operator|.
name|get
argument_list|()
return|;
block|}
DECL|method|close ()
name|void
name|close
parameter_list|()
block|{
assert|assert
name|namesystem
operator|.
name|hasWriteLock
argument_list|()
operator|:
literal|"Closing bmSafeMode needs write lock!"
assert|;
try|try
block|{
name|smmthread
operator|.
name|interrupt
argument_list|()
expr_stmt|;
name|smmthread
operator|.
name|join
argument_list|(
literal|3000
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ignored
parameter_list|)
block|{     }
block|}
comment|/**    * Get time (counting in milliseconds) left to leave extension period.    *    * Negative value indicates the extension period has passed.    */
DECL|method|timeToLeaveExtension ()
specifier|private
name|long
name|timeToLeaveExtension
parameter_list|()
block|{
return|return
name|reachedTime
operator|.
name|get
argument_list|()
operator|+
name|extension
operator|-
name|monotonicNow
argument_list|()
return|;
block|}
comment|/**    * Returns true if Namenode was started with a RollBack option.    *    * @param option - StartupOption    * @return boolean    */
DECL|method|isInRollBackMode (StartupOption option)
specifier|private
specifier|static
name|boolean
name|isInRollBackMode
parameter_list|(
name|StartupOption
name|option
parameter_list|)
block|{
return|return
operator|(
name|option
operator|==
name|StartupOption
operator|.
name|ROLLBACK
operator|)
operator|||
operator|(
name|option
operator|==
name|StartupOption
operator|.
name|ROLLINGUPGRADE
operator|&&
name|option
operator|.
name|getRollingUpgradeStartupOption
argument_list|()
operator|==
name|RollingUpgradeStartupOption
operator|.
name|ROLLBACK
operator|)
return|;
block|}
comment|/** Check if we are ready to initialize replication queues. */
DECL|method|initializeReplQueuesIfNecessary ()
specifier|private
name|void
name|initializeReplQueuesIfNecessary
parameter_list|()
block|{
assert|assert
name|namesystem
operator|.
name|hasWriteLock
argument_list|()
assert|;
comment|// Whether it has reached the threshold for initializing replication queues.
name|boolean
name|canInitializeReplQueues
init|=
name|blockManager
operator|.
name|shouldPopulateReplQueues
argument_list|()
operator|&&
name|blockSafe
operator|>=
name|blockReplQueueThreshold
decl_stmt|;
if|if
condition|(
name|canInitializeReplQueues
operator|&&
operator|!
name|blockManager
operator|.
name|isPopulatingReplQueues
argument_list|()
operator|&&
operator|!
name|haEnabled
condition|)
block|{
name|blockManager
operator|.
name|initializeReplQueues
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * @return true if both block and datanode threshold are met else false.    */
DECL|method|areThresholdsMet ()
specifier|private
name|boolean
name|areThresholdsMet
parameter_list|()
block|{
assert|assert
name|namesystem
operator|.
name|hasWriteLock
argument_list|()
assert|;
name|int
name|datanodeNum
init|=
name|blockManager
operator|.
name|getDatanodeManager
argument_list|()
operator|.
name|getNumLiveDataNodes
argument_list|()
decl_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
return|return
name|blockSafe
operator|>=
name|blockThreshold
operator|&&
name|datanodeNum
operator|>=
name|datanodeThreshold
return|;
block|}
block|}
comment|/**    * Checks consistency of the class state.    * This is costly so only runs if asserts are enabled.    */
DECL|method|doConsistencyCheck ()
specifier|private
name|void
name|doConsistencyCheck
parameter_list|()
block|{
name|boolean
name|assertsOn
init|=
literal|false
decl_stmt|;
assert|assert
name|assertsOn
operator|=
literal|true
assert|;
comment|// set to true if asserts are on
if|if
condition|(
operator|!
name|assertsOn
condition|)
block|{
return|return;
block|}
name|int
name|activeBlocks
init|=
name|blockManager
operator|.
name|getActiveBlockCount
argument_list|()
decl_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
if|if
condition|(
name|blockTotal
operator|!=
name|activeBlocks
operator|&&
operator|!
operator|(
name|blockSafe
operator|>=
literal|0
operator|&&
name|blockSafe
operator|<=
name|blockTotal
operator|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"SafeMode is in inconsistent filesystem state. "
operator|+
literal|"BlockManagerSafeMode data: blockTotal={}, blockSafe={}; "
operator|+
literal|"BlockManager data: activeBlocks={}"
argument_list|,
name|blockTotal
argument_list|,
name|blockSafe
argument_list|,
name|activeBlocks
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Print status every 20 seconds.    */
DECL|method|reportStatus (String msg, boolean rightNow)
specifier|private
name|void
name|reportStatus
parameter_list|(
name|String
name|msg
parameter_list|,
name|boolean
name|rightNow
parameter_list|)
block|{
assert|assert
name|namesystem
operator|.
name|hasWriteLock
argument_list|()
assert|;
name|long
name|curTime
init|=
name|monotonicNow
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|rightNow
operator|&&
operator|(
name|curTime
operator|-
name|lastStatusReport
operator|<
literal|20
operator|*
literal|1000
operator|)
condition|)
block|{
return|return;
block|}
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|info
argument_list|(
name|msg
operator|+
literal|" \n"
operator|+
name|getSafeModeTip
argument_list|()
argument_list|)
expr_stmt|;
name|lastStatusReport
operator|=
name|curTime
expr_stmt|;
block|}
comment|/**    * Periodically check whether it is time to leave safe mode.    * This thread starts when the threshold level is reached.    */
DECL|class|SafeModeMonitor
specifier|private
class|class
name|SafeModeMonitor
implements|implements
name|Runnable
block|{
comment|/** Interval in msec for checking safe mode. */
DECL|field|RECHECK_INTERVAL
specifier|private
specifier|static
specifier|final
name|long
name|RECHECK_INTERVAL
init|=
literal|1000
decl_stmt|;
annotation|@
name|Override
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
while|while
condition|(
name|namesystem
operator|.
name|isRunning
argument_list|()
condition|)
block|{
try|try
block|{
name|namesystem
operator|.
name|writeLock
argument_list|()
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|BMSafeModeStatus
operator|.
name|OFF
condition|)
block|{
comment|// Not in safe mode.
break|break;
block|}
if|if
condition|(
name|canLeave
argument_list|()
condition|)
block|{
comment|// EXTENSION -> OFF
name|leaveSafeMode
argument_list|(
literal|false
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
finally|finally
block|{
name|namesystem
operator|.
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|RECHECK_INTERVAL
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ignored
parameter_list|)
block|{         }
block|}
if|if
condition|(
operator|!
name|namesystem
operator|.
name|isRunning
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"NameNode is being shutdown, exit SafeModeMonitor thread"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Check whether the safe mode can be turned off by this monitor.      *      * Safe mode can be turned off iff      * the threshold is reached, and      * the extension time has passed.      */
DECL|method|canLeave ()
specifier|private
name|boolean
name|canLeave
parameter_list|()
block|{
if|if
condition|(
name|namesystem
operator|.
name|inTransitionToActive
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
elseif|else
if|if
condition|(
name|timeToLeaveExtension
argument_list|()
operator|>
literal|0
condition|)
block|{
name|reportStatus
argument_list|(
literal|"STATE* Safe mode ON, in safe mode extension."
argument_list|,
literal|false
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|areThresholdsMet
argument_list|()
condition|)
block|{
name|reportStatus
argument_list|(
literal|"STATE* Safe mode ON, thresholds not met."
argument_list|,
literal|false
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
else|else
block|{
return|return
literal|true
return|;
block|}
block|}
block|}
block|}
end_class

end_unit

