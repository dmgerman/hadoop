begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdfs.server.common
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileNotFoundException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|RandomAccessFile
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|management
operator|.
name|ManagementFactory
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|channels
operator|.
name|FileLock
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|channels
operator|.
name|OverlappingFileLockException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|DirectoryStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|Files
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Properties
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|CopyOnWriteArrayList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|io
operator|.
name|FileUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|HdfsServerConstants
operator|.
name|NodeType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|HdfsServerConstants
operator|.
name|StartupOption
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|StorageLocation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|nativeio
operator|.
name|NativeIO
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|nativeio
operator|.
name|NativeIOException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|ToolRunner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|VersionInfo
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Charsets
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_comment
comment|/**  * Storage information file.  *<p>  * Local storage information is stored in a separate file VERSION.  * It contains type of the node,   * the storage layout version, the namespace id, and   * the fs state creation time.  *<p>  * Local storage can reside in multiple directories.   * Each directory should contain the same VERSION file as the others.  * During startup Hadoop servers (name-node and data-nodes) read their local   * storage information from them.  *<p>  * The servers hold a lock for each storage directory while they run so that   * other nodes were not able to startup sharing the same storage.  * The locks are released when the servers stop (normally or abnormally).  *   */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
DECL|class|Storage
specifier|public
specifier|abstract
class|class
name|Storage
extends|extends
name|StorageInfo
block|{
DECL|field|LOG
specifier|public
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|Storage
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
comment|// last layout version that did not support upgrades
DECL|field|LAST_PRE_UPGRADE_LAYOUT_VERSION
specifier|public
specifier|static
specifier|final
name|int
name|LAST_PRE_UPGRADE_LAYOUT_VERSION
init|=
operator|-
literal|3
decl_stmt|;
comment|// this corresponds to Hadoop-0.18
DECL|field|LAST_UPGRADABLE_LAYOUT_VERSION
specifier|public
specifier|static
specifier|final
name|int
name|LAST_UPGRADABLE_LAYOUT_VERSION
init|=
operator|-
literal|16
decl_stmt|;
DECL|field|LAST_UPGRADABLE_HADOOP_VERSION
specifier|protected
specifier|static
specifier|final
name|String
name|LAST_UPGRADABLE_HADOOP_VERSION
init|=
literal|"Hadoop-0.18"
decl_stmt|;
comment|/** Layout versions of 0.20.203 release */
DECL|field|LAYOUT_VERSIONS_203
specifier|public
specifier|static
specifier|final
name|int
index|[]
name|LAYOUT_VERSIONS_203
init|=
block|{
operator|-
literal|19
block|,
operator|-
literal|31
block|}
decl_stmt|;
DECL|field|STORAGE_FILE_LOCK
specifier|public
specifier|static
specifier|final
name|String
name|STORAGE_FILE_LOCK
init|=
literal|"in_use.lock"
decl_stmt|;
DECL|field|STORAGE_DIR_CURRENT
specifier|public
specifier|static
specifier|final
name|String
name|STORAGE_DIR_CURRENT
init|=
literal|"current"
decl_stmt|;
DECL|field|STORAGE_DIR_PREVIOUS
specifier|public
specifier|static
specifier|final
name|String
name|STORAGE_DIR_PREVIOUS
init|=
literal|"previous"
decl_stmt|;
DECL|field|STORAGE_TMP_REMOVED
specifier|public
specifier|static
specifier|final
name|String
name|STORAGE_TMP_REMOVED
init|=
literal|"removed.tmp"
decl_stmt|;
DECL|field|STORAGE_TMP_PREVIOUS
specifier|public
specifier|static
specifier|final
name|String
name|STORAGE_TMP_PREVIOUS
init|=
literal|"previous.tmp"
decl_stmt|;
DECL|field|STORAGE_TMP_FINALIZED
specifier|public
specifier|static
specifier|final
name|String
name|STORAGE_TMP_FINALIZED
init|=
literal|"finalized.tmp"
decl_stmt|;
DECL|field|STORAGE_TMP_LAST_CKPT
specifier|public
specifier|static
specifier|final
name|String
name|STORAGE_TMP_LAST_CKPT
init|=
literal|"lastcheckpoint.tmp"
decl_stmt|;
DECL|field|STORAGE_PREVIOUS_CKPT
specifier|public
specifier|static
specifier|final
name|String
name|STORAGE_PREVIOUS_CKPT
init|=
literal|"previous.checkpoint"
decl_stmt|;
comment|/**    * The blocksBeingWritten directory which was used in some 1.x and earlier    * releases.    */
DECL|field|STORAGE_1_BBW
specifier|public
specifier|static
specifier|final
name|String
name|STORAGE_1_BBW
init|=
literal|"blocksBeingWritten"
decl_stmt|;
DECL|enum|StorageState
specifier|public
enum|enum
name|StorageState
block|{
DECL|enumConstant|NON_EXISTENT
name|NON_EXISTENT
block|,
DECL|enumConstant|NOT_FORMATTED
name|NOT_FORMATTED
block|,
DECL|enumConstant|COMPLETE_UPGRADE
name|COMPLETE_UPGRADE
block|,
DECL|enumConstant|RECOVER_UPGRADE
name|RECOVER_UPGRADE
block|,
DECL|enumConstant|COMPLETE_FINALIZE
name|COMPLETE_FINALIZE
block|,
DECL|enumConstant|COMPLETE_ROLLBACK
name|COMPLETE_ROLLBACK
block|,
DECL|enumConstant|RECOVER_ROLLBACK
name|RECOVER_ROLLBACK
block|,
DECL|enumConstant|COMPLETE_CHECKPOINT
name|COMPLETE_CHECKPOINT
block|,
DECL|enumConstant|RECOVER_CHECKPOINT
name|RECOVER_CHECKPOINT
block|,
DECL|enumConstant|NORMAL
name|NORMAL
block|;   }
comment|/**    * An interface to denote storage directory type    * Implementations can define a type for storage directory by implementing    * this interface.    */
annotation|@
name|InterfaceAudience
operator|.
name|Private
DECL|interface|StorageDirType
specifier|public
interface|interface
name|StorageDirType
block|{
DECL|method|getStorageDirType ()
specifier|public
name|StorageDirType
name|getStorageDirType
parameter_list|()
function_decl|;
DECL|method|isOfType (StorageDirType type)
specifier|public
name|boolean
name|isOfType
parameter_list|(
name|StorageDirType
name|type
parameter_list|)
function_decl|;
block|}
DECL|field|storageDirs
specifier|private
specifier|final
name|List
argument_list|<
name|StorageDirectory
argument_list|>
name|storageDirs
init|=
operator|new
name|CopyOnWriteArrayList
argument_list|<>
argument_list|()
decl_stmt|;
DECL|class|DirIterator
specifier|private
class|class
name|DirIterator
implements|implements
name|Iterator
argument_list|<
name|StorageDirectory
argument_list|>
block|{
DECL|field|dirType
specifier|final
name|StorageDirType
name|dirType
decl_stmt|;
DECL|field|includeShared
specifier|final
name|boolean
name|includeShared
decl_stmt|;
DECL|field|prevIndex
name|int
name|prevIndex
decl_stmt|;
comment|// for remove()
DECL|field|nextIndex
name|int
name|nextIndex
decl_stmt|;
comment|// for next()
DECL|method|DirIterator (StorageDirType dirType, boolean includeShared)
name|DirIterator
parameter_list|(
name|StorageDirType
name|dirType
parameter_list|,
name|boolean
name|includeShared
parameter_list|)
block|{
name|this
operator|.
name|dirType
operator|=
name|dirType
expr_stmt|;
name|this
operator|.
name|nextIndex
operator|=
literal|0
expr_stmt|;
name|this
operator|.
name|prevIndex
operator|=
literal|0
expr_stmt|;
name|this
operator|.
name|includeShared
operator|=
name|includeShared
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|hasNext ()
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
if|if
condition|(
name|storageDirs
operator|.
name|isEmpty
argument_list|()
operator|||
name|nextIndex
operator|>=
name|storageDirs
operator|.
name|size
argument_list|()
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|dirType
operator|!=
literal|null
operator|||
operator|!
name|includeShared
condition|)
block|{
while|while
condition|(
name|nextIndex
operator|<
name|storageDirs
operator|.
name|size
argument_list|()
condition|)
block|{
if|if
condition|(
name|shouldReturnNextDir
argument_list|()
condition|)
break|break;
name|nextIndex
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|nextIndex
operator|>=
name|storageDirs
operator|.
name|size
argument_list|()
condition|)
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
annotation|@
name|Override
DECL|method|next ()
specifier|public
name|StorageDirectory
name|next
parameter_list|()
block|{
name|StorageDirectory
name|sd
init|=
name|getStorageDir
argument_list|(
name|nextIndex
argument_list|)
decl_stmt|;
name|prevIndex
operator|=
name|nextIndex
expr_stmt|;
name|nextIndex
operator|++
expr_stmt|;
if|if
condition|(
name|dirType
operator|!=
literal|null
operator|||
operator|!
name|includeShared
condition|)
block|{
while|while
condition|(
name|nextIndex
operator|<
name|storageDirs
operator|.
name|size
argument_list|()
condition|)
block|{
if|if
condition|(
name|shouldReturnNextDir
argument_list|()
condition|)
break|break;
name|nextIndex
operator|++
expr_stmt|;
block|}
block|}
return|return
name|sd
return|;
block|}
annotation|@
name|Override
DECL|method|remove ()
specifier|public
name|void
name|remove
parameter_list|()
block|{
name|nextIndex
operator|=
name|prevIndex
expr_stmt|;
comment|// restore previous state
name|storageDirs
operator|.
name|remove
argument_list|(
name|prevIndex
argument_list|)
expr_stmt|;
comment|// remove last returned element
name|hasNext
argument_list|()
expr_stmt|;
comment|// reset nextIndex to correct place
block|}
DECL|method|shouldReturnNextDir ()
specifier|private
name|boolean
name|shouldReturnNextDir
parameter_list|()
block|{
name|StorageDirectory
name|sd
init|=
name|getStorageDir
argument_list|(
name|nextIndex
argument_list|)
decl_stmt|;
return|return
operator|(
name|dirType
operator|==
literal|null
operator|||
name|sd
operator|.
name|getStorageDirType
argument_list|()
operator|.
name|isOfType
argument_list|(
name|dirType
argument_list|)
operator|)
operator|&&
operator|(
name|includeShared
operator|||
operator|!
name|sd
operator|.
name|isShared
argument_list|()
operator|)
return|;
block|}
block|}
comment|/**    * @return A list of the given File in every available storage directory,    * regardless of whether it might exist.    */
DECL|method|getFiles (StorageDirType dirType, String fileName)
specifier|public
name|List
argument_list|<
name|File
argument_list|>
name|getFiles
parameter_list|(
name|StorageDirType
name|dirType
parameter_list|,
name|String
name|fileName
parameter_list|)
block|{
name|ArrayList
argument_list|<
name|File
argument_list|>
name|list
init|=
operator|new
name|ArrayList
argument_list|<
name|File
argument_list|>
argument_list|()
decl_stmt|;
name|Iterator
argument_list|<
name|StorageDirectory
argument_list|>
name|it
init|=
operator|(
name|dirType
operator|==
literal|null
operator|)
condition|?
name|dirIterator
argument_list|()
else|:
name|dirIterator
argument_list|(
name|dirType
argument_list|)
decl_stmt|;
for|for
control|(
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|list
operator|.
name|add
argument_list|(
operator|new
name|File
argument_list|(
name|it
operator|.
name|next
argument_list|()
operator|.
name|getCurrentDir
argument_list|()
argument_list|,
name|fileName
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|list
return|;
block|}
comment|/**    * Return default iterator    * This iterator returns all entries in storageDirs    */
DECL|method|dirIterator ()
specifier|public
name|Iterator
argument_list|<
name|StorageDirectory
argument_list|>
name|dirIterator
parameter_list|()
block|{
return|return
name|dirIterator
argument_list|(
literal|null
argument_list|)
return|;
block|}
comment|/**    * Return iterator based on Storage Directory Type    * This iterator selects entries in storageDirs of type dirType and returns    * them via the Iterator    */
DECL|method|dirIterator (StorageDirType dirType)
specifier|public
name|Iterator
argument_list|<
name|StorageDirectory
argument_list|>
name|dirIterator
parameter_list|(
name|StorageDirType
name|dirType
parameter_list|)
block|{
return|return
name|dirIterator
argument_list|(
name|dirType
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|/**    * Return all entries in storageDirs, potentially excluding shared dirs.    * @param includeShared whether or not to include shared dirs.    * @return an iterator over the configured storage dirs.    */
DECL|method|dirIterator (boolean includeShared)
specifier|public
name|Iterator
argument_list|<
name|StorageDirectory
argument_list|>
name|dirIterator
parameter_list|(
name|boolean
name|includeShared
parameter_list|)
block|{
return|return
name|dirIterator
argument_list|(
literal|null
argument_list|,
name|includeShared
argument_list|)
return|;
block|}
comment|/**    * @param dirType all entries will be of this type of dir    * @param includeShared true to include any shared directories,    *        false otherwise    * @return an iterator over the configured storage dirs.    */
DECL|method|dirIterator (StorageDirType dirType, boolean includeShared)
specifier|public
name|Iterator
argument_list|<
name|StorageDirectory
argument_list|>
name|dirIterator
parameter_list|(
name|StorageDirType
name|dirType
parameter_list|,
name|boolean
name|includeShared
parameter_list|)
block|{
return|return
operator|new
name|DirIterator
argument_list|(
name|dirType
argument_list|,
name|includeShared
argument_list|)
return|;
block|}
DECL|method|dirIterable (final StorageDirType dirType)
specifier|public
name|Iterable
argument_list|<
name|StorageDirectory
argument_list|>
name|dirIterable
parameter_list|(
specifier|final
name|StorageDirType
name|dirType
parameter_list|)
block|{
return|return
operator|new
name|Iterable
argument_list|<
name|StorageDirectory
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|StorageDirectory
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
name|dirIterator
argument_list|(
name|dirType
argument_list|)
return|;
block|}
block|}
return|;
block|}
comment|/**    * generate storage list (debug line)    */
DECL|method|listStorageDirectories ()
specifier|public
name|String
name|listStorageDirectories
parameter_list|()
block|{
name|StringBuilder
name|buf
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|StorageDirectory
name|sd
range|:
name|storageDirs
control|)
block|{
name|buf
operator|.
name|append
argument_list|(
name|sd
operator|.
name|getRoot
argument_list|()
operator|+
literal|"("
operator|+
name|sd
operator|.
name|getStorageDirType
argument_list|()
operator|+
literal|");"
argument_list|)
expr_stmt|;
block|}
return|return
name|buf
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * One of the storage directories.    */
annotation|@
name|InterfaceAudience
operator|.
name|Private
DECL|class|StorageDirectory
specifier|public
specifier|static
class|class
name|StorageDirectory
implements|implements
name|FormatConfirmable
block|{
DECL|field|root
specifier|final
name|File
name|root
decl_stmt|;
comment|// root directory
comment|// whether or not this dir is shared between two separate NNs for HA, or
comment|// between multiple block pools in the case of federation.
DECL|field|isShared
specifier|final
name|boolean
name|isShared
decl_stmt|;
DECL|field|dirType
specifier|final
name|StorageDirType
name|dirType
decl_stmt|;
comment|// storage dir type
DECL|field|lock
name|FileLock
name|lock
decl_stmt|;
comment|// storage lock
DECL|field|storageUuid
specifier|private
name|String
name|storageUuid
init|=
literal|null
decl_stmt|;
comment|// Storage directory identifier.
DECL|field|location
specifier|private
specifier|final
name|StorageLocation
name|location
decl_stmt|;
DECL|method|StorageDirectory (File dir)
specifier|public
name|StorageDirectory
parameter_list|(
name|File
name|dir
parameter_list|)
block|{
comment|// default dirType is null
name|this
argument_list|(
name|dir
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
DECL|method|StorageDirectory (StorageLocation location)
specifier|public
name|StorageDirectory
parameter_list|(
name|StorageLocation
name|location
parameter_list|)
block|{
comment|// default dirType is null
name|this
argument_list|(
literal|null
argument_list|,
literal|false
argument_list|,
name|location
argument_list|)
expr_stmt|;
block|}
DECL|method|StorageDirectory (File dir, StorageDirType dirType)
specifier|public
name|StorageDirectory
parameter_list|(
name|File
name|dir
parameter_list|,
name|StorageDirType
name|dirType
parameter_list|)
block|{
name|this
argument_list|(
name|dir
argument_list|,
name|dirType
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
DECL|method|setStorageUuid (String storageUuid)
specifier|public
name|void
name|setStorageUuid
parameter_list|(
name|String
name|storageUuid
parameter_list|)
block|{
name|this
operator|.
name|storageUuid
operator|=
name|storageUuid
expr_stmt|;
block|}
DECL|method|getStorageUuid ()
specifier|public
name|String
name|getStorageUuid
parameter_list|()
block|{
return|return
name|storageUuid
return|;
block|}
comment|/**      * Constructor      * @param dir directory corresponding to the storage      * @param dirType storage directory type      * @param isShared whether or not this dir is shared between two NNs. true      *          disables locking on the storage directory, false enables locking      */
DECL|method|StorageDirectory (File dir, StorageDirType dirType, boolean isShared)
specifier|public
name|StorageDirectory
parameter_list|(
name|File
name|dir
parameter_list|,
name|StorageDirType
name|dirType
parameter_list|,
name|boolean
name|isShared
parameter_list|)
block|{
name|this
argument_list|(
name|dir
argument_list|,
name|dirType
argument_list|,
name|isShared
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**      * Constructor      * @param dirType storage directory type      * @param isShared whether or not this dir is shared between two NNs. true      *          disables locking on the storage directory, false enables locking      * @param location the {@link StorageLocation} for this directory      */
DECL|method|StorageDirectory (StorageDirType dirType, boolean isShared, StorageLocation location)
specifier|public
name|StorageDirectory
parameter_list|(
name|StorageDirType
name|dirType
parameter_list|,
name|boolean
name|isShared
parameter_list|,
name|StorageLocation
name|location
parameter_list|)
block|{
name|this
argument_list|(
name|getStorageLocationFile
argument_list|(
name|location
argument_list|)
argument_list|,
name|dirType
argument_list|,
name|isShared
argument_list|,
name|location
argument_list|)
expr_stmt|;
block|}
comment|/**      * Constructor      * @param bpid the block pool id      * @param dirType storage directory type      * @param isShared whether or not this dir is shared between two NNs. true      *          disables locking on the storage directory, false enables locking      * @param location the {@link StorageLocation} for this directory      */
DECL|method|StorageDirectory (String bpid, StorageDirType dirType, boolean isShared, StorageLocation location)
specifier|public
name|StorageDirectory
parameter_list|(
name|String
name|bpid
parameter_list|,
name|StorageDirType
name|dirType
parameter_list|,
name|boolean
name|isShared
parameter_list|,
name|StorageLocation
name|location
parameter_list|)
block|{
name|this
argument_list|(
operator|new
name|File
argument_list|(
name|location
operator|.
name|getBpURI
argument_list|(
name|bpid
argument_list|,
name|STORAGE_DIR_CURRENT
argument_list|)
argument_list|)
argument_list|,
name|dirType
argument_list|,
name|isShared
argument_list|,
name|location
argument_list|)
expr_stmt|;
block|}
DECL|method|StorageDirectory (File dir, StorageDirType dirType, boolean isShared, StorageLocation location)
specifier|private
name|StorageDirectory
parameter_list|(
name|File
name|dir
parameter_list|,
name|StorageDirType
name|dirType
parameter_list|,
name|boolean
name|isShared
parameter_list|,
name|StorageLocation
name|location
parameter_list|)
block|{
name|this
operator|.
name|root
operator|=
name|dir
expr_stmt|;
name|this
operator|.
name|lock
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|dirType
operator|=
name|dirType
expr_stmt|;
name|this
operator|.
name|isShared
operator|=
name|isShared
expr_stmt|;
name|this
operator|.
name|location
operator|=
name|location
expr_stmt|;
assert|assert
name|location
operator|==
literal|null
operator|||
name|dir
operator|==
literal|null
operator|||
name|dir
operator|.
name|getAbsolutePath
argument_list|()
operator|.
name|startsWith
argument_list|(
operator|new
name|File
argument_list|(
name|location
operator|.
name|getUri
argument_list|()
argument_list|)
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
operator|:
literal|"The storage location and directory should be equal"
assert|;
block|}
DECL|method|getStorageLocationFile (StorageLocation location)
specifier|private
specifier|static
name|File
name|getStorageLocationFile
parameter_list|(
name|StorageLocation
name|location
parameter_list|)
block|{
if|if
condition|(
name|location
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
try|try
block|{
return|return
operator|new
name|File
argument_list|(
name|location
operator|.
name|getUri
argument_list|()
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
comment|//if location does not refer to a File
return|return
literal|null
return|;
block|}
block|}
comment|/**      * Get root directory of this storage      */
DECL|method|getRoot ()
specifier|public
name|File
name|getRoot
parameter_list|()
block|{
return|return
name|root
return|;
block|}
comment|/**      * Get storage directory type      */
DECL|method|getStorageDirType ()
specifier|public
name|StorageDirType
name|getStorageDirType
parameter_list|()
block|{
return|return
name|dirType
return|;
block|}
comment|/**      * Get storage directory size.      */
DECL|method|getDirecorySize ()
specifier|public
name|long
name|getDirecorySize
parameter_list|()
block|{
try|try
block|{
if|if
condition|(
operator|!
name|isShared
argument_list|()
operator|&&
name|root
operator|!=
literal|null
operator|&&
name|root
operator|.
name|exists
argument_list|()
condition|)
block|{
return|return
name|FileUtils
operator|.
name|sizeOfDirectory
argument_list|(
name|root
argument_list|)
return|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to get directory size :"
operator|+
name|root
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
DECL|method|read (File from, Storage storage)
specifier|public
name|void
name|read
parameter_list|(
name|File
name|from
parameter_list|,
name|Storage
name|storage
parameter_list|)
throws|throws
name|IOException
block|{
name|Properties
name|props
init|=
name|readPropertiesFile
argument_list|(
name|from
argument_list|)
decl_stmt|;
name|storage
operator|.
name|setFieldsFromProperties
argument_list|(
name|props
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
comment|/**      * Clear and re-create storage directory.      *<p>      * Removes contents of the current directory and creates an empty directory.      *       * This does not fully format storage directory.       * It cannot write the version file since it should be written last after        * all other storage type dependent files are written.      * Derived storage is responsible for setting specific storage values and      * writing the version file to disk.      *       * @throws IOException      */
DECL|method|clearDirectory ()
specifier|public
name|void
name|clearDirectory
parameter_list|()
throws|throws
name|IOException
block|{
name|File
name|curDir
init|=
name|this
operator|.
name|getCurrentDir
argument_list|()
decl_stmt|;
if|if
condition|(
name|curDir
operator|.
name|exists
argument_list|()
condition|)
block|{
name|File
index|[]
name|files
init|=
name|FileUtil
operator|.
name|listFiles
argument_list|(
name|curDir
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Will remove files: "
operator|+
name|Arrays
operator|.
name|toString
argument_list|(
name|files
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|FileUtil
operator|.
name|fullyDelete
argument_list|(
name|curDir
argument_list|)
operator|)
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Cannot remove current directory: "
operator|+
name|curDir
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|curDir
operator|.
name|mkdirs
argument_list|()
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Cannot create directory "
operator|+
name|curDir
argument_list|)
throw|;
block|}
comment|/**      * Directory {@code current} contains latest files defining      * the file system meta-data.      *       * @return the directory path      */
DECL|method|getCurrentDir ()
specifier|public
name|File
name|getCurrentDir
parameter_list|()
block|{
return|return
operator|new
name|File
argument_list|(
name|root
argument_list|,
name|STORAGE_DIR_CURRENT
argument_list|)
return|;
block|}
comment|/**      * File {@code VERSION} contains the following fields:      *<ol>      *<li>node type</li>      *<li>layout version</li>      *<li>namespaceID</li>      *<li>fs state creation time</li>      *<li>other fields specific for this node type</li>      *</ol>      * The version file is always written last during storage directory updates.      * The existence of the version file indicates that all other files have      * been successfully written in the storage directory, the storage is valid      * and does not need to be recovered.      *       * @return the version file path      */
DECL|method|getVersionFile ()
specifier|public
name|File
name|getVersionFile
parameter_list|()
block|{
return|return
operator|new
name|File
argument_list|(
operator|new
name|File
argument_list|(
name|root
argument_list|,
name|STORAGE_DIR_CURRENT
argument_list|)
argument_list|,
name|STORAGE_FILE_VERSION
argument_list|)
return|;
block|}
comment|/**      * File {@code VERSION} from the {@code previous} directory.      *       * @return the previous version file path      */
DECL|method|getPreviousVersionFile ()
specifier|public
name|File
name|getPreviousVersionFile
parameter_list|()
block|{
return|return
operator|new
name|File
argument_list|(
operator|new
name|File
argument_list|(
name|root
argument_list|,
name|STORAGE_DIR_PREVIOUS
argument_list|)
argument_list|,
name|STORAGE_FILE_VERSION
argument_list|)
return|;
block|}
comment|/**      * Directory {@code previous} contains the previous file system state,      * which the system can be rolled back to.      *       * @return the directory path      */
DECL|method|getPreviousDir ()
specifier|public
name|File
name|getPreviousDir
parameter_list|()
block|{
return|return
operator|new
name|File
argument_list|(
name|root
argument_list|,
name|STORAGE_DIR_PREVIOUS
argument_list|)
return|;
block|}
comment|/**      * {@code previous.tmp} is a transient directory, which holds      * current file system state while the new state is saved into the new      * {@code current} during upgrade.      * If the saving succeeds {@code previous.tmp} will be moved to      * {@code previous}, otherwise it will be renamed back to       * {@code current} by the recovery procedure during startup.      *       * @return the directory path      */
DECL|method|getPreviousTmp ()
specifier|public
name|File
name|getPreviousTmp
parameter_list|()
block|{
return|return
operator|new
name|File
argument_list|(
name|root
argument_list|,
name|STORAGE_TMP_PREVIOUS
argument_list|)
return|;
block|}
comment|/**      * {@code removed.tmp} is a transient directory, which holds      * current file system state while the previous state is moved into      * {@code current} during rollback.      * If the moving succeeds {@code removed.tmp} will be removed,      * otherwise it will be renamed back to       * {@code current} by the recovery procedure during startup.      *       * @return the directory path      */
DECL|method|getRemovedTmp ()
specifier|public
name|File
name|getRemovedTmp
parameter_list|()
block|{
return|return
operator|new
name|File
argument_list|(
name|root
argument_list|,
name|STORAGE_TMP_REMOVED
argument_list|)
return|;
block|}
comment|/**      * {@code finalized.tmp} is a transient directory, which holds      * the {@code previous} file system state while it is being removed      * in response to the finalize request.      * Finalize operation will remove {@code finalized.tmp} when completed,      * otherwise the removal will resume upon the system startup.      *       * @return the directory path      */
DECL|method|getFinalizedTmp ()
specifier|public
name|File
name|getFinalizedTmp
parameter_list|()
block|{
return|return
operator|new
name|File
argument_list|(
name|root
argument_list|,
name|STORAGE_TMP_FINALIZED
argument_list|)
return|;
block|}
comment|/**      * {@code lastcheckpoint.tmp} is a transient directory, which holds      * current file system state while the new state is saved into the new      * {@code current} during regular namespace updates.      * If the saving succeeds {@code lastcheckpoint.tmp} will be moved to      * {@code previous.checkpoint}, otherwise it will be renamed back to       * {@code current} by the recovery procedure during startup.      *       * @return the directory path      */
DECL|method|getLastCheckpointTmp ()
specifier|public
name|File
name|getLastCheckpointTmp
parameter_list|()
block|{
return|return
operator|new
name|File
argument_list|(
name|root
argument_list|,
name|STORAGE_TMP_LAST_CKPT
argument_list|)
return|;
block|}
comment|/**      * {@code previous.checkpoint} is a directory, which holds the previous      * (before the last save) state of the storage directory.      * The directory is created as a reference only, it does not play role      * in state recovery procedures, and is recycled automatically,       * but it may be useful for manual recovery of a stale state of the system.      *       * @return the directory path      */
DECL|method|getPreviousCheckpoint ()
specifier|public
name|File
name|getPreviousCheckpoint
parameter_list|()
block|{
return|return
operator|new
name|File
argument_list|(
name|root
argument_list|,
name|STORAGE_PREVIOUS_CKPT
argument_list|)
return|;
block|}
comment|/**      * Check to see if current/ directory is empty. This method is used      * before determining to format the directory.      *      * @throws InconsistentFSStateException if not empty.      * @throws IOException if unable to list files under the directory.      */
DECL|method|checkEmptyCurrent ()
specifier|private
name|void
name|checkEmptyCurrent
parameter_list|()
throws|throws
name|InconsistentFSStateException
throws|,
name|IOException
block|{
name|File
name|currentDir
init|=
name|getCurrentDir
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|currentDir
operator|.
name|exists
argument_list|()
condition|)
block|{
comment|// if current/ does not exist, it's safe to format it.
return|return;
block|}
try|try
init|(
name|DirectoryStream
argument_list|<
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|Path
argument_list|>
name|dirStream
init|=
name|Files
operator|.
name|newDirectoryStream
argument_list|(
name|currentDir
operator|.
name|toPath
argument_list|()
argument_list|)
init|)
block|{
if|if
condition|(
name|dirStream
operator|.
name|iterator
argument_list|()
operator|.
name|hasNext
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|InconsistentFSStateException
argument_list|(
name|root
argument_list|,
literal|"Can't format the storage directory because the current/ "
operator|+
literal|"directory is not empty."
argument_list|)
throw|;
block|}
block|}
block|}
comment|/**      * Check consistency of the storage directory.      *      * @param startOpt a startup option.      * @param storage The Storage object that manages this StorageDirectory.      *      * @return state {@link StorageState} of the storage directory      * @throws InconsistentFSStateException if directory state is not      * consistent and cannot be recovered.      * @throws IOException      */
DECL|method|analyzeStorage (StartupOption startOpt, Storage storage)
specifier|public
name|StorageState
name|analyzeStorage
parameter_list|(
name|StartupOption
name|startOpt
parameter_list|,
name|Storage
name|storage
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|analyzeStorage
argument_list|(
name|startOpt
argument_list|,
name|storage
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**      * Check consistency of the storage directory.      *       * @param startOpt a startup option.      * @param storage The Storage object that manages this StorageDirectory.      * @param checkCurrentIsEmpty if true, make sure current/ directory      *                            is empty before determining to format it.      *        * @return state {@link StorageState} of the storage directory       * @throws InconsistentFSStateException if directory state is not       * consistent and cannot be recovered.      * @throws IOException      */
DECL|method|analyzeStorage (StartupOption startOpt, Storage storage, boolean checkCurrentIsEmpty)
specifier|public
name|StorageState
name|analyzeStorage
parameter_list|(
name|StartupOption
name|startOpt
parameter_list|,
name|Storage
name|storage
parameter_list|,
name|boolean
name|checkCurrentIsEmpty
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|root
operator|!=
literal|null
operator|:
literal|"root is null"
assert|;
name|boolean
name|hadMkdirs
init|=
literal|false
decl_stmt|;
name|String
name|rootPath
init|=
name|root
operator|.
name|getCanonicalPath
argument_list|()
decl_stmt|;
try|try
block|{
comment|// check that storage exists
if|if
condition|(
operator|!
name|root
operator|.
name|exists
argument_list|()
condition|)
block|{
comment|// storage directory does not exist
if|if
condition|(
name|startOpt
operator|!=
name|StartupOption
operator|.
name|FORMAT
operator|&&
name|startOpt
operator|!=
name|StartupOption
operator|.
name|HOTSWAP
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Storage directory "
operator|+
name|rootPath
operator|+
literal|" does not exist"
argument_list|)
expr_stmt|;
return|return
name|StorageState
operator|.
name|NON_EXISTENT
return|;
block|}
name|LOG
operator|.
name|info
argument_list|(
name|rootPath
operator|+
literal|" does not exist. Creating ..."
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|root
operator|.
name|mkdirs
argument_list|()
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Cannot create directory "
operator|+
name|rootPath
argument_list|)
throw|;
name|hadMkdirs
operator|=
literal|true
expr_stmt|;
block|}
comment|// or is inaccessible
if|if
condition|(
operator|!
name|root
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|rootPath
operator|+
literal|"is not a directory"
argument_list|)
expr_stmt|;
return|return
name|StorageState
operator|.
name|NON_EXISTENT
return|;
block|}
if|if
condition|(
operator|!
name|FileUtil
operator|.
name|canWrite
argument_list|(
name|root
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Cannot access storage directory "
operator|+
name|rootPath
argument_list|)
expr_stmt|;
return|return
name|StorageState
operator|.
name|NON_EXISTENT
return|;
block|}
block|}
catch|catch
parameter_list|(
name|SecurityException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Cannot access storage directory "
operator|+
name|rootPath
argument_list|,
name|ex
argument_list|)
expr_stmt|;
return|return
name|StorageState
operator|.
name|NON_EXISTENT
return|;
block|}
name|this
operator|.
name|lock
argument_list|()
expr_stmt|;
comment|// lock storage if it exists
comment|// If startOpt is HOTSWAP, it returns NOT_FORMATTED for empty directory,
comment|// while it also checks the layout version.
if|if
condition|(
name|startOpt
operator|==
name|HdfsServerConstants
operator|.
name|StartupOption
operator|.
name|FORMAT
operator|||
operator|(
name|startOpt
operator|==
name|StartupOption
operator|.
name|HOTSWAP
operator|&&
name|hadMkdirs
operator|)
condition|)
block|{
if|if
condition|(
name|checkCurrentIsEmpty
condition|)
block|{
name|checkEmptyCurrent
argument_list|()
expr_stmt|;
block|}
return|return
name|StorageState
operator|.
name|NOT_FORMATTED
return|;
block|}
if|if
condition|(
name|startOpt
operator|!=
name|HdfsServerConstants
operator|.
name|StartupOption
operator|.
name|IMPORT
condition|)
block|{
name|storage
operator|.
name|checkOldLayoutStorage
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
comment|// check whether current directory is valid
name|File
name|versionFile
init|=
name|getVersionFile
argument_list|()
decl_stmt|;
name|boolean
name|hasCurrent
init|=
name|versionFile
operator|.
name|exists
argument_list|()
decl_stmt|;
comment|// check which directories exist
name|boolean
name|hasPrevious
init|=
name|getPreviousDir
argument_list|()
operator|.
name|exists
argument_list|()
decl_stmt|;
name|boolean
name|hasPreviousTmp
init|=
name|getPreviousTmp
argument_list|()
operator|.
name|exists
argument_list|()
decl_stmt|;
name|boolean
name|hasRemovedTmp
init|=
name|getRemovedTmp
argument_list|()
operator|.
name|exists
argument_list|()
decl_stmt|;
name|boolean
name|hasFinalizedTmp
init|=
name|getFinalizedTmp
argument_list|()
operator|.
name|exists
argument_list|()
decl_stmt|;
name|boolean
name|hasCheckpointTmp
init|=
name|getLastCheckpointTmp
argument_list|()
operator|.
name|exists
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|hasPreviousTmp
operator|||
name|hasRemovedTmp
operator|||
name|hasFinalizedTmp
operator|||
name|hasCheckpointTmp
operator|)
condition|)
block|{
comment|// no temp dirs - no recovery
if|if
condition|(
name|hasCurrent
condition|)
return|return
name|StorageState
operator|.
name|NORMAL
return|;
if|if
condition|(
name|hasPrevious
condition|)
throw|throw
operator|new
name|InconsistentFSStateException
argument_list|(
name|root
argument_list|,
literal|"version file in current directory is missing."
argument_list|)
throw|;
if|if
condition|(
name|checkCurrentIsEmpty
condition|)
block|{
name|checkEmptyCurrent
argument_list|()
expr_stmt|;
block|}
return|return
name|StorageState
operator|.
name|NOT_FORMATTED
return|;
block|}
if|if
condition|(
operator|(
name|hasPreviousTmp
condition|?
literal|1
else|:
literal|0
operator|)
operator|+
operator|(
name|hasRemovedTmp
condition|?
literal|1
else|:
literal|0
operator|)
operator|+
operator|(
name|hasFinalizedTmp
condition|?
literal|1
else|:
literal|0
operator|)
operator|+
operator|(
name|hasCheckpointTmp
condition|?
literal|1
else|:
literal|0
operator|)
operator|>
literal|1
condition|)
comment|// more than one temp dirs
throw|throw
operator|new
name|InconsistentFSStateException
argument_list|(
name|root
argument_list|,
literal|"too many temporary directories."
argument_list|)
throw|;
comment|// # of temp dirs == 1 should either recover or complete a transition
if|if
condition|(
name|hasCheckpointTmp
condition|)
block|{
return|return
name|hasCurrent
condition|?
name|StorageState
operator|.
name|COMPLETE_CHECKPOINT
else|:
name|StorageState
operator|.
name|RECOVER_CHECKPOINT
return|;
block|}
if|if
condition|(
name|hasFinalizedTmp
condition|)
block|{
if|if
condition|(
name|hasPrevious
condition|)
throw|throw
operator|new
name|InconsistentFSStateException
argument_list|(
name|root
argument_list|,
name|STORAGE_DIR_PREVIOUS
operator|+
literal|" and "
operator|+
name|STORAGE_TMP_FINALIZED
operator|+
literal|"cannot exist together."
argument_list|)
throw|;
return|return
name|StorageState
operator|.
name|COMPLETE_FINALIZE
return|;
block|}
if|if
condition|(
name|hasPreviousTmp
condition|)
block|{
if|if
condition|(
name|hasPrevious
condition|)
throw|throw
operator|new
name|InconsistentFSStateException
argument_list|(
name|root
argument_list|,
name|STORAGE_DIR_PREVIOUS
operator|+
literal|" and "
operator|+
name|STORAGE_TMP_PREVIOUS
operator|+
literal|" cannot exist together."
argument_list|)
throw|;
if|if
condition|(
name|hasCurrent
condition|)
return|return
name|StorageState
operator|.
name|COMPLETE_UPGRADE
return|;
return|return
name|StorageState
operator|.
name|RECOVER_UPGRADE
return|;
block|}
assert|assert
name|hasRemovedTmp
operator|:
literal|"hasRemovedTmp must be true"
assert|;
if|if
condition|(
operator|!
operator|(
name|hasCurrent
operator|^
name|hasPrevious
operator|)
condition|)
throw|throw
operator|new
name|InconsistentFSStateException
argument_list|(
name|root
argument_list|,
literal|"one and only one directory "
operator|+
name|STORAGE_DIR_CURRENT
operator|+
literal|" or "
operator|+
name|STORAGE_DIR_PREVIOUS
operator|+
literal|" must be present when "
operator|+
name|STORAGE_TMP_REMOVED
operator|+
literal|" exists."
argument_list|)
throw|;
if|if
condition|(
name|hasCurrent
condition|)
return|return
name|StorageState
operator|.
name|COMPLETE_ROLLBACK
return|;
return|return
name|StorageState
operator|.
name|RECOVER_ROLLBACK
return|;
block|}
comment|/**      * Complete or recover storage state from previously failed transition.      *       * @param curState specifies what/how the state should be recovered      * @throws IOException      */
DECL|method|doRecover (StorageState curState)
specifier|public
name|void
name|doRecover
parameter_list|(
name|StorageState
name|curState
parameter_list|)
throws|throws
name|IOException
block|{
name|File
name|curDir
init|=
name|getCurrentDir
argument_list|()
decl_stmt|;
name|String
name|rootPath
init|=
name|root
operator|.
name|getCanonicalPath
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|curState
condition|)
block|{
case|case
name|COMPLETE_UPGRADE
case|:
comment|// mv previous.tmp -> previous
name|LOG
operator|.
name|info
argument_list|(
literal|"Completing previous upgrade for storage directory "
operator|+
name|rootPath
argument_list|)
expr_stmt|;
name|rename
argument_list|(
name|getPreviousTmp
argument_list|()
argument_list|,
name|getPreviousDir
argument_list|()
argument_list|)
expr_stmt|;
return|return;
case|case
name|RECOVER_UPGRADE
case|:
comment|// mv previous.tmp -> current
name|LOG
operator|.
name|info
argument_list|(
literal|"Recovering storage directory "
operator|+
name|rootPath
operator|+
literal|" from previous upgrade"
argument_list|)
expr_stmt|;
if|if
condition|(
name|curDir
operator|.
name|exists
argument_list|()
condition|)
name|deleteDir
argument_list|(
name|curDir
argument_list|)
expr_stmt|;
name|rename
argument_list|(
name|getPreviousTmp
argument_list|()
argument_list|,
name|curDir
argument_list|)
expr_stmt|;
return|return;
case|case
name|COMPLETE_ROLLBACK
case|:
comment|// rm removed.tmp
name|LOG
operator|.
name|info
argument_list|(
literal|"Completing previous rollback for storage directory "
operator|+
name|rootPath
argument_list|)
expr_stmt|;
name|deleteDir
argument_list|(
name|getRemovedTmp
argument_list|()
argument_list|)
expr_stmt|;
return|return;
case|case
name|RECOVER_ROLLBACK
case|:
comment|// mv removed.tmp -> current
name|LOG
operator|.
name|info
argument_list|(
literal|"Recovering storage directory "
operator|+
name|rootPath
operator|+
literal|" from previous rollback"
argument_list|)
expr_stmt|;
name|rename
argument_list|(
name|getRemovedTmp
argument_list|()
argument_list|,
name|curDir
argument_list|)
expr_stmt|;
return|return;
case|case
name|COMPLETE_FINALIZE
case|:
comment|// rm finalized.tmp
name|LOG
operator|.
name|info
argument_list|(
literal|"Completing previous finalize for storage directory "
operator|+
name|rootPath
argument_list|)
expr_stmt|;
name|deleteDir
argument_list|(
name|getFinalizedTmp
argument_list|()
argument_list|)
expr_stmt|;
return|return;
case|case
name|COMPLETE_CHECKPOINT
case|:
comment|// mv lastcheckpoint.tmp -> previous.checkpoint
name|LOG
operator|.
name|info
argument_list|(
literal|"Completing previous checkpoint for storage directory "
operator|+
name|rootPath
argument_list|)
expr_stmt|;
name|File
name|prevCkptDir
init|=
name|getPreviousCheckpoint
argument_list|()
decl_stmt|;
if|if
condition|(
name|prevCkptDir
operator|.
name|exists
argument_list|()
condition|)
name|deleteDir
argument_list|(
name|prevCkptDir
argument_list|)
expr_stmt|;
name|rename
argument_list|(
name|getLastCheckpointTmp
argument_list|()
argument_list|,
name|prevCkptDir
argument_list|)
expr_stmt|;
return|return;
case|case
name|RECOVER_CHECKPOINT
case|:
comment|// mv lastcheckpoint.tmp -> current
name|LOG
operator|.
name|info
argument_list|(
literal|"Recovering storage directory "
operator|+
name|rootPath
operator|+
literal|" from failed checkpoint"
argument_list|)
expr_stmt|;
if|if
condition|(
name|curDir
operator|.
name|exists
argument_list|()
condition|)
name|deleteDir
argument_list|(
name|curDir
argument_list|)
expr_stmt|;
name|rename
argument_list|(
name|getLastCheckpointTmp
argument_list|()
argument_list|,
name|curDir
argument_list|)
expr_stmt|;
return|return;
default|default:
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unexpected FS state: "
operator|+
name|curState
operator|+
literal|" for storage directory: "
operator|+
name|rootPath
argument_list|)
throw|;
block|}
block|}
comment|/**      * @return true if the storage directory should prompt the user prior      * to formatting (i.e if the directory appears to contain some data)      * @throws IOException if the SD cannot be accessed due to an IO error      */
annotation|@
name|Override
DECL|method|hasSomeData ()
specifier|public
name|boolean
name|hasSomeData
parameter_list|()
throws|throws
name|IOException
block|{
comment|// Its alright for a dir not to exist, or to exist (properly accessible)
comment|// and be completely empty.
if|if
condition|(
operator|!
name|root
operator|.
name|exists
argument_list|()
condition|)
return|return
literal|false
return|;
if|if
condition|(
operator|!
name|root
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
comment|// a file where you expect a directory should not cause silent
comment|// formatting
return|return
literal|true
return|;
block|}
if|if
condition|(
name|FileUtil
operator|.
name|listFiles
argument_list|(
name|root
argument_list|)
operator|.
name|length
operator|==
literal|0
condition|)
block|{
comment|// Empty dir can format without prompt.
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
DECL|method|isShared ()
specifier|public
name|boolean
name|isShared
parameter_list|()
block|{
return|return
name|isShared
return|;
block|}
comment|/**      * Lock storage to provide exclusive access.      *       *<p> Locking is not supported by all file systems.      * E.g., NFS does not consistently support exclusive locks.      *       *<p> If locking is supported we guarantee exclusive access to the      * storage directory. Otherwise, no guarantee is given.      *       * @throws IOException if locking fails      */
DECL|method|lock ()
specifier|public
name|void
name|lock
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|isShared
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Locking is disabled for "
operator|+
name|this
operator|.
name|root
argument_list|)
expr_stmt|;
return|return;
block|}
name|FileLock
name|newLock
init|=
name|tryLock
argument_list|()
decl_stmt|;
if|if
condition|(
name|newLock
operator|==
literal|null
condition|)
block|{
name|String
name|msg
init|=
literal|"Cannot lock storage "
operator|+
name|this
operator|.
name|root
operator|+
literal|". The directory is already locked"
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|msg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
name|msg
argument_list|)
throw|;
block|}
comment|// Don't overwrite lock until success - this way if we accidentally
comment|// call lock twice, the internal state won't be cleared by the second
comment|// (failed) lock attempt
name|lock
operator|=
name|newLock
expr_stmt|;
block|}
comment|/**      * Attempts to acquire an exclusive lock on the storage.      *       * @return A lock object representing the newly-acquired lock or      *<code>null</code> if storage is already locked.      * @throws IOException if locking fails.      */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"resource"
argument_list|)
DECL|method|tryLock ()
name|FileLock
name|tryLock
parameter_list|()
throws|throws
name|IOException
block|{
name|boolean
name|deletionHookAdded
init|=
literal|false
decl_stmt|;
name|File
name|lockF
init|=
operator|new
name|File
argument_list|(
name|root
argument_list|,
name|STORAGE_FILE_LOCK
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|lockF
operator|.
name|exists
argument_list|()
condition|)
block|{
name|lockF
operator|.
name|deleteOnExit
argument_list|()
expr_stmt|;
name|deletionHookAdded
operator|=
literal|true
expr_stmt|;
block|}
name|RandomAccessFile
name|file
init|=
operator|new
name|RandomAccessFile
argument_list|(
name|lockF
argument_list|,
literal|"rws"
argument_list|)
decl_stmt|;
name|String
name|jvmName
init|=
name|ManagementFactory
operator|.
name|getRuntimeMXBean
argument_list|()
operator|.
name|getName
argument_list|()
decl_stmt|;
name|FileLock
name|res
init|=
literal|null
decl_stmt|;
try|try
block|{
name|res
operator|=
name|file
operator|.
name|getChannel
argument_list|()
operator|.
name|tryLock
argument_list|()
expr_stmt|;
if|if
condition|(
literal|null
operator|==
name|res
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to acquire file lock on path "
operator|+
name|lockF
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|OverlappingFileLockException
argument_list|()
throw|;
block|}
name|file
operator|.
name|write
argument_list|(
name|jvmName
operator|.
name|getBytes
argument_list|(
name|Charsets
operator|.
name|UTF_8
argument_list|)
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Lock on "
operator|+
name|lockF
operator|+
literal|" acquired by nodename "
operator|+
name|jvmName
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|OverlappingFileLockException
name|oe
parameter_list|)
block|{
comment|// Cannot read from the locked file on Windows.
name|String
name|lockingJvmName
init|=
name|Path
operator|.
name|WINDOWS
condition|?
literal|""
else|:
operator|(
literal|" "
operator|+
name|file
operator|.
name|readLine
argument_list|()
operator|)
decl_stmt|;
name|LOG
operator|.
name|error
argument_list|(
literal|"It appears that another node "
operator|+
name|lockingJvmName
operator|+
literal|" has already locked the storage directory: "
operator|+
name|root
argument_list|,
name|oe
argument_list|)
expr_stmt|;
name|file
operator|.
name|close
argument_list|()
expr_stmt|;
return|return
literal|null
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Failed to acquire lock on "
operator|+
name|lockF
operator|+
literal|". If this storage directory is mounted via NFS, "
operator|+
literal|"ensure that the appropriate nfs lock services are running."
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|file
operator|.
name|close
argument_list|()
expr_stmt|;
throw|throw
name|e
throw|;
block|}
if|if
condition|(
operator|!
name|deletionHookAdded
condition|)
block|{
comment|// If the file existed prior to our startup, we didn't
comment|// call deleteOnExit above. But since we successfully locked
comment|// the dir, we can take care of cleaning it up.
name|lockF
operator|.
name|deleteOnExit
argument_list|()
expr_stmt|;
block|}
return|return
name|res
return|;
block|}
comment|/**      * Unlock storage.      *       * @throws IOException      */
DECL|method|unlock ()
specifier|public
name|void
name|unlock
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|this
operator|.
name|lock
operator|==
literal|null
condition|)
return|return;
name|this
operator|.
name|lock
operator|.
name|release
argument_list|()
expr_stmt|;
name|lock
operator|.
name|channel
argument_list|()
operator|.
name|close
argument_list|()
expr_stmt|;
name|lock
operator|=
literal|null
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"Storage Directory "
operator|+
name|this
operator|.
name|root
return|;
block|}
comment|/**      * Check whether underlying file system supports file locking.      *       * @return<code>true</code> if exclusive locks are supported or      *<code>false</code> otherwise.      * @throws IOException      * @see StorageDirectory#lock()      */
DECL|method|isLockSupported ()
specifier|public
name|boolean
name|isLockSupported
parameter_list|()
throws|throws
name|IOException
block|{
name|FileLock
name|firstLock
init|=
literal|null
decl_stmt|;
name|FileLock
name|secondLock
init|=
literal|null
decl_stmt|;
try|try
block|{
name|firstLock
operator|=
name|lock
expr_stmt|;
if|if
condition|(
name|firstLock
operator|==
literal|null
condition|)
block|{
name|firstLock
operator|=
name|tryLock
argument_list|()
expr_stmt|;
if|if
condition|(
name|firstLock
operator|==
literal|null
condition|)
return|return
literal|true
return|;
block|}
name|secondLock
operator|=
name|tryLock
argument_list|()
expr_stmt|;
if|if
condition|(
name|secondLock
operator|==
literal|null
condition|)
return|return
literal|true
return|;
block|}
finally|finally
block|{
if|if
condition|(
name|firstLock
operator|!=
literal|null
operator|&&
name|firstLock
operator|!=
name|lock
condition|)
block|{
name|firstLock
operator|.
name|release
argument_list|()
expr_stmt|;
name|firstLock
operator|.
name|channel
argument_list|()
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|secondLock
operator|!=
literal|null
condition|)
block|{
name|secondLock
operator|.
name|release
argument_list|()
expr_stmt|;
name|secondLock
operator|.
name|channel
argument_list|()
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
return|return
literal|false
return|;
block|}
DECL|method|getStorageLocation ()
specifier|public
name|StorageLocation
name|getStorageLocation
parameter_list|()
block|{
return|return
name|location
return|;
block|}
block|}
comment|/**    * Create empty storage info of the specified type    */
DECL|method|Storage (NodeType type)
specifier|protected
name|Storage
parameter_list|(
name|NodeType
name|type
parameter_list|)
block|{
name|super
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
DECL|method|Storage (StorageInfo storageInfo)
specifier|protected
name|Storage
parameter_list|(
name|StorageInfo
name|storageInfo
parameter_list|)
block|{
name|super
argument_list|(
name|storageInfo
argument_list|)
expr_stmt|;
block|}
DECL|method|getNumStorageDirs ()
specifier|public
name|int
name|getNumStorageDirs
parameter_list|()
block|{
return|return
name|storageDirs
operator|.
name|size
argument_list|()
return|;
block|}
DECL|method|getStorageDirs ()
specifier|public
name|List
argument_list|<
name|StorageDirectory
argument_list|>
name|getStorageDirs
parameter_list|()
block|{
return|return
name|storageDirs
return|;
block|}
DECL|method|getStorageDir (int idx)
specifier|public
name|StorageDirectory
name|getStorageDir
parameter_list|(
name|int
name|idx
parameter_list|)
block|{
return|return
name|storageDirs
operator|.
name|get
argument_list|(
name|idx
argument_list|)
return|;
block|}
comment|/**    * @return the storage directory, with the precondition that this storage    * has exactly one storage directory    */
DECL|method|getSingularStorageDir ()
specifier|public
name|StorageDirectory
name|getSingularStorageDir
parameter_list|()
block|{
name|Preconditions
operator|.
name|checkState
argument_list|(
name|storageDirs
operator|.
name|size
argument_list|()
operator|==
literal|1
argument_list|)
expr_stmt|;
return|return
name|storageDirs
operator|.
name|get
argument_list|(
literal|0
argument_list|)
return|;
block|}
DECL|method|addStorageDir (StorageDirectory sd)
specifier|protected
name|void
name|addStorageDir
parameter_list|(
name|StorageDirectory
name|sd
parameter_list|)
block|{
name|storageDirs
operator|.
name|add
argument_list|(
name|sd
argument_list|)
expr_stmt|;
block|}
comment|/**    * Returns true if the storage directory on the given directory is already    * loaded.    * @param root the root directory of a {@link StorageDirectory}    * @throws IOException if failed to get canonical path.    */
DECL|method|containsStorageDir (File root)
specifier|protected
name|boolean
name|containsStorageDir
parameter_list|(
name|File
name|root
parameter_list|)
throws|throws
name|IOException
block|{
for|for
control|(
name|StorageDirectory
name|sd
range|:
name|storageDirs
control|)
block|{
if|if
condition|(
name|sd
operator|.
name|getRoot
argument_list|()
operator|.
name|getCanonicalPath
argument_list|()
operator|.
name|equals
argument_list|(
name|root
operator|.
name|getCanonicalPath
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/**    * Returns true if the storage directory on the given directory is already    * loaded.    * @param location the {@link StorageLocation}    * @throws IOException if failed to get canonical path.    */
DECL|method|containsStorageDir (StorageLocation location)
specifier|protected
name|boolean
name|containsStorageDir
parameter_list|(
name|StorageLocation
name|location
parameter_list|)
throws|throws
name|IOException
block|{
for|for
control|(
name|StorageDirectory
name|sd
range|:
name|storageDirs
control|)
block|{
if|if
condition|(
name|location
operator|.
name|matchesStorageDirectory
argument_list|(
name|sd
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/**    * Returns true if the storage directory on the given location is already    * loaded.    * @param location the {@link StorageLocation}    * @param bpid the block pool id    * @return true if the location matches to any existing storage directories    * @throws IOException IOException if failed to read location    * or storage directory path    */
DECL|method|containsStorageDir (StorageLocation location, String bpid)
specifier|protected
name|boolean
name|containsStorageDir
parameter_list|(
name|StorageLocation
name|location
parameter_list|,
name|String
name|bpid
parameter_list|)
throws|throws
name|IOException
block|{
for|for
control|(
name|StorageDirectory
name|sd
range|:
name|storageDirs
control|)
block|{
if|if
condition|(
name|location
operator|.
name|matchesStorageDirectory
argument_list|(
name|sd
argument_list|,
name|bpid
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/**    * Return true if the layout of the given storage directory is from a version    * of Hadoop prior to the introduction of the "current" and "previous"    * directories which allow upgrade and rollback.    */
DECL|method|isPreUpgradableLayout (StorageDirectory sd)
specifier|public
specifier|abstract
name|boolean
name|isPreUpgradableLayout
parameter_list|(
name|StorageDirectory
name|sd
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/**    * Check if the given storage directory comes from a version of Hadoop    * prior to when the directory layout changed (ie 0.13). If this is    * the case, this method throws an IOException.    */
DECL|method|checkOldLayoutStorage (StorageDirectory sd)
specifier|private
name|void
name|checkOldLayoutStorage
parameter_list|(
name|StorageDirectory
name|sd
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|isPreUpgradableLayout
argument_list|(
name|sd
argument_list|)
condition|)
block|{
name|checkVersionUpgradable
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Checks if the upgrade from {@code oldVersion} is supported.    * @param oldVersion the version of the metadata to check with the current    *                   version    * @throws IOException if upgrade is not supported    */
DECL|method|checkVersionUpgradable (int oldVersion)
specifier|public
specifier|static
name|void
name|checkVersionUpgradable
parameter_list|(
name|int
name|oldVersion
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|oldVersion
operator|>
name|LAST_UPGRADABLE_LAYOUT_VERSION
condition|)
block|{
name|String
name|msg
init|=
literal|"*********** Upgrade is not supported from this "
operator|+
literal|" older version "
operator|+
name|oldVersion
operator|+
literal|" of storage to the current version."
operator|+
literal|" Please upgrade to "
operator|+
name|LAST_UPGRADABLE_HADOOP_VERSION
operator|+
literal|" or a later version and then upgrade to current"
operator|+
literal|" version. Old layout version is "
operator|+
operator|(
name|oldVersion
operator|==
literal|0
condition|?
literal|"'too old'"
else|:
operator|(
literal|""
operator|+
name|oldVersion
operator|)
operator|)
operator|+
literal|" and latest layout version this software version can"
operator|+
literal|" upgrade from is "
operator|+
name|LAST_UPGRADABLE_LAYOUT_VERSION
operator|+
literal|". ************"
decl_stmt|;
name|LOG
operator|.
name|error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
name|msg
argument_list|)
throw|;
block|}
block|}
comment|/**    * Iterate over each of the {@link FormatConfirmable} objects,    * potentially checking with the user whether it should be formatted.    *     * If running in interactive mode, will prompt the user for each    * directory to allow them to format anyway. Otherwise, returns    * false, unless 'force' is specified.    *     * @param force format regardless of whether dirs exist    * @param interactive prompt the user when a dir exists    * @return true if formatting should proceed    * @throws IOException if some storage cannot be accessed    */
DECL|method|confirmFormat ( Iterable<? extends FormatConfirmable> items, boolean force, boolean interactive)
specifier|public
specifier|static
name|boolean
name|confirmFormat
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|FormatConfirmable
argument_list|>
name|items
parameter_list|,
name|boolean
name|force
parameter_list|,
name|boolean
name|interactive
parameter_list|)
throws|throws
name|IOException
block|{
for|for
control|(
name|FormatConfirmable
name|item
range|:
name|items
control|)
block|{
if|if
condition|(
operator|!
name|item
operator|.
name|hasSomeData
argument_list|()
condition|)
continue|continue;
if|if
condition|(
name|force
condition|)
block|{
comment|// Don't confirm, always format.
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Data exists in "
operator|+
name|item
operator|+
literal|". Formatting anyway."
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|interactive
condition|)
block|{
comment|// Don't ask - always don't format
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Running in non-interactive mode, and data appears to exist in "
operator|+
name|item
operator|+
literal|". Not formatting."
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|ToolRunner
operator|.
name|confirmPrompt
argument_list|(
literal|"Re-format filesystem in "
operator|+
name|item
operator|+
literal|" ?"
argument_list|)
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Format aborted in "
operator|+
name|item
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Interface for classes which need to have the user confirm their    * formatting during NameNode -format and other similar operations.    *     * This is currently a storage directory or journal manager.    */
annotation|@
name|InterfaceAudience
operator|.
name|Private
DECL|interface|FormatConfirmable
specifier|public
interface|interface
name|FormatConfirmable
block|{
comment|/**      * @return true if the storage seems to have some valid data in it,      * and the user should be required to confirm the format. Otherwise,      * false.      * @throws IOException if the storage cannot be accessed at all.      */
DECL|method|hasSomeData ()
specifier|public
name|boolean
name|hasSomeData
parameter_list|()
throws|throws
name|IOException
function_decl|;
comment|/**      * @return a string representation of the formattable item, suitable      * for display to the user inside a prompt      */
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
function_decl|;
block|}
comment|/**    * Set common storage fields into the given properties object.    * Should be overloaded if additional fields need to be set.    *     * @param props the Properties object to write into    */
DECL|method|setPropertiesFromFields (Properties props, StorageDirectory sd)
specifier|protected
name|void
name|setPropertiesFromFields
parameter_list|(
name|Properties
name|props
parameter_list|,
name|StorageDirectory
name|sd
parameter_list|)
throws|throws
name|IOException
block|{
name|props
operator|.
name|setProperty
argument_list|(
literal|"layoutVersion"
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
name|layoutVersion
argument_list|)
argument_list|)
expr_stmt|;
name|props
operator|.
name|setProperty
argument_list|(
literal|"storageType"
argument_list|,
name|storageType
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|props
operator|.
name|setProperty
argument_list|(
literal|"namespaceID"
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
name|namespaceID
argument_list|)
argument_list|)
expr_stmt|;
comment|// Set clusterID in version with federation support
if|if
condition|(
name|versionSupportsFederation
argument_list|(
name|getServiceLayoutFeatureMap
argument_list|()
argument_list|)
condition|)
block|{
name|props
operator|.
name|setProperty
argument_list|(
literal|"clusterID"
argument_list|,
name|clusterID
argument_list|)
expr_stmt|;
block|}
name|props
operator|.
name|setProperty
argument_list|(
literal|"cTime"
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
name|cTime
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Write properties to the VERSION file in the given storage directory.    */
DECL|method|writeProperties (StorageDirectory sd)
specifier|public
name|void
name|writeProperties
parameter_list|(
name|StorageDirectory
name|sd
parameter_list|)
throws|throws
name|IOException
block|{
name|writeProperties
argument_list|(
name|sd
operator|.
name|getVersionFile
argument_list|()
argument_list|,
name|sd
argument_list|)
expr_stmt|;
block|}
DECL|method|writeProperties (File to, StorageDirectory sd)
specifier|public
name|void
name|writeProperties
parameter_list|(
name|File
name|to
parameter_list|,
name|StorageDirectory
name|sd
parameter_list|)
throws|throws
name|IOException
block|{
name|Properties
name|props
init|=
operator|new
name|Properties
argument_list|()
decl_stmt|;
name|setPropertiesFromFields
argument_list|(
name|props
argument_list|,
name|sd
argument_list|)
expr_stmt|;
name|writeProperties
argument_list|(
name|to
argument_list|,
name|props
argument_list|)
expr_stmt|;
block|}
DECL|method|writeProperties (File to, Properties props)
specifier|public
specifier|static
name|void
name|writeProperties
parameter_list|(
name|File
name|to
parameter_list|,
name|Properties
name|props
parameter_list|)
throws|throws
name|IOException
block|{
try|try
init|(
name|RandomAccessFile
name|file
init|=
operator|new
name|RandomAccessFile
argument_list|(
name|to
argument_list|,
literal|"rws"
argument_list|)
init|;
name|FileOutputStream
name|out
operator|=
operator|new
name|FileOutputStream
argument_list|(
name|file
operator|.
name|getFD
argument_list|()
argument_list|)
init|)
block|{
name|file
operator|.
name|seek
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/*        * If server is interrupted before this line,        * the version file will remain unchanged.        */
name|props
operator|.
name|store
argument_list|(
name|out
argument_list|,
literal|null
argument_list|)
expr_stmt|;
comment|/*        * Now the new fields are flushed to the head of the file, but file        * length can still be larger then required and therefore the file can        * contain whole or corrupted fields from its old contents in the end.        * If server is interrupted here and restarted later these extra fields        * either should not effect server behavior or should be handled        * by the server correctly.        */
name|file
operator|.
name|setLength
argument_list|(
name|out
operator|.
name|getChannel
argument_list|()
operator|.
name|position
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|rename (File from, File to)
specifier|public
specifier|static
name|void
name|rename
parameter_list|(
name|File
name|from
parameter_list|,
name|File
name|to
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
name|NativeIO
operator|.
name|renameTo
argument_list|(
name|from
argument_list|,
name|to
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NativeIOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Failed to rename "
operator|+
name|from
operator|.
name|getCanonicalPath
argument_list|()
operator|+
literal|" to "
operator|+
name|to
operator|.
name|getCanonicalPath
argument_list|()
operator|+
literal|" due to failure in native rename. "
operator|+
name|e
operator|.
name|toString
argument_list|()
argument_list|)
throw|;
block|}
block|}
comment|/**    * Copies a file (usually large) to a new location using native unbuffered IO.    *<p>    * This method copies the contents of the specified source file    * to the specified destination file using OS specific unbuffered IO.    * The goal is to avoid churning the file system buffer cache when copying    * large files.    *    * We can't use FileUtils#copyFile from apache-commons-io because it    * is a buffered IO based on FileChannel#transferFrom, which uses MmapByteBuffer    * internally.    *    * The directory holding the destination file is created if it does not exist.    * If the destination file exists, then this method will delete it first.    *<p>    *<strong>Note:</strong> Setting<code>preserveFileDate</code> to    * {@code true} tries to preserve the file's last modified    * date/times using {@link File#setLastModified(long)}, however it is    * not guaranteed that the operation will succeed.    * If the modification operation fails, no indication is provided.    *    * @param srcFile  an existing file to copy, must not be {@code null}    * @param destFile  the new file, must not be {@code null}    * @param preserveFileDate  true if the file date of the copy    *  should be the same as the original    *    * @throws NullPointerException if source or destination is {@code null}    * @throws IOException if source or destination is invalid    * @throws IOException if an IO error occurs during copying    */
DECL|method|nativeCopyFileUnbuffered (File srcFile, File destFile, boolean preserveFileDate)
specifier|public
specifier|static
name|void
name|nativeCopyFileUnbuffered
parameter_list|(
name|File
name|srcFile
parameter_list|,
name|File
name|destFile
parameter_list|,
name|boolean
name|preserveFileDate
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|srcFile
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NullPointerException
argument_list|(
literal|"Source must not be null"
argument_list|)
throw|;
block|}
if|if
condition|(
name|destFile
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NullPointerException
argument_list|(
literal|"Destination must not be null"
argument_list|)
throw|;
block|}
if|if
condition|(
name|srcFile
operator|.
name|exists
argument_list|()
operator|==
literal|false
condition|)
block|{
throw|throw
operator|new
name|FileNotFoundException
argument_list|(
literal|"Source '"
operator|+
name|srcFile
operator|+
literal|"' does not exist"
argument_list|)
throw|;
block|}
if|if
condition|(
name|srcFile
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Source '"
operator|+
name|srcFile
operator|+
literal|"' exists but is a directory"
argument_list|)
throw|;
block|}
if|if
condition|(
name|srcFile
operator|.
name|getCanonicalPath
argument_list|()
operator|.
name|equals
argument_list|(
name|destFile
operator|.
name|getCanonicalPath
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Source '"
operator|+
name|srcFile
operator|+
literal|"' and destination '"
operator|+
name|destFile
operator|+
literal|"' are the same"
argument_list|)
throw|;
block|}
name|File
name|parentFile
init|=
name|destFile
operator|.
name|getParentFile
argument_list|()
decl_stmt|;
if|if
condition|(
name|parentFile
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
operator|!
name|parentFile
operator|.
name|mkdirs
argument_list|()
operator|&&
operator|!
name|parentFile
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Destination '"
operator|+
name|parentFile
operator|+
literal|"' directory cannot be created"
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
name|destFile
operator|.
name|exists
argument_list|()
condition|)
block|{
if|if
condition|(
name|FileUtil
operator|.
name|canWrite
argument_list|(
name|destFile
argument_list|)
operator|==
literal|false
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Destination '"
operator|+
name|destFile
operator|+
literal|"' exists but is read-only"
argument_list|)
throw|;
block|}
else|else
block|{
if|if
condition|(
name|destFile
operator|.
name|delete
argument_list|()
operator|==
literal|false
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Destination '"
operator|+
name|destFile
operator|+
literal|"' exists but cannot be deleted"
argument_list|)
throw|;
block|}
block|}
block|}
try|try
block|{
name|NativeIO
operator|.
name|copyFileUnbuffered
argument_list|(
name|srcFile
argument_list|,
name|destFile
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NativeIOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Failed to copy "
operator|+
name|srcFile
operator|.
name|getCanonicalPath
argument_list|()
operator|+
literal|" to "
operator|+
name|destFile
operator|.
name|getCanonicalPath
argument_list|()
operator|+
literal|" due to failure in NativeIO#copyFileUnbuffered(). "
operator|+
name|e
operator|.
name|toString
argument_list|()
argument_list|)
throw|;
block|}
if|if
condition|(
name|srcFile
operator|.
name|length
argument_list|()
operator|!=
name|destFile
operator|.
name|length
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Failed to copy full contents from '"
operator|+
name|srcFile
operator|+
literal|"' to '"
operator|+
name|destFile
operator|+
literal|"'"
argument_list|)
throw|;
block|}
if|if
condition|(
name|preserveFileDate
condition|)
block|{
if|if
condition|(
name|destFile
operator|.
name|setLastModified
argument_list|(
name|srcFile
operator|.
name|lastModified
argument_list|()
argument_list|)
operator|==
literal|false
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Failed to preserve last modified date from'"
operator|+
name|srcFile
operator|+
literal|"' to '"
operator|+
name|destFile
operator|+
literal|"'"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**    * Recursively delete all the content of the directory first and then     * the directory itself from the local filesystem.    * @param dir The directory to delete    * @throws IOException    */
DECL|method|deleteDir (File dir)
specifier|public
specifier|static
name|void
name|deleteDir
parameter_list|(
name|File
name|dir
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|FileUtil
operator|.
name|fullyDelete
argument_list|(
name|dir
argument_list|)
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Failed to delete "
operator|+
name|dir
operator|.
name|getCanonicalPath
argument_list|()
argument_list|)
throw|;
block|}
comment|/**    * Write all data storage files.    * @throws IOException    */
DECL|method|writeAll ()
specifier|public
name|void
name|writeAll
parameter_list|()
throws|throws
name|IOException
block|{
name|this
operator|.
name|layoutVersion
operator|=
name|getServiceLayoutVersion
argument_list|()
expr_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|StorageDirectory
argument_list|>
name|it
init|=
name|storageDirs
operator|.
name|iterator
argument_list|()
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|writeProperties
argument_list|(
name|it
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Unlock all storage directories.    * @throws IOException    */
DECL|method|unlockAll ()
specifier|public
name|void
name|unlockAll
parameter_list|()
throws|throws
name|IOException
block|{
for|for
control|(
name|Iterator
argument_list|<
name|StorageDirectory
argument_list|>
name|it
init|=
name|storageDirs
operator|.
name|iterator
argument_list|()
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|it
operator|.
name|next
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|getBuildVersion ()
specifier|public
specifier|static
name|String
name|getBuildVersion
parameter_list|()
block|{
return|return
name|VersionInfo
operator|.
name|getRevision
argument_list|()
return|;
block|}
DECL|method|getRegistrationID (StorageInfo storage)
specifier|public
specifier|static
name|String
name|getRegistrationID
parameter_list|(
name|StorageInfo
name|storage
parameter_list|)
block|{
return|return
literal|"NS-"
operator|+
name|Integer
operator|.
name|toString
argument_list|(
name|storage
operator|.
name|getNamespaceID
argument_list|()
argument_list|)
operator|+
literal|"-"
operator|+
name|storage
operator|.
name|getClusterID
argument_list|()
operator|+
literal|"-"
operator|+
name|Long
operator|.
name|toString
argument_list|(
name|storage
operator|.
name|getCTime
argument_list|()
argument_list|)
return|;
block|}
DECL|method|is203LayoutVersion (int layoutVersion)
specifier|public
specifier|static
name|boolean
name|is203LayoutVersion
parameter_list|(
name|int
name|layoutVersion
parameter_list|)
block|{
for|for
control|(
name|int
name|lv203
range|:
name|LAYOUT_VERSIONS_203
control|)
block|{
if|if
condition|(
name|lv203
operator|==
name|layoutVersion
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
block|}
end_class

end_unit

