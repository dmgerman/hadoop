begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdfs.server.common
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|RandomAccessFile
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|management
operator|.
name|ManagementFactory
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|channels
operator|.
name|FileLock
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|channels
operator|.
name|OverlappingFileLockException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Properties
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|HdfsConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|LayoutVersion
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|LayoutVersion
operator|.
name|Feature
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|HdfsServerConstants
operator|.
name|NodeType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|HdfsServerConstants
operator|.
name|StartupOption
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|VersionInfo
import|;
end_import

begin_comment
comment|/**  * Storage information file.  *<p>  * Local storage information is stored in a separate file VERSION.  * It contains type of the node,   * the storage layout version, the namespace id, and   * the fs state creation time.  *<p>  * Local storage can reside in multiple directories.   * Each directory should contain the same VERSION file as the others.  * During startup Hadoop servers (name-node and data-nodes) read their local   * storage information from them.  *<p>  * The servers hold a lock for each storage directory while they run so that   * other nodes were not able to startup sharing the same storage.  * The locks are released when the servers stop (normally or abnormally).  *   */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
DECL|class|Storage
specifier|public
specifier|abstract
class|class
name|Storage
extends|extends
name|StorageInfo
block|{
DECL|field|LOG
specifier|public
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|Storage
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
comment|// last layout version that did not support upgrades
DECL|field|LAST_PRE_UPGRADE_LAYOUT_VERSION
specifier|public
specifier|static
specifier|final
name|int
name|LAST_PRE_UPGRADE_LAYOUT_VERSION
init|=
operator|-
literal|3
decl_stmt|;
comment|// this corresponds to Hadoop-0.18
DECL|field|LAST_UPGRADABLE_LAYOUT_VERSION
specifier|public
specifier|static
specifier|final
name|int
name|LAST_UPGRADABLE_LAYOUT_VERSION
init|=
operator|-
literal|16
decl_stmt|;
DECL|field|LAST_UPGRADABLE_HADOOP_VERSION
specifier|protected
specifier|static
specifier|final
name|String
name|LAST_UPGRADABLE_HADOOP_VERSION
init|=
literal|"Hadoop-0.18"
decl_stmt|;
comment|/** Layout versions of 0.20.203 release */
DECL|field|LAYOUT_VERSIONS_203
specifier|public
specifier|static
specifier|final
name|int
index|[]
name|LAYOUT_VERSIONS_203
init|=
block|{
operator|-
literal|19
block|,
operator|-
literal|31
block|}
decl_stmt|;
DECL|field|STORAGE_FILE_LOCK
specifier|private
specifier|static
specifier|final
name|String
name|STORAGE_FILE_LOCK
init|=
literal|"in_use.lock"
decl_stmt|;
DECL|field|STORAGE_FILE_VERSION
specifier|protected
specifier|static
specifier|final
name|String
name|STORAGE_FILE_VERSION
init|=
literal|"VERSION"
decl_stmt|;
DECL|field|STORAGE_DIR_CURRENT
specifier|public
specifier|static
specifier|final
name|String
name|STORAGE_DIR_CURRENT
init|=
literal|"current"
decl_stmt|;
DECL|field|STORAGE_DIR_PREVIOUS
specifier|public
specifier|static
specifier|final
name|String
name|STORAGE_DIR_PREVIOUS
init|=
literal|"previous"
decl_stmt|;
DECL|field|STORAGE_TMP_REMOVED
specifier|public
specifier|static
specifier|final
name|String
name|STORAGE_TMP_REMOVED
init|=
literal|"removed.tmp"
decl_stmt|;
DECL|field|STORAGE_TMP_PREVIOUS
specifier|public
specifier|static
specifier|final
name|String
name|STORAGE_TMP_PREVIOUS
init|=
literal|"previous.tmp"
decl_stmt|;
DECL|field|STORAGE_TMP_FINALIZED
specifier|public
specifier|static
specifier|final
name|String
name|STORAGE_TMP_FINALIZED
init|=
literal|"finalized.tmp"
decl_stmt|;
DECL|field|STORAGE_TMP_LAST_CKPT
specifier|public
specifier|static
specifier|final
name|String
name|STORAGE_TMP_LAST_CKPT
init|=
literal|"lastcheckpoint.tmp"
decl_stmt|;
DECL|field|STORAGE_PREVIOUS_CKPT
specifier|public
specifier|static
specifier|final
name|String
name|STORAGE_PREVIOUS_CKPT
init|=
literal|"previous.checkpoint"
decl_stmt|;
DECL|enum|StorageState
specifier|public
enum|enum
name|StorageState
block|{
DECL|enumConstant|NON_EXISTENT
name|NON_EXISTENT
block|,
DECL|enumConstant|NOT_FORMATTED
name|NOT_FORMATTED
block|,
DECL|enumConstant|COMPLETE_UPGRADE
name|COMPLETE_UPGRADE
block|,
DECL|enumConstant|RECOVER_UPGRADE
name|RECOVER_UPGRADE
block|,
DECL|enumConstant|COMPLETE_FINALIZE
name|COMPLETE_FINALIZE
block|,
DECL|enumConstant|COMPLETE_ROLLBACK
name|COMPLETE_ROLLBACK
block|,
DECL|enumConstant|RECOVER_ROLLBACK
name|RECOVER_ROLLBACK
block|,
DECL|enumConstant|COMPLETE_CHECKPOINT
name|COMPLETE_CHECKPOINT
block|,
DECL|enumConstant|RECOVER_CHECKPOINT
name|RECOVER_CHECKPOINT
block|,
DECL|enumConstant|NORMAL
name|NORMAL
block|;   }
comment|/**    * An interface to denote storage directory type    * Implementations can define a type for storage directory by implementing    * this interface.    */
annotation|@
name|InterfaceAudience
operator|.
name|Private
DECL|interface|StorageDirType
specifier|public
interface|interface
name|StorageDirType
block|{
DECL|method|getStorageDirType ()
specifier|public
name|StorageDirType
name|getStorageDirType
parameter_list|()
function_decl|;
DECL|method|isOfType (StorageDirType type)
specifier|public
name|boolean
name|isOfType
parameter_list|(
name|StorageDirType
name|type
parameter_list|)
function_decl|;
block|}
DECL|field|storageType
specifier|protected
name|NodeType
name|storageType
decl_stmt|;
comment|// Type of the node using this storage
DECL|field|storageDirs
specifier|protected
name|List
argument_list|<
name|StorageDirectory
argument_list|>
name|storageDirs
init|=
operator|new
name|ArrayList
argument_list|<
name|StorageDirectory
argument_list|>
argument_list|()
decl_stmt|;
DECL|class|DirIterator
specifier|private
class|class
name|DirIterator
implements|implements
name|Iterator
argument_list|<
name|StorageDirectory
argument_list|>
block|{
DECL|field|dirType
name|StorageDirType
name|dirType
decl_stmt|;
DECL|field|prevIndex
name|int
name|prevIndex
decl_stmt|;
comment|// for remove()
DECL|field|nextIndex
name|int
name|nextIndex
decl_stmt|;
comment|// for next()
DECL|method|DirIterator (StorageDirType dirType)
name|DirIterator
parameter_list|(
name|StorageDirType
name|dirType
parameter_list|)
block|{
name|this
operator|.
name|dirType
operator|=
name|dirType
expr_stmt|;
name|this
operator|.
name|nextIndex
operator|=
literal|0
expr_stmt|;
name|this
operator|.
name|prevIndex
operator|=
literal|0
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|hasNext ()
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
if|if
condition|(
name|storageDirs
operator|.
name|isEmpty
argument_list|()
operator|||
name|nextIndex
operator|>=
name|storageDirs
operator|.
name|size
argument_list|()
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|dirType
operator|!=
literal|null
condition|)
block|{
while|while
condition|(
name|nextIndex
operator|<
name|storageDirs
operator|.
name|size
argument_list|()
condition|)
block|{
if|if
condition|(
name|getStorageDir
argument_list|(
name|nextIndex
argument_list|)
operator|.
name|getStorageDirType
argument_list|()
operator|.
name|isOfType
argument_list|(
name|dirType
argument_list|)
condition|)
break|break;
name|nextIndex
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|nextIndex
operator|>=
name|storageDirs
operator|.
name|size
argument_list|()
condition|)
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
annotation|@
name|Override
DECL|method|next ()
specifier|public
name|StorageDirectory
name|next
parameter_list|()
block|{
name|StorageDirectory
name|sd
init|=
name|getStorageDir
argument_list|(
name|nextIndex
argument_list|)
decl_stmt|;
name|prevIndex
operator|=
name|nextIndex
expr_stmt|;
name|nextIndex
operator|++
expr_stmt|;
if|if
condition|(
name|dirType
operator|!=
literal|null
condition|)
block|{
while|while
condition|(
name|nextIndex
operator|<
name|storageDirs
operator|.
name|size
argument_list|()
condition|)
block|{
if|if
condition|(
name|getStorageDir
argument_list|(
name|nextIndex
argument_list|)
operator|.
name|getStorageDirType
argument_list|()
operator|.
name|isOfType
argument_list|(
name|dirType
argument_list|)
condition|)
break|break;
name|nextIndex
operator|++
expr_stmt|;
block|}
block|}
return|return
name|sd
return|;
block|}
annotation|@
name|Override
DECL|method|remove ()
specifier|public
name|void
name|remove
parameter_list|()
block|{
name|nextIndex
operator|=
name|prevIndex
expr_stmt|;
comment|// restore previous state
name|storageDirs
operator|.
name|remove
argument_list|(
name|prevIndex
argument_list|)
expr_stmt|;
comment|// remove last returned element
name|hasNext
argument_list|()
expr_stmt|;
comment|// reset nextIndex to correct place
block|}
block|}
comment|/**    * @return A list of the given File in every available storage directory,    * regardless of whether it might exist.    */
DECL|method|getFiles (StorageDirType dirType, String fileName)
specifier|public
name|List
argument_list|<
name|File
argument_list|>
name|getFiles
parameter_list|(
name|StorageDirType
name|dirType
parameter_list|,
name|String
name|fileName
parameter_list|)
block|{
name|ArrayList
argument_list|<
name|File
argument_list|>
name|list
init|=
operator|new
name|ArrayList
argument_list|<
name|File
argument_list|>
argument_list|()
decl_stmt|;
name|Iterator
argument_list|<
name|StorageDirectory
argument_list|>
name|it
init|=
operator|(
name|dirType
operator|==
literal|null
operator|)
condition|?
name|dirIterator
argument_list|()
else|:
name|dirIterator
argument_list|(
name|dirType
argument_list|)
decl_stmt|;
for|for
control|(
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|list
operator|.
name|add
argument_list|(
operator|new
name|File
argument_list|(
name|it
operator|.
name|next
argument_list|()
operator|.
name|getCurrentDir
argument_list|()
argument_list|,
name|fileName
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|list
return|;
block|}
comment|/**    * Return default iterator    * This iterator returns all entries in storageDirs    */
DECL|method|dirIterator ()
specifier|public
name|Iterator
argument_list|<
name|StorageDirectory
argument_list|>
name|dirIterator
parameter_list|()
block|{
return|return
name|dirIterator
argument_list|(
literal|null
argument_list|)
return|;
block|}
comment|/**    * Return iterator based on Storage Directory Type    * This iterator selects entries in storageDirs of type dirType and returns    * them via the Iterator    */
DECL|method|dirIterator (StorageDirType dirType)
specifier|public
name|Iterator
argument_list|<
name|StorageDirectory
argument_list|>
name|dirIterator
parameter_list|(
name|StorageDirType
name|dirType
parameter_list|)
block|{
return|return
operator|new
name|DirIterator
argument_list|(
name|dirType
argument_list|)
return|;
block|}
DECL|method|dirIterable (final StorageDirType dirType)
specifier|public
name|Iterable
argument_list|<
name|StorageDirectory
argument_list|>
name|dirIterable
parameter_list|(
specifier|final
name|StorageDirType
name|dirType
parameter_list|)
block|{
return|return
operator|new
name|Iterable
argument_list|<
name|StorageDirectory
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|StorageDirectory
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
name|dirIterator
argument_list|(
name|dirType
argument_list|)
return|;
block|}
block|}
return|;
block|}
comment|/**    * generate storage list (debug line)    */
DECL|method|listStorageDirectories ()
specifier|public
name|String
name|listStorageDirectories
parameter_list|()
block|{
name|StringBuilder
name|buf
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|StorageDirectory
name|sd
range|:
name|storageDirs
control|)
block|{
name|buf
operator|.
name|append
argument_list|(
name|sd
operator|.
name|getRoot
argument_list|()
operator|+
literal|"("
operator|+
name|sd
operator|.
name|getStorageDirType
argument_list|()
operator|+
literal|");"
argument_list|)
expr_stmt|;
block|}
return|return
name|buf
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * One of the storage directories.    */
annotation|@
name|InterfaceAudience
operator|.
name|Private
DECL|class|StorageDirectory
specifier|public
specifier|static
class|class
name|StorageDirectory
block|{
DECL|field|root
specifier|final
name|File
name|root
decl_stmt|;
comment|// root directory
DECL|field|useLock
specifier|final
name|boolean
name|useLock
decl_stmt|;
comment|// flag to enable storage lock
DECL|field|dirType
specifier|final
name|StorageDirType
name|dirType
decl_stmt|;
comment|// storage dir type
DECL|field|lock
name|FileLock
name|lock
decl_stmt|;
comment|// storage lock
DECL|method|StorageDirectory (File dir)
specifier|public
name|StorageDirectory
parameter_list|(
name|File
name|dir
parameter_list|)
block|{
comment|// default dirType is null
name|this
argument_list|(
name|dir
argument_list|,
literal|null
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
DECL|method|StorageDirectory (File dir, StorageDirType dirType)
specifier|public
name|StorageDirectory
parameter_list|(
name|File
name|dir
parameter_list|,
name|StorageDirType
name|dirType
parameter_list|)
block|{
name|this
argument_list|(
name|dir
argument_list|,
name|dirType
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**      * Constructor      * @param dir directory corresponding to the storage      * @param dirType storage directory type      * @param useLock true - enables locking on the storage directory and false      *          disables locking      */
DECL|method|StorageDirectory (File dir, StorageDirType dirType, boolean useLock)
specifier|public
name|StorageDirectory
parameter_list|(
name|File
name|dir
parameter_list|,
name|StorageDirType
name|dirType
parameter_list|,
name|boolean
name|useLock
parameter_list|)
block|{
name|this
operator|.
name|root
operator|=
name|dir
expr_stmt|;
name|this
operator|.
name|lock
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|dirType
operator|=
name|dirType
expr_stmt|;
name|this
operator|.
name|useLock
operator|=
name|useLock
expr_stmt|;
block|}
comment|/**      * Get root directory of this storage      */
DECL|method|getRoot ()
specifier|public
name|File
name|getRoot
parameter_list|()
block|{
return|return
name|root
return|;
block|}
comment|/**      * Get storage directory type      */
DECL|method|getStorageDirType ()
specifier|public
name|StorageDirType
name|getStorageDirType
parameter_list|()
block|{
return|return
name|dirType
return|;
block|}
DECL|method|read (File from, Storage storage)
specifier|public
name|void
name|read
parameter_list|(
name|File
name|from
parameter_list|,
name|Storage
name|storage
parameter_list|)
throws|throws
name|IOException
block|{
name|Properties
name|props
init|=
name|readPropertiesFile
argument_list|(
name|from
argument_list|)
decl_stmt|;
name|storage
operator|.
name|setFieldsFromProperties
argument_list|(
name|props
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
comment|/**      * Clear and re-create storage directory.      *<p>      * Removes contents of the current directory and creates an empty directory.      *       * This does not fully format storage directory.       * It cannot write the version file since it should be written last after        * all other storage type dependent files are written.      * Derived storage is responsible for setting specific storage values and      * writing the version file to disk.      *       * @throws IOException      */
DECL|method|clearDirectory ()
specifier|public
name|void
name|clearDirectory
parameter_list|()
throws|throws
name|IOException
block|{
name|File
name|curDir
init|=
name|this
operator|.
name|getCurrentDir
argument_list|()
decl_stmt|;
if|if
condition|(
name|curDir
operator|.
name|exists
argument_list|()
condition|)
if|if
condition|(
operator|!
operator|(
name|FileUtil
operator|.
name|fullyDelete
argument_list|(
name|curDir
argument_list|)
operator|)
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Cannot remove current directory: "
operator|+
name|curDir
argument_list|)
throw|;
if|if
condition|(
operator|!
name|curDir
operator|.
name|mkdirs
argument_list|()
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Cannot create directory "
operator|+
name|curDir
argument_list|)
throw|;
block|}
comment|/**      * Directory {@code current} contains latest files defining      * the file system meta-data.      *       * @return the directory path      */
DECL|method|getCurrentDir ()
specifier|public
name|File
name|getCurrentDir
parameter_list|()
block|{
return|return
operator|new
name|File
argument_list|(
name|root
argument_list|,
name|STORAGE_DIR_CURRENT
argument_list|)
return|;
block|}
comment|/**      * File {@code VERSION} contains the following fields:      *<ol>      *<li>node type</li>      *<li>layout version</li>      *<li>namespaceID</li>      *<li>fs state creation time</li>      *<li>other fields specific for this node type</li>      *</ol>      * The version file is always written last during storage directory updates.      * The existence of the version file indicates that all other files have      * been successfully written in the storage directory, the storage is valid      * and does not need to be recovered.      *       * @return the version file path      */
DECL|method|getVersionFile ()
specifier|public
name|File
name|getVersionFile
parameter_list|()
block|{
return|return
operator|new
name|File
argument_list|(
operator|new
name|File
argument_list|(
name|root
argument_list|,
name|STORAGE_DIR_CURRENT
argument_list|)
argument_list|,
name|STORAGE_FILE_VERSION
argument_list|)
return|;
block|}
comment|/**      * File {@code VERSION} from the {@code previous} directory.      *       * @return the previous version file path      */
DECL|method|getPreviousVersionFile ()
specifier|public
name|File
name|getPreviousVersionFile
parameter_list|()
block|{
return|return
operator|new
name|File
argument_list|(
operator|new
name|File
argument_list|(
name|root
argument_list|,
name|STORAGE_DIR_PREVIOUS
argument_list|)
argument_list|,
name|STORAGE_FILE_VERSION
argument_list|)
return|;
block|}
comment|/**      * Directory {@code previous} contains the previous file system state,      * which the system can be rolled back to.      *       * @return the directory path      */
DECL|method|getPreviousDir ()
specifier|public
name|File
name|getPreviousDir
parameter_list|()
block|{
return|return
operator|new
name|File
argument_list|(
name|root
argument_list|,
name|STORAGE_DIR_PREVIOUS
argument_list|)
return|;
block|}
comment|/**      * {@code previous.tmp} is a transient directory, which holds      * current file system state while the new state is saved into the new      * {@code current} during upgrade.      * If the saving succeeds {@code previous.tmp} will be moved to      * {@code previous}, otherwise it will be renamed back to       * {@code current} by the recovery procedure during startup.      *       * @return the directory path      */
DECL|method|getPreviousTmp ()
specifier|public
name|File
name|getPreviousTmp
parameter_list|()
block|{
return|return
operator|new
name|File
argument_list|(
name|root
argument_list|,
name|STORAGE_TMP_PREVIOUS
argument_list|)
return|;
block|}
comment|/**      * {@code removed.tmp} is a transient directory, which holds      * current file system state while the previous state is moved into      * {@code current} during rollback.      * If the moving succeeds {@code removed.tmp} will be removed,      * otherwise it will be renamed back to       * {@code current} by the recovery procedure during startup.      *       * @return the directory path      */
DECL|method|getRemovedTmp ()
specifier|public
name|File
name|getRemovedTmp
parameter_list|()
block|{
return|return
operator|new
name|File
argument_list|(
name|root
argument_list|,
name|STORAGE_TMP_REMOVED
argument_list|)
return|;
block|}
comment|/**      * {@code finalized.tmp} is a transient directory, which holds      * the {@code previous} file system state while it is being removed      * in response to the finalize request.      * Finalize operation will remove {@code finalized.tmp} when completed,      * otherwise the removal will resume upon the system startup.      *       * @return the directory path      */
DECL|method|getFinalizedTmp ()
specifier|public
name|File
name|getFinalizedTmp
parameter_list|()
block|{
return|return
operator|new
name|File
argument_list|(
name|root
argument_list|,
name|STORAGE_TMP_FINALIZED
argument_list|)
return|;
block|}
comment|/**      * {@code lastcheckpoint.tmp} is a transient directory, which holds      * current file system state while the new state is saved into the new      * {@code current} during regular namespace updates.      * If the saving succeeds {@code lastcheckpoint.tmp} will be moved to      * {@code previous.checkpoint}, otherwise it will be renamed back to       * {@code current} by the recovery procedure during startup.      *       * @return the directory path      */
DECL|method|getLastCheckpointTmp ()
specifier|public
name|File
name|getLastCheckpointTmp
parameter_list|()
block|{
return|return
operator|new
name|File
argument_list|(
name|root
argument_list|,
name|STORAGE_TMP_LAST_CKPT
argument_list|)
return|;
block|}
comment|/**      * {@code previous.checkpoint} is a directory, which holds the previous      * (before the last save) state of the storage directory.      * The directory is created as a reference only, it does not play role      * in state recovery procedures, and is recycled automatically,       * but it may be useful for manual recovery of a stale state of the system.      *       * @return the directory path      */
DECL|method|getPreviousCheckpoint ()
specifier|public
name|File
name|getPreviousCheckpoint
parameter_list|()
block|{
return|return
operator|new
name|File
argument_list|(
name|root
argument_list|,
name|STORAGE_PREVIOUS_CKPT
argument_list|)
return|;
block|}
comment|/**      * Check consistency of the storage directory      *       * @param startOpt a startup option.      *        * @return state {@link StorageState} of the storage directory       * @throws InconsistentFSStateException if directory state is not       * consistent and cannot be recovered.      * @throws IOException      */
DECL|method|analyzeStorage (StartupOption startOpt, Storage storage)
specifier|public
name|StorageState
name|analyzeStorage
parameter_list|(
name|StartupOption
name|startOpt
parameter_list|,
name|Storage
name|storage
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|root
operator|!=
literal|null
operator|:
literal|"root is null"
assert|;
name|String
name|rootPath
init|=
name|root
operator|.
name|getCanonicalPath
argument_list|()
decl_stmt|;
try|try
block|{
comment|// check that storage exists
if|if
condition|(
operator|!
name|root
operator|.
name|exists
argument_list|()
condition|)
block|{
comment|// storage directory does not exist
if|if
condition|(
name|startOpt
operator|!=
name|StartupOption
operator|.
name|FORMAT
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Storage directory "
operator|+
name|rootPath
operator|+
literal|" does not exist."
argument_list|)
expr_stmt|;
return|return
name|StorageState
operator|.
name|NON_EXISTENT
return|;
block|}
name|LOG
operator|.
name|info
argument_list|(
name|rootPath
operator|+
literal|" does not exist. Creating ..."
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|root
operator|.
name|mkdirs
argument_list|()
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Cannot create directory "
operator|+
name|rootPath
argument_list|)
throw|;
block|}
comment|// or is inaccessible
if|if
condition|(
operator|!
name|root
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
name|rootPath
operator|+
literal|"is not a directory."
argument_list|)
expr_stmt|;
return|return
name|StorageState
operator|.
name|NON_EXISTENT
return|;
block|}
if|if
condition|(
operator|!
name|root
operator|.
name|canWrite
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Cannot access storage directory "
operator|+
name|rootPath
argument_list|)
expr_stmt|;
return|return
name|StorageState
operator|.
name|NON_EXISTENT
return|;
block|}
block|}
catch|catch
parameter_list|(
name|SecurityException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Cannot access storage directory "
operator|+
name|rootPath
argument_list|,
name|ex
argument_list|)
expr_stmt|;
return|return
name|StorageState
operator|.
name|NON_EXISTENT
return|;
block|}
name|this
operator|.
name|lock
argument_list|()
expr_stmt|;
comment|// lock storage if it exists
if|if
condition|(
name|startOpt
operator|==
name|HdfsServerConstants
operator|.
name|StartupOption
operator|.
name|FORMAT
condition|)
return|return
name|StorageState
operator|.
name|NOT_FORMATTED
return|;
if|if
condition|(
name|startOpt
operator|!=
name|HdfsServerConstants
operator|.
name|StartupOption
operator|.
name|IMPORT
condition|)
block|{
name|storage
operator|.
name|checkOldLayoutStorage
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
comment|// check whether current directory is valid
name|File
name|versionFile
init|=
name|getVersionFile
argument_list|()
decl_stmt|;
name|boolean
name|hasCurrent
init|=
name|versionFile
operator|.
name|exists
argument_list|()
decl_stmt|;
comment|// check which directories exist
name|boolean
name|hasPrevious
init|=
name|getPreviousDir
argument_list|()
operator|.
name|exists
argument_list|()
decl_stmt|;
name|boolean
name|hasPreviousTmp
init|=
name|getPreviousTmp
argument_list|()
operator|.
name|exists
argument_list|()
decl_stmt|;
name|boolean
name|hasRemovedTmp
init|=
name|getRemovedTmp
argument_list|()
operator|.
name|exists
argument_list|()
decl_stmt|;
name|boolean
name|hasFinalizedTmp
init|=
name|getFinalizedTmp
argument_list|()
operator|.
name|exists
argument_list|()
decl_stmt|;
name|boolean
name|hasCheckpointTmp
init|=
name|getLastCheckpointTmp
argument_list|()
operator|.
name|exists
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|hasPreviousTmp
operator|||
name|hasRemovedTmp
operator|||
name|hasFinalizedTmp
operator|||
name|hasCheckpointTmp
operator|)
condition|)
block|{
comment|// no temp dirs - no recovery
if|if
condition|(
name|hasCurrent
condition|)
return|return
name|StorageState
operator|.
name|NORMAL
return|;
if|if
condition|(
name|hasPrevious
condition|)
throw|throw
operator|new
name|InconsistentFSStateException
argument_list|(
name|root
argument_list|,
literal|"version file in current directory is missing."
argument_list|)
throw|;
return|return
name|StorageState
operator|.
name|NOT_FORMATTED
return|;
block|}
if|if
condition|(
operator|(
name|hasPreviousTmp
condition|?
literal|1
else|:
literal|0
operator|)
operator|+
operator|(
name|hasRemovedTmp
condition|?
literal|1
else|:
literal|0
operator|)
operator|+
operator|(
name|hasFinalizedTmp
condition|?
literal|1
else|:
literal|0
operator|)
operator|+
operator|(
name|hasCheckpointTmp
condition|?
literal|1
else|:
literal|0
operator|)
operator|>
literal|1
condition|)
comment|// more than one temp dirs
throw|throw
operator|new
name|InconsistentFSStateException
argument_list|(
name|root
argument_list|,
literal|"too many temporary directories."
argument_list|)
throw|;
comment|// # of temp dirs == 1 should either recover or complete a transition
if|if
condition|(
name|hasCheckpointTmp
condition|)
block|{
return|return
name|hasCurrent
condition|?
name|StorageState
operator|.
name|COMPLETE_CHECKPOINT
else|:
name|StorageState
operator|.
name|RECOVER_CHECKPOINT
return|;
block|}
if|if
condition|(
name|hasFinalizedTmp
condition|)
block|{
if|if
condition|(
name|hasPrevious
condition|)
throw|throw
operator|new
name|InconsistentFSStateException
argument_list|(
name|root
argument_list|,
name|STORAGE_DIR_PREVIOUS
operator|+
literal|" and "
operator|+
name|STORAGE_TMP_FINALIZED
operator|+
literal|"cannot exist together."
argument_list|)
throw|;
return|return
name|StorageState
operator|.
name|COMPLETE_FINALIZE
return|;
block|}
if|if
condition|(
name|hasPreviousTmp
condition|)
block|{
if|if
condition|(
name|hasPrevious
condition|)
throw|throw
operator|new
name|InconsistentFSStateException
argument_list|(
name|root
argument_list|,
name|STORAGE_DIR_PREVIOUS
operator|+
literal|" and "
operator|+
name|STORAGE_TMP_PREVIOUS
operator|+
literal|" cannot exist together."
argument_list|)
throw|;
if|if
condition|(
name|hasCurrent
condition|)
return|return
name|StorageState
operator|.
name|COMPLETE_UPGRADE
return|;
return|return
name|StorageState
operator|.
name|RECOVER_UPGRADE
return|;
block|}
assert|assert
name|hasRemovedTmp
operator|:
literal|"hasRemovedTmp must be true"
assert|;
if|if
condition|(
operator|!
operator|(
name|hasCurrent
operator|^
name|hasPrevious
operator|)
condition|)
throw|throw
operator|new
name|InconsistentFSStateException
argument_list|(
name|root
argument_list|,
literal|"one and only one directory "
operator|+
name|STORAGE_DIR_CURRENT
operator|+
literal|" or "
operator|+
name|STORAGE_DIR_PREVIOUS
operator|+
literal|" must be present when "
operator|+
name|STORAGE_TMP_REMOVED
operator|+
literal|" exists."
argument_list|)
throw|;
if|if
condition|(
name|hasCurrent
condition|)
return|return
name|StorageState
operator|.
name|COMPLETE_ROLLBACK
return|;
return|return
name|StorageState
operator|.
name|RECOVER_ROLLBACK
return|;
block|}
comment|/**      * Complete or recover storage state from previously failed transition.      *       * @param curState specifies what/how the state should be recovered      * @throws IOException      */
DECL|method|doRecover (StorageState curState)
specifier|public
name|void
name|doRecover
parameter_list|(
name|StorageState
name|curState
parameter_list|)
throws|throws
name|IOException
block|{
name|File
name|curDir
init|=
name|getCurrentDir
argument_list|()
decl_stmt|;
name|String
name|rootPath
init|=
name|root
operator|.
name|getCanonicalPath
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|curState
condition|)
block|{
case|case
name|COMPLETE_UPGRADE
case|:
comment|// mv previous.tmp -> previous
name|LOG
operator|.
name|info
argument_list|(
literal|"Completing previous upgrade for storage directory "
operator|+
name|rootPath
operator|+
literal|"."
argument_list|)
expr_stmt|;
name|rename
argument_list|(
name|getPreviousTmp
argument_list|()
argument_list|,
name|getPreviousDir
argument_list|()
argument_list|)
expr_stmt|;
return|return;
case|case
name|RECOVER_UPGRADE
case|:
comment|// mv previous.tmp -> current
name|LOG
operator|.
name|info
argument_list|(
literal|"Recovering storage directory "
operator|+
name|rootPath
operator|+
literal|" from previous upgrade."
argument_list|)
expr_stmt|;
if|if
condition|(
name|curDir
operator|.
name|exists
argument_list|()
condition|)
name|deleteDir
argument_list|(
name|curDir
argument_list|)
expr_stmt|;
name|rename
argument_list|(
name|getPreviousTmp
argument_list|()
argument_list|,
name|curDir
argument_list|)
expr_stmt|;
return|return;
case|case
name|COMPLETE_ROLLBACK
case|:
comment|// rm removed.tmp
name|LOG
operator|.
name|info
argument_list|(
literal|"Completing previous rollback for storage directory "
operator|+
name|rootPath
operator|+
literal|"."
argument_list|)
expr_stmt|;
name|deleteDir
argument_list|(
name|getRemovedTmp
argument_list|()
argument_list|)
expr_stmt|;
return|return;
case|case
name|RECOVER_ROLLBACK
case|:
comment|// mv removed.tmp -> current
name|LOG
operator|.
name|info
argument_list|(
literal|"Recovering storage directory "
operator|+
name|rootPath
operator|+
literal|" from previous rollback."
argument_list|)
expr_stmt|;
name|rename
argument_list|(
name|getRemovedTmp
argument_list|()
argument_list|,
name|curDir
argument_list|)
expr_stmt|;
return|return;
case|case
name|COMPLETE_FINALIZE
case|:
comment|// rm finalized.tmp
name|LOG
operator|.
name|info
argument_list|(
literal|"Completing previous finalize for storage directory "
operator|+
name|rootPath
operator|+
literal|"."
argument_list|)
expr_stmt|;
name|deleteDir
argument_list|(
name|getFinalizedTmp
argument_list|()
argument_list|)
expr_stmt|;
return|return;
case|case
name|COMPLETE_CHECKPOINT
case|:
comment|// mv lastcheckpoint.tmp -> previous.checkpoint
name|LOG
operator|.
name|info
argument_list|(
literal|"Completing previous checkpoint for storage directory "
operator|+
name|rootPath
operator|+
literal|"."
argument_list|)
expr_stmt|;
name|File
name|prevCkptDir
init|=
name|getPreviousCheckpoint
argument_list|()
decl_stmt|;
if|if
condition|(
name|prevCkptDir
operator|.
name|exists
argument_list|()
condition|)
name|deleteDir
argument_list|(
name|prevCkptDir
argument_list|)
expr_stmt|;
name|rename
argument_list|(
name|getLastCheckpointTmp
argument_list|()
argument_list|,
name|prevCkptDir
argument_list|)
expr_stmt|;
return|return;
case|case
name|RECOVER_CHECKPOINT
case|:
comment|// mv lastcheckpoint.tmp -> current
name|LOG
operator|.
name|info
argument_list|(
literal|"Recovering storage directory "
operator|+
name|rootPath
operator|+
literal|" from failed checkpoint."
argument_list|)
expr_stmt|;
if|if
condition|(
name|curDir
operator|.
name|exists
argument_list|()
condition|)
name|deleteDir
argument_list|(
name|curDir
argument_list|)
expr_stmt|;
name|rename
argument_list|(
name|getLastCheckpointTmp
argument_list|()
argument_list|,
name|curDir
argument_list|)
expr_stmt|;
return|return;
default|default:
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unexpected FS state: "
operator|+
name|curState
argument_list|)
throw|;
block|}
block|}
comment|/**      * Lock storage to provide exclusive access.      *       *<p> Locking is not supported by all file systems.      * E.g., NFS does not consistently support exclusive locks.      *       *<p> If locking is supported we guarantee exclusive access to the      * storage directory. Otherwise, no guarantee is given.      *       * @throws IOException if locking fails      */
DECL|method|lock ()
specifier|public
name|void
name|lock
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|useLock
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Locking is disabled"
argument_list|)
expr_stmt|;
return|return;
block|}
name|FileLock
name|newLock
init|=
name|tryLock
argument_list|()
decl_stmt|;
if|if
condition|(
name|newLock
operator|==
literal|null
condition|)
block|{
name|String
name|msg
init|=
literal|"Cannot lock storage "
operator|+
name|this
operator|.
name|root
operator|+
literal|". The directory is already locked."
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|msg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
name|msg
argument_list|)
throw|;
block|}
comment|// Don't overwrite lock until success - this way if we accidentally
comment|// call lock twice, the internal state won't be cleared by the second
comment|// (failed) lock attempt
name|lock
operator|=
name|newLock
expr_stmt|;
block|}
comment|/**      * Attempts to acquire an exclusive lock on the storage.      *       * @return A lock object representing the newly-acquired lock or      *<code>null</code> if storage is already locked.      * @throws IOException if locking fails.      */
DECL|method|tryLock ()
name|FileLock
name|tryLock
parameter_list|()
throws|throws
name|IOException
block|{
name|boolean
name|deletionHookAdded
init|=
literal|false
decl_stmt|;
name|File
name|lockF
init|=
operator|new
name|File
argument_list|(
name|root
argument_list|,
name|STORAGE_FILE_LOCK
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|lockF
operator|.
name|exists
argument_list|()
condition|)
block|{
name|lockF
operator|.
name|deleteOnExit
argument_list|()
expr_stmt|;
name|deletionHookAdded
operator|=
literal|true
expr_stmt|;
block|}
name|RandomAccessFile
name|file
init|=
operator|new
name|RandomAccessFile
argument_list|(
name|lockF
argument_list|,
literal|"rws"
argument_list|)
decl_stmt|;
name|String
name|jvmName
init|=
name|ManagementFactory
operator|.
name|getRuntimeMXBean
argument_list|()
operator|.
name|getName
argument_list|()
decl_stmt|;
name|FileLock
name|res
init|=
literal|null
decl_stmt|;
try|try
block|{
name|res
operator|=
name|file
operator|.
name|getChannel
argument_list|()
operator|.
name|tryLock
argument_list|()
expr_stmt|;
name|file
operator|.
name|write
argument_list|(
name|jvmName
operator|.
name|getBytes
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Lock on "
operator|+
name|lockF
operator|+
literal|" acquired by nodename "
operator|+
name|jvmName
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|OverlappingFileLockException
name|oe
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"It appears that another namenode "
operator|+
name|file
operator|.
name|readLine
argument_list|()
operator|+
literal|" has already locked the storage directory"
argument_list|)
expr_stmt|;
name|file
operator|.
name|close
argument_list|()
expr_stmt|;
return|return
literal|null
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Failed to acquire lock on "
operator|+
name|lockF
operator|+
literal|". If this storage directory is mounted via NFS, "
operator|+
literal|"ensure that the appropriate nfs lock services are running."
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|file
operator|.
name|close
argument_list|()
expr_stmt|;
throw|throw
name|e
throw|;
block|}
if|if
condition|(
name|res
operator|!=
literal|null
operator|&&
operator|!
name|deletionHookAdded
condition|)
block|{
comment|// If the file existed prior to our startup, we didn't
comment|// call deleteOnExit above. But since we successfully locked
comment|// the dir, we can take care of cleaning it up.
name|lockF
operator|.
name|deleteOnExit
argument_list|()
expr_stmt|;
block|}
return|return
name|res
return|;
block|}
comment|/**      * Unlock storage.      *       * @throws IOException      */
DECL|method|unlock ()
specifier|public
name|void
name|unlock
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|this
operator|.
name|lock
operator|==
literal|null
condition|)
return|return;
name|this
operator|.
name|lock
operator|.
name|release
argument_list|()
expr_stmt|;
name|lock
operator|.
name|channel
argument_list|()
operator|.
name|close
argument_list|()
expr_stmt|;
name|lock
operator|=
literal|null
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"Storage Directory "
operator|+
name|this
operator|.
name|root
return|;
block|}
comment|/**      * Check whether underlying file system supports file locking.      *       * @return<code>true</code> if exclusive locks are supported or      *<code>false</code> otherwise.      * @throws IOException      * @see StorageDirectory#lock()      */
DECL|method|isLockSupported ()
specifier|public
name|boolean
name|isLockSupported
parameter_list|()
throws|throws
name|IOException
block|{
name|FileLock
name|firstLock
init|=
literal|null
decl_stmt|;
name|FileLock
name|secondLock
init|=
literal|null
decl_stmt|;
try|try
block|{
name|firstLock
operator|=
name|lock
expr_stmt|;
if|if
condition|(
name|firstLock
operator|==
literal|null
condition|)
block|{
name|firstLock
operator|=
name|tryLock
argument_list|()
expr_stmt|;
if|if
condition|(
name|firstLock
operator|==
literal|null
condition|)
return|return
literal|true
return|;
block|}
name|secondLock
operator|=
name|tryLock
argument_list|()
expr_stmt|;
if|if
condition|(
name|secondLock
operator|==
literal|null
condition|)
return|return
literal|true
return|;
block|}
finally|finally
block|{
if|if
condition|(
name|firstLock
operator|!=
literal|null
operator|&&
name|firstLock
operator|!=
name|lock
condition|)
block|{
name|firstLock
operator|.
name|release
argument_list|()
expr_stmt|;
name|firstLock
operator|.
name|channel
argument_list|()
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|secondLock
operator|!=
literal|null
condition|)
block|{
name|secondLock
operator|.
name|release
argument_list|()
expr_stmt|;
name|secondLock
operator|.
name|channel
argument_list|()
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
return|return
literal|false
return|;
block|}
block|}
comment|/**    * Create empty storage info of the specified type    */
DECL|method|Storage (NodeType type)
specifier|protected
name|Storage
parameter_list|(
name|NodeType
name|type
parameter_list|)
block|{
name|super
argument_list|()
expr_stmt|;
name|this
operator|.
name|storageType
operator|=
name|type
expr_stmt|;
block|}
DECL|method|Storage (NodeType type, StorageInfo storageInfo)
specifier|protected
name|Storage
parameter_list|(
name|NodeType
name|type
parameter_list|,
name|StorageInfo
name|storageInfo
parameter_list|)
block|{
name|super
argument_list|(
name|storageInfo
argument_list|)
expr_stmt|;
name|this
operator|.
name|storageType
operator|=
name|type
expr_stmt|;
block|}
DECL|method|getNumStorageDirs ()
specifier|public
name|int
name|getNumStorageDirs
parameter_list|()
block|{
return|return
name|storageDirs
operator|.
name|size
argument_list|()
return|;
block|}
DECL|method|getStorageDir (int idx)
specifier|public
name|StorageDirectory
name|getStorageDir
parameter_list|(
name|int
name|idx
parameter_list|)
block|{
return|return
name|storageDirs
operator|.
name|get
argument_list|(
name|idx
argument_list|)
return|;
block|}
DECL|method|addStorageDir (StorageDirectory sd)
specifier|protected
name|void
name|addStorageDir
parameter_list|(
name|StorageDirectory
name|sd
parameter_list|)
block|{
name|storageDirs
operator|.
name|add
argument_list|(
name|sd
argument_list|)
expr_stmt|;
block|}
comment|/**    * Return true if the layout of the given storage directory is from a version    * of Hadoop prior to the introduction of the "current" and "previous"    * directories which allow upgrade and rollback.    */
DECL|method|isPreUpgradableLayout (StorageDirectory sd)
specifier|public
specifier|abstract
name|boolean
name|isPreUpgradableLayout
parameter_list|(
name|StorageDirectory
name|sd
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/**    * Check if the given storage directory comes from a version of Hadoop    * prior to when the directory layout changed (ie 0.13). If this is    * the case, this method throws an IOException.    */
DECL|method|checkOldLayoutStorage (StorageDirectory sd)
specifier|private
name|void
name|checkOldLayoutStorage
parameter_list|(
name|StorageDirectory
name|sd
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|isPreUpgradableLayout
argument_list|(
name|sd
argument_list|)
condition|)
block|{
name|checkVersionUpgradable
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Checks if the upgrade from the given old version is supported. If    * no upgrade is supported, it throws IncorrectVersionException.    *     * @param oldVersion    */
DECL|method|checkVersionUpgradable (int oldVersion)
specifier|public
specifier|static
name|void
name|checkVersionUpgradable
parameter_list|(
name|int
name|oldVersion
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|oldVersion
operator|>
name|LAST_UPGRADABLE_LAYOUT_VERSION
condition|)
block|{
name|String
name|msg
init|=
literal|"*********** Upgrade is not supported from this "
operator|+
literal|" older version "
operator|+
name|oldVersion
operator|+
literal|" of storage to the current version."
operator|+
literal|" Please upgrade to "
operator|+
name|LAST_UPGRADABLE_HADOOP_VERSION
operator|+
literal|" or a later version and then upgrade to current"
operator|+
literal|" version. Old layout version is "
operator|+
operator|(
name|oldVersion
operator|==
literal|0
condition|?
literal|"'too old'"
else|:
operator|(
literal|""
operator|+
name|oldVersion
operator|)
operator|)
operator|+
literal|" and latest layout version this software version can"
operator|+
literal|" upgrade from is "
operator|+
name|LAST_UPGRADABLE_LAYOUT_VERSION
operator|+
literal|". ************"
decl_stmt|;
name|LOG
operator|.
name|error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
name|msg
argument_list|)
throw|;
block|}
block|}
comment|/**    * Get common storage fields.    * Should be overloaded if additional fields need to be get.    *     * @param props    * @throws IOException    */
DECL|method|setFieldsFromProperties ( Properties props, StorageDirectory sd)
specifier|protected
name|void
name|setFieldsFromProperties
parameter_list|(
name|Properties
name|props
parameter_list|,
name|StorageDirectory
name|sd
parameter_list|)
throws|throws
name|IOException
block|{
name|setLayoutVersion
argument_list|(
name|props
argument_list|,
name|sd
argument_list|)
expr_stmt|;
name|setNamespaceID
argument_list|(
name|props
argument_list|,
name|sd
argument_list|)
expr_stmt|;
name|setStorageType
argument_list|(
name|props
argument_list|,
name|sd
argument_list|)
expr_stmt|;
name|setcTime
argument_list|(
name|props
argument_list|,
name|sd
argument_list|)
expr_stmt|;
name|setClusterId
argument_list|(
name|props
argument_list|,
name|layoutVersion
argument_list|,
name|sd
argument_list|)
expr_stmt|;
block|}
comment|/**    * Set common storage fields into the given properties object.    * Should be overloaded if additional fields need to be set.    *     * @param props the Properties object to write into    */
DECL|method|setPropertiesFromFields (Properties props, StorageDirectory sd)
specifier|protected
name|void
name|setPropertiesFromFields
parameter_list|(
name|Properties
name|props
parameter_list|,
name|StorageDirectory
name|sd
parameter_list|)
throws|throws
name|IOException
block|{
name|props
operator|.
name|setProperty
argument_list|(
literal|"layoutVersion"
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
name|layoutVersion
argument_list|)
argument_list|)
expr_stmt|;
name|props
operator|.
name|setProperty
argument_list|(
literal|"storageType"
argument_list|,
name|storageType
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|props
operator|.
name|setProperty
argument_list|(
literal|"namespaceID"
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
name|namespaceID
argument_list|)
argument_list|)
expr_stmt|;
comment|// Set clusterID in version with federation support
if|if
condition|(
name|LayoutVersion
operator|.
name|supports
argument_list|(
name|Feature
operator|.
name|FEDERATION
argument_list|,
name|layoutVersion
argument_list|)
condition|)
block|{
name|props
operator|.
name|setProperty
argument_list|(
literal|"clusterID"
argument_list|,
name|clusterID
argument_list|)
expr_stmt|;
block|}
name|props
operator|.
name|setProperty
argument_list|(
literal|"cTime"
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
name|cTime
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Read properties from the VERSION file in the given storage directory.    */
DECL|method|readProperties (StorageDirectory sd)
specifier|public
name|void
name|readProperties
parameter_list|(
name|StorageDirectory
name|sd
parameter_list|)
throws|throws
name|IOException
block|{
name|Properties
name|props
init|=
name|readPropertiesFile
argument_list|(
name|sd
operator|.
name|getVersionFile
argument_list|()
argument_list|)
decl_stmt|;
name|setFieldsFromProperties
argument_list|(
name|props
argument_list|,
name|sd
argument_list|)
expr_stmt|;
block|}
comment|/**    * Read properties from the the previous/VERSION file in the given storage directory.    */
DECL|method|readPreviousVersionProperties (StorageDirectory sd)
specifier|public
name|void
name|readPreviousVersionProperties
parameter_list|(
name|StorageDirectory
name|sd
parameter_list|)
throws|throws
name|IOException
block|{
name|Properties
name|props
init|=
name|readPropertiesFile
argument_list|(
name|sd
operator|.
name|getPreviousVersionFile
argument_list|()
argument_list|)
decl_stmt|;
name|setFieldsFromProperties
argument_list|(
name|props
argument_list|,
name|sd
argument_list|)
expr_stmt|;
block|}
comment|/**    * Write properties to the VERSION file in the given storage directory.    */
DECL|method|writeProperties (StorageDirectory sd)
specifier|public
name|void
name|writeProperties
parameter_list|(
name|StorageDirectory
name|sd
parameter_list|)
throws|throws
name|IOException
block|{
name|writeProperties
argument_list|(
name|sd
operator|.
name|getVersionFile
argument_list|()
argument_list|,
name|sd
argument_list|)
expr_stmt|;
block|}
DECL|method|writeProperties (File to, StorageDirectory sd)
specifier|public
name|void
name|writeProperties
parameter_list|(
name|File
name|to
parameter_list|,
name|StorageDirectory
name|sd
parameter_list|)
throws|throws
name|IOException
block|{
name|Properties
name|props
init|=
operator|new
name|Properties
argument_list|()
decl_stmt|;
name|setPropertiesFromFields
argument_list|(
name|props
argument_list|,
name|sd
argument_list|)
expr_stmt|;
name|RandomAccessFile
name|file
init|=
operator|new
name|RandomAccessFile
argument_list|(
name|to
argument_list|,
literal|"rws"
argument_list|)
decl_stmt|;
name|FileOutputStream
name|out
init|=
literal|null
decl_stmt|;
try|try
block|{
name|file
operator|.
name|seek
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|out
operator|=
operator|new
name|FileOutputStream
argument_list|(
name|file
operator|.
name|getFD
argument_list|()
argument_list|)
expr_stmt|;
comment|/*        * If server is interrupted before this line,         * the version file will remain unchanged.        */
name|props
operator|.
name|store
argument_list|(
name|out
argument_list|,
literal|null
argument_list|)
expr_stmt|;
comment|/*        * Now the new fields are flushed to the head of the file, but file         * length can still be larger then required and therefore the file can         * contain whole or corrupted fields from its old contents in the end.        * If server is interrupted here and restarted later these extra fields        * either should not effect server behavior or should be handled        * by the server correctly.        */
name|file
operator|.
name|setLength
argument_list|(
name|out
operator|.
name|getChannel
argument_list|()
operator|.
name|position
argument_list|()
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|out
operator|!=
literal|null
condition|)
block|{
name|out
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
name|file
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|readPropertiesFile (File from)
specifier|public
specifier|static
name|Properties
name|readPropertiesFile
parameter_list|(
name|File
name|from
parameter_list|)
throws|throws
name|IOException
block|{
name|RandomAccessFile
name|file
init|=
operator|new
name|RandomAccessFile
argument_list|(
name|from
argument_list|,
literal|"rws"
argument_list|)
decl_stmt|;
name|FileInputStream
name|in
init|=
literal|null
decl_stmt|;
name|Properties
name|props
init|=
operator|new
name|Properties
argument_list|()
decl_stmt|;
try|try
block|{
name|in
operator|=
operator|new
name|FileInputStream
argument_list|(
name|file
operator|.
name|getFD
argument_list|()
argument_list|)
expr_stmt|;
name|file
operator|.
name|seek
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|props
operator|.
name|load
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|in
operator|!=
literal|null
condition|)
block|{
name|in
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
name|file
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
return|return
name|props
return|;
block|}
DECL|method|rename (File from, File to)
specifier|public
specifier|static
name|void
name|rename
parameter_list|(
name|File
name|from
parameter_list|,
name|File
name|to
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|from
operator|.
name|renameTo
argument_list|(
name|to
argument_list|)
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Failed to rename "
operator|+
name|from
operator|.
name|getCanonicalPath
argument_list|()
operator|+
literal|" to "
operator|+
name|to
operator|.
name|getCanonicalPath
argument_list|()
argument_list|)
throw|;
block|}
comment|/**    * Recursively delete all the content of the directory first and then     * the directory itself from the local filesystem.    * @param dir The directory to delete    * @throws IOException    */
DECL|method|deleteDir (File dir)
specifier|public
specifier|static
name|void
name|deleteDir
parameter_list|(
name|File
name|dir
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|FileUtil
operator|.
name|fullyDelete
argument_list|(
name|dir
argument_list|)
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Failed to delete "
operator|+
name|dir
operator|.
name|getCanonicalPath
argument_list|()
argument_list|)
throw|;
block|}
comment|/**    * Write all data storage files.    * @throws IOException    */
DECL|method|writeAll ()
specifier|public
name|void
name|writeAll
parameter_list|()
throws|throws
name|IOException
block|{
name|this
operator|.
name|layoutVersion
operator|=
name|HdfsConstants
operator|.
name|LAYOUT_VERSION
expr_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|StorageDirectory
argument_list|>
name|it
init|=
name|storageDirs
operator|.
name|iterator
argument_list|()
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|writeProperties
argument_list|(
name|it
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Unlock all storage directories.    * @throws IOException    */
DECL|method|unlockAll ()
specifier|public
name|void
name|unlockAll
parameter_list|()
throws|throws
name|IOException
block|{
for|for
control|(
name|Iterator
argument_list|<
name|StorageDirectory
argument_list|>
name|it
init|=
name|storageDirs
operator|.
name|iterator
argument_list|()
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|it
operator|.
name|next
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|getBuildVersion ()
specifier|public
specifier|static
name|String
name|getBuildVersion
parameter_list|()
block|{
return|return
name|VersionInfo
operator|.
name|getRevision
argument_list|()
return|;
block|}
DECL|method|getRegistrationID (StorageInfo storage)
specifier|public
specifier|static
name|String
name|getRegistrationID
parameter_list|(
name|StorageInfo
name|storage
parameter_list|)
block|{
return|return
literal|"NS-"
operator|+
name|Integer
operator|.
name|toString
argument_list|(
name|storage
operator|.
name|getNamespaceID
argument_list|()
argument_list|)
operator|+
literal|"-"
operator|+
name|storage
operator|.
name|getClusterID
argument_list|()
operator|+
literal|"-"
operator|+
name|Integer
operator|.
name|toString
argument_list|(
name|storage
operator|.
name|getLayoutVersion
argument_list|()
argument_list|)
operator|+
literal|"-"
operator|+
name|Long
operator|.
name|toString
argument_list|(
name|storage
operator|.
name|getCTime
argument_list|()
argument_list|)
return|;
block|}
DECL|method|getProperty (Properties props, StorageDirectory sd, String name)
name|String
name|getProperty
parameter_list|(
name|Properties
name|props
parameter_list|,
name|StorageDirectory
name|sd
parameter_list|,
name|String
name|name
parameter_list|)
throws|throws
name|InconsistentFSStateException
block|{
name|String
name|property
init|=
name|props
operator|.
name|getProperty
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|property
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|InconsistentFSStateException
argument_list|(
name|sd
operator|.
name|root
argument_list|,
literal|"file "
operator|+
name|STORAGE_FILE_VERSION
operator|+
literal|" has "
operator|+
name|name
operator|+
literal|" missing."
argument_list|)
throw|;
block|}
return|return
name|property
return|;
block|}
comment|/** Validate and set storage type from {@link Properties}*/
DECL|method|setStorageType (Properties props, StorageDirectory sd)
specifier|protected
name|void
name|setStorageType
parameter_list|(
name|Properties
name|props
parameter_list|,
name|StorageDirectory
name|sd
parameter_list|)
throws|throws
name|InconsistentFSStateException
block|{
name|NodeType
name|type
init|=
name|NodeType
operator|.
name|valueOf
argument_list|(
name|getProperty
argument_list|(
name|props
argument_list|,
name|sd
argument_list|,
literal|"storageType"
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|storageType
operator|.
name|equals
argument_list|(
name|type
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|InconsistentFSStateException
argument_list|(
name|sd
operator|.
name|root
argument_list|,
literal|"node type is incompatible with others."
argument_list|)
throw|;
block|}
name|storageType
operator|=
name|type
expr_stmt|;
block|}
comment|/** Validate and set ctime from {@link Properties}*/
DECL|method|setcTime (Properties props, StorageDirectory sd)
specifier|protected
name|void
name|setcTime
parameter_list|(
name|Properties
name|props
parameter_list|,
name|StorageDirectory
name|sd
parameter_list|)
throws|throws
name|InconsistentFSStateException
block|{
name|cTime
operator|=
name|Long
operator|.
name|parseLong
argument_list|(
name|getProperty
argument_list|(
name|props
argument_list|,
name|sd
argument_list|,
literal|"cTime"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** Validate and set clusterId from {@link Properties}*/
DECL|method|setClusterId (Properties props, int layoutVersion, StorageDirectory sd)
specifier|protected
name|void
name|setClusterId
parameter_list|(
name|Properties
name|props
parameter_list|,
name|int
name|layoutVersion
parameter_list|,
name|StorageDirectory
name|sd
parameter_list|)
throws|throws
name|InconsistentFSStateException
block|{
comment|// Set cluster ID in version that supports federation
if|if
condition|(
name|LayoutVersion
operator|.
name|supports
argument_list|(
name|Feature
operator|.
name|FEDERATION
argument_list|,
name|layoutVersion
argument_list|)
condition|)
block|{
name|String
name|cid
init|=
name|getProperty
argument_list|(
name|props
argument_list|,
name|sd
argument_list|,
literal|"clusterID"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|clusterID
operator|.
name|equals
argument_list|(
literal|""
argument_list|)
operator|||
name|cid
operator|.
name|equals
argument_list|(
literal|""
argument_list|)
operator|||
name|clusterID
operator|.
name|equals
argument_list|(
name|cid
argument_list|)
operator|)
condition|)
block|{
throw|throw
operator|new
name|InconsistentFSStateException
argument_list|(
name|sd
operator|.
name|getRoot
argument_list|()
argument_list|,
literal|"cluster Id is incompatible with others."
argument_list|)
throw|;
block|}
name|clusterID
operator|=
name|cid
expr_stmt|;
block|}
block|}
comment|/** Validate and set layout version from {@link Properties}*/
DECL|method|setLayoutVersion (Properties props, StorageDirectory sd)
specifier|protected
name|void
name|setLayoutVersion
parameter_list|(
name|Properties
name|props
parameter_list|,
name|StorageDirectory
name|sd
parameter_list|)
throws|throws
name|IncorrectVersionException
throws|,
name|InconsistentFSStateException
block|{
name|int
name|lv
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|getProperty
argument_list|(
name|props
argument_list|,
name|sd
argument_list|,
literal|"layoutVersion"
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|lv
operator|<
name|HdfsConstants
operator|.
name|LAYOUT_VERSION
condition|)
block|{
comment|// future version
throw|throw
operator|new
name|IncorrectVersionException
argument_list|(
name|lv
argument_list|,
literal|"storage directory "
operator|+
name|sd
operator|.
name|root
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
throw|;
block|}
name|layoutVersion
operator|=
name|lv
expr_stmt|;
block|}
comment|/** Validate and set namespaceID version from {@link Properties}*/
DECL|method|setNamespaceID (Properties props, StorageDirectory sd)
specifier|protected
name|void
name|setNamespaceID
parameter_list|(
name|Properties
name|props
parameter_list|,
name|StorageDirectory
name|sd
parameter_list|)
throws|throws
name|InconsistentFSStateException
block|{
name|int
name|nsId
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|getProperty
argument_list|(
name|props
argument_list|,
name|sd
argument_list|,
literal|"namespaceID"
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|namespaceID
operator|!=
literal|0
operator|&&
name|nsId
operator|!=
literal|0
operator|&&
name|namespaceID
operator|!=
name|nsId
condition|)
block|{
throw|throw
operator|new
name|InconsistentFSStateException
argument_list|(
name|sd
operator|.
name|root
argument_list|,
literal|"namespaceID is incompatible with others."
argument_list|)
throw|;
block|}
name|namespaceID
operator|=
name|nsId
expr_stmt|;
block|}
DECL|method|is203LayoutVersion (int layoutVersion)
specifier|public
specifier|static
name|boolean
name|is203LayoutVersion
parameter_list|(
name|int
name|layoutVersion
parameter_list|)
block|{
for|for
control|(
name|int
name|lv203
range|:
name|LAYOUT_VERSIONS_203
control|)
block|{
if|if
condition|(
name|lv203
operator|==
name|layoutVersion
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
block|}
end_class

end_unit

