begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdfs.util
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|util
package|;
end_package

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|StorageType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSClient
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSStripedOutputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|DatanodeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|ExtendedBlock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|LocatedBlock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|LocatedStripedBlock
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|erasurecode
operator|.
name|ECSchema
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|erasurecode
operator|.
name|rawcoder
operator|.
name|RawErasureDecoder
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|ByteBuffer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|CancellationException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|CompletionService
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutionException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Future
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_comment
comment|/**  * When accessing a file in striped layout, operations on logical byte ranges  * in the file need to be mapped to physical byte ranges on block files stored  * on DataNodes. This utility class facilities this mapping by defining and  * exposing a number of striping-related concepts. The most basic ones are  * illustrated in the following diagram. Unless otherwise specified, all  * range-related calculations are inclusive (the end offset of the previous  * range should be 1 byte lower than the start offset of the next one).  *  *  |<----  Block Group ----> |<- Block Group: logical unit composing  *  |                          |        striped HDFS files.  *  blk_0      blk_1       blk_2<- Internal Blocks: each internal block  *    |          |           |          represents a physically stored local  *    v          v           v          block file  * +------+   +------+   +------+  * |cell_0|   |cell_1|   |cell_2|<- {@link StripingCell} represents the  * +------+   +------+   +------+       logical order that a Block Group should  * |cell_3|   |cell_4|   |cell_5|       be accessed: cell_0, cell_1, ...  * +------+   +------+   +------+  * |cell_6|   |cell_7|   |cell_8|  * +------+   +------+   +------+  * |cell_9|  * +------+<- A cell contains cellSize bytes of data  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
DECL|class|StripedBlockUtil
specifier|public
class|class
name|StripedBlockUtil
block|{
comment|/**    * This method parses a striped block group into individual blocks.    *    * @param bg The striped block group    * @param cellSize The size of a striping cell    * @param dataBlkNum The number of data blocks    * @return An array containing the blocks in the group    */
DECL|method|parseStripedBlockGroup (LocatedStripedBlock bg, int cellSize, int dataBlkNum, int parityBlkNum)
specifier|public
specifier|static
name|LocatedBlock
index|[]
name|parseStripedBlockGroup
parameter_list|(
name|LocatedStripedBlock
name|bg
parameter_list|,
name|int
name|cellSize
parameter_list|,
name|int
name|dataBlkNum
parameter_list|,
name|int
name|parityBlkNum
parameter_list|)
block|{
name|int
name|locatedBGSize
init|=
name|bg
operator|.
name|getBlockIndices
argument_list|()
operator|.
name|length
decl_stmt|;
name|LocatedBlock
index|[]
name|lbs
init|=
operator|new
name|LocatedBlock
index|[
name|dataBlkNum
operator|+
name|parityBlkNum
index|]
decl_stmt|;
for|for
control|(
name|short
name|i
init|=
literal|0
init|;
name|i
operator|<
name|locatedBGSize
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|int
name|idx
init|=
name|bg
operator|.
name|getBlockIndices
argument_list|()
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|idx
operator|<
operator|(
name|dataBlkNum
operator|+
name|parityBlkNum
operator|)
operator|&&
name|lbs
index|[
name|idx
index|]
operator|==
literal|null
condition|)
block|{
name|lbs
index|[
name|idx
index|]
operator|=
name|constructInternalBlock
argument_list|(
name|bg
argument_list|,
name|i
argument_list|,
name|cellSize
argument_list|,
name|dataBlkNum
argument_list|,
name|idx
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|lbs
return|;
block|}
comment|/**    * This method creates an internal block at the given index of a block group    *    * @param idxInReturnedLocs The index in the stored locations in the    *                          {@link LocatedStripedBlock} object    * @param idxInBlockGroup The logical index in the striped block group    * @return The constructed internal block    */
DECL|method|constructInternalBlock (LocatedStripedBlock bg, int idxInReturnedLocs, int cellSize, int dataBlkNum, int idxInBlockGroup)
specifier|public
specifier|static
name|LocatedBlock
name|constructInternalBlock
parameter_list|(
name|LocatedStripedBlock
name|bg
parameter_list|,
name|int
name|idxInReturnedLocs
parameter_list|,
name|int
name|cellSize
parameter_list|,
name|int
name|dataBlkNum
parameter_list|,
name|int
name|idxInBlockGroup
parameter_list|)
block|{
specifier|final
name|ExtendedBlock
name|blk
init|=
name|constructInternalBlock
argument_list|(
name|bg
operator|.
name|getBlock
argument_list|()
argument_list|,
name|cellSize
argument_list|,
name|dataBlkNum
argument_list|,
name|idxInBlockGroup
argument_list|)
decl_stmt|;
if|if
condition|(
name|idxInReturnedLocs
operator|<
name|bg
operator|.
name|getLocations
argument_list|()
operator|.
name|length
condition|)
block|{
return|return
operator|new
name|LocatedBlock
argument_list|(
name|blk
argument_list|,
operator|new
name|DatanodeInfo
index|[]
block|{
name|bg
operator|.
name|getLocations
argument_list|()
index|[
name|idxInReturnedLocs
index|]
block|}
argument_list|,
operator|new
name|String
index|[]
block|{
name|bg
operator|.
name|getStorageIDs
argument_list|()
index|[
name|idxInReturnedLocs
index|]
block|}
argument_list|,
operator|new
name|StorageType
index|[]
block|{
name|bg
operator|.
name|getStorageTypes
argument_list|()
index|[
name|idxInReturnedLocs
index|]
block|}
argument_list|,
name|bg
operator|.
name|getStartOffset
argument_list|()
argument_list|,
name|bg
operator|.
name|isCorrupt
argument_list|()
argument_list|,
literal|null
argument_list|)
return|;
block|}
else|else
block|{
return|return
operator|new
name|LocatedBlock
argument_list|(
name|blk
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|bg
operator|.
name|getStartOffset
argument_list|()
argument_list|,
name|bg
operator|.
name|isCorrupt
argument_list|()
argument_list|,
literal|null
argument_list|)
return|;
block|}
block|}
comment|/**    * This method creates an internal {@link ExtendedBlock} at the given index    * of a block group.    */
DECL|method|constructInternalBlock (ExtendedBlock blockGroup, int cellSize, int dataBlkNum, int idxInBlockGroup)
specifier|public
specifier|static
name|ExtendedBlock
name|constructInternalBlock
parameter_list|(
name|ExtendedBlock
name|blockGroup
parameter_list|,
name|int
name|cellSize
parameter_list|,
name|int
name|dataBlkNum
parameter_list|,
name|int
name|idxInBlockGroup
parameter_list|)
block|{
name|ExtendedBlock
name|block
init|=
operator|new
name|ExtendedBlock
argument_list|(
name|blockGroup
argument_list|)
decl_stmt|;
name|block
operator|.
name|setBlockId
argument_list|(
name|blockGroup
operator|.
name|getBlockId
argument_list|()
operator|+
name|idxInBlockGroup
argument_list|)
expr_stmt|;
name|block
operator|.
name|setNumBytes
argument_list|(
name|getInternalBlockLength
argument_list|(
name|blockGroup
operator|.
name|getNumBytes
argument_list|()
argument_list|,
name|cellSize
argument_list|,
name|dataBlkNum
argument_list|,
name|idxInBlockGroup
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|block
return|;
block|}
comment|/**    * Get the size of an internal block at the given index of a block group    *    * @param dataSize Size of the block group only counting data blocks    * @param cellSize The size of a striping cell    * @param numDataBlocks The number of data blocks    * @param i The logical index in the striped block group    * @return The size of the internal block at the specified index    */
DECL|method|getInternalBlockLength (long dataSize, int cellSize, int numDataBlocks, int i)
specifier|public
specifier|static
name|long
name|getInternalBlockLength
parameter_list|(
name|long
name|dataSize
parameter_list|,
name|int
name|cellSize
parameter_list|,
name|int
name|numDataBlocks
parameter_list|,
name|int
name|i
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|dataSize
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|cellSize
operator|>
literal|0
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|numDataBlocks
operator|>
literal|0
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|i
operator|>=
literal|0
argument_list|)
expr_stmt|;
comment|// Size of each stripe (only counting data blocks)
specifier|final
name|int
name|stripeSize
init|=
name|cellSize
operator|*
name|numDataBlocks
decl_stmt|;
comment|// If block group ends at stripe boundary, each internal block has an equal
comment|// share of the group
specifier|final
name|int
name|lastStripeDataLen
init|=
call|(
name|int
call|)
argument_list|(
name|dataSize
operator|%
name|stripeSize
argument_list|)
decl_stmt|;
if|if
condition|(
name|lastStripeDataLen
operator|==
literal|0
condition|)
block|{
return|return
name|dataSize
operator|/
name|numDataBlocks
return|;
block|}
specifier|final
name|int
name|numStripes
init|=
call|(
name|int
call|)
argument_list|(
operator|(
name|dataSize
operator|-
literal|1
operator|)
operator|/
name|stripeSize
operator|+
literal|1
argument_list|)
decl_stmt|;
return|return
operator|(
name|numStripes
operator|-
literal|1L
operator|)
operator|*
name|cellSize
operator|+
name|lastCellSize
argument_list|(
name|lastStripeDataLen
argument_list|,
name|cellSize
argument_list|,
name|numDataBlocks
argument_list|,
name|i
argument_list|)
return|;
block|}
DECL|method|lastCellSize (int size, int cellSize, int numDataBlocks, int i)
specifier|private
specifier|static
name|int
name|lastCellSize
parameter_list|(
name|int
name|size
parameter_list|,
name|int
name|cellSize
parameter_list|,
name|int
name|numDataBlocks
parameter_list|,
name|int
name|i
parameter_list|)
block|{
if|if
condition|(
name|i
operator|<
name|numDataBlocks
condition|)
block|{
comment|// parity block size (i.e. i>= numDataBlocks) is the same as
comment|// the first data block size (i.e. i = 0).
name|size
operator|-=
name|i
operator|*
name|cellSize
expr_stmt|;
if|if
condition|(
name|size
operator|<
literal|0
condition|)
block|{
name|size
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return
name|size
operator|>
name|cellSize
condition|?
name|cellSize
else|:
name|size
return|;
block|}
comment|/**    * Given a byte's offset in an internal block, calculate the offset in    * the block group    */
DECL|method|offsetInBlkToOffsetInBG (int cellSize, int dataBlkNum, long offsetInBlk, int idxInBlockGroup)
specifier|public
specifier|static
name|long
name|offsetInBlkToOffsetInBG
parameter_list|(
name|int
name|cellSize
parameter_list|,
name|int
name|dataBlkNum
parameter_list|,
name|long
name|offsetInBlk
parameter_list|,
name|int
name|idxInBlockGroup
parameter_list|)
block|{
name|int
name|cellIdxInBlk
init|=
call|(
name|int
call|)
argument_list|(
name|offsetInBlk
operator|/
name|cellSize
argument_list|)
decl_stmt|;
return|return
name|cellIdxInBlk
operator|*
name|cellSize
operator|*
name|dataBlkNum
comment|// n full stripes before offset
operator|+
name|idxInBlockGroup
operator|*
name|cellSize
comment|// m full cells before offset
operator|+
name|offsetInBlk
operator|%
name|cellSize
return|;
comment|// partial cell
block|}
comment|/**    * Get the next completed striped read task    *    * @return {@link StripingChunkReadResult} indicating the status of the read task    *          succeeded, and the block index of the task. If the method times    *          out without getting any completed read tasks, -1 is returned as    *          block index.    * @throws InterruptedException    */
DECL|method|getNextCompletedStripedRead ( CompletionService<Void> readService, Map<Future<Void>, Integer> futures, final long threshold)
specifier|public
specifier|static
name|StripingChunkReadResult
name|getNextCompletedStripedRead
parameter_list|(
name|CompletionService
argument_list|<
name|Void
argument_list|>
name|readService
parameter_list|,
name|Map
argument_list|<
name|Future
argument_list|<
name|Void
argument_list|>
argument_list|,
name|Integer
argument_list|>
name|futures
parameter_list|,
specifier|final
name|long
name|threshold
parameter_list|)
throws|throws
name|InterruptedException
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
operator|!
name|futures
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
name|Future
argument_list|<
name|Void
argument_list|>
name|future
init|=
literal|null
decl_stmt|;
try|try
block|{
if|if
condition|(
name|threshold
operator|>
literal|0
condition|)
block|{
name|future
operator|=
name|readService
operator|.
name|poll
argument_list|(
name|threshold
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|future
operator|=
name|readService
operator|.
name|take
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|future
operator|!=
literal|null
condition|)
block|{
name|future
operator|.
name|get
argument_list|()
expr_stmt|;
return|return
operator|new
name|StripingChunkReadResult
argument_list|(
name|futures
operator|.
name|remove
argument_list|(
name|future
argument_list|)
argument_list|,
name|StripingChunkReadResult
operator|.
name|SUCCESSFUL
argument_list|)
return|;
block|}
else|else
block|{
return|return
operator|new
name|StripingChunkReadResult
argument_list|(
name|StripingChunkReadResult
operator|.
name|TIMEOUT
argument_list|)
return|;
block|}
block|}
catch|catch
parameter_list|(
name|ExecutionException
name|e
parameter_list|)
block|{
name|DFSClient
operator|.
name|LOG
operator|.
name|warn
argument_list|(
literal|"ExecutionException "
operator|+
name|e
argument_list|)
expr_stmt|;
return|return
operator|new
name|StripingChunkReadResult
argument_list|(
name|futures
operator|.
name|remove
argument_list|(
name|future
argument_list|)
argument_list|,
name|StripingChunkReadResult
operator|.
name|FAILED
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|CancellationException
name|e
parameter_list|)
block|{
return|return
operator|new
name|StripingChunkReadResult
argument_list|(
name|futures
operator|.
name|remove
argument_list|(
name|future
argument_list|)
argument_list|,
name|StripingChunkReadResult
operator|.
name|CANCELLED
argument_list|)
return|;
block|}
block|}
comment|/**    * Get the total usage of the striped blocks, which is the total of data    * blocks and parity blocks    *    * @param numDataBlkBytes    *          Size of the block group only counting data blocks    * @param dataBlkNum    *          The number of data blocks    * @param parityBlkNum    *          The number of parity blocks    * @param cellSize    *          The size of a striping cell    * @return The total usage of data blocks and parity blocks    */
DECL|method|spaceConsumedByStripedBlock (long numDataBlkBytes, int dataBlkNum, int parityBlkNum, int cellSize)
specifier|public
specifier|static
name|long
name|spaceConsumedByStripedBlock
parameter_list|(
name|long
name|numDataBlkBytes
parameter_list|,
name|int
name|dataBlkNum
parameter_list|,
name|int
name|parityBlkNum
parameter_list|,
name|int
name|cellSize
parameter_list|)
block|{
name|int
name|parityIndex
init|=
name|dataBlkNum
operator|+
literal|1
decl_stmt|;
name|long
name|numParityBlkBytes
init|=
name|getInternalBlockLength
argument_list|(
name|numDataBlkBytes
argument_list|,
name|cellSize
argument_list|,
name|dataBlkNum
argument_list|,
name|parityIndex
argument_list|)
operator|*
name|parityBlkNum
decl_stmt|;
return|return
name|numDataBlkBytes
operator|+
name|numParityBlkBytes
return|;
block|}
comment|/**    * Initialize the decoding input buffers based on the chunk states in an    * {@link AlignedStripe}. For each chunk that was not initially requested,    * schedule a new fetch request with the decoding input buffer as transfer    * destination.    */
DECL|method|initDecodeInputs (AlignedStripe alignedStripe, int dataBlkNum, int parityBlkNum)
specifier|public
specifier|static
name|byte
index|[]
index|[]
name|initDecodeInputs
parameter_list|(
name|AlignedStripe
name|alignedStripe
parameter_list|,
name|int
name|dataBlkNum
parameter_list|,
name|int
name|parityBlkNum
parameter_list|)
block|{
name|byte
index|[]
index|[]
name|decodeInputs
init|=
operator|new
name|byte
index|[
name|dataBlkNum
operator|+
name|parityBlkNum
index|]
index|[
operator|(
name|int
operator|)
name|alignedStripe
operator|.
name|getSpanInBlock
argument_list|()
index|]
decl_stmt|;
comment|// read the full data aligned stripe
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|dataBlkNum
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|alignedStripe
operator|.
name|chunks
index|[
name|i
index|]
operator|==
literal|null
condition|)
block|{
specifier|final
name|int
name|decodeIndex
init|=
name|convertIndex4Decode
argument_list|(
name|i
argument_list|,
name|dataBlkNum
argument_list|,
name|parityBlkNum
argument_list|)
decl_stmt|;
name|alignedStripe
operator|.
name|chunks
index|[
name|i
index|]
operator|=
operator|new
name|StripingChunk
argument_list|(
name|decodeInputs
index|[
name|decodeIndex
index|]
argument_list|)
expr_stmt|;
name|alignedStripe
operator|.
name|chunks
index|[
name|i
index|]
operator|.
name|addByteArraySlice
argument_list|(
literal|0
argument_list|,
operator|(
name|int
operator|)
name|alignedStripe
operator|.
name|getSpanInBlock
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|decodeInputs
return|;
block|}
comment|/**    * Some fetched {@link StripingChunk} might be stored in original application    * buffer instead of prepared decode input buffers. Some others are beyond    * the range of the internal blocks and should correspond to all zero bytes.    * When all pending requests have returned, this method should be called to    * finalize decode input buffers.    */
DECL|method|finalizeDecodeInputs (final byte[][] decodeInputs, int dataBlkNum, int parityBlkNum, AlignedStripe alignedStripe)
specifier|public
specifier|static
name|void
name|finalizeDecodeInputs
parameter_list|(
specifier|final
name|byte
index|[]
index|[]
name|decodeInputs
parameter_list|,
name|int
name|dataBlkNum
parameter_list|,
name|int
name|parityBlkNum
parameter_list|,
name|AlignedStripe
name|alignedStripe
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|alignedStripe
operator|.
name|chunks
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|StripingChunk
name|chunk
init|=
name|alignedStripe
operator|.
name|chunks
index|[
name|i
index|]
decl_stmt|;
specifier|final
name|int
name|decodeIndex
init|=
name|convertIndex4Decode
argument_list|(
name|i
argument_list|,
name|dataBlkNum
argument_list|,
name|parityBlkNum
argument_list|)
decl_stmt|;
if|if
condition|(
name|chunk
operator|!=
literal|null
operator|&&
name|chunk
operator|.
name|state
operator|==
name|StripingChunk
operator|.
name|FETCHED
condition|)
block|{
name|chunk
operator|.
name|copyTo
argument_list|(
name|decodeInputs
index|[
name|decodeIndex
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|chunk
operator|!=
literal|null
operator|&&
name|chunk
operator|.
name|state
operator|==
name|StripingChunk
operator|.
name|ALLZERO
condition|)
block|{
name|Arrays
operator|.
name|fill
argument_list|(
name|decodeInputs
index|[
name|decodeIndex
index|]
argument_list|,
operator|(
name|byte
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|decodeInputs
index|[
name|decodeIndex
index|]
operator|=
literal|null
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Currently decoding requires parity chunks are before data chunks.    * The indices are opposite to what we store in NN. In future we may    * improve the decoding to make the indices order the same as in NN.    *    * @param index The index to convert    * @param dataBlkNum The number of data blocks    * @param parityBlkNum The number of parity blocks    * @return converted index    */
DECL|method|convertIndex4Decode (int index, int dataBlkNum, int parityBlkNum)
specifier|public
specifier|static
name|int
name|convertIndex4Decode
parameter_list|(
name|int
name|index
parameter_list|,
name|int
name|dataBlkNum
parameter_list|,
name|int
name|parityBlkNum
parameter_list|)
block|{
return|return
name|index
operator|<
name|dataBlkNum
condition|?
name|index
operator|+
name|parityBlkNum
else|:
name|index
operator|-
name|dataBlkNum
return|;
block|}
DECL|method|convertDecodeIndexBack (int index, int dataBlkNum, int parityBlkNum)
specifier|public
specifier|static
name|int
name|convertDecodeIndexBack
parameter_list|(
name|int
name|index
parameter_list|,
name|int
name|dataBlkNum
parameter_list|,
name|int
name|parityBlkNum
parameter_list|)
block|{
return|return
name|index
operator|<
name|parityBlkNum
condition|?
name|index
operator|+
name|dataBlkNum
else|:
name|index
operator|-
name|parityBlkNum
return|;
block|}
comment|/**    * Decode based on the given input buffers and schema.    */
DECL|method|decodeAndFillBuffer (final byte[][] decodeInputs, AlignedStripe alignedStripe, int dataBlkNum, int parityBlkNum, RawErasureDecoder decoder)
specifier|public
specifier|static
name|void
name|decodeAndFillBuffer
parameter_list|(
specifier|final
name|byte
index|[]
index|[]
name|decodeInputs
parameter_list|,
name|AlignedStripe
name|alignedStripe
parameter_list|,
name|int
name|dataBlkNum
parameter_list|,
name|int
name|parityBlkNum
parameter_list|,
name|RawErasureDecoder
name|decoder
parameter_list|)
block|{
comment|// Step 1: prepare indices and output buffers for missing data units
name|int
index|[]
name|decodeIndices
init|=
operator|new
name|int
index|[
name|parityBlkNum
index|]
decl_stmt|;
name|int
name|pos
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|alignedStripe
operator|.
name|chunks
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|alignedStripe
operator|.
name|chunks
index|[
name|i
index|]
operator|!=
literal|null
operator|&&
name|alignedStripe
operator|.
name|chunks
index|[
name|i
index|]
operator|.
name|state
operator|==
name|StripingChunk
operator|.
name|MISSING
condition|)
block|{
name|decodeIndices
index|[
name|pos
operator|++
index|]
operator|=
name|convertIndex4Decode
argument_list|(
name|i
argument_list|,
name|dataBlkNum
argument_list|,
name|parityBlkNum
argument_list|)
expr_stmt|;
block|}
block|}
name|decodeIndices
operator|=
name|Arrays
operator|.
name|copyOf
argument_list|(
name|decodeIndices
argument_list|,
name|pos
argument_list|)
expr_stmt|;
name|byte
index|[]
index|[]
name|decodeOutputs
init|=
operator|new
name|byte
index|[
name|decodeIndices
operator|.
name|length
index|]
index|[
operator|(
name|int
operator|)
name|alignedStripe
operator|.
name|getSpanInBlock
argument_list|()
index|]
decl_stmt|;
comment|// Step 2: decode into prepared output buffers
name|decoder
operator|.
name|decode
argument_list|(
name|decodeInputs
argument_list|,
name|decodeIndices
argument_list|,
name|decodeOutputs
argument_list|)
expr_stmt|;
comment|// Step 3: fill original application buffer with decoded data
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|decodeIndices
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|int
name|missingBlkIdx
init|=
name|convertDecodeIndexBack
argument_list|(
name|decodeIndices
index|[
name|i
index|]
argument_list|,
name|dataBlkNum
argument_list|,
name|parityBlkNum
argument_list|)
decl_stmt|;
name|StripingChunk
name|chunk
init|=
name|alignedStripe
operator|.
name|chunks
index|[
name|missingBlkIdx
index|]
decl_stmt|;
if|if
condition|(
name|chunk
operator|.
name|state
operator|==
name|StripingChunk
operator|.
name|MISSING
condition|)
block|{
name|chunk
operator|.
name|copyFrom
argument_list|(
name|decodeOutputs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Similar functionality with {@link #divideByteRangeIntoStripes}, but is used    * by stateful read and uses ByteBuffer as reading target buffer. Besides the    * read range is within a single stripe thus the calculation logic is simpler.    */
DECL|method|divideOneStripe (ECSchema ecSchema, int cellSize, LocatedStripedBlock blockGroup, long rangeStartInBlockGroup, long rangeEndInBlockGroup, ByteBuffer buf)
specifier|public
specifier|static
name|AlignedStripe
index|[]
name|divideOneStripe
parameter_list|(
name|ECSchema
name|ecSchema
parameter_list|,
name|int
name|cellSize
parameter_list|,
name|LocatedStripedBlock
name|blockGroup
parameter_list|,
name|long
name|rangeStartInBlockGroup
parameter_list|,
name|long
name|rangeEndInBlockGroup
parameter_list|,
name|ByteBuffer
name|buf
parameter_list|)
block|{
specifier|final
name|int
name|dataBlkNum
init|=
name|ecSchema
operator|.
name|getNumDataUnits
argument_list|()
decl_stmt|;
comment|// Step 1: map the byte range to StripingCells
name|StripingCell
index|[]
name|cells
init|=
name|getStripingCellsOfByteRange
argument_list|(
name|ecSchema
argument_list|,
name|cellSize
argument_list|,
name|blockGroup
argument_list|,
name|rangeStartInBlockGroup
argument_list|,
name|rangeEndInBlockGroup
argument_list|)
decl_stmt|;
comment|// Step 2: get the unmerged ranges on each internal block
name|VerticalRange
index|[]
name|ranges
init|=
name|getRangesForInternalBlocks
argument_list|(
name|ecSchema
argument_list|,
name|cellSize
argument_list|,
name|cells
argument_list|)
decl_stmt|;
comment|// Step 3: merge into stripes
name|AlignedStripe
index|[]
name|stripes
init|=
name|mergeRangesForInternalBlocks
argument_list|(
name|ecSchema
argument_list|,
name|ranges
argument_list|)
decl_stmt|;
comment|// Step 4: calculate each chunk's position in destination buffer. Since the
comment|// whole read range is within a single stripe, the logic is simpler here.
name|int
name|bufOffset
init|=
call|(
name|int
call|)
argument_list|(
name|rangeStartInBlockGroup
operator|%
operator|(
name|cellSize
operator|*
name|dataBlkNum
operator|)
argument_list|)
decl_stmt|;
for|for
control|(
name|StripingCell
name|cell
range|:
name|cells
control|)
block|{
name|long
name|cellStart
init|=
name|cell
operator|.
name|idxInInternalBlk
operator|*
name|cellSize
operator|+
name|cell
operator|.
name|offset
decl_stmt|;
name|long
name|cellEnd
init|=
name|cellStart
operator|+
name|cell
operator|.
name|size
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|AlignedStripe
name|s
range|:
name|stripes
control|)
block|{
name|long
name|stripeEnd
init|=
name|s
operator|.
name|getOffsetInBlock
argument_list|()
operator|+
name|s
operator|.
name|getSpanInBlock
argument_list|()
operator|-
literal|1
decl_stmt|;
name|long
name|overlapStart
init|=
name|Math
operator|.
name|max
argument_list|(
name|cellStart
argument_list|,
name|s
operator|.
name|getOffsetInBlock
argument_list|()
argument_list|)
decl_stmt|;
name|long
name|overlapEnd
init|=
name|Math
operator|.
name|min
argument_list|(
name|cellEnd
argument_list|,
name|stripeEnd
argument_list|)
decl_stmt|;
name|int
name|overLapLen
init|=
call|(
name|int
call|)
argument_list|(
name|overlapEnd
operator|-
name|overlapStart
operator|+
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|overLapLen
operator|>
literal|0
condition|)
block|{
name|Preconditions
operator|.
name|checkState
argument_list|(
name|s
operator|.
name|chunks
index|[
name|cell
operator|.
name|idxInStripe
index|]
operator|==
literal|null
argument_list|)
expr_stmt|;
specifier|final
name|int
name|pos
init|=
call|(
name|int
call|)
argument_list|(
name|bufOffset
operator|+
name|overlapStart
operator|-
name|cellStart
argument_list|)
decl_stmt|;
name|buf
operator|.
name|position
argument_list|(
name|pos
argument_list|)
expr_stmt|;
name|buf
operator|.
name|limit
argument_list|(
name|pos
operator|+
name|overLapLen
argument_list|)
expr_stmt|;
name|s
operator|.
name|chunks
index|[
name|cell
operator|.
name|idxInStripe
index|]
operator|=
operator|new
name|StripingChunk
argument_list|(
name|buf
operator|.
name|slice
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|bufOffset
operator|+=
name|cell
operator|.
name|size
expr_stmt|;
block|}
comment|// Step 5: prepare ALLZERO blocks
name|prepareAllZeroChunks
argument_list|(
name|blockGroup
argument_list|,
name|stripes
argument_list|,
name|cellSize
argument_list|,
name|dataBlkNum
argument_list|)
expr_stmt|;
return|return
name|stripes
return|;
block|}
comment|/**    * This method divides a requested byte range into an array of inclusive    * {@link AlignedStripe}.    * @param ecSchema The codec schema for the file, which carries the numbers    *                 of data / parity blocks    * @param cellSize Cell size of stripe    * @param blockGroup The striped block group    * @param rangeStartInBlockGroup The byte range's start offset in block group    * @param rangeEndInBlockGroup The byte range's end offset in block group    * @param buf Destination buffer of the read operation for the byte range    * @param offsetInBuf Start offset into the destination buffer    *    * At most 5 stripes will be generated from each logical range, as    * demonstrated in the header of {@link AlignedStripe}.    */
DECL|method|divideByteRangeIntoStripes (ECSchema ecSchema, int cellSize, LocatedStripedBlock blockGroup, long rangeStartInBlockGroup, long rangeEndInBlockGroup, byte[] buf, int offsetInBuf)
specifier|public
specifier|static
name|AlignedStripe
index|[]
name|divideByteRangeIntoStripes
parameter_list|(
name|ECSchema
name|ecSchema
parameter_list|,
name|int
name|cellSize
parameter_list|,
name|LocatedStripedBlock
name|blockGroup
parameter_list|,
name|long
name|rangeStartInBlockGroup
parameter_list|,
name|long
name|rangeEndInBlockGroup
parameter_list|,
name|byte
index|[]
name|buf
parameter_list|,
name|int
name|offsetInBuf
parameter_list|)
block|{
comment|// Step 0: analyze range and calculate basic parameters
specifier|final
name|int
name|dataBlkNum
init|=
name|ecSchema
operator|.
name|getNumDataUnits
argument_list|()
decl_stmt|;
comment|// Step 1: map the byte range to StripingCells
name|StripingCell
index|[]
name|cells
init|=
name|getStripingCellsOfByteRange
argument_list|(
name|ecSchema
argument_list|,
name|cellSize
argument_list|,
name|blockGroup
argument_list|,
name|rangeStartInBlockGroup
argument_list|,
name|rangeEndInBlockGroup
argument_list|)
decl_stmt|;
comment|// Step 2: get the unmerged ranges on each internal block
name|VerticalRange
index|[]
name|ranges
init|=
name|getRangesForInternalBlocks
argument_list|(
name|ecSchema
argument_list|,
name|cellSize
argument_list|,
name|cells
argument_list|)
decl_stmt|;
comment|// Step 3: merge into at most 5 stripes
name|AlignedStripe
index|[]
name|stripes
init|=
name|mergeRangesForInternalBlocks
argument_list|(
name|ecSchema
argument_list|,
name|ranges
argument_list|)
decl_stmt|;
comment|// Step 4: calculate each chunk's position in destination buffer
name|calcualteChunkPositionsInBuf
argument_list|(
name|cellSize
argument_list|,
name|stripes
argument_list|,
name|cells
argument_list|,
name|buf
argument_list|,
name|offsetInBuf
argument_list|)
expr_stmt|;
comment|// Step 5: prepare ALLZERO blocks
name|prepareAllZeroChunks
argument_list|(
name|blockGroup
argument_list|,
name|stripes
argument_list|,
name|cellSize
argument_list|,
name|dataBlkNum
argument_list|)
expr_stmt|;
return|return
name|stripes
return|;
block|}
comment|/**    * Map the logical byte range to a set of inclusive {@link StripingCell}    * instances, each representing the overlap of the byte range to a cell    * used by {@link DFSStripedOutputStream} in encoding    */
annotation|@
name|VisibleForTesting
DECL|method|getStripingCellsOfByteRange (ECSchema ecSchema, int cellSize, LocatedStripedBlock blockGroup, long rangeStartInBlockGroup, long rangeEndInBlockGroup)
specifier|private
specifier|static
name|StripingCell
index|[]
name|getStripingCellsOfByteRange
parameter_list|(
name|ECSchema
name|ecSchema
parameter_list|,
name|int
name|cellSize
parameter_list|,
name|LocatedStripedBlock
name|blockGroup
parameter_list|,
name|long
name|rangeStartInBlockGroup
parameter_list|,
name|long
name|rangeEndInBlockGroup
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|rangeStartInBlockGroup
operator|<=
name|rangeEndInBlockGroup
operator|&&
name|rangeEndInBlockGroup
operator|<
name|blockGroup
operator|.
name|getBlockSize
argument_list|()
argument_list|)
expr_stmt|;
name|long
name|len
init|=
name|rangeEndInBlockGroup
operator|-
name|rangeStartInBlockGroup
operator|+
literal|1
decl_stmt|;
name|int
name|firstCellIdxInBG
init|=
call|(
name|int
call|)
argument_list|(
name|rangeStartInBlockGroup
operator|/
name|cellSize
argument_list|)
decl_stmt|;
name|int
name|lastCellIdxInBG
init|=
call|(
name|int
call|)
argument_list|(
name|rangeEndInBlockGroup
operator|/
name|cellSize
argument_list|)
decl_stmt|;
name|int
name|numCells
init|=
name|lastCellIdxInBG
operator|-
name|firstCellIdxInBG
operator|+
literal|1
decl_stmt|;
name|StripingCell
index|[]
name|cells
init|=
operator|new
name|StripingCell
index|[
name|numCells
index|]
decl_stmt|;
specifier|final
name|int
name|firstCellOffset
init|=
call|(
name|int
call|)
argument_list|(
name|rangeStartInBlockGroup
operator|%
name|cellSize
argument_list|)
decl_stmt|;
specifier|final
name|int
name|firstCellSize
init|=
operator|(
name|int
operator|)
name|Math
operator|.
name|min
argument_list|(
name|cellSize
operator|-
operator|(
name|rangeStartInBlockGroup
operator|%
name|cellSize
operator|)
argument_list|,
name|len
argument_list|)
decl_stmt|;
name|cells
index|[
literal|0
index|]
operator|=
operator|new
name|StripingCell
argument_list|(
name|ecSchema
argument_list|,
name|firstCellSize
argument_list|,
name|firstCellIdxInBG
argument_list|,
name|firstCellOffset
argument_list|)
expr_stmt|;
if|if
condition|(
name|lastCellIdxInBG
operator|!=
name|firstCellIdxInBG
condition|)
block|{
specifier|final
name|int
name|lastCellSize
init|=
call|(
name|int
call|)
argument_list|(
name|rangeEndInBlockGroup
operator|%
name|cellSize
argument_list|)
operator|+
literal|1
decl_stmt|;
name|cells
index|[
name|numCells
operator|-
literal|1
index|]
operator|=
operator|new
name|StripingCell
argument_list|(
name|ecSchema
argument_list|,
name|lastCellSize
argument_list|,
name|lastCellIdxInBG
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|numCells
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|cells
index|[
name|i
index|]
operator|=
operator|new
name|StripingCell
argument_list|(
name|ecSchema
argument_list|,
name|cellSize
argument_list|,
name|i
operator|+
name|firstCellIdxInBG
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|cells
return|;
block|}
comment|/**    * Given a logical start offset in a block group, calculate the physical    * start offset into each stored internal block.    */
DECL|method|getStartOffsetsForInternalBlocks (ECSchema ecSchema, int cellSize, LocatedStripedBlock blockGroup, long rangeStartInBlockGroup)
specifier|public
specifier|static
name|long
index|[]
name|getStartOffsetsForInternalBlocks
parameter_list|(
name|ECSchema
name|ecSchema
parameter_list|,
name|int
name|cellSize
parameter_list|,
name|LocatedStripedBlock
name|blockGroup
parameter_list|,
name|long
name|rangeStartInBlockGroup
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|rangeStartInBlockGroup
operator|<
name|blockGroup
operator|.
name|getBlockSize
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|dataBlkNum
init|=
name|ecSchema
operator|.
name|getNumDataUnits
argument_list|()
decl_stmt|;
name|int
name|parityBlkNum
init|=
name|ecSchema
operator|.
name|getNumParityUnits
argument_list|()
decl_stmt|;
name|long
index|[]
name|startOffsets
init|=
operator|new
name|long
index|[
name|dataBlkNum
operator|+
name|parityBlkNum
index|]
decl_stmt|;
name|Arrays
operator|.
name|fill
argument_list|(
name|startOffsets
argument_list|,
operator|-
literal|1L
argument_list|)
expr_stmt|;
name|int
name|firstCellIdxInBG
init|=
call|(
name|int
call|)
argument_list|(
name|rangeStartInBlockGroup
operator|/
name|cellSize
argument_list|)
decl_stmt|;
name|StripingCell
name|firstCell
init|=
operator|new
name|StripingCell
argument_list|(
name|ecSchema
argument_list|,
name|cellSize
argument_list|,
name|firstCellIdxInBG
argument_list|,
call|(
name|int
call|)
argument_list|(
name|rangeStartInBlockGroup
operator|%
name|cellSize
argument_list|)
argument_list|)
decl_stmt|;
name|startOffsets
index|[
name|firstCell
operator|.
name|idxInStripe
index|]
operator|=
name|firstCell
operator|.
name|idxInInternalBlk
operator|*
name|cellSize
operator|+
name|firstCell
operator|.
name|offset
expr_stmt|;
name|long
name|earliestStart
init|=
name|startOffsets
index|[
name|firstCell
operator|.
name|idxInStripe
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|dataBlkNum
condition|;
name|i
operator|++
control|)
block|{
name|int
name|idx
init|=
name|firstCellIdxInBG
operator|+
name|i
decl_stmt|;
if|if
condition|(
name|idx
operator|*
operator|(
name|long
operator|)
name|cellSize
operator|>=
name|blockGroup
operator|.
name|getBlockSize
argument_list|()
condition|)
block|{
break|break;
block|}
name|StripingCell
name|cell
init|=
operator|new
name|StripingCell
argument_list|(
name|ecSchema
argument_list|,
name|cellSize
argument_list|,
name|idx
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|startOffsets
index|[
name|cell
operator|.
name|idxInStripe
index|]
operator|=
name|cell
operator|.
name|idxInInternalBlk
operator|*
operator|(
name|long
operator|)
name|cellSize
expr_stmt|;
if|if
condition|(
name|startOffsets
index|[
name|cell
operator|.
name|idxInStripe
index|]
operator|<
name|earliestStart
condition|)
block|{
name|earliestStart
operator|=
name|startOffsets
index|[
name|cell
operator|.
name|idxInStripe
index|]
expr_stmt|;
block|}
block|}
for|for
control|(
name|int
name|i
init|=
name|dataBlkNum
init|;
name|i
operator|<
name|dataBlkNum
operator|+
name|parityBlkNum
condition|;
name|i
operator|++
control|)
block|{
name|startOffsets
index|[
name|i
index|]
operator|=
name|earliestStart
expr_stmt|;
block|}
return|return
name|startOffsets
return|;
block|}
comment|/**    * Given a logical byte range, mapped to each {@link StripingCell}, calculate    * the physical byte range (inclusive) on each stored internal block.    */
annotation|@
name|VisibleForTesting
DECL|method|getRangesForInternalBlocks (ECSchema ecSchema, int cellSize, StripingCell[] cells)
specifier|private
specifier|static
name|VerticalRange
index|[]
name|getRangesForInternalBlocks
parameter_list|(
name|ECSchema
name|ecSchema
parameter_list|,
name|int
name|cellSize
parameter_list|,
name|StripingCell
index|[]
name|cells
parameter_list|)
block|{
name|int
name|dataBlkNum
init|=
name|ecSchema
operator|.
name|getNumDataUnits
argument_list|()
decl_stmt|;
name|int
name|parityBlkNum
init|=
name|ecSchema
operator|.
name|getNumParityUnits
argument_list|()
decl_stmt|;
name|VerticalRange
name|ranges
index|[]
init|=
operator|new
name|VerticalRange
index|[
name|dataBlkNum
operator|+
name|parityBlkNum
index|]
decl_stmt|;
name|long
name|earliestStart
init|=
name|Long
operator|.
name|MAX_VALUE
decl_stmt|;
name|long
name|latestEnd
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|StripingCell
name|cell
range|:
name|cells
control|)
block|{
comment|// iterate through all cells and update the list of StripeRanges
if|if
condition|(
name|ranges
index|[
name|cell
operator|.
name|idxInStripe
index|]
operator|==
literal|null
condition|)
block|{
name|ranges
index|[
name|cell
operator|.
name|idxInStripe
index|]
operator|=
operator|new
name|VerticalRange
argument_list|(
name|cell
operator|.
name|idxInInternalBlk
operator|*
name|cellSize
operator|+
name|cell
operator|.
name|offset
argument_list|,
name|cell
operator|.
name|size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ranges
index|[
name|cell
operator|.
name|idxInStripe
index|]
operator|.
name|spanInBlock
operator|+=
name|cell
operator|.
name|size
expr_stmt|;
block|}
name|VerticalRange
name|range
init|=
name|ranges
index|[
name|cell
operator|.
name|idxInStripe
index|]
decl_stmt|;
if|if
condition|(
name|range
operator|.
name|offsetInBlock
operator|<
name|earliestStart
condition|)
block|{
name|earliestStart
operator|=
name|range
operator|.
name|offsetInBlock
expr_stmt|;
block|}
if|if
condition|(
name|range
operator|.
name|offsetInBlock
operator|+
name|range
operator|.
name|spanInBlock
operator|-
literal|1
operator|>
name|latestEnd
condition|)
block|{
name|latestEnd
operator|=
name|range
operator|.
name|offsetInBlock
operator|+
name|range
operator|.
name|spanInBlock
operator|-
literal|1
expr_stmt|;
block|}
block|}
comment|// Each parity block should be fetched at maximum range of all data blocks
for|for
control|(
name|int
name|i
init|=
name|dataBlkNum
init|;
name|i
operator|<
name|dataBlkNum
operator|+
name|parityBlkNum
condition|;
name|i
operator|++
control|)
block|{
name|ranges
index|[
name|i
index|]
operator|=
operator|new
name|VerticalRange
argument_list|(
name|earliestStart
argument_list|,
name|latestEnd
operator|-
name|earliestStart
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|ranges
return|;
block|}
comment|/**    * Merge byte ranges on each internal block into a set of inclusive    * {@link AlignedStripe} instances.    */
DECL|method|mergeRangesForInternalBlocks ( ECSchema ecSchema, VerticalRange[] ranges)
specifier|private
specifier|static
name|AlignedStripe
index|[]
name|mergeRangesForInternalBlocks
parameter_list|(
name|ECSchema
name|ecSchema
parameter_list|,
name|VerticalRange
index|[]
name|ranges
parameter_list|)
block|{
name|int
name|dataBlkNum
init|=
name|ecSchema
operator|.
name|getNumDataUnits
argument_list|()
decl_stmt|;
name|int
name|parityBlkNum
init|=
name|ecSchema
operator|.
name|getNumParityUnits
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|AlignedStripe
argument_list|>
name|stripes
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|SortedSet
argument_list|<
name|Long
argument_list|>
name|stripePoints
init|=
operator|new
name|TreeSet
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|VerticalRange
name|r
range|:
name|ranges
control|)
block|{
if|if
condition|(
name|r
operator|!=
literal|null
condition|)
block|{
name|stripePoints
operator|.
name|add
argument_list|(
name|r
operator|.
name|offsetInBlock
argument_list|)
expr_stmt|;
name|stripePoints
operator|.
name|add
argument_list|(
name|r
operator|.
name|offsetInBlock
operator|+
name|r
operator|.
name|spanInBlock
argument_list|)
expr_stmt|;
block|}
block|}
name|long
name|prev
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|long
name|point
range|:
name|stripePoints
control|)
block|{
if|if
condition|(
name|prev
operator|>=
literal|0
condition|)
block|{
name|stripes
operator|.
name|add
argument_list|(
operator|new
name|AlignedStripe
argument_list|(
name|prev
argument_list|,
name|point
operator|-
name|prev
argument_list|,
name|dataBlkNum
operator|+
name|parityBlkNum
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|prev
operator|=
name|point
expr_stmt|;
block|}
return|return
name|stripes
operator|.
name|toArray
argument_list|(
operator|new
name|AlignedStripe
index|[
name|stripes
operator|.
name|size
argument_list|()
index|]
argument_list|)
return|;
block|}
DECL|method|calcualteChunkPositionsInBuf (int cellSize, AlignedStripe[] stripes, StripingCell[] cells, byte[] buf, int offsetInBuf)
specifier|private
specifier|static
name|void
name|calcualteChunkPositionsInBuf
parameter_list|(
name|int
name|cellSize
parameter_list|,
name|AlignedStripe
index|[]
name|stripes
parameter_list|,
name|StripingCell
index|[]
name|cells
parameter_list|,
name|byte
index|[]
name|buf
parameter_list|,
name|int
name|offsetInBuf
parameter_list|)
block|{
comment|/**      *     |<--------------- AlignedStripe --------------->|      *      *     |<- length_0 ->|<--  length_1  -->|<- length_2 ->|      * +------------------+------------------+----------------+      * |    cell_0_0_0    |    cell_3_1_0    |   cell_6_2_0   |<- blk_0      * +------------------+------------------+----------------+      *   _/                \_______________________      *  |                                          |      *  v offset_0                                 v offset_1      * +----------------------------------------------------------+      * |  cell_0_0_0 |  cell_1_0_1 and cell_2_0_2  |cell_3_1_0 ...|<- buf      * |  (partial)  |    (from blk_1 and blk_2)   |              |      * +----------------------------------------------------------+      *      * Cell indexing convention defined in {@link StripingCell}      */
name|int
name|done
init|=
literal|0
decl_stmt|;
for|for
control|(
name|StripingCell
name|cell
range|:
name|cells
control|)
block|{
name|long
name|cellStart
init|=
name|cell
operator|.
name|idxInInternalBlk
operator|*
name|cellSize
operator|+
name|cell
operator|.
name|offset
decl_stmt|;
name|long
name|cellEnd
init|=
name|cellStart
operator|+
name|cell
operator|.
name|size
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|AlignedStripe
name|s
range|:
name|stripes
control|)
block|{
name|long
name|stripeEnd
init|=
name|s
operator|.
name|getOffsetInBlock
argument_list|()
operator|+
name|s
operator|.
name|getSpanInBlock
argument_list|()
operator|-
literal|1
decl_stmt|;
name|long
name|overlapStart
init|=
name|Math
operator|.
name|max
argument_list|(
name|cellStart
argument_list|,
name|s
operator|.
name|getOffsetInBlock
argument_list|()
argument_list|)
decl_stmt|;
name|long
name|overlapEnd
init|=
name|Math
operator|.
name|min
argument_list|(
name|cellEnd
argument_list|,
name|stripeEnd
argument_list|)
decl_stmt|;
name|int
name|overLapLen
init|=
call|(
name|int
call|)
argument_list|(
name|overlapEnd
operator|-
name|overlapStart
operator|+
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|overLapLen
operator|<=
literal|0
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|s
operator|.
name|chunks
index|[
name|cell
operator|.
name|idxInStripe
index|]
operator|==
literal|null
condition|)
block|{
name|s
operator|.
name|chunks
index|[
name|cell
operator|.
name|idxInStripe
index|]
operator|=
operator|new
name|StripingChunk
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
name|s
operator|.
name|chunks
index|[
name|cell
operator|.
name|idxInStripe
index|]
operator|.
name|addByteArraySlice
argument_list|(
call|(
name|int
call|)
argument_list|(
name|offsetInBuf
operator|+
name|done
operator|+
name|overlapStart
operator|-
name|cellStart
argument_list|)
argument_list|,
name|overLapLen
argument_list|)
expr_stmt|;
block|}
name|done
operator|+=
name|cell
operator|.
name|size
expr_stmt|;
block|}
block|}
comment|/**    * If a {@link StripingChunk} maps to a byte range beyond an internal block's    * size, the chunk should be treated as zero bytes in decoding.    */
DECL|method|prepareAllZeroChunks (LocatedStripedBlock blockGroup, AlignedStripe[] stripes, int cellSize, int dataBlkNum)
specifier|private
specifier|static
name|void
name|prepareAllZeroChunks
parameter_list|(
name|LocatedStripedBlock
name|blockGroup
parameter_list|,
name|AlignedStripe
index|[]
name|stripes
parameter_list|,
name|int
name|cellSize
parameter_list|,
name|int
name|dataBlkNum
parameter_list|)
block|{
for|for
control|(
name|AlignedStripe
name|s
range|:
name|stripes
control|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|dataBlkNum
condition|;
name|i
operator|++
control|)
block|{
name|long
name|internalBlkLen
init|=
name|getInternalBlockLength
argument_list|(
name|blockGroup
operator|.
name|getBlockSize
argument_list|()
argument_list|,
name|cellSize
argument_list|,
name|dataBlkNum
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|internalBlkLen
operator|<=
name|s
operator|.
name|getOffsetInBlock
argument_list|()
condition|)
block|{
name|Preconditions
operator|.
name|checkState
argument_list|(
name|s
operator|.
name|chunks
index|[
name|i
index|]
operator|==
literal|null
argument_list|)
expr_stmt|;
name|s
operator|.
name|chunks
index|[
name|i
index|]
operator|=
operator|new
name|StripingChunk
argument_list|()
expr_stmt|;
comment|// chunk state is set to ALLZERO
block|}
block|}
block|}
block|}
comment|/**    * Cell is the unit of encoding used in {@link DFSStripedOutputStream}. This    * size impacts how a logical offset in the file or block group translates    * to physical byte offset in a stored internal block. The StripingCell util    * class facilitates this calculation. Each StripingCell is inclusive with    * its start and end offsets -- e.g., the end logical offset of cell_0_0_0    * should be 1 byte lower than the start logical offset of cell_1_0_1.    *    *  |<------- Striped Block Group -------> |    *    blk_0          blk_1          blk_2    *      |              |              |    *      v              v              v    * +----------+   +----------+   +----------+    * |cell_0_0_0|   |cell_1_0_1|   |cell_2_0_2|    * +----------+   +----------+   +----------+    * |cell_3_1_0|   |cell_4_1_1|   |cell_5_1_2|<- {@link #idxInBlkGroup} = 5    * +----------+   +----------+   +----------+    {@link #idxInInternalBlk} = 1    *                                               {@link #idxInStripe} = 2    * A StripingCell is a special instance of {@link StripingChunk} whose offset    * and size align with the cell used when writing data.    * TODO: consider parity cells    */
annotation|@
name|VisibleForTesting
DECL|class|StripingCell
specifier|static
class|class
name|StripingCell
block|{
DECL|field|schema
specifier|final
name|ECSchema
name|schema
decl_stmt|;
comment|/** Logical order in a block group, used when doing I/O to a block group */
DECL|field|idxInBlkGroup
specifier|final
name|int
name|idxInBlkGroup
decl_stmt|;
DECL|field|idxInInternalBlk
specifier|final
name|int
name|idxInInternalBlk
decl_stmt|;
DECL|field|idxInStripe
specifier|final
name|int
name|idxInStripe
decl_stmt|;
comment|/**      * When a logical byte range is mapped to a set of cells, it might      * partially overlap with the first and last cells. This field and the      * {@link #size} variable represent the start offset and size of the      * overlap.      */
DECL|field|offset
specifier|final
name|int
name|offset
decl_stmt|;
DECL|field|size
specifier|final
name|int
name|size
decl_stmt|;
DECL|method|StripingCell (ECSchema ecSchema, int cellSize, int idxInBlkGroup, int offset)
name|StripingCell
parameter_list|(
name|ECSchema
name|ecSchema
parameter_list|,
name|int
name|cellSize
parameter_list|,
name|int
name|idxInBlkGroup
parameter_list|,
name|int
name|offset
parameter_list|)
block|{
name|this
operator|.
name|schema
operator|=
name|ecSchema
expr_stmt|;
name|this
operator|.
name|idxInBlkGroup
operator|=
name|idxInBlkGroup
expr_stmt|;
name|this
operator|.
name|idxInInternalBlk
operator|=
name|idxInBlkGroup
operator|/
name|ecSchema
operator|.
name|getNumDataUnits
argument_list|()
expr_stmt|;
name|this
operator|.
name|idxInStripe
operator|=
name|idxInBlkGroup
operator|-
name|this
operator|.
name|idxInInternalBlk
operator|*
name|ecSchema
operator|.
name|getNumDataUnits
argument_list|()
expr_stmt|;
name|this
operator|.
name|offset
operator|=
name|offset
expr_stmt|;
name|this
operator|.
name|size
operator|=
name|cellSize
expr_stmt|;
block|}
block|}
comment|/**    * Given a requested byte range on a striped block group, an AlignedStripe    * represents an inclusive {@link VerticalRange} that is aligned with both    * the byte range and boundaries of all internal blocks. As illustrated in    * the diagram, any given byte range on a block group leads to 1~5    * AlignedStripe's.    *    * |<-------- Striped Block Group -------->|    * blk_0   blk_1   blk_2      blk_3   blk_4    *                 +----+  |  +----+  +----+    *                 |full|  |  |    |  |    |<- AlignedStripe0:    *         +----+  |~~~~|  |  |~~~~|  |~~~~|      1st cell is partial    *         |part|  |    |  |  |    |  |    |<- AlignedStripe1: byte range    * +----+  +----+  +----+  |  |~~~~|  |~~~~|      doesn't start at 1st block    * |full|  |full|  |full|  |  |    |  |    |    * |cell|  |cell|  |cell|  |  |    |  |    |<- AlignedStripe2 (full stripe)    * |    |  |    |  |    |  |  |    |  |    |    * +----+  +----+  +----+  |  |~~~~|  |~~~~|    * |full|  |part|          |  |    |  |    |<- AlignedStripe3: byte range    * |~~~~|  +----+          |  |~~~~|  |~~~~|      doesn't end at last block    * |    |                  |  |    |  |    |<- AlignedStripe4:    * +----+                  |  +----+  +----+      last cell is partial    *                         |    *<---- data blocks ----> |<--- parity --->    *    * An AlignedStripe is the basic unit of reading from a striped block group,    * because within the AlignedStripe, all internal blocks can be processed in    * a uniform manner.    *    * The coverage of an AlignedStripe on an internal block is represented as a    * {@link StripingChunk}.    *    * To simplify the logic of reading a logical byte range from a block group,    * a StripingChunk is either completely in the requested byte range or    * completely outside the requested byte range.    */
DECL|class|AlignedStripe
specifier|public
specifier|static
class|class
name|AlignedStripe
block|{
DECL|field|range
specifier|public
name|VerticalRange
name|range
decl_stmt|;
comment|/** status of each chunk in the stripe */
DECL|field|chunks
specifier|public
specifier|final
name|StripingChunk
index|[]
name|chunks
decl_stmt|;
DECL|field|fetchedChunksNum
specifier|public
name|int
name|fetchedChunksNum
init|=
literal|0
decl_stmt|;
DECL|field|missingChunksNum
specifier|public
name|int
name|missingChunksNum
init|=
literal|0
decl_stmt|;
DECL|method|AlignedStripe (long offsetInBlock, long length, int width)
specifier|public
name|AlignedStripe
parameter_list|(
name|long
name|offsetInBlock
parameter_list|,
name|long
name|length
parameter_list|,
name|int
name|width
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|offsetInBlock
operator|>=
literal|0
operator|&&
name|length
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|this
operator|.
name|range
operator|=
operator|new
name|VerticalRange
argument_list|(
name|offsetInBlock
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|this
operator|.
name|chunks
operator|=
operator|new
name|StripingChunk
index|[
name|width
index|]
expr_stmt|;
block|}
DECL|method|include (long pos)
specifier|public
name|boolean
name|include
parameter_list|(
name|long
name|pos
parameter_list|)
block|{
return|return
name|range
operator|.
name|include
argument_list|(
name|pos
argument_list|)
return|;
block|}
DECL|method|getOffsetInBlock ()
specifier|public
name|long
name|getOffsetInBlock
parameter_list|()
block|{
return|return
name|range
operator|.
name|offsetInBlock
return|;
block|}
DECL|method|getSpanInBlock ()
specifier|public
name|long
name|getSpanInBlock
parameter_list|()
block|{
return|return
name|range
operator|.
name|spanInBlock
return|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"Offset="
operator|+
name|range
operator|.
name|offsetInBlock
operator|+
literal|", length="
operator|+
name|range
operator|.
name|spanInBlock
operator|+
literal|", fetchedChunksNum="
operator|+
name|fetchedChunksNum
operator|+
literal|", missingChunksNum="
operator|+
name|missingChunksNum
return|;
block|}
block|}
comment|/**    * A simple utility class representing an arbitrary vertical inclusive range    * starting at {@link #offsetInBlock} and lasting for {@link #spanInBlock}    * bytes in an internal block. Note that VerticalRange doesn't necessarily    * align with {@link StripingCell}.    *    * |<- Striped Block Group ->|    *  blk_0    *    |    *    v    * +-----+    * |~~~~~|<-- {@link #offsetInBlock}    * |     |  ^    * |     |  |    * |     |  | {@link #spanInBlock}    * |     |  v    * |~~~~~| ---    * |     |    * +-----+    */
DECL|class|VerticalRange
specifier|public
specifier|static
class|class
name|VerticalRange
block|{
comment|/** start offset in the block group (inclusive) */
DECL|field|offsetInBlock
specifier|public
name|long
name|offsetInBlock
decl_stmt|;
comment|/** length of the stripe range */
DECL|field|spanInBlock
specifier|public
name|long
name|spanInBlock
decl_stmt|;
DECL|method|VerticalRange (long offsetInBlock, long length)
specifier|public
name|VerticalRange
parameter_list|(
name|long
name|offsetInBlock
parameter_list|,
name|long
name|length
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|offsetInBlock
operator|>=
literal|0
operator|&&
name|length
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|this
operator|.
name|offsetInBlock
operator|=
name|offsetInBlock
expr_stmt|;
name|this
operator|.
name|spanInBlock
operator|=
name|length
expr_stmt|;
block|}
comment|/** whether a position is in the range */
DECL|method|include (long pos)
specifier|public
name|boolean
name|include
parameter_list|(
name|long
name|pos
parameter_list|)
block|{
return|return
name|pos
operator|>=
name|offsetInBlock
operator|&&
name|pos
operator|<
name|offsetInBlock
operator|+
name|spanInBlock
return|;
block|}
block|}
comment|/**    * Indicates the coverage of an {@link AlignedStripe} on an internal block,    * and the state of the chunk in the context of the read request.    *    * |<---------------- Striped Block Group --------------->|    *   blk_0        blk_1        blk_2          blk_3   blk_4    *                           +---------+  |  +----+  +----+    *     null         null     |REQUESTED|  |  |null|  |null|<- AlignedStripe0    *              +---------+  |---------|  |  |----|  |----|    *     null     |REQUESTED|  |REQUESTED|  |  |null|  |null|<- AlignedStripe1    * +---------+  +---------+  +---------+  |  +----+  +----+    * |REQUESTED|  |REQUESTED|    ALLZERO    |  |null|  |null|<- AlignedStripe2    * +---------+  +---------+               |  +----+  +----+    *<----------- data blocks ------------> |<--- parity --->    */
DECL|class|StripingChunk
specifier|public
specifier|static
class|class
name|StripingChunk
block|{
comment|/** Chunk has been successfully fetched */
DECL|field|FETCHED
specifier|public
specifier|static
specifier|final
name|int
name|FETCHED
init|=
literal|0x01
decl_stmt|;
comment|/** Chunk has encountered failed when being fetched */
DECL|field|MISSING
specifier|public
specifier|static
specifier|final
name|int
name|MISSING
init|=
literal|0x02
decl_stmt|;
comment|/** Chunk being fetched (fetching task is in-flight) */
DECL|field|PENDING
specifier|public
specifier|static
specifier|final
name|int
name|PENDING
init|=
literal|0x04
decl_stmt|;
comment|/**      * Chunk is requested either by application or for decoding, need to      * schedule read task      */
DECL|field|REQUESTED
specifier|public
specifier|static
specifier|final
name|int
name|REQUESTED
init|=
literal|0X08
decl_stmt|;
comment|/**      * Internal block is short and has no overlap with chunk. Chunk considered      * all-zero bytes in codec calculations.      */
DECL|field|ALLZERO
specifier|public
specifier|static
specifier|final
name|int
name|ALLZERO
init|=
literal|0X0f
decl_stmt|;
comment|/**      * If a chunk is completely in requested range, the state transition is:      * REQUESTED (when AlignedStripe created) -> PENDING -> {FETCHED | MISSING}      * If a chunk is completely outside requested range (including parity      * chunks), state transition is:      * null (AlignedStripe created) -> REQUESTED (upon failure) -> PENDING ...      */
DECL|field|state
specifier|public
name|int
name|state
init|=
name|REQUESTED
decl_stmt|;
DECL|field|byteArray
specifier|public
specifier|final
name|ChunkByteArray
name|byteArray
decl_stmt|;
DECL|field|byteBuffer
specifier|public
specifier|final
name|ByteBuffer
name|byteBuffer
decl_stmt|;
DECL|method|StripingChunk (byte[] buf)
specifier|public
name|StripingChunk
parameter_list|(
name|byte
index|[]
name|buf
parameter_list|)
block|{
name|this
operator|.
name|byteArray
operator|=
operator|new
name|ChunkByteArray
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|byteBuffer
operator|=
literal|null
expr_stmt|;
block|}
DECL|method|StripingChunk (ByteBuffer buf)
specifier|public
name|StripingChunk
parameter_list|(
name|ByteBuffer
name|buf
parameter_list|)
block|{
name|this
operator|.
name|byteArray
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|byteBuffer
operator|=
name|buf
expr_stmt|;
block|}
DECL|method|StripingChunk ()
specifier|public
name|StripingChunk
parameter_list|()
block|{
name|this
operator|.
name|byteArray
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|byteBuffer
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|state
operator|=
name|ALLZERO
expr_stmt|;
block|}
DECL|method|addByteArraySlice (int offset, int length)
specifier|public
name|void
name|addByteArraySlice
parameter_list|(
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
block|{
assert|assert
name|byteArray
operator|!=
literal|null
assert|;
name|byteArray
operator|.
name|offsetsInBuf
operator|.
name|add
argument_list|(
name|offset
argument_list|)
expr_stmt|;
name|byteArray
operator|.
name|lengthsInBuf
operator|.
name|add
argument_list|(
name|length
argument_list|)
expr_stmt|;
block|}
DECL|method|copyTo (byte[] target)
name|void
name|copyTo
parameter_list|(
name|byte
index|[]
name|target
parameter_list|)
block|{
assert|assert
name|byteArray
operator|!=
literal|null
assert|;
name|byteArray
operator|.
name|copyTo
argument_list|(
name|target
argument_list|)
expr_stmt|;
block|}
DECL|method|copyFrom (byte[] src)
name|void
name|copyFrom
parameter_list|(
name|byte
index|[]
name|src
parameter_list|)
block|{
assert|assert
name|byteArray
operator|!=
literal|null
assert|;
name|byteArray
operator|.
name|copyFrom
argument_list|(
name|src
argument_list|)
expr_stmt|;
block|}
block|}
DECL|class|ChunkByteArray
specifier|public
specifier|static
class|class
name|ChunkByteArray
block|{
DECL|field|buf
specifier|private
specifier|final
name|byte
index|[]
name|buf
decl_stmt|;
DECL|field|offsetsInBuf
specifier|private
specifier|final
name|List
argument_list|<
name|Integer
argument_list|>
name|offsetsInBuf
decl_stmt|;
DECL|field|lengthsInBuf
specifier|private
specifier|final
name|List
argument_list|<
name|Integer
argument_list|>
name|lengthsInBuf
decl_stmt|;
DECL|method|ChunkByteArray (byte[] buf)
name|ChunkByteArray
parameter_list|(
name|byte
index|[]
name|buf
parameter_list|)
block|{
name|this
operator|.
name|buf
operator|=
name|buf
expr_stmt|;
name|this
operator|.
name|offsetsInBuf
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
expr_stmt|;
name|this
operator|.
name|lengthsInBuf
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
expr_stmt|;
block|}
DECL|method|getOffsets ()
specifier|public
name|int
index|[]
name|getOffsets
parameter_list|()
block|{
name|int
index|[]
name|offsets
init|=
operator|new
name|int
index|[
name|offsetsInBuf
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|offsets
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|offsets
index|[
name|i
index|]
operator|=
name|offsetsInBuf
operator|.
name|get
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
return|return
name|offsets
return|;
block|}
DECL|method|getLengths ()
specifier|public
name|int
index|[]
name|getLengths
parameter_list|()
block|{
name|int
index|[]
name|lens
init|=
operator|new
name|int
index|[
name|this
operator|.
name|lengthsInBuf
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|lens
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|lens
index|[
name|i
index|]
operator|=
name|this
operator|.
name|lengthsInBuf
operator|.
name|get
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
return|return
name|lens
return|;
block|}
DECL|method|buf ()
specifier|public
name|byte
index|[]
name|buf
parameter_list|()
block|{
return|return
name|buf
return|;
block|}
DECL|method|copyTo (byte[] target)
name|void
name|copyTo
parameter_list|(
name|byte
index|[]
name|target
parameter_list|)
block|{
name|int
name|posInBuf
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|offsetsInBuf
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|System
operator|.
name|arraycopy
argument_list|(
name|buf
argument_list|,
name|offsetsInBuf
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|,
name|target
argument_list|,
name|posInBuf
argument_list|,
name|lengthsInBuf
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|posInBuf
operator|+=
name|lengthsInBuf
operator|.
name|get
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|copyFrom (byte[] src)
name|void
name|copyFrom
parameter_list|(
name|byte
index|[]
name|src
parameter_list|)
block|{
name|int
name|srcPos
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|offsetsInBuf
operator|.
name|size
argument_list|()
condition|;
name|j
operator|++
control|)
block|{
name|System
operator|.
name|arraycopy
argument_list|(
name|src
argument_list|,
name|srcPos
argument_list|,
name|buf
argument_list|,
name|offsetsInBuf
operator|.
name|get
argument_list|(
name|j
argument_list|)
argument_list|,
name|lengthsInBuf
operator|.
name|get
argument_list|(
name|j
argument_list|)
argument_list|)
expr_stmt|;
name|srcPos
operator|+=
name|lengthsInBuf
operator|.
name|get
argument_list|(
name|j
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * This class represents result from a striped read request.    * If the task was successful or the internal computation failed,    * an index is also returned.    */
DECL|class|StripingChunkReadResult
specifier|public
specifier|static
class|class
name|StripingChunkReadResult
block|{
DECL|field|SUCCESSFUL
specifier|public
specifier|static
specifier|final
name|int
name|SUCCESSFUL
init|=
literal|0x01
decl_stmt|;
DECL|field|FAILED
specifier|public
specifier|static
specifier|final
name|int
name|FAILED
init|=
literal|0x02
decl_stmt|;
DECL|field|TIMEOUT
specifier|public
specifier|static
specifier|final
name|int
name|TIMEOUT
init|=
literal|0x04
decl_stmt|;
DECL|field|CANCELLED
specifier|public
specifier|static
specifier|final
name|int
name|CANCELLED
init|=
literal|0x08
decl_stmt|;
DECL|field|index
specifier|public
specifier|final
name|int
name|index
decl_stmt|;
DECL|field|state
specifier|public
specifier|final
name|int
name|state
decl_stmt|;
DECL|method|StripingChunkReadResult (int state)
specifier|public
name|StripingChunkReadResult
parameter_list|(
name|int
name|state
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|state
operator|==
name|TIMEOUT
argument_list|,
literal|"Only timeout result should return negative index."
argument_list|)
expr_stmt|;
name|this
operator|.
name|index
operator|=
operator|-
literal|1
expr_stmt|;
name|this
operator|.
name|state
operator|=
name|state
expr_stmt|;
block|}
DECL|method|StripingChunkReadResult (int index, int state)
specifier|public
name|StripingChunkReadResult
parameter_list|(
name|int
name|index
parameter_list|,
name|int
name|state
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|state
operator|!=
name|TIMEOUT
argument_list|,
literal|"Timeout result should return negative index."
argument_list|)
expr_stmt|;
name|this
operator|.
name|index
operator|=
name|index
expr_stmt|;
name|this
operator|.
name|state
operator|=
name|state
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"(index="
operator|+
name|index
operator|+
literal|", state ="
operator|+
name|state
operator|+
literal|")"
return|;
block|}
block|}
comment|/**    * Check if the information such as IDs and generation stamps in block-i    * match block-0.    */
DECL|method|checkBlocks (ExtendedBlock block0, int i, ExtendedBlock blocki)
specifier|public
specifier|static
name|void
name|checkBlocks
parameter_list|(
name|ExtendedBlock
name|block0
parameter_list|,
name|int
name|i
parameter_list|,
name|ExtendedBlock
name|blocki
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|blocki
operator|.
name|getBlockPoolId
argument_list|()
operator|.
name|equals
argument_list|(
name|block0
operator|.
name|getBlockPoolId
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Block pool IDs mismatched: block0="
operator|+
name|block0
operator|+
literal|", block"
operator|+
name|i
operator|+
literal|"="
operator|+
name|blocki
argument_list|)
throw|;
block|}
if|if
condition|(
name|blocki
operator|.
name|getBlockId
argument_list|()
operator|-
name|i
operator|!=
name|block0
operator|.
name|getBlockId
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Block IDs mismatched: block0="
operator|+
name|block0
operator|+
literal|", block"
operator|+
name|i
operator|+
literal|"="
operator|+
name|blocki
argument_list|)
throw|;
block|}
if|if
condition|(
name|blocki
operator|.
name|getGenerationStamp
argument_list|()
operator|!=
name|block0
operator|.
name|getGenerationStamp
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Generation stamps mismatched: block0="
operator|+
name|block0
operator|+
literal|", block"
operator|+
name|i
operator|+
literal|"="
operator|+
name|blocki
argument_list|)
throw|;
block|}
block|}
block|}
end_class

end_unit

