begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdfs.util
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|util
package|;
end_package

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|StorageType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSClient
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSStripedOutputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|DatanodeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|ExtendedBlock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|LocatedBlock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|LocatedStripedBlock
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|erasurecode
operator|.
name|ECSchema
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|erasurecode
operator|.
name|rawcoder
operator|.
name|RSRawDecoder
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|CancellationException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|CompletionService
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutionException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Future
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_comment
comment|/**  * Utility class for analyzing striped block groups  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
DECL|class|StripedBlockUtil
specifier|public
class|class
name|StripedBlockUtil
block|{
comment|/**    * This method parses a striped block group into individual blocks.    *    * @param bg The striped block group    * @param cellSize The size of a striping cell    * @param dataBlkNum The number of data blocks    * @return An array containing the blocks in the group    */
DECL|method|parseStripedBlockGroup (LocatedStripedBlock bg, int cellSize, int dataBlkNum, int parityBlkNum)
specifier|public
specifier|static
name|LocatedBlock
index|[]
name|parseStripedBlockGroup
parameter_list|(
name|LocatedStripedBlock
name|bg
parameter_list|,
name|int
name|cellSize
parameter_list|,
name|int
name|dataBlkNum
parameter_list|,
name|int
name|parityBlkNum
parameter_list|)
block|{
name|int
name|locatedBGSize
init|=
name|bg
operator|.
name|getBlockIndices
argument_list|()
operator|.
name|length
decl_stmt|;
comment|// TODO not considering missing blocks for now, only identify data blocks
name|LocatedBlock
index|[]
name|lbs
init|=
operator|new
name|LocatedBlock
index|[
name|dataBlkNum
operator|+
name|parityBlkNum
index|]
decl_stmt|;
for|for
control|(
name|short
name|i
init|=
literal|0
init|;
name|i
operator|<
name|locatedBGSize
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|int
name|idx
init|=
name|bg
operator|.
name|getBlockIndices
argument_list|()
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|idx
operator|<
operator|(
name|dataBlkNum
operator|+
name|parityBlkNum
operator|)
operator|&&
name|lbs
index|[
name|idx
index|]
operator|==
literal|null
condition|)
block|{
name|lbs
index|[
name|idx
index|]
operator|=
name|constructInternalBlock
argument_list|(
name|bg
argument_list|,
name|i
argument_list|,
name|cellSize
argument_list|,
name|dataBlkNum
argument_list|,
name|idx
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|lbs
return|;
block|}
comment|/**    * This method creates an internal block at the given index of a block group    *    * @param idxInReturnedLocs The index in the stored locations in the    *                          {@link LocatedStripedBlock} object    * @param idxInBlockGroup The logical index in the striped block group    * @return The constructed internal block    */
DECL|method|constructInternalBlock (LocatedStripedBlock bg, int idxInReturnedLocs, int cellSize, int dataBlkNum, int idxInBlockGroup)
specifier|public
specifier|static
name|LocatedBlock
name|constructInternalBlock
parameter_list|(
name|LocatedStripedBlock
name|bg
parameter_list|,
name|int
name|idxInReturnedLocs
parameter_list|,
name|int
name|cellSize
parameter_list|,
name|int
name|dataBlkNum
parameter_list|,
name|int
name|idxInBlockGroup
parameter_list|)
block|{
specifier|final
name|ExtendedBlock
name|blk
init|=
name|constructInternalBlock
argument_list|(
name|bg
operator|.
name|getBlock
argument_list|()
argument_list|,
name|cellSize
argument_list|,
name|dataBlkNum
argument_list|,
name|idxInBlockGroup
argument_list|)
decl_stmt|;
return|return
operator|new
name|LocatedBlock
argument_list|(
name|blk
argument_list|,
operator|new
name|DatanodeInfo
index|[]
block|{
name|bg
operator|.
name|getLocations
argument_list|()
index|[
name|idxInReturnedLocs
index|]
block|}
argument_list|,
operator|new
name|String
index|[]
block|{
name|bg
operator|.
name|getStorageIDs
argument_list|()
index|[
name|idxInReturnedLocs
index|]
block|}
argument_list|,
operator|new
name|StorageType
index|[]
block|{
name|bg
operator|.
name|getStorageTypes
argument_list|()
index|[
name|idxInReturnedLocs
index|]
block|}
argument_list|,
name|bg
operator|.
name|getStartOffset
argument_list|()
operator|+
name|idxInBlockGroup
argument_list|,
name|bg
operator|.
name|isCorrupt
argument_list|()
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**    * This method creates an internal {@link ExtendedBlock} at the given index    * of a block group.    */
DECL|method|constructInternalBlock (ExtendedBlock blockGroup, int cellSize, int dataBlkNum, int idxInBlockGroup)
specifier|public
specifier|static
name|ExtendedBlock
name|constructInternalBlock
parameter_list|(
name|ExtendedBlock
name|blockGroup
parameter_list|,
name|int
name|cellSize
parameter_list|,
name|int
name|dataBlkNum
parameter_list|,
name|int
name|idxInBlockGroup
parameter_list|)
block|{
name|ExtendedBlock
name|block
init|=
operator|new
name|ExtendedBlock
argument_list|(
name|blockGroup
argument_list|)
decl_stmt|;
name|block
operator|.
name|setBlockId
argument_list|(
name|blockGroup
operator|.
name|getBlockId
argument_list|()
operator|+
name|idxInBlockGroup
argument_list|)
expr_stmt|;
name|block
operator|.
name|setNumBytes
argument_list|(
name|getInternalBlockLength
argument_list|(
name|blockGroup
operator|.
name|getNumBytes
argument_list|()
argument_list|,
name|cellSize
argument_list|,
name|dataBlkNum
argument_list|,
name|idxInBlockGroup
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|block
return|;
block|}
comment|/**    * This method creates an internal {@link ExtendedBlock} at the given index    * of a block group, for both data and parity block.    */
DECL|method|constructStripedBlock (ExtendedBlock blockGroup, int cellSize, int dataBlkNum, int idxInBlockGroup)
specifier|public
specifier|static
name|ExtendedBlock
name|constructStripedBlock
parameter_list|(
name|ExtendedBlock
name|blockGroup
parameter_list|,
name|int
name|cellSize
parameter_list|,
name|int
name|dataBlkNum
parameter_list|,
name|int
name|idxInBlockGroup
parameter_list|)
block|{
name|ExtendedBlock
name|block
init|=
operator|new
name|ExtendedBlock
argument_list|(
name|blockGroup
argument_list|)
decl_stmt|;
name|block
operator|.
name|setBlockId
argument_list|(
name|blockGroup
operator|.
name|getBlockId
argument_list|()
operator|+
name|idxInBlockGroup
argument_list|)
expr_stmt|;
name|block
operator|.
name|setNumBytes
argument_list|(
name|getStripedBlockLength
argument_list|(
name|blockGroup
operator|.
name|getNumBytes
argument_list|()
argument_list|,
name|cellSize
argument_list|,
name|dataBlkNum
argument_list|,
name|idxInBlockGroup
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|block
return|;
block|}
comment|/**    * Returns an internal block length at the given index of a block group,    * for both data and parity block.    */
DECL|method|getStripedBlockLength (long numBytes, int cellSize, int dataBlkNum, int idxInBlockGroup)
specifier|public
specifier|static
name|long
name|getStripedBlockLength
parameter_list|(
name|long
name|numBytes
parameter_list|,
name|int
name|cellSize
parameter_list|,
name|int
name|dataBlkNum
parameter_list|,
name|int
name|idxInBlockGroup
parameter_list|)
block|{
comment|// parity block length is the same as the first striped block length.
return|return
name|StripedBlockUtil
operator|.
name|getInternalBlockLength
argument_list|(
name|numBytes
argument_list|,
name|cellSize
argument_list|,
name|dataBlkNum
argument_list|,
name|idxInBlockGroup
operator|<
name|dataBlkNum
condition|?
name|idxInBlockGroup
else|:
literal|0
argument_list|)
return|;
block|}
comment|/**    * Get the size of an internal block at the given index of a block group    *    * @param dataSize Size of the block group only counting data blocks    * @param cellSize The size of a striping cell    * @param numDataBlocks The number of data blocks    * @param i The logical index in the striped block group    * @return The size of the internal block at the specified index    */
DECL|method|getInternalBlockLength (long dataSize, int cellSize, int numDataBlocks, int i)
specifier|public
specifier|static
name|long
name|getInternalBlockLength
parameter_list|(
name|long
name|dataSize
parameter_list|,
name|int
name|cellSize
parameter_list|,
name|int
name|numDataBlocks
parameter_list|,
name|int
name|i
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|dataSize
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|cellSize
operator|>
literal|0
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|numDataBlocks
operator|>
literal|0
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|i
operator|>=
literal|0
argument_list|)
expr_stmt|;
comment|// Size of each stripe (only counting data blocks)
specifier|final
name|int
name|stripeSize
init|=
name|cellSize
operator|*
name|numDataBlocks
decl_stmt|;
comment|// If block group ends at stripe boundary, each internal block has an equal
comment|// share of the group
specifier|final
name|int
name|lastStripeDataLen
init|=
call|(
name|int
call|)
argument_list|(
name|dataSize
operator|%
name|stripeSize
argument_list|)
decl_stmt|;
if|if
condition|(
name|lastStripeDataLen
operator|==
literal|0
condition|)
block|{
return|return
name|dataSize
operator|/
name|numDataBlocks
return|;
block|}
specifier|final
name|int
name|numStripes
init|=
call|(
name|int
call|)
argument_list|(
operator|(
name|dataSize
operator|-
literal|1
operator|)
operator|/
name|stripeSize
operator|+
literal|1
argument_list|)
decl_stmt|;
return|return
operator|(
name|numStripes
operator|-
literal|1L
operator|)
operator|*
name|cellSize
operator|+
name|lastCellSize
argument_list|(
name|lastStripeDataLen
argument_list|,
name|cellSize
argument_list|,
name|numDataBlocks
argument_list|,
name|i
argument_list|)
return|;
block|}
DECL|method|lastCellSize (int size, int cellSize, int numDataBlocks, int i)
specifier|private
specifier|static
name|int
name|lastCellSize
parameter_list|(
name|int
name|size
parameter_list|,
name|int
name|cellSize
parameter_list|,
name|int
name|numDataBlocks
parameter_list|,
name|int
name|i
parameter_list|)
block|{
if|if
condition|(
name|i
operator|<
name|numDataBlocks
condition|)
block|{
comment|// parity block size (i.e. i>= numDataBlocks) is the same as
comment|// the first data block size (i.e. i = 0).
name|size
operator|-=
name|i
operator|*
name|cellSize
expr_stmt|;
if|if
condition|(
name|size
operator|<
literal|0
condition|)
block|{
name|size
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return
name|size
operator|>
name|cellSize
condition|?
name|cellSize
else|:
name|size
return|;
block|}
comment|/**    * Given a byte's offset in an internal block, calculate the offset in    * the block group    */
DECL|method|offsetInBlkToOffsetInBG (int cellSize, int dataBlkNum, long offsetInBlk, int idxInBlockGroup)
specifier|public
specifier|static
name|long
name|offsetInBlkToOffsetInBG
parameter_list|(
name|int
name|cellSize
parameter_list|,
name|int
name|dataBlkNum
parameter_list|,
name|long
name|offsetInBlk
parameter_list|,
name|int
name|idxInBlockGroup
parameter_list|)
block|{
name|int
name|cellIdxInBlk
init|=
call|(
name|int
call|)
argument_list|(
name|offsetInBlk
operator|/
name|cellSize
argument_list|)
decl_stmt|;
return|return
name|cellIdxInBlk
operator|*
name|cellSize
operator|*
name|dataBlkNum
comment|// n full stripes before offset
operator|+
name|idxInBlockGroup
operator|*
name|cellSize
comment|// m full cells before offset
operator|+
name|offsetInBlk
operator|%
name|cellSize
return|;
comment|// partial cell
block|}
comment|/**    * This method plans the read portion from each block in the stripe    * @param dataBlkNum The number of data blocks in the striping group    * @param cellSize The size of each striping cell    * @param startInBlk Starting offset in the striped block    * @param len Length of the read request    * @param bufOffset  Initial offset in the result buffer    * @return array of {@link ReadPortion}, each representing the portion of I/O    *         for an individual block in the group    */
annotation|@
name|VisibleForTesting
DECL|method|planReadPortions (final int dataBlkNum, final int cellSize, final long startInBlk, final int len, int bufOffset)
specifier|public
specifier|static
name|ReadPortion
index|[]
name|planReadPortions
parameter_list|(
specifier|final
name|int
name|dataBlkNum
parameter_list|,
specifier|final
name|int
name|cellSize
parameter_list|,
specifier|final
name|long
name|startInBlk
parameter_list|,
specifier|final
name|int
name|len
parameter_list|,
name|int
name|bufOffset
parameter_list|)
block|{
name|ReadPortion
index|[]
name|results
init|=
operator|new
name|ReadPortion
index|[
name|dataBlkNum
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|dataBlkNum
condition|;
name|i
operator|++
control|)
block|{
name|results
index|[
name|i
index|]
operator|=
operator|new
name|ReadPortion
argument_list|()
expr_stmt|;
block|}
comment|// cellIdxInBlk is the index of the cell in the block
comment|// E.g., cell_3 is the 2nd cell in blk_0
name|int
name|cellIdxInBlk
init|=
call|(
name|int
call|)
argument_list|(
name|startInBlk
operator|/
operator|(
name|cellSize
operator|*
name|dataBlkNum
operator|)
argument_list|)
decl_stmt|;
comment|// blkIdxInGroup is the index of the block in the striped block group
comment|// E.g., blk_2 is the 3rd block in the group
specifier|final
name|int
name|blkIdxInGroup
init|=
call|(
name|int
call|)
argument_list|(
name|startInBlk
operator|/
name|cellSize
operator|%
name|dataBlkNum
argument_list|)
decl_stmt|;
name|results
index|[
name|blkIdxInGroup
index|]
operator|.
name|setStartOffsetInBlock
argument_list|(
name|cellSize
operator|*
name|cellIdxInBlk
operator|+
name|startInBlk
operator|%
name|cellSize
argument_list|)
expr_stmt|;
name|boolean
name|crossStripe
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|dataBlkNum
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|blkIdxInGroup
operator|+
name|i
operator|>=
name|dataBlkNum
operator|&&
operator|!
name|crossStripe
condition|)
block|{
name|cellIdxInBlk
operator|++
expr_stmt|;
name|crossStripe
operator|=
literal|true
expr_stmt|;
block|}
name|results
index|[
operator|(
name|blkIdxInGroup
operator|+
name|i
operator|)
operator|%
name|dataBlkNum
index|]
operator|.
name|setStartOffsetInBlock
argument_list|(
name|cellSize
operator|*
name|cellIdxInBlk
argument_list|)
expr_stmt|;
block|}
name|int
name|firstCellLen
init|=
name|Math
operator|.
name|min
argument_list|(
name|cellSize
operator|-
call|(
name|int
call|)
argument_list|(
name|startInBlk
operator|%
name|cellSize
argument_list|)
argument_list|,
name|len
argument_list|)
decl_stmt|;
name|results
index|[
name|blkIdxInGroup
index|]
operator|.
name|offsetsInBuf
operator|.
name|add
argument_list|(
name|bufOffset
argument_list|)
expr_stmt|;
name|results
index|[
name|blkIdxInGroup
index|]
operator|.
name|lengths
operator|.
name|add
argument_list|(
name|firstCellLen
argument_list|)
expr_stmt|;
name|results
index|[
name|blkIdxInGroup
index|]
operator|.
name|addReadLength
argument_list|(
name|firstCellLen
argument_list|)
expr_stmt|;
name|int
name|i
init|=
operator|(
name|blkIdxInGroup
operator|+
literal|1
operator|)
operator|%
name|dataBlkNum
decl_stmt|;
for|for
control|(
name|int
name|done
init|=
name|firstCellLen
init|;
name|done
operator|<
name|len
condition|;
name|done
operator|+=
name|cellSize
control|)
block|{
name|ReadPortion
name|rp
init|=
name|results
index|[
name|i
index|]
decl_stmt|;
name|rp
operator|.
name|offsetsInBuf
operator|.
name|add
argument_list|(
name|done
operator|+
name|bufOffset
argument_list|)
expr_stmt|;
specifier|final
name|int
name|readLen
init|=
name|Math
operator|.
name|min
argument_list|(
name|len
operator|-
name|done
argument_list|,
name|cellSize
argument_list|)
decl_stmt|;
name|rp
operator|.
name|lengths
operator|.
name|add
argument_list|(
name|readLen
argument_list|)
expr_stmt|;
name|rp
operator|.
name|addReadLength
argument_list|(
name|readLen
argument_list|)
expr_stmt|;
name|i
operator|=
operator|(
name|i
operator|+
literal|1
operator|)
operator|%
name|dataBlkNum
expr_stmt|;
block|}
return|return
name|results
return|;
block|}
comment|/**    * Get the next completed striped read task    *    * @return {@link StripingChunkReadResult} indicating the status of the read task    *          succeeded, and the block index of the task. If the method times    *          out without getting any completed read tasks, -1 is returned as    *          block index.    * @throws InterruptedException    */
DECL|method|getNextCompletedStripedRead ( CompletionService<Void> readService, Map<Future<Void>, Integer> futures, final long threshold)
specifier|public
specifier|static
name|StripingChunkReadResult
name|getNextCompletedStripedRead
parameter_list|(
name|CompletionService
argument_list|<
name|Void
argument_list|>
name|readService
parameter_list|,
name|Map
argument_list|<
name|Future
argument_list|<
name|Void
argument_list|>
argument_list|,
name|Integer
argument_list|>
name|futures
parameter_list|,
specifier|final
name|long
name|threshold
parameter_list|)
throws|throws
name|InterruptedException
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
operator|!
name|futures
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
name|Future
argument_list|<
name|Void
argument_list|>
name|future
init|=
literal|null
decl_stmt|;
try|try
block|{
if|if
condition|(
name|threshold
operator|>
literal|0
condition|)
block|{
name|future
operator|=
name|readService
operator|.
name|poll
argument_list|(
name|threshold
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|future
operator|=
name|readService
operator|.
name|take
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|future
operator|!=
literal|null
condition|)
block|{
name|future
operator|.
name|get
argument_list|()
expr_stmt|;
return|return
operator|new
name|StripingChunkReadResult
argument_list|(
name|futures
operator|.
name|remove
argument_list|(
name|future
argument_list|)
argument_list|,
name|StripingChunkReadResult
operator|.
name|SUCCESSFUL
argument_list|)
return|;
block|}
else|else
block|{
return|return
operator|new
name|StripingChunkReadResult
argument_list|(
name|StripingChunkReadResult
operator|.
name|TIMEOUT
argument_list|)
return|;
block|}
block|}
catch|catch
parameter_list|(
name|ExecutionException
name|e
parameter_list|)
block|{
name|DFSClient
operator|.
name|LOG
operator|.
name|error
argument_list|(
literal|"ExecutionException "
operator|+
name|e
argument_list|)
expr_stmt|;
return|return
operator|new
name|StripingChunkReadResult
argument_list|(
name|futures
operator|.
name|remove
argument_list|(
name|future
argument_list|)
argument_list|,
name|StripingChunkReadResult
operator|.
name|FAILED
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|CancellationException
name|e
parameter_list|)
block|{
return|return
operator|new
name|StripingChunkReadResult
argument_list|(
name|futures
operator|.
name|remove
argument_list|(
name|future
argument_list|)
argument_list|,
name|StripingChunkReadResult
operator|.
name|CANCELLED
argument_list|)
return|;
block|}
block|}
comment|/**    * Get the total usage of the striped blocks, which is the total of data    * blocks and parity blocks    *    * @param numDataBlkBytes    *          Size of the block group only counting data blocks    * @param dataBlkNum    *          The number of data blocks    * @param parityBlkNum    *          The number of parity blocks    * @param cellSize    *          The size of a striping cell    * @return The total usage of data blocks and parity blocks    */
DECL|method|spaceConsumedByStripedBlock (long numDataBlkBytes, int dataBlkNum, int parityBlkNum, int cellSize)
specifier|public
specifier|static
name|long
name|spaceConsumedByStripedBlock
parameter_list|(
name|long
name|numDataBlkBytes
parameter_list|,
name|int
name|dataBlkNum
parameter_list|,
name|int
name|parityBlkNum
parameter_list|,
name|int
name|cellSize
parameter_list|)
block|{
name|int
name|parityIndex
init|=
name|dataBlkNum
operator|+
literal|1
decl_stmt|;
name|long
name|numParityBlkBytes
init|=
name|getInternalBlockLength
argument_list|(
name|numDataBlkBytes
argument_list|,
name|cellSize
argument_list|,
name|dataBlkNum
argument_list|,
name|parityIndex
argument_list|)
operator|*
name|parityBlkNum
decl_stmt|;
return|return
name|numDataBlkBytes
operator|+
name|numParityBlkBytes
return|;
block|}
comment|/**    * Initialize the decoding input buffers based on the chunk states in an    * AlignedStripe    */
DECL|method|initDecodeInputs (AlignedStripe alignedStripe, int dataBlkNum, int parityBlkNum)
specifier|public
specifier|static
name|byte
index|[]
index|[]
name|initDecodeInputs
parameter_list|(
name|AlignedStripe
name|alignedStripe
parameter_list|,
name|int
name|dataBlkNum
parameter_list|,
name|int
name|parityBlkNum
parameter_list|)
block|{
name|byte
index|[]
index|[]
name|decodeInputs
init|=
operator|new
name|byte
index|[
name|dataBlkNum
operator|+
name|parityBlkNum
index|]
index|[
operator|(
name|int
operator|)
name|alignedStripe
operator|.
name|getSpanInBlock
argument_list|()
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|alignedStripe
operator|.
name|chunks
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|StripingChunk
name|chunk
init|=
name|alignedStripe
operator|.
name|chunks
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|chunk
operator|==
literal|null
condition|)
block|{
name|alignedStripe
operator|.
name|chunks
index|[
name|i
index|]
operator|=
operator|new
name|StripingChunk
argument_list|(
name|decodeInputs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|alignedStripe
operator|.
name|chunks
index|[
name|i
index|]
operator|.
name|offsetsInBuf
operator|.
name|add
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|alignedStripe
operator|.
name|chunks
index|[
name|i
index|]
operator|.
name|lengthsInBuf
operator|.
name|add
argument_list|(
operator|(
name|int
operator|)
name|alignedStripe
operator|.
name|getSpanInBlock
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|chunk
operator|.
name|state
operator|==
name|StripingChunk
operator|.
name|FETCHED
condition|)
block|{
name|int
name|posInBuf
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|chunk
operator|.
name|offsetsInBuf
operator|.
name|size
argument_list|()
condition|;
name|j
operator|++
control|)
block|{
name|System
operator|.
name|arraycopy
argument_list|(
name|chunk
operator|.
name|buf
argument_list|,
name|chunk
operator|.
name|offsetsInBuf
operator|.
name|get
argument_list|(
name|j
argument_list|)
argument_list|,
name|decodeInputs
index|[
name|i
index|]
argument_list|,
name|posInBuf
argument_list|,
name|chunk
operator|.
name|lengthsInBuf
operator|.
name|get
argument_list|(
name|j
argument_list|)
argument_list|)
expr_stmt|;
name|posInBuf
operator|+=
name|chunk
operator|.
name|lengthsInBuf
operator|.
name|get
argument_list|(
name|j
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|chunk
operator|.
name|state
operator|==
name|StripingChunk
operator|.
name|ALLZERO
condition|)
block|{
name|Arrays
operator|.
name|fill
argument_list|(
name|decodeInputs
index|[
name|i
index|]
argument_list|,
operator|(
name|byte
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|decodeInputs
return|;
block|}
comment|/**    * Decode based on the given input buffers and schema    */
DECL|method|decodeAndFillBuffer (final byte[][] decodeInputs, byte[] buf, AlignedStripe alignedStripe, int dataBlkNum, int parityBlkNum)
specifier|public
specifier|static
name|void
name|decodeAndFillBuffer
parameter_list|(
specifier|final
name|byte
index|[]
index|[]
name|decodeInputs
parameter_list|,
name|byte
index|[]
name|buf
parameter_list|,
name|AlignedStripe
name|alignedStripe
parameter_list|,
name|int
name|dataBlkNum
parameter_list|,
name|int
name|parityBlkNum
parameter_list|)
block|{
name|int
index|[]
name|decodeIndices
init|=
operator|new
name|int
index|[
name|parityBlkNum
index|]
decl_stmt|;
name|int
name|pos
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|alignedStripe
operator|.
name|chunks
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|alignedStripe
operator|.
name|chunks
index|[
name|i
index|]
operator|.
name|state
operator|!=
name|StripingChunk
operator|.
name|FETCHED
operator|&&
name|alignedStripe
operator|.
name|chunks
index|[
name|i
index|]
operator|.
name|state
operator|!=
name|StripingChunk
operator|.
name|ALLZERO
condition|)
block|{
name|decodeIndices
index|[
name|pos
operator|++
index|]
operator|=
name|i
expr_stmt|;
block|}
block|}
name|byte
index|[]
index|[]
name|outputs
init|=
operator|new
name|byte
index|[
name|parityBlkNum
index|]
index|[
operator|(
name|int
operator|)
name|alignedStripe
operator|.
name|getSpanInBlock
argument_list|()
index|]
decl_stmt|;
name|RSRawDecoder
name|rsRawDecoder
init|=
operator|new
name|RSRawDecoder
argument_list|()
decl_stmt|;
name|rsRawDecoder
operator|.
name|initialize
argument_list|(
name|dataBlkNum
argument_list|,
name|parityBlkNum
argument_list|,
operator|(
name|int
operator|)
name|alignedStripe
operator|.
name|getSpanInBlock
argument_list|()
argument_list|)
expr_stmt|;
name|rsRawDecoder
operator|.
name|decode
argument_list|(
name|decodeInputs
argument_list|,
name|decodeIndices
argument_list|,
name|outputs
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|dataBlkNum
operator|+
name|parityBlkNum
condition|;
name|i
operator|++
control|)
block|{
name|StripingChunk
name|chunk
init|=
name|alignedStripe
operator|.
name|chunks
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|chunk
operator|.
name|state
operator|==
name|StripingChunk
operator|.
name|MISSING
condition|)
block|{
name|int
name|srcPos
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|chunk
operator|.
name|offsetsInBuf
operator|.
name|size
argument_list|()
condition|;
name|j
operator|++
control|)
block|{
comment|//TODO: workaround (filling fixed bytes), to remove after HADOOP-11938
comment|//          System.arraycopy(outputs[i], srcPos, buf, chunk.offsetsInBuf.get(j),
comment|//              chunk.lengthsInBuf.get(j));
name|Arrays
operator|.
name|fill
argument_list|(
name|buf
argument_list|,
name|chunk
operator|.
name|offsetsInBuf
operator|.
name|get
argument_list|(
name|j
argument_list|)
argument_list|,
name|chunk
operator|.
name|offsetsInBuf
operator|.
name|get
argument_list|(
name|j
argument_list|)
operator|+
name|chunk
operator|.
name|lengthsInBuf
operator|.
name|get
argument_list|(
name|j
argument_list|)
argument_list|,
operator|(
name|byte
operator|)
literal|7
argument_list|)
expr_stmt|;
name|srcPos
operator|+=
name|chunk
operator|.
name|lengthsInBuf
operator|.
name|get
argument_list|(
name|j
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**    * This method divides a requested byte range into an array of    * {@link AlignedStripe}    *    *    * At most 5 stripes will be generated from each logical range    * TODO: cleanup and get rid of planReadPortions    */
DECL|method|divideByteRangeIntoStripes ( ECSchema ecSchema, LocatedStripedBlock blockGroup, long start, long end, byte[] buf, int offsetInBuf)
specifier|public
specifier|static
name|AlignedStripe
index|[]
name|divideByteRangeIntoStripes
parameter_list|(
name|ECSchema
name|ecSchema
parameter_list|,
name|LocatedStripedBlock
name|blockGroup
parameter_list|,
name|long
name|start
parameter_list|,
name|long
name|end
parameter_list|,
name|byte
index|[]
name|buf
parameter_list|,
name|int
name|offsetInBuf
parameter_list|)
block|{
comment|// TODO: change ECSchema naming to use cell size instead of chunk size
comment|// Step 0: analyze range and calculate basic parameters
name|int
name|cellSize
init|=
name|ecSchema
operator|.
name|getChunkSize
argument_list|()
decl_stmt|;
name|int
name|dataBlkNum
init|=
name|ecSchema
operator|.
name|getNumDataUnits
argument_list|()
decl_stmt|;
name|int
name|len
init|=
call|(
name|int
call|)
argument_list|(
name|end
operator|-
name|start
operator|+
literal|1
argument_list|)
decl_stmt|;
name|int
name|firstCellIdxInBG
init|=
call|(
name|int
call|)
argument_list|(
name|start
operator|/
name|cellSize
argument_list|)
decl_stmt|;
name|int
name|lastCellIdxInBG
init|=
call|(
name|int
call|)
argument_list|(
name|end
operator|/
name|cellSize
argument_list|)
decl_stmt|;
name|int
name|firstCellSize
init|=
name|Math
operator|.
name|min
argument_list|(
name|cellSize
operator|-
call|(
name|int
call|)
argument_list|(
name|start
operator|%
name|cellSize
argument_list|)
argument_list|,
name|len
argument_list|)
decl_stmt|;
name|long
name|firstCellOffsetInBlk
init|=
name|start
operator|%
name|cellSize
decl_stmt|;
name|int
name|lastCellSize
init|=
name|lastCellIdxInBG
operator|==
name|firstCellIdxInBG
condition|?
name|firstCellSize
else|:
call|(
name|int
call|)
argument_list|(
name|end
operator|%
name|cellSize
argument_list|)
operator|+
literal|1
decl_stmt|;
comment|// Step 1: get the unmerged ranges on each internal block
comment|// TODO: StripingCell should carry info on size and start offset (HDFS-8320)
name|VerticalRange
index|[]
name|ranges
init|=
name|getRangesForInternalBlocks
argument_list|(
name|ecSchema
argument_list|,
name|firstCellIdxInBG
argument_list|,
name|lastCellIdxInBG
argument_list|,
name|firstCellSize
argument_list|,
name|firstCellOffsetInBlk
argument_list|,
name|lastCellSize
argument_list|)
decl_stmt|;
comment|// Step 2: merge into at most 5 stripes
name|AlignedStripe
index|[]
name|stripes
init|=
name|mergeRangesForInternalBlocks
argument_list|(
name|ecSchema
argument_list|,
name|ranges
argument_list|)
decl_stmt|;
comment|// Step 3: calculate each chunk's position in destination buffer
name|calcualteChunkPositionsInBuf
argument_list|(
name|ecSchema
argument_list|,
name|blockGroup
argument_list|,
name|buf
argument_list|,
name|offsetInBuf
argument_list|,
name|firstCellIdxInBG
argument_list|,
name|lastCellIdxInBG
argument_list|,
name|firstCellSize
argument_list|,
name|firstCellOffsetInBlk
argument_list|,
name|lastCellSize
argument_list|,
name|stripes
argument_list|)
expr_stmt|;
comment|// Step 4: prepare ALLZERO blocks
name|prepareAllZeroChunks
argument_list|(
name|blockGroup
argument_list|,
name|buf
argument_list|,
name|stripes
argument_list|,
name|cellSize
argument_list|,
name|dataBlkNum
argument_list|)
expr_stmt|;
return|return
name|stripes
return|;
block|}
DECL|method|getRangesForInternalBlocks (ECSchema ecSchema, int firstCellIdxInBG, int lastCellIdxInBG, int firstCellSize, long firstCellOffsetInBlk, int lastCellSize)
specifier|private
specifier|static
name|VerticalRange
index|[]
name|getRangesForInternalBlocks
parameter_list|(
name|ECSchema
name|ecSchema
parameter_list|,
name|int
name|firstCellIdxInBG
parameter_list|,
name|int
name|lastCellIdxInBG
parameter_list|,
name|int
name|firstCellSize
parameter_list|,
name|long
name|firstCellOffsetInBlk
parameter_list|,
name|int
name|lastCellSize
parameter_list|)
block|{
name|int
name|cellSize
init|=
name|ecSchema
operator|.
name|getChunkSize
argument_list|()
decl_stmt|;
name|int
name|dataBlkNum
init|=
name|ecSchema
operator|.
name|getNumDataUnits
argument_list|()
decl_stmt|;
name|StripingCell
name|firstCell
init|=
operator|new
name|StripingCell
argument_list|(
name|ecSchema
argument_list|,
name|firstCellIdxInBG
argument_list|)
decl_stmt|;
name|StripingCell
name|lastCell
init|=
operator|new
name|StripingCell
argument_list|(
name|ecSchema
argument_list|,
name|lastCellIdxInBG
argument_list|)
decl_stmt|;
name|VerticalRange
name|ranges
index|[]
init|=
operator|new
name|VerticalRange
index|[
name|dataBlkNum
index|]
decl_stmt|;
name|ranges
index|[
name|firstCell
operator|.
name|idxInStripe
index|]
operator|=
operator|new
name|VerticalRange
argument_list|(
name|firstCellOffsetInBlk
argument_list|,
name|firstCellSize
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
name|firstCellIdxInBG
operator|+
literal|1
init|;
name|i
operator|<
name|lastCellIdxInBG
condition|;
name|i
operator|++
control|)
block|{
comment|// iterate through all cells and update the list of StripeRanges
name|StripingCell
name|cell
init|=
operator|new
name|StripingCell
argument_list|(
name|ecSchema
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|ranges
index|[
name|cell
operator|.
name|idxInStripe
index|]
operator|==
literal|null
condition|)
block|{
name|ranges
index|[
name|cell
operator|.
name|idxInStripe
index|]
operator|=
operator|new
name|VerticalRange
argument_list|(
name|cell
operator|.
name|idxInInternalBlk
operator|*
name|cellSize
argument_list|,
name|cellSize
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ranges
index|[
name|cell
operator|.
name|idxInStripe
index|]
operator|.
name|spanInBlock
operator|+=
name|cellSize
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ranges
index|[
name|lastCell
operator|.
name|idxInStripe
index|]
operator|==
literal|null
condition|)
block|{
name|ranges
index|[
name|lastCell
operator|.
name|idxInStripe
index|]
operator|=
operator|new
name|VerticalRange
argument_list|(
name|lastCell
operator|.
name|idxInInternalBlk
operator|*
name|cellSize
argument_list|,
name|lastCellSize
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lastCell
operator|.
name|idxInBlkGroup
operator|!=
name|firstCell
operator|.
name|idxInBlkGroup
condition|)
block|{
name|ranges
index|[
name|lastCell
operator|.
name|idxInStripe
index|]
operator|.
name|spanInBlock
operator|+=
name|lastCellSize
expr_stmt|;
block|}
return|return
name|ranges
return|;
block|}
DECL|method|mergeRangesForInternalBlocks (ECSchema ecSchema, VerticalRange[] ranges)
specifier|private
specifier|static
name|AlignedStripe
index|[]
name|mergeRangesForInternalBlocks
parameter_list|(
name|ECSchema
name|ecSchema
parameter_list|,
name|VerticalRange
index|[]
name|ranges
parameter_list|)
block|{
name|int
name|dataBlkNum
init|=
name|ecSchema
operator|.
name|getNumDataUnits
argument_list|()
decl_stmt|;
name|int
name|parityBlkNum
init|=
name|ecSchema
operator|.
name|getNumParityUnits
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|AlignedStripe
argument_list|>
name|stripes
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|SortedSet
argument_list|<
name|Long
argument_list|>
name|stripePoints
init|=
operator|new
name|TreeSet
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|VerticalRange
name|r
range|:
name|ranges
control|)
block|{
if|if
condition|(
name|r
operator|!=
literal|null
condition|)
block|{
name|stripePoints
operator|.
name|add
argument_list|(
name|r
operator|.
name|offsetInBlock
argument_list|)
expr_stmt|;
name|stripePoints
operator|.
name|add
argument_list|(
name|r
operator|.
name|offsetInBlock
operator|+
name|r
operator|.
name|spanInBlock
argument_list|)
expr_stmt|;
block|}
block|}
name|long
name|prev
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|long
name|point
range|:
name|stripePoints
control|)
block|{
if|if
condition|(
name|prev
operator|>=
literal|0
condition|)
block|{
name|stripes
operator|.
name|add
argument_list|(
operator|new
name|AlignedStripe
argument_list|(
name|prev
argument_list|,
name|point
operator|-
name|prev
argument_list|,
name|dataBlkNum
operator|+
name|parityBlkNum
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|prev
operator|=
name|point
expr_stmt|;
block|}
return|return
name|stripes
operator|.
name|toArray
argument_list|(
operator|new
name|AlignedStripe
index|[
name|stripes
operator|.
name|size
argument_list|()
index|]
argument_list|)
return|;
block|}
DECL|method|calcualteChunkPositionsInBuf (ECSchema ecSchema, LocatedStripedBlock blockGroup, byte[] buf, int offsetInBuf, int firstCellIdxInBG, int lastCellIdxInBG, int firstCellSize, long firstCellOffsetInBlk, int lastCellSize, AlignedStripe[] stripes)
specifier|private
specifier|static
name|void
name|calcualteChunkPositionsInBuf
parameter_list|(
name|ECSchema
name|ecSchema
parameter_list|,
name|LocatedStripedBlock
name|blockGroup
parameter_list|,
name|byte
index|[]
name|buf
parameter_list|,
name|int
name|offsetInBuf
parameter_list|,
name|int
name|firstCellIdxInBG
parameter_list|,
name|int
name|lastCellIdxInBG
parameter_list|,
name|int
name|firstCellSize
parameter_list|,
name|long
name|firstCellOffsetInBlk
parameter_list|,
name|int
name|lastCellSize
parameter_list|,
name|AlignedStripe
index|[]
name|stripes
parameter_list|)
block|{
name|int
name|cellSize
init|=
name|ecSchema
operator|.
name|getChunkSize
argument_list|()
decl_stmt|;
name|int
name|dataBlkNum
init|=
name|ecSchema
operator|.
name|getNumDataUnits
argument_list|()
decl_stmt|;
comment|// Step 3: calculate each chunk's position in destination buffer
comment|/**      *     |<--------------- AlignedStripe --------------->|      *      *     |<- length_0 ->|<--  length_1  -->|<- length_2 ->|      * +------------------+------------------+----------------+      * |    cell_0_0_0    |    cell_3_1_0    |   cell_6_2_0   |<- blk_0      * +------------------+------------------+----------------+      *   _/                \_______________________      *  |                                          |      *  v offset_0                                 v offset_1      * +----------------------------------------------------------+      * |  cell_0_0_0 |  cell_1_0_1 and cell_2_0_2  |cell_3_1_0 ...|<- buf      * |  (partial)  |    (from blk_1 and blk_2)   |              |      * +----------------------------------------------------------+      *      * Cell indexing convention defined in {@link StripingCell}      */
name|int
name|done
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|firstCellIdxInBG
init|;
name|i
operator|<=
name|lastCellIdxInBG
condition|;
name|i
operator|++
control|)
block|{
name|StripingCell
name|cell
init|=
operator|new
name|StripingCell
argument_list|(
name|ecSchema
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|long
name|cellStart
init|=
name|i
operator|==
name|firstCellIdxInBG
condition|?
name|firstCellOffsetInBlk
else|:
name|cell
operator|.
name|idxInInternalBlk
operator|*
name|cellSize
decl_stmt|;
name|int
name|cellLen
decl_stmt|;
if|if
condition|(
name|i
operator|==
name|firstCellIdxInBG
condition|)
block|{
name|cellLen
operator|=
name|firstCellSize
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|==
name|lastCellIdxInBG
condition|)
block|{
name|cellLen
operator|=
name|lastCellSize
expr_stmt|;
block|}
else|else
block|{
name|cellLen
operator|=
name|cellSize
expr_stmt|;
block|}
name|long
name|cellEnd
init|=
name|cellStart
operator|+
name|cellLen
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|AlignedStripe
name|s
range|:
name|stripes
control|)
block|{
name|long
name|stripeEnd
init|=
name|s
operator|.
name|getOffsetInBlock
argument_list|()
operator|+
name|s
operator|.
name|getSpanInBlock
argument_list|()
operator|-
literal|1
decl_stmt|;
name|long
name|overlapStart
init|=
name|Math
operator|.
name|max
argument_list|(
name|cellStart
argument_list|,
name|s
operator|.
name|getOffsetInBlock
argument_list|()
argument_list|)
decl_stmt|;
name|long
name|overlapEnd
init|=
name|Math
operator|.
name|min
argument_list|(
name|cellEnd
argument_list|,
name|stripeEnd
argument_list|)
decl_stmt|;
name|int
name|overLapLen
init|=
call|(
name|int
call|)
argument_list|(
name|overlapEnd
operator|-
name|overlapStart
operator|+
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|overLapLen
operator|<=
literal|0
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|s
operator|.
name|chunks
index|[
name|cell
operator|.
name|idxInStripe
index|]
operator|==
literal|null
condition|)
block|{
name|s
operator|.
name|chunks
index|[
name|cell
operator|.
name|idxInStripe
index|]
operator|=
operator|new
name|StripingChunk
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
name|s
operator|.
name|chunks
index|[
name|cell
operator|.
name|idxInStripe
index|]
operator|.
name|offsetsInBuf
operator|.
name|add
argument_list|(
call|(
name|int
call|)
argument_list|(
name|offsetInBuf
operator|+
name|done
operator|+
name|overlapStart
operator|-
name|cellStart
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|.
name|chunks
index|[
name|cell
operator|.
name|idxInStripe
index|]
operator|.
name|lengthsInBuf
operator|.
name|add
argument_list|(
name|overLapLen
argument_list|)
expr_stmt|;
block|}
name|done
operator|+=
name|cellLen
expr_stmt|;
block|}
block|}
DECL|method|prepareAllZeroChunks (LocatedStripedBlock blockGroup, byte[] buf, AlignedStripe[] stripes, int cellSize, int dataBlkNum)
specifier|private
specifier|static
name|void
name|prepareAllZeroChunks
parameter_list|(
name|LocatedStripedBlock
name|blockGroup
parameter_list|,
name|byte
index|[]
name|buf
parameter_list|,
name|AlignedStripe
index|[]
name|stripes
parameter_list|,
name|int
name|cellSize
parameter_list|,
name|int
name|dataBlkNum
parameter_list|)
block|{
for|for
control|(
name|AlignedStripe
name|s
range|:
name|stripes
control|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|dataBlkNum
condition|;
name|i
operator|++
control|)
block|{
name|long
name|internalBlkLen
init|=
name|getInternalBlockLength
argument_list|(
name|blockGroup
operator|.
name|getBlockSize
argument_list|()
argument_list|,
name|cellSize
argument_list|,
name|dataBlkNum
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|internalBlkLen
operator|<=
name|s
operator|.
name|getOffsetInBlock
argument_list|()
condition|)
block|{
name|Preconditions
operator|.
name|checkState
argument_list|(
name|s
operator|.
name|chunks
index|[
name|i
index|]
operator|==
literal|null
argument_list|)
expr_stmt|;
name|s
operator|.
name|chunks
index|[
name|i
index|]
operator|=
operator|new
name|StripingChunk
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|s
operator|.
name|chunks
index|[
name|i
index|]
operator|.
name|state
operator|=
name|StripingChunk
operator|.
name|ALLZERO
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**    * This class represents the portion of I/O associated with each block in the    * striped block group.    * TODO: consolidate ReadPortion with AlignedStripe    */
DECL|class|ReadPortion
specifier|public
specifier|static
class|class
name|ReadPortion
block|{
DECL|field|startOffsetInBlock
specifier|private
name|long
name|startOffsetInBlock
init|=
literal|0
decl_stmt|;
DECL|field|readLength
specifier|private
name|int
name|readLength
init|=
literal|0
decl_stmt|;
DECL|field|offsetsInBuf
specifier|public
specifier|final
name|List
argument_list|<
name|Integer
argument_list|>
name|offsetsInBuf
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|lengths
specifier|public
specifier|final
name|List
argument_list|<
name|Integer
argument_list|>
name|lengths
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
DECL|method|getOffsets ()
specifier|public
name|int
index|[]
name|getOffsets
parameter_list|()
block|{
name|int
index|[]
name|offsets
init|=
operator|new
name|int
index|[
name|offsetsInBuf
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|offsets
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|offsets
index|[
name|i
index|]
operator|=
name|offsetsInBuf
operator|.
name|get
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
return|return
name|offsets
return|;
block|}
DECL|method|getLengths ()
specifier|public
name|int
index|[]
name|getLengths
parameter_list|()
block|{
name|int
index|[]
name|lens
init|=
operator|new
name|int
index|[
name|this
operator|.
name|lengths
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|lens
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|lens
index|[
name|i
index|]
operator|=
name|this
operator|.
name|lengths
operator|.
name|get
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
return|return
name|lens
return|;
block|}
DECL|method|getStartOffsetInBlock ()
specifier|public
name|long
name|getStartOffsetInBlock
parameter_list|()
block|{
return|return
name|startOffsetInBlock
return|;
block|}
DECL|method|getReadLength ()
specifier|public
name|int
name|getReadLength
parameter_list|()
block|{
return|return
name|readLength
return|;
block|}
DECL|method|setStartOffsetInBlock (long startOffsetInBlock)
specifier|public
name|void
name|setStartOffsetInBlock
parameter_list|(
name|long
name|startOffsetInBlock
parameter_list|)
block|{
name|this
operator|.
name|startOffsetInBlock
operator|=
name|startOffsetInBlock
expr_stmt|;
block|}
DECL|method|addReadLength (int extraLength)
name|void
name|addReadLength
parameter_list|(
name|int
name|extraLength
parameter_list|)
block|{
name|this
operator|.
name|readLength
operator|+=
name|extraLength
expr_stmt|;
block|}
block|}
comment|/**    * The unit of encoding used in {@link DFSStripedOutputStream}    *  |<------- Striped Block Group -------> |    *    blk_0          blk_1          blk_2    *      |              |              |    *      v              v              v    * +----------+   +----------+   +----------+    * |cell_0_0_0|   |cell_1_0_1|   |cell_2_0_2|    * +----------+   +----------+   +----------+    * |cell_3_1_0|   |cell_4_1_1|   |cell_5_1_2|<- {@link idxInBlkGroup} = 5    * +----------+   +----------+   +----------+    {@link idxInInternalBlk} = 1    *                                               {@link idxInStripe} = 2    * A StripingCell is a special instance of {@link StripingChunk} whose offset    * and size align with the cell used when writing data.    * TODO: consider parity cells    */
DECL|class|StripingCell
specifier|public
specifier|static
class|class
name|StripingCell
block|{
DECL|field|schema
specifier|public
specifier|final
name|ECSchema
name|schema
decl_stmt|;
comment|/** Logical order in a block group, used when doing I/O to a block group */
DECL|field|idxInBlkGroup
specifier|public
specifier|final
name|int
name|idxInBlkGroup
decl_stmt|;
DECL|field|idxInInternalBlk
specifier|public
specifier|final
name|int
name|idxInInternalBlk
decl_stmt|;
DECL|field|idxInStripe
specifier|public
specifier|final
name|int
name|idxInStripe
decl_stmt|;
DECL|method|StripingCell (ECSchema ecSchema, int idxInBlkGroup)
specifier|public
name|StripingCell
parameter_list|(
name|ECSchema
name|ecSchema
parameter_list|,
name|int
name|idxInBlkGroup
parameter_list|)
block|{
name|this
operator|.
name|schema
operator|=
name|ecSchema
expr_stmt|;
name|this
operator|.
name|idxInBlkGroup
operator|=
name|idxInBlkGroup
expr_stmt|;
name|this
operator|.
name|idxInInternalBlk
operator|=
name|idxInBlkGroup
operator|/
name|ecSchema
operator|.
name|getNumDataUnits
argument_list|()
expr_stmt|;
name|this
operator|.
name|idxInStripe
operator|=
name|idxInBlkGroup
operator|-
name|this
operator|.
name|idxInInternalBlk
operator|*
name|ecSchema
operator|.
name|getNumDataUnits
argument_list|()
expr_stmt|;
block|}
DECL|method|StripingCell (ECSchema ecSchema, int idxInInternalBlk, int idxInStripe)
specifier|public
name|StripingCell
parameter_list|(
name|ECSchema
name|ecSchema
parameter_list|,
name|int
name|idxInInternalBlk
parameter_list|,
name|int
name|idxInStripe
parameter_list|)
block|{
name|this
operator|.
name|schema
operator|=
name|ecSchema
expr_stmt|;
name|this
operator|.
name|idxInInternalBlk
operator|=
name|idxInInternalBlk
expr_stmt|;
name|this
operator|.
name|idxInStripe
operator|=
name|idxInStripe
expr_stmt|;
name|this
operator|.
name|idxInBlkGroup
operator|=
name|idxInInternalBlk
operator|*
name|ecSchema
operator|.
name|getNumDataUnits
argument_list|()
operator|+
name|idxInStripe
expr_stmt|;
block|}
block|}
comment|/**    * Given a requested byte range on a striped block group, an AlignedStripe    * represents a {@link VerticalRange} that is aligned with both the byte range    * and boundaries of all internal blocks. As illustrated in the diagram, any    * given byte range on a block group leads to 1~5 AlignedStripe's.    *    * |<-------- Striped Block Group -------->|    * blk_0   blk_1   blk_2      blk_3   blk_4    *                 +----+  |  +----+  +----+    *                 |full|  |  |    |  |    |<- AlignedStripe0:    *         +----+  |~~~~|  |  |~~~~|  |~~~~|      1st cell is partial    *         |part|  |    |  |  |    |  |    |<- AlignedStripe1: byte range    * +----+  +----+  +----+  |  |~~~~|  |~~~~|      doesn't start at 1st block    * |full|  |full|  |full|  |  |    |  |    |    * |cell|  |cell|  |cell|  |  |    |  |    |<- AlignedStripe2 (full stripe)    * |    |  |    |  |    |  |  |    |  |    |    * +----+  +----+  +----+  |  |~~~~|  |~~~~|    * |full|  |part|          |  |    |  |    |<- AlignedStripe3: byte range    * |~~~~|  +----+          |  |~~~~|  |~~~~|      doesn't end at last block    * |    |                  |  |    |  |    |<- AlignedStripe4:    * +----+                  |  +----+  +----+      last cell is partial    *                         |    *<---- data blocks ----> |<--- parity --->    *    * An AlignedStripe is the basic unit of reading from a striped block group,    * because within the AlignedStripe, all internal blocks can be processed in    * a uniform manner.    *    * The coverage of an AlignedStripe on an internal block is represented as a    * {@link StripingChunk}.    * To simplify the logic of reading a logical byte range from a block group,    * a StripingChunk is either completely in the requested byte range or    * completely outside the requested byte range.    */
DECL|class|AlignedStripe
specifier|public
specifier|static
class|class
name|AlignedStripe
block|{
DECL|field|range
specifier|public
name|VerticalRange
name|range
decl_stmt|;
comment|/** status of each chunk in the stripe */
DECL|field|chunks
specifier|public
specifier|final
name|StripingChunk
index|[]
name|chunks
decl_stmt|;
DECL|field|fetchedChunksNum
specifier|public
name|int
name|fetchedChunksNum
init|=
literal|0
decl_stmt|;
DECL|field|missingChunksNum
specifier|public
name|int
name|missingChunksNum
init|=
literal|0
decl_stmt|;
DECL|method|AlignedStripe (long offsetInBlock, long length, int width)
specifier|public
name|AlignedStripe
parameter_list|(
name|long
name|offsetInBlock
parameter_list|,
name|long
name|length
parameter_list|,
name|int
name|width
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|offsetInBlock
operator|>=
literal|0
operator|&&
name|length
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|this
operator|.
name|range
operator|=
operator|new
name|VerticalRange
argument_list|(
name|offsetInBlock
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|this
operator|.
name|chunks
operator|=
operator|new
name|StripingChunk
index|[
name|width
index|]
expr_stmt|;
block|}
DECL|method|AlignedStripe (VerticalRange range, int width)
specifier|public
name|AlignedStripe
parameter_list|(
name|VerticalRange
name|range
parameter_list|,
name|int
name|width
parameter_list|)
block|{
name|this
operator|.
name|range
operator|=
name|range
expr_stmt|;
name|this
operator|.
name|chunks
operator|=
operator|new
name|StripingChunk
index|[
name|width
index|]
expr_stmt|;
block|}
DECL|method|include (long pos)
specifier|public
name|boolean
name|include
parameter_list|(
name|long
name|pos
parameter_list|)
block|{
return|return
name|range
operator|.
name|include
argument_list|(
name|pos
argument_list|)
return|;
block|}
DECL|method|getOffsetInBlock ()
specifier|public
name|long
name|getOffsetInBlock
parameter_list|()
block|{
return|return
name|range
operator|.
name|offsetInBlock
return|;
block|}
DECL|method|getSpanInBlock ()
specifier|public
name|long
name|getSpanInBlock
parameter_list|()
block|{
return|return
name|range
operator|.
name|spanInBlock
return|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"Offset="
operator|+
name|range
operator|.
name|offsetInBlock
operator|+
literal|", length="
operator|+
name|range
operator|.
name|spanInBlock
operator|+
literal|", fetchedChunksNum="
operator|+
name|fetchedChunksNum
operator|+
literal|", missingChunksNum="
operator|+
name|missingChunksNum
return|;
block|}
block|}
comment|/**    * A simple utility class representing an arbitrary vertical inclusive range    * starting at {@link offsetInBlock} and lasting for {@link length} bytes in    * an internal block. Note that VerticalRange doesn't necessarily align with    * {@link StripingCell}.    *    * |<- Striped Block Group ->|    *  blk_0    *    |    *    v    * +-----+    * |~~~~~|<-- {@link offsetInBlock}    * |     |  ^    * |     |  |    * |     |  | {@link spanInBlock}    * |     |  v    * |~~~~~| ---    * |     |    * +-----+    */
DECL|class|VerticalRange
specifier|public
specifier|static
class|class
name|VerticalRange
block|{
comment|/** start offset in the block group (inclusive) */
DECL|field|offsetInBlock
specifier|public
name|long
name|offsetInBlock
decl_stmt|;
comment|/** length of the stripe range */
DECL|field|spanInBlock
specifier|public
name|long
name|spanInBlock
decl_stmt|;
DECL|method|VerticalRange (long offsetInBlock, long length)
specifier|public
name|VerticalRange
parameter_list|(
name|long
name|offsetInBlock
parameter_list|,
name|long
name|length
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|offsetInBlock
operator|>=
literal|0
operator|&&
name|length
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|this
operator|.
name|offsetInBlock
operator|=
name|offsetInBlock
expr_stmt|;
name|this
operator|.
name|spanInBlock
operator|=
name|length
expr_stmt|;
block|}
comment|/** whether a position is in the range */
DECL|method|include (long pos)
specifier|public
name|boolean
name|include
parameter_list|(
name|long
name|pos
parameter_list|)
block|{
return|return
name|pos
operator|>=
name|offsetInBlock
operator|&&
name|pos
operator|<
name|offsetInBlock
operator|+
name|spanInBlock
return|;
block|}
block|}
comment|/**    * Indicates the coverage of an {@link AlignedStripe} on an internal block,    * and the state of the chunk in the context of the read request.    *    * |<---------------- Striped Block Group --------------->|    *   blk_0        blk_1        blk_2          blk_3   blk_4    *                           +---------+  |  +----+  +----+    *     null         null     |REQUESTED|  |  |null|  |null|<- AlignedStripe0    *              +---------+  |---------|  |  |----|  |----|    *     null     |REQUESTED|  |REQUESTED|  |  |null|  |null|<- AlignedStripe1    * +---------+  +---------+  +---------+  |  +----+  +----+    * |REQUESTED|  |REQUESTED|    ALLZERO    |  |null|  |null|<- AlignedStripe2    * +---------+  +---------+               |  +----+  +----+    *<----------- data blocks ------------> |<--- parity --->    *    * The class also carries {@link buf}, {@link offsetsInBuf}, and    * {@link lengthsInBuf} to define how read task for this chunk should deliver    * the returned data.    */
DECL|class|StripingChunk
specifier|public
specifier|static
class|class
name|StripingChunk
block|{
comment|/** Chunk has been successfully fetched */
DECL|field|FETCHED
specifier|public
specifier|static
specifier|final
name|int
name|FETCHED
init|=
literal|0x01
decl_stmt|;
comment|/** Chunk has encountered failed when being fetched */
DECL|field|MISSING
specifier|public
specifier|static
specifier|final
name|int
name|MISSING
init|=
literal|0x02
decl_stmt|;
comment|/** Chunk being fetched (fetching task is in-flight) */
DECL|field|PENDING
specifier|public
specifier|static
specifier|final
name|int
name|PENDING
init|=
literal|0x04
decl_stmt|;
comment|/**      * Chunk is requested either by application or for decoding, need to      * schedule read task      */
DECL|field|REQUESTED
specifier|public
specifier|static
specifier|final
name|int
name|REQUESTED
init|=
literal|0X08
decl_stmt|;
comment|/**      * Internal block is short and has no overlap with chunk. Chunk considered      * all-zero bytes in codec calculations.      */
DECL|field|ALLZERO
specifier|public
specifier|static
specifier|final
name|int
name|ALLZERO
init|=
literal|0X0f
decl_stmt|;
comment|/**      * If a chunk is completely in requested range, the state transition is:      * REQUESTED (when AlignedStripe created) -> PENDING -> {FETCHED | MISSING}      * If a chunk is completely outside requested range (including parity      * chunks), state transition is:      * null (AlignedStripe created) -> REQUESTED (upon failure) -> PENDING ...      */
DECL|field|state
specifier|public
name|int
name|state
init|=
name|REQUESTED
decl_stmt|;
DECL|field|buf
specifier|public
name|byte
index|[]
name|buf
decl_stmt|;
DECL|field|offsetsInBuf
specifier|public
name|List
argument_list|<
name|Integer
argument_list|>
name|offsetsInBuf
decl_stmt|;
DECL|field|lengthsInBuf
specifier|public
name|List
argument_list|<
name|Integer
argument_list|>
name|lengthsInBuf
decl_stmt|;
DECL|method|StripingChunk (byte[] buf)
specifier|public
name|StripingChunk
parameter_list|(
name|byte
index|[]
name|buf
parameter_list|)
block|{
name|this
operator|.
name|buf
operator|=
name|buf
expr_stmt|;
name|this
operator|.
name|offsetsInBuf
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
expr_stmt|;
name|this
operator|.
name|lengthsInBuf
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
expr_stmt|;
block|}
DECL|method|getOffsets ()
specifier|public
name|int
index|[]
name|getOffsets
parameter_list|()
block|{
name|int
index|[]
name|offsets
init|=
operator|new
name|int
index|[
name|offsetsInBuf
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|offsets
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|offsets
index|[
name|i
index|]
operator|=
name|offsetsInBuf
operator|.
name|get
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
return|return
name|offsets
return|;
block|}
DECL|method|getLengths ()
specifier|public
name|int
index|[]
name|getLengths
parameter_list|()
block|{
name|int
index|[]
name|lens
init|=
operator|new
name|int
index|[
name|this
operator|.
name|lengthsInBuf
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|lens
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|lens
index|[
name|i
index|]
operator|=
name|this
operator|.
name|lengthsInBuf
operator|.
name|get
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
return|return
name|lens
return|;
block|}
block|}
comment|/**    * This class represents result from a striped read request.    * If the task was successful or the internal computation failed,    * an index is also returned.    */
DECL|class|StripingChunkReadResult
specifier|public
specifier|static
class|class
name|StripingChunkReadResult
block|{
DECL|field|SUCCESSFUL
specifier|public
specifier|static
specifier|final
name|int
name|SUCCESSFUL
init|=
literal|0x01
decl_stmt|;
DECL|field|FAILED
specifier|public
specifier|static
specifier|final
name|int
name|FAILED
init|=
literal|0x02
decl_stmt|;
DECL|field|TIMEOUT
specifier|public
specifier|static
specifier|final
name|int
name|TIMEOUT
init|=
literal|0x04
decl_stmt|;
DECL|field|CANCELLED
specifier|public
specifier|static
specifier|final
name|int
name|CANCELLED
init|=
literal|0x08
decl_stmt|;
DECL|field|index
specifier|public
specifier|final
name|int
name|index
decl_stmt|;
DECL|field|state
specifier|public
specifier|final
name|int
name|state
decl_stmt|;
DECL|method|StripingChunkReadResult (int state)
specifier|public
name|StripingChunkReadResult
parameter_list|(
name|int
name|state
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|state
operator|==
name|TIMEOUT
argument_list|,
literal|"Only timeout result should return negative index."
argument_list|)
expr_stmt|;
name|this
operator|.
name|index
operator|=
operator|-
literal|1
expr_stmt|;
name|this
operator|.
name|state
operator|=
name|state
expr_stmt|;
block|}
DECL|method|StripingChunkReadResult (int index, int state)
specifier|public
name|StripingChunkReadResult
parameter_list|(
name|int
name|index
parameter_list|,
name|int
name|state
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|state
operator|!=
name|TIMEOUT
argument_list|,
literal|"Timeout result should return negative index."
argument_list|)
expr_stmt|;
name|this
operator|.
name|index
operator|=
name|index
expr_stmt|;
name|this
operator|.
name|state
operator|=
name|state
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"(index="
operator|+
name|index
operator|+
literal|", state ="
operator|+
name|state
operator|+
literal|")"
return|;
block|}
block|}
block|}
end_class

end_unit

