begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdfs.util
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|util
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Random
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Callable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutorService
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Executors
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Future
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ThreadLocalRandom
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeoutException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|impl
operator|.
name|Log4JLogger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|client
operator|.
name|HdfsClientConfigKeys
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|util
operator|.
name|ByteArrayManager
operator|.
name|Counter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|util
operator|.
name|ByteArrayManager
operator|.
name|CounterMap
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|util
operator|.
name|ByteArrayManager
operator|.
name|FixedLengthManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|util
operator|.
name|ByteArrayManager
operator|.
name|ManagerMap
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Time
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|log4j
operator|.
name|Level
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Assert
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Test
import|;
end_import

begin_comment
comment|/**  * Test {@link ByteArrayManager}.  */
end_comment

begin_class
DECL|class|TestByteArrayManager
specifier|public
class|class
name|TestByteArrayManager
block|{
static|static
block|{
operator|(
operator|(
name|Log4JLogger
operator|)
name|LogFactory
operator|.
name|getLog
argument_list|(
name|ByteArrayManager
operator|.
name|class
argument_list|)
operator|)
operator|.
name|getLogger
argument_list|()
operator|.
name|setLevel
argument_list|(
name|Level
operator|.
name|ALL
argument_list|)
expr_stmt|;
block|}
DECL|field|LOG
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|TestByteArrayManager
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|CMP
specifier|private
specifier|static
specifier|final
name|Comparator
argument_list|<
name|Future
argument_list|<
name|Integer
argument_list|>
argument_list|>
name|CMP
init|=
operator|new
name|Comparator
argument_list|<
name|Future
argument_list|<
name|Integer
argument_list|>
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|int
name|compare
parameter_list|(
name|Future
argument_list|<
name|Integer
argument_list|>
name|left
parameter_list|,
name|Future
argument_list|<
name|Integer
argument_list|>
name|right
parameter_list|)
block|{
try|try
block|{
return|return
name|left
operator|.
name|get
argument_list|()
operator|.
name|intValue
argument_list|()
operator|-
name|right
operator|.
name|get
argument_list|()
operator|.
name|intValue
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
block|}
decl_stmt|;
annotation|@
name|Test
DECL|method|testCounter ()
specifier|public
name|void
name|testCounter
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|long
name|countResetTimePeriodMs
init|=
literal|200L
decl_stmt|;
specifier|final
name|Counter
name|c
init|=
operator|new
name|Counter
argument_list|(
name|countResetTimePeriodMs
argument_list|)
decl_stmt|;
specifier|final
name|int
name|n
init|=
name|ThreadLocalRandom
operator|.
name|current
argument_list|()
operator|.
name|nextInt
argument_list|(
literal|512
argument_list|)
operator|+
literal|512
decl_stmt|;
specifier|final
name|List
argument_list|<
name|Future
argument_list|<
name|Integer
argument_list|>
argument_list|>
name|futures
init|=
operator|new
name|ArrayList
argument_list|<
name|Future
argument_list|<
name|Integer
argument_list|>
argument_list|>
argument_list|(
name|n
argument_list|)
decl_stmt|;
specifier|final
name|ExecutorService
name|pool
init|=
name|Executors
operator|.
name|newFixedThreadPool
argument_list|(
literal|32
argument_list|)
decl_stmt|;
try|try
block|{
comment|// increment
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|futures
operator|.
name|add
argument_list|(
name|pool
operator|.
name|submit
argument_list|(
operator|new
name|Callable
argument_list|<
name|Integer
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Integer
name|call
parameter_list|()
throws|throws
name|Exception
block|{
return|return
operator|(
name|int
operator|)
name|c
operator|.
name|increment
argument_list|()
return|;
block|}
block|}
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// sort and wait for the futures
name|Collections
operator|.
name|sort
argument_list|(
name|futures
argument_list|,
name|CMP
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|pool
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
comment|// check futures
name|Assert
operator|.
name|assertEquals
argument_list|(
name|n
argument_list|,
name|futures
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|Assert
operator|.
name|assertEquals
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|futures
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|get
argument_list|()
operator|.
name|intValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|Assert
operator|.
name|assertEquals
argument_list|(
name|n
argument_list|,
name|c
operator|.
name|getCount
argument_list|()
argument_list|)
expr_stmt|;
comment|// test auto-reset
name|Thread
operator|.
name|sleep
argument_list|(
name|countResetTimePeriodMs
operator|+
literal|100
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|c
operator|.
name|increment
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testAllocateRecycle ()
specifier|public
name|void
name|testAllocateRecycle
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|int
name|countThreshold
init|=
literal|4
decl_stmt|;
specifier|final
name|int
name|countLimit
init|=
literal|8
decl_stmt|;
specifier|final
name|long
name|countResetTimePeriodMs
init|=
literal|200L
decl_stmt|;
specifier|final
name|ByteArrayManager
operator|.
name|Impl
name|bam
init|=
operator|new
name|ByteArrayManager
operator|.
name|Impl
argument_list|(
operator|new
name|ByteArrayManager
operator|.
name|Conf
argument_list|(
name|countThreshold
argument_list|,
name|countLimit
argument_list|,
name|countResetTimePeriodMs
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|CounterMap
name|counters
init|=
name|bam
operator|.
name|getCounters
argument_list|()
decl_stmt|;
specifier|final
name|ManagerMap
name|managers
init|=
name|bam
operator|.
name|getManagers
argument_list|()
decl_stmt|;
specifier|final
name|int
index|[]
name|uncommonArrays
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|4
block|,
literal|8
block|,
literal|16
block|,
literal|32
block|,
literal|64
block|}
decl_stmt|;
specifier|final
name|int
name|arrayLength
init|=
literal|1024
decl_stmt|;
specifier|final
name|Allocator
name|allocator
init|=
operator|new
name|Allocator
argument_list|(
name|bam
argument_list|)
decl_stmt|;
specifier|final
name|Recycler
name|recycler
init|=
operator|new
name|Recycler
argument_list|(
name|bam
argument_list|)
decl_stmt|;
try|try
block|{
block|{
comment|// allocate within threshold
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|countThreshold
condition|;
name|i
operator|++
control|)
block|{
name|allocator
operator|.
name|submit
argument_list|(
name|arrayLength
argument_list|)
expr_stmt|;
block|}
name|waitForAll
argument_list|(
name|allocator
operator|.
name|futures
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|countThreshold
argument_list|,
name|counters
operator|.
name|get
argument_list|(
name|arrayLength
argument_list|,
literal|false
argument_list|)
operator|.
name|getCount
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertNull
argument_list|(
name|managers
operator|.
name|get
argument_list|(
name|arrayLength
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|n
range|:
name|uncommonArrays
control|)
block|{
name|Assert
operator|.
name|assertNull
argument_list|(
name|counters
operator|.
name|get
argument_list|(
name|n
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertNull
argument_list|(
name|managers
operator|.
name|get
argument_list|(
name|n
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|{
comment|// recycle half of the arrays
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|countThreshold
operator|/
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|recycler
operator|.
name|submit
argument_list|(
name|removeLast
argument_list|(
name|allocator
operator|.
name|futures
argument_list|)
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Future
argument_list|<
name|Integer
argument_list|>
name|f
range|:
name|recycler
operator|.
name|furtures
control|)
block|{
name|Assert
operator|.
name|assertEquals
argument_list|(
operator|-
literal|1
argument_list|,
name|f
operator|.
name|get
argument_list|()
operator|.
name|intValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|recycler
operator|.
name|furtures
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|{
comment|// allocate one more
name|allocator
operator|.
name|submit
argument_list|(
name|arrayLength
argument_list|)
operator|.
name|get
argument_list|()
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|countThreshold
operator|+
literal|1
argument_list|,
name|counters
operator|.
name|get
argument_list|(
name|arrayLength
argument_list|,
literal|false
argument_list|)
operator|.
name|getCount
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertNotNull
argument_list|(
name|managers
operator|.
name|get
argument_list|(
name|arrayLength
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|{
comment|// recycle the remaining arrays
specifier|final
name|int
name|n
init|=
name|allocator
operator|.
name|recycleAll
argument_list|(
name|recycler
argument_list|)
decl_stmt|;
name|recycler
operator|.
name|verify
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
block|{
comment|// allocate until the maximum.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|countLimit
condition|;
name|i
operator|++
control|)
block|{
name|allocator
operator|.
name|submit
argument_list|(
name|arrayLength
argument_list|)
expr_stmt|;
block|}
name|waitForAll
argument_list|(
name|allocator
operator|.
name|futures
argument_list|)
expr_stmt|;
comment|// allocate one more should be blocked
specifier|final
name|AllocatorThread
name|t
init|=
operator|new
name|AllocatorThread
argument_list|(
name|arrayLength
argument_list|,
name|bam
argument_list|)
decl_stmt|;
name|t
operator|.
name|start
argument_list|()
expr_stmt|;
comment|// check if the thread is waiting, timed wait or runnable.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
block|{
name|Thread
operator|.
name|sleep
argument_list|(
literal|100
argument_list|)
expr_stmt|;
specifier|final
name|Thread
operator|.
name|State
name|threadState
init|=
name|t
operator|.
name|getState
argument_list|()
decl_stmt|;
if|if
condition|(
name|threadState
operator|!=
name|Thread
operator|.
name|State
operator|.
name|RUNNABLE
operator|&&
name|threadState
operator|!=
name|Thread
operator|.
name|State
operator|.
name|WAITING
operator|&&
name|threadState
operator|!=
name|Thread
operator|.
name|State
operator|.
name|TIMED_WAITING
condition|)
block|{
name|Assert
operator|.
name|fail
argument_list|(
literal|"threadState = "
operator|+
name|threadState
argument_list|)
expr_stmt|;
block|}
block|}
comment|// recycle an array
name|recycler
operator|.
name|submit
argument_list|(
name|removeLast
argument_list|(
name|allocator
operator|.
name|futures
argument_list|)
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|removeLast
argument_list|(
name|recycler
operator|.
name|furtures
argument_list|)
operator|.
name|get
argument_list|()
operator|.
name|intValue
argument_list|()
argument_list|)
expr_stmt|;
comment|// check if the thread is unblocked
name|Thread
operator|.
name|sleep
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|Thread
operator|.
name|State
operator|.
name|TERMINATED
argument_list|,
name|t
operator|.
name|getState
argument_list|()
argument_list|)
expr_stmt|;
comment|// recycle the remaining, the recycle should be full.
name|Assert
operator|.
name|assertEquals
argument_list|(
name|countLimit
operator|-
literal|1
argument_list|,
name|allocator
operator|.
name|recycleAll
argument_list|(
name|recycler
argument_list|)
argument_list|)
expr_stmt|;
name|recycler
operator|.
name|submit
argument_list|(
name|t
operator|.
name|array
argument_list|)
expr_stmt|;
name|recycler
operator|.
name|verify
argument_list|(
name|countLimit
argument_list|)
expr_stmt|;
comment|// recycle one more; it should not increase the free queue size
name|Assert
operator|.
name|assertEquals
argument_list|(
name|countLimit
argument_list|,
name|bam
operator|.
name|release
argument_list|(
operator|new
name|byte
index|[
name|arrayLength
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|allocator
operator|.
name|pool
operator|.
name|shutdown
argument_list|()
expr_stmt|;
name|recycler
operator|.
name|pool
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|removeLast (List<Future<T>> furtures)
specifier|static
parameter_list|<
name|T
parameter_list|>
name|Future
argument_list|<
name|T
argument_list|>
name|removeLast
parameter_list|(
name|List
argument_list|<
name|Future
argument_list|<
name|T
argument_list|>
argument_list|>
name|furtures
parameter_list|)
throws|throws
name|Exception
block|{
return|return
name|remove
argument_list|(
name|furtures
argument_list|,
name|furtures
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
return|;
block|}
DECL|method|remove (List<Future<T>> furtures, int i)
specifier|static
parameter_list|<
name|T
parameter_list|>
name|Future
argument_list|<
name|T
argument_list|>
name|remove
parameter_list|(
name|List
argument_list|<
name|Future
argument_list|<
name|T
argument_list|>
argument_list|>
name|furtures
parameter_list|,
name|int
name|i
parameter_list|)
throws|throws
name|Exception
block|{
return|return
name|furtures
operator|.
name|isEmpty
argument_list|()
condition|?
literal|null
else|:
name|furtures
operator|.
name|remove
argument_list|(
name|i
argument_list|)
return|;
block|}
DECL|method|waitForAll (List<Future<T>> furtures)
specifier|static
parameter_list|<
name|T
parameter_list|>
name|void
name|waitForAll
parameter_list|(
name|List
argument_list|<
name|Future
argument_list|<
name|T
argument_list|>
argument_list|>
name|furtures
parameter_list|)
throws|throws
name|Exception
block|{
for|for
control|(
name|Future
argument_list|<
name|T
argument_list|>
name|f
range|:
name|furtures
control|)
block|{
name|f
operator|.
name|get
argument_list|()
expr_stmt|;
block|}
block|}
DECL|class|AllocatorThread
specifier|static
class|class
name|AllocatorThread
extends|extends
name|Thread
block|{
DECL|field|bam
specifier|private
specifier|final
name|ByteArrayManager
name|bam
decl_stmt|;
DECL|field|arrayLength
specifier|private
specifier|final
name|int
name|arrayLength
decl_stmt|;
DECL|field|array
specifier|private
name|byte
index|[]
name|array
decl_stmt|;
DECL|method|AllocatorThread (int arrayLength, ByteArrayManager bam)
name|AllocatorThread
parameter_list|(
name|int
name|arrayLength
parameter_list|,
name|ByteArrayManager
name|bam
parameter_list|)
block|{
name|this
operator|.
name|bam
operator|=
name|bam
expr_stmt|;
name|this
operator|.
name|arrayLength
operator|=
name|arrayLength
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
try|try
block|{
name|array
operator|=
name|bam
operator|.
name|newByteArray
argument_list|(
name|arrayLength
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|e
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
block|}
block|}
DECL|class|Allocator
specifier|static
class|class
name|Allocator
block|{
DECL|field|bam
specifier|private
specifier|final
name|ByteArrayManager
name|bam
decl_stmt|;
DECL|field|pool
specifier|final
name|ExecutorService
name|pool
init|=
name|Executors
operator|.
name|newFixedThreadPool
argument_list|(
literal|8
argument_list|)
decl_stmt|;
DECL|field|futures
specifier|final
name|List
argument_list|<
name|Future
argument_list|<
name|byte
index|[]
argument_list|>
argument_list|>
name|futures
init|=
operator|new
name|LinkedList
argument_list|<
name|Future
argument_list|<
name|byte
index|[]
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
DECL|method|Allocator (ByteArrayManager bam)
name|Allocator
parameter_list|(
name|ByteArrayManager
name|bam
parameter_list|)
block|{
name|this
operator|.
name|bam
operator|=
name|bam
expr_stmt|;
block|}
DECL|method|submit (final int arrayLength)
name|Future
argument_list|<
name|byte
index|[]
argument_list|>
name|submit
parameter_list|(
specifier|final
name|int
name|arrayLength
parameter_list|)
block|{
specifier|final
name|Future
argument_list|<
name|byte
index|[]
argument_list|>
name|f
init|=
name|pool
operator|.
name|submit
argument_list|(
operator|new
name|Callable
argument_list|<
name|byte
index|[]
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|byte
index|[]
name|call
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|byte
index|[]
name|array
init|=
name|bam
operator|.
name|newByteArray
argument_list|(
name|arrayLength
argument_list|)
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|arrayLength
argument_list|,
name|array
operator|.
name|length
argument_list|)
expr_stmt|;
return|return
name|array
return|;
block|}
block|}
argument_list|)
decl_stmt|;
name|futures
operator|.
name|add
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
name|f
return|;
block|}
DECL|method|recycleAll (Recycler recycler)
name|int
name|recycleAll
parameter_list|(
name|Recycler
name|recycler
parameter_list|)
throws|throws
name|Exception
block|{
specifier|final
name|int
name|n
init|=
name|futures
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|Future
argument_list|<
name|byte
index|[]
argument_list|>
name|f
range|:
name|futures
control|)
block|{
name|recycler
operator|.
name|submit
argument_list|(
name|f
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|futures
operator|.
name|clear
argument_list|()
expr_stmt|;
return|return
name|n
return|;
block|}
block|}
DECL|class|Recycler
specifier|static
class|class
name|Recycler
block|{
DECL|field|bam
specifier|private
specifier|final
name|ByteArrayManager
name|bam
decl_stmt|;
DECL|field|pool
specifier|final
name|ExecutorService
name|pool
init|=
name|Executors
operator|.
name|newFixedThreadPool
argument_list|(
literal|8
argument_list|)
decl_stmt|;
DECL|field|furtures
specifier|final
name|List
argument_list|<
name|Future
argument_list|<
name|Integer
argument_list|>
argument_list|>
name|furtures
init|=
operator|new
name|LinkedList
argument_list|<
name|Future
argument_list|<
name|Integer
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
DECL|method|Recycler (ByteArrayManager bam)
name|Recycler
parameter_list|(
name|ByteArrayManager
name|bam
parameter_list|)
block|{
name|this
operator|.
name|bam
operator|=
name|bam
expr_stmt|;
block|}
DECL|method|submit (final byte[] array)
name|Future
argument_list|<
name|Integer
argument_list|>
name|submit
parameter_list|(
specifier|final
name|byte
index|[]
name|array
parameter_list|)
block|{
specifier|final
name|Future
argument_list|<
name|Integer
argument_list|>
name|f
init|=
name|pool
operator|.
name|submit
argument_list|(
operator|new
name|Callable
argument_list|<
name|Integer
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Integer
name|call
parameter_list|()
throws|throws
name|Exception
block|{
return|return
name|bam
operator|.
name|release
argument_list|(
name|array
argument_list|)
return|;
block|}
block|}
argument_list|)
decl_stmt|;
name|furtures
operator|.
name|add
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
name|f
return|;
block|}
DECL|method|verify (final int expectedSize)
name|void
name|verify
parameter_list|(
specifier|final
name|int
name|expectedSize
parameter_list|)
throws|throws
name|Exception
block|{
name|Assert
operator|.
name|assertEquals
argument_list|(
name|expectedSize
argument_list|,
name|furtures
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|Collections
operator|.
name|sort
argument_list|(
name|furtures
argument_list|,
name|CMP
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|furtures
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|Assert
operator|.
name|assertEquals
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|furtures
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|get
argument_list|()
operator|.
name|intValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|furtures
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Test
DECL|method|testByteArrayManager ()
specifier|public
name|void
name|testByteArrayManager
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|int
name|countThreshold
init|=
literal|32
decl_stmt|;
specifier|final
name|int
name|countLimit
init|=
literal|64
decl_stmt|;
specifier|final
name|long
name|countResetTimePeriodMs
init|=
literal|1000L
decl_stmt|;
specifier|final
name|ByteArrayManager
operator|.
name|Impl
name|bam
init|=
operator|new
name|ByteArrayManager
operator|.
name|Impl
argument_list|(
operator|new
name|ByteArrayManager
operator|.
name|Conf
argument_list|(
name|countThreshold
argument_list|,
name|countLimit
argument_list|,
name|countResetTimePeriodMs
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|CounterMap
name|counters
init|=
name|bam
operator|.
name|getCounters
argument_list|()
decl_stmt|;
specifier|final
name|ManagerMap
name|managers
init|=
name|bam
operator|.
name|getManagers
argument_list|()
decl_stmt|;
specifier|final
name|ExecutorService
name|pool
init|=
name|Executors
operator|.
name|newFixedThreadPool
argument_list|(
literal|128
argument_list|)
decl_stmt|;
specifier|final
name|Runner
index|[]
name|runners
init|=
operator|new
name|Runner
index|[
name|Runner
operator|.
name|NUM_RUNNERS
index|]
decl_stmt|;
specifier|final
name|Thread
index|[]
name|threads
init|=
operator|new
name|Thread
index|[
name|runners
operator|.
name|length
index|]
decl_stmt|;
specifier|final
name|int
name|num
init|=
literal|1
operator|<<
literal|10
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|runners
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|runners
index|[
name|i
index|]
operator|=
operator|new
name|Runner
argument_list|(
name|i
argument_list|,
name|countThreshold
argument_list|,
name|countLimit
argument_list|,
name|pool
argument_list|,
name|i
argument_list|,
name|bam
argument_list|)
expr_stmt|;
name|threads
index|[
name|i
index|]
operator|=
name|runners
index|[
name|i
index|]
operator|.
name|start
argument_list|(
name|num
argument_list|)
expr_stmt|;
block|}
specifier|final
name|List
argument_list|<
name|Exception
argument_list|>
name|exceptions
init|=
operator|new
name|ArrayList
argument_list|<
name|Exception
argument_list|>
argument_list|()
decl_stmt|;
specifier|final
name|Thread
name|randomRecycler
init|=
operator|new
name|Thread
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"randomRecycler start"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|shouldRun
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|int
name|j
init|=
name|ThreadLocalRandom
operator|.
name|current
argument_list|()
operator|.
name|nextInt
argument_list|(
name|runners
operator|.
name|length
argument_list|)
decl_stmt|;
try|try
block|{
name|runners
index|[
name|j
index|]
operator|.
name|recycle
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|e
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
name|exceptions
operator|.
name|add
argument_list|(
operator|new
name|Exception
argument_list|(
name|this
operator|+
literal|" has an exception"
argument_list|,
name|e
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|i
operator|&
literal|0xFF
operator|)
operator|==
literal|0
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"randomRecycler sleep, i="
operator|+
name|i
argument_list|)
expr_stmt|;
name|sleepMs
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"randomRecycler done"
argument_list|)
expr_stmt|;
block|}
name|boolean
name|shouldRun
parameter_list|()
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|runners
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|threads
index|[
name|i
index|]
operator|.
name|isAlive
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
operator|!
name|runners
index|[
name|i
index|]
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
block|}
decl_stmt|;
name|randomRecycler
operator|.
name|start
argument_list|()
expr_stmt|;
name|randomRecycler
operator|.
name|join
argument_list|()
expr_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
name|exceptions
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertNull
argument_list|(
name|counters
operator|.
name|get
argument_list|(
literal|0
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|runners
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|runners
index|[
name|i
index|]
operator|.
name|assertionErrors
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|AssertionError
name|e
range|:
name|runners
index|[
name|i
index|]
operator|.
name|assertionErrors
control|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"AssertionError "
operator|+
name|i
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
name|Assert
operator|.
name|fail
argument_list|(
name|runners
index|[
name|i
index|]
operator|.
name|assertionErrors
operator|.
name|size
argument_list|()
operator|+
literal|" AssertionError(s)"
argument_list|)
expr_stmt|;
block|}
specifier|final
name|int
name|arrayLength
init|=
name|Runner
operator|.
name|index2arrayLength
argument_list|(
name|i
argument_list|)
decl_stmt|;
specifier|final
name|boolean
name|exceedCountThreshold
init|=
name|counters
operator|.
name|get
argument_list|(
name|arrayLength
argument_list|,
literal|false
argument_list|)
operator|.
name|getCount
argument_list|()
operator|>
name|countThreshold
decl_stmt|;
specifier|final
name|FixedLengthManager
name|m
init|=
name|managers
operator|.
name|get
argument_list|(
name|arrayLength
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|exceedCountThreshold
condition|)
block|{
name|Assert
operator|.
name|assertNotNull
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Assert
operator|.
name|assertNull
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|sleepMs (long ms)
specifier|static
name|void
name|sleepMs
parameter_list|(
name|long
name|ms
parameter_list|)
block|{
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|ms
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|e
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
name|Assert
operator|.
name|fail
argument_list|(
literal|"Sleep is interrupted: "
operator|+
name|e
argument_list|)
expr_stmt|;
block|}
block|}
DECL|class|Runner
specifier|static
class|class
name|Runner
implements|implements
name|Runnable
block|{
DECL|field|NUM_RUNNERS
specifier|static
specifier|final
name|int
name|NUM_RUNNERS
init|=
literal|5
decl_stmt|;
DECL|method|index2arrayLength (int index)
specifier|static
name|int
name|index2arrayLength
parameter_list|(
name|int
name|index
parameter_list|)
block|{
return|return
name|ByteArrayManager
operator|.
name|MIN_ARRAY_LENGTH
operator|<<
operator|(
name|index
operator|-
literal|1
operator|)
return|;
block|}
DECL|field|bam
specifier|private
specifier|final
name|ByteArrayManager
name|bam
decl_stmt|;
DECL|field|maxArrayLength
specifier|final
name|int
name|maxArrayLength
decl_stmt|;
DECL|field|countThreshold
specifier|final
name|int
name|countThreshold
decl_stmt|;
DECL|field|maxArrays
specifier|final
name|int
name|maxArrays
decl_stmt|;
DECL|field|pool
specifier|final
name|ExecutorService
name|pool
decl_stmt|;
DECL|field|arrays
specifier|final
name|List
argument_list|<
name|Future
argument_list|<
name|byte
index|[]
argument_list|>
argument_list|>
name|arrays
init|=
operator|new
name|ArrayList
argument_list|<
name|Future
argument_list|<
name|byte
index|[]
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|count
specifier|final
name|AtomicInteger
name|count
init|=
operator|new
name|AtomicInteger
argument_list|()
decl_stmt|;
DECL|field|p
specifier|final
name|int
name|p
decl_stmt|;
DECL|field|n
specifier|private
name|int
name|n
decl_stmt|;
DECL|field|assertionErrors
specifier|final
name|List
argument_list|<
name|AssertionError
argument_list|>
name|assertionErrors
init|=
operator|new
name|ArrayList
argument_list|<
name|AssertionError
argument_list|>
argument_list|()
decl_stmt|;
DECL|method|Runner (int index, int countThreshold, int maxArrays, ExecutorService pool, int p, ByteArrayManager bam)
name|Runner
parameter_list|(
name|int
name|index
parameter_list|,
name|int
name|countThreshold
parameter_list|,
name|int
name|maxArrays
parameter_list|,
name|ExecutorService
name|pool
parameter_list|,
name|int
name|p
parameter_list|,
name|ByteArrayManager
name|bam
parameter_list|)
block|{
name|this
operator|.
name|maxArrayLength
operator|=
name|index2arrayLength
argument_list|(
name|index
argument_list|)
expr_stmt|;
name|this
operator|.
name|countThreshold
operator|=
name|countThreshold
expr_stmt|;
name|this
operator|.
name|maxArrays
operator|=
name|maxArrays
expr_stmt|;
name|this
operator|.
name|pool
operator|=
name|pool
expr_stmt|;
name|this
operator|.
name|p
operator|=
name|p
expr_stmt|;
name|this
operator|.
name|bam
operator|=
name|bam
expr_stmt|;
block|}
DECL|method|isEmpty ()
name|boolean
name|isEmpty
parameter_list|()
block|{
synchronized|synchronized
init|(
name|arrays
init|)
block|{
return|return
name|arrays
operator|.
name|isEmpty
argument_list|()
return|;
block|}
block|}
DECL|method|submitAllocate ()
name|Future
argument_list|<
name|byte
index|[]
argument_list|>
name|submitAllocate
parameter_list|()
block|{
name|count
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
specifier|final
name|Future
argument_list|<
name|byte
index|[]
argument_list|>
name|f
init|=
name|pool
operator|.
name|submit
argument_list|(
operator|new
name|Callable
argument_list|<
name|byte
index|[]
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|byte
index|[]
name|call
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|int
name|lower
init|=
name|maxArrayLength
operator|==
name|ByteArrayManager
operator|.
name|MIN_ARRAY_LENGTH
condition|?
literal|0
else|:
name|maxArrayLength
operator|>>
literal|1
decl_stmt|;
specifier|final
name|int
name|arrayLength
init|=
name|ThreadLocalRandom
operator|.
name|current
argument_list|()
operator|.
name|nextInt
argument_list|(
name|maxArrayLength
operator|-
name|lower
argument_list|)
operator|+
name|lower
operator|+
literal|1
decl_stmt|;
specifier|final
name|byte
index|[]
name|array
init|=
name|bam
operator|.
name|newByteArray
argument_list|(
name|arrayLength
argument_list|)
decl_stmt|;
try|try
block|{
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"arrayLength="
operator|+
name|arrayLength
operator|+
literal|", lower="
operator|+
name|lower
argument_list|,
name|maxArrayLength
argument_list|,
name|array
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|AssertionError
name|e
parameter_list|)
block|{
name|assertionErrors
operator|.
name|add
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
return|return
name|array
return|;
block|}
block|}
argument_list|)
decl_stmt|;
synchronized|synchronized
init|(
name|arrays
init|)
block|{
name|arrays
operator|.
name|add
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
return|return
name|f
return|;
block|}
DECL|method|removeFirst ()
name|Future
argument_list|<
name|byte
index|[]
argument_list|>
name|removeFirst
parameter_list|()
throws|throws
name|Exception
block|{
synchronized|synchronized
init|(
name|arrays
init|)
block|{
return|return
name|remove
argument_list|(
name|arrays
argument_list|,
literal|0
argument_list|)
return|;
block|}
block|}
DECL|method|recycle ()
name|void
name|recycle
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|Future
argument_list|<
name|byte
index|[]
argument_list|>
name|f
init|=
name|removeFirst
argument_list|()
decl_stmt|;
if|if
condition|(
name|f
operator|!=
literal|null
condition|)
block|{
name|printf
argument_list|(
literal|"randomRecycler: "
argument_list|)
expr_stmt|;
try|try
block|{
name|recycle
argument_list|(
name|f
operator|.
name|get
argument_list|(
literal|10
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|TimeoutException
name|e
parameter_list|)
block|{
name|recycle
argument_list|(
operator|new
name|byte
index|[
name|maxArrayLength
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"timeout, new byte[%d]\n"
argument_list|,
name|maxArrayLength
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|recycle (final byte[] array)
name|int
name|recycle
parameter_list|(
specifier|final
name|byte
index|[]
name|array
parameter_list|)
block|{
return|return
name|bam
operator|.
name|release
argument_list|(
name|array
argument_list|)
return|;
block|}
DECL|method|submitRecycle (final byte[] array)
name|Future
argument_list|<
name|Integer
argument_list|>
name|submitRecycle
parameter_list|(
specifier|final
name|byte
index|[]
name|array
parameter_list|)
block|{
name|count
operator|.
name|decrementAndGet
argument_list|()
expr_stmt|;
specifier|final
name|Future
argument_list|<
name|Integer
argument_list|>
name|f
init|=
name|pool
operator|.
name|submit
argument_list|(
operator|new
name|Callable
argument_list|<
name|Integer
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Integer
name|call
parameter_list|()
throws|throws
name|Exception
block|{
return|return
name|recycle
argument_list|(
name|array
argument_list|)
return|;
block|}
block|}
argument_list|)
decl_stmt|;
return|return
name|f
return|;
block|}
annotation|@
name|Override
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|boolean
name|isAllocate
init|=
name|ThreadLocalRandom
operator|.
name|current
argument_list|()
operator|.
name|nextInt
argument_list|(
name|NUM_RUNNERS
argument_list|)
operator|<
name|p
decl_stmt|;
if|if
condition|(
name|isAllocate
condition|)
block|{
name|submitAllocate
argument_list|()
expr_stmt|;
block|}
else|else
block|{
try|try
block|{
specifier|final
name|Future
argument_list|<
name|byte
index|[]
argument_list|>
name|f
init|=
name|removeFirst
argument_list|()
decl_stmt|;
if|if
condition|(
name|f
operator|!=
literal|null
condition|)
block|{
name|submitRecycle
argument_list|(
name|f
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|e
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
name|Assert
operator|.
name|fail
argument_list|(
name|this
operator|+
literal|" has "
operator|+
name|e
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|i
operator|&
literal|0xFF
operator|)
operator|==
literal|0
condition|)
block|{
name|sleepMs
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|start (int n)
name|Thread
name|start
parameter_list|(
name|int
name|n
parameter_list|)
block|{
name|this
operator|.
name|n
operator|=
name|n
expr_stmt|;
specifier|final
name|Thread
name|t
init|=
operator|new
name|Thread
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|t
operator|.
name|start
argument_list|()
expr_stmt|;
return|return
name|t
return|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|": max="
operator|+
name|maxArrayLength
operator|+
literal|", count="
operator|+
name|count
return|;
block|}
block|}
DECL|class|NewByteArrayWithLimit
specifier|static
class|class
name|NewByteArrayWithLimit
extends|extends
name|ByteArrayManager
block|{
DECL|field|maxCount
specifier|private
specifier|final
name|int
name|maxCount
decl_stmt|;
DECL|field|count
specifier|private
name|int
name|count
init|=
literal|0
decl_stmt|;
DECL|method|NewByteArrayWithLimit (int maxCount)
name|NewByteArrayWithLimit
parameter_list|(
name|int
name|maxCount
parameter_list|)
block|{
name|this
operator|.
name|maxCount
operator|=
name|maxCount
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|newByteArray (int size)
specifier|public
specifier|synchronized
name|byte
index|[]
name|newByteArray
parameter_list|(
name|int
name|size
parameter_list|)
throws|throws
name|InterruptedException
block|{
for|for
control|(
init|;
name|count
operator|>=
name|maxCount
condition|;
control|)
block|{
name|wait
argument_list|()
expr_stmt|;
block|}
name|count
operator|++
expr_stmt|;
return|return
operator|new
name|byte
index|[
name|size
index|]
return|;
block|}
annotation|@
name|Override
DECL|method|release (byte[] array)
specifier|public
specifier|synchronized
name|int
name|release
parameter_list|(
name|byte
index|[]
name|array
parameter_list|)
block|{
if|if
condition|(
name|count
operator|==
name|maxCount
condition|)
block|{
name|notifyAll
argument_list|()
expr_stmt|;
block|}
name|count
operator|--
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
DECL|method|main (String[] args)
specifier|public
specifier|static
name|void
name|main
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
throws|throws
name|Exception
block|{
operator|(
operator|(
name|Log4JLogger
operator|)
name|LogFactory
operator|.
name|getLog
argument_list|(
name|ByteArrayManager
operator|.
name|class
argument_list|)
operator|)
operator|.
name|getLogger
argument_list|()
operator|.
name|setLevel
argument_list|(
name|Level
operator|.
name|OFF
argument_list|)
expr_stmt|;
specifier|final
name|int
name|arrayLength
init|=
literal|64
operator|*
literal|1024
decl_stmt|;
comment|//64k
specifier|final
name|int
name|nThreads
init|=
literal|512
decl_stmt|;
specifier|final
name|int
name|nAllocations
init|=
literal|1
operator|<<
literal|15
decl_stmt|;
specifier|final
name|int
name|maxArrays
init|=
literal|1
operator|<<
literal|10
decl_stmt|;
specifier|final
name|int
name|nTrials
init|=
literal|5
decl_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"arrayLength="
operator|+
name|arrayLength
operator|+
literal|", nThreads="
operator|+
name|nThreads
operator|+
literal|", nAllocations="
operator|+
name|nAllocations
operator|+
literal|", maxArrays="
operator|+
name|maxArrays
argument_list|)
expr_stmt|;
specifier|final
name|ByteArrayManager
index|[]
name|impls
init|=
block|{
operator|new
name|ByteArrayManager
operator|.
name|NewByteArrayWithoutLimit
argument_list|()
block|,
operator|new
name|NewByteArrayWithLimit
argument_list|(
name|maxArrays
argument_list|)
block|,
operator|new
name|ByteArrayManager
operator|.
name|Impl
argument_list|(
operator|new
name|ByteArrayManager
operator|.
name|Conf
argument_list|(
name|HdfsClientConfigKeys
operator|.
name|Write
operator|.
name|ByteArrayManager
operator|.
name|COUNT_THRESHOLD_DEFAULT
argument_list|,
name|maxArrays
argument_list|,
name|HdfsClientConfigKeys
operator|.
name|Write
operator|.
name|ByteArrayManager
operator|.
name|COUNT_RESET_TIME_PERIOD_MS_DEFAULT
argument_list|)
argument_list|)
block|}
decl_stmt|;
specifier|final
name|double
index|[]
name|avg
init|=
operator|new
name|double
index|[
name|impls
operator|.
name|length
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|impls
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|double
name|duration
init|=
literal|0
decl_stmt|;
name|printf
argument_list|(
literal|"%26s:"
argument_list|,
name|impls
index|[
name|i
index|]
operator|.
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|nTrials
condition|;
name|j
operator|++
control|)
block|{
specifier|final
name|int
index|[]
name|sleepTime
init|=
operator|new
name|int
index|[
name|nAllocations
index|]
decl_stmt|;
for|for
control|(
name|int
name|k
init|=
literal|0
init|;
name|k
operator|<
name|sleepTime
operator|.
name|length
condition|;
name|k
operator|++
control|)
block|{
name|sleepTime
index|[
name|k
index|]
operator|=
name|ThreadLocalRandom
operator|.
name|current
argument_list|()
operator|.
name|nextInt
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
specifier|final
name|long
name|elapsed
init|=
name|performanceTest
argument_list|(
name|arrayLength
argument_list|,
name|maxArrays
argument_list|,
name|nThreads
argument_list|,
name|sleepTime
argument_list|,
name|impls
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|duration
operator|+=
name|elapsed
expr_stmt|;
name|printf
argument_list|(
literal|"%5d, "
argument_list|,
name|elapsed
argument_list|)
expr_stmt|;
block|}
name|avg
index|[
name|i
index|]
operator|=
name|duration
operator|/
name|nTrials
expr_stmt|;
name|printf
argument_list|(
literal|"avg=%6.3fs"
argument_list|,
name|avg
index|[
name|i
index|]
operator|/
literal|1000
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|++
control|)
block|{
name|printf
argument_list|(
literal|" (%6.2f%%)"
argument_list|,
name|percentageDiff
argument_list|(
name|avg
index|[
name|j
index|]
argument_list|,
name|avg
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|percentageDiff (double original, double newValue)
specifier|static
name|double
name|percentageDiff
parameter_list|(
name|double
name|original
parameter_list|,
name|double
name|newValue
parameter_list|)
block|{
return|return
operator|(
name|newValue
operator|-
name|original
operator|)
operator|/
name|original
operator|*
literal|100
return|;
block|}
DECL|method|printf (String format, Object... args)
specifier|static
name|void
name|printf
parameter_list|(
name|String
name|format
parameter_list|,
name|Object
modifier|...
name|args
parameter_list|)
block|{
name|System
operator|.
name|out
operator|.
name|printf
argument_list|(
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
DECL|method|performanceTest (final int arrayLength, final int maxArrays, final int nThreads, final int[] sleepTimeMSs, final ByteArrayManager impl)
specifier|static
name|long
name|performanceTest
parameter_list|(
specifier|final
name|int
name|arrayLength
parameter_list|,
specifier|final
name|int
name|maxArrays
parameter_list|,
specifier|final
name|int
name|nThreads
parameter_list|,
specifier|final
name|int
index|[]
name|sleepTimeMSs
parameter_list|,
specifier|final
name|ByteArrayManager
name|impl
parameter_list|)
throws|throws
name|Exception
block|{
specifier|final
name|ExecutorService
name|pool
init|=
name|Executors
operator|.
name|newFixedThreadPool
argument_list|(
name|nThreads
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|Future
argument_list|<
name|Void
argument_list|>
argument_list|>
name|futures
init|=
operator|new
name|ArrayList
argument_list|<
name|Future
argument_list|<
name|Void
argument_list|>
argument_list|>
argument_list|(
name|sleepTimeMSs
operator|.
name|length
argument_list|)
decl_stmt|;
specifier|final
name|long
name|startTime
init|=
name|Time
operator|.
name|monotonicNow
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sleepTimeMSs
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|long
name|sleepTime
init|=
name|sleepTimeMSs
index|[
name|i
index|]
decl_stmt|;
name|futures
operator|.
name|add
argument_list|(
name|pool
operator|.
name|submit
argument_list|(
operator|new
name|Callable
argument_list|<
name|Void
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Void
name|call
parameter_list|()
throws|throws
name|Exception
block|{
name|byte
index|[]
name|array
init|=
name|impl
operator|.
name|newByteArray
argument_list|(
name|arrayLength
argument_list|)
decl_stmt|;
name|sleepMs
argument_list|(
name|sleepTime
argument_list|)
expr_stmt|;
name|impl
operator|.
name|release
argument_list|(
name|array
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Future
argument_list|<
name|Void
argument_list|>
name|f
range|:
name|futures
control|)
block|{
name|f
operator|.
name|get
argument_list|()
expr_stmt|;
block|}
specifier|final
name|long
name|endTime
init|=
name|Time
operator|.
name|monotonicNow
argument_list|()
decl_stmt|;
name|pool
operator|.
name|shutdown
argument_list|()
expr_stmt|;
return|return
name|endTime
operator|-
name|startTime
return|;
block|}
block|}
end_class

end_unit

