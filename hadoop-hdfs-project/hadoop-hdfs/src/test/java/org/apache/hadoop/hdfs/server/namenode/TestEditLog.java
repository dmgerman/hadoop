begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdfs.server.namenode
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|permission
operator|.
name|AclEntryScope
operator|.
name|*
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|permission
operator|.
name|AclEntryType
operator|.
name|*
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|permission
operator|.
name|FsAction
operator|.
name|*
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|AclTestHelpers
operator|.
name|*
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|test
operator|.
name|MetricsAsserts
operator|.
name|assertCounter
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|test
operator|.
name|MetricsAsserts
operator|.
name|getMetrics
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertEquals
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertFalse
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertNotNull
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertTrue
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|fail
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|BufferedInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FilenameFilter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|RandomAccessFile
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URI
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Random
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Callable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutorService
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Executors
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Matcher
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Pattern
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|io
operator|.
name|FileUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|ChecksumException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|permission
operator|.
name|AclEntry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|permission
operator|.
name|FsPermission
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|permission
operator|.
name|PermissionStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSInotifyEventInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DistributedFileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|HdfsConfiguration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|MiniDFSCluster
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|HdfsFileStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|blockmanagement
operator|.
name|BlockInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|HdfsServerConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|Storage
operator|.
name|StorageDirectory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|NNStorage
operator|.
name|NameNodeDirType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|metrics
operator|.
name|NameNodeMetrics
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|NamespaceInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|util
operator|.
name|XMLUtils
operator|.
name|InvalidXmlException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|util
operator|.
name|XMLUtils
operator|.
name|Stanza
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|test
operator|.
name|GenericTestUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|test
operator|.
name|PathUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Time
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|log4j
operator|.
name|Level
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|log4j
operator|.
name|AppenderSkeleton
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|log4j
operator|.
name|LogManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|log4j
operator|.
name|spi
operator|.
name|LoggingEvent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Test
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|runner
operator|.
name|RunWith
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|runners
operator|.
name|Parameterized
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|runners
operator|.
name|Parameterized
operator|.
name|Parameters
import|;
end_import

begin_import
import|import
name|org
operator|.
name|mockito
operator|.
name|Mockito
import|;
end_import

begin_import
import|import
name|org
operator|.
name|xml
operator|.
name|sax
operator|.
name|ContentHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|xml
operator|.
name|sax
operator|.
name|SAXException
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_comment
comment|/**  * This class tests the creation and validation of a checkpoint.  */
end_comment

begin_class
annotation|@
name|RunWith
argument_list|(
name|Parameterized
operator|.
name|class
argument_list|)
DECL|class|TestEditLog
specifier|public
class|class
name|TestEditLog
block|{
static|static
block|{
name|GenericTestUtils
operator|.
name|setLogLevel
argument_list|(
name|FSEditLog
operator|.
name|LOG
argument_list|,
name|Level
operator|.
name|ALL
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Parameters
DECL|method|data ()
specifier|public
specifier|static
name|Collection
argument_list|<
name|Object
index|[]
argument_list|>
name|data
parameter_list|()
block|{
name|Collection
argument_list|<
name|Object
index|[]
argument_list|>
name|params
init|=
operator|new
name|ArrayList
argument_list|<
name|Object
index|[]
argument_list|>
argument_list|()
decl_stmt|;
name|params
operator|.
name|add
argument_list|(
operator|new
name|Object
index|[]
block|{
name|Boolean
operator|.
name|FALSE
block|}
argument_list|)
expr_stmt|;
name|params
operator|.
name|add
argument_list|(
operator|new
name|Object
index|[]
block|{
name|Boolean
operator|.
name|TRUE
block|}
argument_list|)
expr_stmt|;
return|return
name|params
return|;
block|}
DECL|field|useAsyncEditLog
specifier|private
specifier|static
name|boolean
name|useAsyncEditLog
decl_stmt|;
DECL|method|TestEditLog (Boolean async)
specifier|public
name|TestEditLog
parameter_list|(
name|Boolean
name|async
parameter_list|)
block|{
name|useAsyncEditLog
operator|=
name|async
expr_stmt|;
block|}
DECL|method|getConf ()
specifier|public
specifier|static
name|Configuration
name|getConf
parameter_list|()
block|{
name|Configuration
name|conf
init|=
operator|new
name|HdfsConfiguration
argument_list|()
decl_stmt|;
name|conf
operator|.
name|setBoolean
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_EDITS_ASYNC_LOGGING
argument_list|,
name|useAsyncEditLog
argument_list|)
expr_stmt|;
return|return
name|conf
return|;
block|}
comment|/**    * A garbage mkdir op which is used for testing    * {@link EditLogFileInputStream#scanEditLog(File, long, boolean)}    */
DECL|class|GarbageMkdirOp
specifier|public
specifier|static
class|class
name|GarbageMkdirOp
extends|extends
name|FSEditLogOp
block|{
DECL|method|GarbageMkdirOp ()
specifier|public
name|GarbageMkdirOp
parameter_list|()
block|{
name|super
argument_list|(
name|FSEditLogOpCodes
operator|.
name|OP_MKDIR
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|resetSubFields ()
name|void
name|resetSubFields
parameter_list|()
block|{
comment|// nop
block|}
annotation|@
name|Override
DECL|method|readFields (DataInputStream in, int logVersion)
name|void
name|readFields
parameter_list|(
name|DataInputStream
name|in
parameter_list|,
name|int
name|logVersion
parameter_list|)
throws|throws
name|IOException
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"cannot decode GarbageMkdirOp"
argument_list|)
throw|;
block|}
annotation|@
name|Override
DECL|method|writeFields (DataOutputStream out)
specifier|public
name|void
name|writeFields
parameter_list|(
name|DataOutputStream
name|out
parameter_list|)
throws|throws
name|IOException
block|{
comment|// write in some garbage content
name|Random
name|random
init|=
operator|new
name|Random
argument_list|()
decl_stmt|;
name|byte
index|[]
name|content
init|=
operator|new
name|byte
index|[
name|random
operator|.
name|nextInt
argument_list|(
literal|16
argument_list|)
operator|+
literal|1
index|]
decl_stmt|;
name|random
operator|.
name|nextBytes
argument_list|(
name|content
argument_list|)
expr_stmt|;
name|out
operator|.
name|write
argument_list|(
name|content
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|toXml (ContentHandler contentHandler)
specifier|protected
name|void
name|toXml
parameter_list|(
name|ContentHandler
name|contentHandler
parameter_list|)
throws|throws
name|SAXException
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"Not supported for GarbageMkdirOp"
argument_list|)
throw|;
block|}
annotation|@
name|Override
DECL|method|fromXml (Stanza st)
name|void
name|fromXml
parameter_list|(
name|Stanza
name|st
parameter_list|)
throws|throws
name|InvalidXmlException
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"Not supported for GarbageMkdirOp"
argument_list|)
throw|;
block|}
block|}
DECL|field|LOG
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|TestEditLog
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|NUM_DATA_NODES
specifier|static
specifier|final
name|int
name|NUM_DATA_NODES
init|=
literal|0
decl_stmt|;
comment|// This test creates NUM_THREADS threads and each thread does
comment|// 2 * NUM_TRANSACTIONS Transactions concurrently.
DECL|field|NUM_TRANSACTIONS
specifier|static
specifier|final
name|int
name|NUM_TRANSACTIONS
init|=
literal|100
decl_stmt|;
DECL|field|NUM_THREADS
specifier|static
specifier|final
name|int
name|NUM_THREADS
init|=
literal|100
decl_stmt|;
DECL|field|TEST_DIR
specifier|static
specifier|final
name|File
name|TEST_DIR
init|=
name|PathUtils
operator|.
name|getTestDir
argument_list|(
name|TestEditLog
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/** An edits log with 3 edits from 0.20 - the result of    * a fresh namesystem followed by hadoop fs -touchz /myfile */
DECL|field|HADOOP20_SOME_EDITS
specifier|static
specifier|final
name|byte
index|[]
name|HADOOP20_SOME_EDITS
init|=
name|StringUtils
operator|.
name|hexStringToByte
argument_list|(
operator|(
literal|"ffff ffed 0a00 0000 0000 03fa e100 0000"
operator|+
literal|"0005 0007 2f6d 7966 696c 6500 0133 000d"
operator|+
literal|"3132 3932 3331 3634 3034 3138 3400 0d31"
operator|+
literal|"3239 3233 3136 3430 3431 3834 0009 3133"
operator|+
literal|"3432 3137 3732 3800 0000 0004 746f 6464"
operator|+
literal|"0a73 7570 6572 6772 6f75 7001 a400 1544"
operator|+
literal|"4653 436c 6965 6e74 5f2d 3136 3136 3535"
operator|+
literal|"3738 3931 000b 3137 322e 3239 2e35 2e33"
operator|+
literal|"3209 0000 0005 0007 2f6d 7966 696c 6500"
operator|+
literal|"0133 000d 3132 3932 3331 3634 3034 3138"
operator|+
literal|"3400 0d31 3239 3233 3136 3430 3431 3834"
operator|+
literal|"0009 3133 3432 3137 3732 3800 0000 0004"
operator|+
literal|"746f 6464 0a73 7570 6572 6772 6f75 7001"
operator|+
literal|"a4ff 0000 0000 0000 0000 0000 0000 0000"
operator|)
operator|.
name|replace
argument_list|(
literal|" "
argument_list|,
literal|""
argument_list|)
argument_list|)
decl_stmt|;
static|static
block|{
comment|// No need to fsync for the purposes of tests. This makes
comment|// the tests run much faster.
name|EditLogFileOutputStream
operator|.
name|setShouldSkipFsyncForTesting
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
DECL|field|TRAILER_BYTE
specifier|static
specifier|final
name|byte
name|TRAILER_BYTE
init|=
name|FSEditLogOpCodes
operator|.
name|OP_INVALID
operator|.
name|getOpCode
argument_list|()
decl_stmt|;
DECL|field|CHECKPOINT_ON_STARTUP_MIN_TXNS
specifier|private
specifier|static
specifier|final
name|int
name|CHECKPOINT_ON_STARTUP_MIN_TXNS
init|=
literal|100
decl_stmt|;
comment|//
comment|// an object that does a bunch of transactions
comment|//
DECL|class|Transactions
specifier|static
class|class
name|Transactions
implements|implements
name|Runnable
block|{
DECL|field|namesystem
specifier|final
name|FSNamesystem
name|namesystem
decl_stmt|;
DECL|field|numTransactions
specifier|final
name|int
name|numTransactions
decl_stmt|;
DECL|field|replication
specifier|final
name|short
name|replication
init|=
literal|3
decl_stmt|;
DECL|field|blockSize
specifier|final
name|long
name|blockSize
init|=
literal|64
decl_stmt|;
DECL|field|startIndex
specifier|final
name|int
name|startIndex
decl_stmt|;
DECL|method|Transactions (FSNamesystem ns, int numTx, int startIdx)
name|Transactions
parameter_list|(
name|FSNamesystem
name|ns
parameter_list|,
name|int
name|numTx
parameter_list|,
name|int
name|startIdx
parameter_list|)
block|{
name|namesystem
operator|=
name|ns
expr_stmt|;
name|numTransactions
operator|=
name|numTx
expr_stmt|;
name|startIndex
operator|=
name|startIdx
expr_stmt|;
block|}
comment|// add a bunch of transactions.
annotation|@
name|Override
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
name|PermissionStatus
name|p
init|=
name|namesystem
operator|.
name|createFsOwnerPermissions
argument_list|(
operator|new
name|FsPermission
argument_list|(
operator|(
name|short
operator|)
literal|0777
argument_list|)
argument_list|)
decl_stmt|;
name|FSEditLog
name|editLog
init|=
name|namesystem
operator|.
name|getEditLog
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numTransactions
condition|;
name|i
operator|++
control|)
block|{
name|INodeFile
name|inode
init|=
operator|new
name|INodeFile
argument_list|(
name|namesystem
operator|.
name|dir
operator|.
name|allocateNewInodeId
argument_list|()
argument_list|,
literal|null
argument_list|,
name|p
argument_list|,
literal|0L
argument_list|,
literal|0L
argument_list|,
name|BlockInfo
operator|.
name|EMPTY_ARRAY
argument_list|,
name|replication
argument_list|,
name|blockSize
argument_list|)
decl_stmt|;
name|inode
operator|.
name|toUnderConstruction
argument_list|(
literal|""
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|editLog
operator|.
name|logOpenFile
argument_list|(
literal|"/filename"
operator|+
operator|(
name|startIndex
operator|+
name|i
operator|)
argument_list|,
name|inode
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|editLog
operator|.
name|logCloseFile
argument_list|(
literal|"/filename"
operator|+
operator|(
name|startIndex
operator|+
name|i
operator|)
argument_list|,
name|inode
argument_list|)
expr_stmt|;
name|editLog
operator|.
name|logSync
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Construct FSEditLog with default configuration, taking editDirs from NNStorage    *     * @param storage Storage object used by namenode    */
DECL|method|getFSEditLog (NNStorage storage)
specifier|private
specifier|static
name|FSEditLog
name|getFSEditLog
parameter_list|(
name|NNStorage
name|storage
parameter_list|)
throws|throws
name|IOException
block|{
name|Configuration
name|conf
init|=
name|getConf
argument_list|()
decl_stmt|;
comment|// Make sure the edits dirs are set in the provided configuration object.
name|conf
operator|.
name|set
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_EDITS_DIR_KEY
argument_list|,
name|StringUtils
operator|.
name|join
argument_list|(
literal|","
argument_list|,
name|storage
operator|.
name|getEditsDirectories
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|FSEditLog
name|log
init|=
name|FSEditLog
operator|.
name|newInstance
argument_list|(
name|conf
argument_list|,
name|storage
argument_list|,
name|FSNamesystem
operator|.
name|getNamespaceEditsDirs
argument_list|(
name|conf
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|log
return|;
block|}
comment|/**    * Test case for an empty edit log from a prior version of Hadoop.    */
annotation|@
name|Test
DECL|method|testPreTxIdEditLogNoEdits ()
specifier|public
name|void
name|testPreTxIdEditLogNoEdits
parameter_list|()
throws|throws
name|Exception
block|{
name|FSNamesystem
name|namesys
init|=
name|Mockito
operator|.
name|mock
argument_list|(
name|FSNamesystem
operator|.
name|class
argument_list|)
decl_stmt|;
name|namesys
operator|.
name|dir
operator|=
name|Mockito
operator|.
name|mock
argument_list|(
name|FSDirectory
operator|.
name|class
argument_list|)
expr_stmt|;
name|long
name|numEdits
init|=
name|testLoad
argument_list|(
name|StringUtils
operator|.
name|hexStringToByte
argument_list|(
literal|"ffffffed"
argument_list|)
argument_list|,
comment|// just version number
name|namesys
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|numEdits
argument_list|)
expr_stmt|;
block|}
comment|/**    * Test case for loading a very simple edit log from a format    * prior to the inclusion of edit transaction IDs in the log.    */
annotation|@
name|Test
DECL|method|testPreTxidEditLogWithEdits ()
specifier|public
name|void
name|testPreTxidEditLogWithEdits
parameter_list|()
throws|throws
name|Exception
block|{
name|Configuration
name|conf
init|=
name|getConf
argument_list|()
decl_stmt|;
name|MiniDFSCluster
name|cluster
init|=
literal|null
decl_stmt|;
try|try
block|{
name|cluster
operator|=
operator|new
name|MiniDFSCluster
operator|.
name|Builder
argument_list|(
name|conf
argument_list|)
operator|.
name|numDataNodes
argument_list|(
literal|0
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
name|cluster
operator|.
name|waitActive
argument_list|()
expr_stmt|;
specifier|final
name|FSNamesystem
name|namesystem
init|=
name|cluster
operator|.
name|getNamesystem
argument_list|()
decl_stmt|;
name|long
name|numEdits
init|=
name|testLoad
argument_list|(
name|HADOOP20_SOME_EDITS
argument_list|,
name|namesystem
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|3
argument_list|,
name|numEdits
argument_list|)
expr_stmt|;
comment|// Sanity check the edit
name|HdfsFileStatus
name|fileInfo
init|=
name|namesystem
operator|.
name|getFileInfo
argument_list|(
literal|"/myfile"
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|"supergroup"
argument_list|,
name|fileInfo
operator|.
name|getGroup
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|3
argument_list|,
name|fileInfo
operator|.
name|getReplication
argument_list|()
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|cluster
operator|!=
literal|null
condition|)
block|{
name|cluster
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
block|}
block|}
DECL|method|testLoad (byte[] data, FSNamesystem namesys)
specifier|private
name|long
name|testLoad
parameter_list|(
name|byte
index|[]
name|data
parameter_list|,
name|FSNamesystem
name|namesys
parameter_list|)
throws|throws
name|IOException
block|{
name|FSEditLogLoader
name|loader
init|=
operator|new
name|FSEditLogLoader
argument_list|(
name|namesys
argument_list|,
literal|0
argument_list|)
decl_stmt|;
return|return
name|loader
operator|.
name|loadFSEdits
argument_list|(
operator|new
name|EditLogByteInputStream
argument_list|(
name|data
argument_list|)
argument_list|,
literal|1
argument_list|)
return|;
block|}
comment|/**    * Simple test for writing to and rolling the edit log.    */
annotation|@
name|Test
DECL|method|testSimpleEditLog ()
specifier|public
name|void
name|testSimpleEditLog
parameter_list|()
throws|throws
name|IOException
block|{
comment|// start a cluster
name|Configuration
name|conf
init|=
name|getConf
argument_list|()
decl_stmt|;
name|MiniDFSCluster
name|cluster
init|=
literal|null
decl_stmt|;
name|FileSystem
name|fileSys
init|=
literal|null
decl_stmt|;
try|try
block|{
name|cluster
operator|=
operator|new
name|MiniDFSCluster
operator|.
name|Builder
argument_list|(
name|conf
argument_list|)
operator|.
name|numDataNodes
argument_list|(
name|NUM_DATA_NODES
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
name|cluster
operator|.
name|waitActive
argument_list|()
expr_stmt|;
name|fileSys
operator|=
name|cluster
operator|.
name|getFileSystem
argument_list|()
expr_stmt|;
specifier|final
name|FSNamesystem
name|namesystem
init|=
name|cluster
operator|.
name|getNamesystem
argument_list|()
decl_stmt|;
name|FSImage
name|fsimage
init|=
name|namesystem
operator|.
name|getFSImage
argument_list|()
decl_stmt|;
specifier|final
name|FSEditLog
name|editLog
init|=
name|fsimage
operator|.
name|getEditLog
argument_list|()
decl_stmt|;
name|assertExistsInStorageDirs
argument_list|(
name|cluster
argument_list|,
name|NameNodeDirType
operator|.
name|EDITS
argument_list|,
name|NNStorage
operator|.
name|getInProgressEditsFileName
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|editLog
operator|.
name|logSetReplication
argument_list|(
literal|"fakefile"
argument_list|,
operator|(
name|short
operator|)
literal|1
argument_list|)
expr_stmt|;
name|editLog
operator|.
name|logSync
argument_list|()
expr_stmt|;
name|editLog
operator|.
name|rollEditLog
argument_list|(
name|NameNodeLayoutVersion
operator|.
name|CURRENT_LAYOUT_VERSION
argument_list|)
expr_stmt|;
name|assertExistsInStorageDirs
argument_list|(
name|cluster
argument_list|,
name|NameNodeDirType
operator|.
name|EDITS
argument_list|,
name|NNStorage
operator|.
name|getFinalizedEditsFileName
argument_list|(
literal|1
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|assertExistsInStorageDirs
argument_list|(
name|cluster
argument_list|,
name|NameNodeDirType
operator|.
name|EDITS
argument_list|,
name|NNStorage
operator|.
name|getInProgressEditsFileName
argument_list|(
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|editLog
operator|.
name|logSetReplication
argument_list|(
literal|"fakefile"
argument_list|,
operator|(
name|short
operator|)
literal|2
argument_list|)
expr_stmt|;
name|editLog
operator|.
name|logSync
argument_list|()
expr_stmt|;
name|editLog
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|fileSys
operator|!=
literal|null
condition|)
name|fileSys
operator|.
name|close
argument_list|()
expr_stmt|;
if|if
condition|(
name|cluster
operator|!=
literal|null
condition|)
name|cluster
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Tests transaction logging in dfs.    */
annotation|@
name|Test
DECL|method|testMultiThreadedEditLog ()
specifier|public
name|void
name|testMultiThreadedEditLog
parameter_list|()
throws|throws
name|IOException
block|{
name|testEditLog
argument_list|(
literal|2048
argument_list|)
expr_stmt|;
comment|// force edit buffer to automatically sync on each log of edit log entry
name|testEditLog
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
DECL|method|assertExistsInStorageDirs (MiniDFSCluster cluster, NameNodeDirType dirType, String filename)
specifier|private
name|void
name|assertExistsInStorageDirs
parameter_list|(
name|MiniDFSCluster
name|cluster
parameter_list|,
name|NameNodeDirType
name|dirType
parameter_list|,
name|String
name|filename
parameter_list|)
block|{
name|NNStorage
name|storage
init|=
name|cluster
operator|.
name|getNamesystem
argument_list|()
operator|.
name|getFSImage
argument_list|()
operator|.
name|getStorage
argument_list|()
decl_stmt|;
for|for
control|(
name|StorageDirectory
name|sd
range|:
name|storage
operator|.
name|dirIterable
argument_list|(
name|dirType
argument_list|)
control|)
block|{
name|File
name|f
init|=
operator|new
name|File
argument_list|(
name|sd
operator|.
name|getCurrentDir
argument_list|()
argument_list|,
name|filename
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
literal|"Expect that "
operator|+
name|f
operator|+
literal|" exists"
argument_list|,
name|f
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Test edit log with different initial buffer size    *     * @param initialSize initial edit log buffer size    * @throws IOException    */
DECL|method|testEditLog (int initialSize)
specifier|private
name|void
name|testEditLog
parameter_list|(
name|int
name|initialSize
parameter_list|)
throws|throws
name|IOException
block|{
comment|// start a cluster
name|Configuration
name|conf
init|=
name|getConf
argument_list|()
decl_stmt|;
name|MiniDFSCluster
name|cluster
init|=
literal|null
decl_stmt|;
name|FileSystem
name|fileSys
init|=
literal|null
decl_stmt|;
try|try
block|{
name|cluster
operator|=
operator|new
name|MiniDFSCluster
operator|.
name|Builder
argument_list|(
name|conf
argument_list|)
operator|.
name|numDataNodes
argument_list|(
name|NUM_DATA_NODES
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
name|cluster
operator|.
name|waitActive
argument_list|()
expr_stmt|;
name|fileSys
operator|=
name|cluster
operator|.
name|getFileSystem
argument_list|()
expr_stmt|;
specifier|final
name|FSNamesystem
name|namesystem
init|=
name|cluster
operator|.
name|getNamesystem
argument_list|()
decl_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|URI
argument_list|>
name|it
init|=
name|cluster
operator|.
name|getNameDirs
argument_list|(
literal|0
argument_list|)
operator|.
name|iterator
argument_list|()
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|File
name|dir
init|=
operator|new
name|File
argument_list|(
name|it
operator|.
name|next
argument_list|()
operator|.
name|getPath
argument_list|()
argument_list|)
decl_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|dir
argument_list|)
expr_stmt|;
block|}
name|FSImage
name|fsimage
init|=
name|namesystem
operator|.
name|getFSImage
argument_list|()
decl_stmt|;
name|FSEditLog
name|editLog
init|=
name|fsimage
operator|.
name|getEditLog
argument_list|()
decl_stmt|;
comment|// set small size of flush buffer
name|editLog
operator|.
name|setOutputBufferCapacity
argument_list|(
name|initialSize
argument_list|)
expr_stmt|;
comment|// Roll log so new output buffer size takes effect
comment|// we should now be writing to edits_inprogress_3
name|fsimage
operator|.
name|rollEditLog
argument_list|(
name|NameNodeLayoutVersion
operator|.
name|CURRENT_LAYOUT_VERSION
argument_list|)
expr_stmt|;
comment|// Remember the current lastInodeId and will reset it back to test
comment|// loading editlog segments.The transactions in the following allocate new
comment|// inode id to write to editlogs but doesn't create ionde in namespace
name|long
name|originalLastInodeId
init|=
name|namesystem
operator|.
name|dir
operator|.
name|getLastInodeId
argument_list|()
decl_stmt|;
comment|// Create threads and make them run transactions concurrently.
name|Thread
name|threadId
index|[]
init|=
operator|new
name|Thread
index|[
name|NUM_THREADS
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|NUM_THREADS
condition|;
name|i
operator|++
control|)
block|{
name|Transactions
name|trans
init|=
operator|new
name|Transactions
argument_list|(
name|namesystem
argument_list|,
name|NUM_TRANSACTIONS
argument_list|,
name|i
operator|*
name|NUM_TRANSACTIONS
argument_list|)
decl_stmt|;
name|threadId
index|[
name|i
index|]
operator|=
operator|new
name|Thread
argument_list|(
name|trans
argument_list|,
literal|"TransactionThread-"
operator|+
name|i
argument_list|)
expr_stmt|;
name|threadId
index|[
name|i
index|]
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
comment|// wait for all transactions to get over
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|NUM_THREADS
condition|;
name|i
operator|++
control|)
block|{
try|try
block|{
name|threadId
index|[
name|i
index|]
operator|.
name|join
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|i
operator|--
expr_stmt|;
comment|// retry
block|}
block|}
comment|// Reopen some files as for append
name|Transactions
name|trans
init|=
operator|new
name|Transactions
argument_list|(
name|namesystem
argument_list|,
name|NUM_TRANSACTIONS
argument_list|,
name|NUM_TRANSACTIONS
operator|/
literal|2
argument_list|)
decl_stmt|;
name|trans
operator|.
name|run
argument_list|()
expr_stmt|;
comment|// Roll another time to finalize edits_inprogress_3
name|fsimage
operator|.
name|rollEditLog
argument_list|(
name|NameNodeLayoutVersion
operator|.
name|CURRENT_LAYOUT_VERSION
argument_list|)
expr_stmt|;
name|long
name|expectedTxns
init|=
operator|(
operator|(
name|NUM_THREADS
operator|+
literal|1
operator|)
operator|*
literal|2
operator|*
name|NUM_TRANSACTIONS
operator|)
operator|+
literal|2
decl_stmt|;
comment|// +2 for start/end txns
comment|// Verify that we can read in all the transactions that we have written.
comment|// If there were any corruptions, it is likely that the reading in
comment|// of these transactions will throw an exception.
comment|//
name|namesystem
operator|.
name|dir
operator|.
name|resetLastInodeIdWithoutChecking
argument_list|(
name|originalLastInodeId
argument_list|)
expr_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|StorageDirectory
argument_list|>
name|it
init|=
name|fsimage
operator|.
name|getStorage
argument_list|()
operator|.
name|dirIterator
argument_list|(
name|NameNodeDirType
operator|.
name|EDITS
argument_list|)
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|FSEditLogLoader
name|loader
init|=
operator|new
name|FSEditLogLoader
argument_list|(
name|namesystem
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|File
name|editFile
init|=
name|NNStorage
operator|.
name|getFinalizedEditsFile
argument_list|(
name|it
operator|.
name|next
argument_list|()
argument_list|,
literal|3
argument_list|,
literal|3
operator|+
name|expectedTxns
operator|-
literal|1
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
literal|"Expect "
operator|+
name|editFile
operator|+
literal|" exists"
argument_list|,
name|editFile
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Verifying file: "
operator|+
name|editFile
argument_list|)
expr_stmt|;
name|long
name|numEdits
init|=
name|loader
operator|.
name|loadFSEdits
argument_list|(
operator|new
name|EditLogFileInputStream
argument_list|(
name|editFile
argument_list|)
argument_list|,
literal|3
argument_list|)
decl_stmt|;
name|int
name|numLeases
init|=
name|namesystem
operator|.
name|leaseManager
operator|.
name|countLease
argument_list|()
decl_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Number of outstanding leases "
operator|+
name|numLeases
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|numLeases
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"Verification for "
operator|+
name|editFile
operator|+
literal|" failed. "
operator|+
literal|"Expected "
operator|+
name|expectedTxns
operator|+
literal|" transactions. "
operator|+
literal|"Found "
operator|+
name|numEdits
operator|+
literal|" transactions."
argument_list|,
name|numEdits
operator|==
name|expectedTxns
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
try|try
block|{
if|if
condition|(
name|fileSys
operator|!=
literal|null
condition|)
name|fileSys
operator|.
name|close
argument_list|()
expr_stmt|;
if|if
condition|(
name|cluster
operator|!=
literal|null
condition|)
name|cluster
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Couldn't shut down cleanly"
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|doLogEdit (ExecutorService exec, final FSEditLog log, final String filename)
specifier|private
name|void
name|doLogEdit
parameter_list|(
name|ExecutorService
name|exec
parameter_list|,
specifier|final
name|FSEditLog
name|log
parameter_list|,
specifier|final
name|String
name|filename
parameter_list|)
throws|throws
name|Exception
block|{
name|exec
operator|.
name|submit
argument_list|(
operator|new
name|Callable
argument_list|<
name|Void
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Void
name|call
parameter_list|()
block|{
name|log
operator|.
name|logSetReplication
argument_list|(
name|filename
argument_list|,
operator|(
name|short
operator|)
literal|1
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
argument_list|)
operator|.
name|get
argument_list|()
expr_stmt|;
block|}
DECL|method|doCallLogSync (ExecutorService exec, final FSEditLog log)
specifier|private
name|void
name|doCallLogSync
parameter_list|(
name|ExecutorService
name|exec
parameter_list|,
specifier|final
name|FSEditLog
name|log
parameter_list|)
throws|throws
name|Exception
block|{
name|exec
operator|.
name|submit
argument_list|(
operator|new
name|Callable
argument_list|<
name|Void
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Void
name|call
parameter_list|()
block|{
name|log
operator|.
name|logSync
argument_list|()
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
argument_list|)
operator|.
name|get
argument_list|()
expr_stmt|;
block|}
DECL|method|doCallLogSyncAll (ExecutorService exec, final FSEditLog log)
specifier|private
name|void
name|doCallLogSyncAll
parameter_list|(
name|ExecutorService
name|exec
parameter_list|,
specifier|final
name|FSEditLog
name|log
parameter_list|)
throws|throws
name|Exception
block|{
name|exec
operator|.
name|submit
argument_list|(
operator|new
name|Callable
argument_list|<
name|Void
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Void
name|call
parameter_list|()
throws|throws
name|Exception
block|{
name|log
operator|.
name|logSyncAll
argument_list|()
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
argument_list|)
operator|.
name|get
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testSyncBatching ()
specifier|public
name|void
name|testSyncBatching
parameter_list|()
throws|throws
name|Exception
block|{
if|if
condition|(
name|useAsyncEditLog
condition|)
block|{
comment|// semantics are completely differently since edits will be auto-synced
return|return;
block|}
comment|// start a cluster
name|Configuration
name|conf
init|=
name|getConf
argument_list|()
decl_stmt|;
name|MiniDFSCluster
name|cluster
init|=
literal|null
decl_stmt|;
name|FileSystem
name|fileSys
init|=
literal|null
decl_stmt|;
name|ExecutorService
name|threadA
init|=
name|Executors
operator|.
name|newSingleThreadExecutor
argument_list|()
decl_stmt|;
name|ExecutorService
name|threadB
init|=
name|Executors
operator|.
name|newSingleThreadExecutor
argument_list|()
decl_stmt|;
try|try
block|{
name|cluster
operator|=
operator|new
name|MiniDFSCluster
operator|.
name|Builder
argument_list|(
name|conf
argument_list|)
operator|.
name|numDataNodes
argument_list|(
name|NUM_DATA_NODES
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
name|cluster
operator|.
name|waitActive
argument_list|()
expr_stmt|;
name|fileSys
operator|=
name|cluster
operator|.
name|getFileSystem
argument_list|()
expr_stmt|;
specifier|final
name|FSNamesystem
name|namesystem
init|=
name|cluster
operator|.
name|getNamesystem
argument_list|()
decl_stmt|;
name|FSImage
name|fsimage
init|=
name|namesystem
operator|.
name|getFSImage
argument_list|()
decl_stmt|;
specifier|final
name|FSEditLog
name|editLog
init|=
name|fsimage
operator|.
name|getEditLog
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
literal|"should start with only the BEGIN_LOG_SEGMENT txn synced"
argument_list|,
literal|1
argument_list|,
name|editLog
operator|.
name|getSyncTxId
argument_list|()
argument_list|)
expr_stmt|;
comment|// Log an edit from thread A
name|doLogEdit
argument_list|(
name|threadA
argument_list|,
name|editLog
argument_list|,
literal|"thread-a 1"
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"logging edit without syncing should do not affect txid"
argument_list|,
literal|1
argument_list|,
name|editLog
operator|.
name|getSyncTxId
argument_list|()
argument_list|)
expr_stmt|;
comment|// Log an edit from thread B
name|doLogEdit
argument_list|(
name|threadB
argument_list|,
name|editLog
argument_list|,
literal|"thread-b 1"
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"logging edit without syncing should do not affect txid"
argument_list|,
literal|1
argument_list|,
name|editLog
operator|.
name|getSyncTxId
argument_list|()
argument_list|)
expr_stmt|;
comment|// Now ask to sync edit from B, which should sync both edits.
name|doCallLogSync
argument_list|(
name|threadB
argument_list|,
name|editLog
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"logSync from second thread should bump txid up to 3"
argument_list|,
literal|3
argument_list|,
name|editLog
operator|.
name|getSyncTxId
argument_list|()
argument_list|)
expr_stmt|;
comment|// Now ask to sync edit from A, which was already batched in - thus
comment|// it should increment the batch count metric
name|doCallLogSync
argument_list|(
name|threadA
argument_list|,
name|editLog
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"logSync from first thread shouldn't change txid"
argument_list|,
literal|3
argument_list|,
name|editLog
operator|.
name|getSyncTxId
argument_list|()
argument_list|)
expr_stmt|;
comment|//Should have incremented the batch count exactly once
name|assertCounter
argument_list|(
literal|"TransactionsBatchedInSync"
argument_list|,
literal|1L
argument_list|,
name|getMetrics
argument_list|(
literal|"NameNodeActivity"
argument_list|)
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|threadA
operator|.
name|shutdown
argument_list|()
expr_stmt|;
name|threadB
operator|.
name|shutdown
argument_list|()
expr_stmt|;
if|if
condition|(
name|fileSys
operator|!=
literal|null
condition|)
name|fileSys
operator|.
name|close
argument_list|()
expr_stmt|;
if|if
condition|(
name|cluster
operator|!=
literal|null
condition|)
name|cluster
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Test what happens with the following sequence:    *    *  Thread A writes edit    *  Thread B calls logSyncAll    *           calls close() on stream    *  Thread A calls logSync    *    * This sequence is legal and can occur if enterSafeMode() is closely    * followed by saveNamespace.    */
annotation|@
name|Test
DECL|method|testBatchedSyncWithClosedLogs ()
specifier|public
name|void
name|testBatchedSyncWithClosedLogs
parameter_list|()
throws|throws
name|Exception
block|{
comment|// start a cluster
name|Configuration
name|conf
init|=
name|getConf
argument_list|()
decl_stmt|;
name|MiniDFSCluster
name|cluster
init|=
literal|null
decl_stmt|;
name|FileSystem
name|fileSys
init|=
literal|null
decl_stmt|;
name|ExecutorService
name|threadA
init|=
name|Executors
operator|.
name|newSingleThreadExecutor
argument_list|()
decl_stmt|;
name|ExecutorService
name|threadB
init|=
name|Executors
operator|.
name|newSingleThreadExecutor
argument_list|()
decl_stmt|;
try|try
block|{
name|cluster
operator|=
operator|new
name|MiniDFSCluster
operator|.
name|Builder
argument_list|(
name|conf
argument_list|)
operator|.
name|numDataNodes
argument_list|(
name|NUM_DATA_NODES
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
name|cluster
operator|.
name|waitActive
argument_list|()
expr_stmt|;
name|fileSys
operator|=
name|cluster
operator|.
name|getFileSystem
argument_list|()
expr_stmt|;
specifier|final
name|FSNamesystem
name|namesystem
init|=
name|cluster
operator|.
name|getNamesystem
argument_list|()
decl_stmt|;
name|FSImage
name|fsimage
init|=
name|namesystem
operator|.
name|getFSImage
argument_list|()
decl_stmt|;
specifier|final
name|FSEditLog
name|editLog
init|=
name|fsimage
operator|.
name|getEditLog
argument_list|()
decl_stmt|;
comment|// Log an edit from thread A
name|doLogEdit
argument_list|(
name|threadA
argument_list|,
name|editLog
argument_list|,
literal|"thread-a 1"
argument_list|)
expr_stmt|;
comment|// async log is doing batched syncs in background.  logSync just ensures
comment|// the edit is durable, so the txid may increase prior to sync
if|if
condition|(
operator|!
name|useAsyncEditLog
condition|)
block|{
name|assertEquals
argument_list|(
literal|"logging edit without syncing should do not affect txid"
argument_list|,
literal|1
argument_list|,
name|editLog
operator|.
name|getSyncTxId
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// logSyncAll in Thread B
name|doCallLogSyncAll
argument_list|(
name|threadB
argument_list|,
name|editLog
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"logSyncAll should sync thread A's transaction"
argument_list|,
literal|2
argument_list|,
name|editLog
operator|.
name|getSyncTxId
argument_list|()
argument_list|)
expr_stmt|;
comment|// Close edit log
name|editLog
operator|.
name|close
argument_list|()
expr_stmt|;
comment|// Ask thread A to finish sync (which should be a no-op)
name|doCallLogSync
argument_list|(
name|threadA
argument_list|,
name|editLog
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|threadA
operator|.
name|shutdown
argument_list|()
expr_stmt|;
name|threadB
operator|.
name|shutdown
argument_list|()
expr_stmt|;
if|if
condition|(
name|fileSys
operator|!=
literal|null
condition|)
name|fileSys
operator|.
name|close
argument_list|()
expr_stmt|;
if|if
condition|(
name|cluster
operator|!=
literal|null
condition|)
name|cluster
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Test
DECL|method|testEditChecksum ()
specifier|public
name|void
name|testEditChecksum
parameter_list|()
throws|throws
name|Exception
block|{
comment|// start a cluster
name|Configuration
name|conf
init|=
name|getConf
argument_list|()
decl_stmt|;
name|MiniDFSCluster
name|cluster
init|=
literal|null
decl_stmt|;
name|FileSystem
name|fileSys
init|=
literal|null
decl_stmt|;
name|cluster
operator|=
operator|new
name|MiniDFSCluster
operator|.
name|Builder
argument_list|(
name|conf
argument_list|)
operator|.
name|numDataNodes
argument_list|(
name|NUM_DATA_NODES
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
name|cluster
operator|.
name|waitActive
argument_list|()
expr_stmt|;
name|fileSys
operator|=
name|cluster
operator|.
name|getFileSystem
argument_list|()
expr_stmt|;
specifier|final
name|FSNamesystem
name|namesystem
init|=
name|cluster
operator|.
name|getNamesystem
argument_list|()
decl_stmt|;
name|FSImage
name|fsimage
init|=
name|namesystem
operator|.
name|getFSImage
argument_list|()
decl_stmt|;
specifier|final
name|FSEditLog
name|editLog
init|=
name|fsimage
operator|.
name|getEditLog
argument_list|()
decl_stmt|;
name|fileSys
operator|.
name|mkdirs
argument_list|(
operator|new
name|Path
argument_list|(
literal|"/tmp"
argument_list|)
argument_list|)
expr_stmt|;
name|Iterator
argument_list|<
name|StorageDirectory
argument_list|>
name|iter
init|=
name|fsimage
operator|.
name|getStorage
argument_list|()
operator|.
name|dirIterator
argument_list|(
name|NameNodeDirType
operator|.
name|EDITS
argument_list|)
decl_stmt|;
name|LinkedList
argument_list|<
name|StorageDirectory
argument_list|>
name|sds
init|=
operator|new
name|LinkedList
argument_list|<
name|StorageDirectory
argument_list|>
argument_list|()
decl_stmt|;
while|while
condition|(
name|iter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|sds
operator|.
name|add
argument_list|(
name|iter
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|editLog
operator|.
name|close
argument_list|()
expr_stmt|;
name|cluster
operator|.
name|shutdown
argument_list|()
expr_stmt|;
for|for
control|(
name|StorageDirectory
name|sd
range|:
name|sds
control|)
block|{
name|File
name|editFile
init|=
name|NNStorage
operator|.
name|getFinalizedEditsFile
argument_list|(
name|sd
argument_list|,
literal|1
argument_list|,
literal|3
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|editFile
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
name|long
name|fileLen
init|=
name|editFile
operator|.
name|length
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Corrupting Log File: "
operator|+
name|editFile
operator|+
literal|" len: "
operator|+
name|fileLen
argument_list|)
expr_stmt|;
name|RandomAccessFile
name|rwf
init|=
operator|new
name|RandomAccessFile
argument_list|(
name|editFile
argument_list|,
literal|"rw"
argument_list|)
decl_stmt|;
name|rwf
operator|.
name|seek
argument_list|(
name|fileLen
operator|-
literal|4
argument_list|)
expr_stmt|;
comment|// seek to checksum bytes
name|int
name|b
init|=
name|rwf
operator|.
name|readInt
argument_list|()
decl_stmt|;
name|rwf
operator|.
name|seek
argument_list|(
name|fileLen
operator|-
literal|4
argument_list|)
expr_stmt|;
name|rwf
operator|.
name|writeInt
argument_list|(
name|b
operator|+
literal|1
argument_list|)
expr_stmt|;
name|rwf
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
try|try
block|{
name|cluster
operator|=
operator|new
name|MiniDFSCluster
operator|.
name|Builder
argument_list|(
name|conf
argument_list|)
operator|.
name|numDataNodes
argument_list|(
name|NUM_DATA_NODES
argument_list|)
operator|.
name|format
argument_list|(
literal|false
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
name|fail
argument_list|(
literal|"should not be able to start"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// expected
name|assertNotNull
argument_list|(
literal|"Cause of exception should be ChecksumException"
argument_list|,
name|e
operator|.
name|getCause
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Cause of exception should be ChecksumException"
argument_list|,
name|ChecksumException
operator|.
name|class
argument_list|,
name|e
operator|.
name|getCause
argument_list|()
operator|.
name|getClass
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Test what happens if the NN crashes when it has has started but    * had no transactions written.    */
annotation|@
name|Test
DECL|method|testCrashRecoveryNoTransactions ()
specifier|public
name|void
name|testCrashRecoveryNoTransactions
parameter_list|()
throws|throws
name|Exception
block|{
name|testCrashRecovery
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/**    * Test what happens if the NN crashes when it has has started and    * had a few transactions written    */
annotation|@
name|Test
DECL|method|testCrashRecoveryWithTransactions ()
specifier|public
name|void
name|testCrashRecoveryWithTransactions
parameter_list|()
throws|throws
name|Exception
block|{
name|testCrashRecovery
argument_list|(
literal|150
argument_list|)
expr_stmt|;
block|}
comment|/**    * Do a test to make sure the edit log can recover edits even after    * a non-clean shutdown. This does a simulated crash by copying over    * the edits directory while the NN is still running, then shutting it    * down, and restoring that edits directory.    */
DECL|method|testCrashRecovery (int numTransactions)
specifier|private
name|void
name|testCrashRecovery
parameter_list|(
name|int
name|numTransactions
parameter_list|)
throws|throws
name|Exception
block|{
name|MiniDFSCluster
name|cluster
init|=
literal|null
decl_stmt|;
name|Configuration
name|conf
init|=
name|getConf
argument_list|()
decl_stmt|;
name|conf
operator|.
name|setInt
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_CHECKPOINT_TXNS_KEY
argument_list|,
name|CHECKPOINT_ON_STARTUP_MIN_TXNS
argument_list|)
expr_stmt|;
try|try
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"\n===========================================\n"
operator|+
literal|"Starting empty cluster"
argument_list|)
expr_stmt|;
name|cluster
operator|=
operator|new
name|MiniDFSCluster
operator|.
name|Builder
argument_list|(
name|conf
argument_list|)
operator|.
name|numDataNodes
argument_list|(
name|NUM_DATA_NODES
argument_list|)
operator|.
name|format
argument_list|(
literal|true
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
name|cluster
operator|.
name|waitActive
argument_list|()
expr_stmt|;
name|FileSystem
name|fs
init|=
name|cluster
operator|.
name|getFileSystem
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numTransactions
condition|;
name|i
operator|++
control|)
block|{
name|fs
operator|.
name|mkdirs
argument_list|(
operator|new
name|Path
argument_list|(
literal|"/test"
operator|+
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Directory layout looks like:
comment|// test/data/dfs/nameN/current/{fsimage_N,edits_...}
name|File
name|nameDir
init|=
operator|new
name|File
argument_list|(
name|cluster
operator|.
name|getNameDirs
argument_list|(
literal|0
argument_list|)
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
operator|.
name|getPath
argument_list|()
argument_list|)
decl_stmt|;
name|File
name|dfsDir
init|=
name|nameDir
operator|.
name|getParentFile
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
name|dfsDir
operator|.
name|getName
argument_list|()
argument_list|,
literal|"dfs"
argument_list|)
expr_stmt|;
comment|// make sure we got right dir
name|LOG
operator|.
name|info
argument_list|(
literal|"Copying data directory aside to a hot backup"
argument_list|)
expr_stmt|;
name|File
name|backupDir
init|=
operator|new
name|File
argument_list|(
name|dfsDir
operator|.
name|getParentFile
argument_list|()
argument_list|,
literal|"dfs.backup-while-running"
argument_list|)
decl_stmt|;
name|FileUtils
operator|.
name|copyDirectory
argument_list|(
name|dfsDir
argument_list|,
name|backupDir
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Shutting down cluster #1"
argument_list|)
expr_stmt|;
name|cluster
operator|.
name|shutdown
argument_list|()
expr_stmt|;
name|cluster
operator|=
literal|null
expr_stmt|;
comment|// Now restore the backup
name|FileUtil
operator|.
name|fullyDeleteContents
argument_list|(
name|dfsDir
argument_list|)
expr_stmt|;
name|dfsDir
operator|.
name|delete
argument_list|()
expr_stmt|;
name|backupDir
operator|.
name|renameTo
argument_list|(
name|dfsDir
argument_list|)
expr_stmt|;
comment|// Directory layout looks like:
comment|// test/data/dfs/nameN/current/{fsimage_N,edits_...}
name|File
name|currentDir
init|=
operator|new
name|File
argument_list|(
name|nameDir
argument_list|,
literal|"current"
argument_list|)
decl_stmt|;
comment|// We should see the file as in-progress
name|File
name|editsFile
init|=
operator|new
name|File
argument_list|(
name|currentDir
argument_list|,
name|NNStorage
operator|.
name|getInProgressEditsFileName
argument_list|(
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
literal|"Edits file "
operator|+
name|editsFile
operator|+
literal|" should exist"
argument_list|,
name|editsFile
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
name|File
name|imageFile
init|=
name|FSImageTestUtil
operator|.
name|findNewestImageFile
argument_list|(
name|currentDir
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
decl_stmt|;
name|assertNotNull
argument_list|(
literal|"No image found in "
operator|+
name|nameDir
argument_list|,
name|imageFile
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|NNStorage
operator|.
name|getImageFileName
argument_list|(
literal|0
argument_list|)
argument_list|,
name|imageFile
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
comment|// Try to start a new cluster
name|LOG
operator|.
name|info
argument_list|(
literal|"\n===========================================\n"
operator|+
literal|"Starting same cluster after simulated crash"
argument_list|)
expr_stmt|;
name|cluster
operator|=
operator|new
name|MiniDFSCluster
operator|.
name|Builder
argument_list|(
name|conf
argument_list|)
operator|.
name|numDataNodes
argument_list|(
name|NUM_DATA_NODES
argument_list|)
operator|.
name|format
argument_list|(
literal|false
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
name|cluster
operator|.
name|waitActive
argument_list|()
expr_stmt|;
comment|// We should still have the files we wrote prior to the simulated crash
name|fs
operator|=
name|cluster
operator|.
name|getFileSystem
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numTransactions
condition|;
name|i
operator|++
control|)
block|{
name|assertTrue
argument_list|(
name|fs
operator|.
name|exists
argument_list|(
operator|new
name|Path
argument_list|(
literal|"/test"
operator|+
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|long
name|expectedTxId
decl_stmt|;
if|if
condition|(
name|numTransactions
operator|>
name|CHECKPOINT_ON_STARTUP_MIN_TXNS
condition|)
block|{
comment|// It should have saved a checkpoint on startup since there
comment|// were more unfinalized edits than configured
name|expectedTxId
operator|=
name|numTransactions
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|// otherwise, it shouldn't have made a checkpoint
name|expectedTxId
operator|=
literal|0
expr_stmt|;
block|}
name|imageFile
operator|=
name|FSImageTestUtil
operator|.
name|findNewestImageFile
argument_list|(
name|currentDir
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
name|assertNotNull
argument_list|(
literal|"No image found in "
operator|+
name|nameDir
argument_list|,
name|imageFile
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|NNStorage
operator|.
name|getImageFileName
argument_list|(
name|expectedTxId
argument_list|)
argument_list|,
name|imageFile
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
comment|// Started successfully. Shut it down and make sure it can restart.
name|cluster
operator|.
name|shutdown
argument_list|()
expr_stmt|;
name|cluster
operator|=
literal|null
expr_stmt|;
name|cluster
operator|=
operator|new
name|MiniDFSCluster
operator|.
name|Builder
argument_list|(
name|conf
argument_list|)
operator|.
name|numDataNodes
argument_list|(
name|NUM_DATA_NODES
argument_list|)
operator|.
name|format
argument_list|(
literal|false
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
name|cluster
operator|.
name|waitActive
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|cluster
operator|!=
literal|null
condition|)
block|{
name|cluster
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|// should succeed - only one corrupt log dir
annotation|@
name|Test
DECL|method|testCrashRecoveryEmptyLogOneDir ()
specifier|public
name|void
name|testCrashRecoveryEmptyLogOneDir
parameter_list|()
throws|throws
name|Exception
block|{
name|doTestCrashRecoveryEmptyLog
argument_list|(
literal|false
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|// should fail - seen_txid updated to 3, but no log dir contains txid 3
annotation|@
name|Test
DECL|method|testCrashRecoveryEmptyLogBothDirs ()
specifier|public
name|void
name|testCrashRecoveryEmptyLogBothDirs
parameter_list|()
throws|throws
name|Exception
block|{
name|doTestCrashRecoveryEmptyLog
argument_list|(
literal|true
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|// should succeed - only one corrupt log dir
annotation|@
name|Test
DECL|method|testCrashRecoveryEmptyLogOneDirNoUpdateSeenTxId ()
specifier|public
name|void
name|testCrashRecoveryEmptyLogOneDirNoUpdateSeenTxId
parameter_list|()
throws|throws
name|Exception
block|{
name|doTestCrashRecoveryEmptyLog
argument_list|(
literal|false
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|// should succeed - both log dirs corrupt, but seen_txid never updated
annotation|@
name|Test
DECL|method|testCrashRecoveryEmptyLogBothDirsNoUpdateSeenTxId ()
specifier|public
name|void
name|testCrashRecoveryEmptyLogBothDirsNoUpdateSeenTxId
parameter_list|()
throws|throws
name|Exception
block|{
name|doTestCrashRecoveryEmptyLog
argument_list|(
literal|true
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**    * Test that the NN handles the corruption properly    * after it crashes just after creating an edit log    * (ie before writing START_LOG_SEGMENT). In the case    * that all logs have this problem, it should mark them    * as corrupt instead of trying to finalize them.    *     * @param inBothDirs if true, there will be a truncated log in    * both of the edits directories. If false, the truncated log    * will only be in one of the directories. In both cases, the    * NN should fail to start up, because it's aware that txid 3    * was reached, but unable to find a non-corrupt log starting there.    * @param updateTransactionIdFile if true update the seen_txid file.    * If false, it will not be updated. This will simulate a case where    * the NN crashed between creating the new segment and updating the    * seen_txid file.    * @param shouldSucceed true if the test is expected to succeed.    */
DECL|method|doTestCrashRecoveryEmptyLog (boolean inBothDirs, boolean updateTransactionIdFile, boolean shouldSucceed)
specifier|private
name|void
name|doTestCrashRecoveryEmptyLog
parameter_list|(
name|boolean
name|inBothDirs
parameter_list|,
name|boolean
name|updateTransactionIdFile
parameter_list|,
name|boolean
name|shouldSucceed
parameter_list|)
throws|throws
name|Exception
block|{
comment|// start a cluster
name|Configuration
name|conf
init|=
name|getConf
argument_list|()
decl_stmt|;
name|MiniDFSCluster
name|cluster
init|=
literal|null
decl_stmt|;
name|cluster
operator|=
operator|new
name|MiniDFSCluster
operator|.
name|Builder
argument_list|(
name|conf
argument_list|)
operator|.
name|numDataNodes
argument_list|(
name|NUM_DATA_NODES
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
name|cluster
operator|.
name|shutdown
argument_list|()
expr_stmt|;
name|Collection
argument_list|<
name|URI
argument_list|>
name|editsDirs
init|=
name|cluster
operator|.
name|getNameEditsDirs
argument_list|(
literal|0
argument_list|)
decl_stmt|;
for|for
control|(
name|URI
name|uri
range|:
name|editsDirs
control|)
block|{
name|File
name|dir
init|=
operator|new
name|File
argument_list|(
name|uri
operator|.
name|getPath
argument_list|()
argument_list|)
decl_stmt|;
name|File
name|currentDir
init|=
operator|new
name|File
argument_list|(
name|dir
argument_list|,
literal|"current"
argument_list|)
decl_stmt|;
comment|// We should start with only the finalized edits_1-2
name|GenericTestUtils
operator|.
name|assertGlobEquals
argument_list|(
name|currentDir
argument_list|,
literal|"edits_.*"
argument_list|,
name|NNStorage
operator|.
name|getFinalizedEditsFileName
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
comment|// Make a truncated edits_3_inprogress
name|File
name|log
init|=
operator|new
name|File
argument_list|(
name|currentDir
argument_list|,
name|NNStorage
operator|.
name|getInProgressEditsFileName
argument_list|(
literal|3
argument_list|)
argument_list|)
decl_stmt|;
name|EditLogFileOutputStream
name|stream
init|=
operator|new
name|EditLogFileOutputStream
argument_list|(
name|conf
argument_list|,
name|log
argument_list|,
literal|1024
argument_list|)
decl_stmt|;
try|try
block|{
name|stream
operator|.
name|create
argument_list|(
name|NameNodeLayoutVersion
operator|.
name|CURRENT_LAYOUT_VERSION
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|inBothDirs
condition|)
block|{
break|break;
block|}
name|NNStorage
name|storage
init|=
operator|new
name|NNStorage
argument_list|(
name|conf
argument_list|,
name|Collections
operator|.
expr|<
name|URI
operator|>
name|emptyList
argument_list|()
argument_list|,
name|Lists
operator|.
name|newArrayList
argument_list|(
name|uri
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|updateTransactionIdFile
condition|)
block|{
name|storage
operator|.
name|writeTransactionIdFileToStorage
argument_list|(
literal|3
argument_list|)
expr_stmt|;
block|}
name|storage
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|stream
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
try|try
block|{
name|cluster
operator|=
operator|new
name|MiniDFSCluster
operator|.
name|Builder
argument_list|(
name|conf
argument_list|)
operator|.
name|numDataNodes
argument_list|(
name|NUM_DATA_NODES
argument_list|)
operator|.
name|format
argument_list|(
literal|false
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|shouldSucceed
condition|)
block|{
name|fail
argument_list|(
literal|"Should not have succeeded in startin cluster"
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
if|if
condition|(
name|shouldSucceed
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Should have succeeded in starting cluster, but failed"
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
throw|throw
name|ioe
throw|;
block|}
else|else
block|{
name|GenericTestUtils
operator|.
name|assertExceptionContains
argument_list|(
literal|"Gap in transactions. Expected to be able to read up until "
operator|+
literal|"at least txid 3 but unable to find any edit logs containing "
operator|+
literal|"txid 3"
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|cluster
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
block|}
DECL|class|EditLogByteInputStream
specifier|private
specifier|static
class|class
name|EditLogByteInputStream
extends|extends
name|EditLogInputStream
block|{
DECL|field|input
specifier|private
specifier|final
name|InputStream
name|input
decl_stmt|;
DECL|field|len
specifier|private
specifier|final
name|long
name|len
decl_stmt|;
DECL|field|version
specifier|private
name|int
name|version
decl_stmt|;
DECL|field|reader
specifier|private
name|FSEditLogOp
operator|.
name|Reader
name|reader
init|=
literal|null
decl_stmt|;
DECL|field|tracker
specifier|private
name|FSEditLogLoader
operator|.
name|PositionTrackingInputStream
name|tracker
init|=
literal|null
decl_stmt|;
DECL|method|EditLogByteInputStream (byte[] data)
specifier|public
name|EditLogByteInputStream
parameter_list|(
name|byte
index|[]
name|data
parameter_list|)
throws|throws
name|IOException
block|{
name|len
operator|=
name|data
operator|.
name|length
expr_stmt|;
name|input
operator|=
operator|new
name|ByteArrayInputStream
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|BufferedInputStream
name|bin
init|=
operator|new
name|BufferedInputStream
argument_list|(
name|input
argument_list|)
decl_stmt|;
name|DataInputStream
name|in
init|=
operator|new
name|DataInputStream
argument_list|(
name|bin
argument_list|)
decl_stmt|;
name|version
operator|=
name|EditLogFileInputStream
operator|.
name|readLogVersion
argument_list|(
name|in
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|tracker
operator|=
operator|new
name|FSEditLogLoader
operator|.
name|PositionTrackingInputStream
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|in
operator|=
operator|new
name|DataInputStream
argument_list|(
name|tracker
argument_list|)
expr_stmt|;
name|reader
operator|=
name|FSEditLogOp
operator|.
name|Reader
operator|.
name|create
argument_list|(
name|in
argument_list|,
name|tracker
argument_list|,
name|version
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getFirstTxId ()
specifier|public
name|long
name|getFirstTxId
parameter_list|()
block|{
return|return
name|HdfsServerConstants
operator|.
name|INVALID_TXID
return|;
block|}
annotation|@
name|Override
DECL|method|getLastTxId ()
specifier|public
name|long
name|getLastTxId
parameter_list|()
block|{
return|return
name|HdfsServerConstants
operator|.
name|INVALID_TXID
return|;
block|}
annotation|@
name|Override
DECL|method|length ()
specifier|public
name|long
name|length
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|len
return|;
block|}
annotation|@
name|Override
DECL|method|getPosition ()
specifier|public
name|long
name|getPosition
parameter_list|()
block|{
return|return
name|tracker
operator|.
name|getPos
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|nextOp ()
specifier|protected
name|FSEditLogOp
name|nextOp
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|reader
operator|.
name|readOp
argument_list|(
literal|false
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|getVersion (boolean verifyVersion)
specifier|public
name|int
name|getVersion
parameter_list|(
name|boolean
name|verifyVersion
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|version
return|;
block|}
annotation|@
name|Override
DECL|method|close ()
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
name|input
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getName ()
specifier|public
name|String
name|getName
parameter_list|()
block|{
return|return
literal|"AnonEditLogByteInputStream"
return|;
block|}
annotation|@
name|Override
DECL|method|isInProgress ()
specifier|public
name|boolean
name|isInProgress
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
annotation|@
name|Override
DECL|method|setMaxOpSize (int maxOpSize)
specifier|public
name|void
name|setMaxOpSize
parameter_list|(
name|int
name|maxOpSize
parameter_list|)
block|{
name|reader
operator|.
name|setMaxOpSize
argument_list|(
name|maxOpSize
argument_list|)
expr_stmt|;
block|}
DECL|method|isLocalLog ()
annotation|@
name|Override
specifier|public
name|boolean
name|isLocalLog
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
block|}
annotation|@
name|Test
DECL|method|testFailedOpen ()
specifier|public
name|void
name|testFailedOpen
parameter_list|()
throws|throws
name|Exception
block|{
name|File
name|logDir
init|=
operator|new
name|File
argument_list|(
name|TEST_DIR
argument_list|,
literal|"testFailedOpen"
argument_list|)
decl_stmt|;
name|logDir
operator|.
name|mkdirs
argument_list|()
expr_stmt|;
name|FSEditLog
name|log
init|=
name|FSImageTestUtil
operator|.
name|createStandaloneEditLog
argument_list|(
name|logDir
argument_list|)
decl_stmt|;
try|try
block|{
name|FileUtil
operator|.
name|setWritable
argument_list|(
name|logDir
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|log
operator|.
name|openForWrite
argument_list|(
name|NameNodeLayoutVersion
operator|.
name|CURRENT_LAYOUT_VERSION
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"Did no throw exception on only having a bad dir"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|GenericTestUtils
operator|.
name|assertExceptionContains
argument_list|(
literal|"too few journals successfully started"
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|FileUtil
operator|.
name|setWritable
argument_list|(
name|logDir
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|log
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Regression test for HDFS-1112/HDFS-3020. Ensures that, even if    * logSync isn't called periodically, the edit log will sync itself.    */
annotation|@
name|Test
DECL|method|testAutoSync ()
specifier|public
name|void
name|testAutoSync
parameter_list|()
throws|throws
name|Exception
block|{
name|File
name|logDir
init|=
operator|new
name|File
argument_list|(
name|TEST_DIR
argument_list|,
literal|"testAutoSync"
argument_list|)
decl_stmt|;
name|logDir
operator|.
name|mkdirs
argument_list|()
expr_stmt|;
name|FSEditLog
name|log
init|=
name|FSImageTestUtil
operator|.
name|createStandaloneEditLog
argument_list|(
name|logDir
argument_list|)
decl_stmt|;
name|String
name|oneKB
init|=
name|StringUtils
operator|.
name|byteToHexString
argument_list|(
operator|new
name|byte
index|[
literal|500
index|]
argument_list|)
decl_stmt|;
try|try
block|{
name|log
operator|.
name|openForWrite
argument_list|(
name|NameNodeLayoutVersion
operator|.
name|CURRENT_LAYOUT_VERSION
argument_list|)
expr_stmt|;
name|NameNodeMetrics
name|mockMetrics
init|=
name|Mockito
operator|.
name|mock
argument_list|(
name|NameNodeMetrics
operator|.
name|class
argument_list|)
decl_stmt|;
name|log
operator|.
name|setMetricsForTests
argument_list|(
name|mockMetrics
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|400
condition|;
name|i
operator|++
control|)
block|{
name|log
operator|.
name|logDelete
argument_list|(
name|oneKB
argument_list|,
literal|1L
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|// After ~400KB, we're still within the 512KB buffer size
name|Mockito
operator|.
name|verify
argument_list|(
name|mockMetrics
argument_list|,
name|Mockito
operator|.
name|times
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|.
name|addSync
argument_list|(
name|Mockito
operator|.
name|anyLong
argument_list|()
argument_list|)
expr_stmt|;
comment|// After ~400KB more, we should have done an automatic sync
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|400
condition|;
name|i
operator|++
control|)
block|{
name|log
operator|.
name|logDelete
argument_list|(
name|oneKB
argument_list|,
literal|1L
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
name|Mockito
operator|.
name|verify
argument_list|(
name|mockMetrics
argument_list|,
name|Mockito
operator|.
name|times
argument_list|(
literal|1
argument_list|)
argument_list|)
operator|.
name|addSync
argument_list|(
name|Mockito
operator|.
name|anyLong
argument_list|()
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|log
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Tests the getEditLogManifest function using mock storage for a number    * of different situations.    */
annotation|@
name|Test
DECL|method|testEditLogManifestMocks ()
specifier|public
name|void
name|testEditLogManifestMocks
parameter_list|()
throws|throws
name|IOException
block|{
name|NNStorage
name|storage
decl_stmt|;
name|FSEditLog
name|log
decl_stmt|;
comment|// Simple case - different directories have the same
comment|// set of logs, with an in-progress one at end
name|storage
operator|=
name|mockStorageWithEdits
argument_list|(
literal|"[1,100]|[101,200]|[201,]"
argument_list|,
literal|"[1,100]|[101,200]|[201,]"
argument_list|)
expr_stmt|;
name|log
operator|=
name|getFSEditLog
argument_list|(
name|storage
argument_list|)
expr_stmt|;
name|log
operator|.
name|initJournalsForWrite
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
literal|"[[1,100], [101,200]] CommittedTxId: 200"
argument_list|,
name|log
operator|.
name|getEditLogManifest
argument_list|(
literal|1
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"[[101,200]] CommittedTxId: 200"
argument_list|,
name|log
operator|.
name|getEditLogManifest
argument_list|(
literal|101
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
comment|// Another simple case, different directories have different
comment|// sets of files
name|storage
operator|=
name|mockStorageWithEdits
argument_list|(
literal|"[1,100]|[101,200]"
argument_list|,
literal|"[1,100]|[201,300]|[301,400]"
argument_list|)
expr_stmt|;
comment|// nothing starting at 101
name|log
operator|=
name|getFSEditLog
argument_list|(
name|storage
argument_list|)
expr_stmt|;
name|log
operator|.
name|initJournalsForWrite
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
literal|"[[1,100], [101,200], [201,300], [301,400]]"
operator|+
literal|" CommittedTxId: 400"
argument_list|,
name|log
operator|.
name|getEditLogManifest
argument_list|(
literal|1
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
comment|// Case where one directory has an earlier finalized log, followed
comment|// by a gap. The returned manifest should start after the gap.
name|storage
operator|=
name|mockStorageWithEdits
argument_list|(
literal|"[1,100]|[301,400]"
argument_list|,
comment|// gap from 101 to 300
literal|"[301,400]|[401,500]"
argument_list|)
expr_stmt|;
name|log
operator|=
name|getFSEditLog
argument_list|(
name|storage
argument_list|)
expr_stmt|;
name|log
operator|.
name|initJournalsForWrite
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
literal|"[[301,400], [401,500]] CommittedTxId: 500"
argument_list|,
name|log
operator|.
name|getEditLogManifest
argument_list|(
literal|1
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
comment|// Case where different directories have different length logs
comment|// starting at the same txid - should pick the longer one
name|storage
operator|=
name|mockStorageWithEdits
argument_list|(
literal|"[1,100]|[101,150]"
argument_list|,
comment|// short log at 101
literal|"[1,50]|[101,200]"
argument_list|)
expr_stmt|;
comment|// short log at 1
name|log
operator|=
name|getFSEditLog
argument_list|(
name|storage
argument_list|)
expr_stmt|;
name|log
operator|.
name|initJournalsForWrite
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
literal|"[[1,100], [101,200]] CommittedTxId: 200"
argument_list|,
name|log
operator|.
name|getEditLogManifest
argument_list|(
literal|1
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"[[101,200]] CommittedTxId: 200"
argument_list|,
name|log
operator|.
name|getEditLogManifest
argument_list|(
literal|101
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
comment|// Case where the first storage has an inprogress while
comment|// the second has finalised that file (i.e. the first failed
comment|// recently)
name|storage
operator|=
name|mockStorageWithEdits
argument_list|(
literal|"[1,100]|[101,]"
argument_list|,
literal|"[1,100]|[101,200]"
argument_list|)
expr_stmt|;
name|log
operator|=
name|getFSEditLog
argument_list|(
name|storage
argument_list|)
expr_stmt|;
name|log
operator|.
name|initJournalsForWrite
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
literal|"[[1,100], [101,200]] CommittedTxId: 200"
argument_list|,
name|log
operator|.
name|getEditLogManifest
argument_list|(
literal|1
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"[[101,200]] CommittedTxId: 200"
argument_list|,
name|log
operator|.
name|getEditLogManifest
argument_list|(
literal|101
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Create a mock NNStorage object with several directories, each directory    * holding edit logs according to a specification. Each directory    * is specified by a pipe-separated string. For example:    *<code>[1,100]|[101,200]</code> specifies a directory which    * includes two finalized segments, one from 1-100, and one from 101-200.    * The syntax<code>[1,]</code> specifies an in-progress log starting at    * txid 1.    */
DECL|method|mockStorageWithEdits (String... editsDirSpecs)
specifier|private
name|NNStorage
name|mockStorageWithEdits
parameter_list|(
name|String
modifier|...
name|editsDirSpecs
parameter_list|)
throws|throws
name|IOException
block|{
name|List
argument_list|<
name|StorageDirectory
argument_list|>
name|sds
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|URI
argument_list|>
name|uris
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
name|NNStorage
name|storage
init|=
name|Mockito
operator|.
name|mock
argument_list|(
name|NNStorage
operator|.
name|class
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|dirSpec
range|:
name|editsDirSpecs
control|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|files
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
name|String
index|[]
name|logSpecs
init|=
name|dirSpec
operator|.
name|split
argument_list|(
literal|"\\|"
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|logSpec
range|:
name|logSpecs
control|)
block|{
name|Matcher
name|m
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"\\[(\\d+),(\\d+)?\\]"
argument_list|)
operator|.
name|matcher
argument_list|(
name|logSpec
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
literal|"bad spec: "
operator|+
name|logSpec
argument_list|,
name|m
operator|.
name|matches
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|.
name|group
argument_list|(
literal|2
argument_list|)
operator|==
literal|null
condition|)
block|{
name|files
operator|.
name|add
argument_list|(
name|NNStorage
operator|.
name|getInProgressEditsFileName
argument_list|(
name|Long
operator|.
name|parseLong
argument_list|(
name|m
operator|.
name|group
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|files
operator|.
name|add
argument_list|(
name|NNStorage
operator|.
name|getFinalizedEditsFileName
argument_list|(
name|Long
operator|.
name|parseLong
argument_list|(
name|m
operator|.
name|group
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|,
name|Long
operator|.
name|parseLong
argument_list|(
name|m
operator|.
name|group
argument_list|(
literal|2
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|StorageDirectory
name|sd
init|=
name|FSImageTestUtil
operator|.
name|mockStorageDirectory
argument_list|(
name|NameNodeDirType
operator|.
name|EDITS
argument_list|,
literal|false
argument_list|,
name|files
operator|.
name|toArray
argument_list|(
operator|new
name|String
index|[
literal|0
index|]
argument_list|)
argument_list|)
decl_stmt|;
name|sds
operator|.
name|add
argument_list|(
name|sd
argument_list|)
expr_stmt|;
name|URI
name|u
init|=
name|URI
operator|.
name|create
argument_list|(
literal|"file:///storage"
operator|+
name|Math
operator|.
name|random
argument_list|()
argument_list|)
decl_stmt|;
name|Mockito
operator|.
name|doReturn
argument_list|(
name|sd
argument_list|)
operator|.
name|when
argument_list|(
name|storage
argument_list|)
operator|.
name|getStorageDirectory
argument_list|(
name|u
argument_list|)
expr_stmt|;
name|uris
operator|.
name|add
argument_list|(
name|u
argument_list|)
expr_stmt|;
block|}
name|Mockito
operator|.
name|doReturn
argument_list|(
name|sds
argument_list|)
operator|.
name|when
argument_list|(
name|storage
argument_list|)
operator|.
name|dirIterable
argument_list|(
name|NameNodeDirType
operator|.
name|EDITS
argument_list|)
expr_stmt|;
name|Mockito
operator|.
name|doReturn
argument_list|(
name|uris
argument_list|)
operator|.
name|when
argument_list|(
name|storage
argument_list|)
operator|.
name|getEditsDirectories
argument_list|()
expr_stmt|;
return|return
name|storage
return|;
block|}
comment|/**     * Specification for a failure during #setupEdits    */
DECL|class|AbortSpec
specifier|static
class|class
name|AbortSpec
block|{
DECL|field|roll
specifier|final
name|int
name|roll
decl_stmt|;
DECL|field|logindex
specifier|final
name|int
name|logindex
decl_stmt|;
comment|/**      * Construct the failure specification.       * @param roll number to fail after. e.g. 1 to fail after the first roll      * @param logindex index of journal to fail.      */
DECL|method|AbortSpec (int roll, int logindex)
name|AbortSpec
parameter_list|(
name|int
name|roll
parameter_list|,
name|int
name|logindex
parameter_list|)
block|{
name|this
operator|.
name|roll
operator|=
name|roll
expr_stmt|;
name|this
operator|.
name|logindex
operator|=
name|logindex
expr_stmt|;
block|}
block|}
DECL|field|TXNS_PER_ROLL
specifier|final
specifier|static
name|int
name|TXNS_PER_ROLL
init|=
literal|10
decl_stmt|;
DECL|field|TXNS_PER_FAIL
specifier|final
specifier|static
name|int
name|TXNS_PER_FAIL
init|=
literal|2
decl_stmt|;
comment|/**    * Set up directories for tests.     *    * Each rolled file is 10 txns long.     * A failed file is 2 txns long.    *     * @param editUris directories to create edit logs in    * @param numrolls number of times to roll the edit log during setup    * @param closeOnFinish whether to close the edit log after setup    * @param abortAtRolls Specifications for when to fail, see AbortSpec    */
DECL|method|setupEdits (List<URI> editUris, int numrolls, boolean closeOnFinish, AbortSpec... abortAtRolls)
specifier|public
specifier|static
name|NNStorage
name|setupEdits
parameter_list|(
name|List
argument_list|<
name|URI
argument_list|>
name|editUris
parameter_list|,
name|int
name|numrolls
parameter_list|,
name|boolean
name|closeOnFinish
parameter_list|,
name|AbortSpec
modifier|...
name|abortAtRolls
parameter_list|)
throws|throws
name|IOException
block|{
name|List
argument_list|<
name|AbortSpec
argument_list|>
name|aborts
init|=
operator|new
name|ArrayList
argument_list|<
name|AbortSpec
argument_list|>
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|abortAtRolls
argument_list|)
argument_list|)
decl_stmt|;
name|NNStorage
name|storage
init|=
operator|new
name|NNStorage
argument_list|(
name|getConf
argument_list|()
argument_list|,
name|Collections
operator|.
expr|<
name|URI
operator|>
name|emptyList
argument_list|()
argument_list|,
name|editUris
argument_list|)
decl_stmt|;
name|storage
operator|.
name|format
argument_list|(
operator|new
name|NamespaceInfo
argument_list|()
argument_list|)
expr_stmt|;
name|FSEditLog
name|editlog
init|=
name|getFSEditLog
argument_list|(
name|storage
argument_list|)
decl_stmt|;
comment|// open the edit log and add two transactions
comment|// logGenerationStamp is used, simply because it doesn't
comment|// require complex arguments.
name|editlog
operator|.
name|initJournalsForWrite
argument_list|()
expr_stmt|;
name|editlog
operator|.
name|openForWrite
argument_list|(
name|NameNodeLayoutVersion
operator|.
name|CURRENT_LAYOUT_VERSION
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|2
init|;
name|i
operator|<
name|TXNS_PER_ROLL
condition|;
name|i
operator|++
control|)
block|{
name|editlog
operator|.
name|logGenerationStamp
argument_list|(
operator|(
name|long
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
name|editlog
operator|.
name|logSync
argument_list|()
expr_stmt|;
comment|// Go into edit log rolling loop.
comment|// On each roll, the abortAtRolls abort specs are
comment|// checked to see if an abort is required. If so the
comment|// the specified journal is aborted. It will be brought
comment|// back into rotation automatically by rollEditLog
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numrolls
condition|;
name|i
operator|++
control|)
block|{
name|editlog
operator|.
name|rollEditLog
argument_list|(
name|NameNodeLayoutVersion
operator|.
name|CURRENT_LAYOUT_VERSION
argument_list|)
expr_stmt|;
name|editlog
operator|.
name|logGenerationStamp
argument_list|(
operator|(
name|long
operator|)
name|i
argument_list|)
expr_stmt|;
name|editlog
operator|.
name|logSync
argument_list|()
expr_stmt|;
while|while
condition|(
name|aborts
operator|.
name|size
argument_list|()
operator|>
literal|0
operator|&&
name|aborts
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|roll
operator|==
operator|(
name|i
operator|+
literal|1
operator|)
condition|)
block|{
name|AbortSpec
name|spec
init|=
name|aborts
operator|.
name|remove
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|editlog
operator|.
name|getJournals
argument_list|()
operator|.
name|get
argument_list|(
name|spec
operator|.
name|logindex
argument_list|)
operator|.
name|abort
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|int
name|j
init|=
literal|3
init|;
name|j
operator|<
name|TXNS_PER_ROLL
condition|;
name|j
operator|++
control|)
block|{
name|editlog
operator|.
name|logGenerationStamp
argument_list|(
operator|(
name|long
operator|)
name|i
argument_list|)
expr_stmt|;
block|}
name|editlog
operator|.
name|logSync
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|closeOnFinish
condition|)
block|{
name|editlog
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
name|FSImageTestUtil
operator|.
name|logStorageContents
argument_list|(
name|LOG
argument_list|,
name|storage
argument_list|)
expr_stmt|;
return|return
name|storage
return|;
block|}
comment|/**    * Set up directories for tests.     *    * Each rolled file is 10 txns long.     * A failed file is 2 txns long.    *     * @param editUris directories to create edit logs in    * @param numrolls number of times to roll the edit log during setup    * @param abortAtRolls Specifications for when to fail, see AbortSpec    */
DECL|method|setupEdits (List<URI> editUris, int numrolls, AbortSpec... abortAtRolls)
specifier|public
specifier|static
name|NNStorage
name|setupEdits
parameter_list|(
name|List
argument_list|<
name|URI
argument_list|>
name|editUris
parameter_list|,
name|int
name|numrolls
parameter_list|,
name|AbortSpec
modifier|...
name|abortAtRolls
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|setupEdits
argument_list|(
name|editUris
argument_list|,
name|numrolls
argument_list|,
literal|true
argument_list|,
name|abortAtRolls
argument_list|)
return|;
block|}
comment|/**     * Test loading an editlog which has had both its storage fail    * on alternating rolls. Two edit log directories are created.    * The first one fails on odd rolls, the second on even. Test    * that we are able to load the entire editlog regardless.    */
annotation|@
name|Test
DECL|method|testAlternatingJournalFailure ()
specifier|public
name|void
name|testAlternatingJournalFailure
parameter_list|()
throws|throws
name|IOException
block|{
name|File
name|f1
init|=
operator|new
name|File
argument_list|(
name|TEST_DIR
operator|+
literal|"/alternatingjournaltest0"
argument_list|)
decl_stmt|;
name|File
name|f2
init|=
operator|new
name|File
argument_list|(
name|TEST_DIR
operator|+
literal|"/alternatingjournaltest1"
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|URI
argument_list|>
name|editUris
init|=
name|ImmutableList
operator|.
name|of
argument_list|(
name|f1
operator|.
name|toURI
argument_list|()
argument_list|,
name|f2
operator|.
name|toURI
argument_list|()
argument_list|)
decl_stmt|;
name|NNStorage
name|storage
init|=
name|setupEdits
argument_list|(
name|editUris
argument_list|,
literal|10
argument_list|,
operator|new
name|AbortSpec
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|new
name|AbortSpec
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|)
argument_list|,
operator|new
name|AbortSpec
argument_list|(
literal|3
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|new
name|AbortSpec
argument_list|(
literal|4
argument_list|,
literal|1
argument_list|)
argument_list|,
operator|new
name|AbortSpec
argument_list|(
literal|5
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|new
name|AbortSpec
argument_list|(
literal|6
argument_list|,
literal|1
argument_list|)
argument_list|,
operator|new
name|AbortSpec
argument_list|(
literal|7
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|new
name|AbortSpec
argument_list|(
literal|8
argument_list|,
literal|1
argument_list|)
argument_list|,
operator|new
name|AbortSpec
argument_list|(
literal|9
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|new
name|AbortSpec
argument_list|(
literal|10
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|long
name|totaltxnread
init|=
literal|0
decl_stmt|;
name|FSEditLog
name|editlog
init|=
name|getFSEditLog
argument_list|(
name|storage
argument_list|)
decl_stmt|;
name|editlog
operator|.
name|initJournalsForWrite
argument_list|()
expr_stmt|;
name|long
name|startTxId
init|=
literal|1
decl_stmt|;
name|Iterable
argument_list|<
name|EditLogInputStream
argument_list|>
name|editStreams
init|=
name|editlog
operator|.
name|selectInputStreams
argument_list|(
name|startTxId
argument_list|,
name|TXNS_PER_ROLL
operator|*
literal|11
argument_list|)
decl_stmt|;
for|for
control|(
name|EditLogInputStream
name|edits
range|:
name|editStreams
control|)
block|{
name|FSEditLogLoader
operator|.
name|EditLogValidation
name|val
init|=
name|FSEditLogLoader
operator|.
name|scanEditLog
argument_list|(
name|edits
argument_list|,
name|Long
operator|.
name|MAX_VALUE
argument_list|)
decl_stmt|;
name|long
name|read
init|=
operator|(
name|val
operator|.
name|getEndTxId
argument_list|()
operator|-
name|edits
operator|.
name|getFirstTxId
argument_list|()
operator|)
operator|+
literal|1
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Loading edits "
operator|+
name|edits
operator|+
literal|" read "
operator|+
name|read
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|startTxId
argument_list|,
name|edits
operator|.
name|getFirstTxId
argument_list|()
argument_list|)
expr_stmt|;
name|startTxId
operator|+=
name|read
expr_stmt|;
name|totaltxnread
operator|+=
name|read
expr_stmt|;
block|}
name|editlog
operator|.
name|close
argument_list|()
expr_stmt|;
name|storage
operator|.
name|close
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
name|TXNS_PER_ROLL
operator|*
literal|11
argument_list|,
name|totaltxnread
argument_list|)
expr_stmt|;
block|}
comment|/**     * Test loading an editlog with gaps. A single editlog directory    * is set up. On of the edit log files is deleted. This should    * fail when selecting the input streams as it will not be able     * to select enough streams to load up to 4*TXNS_PER_ROLL.    * There should be 4*TXNS_PER_ROLL transactions as we rolled 3    * times.     */
annotation|@
name|Test
DECL|method|testLoadingWithGaps ()
specifier|public
name|void
name|testLoadingWithGaps
parameter_list|()
throws|throws
name|IOException
block|{
name|File
name|f1
init|=
operator|new
name|File
argument_list|(
name|TEST_DIR
operator|+
literal|"/gaptest0"
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|URI
argument_list|>
name|editUris
init|=
name|ImmutableList
operator|.
name|of
argument_list|(
name|f1
operator|.
name|toURI
argument_list|()
argument_list|)
decl_stmt|;
name|NNStorage
name|storage
init|=
name|setupEdits
argument_list|(
name|editUris
argument_list|,
literal|3
argument_list|)
decl_stmt|;
specifier|final
name|long
name|startGapTxId
init|=
literal|1
operator|*
name|TXNS_PER_ROLL
operator|+
literal|1
decl_stmt|;
specifier|final
name|long
name|endGapTxId
init|=
literal|2
operator|*
name|TXNS_PER_ROLL
decl_stmt|;
name|File
index|[]
name|files
init|=
operator|new
name|File
argument_list|(
name|f1
argument_list|,
literal|"current"
argument_list|)
operator|.
name|listFiles
argument_list|(
operator|new
name|FilenameFilter
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|accept
parameter_list|(
name|File
name|dir
parameter_list|,
name|String
name|name
parameter_list|)
block|{
if|if
condition|(
name|name
operator|.
name|startsWith
argument_list|(
name|NNStorage
operator|.
name|getFinalizedEditsFileName
argument_list|(
name|startGapTxId
argument_list|,
name|endGapTxId
argument_list|)
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
block|}
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|files
operator|.
name|length
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|files
index|[
literal|0
index|]
operator|.
name|delete
argument_list|()
argument_list|)
expr_stmt|;
name|FSEditLog
name|editlog
init|=
name|getFSEditLog
argument_list|(
name|storage
argument_list|)
decl_stmt|;
name|editlog
operator|.
name|initJournalsForWrite
argument_list|()
expr_stmt|;
name|long
name|startTxId
init|=
literal|1
decl_stmt|;
try|try
block|{
name|editlog
operator|.
name|selectInputStreams
argument_list|(
name|startTxId
argument_list|,
literal|4
operator|*
name|TXNS_PER_ROLL
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"Should have thrown exception"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|GenericTestUtils
operator|.
name|assertExceptionContains
argument_list|(
literal|"Gap in transactions. Expected to be able to read up until "
operator|+
literal|"at least txid 40 but unable to find any edit logs containing "
operator|+
literal|"txid 11"
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Test that we can read from a byte stream without crashing.    *    */
DECL|method|validateNoCrash (byte garbage[])
specifier|static
name|void
name|validateNoCrash
parameter_list|(
name|byte
name|garbage
index|[]
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|File
name|TEST_LOG_NAME
init|=
operator|new
name|File
argument_list|(
name|TEST_DIR
argument_list|,
literal|"test_edit_log"
argument_list|)
decl_stmt|;
name|EditLogFileOutputStream
name|elfos
init|=
literal|null
decl_stmt|;
name|EditLogFileInputStream
name|elfis
init|=
literal|null
decl_stmt|;
try|try
block|{
name|elfos
operator|=
operator|new
name|EditLogFileOutputStream
argument_list|(
name|getConf
argument_list|()
argument_list|,
name|TEST_LOG_NAME
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|elfos
operator|.
name|create
argument_list|(
name|NameNodeLayoutVersion
operator|.
name|CURRENT_LAYOUT_VERSION
argument_list|)
expr_stmt|;
name|elfos
operator|.
name|writeRaw
argument_list|(
name|garbage
argument_list|,
literal|0
argument_list|,
name|garbage
operator|.
name|length
argument_list|)
expr_stmt|;
name|elfos
operator|.
name|setReadyToFlush
argument_list|()
expr_stmt|;
name|elfos
operator|.
name|flushAndSync
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|elfos
operator|.
name|close
argument_list|()
expr_stmt|;
name|elfos
operator|=
literal|null
expr_stmt|;
name|elfis
operator|=
operator|new
name|EditLogFileInputStream
argument_list|(
name|TEST_LOG_NAME
argument_list|)
expr_stmt|;
comment|// verify that we can read everything without killing the JVM or
comment|// throwing an exception other than IOException
try|try
block|{
while|while
condition|(
literal|true
condition|)
block|{
name|FSEditLogOp
name|op
init|=
name|elfis
operator|.
name|readOp
argument_list|()
decl_stmt|;
if|if
condition|(
name|op
operator|==
literal|null
condition|)
break|break;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{       }
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|fail
argument_list|(
literal|"Caught non-IOException throwable "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
if|if
condition|(
operator|(
name|elfos
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|elfos
operator|.
name|isOpen
argument_list|()
operator|)
condition|)
name|elfos
operator|.
name|close
argument_list|()
expr_stmt|;
if|if
condition|(
name|elfis
operator|!=
literal|null
condition|)
name|elfis
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
DECL|field|invalidSequenecs
specifier|static
name|byte
index|[]
index|[]
name|invalidSequenecs
init|=
literal|null
decl_stmt|;
comment|/**    * "Fuzz" test for the edit log.    *    * This tests that we can read random garbage from the edit log without    * crashing the JVM or throwing an unchecked exception.    */
annotation|@
name|Test
DECL|method|testFuzzSequences ()
specifier|public
name|void
name|testFuzzSequences
parameter_list|()
throws|throws
name|IOException
block|{
specifier|final
name|int
name|MAX_GARBAGE_LENGTH
init|=
literal|512
decl_stmt|;
specifier|final
name|int
name|MAX_INVALID_SEQ
init|=
literal|5000
decl_stmt|;
comment|// The seed to use for our random number generator.  When given the same
comment|// seed, Java.util.Random will always produce the same sequence of values.
comment|// This is important because it means that the test is deterministic and
comment|// repeatable on any machine.
specifier|final
name|int
name|RANDOM_SEED
init|=
literal|123
decl_stmt|;
name|Random
name|r
init|=
operator|new
name|Random
argument_list|(
name|RANDOM_SEED
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|MAX_INVALID_SEQ
condition|;
name|i
operator|++
control|)
block|{
name|byte
index|[]
name|garbage
init|=
operator|new
name|byte
index|[
name|r
operator|.
name|nextInt
argument_list|(
name|MAX_GARBAGE_LENGTH
argument_list|)
index|]
decl_stmt|;
name|r
operator|.
name|nextBytes
argument_list|(
name|garbage
argument_list|)
expr_stmt|;
name|validateNoCrash
argument_list|(
name|garbage
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|readAllEdits (Collection<EditLogInputStream> streams, long startTxId)
specifier|private
specifier|static
name|long
name|readAllEdits
parameter_list|(
name|Collection
argument_list|<
name|EditLogInputStream
argument_list|>
name|streams
parameter_list|,
name|long
name|startTxId
parameter_list|)
throws|throws
name|IOException
block|{
name|FSEditLogOp
name|op
decl_stmt|;
name|long
name|nextTxId
init|=
name|startTxId
decl_stmt|;
name|long
name|numTx
init|=
literal|0
decl_stmt|;
for|for
control|(
name|EditLogInputStream
name|s
range|:
name|streams
control|)
block|{
while|while
condition|(
literal|true
condition|)
block|{
name|op
operator|=
name|s
operator|.
name|readOp
argument_list|()
expr_stmt|;
if|if
condition|(
name|op
operator|==
literal|null
condition|)
break|break;
if|if
condition|(
name|op
operator|.
name|getTransactionId
argument_list|()
operator|!=
name|nextTxId
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"out of order transaction ID!  expected "
operator|+
name|nextTxId
operator|+
literal|" but got "
operator|+
name|op
operator|.
name|getTransactionId
argument_list|()
operator|+
literal|" when "
operator|+
literal|"reading "
operator|+
name|s
operator|.
name|getName
argument_list|()
argument_list|)
throw|;
block|}
name|numTx
operator|++
expr_stmt|;
name|nextTxId
operator|=
name|op
operator|.
name|getTransactionId
argument_list|()
operator|+
literal|1
expr_stmt|;
block|}
block|}
return|return
name|numTx
return|;
block|}
comment|/**    * Test edit log failover.  If a single edit log is missing, other     * edits logs should be used instead.    */
annotation|@
name|Test
DECL|method|testEditLogFailOverFromMissing ()
specifier|public
name|void
name|testEditLogFailOverFromMissing
parameter_list|()
throws|throws
name|IOException
block|{
name|File
name|f1
init|=
operator|new
name|File
argument_list|(
name|TEST_DIR
operator|+
literal|"/failover0"
argument_list|)
decl_stmt|;
name|File
name|f2
init|=
operator|new
name|File
argument_list|(
name|TEST_DIR
operator|+
literal|"/failover1"
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|URI
argument_list|>
name|editUris
init|=
name|ImmutableList
operator|.
name|of
argument_list|(
name|f1
operator|.
name|toURI
argument_list|()
argument_list|,
name|f2
operator|.
name|toURI
argument_list|()
argument_list|)
decl_stmt|;
name|NNStorage
name|storage
init|=
name|setupEdits
argument_list|(
name|editUris
argument_list|,
literal|3
argument_list|)
decl_stmt|;
specifier|final
name|long
name|startErrorTxId
init|=
literal|1
operator|*
name|TXNS_PER_ROLL
operator|+
literal|1
decl_stmt|;
specifier|final
name|long
name|endErrorTxId
init|=
literal|2
operator|*
name|TXNS_PER_ROLL
decl_stmt|;
name|File
index|[]
name|files
init|=
operator|new
name|File
argument_list|(
name|f1
argument_list|,
literal|"current"
argument_list|)
operator|.
name|listFiles
argument_list|(
operator|new
name|FilenameFilter
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|accept
parameter_list|(
name|File
name|dir
parameter_list|,
name|String
name|name
parameter_list|)
block|{
if|if
condition|(
name|name
operator|.
name|startsWith
argument_list|(
name|NNStorage
operator|.
name|getFinalizedEditsFileName
argument_list|(
name|startErrorTxId
argument_list|,
name|endErrorTxId
argument_list|)
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
block|}
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|files
operator|.
name|length
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|files
index|[
literal|0
index|]
operator|.
name|delete
argument_list|()
argument_list|)
expr_stmt|;
name|FSEditLog
name|editlog
init|=
name|getFSEditLog
argument_list|(
name|storage
argument_list|)
decl_stmt|;
name|editlog
operator|.
name|initJournalsForWrite
argument_list|()
expr_stmt|;
name|long
name|startTxId
init|=
literal|1
decl_stmt|;
name|Collection
argument_list|<
name|EditLogInputStream
argument_list|>
name|streams
init|=
literal|null
decl_stmt|;
try|try
block|{
name|streams
operator|=
name|editlog
operator|.
name|selectInputStreams
argument_list|(
name|startTxId
argument_list|,
literal|4
operator|*
name|TXNS_PER_ROLL
argument_list|)
expr_stmt|;
name|readAllEdits
argument_list|(
name|streams
argument_list|,
name|startTxId
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"edit log failover didn't work"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"Edit log failover didn't work"
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|IOUtils
operator|.
name|cleanup
argument_list|(
literal|null
argument_list|,
name|streams
operator|.
name|toArray
argument_list|(
operator|new
name|EditLogInputStream
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**     * Test edit log failover from a corrupt edit log    */
annotation|@
name|Test
DECL|method|testEditLogFailOverFromCorrupt ()
specifier|public
name|void
name|testEditLogFailOverFromCorrupt
parameter_list|()
throws|throws
name|IOException
block|{
name|File
name|f1
init|=
operator|new
name|File
argument_list|(
name|TEST_DIR
operator|+
literal|"/failover0"
argument_list|)
decl_stmt|;
name|File
name|f2
init|=
operator|new
name|File
argument_list|(
name|TEST_DIR
operator|+
literal|"/failover1"
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|URI
argument_list|>
name|editUris
init|=
name|ImmutableList
operator|.
name|of
argument_list|(
name|f1
operator|.
name|toURI
argument_list|()
argument_list|,
name|f2
operator|.
name|toURI
argument_list|()
argument_list|)
decl_stmt|;
name|NNStorage
name|storage
init|=
name|setupEdits
argument_list|(
name|editUris
argument_list|,
literal|3
argument_list|)
decl_stmt|;
specifier|final
name|long
name|startErrorTxId
init|=
literal|1
operator|*
name|TXNS_PER_ROLL
operator|+
literal|1
decl_stmt|;
specifier|final
name|long
name|endErrorTxId
init|=
literal|2
operator|*
name|TXNS_PER_ROLL
decl_stmt|;
name|File
index|[]
name|files
init|=
operator|new
name|File
argument_list|(
name|f1
argument_list|,
literal|"current"
argument_list|)
operator|.
name|listFiles
argument_list|(
operator|new
name|FilenameFilter
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|accept
parameter_list|(
name|File
name|dir
parameter_list|,
name|String
name|name
parameter_list|)
block|{
if|if
condition|(
name|name
operator|.
name|startsWith
argument_list|(
name|NNStorage
operator|.
name|getFinalizedEditsFileName
argument_list|(
name|startErrorTxId
argument_list|,
name|endErrorTxId
argument_list|)
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
block|}
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|files
operator|.
name|length
argument_list|)
expr_stmt|;
name|long
name|fileLen
init|=
name|files
index|[
literal|0
index|]
operator|.
name|length
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Corrupting Log File: "
operator|+
name|files
index|[
literal|0
index|]
operator|+
literal|" len: "
operator|+
name|fileLen
argument_list|)
expr_stmt|;
name|RandomAccessFile
name|rwf
init|=
operator|new
name|RandomAccessFile
argument_list|(
name|files
index|[
literal|0
index|]
argument_list|,
literal|"rw"
argument_list|)
decl_stmt|;
name|rwf
operator|.
name|seek
argument_list|(
name|fileLen
operator|-
literal|4
argument_list|)
expr_stmt|;
comment|// seek to checksum bytes
name|int
name|b
init|=
name|rwf
operator|.
name|readInt
argument_list|()
decl_stmt|;
name|rwf
operator|.
name|seek
argument_list|(
name|fileLen
operator|-
literal|4
argument_list|)
expr_stmt|;
name|rwf
operator|.
name|writeInt
argument_list|(
name|b
operator|+
literal|1
argument_list|)
expr_stmt|;
name|rwf
operator|.
name|close
argument_list|()
expr_stmt|;
name|FSEditLog
name|editlog
init|=
name|getFSEditLog
argument_list|(
name|storage
argument_list|)
decl_stmt|;
name|editlog
operator|.
name|initJournalsForWrite
argument_list|()
expr_stmt|;
name|long
name|startTxId
init|=
literal|1
decl_stmt|;
name|Collection
argument_list|<
name|EditLogInputStream
argument_list|>
name|streams
init|=
literal|null
decl_stmt|;
try|try
block|{
name|streams
operator|=
name|editlog
operator|.
name|selectInputStreams
argument_list|(
name|startTxId
argument_list|,
literal|4
operator|*
name|TXNS_PER_ROLL
argument_list|)
expr_stmt|;
name|readAllEdits
argument_list|(
name|streams
argument_list|,
name|startTxId
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"edit log failover didn't work"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"Edit log failover didn't work"
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|IOUtils
operator|.
name|cleanup
argument_list|(
literal|null
argument_list|,
name|streams
operator|.
name|toArray
argument_list|(
operator|new
name|EditLogInputStream
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Test creating a directory with lots and lots of edit log segments    */
annotation|@
name|Test
DECL|method|testManyEditLogSegments ()
specifier|public
name|void
name|testManyEditLogSegments
parameter_list|()
throws|throws
name|IOException
block|{
specifier|final
name|int
name|NUM_EDIT_LOG_ROLLS
init|=
literal|1000
decl_stmt|;
comment|// start a cluster
name|Configuration
name|conf
init|=
name|getConf
argument_list|()
decl_stmt|;
name|MiniDFSCluster
name|cluster
init|=
literal|null
decl_stmt|;
name|FileSystem
name|fileSys
init|=
literal|null
decl_stmt|;
try|try
block|{
name|cluster
operator|=
operator|new
name|MiniDFSCluster
operator|.
name|Builder
argument_list|(
name|conf
argument_list|)
operator|.
name|numDataNodes
argument_list|(
name|NUM_DATA_NODES
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
name|cluster
operator|.
name|waitActive
argument_list|()
expr_stmt|;
name|fileSys
operator|=
name|cluster
operator|.
name|getFileSystem
argument_list|()
expr_stmt|;
specifier|final
name|FSNamesystem
name|namesystem
init|=
name|cluster
operator|.
name|getNamesystem
argument_list|()
decl_stmt|;
name|FSImage
name|fsimage
init|=
name|namesystem
operator|.
name|getFSImage
argument_list|()
decl_stmt|;
specifier|final
name|FSEditLog
name|editLog
init|=
name|fsimage
operator|.
name|getEditLog
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|NUM_EDIT_LOG_ROLLS
condition|;
name|i
operator|++
control|)
block|{
name|editLog
operator|.
name|logSetReplication
argument_list|(
literal|"fakefile"
operator|+
name|i
argument_list|,
call|(
name|short
call|)
argument_list|(
name|i
operator|%
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|assertExistsInStorageDirs
argument_list|(
name|cluster
argument_list|,
name|NameNodeDirType
operator|.
name|EDITS
argument_list|,
name|NNStorage
operator|.
name|getInProgressEditsFileName
argument_list|(
operator|(
name|i
operator|*
literal|3
operator|)
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|editLog
operator|.
name|logSync
argument_list|()
expr_stmt|;
name|editLog
operator|.
name|rollEditLog
argument_list|(
name|NameNodeLayoutVersion
operator|.
name|CURRENT_LAYOUT_VERSION
argument_list|)
expr_stmt|;
name|assertExistsInStorageDirs
argument_list|(
name|cluster
argument_list|,
name|NameNodeDirType
operator|.
name|EDITS
argument_list|,
name|NNStorage
operator|.
name|getFinalizedEditsFileName
argument_list|(
operator|(
name|i
operator|*
literal|3
operator|)
operator|+
literal|1
argument_list|,
operator|(
name|i
operator|*
literal|3
operator|)
operator|+
literal|3
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|editLog
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|fileSys
operator|!=
literal|null
condition|)
name|fileSys
operator|.
name|close
argument_list|()
expr_stmt|;
if|if
condition|(
name|cluster
operator|!=
literal|null
condition|)
name|cluster
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
comment|// How long does it take to read through all these edit logs?
name|long
name|startTime
init|=
name|Time
operator|.
name|now
argument_list|()
decl_stmt|;
try|try
block|{
name|cluster
operator|=
operator|new
name|MiniDFSCluster
operator|.
name|Builder
argument_list|(
name|conf
argument_list|)
operator|.
name|numDataNodes
argument_list|(
name|NUM_DATA_NODES
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
name|cluster
operator|.
name|waitActive
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|cluster
operator|!=
literal|null
condition|)
block|{
name|cluster
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
block|}
name|long
name|endTime
init|=
name|Time
operator|.
name|now
argument_list|()
decl_stmt|;
name|double
name|delta
init|=
operator|(
call|(
name|float
call|)
argument_list|(
name|endTime
operator|-
name|startTime
argument_list|)
operator|)
operator|/
literal|1000.0
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"loaded %d edit log segments in %.2f seconds"
argument_list|,
name|NUM_EDIT_LOG_ROLLS
argument_list|,
name|delta
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Edit log op instances are cached internally using thread-local storage.    * This test checks that the cached instances are reset in between different    * transactions processed on the same thread, so that we don't accidentally    * apply incorrect attributes to an inode.    *    * @throws IOException if there is an I/O error    */
annotation|@
name|Test
DECL|method|testResetThreadLocalCachedOps ()
specifier|public
name|void
name|testResetThreadLocalCachedOps
parameter_list|()
throws|throws
name|IOException
block|{
name|Configuration
name|conf
init|=
operator|new
name|HdfsConfiguration
argument_list|()
decl_stmt|;
name|conf
operator|.
name|setBoolean
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_ACLS_ENABLED_KEY
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|// Set single handler thread, so all transactions hit same thread-local ops.
name|conf
operator|.
name|setInt
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_HANDLER_COUNT_KEY
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|MiniDFSCluster
name|cluster
init|=
literal|null
decl_stmt|;
name|FileSystem
name|fileSys
init|=
literal|null
decl_stmt|;
try|try
block|{
name|cluster
operator|=
operator|new
name|MiniDFSCluster
operator|.
name|Builder
argument_list|(
name|conf
argument_list|)
operator|.
name|numDataNodes
argument_list|(
literal|1
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
name|cluster
operator|.
name|waitActive
argument_list|()
expr_stmt|;
name|fileSys
operator|=
name|cluster
operator|.
name|getFileSystem
argument_list|()
expr_stmt|;
comment|// Create /dir1 with a default ACL.
name|Path
name|dir1
init|=
operator|new
name|Path
argument_list|(
literal|"/dir1"
argument_list|)
decl_stmt|;
name|fileSys
operator|.
name|mkdirs
argument_list|(
name|dir1
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|AclEntry
argument_list|>
name|aclSpec
init|=
name|Lists
operator|.
name|newArrayList
argument_list|(
name|aclEntry
argument_list|(
name|DEFAULT
argument_list|,
name|USER
argument_list|,
literal|"foo"
argument_list|,
name|READ_EXECUTE
argument_list|)
argument_list|)
decl_stmt|;
name|fileSys
operator|.
name|modifyAclEntries
argument_list|(
name|dir1
argument_list|,
name|aclSpec
argument_list|)
expr_stmt|;
comment|// /dir1/dir2 is expected to clone the default ACL.
name|Path
name|dir2
init|=
operator|new
name|Path
argument_list|(
literal|"/dir1/dir2"
argument_list|)
decl_stmt|;
name|fileSys
operator|.
name|mkdirs
argument_list|(
name|dir2
argument_list|)
expr_stmt|;
comment|// /dir1/file1 is expected to clone the default ACL.
name|Path
name|file1
init|=
operator|new
name|Path
argument_list|(
literal|"/dir1/file1"
argument_list|)
decl_stmt|;
name|fileSys
operator|.
name|create
argument_list|(
name|file1
argument_list|)
operator|.
name|close
argument_list|()
expr_stmt|;
comment|// /dir3 is not a child of /dir1, so must not clone the default ACL.
name|Path
name|dir3
init|=
operator|new
name|Path
argument_list|(
literal|"/dir3"
argument_list|)
decl_stmt|;
name|fileSys
operator|.
name|mkdirs
argument_list|(
name|dir3
argument_list|)
expr_stmt|;
comment|// /file2 is not a child of /dir1, so must not clone the default ACL.
name|Path
name|file2
init|=
operator|new
name|Path
argument_list|(
literal|"/file2"
argument_list|)
decl_stmt|;
name|fileSys
operator|.
name|create
argument_list|(
name|file2
argument_list|)
operator|.
name|close
argument_list|()
expr_stmt|;
comment|// Restart and assert the above stated expectations.
name|IOUtils
operator|.
name|cleanup
argument_list|(
name|LOG
argument_list|,
name|fileSys
argument_list|)
expr_stmt|;
name|cluster
operator|.
name|restartNameNode
argument_list|()
expr_stmt|;
name|fileSys
operator|=
name|cluster
operator|.
name|getFileSystem
argument_list|()
expr_stmt|;
name|assertFalse
argument_list|(
name|fileSys
operator|.
name|getAclStatus
argument_list|(
name|dir1
argument_list|)
operator|.
name|getEntries
argument_list|()
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|fileSys
operator|.
name|getAclStatus
argument_list|(
name|dir2
argument_list|)
operator|.
name|getEntries
argument_list|()
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|fileSys
operator|.
name|getAclStatus
argument_list|(
name|file1
argument_list|)
operator|.
name|getEntries
argument_list|()
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|fileSys
operator|.
name|getAclStatus
argument_list|(
name|dir3
argument_list|)
operator|.
name|getEntries
argument_list|()
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|fileSys
operator|.
name|getAclStatus
argument_list|(
name|file2
argument_list|)
operator|.
name|getEntries
argument_list|()
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|IOUtils
operator|.
name|cleanup
argument_list|(
name|LOG
argument_list|,
name|fileSys
argument_list|)
expr_stmt|;
if|if
condition|(
name|cluster
operator|!=
literal|null
condition|)
block|{
name|cluster
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
block|}
block|}
DECL|class|TestAppender
class|class
name|TestAppender
extends|extends
name|AppenderSkeleton
block|{
DECL|field|log
specifier|private
specifier|final
name|List
argument_list|<
name|LoggingEvent
argument_list|>
name|log
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
annotation|@
name|Override
DECL|method|requiresLayout ()
specifier|public
name|boolean
name|requiresLayout
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
annotation|@
name|Override
DECL|method|append (final LoggingEvent loggingEvent)
specifier|protected
name|void
name|append
parameter_list|(
specifier|final
name|LoggingEvent
name|loggingEvent
parameter_list|)
block|{
name|log
operator|.
name|add
argument_list|(
name|loggingEvent
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|close ()
specifier|public
name|void
name|close
parameter_list|()
block|{     }
DECL|method|getLog ()
specifier|public
name|List
argument_list|<
name|LoggingEvent
argument_list|>
name|getLog
parameter_list|()
block|{
return|return
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|log
argument_list|)
return|;
block|}
block|}
comment|/**    *    * @throws Exception    */
annotation|@
name|Test
DECL|method|testReadActivelyUpdatedLog ()
specifier|public
name|void
name|testReadActivelyUpdatedLog
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|TestAppender
name|appender
init|=
operator|new
name|TestAppender
argument_list|()
decl_stmt|;
name|LogManager
operator|.
name|getRootLogger
argument_list|()
operator|.
name|addAppender
argument_list|(
name|appender
argument_list|)
expr_stmt|;
name|Configuration
name|conf
init|=
operator|new
name|HdfsConfiguration
argument_list|()
decl_stmt|;
name|conf
operator|.
name|setBoolean
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_ACLS_ENABLED_KEY
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|// Set single handler thread, so all transactions hit same thread-local ops.
name|conf
operator|.
name|setInt
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_HANDLER_COUNT_KEY
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|MiniDFSCluster
name|cluster
init|=
literal|null
decl_stmt|;
try|try
block|{
name|cluster
operator|=
operator|new
name|MiniDFSCluster
operator|.
name|Builder
argument_list|(
name|conf
argument_list|)
operator|.
name|numDataNodes
argument_list|(
literal|1
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
name|cluster
operator|.
name|waitActive
argument_list|()
expr_stmt|;
name|FSImage
name|fsimage
init|=
name|cluster
operator|.
name|getNamesystem
argument_list|()
operator|.
name|getFSImage
argument_list|()
decl_stmt|;
name|StorageDirectory
name|sd
init|=
name|fsimage
operator|.
name|getStorage
argument_list|()
operator|.
name|getStorageDir
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|DistributedFileSystem
name|fileSys
init|=
name|cluster
operator|.
name|getFileSystem
argument_list|()
decl_stmt|;
name|DFSInotifyEventInputStream
name|events
init|=
name|fileSys
operator|.
name|getInotifyEventStream
argument_list|()
decl_stmt|;
name|fileSys
operator|.
name|mkdirs
argument_list|(
operator|new
name|Path
argument_list|(
literal|"/test"
argument_list|)
argument_list|)
expr_stmt|;
name|fileSys
operator|.
name|mkdirs
argument_list|(
operator|new
name|Path
argument_list|(
literal|"/test/dir1"
argument_list|)
argument_list|)
expr_stmt|;
name|fileSys
operator|.
name|delete
argument_list|(
operator|new
name|Path
argument_list|(
literal|"/test/dir1"
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|fsimage
operator|.
name|getEditLog
argument_list|()
operator|.
name|logSync
argument_list|()
expr_stmt|;
name|fileSys
operator|.
name|mkdirs
argument_list|(
operator|new
name|Path
argument_list|(
literal|"/test/dir2"
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|File
name|inProgressEdit
init|=
name|NNStorage
operator|.
name|getInProgressEditsFile
argument_list|(
name|sd
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|inProgressEdit
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
name|EditLogFileInputStream
name|elis
init|=
operator|new
name|EditLogFileInputStream
argument_list|(
name|inProgressEdit
argument_list|)
decl_stmt|;
name|FSEditLogOp
name|op
decl_stmt|;
name|long
name|pos
init|=
literal|0
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|op
operator|=
name|elis
operator|.
name|readOp
argument_list|()
expr_stmt|;
if|if
condition|(
name|op
operator|!=
literal|null
operator|&&
name|op
operator|.
name|opCode
operator|!=
name|FSEditLogOpCodes
operator|.
name|OP_INVALID
condition|)
block|{
name|pos
operator|=
name|elis
operator|.
name|getPosition
argument_list|()
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
block|}
name|elis
operator|.
name|close
argument_list|()
expr_stmt|;
name|assertTrue
argument_list|(
name|pos
operator|>
literal|0
argument_list|)
expr_stmt|;
name|RandomAccessFile
name|rwf
init|=
operator|new
name|RandomAccessFile
argument_list|(
name|inProgressEdit
argument_list|,
literal|"rw"
argument_list|)
decl_stmt|;
name|rwf
operator|.
name|seek
argument_list|(
name|pos
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|rwf
operator|.
name|readByte
argument_list|()
argument_list|,
operator|(
name|byte
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|rwf
operator|.
name|seek
argument_list|(
name|pos
operator|+
literal|1
argument_list|)
expr_stmt|;
name|rwf
operator|.
name|writeByte
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|rwf
operator|.
name|close
argument_list|()
expr_stmt|;
name|events
operator|.
name|poll
argument_list|()
expr_stmt|;
name|String
name|pattern
init|=
literal|"Caught exception after reading (.*) ops"
decl_stmt|;
name|Pattern
name|r
init|=
name|Pattern
operator|.
name|compile
argument_list|(
name|pattern
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|LoggingEvent
argument_list|>
name|log
init|=
name|appender
operator|.
name|getLog
argument_list|()
decl_stmt|;
for|for
control|(
name|LoggingEvent
name|event
range|:
name|log
control|)
block|{
name|Matcher
name|m
init|=
name|r
operator|.
name|matcher
argument_list|(
name|event
operator|.
name|getRenderedMessage
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|m
operator|.
name|find
argument_list|()
condition|)
block|{
name|fail
argument_list|(
literal|"Should not try to read past latest syned edit log op"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
if|if
condition|(
name|cluster
operator|!=
literal|null
condition|)
block|{
name|cluster
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
name|LogManager
operator|.
name|getRootLogger
argument_list|()
operator|.
name|removeAppender
argument_list|(
name|appender
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

