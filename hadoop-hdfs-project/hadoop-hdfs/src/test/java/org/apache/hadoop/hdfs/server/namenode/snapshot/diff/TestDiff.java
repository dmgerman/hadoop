begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdfs.server.namenode.snapshot.diff
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|snapshot
operator|.
name|diff
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Random
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|permission
operator|.
name|FsPermission
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|permission
operator|.
name|PermissionStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|INode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|INodeDirectory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|snapshot
operator|.
name|diff
operator|.
name|Diff
operator|.
name|Container
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|snapshot
operator|.
name|diff
operator|.
name|Diff
operator|.
name|UndoInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Assert
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Test
import|;
end_import

begin_comment
comment|/**  * Test {@link Diff} with {@link INode}.  */
end_comment

begin_class
DECL|class|TestDiff
specifier|public
class|class
name|TestDiff
block|{
DECL|field|RANDOM
specifier|private
specifier|static
specifier|final
name|Random
name|RANDOM
init|=
operator|new
name|Random
argument_list|()
decl_stmt|;
DECL|field|UNDO_TEST_P
specifier|private
specifier|static
specifier|final
name|int
name|UNDO_TEST_P
init|=
literal|10
decl_stmt|;
DECL|field|PERM
specifier|private
specifier|static
specifier|final
name|PermissionStatus
name|PERM
init|=
name|PermissionStatus
operator|.
name|createImmutable
argument_list|(
literal|"user"
argument_list|,
literal|"group"
argument_list|,
name|FsPermission
operator|.
name|createImmutable
argument_list|(
operator|(
name|short
operator|)
literal|0
argument_list|)
argument_list|)
decl_stmt|;
DECL|method|nextStep (int n)
specifier|static
name|int
name|nextStep
parameter_list|(
name|int
name|n
parameter_list|)
block|{
return|return
name|n
operator|==
literal|0
condition|?
literal|1
else|:
literal|10
operator|*
name|n
return|;
block|}
comment|/** Test directory diff. */
annotation|@
name|Test
DECL|method|testDiff ()
specifier|public
name|void
name|testDiff
parameter_list|()
throws|throws
name|Exception
block|{
for|for
control|(
name|int
name|startSize
init|=
literal|0
init|;
name|startSize
operator|<=
literal|1000
condition|;
name|startSize
operator|=
name|nextStep
argument_list|(
name|startSize
argument_list|)
control|)
block|{
for|for
control|(
name|int
name|m
init|=
literal|0
init|;
name|m
operator|<=
literal|10000
condition|;
name|m
operator|=
name|nextStep
argument_list|(
name|m
argument_list|)
control|)
block|{
name|runDiffTest
argument_list|(
name|startSize
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * The following are the step of the diff test:    * 1) Initialize the previous list and add s elements to it,    *    where s = startSize.    * 2) Initialize the current list by coping all elements from the previous list    * 3) Initialize an empty diff object.    * 4) Make m modifications to the current list, where m = numModifications.    *    Record the modifications in diff at the same time.    * 5) Test if current == previous + diff and previous == current - diff.    * 6) Test accessPrevious and accessCurrent.    *    * @param startSize    * @param numModifications    * @param computeDiff    */
DECL|method|runDiffTest (int startSize, int numModifications)
name|void
name|runDiffTest
parameter_list|(
name|int
name|startSize
parameter_list|,
name|int
name|numModifications
parameter_list|)
block|{
specifier|final
name|int
name|width
init|=
name|findWidth
argument_list|(
name|startSize
operator|+
name|numModifications
argument_list|)
decl_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"\nstartSize="
operator|+
name|startSize
operator|+
literal|", numModifications="
operator|+
name|numModifications
operator|+
literal|", width="
operator|+
name|width
argument_list|)
expr_stmt|;
comment|// initialize previous
specifier|final
name|List
argument_list|<
name|INode
argument_list|>
name|previous
init|=
operator|new
name|ArrayList
argument_list|<
name|INode
argument_list|>
argument_list|()
decl_stmt|;
name|int
name|n
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
name|n
operator|<
name|startSize
condition|;
name|n
operator|++
control|)
block|{
name|previous
operator|.
name|add
argument_list|(
name|newINode
argument_list|(
name|n
argument_list|,
name|width
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// make modifications to current and record the diff
specifier|final
name|List
argument_list|<
name|INode
argument_list|>
name|current
init|=
operator|new
name|ArrayList
argument_list|<
name|INode
argument_list|>
argument_list|(
name|previous
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|Diff
argument_list|<
name|byte
index|[]
argument_list|,
name|INode
argument_list|>
argument_list|>
name|diffs
init|=
operator|new
name|ArrayList
argument_list|<
name|Diff
argument_list|<
name|byte
index|[]
argument_list|,
name|INode
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
literal|5
condition|;
name|j
operator|++
control|)
block|{
name|diffs
operator|.
name|add
argument_list|(
operator|new
name|Diff
argument_list|<
name|byte
index|[]
argument_list|,
name|INode
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|m
init|=
literal|0
init|;
name|m
operator|<
name|numModifications
condition|;
name|m
operator|++
control|)
block|{
specifier|final
name|int
name|j
init|=
name|m
operator|*
name|diffs
operator|.
name|size
argument_list|()
operator|/
name|numModifications
decl_stmt|;
comment|// if current is empty, the next operation must be create;
comment|// otherwise, randomly pick an operation.
specifier|final
name|int
name|nextOperation
init|=
name|current
operator|.
name|isEmpty
argument_list|()
condition|?
literal|1
else|:
name|RANDOM
operator|.
name|nextInt
argument_list|(
literal|3
argument_list|)
operator|+
literal|1
decl_stmt|;
switch|switch
condition|(
name|nextOperation
condition|)
block|{
case|case
literal|1
case|:
comment|// create
block|{
specifier|final
name|INode
name|i
init|=
name|newINode
argument_list|(
name|n
operator|++
argument_list|,
name|width
argument_list|)
decl_stmt|;
name|create
argument_list|(
name|i
argument_list|,
name|current
argument_list|,
name|diffs
operator|.
name|get
argument_list|(
name|j
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|2
case|:
comment|// delete
block|{
specifier|final
name|INode
name|i
init|=
name|current
operator|.
name|get
argument_list|(
name|RANDOM
operator|.
name|nextInt
argument_list|(
name|current
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|delete
argument_list|(
name|i
argument_list|,
name|current
argument_list|,
name|diffs
operator|.
name|get
argument_list|(
name|j
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|3
case|:
comment|// modify
block|{
specifier|final
name|INode
name|i
init|=
name|current
operator|.
name|get
argument_list|(
name|RANDOM
operator|.
name|nextInt
argument_list|(
name|current
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|modify
argument_list|(
name|i
argument_list|,
name|current
argument_list|,
name|diffs
operator|.
name|get
argument_list|(
name|j
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|{
comment|// check if current == previous + diffs
name|List
argument_list|<
name|INode
argument_list|>
name|c
init|=
name|previous
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|diffs
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|c
operator|=
name|diffs
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|apply2Previous
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|hasIdenticalElements
argument_list|(
name|current
argument_list|,
name|c
argument_list|)
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"previous = "
operator|+
name|previous
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|()
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"current  = "
operator|+
name|current
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"c        = "
operator|+
name|c
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"current and c are not identical."
argument_list|)
throw|;
block|}
comment|// check if previous == current - diffs
name|List
argument_list|<
name|INode
argument_list|>
name|p
init|=
name|current
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|diffs
operator|.
name|size
argument_list|()
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|p
operator|=
name|diffs
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|apply2Current
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|hasIdenticalElements
argument_list|(
name|previous
argument_list|,
name|p
argument_list|)
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"previous = "
operator|+
name|previous
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"p        = "
operator|+
name|p
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|()
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"current  = "
operator|+
name|current
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"previous and p are not identical."
argument_list|)
throw|;
block|}
block|}
comment|// combine all diffs
specifier|final
name|Diff
argument_list|<
name|byte
index|[]
argument_list|,
name|INode
argument_list|>
name|combined
init|=
name|diffs
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|diffs
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|combined
operator|.
name|combinePosterior
argument_list|(
name|diffs
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
block|{
comment|// check if current == previous + combined
specifier|final
name|List
argument_list|<
name|INode
argument_list|>
name|c
init|=
name|combined
operator|.
name|apply2Previous
argument_list|(
name|previous
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|hasIdenticalElements
argument_list|(
name|current
argument_list|,
name|c
argument_list|)
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"previous = "
operator|+
name|previous
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|()
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"current  = "
operator|+
name|current
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"c        = "
operator|+
name|c
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"current and c are not identical."
argument_list|)
throw|;
block|}
comment|// check if previous == current - combined
specifier|final
name|List
argument_list|<
name|INode
argument_list|>
name|p
init|=
name|combined
operator|.
name|apply2Current
argument_list|(
name|current
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|hasIdenticalElements
argument_list|(
name|previous
argument_list|,
name|p
argument_list|)
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"previous = "
operator|+
name|previous
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"p        = "
operator|+
name|p
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|()
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"current  = "
operator|+
name|current
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"previous and p are not identical."
argument_list|)
throw|;
block|}
block|}
block|{
for|for
control|(
name|int
name|m
init|=
literal|0
init|;
name|m
operator|<
name|n
condition|;
name|m
operator|++
control|)
block|{
specifier|final
name|INode
name|inode
init|=
name|newINode
argument_list|(
name|m
argument_list|,
name|width
argument_list|)
decl_stmt|;
block|{
comment|// test accessPrevious
specifier|final
name|Container
argument_list|<
name|INode
argument_list|>
name|r
init|=
name|combined
operator|.
name|accessPrevious
argument_list|(
name|inode
operator|.
name|getKey
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|INode
name|computed
decl_stmt|;
if|if
condition|(
name|r
operator|!=
literal|null
condition|)
block|{
name|computed
operator|=
name|r
operator|.
name|getElement
argument_list|()
expr_stmt|;
block|}
else|else
block|{
specifier|final
name|int
name|i
init|=
name|Diff
operator|.
name|search
argument_list|(
name|current
argument_list|,
name|inode
operator|.
name|getKey
argument_list|()
argument_list|)
decl_stmt|;
name|computed
operator|=
name|i
operator|<
literal|0
condition|?
literal|null
else|:
name|current
operator|.
name|get
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
specifier|final
name|int
name|j
init|=
name|Diff
operator|.
name|search
argument_list|(
name|previous
argument_list|,
name|inode
operator|.
name|getKey
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|INode
name|expected
init|=
name|j
operator|<
literal|0
condition|?
literal|null
else|:
name|previous
operator|.
name|get
argument_list|(
name|j
argument_list|)
decl_stmt|;
comment|// must be the same object (equals is not enough)
name|Assert
operator|.
name|assertTrue
argument_list|(
name|computed
operator|==
name|expected
argument_list|)
expr_stmt|;
block|}
block|{
comment|// test accessCurrent
specifier|final
name|Container
argument_list|<
name|INode
argument_list|>
name|r
init|=
name|combined
operator|.
name|accessCurrent
argument_list|(
name|inode
operator|.
name|getKey
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|INode
name|computed
decl_stmt|;
if|if
condition|(
name|r
operator|!=
literal|null
condition|)
block|{
name|computed
operator|=
name|r
operator|.
name|getElement
argument_list|()
expr_stmt|;
block|}
else|else
block|{
specifier|final
name|int
name|i
init|=
name|Diff
operator|.
name|search
argument_list|(
name|previous
argument_list|,
name|inode
operator|.
name|getKey
argument_list|()
argument_list|)
decl_stmt|;
name|computed
operator|=
name|i
operator|<
literal|0
condition|?
literal|null
else|:
name|previous
operator|.
name|get
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
specifier|final
name|int
name|j
init|=
name|Diff
operator|.
name|search
argument_list|(
name|current
argument_list|,
name|inode
operator|.
name|getKey
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|INode
name|expected
init|=
name|j
operator|<
literal|0
condition|?
literal|null
else|:
name|current
operator|.
name|get
argument_list|(
name|j
argument_list|)
decl_stmt|;
comment|// must be the same object (equals is not enough)
name|Assert
operator|.
name|assertTrue
argument_list|(
name|computed
operator|==
name|expected
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
DECL|method|hasIdenticalElements (final List<INode> expected, final List<INode> computed)
specifier|static
name|boolean
name|hasIdenticalElements
parameter_list|(
specifier|final
name|List
argument_list|<
name|INode
argument_list|>
name|expected
parameter_list|,
specifier|final
name|List
argument_list|<
name|INode
argument_list|>
name|computed
parameter_list|)
block|{
if|if
condition|(
name|expected
operator|==
literal|null
condition|)
block|{
return|return
name|computed
operator|==
literal|null
return|;
block|}
if|if
condition|(
name|expected
operator|.
name|size
argument_list|()
operator|!=
name|computed
operator|.
name|size
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|expected
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
comment|// must be the same object (equals is not enough)
if|if
condition|(
name|expected
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|!=
name|computed
operator|.
name|get
argument_list|(
name|i
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
DECL|method|toString (INode inode)
specifier|static
name|String
name|toString
parameter_list|(
name|INode
name|inode
parameter_list|)
block|{
return|return
name|inode
operator|==
literal|null
condition|?
literal|null
else|:
name|inode
operator|.
name|getLocalName
argument_list|()
operator|+
literal|":"
operator|+
name|inode
operator|.
name|getModificationTime
argument_list|()
return|;
block|}
DECL|method|findWidth (int max)
specifier|static
name|int
name|findWidth
parameter_list|(
name|int
name|max
parameter_list|)
block|{
name|int
name|w
init|=
literal|1
decl_stmt|;
for|for
control|(
name|long
name|n
init|=
literal|10
init|;
name|n
operator|<
name|max
condition|;
name|n
operator|*=
literal|10
operator|,
name|w
operator|++
control|)
empty_stmt|;
return|return
name|w
return|;
block|}
DECL|method|newINode (int n, int width)
specifier|static
name|INode
name|newINode
parameter_list|(
name|int
name|n
parameter_list|,
name|int
name|width
parameter_list|)
block|{
return|return
operator|new
name|INodeDirectory
argument_list|(
name|n
argument_list|,
name|String
operator|.
name|format
argument_list|(
literal|"n%0"
operator|+
name|width
operator|+
literal|"d"
argument_list|,
name|n
argument_list|)
argument_list|,
name|PERM
argument_list|)
return|;
block|}
DECL|method|create (INode inode, final List<INode> current, Diff<byte[], INode> diff)
specifier|static
name|void
name|create
parameter_list|(
name|INode
name|inode
parameter_list|,
specifier|final
name|List
argument_list|<
name|INode
argument_list|>
name|current
parameter_list|,
name|Diff
argument_list|<
name|byte
index|[]
argument_list|,
name|INode
argument_list|>
name|diff
parameter_list|)
block|{
specifier|final
name|int
name|i
init|=
name|Diff
operator|.
name|search
argument_list|(
name|current
argument_list|,
name|inode
operator|.
name|getKey
argument_list|()
argument_list|)
decl_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
name|i
operator|<
literal|0
argument_list|)
expr_stmt|;
name|current
operator|.
name|add
argument_list|(
operator|-
name|i
operator|-
literal|1
argument_list|,
name|inode
argument_list|)
expr_stmt|;
if|if
condition|(
name|diff
operator|!=
literal|null
condition|)
block|{
comment|//test undo with 1/UNDO_TEST_P probability
specifier|final
name|boolean
name|testUndo
init|=
name|RANDOM
operator|.
name|nextInt
argument_list|(
name|UNDO_TEST_P
argument_list|)
operator|==
literal|0
decl_stmt|;
name|String
name|before
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|testUndo
condition|)
block|{
name|before
operator|=
name|diff
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
specifier|final
name|int
name|undoInfo
init|=
name|diff
operator|.
name|create
argument_list|(
name|inode
argument_list|)
decl_stmt|;
if|if
condition|(
name|testUndo
condition|)
block|{
specifier|final
name|String
name|after
init|=
name|diff
operator|.
name|toString
argument_list|()
decl_stmt|;
comment|//undo
name|diff
operator|.
name|undoCreate
argument_list|(
name|inode
argument_list|,
name|undoInfo
argument_list|)
expr_stmt|;
name|assertDiff
argument_list|(
name|before
argument_list|,
name|diff
argument_list|)
expr_stmt|;
comment|//re-do
name|diff
operator|.
name|create
argument_list|(
name|inode
argument_list|)
expr_stmt|;
name|assertDiff
argument_list|(
name|after
argument_list|,
name|diff
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|delete (INode inode, final List<INode> current, Diff<byte[], INode> diff)
specifier|static
name|void
name|delete
parameter_list|(
name|INode
name|inode
parameter_list|,
specifier|final
name|List
argument_list|<
name|INode
argument_list|>
name|current
parameter_list|,
name|Diff
argument_list|<
name|byte
index|[]
argument_list|,
name|INode
argument_list|>
name|diff
parameter_list|)
block|{
specifier|final
name|int
name|i
init|=
name|Diff
operator|.
name|search
argument_list|(
name|current
argument_list|,
name|inode
operator|.
name|getKey
argument_list|()
argument_list|)
decl_stmt|;
name|current
operator|.
name|remove
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|diff
operator|!=
literal|null
condition|)
block|{
comment|//test undo with 1/UNDO_TEST_P probability
specifier|final
name|boolean
name|testUndo
init|=
name|RANDOM
operator|.
name|nextInt
argument_list|(
name|UNDO_TEST_P
argument_list|)
operator|==
literal|0
decl_stmt|;
name|String
name|before
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|testUndo
condition|)
block|{
name|before
operator|=
name|diff
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
specifier|final
name|UndoInfo
argument_list|<
name|INode
argument_list|>
name|undoInfo
init|=
name|diff
operator|.
name|delete
argument_list|(
name|inode
argument_list|)
decl_stmt|;
if|if
condition|(
name|testUndo
condition|)
block|{
specifier|final
name|String
name|after
init|=
name|diff
operator|.
name|toString
argument_list|()
decl_stmt|;
comment|//undo
name|diff
operator|.
name|undoDelete
argument_list|(
name|inode
argument_list|,
name|undoInfo
argument_list|)
expr_stmt|;
name|assertDiff
argument_list|(
name|before
argument_list|,
name|diff
argument_list|)
expr_stmt|;
comment|//re-do
name|diff
operator|.
name|delete
argument_list|(
name|inode
argument_list|)
expr_stmt|;
name|assertDiff
argument_list|(
name|after
argument_list|,
name|diff
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|modify (INode inode, final List<INode> current, Diff<byte[], INode> diff)
specifier|static
name|void
name|modify
parameter_list|(
name|INode
name|inode
parameter_list|,
specifier|final
name|List
argument_list|<
name|INode
argument_list|>
name|current
parameter_list|,
name|Diff
argument_list|<
name|byte
index|[]
argument_list|,
name|INode
argument_list|>
name|diff
parameter_list|)
block|{
specifier|final
name|int
name|i
init|=
name|Diff
operator|.
name|search
argument_list|(
name|current
argument_list|,
name|inode
operator|.
name|getKey
argument_list|()
argument_list|)
decl_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
name|i
operator|>=
literal|0
argument_list|)
expr_stmt|;
specifier|final
name|INodeDirectory
name|oldinode
init|=
operator|(
name|INodeDirectory
operator|)
name|current
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
specifier|final
name|INodeDirectory
name|newinode
init|=
operator|new
name|INodeDirectory
argument_list|(
name|oldinode
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|newinode
operator|.
name|updateModificationTime
argument_list|(
name|oldinode
operator|.
name|getModificationTime
argument_list|()
operator|+
literal|1
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|current
operator|.
name|set
argument_list|(
name|i
argument_list|,
name|newinode
argument_list|)
expr_stmt|;
if|if
condition|(
name|diff
operator|!=
literal|null
condition|)
block|{
comment|//test undo with 1/UNDO_TEST_P probability
specifier|final
name|boolean
name|testUndo
init|=
name|RANDOM
operator|.
name|nextInt
argument_list|(
name|UNDO_TEST_P
argument_list|)
operator|==
literal|0
decl_stmt|;
name|String
name|before
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|testUndo
condition|)
block|{
name|before
operator|=
name|diff
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
specifier|final
name|UndoInfo
argument_list|<
name|INode
argument_list|>
name|undoInfo
init|=
name|diff
operator|.
name|modify
argument_list|(
name|oldinode
argument_list|,
name|newinode
argument_list|)
decl_stmt|;
if|if
condition|(
name|testUndo
condition|)
block|{
specifier|final
name|String
name|after
init|=
name|diff
operator|.
name|toString
argument_list|()
decl_stmt|;
comment|//undo
name|diff
operator|.
name|undoModify
argument_list|(
name|oldinode
argument_list|,
name|newinode
argument_list|,
name|undoInfo
argument_list|)
expr_stmt|;
name|assertDiff
argument_list|(
name|before
argument_list|,
name|diff
argument_list|)
expr_stmt|;
comment|//re-do
name|diff
operator|.
name|modify
argument_list|(
name|oldinode
argument_list|,
name|newinode
argument_list|)
expr_stmt|;
name|assertDiff
argument_list|(
name|after
argument_list|,
name|diff
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|assertDiff (String s, Diff<byte[], INode> diff)
specifier|static
name|void
name|assertDiff
parameter_list|(
name|String
name|s
parameter_list|,
name|Diff
argument_list|<
name|byte
index|[]
argument_list|,
name|INode
argument_list|>
name|diff
parameter_list|)
block|{
name|Assert
operator|.
name|assertEquals
argument_list|(
name|s
argument_list|,
name|diff
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
end_class

end_unit

