begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdfs.net
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|net
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|StorageType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSTestUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|blockmanagement
operator|.
name|DatanodeDescriptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|blockmanagement
operator|.
name|DatanodeStorageInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|net
operator|.
name|NetworkTopology
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|net
operator|.
name|Node
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Before
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|BeforeClass
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Ignore
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Test
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|java
operator|.
name|text
operator|.
name|NumberFormat
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|EnumSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Random
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertNotNull
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertTrue
import|;
end_import

begin_comment
comment|/**  * Performance test of the new DFSNetworkTopology chooseRandom.  *  * NOTE that the tests are not for correctness but for performance comparison,  * so the tests are printing and writing down values rather than doing assertion  * checks or timeout checks. Therefore, it is pointless to run these  * tests without something reading the value. So disabled the tests to for now,  * anyone interested in looking at the numbers can enable them.  */
end_comment

begin_class
annotation|@
name|Ignore
DECL|class|TestDFSNetworkTopologyPerformance
specifier|public
class|class
name|TestDFSNetworkTopologyPerformance
block|{
DECL|field|LOG
specifier|public
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|TestDFSNetworkTopologyPerformance
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|cluster
specifier|private
specifier|static
name|NetworkTopology
name|cluster
decl_stmt|;
DECL|field|dfscluster
specifier|private
specifier|static
name|DFSNetworkTopology
name|dfscluster
decl_stmt|;
DECL|field|dataNodes
specifier|private
name|DatanodeDescriptor
index|[]
name|dataNodes
decl_stmt|;
DECL|field|NODE_NUM
specifier|private
specifier|final
specifier|static
name|int
name|NODE_NUM
init|=
literal|2000
decl_stmt|;
DECL|field|OP_NUM
specifier|private
specifier|final
specifier|static
name|int
name|OP_NUM
init|=
literal|20000
decl_stmt|;
DECL|field|L1_NUM
specifier|private
specifier|final
specifier|static
name|int
name|L1_NUM
init|=
literal|5
decl_stmt|;
DECL|field|L2_NUM
specifier|private
specifier|final
specifier|static
name|int
name|L2_NUM
init|=
literal|10
decl_stmt|;
DECL|field|L3_NUM
specifier|private
specifier|final
specifier|static
name|int
name|L3_NUM
init|=
literal|10
decl_stmt|;
DECL|field|NS_TO_MS
specifier|private
specifier|final
specifier|static
name|float
name|NS_TO_MS
init|=
literal|1000000
decl_stmt|;
DECL|field|RANDOM
specifier|private
specifier|final
specifier|static
name|Random
name|RANDOM
init|=
operator|new
name|Random
argument_list|()
decl_stmt|;
DECL|field|node
specifier|private
name|Node
name|node
decl_stmt|;
DECL|field|totalStart
specifier|private
name|long
name|totalStart
decl_stmt|;
DECL|field|totalEnd
specifier|private
name|long
name|totalEnd
decl_stmt|;
DECL|field|totalTrials
specifier|private
name|int
name|totalTrials
decl_stmt|;
DECL|field|totalMs
specifier|private
name|float
name|totalMs
decl_stmt|;
DECL|field|excluded
specifier|private
name|Set
argument_list|<
name|Node
argument_list|>
name|excluded
decl_stmt|;
DECL|field|racks
specifier|private
specifier|static
name|String
index|[]
name|racks
decl_stmt|;
DECL|field|hosts
specifier|private
specifier|static
name|String
index|[]
name|hosts
decl_stmt|;
DECL|field|types
specifier|private
specifier|static
name|StorageType
index|[]
name|types
decl_stmt|;
DECL|field|records
specifier|private
specifier|static
name|long
index|[]
name|records
decl_stmt|;
DECL|field|localStart
specifier|private
name|long
name|localStart
decl_stmt|;
DECL|field|localEnd
specifier|private
name|long
name|localEnd
decl_stmt|;
annotation|@
name|BeforeClass
DECL|method|init ()
specifier|public
specifier|static
name|void
name|init
parameter_list|()
throws|throws
name|Exception
block|{
name|racks
operator|=
operator|new
name|String
index|[
name|NODE_NUM
index|]
expr_stmt|;
name|hosts
operator|=
operator|new
name|String
index|[
name|NODE_NUM
index|]
expr_stmt|;
name|types
operator|=
operator|new
name|StorageType
index|[
name|NODE_NUM
index|]
expr_stmt|;
name|records
operator|=
operator|new
name|long
index|[
name|OP_NUM
index|]
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|NODE_NUM
condition|;
name|i
operator|++
control|)
block|{
name|racks
index|[
name|i
index|]
operator|=
name|getRandLocation
argument_list|()
expr_stmt|;
name|hosts
index|[
name|i
index|]
operator|=
literal|"host"
operator|+
name|i
expr_stmt|;
block|}
block|}
annotation|@
name|Before
DECL|method|setup ()
specifier|public
name|void
name|setup
parameter_list|()
throws|throws
name|Exception
block|{
name|cluster
operator|=
name|NetworkTopology
operator|.
name|getInstance
argument_list|(
operator|new
name|Configuration
argument_list|()
argument_list|)
expr_stmt|;
name|dfscluster
operator|=
name|DFSNetworkTopology
operator|.
name|getInstance
argument_list|(
operator|new
name|Configuration
argument_list|()
argument_list|)
expr_stmt|;
name|excluded
operator|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
expr_stmt|;
block|}
comment|/**    * In this test, all the node types are uniformly distributed. i.e. a node    * has equal of being DISK, RAM_DISK, SSD and ARCHIVE. This test did two tests    * first test runs the old chooseRandom approach, the second test runs the    * new chooseRandom approach.    * @throws Exception    */
annotation|@
name|Test
DECL|method|testUniformStorageType ()
specifier|public
name|void
name|testUniformStorageType
parameter_list|()
throws|throws
name|Exception
block|{
name|EnumSet
argument_list|<
name|StorageType
argument_list|>
name|missingTypes
init|=
name|EnumSet
operator|.
name|allOf
argument_list|(
name|StorageType
operator|.
name|class
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|NODE_NUM
condition|;
name|i
operator|++
control|)
block|{
name|types
index|[
name|i
index|]
operator|=
name|getRandType
argument_list|()
expr_stmt|;
name|missingTypes
operator|.
name|remove
argument_list|(
name|types
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|missingTypes
operator|.
name|size
argument_list|()
operator|!=
literal|0
condition|)
block|{
comment|// it is statistically very, very rare that missingTypes is not length 0
comment|// at this point. But if it happened, we do the trick by inserting 1 per
comment|// remaining types randomly into the array, such that it is guaranteed all
comment|// types exist
name|Set
argument_list|<
name|Integer
argument_list|>
name|usedIdx
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
name|int
name|idx
decl_stmt|;
for|for
control|(
name|StorageType
name|type
range|:
name|missingTypes
control|)
block|{
do|do
block|{
name|idx
operator|=
name|RANDOM
operator|.
name|nextInt
argument_list|(
name|NODE_NUM
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|usedIdx
operator|.
name|contains
argument_list|(
name|idx
argument_list|)
condition|)
do|;
name|usedIdx
operator|.
name|add
argument_list|(
name|idx
argument_list|)
expr_stmt|;
name|types
index|[
name|idx
index|]
operator|=
name|type
expr_stmt|;
block|}
block|}
name|addNodeByTypes
argument_list|(
name|types
argument_list|)
expr_stmt|;
comment|// wait a bit for things to become stable
name|Thread
operator|.
name|sleep
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|printMemUsage
argument_list|(
literal|"before test1"
argument_list|)
expr_stmt|;
name|totalStart
operator|=
name|System
operator|.
name|nanoTime
argument_list|()
expr_stmt|;
name|totalTrials
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|OP_NUM
condition|;
name|i
operator|++
control|)
block|{
name|StorageType
name|type
init|=
name|StorageType
operator|.
name|values
argument_list|()
index|[
name|i
operator|%
name|StorageType
operator|.
name|values
argument_list|()
operator|.
name|length
index|]
decl_stmt|;
comment|// mimic the behaviour of current code:
comment|// 1. chooseRandom on NetworkTopology
comment|// 2. if it satisfies, we are good, break
comment|// 3. if not, add to excluded, try again
comment|// The reason of doing simulated behaviour is that in NetworkTopology,
comment|// the code that does this is a wrapper method that is fairly complex
comment|// and does something more than just chooseRandom. So it would be unfair
comment|// to the current code if we compare the wrapper with the new chooseRandom
comment|// because we should only compare the two chooseRandom methods.
comment|// However the way current chooseRandom works involves checking storage
comment|// type of return nodes. We still need to simulate this behaviour.
name|localStart
operator|=
name|System
operator|.
name|nanoTime
argument_list|()
expr_stmt|;
do|do
block|{
name|totalTrials
operator|+=
literal|1
expr_stmt|;
name|node
operator|=
name|cluster
operator|.
name|chooseRandom
argument_list|(
literal|""
argument_list|,
name|excluded
argument_list|)
expr_stmt|;
name|assertNotNull
argument_list|(
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|isType
argument_list|(
name|node
argument_list|,
name|type
argument_list|)
condition|)
block|{
break|break;
block|}
name|excluded
operator|.
name|add
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
literal|true
condition|)
do|;
name|excluded
operator|.
name|clear
argument_list|()
expr_stmt|;
name|localEnd
operator|=
name|System
operator|.
name|nanoTime
argument_list|()
expr_stmt|;
name|records
index|[
name|i
index|]
operator|=
name|localEnd
operator|-
name|localStart
expr_stmt|;
block|}
name|totalEnd
operator|=
name|System
operator|.
name|nanoTime
argument_list|()
expr_stmt|;
name|totalMs
operator|=
operator|(
name|totalEnd
operator|-
name|totalStart
operator|)
operator|/
name|NS_TO_MS
expr_stmt|;
comment|// 4 trials on average.
name|LOG
operator|.
name|info
argument_list|(
literal|"total time: {} avg time: {} avg trials: {}"
argument_list|,
name|totalMs
argument_list|,
name|totalMs
operator|/
name|OP_NUM
argument_list|,
operator|(
name|float
operator|)
name|totalTrials
operator|/
name|OP_NUM
argument_list|)
expr_stmt|;
comment|// wait a bit for things to become stable
name|Thread
operator|.
name|sleep
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|printMemUsage
argument_list|(
literal|"after test1 before test2"
argument_list|)
expr_stmt|;
name|totalStart
operator|=
name|System
operator|.
name|nanoTime
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|OP_NUM
condition|;
name|i
operator|++
control|)
block|{
name|StorageType
name|type
init|=
name|StorageType
operator|.
name|values
argument_list|()
index|[
name|i
operator|%
name|StorageType
operator|.
name|values
argument_list|()
operator|.
name|length
index|]
decl_stmt|;
name|localStart
operator|=
name|System
operator|.
name|nanoTime
argument_list|()
expr_stmt|;
name|node
operator|=
name|dfscluster
operator|.
name|chooseRandomWithStorageType
argument_list|(
literal|""
argument_list|,
name|excluded
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|assertNotNull
argument_list|(
name|node
argument_list|)
expr_stmt|;
comment|// with dfs cluster, the returned is always already the required type;
comment|// add assertion mainly to make a more fair comparison
name|assertTrue
argument_list|(
name|isType
argument_list|(
name|node
argument_list|,
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|localEnd
operator|=
name|System
operator|.
name|nanoTime
argument_list|()
expr_stmt|;
name|records
index|[
name|i
index|]
operator|=
name|localEnd
operator|-
name|localStart
expr_stmt|;
block|}
name|totalEnd
operator|=
name|System
operator|.
name|nanoTime
argument_list|()
expr_stmt|;
name|totalMs
operator|=
operator|(
name|totalEnd
operator|-
name|totalStart
operator|)
operator|/
name|NS_TO_MS
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"total time: {} avg time: {}"
argument_list|,
name|totalMs
argument_list|,
name|totalMs
operator|/
name|OP_NUM
argument_list|)
expr_stmt|;
name|printMemUsage
argument_list|(
literal|"after test2"
argument_list|)
expr_stmt|;
block|}
comment|/**    * There are two storage types DISK and ARCHIVE. DISK compose the majority and    * ARCHIVE only compose 1/20 nodes, uniformly distributed. This test also runs    * two tests, one with old approach and one with the new approach. Try to    * search for ARCHIVE type devices. This test show how new approach can    * outperform the old one.    * @throws Exception    */
annotation|@
name|Test
DECL|method|testUnbalancedStorageType ()
specifier|public
name|void
name|testUnbalancedStorageType
parameter_list|()
throws|throws
name|Exception
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|NODE_NUM
condition|;
name|i
operator|++
control|)
block|{
name|types
index|[
name|i
index|]
operator|=
name|StorageType
operator|.
name|DISK
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|NODE_NUM
operator|/
literal|20
condition|;
name|i
operator|++
control|)
block|{
name|types
index|[
name|RANDOM
operator|.
name|nextInt
argument_list|(
name|NODE_NUM
argument_list|)
index|]
operator|=
name|StorageType
operator|.
name|ARCHIVE
expr_stmt|;
block|}
name|addNodeByTypes
argument_list|(
name|types
argument_list|)
expr_stmt|;
comment|// wait a bit for things to become stable
name|Thread
operator|.
name|sleep
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|printMemUsage
argument_list|(
literal|"before test1"
argument_list|)
expr_stmt|;
name|totalStart
operator|=
name|System
operator|.
name|nanoTime
argument_list|()
expr_stmt|;
name|totalTrials
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|OP_NUM
condition|;
name|i
operator|++
control|)
block|{
comment|// mimic the behaviour of current code:
comment|// 1. chooseRandom on NetworkTopology
comment|// 2. if it satisfies, we are good, break
comment|// 3. if not, add to excluded, try again
name|localStart
operator|=
name|System
operator|.
name|nanoTime
argument_list|()
expr_stmt|;
do|do
block|{
name|totalTrials
operator|+=
literal|1
expr_stmt|;
name|node
operator|=
name|cluster
operator|.
name|chooseRandom
argument_list|(
literal|""
argument_list|,
name|excluded
argument_list|)
expr_stmt|;
name|assertNotNull
argument_list|(
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|isType
argument_list|(
name|node
argument_list|,
name|StorageType
operator|.
name|ARCHIVE
argument_list|)
condition|)
block|{
break|break;
block|}
name|excluded
operator|.
name|add
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
literal|true
condition|)
do|;
name|excluded
operator|.
name|clear
argument_list|()
expr_stmt|;
name|localEnd
operator|=
name|System
operator|.
name|nanoTime
argument_list|()
expr_stmt|;
name|records
index|[
name|i
index|]
operator|=
name|localEnd
operator|-
name|localStart
expr_stmt|;
block|}
name|totalEnd
operator|=
name|System
operator|.
name|nanoTime
argument_list|()
expr_stmt|;
name|totalMs
operator|=
operator|(
name|totalEnd
operator|-
name|totalStart
operator|)
operator|/
name|NS_TO_MS
expr_stmt|;
comment|// on average it takes 20 trials
name|LOG
operator|.
name|info
argument_list|(
literal|"total time: {} avg time: {} avg trials: {}"
argument_list|,
name|totalMs
argument_list|,
name|totalMs
operator|/
name|OP_NUM
argument_list|,
operator|(
name|float
operator|)
name|totalTrials
operator|/
name|OP_NUM
argument_list|)
expr_stmt|;
comment|// wait a bit for things to become stable
name|Thread
operator|.
name|sleep
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|printMemUsage
argument_list|(
literal|"after test1 before test2"
argument_list|)
expr_stmt|;
name|totalStart
operator|=
name|System
operator|.
name|nanoTime
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|OP_NUM
condition|;
name|i
operator|++
control|)
block|{
name|localStart
operator|=
name|System
operator|.
name|nanoTime
argument_list|()
expr_stmt|;
name|node
operator|=
name|dfscluster
operator|.
name|chooseRandomWithStorageType
argument_list|(
literal|""
argument_list|,
name|excluded
argument_list|,
name|StorageType
operator|.
name|ARCHIVE
argument_list|)
expr_stmt|;
name|assertNotNull
argument_list|(
name|node
argument_list|)
expr_stmt|;
comment|// with dfs cluster, the returned is always already the required type;
comment|// add assertion mainly to make a more fair comparison
name|assertTrue
argument_list|(
name|isType
argument_list|(
name|node
argument_list|,
name|StorageType
operator|.
name|ARCHIVE
argument_list|)
argument_list|)
expr_stmt|;
name|localEnd
operator|=
name|System
operator|.
name|nanoTime
argument_list|()
expr_stmt|;
name|records
index|[
name|i
index|]
operator|=
name|localEnd
operator|-
name|localStart
expr_stmt|;
block|}
name|totalEnd
operator|=
name|System
operator|.
name|nanoTime
argument_list|()
expr_stmt|;
name|totalMs
operator|=
operator|(
name|totalEnd
operator|-
name|totalStart
operator|)
operator|/
name|NS_TO_MS
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"total time: {} avg time: {}"
argument_list|,
name|totalMs
argument_list|,
name|totalMs
operator|/
name|OP_NUM
argument_list|)
expr_stmt|;
name|printMemUsage
argument_list|(
literal|"after test2"
argument_list|)
expr_stmt|;
block|}
comment|/**    * There is only one storage type (DISK) in the cluster. And tries to select    * a DISK devices every time also. One approach will always succeed in one    * call. This test shows how bad the new approach is compared to the optimal    * situation.    * @throws Exception    */
annotation|@
name|Test
DECL|method|testSameStorageType ()
specifier|public
name|void
name|testSameStorageType
parameter_list|()
throws|throws
name|Exception
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|NODE_NUM
condition|;
name|i
operator|++
control|)
block|{
name|types
index|[
name|i
index|]
operator|=
name|StorageType
operator|.
name|DISK
expr_stmt|;
block|}
name|addNodeByTypes
argument_list|(
name|types
argument_list|)
expr_stmt|;
comment|// wait a bit for things to become stable
name|Thread
operator|.
name|sleep
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|printMemUsage
argument_list|(
literal|"before test1"
argument_list|)
expr_stmt|;
name|totalStart
operator|=
name|System
operator|.
name|nanoTime
argument_list|()
expr_stmt|;
name|totalTrials
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|OP_NUM
condition|;
name|i
operator|++
control|)
block|{
comment|// mimic the behaviour of current code:
comment|// 1. chooseRandom on NetworkTopology
comment|// 2. if it satisfies, we are good, break
comment|// 3. if not, add to excluded, try again
do|do
block|{
name|totalTrials
operator|+=
literal|1
expr_stmt|;
name|node
operator|=
name|cluster
operator|.
name|chooseRandom
argument_list|(
literal|""
argument_list|,
name|excluded
argument_list|)
expr_stmt|;
name|assertNotNull
argument_list|(
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|isType
argument_list|(
name|node
argument_list|,
name|StorageType
operator|.
name|DISK
argument_list|)
condition|)
block|{
break|break;
block|}
name|excluded
operator|.
name|add
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
literal|true
condition|)
do|;
name|excluded
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
name|totalEnd
operator|=
name|System
operator|.
name|nanoTime
argument_list|()
expr_stmt|;
name|totalMs
operator|=
operator|(
name|totalEnd
operator|-
name|totalStart
operator|)
operator|/
name|NS_TO_MS
expr_stmt|;
comment|// on average it takes 20 trials
name|LOG
operator|.
name|info
argument_list|(
literal|"total time: {} avg time: {} avg trials: {}"
argument_list|,
name|totalMs
argument_list|,
name|totalMs
operator|/
name|OP_NUM
argument_list|,
operator|(
name|float
operator|)
name|totalTrials
operator|/
name|OP_NUM
argument_list|)
expr_stmt|;
comment|// wait a bit for things to become stable
name|Thread
operator|.
name|sleep
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|printMemUsage
argument_list|(
literal|"after test1 before test2"
argument_list|)
expr_stmt|;
name|totalStart
operator|=
name|System
operator|.
name|nanoTime
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|OP_NUM
condition|;
name|i
operator|++
control|)
block|{
name|node
operator|=
name|dfscluster
operator|.
name|chooseRandomWithStorageType
argument_list|(
literal|""
argument_list|,
name|excluded
argument_list|,
name|StorageType
operator|.
name|DISK
argument_list|)
expr_stmt|;
name|assertNotNull
argument_list|(
name|node
argument_list|)
expr_stmt|;
comment|// with dfs cluster, the returned is always already the required type;
comment|// add assertion mainly to make a more fair comparison
name|assertTrue
argument_list|(
name|isType
argument_list|(
name|node
argument_list|,
name|StorageType
operator|.
name|DISK
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|totalEnd
operator|=
name|System
operator|.
name|nanoTime
argument_list|()
expr_stmt|;
name|totalMs
operator|=
operator|(
name|totalEnd
operator|-
name|totalStart
operator|)
operator|/
name|NS_TO_MS
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"total time: {} avg time: {}"
argument_list|,
name|totalMs
argument_list|,
name|totalMs
operator|/
name|OP_NUM
argument_list|)
expr_stmt|;
name|printMemUsage
argument_list|(
literal|"after test2"
argument_list|)
expr_stmt|;
block|}
DECL|method|coinFlip (double chance)
specifier|private
name|boolean
name|coinFlip
parameter_list|(
name|double
name|chance
parameter_list|)
block|{
return|return
name|RANDOM
operator|.
name|nextInt
argument_list|(
name|NODE_NUM
argument_list|)
operator|<=
name|NODE_NUM
operator|*
name|chance
return|;
block|}
comment|/**    * This is a helper test, can be changed to different distribution each run.    * Changing the value percentage = X where X is between 0.0 to 1.0 will result    * in different outcomes. This is to help understanding what is the boundary    * that makes the new approach better than the old one. The lower X is, the    * less likely the old approach will succeed in one call, in which case the    * new approach is more likely to be better.    * @throws Exception    */
annotation|@
name|Test
DECL|method|testPercentageStorageType ()
specifier|public
name|void
name|testPercentageStorageType
parameter_list|()
throws|throws
name|Exception
block|{
name|double
name|percentage
init|=
literal|0.9
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|NODE_NUM
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|coinFlip
argument_list|(
name|percentage
argument_list|)
condition|)
block|{
name|types
index|[
name|i
index|]
operator|=
name|StorageType
operator|.
name|ARCHIVE
expr_stmt|;
block|}
else|else
block|{
name|types
index|[
name|i
index|]
operator|=
name|StorageType
operator|.
name|DISK
expr_stmt|;
block|}
block|}
name|addNodeByTypes
argument_list|(
name|types
argument_list|)
expr_stmt|;
comment|// wait a bit for things to become stable
name|Thread
operator|.
name|sleep
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|printMemUsage
argument_list|(
literal|"before test1"
argument_list|)
expr_stmt|;
name|totalStart
operator|=
name|System
operator|.
name|nanoTime
argument_list|()
expr_stmt|;
name|totalTrials
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|OP_NUM
condition|;
name|i
operator|++
control|)
block|{
comment|// mimic the behaviour of current code:
comment|// 1. chooseRandom on NetworkTopology
comment|// 2. if it satisfies, we are good, break
comment|// 3. if not, add to excluded, try again
name|localStart
operator|=
name|System
operator|.
name|nanoTime
argument_list|()
expr_stmt|;
do|do
block|{
name|totalTrials
operator|+=
literal|1
expr_stmt|;
name|node
operator|=
name|cluster
operator|.
name|chooseRandom
argument_list|(
literal|""
argument_list|,
name|excluded
argument_list|)
expr_stmt|;
name|assertNotNull
argument_list|(
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|isType
argument_list|(
name|node
argument_list|,
name|StorageType
operator|.
name|ARCHIVE
argument_list|)
condition|)
block|{
break|break;
block|}
name|excluded
operator|.
name|add
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
literal|true
condition|)
do|;
name|excluded
operator|.
name|clear
argument_list|()
expr_stmt|;
name|localEnd
operator|=
name|System
operator|.
name|nanoTime
argument_list|()
expr_stmt|;
name|records
index|[
name|i
index|]
operator|=
name|localEnd
operator|-
name|localStart
expr_stmt|;
block|}
name|totalEnd
operator|=
name|System
operator|.
name|nanoTime
argument_list|()
expr_stmt|;
name|totalMs
operator|=
operator|(
name|totalEnd
operator|-
name|totalStart
operator|)
operator|/
name|NS_TO_MS
expr_stmt|;
comment|// on average it takes 20 trials
name|LOG
operator|.
name|info
argument_list|(
literal|"total time: {} avg time: {} avg trials: {}"
argument_list|,
name|totalMs
argument_list|,
name|totalMs
operator|/
name|OP_NUM
argument_list|,
operator|(
name|float
operator|)
name|totalTrials
operator|/
name|OP_NUM
argument_list|)
expr_stmt|;
comment|// wait a bit for things to become stable
name|Thread
operator|.
name|sleep
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|printMemUsage
argument_list|(
literal|"after test1 before test2"
argument_list|)
expr_stmt|;
name|totalStart
operator|=
name|System
operator|.
name|nanoTime
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|OP_NUM
condition|;
name|i
operator|++
control|)
block|{
name|localStart
operator|=
name|System
operator|.
name|nanoTime
argument_list|()
expr_stmt|;
name|node
operator|=
name|dfscluster
operator|.
name|chooseRandomWithStorageType
argument_list|(
literal|""
argument_list|,
name|excluded
argument_list|,
name|StorageType
operator|.
name|ARCHIVE
argument_list|)
expr_stmt|;
name|assertNotNull
argument_list|(
name|node
argument_list|)
expr_stmt|;
comment|// with dfs cluster, the returned is always already the required type;
comment|// add assertion mainly to make a more fair comparison
name|assertTrue
argument_list|(
name|isType
argument_list|(
name|node
argument_list|,
name|StorageType
operator|.
name|ARCHIVE
argument_list|)
argument_list|)
expr_stmt|;
name|localEnd
operator|=
name|System
operator|.
name|nanoTime
argument_list|()
expr_stmt|;
name|records
index|[
name|i
index|]
operator|=
name|localEnd
operator|-
name|localStart
expr_stmt|;
block|}
name|totalEnd
operator|=
name|System
operator|.
name|nanoTime
argument_list|()
expr_stmt|;
name|totalMs
operator|=
operator|(
name|totalEnd
operator|-
name|totalStart
operator|)
operator|/
name|NS_TO_MS
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"total time: {} avg time: {}"
argument_list|,
name|totalMs
argument_list|,
name|totalMs
operator|/
name|OP_NUM
argument_list|)
expr_stmt|;
name|printMemUsage
argument_list|(
literal|"after test2"
argument_list|)
expr_stmt|;
block|}
comment|/**    * Similar to the previous test, change the percentage value to understand    * the performance of the mixed approach. More specifically, this test takes    * the approach that, it uses old approach for the first try, only if the    * old approach failed in the first try, it makes another call with the    * new approach. There is no comparison within this test.    * @throws Exception    */
annotation|@
name|Test
DECL|method|testPercentageStorageTypeWithMixedTopology ()
specifier|public
name|void
name|testPercentageStorageTypeWithMixedTopology
parameter_list|()
throws|throws
name|Exception
block|{
name|double
name|percentage
init|=
literal|0.9
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|NODE_NUM
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|coinFlip
argument_list|(
name|percentage
argument_list|)
condition|)
block|{
name|types
index|[
name|i
index|]
operator|=
name|StorageType
operator|.
name|ARCHIVE
expr_stmt|;
block|}
else|else
block|{
name|types
index|[
name|i
index|]
operator|=
name|StorageType
operator|.
name|DISK
expr_stmt|;
block|}
block|}
name|addNodeByTypes
argument_list|(
name|types
argument_list|)
expr_stmt|;
comment|// wait a bit for things to become stable
name|Thread
operator|.
name|sleep
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|printMemUsage
argument_list|(
literal|"before test1"
argument_list|)
expr_stmt|;
name|totalStart
operator|=
name|System
operator|.
name|nanoTime
argument_list|()
expr_stmt|;
name|totalTrials
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|OP_NUM
condition|;
name|i
operator|++
control|)
block|{
comment|// mimic the behavior of current code:
comment|// 1. chooseRandom on NetworkTopology
comment|// 2. if it satisfies, we are good, do the next operation
comment|// 3. if not, chooseRandom on DFSNetworkTopology
name|localStart
operator|=
name|System
operator|.
name|nanoTime
argument_list|()
expr_stmt|;
name|totalTrials
operator|+=
literal|1
expr_stmt|;
name|node
operator|=
name|cluster
operator|.
name|chooseRandom
argument_list|(
literal|""
argument_list|,
name|excluded
argument_list|)
expr_stmt|;
name|assertNotNull
argument_list|(
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isType
argument_list|(
name|node
argument_list|,
name|StorageType
operator|.
name|ARCHIVE
argument_list|)
condition|)
block|{
name|totalTrials
operator|+=
literal|1
expr_stmt|;
name|excluded
operator|.
name|add
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|node
operator|=
name|dfscluster
operator|.
name|chooseRandomWithStorageType
argument_list|(
literal|""
argument_list|,
name|excluded
argument_list|,
name|StorageType
operator|.
name|ARCHIVE
argument_list|)
expr_stmt|;
block|}
name|assertTrue
argument_list|(
name|isType
argument_list|(
name|node
argument_list|,
name|StorageType
operator|.
name|ARCHIVE
argument_list|)
argument_list|)
expr_stmt|;
name|excluded
operator|.
name|clear
argument_list|()
expr_stmt|;
name|localEnd
operator|=
name|System
operator|.
name|nanoTime
argument_list|()
expr_stmt|;
name|records
index|[
name|i
index|]
operator|=
name|localEnd
operator|-
name|localStart
expr_stmt|;
block|}
name|totalEnd
operator|=
name|System
operator|.
name|nanoTime
argument_list|()
expr_stmt|;
name|totalMs
operator|=
operator|(
name|totalEnd
operator|-
name|totalStart
operator|)
operator|/
name|NS_TO_MS
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"total time: {} avg time: {} avg trials: {}"
argument_list|,
name|totalMs
argument_list|,
name|totalMs
operator|/
name|OP_NUM
argument_list|,
operator|(
name|float
operator|)
name|totalTrials
operator|/
name|OP_NUM
argument_list|)
expr_stmt|;
comment|// wait a bit for things to become stable
name|Thread
operator|.
name|sleep
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|printMemUsage
argument_list|(
literal|"test StorageType with mixed topology."
argument_list|)
expr_stmt|;
block|}
comment|/**    * Print out the memory usage statistics. Note that this is an estimation by    * Java Runtime. Should not take the actual value too serious but more focus    * on the relative changes.    * @param message a prefix message    * @throws Exception throws exception    */
DECL|method|printMemUsage (String message)
specifier|private
name|void
name|printMemUsage
parameter_list|(
name|String
name|message
parameter_list|)
throws|throws
name|Exception
block|{
name|Runtime
name|runtime
init|=
name|Runtime
operator|.
name|getRuntime
argument_list|()
decl_stmt|;
name|NumberFormat
name|format
init|=
name|NumberFormat
operator|.
name|getInstance
argument_list|()
decl_stmt|;
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|message
argument_list|)
expr_stmt|;
name|long
name|maxMemory
init|=
name|runtime
operator|.
name|maxMemory
argument_list|()
decl_stmt|;
name|long
name|allocatedMemory
init|=
name|runtime
operator|.
name|totalMemory
argument_list|()
decl_stmt|;
name|long
name|freeMemory
init|=
name|runtime
operator|.
name|freeMemory
argument_list|()
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"\nfree memory: "
operator|+
name|format
operator|.
name|format
argument_list|(
name|freeMemory
operator|/
literal|1024
argument_list|)
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"\nallocated memory: "
operator|+
name|format
operator|.
name|format
argument_list|(
name|allocatedMemory
operator|/
literal|1024
argument_list|)
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"\nmax memory: "
operator|+
name|format
operator|.
name|format
argument_list|(
name|maxMemory
operator|/
literal|1024
argument_list|)
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"\ntotal free memory: "
operator|+
name|format
operator|.
name|format
argument_list|(
operator|(
name|freeMemory
operator|+
operator|(
name|maxMemory
operator|-
name|allocatedMemory
operator|)
operator|)
operator|/
literal|1024
argument_list|)
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|sb
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|addNodeByTypes (StorageType[] allTypes)
specifier|private
name|void
name|addNodeByTypes
parameter_list|(
name|StorageType
index|[]
name|allTypes
parameter_list|)
block|{
name|DatanodeStorageInfo
index|[]
name|storages
init|=
name|DFSTestUtil
operator|.
name|createDatanodeStorageInfos
argument_list|(
name|NODE_NUM
argument_list|,
name|racks
argument_list|,
name|hosts
argument_list|,
name|allTypes
argument_list|)
decl_stmt|;
name|dataNodes
operator|=
name|DFSTestUtil
operator|.
name|toDatanodeDescriptor
argument_list|(
name|storages
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|NODE_NUM
condition|;
name|i
operator|++
control|)
block|{
name|cluster
operator|.
name|add
argument_list|(
name|dataNodes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|dfscluster
operator|.
name|add
argument_list|(
name|dataNodes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|getRandLocation ()
specifier|private
specifier|static
name|String
name|getRandLocation
parameter_list|()
block|{
name|int
name|l1
init|=
name|RANDOM
operator|.
name|nextInt
argument_list|(
name|L1_NUM
argument_list|)
operator|+
literal|1
decl_stmt|;
name|int
name|l2
init|=
name|RANDOM
operator|.
name|nextInt
argument_list|(
name|L2_NUM
argument_list|)
operator|+
literal|1
decl_stmt|;
name|int
name|l3
init|=
name|RANDOM
operator|.
name|nextInt
argument_list|(
name|L3_NUM
argument_list|)
operator|+
literal|1
decl_stmt|;
return|return
name|String
operator|.
name|format
argument_list|(
literal|"/%d/%d/%d"
argument_list|,
name|l1
argument_list|,
name|l2
argument_list|,
name|l3
argument_list|)
return|;
block|}
DECL|method|getRandType ()
specifier|private
name|StorageType
name|getRandType
parameter_list|()
block|{
name|int
name|len
init|=
name|StorageType
operator|.
name|values
argument_list|()
operator|.
name|length
decl_stmt|;
return|return
name|StorageType
operator|.
name|values
argument_list|()
index|[
name|RANDOM
operator|.
name|nextInt
argument_list|(
name|len
argument_list|)
index|]
return|;
block|}
DECL|method|isType (Node n, StorageType type)
specifier|private
name|boolean
name|isType
parameter_list|(
name|Node
name|n
parameter_list|,
name|StorageType
name|type
parameter_list|)
block|{
comment|// no need to check n == null, because it's done by the caller
if|if
condition|(
operator|!
operator|(
name|n
operator|instanceof
name|DatanodeDescriptor
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|DatanodeDescriptor
name|dnDescriptor
init|=
operator|(
name|DatanodeDescriptor
operator|)
name|n
decl_stmt|;
return|return
name|dnDescriptor
operator|.
name|hasStorageType
argument_list|(
name|type
argument_list|)
return|;
block|}
block|}
end_class

end_unit

