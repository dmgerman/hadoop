begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdfs.server.blockmanagement
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|blockmanagement
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertEquals
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertArrayEquals
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|fail
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertTrue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeoutException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|InternalDataNodeTestUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|DatanodeRegistration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|BlockLocation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSTestUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|HdfsConfiguration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|MiniDFSCluster
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|DatanodeID
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|ExtendedBlock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|DataNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|FSNamesystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|NameNodeAdapter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|util
operator|.
name|HostsFileWriter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|test
operator|.
name|GenericTestUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Test
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|event
operator|.
name|Level
import|;
end_import

begin_class
DECL|class|TestBlocksWithNotEnoughRacks
specifier|public
class|class
name|TestBlocksWithNotEnoughRacks
block|{
DECL|field|LOG
specifier|public
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|TestBlocksWithNotEnoughRacks
operator|.
name|class
argument_list|)
decl_stmt|;
static|static
block|{
name|GenericTestUtils
operator|.
name|setLogLevel
argument_list|(
name|FSNamesystem
operator|.
name|LOG
argument_list|,
name|Level
operator|.
name|TRACE
argument_list|)
expr_stmt|;
name|GenericTestUtils
operator|.
name|setLogLevel
argument_list|(
name|LOG
argument_list|,
name|Level
operator|.
name|TRACE
argument_list|)
expr_stmt|;
block|}
comment|/*    * Return a configuration object with low timeouts for testing and     * a topology script set (which enables rack awareness).      */
DECL|method|getConf ()
specifier|private
name|Configuration
name|getConf
parameter_list|()
block|{
name|Configuration
name|conf
init|=
operator|new
name|HdfsConfiguration
argument_list|()
decl_stmt|;
comment|// Lower the heart beat interval so the NN quickly learns of dead
comment|// or decommissioned DNs and the NN issues replication and invalidation
comment|// commands quickly (as replies to heartbeats)
name|conf
operator|.
name|setLong
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_HEARTBEAT_INTERVAL_KEY
argument_list|,
literal|1L
argument_list|)
expr_stmt|;
comment|// Have the NN RedundancyMonitor compute the reconstruction and
comment|// invalidation commands to send DNs every second.
name|conf
operator|.
name|setInt
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_REDUNDANCY_INTERVAL_SECONDS_KEY
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|// Have the NN check for pending replications every second so it
comment|// quickly schedules additional replicas as they are identified.
name|conf
operator|.
name|setInt
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_RECONSTRUCTION_PENDING_TIMEOUT_SEC_KEY
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|// The DNs report blocks every second.
name|conf
operator|.
name|setLong
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_BLOCKREPORT_INTERVAL_MSEC_KEY
argument_list|,
literal|1000L
argument_list|)
expr_stmt|;
comment|// Indicates we have multiple racks
name|conf
operator|.
name|set
argument_list|(
name|DFSConfigKeys
operator|.
name|NET_TOPOLOGY_SCRIPT_FILE_NAME_KEY
argument_list|,
literal|"xyz"
argument_list|)
expr_stmt|;
return|return
name|conf
return|;
block|}
comment|/*    * Creates a block with all datanodes on the same rack, though the block    * is sufficiently replicated. Adds an additional datanode on a new rack.     * The block should be replicated to the new rack.    */
annotation|@
name|Test
DECL|method|testSufficientlyReplBlocksUsesNewRack ()
specifier|public
name|void
name|testSufficientlyReplBlocksUsesNewRack
parameter_list|()
throws|throws
name|Exception
block|{
name|Configuration
name|conf
init|=
name|getConf
argument_list|()
decl_stmt|;
specifier|final
name|short
name|REPLICATION_FACTOR
init|=
literal|3
decl_stmt|;
specifier|final
name|Path
name|filePath
init|=
operator|new
name|Path
argument_list|(
literal|"/testFile"
argument_list|)
decl_stmt|;
comment|// All datanodes are on the same rack
name|String
name|racks
index|[]
init|=
block|{
literal|"/rack1"
block|,
literal|"/rack1"
block|,
literal|"/rack1"
block|}
decl_stmt|;
name|MiniDFSCluster
name|cluster
init|=
operator|new
name|MiniDFSCluster
operator|.
name|Builder
argument_list|(
name|conf
argument_list|)
operator|.
name|numDataNodes
argument_list|(
name|racks
operator|.
name|length
argument_list|)
operator|.
name|racks
argument_list|(
name|racks
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
try|try
block|{
comment|// Create a file with one block with a replication factor of 3
specifier|final
name|FileSystem
name|fs
init|=
name|cluster
operator|.
name|getFileSystem
argument_list|()
decl_stmt|;
name|DFSTestUtil
operator|.
name|createFile
argument_list|(
name|fs
argument_list|,
name|filePath
argument_list|,
literal|1L
argument_list|,
name|REPLICATION_FACTOR
argument_list|,
literal|1L
argument_list|)
expr_stmt|;
name|ExtendedBlock
name|b
init|=
name|DFSTestUtil
operator|.
name|getFirstBlock
argument_list|(
name|fs
argument_list|,
name|filePath
argument_list|)
decl_stmt|;
name|DFSTestUtil
operator|.
name|waitForReplication
argument_list|(
name|cluster
argument_list|,
name|b
argument_list|,
literal|1
argument_list|,
name|REPLICATION_FACTOR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|// Add a new datanode on a different rack
name|String
name|newRacks
index|[]
init|=
block|{
literal|"/rack2"
block|}
decl_stmt|;
name|cluster
operator|.
name|startDataNodes
argument_list|(
name|conf
argument_list|,
literal|1
argument_list|,
literal|true
argument_list|,
literal|null
argument_list|,
name|newRacks
argument_list|)
expr_stmt|;
name|cluster
operator|.
name|waitActive
argument_list|()
expr_stmt|;
name|DFSTestUtil
operator|.
name|waitForReplication
argument_list|(
name|cluster
argument_list|,
name|b
argument_list|,
literal|2
argument_list|,
name|REPLICATION_FACTOR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|cluster
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
block|}
comment|/*    * Like the previous test but the block starts with a single replica,    * and therefore unlike the previous test the block does not start    * off needing replicas.    */
annotation|@
name|Test
DECL|method|testSufficientlySingleReplBlockUsesNewRack ()
specifier|public
name|void
name|testSufficientlySingleReplBlockUsesNewRack
parameter_list|()
throws|throws
name|Exception
block|{
name|Configuration
name|conf
init|=
name|getConf
argument_list|()
decl_stmt|;
name|short
name|REPLICATION_FACTOR
init|=
literal|1
decl_stmt|;
specifier|final
name|Path
name|filePath
init|=
operator|new
name|Path
argument_list|(
literal|"/testFile"
argument_list|)
decl_stmt|;
name|String
name|racks
index|[]
init|=
block|{
literal|"/rack1"
block|,
literal|"/rack1"
block|,
literal|"/rack1"
block|,
literal|"/rack2"
block|}
decl_stmt|;
name|MiniDFSCluster
name|cluster
init|=
operator|new
name|MiniDFSCluster
operator|.
name|Builder
argument_list|(
name|conf
argument_list|)
operator|.
name|numDataNodes
argument_list|(
name|racks
operator|.
name|length
argument_list|)
operator|.
name|racks
argument_list|(
name|racks
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|FSNamesystem
name|ns
init|=
name|cluster
operator|.
name|getNameNode
argument_list|()
operator|.
name|getNamesystem
argument_list|()
decl_stmt|;
try|try
block|{
comment|// Create a file with one block with a replication factor of 1
specifier|final
name|FileSystem
name|fs
init|=
name|cluster
operator|.
name|getFileSystem
argument_list|()
decl_stmt|;
name|DFSTestUtil
operator|.
name|createFile
argument_list|(
name|fs
argument_list|,
name|filePath
argument_list|,
literal|1L
argument_list|,
name|REPLICATION_FACTOR
argument_list|,
literal|1L
argument_list|)
expr_stmt|;
name|ExtendedBlock
name|b
init|=
name|DFSTestUtil
operator|.
name|getFirstBlock
argument_list|(
name|fs
argument_list|,
name|filePath
argument_list|)
decl_stmt|;
name|DFSTestUtil
operator|.
name|waitForReplication
argument_list|(
name|cluster
argument_list|,
name|b
argument_list|,
literal|1
argument_list|,
name|REPLICATION_FACTOR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|REPLICATION_FACTOR
operator|=
literal|2
expr_stmt|;
name|NameNodeAdapter
operator|.
name|setReplication
argument_list|(
name|ns
argument_list|,
literal|"/testFile"
argument_list|,
name|REPLICATION_FACTOR
argument_list|)
expr_stmt|;
name|DFSTestUtil
operator|.
name|waitForReplication
argument_list|(
name|cluster
argument_list|,
name|b
argument_list|,
literal|2
argument_list|,
name|REPLICATION_FACTOR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|cluster
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
block|}
comment|/*    * Initialize a cluster with datanodes on two different racks and shutdown    * all datanodes on one rack. Now create a file with a single block. Even    * though the block is sufficiently replicated, it violates the replica    * placement policy. Now restart the datanodes stopped earlier. Run the fsck    * command with -replicate option to schedule the replication of these    * mis-replicated blocks and verify if it indeed works as expected.    */
annotation|@
name|Test
DECL|method|testMisReplicatedBlockUsesNewRack ()
specifier|public
name|void
name|testMisReplicatedBlockUsesNewRack
parameter_list|()
throws|throws
name|Exception
block|{
name|Configuration
name|conf
init|=
name|getConf
argument_list|()
decl_stmt|;
name|conf
operator|.
name|setInt
argument_list|(
literal|"dfs.namenode.heartbeat.recheck-interval"
argument_list|,
literal|500
argument_list|)
expr_stmt|;
specifier|final
name|short
name|replicationFactor
init|=
literal|3
decl_stmt|;
specifier|final
name|Path
name|filePath
init|=
operator|new
name|Path
argument_list|(
literal|"/testFile"
argument_list|)
decl_stmt|;
comment|// All datanodes are on two different racks
name|String
index|[]
name|racks
init|=
operator|new
name|String
index|[]
block|{
literal|"/rack1"
block|,
literal|"/rack1"
block|,
literal|"/rack1"
block|,
literal|"/rack2"
block|}
decl_stmt|;
try|try
init|(
name|MiniDFSCluster
name|cluster
init|=
operator|new
name|MiniDFSCluster
operator|.
name|Builder
argument_list|(
name|conf
argument_list|)
operator|.
name|numDataNodes
argument_list|(
name|racks
operator|.
name|length
argument_list|)
operator|.
name|racks
argument_list|(
name|racks
argument_list|)
operator|.
name|build
argument_list|()
init|)
block|{
name|cluster
operator|.
name|waitActive
argument_list|()
expr_stmt|;
name|String
name|poolId
init|=
name|cluster
operator|.
name|getNamesystem
argument_list|()
operator|.
name|getBlockPoolId
argument_list|()
decl_stmt|;
name|DatanodeRegistration
name|reg
init|=
name|InternalDataNodeTestUtils
operator|.
name|getDNRegistrationForBP
argument_list|(
name|cluster
operator|.
name|getDataNodes
argument_list|()
operator|.
name|get
argument_list|(
literal|3
argument_list|)
argument_list|,
name|poolId
argument_list|)
decl_stmt|;
comment|// Shutdown datanode on rack2 and wait for it to be marked dead
name|cluster
operator|.
name|stopDataNode
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|DFSTestUtil
operator|.
name|waitForDatanodeState
argument_list|(
name|cluster
argument_list|,
name|reg
operator|.
name|getDatanodeUuid
argument_list|()
argument_list|,
literal|false
argument_list|,
literal|20000
argument_list|)
expr_stmt|;
comment|// Create a file with one block with a replication factor of 3
specifier|final
name|FileSystem
name|fs
init|=
name|cluster
operator|.
name|getFileSystem
argument_list|()
decl_stmt|;
name|DFSTestUtil
operator|.
name|createFile
argument_list|(
name|fs
argument_list|,
name|filePath
argument_list|,
literal|1L
argument_list|,
name|replicationFactor
argument_list|,
literal|1L
argument_list|)
expr_stmt|;
name|ExtendedBlock
name|b
init|=
name|DFSTestUtil
operator|.
name|getFirstBlock
argument_list|(
name|fs
argument_list|,
name|filePath
argument_list|)
decl_stmt|;
name|DFSTestUtil
operator|.
name|waitReplication
argument_list|(
name|cluster
operator|.
name|getFileSystem
argument_list|()
argument_list|,
name|filePath
argument_list|,
name|replicationFactor
argument_list|)
expr_stmt|;
comment|// Add datanode on rack2 and wait for it be recognized as alive by NN
name|cluster
operator|.
name|startDataNodes
argument_list|(
name|conf
argument_list|,
literal|1
argument_list|,
literal|true
argument_list|,
literal|null
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"/rack2"
block|}
argument_list|)
expr_stmt|;
name|cluster
operator|.
name|waitActive
argument_list|()
expr_stmt|;
try|try
block|{
name|DFSTestUtil
operator|.
name|waitForReplication
argument_list|(
name|cluster
argument_list|,
name|b
argument_list|,
literal|2
argument_list|,
name|replicationFactor
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"NameNode should not have fixed the mis-replicated blocks"
operator|+
literal|" automatically."
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|TimeoutException
name|e
parameter_list|)
block|{
comment|//Expected.
block|}
name|String
name|fsckOp
init|=
name|DFSTestUtil
operator|.
name|runFsck
argument_list|(
name|conf
argument_list|,
literal|0
argument_list|,
literal|true
argument_list|,
name|filePath
operator|.
name|toString
argument_list|()
argument_list|,
literal|"-replicate"
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"fsck response {}"
argument_list|,
name|fsckOp
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|fsckOp
operator|.
name|contains
argument_list|(
literal|"/testFile:  Replica placement policy is violated"
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|fsckOp
operator|.
name|contains
argument_list|(
literal|" Block should be additionally replicated"
operator|+
literal|" on 1 more rack(s). Total number of racks in the cluster: 2"
argument_list|)
argument_list|)
expr_stmt|;
try|try
block|{
name|DFSTestUtil
operator|.
name|waitForReplication
argument_list|(
name|cluster
argument_list|,
name|b
argument_list|,
literal|2
argument_list|,
name|replicationFactor
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|TimeoutException
name|e
parameter_list|)
block|{
name|fail
argument_list|(
literal|"NameNode should have fixed the mis-replicated blocks as a"
operator|+
literal|" result of fsck command."
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/*    * Creates a block with all datanodes on the same rack. Add additional    * datanodes on a different rack and increase the replication factor,     * making sure there are enough replicas across racks. If the previous    * test passes this one should too, however this test may pass when    * the previous one fails because the replication code is explicitly    * triggered by setting the replication factor.    */
annotation|@
name|Test
DECL|method|testUnderReplicatedUsesNewRacks ()
specifier|public
name|void
name|testUnderReplicatedUsesNewRacks
parameter_list|()
throws|throws
name|Exception
block|{
name|Configuration
name|conf
init|=
name|getConf
argument_list|()
decl_stmt|;
name|short
name|REPLICATION_FACTOR
init|=
literal|3
decl_stmt|;
specifier|final
name|Path
name|filePath
init|=
operator|new
name|Path
argument_list|(
literal|"/testFile"
argument_list|)
decl_stmt|;
comment|// All datanodes are on the same rack
name|String
name|racks
index|[]
init|=
block|{
literal|"/rack1"
block|,
literal|"/rack1"
block|,
literal|"/rack1"
block|,
literal|"/rack1"
block|,
literal|"/rack1"
block|}
decl_stmt|;
name|MiniDFSCluster
name|cluster
init|=
operator|new
name|MiniDFSCluster
operator|.
name|Builder
argument_list|(
name|conf
argument_list|)
operator|.
name|numDataNodes
argument_list|(
name|racks
operator|.
name|length
argument_list|)
operator|.
name|racks
argument_list|(
name|racks
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|FSNamesystem
name|ns
init|=
name|cluster
operator|.
name|getNameNode
argument_list|()
operator|.
name|getNamesystem
argument_list|()
decl_stmt|;
try|try
block|{
comment|// Create a file with one block
specifier|final
name|FileSystem
name|fs
init|=
name|cluster
operator|.
name|getFileSystem
argument_list|()
decl_stmt|;
name|DFSTestUtil
operator|.
name|createFile
argument_list|(
name|fs
argument_list|,
name|filePath
argument_list|,
literal|1L
argument_list|,
name|REPLICATION_FACTOR
argument_list|,
literal|1L
argument_list|)
expr_stmt|;
name|ExtendedBlock
name|b
init|=
name|DFSTestUtil
operator|.
name|getFirstBlock
argument_list|(
name|fs
argument_list|,
name|filePath
argument_list|)
decl_stmt|;
name|DFSTestUtil
operator|.
name|waitForReplication
argument_list|(
name|cluster
argument_list|,
name|b
argument_list|,
literal|1
argument_list|,
name|REPLICATION_FACTOR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|// Add new datanodes on a different rack and increase the
comment|// replication factor so the block is underreplicated and make
comment|// sure at least one of the hosts on the new rack is used.
name|String
name|newRacks
index|[]
init|=
block|{
literal|"/rack2"
block|,
literal|"/rack2"
block|}
decl_stmt|;
name|cluster
operator|.
name|startDataNodes
argument_list|(
name|conf
argument_list|,
literal|2
argument_list|,
literal|true
argument_list|,
literal|null
argument_list|,
name|newRacks
argument_list|)
expr_stmt|;
name|REPLICATION_FACTOR
operator|=
literal|5
expr_stmt|;
name|NameNodeAdapter
operator|.
name|setReplication
argument_list|(
name|ns
argument_list|,
literal|"/testFile"
argument_list|,
name|REPLICATION_FACTOR
argument_list|)
expr_stmt|;
name|DFSTestUtil
operator|.
name|waitForReplication
argument_list|(
name|cluster
argument_list|,
name|b
argument_list|,
literal|2
argument_list|,
name|REPLICATION_FACTOR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|cluster
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
block|}
comment|/*    * Test that a block that is re-replicated because one of its replicas    * is found to be corrupt and is re-replicated across racks.    */
annotation|@
name|Test
DECL|method|testCorruptBlockRereplicatedAcrossRacks ()
specifier|public
name|void
name|testCorruptBlockRereplicatedAcrossRacks
parameter_list|()
throws|throws
name|Exception
block|{
name|Configuration
name|conf
init|=
name|getConf
argument_list|()
decl_stmt|;
name|short
name|REPLICATION_FACTOR
init|=
literal|2
decl_stmt|;
name|int
name|fileLen
init|=
literal|512
decl_stmt|;
specifier|final
name|Path
name|filePath
init|=
operator|new
name|Path
argument_list|(
literal|"/testFile"
argument_list|)
decl_stmt|;
comment|// Datanodes are spread across two racks
name|String
name|racks
index|[]
init|=
block|{
literal|"/rack1"
block|,
literal|"/rack1"
block|,
literal|"/rack2"
block|,
literal|"/rack2"
block|}
decl_stmt|;
name|MiniDFSCluster
name|cluster
init|=
operator|new
name|MiniDFSCluster
operator|.
name|Builder
argument_list|(
name|conf
argument_list|)
operator|.
name|numDataNodes
argument_list|(
name|racks
operator|.
name|length
argument_list|)
operator|.
name|racks
argument_list|(
name|racks
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|FSNamesystem
name|ns
init|=
name|cluster
operator|.
name|getNameNode
argument_list|()
operator|.
name|getNamesystem
argument_list|()
decl_stmt|;
try|try
block|{
comment|// Create a file with one block with a replication factor of 2
specifier|final
name|FileSystem
name|fs
init|=
name|cluster
operator|.
name|getFileSystem
argument_list|()
decl_stmt|;
name|DFSTestUtil
operator|.
name|createFile
argument_list|(
name|fs
argument_list|,
name|filePath
argument_list|,
name|fileLen
argument_list|,
name|REPLICATION_FACTOR
argument_list|,
literal|1L
argument_list|)
expr_stmt|;
specifier|final
name|byte
index|[]
name|fileContent
init|=
name|DFSTestUtil
operator|.
name|readFileAsBytes
argument_list|(
name|fs
argument_list|,
name|filePath
argument_list|)
decl_stmt|;
name|ExtendedBlock
name|b
init|=
name|DFSTestUtil
operator|.
name|getFirstBlock
argument_list|(
name|fs
argument_list|,
name|filePath
argument_list|)
decl_stmt|;
name|DFSTestUtil
operator|.
name|waitForReplication
argument_list|(
name|cluster
argument_list|,
name|b
argument_list|,
literal|2
argument_list|,
name|REPLICATION_FACTOR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|// Corrupt a replica of the block
name|int
name|dnToCorrupt
init|=
name|DFSTestUtil
operator|.
name|firstDnWithBlock
argument_list|(
name|cluster
argument_list|,
name|b
argument_list|)
decl_stmt|;
name|cluster
operator|.
name|corruptReplica
argument_list|(
name|dnToCorrupt
argument_list|,
name|b
argument_list|)
expr_stmt|;
comment|// Restart the datanode so blocks are re-scanned, and the corrupt
comment|// block is detected.
name|cluster
operator|.
name|restartDataNode
argument_list|(
name|dnToCorrupt
argument_list|)
expr_stmt|;
comment|// Wait for the namenode to notice the corrupt replica
name|DFSTestUtil
operator|.
name|waitCorruptReplicas
argument_list|(
name|fs
argument_list|,
name|ns
argument_list|,
name|filePath
argument_list|,
name|b
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|// The rack policy is still respected
name|DFSTestUtil
operator|.
name|waitForReplication
argument_list|(
name|cluster
argument_list|,
name|b
argument_list|,
literal|2
argument_list|,
name|REPLICATION_FACTOR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|// Ensure all replicas are valid (the corrupt replica may not
comment|// have been cleaned up yet).
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|racks
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|byte
index|[]
name|blockContent
init|=
name|cluster
operator|.
name|readBlockOnDataNodeAsBytes
argument_list|(
name|i
argument_list|,
name|b
argument_list|)
decl_stmt|;
if|if
condition|(
name|blockContent
operator|!=
literal|null
operator|&&
name|i
operator|!=
name|dnToCorrupt
condition|)
block|{
name|assertArrayEquals
argument_list|(
literal|"Corrupt replica"
argument_list|,
name|fileContent
argument_list|,
name|blockContent
argument_list|)
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
name|cluster
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
block|}
comment|/*    * Reduce the replication factor of a file, making sure that the only    * cross rack replica is not removed when deleting replicas.    */
annotation|@
name|Test
DECL|method|testReduceReplFactorRespectsRackPolicy ()
specifier|public
name|void
name|testReduceReplFactorRespectsRackPolicy
parameter_list|()
throws|throws
name|Exception
block|{
name|Configuration
name|conf
init|=
name|getConf
argument_list|()
decl_stmt|;
name|short
name|REPLICATION_FACTOR
init|=
literal|3
decl_stmt|;
specifier|final
name|Path
name|filePath
init|=
operator|new
name|Path
argument_list|(
literal|"/testFile"
argument_list|)
decl_stmt|;
name|String
name|racks
index|[]
init|=
block|{
literal|"/rack1"
block|,
literal|"/rack1"
block|,
literal|"/rack2"
block|,
literal|"/rack2"
block|}
decl_stmt|;
name|MiniDFSCluster
name|cluster
init|=
operator|new
name|MiniDFSCluster
operator|.
name|Builder
argument_list|(
name|conf
argument_list|)
operator|.
name|numDataNodes
argument_list|(
name|racks
operator|.
name|length
argument_list|)
operator|.
name|racks
argument_list|(
name|racks
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|FSNamesystem
name|ns
init|=
name|cluster
operator|.
name|getNameNode
argument_list|()
operator|.
name|getNamesystem
argument_list|()
decl_stmt|;
try|try
block|{
comment|// Create a file with one block
specifier|final
name|FileSystem
name|fs
init|=
name|cluster
operator|.
name|getFileSystem
argument_list|()
decl_stmt|;
name|DFSTestUtil
operator|.
name|createFile
argument_list|(
name|fs
argument_list|,
name|filePath
argument_list|,
literal|1L
argument_list|,
name|REPLICATION_FACTOR
argument_list|,
literal|1L
argument_list|)
expr_stmt|;
name|ExtendedBlock
name|b
init|=
name|DFSTestUtil
operator|.
name|getFirstBlock
argument_list|(
name|fs
argument_list|,
name|filePath
argument_list|)
decl_stmt|;
name|DFSTestUtil
operator|.
name|waitForReplication
argument_list|(
name|cluster
argument_list|,
name|b
argument_list|,
literal|2
argument_list|,
name|REPLICATION_FACTOR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|// Decrease the replication factor, make sure the deleted replica
comment|// was not the one that lived on the rack with only one replica,
comment|// ie we should still have 2 racks after reducing the repl factor.
name|REPLICATION_FACTOR
operator|=
literal|2
expr_stmt|;
name|NameNodeAdapter
operator|.
name|setReplication
argument_list|(
name|ns
argument_list|,
literal|"/testFile"
argument_list|,
name|REPLICATION_FACTOR
argument_list|)
expr_stmt|;
name|DFSTestUtil
operator|.
name|waitForReplication
argument_list|(
name|cluster
argument_list|,
name|b
argument_list|,
literal|2
argument_list|,
name|REPLICATION_FACTOR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|cluster
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
block|}
comment|/*    * Test that when a block is replicated because a replica is lost due    * to host failure the the rack policy is preserved.    */
annotation|@
name|Test
DECL|method|testReplDueToNodeFailRespectsRackPolicy ()
specifier|public
name|void
name|testReplDueToNodeFailRespectsRackPolicy
parameter_list|()
throws|throws
name|Exception
block|{
name|Configuration
name|conf
init|=
name|getConf
argument_list|()
decl_stmt|;
name|short
name|REPLICATION_FACTOR
init|=
literal|3
decl_stmt|;
specifier|final
name|Path
name|filePath
init|=
operator|new
name|Path
argument_list|(
literal|"/testFile"
argument_list|)
decl_stmt|;
comment|// Last datanode is on a different rack
name|String
name|racks
index|[]
init|=
block|{
literal|"/rack1"
block|,
literal|"/rack1"
block|,
literal|"/rack1"
block|,
literal|"/rack2"
block|,
literal|"/rack2"
block|}
decl_stmt|;
name|MiniDFSCluster
name|cluster
init|=
operator|new
name|MiniDFSCluster
operator|.
name|Builder
argument_list|(
name|conf
argument_list|)
operator|.
name|numDataNodes
argument_list|(
name|racks
operator|.
name|length
argument_list|)
operator|.
name|racks
argument_list|(
name|racks
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|FSNamesystem
name|ns
init|=
name|cluster
operator|.
name|getNameNode
argument_list|()
operator|.
name|getNamesystem
argument_list|()
decl_stmt|;
specifier|final
name|DatanodeManager
name|dm
init|=
name|ns
operator|.
name|getBlockManager
argument_list|()
operator|.
name|getDatanodeManager
argument_list|()
decl_stmt|;
try|try
block|{
comment|// Create a file with one block with a replication factor of 3
specifier|final
name|FileSystem
name|fs
init|=
name|cluster
operator|.
name|getFileSystem
argument_list|()
decl_stmt|;
name|DFSTestUtil
operator|.
name|createFile
argument_list|(
name|fs
argument_list|,
name|filePath
argument_list|,
literal|1L
argument_list|,
name|REPLICATION_FACTOR
argument_list|,
literal|1L
argument_list|)
expr_stmt|;
name|ExtendedBlock
name|b
init|=
name|DFSTestUtil
operator|.
name|getFirstBlock
argument_list|(
name|fs
argument_list|,
name|filePath
argument_list|)
decl_stmt|;
name|DFSTestUtil
operator|.
name|waitForReplication
argument_list|(
name|cluster
argument_list|,
name|b
argument_list|,
literal|2
argument_list|,
name|REPLICATION_FACTOR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|// Make the last datanode look like it failed to heartbeat by
comment|// calling removeDatanode and stopping it.
name|ArrayList
argument_list|<
name|DataNode
argument_list|>
name|datanodes
init|=
name|cluster
operator|.
name|getDataNodes
argument_list|()
decl_stmt|;
name|int
name|idx
init|=
name|datanodes
operator|.
name|size
argument_list|()
operator|-
literal|1
decl_stmt|;
name|DataNode
name|dataNode
init|=
name|datanodes
operator|.
name|get
argument_list|(
name|idx
argument_list|)
decl_stmt|;
name|DatanodeID
name|dnId
init|=
name|dataNode
operator|.
name|getDatanodeId
argument_list|()
decl_stmt|;
name|cluster
operator|.
name|stopDataNode
argument_list|(
name|idx
argument_list|)
expr_stmt|;
name|dm
operator|.
name|removeDatanode
argument_list|(
name|dnId
argument_list|)
expr_stmt|;
comment|// The block should still have sufficient # replicas, across racks.
comment|// The last node may not have contained a replica, but if it did
comment|// it should have been replicated within the same rack.
name|DFSTestUtil
operator|.
name|waitForReplication
argument_list|(
name|cluster
argument_list|,
name|b
argument_list|,
literal|2
argument_list|,
name|REPLICATION_FACTOR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|// Fail the last datanode again, it's also on rack2 so there is
comment|// only 1 rack for all the replicas
name|datanodes
operator|=
name|cluster
operator|.
name|getDataNodes
argument_list|()
expr_stmt|;
name|idx
operator|=
name|datanodes
operator|.
name|size
argument_list|()
operator|-
literal|1
expr_stmt|;
name|dataNode
operator|=
name|datanodes
operator|.
name|get
argument_list|(
name|idx
argument_list|)
expr_stmt|;
name|dnId
operator|=
name|dataNode
operator|.
name|getDatanodeId
argument_list|()
expr_stmt|;
name|cluster
operator|.
name|stopDataNode
argument_list|(
name|idx
argument_list|)
expr_stmt|;
name|dm
operator|.
name|removeDatanode
argument_list|(
name|dnId
argument_list|)
expr_stmt|;
comment|// Make sure we have enough live replicas even though we are
comment|// short one rack. The cluster now has only 1 rack thus we just make sure
comment|// we still have 3 replicas.
name|DFSTestUtil
operator|.
name|waitForReplication
argument_list|(
name|cluster
argument_list|,
name|b
argument_list|,
literal|1
argument_list|,
name|REPLICATION_FACTOR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|cluster
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
block|}
comment|/*    * Test that when the excess replicas of a block are reduced due to    * a node re-joining the cluster the rack policy is not violated.    */
annotation|@
name|Test
DECL|method|testReduceReplFactorDueToRejoinRespectsRackPolicy ()
specifier|public
name|void
name|testReduceReplFactorDueToRejoinRespectsRackPolicy
parameter_list|()
throws|throws
name|Exception
block|{
name|Configuration
name|conf
init|=
name|getConf
argument_list|()
decl_stmt|;
name|short
name|REPLICATION_FACTOR
init|=
literal|2
decl_stmt|;
specifier|final
name|Path
name|filePath
init|=
operator|new
name|Path
argument_list|(
literal|"/testFile"
argument_list|)
decl_stmt|;
comment|// Last datanode is on a different rack
name|String
name|racks
index|[]
init|=
block|{
literal|"/rack1"
block|,
literal|"/rack1"
block|,
literal|"/rack2"
block|}
decl_stmt|;
name|MiniDFSCluster
name|cluster
init|=
operator|new
name|MiniDFSCluster
operator|.
name|Builder
argument_list|(
name|conf
argument_list|)
operator|.
name|numDataNodes
argument_list|(
name|racks
operator|.
name|length
argument_list|)
operator|.
name|racks
argument_list|(
name|racks
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|FSNamesystem
name|ns
init|=
name|cluster
operator|.
name|getNameNode
argument_list|()
operator|.
name|getNamesystem
argument_list|()
decl_stmt|;
specifier|final
name|DatanodeManager
name|dm
init|=
name|ns
operator|.
name|getBlockManager
argument_list|()
operator|.
name|getDatanodeManager
argument_list|()
decl_stmt|;
try|try
block|{
comment|// Create a file with one block
specifier|final
name|FileSystem
name|fs
init|=
name|cluster
operator|.
name|getFileSystem
argument_list|()
decl_stmt|;
name|DFSTestUtil
operator|.
name|createFile
argument_list|(
name|fs
argument_list|,
name|filePath
argument_list|,
literal|1L
argument_list|,
name|REPLICATION_FACTOR
argument_list|,
literal|1L
argument_list|)
expr_stmt|;
name|ExtendedBlock
name|b
init|=
name|DFSTestUtil
operator|.
name|getFirstBlock
argument_list|(
name|fs
argument_list|,
name|filePath
argument_list|)
decl_stmt|;
name|DFSTestUtil
operator|.
name|waitForReplication
argument_list|(
name|cluster
argument_list|,
name|b
argument_list|,
literal|2
argument_list|,
name|REPLICATION_FACTOR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|// Make the last (cross rack) datanode look like it failed
comment|// to heartbeat by stopping it and calling removeDatanode.
name|ArrayList
argument_list|<
name|DataNode
argument_list|>
name|datanodes
init|=
name|cluster
operator|.
name|getDataNodes
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
literal|3
argument_list|,
name|datanodes
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|DataNode
name|dataNode
init|=
name|datanodes
operator|.
name|get
argument_list|(
literal|2
argument_list|)
decl_stmt|;
name|DatanodeID
name|dnId
init|=
name|dataNode
operator|.
name|getDatanodeId
argument_list|()
decl_stmt|;
name|cluster
operator|.
name|stopDataNode
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|dm
operator|.
name|removeDatanode
argument_list|(
name|dnId
argument_list|)
expr_stmt|;
comment|// The block gets re-replicated to another datanode so it has a
comment|// sufficient # replicas, but not across racks, so there should
comment|// be 1 rack.
name|DFSTestUtil
operator|.
name|waitForReplication
argument_list|(
name|cluster
argument_list|,
name|b
argument_list|,
literal|1
argument_list|,
name|REPLICATION_FACTOR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|// Start the "failed" datanode, which has a replica so the block is
comment|// now over-replicated and therefore a replica should be removed but
comment|// not on the restarted datanode as that would violate the rack policy.
name|String
name|rack2
index|[]
init|=
block|{
literal|"/rack2"
block|}
decl_stmt|;
name|cluster
operator|.
name|startDataNodes
argument_list|(
name|conf
argument_list|,
literal|1
argument_list|,
literal|true
argument_list|,
literal|null
argument_list|,
name|rack2
argument_list|)
expr_stmt|;
name|cluster
operator|.
name|waitActive
argument_list|()
expr_stmt|;
comment|// The block now has sufficient # replicas, across racks
name|DFSTestUtil
operator|.
name|waitForReplication
argument_list|(
name|cluster
argument_list|,
name|b
argument_list|,
literal|2
argument_list|,
name|REPLICATION_FACTOR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|cluster
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
block|}
comment|/*    * Test that rack policy is still respected when blocks are replicated    * due to node decommissioning.    */
annotation|@
name|Test
DECL|method|testNodeDecomissionRespectsRackPolicy ()
specifier|public
name|void
name|testNodeDecomissionRespectsRackPolicy
parameter_list|()
throws|throws
name|Exception
block|{
name|Configuration
name|conf
init|=
name|getConf
argument_list|()
decl_stmt|;
name|short
name|REPLICATION_FACTOR
init|=
literal|2
decl_stmt|;
specifier|final
name|Path
name|filePath
init|=
operator|new
name|Path
argument_list|(
literal|"/testFile"
argument_list|)
decl_stmt|;
name|HostsFileWriter
name|hostsFileWriter
init|=
operator|new
name|HostsFileWriter
argument_list|()
decl_stmt|;
name|hostsFileWriter
operator|.
name|initialize
argument_list|(
name|conf
argument_list|,
literal|"temp/decommission"
argument_list|)
expr_stmt|;
comment|// Two blocks and four racks
name|String
name|racks
index|[]
init|=
block|{
literal|"/rack1"
block|,
literal|"/rack1"
block|,
literal|"/rack2"
block|,
literal|"/rack2"
block|}
decl_stmt|;
name|MiniDFSCluster
name|cluster
init|=
operator|new
name|MiniDFSCluster
operator|.
name|Builder
argument_list|(
name|conf
argument_list|)
operator|.
name|numDataNodes
argument_list|(
name|racks
operator|.
name|length
argument_list|)
operator|.
name|racks
argument_list|(
name|racks
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|FSNamesystem
name|ns
init|=
name|cluster
operator|.
name|getNameNode
argument_list|()
operator|.
name|getNamesystem
argument_list|()
decl_stmt|;
try|try
block|{
comment|// Create a file with one block
specifier|final
name|FileSystem
name|fs
init|=
name|cluster
operator|.
name|getFileSystem
argument_list|()
decl_stmt|;
name|DFSTestUtil
operator|.
name|createFile
argument_list|(
name|fs
argument_list|,
name|filePath
argument_list|,
literal|1L
argument_list|,
name|REPLICATION_FACTOR
argument_list|,
literal|1L
argument_list|)
expr_stmt|;
name|ExtendedBlock
name|b
init|=
name|DFSTestUtil
operator|.
name|getFirstBlock
argument_list|(
name|fs
argument_list|,
name|filePath
argument_list|)
decl_stmt|;
name|DFSTestUtil
operator|.
name|waitForReplication
argument_list|(
name|cluster
argument_list|,
name|b
argument_list|,
literal|2
argument_list|,
name|REPLICATION_FACTOR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|// Decommission one of the hosts with the block, this should cause
comment|// the block to get replicated to another host on the same rack,
comment|// otherwise the rack policy is violated.
name|BlockLocation
name|locs
index|[]
init|=
name|fs
operator|.
name|getFileBlockLocations
argument_list|(
name|fs
operator|.
name|getFileStatus
argument_list|(
name|filePath
argument_list|)
argument_list|,
literal|0
argument_list|,
name|Long
operator|.
name|MAX_VALUE
argument_list|)
decl_stmt|;
name|String
name|name
init|=
name|locs
index|[
literal|0
index|]
operator|.
name|getNames
argument_list|()
index|[
literal|0
index|]
decl_stmt|;
name|hostsFileWriter
operator|.
name|initExcludeHost
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|ns
operator|.
name|getBlockManager
argument_list|()
operator|.
name|getDatanodeManager
argument_list|()
operator|.
name|refreshNodes
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|DFSTestUtil
operator|.
name|waitForDecommission
argument_list|(
name|fs
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|// Check the block still has sufficient # replicas across racks
name|DFSTestUtil
operator|.
name|waitForReplication
argument_list|(
name|cluster
argument_list|,
name|b
argument_list|,
literal|2
argument_list|,
name|REPLICATION_FACTOR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|cluster
operator|.
name|shutdown
argument_list|()
expr_stmt|;
name|hostsFileWriter
operator|.
name|cleanup
argument_list|()
expr_stmt|;
block|}
block|}
comment|/*    * Test that rack policy is still respected when blocks are replicated    * due to node decommissioning, when the blocks are over-replicated.    */
annotation|@
name|Test
DECL|method|testNodeDecomissionWithOverreplicationRespectsRackPolicy ()
specifier|public
name|void
name|testNodeDecomissionWithOverreplicationRespectsRackPolicy
parameter_list|()
throws|throws
name|Exception
block|{
name|Configuration
name|conf
init|=
name|getConf
argument_list|()
decl_stmt|;
name|short
name|REPLICATION_FACTOR
init|=
literal|5
decl_stmt|;
specifier|final
name|Path
name|filePath
init|=
operator|new
name|Path
argument_list|(
literal|"/testFile"
argument_list|)
decl_stmt|;
name|HostsFileWriter
name|hostsFileWriter
init|=
operator|new
name|HostsFileWriter
argument_list|()
decl_stmt|;
name|hostsFileWriter
operator|.
name|initialize
argument_list|(
name|conf
argument_list|,
literal|"temp/decommission"
argument_list|)
expr_stmt|;
comment|// All hosts are on two racks, only one host on /rack2
name|String
name|racks
index|[]
init|=
block|{
literal|"/rack1"
block|,
literal|"/rack2"
block|,
literal|"/rack1"
block|,
literal|"/rack1"
block|,
literal|"/rack1"
block|}
decl_stmt|;
name|MiniDFSCluster
name|cluster
init|=
operator|new
name|MiniDFSCluster
operator|.
name|Builder
argument_list|(
name|conf
argument_list|)
operator|.
name|numDataNodes
argument_list|(
name|racks
operator|.
name|length
argument_list|)
operator|.
name|racks
argument_list|(
name|racks
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|FSNamesystem
name|ns
init|=
name|cluster
operator|.
name|getNameNode
argument_list|()
operator|.
name|getNamesystem
argument_list|()
decl_stmt|;
try|try
block|{
specifier|final
name|FileSystem
name|fs
init|=
name|cluster
operator|.
name|getFileSystem
argument_list|()
decl_stmt|;
name|DFSTestUtil
operator|.
name|createFile
argument_list|(
name|fs
argument_list|,
name|filePath
argument_list|,
literal|1L
argument_list|,
name|REPLICATION_FACTOR
argument_list|,
literal|1L
argument_list|)
expr_stmt|;
name|ExtendedBlock
name|b
init|=
name|DFSTestUtil
operator|.
name|getFirstBlock
argument_list|(
name|fs
argument_list|,
name|filePath
argument_list|)
decl_stmt|;
name|DFSTestUtil
operator|.
name|waitForReplication
argument_list|(
name|cluster
argument_list|,
name|b
argument_list|,
literal|2
argument_list|,
name|REPLICATION_FACTOR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|// Lower the replication factor so the blocks are over replicated
name|REPLICATION_FACTOR
operator|=
literal|2
expr_stmt|;
name|fs
operator|.
name|setReplication
argument_list|(
name|filePath
argument_list|,
name|REPLICATION_FACTOR
argument_list|)
expr_stmt|;
comment|// Decommission one of the hosts with the block that is not on
comment|// the lone host on rack2 (if we decomission that host it would
comment|// be impossible to respect the rack policy).
name|BlockLocation
name|locs
index|[]
init|=
name|fs
operator|.
name|getFileBlockLocations
argument_list|(
name|fs
operator|.
name|getFileStatus
argument_list|(
name|filePath
argument_list|)
argument_list|,
literal|0
argument_list|,
name|Long
operator|.
name|MAX_VALUE
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|top
range|:
name|locs
index|[
literal|0
index|]
operator|.
name|getTopologyPaths
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|top
operator|.
name|startsWith
argument_list|(
literal|"/rack2"
argument_list|)
condition|)
block|{
name|String
name|name
init|=
name|top
operator|.
name|substring
argument_list|(
literal|"/rack1"
operator|.
name|length
argument_list|()
operator|+
literal|1
argument_list|)
decl_stmt|;
name|hostsFileWriter
operator|.
name|initExcludeHost
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|ns
operator|.
name|getBlockManager
argument_list|()
operator|.
name|getDatanodeManager
argument_list|()
operator|.
name|refreshNodes
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|DFSTestUtil
operator|.
name|waitForDecommission
argument_list|(
name|fs
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|// Check the block still has sufficient # replicas across racks,
comment|// ie we didn't remove the replica on the host on /rack1.
name|DFSTestUtil
operator|.
name|waitForReplication
argument_list|(
name|cluster
argument_list|,
name|b
argument_list|,
literal|2
argument_list|,
name|REPLICATION_FACTOR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|cluster
operator|.
name|shutdown
argument_list|()
expr_stmt|;
name|hostsFileWriter
operator|.
name|cleanup
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

