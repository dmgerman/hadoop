begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdfs.server.blockmanagement
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|blockmanagement
package|;
end_package

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Joiner
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|LinkedListMultimap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|CreateFlag
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FSDataInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FSDataOutputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|StorageType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSOutputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSTestUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DistributedFileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|HdfsConfiguration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|MiniDFSCluster
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|StripedFileTestUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|Block
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|BlockListAsLongs
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|ExtendedBlock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|LocatedBlock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|LocatedBlocks
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|blockmanagement
operator|.
name|DatanodeDescriptor
operator|.
name|BlockTargetPair
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|HdfsServerConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|DataNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|FinalizedReplica
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|InternalDataNodeTestUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|ReplicaBeingWritten
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|CacheManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|CachedBlock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|FSNamesystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|INodeFile
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|INodeId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|NameNodeAdapter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|TestINodeFile
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|ha
operator|.
name|HAContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|ha
operator|.
name|HAState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|BlockReportContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|DatanodeRegistration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|DatanodeStorage
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|NamenodeProtocols
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|ReceivedDeletedBlockInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|StorageReceivedDeletedBlocks
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|StorageReport
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|EnumSetWritable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|RemoteException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|metrics2
operator|.
name|MetricsRecordBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|net
operator|.
name|NetworkTopology
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|test
operator|.
name|GenericTestUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|test
operator|.
name|MetricsAsserts
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|GSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|LightWeightGSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|log4j
operator|.
name|Level
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|log4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Assert
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Before
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Test
import|;
end_import

begin_import
import|import
name|org
operator|.
name|mockito
operator|.
name|Mockito
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|BufferedReader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStreamReader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|PrintWriter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|EnumSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|BrokenBarrierException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Callable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|CountDownLatch
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|CyclicBarrier
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutorService
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Executors
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Future
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|FutureTask
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeoutException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicBoolean
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|HdfsServerConstants
operator|.
name|BlockUCState
operator|.
name|UNDER_CONSTRUCTION
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|test
operator|.
name|MetricsAsserts
operator|.
name|getMetrics
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertEquals
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertFalse
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertNotNull
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertNull
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertTrue
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|mockito
operator|.
name|Mockito
operator|.
name|doReturn
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|mockito
operator|.
name|Mockito
operator|.
name|reset
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|mockito
operator|.
name|Mockito
operator|.
name|spy
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|mockito
operator|.
name|Mockito
operator|.
name|verify
import|;
end_import

begin_class
DECL|class|TestBlockManager
specifier|public
class|class
name|TestBlockManager
block|{
DECL|field|storages
specifier|private
name|DatanodeStorageInfo
index|[]
name|storages
decl_stmt|;
DECL|field|nodes
specifier|private
name|List
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|nodes
decl_stmt|;
DECL|field|rackA
specifier|private
name|List
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|rackA
decl_stmt|;
DECL|field|rackB
specifier|private
name|List
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|rackB
decl_stmt|;
comment|/**    * Some of these tests exercise code which has some randomness involved -    * ie even if there's a bug, they may pass because the random node selection    * chooses the correct result.    *     * Since they're true unit tests and run quickly, we loop them a number    * of times trying to trigger the incorrect behavior.    */
DECL|field|NUM_TEST_ITERS
specifier|private
specifier|static
specifier|final
name|int
name|NUM_TEST_ITERS
init|=
literal|30
decl_stmt|;
DECL|field|BLOCK_SIZE
specifier|private
specifier|static
specifier|final
name|int
name|BLOCK_SIZE
init|=
literal|64
operator|*
literal|1024
decl_stmt|;
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|TestBlockManager
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|fsn
specifier|private
name|FSNamesystem
name|fsn
decl_stmt|;
DECL|field|bm
specifier|private
name|BlockManager
name|bm
decl_stmt|;
DECL|field|mockINodeId
specifier|private
name|long
name|mockINodeId
decl_stmt|;
annotation|@
name|Before
DECL|method|setupMockCluster ()
specifier|public
name|void
name|setupMockCluster
parameter_list|()
throws|throws
name|IOException
block|{
name|Configuration
name|conf
init|=
operator|new
name|HdfsConfiguration
argument_list|()
decl_stmt|;
name|conf
operator|.
name|set
argument_list|(
name|DFSConfigKeys
operator|.
name|NET_TOPOLOGY_SCRIPT_FILE_NAME_KEY
argument_list|,
literal|"need to set a dummy value here so it assumes a multi-rack cluster"
argument_list|)
expr_stmt|;
name|fsn
operator|=
name|Mockito
operator|.
name|mock
argument_list|(
name|FSNamesystem
operator|.
name|class
argument_list|)
expr_stmt|;
name|Mockito
operator|.
name|doReturn
argument_list|(
literal|true
argument_list|)
operator|.
name|when
argument_list|(
name|fsn
argument_list|)
operator|.
name|hasWriteLock
argument_list|()
expr_stmt|;
name|Mockito
operator|.
name|doReturn
argument_list|(
literal|true
argument_list|)
operator|.
name|when
argument_list|(
name|fsn
argument_list|)
operator|.
name|hasReadLock
argument_list|()
expr_stmt|;
name|Mockito
operator|.
name|doReturn
argument_list|(
literal|true
argument_list|)
operator|.
name|when
argument_list|(
name|fsn
argument_list|)
operator|.
name|isRunning
argument_list|()
expr_stmt|;
comment|//Make shouldPopulaeReplQueues return true
name|HAContext
name|haContext
init|=
name|Mockito
operator|.
name|mock
argument_list|(
name|HAContext
operator|.
name|class
argument_list|)
decl_stmt|;
name|HAState
name|haState
init|=
name|Mockito
operator|.
name|mock
argument_list|(
name|HAState
operator|.
name|class
argument_list|)
decl_stmt|;
name|Mockito
operator|.
name|when
argument_list|(
name|haContext
operator|.
name|getState
argument_list|()
argument_list|)
operator|.
name|thenReturn
argument_list|(
name|haState
argument_list|)
expr_stmt|;
name|Mockito
operator|.
name|when
argument_list|(
name|haState
operator|.
name|shouldPopulateReplQueues
argument_list|()
argument_list|)
operator|.
name|thenReturn
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|Mockito
operator|.
name|when
argument_list|(
name|fsn
operator|.
name|getHAContext
argument_list|()
argument_list|)
operator|.
name|thenReturn
argument_list|(
name|haContext
argument_list|)
expr_stmt|;
name|bm
operator|=
operator|new
name|BlockManager
argument_list|(
name|fsn
argument_list|,
literal|false
argument_list|,
name|conf
argument_list|)
expr_stmt|;
name|CacheManager
name|cm
init|=
name|Mockito
operator|.
name|mock
argument_list|(
name|CacheManager
operator|.
name|class
argument_list|)
decl_stmt|;
name|Mockito
operator|.
name|doReturn
argument_list|(
name|cm
argument_list|)
operator|.
name|when
argument_list|(
name|fsn
argument_list|)
operator|.
name|getCacheManager
argument_list|()
expr_stmt|;
name|GSet
argument_list|<
name|CachedBlock
argument_list|,
name|CachedBlock
argument_list|>
name|cb
init|=
operator|new
name|LightWeightGSet
argument_list|<
name|CachedBlock
argument_list|,
name|CachedBlock
argument_list|>
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|Mockito
operator|.
name|when
argument_list|(
name|cm
operator|.
name|getCachedBlocks
argument_list|()
argument_list|)
operator|.
name|thenReturn
argument_list|(
name|cb
argument_list|)
expr_stmt|;
specifier|final
name|String
index|[]
name|racks
init|=
block|{
literal|"/rackA"
block|,
literal|"/rackA"
block|,
literal|"/rackA"
block|,
literal|"/rackB"
block|,
literal|"/rackB"
block|,
literal|"/rackB"
block|}
decl_stmt|;
name|storages
operator|=
name|DFSTestUtil
operator|.
name|createDatanodeStorageInfos
argument_list|(
name|racks
argument_list|)
expr_stmt|;
name|nodes
operator|=
name|Arrays
operator|.
name|asList
argument_list|(
name|DFSTestUtil
operator|.
name|toDatanodeDescriptor
argument_list|(
name|storages
argument_list|)
argument_list|)
expr_stmt|;
name|rackA
operator|=
name|nodes
operator|.
name|subList
argument_list|(
literal|0
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|rackB
operator|=
name|nodes
operator|.
name|subList
argument_list|(
literal|3
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|mockINodeId
operator|=
name|INodeId
operator|.
name|ROOT_INODE_ID
operator|+
literal|1
expr_stmt|;
block|}
DECL|method|addNodes (Iterable<DatanodeDescriptor> nodesToAdd)
specifier|private
name|void
name|addNodes
parameter_list|(
name|Iterable
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|nodesToAdd
parameter_list|)
block|{
name|NetworkTopology
name|cluster
init|=
name|bm
operator|.
name|getDatanodeManager
argument_list|()
operator|.
name|getNetworkTopology
argument_list|()
decl_stmt|;
comment|// construct network topology
for|for
control|(
name|DatanodeDescriptor
name|dn
range|:
name|nodesToAdd
control|)
block|{
name|cluster
operator|.
name|add
argument_list|(
name|dn
argument_list|)
expr_stmt|;
name|dn
operator|.
name|getStorageInfos
argument_list|()
index|[
literal|0
index|]
operator|.
name|setUtilizationForTesting
argument_list|(
literal|2
operator|*
name|HdfsServerConstants
operator|.
name|MIN_BLOCKS_FOR_WRITE
operator|*
name|BLOCK_SIZE
argument_list|,
literal|0L
argument_list|,
literal|2
operator|*
name|HdfsServerConstants
operator|.
name|MIN_BLOCKS_FOR_WRITE
operator|*
name|BLOCK_SIZE
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
name|dn
operator|.
name|updateHeartbeat
argument_list|(
name|BlockManagerTestUtil
operator|.
name|getStorageReportsForDatanode
argument_list|(
name|dn
argument_list|)
argument_list|,
literal|0L
argument_list|,
literal|0L
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|bm
operator|.
name|getDatanodeManager
argument_list|()
operator|.
name|checkIfClusterIsNowMultiRack
argument_list|(
name|dn
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|removeNode (DatanodeDescriptor deadNode)
specifier|private
name|void
name|removeNode
parameter_list|(
name|DatanodeDescriptor
name|deadNode
parameter_list|)
block|{
name|NetworkTopology
name|cluster
init|=
name|bm
operator|.
name|getDatanodeManager
argument_list|()
operator|.
name|getNetworkTopology
argument_list|()
decl_stmt|;
name|cluster
operator|.
name|remove
argument_list|(
name|deadNode
argument_list|)
expr_stmt|;
name|bm
operator|.
name|removeBlocksAssociatedTo
argument_list|(
name|deadNode
argument_list|)
expr_stmt|;
block|}
comment|/**    * Test that replication of under-replicated blocks is detected    * and basically works    */
annotation|@
name|Test
DECL|method|testBasicReplication ()
specifier|public
name|void
name|testBasicReplication
parameter_list|()
throws|throws
name|Exception
block|{
name|addNodes
argument_list|(
name|nodes
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|NUM_TEST_ITERS
condition|;
name|i
operator|++
control|)
block|{
name|doBasicTest
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|doBasicTest (int testIndex)
specifier|private
name|void
name|doBasicTest
parameter_list|(
name|int
name|testIndex
parameter_list|)
block|{
name|List
argument_list|<
name|DatanodeStorageInfo
argument_list|>
name|origStorages
init|=
name|getStorages
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|origNodes
init|=
name|getNodes
argument_list|(
name|origStorages
argument_list|)
decl_stmt|;
name|BlockInfo
name|blockInfo
init|=
name|addBlockOnNodes
argument_list|(
name|testIndex
argument_list|,
name|origNodes
argument_list|)
decl_stmt|;
name|DatanodeStorageInfo
index|[]
name|pipeline
init|=
name|scheduleSingleReplication
argument_list|(
name|blockInfo
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|pipeline
operator|.
name|length
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"Source of replication should be one of the nodes the block "
operator|+
literal|"was on. Was: "
operator|+
name|pipeline
index|[
literal|0
index|]
argument_list|,
name|origStorages
operator|.
name|contains
argument_list|(
name|pipeline
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"Destination of replication should be on the other rack. "
operator|+
literal|"Was: "
operator|+
name|pipeline
index|[
literal|1
index|]
argument_list|,
name|rackB
operator|.
name|contains
argument_list|(
name|pipeline
index|[
literal|1
index|]
operator|.
name|getDatanodeDescriptor
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Regression test for HDFS-1480    * - Cluster has 2 racks, A and B, each with three nodes.    * - Block initially written on A1, A2, B1    * - Admin decommissions two of these nodes (let's say A1 and A2 but it doesn't matter)    * - Re-replication should respect rack policy    */
annotation|@
name|Test
DECL|method|testTwoOfThreeNodesDecommissioned ()
specifier|public
name|void
name|testTwoOfThreeNodesDecommissioned
parameter_list|()
throws|throws
name|Exception
block|{
name|addNodes
argument_list|(
name|nodes
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|NUM_TEST_ITERS
condition|;
name|i
operator|++
control|)
block|{
name|doTestTwoOfThreeNodesDecommissioned
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|doTestTwoOfThreeNodesDecommissioned (int testIndex)
specifier|private
name|void
name|doTestTwoOfThreeNodesDecommissioned
parameter_list|(
name|int
name|testIndex
parameter_list|)
throws|throws
name|Exception
block|{
comment|// Block originally on A1, A2, B1
name|List
argument_list|<
name|DatanodeStorageInfo
argument_list|>
name|origStorages
init|=
name|getStorages
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|,
literal|3
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|origNodes
init|=
name|getNodes
argument_list|(
name|origStorages
argument_list|)
decl_stmt|;
name|BlockInfo
name|blockInfo
init|=
name|addBlockOnNodes
argument_list|(
name|testIndex
argument_list|,
name|origNodes
argument_list|)
decl_stmt|;
comment|// Decommission two of the nodes (A1, A2)
name|List
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|decomNodes
init|=
name|startDecommission
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|DatanodeStorageInfo
index|[]
name|pipeline
init|=
name|scheduleSingleReplication
argument_list|(
name|blockInfo
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
literal|"Source of replication should be one of the nodes the block "
operator|+
literal|"was on. Was: "
operator|+
name|pipeline
index|[
literal|0
index|]
argument_list|,
name|origStorages
operator|.
name|contains
argument_list|(
name|pipeline
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Should have three targets"
argument_list|,
literal|3
argument_list|,
name|pipeline
operator|.
name|length
argument_list|)
expr_stmt|;
name|boolean
name|foundOneOnRackA
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|pipeline
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|DatanodeDescriptor
name|target
init|=
name|pipeline
index|[
name|i
index|]
operator|.
name|getDatanodeDescriptor
argument_list|()
decl_stmt|;
if|if
condition|(
name|rackA
operator|.
name|contains
argument_list|(
name|target
argument_list|)
condition|)
block|{
name|foundOneOnRackA
operator|=
literal|true
expr_stmt|;
block|}
name|assertFalse
argument_list|(
name|decomNodes
operator|.
name|contains
argument_list|(
name|target
argument_list|)
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|origNodes
operator|.
name|contains
argument_list|(
name|target
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|assertTrue
argument_list|(
literal|"Should have at least one target on rack A. Pipeline: "
operator|+
name|Joiner
operator|.
name|on
argument_list|(
literal|","
argument_list|)
operator|.
name|join
argument_list|(
name|pipeline
argument_list|)
argument_list|,
name|foundOneOnRackA
argument_list|)
expr_stmt|;
block|}
comment|/**    * Test what happens when a block is on three nodes, and all three of those    * nodes are decommissioned. It should properly re-replicate to three new    * nodes.     */
annotation|@
name|Test
DECL|method|testAllNodesHoldingReplicasDecommissioned ()
specifier|public
name|void
name|testAllNodesHoldingReplicasDecommissioned
parameter_list|()
throws|throws
name|Exception
block|{
name|addNodes
argument_list|(
name|nodes
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|NUM_TEST_ITERS
condition|;
name|i
operator|++
control|)
block|{
name|doTestAllNodesHoldingReplicasDecommissioned
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|doTestAllNodesHoldingReplicasDecommissioned (int testIndex)
specifier|private
name|void
name|doTestAllNodesHoldingReplicasDecommissioned
parameter_list|(
name|int
name|testIndex
parameter_list|)
throws|throws
name|Exception
block|{
comment|// Block originally on A1, A2, B1
name|List
argument_list|<
name|DatanodeStorageInfo
argument_list|>
name|origStorages
init|=
name|getStorages
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|,
literal|3
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|origNodes
init|=
name|getNodes
argument_list|(
name|origStorages
argument_list|)
decl_stmt|;
name|BlockInfo
name|blockInfo
init|=
name|addBlockOnNodes
argument_list|(
name|testIndex
argument_list|,
name|origNodes
argument_list|)
decl_stmt|;
comment|// Decommission all of the nodes
name|List
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|decomNodes
init|=
name|startDecommission
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|,
literal|3
argument_list|)
decl_stmt|;
name|DatanodeStorageInfo
index|[]
name|pipeline
init|=
name|scheduleSingleReplication
argument_list|(
name|blockInfo
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
literal|"Source of replication should be one of the nodes the block "
operator|+
literal|"was on. Was: "
operator|+
name|pipeline
index|[
literal|0
index|]
argument_list|,
name|origStorages
operator|.
name|contains
argument_list|(
name|pipeline
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Should have three targets"
argument_list|,
literal|4
argument_list|,
name|pipeline
operator|.
name|length
argument_list|)
expr_stmt|;
name|boolean
name|foundOneOnRackA
init|=
literal|false
decl_stmt|;
name|boolean
name|foundOneOnRackB
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|pipeline
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|DatanodeDescriptor
name|target
init|=
name|pipeline
index|[
name|i
index|]
operator|.
name|getDatanodeDescriptor
argument_list|()
decl_stmt|;
if|if
condition|(
name|rackA
operator|.
name|contains
argument_list|(
name|target
argument_list|)
condition|)
block|{
name|foundOneOnRackA
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rackB
operator|.
name|contains
argument_list|(
name|target
argument_list|)
condition|)
block|{
name|foundOneOnRackB
operator|=
literal|true
expr_stmt|;
block|}
name|assertFalse
argument_list|(
name|decomNodes
operator|.
name|contains
argument_list|(
name|target
argument_list|)
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|origNodes
operator|.
name|contains
argument_list|(
name|target
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|assertTrue
argument_list|(
literal|"Should have at least one target on rack A. Pipeline: "
operator|+
name|Joiner
operator|.
name|on
argument_list|(
literal|","
argument_list|)
operator|.
name|join
argument_list|(
name|pipeline
argument_list|)
argument_list|,
name|foundOneOnRackA
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"Should have at least one target on rack B. Pipeline: "
operator|+
name|Joiner
operator|.
name|on
argument_list|(
literal|","
argument_list|)
operator|.
name|join
argument_list|(
name|pipeline
argument_list|)
argument_list|,
name|foundOneOnRackB
argument_list|)
expr_stmt|;
block|}
comment|/**    * Test what happens when there are two racks, and an entire rack is    * decommissioned.    *     * Since the cluster is multi-rack, it will consider the block    * under-replicated rather than create a third replica on the    * same rack. Adding a new node on a third rack should cause re-replication    * to that node.    */
annotation|@
name|Test
DECL|method|testOneOfTwoRacksDecommissioned ()
specifier|public
name|void
name|testOneOfTwoRacksDecommissioned
parameter_list|()
throws|throws
name|Exception
block|{
name|addNodes
argument_list|(
name|nodes
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|NUM_TEST_ITERS
condition|;
name|i
operator|++
control|)
block|{
name|doTestOneOfTwoRacksDecommissioned
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|doTestOneOfTwoRacksDecommissioned (int testIndex)
specifier|private
name|void
name|doTestOneOfTwoRacksDecommissioned
parameter_list|(
name|int
name|testIndex
parameter_list|)
throws|throws
name|Exception
block|{
comment|// Block originally on A1, A2, B1
name|List
argument_list|<
name|DatanodeStorageInfo
argument_list|>
name|origStorages
init|=
name|getStorages
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|,
literal|3
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|origNodes
init|=
name|getNodes
argument_list|(
name|origStorages
argument_list|)
decl_stmt|;
name|BlockInfo
name|blockInfo
init|=
name|addBlockOnNodes
argument_list|(
name|testIndex
argument_list|,
name|origNodes
argument_list|)
decl_stmt|;
comment|// Decommission all of the nodes in rack A
name|List
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|decomNodes
init|=
name|startDecommission
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|DatanodeStorageInfo
index|[]
name|pipeline
init|=
name|scheduleSingleReplication
argument_list|(
name|blockInfo
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
literal|"Source of replication should be one of the nodes the block "
operator|+
literal|"was on. Was: "
operator|+
name|pipeline
index|[
literal|0
index|]
argument_list|,
name|origStorages
operator|.
name|contains
argument_list|(
name|pipeline
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
comment|// Only up to two nodes can be picked per rack when there are two racks.
name|assertEquals
argument_list|(
literal|"Should have two targets"
argument_list|,
literal|2
argument_list|,
name|pipeline
operator|.
name|length
argument_list|)
expr_stmt|;
name|boolean
name|foundOneOnRackB
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|pipeline
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|DatanodeDescriptor
name|target
init|=
name|pipeline
index|[
name|i
index|]
operator|.
name|getDatanodeDescriptor
argument_list|()
decl_stmt|;
if|if
condition|(
name|rackB
operator|.
name|contains
argument_list|(
name|target
argument_list|)
condition|)
block|{
name|foundOneOnRackB
operator|=
literal|true
expr_stmt|;
block|}
name|assertFalse
argument_list|(
name|decomNodes
operator|.
name|contains
argument_list|(
name|target
argument_list|)
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|origNodes
operator|.
name|contains
argument_list|(
name|target
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|assertTrue
argument_list|(
literal|"Should have at least one target on rack B. Pipeline: "
operator|+
name|Joiner
operator|.
name|on
argument_list|(
literal|","
argument_list|)
operator|.
name|join
argument_list|(
name|pipeline
argument_list|)
argument_list|,
name|foundOneOnRackB
argument_list|)
expr_stmt|;
comment|// Mark the block as received on the target nodes in the pipeline
name|fulfillPipeline
argument_list|(
name|blockInfo
argument_list|,
name|pipeline
argument_list|)
expr_stmt|;
comment|// the block is still under-replicated. Add a new node. This should allow
comment|// the third off-rack replica.
name|DatanodeDescriptor
name|rackCNode
init|=
name|DFSTestUtil
operator|.
name|getDatanodeDescriptor
argument_list|(
literal|"7.7.7.7"
argument_list|,
literal|"/rackC"
argument_list|)
decl_stmt|;
name|rackCNode
operator|.
name|updateStorage
argument_list|(
operator|new
name|DatanodeStorage
argument_list|(
name|DatanodeStorage
operator|.
name|generateUuid
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|addNodes
argument_list|(
name|ImmutableList
operator|.
name|of
argument_list|(
name|rackCNode
argument_list|)
argument_list|)
expr_stmt|;
try|try
block|{
name|DatanodeStorageInfo
index|[]
name|pipeline2
init|=
name|scheduleSingleReplication
argument_list|(
name|blockInfo
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|pipeline2
operator|.
name|length
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|rackCNode
argument_list|,
name|pipeline2
index|[
literal|1
index|]
operator|.
name|getDatanodeDescriptor
argument_list|()
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|removeNode
argument_list|(
name|rackCNode
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Unit test version of testSufficientlyReplBlocksUsesNewRack from    * {@link TestBlocksWithNotEnoughRacks}.    **/
annotation|@
name|Test
DECL|method|testSufficientlyReplBlocksUsesNewRack ()
specifier|public
name|void
name|testSufficientlyReplBlocksUsesNewRack
parameter_list|()
throws|throws
name|Exception
block|{
name|addNodes
argument_list|(
name|nodes
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|NUM_TEST_ITERS
condition|;
name|i
operator|++
control|)
block|{
name|doTestSufficientlyReplBlocksUsesNewRack
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|doTestSufficientlyReplBlocksUsesNewRack (int testIndex)
specifier|private
name|void
name|doTestSufficientlyReplBlocksUsesNewRack
parameter_list|(
name|int
name|testIndex
parameter_list|)
block|{
comment|// Originally on only nodes in rack A.
name|List
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|origNodes
init|=
name|rackA
decl_stmt|;
name|BlockInfo
name|blockInfo
init|=
name|addBlockOnNodes
argument_list|(
name|testIndex
argument_list|,
name|origNodes
argument_list|)
decl_stmt|;
name|DatanodeStorageInfo
name|pipeline
index|[]
init|=
name|scheduleSingleReplication
argument_list|(
name|blockInfo
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|pipeline
operator|.
name|length
argument_list|)
expr_stmt|;
comment|// single new copy
name|assertTrue
argument_list|(
literal|"Source of replication should be one of the nodes the block "
operator|+
literal|"was on. Was: "
operator|+
name|pipeline
index|[
literal|0
index|]
argument_list|,
name|origNodes
operator|.
name|contains
argument_list|(
name|pipeline
index|[
literal|0
index|]
operator|.
name|getDatanodeDescriptor
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"Destination of replication should be on the other rack. "
operator|+
literal|"Was: "
operator|+
name|pipeline
index|[
literal|1
index|]
argument_list|,
name|rackB
operator|.
name|contains
argument_list|(
name|pipeline
index|[
literal|1
index|]
operator|.
name|getDatanodeDescriptor
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testBlocksAreNotUnderreplicatedInSingleRack ()
specifier|public
name|void
name|testBlocksAreNotUnderreplicatedInSingleRack
parameter_list|()
throws|throws
name|Exception
block|{
name|List
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|nodes
init|=
name|ImmutableList
operator|.
name|of
argument_list|(
name|BlockManagerTestUtil
operator|.
name|getDatanodeDescriptor
argument_list|(
literal|"1.1.1.1"
argument_list|,
literal|"/rackA"
argument_list|,
literal|true
argument_list|)
argument_list|,
name|BlockManagerTestUtil
operator|.
name|getDatanodeDescriptor
argument_list|(
literal|"2.2.2.2"
argument_list|,
literal|"/rackA"
argument_list|,
literal|true
argument_list|)
argument_list|,
name|BlockManagerTestUtil
operator|.
name|getDatanodeDescriptor
argument_list|(
literal|"3.3.3.3"
argument_list|,
literal|"/rackA"
argument_list|,
literal|true
argument_list|)
argument_list|,
name|BlockManagerTestUtil
operator|.
name|getDatanodeDescriptor
argument_list|(
literal|"4.4.4.4"
argument_list|,
literal|"/rackA"
argument_list|,
literal|true
argument_list|)
argument_list|,
name|BlockManagerTestUtil
operator|.
name|getDatanodeDescriptor
argument_list|(
literal|"5.5.5.5"
argument_list|,
literal|"/rackA"
argument_list|,
literal|true
argument_list|)
argument_list|,
name|BlockManagerTestUtil
operator|.
name|getDatanodeDescriptor
argument_list|(
literal|"6.6.6.6"
argument_list|,
literal|"/rackA"
argument_list|,
literal|true
argument_list|)
argument_list|)
decl_stmt|;
name|addNodes
argument_list|(
name|nodes
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|origNodes
init|=
name|nodes
operator|.
name|subList
argument_list|(
literal|0
argument_list|,
literal|3
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|NUM_TEST_ITERS
condition|;
name|i
operator|++
control|)
block|{
name|doTestSingleRackClusterHasSufficientRedundancy
argument_list|(
name|i
argument_list|,
name|origNodes
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|doTestSingleRackClusterHasSufficientRedundancy (int testIndex, List<DatanodeDescriptor> origNodes)
specifier|private
name|void
name|doTestSingleRackClusterHasSufficientRedundancy
parameter_list|(
name|int
name|testIndex
parameter_list|,
name|List
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|origNodes
parameter_list|)
throws|throws
name|Exception
block|{
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|bm
operator|.
name|numOfUnderReplicatedBlocks
argument_list|()
argument_list|)
expr_stmt|;
name|BlockInfo
name|block
init|=
name|addBlockOnNodes
argument_list|(
name|testIndex
argument_list|,
name|origNodes
argument_list|)
decl_stmt|;
name|assertFalse
argument_list|(
name|bm
operator|.
name|isNeededReconstruction
argument_list|(
name|block
argument_list|,
name|bm
operator|.
name|countNodes
argument_list|(
name|block
argument_list|,
name|fsn
operator|.
name|isInStartupSafeMode
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
argument_list|(
name|timeout
operator|=
literal|60000
argument_list|)
DECL|method|testNeededReconstructionWhileAppending ()
specifier|public
name|void
name|testNeededReconstructionWhileAppending
parameter_list|()
throws|throws
name|IOException
block|{
name|Configuration
name|conf
init|=
operator|new
name|HdfsConfiguration
argument_list|()
decl_stmt|;
name|String
name|src
init|=
literal|"/test-file"
decl_stmt|;
name|Path
name|file
init|=
operator|new
name|Path
argument_list|(
name|src
argument_list|)
decl_stmt|;
name|MiniDFSCluster
name|cluster
init|=
operator|new
name|MiniDFSCluster
operator|.
name|Builder
argument_list|(
name|conf
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|cluster
operator|.
name|waitActive
argument_list|()
expr_stmt|;
try|try
block|{
name|BlockManager
name|bm
init|=
name|cluster
operator|.
name|getNamesystem
argument_list|()
operator|.
name|getBlockManager
argument_list|()
decl_stmt|;
name|FileSystem
name|fs
init|=
name|cluster
operator|.
name|getFileSystem
argument_list|()
decl_stmt|;
name|NamenodeProtocols
name|namenode
init|=
name|cluster
operator|.
name|getNameNodeRpc
argument_list|()
decl_stmt|;
name|DFSOutputStream
name|out
init|=
literal|null
decl_stmt|;
try|try
block|{
name|out
operator|=
call|(
name|DFSOutputStream
call|)
argument_list|(
name|fs
operator|.
name|create
argument_list|(
name|file
argument_list|)
operator|.
name|getWrappedStream
argument_list|()
argument_list|)
expr_stmt|;
name|out
operator|.
name|write
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|out
operator|.
name|hflush
argument_list|()
expr_stmt|;
name|out
operator|.
name|close
argument_list|()
expr_stmt|;
name|FSDataInputStream
name|in
init|=
literal|null
decl_stmt|;
name|ExtendedBlock
name|oldBlock
init|=
literal|null
decl_stmt|;
try|try
block|{
name|in
operator|=
name|fs
operator|.
name|open
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|oldBlock
operator|=
name|DFSTestUtil
operator|.
name|getAllBlocks
argument_list|(
name|in
argument_list|)
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getBlock
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|IOUtils
operator|.
name|closeStream
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
name|String
name|clientName
init|=
operator|(
operator|(
name|DistributedFileSystem
operator|)
name|fs
operator|)
operator|.
name|getClient
argument_list|()
operator|.
name|getClientName
argument_list|()
decl_stmt|;
name|namenode
operator|.
name|append
argument_list|(
name|src
argument_list|,
name|clientName
argument_list|,
operator|new
name|EnumSetWritable
argument_list|<>
argument_list|(
name|EnumSet
operator|.
name|of
argument_list|(
name|CreateFlag
operator|.
name|APPEND
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|LocatedBlock
name|newLocatedBlock
init|=
name|namenode
operator|.
name|updateBlockForPipeline
argument_list|(
name|oldBlock
argument_list|,
name|clientName
argument_list|)
decl_stmt|;
name|ExtendedBlock
name|newBlock
init|=
operator|new
name|ExtendedBlock
argument_list|(
name|oldBlock
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|oldBlock
operator|.
name|getBlockId
argument_list|()
argument_list|,
name|oldBlock
operator|.
name|getNumBytes
argument_list|()
argument_list|,
name|newLocatedBlock
operator|.
name|getBlock
argument_list|()
operator|.
name|getGenerationStamp
argument_list|()
argument_list|)
decl_stmt|;
name|namenode
operator|.
name|updatePipeline
argument_list|(
name|clientName
argument_list|,
name|oldBlock
argument_list|,
name|newBlock
argument_list|,
name|newLocatedBlock
operator|.
name|getLocations
argument_list|()
argument_list|,
name|newLocatedBlock
operator|.
name|getStorageIDs
argument_list|()
argument_list|)
expr_stmt|;
name|BlockInfo
name|bi
init|=
name|bm
operator|.
name|getStoredBlock
argument_list|(
name|newBlock
operator|.
name|getLocalBlock
argument_list|()
argument_list|)
decl_stmt|;
name|assertFalse
argument_list|(
name|bm
operator|.
name|isNeededReconstruction
argument_list|(
name|bi
argument_list|,
name|bm
operator|.
name|countNodes
argument_list|(
name|bi
argument_list|,
name|cluster
operator|.
name|getNamesystem
argument_list|()
operator|.
name|isInStartupSafeMode
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|IOUtils
operator|.
name|closeStream
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|cluster
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Tell the block manager that replication is completed for the given    * pipeline.    */
DECL|method|fulfillPipeline (BlockInfo blockInfo, DatanodeStorageInfo[] pipeline)
specifier|private
name|void
name|fulfillPipeline
parameter_list|(
name|BlockInfo
name|blockInfo
parameter_list|,
name|DatanodeStorageInfo
index|[]
name|pipeline
parameter_list|)
throws|throws
name|IOException
block|{
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|pipeline
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|DatanodeStorageInfo
name|storage
init|=
name|pipeline
index|[
name|i
index|]
decl_stmt|;
name|bm
operator|.
name|addBlock
argument_list|(
name|storage
argument_list|,
name|blockInfo
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|blockInfo
operator|.
name|addStorage
argument_list|(
name|storage
argument_list|,
name|blockInfo
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|blockOnNodes (long blkId, List<DatanodeDescriptor> nodes)
specifier|private
name|BlockInfo
name|blockOnNodes
parameter_list|(
name|long
name|blkId
parameter_list|,
name|List
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|nodes
parameter_list|)
block|{
name|Block
name|block
init|=
operator|new
name|Block
argument_list|(
name|blkId
argument_list|)
decl_stmt|;
name|BlockInfo
name|blockInfo
init|=
operator|new
name|BlockInfoContiguous
argument_list|(
name|block
argument_list|,
operator|(
name|short
operator|)
literal|3
argument_list|)
decl_stmt|;
for|for
control|(
name|DatanodeDescriptor
name|dn
range|:
name|nodes
control|)
block|{
for|for
control|(
name|DatanodeStorageInfo
name|storage
range|:
name|dn
operator|.
name|getStorageInfos
argument_list|()
control|)
block|{
name|blockInfo
operator|.
name|addStorage
argument_list|(
name|storage
argument_list|,
name|blockInfo
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|blockInfo
return|;
block|}
DECL|method|getNodes (int ... indexes)
specifier|private
name|List
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|getNodes
parameter_list|(
name|int
modifier|...
name|indexes
parameter_list|)
block|{
name|List
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|ret
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|idx
range|:
name|indexes
control|)
block|{
name|ret
operator|.
name|add
argument_list|(
name|nodes
operator|.
name|get
argument_list|(
name|idx
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
DECL|method|getNodes (List<DatanodeStorageInfo> storages)
specifier|private
name|List
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|getNodes
parameter_list|(
name|List
argument_list|<
name|DatanodeStorageInfo
argument_list|>
name|storages
parameter_list|)
block|{
name|List
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|ret
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
for|for
control|(
name|DatanodeStorageInfo
name|s
range|:
name|storages
control|)
block|{
name|ret
operator|.
name|add
argument_list|(
name|s
operator|.
name|getDatanodeDescriptor
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
DECL|method|getStorages (int ... indexes)
specifier|private
name|List
argument_list|<
name|DatanodeStorageInfo
argument_list|>
name|getStorages
parameter_list|(
name|int
modifier|...
name|indexes
parameter_list|)
block|{
name|List
argument_list|<
name|DatanodeStorageInfo
argument_list|>
name|ret
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|idx
range|:
name|indexes
control|)
block|{
name|ret
operator|.
name|add
argument_list|(
name|storages
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
DECL|method|startDecommission (int ... indexes)
specifier|private
name|List
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|startDecommission
parameter_list|(
name|int
modifier|...
name|indexes
parameter_list|)
block|{
name|List
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|nodes
init|=
name|getNodes
argument_list|(
name|indexes
argument_list|)
decl_stmt|;
for|for
control|(
name|DatanodeDescriptor
name|node
range|:
name|nodes
control|)
block|{
name|node
operator|.
name|startDecommission
argument_list|()
expr_stmt|;
block|}
return|return
name|nodes
return|;
block|}
DECL|method|addBlockOnNodes (long blockId, List<DatanodeDescriptor> nodes)
specifier|private
name|BlockInfo
name|addBlockOnNodes
parameter_list|(
name|long
name|blockId
parameter_list|,
name|List
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|nodes
parameter_list|)
block|{
name|long
name|inodeId
init|=
operator|++
name|mockINodeId
decl_stmt|;
specifier|final
name|INodeFile
name|bc
init|=
name|TestINodeFile
operator|.
name|createINodeFile
argument_list|(
name|inodeId
argument_list|)
decl_stmt|;
name|BlockInfo
name|blockInfo
init|=
name|blockOnNodes
argument_list|(
name|blockId
argument_list|,
name|nodes
argument_list|)
decl_stmt|;
name|blockInfo
operator|.
name|setReplication
argument_list|(
operator|(
name|short
operator|)
literal|3
argument_list|)
expr_stmt|;
name|blockInfo
operator|.
name|setBlockCollectionId
argument_list|(
name|inodeId
argument_list|)
expr_stmt|;
name|Mockito
operator|.
name|doReturn
argument_list|(
name|bc
argument_list|)
operator|.
name|when
argument_list|(
name|fsn
argument_list|)
operator|.
name|getBlockCollection
argument_list|(
name|inodeId
argument_list|)
expr_stmt|;
name|bm
operator|.
name|blocksMap
operator|.
name|addBlockCollection
argument_list|(
name|blockInfo
argument_list|,
name|bc
argument_list|)
expr_stmt|;
return|return
name|blockInfo
return|;
block|}
DECL|method|addCorruptBlockOnNodes (long blockId, List<DatanodeDescriptor> nodes)
specifier|private
name|BlockInfo
name|addCorruptBlockOnNodes
parameter_list|(
name|long
name|blockId
parameter_list|,
name|List
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|nodes
parameter_list|)
throws|throws
name|IOException
block|{
name|long
name|inodeId
init|=
operator|++
name|mockINodeId
decl_stmt|;
specifier|final
name|INodeFile
name|bc
init|=
name|TestINodeFile
operator|.
name|createINodeFile
argument_list|(
name|inodeId
argument_list|)
decl_stmt|;
name|BlockInfo
name|blockInfo
init|=
name|blockOnNodes
argument_list|(
name|blockId
argument_list|,
name|nodes
argument_list|)
decl_stmt|;
name|blockInfo
operator|.
name|setReplication
argument_list|(
operator|(
name|short
operator|)
literal|3
argument_list|)
expr_stmt|;
name|blockInfo
operator|.
name|setBlockCollectionId
argument_list|(
name|inodeId
argument_list|)
expr_stmt|;
name|Mockito
operator|.
name|doReturn
argument_list|(
name|bc
argument_list|)
operator|.
name|when
argument_list|(
name|fsn
argument_list|)
operator|.
name|getBlockCollection
argument_list|(
name|inodeId
argument_list|)
expr_stmt|;
name|bm
operator|.
name|blocksMap
operator|.
name|addBlockCollection
argument_list|(
name|blockInfo
argument_list|,
name|bc
argument_list|)
expr_stmt|;
name|bm
operator|.
name|markBlockReplicasAsCorrupt
argument_list|(
name|blockInfo
argument_list|,
name|blockInfo
argument_list|,
name|blockInfo
operator|.
name|getGenerationStamp
argument_list|()
operator|+
literal|1
argument_list|,
name|blockInfo
operator|.
name|getNumBytes
argument_list|()
argument_list|,
operator|new
name|DatanodeStorageInfo
index|[]
block|{
name|nodes
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getStorageInfos
argument_list|()
index|[
literal|0
index|]
block|}
argument_list|)
expr_stmt|;
return|return
name|blockInfo
return|;
block|}
DECL|method|scheduleSingleReplication (BlockInfo block)
specifier|private
name|DatanodeStorageInfo
index|[]
name|scheduleSingleReplication
parameter_list|(
name|BlockInfo
name|block
parameter_list|)
block|{
comment|// list for priority 1
name|List
argument_list|<
name|BlockInfo
argument_list|>
name|list_p1
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|list_p1
operator|.
name|add
argument_list|(
name|block
argument_list|)
expr_stmt|;
comment|// list of lists for each priority
name|List
argument_list|<
name|List
argument_list|<
name|BlockInfo
argument_list|>
argument_list|>
name|list_all
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|list_all
operator|.
name|add
argument_list|(
operator|new
name|ArrayList
argument_list|<
name|BlockInfo
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
comment|// for priority 0
name|list_all
operator|.
name|add
argument_list|(
name|list_p1
argument_list|)
expr_stmt|;
comment|// for priority 1
name|assertEquals
argument_list|(
literal|"Block not initially pending reconstruction"
argument_list|,
literal|0
argument_list|,
name|bm
operator|.
name|pendingReconstruction
operator|.
name|getNumReplicas
argument_list|(
name|block
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"computeBlockReconstructionWork should indicate reconstruction is needed"
argument_list|,
literal|1
argument_list|,
name|bm
operator|.
name|computeReconstructionWorkForBlocks
argument_list|(
name|list_all
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"reconstruction is pending after work is computed"
argument_list|,
name|bm
operator|.
name|pendingReconstruction
operator|.
name|getNumReplicas
argument_list|(
name|block
argument_list|)
operator|>
literal|0
argument_list|)
expr_stmt|;
name|LinkedListMultimap
argument_list|<
name|DatanodeStorageInfo
argument_list|,
name|BlockTargetPair
argument_list|>
name|repls
init|=
name|getAllPendingReconstruction
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|repls
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|Entry
argument_list|<
name|DatanodeStorageInfo
argument_list|,
name|BlockTargetPair
argument_list|>
name|repl
init|=
name|repls
operator|.
name|entries
argument_list|()
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
decl_stmt|;
name|DatanodeStorageInfo
index|[]
name|targets
init|=
name|repl
operator|.
name|getValue
argument_list|()
operator|.
name|targets
decl_stmt|;
name|DatanodeStorageInfo
index|[]
name|pipeline
init|=
operator|new
name|DatanodeStorageInfo
index|[
literal|1
operator|+
name|targets
operator|.
name|length
index|]
decl_stmt|;
name|pipeline
index|[
literal|0
index|]
operator|=
name|repl
operator|.
name|getKey
argument_list|()
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|targets
argument_list|,
literal|0
argument_list|,
name|pipeline
argument_list|,
literal|1
argument_list|,
name|targets
operator|.
name|length
argument_list|)
expr_stmt|;
return|return
name|pipeline
return|;
block|}
DECL|method|getAllPendingReconstruction ()
specifier|private
name|LinkedListMultimap
argument_list|<
name|DatanodeStorageInfo
argument_list|,
name|BlockTargetPair
argument_list|>
name|getAllPendingReconstruction
parameter_list|()
block|{
name|LinkedListMultimap
argument_list|<
name|DatanodeStorageInfo
argument_list|,
name|BlockTargetPair
argument_list|>
name|repls
init|=
name|LinkedListMultimap
operator|.
name|create
argument_list|()
decl_stmt|;
for|for
control|(
name|DatanodeDescriptor
name|dn
range|:
name|nodes
control|)
block|{
name|List
argument_list|<
name|BlockTargetPair
argument_list|>
name|thisRepls
init|=
name|dn
operator|.
name|getReplicationCommand
argument_list|(
literal|10
argument_list|)
decl_stmt|;
if|if
condition|(
name|thisRepls
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|DatanodeStorageInfo
name|storage
range|:
name|dn
operator|.
name|getStorageInfos
argument_list|()
control|)
block|{
name|repls
operator|.
name|putAll
argument_list|(
name|storage
argument_list|,
name|thisRepls
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|repls
return|;
block|}
comment|/**    * Test that a source node for a highest-priority reconstruction is chosen    * even if all available source nodes have reached their replication limits.    */
annotation|@
name|Test
DECL|method|testHighestPriReplSrcChosenDespiteMaxReplLimit ()
specifier|public
name|void
name|testHighestPriReplSrcChosenDespiteMaxReplLimit
parameter_list|()
throws|throws
name|Exception
block|{
name|bm
operator|.
name|maxReplicationStreams
operator|=
literal|0
expr_stmt|;
name|bm
operator|.
name|replicationStreamsHardLimit
operator|=
literal|1
expr_stmt|;
name|long
name|blockId
init|=
literal|42
decl_stmt|;
comment|// arbitrary
name|Block
name|aBlock
init|=
operator|new
name|Block
argument_list|(
name|blockId
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|origNodes
init|=
name|getNodes
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
decl_stmt|;
comment|// Add the block to the first node.
name|addBlockOnNodes
argument_list|(
name|blockId
argument_list|,
name|origNodes
operator|.
name|subList
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|cntNodes
init|=
operator|new
name|LinkedList
argument_list|<
name|DatanodeDescriptor
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|DatanodeStorageInfo
argument_list|>
name|liveNodes
init|=
operator|new
name|LinkedList
argument_list|<
name|DatanodeStorageInfo
argument_list|>
argument_list|()
decl_stmt|;
name|assertNotNull
argument_list|(
literal|"Chooses source node for a highest-priority replication"
operator|+
literal|" even if all available source nodes have reached their replication"
operator|+
literal|" limits below the hard limit."
argument_list|,
name|bm
operator|.
name|chooseSourceDatanodes
argument_list|(
name|bm
operator|.
name|getStoredBlock
argument_list|(
name|aBlock
argument_list|)
argument_list|,
name|cntNodes
argument_list|,
name|liveNodes
argument_list|,
operator|new
name|NumberReplicas
argument_list|()
argument_list|,
operator|new
name|ArrayList
argument_list|<
name|Byte
argument_list|>
argument_list|()
argument_list|,
name|LowRedundancyBlocks
operator|.
name|QUEUE_HIGHEST_PRIORITY
argument_list|)
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Does not choose a source node for a less-than-highest-priority"
operator|+
literal|" replication since all available source nodes have reached"
operator|+
literal|" their replication limits."
argument_list|,
literal|0
argument_list|,
name|bm
operator|.
name|chooseSourceDatanodes
argument_list|(
name|bm
operator|.
name|getStoredBlock
argument_list|(
name|aBlock
argument_list|)
argument_list|,
name|cntNodes
argument_list|,
name|liveNodes
argument_list|,
operator|new
name|NumberReplicas
argument_list|()
argument_list|,
operator|new
name|ArrayList
argument_list|<
name|Byte
argument_list|>
argument_list|()
argument_list|,
name|LowRedundancyBlocks
operator|.
name|QUEUE_VERY_LOW_REDUNDANCY
argument_list|)
operator|.
name|length
argument_list|)
expr_stmt|;
comment|// Increase the replication count to test replication count> hard limit
name|DatanodeStorageInfo
name|targets
index|[]
init|=
block|{
name|origNodes
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|getStorageInfos
argument_list|()
index|[
literal|0
index|]
block|}
decl_stmt|;
name|origNodes
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|addBlockToBeReplicated
argument_list|(
name|aBlock
argument_list|,
name|targets
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Does not choose a source node for a highest-priority"
operator|+
literal|" replication when all available nodes exceed the hard limit."
argument_list|,
literal|0
argument_list|,
name|bm
operator|.
name|chooseSourceDatanodes
argument_list|(
name|bm
operator|.
name|getStoredBlock
argument_list|(
name|aBlock
argument_list|)
argument_list|,
name|cntNodes
argument_list|,
name|liveNodes
argument_list|,
operator|new
name|NumberReplicas
argument_list|()
argument_list|,
operator|new
name|ArrayList
argument_list|<
name|Byte
argument_list|>
argument_list|()
argument_list|,
name|LowRedundancyBlocks
operator|.
name|QUEUE_HIGHEST_PRIORITY
argument_list|)
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testFavorDecomUntilHardLimit ()
specifier|public
name|void
name|testFavorDecomUntilHardLimit
parameter_list|()
throws|throws
name|Exception
block|{
name|bm
operator|.
name|maxReplicationStreams
operator|=
literal|0
expr_stmt|;
name|bm
operator|.
name|replicationStreamsHardLimit
operator|=
literal|1
expr_stmt|;
name|long
name|blockId
init|=
literal|42
decl_stmt|;
comment|// arbitrary
name|Block
name|aBlock
init|=
operator|new
name|Block
argument_list|(
name|blockId
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|origNodes
init|=
name|getNodes
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
decl_stmt|;
comment|// Add the block to the first node.
name|addBlockOnNodes
argument_list|(
name|blockId
argument_list|,
name|origNodes
operator|.
name|subList
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|origNodes
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|startDecommission
argument_list|()
expr_stmt|;
name|List
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|cntNodes
init|=
operator|new
name|LinkedList
argument_list|<
name|DatanodeDescriptor
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|DatanodeStorageInfo
argument_list|>
name|liveNodes
init|=
operator|new
name|LinkedList
argument_list|<
name|DatanodeStorageInfo
argument_list|>
argument_list|()
decl_stmt|;
name|assertNotNull
argument_list|(
literal|"Chooses decommissioning source node for a normal replication"
operator|+
literal|" if all available source nodes have reached their replication"
operator|+
literal|" limits below the hard limit."
argument_list|,
name|bm
operator|.
name|chooseSourceDatanodes
argument_list|(
name|bm
operator|.
name|getStoredBlock
argument_list|(
name|aBlock
argument_list|)
argument_list|,
name|cntNodes
argument_list|,
name|liveNodes
argument_list|,
operator|new
name|NumberReplicas
argument_list|()
argument_list|,
operator|new
name|LinkedList
argument_list|<
name|Byte
argument_list|>
argument_list|()
argument_list|,
name|LowRedundancyBlocks
operator|.
name|QUEUE_LOW_REDUNDANCY
argument_list|)
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|// Increase the replication count to test replication count> hard limit
name|DatanodeStorageInfo
name|targets
index|[]
init|=
block|{
name|origNodes
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|getStorageInfos
argument_list|()
index|[
literal|0
index|]
block|}
decl_stmt|;
name|origNodes
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|addBlockToBeReplicated
argument_list|(
name|aBlock
argument_list|,
name|targets
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Does not choose a source decommissioning node for a normal"
operator|+
literal|" replication when all available nodes exceed the hard limit."
argument_list|,
literal|0
argument_list|,
name|bm
operator|.
name|chooseSourceDatanodes
argument_list|(
name|bm
operator|.
name|getStoredBlock
argument_list|(
name|aBlock
argument_list|)
argument_list|,
name|cntNodes
argument_list|,
name|liveNodes
argument_list|,
operator|new
name|NumberReplicas
argument_list|()
argument_list|,
operator|new
name|LinkedList
argument_list|<
name|Byte
argument_list|>
argument_list|()
argument_list|,
name|LowRedundancyBlocks
operator|.
name|QUEUE_LOW_REDUNDANCY
argument_list|)
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testSafeModeIBR ()
specifier|public
name|void
name|testSafeModeIBR
parameter_list|()
throws|throws
name|Exception
block|{
name|DatanodeDescriptor
name|node
init|=
name|spy
argument_list|(
name|nodes
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|DatanodeStorageInfo
name|ds
init|=
name|node
operator|.
name|getStorageInfos
argument_list|()
index|[
literal|0
index|]
decl_stmt|;
name|node
operator|.
name|setAlive
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|DatanodeRegistration
name|nodeReg
init|=
operator|new
name|DatanodeRegistration
argument_list|(
name|node
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|""
argument_list|)
decl_stmt|;
comment|// pretend to be in safemode
name|doReturn
argument_list|(
literal|true
argument_list|)
operator|.
name|when
argument_list|(
name|fsn
argument_list|)
operator|.
name|isInStartupSafeMode
argument_list|()
expr_stmt|;
comment|// register new node
name|bm
operator|.
name|getDatanodeManager
argument_list|()
operator|.
name|registerDatanode
argument_list|(
name|nodeReg
argument_list|)
expr_stmt|;
name|bm
operator|.
name|getDatanodeManager
argument_list|()
operator|.
name|addDatanode
argument_list|(
name|node
argument_list|)
expr_stmt|;
comment|// swap in spy
name|assertEquals
argument_list|(
name|node
argument_list|,
name|bm
operator|.
name|getDatanodeManager
argument_list|()
operator|.
name|getDatanode
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|ds
operator|.
name|getBlockReportCount
argument_list|()
argument_list|)
expr_stmt|;
comment|// send block report, should be processed
name|reset
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|bm
operator|.
name|processReport
argument_list|(
name|node
argument_list|,
operator|new
name|DatanodeStorage
argument_list|(
name|ds
operator|.
name|getStorageID
argument_list|()
argument_list|)
argument_list|,
name|BlockListAsLongs
operator|.
name|EMPTY
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|ds
operator|.
name|getBlockReportCount
argument_list|()
argument_list|)
expr_stmt|;
comment|// send block report again, should NOT be processed
name|reset
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|bm
operator|.
name|processReport
argument_list|(
name|node
argument_list|,
operator|new
name|DatanodeStorage
argument_list|(
name|ds
operator|.
name|getStorageID
argument_list|()
argument_list|)
argument_list|,
name|BlockListAsLongs
operator|.
name|EMPTY
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|ds
operator|.
name|getBlockReportCount
argument_list|()
argument_list|)
expr_stmt|;
comment|// re-register as if node restarted, should update existing node
name|bm
operator|.
name|getDatanodeManager
argument_list|()
operator|.
name|removeDatanode
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|reset
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|bm
operator|.
name|getDatanodeManager
argument_list|()
operator|.
name|registerDatanode
argument_list|(
name|nodeReg
argument_list|)
expr_stmt|;
name|verify
argument_list|(
name|node
argument_list|)
operator|.
name|updateRegInfo
argument_list|(
name|nodeReg
argument_list|)
expr_stmt|;
comment|// send block report, should be processed after restart
name|reset
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|bm
operator|.
name|processReport
argument_list|(
name|node
argument_list|,
operator|new
name|DatanodeStorage
argument_list|(
name|ds
operator|.
name|getStorageID
argument_list|()
argument_list|)
argument_list|,
name|BlockListAsLongs
operator|.
name|EMPTY
argument_list|,
literal|null
argument_list|)
expr_stmt|;
comment|// Reinitialize as registration with empty storage list pruned
comment|// node.storageMap.
name|ds
operator|=
name|node
operator|.
name|getStorageInfos
argument_list|()
index|[
literal|0
index|]
expr_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|ds
operator|.
name|getBlockReportCount
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testSafeModeIBRAfterIncremental ()
specifier|public
name|void
name|testSafeModeIBRAfterIncremental
parameter_list|()
throws|throws
name|Exception
block|{
name|DatanodeDescriptor
name|node
init|=
name|spy
argument_list|(
name|nodes
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|DatanodeStorageInfo
name|ds
init|=
name|node
operator|.
name|getStorageInfos
argument_list|()
index|[
literal|0
index|]
decl_stmt|;
name|node
operator|.
name|setAlive
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|DatanodeRegistration
name|nodeReg
init|=
operator|new
name|DatanodeRegistration
argument_list|(
name|node
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|""
argument_list|)
decl_stmt|;
comment|// pretend to be in safemode
name|doReturn
argument_list|(
literal|true
argument_list|)
operator|.
name|when
argument_list|(
name|fsn
argument_list|)
operator|.
name|isInStartupSafeMode
argument_list|()
expr_stmt|;
comment|// register new node
name|bm
operator|.
name|getDatanodeManager
argument_list|()
operator|.
name|registerDatanode
argument_list|(
name|nodeReg
argument_list|)
expr_stmt|;
name|bm
operator|.
name|getDatanodeManager
argument_list|()
operator|.
name|addDatanode
argument_list|(
name|node
argument_list|)
expr_stmt|;
comment|// swap in spy
name|assertEquals
argument_list|(
name|node
argument_list|,
name|bm
operator|.
name|getDatanodeManager
argument_list|()
operator|.
name|getDatanode
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|ds
operator|.
name|getBlockReportCount
argument_list|()
argument_list|)
expr_stmt|;
comment|// send block report while pretending to already have blocks
name|reset
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|doReturn
argument_list|(
literal|1
argument_list|)
operator|.
name|when
argument_list|(
name|node
argument_list|)
operator|.
name|numBlocks
argument_list|()
expr_stmt|;
name|bm
operator|.
name|processReport
argument_list|(
name|node
argument_list|,
operator|new
name|DatanodeStorage
argument_list|(
name|ds
operator|.
name|getStorageID
argument_list|()
argument_list|)
argument_list|,
name|BlockListAsLongs
operator|.
name|EMPTY
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|ds
operator|.
name|getBlockReportCount
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * test when NN starts and in same mode, it receives an incremental blockReport    * firstly. Then receives first full block report.    */
annotation|@
name|Test
DECL|method|testSafeModeIBRBeforeFirstFullBR ()
specifier|public
name|void
name|testSafeModeIBRBeforeFirstFullBR
parameter_list|()
throws|throws
name|Exception
block|{
comment|// pretend to be in safemode
name|doReturn
argument_list|(
literal|true
argument_list|)
operator|.
name|when
argument_list|(
name|fsn
argument_list|)
operator|.
name|isInStartupSafeMode
argument_list|()
expr_stmt|;
name|DatanodeDescriptor
name|node
init|=
name|nodes
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|DatanodeStorageInfo
name|ds
init|=
name|node
operator|.
name|getStorageInfos
argument_list|()
index|[
literal|0
index|]
decl_stmt|;
name|node
operator|.
name|setAlive
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|DatanodeRegistration
name|nodeReg
init|=
operator|new
name|DatanodeRegistration
argument_list|(
name|node
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|""
argument_list|)
decl_stmt|;
comment|// register new node
name|bm
operator|.
name|getDatanodeManager
argument_list|()
operator|.
name|registerDatanode
argument_list|(
name|nodeReg
argument_list|)
expr_stmt|;
name|bm
operator|.
name|getDatanodeManager
argument_list|()
operator|.
name|addDatanode
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|node
argument_list|,
name|bm
operator|.
name|getDatanodeManager
argument_list|()
operator|.
name|getDatanode
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|ds
operator|.
name|getBlockReportCount
argument_list|()
argument_list|)
expr_stmt|;
comment|// Build a incremental report
name|List
argument_list|<
name|ReceivedDeletedBlockInfo
argument_list|>
name|rdbiList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
comment|// Build a full report
name|BlockListAsLongs
operator|.
name|Builder
name|builder
init|=
name|BlockListAsLongs
operator|.
name|builder
argument_list|()
decl_stmt|;
comment|// blk_42 is finalized.
name|long
name|receivedBlockId
init|=
literal|42
decl_stmt|;
comment|// arbitrary
name|BlockInfo
name|receivedBlock
init|=
name|addBlockToBM
argument_list|(
name|receivedBlockId
argument_list|)
decl_stmt|;
name|rdbiList
operator|.
name|add
argument_list|(
operator|new
name|ReceivedDeletedBlockInfo
argument_list|(
operator|new
name|Block
argument_list|(
name|receivedBlock
argument_list|)
argument_list|,
name|ReceivedDeletedBlockInfo
operator|.
name|BlockStatus
operator|.
name|RECEIVED_BLOCK
argument_list|,
literal|null
argument_list|)
argument_list|)
expr_stmt|;
name|builder
operator|.
name|add
argument_list|(
operator|new
name|FinalizedReplica
argument_list|(
name|receivedBlock
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
argument_list|)
expr_stmt|;
comment|// blk_43 is under construction.
name|long
name|receivingBlockId
init|=
literal|43
decl_stmt|;
name|BlockInfo
name|receivingBlock
init|=
name|addUcBlockToBM
argument_list|(
name|receivingBlockId
argument_list|)
decl_stmt|;
name|rdbiList
operator|.
name|add
argument_list|(
operator|new
name|ReceivedDeletedBlockInfo
argument_list|(
operator|new
name|Block
argument_list|(
name|receivingBlock
argument_list|)
argument_list|,
name|ReceivedDeletedBlockInfo
operator|.
name|BlockStatus
operator|.
name|RECEIVING_BLOCK
argument_list|,
literal|null
argument_list|)
argument_list|)
expr_stmt|;
name|builder
operator|.
name|add
argument_list|(
operator|new
name|ReplicaBeingWritten
argument_list|(
name|receivingBlock
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
argument_list|)
expr_stmt|;
comment|// blk_44 has 2 records in IBR. It's finalized. So full BR has 1 record.
name|long
name|receivingReceivedBlockId
init|=
literal|44
decl_stmt|;
name|BlockInfo
name|receivingReceivedBlock
init|=
name|addBlockToBM
argument_list|(
name|receivingReceivedBlockId
argument_list|)
decl_stmt|;
name|rdbiList
operator|.
name|add
argument_list|(
operator|new
name|ReceivedDeletedBlockInfo
argument_list|(
operator|new
name|Block
argument_list|(
name|receivingReceivedBlock
argument_list|)
argument_list|,
name|ReceivedDeletedBlockInfo
operator|.
name|BlockStatus
operator|.
name|RECEIVING_BLOCK
argument_list|,
literal|null
argument_list|)
argument_list|)
expr_stmt|;
name|rdbiList
operator|.
name|add
argument_list|(
operator|new
name|ReceivedDeletedBlockInfo
argument_list|(
operator|new
name|Block
argument_list|(
name|receivingReceivedBlock
argument_list|)
argument_list|,
name|ReceivedDeletedBlockInfo
operator|.
name|BlockStatus
operator|.
name|RECEIVED_BLOCK
argument_list|,
literal|null
argument_list|)
argument_list|)
expr_stmt|;
name|builder
operator|.
name|add
argument_list|(
operator|new
name|FinalizedReplica
argument_list|(
name|receivingReceivedBlock
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
argument_list|)
expr_stmt|;
comment|// blk_45 is not in full BR, because it's deleted.
name|long
name|ReceivedDeletedBlockId
init|=
literal|45
decl_stmt|;
name|rdbiList
operator|.
name|add
argument_list|(
operator|new
name|ReceivedDeletedBlockInfo
argument_list|(
operator|new
name|Block
argument_list|(
name|ReceivedDeletedBlockId
argument_list|)
argument_list|,
name|ReceivedDeletedBlockInfo
operator|.
name|BlockStatus
operator|.
name|RECEIVED_BLOCK
argument_list|,
literal|null
argument_list|)
argument_list|)
expr_stmt|;
name|rdbiList
operator|.
name|add
argument_list|(
operator|new
name|ReceivedDeletedBlockInfo
argument_list|(
operator|new
name|Block
argument_list|(
name|ReceivedDeletedBlockId
argument_list|)
argument_list|,
name|ReceivedDeletedBlockInfo
operator|.
name|BlockStatus
operator|.
name|DELETED_BLOCK
argument_list|,
literal|null
argument_list|)
argument_list|)
expr_stmt|;
comment|// blk_46 exists in DN for a long time, so it's in full BR, but not in IBR.
name|long
name|existedBlockId
init|=
literal|46
decl_stmt|;
name|BlockInfo
name|existedBlock
init|=
name|addBlockToBM
argument_list|(
name|existedBlockId
argument_list|)
decl_stmt|;
name|builder
operator|.
name|add
argument_list|(
operator|new
name|FinalizedReplica
argument_list|(
name|existedBlock
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
argument_list|)
expr_stmt|;
comment|// process IBR and full BR
name|StorageReceivedDeletedBlocks
name|srdb
init|=
operator|new
name|StorageReceivedDeletedBlocks
argument_list|(
operator|new
name|DatanodeStorage
argument_list|(
name|ds
operator|.
name|getStorageID
argument_list|()
argument_list|)
argument_list|,
name|rdbiList
operator|.
name|toArray
argument_list|(
operator|new
name|ReceivedDeletedBlockInfo
index|[
name|rdbiList
operator|.
name|size
argument_list|()
index|]
argument_list|)
argument_list|)
decl_stmt|;
name|bm
operator|.
name|processIncrementalBlockReport
argument_list|(
name|node
argument_list|,
name|srdb
argument_list|)
expr_stmt|;
comment|// Make sure it's the first full report
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|ds
operator|.
name|getBlockReportCount
argument_list|()
argument_list|)
expr_stmt|;
name|bm
operator|.
name|processReport
argument_list|(
name|node
argument_list|,
operator|new
name|DatanodeStorage
argument_list|(
name|ds
operator|.
name|getStorageID
argument_list|()
argument_list|)
argument_list|,
name|builder
operator|.
name|build
argument_list|()
argument_list|,
operator|new
name|BlockReportContext
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
name|System
operator|.
name|nanoTime
argument_list|()
argument_list|,
literal|0
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|ds
operator|.
name|getBlockReportCount
argument_list|()
argument_list|)
expr_stmt|;
comment|// verify the storage info is correct
name|assertTrue
argument_list|(
name|bm
operator|.
name|getStoredBlock
argument_list|(
operator|new
name|Block
argument_list|(
name|receivedBlockId
argument_list|)
argument_list|)
operator|.
name|findStorageInfo
argument_list|(
name|ds
argument_list|)
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|bm
operator|.
name|getStoredBlock
argument_list|(
operator|new
name|Block
argument_list|(
name|receivingBlockId
argument_list|)
argument_list|)
operator|.
name|getUnderConstructionFeature
argument_list|()
operator|.
name|getNumExpectedLocations
argument_list|()
operator|>
literal|0
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|bm
operator|.
name|getStoredBlock
argument_list|(
operator|new
name|Block
argument_list|(
name|receivingReceivedBlockId
argument_list|)
argument_list|)
operator|.
name|findStorageInfo
argument_list|(
name|ds
argument_list|)
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|assertNull
argument_list|(
name|bm
operator|.
name|getStoredBlock
argument_list|(
operator|new
name|Block
argument_list|(
name|ReceivedDeletedBlockId
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|bm
operator|.
name|getStoredBlock
argument_list|(
operator|new
name|Block
argument_list|(
name|existedBlock
argument_list|)
argument_list|)
operator|.
name|findStorageInfo
argument_list|(
name|ds
argument_list|)
operator|>=
literal|0
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testFullBR ()
specifier|public
name|void
name|testFullBR
parameter_list|()
throws|throws
name|Exception
block|{
name|doReturn
argument_list|(
literal|true
argument_list|)
operator|.
name|when
argument_list|(
name|fsn
argument_list|)
operator|.
name|isRunning
argument_list|()
expr_stmt|;
name|DatanodeDescriptor
name|node
init|=
name|nodes
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|DatanodeStorageInfo
name|ds
init|=
name|node
operator|.
name|getStorageInfos
argument_list|()
index|[
literal|0
index|]
decl_stmt|;
name|node
operator|.
name|setAlive
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|DatanodeRegistration
name|nodeReg
init|=
operator|new
name|DatanodeRegistration
argument_list|(
name|node
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|""
argument_list|)
decl_stmt|;
comment|// register new node
name|bm
operator|.
name|getDatanodeManager
argument_list|()
operator|.
name|registerDatanode
argument_list|(
name|nodeReg
argument_list|)
expr_stmt|;
name|bm
operator|.
name|getDatanodeManager
argument_list|()
operator|.
name|addDatanode
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|node
argument_list|,
name|bm
operator|.
name|getDatanodeManager
argument_list|()
operator|.
name|getDatanode
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|ds
operator|.
name|getBlockReportCount
argument_list|()
argument_list|)
expr_stmt|;
name|ArrayList
argument_list|<
name|BlockInfo
argument_list|>
name|blocks
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|id
init|=
literal|24
init|;
name|id
operator|>
literal|0
condition|;
name|id
operator|--
control|)
block|{
name|blocks
operator|.
name|add
argument_list|(
name|addBlockToBM
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Make sure it's the first full report
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|ds
operator|.
name|getBlockReportCount
argument_list|()
argument_list|)
expr_stmt|;
name|bm
operator|.
name|processReport
argument_list|(
name|node
argument_list|,
operator|new
name|DatanodeStorage
argument_list|(
name|ds
operator|.
name|getStorageID
argument_list|()
argument_list|)
argument_list|,
name|generateReport
argument_list|(
name|blocks
argument_list|)
argument_list|,
operator|new
name|BlockReportContext
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
name|System
operator|.
name|nanoTime
argument_list|()
argument_list|,
literal|0
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|ds
operator|.
name|getBlockReportCount
argument_list|()
argument_list|)
expr_stmt|;
comment|// verify the storage info is correct
for|for
control|(
name|BlockInfo
name|block
range|:
name|blocks
control|)
block|{
name|assertTrue
argument_list|(
name|bm
operator|.
name|getStoredBlock
argument_list|(
name|block
argument_list|)
operator|.
name|findStorageInfo
argument_list|(
name|ds
argument_list|)
operator|>=
literal|0
argument_list|)
expr_stmt|;
block|}
comment|// Send unsorted report
name|bm
operator|.
name|processReport
argument_list|(
name|node
argument_list|,
operator|new
name|DatanodeStorage
argument_list|(
name|ds
operator|.
name|getStorageID
argument_list|()
argument_list|)
argument_list|,
name|generateReport
argument_list|(
name|blocks
argument_list|)
argument_list|,
operator|new
name|BlockReportContext
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
name|System
operator|.
name|nanoTime
argument_list|()
argument_list|,
literal|0
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|ds
operator|.
name|getBlockReportCount
argument_list|()
argument_list|)
expr_stmt|;
comment|// verify the storage info is correct
for|for
control|(
name|BlockInfo
name|block
range|:
name|blocks
control|)
block|{
name|assertTrue
argument_list|(
name|bm
operator|.
name|getStoredBlock
argument_list|(
name|block
argument_list|)
operator|.
name|findStorageInfo
argument_list|(
name|ds
argument_list|)
operator|>=
literal|0
argument_list|)
expr_stmt|;
block|}
comment|// Sort list and send a sorted report
name|Collections
operator|.
name|sort
argument_list|(
name|blocks
argument_list|)
expr_stmt|;
name|bm
operator|.
name|processReport
argument_list|(
name|node
argument_list|,
operator|new
name|DatanodeStorage
argument_list|(
name|ds
operator|.
name|getStorageID
argument_list|()
argument_list|)
argument_list|,
name|generateReport
argument_list|(
name|blocks
argument_list|)
argument_list|,
operator|new
name|BlockReportContext
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
name|System
operator|.
name|nanoTime
argument_list|()
argument_list|,
literal|0
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|3
argument_list|,
name|ds
operator|.
name|getBlockReportCount
argument_list|()
argument_list|)
expr_stmt|;
comment|// verify the storage info is correct
for|for
control|(
name|BlockInfo
name|block
range|:
name|blocks
control|)
block|{
name|assertTrue
argument_list|(
name|bm
operator|.
name|getStoredBlock
argument_list|(
name|block
argument_list|)
operator|.
name|findStorageInfo
argument_list|(
name|ds
argument_list|)
operator|>=
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|generateReport (List<BlockInfo> blocks)
specifier|private
name|BlockListAsLongs
name|generateReport
parameter_list|(
name|List
argument_list|<
name|BlockInfo
argument_list|>
name|blocks
parameter_list|)
block|{
name|BlockListAsLongs
operator|.
name|Builder
name|builder
init|=
name|BlockListAsLongs
operator|.
name|builder
argument_list|()
decl_stmt|;
for|for
control|(
name|BlockInfo
name|block
range|:
name|blocks
control|)
block|{
name|builder
operator|.
name|add
argument_list|(
operator|new
name|FinalizedReplica
argument_list|(
name|block
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|builder
operator|.
name|build
argument_list|()
return|;
block|}
annotation|@
name|Test
DECL|method|testUCBlockNotConsideredMissing ()
specifier|public
name|void
name|testUCBlockNotConsideredMissing
parameter_list|()
throws|throws
name|Exception
block|{
name|DatanodeDescriptor
name|node
init|=
name|nodes
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|DatanodeStorageInfo
name|ds
init|=
name|node
operator|.
name|getStorageInfos
argument_list|()
index|[
literal|0
index|]
decl_stmt|;
name|node
operator|.
name|setAlive
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|DatanodeRegistration
name|nodeReg
init|=
operator|new
name|DatanodeRegistration
argument_list|(
name|node
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|""
argument_list|)
decl_stmt|;
comment|// register new node
name|bm
operator|.
name|getDatanodeManager
argument_list|()
operator|.
name|registerDatanode
argument_list|(
name|nodeReg
argument_list|)
expr_stmt|;
name|bm
operator|.
name|getDatanodeManager
argument_list|()
operator|.
name|addDatanode
argument_list|(
name|node
argument_list|)
expr_stmt|;
comment|// Build an incremental report
name|List
argument_list|<
name|ReceivedDeletedBlockInfo
argument_list|>
name|rdbiList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
comment|// blk_42 is under construction, finalizes on one node and is
comment|// immediately deleted on same node
name|long
name|blockId
init|=
literal|42
decl_stmt|;
comment|// arbitrary
name|BlockInfo
name|receivedBlock
init|=
name|addUcBlockToBM
argument_list|(
name|blockId
argument_list|)
decl_stmt|;
name|rdbiList
operator|.
name|add
argument_list|(
operator|new
name|ReceivedDeletedBlockInfo
argument_list|(
operator|new
name|Block
argument_list|(
name|receivedBlock
argument_list|)
argument_list|,
name|ReceivedDeletedBlockInfo
operator|.
name|BlockStatus
operator|.
name|RECEIVED_BLOCK
argument_list|,
literal|null
argument_list|)
argument_list|)
expr_stmt|;
name|rdbiList
operator|.
name|add
argument_list|(
operator|new
name|ReceivedDeletedBlockInfo
argument_list|(
operator|new
name|Block
argument_list|(
name|blockId
argument_list|)
argument_list|,
name|ReceivedDeletedBlockInfo
operator|.
name|BlockStatus
operator|.
name|DELETED_BLOCK
argument_list|,
literal|null
argument_list|)
argument_list|)
expr_stmt|;
comment|// process IBR
name|StorageReceivedDeletedBlocks
name|srdb
init|=
operator|new
name|StorageReceivedDeletedBlocks
argument_list|(
operator|new
name|DatanodeStorage
argument_list|(
name|ds
operator|.
name|getStorageID
argument_list|()
argument_list|)
argument_list|,
name|rdbiList
operator|.
name|toArray
argument_list|(
operator|new
name|ReceivedDeletedBlockInfo
index|[
name|rdbiList
operator|.
name|size
argument_list|()
index|]
argument_list|)
argument_list|)
decl_stmt|;
name|bm
operator|.
name|setInitializedReplQueues
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|bm
operator|.
name|processIncrementalBlockReport
argument_list|(
name|node
argument_list|,
name|srdb
argument_list|)
expr_stmt|;
comment|// Needed replications should still be 0.
name|assertEquals
argument_list|(
literal|"UC block was incorrectly added to needed Replications"
argument_list|,
literal|0
argument_list|,
name|bm
operator|.
name|neededReconstruction
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|bm
operator|.
name|setInitializedReplQueues
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
DECL|method|addBlockToBM (long blkId)
specifier|private
name|BlockInfo
name|addBlockToBM
parameter_list|(
name|long
name|blkId
parameter_list|)
block|{
name|Block
name|block
init|=
operator|new
name|Block
argument_list|(
name|blkId
argument_list|)
decl_stmt|;
name|BlockInfo
name|blockInfo
init|=
operator|new
name|BlockInfoContiguous
argument_list|(
name|block
argument_list|,
operator|(
name|short
operator|)
literal|3
argument_list|)
decl_stmt|;
name|long
name|inodeId
init|=
operator|++
name|mockINodeId
decl_stmt|;
specifier|final
name|INodeFile
name|bc
init|=
name|TestINodeFile
operator|.
name|createINodeFile
argument_list|(
name|inodeId
argument_list|)
decl_stmt|;
name|bm
operator|.
name|blocksMap
operator|.
name|addBlockCollection
argument_list|(
name|blockInfo
argument_list|,
name|bc
argument_list|)
expr_stmt|;
name|blockInfo
operator|.
name|setBlockCollectionId
argument_list|(
name|inodeId
argument_list|)
expr_stmt|;
name|doReturn
argument_list|(
name|bc
argument_list|)
operator|.
name|when
argument_list|(
name|fsn
argument_list|)
operator|.
name|getBlockCollection
argument_list|(
name|inodeId
argument_list|)
expr_stmt|;
return|return
name|blockInfo
return|;
block|}
DECL|method|addUcBlockToBM (long blkId)
specifier|private
name|BlockInfo
name|addUcBlockToBM
parameter_list|(
name|long
name|blkId
parameter_list|)
block|{
name|Block
name|block
init|=
operator|new
name|Block
argument_list|(
name|blkId
argument_list|)
decl_stmt|;
name|BlockInfo
name|blockInfo
init|=
operator|new
name|BlockInfoContiguous
argument_list|(
name|block
argument_list|,
operator|(
name|short
operator|)
literal|3
argument_list|)
decl_stmt|;
name|blockInfo
operator|.
name|convertToBlockUnderConstruction
argument_list|(
name|UNDER_CONSTRUCTION
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|long
name|inodeId
init|=
operator|++
name|mockINodeId
decl_stmt|;
specifier|final
name|INodeFile
name|bc
init|=
name|TestINodeFile
operator|.
name|createINodeFile
argument_list|(
name|inodeId
argument_list|)
decl_stmt|;
name|blockInfo
operator|.
name|setBlockCollectionId
argument_list|(
name|inodeId
argument_list|)
expr_stmt|;
name|bm
operator|.
name|blocksMap
operator|.
name|addBlockCollection
argument_list|(
name|blockInfo
argument_list|,
name|bc
argument_list|)
expr_stmt|;
name|doReturn
argument_list|(
name|bc
argument_list|)
operator|.
name|when
argument_list|(
name|fsn
argument_list|)
operator|.
name|getBlockCollection
argument_list|(
name|inodeId
argument_list|)
expr_stmt|;
return|return
name|blockInfo
return|;
block|}
comment|/**    * Tests that a namenode doesn't choose a datanode with full disks to     * store blocks.    * @throws Exception    */
annotation|@
name|Test
DECL|method|testStorageWithRemainingCapacity ()
specifier|public
name|void
name|testStorageWithRemainingCapacity
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|Configuration
name|conf
init|=
operator|new
name|HdfsConfiguration
argument_list|()
decl_stmt|;
specifier|final
name|MiniDFSCluster
name|cluster
init|=
operator|new
name|MiniDFSCluster
operator|.
name|Builder
argument_list|(
name|conf
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|FileSystem
name|fs
init|=
name|FileSystem
operator|.
name|get
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|Path
name|file1
init|=
literal|null
decl_stmt|;
try|try
block|{
name|cluster
operator|.
name|waitActive
argument_list|()
expr_stmt|;
specifier|final
name|FSNamesystem
name|namesystem
init|=
name|cluster
operator|.
name|getNamesystem
argument_list|()
decl_stmt|;
specifier|final
name|String
name|poolId
init|=
name|namesystem
operator|.
name|getBlockPoolId
argument_list|()
decl_stmt|;
specifier|final
name|DatanodeRegistration
name|nodeReg
init|=
name|InternalDataNodeTestUtils
operator|.
name|getDNRegistrationForBP
argument_list|(
name|cluster
operator|.
name|getDataNodes
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|poolId
argument_list|)
decl_stmt|;
specifier|final
name|DatanodeDescriptor
name|dd
init|=
name|NameNodeAdapter
operator|.
name|getDatanode
argument_list|(
name|namesystem
argument_list|,
name|nodeReg
argument_list|)
decl_stmt|;
comment|// By default, MiniDFSCluster will create 1 datanode with 2 storages.
comment|// Assigning 64k for remaining storage capacity and will
comment|//create a file with 100k.
for|for
control|(
name|DatanodeStorageInfo
name|storage
range|:
name|dd
operator|.
name|getStorageInfos
argument_list|()
control|)
block|{
name|storage
operator|.
name|setUtilizationForTesting
argument_list|(
literal|65536
argument_list|,
literal|0
argument_list|,
literal|65536
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|//sum of the remaining capacity of both the storages
name|dd
operator|.
name|setRemaining
argument_list|(
literal|131072
argument_list|)
expr_stmt|;
name|file1
operator|=
operator|new
name|Path
argument_list|(
literal|"testRemainingStorage.dat"
argument_list|)
expr_stmt|;
try|try
block|{
name|DFSTestUtil
operator|.
name|createFile
argument_list|(
name|fs
argument_list|,
name|file1
argument_list|,
literal|102400
argument_list|,
literal|102400
argument_list|,
literal|102400
argument_list|,
operator|(
name|short
operator|)
literal|1
argument_list|,
literal|0x1BAD5EED
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RemoteException
name|re
parameter_list|)
block|{
name|GenericTestUtils
operator|.
name|assertExceptionContains
argument_list|(
literal|"nodes instead of "
operator|+
literal|"minReplication"
argument_list|,
name|re
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
comment|// Clean up
name|assertTrue
argument_list|(
name|fs
operator|.
name|exists
argument_list|(
name|file1
argument_list|)
argument_list|)
expr_stmt|;
name|fs
operator|.
name|delete
argument_list|(
name|file1
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
operator|!
name|fs
operator|.
name|exists
argument_list|(
name|file1
argument_list|)
argument_list|)
expr_stmt|;
name|cluster
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Test
DECL|method|testUseDelHint ()
specifier|public
name|void
name|testUseDelHint
parameter_list|()
block|{
name|DatanodeStorageInfo
name|delHint
init|=
operator|new
name|DatanodeStorageInfo
argument_list|(
name|DFSTestUtil
operator|.
name|getLocalDatanodeDescriptor
argument_list|()
argument_list|,
operator|new
name|DatanodeStorage
argument_list|(
literal|"id"
argument_list|)
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|DatanodeStorageInfo
argument_list|>
name|moreThan1Racks
init|=
name|Arrays
operator|.
name|asList
argument_list|(
name|delHint
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|StorageType
argument_list|>
name|excessTypes
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|BlockPlacementPolicyDefault
name|policyDefault
init|=
operator|(
name|BlockPlacementPolicyDefault
operator|)
name|bm
operator|.
name|getBlockPlacementPolicy
argument_list|()
decl_stmt|;
name|excessTypes
operator|.
name|add
argument_list|(
name|StorageType
operator|.
name|DEFAULT
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
name|policyDefault
operator|.
name|useDelHint
argument_list|(
name|delHint
argument_list|,
literal|null
argument_list|,
name|moreThan1Racks
argument_list|,
literal|null
argument_list|,
name|excessTypes
argument_list|)
argument_list|)
expr_stmt|;
name|excessTypes
operator|.
name|remove
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|excessTypes
operator|.
name|add
argument_list|(
name|StorageType
operator|.
name|SSD
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertFalse
argument_list|(
name|policyDefault
operator|.
name|useDelHint
argument_list|(
name|delHint
argument_list|,
literal|null
argument_list|,
name|moreThan1Racks
argument_list|,
literal|null
argument_list|,
name|excessTypes
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testBlockReportQueueing ()
specifier|public
name|void
name|testBlockReportQueueing
parameter_list|()
throws|throws
name|Exception
block|{
name|Configuration
name|conf
init|=
operator|new
name|HdfsConfiguration
argument_list|()
decl_stmt|;
specifier|final
name|MiniDFSCluster
name|cluster
init|=
operator|new
name|MiniDFSCluster
operator|.
name|Builder
argument_list|(
name|conf
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
try|try
block|{
name|cluster
operator|.
name|waitActive
argument_list|()
expr_stmt|;
specifier|final
name|FSNamesystem
name|fsn
init|=
name|cluster
operator|.
name|getNamesystem
argument_list|()
decl_stmt|;
specifier|final
name|BlockManager
name|bm
init|=
name|fsn
operator|.
name|getBlockManager
argument_list|()
decl_stmt|;
specifier|final
name|ExecutorService
name|executor
init|=
name|Executors
operator|.
name|newCachedThreadPool
argument_list|()
decl_stmt|;
specifier|final
name|CyclicBarrier
name|startBarrier
init|=
operator|new
name|CyclicBarrier
argument_list|(
literal|2
argument_list|)
decl_stmt|;
specifier|final
name|CountDownLatch
name|endLatch
init|=
operator|new
name|CountDownLatch
argument_list|(
literal|3
argument_list|)
decl_stmt|;
specifier|final
name|CountDownLatch
name|doneLatch
init|=
operator|new
name|CountDownLatch
argument_list|(
literal|1
argument_list|)
decl_stmt|;
comment|// create a task intended to block while processing, thus causing
comment|// the queue to backup.  simulates how a full BR is processed.
name|FutureTask
argument_list|<
name|?
argument_list|>
name|blockingOp
init|=
operator|new
name|FutureTask
argument_list|<
name|Void
argument_list|>
argument_list|(
operator|new
name|Callable
argument_list|<
name|Void
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Void
name|call
parameter_list|()
throws|throws
name|IOException
block|{
name|bm
operator|.
name|runBlockOp
argument_list|(
operator|new
name|Callable
argument_list|<
name|Void
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Void
name|call
parameter_list|()
throws|throws
name|InterruptedException
throws|,
name|BrokenBarrierException
block|{
comment|// use a barrier to control the blocking.
name|startBarrier
operator|.
name|await
argument_list|()
expr_stmt|;
name|endLatch
operator|.
name|countDown
argument_list|()
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
argument_list|)
expr_stmt|;
comment|// signal that runBlockOp returned
name|doneLatch
operator|.
name|countDown
argument_list|()
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
argument_list|)
decl_stmt|;
comment|// create an async task.  simulates how an IBR is processed.
name|Callable
argument_list|<
name|?
argument_list|>
name|asyncOp
init|=
operator|new
name|Callable
argument_list|<
name|Void
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Void
name|call
parameter_list|()
throws|throws
name|IOException
block|{
name|bm
operator|.
name|enqueueBlockOp
argument_list|(
operator|new
name|Runnable
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
comment|// use the latch to signal if the op has run.
name|endLatch
operator|.
name|countDown
argument_list|()
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
decl_stmt|;
comment|// calling get forces its execution so we can test if it's blocked.
name|Future
argument_list|<
name|?
argument_list|>
name|blockedFuture
init|=
name|executor
operator|.
name|submit
argument_list|(
name|blockingOp
argument_list|)
decl_stmt|;
name|boolean
name|isBlocked
init|=
literal|false
decl_stmt|;
try|try
block|{
comment|// wait 1s for the future to block.  it should run instantaneously.
name|blockedFuture
operator|.
name|get
argument_list|(
literal|1
argument_list|,
name|TimeUnit
operator|.
name|SECONDS
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|TimeoutException
name|te
parameter_list|)
block|{
name|isBlocked
operator|=
literal|true
expr_stmt|;
block|}
name|assertTrue
argument_list|(
name|isBlocked
argument_list|)
expr_stmt|;
comment|// should effectively return immediately since calls are queued.
comment|// however they should be backed up in the queue behind the blocking
comment|// operation.
name|executor
operator|.
name|submit
argument_list|(
name|asyncOp
argument_list|)
operator|.
name|get
argument_list|(
literal|1
argument_list|,
name|TimeUnit
operator|.
name|SECONDS
argument_list|)
expr_stmt|;
name|executor
operator|.
name|submit
argument_list|(
name|asyncOp
argument_list|)
operator|.
name|get
argument_list|(
literal|1
argument_list|,
name|TimeUnit
operator|.
name|SECONDS
argument_list|)
expr_stmt|;
comment|// check the async calls are queued, and first is still blocked.
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|bm
operator|.
name|getBlockOpQueueLength
argument_list|()
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|blockedFuture
operator|.
name|isDone
argument_list|()
argument_list|)
expr_stmt|;
comment|// unblock the queue, wait for last op to complete, check the blocked
comment|// call has returned
name|startBarrier
operator|.
name|await
argument_list|(
literal|1
argument_list|,
name|TimeUnit
operator|.
name|SECONDS
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|endLatch
operator|.
name|await
argument_list|(
literal|1
argument_list|,
name|TimeUnit
operator|.
name|SECONDS
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|bm
operator|.
name|getBlockOpQueueLength
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|doneLatch
operator|.
name|await
argument_list|(
literal|1
argument_list|,
name|TimeUnit
operator|.
name|SECONDS
argument_list|)
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|cluster
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
block|}
comment|// spam the block manager with IBRs to verify queuing is occurring.
annotation|@
name|Test
DECL|method|testAsyncIBR ()
specifier|public
name|void
name|testAsyncIBR
parameter_list|()
throws|throws
name|Exception
block|{
name|Logger
operator|.
name|getRootLogger
argument_list|()
operator|.
name|setLevel
argument_list|(
name|Level
operator|.
name|WARN
argument_list|)
expr_stmt|;
comment|// will create files with many small blocks.
specifier|final
name|int
name|blkSize
init|=
literal|4
operator|*
literal|1024
decl_stmt|;
specifier|final
name|int
name|fileSize
init|=
name|blkSize
operator|*
literal|100
decl_stmt|;
specifier|final
name|byte
index|[]
name|buf
init|=
operator|new
name|byte
index|[
literal|2
operator|*
name|blkSize
index|]
decl_stmt|;
specifier|final
name|int
name|numWriters
init|=
literal|4
decl_stmt|;
specifier|final
name|int
name|repl
init|=
literal|3
decl_stmt|;
specifier|final
name|CyclicBarrier
name|barrier
init|=
operator|new
name|CyclicBarrier
argument_list|(
name|numWriters
argument_list|)
decl_stmt|;
specifier|final
name|CountDownLatch
name|writeLatch
init|=
operator|new
name|CountDownLatch
argument_list|(
name|numWriters
argument_list|)
decl_stmt|;
specifier|final
name|AtomicBoolean
name|failure
init|=
operator|new
name|AtomicBoolean
argument_list|()
decl_stmt|;
specifier|final
name|Configuration
name|conf
init|=
operator|new
name|HdfsConfiguration
argument_list|()
decl_stmt|;
name|conf
operator|.
name|getLong
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_MIN_BLOCK_SIZE_KEY
argument_list|,
name|blkSize
argument_list|)
expr_stmt|;
specifier|final
name|MiniDFSCluster
name|cluster
init|=
operator|new
name|MiniDFSCluster
operator|.
name|Builder
argument_list|(
name|conf
argument_list|)
operator|.
name|numDataNodes
argument_list|(
literal|8
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
try|try
block|{
name|cluster
operator|.
name|waitActive
argument_list|()
expr_stmt|;
comment|// create multiple writer threads to create a file with many blocks.
comment|// will test that concurrent writing causes IBR batching in the NN
name|Thread
index|[]
name|writers
init|=
operator|new
name|Thread
index|[
name|numWriters
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|writers
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|Path
name|p
init|=
operator|new
name|Path
argument_list|(
literal|"/writer"
operator|+
name|i
argument_list|)
decl_stmt|;
name|writers
index|[
name|i
index|]
operator|=
operator|new
name|Thread
argument_list|(
operator|new
name|Runnable
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
try|try
block|{
name|FileSystem
name|fs
init|=
name|cluster
operator|.
name|getFileSystem
argument_list|()
decl_stmt|;
name|FSDataOutputStream
name|os
init|=
name|fs
operator|.
name|create
argument_list|(
name|p
argument_list|,
literal|true
argument_list|,
name|buf
operator|.
name|length
argument_list|,
operator|(
name|short
operator|)
name|repl
argument_list|,
name|blkSize
argument_list|)
decl_stmt|;
comment|// align writers for maximum chance of IBR batching.
name|barrier
operator|.
name|await
argument_list|()
expr_stmt|;
name|int
name|remaining
init|=
name|fileSize
decl_stmt|;
while|while
condition|(
name|remaining
operator|>
literal|0
condition|)
block|{
name|os
operator|.
name|write
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|remaining
operator|-=
name|buf
operator|.
name|length
expr_stmt|;
block|}
name|os
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|e
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
name|failure
operator|.
name|set
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
comment|// let main thread know we are done.
name|writeLatch
operator|.
name|countDown
argument_list|()
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
name|writers
index|[
name|i
index|]
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
comment|// when and how many IBRs are queued is indeterminate, so just watch
comment|// the metrics and verify something was queued at during execution.
name|boolean
name|sawQueued
init|=
literal|false
decl_stmt|;
while|while
condition|(
operator|!
name|writeLatch
operator|.
name|await
argument_list|(
literal|10
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
condition|)
block|{
name|assertFalse
argument_list|(
name|failure
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
name|MetricsRecordBuilder
name|rb
init|=
name|getMetrics
argument_list|(
literal|"NameNodeActivity"
argument_list|)
decl_stmt|;
name|long
name|queued
init|=
name|MetricsAsserts
operator|.
name|getIntGauge
argument_list|(
literal|"BlockOpsQueued"
argument_list|,
name|rb
argument_list|)
decl_stmt|;
name|sawQueued
operator||=
operator|(
name|queued
operator|>
literal|0
operator|)
expr_stmt|;
block|}
name|assertFalse
argument_list|(
name|failure
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|sawQueued
argument_list|)
expr_stmt|;
comment|// verify that batching of the IBRs occurred.
name|MetricsRecordBuilder
name|rb
init|=
name|getMetrics
argument_list|(
literal|"NameNodeActivity"
argument_list|)
decl_stmt|;
name|long
name|batched
init|=
name|MetricsAsserts
operator|.
name|getLongCounter
argument_list|(
literal|"BlockOpsBatched"
argument_list|,
name|rb
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|batched
operator|>
literal|0
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|cluster
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Test
argument_list|(
name|timeout
operator|=
literal|60000
argument_list|)
DECL|method|testBlockManagerMachinesArray ()
specifier|public
name|void
name|testBlockManagerMachinesArray
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|Configuration
name|conf
init|=
operator|new
name|HdfsConfiguration
argument_list|()
decl_stmt|;
specifier|final
name|MiniDFSCluster
name|cluster
init|=
operator|new
name|MiniDFSCluster
operator|.
name|Builder
argument_list|(
name|conf
argument_list|)
operator|.
name|numDataNodes
argument_list|(
literal|4
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|cluster
operator|.
name|waitActive
argument_list|()
expr_stmt|;
name|BlockManager
name|blockManager
init|=
name|cluster
operator|.
name|getNamesystem
argument_list|()
operator|.
name|getBlockManager
argument_list|()
decl_stmt|;
name|FileSystem
name|fs
init|=
name|cluster
operator|.
name|getFileSystem
argument_list|()
decl_stmt|;
specifier|final
name|Path
name|filePath
init|=
operator|new
name|Path
argument_list|(
literal|"/tmp.txt"
argument_list|)
decl_stmt|;
specifier|final
name|long
name|fileLen
init|=
literal|1L
decl_stmt|;
name|DFSTestUtil
operator|.
name|createFile
argument_list|(
name|fs
argument_list|,
name|filePath
argument_list|,
name|fileLen
argument_list|,
operator|(
name|short
operator|)
literal|3
argument_list|,
literal|1L
argument_list|)
expr_stmt|;
name|DFSTestUtil
operator|.
name|waitForReplication
argument_list|(
operator|(
name|DistributedFileSystem
operator|)
name|fs
argument_list|,
name|filePath
argument_list|,
operator|(
name|short
operator|)
literal|3
argument_list|,
literal|60000
argument_list|)
expr_stmt|;
name|ArrayList
argument_list|<
name|DataNode
argument_list|>
name|datanodes
init|=
name|cluster
operator|.
name|getDataNodes
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
name|datanodes
operator|.
name|size
argument_list|()
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|FSNamesystem
name|ns
init|=
name|cluster
operator|.
name|getNamesystem
argument_list|()
decl_stmt|;
comment|// get the block
specifier|final
name|String
name|bpid
init|=
name|cluster
operator|.
name|getNamesystem
argument_list|()
operator|.
name|getBlockPoolId
argument_list|()
decl_stmt|;
name|File
name|storageDir
init|=
name|cluster
operator|.
name|getInstanceStorageDir
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|File
name|dataDir
init|=
name|MiniDFSCluster
operator|.
name|getFinalizedDir
argument_list|(
name|storageDir
argument_list|,
name|bpid
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
literal|"Data directory does not exist"
argument_list|,
name|dataDir
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
name|BlockInfo
name|blockInfo
init|=
name|blockManager
operator|.
name|blocksMap
operator|.
name|getBlocks
argument_list|()
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
decl_stmt|;
name|ExtendedBlock
name|blk
init|=
operator|new
name|ExtendedBlock
argument_list|(
name|bpid
argument_list|,
name|blockInfo
operator|.
name|getBlockId
argument_list|()
argument_list|,
name|blockInfo
operator|.
name|getNumBytes
argument_list|()
argument_list|,
name|blockInfo
operator|.
name|getGenerationStamp
argument_list|()
argument_list|)
decl_stmt|;
name|DatanodeDescriptor
name|failedStorageDataNode
init|=
name|blockManager
operator|.
name|getStoredBlock
argument_list|(
name|blockInfo
argument_list|)
operator|.
name|getDatanode
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|DatanodeDescriptor
name|corruptStorageDataNode
init|=
name|blockManager
operator|.
name|getStoredBlock
argument_list|(
name|blockInfo
argument_list|)
operator|.
name|getDatanode
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|ArrayList
argument_list|<
name|StorageReport
argument_list|>
name|reports
init|=
operator|new
name|ArrayList
argument_list|<
name|StorageReport
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|failedStorageDataNode
operator|.
name|getStorageInfos
argument_list|()
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|DatanodeStorageInfo
name|storageInfo
init|=
name|failedStorageDataNode
operator|.
name|getStorageInfos
argument_list|()
index|[
name|i
index|]
decl_stmt|;
name|DatanodeStorage
name|dns
init|=
operator|new
name|DatanodeStorage
argument_list|(
name|failedStorageDataNode
operator|.
name|getStorageInfos
argument_list|()
index|[
name|i
index|]
operator|.
name|getStorageID
argument_list|()
argument_list|,
name|DatanodeStorage
operator|.
name|State
operator|.
name|FAILED
argument_list|,
name|failedStorageDataNode
operator|.
name|getStorageInfos
argument_list|()
index|[
name|i
index|]
operator|.
name|getStorageType
argument_list|()
argument_list|)
decl_stmt|;
while|while
condition|(
name|storageInfo
operator|.
name|getBlockIterator
argument_list|()
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|BlockInfo
name|blockInfo1
init|=
name|storageInfo
operator|.
name|getBlockIterator
argument_list|()
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|blockInfo1
operator|.
name|equals
argument_list|(
name|blockInfo
argument_list|)
condition|)
block|{
name|StorageReport
name|report
init|=
operator|new
name|StorageReport
argument_list|(
name|dns
argument_list|,
literal|true
argument_list|,
name|storageInfo
operator|.
name|getCapacity
argument_list|()
argument_list|,
name|storageInfo
operator|.
name|getDfsUsed
argument_list|()
argument_list|,
name|storageInfo
operator|.
name|getRemaining
argument_list|()
argument_list|,
name|storageInfo
operator|.
name|getBlockPoolUsed
argument_list|()
argument_list|,
literal|0L
argument_list|)
decl_stmt|;
name|reports
operator|.
name|add
argument_list|(
name|report
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
name|failedStorageDataNode
operator|.
name|updateHeartbeat
argument_list|(
name|reports
operator|.
name|toArray
argument_list|(
name|StorageReport
operator|.
name|EMPTY_ARRAY
argument_list|)
argument_list|,
literal|0L
argument_list|,
literal|0L
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|ns
operator|.
name|writeLock
argument_list|()
expr_stmt|;
name|DatanodeStorageInfo
name|corruptStorageInfo
init|=
literal|null
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|corruptStorageDataNode
operator|.
name|getStorageInfos
argument_list|()
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|corruptStorageInfo
operator|=
name|corruptStorageDataNode
operator|.
name|getStorageInfos
argument_list|()
index|[
name|i
index|]
expr_stmt|;
while|while
condition|(
name|corruptStorageInfo
operator|.
name|getBlockIterator
argument_list|()
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|BlockInfo
name|blockInfo1
init|=
name|corruptStorageInfo
operator|.
name|getBlockIterator
argument_list|()
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|blockInfo1
operator|.
name|equals
argument_list|(
name|blockInfo
argument_list|)
condition|)
block|{
break|break;
block|}
block|}
block|}
name|blockManager
operator|.
name|findAndMarkBlockAsCorrupt
argument_list|(
name|blk
argument_list|,
name|corruptStorageDataNode
argument_list|,
name|corruptStorageInfo
operator|.
name|getStorageID
argument_list|()
argument_list|,
name|CorruptReplicasMap
operator|.
name|Reason
operator|.
name|ANY
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|ns
operator|.
name|writeUnlock
argument_list|()
expr_stmt|;
name|BlockInfo
index|[]
name|blockInfos
init|=
operator|new
name|BlockInfo
index|[]
block|{
name|blockInfo
block|}
decl_stmt|;
name|ns
operator|.
name|readLock
argument_list|()
expr_stmt|;
name|LocatedBlocks
name|locatedBlocks
init|=
name|blockManager
operator|.
name|createLocatedBlocks
argument_list|(
name|blockInfos
argument_list|,
literal|3L
argument_list|,
literal|false
argument_list|,
literal|0L
argument_list|,
literal|3L
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
literal|"Located Blocks should exclude corrupt"
operator|+
literal|"replicas and failed storages"
argument_list|,
name|locatedBlocks
operator|.
name|getLocatedBlocks
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|1
argument_list|)
expr_stmt|;
name|ns
operator|.
name|readUnlock
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testMetaSaveCorruptBlocks ()
specifier|public
name|void
name|testMetaSaveCorruptBlocks
parameter_list|()
throws|throws
name|Exception
block|{
name|List
argument_list|<
name|DatanodeStorageInfo
argument_list|>
name|origStorages
init|=
name|getStorages
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|origNodes
init|=
name|getNodes
argument_list|(
name|origStorages
argument_list|)
decl_stmt|;
name|addCorruptBlockOnNodes
argument_list|(
literal|0
argument_list|,
name|origNodes
argument_list|)
expr_stmt|;
name|File
name|file
init|=
operator|new
name|File
argument_list|(
literal|"test.log"
argument_list|)
decl_stmt|;
name|PrintWriter
name|out
init|=
operator|new
name|PrintWriter
argument_list|(
name|file
argument_list|)
decl_stmt|;
name|bm
operator|.
name|metaSave
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|out
operator|.
name|flush
argument_list|()
expr_stmt|;
name|FileInputStream
name|fstream
init|=
operator|new
name|FileInputStream
argument_list|(
name|file
argument_list|)
decl_stmt|;
name|DataInputStream
name|in
init|=
operator|new
name|DataInputStream
argument_list|(
name|fstream
argument_list|)
decl_stmt|;
name|BufferedReader
name|reader
init|=
operator|new
name|BufferedReader
argument_list|(
operator|new
name|InputStreamReader
argument_list|(
name|in
argument_list|)
argument_list|)
decl_stmt|;
name|String
name|corruptBlocksLine
decl_stmt|;
name|Boolean
name|foundIt
init|=
literal|false
decl_stmt|;
try|try
block|{
while|while
condition|(
operator|(
name|corruptBlocksLine
operator|=
name|reader
operator|.
name|readLine
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|corruptBlocksLine
operator|.
name|compareTo
argument_list|(
literal|"Corrupt Blocks:"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|foundIt
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
name|assertTrue
argument_list|(
literal|"Unexpected text in metasave,"
operator|+
literal|"was expecting corrupt blocks section!"
argument_list|,
name|foundIt
argument_list|)
expr_stmt|;
name|corruptBlocksLine
operator|=
name|reader
operator|.
name|readLine
argument_list|()
expr_stmt|;
name|String
name|regex
init|=
literal|"Block=[0-9]+\\tNode=.*\\tStorageID=.*StorageState.*"
operator|+
literal|"TotalReplicas=.*Reason=GENSTAMP_MISMATCH"
decl_stmt|;
name|assertTrue
argument_list|(
literal|"Unexpected corrupt block section in metasave!"
argument_list|,
name|corruptBlocksLine
operator|.
name|matches
argument_list|(
name|regex
argument_list|)
argument_list|)
expr_stmt|;
name|corruptBlocksLine
operator|=
name|reader
operator|.
name|readLine
argument_list|()
expr_stmt|;
name|regex
operator|=
literal|"Metasave: Number of datanodes.*"
expr_stmt|;
name|assertTrue
argument_list|(
literal|"Unexpected corrupt block section in metasave!"
argument_list|,
name|corruptBlocksLine
operator|.
name|matches
argument_list|(
name|regex
argument_list|)
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|reader
operator|!=
literal|null
condition|)
name|reader
operator|.
name|close
argument_list|()
expr_stmt|;
name|file
operator|.
name|delete
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Test
DECL|method|testIsReplicaCorruptCall ()
specifier|public
name|void
name|testIsReplicaCorruptCall
parameter_list|()
throws|throws
name|Exception
block|{
name|BlockManager
name|spyBM
init|=
name|spy
argument_list|(
name|bm
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|DatanodeStorageInfo
argument_list|>
name|origStorages
init|=
name|getStorages
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|,
literal|3
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|origNodes
init|=
name|getNodes
argument_list|(
name|origStorages
argument_list|)
decl_stmt|;
name|BlockInfo
name|blockInfo
init|=
name|addBlockOnNodes
argument_list|(
literal|0
argument_list|,
name|origNodes
argument_list|)
decl_stmt|;
name|spyBM
operator|.
name|createLocatedBlocks
argument_list|(
operator|new
name|BlockInfo
index|[]
block|{
name|blockInfo
block|}
argument_list|,
literal|3L
argument_list|,
literal|false
argument_list|,
literal|0L
argument_list|,
literal|3L
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|verify
argument_list|(
name|spyBM
argument_list|,
name|Mockito
operator|.
name|atLeast
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|.
name|isReplicaCorrupt
argument_list|(
name|Mockito
operator|.
name|any
argument_list|(
name|BlockInfo
operator|.
name|class
argument_list|)
argument_list|,
name|Mockito
operator|.
name|any
argument_list|(
name|DatanodeDescriptor
operator|.
name|class
argument_list|)
argument_list|)
expr_stmt|;
name|addCorruptBlockOnNodes
argument_list|(
literal|0
argument_list|,
name|origNodes
argument_list|)
expr_stmt|;
name|spyBM
operator|.
name|createLocatedBlocks
argument_list|(
operator|new
name|BlockInfo
index|[]
block|{
name|blockInfo
block|}
argument_list|,
literal|3L
argument_list|,
literal|false
argument_list|,
literal|0L
argument_list|,
literal|3L
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|verify
argument_list|(
name|spyBM
argument_list|,
name|Mockito
operator|.
name|atLeast
argument_list|(
literal|1
argument_list|)
argument_list|)
operator|.
name|isReplicaCorrupt
argument_list|(
name|Mockito
operator|.
name|any
argument_list|(
name|BlockInfo
operator|.
name|class
argument_list|)
argument_list|,
name|Mockito
operator|.
name|any
argument_list|(
name|DatanodeDescriptor
operator|.
name|class
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
argument_list|(
name|timeout
operator|=
literal|300000
argument_list|)
DECL|method|testPlacementPolicySatisfied ()
specifier|public
name|void
name|testPlacementPolicySatisfied
parameter_list|()
throws|throws
name|Exception
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Starting testPlacementPolicySatisfied."
argument_list|)
expr_stmt|;
specifier|final
name|String
index|[]
name|initialRacks
init|=
operator|new
name|String
index|[]
block|{
literal|"/rack0"
block|,
literal|"/rack1"
block|,
literal|"/rack2"
block|,
literal|"/rack3"
block|,
literal|"/rack4"
block|,
literal|"/rack5"
block|}
decl_stmt|;
specifier|final
name|String
index|[]
name|initialHosts
init|=
operator|new
name|String
index|[]
block|{
literal|"host0"
block|,
literal|"host1"
block|,
literal|"host2"
block|,
literal|"host3"
block|,
literal|"host4"
block|,
literal|"host5"
block|}
decl_stmt|;
specifier|final
name|int
name|numDataBlocks
init|=
name|StripedFileTestUtil
operator|.
name|getDefaultECPolicy
argument_list|()
operator|.
name|getNumDataUnits
argument_list|()
decl_stmt|;
specifier|final
name|int
name|numParityBlocks
init|=
name|StripedFileTestUtil
operator|.
name|getDefaultECPolicy
argument_list|()
operator|.
name|getNumParityUnits
argument_list|()
decl_stmt|;
specifier|final
name|long
name|blockSize
init|=
literal|6
operator|*
literal|1024
operator|*
literal|1024
decl_stmt|;
name|Configuration
name|conf
init|=
operator|new
name|Configuration
argument_list|()
decl_stmt|;
name|conf
operator|.
name|setLong
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_BLOCK_SIZE_KEY
argument_list|,
name|blockSize
argument_list|)
expr_stmt|;
name|conf
operator|.
name|setLong
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_REDUNDANCY_INTERVAL_SECONDS_KEY
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|MiniDFSCluster
name|cluster
init|=
literal|null
decl_stmt|;
try|try
block|{
name|cluster
operator|=
operator|new
name|MiniDFSCluster
operator|.
name|Builder
argument_list|(
name|conf
argument_list|)
operator|.
name|racks
argument_list|(
name|initialRacks
argument_list|)
operator|.
name|hosts
argument_list|(
name|initialHosts
argument_list|)
operator|.
name|numDataNodes
argument_list|(
name|initialRacks
operator|.
name|length
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
name|cluster
operator|.
name|waitActive
argument_list|()
expr_stmt|;
specifier|final
name|DistributedFileSystem
name|dfs
init|=
name|cluster
operator|.
name|getFileSystem
argument_list|()
decl_stmt|;
specifier|final
name|Path
name|ecDir
init|=
operator|new
name|Path
argument_list|(
literal|"/ec"
argument_list|)
decl_stmt|;
specifier|final
name|Path
name|testFileUnsatisfied
init|=
operator|new
name|Path
argument_list|(
name|ecDir
argument_list|,
literal|"test1"
argument_list|)
decl_stmt|;
specifier|final
name|Path
name|testFileSatisfied
init|=
operator|new
name|Path
argument_list|(
name|ecDir
argument_list|,
literal|"test2"
argument_list|)
decl_stmt|;
name|dfs
operator|.
name|enableErasureCodingPolicy
argument_list|(
name|StripedFileTestUtil
operator|.
name|getDefaultECPolicy
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|cluster
operator|.
name|getFileSystem
argument_list|()
operator|.
name|getClient
argument_list|()
operator|.
name|mkdirs
argument_list|(
name|ecDir
operator|.
name|toString
argument_list|()
argument_list|,
literal|null
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|cluster
operator|.
name|getFileSystem
argument_list|()
operator|.
name|getClient
argument_list|()
operator|.
name|setErasureCodingPolicy
argument_list|(
name|ecDir
operator|.
name|toString
argument_list|()
argument_list|,
name|StripedFileTestUtil
operator|.
name|getDefaultECPolicy
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|long
name|fileLen
init|=
name|blockSize
operator|*
name|numDataBlocks
decl_stmt|;
comment|// Create a file to be stored in 6 racks.
name|DFSTestUtil
operator|.
name|createFile
argument_list|(
name|dfs
argument_list|,
name|testFileUnsatisfied
argument_list|,
name|fileLen
argument_list|,
operator|(
name|short
operator|)
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|// Block placement policy should be satisfied as rack count
comment|// is less than numDataBlocks + numParityBlocks.
name|verifyPlacementPolicy
argument_list|(
name|cluster
argument_list|,
name|testFileUnsatisfied
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Adding 3 new hosts in the existing racks."
argument_list|)
expr_stmt|;
name|cluster
operator|.
name|startDataNodes
argument_list|(
name|conf
argument_list|,
literal|3
argument_list|,
literal|true
argument_list|,
literal|null
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"/rack3"
block|,
literal|"/rack4"
block|,
literal|"/rack5"
block|}
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"host3-2"
block|,
literal|"host4-2"
block|,
literal|"host5-2"
block|}
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|cluster
operator|.
name|triggerHeartbeats
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Waiting for EC reconstruction to complete."
argument_list|)
expr_stmt|;
name|DFSTestUtil
operator|.
name|waitForReplication
argument_list|(
name|dfs
argument_list|,
name|testFileUnsatisfied
argument_list|,
call|(
name|short
call|)
argument_list|(
name|numDataBlocks
operator|+
name|numParityBlocks
argument_list|)
argument_list|,
literal|30
operator|*
literal|1000
argument_list|)
expr_stmt|;
comment|// Block placement policy should still be satisfied
comment|// as there are only 6 racks.
name|verifyPlacementPolicy
argument_list|(
name|cluster
argument_list|,
name|testFileUnsatisfied
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Adding 3 new hosts in 3 new racks."
argument_list|)
expr_stmt|;
name|cluster
operator|.
name|startDataNodes
argument_list|(
name|conf
argument_list|,
literal|3
argument_list|,
literal|true
argument_list|,
literal|null
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"/rack6"
block|,
literal|"/rack7"
block|,
literal|"/rack8"
block|}
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"host6"
block|,
literal|"host7"
block|,
literal|"host8"
block|}
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|cluster
operator|.
name|triggerHeartbeats
argument_list|()
expr_stmt|;
comment|// Addition of new racks can make the existing EC files block
comment|// placements unsatisfied and there is NO automatic block
comment|// reconstruction for this yet.
comment|// TODO:
comment|//  Verify for block placement satisfied once the automatic
comment|//  block reconstruction is implemented.
name|verifyPlacementPolicy
argument_list|(
name|cluster
argument_list|,
name|testFileUnsatisfied
argument_list|,
literal|false
argument_list|)
expr_stmt|;
comment|// Create a new file
name|DFSTestUtil
operator|.
name|createFile
argument_list|(
name|dfs
argument_list|,
name|testFileSatisfied
argument_list|,
name|fileLen
argument_list|,
operator|(
name|short
operator|)
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|// The new file should be rightly placed on all 9 racks
comment|// and the block placement policy should be satisfied.
name|verifyPlacementPolicy
argument_list|(
name|cluster
argument_list|,
name|testFileUnsatisfied
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|cluster
operator|!=
literal|null
condition|)
block|{
name|cluster
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
block|}
block|}
DECL|method|verifyPlacementPolicy (final MiniDFSCluster cluster, final Path file, boolean isBlockPlacementSatisfied)
specifier|private
name|void
name|verifyPlacementPolicy
parameter_list|(
specifier|final
name|MiniDFSCluster
name|cluster
parameter_list|,
specifier|final
name|Path
name|file
parameter_list|,
name|boolean
name|isBlockPlacementSatisfied
parameter_list|)
throws|throws
name|IOException
block|{
name|DistributedFileSystem
name|dfs
init|=
name|cluster
operator|.
name|getFileSystem
argument_list|()
decl_stmt|;
name|BlockManager
name|blockManager
init|=
name|cluster
operator|.
name|getNamesystem
argument_list|()
operator|.
name|getBlockManager
argument_list|()
decl_stmt|;
name|LocatedBlock
name|lb
init|=
name|DFSTestUtil
operator|.
name|getAllBlocks
argument_list|(
name|dfs
argument_list|,
name|file
argument_list|)
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|BlockInfo
name|blockInfo
init|=
name|blockManager
operator|.
name|getStoredBlock
argument_list|(
name|lb
operator|.
name|getBlock
argument_list|()
operator|.
name|getLocalBlock
argument_list|()
argument_list|)
decl_stmt|;
name|Iterator
argument_list|<
name|DatanodeStorageInfo
argument_list|>
name|itr
init|=
name|blockInfo
operator|.
name|getStorageInfos
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Block "
operator|+
name|blockInfo
operator|+
literal|" storages: "
argument_list|)
expr_stmt|;
while|while
condition|(
name|itr
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|DatanodeStorageInfo
name|dn
init|=
name|itr
operator|.
name|next
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|" Rack: "
operator|+
name|dn
operator|.
name|getDatanodeDescriptor
argument_list|()
operator|.
name|getNetworkLocation
argument_list|()
operator|+
literal|", DataNode: "
operator|+
name|dn
operator|.
name|getDatanodeDescriptor
argument_list|()
operator|.
name|getXferAddr
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isBlockPlacementSatisfied
condition|)
block|{
name|assertTrue
argument_list|(
literal|"Block group of "
operator|+
name|file
operator|+
literal|"should be placement"
operator|+
literal|" policy satisfied, currently!"
argument_list|,
name|blockManager
operator|.
name|isPlacementPolicySatisfied
argument_list|(
name|blockInfo
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|assertFalse
argument_list|(
literal|"Block group of "
operator|+
name|file
operator|+
literal|" should be placement"
operator|+
literal|" policy unsatisfied, currently!"
argument_list|,
name|blockManager
operator|.
name|isPlacementPolicySatisfied
argument_list|(
name|blockInfo
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Test
DECL|method|testMetaSaveMissingReplicas ()
specifier|public
name|void
name|testMetaSaveMissingReplicas
parameter_list|()
throws|throws
name|Exception
block|{
name|List
argument_list|<
name|DatanodeStorageInfo
argument_list|>
name|origStorages
init|=
name|getStorages
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|origNodes
init|=
name|getNodes
argument_list|(
name|origStorages
argument_list|)
decl_stmt|;
name|BlockInfo
name|block
init|=
name|makeBlockReplicasMissing
argument_list|(
literal|0
argument_list|,
name|origNodes
argument_list|)
decl_stmt|;
name|File
name|file
init|=
operator|new
name|File
argument_list|(
literal|"test.log"
argument_list|)
decl_stmt|;
name|PrintWriter
name|out
init|=
operator|new
name|PrintWriter
argument_list|(
name|file
argument_list|)
decl_stmt|;
name|bm
operator|.
name|metaSave
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|out
operator|.
name|flush
argument_list|()
expr_stmt|;
name|FileInputStream
name|fstream
init|=
operator|new
name|FileInputStream
argument_list|(
name|file
argument_list|)
decl_stmt|;
name|DataInputStream
name|in
init|=
operator|new
name|DataInputStream
argument_list|(
name|fstream
argument_list|)
decl_stmt|;
name|BufferedReader
name|reader
init|=
operator|new
name|BufferedReader
argument_list|(
operator|new
name|InputStreamReader
argument_list|(
name|in
argument_list|)
argument_list|)
decl_stmt|;
name|StringBuffer
name|buffer
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
name|String
name|line
decl_stmt|;
try|try
block|{
while|while
condition|(
operator|(
name|line
operator|=
name|reader
operator|.
name|readLine
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
name|buffer
operator|.
name|append
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
name|String
name|output
init|=
name|buffer
operator|.
name|toString
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
literal|"Metasave output should have reported missing blocks."
argument_list|,
name|output
operator|.
name|contains
argument_list|(
literal|"Metasave: Blocks currently missing: 1"
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"There should be 0 blocks waiting for reconstruction"
argument_list|,
name|output
operator|.
name|contains
argument_list|(
literal|"Metasave: Blocks waiting for reconstruction: 0"
argument_list|)
argument_list|)
expr_stmt|;
name|String
name|blockNameGS
init|=
name|block
operator|.
name|getBlockName
argument_list|()
operator|+
literal|"_"
operator|+
name|block
operator|.
name|getGenerationStamp
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
literal|"Block "
operator|+
name|blockNameGS
operator|+
literal|" should be MISSING."
argument_list|,
name|output
operator|.
name|contains
argument_list|(
name|blockNameGS
operator|+
literal|" MISSING"
argument_list|)
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|reader
operator|.
name|close
argument_list|()
expr_stmt|;
name|file
operator|.
name|delete
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|makeBlockReplicasMissing (long blockId, List<DatanodeDescriptor> nodesList)
specifier|private
name|BlockInfo
name|makeBlockReplicasMissing
parameter_list|(
name|long
name|blockId
parameter_list|,
name|List
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|nodesList
parameter_list|)
throws|throws
name|IOException
block|{
name|long
name|inodeId
init|=
operator|++
name|mockINodeId
decl_stmt|;
specifier|final
name|INodeFile
name|bc
init|=
name|TestINodeFile
operator|.
name|createINodeFile
argument_list|(
name|inodeId
argument_list|)
decl_stmt|;
name|BlockInfo
name|blockInfo
init|=
name|blockOnNodes
argument_list|(
name|blockId
argument_list|,
name|nodesList
argument_list|)
decl_stmt|;
name|blockInfo
operator|.
name|setReplication
argument_list|(
operator|(
name|short
operator|)
literal|3
argument_list|)
expr_stmt|;
name|blockInfo
operator|.
name|setBlockCollectionId
argument_list|(
name|inodeId
argument_list|)
expr_stmt|;
name|Mockito
operator|.
name|doReturn
argument_list|(
name|bc
argument_list|)
operator|.
name|when
argument_list|(
name|fsn
argument_list|)
operator|.
name|getBlockCollection
argument_list|(
name|inodeId
argument_list|)
expr_stmt|;
name|bm
operator|.
name|blocksMap
operator|.
name|addBlockCollection
argument_list|(
name|blockInfo
argument_list|,
name|bc
argument_list|)
expr_stmt|;
name|bm
operator|.
name|markBlockReplicasAsCorrupt
argument_list|(
name|blockInfo
argument_list|,
name|blockInfo
argument_list|,
name|blockInfo
operator|.
name|getGenerationStamp
argument_list|()
operator|+
literal|1
argument_list|,
name|blockInfo
operator|.
name|getNumBytes
argument_list|()
argument_list|,
operator|new
name|DatanodeStorageInfo
index|[]
block|{}
argument_list|)
expr_stmt|;
name|BlockCollection
name|mockedBc
init|=
name|Mockito
operator|.
name|mock
argument_list|(
name|BlockCollection
operator|.
name|class
argument_list|)
decl_stmt|;
name|Mockito
operator|.
name|when
argument_list|(
name|mockedBc
operator|.
name|getBlocks
argument_list|()
argument_list|)
operator|.
name|thenReturn
argument_list|(
operator|new
name|BlockInfo
index|[]
block|{
name|blockInfo
block|}
argument_list|)
expr_stmt|;
name|bm
operator|.
name|checkRedundancy
argument_list|(
name|mockedBc
argument_list|)
expr_stmt|;
return|return
name|blockInfo
return|;
block|}
block|}
end_class

end_unit

