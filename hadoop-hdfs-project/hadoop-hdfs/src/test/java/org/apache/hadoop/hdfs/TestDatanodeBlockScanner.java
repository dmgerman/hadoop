begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdfs
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertArrayEquals
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertEquals
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertFalse
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertTrue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|RandomAccessFile
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|InetSocketAddress
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URL
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Random
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeoutException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Matcher
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Pattern
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|impl
operator|.
name|Log4JLogger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|DatanodeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|ExtendedBlock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|HdfsConstants
operator|.
name|DatanodeReportType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|DataNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|DataNodeTestUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|ReplicaInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|FSNamesystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Time
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|log4j
operator|.
name|Level
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Test
import|;
end_import

begin_comment
comment|/**  * This test verifies that block verification occurs on the datanode  */
end_comment

begin_class
DECL|class|TestDatanodeBlockScanner
specifier|public
class|class
name|TestDatanodeBlockScanner
block|{
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|TestDatanodeBlockScanner
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|TIMEOUT
specifier|private
specifier|static
specifier|final
name|long
name|TIMEOUT
init|=
literal|20000
decl_stmt|;
comment|// 20 sec.
DECL|field|pattern
specifier|private
specifier|static
specifier|final
name|Pattern
name|pattern
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|".*?(blk_[-]*\\d+).*?scan time\\s*:\\s*(\\d+)"
argument_list|)
decl_stmt|;
DECL|field|pattern_blockVerify
specifier|private
specifier|static
specifier|final
name|Pattern
name|pattern_blockVerify
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|".*?(SCAN_PERIOD)\\s*:\\s*(\\d+.*?)"
argument_list|)
decl_stmt|;
static|static
block|{
operator|(
operator|(
name|Log4JLogger
operator|)
name|FSNamesystem
operator|.
name|auditLog
operator|)
operator|.
name|getLogger
argument_list|()
operator|.
name|setLevel
argument_list|(
name|Level
operator|.
name|WARN
argument_list|)
expr_stmt|;
block|}
comment|/**    * This connects to datanode and fetches block verification data.    * It repeats this until the given block has a verification time> newTime.    * @param newTime - validation timestamps before newTime are "old", the    *            result of previous validations.  This method waits until a "new"    *            validation timestamp is obtained.  If no validator runs soon    *            enough, the method will time out.    * @return - the new validation timestamp    * @throws IOException    * @throws TimeoutException    */
DECL|method|waitForVerification (int infoPort, FileSystem fs, Path file, int blocksValidated, long newTime, long timeout)
specifier|private
specifier|static
name|long
name|waitForVerification
parameter_list|(
name|int
name|infoPort
parameter_list|,
name|FileSystem
name|fs
parameter_list|,
name|Path
name|file
parameter_list|,
name|int
name|blocksValidated
parameter_list|,
name|long
name|newTime
parameter_list|,
name|long
name|timeout
parameter_list|)
throws|throws
name|IOException
throws|,
name|TimeoutException
block|{
name|URL
name|url
init|=
operator|new
name|URL
argument_list|(
literal|"http://localhost:"
operator|+
name|infoPort
operator|+
literal|"/blockScannerReport?listblocks"
argument_list|)
decl_stmt|;
name|long
name|lastWarnTime
init|=
name|Time
operator|.
name|monotonicNow
argument_list|()
decl_stmt|;
if|if
condition|(
name|newTime
operator|<=
literal|0
condition|)
name|newTime
operator|=
literal|1L
expr_stmt|;
name|long
name|verificationTime
init|=
literal|0
decl_stmt|;
name|String
name|block
init|=
name|DFSTestUtil
operator|.
name|getFirstBlock
argument_list|(
name|fs
argument_list|,
name|file
argument_list|)
operator|.
name|getBlockName
argument_list|()
decl_stmt|;
name|long
name|failtime
init|=
operator|(
name|timeout
operator|<=
literal|0
operator|)
condition|?
name|Long
operator|.
name|MAX_VALUE
else|:
name|Time
operator|.
name|monotonicNow
argument_list|()
operator|+
name|timeout
decl_stmt|;
while|while
condition|(
name|verificationTime
operator|<
name|newTime
condition|)
block|{
if|if
condition|(
name|failtime
operator|<
name|Time
operator|.
name|monotonicNow
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|TimeoutException
argument_list|(
literal|"failed to achieve block verification after "
operator|+
name|timeout
operator|+
literal|" msec.  Current verification timestamp = "
operator|+
name|verificationTime
operator|+
literal|", requested verification time> "
operator|+
name|newTime
argument_list|)
throw|;
block|}
name|String
name|response
init|=
name|DFSTestUtil
operator|.
name|urlGet
argument_list|(
name|url
argument_list|)
decl_stmt|;
if|if
condition|(
name|blocksValidated
operator|>=
literal|0
condition|)
block|{
for|for
control|(
name|Matcher
name|matcher
init|=
name|pattern_blockVerify
operator|.
name|matcher
argument_list|(
name|response
argument_list|)
init|;
name|matcher
operator|.
name|find
argument_list|()
condition|;
control|)
block|{
if|if
condition|(
name|block
operator|.
name|equals
argument_list|(
name|matcher
operator|.
name|group
argument_list|(
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|blocksValidated
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
for|for
control|(
name|Matcher
name|matcher
init|=
name|pattern
operator|.
name|matcher
argument_list|(
name|response
argument_list|)
init|;
name|matcher
operator|.
name|find
argument_list|()
condition|;
control|)
block|{
if|if
condition|(
name|block
operator|.
name|equals
argument_list|(
name|matcher
operator|.
name|group
argument_list|(
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|verificationTime
operator|=
name|Long
operator|.
name|parseLong
argument_list|(
name|matcher
operator|.
name|group
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|verificationTime
operator|<
name|newTime
condition|)
block|{
name|long
name|now
init|=
name|Time
operator|.
name|monotonicNow
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|now
operator|-
name|lastWarnTime
operator|)
operator|>=
literal|5
operator|*
literal|1000
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Waiting for verification of "
operator|+
name|block
argument_list|)
expr_stmt|;
name|lastWarnTime
operator|=
name|now
expr_stmt|;
block|}
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
literal|500
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ignored
parameter_list|)
block|{}
block|}
block|}
return|return
name|verificationTime
return|;
block|}
annotation|@
name|Test
DECL|method|testDatanodeBlockScanner ()
specifier|public
name|void
name|testDatanodeBlockScanner
parameter_list|()
throws|throws
name|IOException
throws|,
name|TimeoutException
block|{
name|long
name|startTime
init|=
name|Time
operator|.
name|monotonicNow
argument_list|()
decl_stmt|;
name|Configuration
name|conf
init|=
operator|new
name|HdfsConfiguration
argument_list|()
decl_stmt|;
name|MiniDFSCluster
name|cluster
init|=
operator|new
name|MiniDFSCluster
operator|.
name|Builder
argument_list|(
name|conf
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|cluster
operator|.
name|waitActive
argument_list|()
expr_stmt|;
name|FileSystem
name|fs
init|=
name|cluster
operator|.
name|getFileSystem
argument_list|()
decl_stmt|;
name|Path
name|file1
init|=
operator|new
name|Path
argument_list|(
literal|"/tmp/testBlockVerification/file1"
argument_list|)
decl_stmt|;
name|Path
name|file2
init|=
operator|new
name|Path
argument_list|(
literal|"/tmp/testBlockVerification/file2"
argument_list|)
decl_stmt|;
comment|/*      * Write the first file and restart the cluster.      */
name|DFSTestUtil
operator|.
name|createFile
argument_list|(
name|fs
argument_list|,
name|file1
argument_list|,
literal|10
argument_list|,
operator|(
name|short
operator|)
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cluster
operator|.
name|shutdown
argument_list|()
expr_stmt|;
name|cluster
operator|=
operator|new
name|MiniDFSCluster
operator|.
name|Builder
argument_list|(
name|conf
argument_list|)
operator|.
name|numDataNodes
argument_list|(
literal|1
argument_list|)
operator|.
name|format
argument_list|(
literal|false
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
name|cluster
operator|.
name|waitActive
argument_list|()
expr_stmt|;
name|DFSClient
name|dfsClient
init|=
operator|new
name|DFSClient
argument_list|(
operator|new
name|InetSocketAddress
argument_list|(
literal|"localhost"
argument_list|,
name|cluster
operator|.
name|getNameNodePort
argument_list|()
argument_list|)
argument_list|,
name|conf
argument_list|)
decl_stmt|;
name|fs
operator|=
name|cluster
operator|.
name|getFileSystem
argument_list|()
expr_stmt|;
name|DatanodeInfo
name|dn
init|=
name|dfsClient
operator|.
name|datanodeReport
argument_list|(
name|DatanodeReportType
operator|.
name|LIVE
argument_list|)
index|[
literal|0
index|]
decl_stmt|;
comment|/*      * The cluster restarted. The block should be verified by now.      */
name|assertTrue
argument_list|(
name|waitForVerification
argument_list|(
name|dn
operator|.
name|getInfoPort
argument_list|()
argument_list|,
name|fs
argument_list|,
name|file1
argument_list|,
literal|1
argument_list|,
name|startTime
argument_list|,
name|TIMEOUT
argument_list|)
operator|>=
name|startTime
argument_list|)
expr_stmt|;
comment|/*      * Create a new file and read the block. The block should be marked       * verified since the client reads the block and verifies checksum.       */
name|DFSTestUtil
operator|.
name|createFile
argument_list|(
name|fs
argument_list|,
name|file2
argument_list|,
literal|10
argument_list|,
operator|(
name|short
operator|)
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|IOUtils
operator|.
name|copyBytes
argument_list|(
name|fs
operator|.
name|open
argument_list|(
name|file2
argument_list|)
argument_list|,
operator|new
name|IOUtils
operator|.
name|NullOutputStream
argument_list|()
argument_list|,
name|conf
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|waitForVerification
argument_list|(
name|dn
operator|.
name|getInfoPort
argument_list|()
argument_list|,
name|fs
argument_list|,
name|file2
argument_list|,
literal|2
argument_list|,
name|startTime
argument_list|,
name|TIMEOUT
argument_list|)
operator|>=
name|startTime
argument_list|)
expr_stmt|;
name|cluster
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
DECL|method|corruptReplica (ExtendedBlock blk, int replica)
specifier|public
specifier|static
name|boolean
name|corruptReplica
parameter_list|(
name|ExtendedBlock
name|blk
parameter_list|,
name|int
name|replica
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|MiniDFSCluster
operator|.
name|corruptReplica
argument_list|(
name|replica
argument_list|,
name|blk
argument_list|)
return|;
block|}
annotation|@
name|Test
DECL|method|testBlockCorruptionPolicy ()
specifier|public
name|void
name|testBlockCorruptionPolicy
parameter_list|()
throws|throws
name|Exception
block|{
name|Configuration
name|conf
init|=
operator|new
name|HdfsConfiguration
argument_list|()
decl_stmt|;
name|conf
operator|.
name|setLong
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_BLOCKREPORT_INTERVAL_MSEC_KEY
argument_list|,
literal|1000L
argument_list|)
expr_stmt|;
name|Random
name|random
init|=
operator|new
name|Random
argument_list|()
decl_stmt|;
name|FileSystem
name|fs
init|=
literal|null
decl_stmt|;
name|int
name|rand
init|=
name|random
operator|.
name|nextInt
argument_list|(
literal|3
argument_list|)
decl_stmt|;
name|MiniDFSCluster
name|cluster
init|=
operator|new
name|MiniDFSCluster
operator|.
name|Builder
argument_list|(
name|conf
argument_list|)
operator|.
name|numDataNodes
argument_list|(
literal|3
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|cluster
operator|.
name|waitActive
argument_list|()
expr_stmt|;
name|fs
operator|=
name|cluster
operator|.
name|getFileSystem
argument_list|()
expr_stmt|;
name|Path
name|file1
init|=
operator|new
name|Path
argument_list|(
literal|"/tmp/testBlockVerification/file1"
argument_list|)
decl_stmt|;
name|DFSTestUtil
operator|.
name|createFile
argument_list|(
name|fs
argument_list|,
name|file1
argument_list|,
literal|1024
argument_list|,
operator|(
name|short
operator|)
literal|3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ExtendedBlock
name|block
init|=
name|DFSTestUtil
operator|.
name|getFirstBlock
argument_list|(
name|fs
argument_list|,
name|file1
argument_list|)
decl_stmt|;
name|DFSTestUtil
operator|.
name|waitReplication
argument_list|(
name|fs
argument_list|,
name|file1
argument_list|,
operator|(
name|short
operator|)
literal|3
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|DFSTestUtil
operator|.
name|allBlockReplicasCorrupt
argument_list|(
name|cluster
argument_list|,
name|file1
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|// Corrupt random replica of block
name|assertTrue
argument_list|(
name|MiniDFSCluster
operator|.
name|corruptReplica
argument_list|(
name|rand
argument_list|,
name|block
argument_list|)
argument_list|)
expr_stmt|;
comment|// Restart the datanode hoping the corrupt block to be reported
name|cluster
operator|.
name|restartDataNode
argument_list|(
name|rand
argument_list|)
expr_stmt|;
comment|// We have 2 good replicas and block is not corrupt
name|DFSTestUtil
operator|.
name|waitReplication
argument_list|(
name|fs
argument_list|,
name|file1
argument_list|,
operator|(
name|short
operator|)
literal|2
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|DFSTestUtil
operator|.
name|allBlockReplicasCorrupt
argument_list|(
name|cluster
argument_list|,
name|file1
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|// Corrupt all replicas. Now, block should be marked as corrupt
comment|// and we should get all the replicas
name|assertTrue
argument_list|(
name|MiniDFSCluster
operator|.
name|corruptReplica
argument_list|(
literal|0
argument_list|,
name|block
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|MiniDFSCluster
operator|.
name|corruptReplica
argument_list|(
literal|1
argument_list|,
name|block
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|MiniDFSCluster
operator|.
name|corruptReplica
argument_list|(
literal|2
argument_list|,
name|block
argument_list|)
argument_list|)
expr_stmt|;
comment|// Trigger each of the DNs to scan this block immediately.
comment|// The block pool scanner doesn't run frequently enough on its own
comment|// to notice these, and due to HDFS-1371, the client won't report
comment|// bad blocks to the NN when all replicas are bad.
for|for
control|(
name|DataNode
name|dn
range|:
name|cluster
operator|.
name|getDataNodes
argument_list|()
control|)
block|{
name|DataNodeTestUtils
operator|.
name|runBlockScannerForBlock
argument_list|(
name|dn
argument_list|,
name|block
argument_list|)
expr_stmt|;
block|}
comment|// We now have the blocks to be marked as corrupt and we get back all
comment|// its replicas
name|DFSTestUtil
operator|.
name|waitReplication
argument_list|(
name|fs
argument_list|,
name|file1
argument_list|,
operator|(
name|short
operator|)
literal|3
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|DFSTestUtil
operator|.
name|allBlockReplicasCorrupt
argument_list|(
name|cluster
argument_list|,
name|file1
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|cluster
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
comment|/**    * testBlockCorruptionRecoveryPolicy.    * This tests recovery of corrupt replicas, first for one corrupt replica    * then for two. The test invokes blockCorruptionRecoveryPolicy which    * 1. Creates a block with desired number of replicas    * 2. Corrupts the desired number of replicas and restarts the datanodes    *    containing the corrupt replica. Additionaly we also read the block    *    in case restarting does not report corrupt replicas.    *    Restarting or reading from the datanode would trigger reportBadBlocks     *    to namenode.    *    NameNode adds it to corruptReplicasMap and neededReplication    * 3. Test waits until all corrupt replicas are reported, meanwhile    *    Re-replciation brings the block back to healthy state    * 4. Test again waits until the block is reported with expected number    *    of good replicas.    */
annotation|@
name|Test
DECL|method|testBlockCorruptionRecoveryPolicy1 ()
specifier|public
name|void
name|testBlockCorruptionRecoveryPolicy1
parameter_list|()
throws|throws
name|Exception
block|{
comment|// Test recovery of 1 corrupt replica
name|LOG
operator|.
name|info
argument_list|(
literal|"Testing corrupt replica recovery for one corrupt replica"
argument_list|)
expr_stmt|;
name|blockCorruptionRecoveryPolicy
argument_list|(
literal|4
argument_list|,
operator|(
name|short
operator|)
literal|3
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testBlockCorruptionRecoveryPolicy2 ()
specifier|public
name|void
name|testBlockCorruptionRecoveryPolicy2
parameter_list|()
throws|throws
name|Exception
block|{
comment|// Test recovery of 2 corrupt replicas
name|LOG
operator|.
name|info
argument_list|(
literal|"Testing corrupt replica recovery for two corrupt replicas"
argument_list|)
expr_stmt|;
name|blockCorruptionRecoveryPolicy
argument_list|(
literal|5
argument_list|,
operator|(
name|short
operator|)
literal|3
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
DECL|method|blockCorruptionRecoveryPolicy (int numDataNodes, short numReplicas, int numCorruptReplicas)
specifier|private
name|void
name|blockCorruptionRecoveryPolicy
parameter_list|(
name|int
name|numDataNodes
parameter_list|,
name|short
name|numReplicas
parameter_list|,
name|int
name|numCorruptReplicas
parameter_list|)
throws|throws
name|Exception
block|{
name|Configuration
name|conf
init|=
operator|new
name|HdfsConfiguration
argument_list|()
decl_stmt|;
name|conf
operator|.
name|setLong
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_BLOCKREPORT_INTERVAL_MSEC_KEY
argument_list|,
literal|30L
argument_list|)
expr_stmt|;
name|conf
operator|.
name|setLong
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_REPLICATION_INTERVAL_KEY
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|conf
operator|.
name|setLong
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_HEARTBEAT_INTERVAL_KEY
argument_list|,
literal|3L
argument_list|)
expr_stmt|;
name|conf
operator|.
name|setBoolean
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_REPLICATION_CONSIDERLOAD_KEY
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|conf
operator|.
name|setLong
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_REPLICATION_PENDING_TIMEOUT_SEC_KEY
argument_list|,
literal|5L
argument_list|)
expr_stmt|;
name|MiniDFSCluster
name|cluster
init|=
operator|new
name|MiniDFSCluster
operator|.
name|Builder
argument_list|(
name|conf
argument_list|)
operator|.
name|numDataNodes
argument_list|(
name|numDataNodes
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|cluster
operator|.
name|waitActive
argument_list|()
expr_stmt|;
name|FileSystem
name|fs
init|=
name|cluster
operator|.
name|getFileSystem
argument_list|()
decl_stmt|;
name|Path
name|file1
init|=
operator|new
name|Path
argument_list|(
literal|"/tmp/testBlockCorruptRecovery/file"
argument_list|)
decl_stmt|;
name|DFSTestUtil
operator|.
name|createFile
argument_list|(
name|fs
argument_list|,
name|file1
argument_list|,
literal|1024
argument_list|,
name|numReplicas
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ExtendedBlock
name|block
init|=
name|DFSTestUtil
operator|.
name|getFirstBlock
argument_list|(
name|fs
argument_list|,
name|file1
argument_list|)
decl_stmt|;
specifier|final
name|int
name|ITERATIONS
init|=
literal|10
decl_stmt|;
comment|// Wait until block is replicated to numReplicas
name|DFSTestUtil
operator|.
name|waitReplication
argument_list|(
name|fs
argument_list|,
name|file1
argument_list|,
name|numReplicas
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|k
init|=
literal|0
init|;
condition|;
name|k
operator|++
control|)
block|{
comment|// Corrupt numCorruptReplicas replicas of block
name|int
index|[]
name|corruptReplicasDNIDs
init|=
operator|new
name|int
index|[
name|numCorruptReplicas
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|,
name|j
init|=
literal|0
init|;
operator|(
name|j
operator|!=
name|numCorruptReplicas
operator|)
operator|&&
operator|(
name|i
operator|<
name|numDataNodes
operator|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|corruptReplica
argument_list|(
name|block
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|corruptReplicasDNIDs
index|[
name|j
operator|++
index|]
operator|=
name|i
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"successfully corrupted block "
operator|+
name|block
operator|+
literal|" on node "
operator|+
name|i
operator|+
literal|" "
operator|+
name|cluster
operator|.
name|getDataNodes
argument_list|()
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getDisplayName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Restart the datanodes containing corrupt replicas
comment|// so they would be reported to namenode and re-replicated
comment|// They MUST be restarted in reverse order from highest to lowest index,
comment|// because the act of restarting them removes them from the ArrayList
comment|// and causes the indexes of all nodes above them in the list to change.
for|for
control|(
name|int
name|i
init|=
name|numCorruptReplicas
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"restarting node with corrupt replica: position "
operator|+
name|i
operator|+
literal|" node "
operator|+
name|corruptReplicasDNIDs
index|[
name|i
index|]
operator|+
literal|" "
operator|+
name|cluster
operator|.
name|getDataNodes
argument_list|()
operator|.
name|get
argument_list|(
name|corruptReplicasDNIDs
index|[
name|i
index|]
argument_list|)
operator|.
name|getDisplayName
argument_list|()
argument_list|)
expr_stmt|;
name|cluster
operator|.
name|restartDataNode
argument_list|(
name|corruptReplicasDNIDs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|// Loop until all corrupt replicas are reported
try|try
block|{
name|DFSTestUtil
operator|.
name|waitCorruptReplicas
argument_list|(
name|fs
argument_list|,
name|cluster
operator|.
name|getNamesystem
argument_list|()
argument_list|,
name|file1
argument_list|,
name|block
argument_list|,
name|numCorruptReplicas
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|TimeoutException
name|e
parameter_list|)
block|{
if|if
condition|(
name|k
operator|>
name|ITERATIONS
condition|)
block|{
throw|throw
name|e
throw|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Timed out waiting for corrupt replicas, trying again, iteration "
operator|+
name|k
argument_list|)
expr_stmt|;
continue|continue;
block|}
break|break;
block|}
comment|// Loop until the block recovers after replication
name|DFSTestUtil
operator|.
name|waitReplication
argument_list|(
name|fs
argument_list|,
name|file1
argument_list|,
name|numReplicas
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|DFSTestUtil
operator|.
name|allBlockReplicasCorrupt
argument_list|(
name|cluster
argument_list|,
name|file1
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|// Make sure the corrupt replica is invalidated and removed from
comment|// corruptReplicasMap
name|DFSTestUtil
operator|.
name|waitCorruptReplicas
argument_list|(
name|fs
argument_list|,
name|cluster
operator|.
name|getNamesystem
argument_list|()
argument_list|,
name|file1
argument_list|,
name|block
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cluster
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
comment|/** Test if NameNode handles truncated blocks in block report */
annotation|@
name|Test
DECL|method|testTruncatedBlockReport ()
specifier|public
name|void
name|testTruncatedBlockReport
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|Configuration
name|conf
init|=
operator|new
name|HdfsConfiguration
argument_list|()
decl_stmt|;
specifier|final
name|short
name|REPLICATION_FACTOR
init|=
operator|(
name|short
operator|)
literal|2
decl_stmt|;
specifier|final
name|Path
name|fileName
init|=
operator|new
name|Path
argument_list|(
literal|"/file1"
argument_list|)
decl_stmt|;
name|conf
operator|.
name|setLong
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_BLOCKREPORT_INTERVAL_MSEC_KEY
argument_list|,
literal|3L
argument_list|)
expr_stmt|;
name|conf
operator|.
name|setLong
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_REPLICATION_INTERVAL_KEY
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|conf
operator|.
name|setLong
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_HEARTBEAT_INTERVAL_KEY
argument_list|,
literal|3L
argument_list|)
expr_stmt|;
name|conf
operator|.
name|setBoolean
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_REPLICATION_CONSIDERLOAD_KEY
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|long
name|startTime
init|=
name|Time
operator|.
name|monotonicNow
argument_list|()
decl_stmt|;
name|MiniDFSCluster
name|cluster
init|=
operator|new
name|MiniDFSCluster
operator|.
name|Builder
argument_list|(
name|conf
argument_list|)
operator|.
name|numDataNodes
argument_list|(
name|REPLICATION_FACTOR
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|cluster
operator|.
name|waitActive
argument_list|()
expr_stmt|;
name|ExtendedBlock
name|block
decl_stmt|;
try|try
block|{
name|FileSystem
name|fs
init|=
name|cluster
operator|.
name|getFileSystem
argument_list|()
decl_stmt|;
name|DFSTestUtil
operator|.
name|createFile
argument_list|(
name|fs
argument_list|,
name|fileName
argument_list|,
literal|1
argument_list|,
name|REPLICATION_FACTOR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DFSTestUtil
operator|.
name|waitReplication
argument_list|(
name|fs
argument_list|,
name|fileName
argument_list|,
name|REPLICATION_FACTOR
argument_list|)
expr_stmt|;
name|block
operator|=
name|DFSTestUtil
operator|.
name|getFirstBlock
argument_list|(
name|fs
argument_list|,
name|fileName
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|cluster
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
comment|// Restart cluster and confirm block is verified on datanode 0,
comment|// then truncate it on datanode 0.
name|cluster
operator|=
operator|new
name|MiniDFSCluster
operator|.
name|Builder
argument_list|(
name|conf
argument_list|)
operator|.
name|numDataNodes
argument_list|(
name|REPLICATION_FACTOR
argument_list|)
operator|.
name|format
argument_list|(
literal|false
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
name|cluster
operator|.
name|waitActive
argument_list|()
expr_stmt|;
try|try
block|{
name|FileSystem
name|fs
init|=
name|cluster
operator|.
name|getFileSystem
argument_list|()
decl_stmt|;
name|int
name|infoPort
init|=
name|cluster
operator|.
name|getDataNodes
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getInfoPort
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
name|waitForVerification
argument_list|(
name|infoPort
argument_list|,
name|fs
argument_list|,
name|fileName
argument_list|,
literal|1
argument_list|,
name|startTime
argument_list|,
name|TIMEOUT
argument_list|)
operator|>=
name|startTime
argument_list|)
expr_stmt|;
comment|// Truncate replica of block
if|if
condition|(
operator|!
name|changeReplicaLength
argument_list|(
name|block
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"failed to find or change length of replica on node 0 "
operator|+
name|cluster
operator|.
name|getDataNodes
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getDisplayName
argument_list|()
argument_list|)
throw|;
block|}
block|}
finally|finally
block|{
name|cluster
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
comment|// Restart the cluster, add a node, and check that the truncated block is
comment|// handled correctly
name|cluster
operator|=
operator|new
name|MiniDFSCluster
operator|.
name|Builder
argument_list|(
name|conf
argument_list|)
operator|.
name|numDataNodes
argument_list|(
name|REPLICATION_FACTOR
argument_list|)
operator|.
name|format
argument_list|(
literal|false
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
name|cluster
operator|.
name|startDataNodes
argument_list|(
name|conf
argument_list|,
literal|1
argument_list|,
literal|true
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|cluster
operator|.
name|waitActive
argument_list|()
expr_stmt|;
comment|// now we have 3 datanodes
comment|// Assure the cluster has left safe mode.
name|cluster
operator|.
name|waitClusterUp
argument_list|()
expr_stmt|;
name|assertFalse
argument_list|(
literal|"failed to leave safe mode"
argument_list|,
name|cluster
operator|.
name|getNameNode
argument_list|()
operator|.
name|isInSafeMode
argument_list|()
argument_list|)
expr_stmt|;
try|try
block|{
comment|// wait for truncated block be detected by block scanner,
comment|// and the block to be replicated
name|DFSTestUtil
operator|.
name|waitReplication
argument_list|(
name|cluster
operator|.
name|getFileSystem
argument_list|()
argument_list|,
name|fileName
argument_list|,
name|REPLICATION_FACTOR
argument_list|)
expr_stmt|;
comment|// Make sure that truncated block will be deleted
name|waitForBlockDeleted
argument_list|(
name|block
argument_list|,
literal|0
argument_list|,
name|TIMEOUT
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|cluster
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Change the length of a block at datanode dnIndex    */
DECL|method|changeReplicaLength (ExtendedBlock blk, int dnIndex, int lenDelta)
specifier|static
name|boolean
name|changeReplicaLength
parameter_list|(
name|ExtendedBlock
name|blk
parameter_list|,
name|int
name|dnIndex
parameter_list|,
name|int
name|lenDelta
parameter_list|)
throws|throws
name|IOException
block|{
name|File
name|blockFile
init|=
name|MiniDFSCluster
operator|.
name|getBlockFile
argument_list|(
name|dnIndex
argument_list|,
name|blk
argument_list|)
decl_stmt|;
if|if
condition|(
name|blockFile
operator|!=
literal|null
operator|&&
name|blockFile
operator|.
name|exists
argument_list|()
condition|)
block|{
name|RandomAccessFile
name|raFile
init|=
operator|new
name|RandomAccessFile
argument_list|(
name|blockFile
argument_list|,
literal|"rw"
argument_list|)
decl_stmt|;
name|raFile
operator|.
name|setLength
argument_list|(
name|raFile
operator|.
name|length
argument_list|()
operator|+
name|lenDelta
argument_list|)
expr_stmt|;
name|raFile
operator|.
name|close
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"failed to change length of block "
operator|+
name|blk
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
DECL|method|waitForBlockDeleted (ExtendedBlock blk, int dnIndex, long timeout)
specifier|private
specifier|static
name|void
name|waitForBlockDeleted
parameter_list|(
name|ExtendedBlock
name|blk
parameter_list|,
name|int
name|dnIndex
parameter_list|,
name|long
name|timeout
parameter_list|)
throws|throws
name|TimeoutException
throws|,
name|InterruptedException
block|{
name|File
name|blockFile
init|=
name|MiniDFSCluster
operator|.
name|getBlockFile
argument_list|(
name|dnIndex
argument_list|,
name|blk
argument_list|)
decl_stmt|;
name|long
name|failtime
init|=
name|Time
operator|.
name|monotonicNow
argument_list|()
operator|+
operator|(
operator|(
name|timeout
operator|>
literal|0
operator|)
condition|?
name|timeout
else|:
name|Long
operator|.
name|MAX_VALUE
operator|)
decl_stmt|;
while|while
condition|(
name|blockFile
operator|!=
literal|null
operator|&&
name|blockFile
operator|.
name|exists
argument_list|()
condition|)
block|{
if|if
condition|(
name|failtime
operator|<
name|Time
operator|.
name|monotonicNow
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|TimeoutException
argument_list|(
literal|"waited too long for blocks to be deleted: "
operator|+
name|blockFile
operator|.
name|getPath
argument_list|()
operator|+
operator|(
name|blockFile
operator|.
name|exists
argument_list|()
condition|?
literal|" still exists; "
else|:
literal|" is absent; "
operator|)
argument_list|)
throw|;
block|}
name|Thread
operator|.
name|sleep
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|blockFile
operator|=
name|MiniDFSCluster
operator|.
name|getBlockFile
argument_list|(
name|dnIndex
argument_list|,
name|blk
argument_list|)
expr_stmt|;
block|}
block|}
DECL|field|BASE_PATH
specifier|private
specifier|static
specifier|final
name|String
name|BASE_PATH
init|=
operator|(
operator|new
name|File
argument_list|(
literal|"/data/current/finalized"
argument_list|)
operator|)
operator|.
name|getAbsolutePath
argument_list|()
decl_stmt|;
annotation|@
name|Test
DECL|method|testReplicaInfoParsing ()
specifier|public
name|void
name|testReplicaInfoParsing
parameter_list|()
throws|throws
name|Exception
block|{
name|testReplicaInfoParsingSingle
argument_list|(
name|BASE_PATH
argument_list|)
expr_stmt|;
name|testReplicaInfoParsingSingle
argument_list|(
name|BASE_PATH
operator|+
literal|"/subdir1"
argument_list|)
expr_stmt|;
name|testReplicaInfoParsingSingle
argument_list|(
name|BASE_PATH
operator|+
literal|"/subdir1/subdir2/subdir3"
argument_list|)
expr_stmt|;
block|}
DECL|method|testReplicaInfoParsingSingle (String subDirPath)
specifier|private
specifier|static
name|void
name|testReplicaInfoParsingSingle
parameter_list|(
name|String
name|subDirPath
parameter_list|)
block|{
name|File
name|testFile
init|=
operator|new
name|File
argument_list|(
name|subDirPath
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|BASE_PATH
argument_list|,
name|ReplicaInfo
operator|.
name|parseBaseDir
argument_list|(
name|testFile
argument_list|)
operator|.
name|baseDirPath
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testDuplicateScans ()
specifier|public
name|void
name|testDuplicateScans
parameter_list|()
throws|throws
name|Exception
block|{
name|long
name|startTime
init|=
name|Time
operator|.
name|monotonicNow
argument_list|()
decl_stmt|;
name|MiniDFSCluster
name|cluster
init|=
operator|new
name|MiniDFSCluster
operator|.
name|Builder
argument_list|(
operator|new
name|Configuration
argument_list|()
argument_list|)
operator|.
name|numDataNodes
argument_list|(
literal|1
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|FileSystem
name|fs
init|=
literal|null
decl_stmt|;
try|try
block|{
name|fs
operator|=
name|cluster
operator|.
name|getFileSystem
argument_list|()
expr_stmt|;
name|DataNode
name|dataNode
init|=
name|cluster
operator|.
name|getDataNodes
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|int
name|infoPort
init|=
name|dataNode
operator|.
name|getInfoPort
argument_list|()
decl_stmt|;
name|long
name|scanTimeBefore
init|=
literal|0
decl_stmt|,
name|scanTimeAfter
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
block|{
name|Path
name|fileName
init|=
operator|new
name|Path
argument_list|(
literal|"/test"
operator|+
name|i
argument_list|)
decl_stmt|;
name|DFSTestUtil
operator|.
name|createFile
argument_list|(
name|fs
argument_list|,
name|fileName
argument_list|,
literal|1024
argument_list|,
operator|(
name|short
operator|)
literal|1
argument_list|,
literal|1000L
argument_list|)
expr_stmt|;
name|waitForVerification
argument_list|(
name|infoPort
argument_list|,
name|fs
argument_list|,
name|fileName
argument_list|,
name|i
argument_list|,
name|startTime
argument_list|,
name|TIMEOUT
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|1
condition|)
block|{
name|scanTimeAfter
operator|=
name|DataNodeTestUtils
operator|.
name|getLatestScanTime
argument_list|(
name|dataNode
argument_list|,
name|DFSTestUtil
operator|.
name|getFirstBlock
argument_list|(
name|fs
argument_list|,
operator|new
name|Path
argument_list|(
literal|"/test"
operator|+
operator|(
name|i
operator|-
literal|1
operator|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
literal|"scan time shoud not be 0"
argument_list|,
name|scanTimeAfter
operator|==
literal|0
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"There should not be duplicate scan"
argument_list|,
name|scanTimeBefore
argument_list|,
name|scanTimeAfter
argument_list|)
expr_stmt|;
block|}
name|scanTimeBefore
operator|=
name|DataNodeTestUtils
operator|.
name|getLatestScanTime
argument_list|(
name|dataNode
argument_list|,
name|DFSTestUtil
operator|.
name|getFirstBlock
argument_list|(
name|fs
argument_list|,
operator|new
name|Path
argument_list|(
literal|"/test"
operator|+
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|cluster
operator|.
name|restartDataNode
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|Thread
operator|.
name|sleep
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
name|dataNode
operator|=
name|cluster
operator|.
name|getDataNodes
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|scanTimeAfter
operator|=
name|DataNodeTestUtils
operator|.
name|getLatestScanTime
argument_list|(
name|dataNode
argument_list|,
name|DFSTestUtil
operator|.
name|getFirstBlock
argument_list|(
name|fs
argument_list|,
operator|new
name|Path
argument_list|(
literal|"/test"
operator|+
operator|(
literal|9
operator|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"There should not be duplicate scan"
argument_list|,
name|scanTimeBefore
argument_list|,
name|scanTimeAfter
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|IOUtils
operator|.
name|closeStream
argument_list|(
name|fs
argument_list|)
expr_stmt|;
name|cluster
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

