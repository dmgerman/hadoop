begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdfs
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertEquals
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertFalse
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertTrue
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|fail
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileNotFoundException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|PrivilegedExceptionAction
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Random
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|CommonConfigurationKeys
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FSDataInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FSDataOutputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Trash
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|permission
operator|.
name|FsPermission
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|permission
operator|.
name|FsAction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|AccessControlException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|UserGroupInformation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Time
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|After
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Before
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Test
import|;
end_import

begin_comment
comment|/** Unit tests for permission */
end_comment

begin_class
DECL|class|TestDFSPermission
specifier|public
class|class
name|TestDFSPermission
block|{
DECL|field|LOG
specifier|public
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|TestDFSPermission
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|conf
specifier|final
specifier|private
specifier|static
name|Configuration
name|conf
init|=
operator|new
name|HdfsConfiguration
argument_list|()
decl_stmt|;
DECL|field|GROUP1_NAME
specifier|final
specifier|private
specifier|static
name|String
name|GROUP1_NAME
init|=
literal|"group1"
decl_stmt|;
DECL|field|GROUP2_NAME
specifier|final
specifier|private
specifier|static
name|String
name|GROUP2_NAME
init|=
literal|"group2"
decl_stmt|;
DECL|field|GROUP3_NAME
specifier|final
specifier|private
specifier|static
name|String
name|GROUP3_NAME
init|=
literal|"group3"
decl_stmt|;
DECL|field|GROUP4_NAME
specifier|final
specifier|private
specifier|static
name|String
name|GROUP4_NAME
init|=
literal|"group4"
decl_stmt|;
DECL|field|USER1_NAME
specifier|final
specifier|private
specifier|static
name|String
name|USER1_NAME
init|=
literal|"user1"
decl_stmt|;
DECL|field|USER2_NAME
specifier|final
specifier|private
specifier|static
name|String
name|USER2_NAME
init|=
literal|"user2"
decl_stmt|;
DECL|field|USER3_NAME
specifier|final
specifier|private
specifier|static
name|String
name|USER3_NAME
init|=
literal|"user3"
decl_stmt|;
DECL|field|SUPERUSER
specifier|private
specifier|static
specifier|final
name|UserGroupInformation
name|SUPERUSER
decl_stmt|;
DECL|field|USER1
specifier|private
specifier|static
specifier|final
name|UserGroupInformation
name|USER1
decl_stmt|;
DECL|field|USER2
specifier|private
specifier|static
specifier|final
name|UserGroupInformation
name|USER2
decl_stmt|;
DECL|field|USER3
specifier|private
specifier|static
specifier|final
name|UserGroupInformation
name|USER3
decl_stmt|;
DECL|field|MAX_PERMISSION
specifier|final
specifier|private
specifier|static
name|short
name|MAX_PERMISSION
init|=
literal|511
decl_stmt|;
DECL|field|DEFAULT_UMASK
specifier|final
specifier|private
specifier|static
name|short
name|DEFAULT_UMASK
init|=
literal|022
decl_stmt|;
DECL|field|DEFAULT_PERMISSION
specifier|final
specifier|private
specifier|static
name|FsPermission
name|DEFAULT_PERMISSION
init|=
name|FsPermission
operator|.
name|createImmutable
argument_list|(
operator|(
name|short
operator|)
literal|0777
argument_list|)
decl_stmt|;
DECL|field|NUM_TEST_PERMISSIONS
specifier|final
specifier|static
specifier|private
name|int
name|NUM_TEST_PERMISSIONS
init|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"test.dfs.permission.num"
argument_list|,
literal|10
argument_list|)
operator|*
operator|(
name|MAX_PERMISSION
operator|+
literal|1
operator|)
operator|/
literal|100
decl_stmt|;
DECL|field|PATH_NAME
specifier|final
specifier|private
specifier|static
name|String
name|PATH_NAME
init|=
literal|"xx"
decl_stmt|;
DECL|field|FILE_DIR_PATH
specifier|final
specifier|private
specifier|static
name|Path
name|FILE_DIR_PATH
init|=
operator|new
name|Path
argument_list|(
literal|"/"
argument_list|,
name|PATH_NAME
argument_list|)
decl_stmt|;
DECL|field|NON_EXISTENT_PATH
specifier|final
specifier|private
specifier|static
name|Path
name|NON_EXISTENT_PATH
init|=
operator|new
name|Path
argument_list|(
literal|"/parent"
argument_list|,
name|PATH_NAME
argument_list|)
decl_stmt|;
DECL|field|NON_EXISTENT_FILE
specifier|final
specifier|private
specifier|static
name|Path
name|NON_EXISTENT_FILE
init|=
operator|new
name|Path
argument_list|(
literal|"/NonExistentFile"
argument_list|)
decl_stmt|;
DECL|field|fs
specifier|private
name|FileSystem
name|fs
decl_stmt|;
DECL|field|cluster
specifier|private
name|MiniDFSCluster
name|cluster
decl_stmt|;
DECL|field|r
specifier|private
specifier|static
specifier|final
name|Random
name|r
decl_stmt|;
static|static
block|{
try|try
block|{
comment|// Initiate the random number generator and logging the seed
name|long
name|seed
init|=
name|Time
operator|.
name|now
argument_list|()
decl_stmt|;
name|r
operator|=
operator|new
name|Random
argument_list|(
name|seed
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Random number generator uses seed "
operator|+
name|seed
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"NUM_TEST_PERMISSIONS="
operator|+
name|NUM_TEST_PERMISSIONS
argument_list|)
expr_stmt|;
comment|// explicitly turn on permission checking
name|conf
operator|.
name|setBoolean
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_PERMISSIONS_ENABLED_KEY
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|// create fake mapping for the groups
name|Map
argument_list|<
name|String
argument_list|,
name|String
index|[]
argument_list|>
name|u2g_map
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
index|[]
argument_list|>
argument_list|(
literal|3
argument_list|)
decl_stmt|;
name|u2g_map
operator|.
name|put
argument_list|(
name|USER1_NAME
argument_list|,
operator|new
name|String
index|[]
block|{
name|GROUP1_NAME
block|,
name|GROUP2_NAME
block|}
argument_list|)
expr_stmt|;
name|u2g_map
operator|.
name|put
argument_list|(
name|USER2_NAME
argument_list|,
operator|new
name|String
index|[]
block|{
name|GROUP2_NAME
block|,
name|GROUP3_NAME
block|}
argument_list|)
expr_stmt|;
name|u2g_map
operator|.
name|put
argument_list|(
name|USER3_NAME
argument_list|,
operator|new
name|String
index|[]
block|{
name|GROUP3_NAME
block|,
name|GROUP4_NAME
block|}
argument_list|)
expr_stmt|;
name|DFSTestUtil
operator|.
name|updateConfWithFakeGroupMapping
argument_list|(
name|conf
argument_list|,
name|u2g_map
argument_list|)
expr_stmt|;
comment|// Initiate all four users
name|SUPERUSER
operator|=
name|UserGroupInformation
operator|.
name|getCurrentUser
argument_list|()
expr_stmt|;
name|USER1
operator|=
name|UserGroupInformation
operator|.
name|createUserForTesting
argument_list|(
name|USER1_NAME
argument_list|,
operator|new
name|String
index|[]
block|{
name|GROUP1_NAME
block|,
name|GROUP2_NAME
block|}
argument_list|)
expr_stmt|;
name|USER2
operator|=
name|UserGroupInformation
operator|.
name|createUserForTesting
argument_list|(
name|USER2_NAME
argument_list|,
operator|new
name|String
index|[]
block|{
name|GROUP2_NAME
block|,
name|GROUP3_NAME
block|}
argument_list|)
expr_stmt|;
name|USER3
operator|=
name|UserGroupInformation
operator|.
name|createUserForTesting
argument_list|(
name|USER3_NAME
argument_list|,
operator|new
name|String
index|[]
block|{
name|GROUP3_NAME
block|,
name|GROUP4_NAME
block|}
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Before
DECL|method|setUp ()
specifier|public
name|void
name|setUp
parameter_list|()
throws|throws
name|IOException
block|{
name|cluster
operator|=
operator|new
name|MiniDFSCluster
operator|.
name|Builder
argument_list|(
name|conf
argument_list|)
operator|.
name|numDataNodes
argument_list|(
literal|3
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
name|cluster
operator|.
name|waitActive
argument_list|()
expr_stmt|;
block|}
annotation|@
name|After
DECL|method|tearDown ()
specifier|public
name|void
name|tearDown
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|cluster
operator|!=
literal|null
condition|)
block|{
name|cluster
operator|.
name|shutdown
argument_list|()
expr_stmt|;
name|cluster
operator|=
literal|null
expr_stmt|;
block|}
block|}
comment|/** This tests if permission setting in create, mkdir, and     * setPermission works correctly    */
annotation|@
name|Test
DECL|method|testPermissionSetting ()
specifier|public
name|void
name|testPermissionSetting
parameter_list|()
throws|throws
name|Exception
block|{
name|testPermissionSetting
argument_list|(
name|OpType
operator|.
name|CREATE
argument_list|)
expr_stmt|;
comment|// test file creation
name|testPermissionSetting
argument_list|(
name|OpType
operator|.
name|MKDIRS
argument_list|)
expr_stmt|;
comment|// test directory creation
block|}
DECL|method|initFileSystem (short umask)
specifier|private
name|void
name|initFileSystem
parameter_list|(
name|short
name|umask
parameter_list|)
throws|throws
name|Exception
block|{
comment|// set umask in configuration, converting to padded octal
name|conf
operator|.
name|set
argument_list|(
name|FsPermission
operator|.
name|UMASK_LABEL
argument_list|,
name|String
operator|.
name|format
argument_list|(
literal|"%1$03o"
argument_list|,
name|umask
argument_list|)
argument_list|)
expr_stmt|;
name|fs
operator|=
name|FileSystem
operator|.
name|get
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
DECL|method|closeFileSystem ()
specifier|private
name|void
name|closeFileSystem
parameter_list|()
throws|throws
name|Exception
block|{
name|fs
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|/* check permission setting works correctly for file or directory */
DECL|method|testPermissionSetting (OpType op)
specifier|private
name|void
name|testPermissionSetting
parameter_list|(
name|OpType
name|op
parameter_list|)
throws|throws
name|Exception
block|{
name|short
name|uMask
init|=
name|DEFAULT_UMASK
decl_stmt|;
comment|// case 1: use default permission but all possible umasks
name|PermissionGenerator
name|generator
init|=
operator|new
name|PermissionGenerator
argument_list|(
name|r
argument_list|)
decl_stmt|;
name|FsPermission
name|permission
init|=
operator|new
name|FsPermission
argument_list|(
name|DEFAULT_PERMISSION
argument_list|)
decl_stmt|;
for|for
control|(
name|short
name|i
init|=
literal|0
init|;
name|i
operator|<
name|NUM_TEST_PERMISSIONS
condition|;
name|i
operator|++
control|)
block|{
name|uMask
operator|=
name|generator
operator|.
name|next
argument_list|()
expr_stmt|;
name|initFileSystem
argument_list|(
name|uMask
argument_list|)
expr_stmt|;
name|createAndCheckPermission
argument_list|(
name|op
argument_list|,
name|FILE_DIR_PATH
argument_list|,
name|uMask
argument_list|,
name|permission
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|closeFileSystem
argument_list|()
expr_stmt|;
block|}
comment|// case 2: use permission 0643 and the default umask
name|uMask
operator|=
name|DEFAULT_UMASK
expr_stmt|;
name|initFileSystem
argument_list|(
name|uMask
argument_list|)
expr_stmt|;
name|createAndCheckPermission
argument_list|(
name|op
argument_list|,
name|FILE_DIR_PATH
argument_list|,
name|uMask
argument_list|,
operator|new
name|FsPermission
argument_list|(
operator|(
name|short
operator|)
literal|0643
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|closeFileSystem
argument_list|()
expr_stmt|;
comment|// case 3: use permission 0643 and umask 0222
name|uMask
operator|=
operator|(
name|short
operator|)
literal|0222
expr_stmt|;
name|initFileSystem
argument_list|(
name|uMask
argument_list|)
expr_stmt|;
name|createAndCheckPermission
argument_list|(
name|op
argument_list|,
name|FILE_DIR_PATH
argument_list|,
name|uMask
argument_list|,
operator|new
name|FsPermission
argument_list|(
operator|(
name|short
operator|)
literal|0643
argument_list|)
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|closeFileSystem
argument_list|()
expr_stmt|;
comment|// case 4: set permission
name|uMask
operator|=
operator|(
name|short
operator|)
literal|0111
expr_stmt|;
name|initFileSystem
argument_list|(
name|uMask
argument_list|)
expr_stmt|;
name|fs
operator|.
name|setPermission
argument_list|(
name|FILE_DIR_PATH
argument_list|,
operator|new
name|FsPermission
argument_list|(
name|uMask
argument_list|)
argument_list|)
expr_stmt|;
name|short
name|expectedPermission
init|=
operator|(
name|short
operator|)
literal|0111
decl_stmt|;
name|checkPermission
argument_list|(
name|FILE_DIR_PATH
argument_list|,
name|expectedPermission
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|closeFileSystem
argument_list|()
expr_stmt|;
comment|// case 5: test non-existent parent directory
name|uMask
operator|=
name|DEFAULT_UMASK
expr_stmt|;
name|initFileSystem
argument_list|(
name|uMask
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
literal|"File shouldn't exists"
argument_list|,
name|fs
operator|.
name|exists
argument_list|(
name|NON_EXISTENT_PATH
argument_list|)
argument_list|)
expr_stmt|;
name|createAndCheckPermission
argument_list|(
name|op
argument_list|,
name|NON_EXISTENT_PATH
argument_list|,
name|uMask
argument_list|,
operator|new
name|FsPermission
argument_list|(
name|DEFAULT_PERMISSION
argument_list|)
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|Path
name|parent
init|=
name|NON_EXISTENT_PATH
operator|.
name|getParent
argument_list|()
decl_stmt|;
name|checkPermission
argument_list|(
name|parent
argument_list|,
name|getPermission
argument_list|(
name|parent
operator|.
name|getParent
argument_list|()
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|closeFileSystem
argument_list|()
expr_stmt|;
block|}
comment|/* get the permission of a file/directory */
DECL|method|getPermission (Path path)
specifier|private
name|short
name|getPermission
parameter_list|(
name|Path
name|path
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|fs
operator|.
name|getFileStatus
argument_list|(
name|path
argument_list|)
operator|.
name|getPermission
argument_list|()
operator|.
name|toShort
argument_list|()
return|;
block|}
DECL|method|create (OpType op, Path name)
specifier|private
name|void
name|create
parameter_list|(
name|OpType
name|op
parameter_list|,
name|Path
name|name
parameter_list|)
throws|throws
name|IOException
block|{
name|create
argument_list|(
name|fs
argument_list|,
name|conf
argument_list|,
name|op
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
comment|/* create a file/directory with the default umask and permission */
DECL|method|create (final FileSystem fs, final Configuration fsConf, OpType op, Path name)
specifier|static
name|void
name|create
parameter_list|(
specifier|final
name|FileSystem
name|fs
parameter_list|,
specifier|final
name|Configuration
name|fsConf
parameter_list|,
name|OpType
name|op
parameter_list|,
name|Path
name|name
parameter_list|)
throws|throws
name|IOException
block|{
name|create
argument_list|(
name|fs
argument_list|,
name|fsConf
argument_list|,
name|op
argument_list|,
name|name
argument_list|,
name|DEFAULT_UMASK
argument_list|,
operator|new
name|FsPermission
argument_list|(
name|DEFAULT_PERMISSION
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|create (OpType op, Path name, short umask, FsPermission permission)
specifier|private
name|void
name|create
parameter_list|(
name|OpType
name|op
parameter_list|,
name|Path
name|name
parameter_list|,
name|short
name|umask
parameter_list|,
name|FsPermission
name|permission
parameter_list|)
throws|throws
name|IOException
block|{
name|create
argument_list|(
name|fs
argument_list|,
name|conf
argument_list|,
name|op
argument_list|,
name|name
argument_list|,
name|umask
argument_list|,
name|permission
argument_list|)
expr_stmt|;
block|}
comment|/* create a file/directory with the given umask and permission */
DECL|method|create (final FileSystem fs, final Configuration fsConf, OpType op, Path name, short umask, FsPermission permission)
specifier|static
name|void
name|create
parameter_list|(
specifier|final
name|FileSystem
name|fs
parameter_list|,
specifier|final
name|Configuration
name|fsConf
parameter_list|,
name|OpType
name|op
parameter_list|,
name|Path
name|name
parameter_list|,
name|short
name|umask
parameter_list|,
name|FsPermission
name|permission
parameter_list|)
throws|throws
name|IOException
block|{
comment|// set umask in configuration, converting to padded octal
name|fsConf
operator|.
name|set
argument_list|(
name|FsPermission
operator|.
name|UMASK_LABEL
argument_list|,
name|String
operator|.
name|format
argument_list|(
literal|"%1$03o"
argument_list|,
name|umask
argument_list|)
argument_list|)
expr_stmt|;
comment|// create the file/directory
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|CREATE
case|:
name|FSDataOutputStream
name|out
init|=
name|fs
operator|.
name|create
argument_list|(
name|name
argument_list|,
name|permission
argument_list|,
literal|true
argument_list|,
name|fsConf
operator|.
name|getInt
argument_list|(
name|CommonConfigurationKeys
operator|.
name|IO_FILE_BUFFER_SIZE_KEY
argument_list|,
literal|4096
argument_list|)
argument_list|,
name|fs
operator|.
name|getDefaultReplication
argument_list|(
name|name
argument_list|)
argument_list|,
name|fs
operator|.
name|getDefaultBlockSize
argument_list|(
name|name
argument_list|)
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|out
operator|.
name|close
argument_list|()
expr_stmt|;
break|break;
case|case
name|MKDIRS
case|:
name|fs
operator|.
name|mkdirs
argument_list|(
name|name
argument_list|,
name|permission
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unsupported operation: "
operator|+
name|op
argument_list|)
throw|;
block|}
block|}
comment|/* create file/directory with the provided umask and permission; then it    * checks if the permission is set correctly;    * If the delete flag is true, delete the file afterwards; otherwise leave    * it in the file system.    */
DECL|method|createAndCheckPermission (OpType op, Path name, short umask, FsPermission permission, boolean delete)
specifier|private
name|void
name|createAndCheckPermission
parameter_list|(
name|OpType
name|op
parameter_list|,
name|Path
name|name
parameter_list|,
name|short
name|umask
parameter_list|,
name|FsPermission
name|permission
parameter_list|,
name|boolean
name|delete
parameter_list|)
throws|throws
name|Exception
block|{
comment|// create the file/directory
name|create
argument_list|(
name|op
argument_list|,
name|name
argument_list|,
name|umask
argument_list|,
name|permission
argument_list|)
expr_stmt|;
comment|// get the short form of the permission
name|short
name|permissionNum
init|=
operator|(
name|DEFAULT_PERMISSION
operator|.
name|equals
argument_list|(
name|permission
argument_list|)
operator|)
condition|?
name|MAX_PERMISSION
else|:
name|permission
operator|.
name|toShort
argument_list|()
decl_stmt|;
comment|// get the expected permission
name|short
name|expectedPermission
init|=
operator|(
name|op
operator|==
name|OpType
operator|.
name|CREATE
operator|)
condition|?
call|(
name|short
call|)
argument_list|(
operator|~
name|umask
operator|&
name|permissionNum
argument_list|)
else|:
call|(
name|short
call|)
argument_list|(
operator|~
name|umask
operator|&
name|permissionNum
argument_list|)
decl_stmt|;
comment|// check if permission is correctly set
name|checkPermission
argument_list|(
name|name
argument_list|,
name|expectedPermission
argument_list|,
name|delete
argument_list|)
expr_stmt|;
block|}
comment|/* Check if the permission of a file/directory is the same as the    * expected permission; If the delete flag is true, delete the    * file/directory afterwards.    */
DECL|method|checkPermission (Path name, short expectedPermission, boolean delete)
specifier|private
name|void
name|checkPermission
parameter_list|(
name|Path
name|name
parameter_list|,
name|short
name|expectedPermission
parameter_list|,
name|boolean
name|delete
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
comment|// check its permission
name|assertEquals
argument_list|(
name|getPermission
argument_list|(
name|name
argument_list|)
argument_list|,
name|expectedPermission
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
comment|// delete the file
if|if
condition|(
name|delete
condition|)
block|{
name|fs
operator|.
name|delete
argument_list|(
name|name
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * check that ImmutableFsPermission can be used as the argument    * to setPermission    */
annotation|@
name|Test
DECL|method|testImmutableFsPermission ()
specifier|public
name|void
name|testImmutableFsPermission
parameter_list|()
throws|throws
name|IOException
block|{
name|fs
operator|=
name|FileSystem
operator|.
name|get
argument_list|(
name|conf
argument_list|)
expr_stmt|;
comment|// set the permission of the root to be world-wide rwx
name|fs
operator|.
name|setPermission
argument_list|(
operator|new
name|Path
argument_list|(
literal|"/"
argument_list|)
argument_list|,
name|FsPermission
operator|.
name|createImmutable
argument_list|(
operator|(
name|short
operator|)
literal|0777
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
argument_list|(
name|timeout
operator|=
literal|30000
argument_list|)
DECL|method|testTrashPermission ()
specifier|public
name|void
name|testTrashPermission
parameter_list|()
throws|throws
name|Exception
block|{
comment|//  /BSS                  user1:group2 777
comment|//   /BSS/user1            user1:group2 755
comment|//   /BSS/user1/test       user1:group1 600
name|Path
name|rootDir
init|=
operator|new
name|Path
argument_list|(
literal|"/BSS"
argument_list|)
decl_stmt|;
name|Path
name|user1Dir
init|=
operator|new
name|Path
argument_list|(
literal|"/BSS/user1"
argument_list|)
decl_stmt|;
name|Path
name|user1File
init|=
operator|new
name|Path
argument_list|(
literal|"/BSS/user1/test"
argument_list|)
decl_stmt|;
try|try
block|{
name|conf
operator|.
name|set
argument_list|(
name|CommonConfigurationKeys
operator|.
name|FS_TRASH_INTERVAL_KEY
argument_list|,
literal|"10"
argument_list|)
expr_stmt|;
name|fs
operator|=
name|FileSystem
operator|.
name|get
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|fs
operator|.
name|mkdirs
argument_list|(
name|rootDir
argument_list|)
expr_stmt|;
name|fs
operator|.
name|setPermission
argument_list|(
name|rootDir
argument_list|,
operator|new
name|FsPermission
argument_list|(
operator|(
name|short
operator|)
literal|0777
argument_list|)
argument_list|)
expr_stmt|;
name|fs
operator|=
name|DFSTestUtil
operator|.
name|login
argument_list|(
name|fs
argument_list|,
name|conf
argument_list|,
name|USER1
argument_list|)
expr_stmt|;
name|fs
operator|.
name|mkdirs
argument_list|(
name|user1Dir
argument_list|)
expr_stmt|;
name|fs
operator|.
name|setPermission
argument_list|(
name|user1Dir
argument_list|,
operator|new
name|FsPermission
argument_list|(
operator|(
name|short
operator|)
literal|0755
argument_list|)
argument_list|)
expr_stmt|;
name|fs
operator|.
name|setOwner
argument_list|(
name|user1Dir
argument_list|,
name|USER1
operator|.
name|getShortUserName
argument_list|()
argument_list|,
name|GROUP2_NAME
argument_list|)
expr_stmt|;
name|create
argument_list|(
name|OpType
operator|.
name|CREATE
argument_list|,
name|user1File
argument_list|)
expr_stmt|;
name|fs
operator|.
name|setOwner
argument_list|(
name|user1File
argument_list|,
name|USER1
operator|.
name|getShortUserName
argument_list|()
argument_list|,
name|GROUP1_NAME
argument_list|)
expr_stmt|;
name|fs
operator|.
name|setPermission
argument_list|(
name|user1File
argument_list|,
operator|new
name|FsPermission
argument_list|(
operator|(
name|short
operator|)
literal|0600
argument_list|)
argument_list|)
expr_stmt|;
try|try
block|{
comment|// login as user2, attempt to delete /BSS/user1
comment|// this should fail because user2 has no permission to
comment|// its sub directory.
name|fs
operator|=
name|DFSTestUtil
operator|.
name|login
argument_list|(
name|fs
argument_list|,
name|conf
argument_list|,
name|USER2
argument_list|)
expr_stmt|;
name|fs
operator|.
name|delete
argument_list|(
name|user1Dir
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"User2 should not be allowed to delete user1's dir."
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|AccessControlException
name|e
parameter_list|)
block|{
name|e
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
name|assertTrue
argument_list|(
literal|"Permission denied messages must carry the username"
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
operator|.
name|contains
argument_list|(
name|USER2_NAME
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// ensure the /BSS/user1 still exists
name|assertTrue
argument_list|(
name|fs
operator|.
name|exists
argument_list|(
name|user1Dir
argument_list|)
argument_list|)
expr_stmt|;
try|try
block|{
name|fs
operator|=
name|DFSTestUtil
operator|.
name|login
argument_list|(
name|fs
argument_list|,
name|conf
argument_list|,
name|SUPERUSER
argument_list|)
expr_stmt|;
name|Trash
name|trash
init|=
operator|new
name|Trash
argument_list|(
name|fs
argument_list|,
name|conf
argument_list|)
decl_stmt|;
name|Path
name|trashRoot
init|=
name|trash
operator|.
name|getCurrentTrashDir
argument_list|(
name|user1Dir
argument_list|)
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|trashRoot
operator|=
name|trashRoot
operator|.
name|getParent
argument_list|()
expr_stmt|;
if|if
condition|(
name|trashRoot
operator|.
name|getParent
argument_list|()
operator|.
name|isRoot
argument_list|()
condition|)
block|{
break|break;
block|}
block|}
name|fs
operator|.
name|mkdirs
argument_list|(
name|trashRoot
argument_list|)
expr_stmt|;
name|fs
operator|.
name|setPermission
argument_list|(
name|trashRoot
argument_list|,
operator|new
name|FsPermission
argument_list|(
operator|(
name|short
operator|)
literal|0777
argument_list|)
argument_list|)
expr_stmt|;
comment|// login as user2, attempt to move /BSS/user1 to trash
comment|// this should also fail otherwise the directory will be
comment|// removed by trash emptier (emptier is running by superuser)
name|fs
operator|=
name|DFSTestUtil
operator|.
name|login
argument_list|(
name|fs
argument_list|,
name|conf
argument_list|,
name|USER2
argument_list|)
expr_stmt|;
name|Trash
name|userTrash
init|=
operator|new
name|Trash
argument_list|(
name|fs
argument_list|,
name|conf
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|userTrash
operator|.
name|isEnabled
argument_list|()
argument_list|)
expr_stmt|;
name|userTrash
operator|.
name|moveToTrash
argument_list|(
name|user1Dir
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"User2 should not be allowed to move"
operator|+
literal|"user1's dir to trash"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// expect the exception is caused by permission denied
name|assertTrue
argument_list|(
name|e
operator|.
name|getCause
argument_list|()
operator|instanceof
name|AccessControlException
argument_list|)
expr_stmt|;
name|e
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
name|assertTrue
argument_list|(
literal|"Permission denied messages must carry the username"
argument_list|,
name|e
operator|.
name|getCause
argument_list|()
operator|.
name|getMessage
argument_list|()
operator|.
name|contains
argument_list|(
name|USER2_NAME
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// ensure /BSS/user1 still exists
name|assertEquals
argument_list|(
name|fs
operator|.
name|exists
argument_list|(
name|user1Dir
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|fs
operator|=
name|DFSTestUtil
operator|.
name|login
argument_list|(
name|fs
argument_list|,
name|conf
argument_list|,
name|SUPERUSER
argument_list|)
expr_stmt|;
name|fs
operator|.
name|delete
argument_list|(
name|rootDir
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|conf
operator|.
name|set
argument_list|(
name|CommonConfigurationKeys
operator|.
name|FS_TRASH_INTERVAL_KEY
argument_list|,
literal|"0"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* check if the ownership of a file/directory is set correctly */
annotation|@
name|Test
DECL|method|testOwnership ()
specifier|public
name|void
name|testOwnership
parameter_list|()
throws|throws
name|Exception
block|{
name|testOwnership
argument_list|(
name|OpType
operator|.
name|CREATE
argument_list|)
expr_stmt|;
comment|// test file creation
name|testOwnership
argument_list|(
name|OpType
operator|.
name|MKDIRS
argument_list|)
expr_stmt|;
comment|// test directory creation
block|}
comment|/* change a file/directory's owner and group.    * if expectDeny is set, expect an AccessControlException.    */
DECL|method|setOwner (Path path, String owner, String group, boolean expectDeny)
specifier|private
name|void
name|setOwner
parameter_list|(
name|Path
name|path
parameter_list|,
name|String
name|owner
parameter_list|,
name|String
name|group
parameter_list|,
name|boolean
name|expectDeny
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
name|String
name|expectedOwner
init|=
operator|(
name|owner
operator|==
literal|null
operator|)
condition|?
name|getOwner
argument_list|(
name|path
argument_list|)
else|:
name|owner
decl_stmt|;
name|String
name|expectedGroup
init|=
operator|(
name|group
operator|==
literal|null
operator|)
condition|?
name|getGroup
argument_list|(
name|path
argument_list|)
else|:
name|group
decl_stmt|;
name|fs
operator|.
name|setOwner
argument_list|(
name|path
argument_list|,
name|owner
argument_list|,
name|group
argument_list|)
expr_stmt|;
name|checkOwnership
argument_list|(
name|path
argument_list|,
name|expectedOwner
argument_list|,
name|expectedGroup
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|expectDeny
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|AccessControlException
name|e
parameter_list|)
block|{
name|assertTrue
argument_list|(
name|expectDeny
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* check ownership is set correctly for a file or directory */
DECL|method|testOwnership (OpType op)
specifier|private
name|void
name|testOwnership
parameter_list|(
name|OpType
name|op
parameter_list|)
throws|throws
name|Exception
block|{
comment|// case 1: superuser create a file/directory
name|fs
operator|=
name|FileSystem
operator|.
name|get
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|create
argument_list|(
name|op
argument_list|,
name|FILE_DIR_PATH
argument_list|,
name|DEFAULT_UMASK
argument_list|,
operator|new
name|FsPermission
argument_list|(
name|DEFAULT_PERMISSION
argument_list|)
argument_list|)
expr_stmt|;
name|checkOwnership
argument_list|(
name|FILE_DIR_PATH
argument_list|,
name|SUPERUSER
operator|.
name|getShortUserName
argument_list|()
argument_list|,
name|getGroup
argument_list|(
name|FILE_DIR_PATH
operator|.
name|getParent
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|// case 2: superuser changes FILE_DIR_PATH's owner to be<user1, group3>
name|setOwner
argument_list|(
name|FILE_DIR_PATH
argument_list|,
name|USER1
operator|.
name|getShortUserName
argument_list|()
argument_list|,
name|GROUP3_NAME
argument_list|,
literal|false
argument_list|)
expr_stmt|;
comment|// case 3: user1 changes FILE_DIR_PATH's owner to be user2
name|fs
operator|=
name|DFSTestUtil
operator|.
name|login
argument_list|(
name|fs
argument_list|,
name|conf
argument_list|,
name|USER1
argument_list|)
expr_stmt|;
name|setOwner
argument_list|(
name|FILE_DIR_PATH
argument_list|,
name|USER2
operator|.
name|getShortUserName
argument_list|()
argument_list|,
literal|null
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|// case 4: user1 changes FILE_DIR_PATH's group to be group1 which it belongs
comment|// to
name|setOwner
argument_list|(
name|FILE_DIR_PATH
argument_list|,
literal|null
argument_list|,
name|GROUP1_NAME
argument_list|,
literal|false
argument_list|)
expr_stmt|;
comment|// case 5: user1 changes FILE_DIR_PATH's group to be group3
comment|// which it does not belong to
name|setOwner
argument_list|(
name|FILE_DIR_PATH
argument_list|,
literal|null
argument_list|,
name|GROUP3_NAME
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|// case 6: user2 (non-owner) changes FILE_DIR_PATH's group to be group3
name|fs
operator|=
name|DFSTestUtil
operator|.
name|login
argument_list|(
name|fs
argument_list|,
name|conf
argument_list|,
name|USER2
argument_list|)
expr_stmt|;
name|setOwner
argument_list|(
name|FILE_DIR_PATH
argument_list|,
literal|null
argument_list|,
name|GROUP3_NAME
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|// case 7: user2 (non-owner) changes FILE_DIR_PATH's user to be user2
name|setOwner
argument_list|(
name|FILE_DIR_PATH
argument_list|,
name|USER2
operator|.
name|getShortUserName
argument_list|()
argument_list|,
literal|null
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|// delete the file/directory
name|fs
operator|=
name|DFSTestUtil
operator|.
name|login
argument_list|(
name|fs
argument_list|,
name|conf
argument_list|,
name|SUPERUSER
argument_list|)
expr_stmt|;
name|fs
operator|.
name|delete
argument_list|(
name|FILE_DIR_PATH
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/* Return the group owner of the file/directory */
DECL|method|getGroup (Path path)
specifier|private
name|String
name|getGroup
parameter_list|(
name|Path
name|path
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|fs
operator|.
name|getFileStatus
argument_list|(
name|path
argument_list|)
operator|.
name|getGroup
argument_list|()
return|;
block|}
comment|/* Return the file owner of the file/directory */
DECL|method|getOwner (Path path)
specifier|private
name|String
name|getOwner
parameter_list|(
name|Path
name|path
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|fs
operator|.
name|getFileStatus
argument_list|(
name|path
argument_list|)
operator|.
name|getOwner
argument_list|()
return|;
block|}
comment|/* check if ownership is set correctly */
DECL|method|checkOwnership (Path name, String expectedOwner, String expectedGroup)
specifier|private
name|void
name|checkOwnership
parameter_list|(
name|Path
name|name
parameter_list|,
name|String
name|expectedOwner
parameter_list|,
name|String
name|expectedGroup
parameter_list|)
throws|throws
name|IOException
block|{
comment|// check its owner and group
name|FileStatus
name|status
init|=
name|fs
operator|.
name|getFileStatus
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|status
operator|.
name|getOwner
argument_list|()
argument_list|,
name|expectedOwner
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|status
operator|.
name|getGroup
argument_list|()
argument_list|,
name|expectedGroup
argument_list|)
expr_stmt|;
block|}
DECL|field|ANCESTOR_NAME
specifier|final
specifier|static
specifier|private
name|String
name|ANCESTOR_NAME
init|=
literal|"/ancestor"
decl_stmt|;
DECL|field|PARENT_NAME
specifier|final
specifier|static
specifier|private
name|String
name|PARENT_NAME
init|=
literal|"parent"
decl_stmt|;
DECL|field|FILE_NAME
specifier|final
specifier|static
specifier|private
name|String
name|FILE_NAME
init|=
literal|"file"
decl_stmt|;
DECL|field|DIR_NAME
specifier|final
specifier|static
specifier|private
name|String
name|DIR_NAME
init|=
literal|"dir"
decl_stmt|;
DECL|field|FILE_DIR_NAME
specifier|final
specifier|static
specifier|private
name|String
name|FILE_DIR_NAME
init|=
literal|"filedir"
decl_stmt|;
DECL|enum|OpType
DECL|enumConstant|CREATE
DECL|enumConstant|MKDIRS
DECL|enumConstant|OPEN
DECL|enumConstant|SET_REPLICATION
enum|enum
name|OpType
block|{
name|CREATE
block|,
name|MKDIRS
block|,
name|OPEN
block|,
name|SET_REPLICATION
block|,
DECL|enumConstant|GET_FILEINFO
DECL|enumConstant|IS_DIR
DECL|enumConstant|EXISTS
DECL|enumConstant|GET_CONTENT_LENGTH
DECL|enumConstant|LIST
DECL|enumConstant|RENAME
DECL|enumConstant|DELETE
name|GET_FILEINFO
block|,
name|IS_DIR
block|,
name|EXISTS
block|,
name|GET_CONTENT_LENGTH
block|,
name|LIST
block|,
name|RENAME
block|,
name|DELETE
block|}
empty_stmt|;
comment|/* Check if namenode performs permission checking correctly for    * superuser, file owner, group owner, and other users */
annotation|@
name|Test
DECL|method|testPermissionChecking ()
specifier|public
name|void
name|testPermissionChecking
parameter_list|()
throws|throws
name|Exception
block|{
try|try
block|{
name|fs
operator|=
name|FileSystem
operator|.
name|get
argument_list|(
name|conf
argument_list|)
expr_stmt|;
comment|// set the permission of the root to be world-wide rwx
name|fs
operator|.
name|setPermission
argument_list|(
operator|new
name|Path
argument_list|(
literal|"/"
argument_list|)
argument_list|,
operator|new
name|FsPermission
argument_list|(
operator|(
name|short
operator|)
literal|0777
argument_list|)
argument_list|)
expr_stmt|;
comment|// create a directory hierarchy and sets random permission for each inode
name|PermissionGenerator
name|ancestorPermissionGenerator
init|=
operator|new
name|PermissionGenerator
argument_list|(
name|r
argument_list|)
decl_stmt|;
name|PermissionGenerator
name|dirPermissionGenerator
init|=
operator|new
name|PermissionGenerator
argument_list|(
name|r
argument_list|)
decl_stmt|;
name|PermissionGenerator
name|filePermissionGenerator
init|=
operator|new
name|PermissionGenerator
argument_list|(
name|r
argument_list|)
decl_stmt|;
name|short
index|[]
name|ancestorPermissions
init|=
operator|new
name|short
index|[
name|NUM_TEST_PERMISSIONS
index|]
decl_stmt|;
name|short
index|[]
name|parentPermissions
init|=
operator|new
name|short
index|[
name|NUM_TEST_PERMISSIONS
index|]
decl_stmt|;
name|short
index|[]
name|permissions
init|=
operator|new
name|short
index|[
name|NUM_TEST_PERMISSIONS
index|]
decl_stmt|;
name|Path
index|[]
name|ancestorPaths
init|=
operator|new
name|Path
index|[
name|NUM_TEST_PERMISSIONS
index|]
decl_stmt|;
name|Path
index|[]
name|parentPaths
init|=
operator|new
name|Path
index|[
name|NUM_TEST_PERMISSIONS
index|]
decl_stmt|;
name|Path
index|[]
name|filePaths
init|=
operator|new
name|Path
index|[
name|NUM_TEST_PERMISSIONS
index|]
decl_stmt|;
name|Path
index|[]
name|dirPaths
init|=
operator|new
name|Path
index|[
name|NUM_TEST_PERMISSIONS
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|NUM_TEST_PERMISSIONS
condition|;
name|i
operator|++
control|)
block|{
comment|// create ancestor directory
name|ancestorPaths
index|[
name|i
index|]
operator|=
operator|new
name|Path
argument_list|(
name|ANCESTOR_NAME
operator|+
name|i
argument_list|)
expr_stmt|;
name|create
argument_list|(
name|OpType
operator|.
name|MKDIRS
argument_list|,
name|ancestorPaths
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|fs
operator|.
name|setOwner
argument_list|(
name|ancestorPaths
index|[
name|i
index|]
argument_list|,
name|USER1_NAME
argument_list|,
name|GROUP2_NAME
argument_list|)
expr_stmt|;
comment|// create parent directory
name|parentPaths
index|[
name|i
index|]
operator|=
operator|new
name|Path
argument_list|(
name|ancestorPaths
index|[
name|i
index|]
argument_list|,
name|PARENT_NAME
operator|+
name|i
argument_list|)
expr_stmt|;
name|create
argument_list|(
name|OpType
operator|.
name|MKDIRS
argument_list|,
name|parentPaths
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|// change parent directory's ownership to be user1
name|fs
operator|.
name|setOwner
argument_list|(
name|parentPaths
index|[
name|i
index|]
argument_list|,
name|USER1_NAME
argument_list|,
name|GROUP2_NAME
argument_list|)
expr_stmt|;
name|filePaths
index|[
name|i
index|]
operator|=
operator|new
name|Path
argument_list|(
name|parentPaths
index|[
name|i
index|]
argument_list|,
name|FILE_NAME
operator|+
name|i
argument_list|)
expr_stmt|;
name|dirPaths
index|[
name|i
index|]
operator|=
operator|new
name|Path
argument_list|(
name|parentPaths
index|[
name|i
index|]
argument_list|,
name|DIR_NAME
operator|+
name|i
argument_list|)
expr_stmt|;
comment|// makes sure that each inode at the same level
comment|// has a different permission
name|ancestorPermissions
index|[
name|i
index|]
operator|=
name|ancestorPermissionGenerator
operator|.
name|next
argument_list|()
expr_stmt|;
name|parentPermissions
index|[
name|i
index|]
operator|=
name|dirPermissionGenerator
operator|.
name|next
argument_list|()
expr_stmt|;
name|permissions
index|[
name|i
index|]
operator|=
name|filePermissionGenerator
operator|.
name|next
argument_list|()
expr_stmt|;
name|fs
operator|.
name|setPermission
argument_list|(
name|ancestorPaths
index|[
name|i
index|]
argument_list|,
operator|new
name|FsPermission
argument_list|(
name|ancestorPermissions
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|fs
operator|.
name|setPermission
argument_list|(
name|parentPaths
index|[
name|i
index|]
argument_list|,
operator|new
name|FsPermission
argument_list|(
name|parentPermissions
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* file owner */
name|testPermissionCheckingPerUser
argument_list|(
name|USER1
argument_list|,
name|ancestorPermissions
argument_list|,
name|parentPermissions
argument_list|,
name|permissions
argument_list|,
name|parentPaths
argument_list|,
name|filePaths
argument_list|,
name|dirPaths
argument_list|)
expr_stmt|;
comment|/* group owner */
name|testPermissionCheckingPerUser
argument_list|(
name|USER2
argument_list|,
name|ancestorPermissions
argument_list|,
name|parentPermissions
argument_list|,
name|permissions
argument_list|,
name|parentPaths
argument_list|,
name|filePaths
argument_list|,
name|dirPaths
argument_list|)
expr_stmt|;
comment|/* other owner */
name|testPermissionCheckingPerUser
argument_list|(
name|USER3
argument_list|,
name|ancestorPermissions
argument_list|,
name|parentPermissions
argument_list|,
name|permissions
argument_list|,
name|parentPaths
argument_list|,
name|filePaths
argument_list|,
name|dirPaths
argument_list|)
expr_stmt|;
comment|/* super owner */
name|testPermissionCheckingPerUser
argument_list|(
name|SUPERUSER
argument_list|,
name|ancestorPermissions
argument_list|,
name|parentPermissions
argument_list|,
name|permissions
argument_list|,
name|parentPaths
argument_list|,
name|filePaths
argument_list|,
name|dirPaths
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|fs
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Test
DECL|method|testAccessOwner ()
specifier|public
name|void
name|testAccessOwner
parameter_list|()
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|FileSystem
name|rootFs
init|=
name|FileSystem
operator|.
name|get
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|Path
name|p1
init|=
operator|new
name|Path
argument_list|(
literal|"/p1"
argument_list|)
decl_stmt|;
name|rootFs
operator|.
name|mkdirs
argument_list|(
name|p1
argument_list|)
expr_stmt|;
name|rootFs
operator|.
name|setOwner
argument_list|(
name|p1
argument_list|,
name|USER1_NAME
argument_list|,
name|GROUP1_NAME
argument_list|)
expr_stmt|;
name|fs
operator|=
name|USER1
operator|.
name|doAs
argument_list|(
operator|new
name|PrivilegedExceptionAction
argument_list|<
name|FileSystem
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|FileSystem
name|run
parameter_list|()
throws|throws
name|Exception
block|{
return|return
name|FileSystem
operator|.
name|get
argument_list|(
name|conf
argument_list|)
return|;
block|}
block|}
argument_list|)
expr_stmt|;
name|fs
operator|.
name|setPermission
argument_list|(
name|p1
argument_list|,
operator|new
name|FsPermission
argument_list|(
operator|(
name|short
operator|)
literal|0444
argument_list|)
argument_list|)
expr_stmt|;
name|fs
operator|.
name|access
argument_list|(
name|p1
argument_list|,
name|FsAction
operator|.
name|READ
argument_list|)
expr_stmt|;
try|try
block|{
name|fs
operator|.
name|access
argument_list|(
name|p1
argument_list|,
name|FsAction
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"The access call should have failed."
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|AccessControlException
name|e
parameter_list|)
block|{
name|assertTrue
argument_list|(
literal|"Permission denied messages must carry the username"
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
operator|.
name|contains
argument_list|(
name|USER1_NAME
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"Permission denied messages must carry the path parent"
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
operator|.
name|contains
argument_list|(
name|p1
operator|.
name|getParent
argument_list|()
operator|.
name|toUri
argument_list|()
operator|.
name|getPath
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Path
name|badPath
init|=
operator|new
name|Path
argument_list|(
literal|"/bad/bad"
argument_list|)
decl_stmt|;
try|try
block|{
name|fs
operator|.
name|access
argument_list|(
name|badPath
argument_list|,
name|FsAction
operator|.
name|READ
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"The access call should have failed"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|e
parameter_list|)
block|{
comment|// expected
block|}
block|}
annotation|@
name|Test
DECL|method|testAccessGroupMember ()
specifier|public
name|void
name|testAccessGroupMember
parameter_list|()
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|FileSystem
name|rootFs
init|=
name|FileSystem
operator|.
name|get
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|Path
name|p2
init|=
operator|new
name|Path
argument_list|(
literal|"/p2"
argument_list|)
decl_stmt|;
name|rootFs
operator|.
name|mkdirs
argument_list|(
name|p2
argument_list|)
expr_stmt|;
name|rootFs
operator|.
name|setOwner
argument_list|(
name|p2
argument_list|,
name|UserGroupInformation
operator|.
name|getCurrentUser
argument_list|()
operator|.
name|getShortUserName
argument_list|()
argument_list|,
name|GROUP1_NAME
argument_list|)
expr_stmt|;
name|rootFs
operator|.
name|setPermission
argument_list|(
name|p2
argument_list|,
operator|new
name|FsPermission
argument_list|(
operator|(
name|short
operator|)
literal|0740
argument_list|)
argument_list|)
expr_stmt|;
name|fs
operator|=
name|USER1
operator|.
name|doAs
argument_list|(
operator|new
name|PrivilegedExceptionAction
argument_list|<
name|FileSystem
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|FileSystem
name|run
parameter_list|()
throws|throws
name|Exception
block|{
return|return
name|FileSystem
operator|.
name|get
argument_list|(
name|conf
argument_list|)
return|;
block|}
block|}
argument_list|)
expr_stmt|;
name|fs
operator|.
name|access
argument_list|(
name|p2
argument_list|,
name|FsAction
operator|.
name|READ
argument_list|)
expr_stmt|;
try|try
block|{
name|fs
operator|.
name|access
argument_list|(
name|p2
argument_list|,
name|FsAction
operator|.
name|EXECUTE
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"The access call should have failed."
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|AccessControlException
name|e
parameter_list|)
block|{
name|assertTrue
argument_list|(
literal|"Permission denied messages must carry the username"
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
operator|.
name|contains
argument_list|(
name|USER1_NAME
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"Permission denied messages must carry the path parent"
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
operator|.
name|contains
argument_list|(
name|p2
operator|.
name|getParent
argument_list|()
operator|.
name|toUri
argument_list|()
operator|.
name|getPath
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Test
DECL|method|testAccessOthers ()
specifier|public
name|void
name|testAccessOthers
parameter_list|()
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|FileSystem
name|rootFs
init|=
name|FileSystem
operator|.
name|get
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|Path
name|p3
init|=
operator|new
name|Path
argument_list|(
literal|"/p3"
argument_list|)
decl_stmt|;
name|rootFs
operator|.
name|mkdirs
argument_list|(
name|p3
argument_list|)
expr_stmt|;
name|rootFs
operator|.
name|setPermission
argument_list|(
name|p3
argument_list|,
operator|new
name|FsPermission
argument_list|(
operator|(
name|short
operator|)
literal|0774
argument_list|)
argument_list|)
expr_stmt|;
name|fs
operator|=
name|USER1
operator|.
name|doAs
argument_list|(
operator|new
name|PrivilegedExceptionAction
argument_list|<
name|FileSystem
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|FileSystem
name|run
parameter_list|()
throws|throws
name|Exception
block|{
return|return
name|FileSystem
operator|.
name|get
argument_list|(
name|conf
argument_list|)
return|;
block|}
block|}
argument_list|)
expr_stmt|;
name|fs
operator|.
name|access
argument_list|(
name|p3
argument_list|,
name|FsAction
operator|.
name|READ
argument_list|)
expr_stmt|;
try|try
block|{
name|fs
operator|.
name|access
argument_list|(
name|p3
argument_list|,
name|FsAction
operator|.
name|READ_WRITE
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"The access call should have failed."
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|AccessControlException
name|e
parameter_list|)
block|{
name|assertTrue
argument_list|(
literal|"Permission denied messages must carry the username"
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
operator|.
name|contains
argument_list|(
name|USER1_NAME
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"Permission denied messages must carry the path parent"
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
operator|.
name|contains
argument_list|(
name|p3
operator|.
name|getParent
argument_list|()
operator|.
name|toUri
argument_list|()
operator|.
name|getPath
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Test
DECL|method|testPermissionMessageOnNonDirAncestor ()
specifier|public
name|void
name|testPermissionMessageOnNonDirAncestor
parameter_list|()
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|FileSystem
name|rootFs
init|=
name|FileSystem
operator|.
name|get
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|Path
name|p4
init|=
operator|new
name|Path
argument_list|(
literal|"/p4"
argument_list|)
decl_stmt|;
name|rootFs
operator|.
name|mkdirs
argument_list|(
name|p4
argument_list|)
expr_stmt|;
name|rootFs
operator|.
name|setOwner
argument_list|(
name|p4
argument_list|,
name|USER1_NAME
argument_list|,
name|GROUP1_NAME
argument_list|)
expr_stmt|;
specifier|final
name|Path
name|fpath
init|=
operator|new
name|Path
argument_list|(
literal|"/p4/file"
argument_list|)
decl_stmt|;
name|DataOutputStream
name|out
init|=
name|rootFs
operator|.
name|create
argument_list|(
name|fpath
argument_list|)
decl_stmt|;
name|out
operator|.
name|writeBytes
argument_list|(
literal|"dhruba: "
operator|+
name|fpath
argument_list|)
expr_stmt|;
name|out
operator|.
name|close
argument_list|()
expr_stmt|;
name|rootFs
operator|.
name|setOwner
argument_list|(
name|fpath
argument_list|,
name|USER1_NAME
argument_list|,
name|GROUP1_NAME
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|rootFs
operator|.
name|exists
argument_list|(
name|fpath
argument_list|)
argument_list|)
expr_stmt|;
name|fs
operator|=
name|USER1
operator|.
name|doAs
argument_list|(
operator|new
name|PrivilegedExceptionAction
argument_list|<
name|FileSystem
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|FileSystem
name|run
parameter_list|()
throws|throws
name|Exception
block|{
return|return
name|FileSystem
operator|.
name|get
argument_list|(
name|conf
argument_list|)
return|;
block|}
block|}
argument_list|)
expr_stmt|;
specifier|final
name|Path
name|nfpath
init|=
operator|new
name|Path
argument_list|(
literal|"/p4/file/nonexisting"
argument_list|)
decl_stmt|;
name|assertFalse
argument_list|(
name|rootFs
operator|.
name|exists
argument_list|(
name|nfpath
argument_list|)
argument_list|)
expr_stmt|;
try|try
block|{
name|fs
operator|.
name|exists
argument_list|(
name|nfpath
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"The exists call should have failed."
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|AccessControlException
name|e
parameter_list|)
block|{
name|assertTrue
argument_list|(
literal|"Permission denied messages must carry file path"
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
operator|.
name|contains
argument_list|(
name|fpath
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"Permission denied messages must specify existing_file is not "
operator|+
literal|"a directory, when checked on /existing_file/non_existing_name"
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
operator|.
name|contains
argument_list|(
literal|"is not a directory"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|rootFs
operator|.
name|setPermission
argument_list|(
name|p4
argument_list|,
operator|new
name|FsPermission
argument_list|(
literal|"600"
argument_list|)
argument_list|)
expr_stmt|;
try|try
block|{
name|fs
operator|.
name|exists
argument_list|(
name|nfpath
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"The exists call should have failed."
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|AccessControlException
name|e
parameter_list|)
block|{
name|assertFalse
argument_list|(
literal|"Permission denied messages must not carry full file path,"
operator|+
literal|"since the user does not have permission on /p4: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
operator|.
name|contains
argument_list|(
name|fpath
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
literal|"Permission denied messages must not specify /p4"
operator|+
literal|" is not a directory: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
operator|.
name|contains
argument_list|(
literal|"is not a directory"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Check if namenode performs permission checking correctly    * for the given user for operations mkdir, open, setReplication,    * getFileInfo, isDirectory, exists, getContentLength, list, rename,    * and delete */
DECL|method|testPermissionCheckingPerUser (UserGroupInformation ugi, short[] ancestorPermission, short[] parentPermission, short[] filePermission, Path[] parentDirs, Path[] files, Path[] dirs)
specifier|private
name|void
name|testPermissionCheckingPerUser
parameter_list|(
name|UserGroupInformation
name|ugi
parameter_list|,
name|short
index|[]
name|ancestorPermission
parameter_list|,
name|short
index|[]
name|parentPermission
parameter_list|,
name|short
index|[]
name|filePermission
parameter_list|,
name|Path
index|[]
name|parentDirs
parameter_list|,
name|Path
index|[]
name|files
parameter_list|,
name|Path
index|[]
name|dirs
parameter_list|)
throws|throws
name|Exception
block|{
name|boolean
index|[]
name|isDirEmpty
init|=
operator|new
name|boolean
index|[
name|NUM_TEST_PERMISSIONS
index|]
decl_stmt|;
name|fs
operator|=
name|DFSTestUtil
operator|.
name|login
argument_list|(
name|fs
argument_list|,
name|conf
argument_list|,
name|SUPERUSER
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|NUM_TEST_PERMISSIONS
condition|;
name|i
operator|++
control|)
block|{
name|create
argument_list|(
name|OpType
operator|.
name|CREATE
argument_list|,
name|files
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|create
argument_list|(
name|OpType
operator|.
name|MKDIRS
argument_list|,
name|dirs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|fs
operator|.
name|setOwner
argument_list|(
name|files
index|[
name|i
index|]
argument_list|,
name|USER1_NAME
argument_list|,
name|GROUP2_NAME
argument_list|)
expr_stmt|;
name|fs
operator|.
name|setOwner
argument_list|(
name|dirs
index|[
name|i
index|]
argument_list|,
name|USER1_NAME
argument_list|,
name|GROUP2_NAME
argument_list|)
expr_stmt|;
name|checkOwnership
argument_list|(
name|dirs
index|[
name|i
index|]
argument_list|,
name|USER1_NAME
argument_list|,
name|GROUP2_NAME
argument_list|)
expr_stmt|;
name|checkOwnership
argument_list|(
name|files
index|[
name|i
index|]
argument_list|,
name|USER1_NAME
argument_list|,
name|GROUP2_NAME
argument_list|)
expr_stmt|;
name|FsPermission
name|fsPermission
init|=
operator|new
name|FsPermission
argument_list|(
name|filePermission
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|fs
operator|.
name|setPermission
argument_list|(
name|files
index|[
name|i
index|]
argument_list|,
name|fsPermission
argument_list|)
expr_stmt|;
name|fs
operator|.
name|setPermission
argument_list|(
name|dirs
index|[
name|i
index|]
argument_list|,
name|fsPermission
argument_list|)
expr_stmt|;
name|isDirEmpty
index|[
name|i
index|]
operator|=
operator|(
name|fs
operator|.
name|listStatus
argument_list|(
name|dirs
index|[
name|i
index|]
argument_list|)
operator|.
name|length
operator|==
literal|0
operator|)
expr_stmt|;
block|}
name|fs
operator|=
name|DFSTestUtil
operator|.
name|login
argument_list|(
name|fs
argument_list|,
name|conf
argument_list|,
name|ugi
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|NUM_TEST_PERMISSIONS
condition|;
name|i
operator|++
control|)
block|{
name|testCreateMkdirs
argument_list|(
name|ugi
argument_list|,
operator|new
name|Path
argument_list|(
name|parentDirs
index|[
name|i
index|]
argument_list|,
name|FILE_DIR_NAME
argument_list|)
argument_list|,
name|ancestorPermission
index|[
name|i
index|]
argument_list|,
name|parentPermission
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|testOpen
argument_list|(
name|ugi
argument_list|,
name|files
index|[
name|i
index|]
argument_list|,
name|ancestorPermission
index|[
name|i
index|]
argument_list|,
name|parentPermission
index|[
name|i
index|]
argument_list|,
name|filePermission
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|testSetReplication
argument_list|(
name|ugi
argument_list|,
name|files
index|[
name|i
index|]
argument_list|,
name|ancestorPermission
index|[
name|i
index|]
argument_list|,
name|parentPermission
index|[
name|i
index|]
argument_list|,
name|filePermission
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|testSetTimes
argument_list|(
name|ugi
argument_list|,
name|files
index|[
name|i
index|]
argument_list|,
name|ancestorPermission
index|[
name|i
index|]
argument_list|,
name|parentPermission
index|[
name|i
index|]
argument_list|,
name|filePermission
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|testStats
argument_list|(
name|ugi
argument_list|,
name|files
index|[
name|i
index|]
argument_list|,
name|ancestorPermission
index|[
name|i
index|]
argument_list|,
name|parentPermission
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|testList
argument_list|(
name|ugi
argument_list|,
name|files
index|[
name|i
index|]
argument_list|,
name|dirs
index|[
name|i
index|]
argument_list|,
name|ancestorPermission
index|[
name|i
index|]
argument_list|,
name|parentPermission
index|[
name|i
index|]
argument_list|,
name|filePermission
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|int
name|next
init|=
name|i
operator|==
name|NUM_TEST_PERMISSIONS
operator|-
literal|1
condition|?
literal|0
else|:
name|i
operator|+
literal|1
decl_stmt|;
name|testRename
argument_list|(
name|ugi
argument_list|,
name|files
index|[
name|i
index|]
argument_list|,
name|files
index|[
name|next
index|]
argument_list|,
name|ancestorPermission
index|[
name|i
index|]
argument_list|,
name|parentPermission
index|[
name|i
index|]
argument_list|,
name|ancestorPermission
index|[
name|next
index|]
argument_list|,
name|parentPermission
index|[
name|next
index|]
argument_list|)
expr_stmt|;
name|testDeleteFile
argument_list|(
name|ugi
argument_list|,
name|files
index|[
name|i
index|]
argument_list|,
name|ancestorPermission
index|[
name|i
index|]
argument_list|,
name|parentPermission
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|testDeleteDir
argument_list|(
name|ugi
argument_list|,
name|dirs
index|[
name|i
index|]
argument_list|,
name|ancestorPermission
index|[
name|i
index|]
argument_list|,
name|parentPermission
index|[
name|i
index|]
argument_list|,
name|filePermission
index|[
name|i
index|]
argument_list|,
literal|null
argument_list|,
name|isDirEmpty
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|// test non existent file
name|checkNonExistentFile
argument_list|()
expr_stmt|;
block|}
comment|/* A random permission generator that guarantees that each permission    * value is generated only once.    */
DECL|class|PermissionGenerator
specifier|static
class|class
name|PermissionGenerator
block|{
DECL|field|r
specifier|private
specifier|final
name|Random
name|r
decl_stmt|;
DECL|field|permissions
specifier|private
specifier|final
name|short
index|[]
name|permissions
init|=
operator|new
name|short
index|[
name|MAX_PERMISSION
operator|+
literal|1
index|]
decl_stmt|;
DECL|field|numLeft
specifier|private
name|int
name|numLeft
init|=
name|MAX_PERMISSION
operator|+
literal|1
decl_stmt|;
DECL|method|PermissionGenerator (Random r)
name|PermissionGenerator
parameter_list|(
name|Random
name|r
parameter_list|)
block|{
name|this
operator|.
name|r
operator|=
name|r
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<=
name|MAX_PERMISSION
condition|;
name|i
operator|++
control|)
block|{
name|permissions
index|[
name|i
index|]
operator|=
operator|(
name|short
operator|)
name|i
expr_stmt|;
block|}
block|}
DECL|method|next ()
name|short
name|next
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|numLeft
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"No more permission is avaialbe"
argument_list|)
throw|;
block|}
name|int
name|index
init|=
name|r
operator|.
name|nextInt
argument_list|(
name|numLeft
argument_list|)
decl_stmt|;
comment|// choose which permission to return
name|numLeft
operator|--
expr_stmt|;
comment|// decrement the counter
comment|// swap the chosen permission with last available permission in the array
name|short
name|temp
init|=
name|permissions
index|[
name|numLeft
index|]
decl_stmt|;
name|permissions
index|[
name|numLeft
index|]
operator|=
name|permissions
index|[
name|index
index|]
expr_stmt|;
name|permissions
index|[
name|index
index|]
operator|=
name|temp
expr_stmt|;
return|return
name|permissions
index|[
name|numLeft
index|]
return|;
block|}
block|}
comment|/* A base class that verifies the permission checking is correct     * for an operation */
DECL|class|PermissionVerifier
specifier|abstract
class|class
name|PermissionVerifier
block|{
DECL|field|path
specifier|protected
name|Path
name|path
decl_stmt|;
DECL|field|ancestorPermission
specifier|protected
name|short
name|ancestorPermission
decl_stmt|;
DECL|field|parentPermission
specifier|protected
name|short
name|parentPermission
decl_stmt|;
DECL|field|permission
specifier|private
name|short
name|permission
decl_stmt|;
DECL|field|requiredAncestorPermission
specifier|protected
name|short
name|requiredAncestorPermission
decl_stmt|;
DECL|field|requiredParentPermission
specifier|protected
name|short
name|requiredParentPermission
decl_stmt|;
DECL|field|requiredPermission
specifier|protected
name|short
name|requiredPermission
decl_stmt|;
DECL|field|opAncestorPermission
specifier|final
specifier|static
specifier|protected
name|short
name|opAncestorPermission
init|=
name|SEARCH_MASK
decl_stmt|;
DECL|field|opParentPermission
specifier|protected
name|short
name|opParentPermission
decl_stmt|;
DECL|field|opPermission
specifier|protected
name|short
name|opPermission
decl_stmt|;
DECL|field|ugi
specifier|protected
name|UserGroupInformation
name|ugi
decl_stmt|;
comment|/* initialize */
DECL|method|set (Path path, short ancestorPermission, short parentPermission, short permission)
specifier|protected
name|void
name|set
parameter_list|(
name|Path
name|path
parameter_list|,
name|short
name|ancestorPermission
parameter_list|,
name|short
name|parentPermission
parameter_list|,
name|short
name|permission
parameter_list|)
block|{
name|this
operator|.
name|path
operator|=
name|path
expr_stmt|;
name|this
operator|.
name|ancestorPermission
operator|=
name|ancestorPermission
expr_stmt|;
name|this
operator|.
name|parentPermission
operator|=
name|parentPermission
expr_stmt|;
name|this
operator|.
name|permission
operator|=
name|permission
expr_stmt|;
name|setOpPermission
argument_list|()
expr_stmt|;
name|this
operator|.
name|ugi
operator|=
literal|null
expr_stmt|;
block|}
comment|/* Perform an operation and verify if the permission checking is correct */
DECL|method|verifyPermission (UserGroupInformation ugi)
name|void
name|verifyPermission
parameter_list|(
name|UserGroupInformation
name|ugi
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|this
operator|.
name|ugi
operator|!=
name|ugi
condition|)
block|{
name|setRequiredPermissions
argument_list|(
name|ugi
argument_list|)
expr_stmt|;
name|this
operator|.
name|ugi
operator|=
name|ugi
expr_stmt|;
block|}
try|try
block|{
try|try
block|{
name|call
argument_list|()
expr_stmt|;
name|assertFalse
argument_list|(
name|expectPermissionDeny
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|AccessControlException
name|e
parameter_list|)
block|{
name|assertTrue
argument_list|(
name|expectPermissionDeny
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|AssertionError
name|ae
parameter_list|)
block|{
name|logPermissions
argument_list|()
expr_stmt|;
throw|throw
name|ae
throw|;
block|}
block|}
comment|/** Log the permissions and required permissions */
DECL|method|logPermissions ()
specifier|protected
name|void
name|logPermissions
parameter_list|()
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"required ancestor permission:"
operator|+
name|Integer
operator|.
name|toOctalString
argument_list|(
name|requiredAncestorPermission
argument_list|)
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"ancestor permission: "
operator|+
name|Integer
operator|.
name|toOctalString
argument_list|(
name|ancestorPermission
argument_list|)
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"required parent permission:"
operator|+
name|Integer
operator|.
name|toOctalString
argument_list|(
name|requiredParentPermission
argument_list|)
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"parent permission: "
operator|+
name|Integer
operator|.
name|toOctalString
argument_list|(
name|parentPermission
argument_list|)
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"required permission:"
operator|+
name|Integer
operator|.
name|toOctalString
argument_list|(
name|requiredPermission
argument_list|)
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"permission: "
operator|+
name|Integer
operator|.
name|toOctalString
argument_list|(
name|permission
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Return true if an AccessControlException is expected */
DECL|method|expectPermissionDeny ()
specifier|protected
name|boolean
name|expectPermissionDeny
parameter_list|()
block|{
return|return
operator|(
name|requiredPermission
operator|&
name|permission
operator|)
operator|!=
name|requiredPermission
operator|||
operator|(
name|requiredParentPermission
operator|&
name|parentPermission
operator|)
operator|!=
name|requiredParentPermission
operator|||
operator|(
name|requiredAncestorPermission
operator|&
name|ancestorPermission
operator|)
operator|!=
name|requiredAncestorPermission
return|;
block|}
comment|/* Set the permissions required to pass the permission checking */
DECL|method|setRequiredPermissions (UserGroupInformation ugi)
specifier|protected
name|void
name|setRequiredPermissions
parameter_list|(
name|UserGroupInformation
name|ugi
parameter_list|)
block|{
if|if
condition|(
name|SUPERUSER
operator|.
name|equals
argument_list|(
name|ugi
argument_list|)
condition|)
block|{
name|requiredAncestorPermission
operator|=
name|SUPER_MASK
expr_stmt|;
name|requiredParentPermission
operator|=
name|SUPER_MASK
expr_stmt|;
name|requiredPermission
operator|=
name|SUPER_MASK
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|USER1
operator|.
name|equals
argument_list|(
name|ugi
argument_list|)
condition|)
block|{
name|requiredAncestorPermission
operator|=
call|(
name|short
call|)
argument_list|(
name|opAncestorPermission
operator|&
name|OWNER_MASK
argument_list|)
expr_stmt|;
name|requiredParentPermission
operator|=
call|(
name|short
call|)
argument_list|(
name|opParentPermission
operator|&
name|OWNER_MASK
argument_list|)
expr_stmt|;
name|requiredPermission
operator|=
call|(
name|short
call|)
argument_list|(
name|opPermission
operator|&
name|OWNER_MASK
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|USER2
operator|.
name|equals
argument_list|(
name|ugi
argument_list|)
condition|)
block|{
name|requiredAncestorPermission
operator|=
call|(
name|short
call|)
argument_list|(
name|opAncestorPermission
operator|&
name|GROUP_MASK
argument_list|)
expr_stmt|;
name|requiredParentPermission
operator|=
call|(
name|short
call|)
argument_list|(
name|opParentPermission
operator|&
name|GROUP_MASK
argument_list|)
expr_stmt|;
name|requiredPermission
operator|=
call|(
name|short
call|)
argument_list|(
name|opPermission
operator|&
name|GROUP_MASK
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|USER3
operator|.
name|equals
argument_list|(
name|ugi
argument_list|)
condition|)
block|{
name|requiredAncestorPermission
operator|=
call|(
name|short
call|)
argument_list|(
name|opAncestorPermission
operator|&
name|OTHER_MASK
argument_list|)
expr_stmt|;
name|requiredParentPermission
operator|=
call|(
name|short
call|)
argument_list|(
name|opParentPermission
operator|&
name|OTHER_MASK
argument_list|)
expr_stmt|;
name|requiredPermission
operator|=
call|(
name|short
call|)
argument_list|(
name|opPermission
operator|&
name|OTHER_MASK
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Non-supported user: "
operator|+
name|ugi
argument_list|)
throw|;
block|}
block|}
comment|/* Set the rwx permissions required for the operation */
DECL|method|setOpPermission ()
specifier|abstract
name|void
name|setOpPermission
parameter_list|()
function_decl|;
comment|/* Perform the operation */
DECL|method|call ()
specifier|abstract
name|void
name|call
parameter_list|()
throws|throws
name|IOException
function_decl|;
block|}
DECL|field|SUPER_MASK
specifier|final
specifier|static
specifier|private
name|short
name|SUPER_MASK
init|=
literal|0
decl_stmt|;
DECL|field|READ_MASK
specifier|final
specifier|static
specifier|private
name|short
name|READ_MASK
init|=
literal|0444
decl_stmt|;
DECL|field|WRITE_MASK
specifier|final
specifier|static
specifier|private
name|short
name|WRITE_MASK
init|=
literal|0222
decl_stmt|;
DECL|field|SEARCH_MASK
specifier|final
specifier|static
specifier|private
name|short
name|SEARCH_MASK
init|=
literal|0111
decl_stmt|;
DECL|field|NULL_MASK
specifier|final
specifier|static
specifier|private
name|short
name|NULL_MASK
init|=
literal|0
decl_stmt|;
DECL|field|OWNER_MASK
specifier|final
specifier|static
specifier|private
name|short
name|OWNER_MASK
init|=
literal|0700
decl_stmt|;
DECL|field|GROUP_MASK
specifier|final
specifier|static
specifier|private
name|short
name|GROUP_MASK
init|=
literal|0070
decl_stmt|;
DECL|field|OTHER_MASK
specifier|final
specifier|static
specifier|private
name|short
name|OTHER_MASK
init|=
literal|0007
decl_stmt|;
comment|/* A class that verifies the permission checking is correct for create/mkdir*/
DECL|class|CreatePermissionVerifier
specifier|private
class|class
name|CreatePermissionVerifier
extends|extends
name|PermissionVerifier
block|{
DECL|field|opType
specifier|private
name|OpType
name|opType
decl_stmt|;
DECL|field|cleanup
specifier|private
name|boolean
name|cleanup
init|=
literal|true
decl_stmt|;
comment|/* initialize */
DECL|method|set (Path path, OpType opType, short ancestorPermission, short parentPermission)
specifier|protected
name|void
name|set
parameter_list|(
name|Path
name|path
parameter_list|,
name|OpType
name|opType
parameter_list|,
name|short
name|ancestorPermission
parameter_list|,
name|short
name|parentPermission
parameter_list|)
block|{
name|super
operator|.
name|set
argument_list|(
name|path
argument_list|,
name|ancestorPermission
argument_list|,
name|parentPermission
argument_list|,
name|NULL_MASK
argument_list|)
expr_stmt|;
name|setOpType
argument_list|(
name|opType
argument_list|)
expr_stmt|;
block|}
DECL|method|setCleanup (boolean cleanup)
name|void
name|setCleanup
parameter_list|(
name|boolean
name|cleanup
parameter_list|)
block|{
name|this
operator|.
name|cleanup
operator|=
name|cleanup
expr_stmt|;
block|}
comment|/* set if the operation mkdir/create */
DECL|method|setOpType (OpType opType)
name|void
name|setOpType
parameter_list|(
name|OpType
name|opType
parameter_list|)
block|{
name|this
operator|.
name|opType
operator|=
name|opType
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|setOpPermission ()
name|void
name|setOpPermission
parameter_list|()
block|{
name|this
operator|.
name|opParentPermission
operator|=
name|SEARCH_MASK
operator||
name|WRITE_MASK
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|call ()
name|void
name|call
parameter_list|()
throws|throws
name|IOException
block|{
name|create
argument_list|(
name|opType
argument_list|,
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|cleanup
condition|)
block|{
name|fs
operator|.
name|delete
argument_list|(
name|path
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|field|createVerifier
specifier|private
specifier|final
name|CreatePermissionVerifier
name|createVerifier
init|=
operator|new
name|CreatePermissionVerifier
argument_list|()
decl_stmt|;
comment|/* test if the permission checking of create/mkdir is correct */
DECL|method|testCreateMkdirs (UserGroupInformation ugi, Path path, short ancestorPermission, short parentPermission)
specifier|private
name|void
name|testCreateMkdirs
parameter_list|(
name|UserGroupInformation
name|ugi
parameter_list|,
name|Path
name|path
parameter_list|,
name|short
name|ancestorPermission
parameter_list|,
name|short
name|parentPermission
parameter_list|)
throws|throws
name|Exception
block|{
name|createVerifier
operator|.
name|set
argument_list|(
name|path
argument_list|,
name|OpType
operator|.
name|MKDIRS
argument_list|,
name|ancestorPermission
argument_list|,
name|parentPermission
argument_list|)
expr_stmt|;
name|createVerifier
operator|.
name|verifyPermission
argument_list|(
name|ugi
argument_list|)
expr_stmt|;
name|createVerifier
operator|.
name|setOpType
argument_list|(
name|OpType
operator|.
name|CREATE
argument_list|)
expr_stmt|;
name|createVerifier
operator|.
name|setCleanup
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|createVerifier
operator|.
name|verifyPermission
argument_list|(
name|ugi
argument_list|)
expr_stmt|;
name|createVerifier
operator|.
name|setCleanup
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|createVerifier
operator|.
name|verifyPermission
argument_list|(
name|ugi
argument_list|)
expr_stmt|;
comment|// test overWritten
block|}
comment|/* A class that verifies the permission checking is correct for open */
DECL|class|OpenPermissionVerifier
specifier|private
class|class
name|OpenPermissionVerifier
extends|extends
name|PermissionVerifier
block|{
annotation|@
name|Override
DECL|method|setOpPermission ()
name|void
name|setOpPermission
parameter_list|()
block|{
name|this
operator|.
name|opParentPermission
operator|=
name|SEARCH_MASK
expr_stmt|;
name|this
operator|.
name|opPermission
operator|=
name|READ_MASK
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|call ()
name|void
name|call
parameter_list|()
throws|throws
name|IOException
block|{
name|FSDataInputStream
name|in
init|=
name|fs
operator|.
name|open
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|in
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
DECL|field|openVerifier
specifier|private
specifier|final
name|OpenPermissionVerifier
name|openVerifier
init|=
operator|new
name|OpenPermissionVerifier
argument_list|()
decl_stmt|;
comment|/* test if the permission checking of open is correct */
DECL|method|testOpen (UserGroupInformation ugi, Path path, short ancestorPermission, short parentPermission, short filePermission)
specifier|private
name|void
name|testOpen
parameter_list|(
name|UserGroupInformation
name|ugi
parameter_list|,
name|Path
name|path
parameter_list|,
name|short
name|ancestorPermission
parameter_list|,
name|short
name|parentPermission
parameter_list|,
name|short
name|filePermission
parameter_list|)
throws|throws
name|Exception
block|{
name|openVerifier
operator|.
name|set
argument_list|(
name|path
argument_list|,
name|ancestorPermission
argument_list|,
name|parentPermission
argument_list|,
name|filePermission
argument_list|)
expr_stmt|;
name|openVerifier
operator|.
name|verifyPermission
argument_list|(
name|ugi
argument_list|)
expr_stmt|;
block|}
comment|/* A class that verifies the permission checking is correct for     * setReplication */
DECL|class|SetReplicationPermissionVerifier
specifier|private
class|class
name|SetReplicationPermissionVerifier
extends|extends
name|PermissionVerifier
block|{
annotation|@
name|Override
DECL|method|setOpPermission ()
name|void
name|setOpPermission
parameter_list|()
block|{
name|this
operator|.
name|opParentPermission
operator|=
name|SEARCH_MASK
expr_stmt|;
name|this
operator|.
name|opPermission
operator|=
name|WRITE_MASK
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|call ()
name|void
name|call
parameter_list|()
throws|throws
name|IOException
block|{
name|fs
operator|.
name|setReplication
argument_list|(
name|path
argument_list|,
operator|(
name|short
operator|)
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
DECL|field|replicatorVerifier
specifier|private
specifier|final
name|SetReplicationPermissionVerifier
name|replicatorVerifier
init|=
operator|new
name|SetReplicationPermissionVerifier
argument_list|()
decl_stmt|;
comment|/* test if the permission checking of setReplication is correct */
DECL|method|testSetReplication (UserGroupInformation ugi, Path path, short ancestorPermission, short parentPermission, short filePermission)
specifier|private
name|void
name|testSetReplication
parameter_list|(
name|UserGroupInformation
name|ugi
parameter_list|,
name|Path
name|path
parameter_list|,
name|short
name|ancestorPermission
parameter_list|,
name|short
name|parentPermission
parameter_list|,
name|short
name|filePermission
parameter_list|)
throws|throws
name|Exception
block|{
name|replicatorVerifier
operator|.
name|set
argument_list|(
name|path
argument_list|,
name|ancestorPermission
argument_list|,
name|parentPermission
argument_list|,
name|filePermission
argument_list|)
expr_stmt|;
name|replicatorVerifier
operator|.
name|verifyPermission
argument_list|(
name|ugi
argument_list|)
expr_stmt|;
block|}
comment|/* A class that verifies the permission checking is correct for     * setTimes */
DECL|class|SetTimesPermissionVerifier
specifier|private
class|class
name|SetTimesPermissionVerifier
extends|extends
name|PermissionVerifier
block|{
annotation|@
name|Override
DECL|method|setOpPermission ()
name|void
name|setOpPermission
parameter_list|()
block|{
name|this
operator|.
name|opParentPermission
operator|=
name|SEARCH_MASK
expr_stmt|;
name|this
operator|.
name|opPermission
operator|=
name|WRITE_MASK
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|call ()
name|void
name|call
parameter_list|()
throws|throws
name|IOException
block|{
name|fs
operator|.
name|setTimes
argument_list|(
name|path
argument_list|,
literal|100
argument_list|,
literal|100
argument_list|)
expr_stmt|;
name|fs
operator|.
name|setTimes
argument_list|(
name|path
argument_list|,
operator|-
literal|1
argument_list|,
literal|100
argument_list|)
expr_stmt|;
name|fs
operator|.
name|setTimes
argument_list|(
name|path
argument_list|,
literal|100
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
DECL|field|timesVerifier
specifier|private
specifier|final
name|SetTimesPermissionVerifier
name|timesVerifier
init|=
operator|new
name|SetTimesPermissionVerifier
argument_list|()
decl_stmt|;
comment|/* test if the permission checking of setReplication is correct */
DECL|method|testSetTimes (UserGroupInformation ugi, Path path, short ancestorPermission, short parentPermission, short filePermission)
specifier|private
name|void
name|testSetTimes
parameter_list|(
name|UserGroupInformation
name|ugi
parameter_list|,
name|Path
name|path
parameter_list|,
name|short
name|ancestorPermission
parameter_list|,
name|short
name|parentPermission
parameter_list|,
name|short
name|filePermission
parameter_list|)
throws|throws
name|Exception
block|{
name|timesVerifier
operator|.
name|set
argument_list|(
name|path
argument_list|,
name|ancestorPermission
argument_list|,
name|parentPermission
argument_list|,
name|filePermission
argument_list|)
expr_stmt|;
name|timesVerifier
operator|.
name|verifyPermission
argument_list|(
name|ugi
argument_list|)
expr_stmt|;
block|}
comment|/* A class that verifies the permission checking is correct for isDirectory,    * exist,  getFileInfo, getContentSummary */
DECL|class|StatsPermissionVerifier
specifier|private
class|class
name|StatsPermissionVerifier
extends|extends
name|PermissionVerifier
block|{
DECL|field|opType
name|OpType
name|opType
decl_stmt|;
comment|/* initialize */
DECL|method|set (Path path, OpType opType, short ancestorPermission, short parentPermission)
name|void
name|set
parameter_list|(
name|Path
name|path
parameter_list|,
name|OpType
name|opType
parameter_list|,
name|short
name|ancestorPermission
parameter_list|,
name|short
name|parentPermission
parameter_list|)
block|{
name|super
operator|.
name|set
argument_list|(
name|path
argument_list|,
name|ancestorPermission
argument_list|,
name|parentPermission
argument_list|,
name|NULL_MASK
argument_list|)
expr_stmt|;
name|setOpType
argument_list|(
name|opType
argument_list|)
expr_stmt|;
block|}
comment|/* set if operation is getFileInfo, isDirectory, exist, getContenSummary */
DECL|method|setOpType (OpType opType)
name|void
name|setOpType
parameter_list|(
name|OpType
name|opType
parameter_list|)
block|{
name|this
operator|.
name|opType
operator|=
name|opType
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|setOpPermission ()
name|void
name|setOpPermission
parameter_list|()
block|{
name|this
operator|.
name|opParentPermission
operator|=
name|SEARCH_MASK
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|call ()
name|void
name|call
parameter_list|()
throws|throws
name|IOException
block|{
switch|switch
condition|(
name|opType
condition|)
block|{
case|case
name|GET_FILEINFO
case|:
name|fs
operator|.
name|getFileStatus
argument_list|(
name|path
argument_list|)
expr_stmt|;
break|break;
case|case
name|IS_DIR
case|:
name|fs
operator|.
name|isDirectory
argument_list|(
name|path
argument_list|)
expr_stmt|;
break|break;
case|case
name|EXISTS
case|:
name|fs
operator|.
name|exists
argument_list|(
name|path
argument_list|)
expr_stmt|;
break|break;
case|case
name|GET_CONTENT_LENGTH
case|:
name|fs
operator|.
name|getContentSummary
argument_list|(
name|path
argument_list|)
operator|.
name|getLength
argument_list|()
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Unexpected operation type: "
operator|+
name|opType
argument_list|)
throw|;
block|}
block|}
block|}
DECL|field|statsVerifier
specifier|private
specifier|final
name|StatsPermissionVerifier
name|statsVerifier
init|=
operator|new
name|StatsPermissionVerifier
argument_list|()
decl_stmt|;
comment|/* test if the permission checking of isDirectory, exist,    * getFileInfo, getContentSummary is correct */
DECL|method|testStats (UserGroupInformation ugi, Path path, short ancestorPermission, short parentPermission)
specifier|private
name|void
name|testStats
parameter_list|(
name|UserGroupInformation
name|ugi
parameter_list|,
name|Path
name|path
parameter_list|,
name|short
name|ancestorPermission
parameter_list|,
name|short
name|parentPermission
parameter_list|)
throws|throws
name|Exception
block|{
name|statsVerifier
operator|.
name|set
argument_list|(
name|path
argument_list|,
name|OpType
operator|.
name|GET_FILEINFO
argument_list|,
name|ancestorPermission
argument_list|,
name|parentPermission
argument_list|)
expr_stmt|;
name|statsVerifier
operator|.
name|verifyPermission
argument_list|(
name|ugi
argument_list|)
expr_stmt|;
name|statsVerifier
operator|.
name|setOpType
argument_list|(
name|OpType
operator|.
name|IS_DIR
argument_list|)
expr_stmt|;
name|statsVerifier
operator|.
name|verifyPermission
argument_list|(
name|ugi
argument_list|)
expr_stmt|;
name|statsVerifier
operator|.
name|setOpType
argument_list|(
name|OpType
operator|.
name|EXISTS
argument_list|)
expr_stmt|;
name|statsVerifier
operator|.
name|verifyPermission
argument_list|(
name|ugi
argument_list|)
expr_stmt|;
name|statsVerifier
operator|.
name|setOpType
argument_list|(
name|OpType
operator|.
name|GET_CONTENT_LENGTH
argument_list|)
expr_stmt|;
name|statsVerifier
operator|.
name|verifyPermission
argument_list|(
name|ugi
argument_list|)
expr_stmt|;
block|}
DECL|enum|InodeType
specifier|private
enum|enum
name|InodeType
block|{
DECL|enumConstant|FILE
DECL|enumConstant|DIR
name|FILE
block|,
name|DIR
block|}
empty_stmt|;
comment|/* A class that verifies the permission checking is correct for list */
DECL|class|ListPermissionVerifier
specifier|private
class|class
name|ListPermissionVerifier
extends|extends
name|PermissionVerifier
block|{
DECL|field|inodeType
specifier|private
name|InodeType
name|inodeType
decl_stmt|;
comment|/* initialize */
DECL|method|set (Path path, InodeType inodeType, short ancestorPermission, short parentPermission, short permission)
name|void
name|set
parameter_list|(
name|Path
name|path
parameter_list|,
name|InodeType
name|inodeType
parameter_list|,
name|short
name|ancestorPermission
parameter_list|,
name|short
name|parentPermission
parameter_list|,
name|short
name|permission
parameter_list|)
block|{
name|this
operator|.
name|inodeType
operator|=
name|inodeType
expr_stmt|;
name|super
operator|.
name|set
argument_list|(
name|path
argument_list|,
name|ancestorPermission
argument_list|,
name|parentPermission
argument_list|,
name|permission
argument_list|)
expr_stmt|;
block|}
comment|/* set if the given path is a file/directory */
DECL|method|setInodeType (Path path, InodeType inodeType)
name|void
name|setInodeType
parameter_list|(
name|Path
name|path
parameter_list|,
name|InodeType
name|inodeType
parameter_list|)
block|{
name|this
operator|.
name|path
operator|=
name|path
expr_stmt|;
name|this
operator|.
name|inodeType
operator|=
name|inodeType
expr_stmt|;
name|setOpPermission
argument_list|()
expr_stmt|;
name|this
operator|.
name|ugi
operator|=
literal|null
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|setOpPermission ()
name|void
name|setOpPermission
parameter_list|()
block|{
name|this
operator|.
name|opParentPermission
operator|=
name|SEARCH_MASK
expr_stmt|;
switch|switch
condition|(
name|inodeType
condition|)
block|{
case|case
name|FILE
case|:
name|this
operator|.
name|opPermission
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|DIR
case|:
name|this
operator|.
name|opPermission
operator|=
name|READ_MASK
operator||
name|SEARCH_MASK
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Illegal inode type: "
operator|+
name|inodeType
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
DECL|method|call ()
name|void
name|call
parameter_list|()
throws|throws
name|IOException
block|{
name|fs
operator|.
name|listStatus
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
block|}
DECL|field|listVerifier
specifier|final
name|ListPermissionVerifier
name|listVerifier
init|=
operator|new
name|ListPermissionVerifier
argument_list|()
decl_stmt|;
comment|/* test if the permission checking of list is correct */
DECL|method|testList (UserGroupInformation ugi, Path file, Path dir, short ancestorPermission, short parentPermission, short filePermission)
specifier|private
name|void
name|testList
parameter_list|(
name|UserGroupInformation
name|ugi
parameter_list|,
name|Path
name|file
parameter_list|,
name|Path
name|dir
parameter_list|,
name|short
name|ancestorPermission
parameter_list|,
name|short
name|parentPermission
parameter_list|,
name|short
name|filePermission
parameter_list|)
throws|throws
name|Exception
block|{
name|listVerifier
operator|.
name|set
argument_list|(
name|file
argument_list|,
name|InodeType
operator|.
name|FILE
argument_list|,
name|ancestorPermission
argument_list|,
name|parentPermission
argument_list|,
name|filePermission
argument_list|)
expr_stmt|;
name|listVerifier
operator|.
name|verifyPermission
argument_list|(
name|ugi
argument_list|)
expr_stmt|;
name|listVerifier
operator|.
name|setInodeType
argument_list|(
name|dir
argument_list|,
name|InodeType
operator|.
name|DIR
argument_list|)
expr_stmt|;
name|listVerifier
operator|.
name|verifyPermission
argument_list|(
name|ugi
argument_list|)
expr_stmt|;
block|}
comment|/* A class that verifies the permission checking is correct for rename */
DECL|class|RenamePermissionVerifier
specifier|private
class|class
name|RenamePermissionVerifier
extends|extends
name|PermissionVerifier
block|{
DECL|field|dst
specifier|private
name|Path
name|dst
decl_stmt|;
DECL|field|dstAncestorPermission
specifier|private
name|short
name|dstAncestorPermission
decl_stmt|;
DECL|field|dstParentPermission
specifier|private
name|short
name|dstParentPermission
decl_stmt|;
comment|/* initialize */
DECL|method|set (Path src, short srcAncestorPermission, short srcParentPermission, Path dst, short dstAncestorPermission, short dstParentPermission)
name|void
name|set
parameter_list|(
name|Path
name|src
parameter_list|,
name|short
name|srcAncestorPermission
parameter_list|,
name|short
name|srcParentPermission
parameter_list|,
name|Path
name|dst
parameter_list|,
name|short
name|dstAncestorPermission
parameter_list|,
name|short
name|dstParentPermission
parameter_list|)
block|{
name|super
operator|.
name|set
argument_list|(
name|src
argument_list|,
name|srcAncestorPermission
argument_list|,
name|srcParentPermission
argument_list|,
name|NULL_MASK
argument_list|)
expr_stmt|;
name|this
operator|.
name|dst
operator|=
name|dst
expr_stmt|;
name|this
operator|.
name|dstAncestorPermission
operator|=
name|dstAncestorPermission
expr_stmt|;
name|this
operator|.
name|dstParentPermission
operator|=
name|dstParentPermission
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|setOpPermission ()
name|void
name|setOpPermission
parameter_list|()
block|{
name|opParentPermission
operator|=
name|SEARCH_MASK
operator||
name|WRITE_MASK
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|call ()
name|void
name|call
parameter_list|()
throws|throws
name|IOException
block|{
name|fs
operator|.
name|rename
argument_list|(
name|path
argument_list|,
name|dst
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|expectPermissionDeny ()
specifier|protected
name|boolean
name|expectPermissionDeny
parameter_list|()
block|{
return|return
name|super
operator|.
name|expectPermissionDeny
argument_list|()
operator|||
operator|(
name|requiredParentPermission
operator|&
name|dstParentPermission
operator|)
operator|!=
name|requiredParentPermission
operator|||
operator|(
name|requiredAncestorPermission
operator|&
name|dstAncestorPermission
operator|)
operator|!=
name|requiredAncestorPermission
return|;
block|}
annotation|@
name|Override
DECL|method|logPermissions ()
specifier|protected
name|void
name|logPermissions
parameter_list|()
block|{
name|super
operator|.
name|logPermissions
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"dst ancestor permission: "
operator|+
name|Integer
operator|.
name|toOctalString
argument_list|(
name|dstAncestorPermission
argument_list|)
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"dst parent permission: "
operator|+
name|Integer
operator|.
name|toOctalString
argument_list|(
name|dstParentPermission
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
DECL|field|renameVerifier
specifier|final
name|RenamePermissionVerifier
name|renameVerifier
init|=
operator|new
name|RenamePermissionVerifier
argument_list|()
decl_stmt|;
comment|/* test if the permission checking of rename is correct */
DECL|method|testRename (UserGroupInformation ugi, Path src, Path dst, short srcAncestorPermission, short srcParentPermission, short dstAncestorPermission, short dstParentPermission)
specifier|private
name|void
name|testRename
parameter_list|(
name|UserGroupInformation
name|ugi
parameter_list|,
name|Path
name|src
parameter_list|,
name|Path
name|dst
parameter_list|,
name|short
name|srcAncestorPermission
parameter_list|,
name|short
name|srcParentPermission
parameter_list|,
name|short
name|dstAncestorPermission
parameter_list|,
name|short
name|dstParentPermission
parameter_list|)
throws|throws
name|Exception
block|{
name|renameVerifier
operator|.
name|set
argument_list|(
name|src
argument_list|,
name|srcAncestorPermission
argument_list|,
name|srcParentPermission
argument_list|,
name|dst
argument_list|,
name|dstAncestorPermission
argument_list|,
name|dstParentPermission
argument_list|)
expr_stmt|;
name|renameVerifier
operator|.
name|verifyPermission
argument_list|(
name|ugi
argument_list|)
expr_stmt|;
block|}
comment|/* A class that verifies the permission checking is correct for delete */
DECL|class|DeletePermissionVerifier
specifier|private
class|class
name|DeletePermissionVerifier
extends|extends
name|PermissionVerifier
block|{
DECL|method|set (Path path, short ancestorPermission, short parentPermission)
name|void
name|set
parameter_list|(
name|Path
name|path
parameter_list|,
name|short
name|ancestorPermission
parameter_list|,
name|short
name|parentPermission
parameter_list|)
block|{
name|super
operator|.
name|set
argument_list|(
name|path
argument_list|,
name|ancestorPermission
argument_list|,
name|parentPermission
argument_list|,
name|NULL_MASK
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|setOpPermission ()
name|void
name|setOpPermission
parameter_list|()
block|{
name|this
operator|.
name|opParentPermission
operator|=
name|SEARCH_MASK
operator||
name|WRITE_MASK
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|call ()
name|void
name|call
parameter_list|()
throws|throws
name|IOException
block|{
name|fs
operator|.
name|delete
argument_list|(
name|path
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* A class that verifies the permission checking is correct for    * directory deletion    */
DECL|class|DeleteDirPermissionVerifier
specifier|private
class|class
name|DeleteDirPermissionVerifier
extends|extends
name|DeletePermissionVerifier
block|{
DECL|field|childPermissions
specifier|private
name|short
index|[]
name|childPermissions
decl_stmt|;
comment|/* initialize */
DECL|method|set (Path path, short ancestorPermission, short parentPermission, short permission, short[] childPermissions)
name|void
name|set
parameter_list|(
name|Path
name|path
parameter_list|,
name|short
name|ancestorPermission
parameter_list|,
name|short
name|parentPermission
parameter_list|,
name|short
name|permission
parameter_list|,
name|short
index|[]
name|childPermissions
parameter_list|)
block|{
name|set
argument_list|(
name|path
argument_list|,
name|ancestorPermission
argument_list|,
name|parentPermission
argument_list|,
name|permission
argument_list|)
expr_stmt|;
name|this
operator|.
name|childPermissions
operator|=
name|childPermissions
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|setOpPermission ()
name|void
name|setOpPermission
parameter_list|()
block|{
name|this
operator|.
name|opParentPermission
operator|=
name|SEARCH_MASK
operator||
name|WRITE_MASK
expr_stmt|;
name|this
operator|.
name|opPermission
operator|=
name|SEARCH_MASK
operator||
name|WRITE_MASK
operator||
name|READ_MASK
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|expectPermissionDeny ()
specifier|protected
name|boolean
name|expectPermissionDeny
parameter_list|()
block|{
if|if
condition|(
name|super
operator|.
name|expectPermissionDeny
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
else|else
block|{
if|if
condition|(
name|childPermissions
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|short
name|childPermission
range|:
name|childPermissions
control|)
block|{
if|if
condition|(
operator|(
name|requiredPermission
operator|&
name|childPermission
operator|)
operator|!=
name|requiredPermission
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
block|}
return|return
literal|false
return|;
block|}
block|}
block|}
comment|/* A class that verifies the permission checking is correct for    * empty-directory deletion    */
DECL|class|DeleteEmptyDirPermissionVerifier
specifier|private
class|class
name|DeleteEmptyDirPermissionVerifier
extends|extends
name|DeleteDirPermissionVerifier
block|{
annotation|@
name|Override
DECL|method|setOpPermission ()
name|void
name|setOpPermission
parameter_list|()
block|{
name|this
operator|.
name|opParentPermission
operator|=
name|SEARCH_MASK
operator||
name|WRITE_MASK
expr_stmt|;
name|this
operator|.
name|opPermission
operator|=
name|NULL_MASK
expr_stmt|;
block|}
block|}
DECL|field|fileDeletionVerifier
specifier|final
name|DeletePermissionVerifier
name|fileDeletionVerifier
init|=
operator|new
name|DeletePermissionVerifier
argument_list|()
decl_stmt|;
comment|/* test if the permission checking of file deletion is correct */
DECL|method|testDeleteFile (UserGroupInformation ugi, Path file, short ancestorPermission, short parentPermission)
specifier|private
name|void
name|testDeleteFile
parameter_list|(
name|UserGroupInformation
name|ugi
parameter_list|,
name|Path
name|file
parameter_list|,
name|short
name|ancestorPermission
parameter_list|,
name|short
name|parentPermission
parameter_list|)
throws|throws
name|Exception
block|{
name|fileDeletionVerifier
operator|.
name|set
argument_list|(
name|file
argument_list|,
name|ancestorPermission
argument_list|,
name|parentPermission
argument_list|)
expr_stmt|;
name|fileDeletionVerifier
operator|.
name|verifyPermission
argument_list|(
name|ugi
argument_list|)
expr_stmt|;
block|}
DECL|field|dirDeletionVerifier
specifier|final
name|DeleteDirPermissionVerifier
name|dirDeletionVerifier
init|=
operator|new
name|DeleteDirPermissionVerifier
argument_list|()
decl_stmt|;
DECL|field|emptyDirDeletionVerifier
specifier|final
name|DeleteEmptyDirPermissionVerifier
name|emptyDirDeletionVerifier
init|=
operator|new
name|DeleteEmptyDirPermissionVerifier
argument_list|()
decl_stmt|;
comment|/* test if the permission checking of directory deletion is correct */
DECL|method|testDeleteDir (UserGroupInformation ugi, Path path, short ancestorPermission, short parentPermission, short permission, short[] childPermissions, final boolean isDirEmpty)
specifier|private
name|void
name|testDeleteDir
parameter_list|(
name|UserGroupInformation
name|ugi
parameter_list|,
name|Path
name|path
parameter_list|,
name|short
name|ancestorPermission
parameter_list|,
name|short
name|parentPermission
parameter_list|,
name|short
name|permission
parameter_list|,
name|short
index|[]
name|childPermissions
parameter_list|,
specifier|final
name|boolean
name|isDirEmpty
parameter_list|)
throws|throws
name|Exception
block|{
name|DeleteDirPermissionVerifier
name|ddpv
init|=
name|isDirEmpty
condition|?
name|emptyDirDeletionVerifier
else|:
name|dirDeletionVerifier
decl_stmt|;
name|ddpv
operator|.
name|set
argument_list|(
name|path
argument_list|,
name|ancestorPermission
argument_list|,
name|parentPermission
argument_list|,
name|permission
argument_list|,
name|childPermissions
argument_list|)
expr_stmt|;
name|ddpv
operator|.
name|verifyPermission
argument_list|(
name|ugi
argument_list|)
expr_stmt|;
block|}
comment|/* test non-existent file */
DECL|method|checkNonExistentFile ()
specifier|private
name|void
name|checkNonExistentFile
parameter_list|()
block|{
try|try
block|{
name|assertFalse
argument_list|(
name|fs
operator|.
name|exists
argument_list|(
name|NON_EXISTENT_FILE
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|checkNoPermissionDeny
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|fs
operator|.
name|open
argument_list|(
name|NON_EXISTENT_FILE
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|checkNoPermissionDeny
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|fs
operator|.
name|setReplication
argument_list|(
name|NON_EXISTENT_FILE
argument_list|,
operator|(
name|short
operator|)
literal|4
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|checkNoPermissionDeny
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|fs
operator|.
name|getFileStatus
argument_list|(
name|NON_EXISTENT_FILE
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|checkNoPermissionDeny
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|fs
operator|.
name|getContentSummary
argument_list|(
name|NON_EXISTENT_FILE
argument_list|)
operator|.
name|getLength
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|checkNoPermissionDeny
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|fs
operator|.
name|listStatus
argument_list|(
name|NON_EXISTENT_FILE
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|checkNoPermissionDeny
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|fs
operator|.
name|delete
argument_list|(
name|NON_EXISTENT_FILE
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|checkNoPermissionDeny
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|fs
operator|.
name|rename
argument_list|(
name|NON_EXISTENT_FILE
argument_list|,
operator|new
name|Path
argument_list|(
name|NON_EXISTENT_FILE
operator|+
literal|".txt"
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|checkNoPermissionDeny
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|checkNoPermissionDeny (IOException e)
specifier|private
name|void
name|checkNoPermissionDeny
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|assertFalse
argument_list|(
name|e
operator|instanceof
name|AccessControlException
argument_list|)
expr_stmt|;
block|}
block|}
end_class

end_unit

