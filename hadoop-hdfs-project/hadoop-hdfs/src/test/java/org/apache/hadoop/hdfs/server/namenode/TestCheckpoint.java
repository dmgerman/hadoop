begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdfs.server.namenode
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|Util
operator|.
name|fileAsURI
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|FSImageTestUtil
operator|.
name|assertNNHasCheckpoints
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|FSImageTestUtil
operator|.
name|getNameNodeCurrentDirs
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertEquals
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertFalse
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertNotNull
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertNull
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertTrue
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|fail
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|management
operator|.
name|ManagementFactory
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|management
operator|.
name|ThreadInfo
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|management
operator|.
name|ThreadMXBean
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|InetSocketAddress
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URI
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|cli
operator|.
name|ParseException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|impl
operator|.
name|Log4JLogger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|CommonConfigurationKeysPublic
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FSDataOutputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSTestUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DistributedFileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|HdfsConfiguration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|MiniDFSCluster
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|MiniDFSNNTopology
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|HdfsConstants
operator|.
name|SafeModeAction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|HdfsServerConstants
operator|.
name|StartupOption
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|Storage
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|Storage
operator|.
name|StorageDirectory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|StorageInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|FileJournalManager
operator|.
name|EditLogFile
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|NNStorage
operator|.
name|NameNodeDirType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|SecondaryNameNode
operator|.
name|CheckpointStorage
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|NamenodeProtocol
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|NamenodeProtocols
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|RemoteEditLog
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|RemoteEditLogManifest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|tools
operator|.
name|DFSAdmin
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|Text
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|net
operator|.
name|NetUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|test
operator|.
name|GenericTestUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|test
operator|.
name|GenericTestUtils
operator|.
name|DelayAnswer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|test
operator|.
name|GenericTestUtils
operator|.
name|LogCapturer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|ExitUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|ExitUtil
operator|.
name|ExitException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|log4j
operator|.
name|Level
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|After
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Before
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Test
import|;
end_import

begin_import
import|import
name|org
operator|.
name|mockito
operator|.
name|ArgumentMatcher
import|;
end_import

begin_import
import|import
name|org
operator|.
name|mockito
operator|.
name|Mockito
import|;
end_import

begin_import
import|import
name|org
operator|.
name|mockito
operator|.
name|invocation
operator|.
name|InvocationOnMock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|mockito
operator|.
name|stubbing
operator|.
name|Answer
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Joiner
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Supplier
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableSet
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|primitives
operator|.
name|Ints
import|;
end_import

begin_comment
comment|/**  * This class tests the creation and validation of a checkpoint.  */
end_comment

begin_class
DECL|class|TestCheckpoint
specifier|public
class|class
name|TestCheckpoint
block|{
static|static
block|{
operator|(
operator|(
name|Log4JLogger
operator|)
name|FSImage
operator|.
name|LOG
operator|)
operator|.
name|getLogger
argument_list|()
operator|.
name|setLevel
argument_list|(
name|Level
operator|.
name|ALL
argument_list|)
expr_stmt|;
block|}
DECL|field|LOG
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|TestCheckpoint
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|seed
specifier|static
specifier|final
name|long
name|seed
init|=
literal|0xDEADBEEFL
decl_stmt|;
DECL|field|blockSize
specifier|static
specifier|final
name|int
name|blockSize
init|=
literal|4096
decl_stmt|;
DECL|field|fileSize
specifier|static
specifier|final
name|int
name|fileSize
init|=
literal|8192
decl_stmt|;
DECL|field|numDatanodes
specifier|static
specifier|final
name|int
name|numDatanodes
init|=
literal|3
decl_stmt|;
DECL|field|replication
name|short
name|replication
init|=
literal|3
decl_stmt|;
DECL|field|faultInjector
specifier|private
name|CheckpointFaultInjector
name|faultInjector
decl_stmt|;
annotation|@
name|Before
DECL|method|setUp ()
specifier|public
name|void
name|setUp
parameter_list|()
throws|throws
name|IOException
block|{
name|FileUtil
operator|.
name|fullyDeleteContents
argument_list|(
operator|new
name|File
argument_list|(
name|MiniDFSCluster
operator|.
name|getBaseDirectory
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|faultInjector
operator|=
name|Mockito
operator|.
name|mock
argument_list|(
name|CheckpointFaultInjector
operator|.
name|class
argument_list|)
expr_stmt|;
name|CheckpointFaultInjector
operator|.
name|instance
operator|=
name|faultInjector
expr_stmt|;
block|}
annotation|@
name|After
DECL|method|checkForSNNThreads ()
specifier|public
name|void
name|checkForSNNThreads
parameter_list|()
block|{
name|ThreadMXBean
name|threadBean
init|=
name|ManagementFactory
operator|.
name|getThreadMXBean
argument_list|()
decl_stmt|;
name|ThreadInfo
index|[]
name|infos
init|=
name|threadBean
operator|.
name|getThreadInfo
argument_list|(
name|threadBean
operator|.
name|getAllThreadIds
argument_list|()
argument_list|,
literal|20
argument_list|)
decl_stmt|;
for|for
control|(
name|ThreadInfo
name|info
range|:
name|infos
control|)
block|{
if|if
condition|(
name|info
operator|==
literal|null
condition|)
continue|continue;
name|LOG
operator|.
name|info
argument_list|(
literal|"Check thread: "
operator|+
name|info
operator|.
name|getThreadName
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|.
name|getThreadName
argument_list|()
operator|.
name|contains
argument_list|(
literal|"SecondaryNameNode"
argument_list|)
condition|)
block|{
name|fail
argument_list|(
literal|"Leaked thread: "
operator|+
name|info
operator|+
literal|"\n"
operator|+
name|Joiner
operator|.
name|on
argument_list|(
literal|"\n"
argument_list|)
operator|.
name|join
argument_list|(
name|info
operator|.
name|getStackTrace
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"--------"
argument_list|)
expr_stmt|;
block|}
DECL|method|checkFile (FileSystem fileSys, Path name, int repl)
specifier|static
name|void
name|checkFile
parameter_list|(
name|FileSystem
name|fileSys
parameter_list|,
name|Path
name|name
parameter_list|,
name|int
name|repl
parameter_list|)
throws|throws
name|IOException
block|{
name|assertTrue
argument_list|(
name|fileSys
operator|.
name|exists
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|int
name|replication
init|=
name|fileSys
operator|.
name|getFileStatus
argument_list|(
name|name
argument_list|)
operator|.
name|getReplication
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
literal|"replication for "
operator|+
name|name
argument_list|,
name|repl
argument_list|,
name|replication
argument_list|)
expr_stmt|;
comment|//We should probably test for more of the file properties.
block|}
DECL|method|cleanupFile (FileSystem fileSys, Path name)
specifier|static
name|void
name|cleanupFile
parameter_list|(
name|FileSystem
name|fileSys
parameter_list|,
name|Path
name|name
parameter_list|)
throws|throws
name|IOException
block|{
name|assertTrue
argument_list|(
name|fileSys
operator|.
name|exists
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|fileSys
operator|.
name|delete
argument_list|(
name|name
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
operator|!
name|fileSys
operator|.
name|exists
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/*    * Verify that namenode does not startup if one namedir is bad.    */
annotation|@
name|Test
DECL|method|testNameDirError ()
specifier|public
name|void
name|testNameDirError
parameter_list|()
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Starting testNameDirError"
argument_list|)
expr_stmt|;
name|Configuration
name|conf
init|=
operator|new
name|HdfsConfiguration
argument_list|()
decl_stmt|;
name|MiniDFSCluster
name|cluster
init|=
operator|new
name|MiniDFSCluster
operator|.
name|Builder
argument_list|(
name|conf
argument_list|)
operator|.
name|numDataNodes
argument_list|(
literal|0
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|Collection
argument_list|<
name|URI
argument_list|>
name|nameDirs
init|=
name|cluster
operator|.
name|getNameDirs
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|cluster
operator|.
name|shutdown
argument_list|()
expr_stmt|;
name|cluster
operator|=
literal|null
expr_stmt|;
for|for
control|(
name|URI
name|nameDirUri
range|:
name|nameDirs
control|)
block|{
name|File
name|dir
init|=
operator|new
name|File
argument_list|(
name|nameDirUri
operator|.
name|getPath
argument_list|()
argument_list|)
decl_stmt|;
try|try
block|{
comment|// Simulate the mount going read-only
name|dir
operator|.
name|setWritable
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|cluster
operator|=
operator|new
name|MiniDFSCluster
operator|.
name|Builder
argument_list|(
name|conf
argument_list|)
operator|.
name|numDataNodes
argument_list|(
literal|0
argument_list|)
operator|.
name|format
argument_list|(
literal|false
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
name|fail
argument_list|(
literal|"NN should have failed to start with "
operator|+
name|dir
operator|+
literal|" set unreadable"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|GenericTestUtils
operator|.
name|assertExceptionContains
argument_list|(
literal|"storage directory does not exist or is not accessible"
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|cluster
operator|!=
literal|null
condition|)
block|{
name|cluster
operator|.
name|shutdown
argument_list|()
expr_stmt|;
name|cluster
operator|=
literal|null
expr_stmt|;
block|}
name|dir
operator|.
name|setWritable
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Checks that an IOException in NNStorage.writeTransactionIdFile is handled    * correctly (by removing the storage directory)    * See https://issues.apache.org/jira/browse/HDFS-2011    */
annotation|@
name|Test
DECL|method|testWriteTransactionIdHandlesIOE ()
specifier|public
name|void
name|testWriteTransactionIdHandlesIOE
parameter_list|()
throws|throws
name|Exception
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Check IOException handled correctly by writeTransactionIdFile"
argument_list|)
expr_stmt|;
name|ArrayList
argument_list|<
name|URI
argument_list|>
name|fsImageDirs
init|=
operator|new
name|ArrayList
argument_list|<
name|URI
argument_list|>
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|URI
argument_list|>
name|editsDirs
init|=
operator|new
name|ArrayList
argument_list|<
name|URI
argument_list|>
argument_list|()
decl_stmt|;
name|File
name|filePath
init|=
operator|new
name|File
argument_list|(
name|System
operator|.
name|getProperty
argument_list|(
literal|"test.build.data"
argument_list|,
literal|"/tmp"
argument_list|)
argument_list|,
literal|"storageDirToCheck"
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
literal|"Couldn't create directory storageDirToCheck"
argument_list|,
name|filePath
operator|.
name|exists
argument_list|()
operator|||
name|filePath
operator|.
name|mkdirs
argument_list|()
argument_list|)
expr_stmt|;
name|fsImageDirs
operator|.
name|add
argument_list|(
name|filePath
operator|.
name|toURI
argument_list|()
argument_list|)
expr_stmt|;
name|editsDirs
operator|.
name|add
argument_list|(
name|filePath
operator|.
name|toURI
argument_list|()
argument_list|)
expr_stmt|;
name|NNStorage
name|nnStorage
init|=
operator|new
name|NNStorage
argument_list|(
operator|new
name|HdfsConfiguration
argument_list|()
argument_list|,
name|fsImageDirs
argument_list|,
name|editsDirs
argument_list|)
decl_stmt|;
try|try
block|{
name|assertTrue
argument_list|(
literal|"List of storage directories didn't have storageDirToCheck."
argument_list|,
name|nnStorage
operator|.
name|getEditsDirectories
argument_list|()
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
operator|.
name|toString
argument_list|()
operator|.
name|indexOf
argument_list|(
literal|"storageDirToCheck"
argument_list|)
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"List of removed storage directories wasn't empty"
argument_list|,
name|nnStorage
operator|.
name|getRemovedStorageDirs
argument_list|()
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
comment|// Delete storage directory to cause IOException in writeTransactionIdFile
name|assertTrue
argument_list|(
literal|"Couldn't remove directory "
operator|+
name|filePath
operator|.
name|getAbsolutePath
argument_list|()
argument_list|,
name|filePath
operator|.
name|delete
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Just call writeTransactionIdFile using any random number
name|nnStorage
operator|.
name|writeTransactionIdFileToStorage
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|StorageDirectory
argument_list|>
name|listRsd
init|=
name|nnStorage
operator|.
name|getRemovedStorageDirs
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
literal|"Removed directory wasn't what was expected"
argument_list|,
name|listRsd
operator|.
name|size
argument_list|()
operator|>
literal|0
operator|&&
name|listRsd
operator|.
name|get
argument_list|(
name|listRsd
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
operator|.
name|getRoot
argument_list|()
operator|.
name|toString
argument_list|()
operator|.
name|indexOf
argument_list|(
literal|"storageDirToCheck"
argument_list|)
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/*    * Simulate exception during edit replay.    */
annotation|@
name|Test
argument_list|(
name|timeout
operator|=
literal|30000
argument_list|)
DECL|method|testReloadOnEditReplayFailure ()
specifier|public
name|void
name|testReloadOnEditReplayFailure
parameter_list|()
throws|throws
name|IOException
block|{
name|Configuration
name|conf
init|=
operator|new
name|HdfsConfiguration
argument_list|()
decl_stmt|;
name|FSDataOutputStream
name|fos
init|=
literal|null
decl_stmt|;
name|SecondaryNameNode
name|secondary
init|=
literal|null
decl_stmt|;
name|MiniDFSCluster
name|cluster
init|=
literal|null
decl_stmt|;
name|FileSystem
name|fs
init|=
literal|null
decl_stmt|;
try|try
block|{
name|cluster
operator|=
operator|new
name|MiniDFSCluster
operator|.
name|Builder
argument_list|(
name|conf
argument_list|)
operator|.
name|numDataNodes
argument_list|(
name|numDatanodes
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
name|cluster
operator|.
name|waitActive
argument_list|()
expr_stmt|;
name|fs
operator|=
name|cluster
operator|.
name|getFileSystem
argument_list|()
expr_stmt|;
name|secondary
operator|=
name|startSecondaryNameNode
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|fos
operator|=
name|fs
operator|.
name|create
argument_list|(
operator|new
name|Path
argument_list|(
literal|"tmpfile0"
argument_list|)
argument_list|)
expr_stmt|;
name|fos
operator|.
name|write
argument_list|(
operator|new
name|byte
index|[]
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|3
block|}
argument_list|)
expr_stmt|;
name|secondary
operator|.
name|doCheckpoint
argument_list|()
expr_stmt|;
name|fos
operator|.
name|write
argument_list|(
operator|new
name|byte
index|[]
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|3
block|}
argument_list|)
expr_stmt|;
name|fos
operator|.
name|hsync
argument_list|()
expr_stmt|;
comment|// Cause merge to fail in next checkpoint.
name|Mockito
operator|.
name|doThrow
argument_list|(
operator|new
name|IOException
argument_list|(
literal|"Injecting failure during merge"
argument_list|)
argument_list|)
operator|.
name|when
argument_list|(
name|faultInjector
argument_list|)
operator|.
name|duringMerge
argument_list|()
expr_stmt|;
try|try
block|{
name|secondary
operator|.
name|doCheckpoint
argument_list|()
expr_stmt|;
name|fail
argument_list|(
literal|"Fault injection failed."
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
comment|// This is expected.
block|}
name|Mockito
operator|.
name|reset
argument_list|(
name|faultInjector
argument_list|)
expr_stmt|;
comment|// The error must be recorded, so next checkpoint will reload image.
name|fos
operator|.
name|write
argument_list|(
operator|new
name|byte
index|[]
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|3
block|}
argument_list|)
expr_stmt|;
name|fos
operator|.
name|hsync
argument_list|()
expr_stmt|;
name|assertTrue
argument_list|(
literal|"Another checkpoint should have reloaded image"
argument_list|,
name|secondary
operator|.
name|doCheckpoint
argument_list|()
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|secondary
operator|!=
literal|null
condition|)
block|{
name|secondary
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|fs
operator|!=
literal|null
condition|)
block|{
name|fs
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|cluster
operator|!=
literal|null
condition|)
block|{
name|cluster
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
name|Mockito
operator|.
name|reset
argument_list|(
name|faultInjector
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*    * Simulate 2NN exit due to too many merge failures.    */
annotation|@
name|Test
argument_list|(
name|timeout
operator|=
literal|10000
argument_list|)
DECL|method|testTooManyEditReplayFailures ()
specifier|public
name|void
name|testTooManyEditReplayFailures
parameter_list|()
throws|throws
name|IOException
block|{
name|Configuration
name|conf
init|=
operator|new
name|HdfsConfiguration
argument_list|()
decl_stmt|;
name|conf
operator|.
name|set
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_CHECKPOINT_MAX_RETRIES_KEY
argument_list|,
literal|"1"
argument_list|)
expr_stmt|;
name|conf
operator|.
name|set
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_CHECKPOINT_CHECK_PERIOD_KEY
argument_list|,
literal|"1"
argument_list|)
expr_stmt|;
name|FSDataOutputStream
name|fos
init|=
literal|null
decl_stmt|;
name|SecondaryNameNode
name|secondary
init|=
literal|null
decl_stmt|;
name|MiniDFSCluster
name|cluster
init|=
literal|null
decl_stmt|;
name|FileSystem
name|fs
init|=
literal|null
decl_stmt|;
try|try
block|{
name|cluster
operator|=
operator|new
name|MiniDFSCluster
operator|.
name|Builder
argument_list|(
name|conf
argument_list|)
operator|.
name|numDataNodes
argument_list|(
name|numDatanodes
argument_list|)
operator|.
name|checkExitOnShutdown
argument_list|(
literal|false
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
name|cluster
operator|.
name|waitActive
argument_list|()
expr_stmt|;
name|fs
operator|=
name|cluster
operator|.
name|getFileSystem
argument_list|()
expr_stmt|;
name|fos
operator|=
name|fs
operator|.
name|create
argument_list|(
operator|new
name|Path
argument_list|(
literal|"tmpfile0"
argument_list|)
argument_list|)
expr_stmt|;
name|fos
operator|.
name|write
argument_list|(
operator|new
name|byte
index|[]
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|3
block|}
argument_list|)
expr_stmt|;
comment|// Cause merge to fail in next checkpoint.
name|Mockito
operator|.
name|doThrow
argument_list|(
operator|new
name|IOException
argument_list|(
literal|"Injecting failure during merge"
argument_list|)
argument_list|)
operator|.
name|when
argument_list|(
name|faultInjector
argument_list|)
operator|.
name|duringMerge
argument_list|()
expr_stmt|;
name|secondary
operator|=
name|startSecondaryNameNode
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|secondary
operator|.
name|doWork
argument_list|()
expr_stmt|;
comment|// Fail if we get here.
name|fail
argument_list|(
literal|"2NN did not exit."
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ExitException
name|ee
parameter_list|)
block|{
comment|// ignore
name|ExitUtil
operator|.
name|resetFirstExitException
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Max retries"
argument_list|,
literal|1
argument_list|,
name|secondary
operator|.
name|getMergeErrorCount
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|secondary
operator|!=
literal|null
condition|)
block|{
name|secondary
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|fs
operator|!=
literal|null
condition|)
block|{
name|fs
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|cluster
operator|!=
literal|null
condition|)
block|{
name|cluster
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
name|Mockito
operator|.
name|reset
argument_list|(
name|faultInjector
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*    * Simulate namenode crashing after rolling edit log.    */
annotation|@
name|Test
DECL|method|testSecondaryNamenodeError1 ()
specifier|public
name|void
name|testSecondaryNamenodeError1
parameter_list|()
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Starting testSecondaryNamenodeError1"
argument_list|)
expr_stmt|;
name|Configuration
name|conf
init|=
operator|new
name|HdfsConfiguration
argument_list|()
decl_stmt|;
name|Path
name|file1
init|=
operator|new
name|Path
argument_list|(
literal|"checkpointxx.dat"
argument_list|)
decl_stmt|;
name|MiniDFSCluster
name|cluster
init|=
operator|new
name|MiniDFSCluster
operator|.
name|Builder
argument_list|(
name|conf
argument_list|)
operator|.
name|numDataNodes
argument_list|(
name|numDatanodes
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|cluster
operator|.
name|waitActive
argument_list|()
expr_stmt|;
name|FileSystem
name|fileSys
init|=
name|cluster
operator|.
name|getFileSystem
argument_list|()
decl_stmt|;
try|try
block|{
name|assertTrue
argument_list|(
operator|!
name|fileSys
operator|.
name|exists
argument_list|(
name|file1
argument_list|)
argument_list|)
expr_stmt|;
comment|//
comment|// Make the checkpoint fail after rolling the edits log.
comment|//
name|SecondaryNameNode
name|secondary
init|=
name|startSecondaryNameNode
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|Mockito
operator|.
name|doThrow
argument_list|(
operator|new
name|IOException
argument_list|(
literal|"Injecting failure after rolling edit logs"
argument_list|)
argument_list|)
operator|.
name|when
argument_list|(
name|faultInjector
argument_list|)
operator|.
name|afterSecondaryCallsRollEditLog
argument_list|()
expr_stmt|;
try|try
block|{
name|secondary
operator|.
name|doCheckpoint
argument_list|()
expr_stmt|;
comment|// this should fail
name|assertTrue
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{       }
name|Mockito
operator|.
name|reset
argument_list|(
name|faultInjector
argument_list|)
expr_stmt|;
name|secondary
operator|.
name|shutdown
argument_list|()
expr_stmt|;
comment|//
comment|// Create a new file
comment|//
name|DFSTestUtil
operator|.
name|createFile
argument_list|(
name|fileSys
argument_list|,
name|file1
argument_list|,
name|fileSize
argument_list|,
name|fileSize
argument_list|,
name|blockSize
argument_list|,
name|replication
argument_list|,
name|seed
argument_list|)
expr_stmt|;
name|checkFile
argument_list|(
name|fileSys
argument_list|,
name|file1
argument_list|,
name|replication
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|fileSys
operator|.
name|close
argument_list|()
expr_stmt|;
name|cluster
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
comment|//
comment|// Restart cluster and verify that file exists.
comment|// Then take another checkpoint to verify that the
comment|// namenode restart accounted for the rolled edit logs.
comment|//
name|cluster
operator|=
operator|new
name|MiniDFSCluster
operator|.
name|Builder
argument_list|(
name|conf
argument_list|)
operator|.
name|numDataNodes
argument_list|(
name|numDatanodes
argument_list|)
operator|.
name|format
argument_list|(
literal|false
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
name|cluster
operator|.
name|waitActive
argument_list|()
expr_stmt|;
name|fileSys
operator|=
name|cluster
operator|.
name|getFileSystem
argument_list|()
expr_stmt|;
try|try
block|{
name|checkFile
argument_list|(
name|fileSys
argument_list|,
name|file1
argument_list|,
name|replication
argument_list|)
expr_stmt|;
name|cleanupFile
argument_list|(
name|fileSys
argument_list|,
name|file1
argument_list|)
expr_stmt|;
name|SecondaryNameNode
name|secondary
init|=
name|startSecondaryNameNode
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|secondary
operator|.
name|doCheckpoint
argument_list|()
expr_stmt|;
name|secondary
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|fileSys
operator|.
name|close
argument_list|()
expr_stmt|;
name|cluster
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
block|}
comment|/*    * Simulate a namenode crash after uploading new image    */
annotation|@
name|Test
DECL|method|testSecondaryNamenodeError2 ()
specifier|public
name|void
name|testSecondaryNamenodeError2
parameter_list|()
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Starting testSecondaryNamenodeError2"
argument_list|)
expr_stmt|;
name|Configuration
name|conf
init|=
operator|new
name|HdfsConfiguration
argument_list|()
decl_stmt|;
name|Path
name|file1
init|=
operator|new
name|Path
argument_list|(
literal|"checkpointyy.dat"
argument_list|)
decl_stmt|;
name|MiniDFSCluster
name|cluster
init|=
operator|new
name|MiniDFSCluster
operator|.
name|Builder
argument_list|(
name|conf
argument_list|)
operator|.
name|numDataNodes
argument_list|(
name|numDatanodes
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|cluster
operator|.
name|waitActive
argument_list|()
expr_stmt|;
name|FileSystem
name|fileSys
init|=
name|cluster
operator|.
name|getFileSystem
argument_list|()
decl_stmt|;
try|try
block|{
name|assertTrue
argument_list|(
operator|!
name|fileSys
operator|.
name|exists
argument_list|(
name|file1
argument_list|)
argument_list|)
expr_stmt|;
comment|//
comment|// Make the checkpoint fail after uploading the new fsimage.
comment|//
name|SecondaryNameNode
name|secondary
init|=
name|startSecondaryNameNode
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|Mockito
operator|.
name|doThrow
argument_list|(
operator|new
name|IOException
argument_list|(
literal|"Injecting failure after uploading new image"
argument_list|)
argument_list|)
operator|.
name|when
argument_list|(
name|faultInjector
argument_list|)
operator|.
name|afterSecondaryUploadsNewImage
argument_list|()
expr_stmt|;
try|try
block|{
name|secondary
operator|.
name|doCheckpoint
argument_list|()
expr_stmt|;
comment|// this should fail
name|assertTrue
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{       }
name|Mockito
operator|.
name|reset
argument_list|(
name|faultInjector
argument_list|)
expr_stmt|;
name|secondary
operator|.
name|shutdown
argument_list|()
expr_stmt|;
comment|//
comment|// Create a new file
comment|//
name|DFSTestUtil
operator|.
name|createFile
argument_list|(
name|fileSys
argument_list|,
name|file1
argument_list|,
name|fileSize
argument_list|,
name|fileSize
argument_list|,
name|blockSize
argument_list|,
name|replication
argument_list|,
name|seed
argument_list|)
expr_stmt|;
name|checkFile
argument_list|(
name|fileSys
argument_list|,
name|file1
argument_list|,
name|replication
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|fileSys
operator|.
name|close
argument_list|()
expr_stmt|;
name|cluster
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
comment|//
comment|// Restart cluster and verify that file exists.
comment|// Then take another checkpoint to verify that the
comment|// namenode restart accounted for the rolled edit logs.
comment|//
name|cluster
operator|=
operator|new
name|MiniDFSCluster
operator|.
name|Builder
argument_list|(
name|conf
argument_list|)
operator|.
name|numDataNodes
argument_list|(
name|numDatanodes
argument_list|)
operator|.
name|format
argument_list|(
literal|false
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
name|cluster
operator|.
name|waitActive
argument_list|()
expr_stmt|;
name|fileSys
operator|=
name|cluster
operator|.
name|getFileSystem
argument_list|()
expr_stmt|;
try|try
block|{
name|checkFile
argument_list|(
name|fileSys
argument_list|,
name|file1
argument_list|,
name|replication
argument_list|)
expr_stmt|;
name|cleanupFile
argument_list|(
name|fileSys
argument_list|,
name|file1
argument_list|)
expr_stmt|;
name|SecondaryNameNode
name|secondary
init|=
name|startSecondaryNameNode
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|secondary
operator|.
name|doCheckpoint
argument_list|()
expr_stmt|;
name|secondary
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|fileSys
operator|.
name|close
argument_list|()
expr_stmt|;
name|cluster
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
block|}
comment|/*    * Simulate a secondary namenode crash after rolling the edit log.    */
annotation|@
name|Test
DECL|method|testSecondaryNamenodeError3 ()
specifier|public
name|void
name|testSecondaryNamenodeError3
parameter_list|()
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Starting testSecondaryNamenodeError3"
argument_list|)
expr_stmt|;
name|Configuration
name|conf
init|=
operator|new
name|HdfsConfiguration
argument_list|()
decl_stmt|;
name|Path
name|file1
init|=
operator|new
name|Path
argument_list|(
literal|"checkpointzz.dat"
argument_list|)
decl_stmt|;
name|MiniDFSCluster
name|cluster
init|=
operator|new
name|MiniDFSCluster
operator|.
name|Builder
argument_list|(
name|conf
argument_list|)
operator|.
name|numDataNodes
argument_list|(
name|numDatanodes
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|cluster
operator|.
name|waitActive
argument_list|()
expr_stmt|;
name|FileSystem
name|fileSys
init|=
name|cluster
operator|.
name|getFileSystem
argument_list|()
decl_stmt|;
try|try
block|{
name|assertTrue
argument_list|(
operator|!
name|fileSys
operator|.
name|exists
argument_list|(
name|file1
argument_list|)
argument_list|)
expr_stmt|;
comment|//
comment|// Make the checkpoint fail after rolling the edit log.
comment|//
name|SecondaryNameNode
name|secondary
init|=
name|startSecondaryNameNode
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|Mockito
operator|.
name|doThrow
argument_list|(
operator|new
name|IOException
argument_list|(
literal|"Injecting failure after rolling edit logs"
argument_list|)
argument_list|)
operator|.
name|when
argument_list|(
name|faultInjector
argument_list|)
operator|.
name|afterSecondaryCallsRollEditLog
argument_list|()
expr_stmt|;
try|try
block|{
name|secondary
operator|.
name|doCheckpoint
argument_list|()
expr_stmt|;
comment|// this should fail
name|assertTrue
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{       }
name|Mockito
operator|.
name|reset
argument_list|(
name|faultInjector
argument_list|)
expr_stmt|;
name|secondary
operator|.
name|shutdown
argument_list|()
expr_stmt|;
comment|// secondary namenode crash!
comment|// start new instance of secondary and verify that
comment|// a new rollEditLog suceedes inspite of the fact that
comment|// edits.new already exists.
comment|//
name|secondary
operator|=
name|startSecondaryNameNode
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|secondary
operator|.
name|doCheckpoint
argument_list|()
expr_stmt|;
comment|// this should work correctly
name|secondary
operator|.
name|shutdown
argument_list|()
expr_stmt|;
comment|//
comment|// Create a new file
comment|//
name|DFSTestUtil
operator|.
name|createFile
argument_list|(
name|fileSys
argument_list|,
name|file1
argument_list|,
name|fileSize
argument_list|,
name|fileSize
argument_list|,
name|blockSize
argument_list|,
name|replication
argument_list|,
name|seed
argument_list|)
expr_stmt|;
name|checkFile
argument_list|(
name|fileSys
argument_list|,
name|file1
argument_list|,
name|replication
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|fileSys
operator|.
name|close
argument_list|()
expr_stmt|;
name|cluster
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
comment|//
comment|// Restart cluster and verify that file exists.
comment|// Then take another checkpoint to verify that the
comment|// namenode restart accounted for the twice-rolled edit logs.
comment|//
name|cluster
operator|=
operator|new
name|MiniDFSCluster
operator|.
name|Builder
argument_list|(
name|conf
argument_list|)
operator|.
name|numDataNodes
argument_list|(
name|numDatanodes
argument_list|)
operator|.
name|format
argument_list|(
literal|false
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
name|cluster
operator|.
name|waitActive
argument_list|()
expr_stmt|;
name|fileSys
operator|=
name|cluster
operator|.
name|getFileSystem
argument_list|()
expr_stmt|;
try|try
block|{
name|checkFile
argument_list|(
name|fileSys
argument_list|,
name|file1
argument_list|,
name|replication
argument_list|)
expr_stmt|;
name|cleanupFile
argument_list|(
name|fileSys
argument_list|,
name|file1
argument_list|)
expr_stmt|;
name|SecondaryNameNode
name|secondary
init|=
name|startSecondaryNameNode
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|secondary
operator|.
name|doCheckpoint
argument_list|()
expr_stmt|;
name|secondary
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|fileSys
operator|.
name|close
argument_list|()
expr_stmt|;
name|cluster
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Simulate a secondary node failure to transfer image    * back to the name-node.    * Used to truncate primary fsimage file.    */
annotation|@
name|Test
DECL|method|testSecondaryFailsToReturnImage ()
specifier|public
name|void
name|testSecondaryFailsToReturnImage
parameter_list|()
throws|throws
name|IOException
block|{
name|Mockito
operator|.
name|doThrow
argument_list|(
operator|new
name|IOException
argument_list|(
literal|"If this exception is not caught by the "
operator|+
literal|"name-node, fs image will be truncated."
argument_list|)
argument_list|)
operator|.
name|when
argument_list|(
name|faultInjector
argument_list|)
operator|.
name|aboutToSendFile
argument_list|(
name|filePathContaining
argument_list|(
literal|"secondary"
argument_list|)
argument_list|)
expr_stmt|;
name|doSecondaryFailsToReturnImage
argument_list|()
expr_stmt|;
block|}
comment|/**    * Similar to above test, but uses an unchecked Error, and causes it    * before even setting the length header. This used to cause image    * truncation. Regression test for HDFS-3330.    */
annotation|@
name|Test
DECL|method|testSecondaryFailsWithErrorBeforeSettingHeaders ()
specifier|public
name|void
name|testSecondaryFailsWithErrorBeforeSettingHeaders
parameter_list|()
throws|throws
name|IOException
block|{
name|Mockito
operator|.
name|doThrow
argument_list|(
operator|new
name|Error
argument_list|(
literal|"If this exception is not caught by the "
operator|+
literal|"name-node, fs image will be truncated."
argument_list|)
argument_list|)
operator|.
name|when
argument_list|(
name|faultInjector
argument_list|)
operator|.
name|beforeGetImageSetsHeaders
argument_list|()
expr_stmt|;
name|doSecondaryFailsToReturnImage
argument_list|()
expr_stmt|;
block|}
DECL|method|doSecondaryFailsToReturnImage ()
specifier|private
name|void
name|doSecondaryFailsToReturnImage
parameter_list|()
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Starting testSecondaryFailsToReturnImage"
argument_list|)
expr_stmt|;
name|Configuration
name|conf
init|=
operator|new
name|HdfsConfiguration
argument_list|()
decl_stmt|;
name|Path
name|file1
init|=
operator|new
name|Path
argument_list|(
literal|"checkpointRI.dat"
argument_list|)
decl_stmt|;
name|MiniDFSCluster
name|cluster
init|=
operator|new
name|MiniDFSCluster
operator|.
name|Builder
argument_list|(
name|conf
argument_list|)
operator|.
name|numDataNodes
argument_list|(
name|numDatanodes
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|cluster
operator|.
name|waitActive
argument_list|()
expr_stmt|;
name|FileSystem
name|fileSys
init|=
name|cluster
operator|.
name|getFileSystem
argument_list|()
decl_stmt|;
name|FSImage
name|image
init|=
name|cluster
operator|.
name|getNameNode
argument_list|()
operator|.
name|getFSImage
argument_list|()
decl_stmt|;
try|try
block|{
name|assertTrue
argument_list|(
operator|!
name|fileSys
operator|.
name|exists
argument_list|(
name|file1
argument_list|)
argument_list|)
expr_stmt|;
name|StorageDirectory
name|sd
init|=
name|image
operator|.
name|getStorage
argument_list|()
operator|.
name|getStorageDir
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|File
name|latestImageBeforeCheckpoint
init|=
name|FSImageTestUtil
operator|.
name|findLatestImageFile
argument_list|(
name|sd
argument_list|)
decl_stmt|;
name|long
name|fsimageLength
init|=
name|latestImageBeforeCheckpoint
operator|.
name|length
argument_list|()
decl_stmt|;
comment|//
comment|// Make the checkpoint
comment|//
name|SecondaryNameNode
name|secondary
init|=
name|startSecondaryNameNode
argument_list|(
name|conf
argument_list|)
decl_stmt|;
try|try
block|{
name|secondary
operator|.
name|doCheckpoint
argument_list|()
expr_stmt|;
comment|// this should fail
name|fail
argument_list|(
literal|"Checkpoint succeeded even though we injected an error!"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// check that it's the injected exception
name|GenericTestUtils
operator|.
name|assertExceptionContains
argument_list|(
literal|"If this exception is not caught"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
name|Mockito
operator|.
name|reset
argument_list|(
name|faultInjector
argument_list|)
expr_stmt|;
comment|// Verify that image file sizes did not change.
for|for
control|(
name|StorageDirectory
name|sd2
range|:
name|image
operator|.
name|getStorage
argument_list|()
operator|.
name|dirIterable
argument_list|(
name|NameNodeDirType
operator|.
name|IMAGE
argument_list|)
control|)
block|{
name|File
name|thisNewestImage
init|=
name|FSImageTestUtil
operator|.
name|findLatestImageFile
argument_list|(
name|sd2
argument_list|)
decl_stmt|;
name|long
name|len
init|=
name|thisNewestImage
operator|.
name|length
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
name|fsimageLength
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
name|secondary
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|fileSys
operator|.
name|close
argument_list|()
expr_stmt|;
name|cluster
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|filePathContaining (final String substring)
specifier|private
name|File
name|filePathContaining
parameter_list|(
specifier|final
name|String
name|substring
parameter_list|)
block|{
return|return
name|Mockito
operator|.
expr|<
name|File
operator|>
name|argThat
argument_list|(
operator|new
name|ArgumentMatcher
argument_list|<
name|File
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|matches
parameter_list|(
name|Object
name|argument
parameter_list|)
block|{
name|String
name|path
init|=
operator|(
operator|(
name|File
operator|)
name|argument
operator|)
operator|.
name|getAbsolutePath
argument_list|()
decl_stmt|;
return|return
name|path
operator|.
name|contains
argument_list|(
name|substring
argument_list|)
return|;
block|}
block|}
argument_list|)
return|;
block|}
comment|/**    * Simulate 2NN failing to send the whole file (error type 3)    * The length header in the HTTP transfer should prevent    * this from corrupting the NN.    */
annotation|@
name|Test
DECL|method|testNameNodeImageSendFailWrongSize ()
specifier|public
name|void
name|testNameNodeImageSendFailWrongSize
parameter_list|()
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Starting testNameNodeImageSendFailWrongSize"
argument_list|)
expr_stmt|;
name|Mockito
operator|.
name|doReturn
argument_list|(
literal|true
argument_list|)
operator|.
name|when
argument_list|(
name|faultInjector
argument_list|)
operator|.
name|shouldSendShortFile
argument_list|(
name|filePathContaining
argument_list|(
literal|"fsimage"
argument_list|)
argument_list|)
expr_stmt|;
name|doSendFailTest
argument_list|(
literal|"is not of the advertised size"
argument_list|)
expr_stmt|;
block|}
comment|/**    * Simulate 2NN sending a corrupt image (error type 4)    * The digest header in the HTTP transfer should prevent    * this from corrupting the NN.    */
annotation|@
name|Test
DECL|method|testNameNodeImageSendFailWrongDigest ()
specifier|public
name|void
name|testNameNodeImageSendFailWrongDigest
parameter_list|()
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Starting testNameNodeImageSendFailWrongDigest"
argument_list|)
expr_stmt|;
name|Mockito
operator|.
name|doReturn
argument_list|(
literal|true
argument_list|)
operator|.
name|when
argument_list|(
name|faultInjector
argument_list|)
operator|.
name|shouldCorruptAByte
argument_list|(
name|Mockito
operator|.
name|any
argument_list|(
name|File
operator|.
name|class
argument_list|)
argument_list|)
expr_stmt|;
name|doSendFailTest
argument_list|(
literal|"does not match advertised digest"
argument_list|)
expr_stmt|;
block|}
comment|/**    * Run a test where the 2NN runs into some kind of error when    * sending the checkpoint back to the NN.    * @param exceptionSubstring an expected substring of the triggered exception    */
DECL|method|doSendFailTest (String exceptionSubstring)
specifier|private
name|void
name|doSendFailTest
parameter_list|(
name|String
name|exceptionSubstring
parameter_list|)
throws|throws
name|IOException
block|{
name|Configuration
name|conf
init|=
operator|new
name|HdfsConfiguration
argument_list|()
decl_stmt|;
name|Path
name|file1
init|=
operator|new
name|Path
argument_list|(
literal|"checkpoint-doSendFailTest-doSendFailTest.dat"
argument_list|)
decl_stmt|;
name|MiniDFSCluster
name|cluster
init|=
operator|new
name|MiniDFSCluster
operator|.
name|Builder
argument_list|(
name|conf
argument_list|)
operator|.
name|numDataNodes
argument_list|(
name|numDatanodes
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|cluster
operator|.
name|waitActive
argument_list|()
expr_stmt|;
name|FileSystem
name|fileSys
init|=
name|cluster
operator|.
name|getFileSystem
argument_list|()
decl_stmt|;
try|try
block|{
name|assertTrue
argument_list|(
operator|!
name|fileSys
operator|.
name|exists
argument_list|(
name|file1
argument_list|)
argument_list|)
expr_stmt|;
comment|//
comment|// Make the checkpoint fail after rolling the edit log.
comment|//
name|SecondaryNameNode
name|secondary
init|=
name|startSecondaryNameNode
argument_list|(
name|conf
argument_list|)
decl_stmt|;
try|try
block|{
name|secondary
operator|.
name|doCheckpoint
argument_list|()
expr_stmt|;
comment|// this should fail
name|fail
argument_list|(
literal|"Did not get expected exception"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// We only sent part of the image. Have to trigger this exception
name|GenericTestUtils
operator|.
name|assertExceptionContains
argument_list|(
name|exceptionSubstring
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
name|Mockito
operator|.
name|reset
argument_list|(
name|faultInjector
argument_list|)
expr_stmt|;
name|secondary
operator|.
name|shutdown
argument_list|()
expr_stmt|;
comment|// secondary namenode crash!
comment|// start new instance of secondary and verify that
comment|// a new rollEditLog succedes in spite of the fact that we had
comment|// a partially failed checkpoint previously.
comment|//
name|secondary
operator|=
name|startSecondaryNameNode
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|secondary
operator|.
name|doCheckpoint
argument_list|()
expr_stmt|;
comment|// this should work correctly
name|secondary
operator|.
name|shutdown
argument_list|()
expr_stmt|;
comment|//
comment|// Create a new file
comment|//
name|DFSTestUtil
operator|.
name|createFile
argument_list|(
name|fileSys
argument_list|,
name|file1
argument_list|,
name|fileSize
argument_list|,
name|fileSize
argument_list|,
name|blockSize
argument_list|,
name|replication
argument_list|,
name|seed
argument_list|)
expr_stmt|;
name|checkFile
argument_list|(
name|fileSys
argument_list|,
name|file1
argument_list|,
name|replication
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|fileSys
operator|.
name|close
argument_list|()
expr_stmt|;
name|cluster
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Test that the NN locks its storage and edits directories, and won't start up    * if the directories are already locked    **/
annotation|@
name|Test
DECL|method|testNameDirLocking ()
specifier|public
name|void
name|testNameDirLocking
parameter_list|()
throws|throws
name|IOException
block|{
name|Configuration
name|conf
init|=
operator|new
name|HdfsConfiguration
argument_list|()
decl_stmt|;
name|MiniDFSCluster
name|cluster
init|=
operator|new
name|MiniDFSCluster
operator|.
name|Builder
argument_list|(
name|conf
argument_list|)
operator|.
name|numDataNodes
argument_list|(
literal|0
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
comment|// Start a NN, and verify that lock() fails in all of the configured
comment|// directories
name|StorageDirectory
name|savedSd
init|=
literal|null
decl_stmt|;
try|try
block|{
name|NNStorage
name|storage
init|=
name|cluster
operator|.
name|getNameNode
argument_list|()
operator|.
name|getFSImage
argument_list|()
operator|.
name|getStorage
argument_list|()
decl_stmt|;
for|for
control|(
name|StorageDirectory
name|sd
range|:
name|storage
operator|.
name|dirIterable
argument_list|(
literal|null
argument_list|)
control|)
block|{
name|assertLockFails
argument_list|(
name|sd
argument_list|)
expr_stmt|;
name|savedSd
operator|=
name|sd
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|cluster
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
name|assertNotNull
argument_list|(
name|savedSd
argument_list|)
expr_stmt|;
comment|// Lock one of the saved directories, then start the NN, and make sure it
comment|// fails to start
name|assertClusterStartFailsWhenDirLocked
argument_list|(
name|conf
argument_list|,
name|savedSd
argument_list|)
expr_stmt|;
block|}
comment|/**    * Test that, if the edits dir is separate from the name dir, it is    * properly locked.    **/
annotation|@
name|Test
DECL|method|testSeparateEditsDirLocking ()
specifier|public
name|void
name|testSeparateEditsDirLocking
parameter_list|()
throws|throws
name|IOException
block|{
name|Configuration
name|conf
init|=
operator|new
name|HdfsConfiguration
argument_list|()
decl_stmt|;
name|File
name|editsDir
init|=
operator|new
name|File
argument_list|(
name|MiniDFSCluster
operator|.
name|getBaseDirectory
argument_list|()
operator|+
literal|"/testSeparateEditsDirLocking"
argument_list|)
decl_stmt|;
name|conf
operator|.
name|set
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_EDITS_DIR_KEY
argument_list|,
name|editsDir
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
name|MiniDFSCluster
name|cluster
init|=
operator|new
name|MiniDFSCluster
operator|.
name|Builder
argument_list|(
name|conf
argument_list|)
operator|.
name|manageNameDfsDirs
argument_list|(
literal|false
argument_list|)
operator|.
name|numDataNodes
argument_list|(
literal|0
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
comment|// Start a NN, and verify that lock() fails in all of the configured
comment|// directories
name|StorageDirectory
name|savedSd
init|=
literal|null
decl_stmt|;
try|try
block|{
name|NNStorage
name|storage
init|=
name|cluster
operator|.
name|getNameNode
argument_list|()
operator|.
name|getFSImage
argument_list|()
operator|.
name|getStorage
argument_list|()
decl_stmt|;
for|for
control|(
name|StorageDirectory
name|sd
range|:
name|storage
operator|.
name|dirIterable
argument_list|(
name|NameNodeDirType
operator|.
name|EDITS
argument_list|)
control|)
block|{
name|assertEquals
argument_list|(
name|editsDir
operator|.
name|getAbsoluteFile
argument_list|()
argument_list|,
name|sd
operator|.
name|getRoot
argument_list|()
argument_list|)
expr_stmt|;
name|assertLockFails
argument_list|(
name|sd
argument_list|)
expr_stmt|;
name|savedSd
operator|=
name|sd
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|cluster
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
name|assertNotNull
argument_list|(
name|savedSd
argument_list|)
expr_stmt|;
comment|// Lock one of the saved directories, then start the NN, and make sure it
comment|// fails to start
name|assertClusterStartFailsWhenDirLocked
argument_list|(
name|conf
argument_list|,
name|savedSd
argument_list|)
expr_stmt|;
block|}
comment|/**    * Test that the SecondaryNameNode properly locks its storage directories.    */
annotation|@
name|Test
DECL|method|testSecondaryNameNodeLocking ()
specifier|public
name|void
name|testSecondaryNameNodeLocking
parameter_list|()
throws|throws
name|Exception
block|{
comment|// Start a primary NN so that the secondary will start successfully
name|Configuration
name|conf
init|=
operator|new
name|HdfsConfiguration
argument_list|()
decl_stmt|;
name|MiniDFSCluster
name|cluster
init|=
operator|new
name|MiniDFSCluster
operator|.
name|Builder
argument_list|(
name|conf
argument_list|)
operator|.
name|numDataNodes
argument_list|(
literal|0
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|SecondaryNameNode
name|secondary
init|=
literal|null
decl_stmt|;
try|try
block|{
name|StorageDirectory
name|savedSd
init|=
literal|null
decl_stmt|;
comment|// Start a secondary NN, then make sure that all of its storage
comment|// dirs got locked.
name|secondary
operator|=
name|startSecondaryNameNode
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|NNStorage
name|storage
init|=
name|secondary
operator|.
name|getFSImage
argument_list|()
operator|.
name|getStorage
argument_list|()
decl_stmt|;
for|for
control|(
name|StorageDirectory
name|sd
range|:
name|storage
operator|.
name|dirIterable
argument_list|(
literal|null
argument_list|)
control|)
block|{
name|assertLockFails
argument_list|(
name|sd
argument_list|)
expr_stmt|;
name|savedSd
operator|=
name|sd
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"===> Shutting down first 2NN"
argument_list|)
expr_stmt|;
name|secondary
operator|.
name|shutdown
argument_list|()
expr_stmt|;
name|secondary
operator|=
literal|null
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"===> Locking a dir, starting second 2NN"
argument_list|)
expr_stmt|;
comment|// Lock one of its dirs, make sure it fails to start
name|LOG
operator|.
name|info
argument_list|(
literal|"Trying to lock"
operator|+
name|savedSd
argument_list|)
expr_stmt|;
name|savedSd
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|secondary
operator|=
name|startSecondaryNameNode
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
literal|"Should fail to start 2NN when "
operator|+
name|savedSd
operator|+
literal|" is locked"
argument_list|,
name|savedSd
operator|.
name|isLockSupported
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|GenericTestUtils
operator|.
name|assertExceptionContains
argument_list|(
literal|"already locked"
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|savedSd
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
finally|finally
block|{
if|if
condition|(
name|secondary
operator|!=
literal|null
condition|)
block|{
name|secondary
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
name|cluster
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Test that, an attempt to lock a storage that is already locked by a nodename,    * logs error message that includes JVM name of the namenode that locked it.    */
annotation|@
name|Test
DECL|method|testStorageAlreadyLockedErrorMessage ()
specifier|public
name|void
name|testStorageAlreadyLockedErrorMessage
parameter_list|()
throws|throws
name|Exception
block|{
name|Configuration
name|conf
init|=
operator|new
name|HdfsConfiguration
argument_list|()
decl_stmt|;
name|MiniDFSCluster
name|cluster
init|=
operator|new
name|MiniDFSCluster
operator|.
name|Builder
argument_list|(
name|conf
argument_list|)
operator|.
name|numDataNodes
argument_list|(
literal|0
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|StorageDirectory
name|savedSd
init|=
literal|null
decl_stmt|;
try|try
block|{
name|NNStorage
name|storage
init|=
name|cluster
operator|.
name|getNameNode
argument_list|()
operator|.
name|getFSImage
argument_list|()
operator|.
name|getStorage
argument_list|()
decl_stmt|;
for|for
control|(
name|StorageDirectory
name|sd
range|:
name|storage
operator|.
name|dirIterable
argument_list|(
literal|null
argument_list|)
control|)
block|{
name|assertLockFails
argument_list|(
name|sd
argument_list|)
expr_stmt|;
name|savedSd
operator|=
name|sd
expr_stmt|;
block|}
name|LogCapturer
name|logs
init|=
name|GenericTestUtils
operator|.
name|LogCapturer
operator|.
name|captureLogs
argument_list|(
name|LogFactory
operator|.
name|getLog
argument_list|(
name|Storage
operator|.
name|class
argument_list|)
argument_list|)
decl_stmt|;
try|try
block|{
comment|// try to lock the storage that's already locked
name|savedSd
operator|.
name|lock
argument_list|()
expr_stmt|;
name|fail
argument_list|(
literal|"Namenode should not be able to lock a storage that is already locked"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|String
name|jvmName
init|=
name|ManagementFactory
operator|.
name|getRuntimeMXBean
argument_list|()
operator|.
name|getName
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
literal|"Error message does not include JVM name '"
operator|+
name|jvmName
operator|+
literal|"'"
argument_list|,
name|logs
operator|.
name|getOutput
argument_list|()
operator|.
name|contains
argument_list|(
name|jvmName
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|cluster
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Assert that the given storage directory can't be locked, because    * it's already locked.    */
DECL|method|assertLockFails (StorageDirectory sd)
specifier|private
specifier|static
name|void
name|assertLockFails
parameter_list|(
name|StorageDirectory
name|sd
parameter_list|)
block|{
try|try
block|{
name|sd
operator|.
name|lock
argument_list|()
expr_stmt|;
comment|// If the above line didn't throw an exception, then
comment|// locking must not be supported
name|assertFalse
argument_list|(
name|sd
operator|.
name|isLockSupported
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|GenericTestUtils
operator|.
name|assertExceptionContains
argument_list|(
literal|"already locked"
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Assert that, if sdToLock is locked, the cluster is not allowed to start up.    * @param conf cluster conf to use    * @param sdToLock the storage directory to lock    */
DECL|method|assertClusterStartFailsWhenDirLocked ( Configuration conf, StorageDirectory sdToLock)
specifier|private
specifier|static
name|void
name|assertClusterStartFailsWhenDirLocked
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|StorageDirectory
name|sdToLock
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Lock the edits dir, then start the NN, and make sure it fails to start
name|sdToLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|MiniDFSCluster
name|cluster
init|=
operator|new
name|MiniDFSCluster
operator|.
name|Builder
argument_list|(
name|conf
argument_list|)
operator|.
name|format
argument_list|(
literal|false
argument_list|)
operator|.
name|manageNameDfsDirs
argument_list|(
literal|false
argument_list|)
operator|.
name|numDataNodes
argument_list|(
literal|0
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|assertFalse
argument_list|(
literal|"cluster should fail to start after locking "
operator|+
name|sdToLock
argument_list|,
name|sdToLock
operator|.
name|isLockSupported
argument_list|()
argument_list|)
expr_stmt|;
name|cluster
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|GenericTestUtils
operator|.
name|assertExceptionContains
argument_list|(
literal|"already locked"
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|sdToLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Test the importCheckpoint startup option. Verifies:    * 1. if the NN already contains an image, it will not be allowed    *   to import a checkpoint.    * 2. if the NN does not contain an image, importing a checkpoint    *    succeeds and re-saves the image    */
annotation|@
name|Test
DECL|method|testImportCheckpoint ()
specifier|public
name|void
name|testImportCheckpoint
parameter_list|()
throws|throws
name|Exception
block|{
name|Configuration
name|conf
init|=
operator|new
name|HdfsConfiguration
argument_list|()
decl_stmt|;
name|Path
name|testPath
init|=
operator|new
name|Path
argument_list|(
literal|"/testfile"
argument_list|)
decl_stmt|;
name|SecondaryNameNode
name|snn
init|=
literal|null
decl_stmt|;
name|MiniDFSCluster
name|cluster
init|=
operator|new
name|MiniDFSCluster
operator|.
name|Builder
argument_list|(
name|conf
argument_list|)
operator|.
name|numDataNodes
argument_list|(
literal|0
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|Collection
argument_list|<
name|URI
argument_list|>
name|nameDirs
init|=
name|cluster
operator|.
name|getNameDirs
argument_list|(
literal|0
argument_list|)
decl_stmt|;
try|try
block|{
comment|// Make an entry in the namespace, used for verifying checkpoint
comment|// later.
name|cluster
operator|.
name|getFileSystem
argument_list|()
operator|.
name|mkdirs
argument_list|(
name|testPath
argument_list|)
expr_stmt|;
comment|// Take a checkpoint
name|snn
operator|=
name|startSecondaryNameNode
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|snn
operator|.
name|doCheckpoint
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|snn
operator|!=
literal|null
condition|)
block|{
name|snn
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
name|cluster
operator|.
name|shutdown
argument_list|()
expr_stmt|;
name|cluster
operator|=
literal|null
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Trying to import checkpoint when the NameNode already "
operator|+
literal|"contains an image. This should fail."
argument_list|)
expr_stmt|;
try|try
block|{
name|cluster
operator|=
operator|new
name|MiniDFSCluster
operator|.
name|Builder
argument_list|(
name|conf
argument_list|)
operator|.
name|numDataNodes
argument_list|(
literal|0
argument_list|)
operator|.
name|format
argument_list|(
literal|false
argument_list|)
operator|.
name|startupOption
argument_list|(
name|StartupOption
operator|.
name|IMPORT
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
name|fail
argument_list|(
literal|"NameNode did not fail to start when it already contained "
operator|+
literal|"an image"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
comment|// Expected
name|GenericTestUtils
operator|.
name|assertExceptionContains
argument_list|(
literal|"NameNode already contains an image"
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|cluster
operator|!=
literal|null
condition|)
block|{
name|cluster
operator|.
name|shutdown
argument_list|()
expr_stmt|;
name|cluster
operator|=
literal|null
expr_stmt|;
block|}
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Removing NN storage contents"
argument_list|)
expr_stmt|;
for|for
control|(
name|URI
name|uri
range|:
name|nameDirs
control|)
block|{
name|File
name|dir
init|=
operator|new
name|File
argument_list|(
name|uri
operator|.
name|getPath
argument_list|()
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Cleaning "
operator|+
name|dir
argument_list|)
expr_stmt|;
name|removeAndRecreateDir
argument_list|(
name|dir
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Trying to import checkpoint"
argument_list|)
expr_stmt|;
try|try
block|{
name|cluster
operator|=
operator|new
name|MiniDFSCluster
operator|.
name|Builder
argument_list|(
name|conf
argument_list|)
operator|.
name|format
argument_list|(
literal|false
argument_list|)
operator|.
name|numDataNodes
argument_list|(
literal|0
argument_list|)
operator|.
name|startupOption
argument_list|(
name|StartupOption
operator|.
name|IMPORT
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
name|assertTrue
argument_list|(
literal|"Path from checkpoint should exist after import"
argument_list|,
name|cluster
operator|.
name|getFileSystem
argument_list|()
operator|.
name|exists
argument_list|(
name|testPath
argument_list|)
argument_list|)
expr_stmt|;
comment|// Make sure that the image got saved on import
name|FSImageTestUtil
operator|.
name|assertNNHasCheckpoints
argument_list|(
name|cluster
argument_list|,
name|Ints
operator|.
name|asList
argument_list|(
literal|3
argument_list|)
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|cluster
operator|!=
literal|null
condition|)
block|{
name|cluster
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
block|}
block|}
DECL|method|removeAndRecreateDir (File dir)
specifier|private
specifier|static
name|void
name|removeAndRecreateDir
parameter_list|(
name|File
name|dir
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|dir
operator|.
name|exists
argument_list|()
condition|)
if|if
condition|(
operator|!
operator|(
name|FileUtil
operator|.
name|fullyDelete
argument_list|(
name|dir
argument_list|)
operator|)
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Cannot remove directory: "
operator|+
name|dir
argument_list|)
throw|;
if|if
condition|(
operator|!
name|dir
operator|.
name|mkdirs
argument_list|()
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Cannot create directory "
operator|+
name|dir
argument_list|)
throw|;
block|}
DECL|method|startSecondaryNameNode (Configuration conf )
name|SecondaryNameNode
name|startSecondaryNameNode
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|conf
operator|.
name|set
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_SECONDARY_HTTP_ADDRESS_KEY
argument_list|,
literal|"0.0.0.0:0"
argument_list|)
expr_stmt|;
return|return
operator|new
name|SecondaryNameNode
argument_list|(
name|conf
argument_list|)
return|;
block|}
DECL|method|startSecondaryNameNode (Configuration conf, int index)
name|SecondaryNameNode
name|startSecondaryNameNode
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|int
name|index
parameter_list|)
throws|throws
name|IOException
block|{
name|Configuration
name|snnConf
init|=
operator|new
name|Configuration
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|snnConf
operator|.
name|set
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_SECONDARY_HTTP_ADDRESS_KEY
argument_list|,
literal|"0.0.0.0:0"
argument_list|)
expr_stmt|;
name|snnConf
operator|.
name|set
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_CHECKPOINT_DIR_KEY
argument_list|,
name|MiniDFSCluster
operator|.
name|getBaseDirectory
argument_list|()
operator|+
literal|"/2nn-"
operator|+
name|index
argument_list|)
expr_stmt|;
return|return
operator|new
name|SecondaryNameNode
argument_list|(
name|snnConf
argument_list|)
return|;
block|}
comment|/**    * Tests checkpoint in HDFS.    */
annotation|@
name|Test
DECL|method|testCheckpoint ()
specifier|public
name|void
name|testCheckpoint
parameter_list|()
throws|throws
name|IOException
block|{
name|Path
name|file1
init|=
operator|new
name|Path
argument_list|(
literal|"checkpoint.dat"
argument_list|)
decl_stmt|;
name|Path
name|file2
init|=
operator|new
name|Path
argument_list|(
literal|"checkpoint2.dat"
argument_list|)
decl_stmt|;
name|Configuration
name|conf
init|=
operator|new
name|HdfsConfiguration
argument_list|()
decl_stmt|;
name|conf
operator|.
name|set
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_SECONDARY_HTTP_ADDRESS_KEY
argument_list|,
literal|"0.0.0.0:0"
argument_list|)
expr_stmt|;
name|replication
operator|=
operator|(
name|short
operator|)
name|conf
operator|.
name|getInt
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_REPLICATION_KEY
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|MiniDFSCluster
name|cluster
init|=
operator|new
name|MiniDFSCluster
operator|.
name|Builder
argument_list|(
name|conf
argument_list|)
operator|.
name|numDataNodes
argument_list|(
name|numDatanodes
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|cluster
operator|.
name|waitActive
argument_list|()
expr_stmt|;
name|FileSystem
name|fileSys
init|=
name|cluster
operator|.
name|getFileSystem
argument_list|()
decl_stmt|;
try|try
block|{
comment|//
comment|// verify that 'format' really blew away all pre-existing files
comment|//
name|assertTrue
argument_list|(
operator|!
name|fileSys
operator|.
name|exists
argument_list|(
name|file1
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
operator|!
name|fileSys
operator|.
name|exists
argument_list|(
name|file2
argument_list|)
argument_list|)
expr_stmt|;
comment|//
comment|// Create file1
comment|//
name|DFSTestUtil
operator|.
name|createFile
argument_list|(
name|fileSys
argument_list|,
name|file1
argument_list|,
name|fileSize
argument_list|,
name|fileSize
argument_list|,
name|blockSize
argument_list|,
name|replication
argument_list|,
name|seed
argument_list|)
expr_stmt|;
name|checkFile
argument_list|(
name|fileSys
argument_list|,
name|file1
argument_list|,
name|replication
argument_list|)
expr_stmt|;
comment|//
comment|// Take a checkpoint
comment|//
name|SecondaryNameNode
name|secondary
init|=
name|startSecondaryNameNode
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|secondary
operator|.
name|doCheckpoint
argument_list|()
expr_stmt|;
name|secondary
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|fileSys
operator|.
name|close
argument_list|()
expr_stmt|;
name|cluster
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
comment|//
comment|// Restart cluster and verify that file1 still exist.
comment|//
name|cluster
operator|=
operator|new
name|MiniDFSCluster
operator|.
name|Builder
argument_list|(
name|conf
argument_list|)
operator|.
name|numDataNodes
argument_list|(
name|numDatanodes
argument_list|)
operator|.
name|format
argument_list|(
literal|false
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
name|cluster
operator|.
name|waitActive
argument_list|()
expr_stmt|;
name|fileSys
operator|=
name|cluster
operator|.
name|getFileSystem
argument_list|()
expr_stmt|;
name|Path
name|tmpDir
init|=
operator|new
name|Path
argument_list|(
literal|"/tmp_tmp"
argument_list|)
decl_stmt|;
try|try
block|{
comment|// check that file1 still exists
name|checkFile
argument_list|(
name|fileSys
argument_list|,
name|file1
argument_list|,
name|replication
argument_list|)
expr_stmt|;
name|cleanupFile
argument_list|(
name|fileSys
argument_list|,
name|file1
argument_list|)
expr_stmt|;
comment|// create new file file2
name|DFSTestUtil
operator|.
name|createFile
argument_list|(
name|fileSys
argument_list|,
name|file2
argument_list|,
name|fileSize
argument_list|,
name|fileSize
argument_list|,
name|blockSize
argument_list|,
name|replication
argument_list|,
name|seed
argument_list|)
expr_stmt|;
name|checkFile
argument_list|(
name|fileSys
argument_list|,
name|file2
argument_list|,
name|replication
argument_list|)
expr_stmt|;
comment|//
comment|// Take a checkpoint
comment|//
name|SecondaryNameNode
name|secondary
init|=
name|startSecondaryNameNode
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|secondary
operator|.
name|doCheckpoint
argument_list|()
expr_stmt|;
name|fileSys
operator|.
name|delete
argument_list|(
name|tmpDir
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|fileSys
operator|.
name|mkdirs
argument_list|(
name|tmpDir
argument_list|)
expr_stmt|;
name|secondary
operator|.
name|doCheckpoint
argument_list|()
expr_stmt|;
name|secondary
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|fileSys
operator|.
name|close
argument_list|()
expr_stmt|;
name|cluster
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
comment|//
comment|// Restart cluster and verify that file2 exists and
comment|// file1 does not exist.
comment|//
name|cluster
operator|=
operator|new
name|MiniDFSCluster
operator|.
name|Builder
argument_list|(
name|conf
argument_list|)
operator|.
name|numDataNodes
argument_list|(
name|numDatanodes
argument_list|)
operator|.
name|format
argument_list|(
literal|false
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
name|cluster
operator|.
name|waitActive
argument_list|()
expr_stmt|;
name|fileSys
operator|=
name|cluster
operator|.
name|getFileSystem
argument_list|()
expr_stmt|;
name|assertTrue
argument_list|(
operator|!
name|fileSys
operator|.
name|exists
argument_list|(
name|file1
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|fileSys
operator|.
name|exists
argument_list|(
name|tmpDir
argument_list|)
argument_list|)
expr_stmt|;
try|try
block|{
comment|// verify that file2 exists
name|checkFile
argument_list|(
name|fileSys
argument_list|,
name|file2
argument_list|,
name|replication
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|fileSys
operator|.
name|close
argument_list|()
expr_stmt|;
name|cluster
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Tests save namespace.    */
annotation|@
name|Test
DECL|method|testSaveNamespace ()
specifier|public
name|void
name|testSaveNamespace
parameter_list|()
throws|throws
name|IOException
block|{
name|MiniDFSCluster
name|cluster
init|=
literal|null
decl_stmt|;
name|DistributedFileSystem
name|fs
init|=
literal|null
decl_stmt|;
name|FileContext
name|fc
decl_stmt|;
try|try
block|{
name|Configuration
name|conf
init|=
operator|new
name|HdfsConfiguration
argument_list|()
decl_stmt|;
name|cluster
operator|=
operator|new
name|MiniDFSCluster
operator|.
name|Builder
argument_list|(
name|conf
argument_list|)
operator|.
name|numDataNodes
argument_list|(
name|numDatanodes
argument_list|)
operator|.
name|format
argument_list|(
literal|true
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
name|cluster
operator|.
name|waitActive
argument_list|()
expr_stmt|;
name|fs
operator|=
call|(
name|DistributedFileSystem
call|)
argument_list|(
name|cluster
operator|.
name|getFileSystem
argument_list|()
argument_list|)
expr_stmt|;
name|fc
operator|=
name|FileContext
operator|.
name|getFileContext
argument_list|(
name|cluster
operator|.
name|getURI
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|// Saving image without safe mode should fail
name|DFSAdmin
name|admin
init|=
operator|new
name|DFSAdmin
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|String
index|[]
name|args
init|=
operator|new
name|String
index|[]
block|{
literal|"-saveNamespace"
block|}
decl_stmt|;
try|try
block|{
name|admin
operator|.
name|run
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|eIO
parameter_list|)
block|{
name|assertTrue
argument_list|(
name|eIO
operator|.
name|getLocalizedMessage
argument_list|()
operator|.
name|contains
argument_list|(
literal|"Safe mode should be turned ON"
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|e
argument_list|)
throw|;
block|}
comment|// create new file
name|Path
name|file
init|=
operator|new
name|Path
argument_list|(
literal|"namespace.dat"
argument_list|)
decl_stmt|;
name|DFSTestUtil
operator|.
name|createFile
argument_list|(
name|fs
argument_list|,
name|file
argument_list|,
name|fileSize
argument_list|,
name|fileSize
argument_list|,
name|blockSize
argument_list|,
name|replication
argument_list|,
name|seed
argument_list|)
expr_stmt|;
name|checkFile
argument_list|(
name|fs
argument_list|,
name|file
argument_list|,
name|replication
argument_list|)
expr_stmt|;
comment|// create new link
name|Path
name|symlink
init|=
operator|new
name|Path
argument_list|(
literal|"file.link"
argument_list|)
decl_stmt|;
name|fc
operator|.
name|createSymlink
argument_list|(
name|file
argument_list|,
name|symlink
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|fc
operator|.
name|getFileLinkStatus
argument_list|(
name|symlink
argument_list|)
operator|.
name|isSymlink
argument_list|()
argument_list|)
expr_stmt|;
comment|// verify that the edits file is NOT empty
name|Collection
argument_list|<
name|URI
argument_list|>
name|editsDirs
init|=
name|cluster
operator|.
name|getNameEditsDirs
argument_list|(
literal|0
argument_list|)
decl_stmt|;
for|for
control|(
name|URI
name|uri
range|:
name|editsDirs
control|)
block|{
name|File
name|ed
init|=
operator|new
name|File
argument_list|(
name|uri
operator|.
name|getPath
argument_list|()
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
operator|new
name|File
argument_list|(
name|ed
argument_list|,
literal|"current/"
operator|+
name|NNStorage
operator|.
name|getInProgressEditsFileName
argument_list|(
literal|1
argument_list|)
argument_list|)
operator|.
name|length
argument_list|()
operator|>
name|Integer
operator|.
name|SIZE
operator|/
name|Byte
operator|.
name|SIZE
argument_list|)
expr_stmt|;
block|}
comment|// Saving image in safe mode should succeed
name|fs
operator|.
name|setSafeMode
argument_list|(
name|SafeModeAction
operator|.
name|SAFEMODE_ENTER
argument_list|)
expr_stmt|;
try|try
block|{
name|admin
operator|.
name|run
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|e
argument_list|)
throw|;
block|}
specifier|final
name|int
name|EXPECTED_TXNS_FIRST_SEG
init|=
literal|12
decl_stmt|;
comment|// the following steps should have happened:
comment|//   edits_inprogress_1 -> edits_1-12  (finalized)
comment|//   fsimage_12 created
comment|//   edits_inprogress_13 created
comment|//
for|for
control|(
name|URI
name|uri
range|:
name|editsDirs
control|)
block|{
name|File
name|ed
init|=
operator|new
name|File
argument_list|(
name|uri
operator|.
name|getPath
argument_list|()
argument_list|)
decl_stmt|;
name|File
name|curDir
init|=
operator|new
name|File
argument_list|(
name|ed
argument_list|,
literal|"current"
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Files in "
operator|+
name|curDir
operator|+
literal|":\n  "
operator|+
name|Joiner
operator|.
name|on
argument_list|(
literal|"\n  "
argument_list|)
operator|.
name|join
argument_list|(
name|curDir
operator|.
name|list
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|// Verify that the first edits file got finalized
name|File
name|originalEdits
init|=
operator|new
name|File
argument_list|(
name|curDir
argument_list|,
name|NNStorage
operator|.
name|getInProgressEditsFileName
argument_list|(
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|assertFalse
argument_list|(
name|originalEdits
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
name|File
name|finalizedEdits
init|=
operator|new
name|File
argument_list|(
name|curDir
argument_list|,
name|NNStorage
operator|.
name|getFinalizedEditsFileName
argument_list|(
literal|1
argument_list|,
name|EXPECTED_TXNS_FIRST_SEG
argument_list|)
argument_list|)
decl_stmt|;
name|GenericTestUtils
operator|.
name|assertExists
argument_list|(
name|finalizedEdits
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|finalizedEdits
operator|.
name|length
argument_list|()
operator|>
name|Integer
operator|.
name|SIZE
operator|/
name|Byte
operator|.
name|SIZE
argument_list|)
expr_stmt|;
name|GenericTestUtils
operator|.
name|assertExists
argument_list|(
operator|new
name|File
argument_list|(
name|ed
argument_list|,
literal|"current/"
operator|+
name|NNStorage
operator|.
name|getInProgressEditsFileName
argument_list|(
name|EXPECTED_TXNS_FIRST_SEG
operator|+
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Collection
argument_list|<
name|URI
argument_list|>
name|imageDirs
init|=
name|cluster
operator|.
name|getNameDirs
argument_list|(
literal|0
argument_list|)
decl_stmt|;
for|for
control|(
name|URI
name|uri
range|:
name|imageDirs
control|)
block|{
name|File
name|imageDir
init|=
operator|new
name|File
argument_list|(
name|uri
operator|.
name|getPath
argument_list|()
argument_list|)
decl_stmt|;
name|File
name|savedImage
init|=
operator|new
name|File
argument_list|(
name|imageDir
argument_list|,
literal|"current/"
operator|+
name|NNStorage
operator|.
name|getImageFileName
argument_list|(
name|EXPECTED_TXNS_FIRST_SEG
argument_list|)
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
literal|"Should have saved image at "
operator|+
name|savedImage
argument_list|,
name|savedImage
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// restart cluster and verify file exists
name|cluster
operator|.
name|shutdown
argument_list|()
expr_stmt|;
name|cluster
operator|=
literal|null
expr_stmt|;
name|cluster
operator|=
operator|new
name|MiniDFSCluster
operator|.
name|Builder
argument_list|(
name|conf
argument_list|)
operator|.
name|numDataNodes
argument_list|(
name|numDatanodes
argument_list|)
operator|.
name|format
argument_list|(
literal|false
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
name|cluster
operator|.
name|waitActive
argument_list|()
expr_stmt|;
name|fs
operator|=
call|(
name|DistributedFileSystem
call|)
argument_list|(
name|cluster
operator|.
name|getFileSystem
argument_list|()
argument_list|)
expr_stmt|;
name|checkFile
argument_list|(
name|fs
argument_list|,
name|file
argument_list|,
name|replication
argument_list|)
expr_stmt|;
name|fc
operator|=
name|FileContext
operator|.
name|getFileContext
argument_list|(
name|cluster
operator|.
name|getURI
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|fc
operator|.
name|getFileLinkStatus
argument_list|(
name|symlink
argument_list|)
operator|.
name|isSymlink
argument_list|()
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
try|try
block|{
if|if
condition|(
name|fs
operator|!=
literal|null
condition|)
name|fs
operator|.
name|close
argument_list|()
expr_stmt|;
if|if
condition|(
name|cluster
operator|!=
literal|null
condition|)
name|cluster
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Failed to shutdown"
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Test case to test CheckpointSignature */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"deprecation"
argument_list|)
annotation|@
name|Test
DECL|method|testCheckpointSignature ()
specifier|public
name|void
name|testCheckpointSignature
parameter_list|()
throws|throws
name|IOException
block|{
name|MiniDFSCluster
name|cluster
init|=
literal|null
decl_stmt|;
name|Configuration
name|conf
init|=
operator|new
name|HdfsConfiguration
argument_list|()
decl_stmt|;
name|cluster
operator|=
operator|new
name|MiniDFSCluster
operator|.
name|Builder
argument_list|(
name|conf
argument_list|)
operator|.
name|numDataNodes
argument_list|(
name|numDatanodes
argument_list|)
operator|.
name|format
argument_list|(
literal|true
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
name|NameNode
name|nn
init|=
name|cluster
operator|.
name|getNameNode
argument_list|()
decl_stmt|;
name|NamenodeProtocols
name|nnRpc
init|=
name|nn
operator|.
name|getRpcServer
argument_list|()
decl_stmt|;
name|SecondaryNameNode
name|secondary
init|=
name|startSecondaryNameNode
argument_list|(
name|conf
argument_list|)
decl_stmt|;
comment|// prepare checkpoint image
name|secondary
operator|.
name|doCheckpoint
argument_list|()
expr_stmt|;
name|CheckpointSignature
name|sig
init|=
name|nnRpc
operator|.
name|rollEditLog
argument_list|()
decl_stmt|;
comment|// manipulate the CheckpointSignature fields
name|sig
operator|.
name|setBlockpoolID
argument_list|(
literal|"somerandomebpid"
argument_list|)
expr_stmt|;
name|sig
operator|.
name|clusterID
operator|=
literal|"somerandomcid"
expr_stmt|;
try|try
block|{
name|sig
operator|.
name|validateStorageInfo
argument_list|(
name|nn
operator|.
name|getFSImage
argument_list|()
argument_list|)
expr_stmt|;
comment|// this should fail
name|assertTrue
argument_list|(
literal|"This test is expected to fail."
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ignored
parameter_list|)
block|{     }
name|secondary
operator|.
name|shutdown
argument_list|()
expr_stmt|;
name|cluster
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
comment|/**    * Tests the following sequence of events:    * - secondary successfully makes a checkpoint    * - it then fails while trying to upload it    * - it then fails again for the same reason    * - it then tries to checkpoint a third time    */
annotation|@
name|Test
DECL|method|testCheckpointAfterTwoFailedUploads ()
specifier|public
name|void
name|testCheckpointAfterTwoFailedUploads
parameter_list|()
throws|throws
name|IOException
block|{
name|MiniDFSCluster
name|cluster
init|=
literal|null
decl_stmt|;
name|SecondaryNameNode
name|secondary
init|=
literal|null
decl_stmt|;
name|Configuration
name|conf
init|=
operator|new
name|HdfsConfiguration
argument_list|()
decl_stmt|;
try|try
block|{
name|cluster
operator|=
operator|new
name|MiniDFSCluster
operator|.
name|Builder
argument_list|(
name|conf
argument_list|)
operator|.
name|numDataNodes
argument_list|(
name|numDatanodes
argument_list|)
operator|.
name|format
argument_list|(
literal|true
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
name|secondary
operator|=
name|startSecondaryNameNode
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|Mockito
operator|.
name|doThrow
argument_list|(
operator|new
name|IOException
argument_list|(
literal|"Injecting failure after rolling edit logs"
argument_list|)
argument_list|)
operator|.
name|when
argument_list|(
name|faultInjector
argument_list|)
operator|.
name|afterSecondaryCallsRollEditLog
argument_list|()
expr_stmt|;
comment|// Fail to checkpoint once
try|try
block|{
name|secondary
operator|.
name|doCheckpoint
argument_list|()
expr_stmt|;
name|fail
argument_list|(
literal|"Should have failed upload"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Got expected failure"
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|ioe
operator|.
name|toString
argument_list|()
operator|.
name|contains
argument_list|(
literal|"Injecting failure"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Fail to checkpoint again
try|try
block|{
name|secondary
operator|.
name|doCheckpoint
argument_list|()
expr_stmt|;
name|fail
argument_list|(
literal|"Should have failed upload"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Got expected failure"
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|ioe
operator|.
name|toString
argument_list|()
operator|.
name|contains
argument_list|(
literal|"Injecting failure"
argument_list|)
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|Mockito
operator|.
name|reset
argument_list|(
name|faultInjector
argument_list|)
expr_stmt|;
block|}
comment|// Now with the cleared error simulation, it should succeed
name|secondary
operator|.
name|doCheckpoint
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|secondary
operator|!=
literal|null
condition|)
block|{
name|secondary
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|cluster
operator|!=
literal|null
condition|)
block|{
name|cluster
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Starts two namenodes and two secondary namenodes, verifies that secondary    * namenodes are configured correctly to talk to their respective namenodes    * and can do the checkpoint.    *     * @throws IOException    */
annotation|@
name|Test
DECL|method|testMultipleSecondaryNamenodes ()
specifier|public
name|void
name|testMultipleSecondaryNamenodes
parameter_list|()
throws|throws
name|IOException
block|{
name|Configuration
name|conf
init|=
operator|new
name|HdfsConfiguration
argument_list|()
decl_stmt|;
name|String
name|nameserviceId1
init|=
literal|"ns1"
decl_stmt|;
name|String
name|nameserviceId2
init|=
literal|"ns2"
decl_stmt|;
name|conf
operator|.
name|set
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMESERVICES
argument_list|,
name|nameserviceId1
operator|+
literal|","
operator|+
name|nameserviceId2
argument_list|)
expr_stmt|;
name|MiniDFSCluster
name|cluster
init|=
operator|new
name|MiniDFSCluster
operator|.
name|Builder
argument_list|(
name|conf
argument_list|)
operator|.
name|nnTopology
argument_list|(
name|MiniDFSNNTopology
operator|.
name|simpleFederatedTopology
argument_list|(
literal|2
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|Configuration
name|snConf1
init|=
operator|new
name|HdfsConfiguration
argument_list|(
name|cluster
operator|.
name|getConfiguration
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|Configuration
name|snConf2
init|=
operator|new
name|HdfsConfiguration
argument_list|(
name|cluster
operator|.
name|getConfiguration
argument_list|(
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|InetSocketAddress
name|nn1RpcAddress
init|=
name|cluster
operator|.
name|getNameNode
argument_list|(
literal|0
argument_list|)
operator|.
name|getNameNodeAddress
argument_list|()
decl_stmt|;
name|InetSocketAddress
name|nn2RpcAddress
init|=
name|cluster
operator|.
name|getNameNode
argument_list|(
literal|1
argument_list|)
operator|.
name|getNameNodeAddress
argument_list|()
decl_stmt|;
name|String
name|nn1
init|=
name|nn1RpcAddress
operator|.
name|getHostName
argument_list|()
operator|+
literal|":"
operator|+
name|nn1RpcAddress
operator|.
name|getPort
argument_list|()
decl_stmt|;
name|String
name|nn2
init|=
name|nn2RpcAddress
operator|.
name|getHostName
argument_list|()
operator|+
literal|":"
operator|+
name|nn2RpcAddress
operator|.
name|getPort
argument_list|()
decl_stmt|;
comment|// Set the Service Rpc address to empty to make sure the node specific
comment|// setting works
name|snConf1
operator|.
name|set
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_SERVICE_RPC_ADDRESS_KEY
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|snConf2
operator|.
name|set
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_SERVICE_RPC_ADDRESS_KEY
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|// Set the nameserviceIds
name|snConf1
operator|.
name|set
argument_list|(
name|DFSUtil
operator|.
name|addKeySuffixes
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_SERVICE_RPC_ADDRESS_KEY
argument_list|,
name|nameserviceId1
argument_list|)
argument_list|,
name|nn1
argument_list|)
expr_stmt|;
name|snConf2
operator|.
name|set
argument_list|(
name|DFSUtil
operator|.
name|addKeySuffixes
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_SERVICE_RPC_ADDRESS_KEY
argument_list|,
name|nameserviceId2
argument_list|)
argument_list|,
name|nn2
argument_list|)
expr_stmt|;
name|SecondaryNameNode
name|secondary1
init|=
name|startSecondaryNameNode
argument_list|(
name|snConf1
argument_list|)
decl_stmt|;
name|SecondaryNameNode
name|secondary2
init|=
name|startSecondaryNameNode
argument_list|(
name|snConf2
argument_list|)
decl_stmt|;
comment|// make sure the two secondary namenodes are talking to correct namenodes.
name|assertEquals
argument_list|(
name|secondary1
operator|.
name|getNameNodeAddress
argument_list|()
operator|.
name|getPort
argument_list|()
argument_list|,
name|nn1RpcAddress
operator|.
name|getPort
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|secondary2
operator|.
name|getNameNodeAddress
argument_list|()
operator|.
name|getPort
argument_list|()
argument_list|,
name|nn2RpcAddress
operator|.
name|getPort
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|secondary1
operator|.
name|getNameNodeAddress
argument_list|()
operator|.
name|getPort
argument_list|()
operator|!=
name|secondary2
operator|.
name|getNameNodeAddress
argument_list|()
operator|.
name|getPort
argument_list|()
argument_list|)
expr_stmt|;
comment|// both should checkpoint.
name|secondary1
operator|.
name|doCheckpoint
argument_list|()
expr_stmt|;
name|secondary2
operator|.
name|doCheckpoint
argument_list|()
expr_stmt|;
name|secondary1
operator|.
name|shutdown
argument_list|()
expr_stmt|;
name|secondary2
operator|.
name|shutdown
argument_list|()
expr_stmt|;
name|cluster
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
comment|/**    * Test that the secondary doesn't have to re-download image    * if it hasn't changed.    */
annotation|@
name|Test
DECL|method|testSecondaryImageDownload ()
specifier|public
name|void
name|testSecondaryImageDownload
parameter_list|()
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Starting testSecondaryImageDownload"
argument_list|)
expr_stmt|;
name|Configuration
name|conf
init|=
operator|new
name|HdfsConfiguration
argument_list|()
decl_stmt|;
name|conf
operator|.
name|set
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_SECONDARY_HTTP_ADDRESS_KEY
argument_list|,
literal|"0.0.0.0:0"
argument_list|)
expr_stmt|;
name|Path
name|dir
init|=
operator|new
name|Path
argument_list|(
literal|"/checkpoint"
argument_list|)
decl_stmt|;
name|MiniDFSCluster
name|cluster
init|=
operator|new
name|MiniDFSCluster
operator|.
name|Builder
argument_list|(
name|conf
argument_list|)
operator|.
name|numDataNodes
argument_list|(
name|numDatanodes
argument_list|)
operator|.
name|format
argument_list|(
literal|true
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|cluster
operator|.
name|waitActive
argument_list|()
expr_stmt|;
name|FileSystem
name|fileSys
init|=
name|cluster
operator|.
name|getFileSystem
argument_list|()
decl_stmt|;
name|FSImage
name|image
init|=
name|cluster
operator|.
name|getNameNode
argument_list|()
operator|.
name|getFSImage
argument_list|()
decl_stmt|;
try|try
block|{
name|assertTrue
argument_list|(
operator|!
name|fileSys
operator|.
name|exists
argument_list|(
name|dir
argument_list|)
argument_list|)
expr_stmt|;
comment|//
comment|// Make the checkpoint
comment|//
name|SecondaryNameNode
name|secondary
init|=
name|startSecondaryNameNode
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|File
name|secondaryDir
init|=
operator|new
name|File
argument_list|(
name|MiniDFSCluster
operator|.
name|getBaseDirectory
argument_list|()
argument_list|,
literal|"namesecondary1"
argument_list|)
decl_stmt|;
name|File
name|secondaryCurrent
init|=
operator|new
name|File
argument_list|(
name|secondaryDir
argument_list|,
literal|"current"
argument_list|)
decl_stmt|;
name|long
name|expectedTxIdToDownload
init|=
name|cluster
operator|.
name|getNameNode
argument_list|()
operator|.
name|getFSImage
argument_list|()
operator|.
name|getStorage
argument_list|()
operator|.
name|getMostRecentCheckpointTxId
argument_list|()
decl_stmt|;
name|File
name|secondaryFsImageBefore
init|=
operator|new
name|File
argument_list|(
name|secondaryCurrent
argument_list|,
name|NNStorage
operator|.
name|getImageFileName
argument_list|(
name|expectedTxIdToDownload
argument_list|)
argument_list|)
decl_stmt|;
name|File
name|secondaryFsImageAfter
init|=
operator|new
name|File
argument_list|(
name|secondaryCurrent
argument_list|,
name|NNStorage
operator|.
name|getImageFileName
argument_list|(
name|expectedTxIdToDownload
operator|+
literal|2
argument_list|)
argument_list|)
decl_stmt|;
name|assertFalse
argument_list|(
literal|"Secondary should start with empty current/ dir "
operator|+
literal|"but "
operator|+
name|secondaryFsImageBefore
operator|+
literal|" exists"
argument_list|,
name|secondaryFsImageBefore
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"Secondary should have loaded an image"
argument_list|,
name|secondary
operator|.
name|doCheckpoint
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"Secondary should have downloaded original image"
argument_list|,
name|secondaryFsImageBefore
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"Secondary should have created a new image"
argument_list|,
name|secondaryFsImageAfter
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
name|long
name|fsimageLength
init|=
name|secondaryFsImageBefore
operator|.
name|length
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
literal|"Image size should not have changed"
argument_list|,
name|fsimageLength
argument_list|,
name|secondaryFsImageAfter
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
comment|// change namespace
name|fileSys
operator|.
name|mkdirs
argument_list|(
name|dir
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
literal|"Another checkpoint should not have to re-load image"
argument_list|,
name|secondary
operator|.
name|doCheckpoint
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|StorageDirectory
name|sd
range|:
name|image
operator|.
name|getStorage
argument_list|()
operator|.
name|dirIterable
argument_list|(
name|NameNodeDirType
operator|.
name|IMAGE
argument_list|)
control|)
block|{
name|File
name|imageFile
init|=
name|NNStorage
operator|.
name|getImageFile
argument_list|(
name|sd
argument_list|,
name|expectedTxIdToDownload
operator|+
literal|5
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
literal|"Image size increased"
argument_list|,
name|imageFile
operator|.
name|length
argument_list|()
operator|>
name|fsimageLength
argument_list|)
expr_stmt|;
block|}
name|secondary
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|fileSys
operator|.
name|close
argument_list|()
expr_stmt|;
name|cluster
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Test NN restart if a failure happens in between creating the fsimage    * MD5 file and renaming the fsimage.    */
annotation|@
name|Test
argument_list|(
name|timeout
operator|=
literal|30000
argument_list|)
DECL|method|testFailureBeforeRename ()
specifier|public
name|void
name|testFailureBeforeRename
parameter_list|()
throws|throws
name|IOException
block|{
name|Configuration
name|conf
init|=
operator|new
name|HdfsConfiguration
argument_list|()
decl_stmt|;
name|FSDataOutputStream
name|fos
init|=
literal|null
decl_stmt|;
name|SecondaryNameNode
name|secondary
init|=
literal|null
decl_stmt|;
name|MiniDFSCluster
name|cluster
init|=
literal|null
decl_stmt|;
name|FileSystem
name|fs
init|=
literal|null
decl_stmt|;
name|NameNode
name|namenode
init|=
literal|null
decl_stmt|;
try|try
block|{
name|cluster
operator|=
operator|new
name|MiniDFSCluster
operator|.
name|Builder
argument_list|(
name|conf
argument_list|)
operator|.
name|numDataNodes
argument_list|(
name|numDatanodes
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
name|cluster
operator|.
name|waitActive
argument_list|()
expr_stmt|;
name|namenode
operator|=
name|cluster
operator|.
name|getNameNode
argument_list|()
expr_stmt|;
name|fs
operator|=
name|cluster
operator|.
name|getFileSystem
argument_list|()
expr_stmt|;
name|secondary
operator|=
name|startSecondaryNameNode
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|fos
operator|=
name|fs
operator|.
name|create
argument_list|(
operator|new
name|Path
argument_list|(
literal|"tmpfile0"
argument_list|)
argument_list|)
expr_stmt|;
name|fos
operator|.
name|write
argument_list|(
operator|new
name|byte
index|[]
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|3
block|}
argument_list|)
expr_stmt|;
name|secondary
operator|.
name|doCheckpoint
argument_list|()
expr_stmt|;
name|fos
operator|.
name|write
argument_list|(
operator|new
name|byte
index|[]
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|3
block|}
argument_list|)
expr_stmt|;
name|fos
operator|.
name|hsync
argument_list|()
expr_stmt|;
comment|// Cause merge to fail in next checkpoint.
name|Mockito
operator|.
name|doThrow
argument_list|(
operator|new
name|IOException
argument_list|(
literal|"Injecting failure after MD5Rename"
argument_list|)
argument_list|)
operator|.
name|when
argument_list|(
name|faultInjector
argument_list|)
operator|.
name|afterMD5Rename
argument_list|()
expr_stmt|;
try|try
block|{
name|secondary
operator|.
name|doCheckpoint
argument_list|()
expr_stmt|;
name|fail
argument_list|(
literal|"Fault injection failed."
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
comment|// This is expected.
block|}
name|Mockito
operator|.
name|reset
argument_list|(
name|faultInjector
argument_list|)
expr_stmt|;
comment|// Namenode should still restart successfully
name|cluster
operator|.
name|restartNameNode
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|secondary
operator|!=
literal|null
condition|)
block|{
name|secondary
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|fs
operator|!=
literal|null
condition|)
block|{
name|fs
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|cluster
operator|!=
literal|null
condition|)
block|{
name|cluster
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
name|Mockito
operator|.
name|reset
argument_list|(
name|faultInjector
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Test case where two secondary namenodes are checkpointing the same    * NameNode. This differs from {@link #testMultipleSecondaryNamenodes()}    * since that test runs against two distinct NNs.    *     * This case tests the following interleaving:    * - 2NN A downloads image (up to txid 2)    * - 2NN A about to save its own checkpoint    * - 2NN B downloads image (up to txid 4)    * - 2NN B uploads checkpoint (txid 4)    * - 2NN A uploads checkpoint (txid 2)    *     * It verifies that this works even though the earlier-txid checkpoint gets    * uploaded after the later-txid checkpoint.    */
annotation|@
name|Test
DECL|method|testMultipleSecondaryNNsAgainstSameNN ()
specifier|public
name|void
name|testMultipleSecondaryNNsAgainstSameNN
parameter_list|()
throws|throws
name|Exception
block|{
name|Configuration
name|conf
init|=
operator|new
name|HdfsConfiguration
argument_list|()
decl_stmt|;
name|MiniDFSCluster
name|cluster
init|=
operator|new
name|MiniDFSCluster
operator|.
name|Builder
argument_list|(
name|conf
argument_list|)
operator|.
name|numDataNodes
argument_list|(
literal|0
argument_list|)
operator|.
name|format
argument_list|(
literal|true
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|SecondaryNameNode
name|secondary1
init|=
literal|null
decl_stmt|,
name|secondary2
init|=
literal|null
decl_stmt|;
try|try
block|{
comment|// Start 2NNs
name|secondary1
operator|=
name|startSecondaryNameNode
argument_list|(
name|conf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|secondary2
operator|=
name|startSecondaryNameNode
argument_list|(
name|conf
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|// Make the first 2NN's checkpoint process delayable - we can pause it
comment|// right before it saves its checkpoint image.
name|CheckpointStorage
name|spyImage1
init|=
name|spyOnSecondaryImage
argument_list|(
name|secondary1
argument_list|)
decl_stmt|;
name|DelayAnswer
name|delayer
init|=
operator|new
name|DelayAnswer
argument_list|(
name|LOG
argument_list|)
decl_stmt|;
name|Mockito
operator|.
name|doAnswer
argument_list|(
name|delayer
argument_list|)
operator|.
name|when
argument_list|(
name|spyImage1
argument_list|)
operator|.
name|saveFSImageInAllDirs
argument_list|(
name|Mockito
operator|.
expr|<
name|FSNamesystem
operator|>
name|any
argument_list|()
argument_list|,
name|Mockito
operator|.
name|anyLong
argument_list|()
argument_list|)
expr_stmt|;
comment|// Set up a thread to do a checkpoint from the first 2NN
name|DoCheckpointThread
name|checkpointThread
init|=
operator|new
name|DoCheckpointThread
argument_list|(
name|secondary1
argument_list|)
decl_stmt|;
name|checkpointThread
operator|.
name|start
argument_list|()
expr_stmt|;
comment|// Wait for the first checkpointer to get to where it should save its image.
name|delayer
operator|.
name|waitForCall
argument_list|()
expr_stmt|;
comment|// Now make the second checkpointer run an entire checkpoint
name|secondary2
operator|.
name|doCheckpoint
argument_list|()
expr_stmt|;
comment|// Let the first one finish
name|delayer
operator|.
name|proceed
argument_list|()
expr_stmt|;
comment|// It should have succeeded even though another checkpoint raced with it.
name|checkpointThread
operator|.
name|join
argument_list|()
expr_stmt|;
name|checkpointThread
operator|.
name|propagateExceptions
argument_list|()
expr_stmt|;
comment|// primary should record "last checkpoint" as the higher txid (even though
comment|// a checkpoint with a lower txid finished most recently)
name|NNStorage
name|storage
init|=
name|cluster
operator|.
name|getNameNode
argument_list|()
operator|.
name|getFSImage
argument_list|()
operator|.
name|getStorage
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
literal|4
argument_list|,
name|storage
operator|.
name|getMostRecentCheckpointTxId
argument_list|()
argument_list|)
expr_stmt|;
comment|// Should have accepted both checkpoints
name|assertNNHasCheckpoints
argument_list|(
name|cluster
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
literal|2
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
comment|// Now have second one checkpoint one more time just to make sure that
comment|// the NN isn't left in a broken state
name|secondary2
operator|.
name|doCheckpoint
argument_list|()
expr_stmt|;
comment|// NN should have received new checkpoint
name|assertEquals
argument_list|(
literal|6
argument_list|,
name|storage
operator|.
name|getMostRecentCheckpointTxId
argument_list|()
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|cleanup
argument_list|(
name|secondary1
argument_list|)
expr_stmt|;
name|cleanup
argument_list|(
name|secondary2
argument_list|)
expr_stmt|;
if|if
condition|(
name|cluster
operator|!=
literal|null
condition|)
block|{
name|cluster
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
block|}
comment|// Validate invariant that files named the same are the same.
name|assertParallelFilesInvariant
argument_list|(
name|cluster
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|secondary1
argument_list|,
name|secondary2
argument_list|)
argument_list|)
expr_stmt|;
comment|// NN should have removed the checkpoint at txid 2 at this point, but has
comment|// one at txid 6
name|assertNNHasCheckpoints
argument_list|(
name|cluster
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
literal|4
argument_list|,
literal|6
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Test case where two secondary namenodes are checkpointing the same    * NameNode. This differs from {@link #testMultipleSecondaryNamenodes()}    * since that test runs against two distinct NNs.    *     * This case tests the following interleaving:    * - 2NN A) calls rollEdits()    * - 2NN B) calls rollEdits()    * - 2NN A) paused at getRemoteEditLogManifest()    * - 2NN B) calls getRemoteEditLogManifest() (returns up to txid 4)    * - 2NN B) uploads checkpoint fsimage_4    * - 2NN A) allowed to proceed, also returns up to txid 4    * - 2NN A) uploads checkpoint fsimage_4 as well, should fail gracefully    *     * It verifies that one of the two gets an error that it's uploading a    * duplicate checkpoint, and the other one succeeds.    */
annotation|@
name|Test
DECL|method|testMultipleSecondaryNNsAgainstSameNN2 ()
specifier|public
name|void
name|testMultipleSecondaryNNsAgainstSameNN2
parameter_list|()
throws|throws
name|Exception
block|{
name|Configuration
name|conf
init|=
operator|new
name|HdfsConfiguration
argument_list|()
decl_stmt|;
name|MiniDFSCluster
name|cluster
init|=
operator|new
name|MiniDFSCluster
operator|.
name|Builder
argument_list|(
name|conf
argument_list|)
operator|.
name|numDataNodes
argument_list|(
literal|0
argument_list|)
operator|.
name|format
argument_list|(
literal|true
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|SecondaryNameNode
name|secondary1
init|=
literal|null
decl_stmt|,
name|secondary2
init|=
literal|null
decl_stmt|;
try|try
block|{
comment|// Start 2NNs
name|secondary1
operator|=
name|startSecondaryNameNode
argument_list|(
name|conf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|secondary2
operator|=
name|startSecondaryNameNode
argument_list|(
name|conf
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|// Make the first 2NN's checkpoint process delayable - we can pause it
comment|// right before it calls getRemoteEditLogManifest.
comment|// The method to set up a spy on an RPC protocol is a little bit involved
comment|// since we can't spy directly on a proxy object. This sets up a mock
comment|// which delegates all its calls to the original object, instead.
specifier|final
name|NamenodeProtocol
name|origNN
init|=
name|secondary1
operator|.
name|getNameNode
argument_list|()
decl_stmt|;
specifier|final
name|Answer
argument_list|<
name|Object
argument_list|>
name|delegator
init|=
operator|new
name|GenericTestUtils
operator|.
name|DelegateAnswer
argument_list|(
name|origNN
argument_list|)
decl_stmt|;
name|NamenodeProtocol
name|spyNN
init|=
name|Mockito
operator|.
name|mock
argument_list|(
name|NamenodeProtocol
operator|.
name|class
argument_list|,
name|delegator
argument_list|)
decl_stmt|;
name|DelayAnswer
name|delayer
init|=
operator|new
name|DelayAnswer
argument_list|(
name|LOG
argument_list|)
block|{
annotation|@
name|Override
specifier|protected
name|Object
name|passThrough
parameter_list|(
name|InvocationOnMock
name|invocation
parameter_list|)
throws|throws
name|Throwable
block|{
return|return
name|delegator
operator|.
name|answer
argument_list|(
name|invocation
argument_list|)
return|;
block|}
block|}
decl_stmt|;
name|secondary1
operator|.
name|setNameNode
argument_list|(
name|spyNN
argument_list|)
expr_stmt|;
name|Mockito
operator|.
name|doAnswer
argument_list|(
name|delayer
argument_list|)
operator|.
name|when
argument_list|(
name|spyNN
argument_list|)
operator|.
name|getEditLogManifest
argument_list|(
name|Mockito
operator|.
name|anyLong
argument_list|()
argument_list|)
expr_stmt|;
comment|// Set up a thread to do a checkpoint from the first 2NN
name|DoCheckpointThread
name|checkpointThread
init|=
operator|new
name|DoCheckpointThread
argument_list|(
name|secondary1
argument_list|)
decl_stmt|;
name|checkpointThread
operator|.
name|start
argument_list|()
expr_stmt|;
comment|// Wait for the first checkpointer to be about to call getEditLogManifest
name|delayer
operator|.
name|waitForCall
argument_list|()
expr_stmt|;
comment|// Now make the second checkpointer run an entire checkpoint
name|secondary2
operator|.
name|doCheckpoint
argument_list|()
expr_stmt|;
comment|// NN should have now received fsimage_4
name|NNStorage
name|storage
init|=
name|cluster
operator|.
name|getNameNode
argument_list|()
operator|.
name|getFSImage
argument_list|()
operator|.
name|getStorage
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
literal|4
argument_list|,
name|storage
operator|.
name|getMostRecentCheckpointTxId
argument_list|()
argument_list|)
expr_stmt|;
comment|// Let the first one finish
name|delayer
operator|.
name|proceed
argument_list|()
expr_stmt|;
comment|// Letting the first node continue, it should try to upload the
comment|// same image, and gracefully ignore it, while logging an
comment|// error message.
name|checkpointThread
operator|.
name|join
argument_list|()
expr_stmt|;
name|checkpointThread
operator|.
name|propagateExceptions
argument_list|()
expr_stmt|;
comment|// primary should still consider fsimage_4 the latest
name|assertEquals
argument_list|(
literal|4
argument_list|,
name|storage
operator|.
name|getMostRecentCheckpointTxId
argument_list|()
argument_list|)
expr_stmt|;
comment|// Now have second one checkpoint one more time just to make sure that
comment|// the NN isn't left in a broken state
name|secondary2
operator|.
name|doCheckpoint
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
literal|6
argument_list|,
name|storage
operator|.
name|getMostRecentCheckpointTxId
argument_list|()
argument_list|)
expr_stmt|;
comment|// Should have accepted both checkpoints
name|assertNNHasCheckpoints
argument_list|(
name|cluster
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
literal|4
argument_list|,
literal|6
argument_list|)
argument_list|)
expr_stmt|;
comment|// Let the first one also go again on its own to make sure it can
comment|// continue at next checkpoint
name|secondary1
operator|.
name|setNameNode
argument_list|(
name|origNN
argument_list|)
expr_stmt|;
name|secondary1
operator|.
name|doCheckpoint
argument_list|()
expr_stmt|;
comment|// NN should have received new checkpoint
name|assertEquals
argument_list|(
literal|8
argument_list|,
name|storage
operator|.
name|getMostRecentCheckpointTxId
argument_list|()
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|cleanup
argument_list|(
name|secondary1
argument_list|)
expr_stmt|;
name|cleanup
argument_list|(
name|secondary2
argument_list|)
expr_stmt|;
if|if
condition|(
name|cluster
operator|!=
literal|null
condition|)
block|{
name|cluster
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
block|}
comment|// Validate invariant that files named the same are the same.
name|assertParallelFilesInvariant
argument_list|(
name|cluster
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|secondary1
argument_list|,
name|secondary2
argument_list|)
argument_list|)
expr_stmt|;
comment|// Validate that the NN received checkpoints at expected txids
comment|// (i.e that both checkpoints went through)
name|assertNNHasCheckpoints
argument_list|(
name|cluster
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
literal|6
argument_list|,
literal|8
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Test case where the name node is reformatted while the secondary namenode    * is running. The secondary should shut itself down if if talks to a NN    * with the wrong namespace.    */
annotation|@
name|Test
DECL|method|testReformatNNBetweenCheckpoints ()
specifier|public
name|void
name|testReformatNNBetweenCheckpoints
parameter_list|()
throws|throws
name|IOException
block|{
name|MiniDFSCluster
name|cluster
init|=
literal|null
decl_stmt|;
name|SecondaryNameNode
name|secondary
init|=
literal|null
decl_stmt|;
name|Configuration
name|conf
init|=
operator|new
name|HdfsConfiguration
argument_list|()
decl_stmt|;
name|conf
operator|.
name|setInt
argument_list|(
name|CommonConfigurationKeysPublic
operator|.
name|IPC_CLIENT_CONNECTION_MAXIDLETIME_KEY
argument_list|,
literal|1
argument_list|)
expr_stmt|;
try|try
block|{
name|cluster
operator|=
operator|new
name|MiniDFSCluster
operator|.
name|Builder
argument_list|(
name|conf
argument_list|)
operator|.
name|numDataNodes
argument_list|(
literal|0
argument_list|)
operator|.
name|format
argument_list|(
literal|true
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
name|int
name|origPort
init|=
name|cluster
operator|.
name|getNameNodePort
argument_list|()
decl_stmt|;
name|int
name|origHttpPort
init|=
name|cluster
operator|.
name|getNameNode
argument_list|()
operator|.
name|getHttpAddress
argument_list|()
operator|.
name|getPort
argument_list|()
decl_stmt|;
name|secondary
operator|=
name|startSecondaryNameNode
argument_list|(
name|conf
argument_list|)
expr_stmt|;
comment|// secondary checkpoints once
name|secondary
operator|.
name|doCheckpoint
argument_list|()
expr_stmt|;
comment|// we reformat primary NN
name|cluster
operator|.
name|shutdown
argument_list|()
expr_stmt|;
name|cluster
operator|=
literal|null
expr_stmt|;
comment|// Brief sleep to make sure that the 2NN's IPC connection to the NN
comment|// is dropped.
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{       }
comment|// Start a new NN with the same host/port.
name|cluster
operator|=
operator|new
name|MiniDFSCluster
operator|.
name|Builder
argument_list|(
name|conf
argument_list|)
operator|.
name|numDataNodes
argument_list|(
literal|0
argument_list|)
operator|.
name|nameNodePort
argument_list|(
name|origPort
argument_list|)
operator|.
name|nameNodeHttpPort
argument_list|(
name|origHttpPort
argument_list|)
operator|.
name|format
argument_list|(
literal|true
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
try|try
block|{
name|secondary
operator|.
name|doCheckpoint
argument_list|()
expr_stmt|;
name|fail
argument_list|(
literal|"Should have failed checkpoint against a different namespace"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Got expected failure"
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|ioe
operator|.
name|toString
argument_list|()
operator|.
name|contains
argument_list|(
literal|"Inconsistent checkpoint"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
if|if
condition|(
name|secondary
operator|!=
literal|null
condition|)
block|{
name|secondary
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|cluster
operator|!=
literal|null
condition|)
block|{
name|cluster
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Test that the primary NN will not serve any files to a 2NN who doesn't    * share its namespace ID, and also will not accept any files from one.    */
annotation|@
name|Test
DECL|method|testNamespaceVerifiedOnFileTransfer ()
specifier|public
name|void
name|testNamespaceVerifiedOnFileTransfer
parameter_list|()
throws|throws
name|IOException
block|{
name|MiniDFSCluster
name|cluster
init|=
literal|null
decl_stmt|;
name|Configuration
name|conf
init|=
operator|new
name|HdfsConfiguration
argument_list|()
decl_stmt|;
try|try
block|{
name|cluster
operator|=
operator|new
name|MiniDFSCluster
operator|.
name|Builder
argument_list|(
name|conf
argument_list|)
operator|.
name|numDataNodes
argument_list|(
literal|0
argument_list|)
operator|.
name|format
argument_list|(
literal|true
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
name|NamenodeProtocols
name|nn
init|=
name|cluster
operator|.
name|getNameNodeRpc
argument_list|()
decl_stmt|;
name|String
name|fsName
init|=
name|NetUtils
operator|.
name|getHostPortString
argument_list|(
name|cluster
operator|.
name|getNameNode
argument_list|()
operator|.
name|getHttpAddress
argument_list|()
argument_list|)
decl_stmt|;
comment|// Make a finalized log on the server side.
name|nn
operator|.
name|rollEditLog
argument_list|()
expr_stmt|;
name|RemoteEditLogManifest
name|manifest
init|=
name|nn
operator|.
name|getEditLogManifest
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|RemoteEditLog
name|log
init|=
name|manifest
operator|.
name|getLogs
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|NNStorage
name|dstImage
init|=
name|Mockito
operator|.
name|mock
argument_list|(
name|NNStorage
operator|.
name|class
argument_list|)
decl_stmt|;
name|Mockito
operator|.
name|doReturn
argument_list|(
name|Lists
operator|.
name|newArrayList
argument_list|(
operator|new
name|File
argument_list|(
literal|"/wont-be-written"
argument_list|)
argument_list|)
argument_list|)
operator|.
name|when
argument_list|(
name|dstImage
argument_list|)
operator|.
name|getFiles
argument_list|(
name|Mockito
operator|.
expr|<
name|NameNodeDirType
operator|>
name|anyObject
argument_list|()
argument_list|,
name|Mockito
operator|.
name|anyString
argument_list|()
argument_list|)
expr_stmt|;
name|Mockito
operator|.
name|doReturn
argument_list|(
operator|new
name|StorageInfo
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|,
literal|"X"
argument_list|,
literal|1
argument_list|)
operator|.
name|toColonSeparatedString
argument_list|()
argument_list|)
operator|.
name|when
argument_list|(
name|dstImage
argument_list|)
operator|.
name|toColonSeparatedString
argument_list|()
expr_stmt|;
try|try
block|{
name|TransferFsImage
operator|.
name|downloadImageToStorage
argument_list|(
name|fsName
argument_list|,
literal|0
argument_list|,
name|dstImage
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"Storage info was not verified"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|String
name|msg
init|=
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|ioe
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|msg
argument_list|,
name|msg
operator|.
name|contains
argument_list|(
literal|"but the secondary expected"
argument_list|)
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|TransferFsImage
operator|.
name|downloadEditsToStorage
argument_list|(
name|fsName
argument_list|,
name|log
argument_list|,
name|dstImage
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"Storage info was not verified"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|String
name|msg
init|=
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|ioe
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|msg
argument_list|,
name|msg
operator|.
name|contains
argument_list|(
literal|"but the secondary expected"
argument_list|)
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|InetSocketAddress
name|fakeAddr
init|=
operator|new
name|InetSocketAddress
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|TransferFsImage
operator|.
name|uploadImageFromStorage
argument_list|(
name|fsName
argument_list|,
name|fakeAddr
argument_list|,
name|dstImage
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"Storage info was not verified"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|String
name|msg
init|=
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|ioe
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|msg
argument_list|,
name|msg
operator|.
name|contains
argument_list|(
literal|"but the secondary expected"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
if|if
condition|(
name|cluster
operator|!=
literal|null
condition|)
block|{
name|cluster
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Test that, if a storage directory is failed when a checkpoint occurs,    * the non-failed storage directory receives the checkpoint.    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"deprecation"
argument_list|)
annotation|@
name|Test
DECL|method|testCheckpointWithFailedStorageDir ()
specifier|public
name|void
name|testCheckpointWithFailedStorageDir
parameter_list|()
throws|throws
name|Exception
block|{
name|MiniDFSCluster
name|cluster
init|=
literal|null
decl_stmt|;
name|SecondaryNameNode
name|secondary
init|=
literal|null
decl_stmt|;
name|File
name|currentDir
init|=
literal|null
decl_stmt|;
name|Configuration
name|conf
init|=
operator|new
name|HdfsConfiguration
argument_list|()
decl_stmt|;
try|try
block|{
name|cluster
operator|=
operator|new
name|MiniDFSCluster
operator|.
name|Builder
argument_list|(
name|conf
argument_list|)
operator|.
name|numDataNodes
argument_list|(
literal|0
argument_list|)
operator|.
name|format
argument_list|(
literal|true
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
name|secondary
operator|=
name|startSecondaryNameNode
argument_list|(
name|conf
argument_list|)
expr_stmt|;
comment|// Checkpoint once
name|secondary
operator|.
name|doCheckpoint
argument_list|()
expr_stmt|;
comment|// Now primary NN experiences failure of a volume -- fake by
comment|// setting its current dir to a-x permissions
name|NamenodeProtocols
name|nn
init|=
name|cluster
operator|.
name|getNameNodeRpc
argument_list|()
decl_stmt|;
name|NNStorage
name|storage
init|=
name|cluster
operator|.
name|getNameNode
argument_list|()
operator|.
name|getFSImage
argument_list|()
operator|.
name|getStorage
argument_list|()
decl_stmt|;
name|StorageDirectory
name|sd0
init|=
name|storage
operator|.
name|getStorageDir
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|StorageDirectory
name|sd1
init|=
name|storage
operator|.
name|getStorageDir
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|currentDir
operator|=
name|sd0
operator|.
name|getCurrentDir
argument_list|()
expr_stmt|;
name|currentDir
operator|.
name|setExecutable
argument_list|(
literal|false
argument_list|)
expr_stmt|;
comment|// Upload checkpoint when NN has a bad storage dir. This should
comment|// succeed and create the checkpoint in the good dir.
name|secondary
operator|.
name|doCheckpoint
argument_list|()
expr_stmt|;
name|GenericTestUtils
operator|.
name|assertExists
argument_list|(
operator|new
name|File
argument_list|(
name|sd1
operator|.
name|getCurrentDir
argument_list|()
argument_list|,
name|NNStorage
operator|.
name|getImageFileName
argument_list|(
literal|2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// Restore the good dir
name|currentDir
operator|.
name|setExecutable
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|nn
operator|.
name|restoreFailedStorage
argument_list|(
literal|"true"
argument_list|)
expr_stmt|;
name|nn
operator|.
name|rollEditLog
argument_list|()
expr_stmt|;
comment|// Checkpoint again -- this should upload to both dirs
name|secondary
operator|.
name|doCheckpoint
argument_list|()
expr_stmt|;
name|assertNNHasCheckpoints
argument_list|(
name|cluster
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
literal|8
argument_list|)
argument_list|)
expr_stmt|;
name|assertParallelFilesInvariant
argument_list|(
name|cluster
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|secondary
argument_list|)
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|currentDir
operator|!=
literal|null
condition|)
block|{
name|currentDir
operator|.
name|setExecutable
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|secondary
operator|!=
literal|null
condition|)
block|{
name|secondary
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|cluster
operator|!=
literal|null
condition|)
block|{
name|cluster
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Test case where the NN is configured with a name-only and an edits-only    * dir, with storage-restore turned on. In this case, if the name-only dir    * disappears and comes back, a new checkpoint after it has been restored    * should function correctly.    * @throws Exception    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"deprecation"
argument_list|)
annotation|@
name|Test
DECL|method|testCheckpointWithSeparateDirsAfterNameFails ()
specifier|public
name|void
name|testCheckpointWithSeparateDirsAfterNameFails
parameter_list|()
throws|throws
name|Exception
block|{
name|MiniDFSCluster
name|cluster
init|=
literal|null
decl_stmt|;
name|SecondaryNameNode
name|secondary
init|=
literal|null
decl_stmt|;
name|File
name|currentDir
init|=
literal|null
decl_stmt|;
name|Configuration
name|conf
init|=
operator|new
name|HdfsConfiguration
argument_list|()
decl_stmt|;
name|File
name|base_dir
init|=
operator|new
name|File
argument_list|(
name|MiniDFSCluster
operator|.
name|getBaseDirectory
argument_list|()
argument_list|)
decl_stmt|;
name|conf
operator|.
name|setBoolean
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_NAME_DIR_RESTORE_KEY
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|conf
operator|.
name|set
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_NAME_DIR_KEY
argument_list|,
name|MiniDFSCluster
operator|.
name|getBaseDirectory
argument_list|()
operator|+
literal|"/name-only"
argument_list|)
expr_stmt|;
name|conf
operator|.
name|set
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_EDITS_DIR_KEY
argument_list|,
name|MiniDFSCluster
operator|.
name|getBaseDirectory
argument_list|()
operator|+
literal|"/edits-only"
argument_list|)
expr_stmt|;
name|conf
operator|.
name|set
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_CHECKPOINT_DIR_KEY
argument_list|,
name|fileAsURI
argument_list|(
operator|new
name|File
argument_list|(
name|base_dir
argument_list|,
literal|"namesecondary1"
argument_list|)
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
try|try
block|{
name|cluster
operator|=
operator|new
name|MiniDFSCluster
operator|.
name|Builder
argument_list|(
name|conf
argument_list|)
operator|.
name|numDataNodes
argument_list|(
literal|0
argument_list|)
operator|.
name|format
argument_list|(
literal|true
argument_list|)
operator|.
name|manageNameDfsDirs
argument_list|(
literal|false
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
name|secondary
operator|=
name|startSecondaryNameNode
argument_list|(
name|conf
argument_list|)
expr_stmt|;
comment|// Checkpoint once
name|secondary
operator|.
name|doCheckpoint
argument_list|()
expr_stmt|;
comment|// Now primary NN experiences failure of its only name dir -- fake by
comment|// setting its current dir to a-x permissions
name|NamenodeProtocols
name|nn
init|=
name|cluster
operator|.
name|getNameNodeRpc
argument_list|()
decl_stmt|;
name|NNStorage
name|storage
init|=
name|cluster
operator|.
name|getNameNode
argument_list|()
operator|.
name|getFSImage
argument_list|()
operator|.
name|getStorage
argument_list|()
decl_stmt|;
name|StorageDirectory
name|sd0
init|=
name|storage
operator|.
name|getStorageDir
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|NameNodeDirType
operator|.
name|IMAGE
argument_list|,
name|sd0
operator|.
name|getStorageDirType
argument_list|()
argument_list|)
expr_stmt|;
name|currentDir
operator|=
name|sd0
operator|.
name|getCurrentDir
argument_list|()
expr_stmt|;
name|currentDir
operator|.
name|setExecutable
argument_list|(
literal|false
argument_list|)
expr_stmt|;
comment|// Try to upload checkpoint -- this should fail since there are no
comment|// valid storage dirs
try|try
block|{
name|secondary
operator|.
name|doCheckpoint
argument_list|()
expr_stmt|;
name|fail
argument_list|(
literal|"Did not fail to checkpoint when there are no valid storage dirs"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|GenericTestUtils
operator|.
name|assertExceptionContains
argument_list|(
literal|"No targets in destination storage"
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
block|}
comment|// Restore the good dir
name|currentDir
operator|.
name|setExecutable
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|nn
operator|.
name|restoreFailedStorage
argument_list|(
literal|"true"
argument_list|)
expr_stmt|;
name|nn
operator|.
name|rollEditLog
argument_list|()
expr_stmt|;
comment|// Checkpoint again -- this should upload to the restored name dir
name|secondary
operator|.
name|doCheckpoint
argument_list|()
expr_stmt|;
name|assertNNHasCheckpoints
argument_list|(
name|cluster
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
literal|8
argument_list|)
argument_list|)
expr_stmt|;
name|assertParallelFilesInvariant
argument_list|(
name|cluster
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|secondary
argument_list|)
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|currentDir
operator|!=
literal|null
condition|)
block|{
name|currentDir
operator|.
name|setExecutable
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|secondary
operator|!=
literal|null
condition|)
block|{
name|secondary
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|cluster
operator|!=
literal|null
condition|)
block|{
name|cluster
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Test that the 2NN triggers a checkpoint after the configurable interval    */
annotation|@
name|Test
argument_list|(
name|timeout
operator|=
literal|30000
argument_list|)
DECL|method|testCheckpointTriggerOnTxnCount ()
specifier|public
name|void
name|testCheckpointTriggerOnTxnCount
parameter_list|()
throws|throws
name|Exception
block|{
name|MiniDFSCluster
name|cluster
init|=
literal|null
decl_stmt|;
name|SecondaryNameNode
name|secondary
init|=
literal|null
decl_stmt|;
name|Configuration
name|conf
init|=
operator|new
name|HdfsConfiguration
argument_list|()
decl_stmt|;
name|conf
operator|.
name|setInt
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_CHECKPOINT_TXNS_KEY
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|conf
operator|.
name|setInt
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_CHECKPOINT_CHECK_PERIOD_KEY
argument_list|,
literal|1
argument_list|)
expr_stmt|;
try|try
block|{
name|cluster
operator|=
operator|new
name|MiniDFSCluster
operator|.
name|Builder
argument_list|(
name|conf
argument_list|)
operator|.
name|numDataNodes
argument_list|(
literal|0
argument_list|)
operator|.
name|format
argument_list|(
literal|true
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
name|FileSystem
name|fs
init|=
name|cluster
operator|.
name|getFileSystem
argument_list|()
decl_stmt|;
name|secondary
operator|=
name|startSecondaryNameNode
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|secondary
operator|.
name|startCheckpointThread
argument_list|()
expr_stmt|;
specifier|final
name|NNStorage
name|storage
init|=
name|secondary
operator|.
name|getFSImage
argument_list|()
operator|.
name|getStorage
argument_list|()
decl_stmt|;
comment|// 2NN should checkpoint at startup
name|GenericTestUtils
operator|.
name|waitFor
argument_list|(
operator|new
name|Supplier
argument_list|<
name|Boolean
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Boolean
name|get
parameter_list|()
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Waiting for checkpoint txn id to go to 2"
argument_list|)
expr_stmt|;
return|return
name|storage
operator|.
name|getMostRecentCheckpointTxId
argument_list|()
operator|==
literal|2
return|;
block|}
block|}
argument_list|,
literal|200
argument_list|,
literal|15000
argument_list|)
expr_stmt|;
comment|// If we make 10 transactions, it should checkpoint again
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
block|{
name|fs
operator|.
name|mkdirs
argument_list|(
operator|new
name|Path
argument_list|(
literal|"/test"
operator|+
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|GenericTestUtils
operator|.
name|waitFor
argument_list|(
operator|new
name|Supplier
argument_list|<
name|Boolean
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Boolean
name|get
parameter_list|()
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Waiting for checkpoint txn id to go> 2"
argument_list|)
expr_stmt|;
return|return
name|storage
operator|.
name|getMostRecentCheckpointTxId
argument_list|()
operator|>
literal|2
return|;
block|}
block|}
argument_list|,
literal|200
argument_list|,
literal|15000
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|cleanup
argument_list|(
name|secondary
argument_list|)
expr_stmt|;
if|if
condition|(
name|cluster
operator|!=
literal|null
condition|)
block|{
name|cluster
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Test case where the secondary does a checkpoint, then stops for a while.    * In the meantime, the NN saves its image several times, so that the    * logs that connect the 2NN's old checkpoint to the current txid    * get archived. Then, the 2NN tries to checkpoint again.    */
annotation|@
name|Test
DECL|method|testSecondaryHasVeryOutOfDateImage ()
specifier|public
name|void
name|testSecondaryHasVeryOutOfDateImage
parameter_list|()
throws|throws
name|IOException
block|{
name|MiniDFSCluster
name|cluster
init|=
literal|null
decl_stmt|;
name|SecondaryNameNode
name|secondary
init|=
literal|null
decl_stmt|;
name|Configuration
name|conf
init|=
operator|new
name|HdfsConfiguration
argument_list|()
decl_stmt|;
try|try
block|{
name|cluster
operator|=
operator|new
name|MiniDFSCluster
operator|.
name|Builder
argument_list|(
name|conf
argument_list|)
operator|.
name|numDataNodes
argument_list|(
name|numDatanodes
argument_list|)
operator|.
name|format
argument_list|(
literal|true
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
name|secondary
operator|=
name|startSecondaryNameNode
argument_list|(
name|conf
argument_list|)
expr_stmt|;
comment|// Checkpoint once
name|secondary
operator|.
name|doCheckpoint
argument_list|()
expr_stmt|;
comment|// Now primary NN saves namespace 3 times
name|NamenodeProtocols
name|nn
init|=
name|cluster
operator|.
name|getNameNodeRpc
argument_list|()
decl_stmt|;
name|nn
operator|.
name|setSafeMode
argument_list|(
name|SafeModeAction
operator|.
name|SAFEMODE_ENTER
argument_list|,
literal|false
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
block|{
name|nn
operator|.
name|saveNamespace
argument_list|()
expr_stmt|;
block|}
name|nn
operator|.
name|setSafeMode
argument_list|(
name|SafeModeAction
operator|.
name|SAFEMODE_LEAVE
argument_list|,
literal|false
argument_list|)
expr_stmt|;
comment|// Now the secondary tries to checkpoint again with its
comment|// old image in memory.
name|secondary
operator|.
name|doCheckpoint
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|secondary
operator|!=
literal|null
condition|)
block|{
name|secondary
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|cluster
operator|!=
literal|null
condition|)
block|{
name|cluster
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Regression test for HDFS-3678 "Edit log files are never being purged from 2NN"    */
annotation|@
name|Test
DECL|method|testSecondaryPurgesEditLogs ()
specifier|public
name|void
name|testSecondaryPurgesEditLogs
parameter_list|()
throws|throws
name|IOException
block|{
name|MiniDFSCluster
name|cluster
init|=
literal|null
decl_stmt|;
name|SecondaryNameNode
name|secondary
init|=
literal|null
decl_stmt|;
name|Configuration
name|conf
init|=
operator|new
name|HdfsConfiguration
argument_list|()
decl_stmt|;
name|conf
operator|.
name|setInt
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_NUM_EXTRA_EDITS_RETAINED_KEY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
try|try
block|{
name|cluster
operator|=
operator|new
name|MiniDFSCluster
operator|.
name|Builder
argument_list|(
name|conf
argument_list|)
operator|.
name|numDataNodes
argument_list|(
literal|0
argument_list|)
operator|.
name|format
argument_list|(
literal|true
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
name|FileSystem
name|fs
init|=
name|cluster
operator|.
name|getFileSystem
argument_list|()
decl_stmt|;
name|fs
operator|.
name|mkdirs
argument_list|(
operator|new
name|Path
argument_list|(
literal|"/foo"
argument_list|)
argument_list|)
expr_stmt|;
name|secondary
operator|=
name|startSecondaryNameNode
argument_list|(
name|conf
argument_list|)
expr_stmt|;
comment|// Checkpoint a few times. Doing this will cause a log roll, and thus
comment|// several edit log segments on the 2NN.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
block|{
name|secondary
operator|.
name|doCheckpoint
argument_list|()
expr_stmt|;
block|}
comment|// Make sure there are no more edit log files than there should be.
name|List
argument_list|<
name|File
argument_list|>
name|checkpointDirs
init|=
name|getCheckpointCurrentDirs
argument_list|(
name|secondary
argument_list|)
decl_stmt|;
for|for
control|(
name|File
name|checkpointDir
range|:
name|checkpointDirs
control|)
block|{
name|List
argument_list|<
name|EditLogFile
argument_list|>
name|editsFiles
init|=
name|FileJournalManager
operator|.
name|matchEditLogs
argument_list|(
name|checkpointDir
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|"Edit log files were not purged from 2NN"
argument_list|,
literal|1
argument_list|,
name|editsFiles
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
if|if
condition|(
name|secondary
operator|!=
literal|null
condition|)
block|{
name|secondary
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|cluster
operator|!=
literal|null
condition|)
block|{
name|cluster
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Regression test for HDFS-3835 - "Long-lived 2NN cannot perform a    * checkpoint if security is enabled and the NN restarts without outstanding    * delegation tokens"    */
annotation|@
name|Test
DECL|method|testSecondaryNameNodeWithDelegationTokens ()
specifier|public
name|void
name|testSecondaryNameNodeWithDelegationTokens
parameter_list|()
throws|throws
name|IOException
block|{
name|MiniDFSCluster
name|cluster
init|=
literal|null
decl_stmt|;
name|SecondaryNameNode
name|secondary
init|=
literal|null
decl_stmt|;
name|Configuration
name|conf
init|=
operator|new
name|HdfsConfiguration
argument_list|()
decl_stmt|;
name|conf
operator|.
name|setBoolean
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_DELEGATION_TOKEN_ALWAYS_USE_KEY
argument_list|,
literal|true
argument_list|)
expr_stmt|;
try|try
block|{
name|cluster
operator|=
operator|new
name|MiniDFSCluster
operator|.
name|Builder
argument_list|(
name|conf
argument_list|)
operator|.
name|numDataNodes
argument_list|(
name|numDatanodes
argument_list|)
operator|.
name|format
argument_list|(
literal|true
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
name|assertNotNull
argument_list|(
name|cluster
operator|.
name|getNamesystem
argument_list|()
operator|.
name|getDelegationToken
argument_list|(
operator|new
name|Text
argument_list|(
literal|"atm"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|secondary
operator|=
name|startSecondaryNameNode
argument_list|(
name|conf
argument_list|)
expr_stmt|;
comment|// Checkpoint once, so the 2NN loads the DT into its in-memory sate.
name|secondary
operator|.
name|doCheckpoint
argument_list|()
expr_stmt|;
comment|// Perform a saveNamespace, so that the NN has a new fsimage, and the 2NN
comment|// therefore needs to download a new fsimage the next time it performs a
comment|// checkpoint.
name|cluster
operator|.
name|getNameNodeRpc
argument_list|()
operator|.
name|setSafeMode
argument_list|(
name|SafeModeAction
operator|.
name|SAFEMODE_ENTER
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|cluster
operator|.
name|getNameNodeRpc
argument_list|()
operator|.
name|saveNamespace
argument_list|()
expr_stmt|;
name|cluster
operator|.
name|getNameNodeRpc
argument_list|()
operator|.
name|setSafeMode
argument_list|(
name|SafeModeAction
operator|.
name|SAFEMODE_LEAVE
argument_list|,
literal|false
argument_list|)
expr_stmt|;
comment|// Ensure that the 2NN can still perform a checkpoint.
name|secondary
operator|.
name|doCheckpoint
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|secondary
operator|!=
literal|null
condition|)
block|{
name|secondary
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|cluster
operator|!=
literal|null
condition|)
block|{
name|cluster
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Regression test for HDFS-3849.  This makes sure that when we re-load the    * FSImage in the 2NN, we clear the existing leases.    */
annotation|@
name|Test
DECL|method|testSecondaryNameNodeWithSavedLeases ()
specifier|public
name|void
name|testSecondaryNameNodeWithSavedLeases
parameter_list|()
throws|throws
name|IOException
block|{
name|MiniDFSCluster
name|cluster
init|=
literal|null
decl_stmt|;
name|SecondaryNameNode
name|secondary
init|=
literal|null
decl_stmt|;
name|FSDataOutputStream
name|fos
init|=
literal|null
decl_stmt|;
name|Configuration
name|conf
init|=
operator|new
name|HdfsConfiguration
argument_list|()
decl_stmt|;
try|try
block|{
name|cluster
operator|=
operator|new
name|MiniDFSCluster
operator|.
name|Builder
argument_list|(
name|conf
argument_list|)
operator|.
name|numDataNodes
argument_list|(
name|numDatanodes
argument_list|)
operator|.
name|format
argument_list|(
literal|true
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
name|FileSystem
name|fs
init|=
name|cluster
operator|.
name|getFileSystem
argument_list|()
decl_stmt|;
name|fos
operator|=
name|fs
operator|.
name|create
argument_list|(
operator|new
name|Path
argument_list|(
literal|"tmpfile"
argument_list|)
argument_list|)
expr_stmt|;
name|fos
operator|.
name|write
argument_list|(
operator|new
name|byte
index|[]
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|3
block|}
argument_list|)
expr_stmt|;
name|fos
operator|.
name|hflush
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|cluster
operator|.
name|getNamesystem
argument_list|()
operator|.
name|getLeaseManager
argument_list|()
operator|.
name|countLease
argument_list|()
argument_list|)
expr_stmt|;
name|secondary
operator|=
name|startSecondaryNameNode
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|secondary
operator|.
name|getFSNamesystem
argument_list|()
operator|.
name|getLeaseManager
argument_list|()
operator|.
name|countLease
argument_list|()
argument_list|)
expr_stmt|;
comment|// Checkpoint once, so the 2NN loads the lease into its in-memory sate.
name|secondary
operator|.
name|doCheckpoint
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|secondary
operator|.
name|getFSNamesystem
argument_list|()
operator|.
name|getLeaseManager
argument_list|()
operator|.
name|countLease
argument_list|()
argument_list|)
expr_stmt|;
name|fos
operator|.
name|close
argument_list|()
expr_stmt|;
name|fos
operator|=
literal|null
expr_stmt|;
comment|// Perform a saveNamespace, so that the NN has a new fsimage, and the 2NN
comment|// therefore needs to download a new fsimage the next time it performs a
comment|// checkpoint.
name|cluster
operator|.
name|getNameNodeRpc
argument_list|()
operator|.
name|setSafeMode
argument_list|(
name|SafeModeAction
operator|.
name|SAFEMODE_ENTER
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|cluster
operator|.
name|getNameNodeRpc
argument_list|()
operator|.
name|saveNamespace
argument_list|()
expr_stmt|;
name|cluster
operator|.
name|getNameNodeRpc
argument_list|()
operator|.
name|setSafeMode
argument_list|(
name|SafeModeAction
operator|.
name|SAFEMODE_LEAVE
argument_list|,
literal|false
argument_list|)
expr_stmt|;
comment|// Ensure that the 2NN can still perform a checkpoint.
name|secondary
operator|.
name|doCheckpoint
argument_list|()
expr_stmt|;
comment|// And the leases have been cleared...
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|secondary
operator|.
name|getFSNamesystem
argument_list|()
operator|.
name|getLeaseManager
argument_list|()
operator|.
name|countLease
argument_list|()
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|fos
operator|!=
literal|null
condition|)
block|{
name|fos
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|secondary
operator|!=
literal|null
condition|)
block|{
name|secondary
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|cluster
operator|!=
literal|null
condition|)
block|{
name|cluster
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Test
DECL|method|testCommandLineParsing ()
specifier|public
name|void
name|testCommandLineParsing
parameter_list|()
throws|throws
name|ParseException
block|{
name|SecondaryNameNode
operator|.
name|CommandLineOpts
name|opts
init|=
operator|new
name|SecondaryNameNode
operator|.
name|CommandLineOpts
argument_list|()
decl_stmt|;
name|opts
operator|.
name|parse
argument_list|()
expr_stmt|;
name|assertNull
argument_list|(
name|opts
operator|.
name|getCommand
argument_list|()
argument_list|)
expr_stmt|;
name|opts
operator|.
name|parse
argument_list|(
literal|"-checkpoint"
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|SecondaryNameNode
operator|.
name|CommandLineOpts
operator|.
name|Command
operator|.
name|CHECKPOINT
argument_list|,
name|opts
operator|.
name|getCommand
argument_list|()
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|opts
operator|.
name|shouldForceCheckpoint
argument_list|()
argument_list|)
expr_stmt|;
name|opts
operator|.
name|parse
argument_list|(
literal|"-checkpoint"
argument_list|,
literal|"force"
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|SecondaryNameNode
operator|.
name|CommandLineOpts
operator|.
name|Command
operator|.
name|CHECKPOINT
argument_list|,
name|opts
operator|.
name|getCommand
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|opts
operator|.
name|shouldForceCheckpoint
argument_list|()
argument_list|)
expr_stmt|;
name|opts
operator|.
name|parse
argument_list|(
literal|"-geteditsize"
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|SecondaryNameNode
operator|.
name|CommandLineOpts
operator|.
name|Command
operator|.
name|GETEDITSIZE
argument_list|,
name|opts
operator|.
name|getCommand
argument_list|()
argument_list|)
expr_stmt|;
name|opts
operator|.
name|parse
argument_list|(
literal|"-format"
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|opts
operator|.
name|shouldFormat
argument_list|()
argument_list|)
expr_stmt|;
try|try
block|{
name|opts
operator|.
name|parse
argument_list|(
literal|"-geteditsize"
argument_list|,
literal|"-checkpoint"
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"Should have failed bad parsing for two actions"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ParseException
name|e
parameter_list|)
block|{}
try|try
block|{
name|opts
operator|.
name|parse
argument_list|(
literal|"-checkpoint"
argument_list|,
literal|"xx"
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"Should have failed for bad checkpoint arg"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ParseException
name|e
parameter_list|)
block|{}
block|}
DECL|method|cleanup (SecondaryNameNode snn)
specifier|private
name|void
name|cleanup
parameter_list|(
name|SecondaryNameNode
name|snn
parameter_list|)
block|{
if|if
condition|(
name|snn
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|snn
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Could not shut down secondary namenode"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Assert that if any two files have the same name across the 2NNs    * and NN, they should have the same content too.    */
DECL|method|assertParallelFilesInvariant (MiniDFSCluster cluster, ImmutableList<SecondaryNameNode> secondaries)
specifier|private
name|void
name|assertParallelFilesInvariant
parameter_list|(
name|MiniDFSCluster
name|cluster
parameter_list|,
name|ImmutableList
argument_list|<
name|SecondaryNameNode
argument_list|>
name|secondaries
parameter_list|)
throws|throws
name|Exception
block|{
name|List
argument_list|<
name|File
argument_list|>
name|allCurrentDirs
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
name|allCurrentDirs
operator|.
name|addAll
argument_list|(
name|getNameNodeCurrentDirs
argument_list|(
name|cluster
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|SecondaryNameNode
name|snn
range|:
name|secondaries
control|)
block|{
name|allCurrentDirs
operator|.
name|addAll
argument_list|(
name|getCheckpointCurrentDirs
argument_list|(
name|snn
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|FSImageTestUtil
operator|.
name|assertParallelFilesAreIdentical
argument_list|(
name|allCurrentDirs
argument_list|,
name|ImmutableSet
operator|.
name|of
argument_list|(
literal|"VERSION"
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|getCheckpointCurrentDirs (SecondaryNameNode secondary)
specifier|private
specifier|static
name|List
argument_list|<
name|File
argument_list|>
name|getCheckpointCurrentDirs
parameter_list|(
name|SecondaryNameNode
name|secondary
parameter_list|)
block|{
name|List
argument_list|<
name|File
argument_list|>
name|ret
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
for|for
control|(
name|URI
name|u
range|:
name|secondary
operator|.
name|getCheckpointDirs
argument_list|()
control|)
block|{
name|File
name|checkpointDir
init|=
operator|new
name|File
argument_list|(
name|u
operator|.
name|getPath
argument_list|()
argument_list|)
decl_stmt|;
name|ret
operator|.
name|add
argument_list|(
operator|new
name|File
argument_list|(
name|checkpointDir
argument_list|,
literal|"current"
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
DECL|method|spyOnSecondaryImage (SecondaryNameNode secondary1)
specifier|private
specifier|static
name|CheckpointStorage
name|spyOnSecondaryImage
parameter_list|(
name|SecondaryNameNode
name|secondary1
parameter_list|)
block|{
name|CheckpointStorage
name|spy
init|=
name|Mockito
operator|.
name|spy
argument_list|(
operator|(
name|CheckpointStorage
operator|)
name|secondary1
operator|.
name|getFSImage
argument_list|()
argument_list|)
decl_stmt|;
empty_stmt|;
name|secondary1
operator|.
name|setFSImage
argument_list|(
name|spy
argument_list|)
expr_stmt|;
return|return
name|spy
return|;
block|}
comment|/**    * A utility class to perform a checkpoint in a different thread.    */
DECL|class|DoCheckpointThread
specifier|private
specifier|static
class|class
name|DoCheckpointThread
extends|extends
name|Thread
block|{
DECL|field|snn
specifier|private
specifier|final
name|SecondaryNameNode
name|snn
decl_stmt|;
DECL|field|thrown
specifier|private
specifier|volatile
name|Throwable
name|thrown
init|=
literal|null
decl_stmt|;
DECL|method|DoCheckpointThread (SecondaryNameNode snn)
name|DoCheckpointThread
parameter_list|(
name|SecondaryNameNode
name|snn
parameter_list|)
block|{
name|this
operator|.
name|snn
operator|=
name|snn
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
try|try
block|{
name|snn
operator|.
name|doCheckpoint
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|thrown
operator|=
name|t
expr_stmt|;
block|}
block|}
DECL|method|propagateExceptions ()
name|void
name|propagateExceptions
parameter_list|()
block|{
if|if
condition|(
name|thrown
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|thrown
argument_list|)
throw|;
block|}
block|}
block|}
block|}
end_class

end_unit

