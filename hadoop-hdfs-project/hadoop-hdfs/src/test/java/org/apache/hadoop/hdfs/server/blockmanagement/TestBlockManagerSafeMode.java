begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdfs.server.blockmanagement
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|blockmanagement
package|;
end_package

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Supplier
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|HdfsConfiguration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|Block
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|BlockListAsLongs
operator|.
name|BlockReportReplica
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|blockmanagement
operator|.
name|BlockManagerSafeMode
operator|.
name|BMSafeModeStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|HdfsServerConstants
operator|.
name|NamenodeRole
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|FSNamesystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|NameNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|test
operator|.
name|GenericTestUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Before
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Test
import|;
end_import

begin_import
import|import
name|org
operator|.
name|mockito
operator|.
name|internal
operator|.
name|util
operator|.
name|reflection
operator|.
name|Whitebox
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InterruptedIOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeoutException
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertEquals
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertFalse
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertTrue
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|mockito
operator|.
name|Matchers
operator|.
name|any
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|mockito
operator|.
name|Mockito
operator|.
name|doReturn
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|mockito
operator|.
name|Mockito
operator|.
name|mock
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|mockito
operator|.
name|Mockito
operator|.
name|spy
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|mockito
operator|.
name|Mockito
operator|.
name|when
import|;
end_import

begin_comment
comment|/**  * This test is for testing {@link BlockManagerSafeMode} package local APIs.  *  * They use heavily mocked objects, treating the {@link BlockManagerSafeMode}  * as white-box. Tests are light-weight thus no multi-thread scenario or real  * mini-cluster is tested.  *  * @see org.apache.hadoop.hdfs.TestSafeMode  * @see org.apache.hadoop.hdfs.server.namenode.ha.TestHASafeMode  * @see org.apache.hadoop.hdfs.TestSafeModeWithStripedFile  */
end_comment

begin_class
DECL|class|TestBlockManagerSafeMode
specifier|public
class|class
name|TestBlockManagerSafeMode
block|{
DECL|field|DATANODE_NUM
specifier|private
specifier|static
specifier|final
name|int
name|DATANODE_NUM
init|=
literal|3
decl_stmt|;
DECL|field|BLOCK_TOTAL
specifier|private
specifier|static
specifier|final
name|long
name|BLOCK_TOTAL
init|=
literal|10
decl_stmt|;
DECL|field|THRESHOLD
specifier|private
specifier|static
specifier|final
name|double
name|THRESHOLD
init|=
literal|0.99
decl_stmt|;
DECL|field|BLOCK_THRESHOLD
specifier|private
specifier|static
specifier|final
name|long
name|BLOCK_THRESHOLD
init|=
call|(
name|long
call|)
argument_list|(
name|BLOCK_TOTAL
operator|*
name|THRESHOLD
argument_list|)
decl_stmt|;
DECL|field|EXTENSION
specifier|private
specifier|static
specifier|final
name|int
name|EXTENSION
init|=
literal|1000
decl_stmt|;
comment|// 1 second
DECL|field|bm
specifier|private
name|BlockManager
name|bm
decl_stmt|;
DECL|field|dn
specifier|private
name|DatanodeManager
name|dn
decl_stmt|;
DECL|field|bmSafeMode
specifier|private
name|BlockManagerSafeMode
name|bmSafeMode
decl_stmt|;
comment|/**    * Set up the mock context.    *    * - extension is always needed (default period is {@link #EXTENSION} ms    * - datanode threshold is always reached via mock    * - safe block is 0 and it needs {@link #BLOCK_THRESHOLD} to reach threshold    * - write/read lock is always held by current thread    *    * @throws IOException    */
annotation|@
name|Before
DECL|method|setupMockCluster ()
specifier|public
name|void
name|setupMockCluster
parameter_list|()
throws|throws
name|IOException
block|{
name|Configuration
name|conf
init|=
operator|new
name|HdfsConfiguration
argument_list|()
decl_stmt|;
name|conf
operator|.
name|setDouble
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_SAFEMODE_THRESHOLD_PCT_KEY
argument_list|,
name|THRESHOLD
argument_list|)
expr_stmt|;
name|conf
operator|.
name|setInt
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_SAFEMODE_EXTENSION_KEY
argument_list|,
name|EXTENSION
argument_list|)
expr_stmt|;
name|conf
operator|.
name|setInt
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_SAFEMODE_MIN_DATANODES_KEY
argument_list|,
name|DATANODE_NUM
argument_list|)
expr_stmt|;
name|FSNamesystem
name|fsn
init|=
name|mock
argument_list|(
name|FSNamesystem
operator|.
name|class
argument_list|)
decl_stmt|;
name|doReturn
argument_list|(
literal|true
argument_list|)
operator|.
name|when
argument_list|(
name|fsn
argument_list|)
operator|.
name|hasWriteLock
argument_list|()
expr_stmt|;
name|doReturn
argument_list|(
literal|true
argument_list|)
operator|.
name|when
argument_list|(
name|fsn
argument_list|)
operator|.
name|hasReadLock
argument_list|()
expr_stmt|;
name|doReturn
argument_list|(
literal|true
argument_list|)
operator|.
name|when
argument_list|(
name|fsn
argument_list|)
operator|.
name|isRunning
argument_list|()
expr_stmt|;
name|NameNode
operator|.
name|initMetrics
argument_list|(
name|conf
argument_list|,
name|NamenodeRole
operator|.
name|NAMENODE
argument_list|)
expr_stmt|;
name|bm
operator|=
name|spy
argument_list|(
operator|new
name|BlockManager
argument_list|(
name|fsn
argument_list|,
literal|false
argument_list|,
name|conf
argument_list|)
argument_list|)
expr_stmt|;
name|doReturn
argument_list|(
literal|true
argument_list|)
operator|.
name|when
argument_list|(
name|bm
argument_list|)
operator|.
name|isGenStampInFuture
argument_list|(
name|any
argument_list|(
name|Block
operator|.
name|class
argument_list|)
argument_list|)
expr_stmt|;
name|dn
operator|=
name|spy
argument_list|(
name|bm
operator|.
name|getDatanodeManager
argument_list|()
argument_list|)
expr_stmt|;
name|Whitebox
operator|.
name|setInternalState
argument_list|(
name|bm
argument_list|,
literal|"datanodeManager"
argument_list|,
name|dn
argument_list|)
expr_stmt|;
comment|// the datanode threshold is always met
name|when
argument_list|(
name|dn
operator|.
name|getNumLiveDataNodes
argument_list|()
argument_list|)
operator|.
name|thenReturn
argument_list|(
name|DATANODE_NUM
argument_list|)
expr_stmt|;
name|bmSafeMode
operator|=
operator|new
name|BlockManagerSafeMode
argument_list|(
name|bm
argument_list|,
name|fsn
argument_list|,
literal|false
argument_list|,
name|conf
argument_list|)
expr_stmt|;
block|}
comment|/**    * Test set block total.    *    * The block total is set which will call checkSafeMode for the first time    * and bmSafeMode transfers from OFF to PENDING_THRESHOLD status    */
annotation|@
name|Test
argument_list|(
name|timeout
operator|=
literal|30000
argument_list|)
DECL|method|testInitialize ()
specifier|public
name|void
name|testInitialize
parameter_list|()
block|{
name|assertFalse
argument_list|(
literal|"Block manager should not be in safe mode at beginning."
argument_list|,
name|bmSafeMode
operator|.
name|isInSafeMode
argument_list|()
argument_list|)
expr_stmt|;
name|bmSafeMode
operator|.
name|activate
argument_list|(
name|BLOCK_TOTAL
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|BMSafeModeStatus
operator|.
name|PENDING_THRESHOLD
argument_list|,
name|getSafeModeStatus
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|bmSafeMode
operator|.
name|isInSafeMode
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Test the state machine transition.    */
annotation|@
name|Test
argument_list|(
name|timeout
operator|=
literal|30000
argument_list|)
DECL|method|testCheckSafeMode ()
specifier|public
name|void
name|testCheckSafeMode
parameter_list|()
block|{
name|bmSafeMode
operator|.
name|activate
argument_list|(
name|BLOCK_TOTAL
argument_list|)
expr_stmt|;
comment|// stays in PENDING_THRESHOLD: pending block threshold
name|setSafeModeStatus
argument_list|(
name|BMSafeModeStatus
operator|.
name|PENDING_THRESHOLD
argument_list|)
expr_stmt|;
for|for
control|(
name|long
name|i
init|=
literal|0
init|;
name|i
operator|<
name|BLOCK_THRESHOLD
condition|;
name|i
operator|++
control|)
block|{
name|setBlockSafe
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|bmSafeMode
operator|.
name|checkSafeMode
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
name|BMSafeModeStatus
operator|.
name|PENDING_THRESHOLD
argument_list|,
name|getSafeModeStatus
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// PENDING_THRESHOLD -> EXTENSION
name|Whitebox
operator|.
name|setInternalState
argument_list|(
name|bmSafeMode
argument_list|,
literal|"extension"
argument_list|,
name|Integer
operator|.
name|MAX_VALUE
argument_list|)
expr_stmt|;
name|setSafeModeStatus
argument_list|(
name|BMSafeModeStatus
operator|.
name|PENDING_THRESHOLD
argument_list|)
expr_stmt|;
name|setBlockSafe
argument_list|(
name|BLOCK_THRESHOLD
argument_list|)
expr_stmt|;
name|bmSafeMode
operator|.
name|checkSafeMode
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
name|BMSafeModeStatus
operator|.
name|EXTENSION
argument_list|,
name|getSafeModeStatus
argument_list|()
argument_list|)
expr_stmt|;
comment|// PENDING_THRESHOLD -> OFF
name|Whitebox
operator|.
name|setInternalState
argument_list|(
name|bmSafeMode
argument_list|,
literal|"extension"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|setSafeModeStatus
argument_list|(
name|BMSafeModeStatus
operator|.
name|PENDING_THRESHOLD
argument_list|)
expr_stmt|;
name|setBlockSafe
argument_list|(
name|BLOCK_THRESHOLD
argument_list|)
expr_stmt|;
name|bmSafeMode
operator|.
name|checkSafeMode
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
name|BMSafeModeStatus
operator|.
name|OFF
argument_list|,
name|getSafeModeStatus
argument_list|()
argument_list|)
expr_stmt|;
comment|// stays in EXTENSION
name|setBlockSafe
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|setSafeModeStatus
argument_list|(
name|BMSafeModeStatus
operator|.
name|EXTENSION
argument_list|)
expr_stmt|;
name|Whitebox
operator|.
name|setInternalState
argument_list|(
name|bmSafeMode
argument_list|,
literal|"extension"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bmSafeMode
operator|.
name|checkSafeMode
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
name|BMSafeModeStatus
operator|.
name|EXTENSION
argument_list|,
name|getSafeModeStatus
argument_list|()
argument_list|)
expr_stmt|;
comment|// stays in EXTENSION: pending extension period
name|Whitebox
operator|.
name|setInternalState
argument_list|(
name|bmSafeMode
argument_list|,
literal|"extension"
argument_list|,
name|Integer
operator|.
name|MAX_VALUE
argument_list|)
expr_stmt|;
name|setSafeModeStatus
argument_list|(
name|BMSafeModeStatus
operator|.
name|EXTENSION
argument_list|)
expr_stmt|;
name|setBlockSafe
argument_list|(
name|BLOCK_THRESHOLD
argument_list|)
expr_stmt|;
name|bmSafeMode
operator|.
name|checkSafeMode
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
name|BMSafeModeStatus
operator|.
name|EXTENSION
argument_list|,
name|getSafeModeStatus
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Test that the block safe increases up to block threshold.    *    * Once the block threshold is reached, the block manger leaves safe mode and    * increment will be a no-op.    * The safe mode status lifecycle: OFF -> PENDING_THRESHOLD -> OFF    */
annotation|@
name|Test
argument_list|(
name|timeout
operator|=
literal|30000
argument_list|)
DECL|method|testIncrementSafeBlockCount ()
specifier|public
name|void
name|testIncrementSafeBlockCount
parameter_list|()
block|{
name|bmSafeMode
operator|.
name|activate
argument_list|(
name|BLOCK_TOTAL
argument_list|)
expr_stmt|;
name|Whitebox
operator|.
name|setInternalState
argument_list|(
name|bmSafeMode
argument_list|,
literal|"extension"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|long
name|i
init|=
literal|1
init|;
name|i
operator|<=
name|BLOCK_TOTAL
condition|;
name|i
operator|++
control|)
block|{
name|BlockInfo
name|blockInfo
init|=
name|mock
argument_list|(
name|BlockInfo
operator|.
name|class
argument_list|)
decl_stmt|;
name|doReturn
argument_list|(
literal|false
argument_list|)
operator|.
name|when
argument_list|(
name|blockInfo
argument_list|)
operator|.
name|isStriped
argument_list|()
expr_stmt|;
name|bmSafeMode
operator|.
name|incrementSafeBlockCount
argument_list|(
literal|1
argument_list|,
name|blockInfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|BLOCK_THRESHOLD
condition|)
block|{
name|assertEquals
argument_list|(
name|i
argument_list|,
name|getblockSafe
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|bmSafeMode
operator|.
name|isInSafeMode
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// block manager leaves safe mode if block threshold is met
name|assertFalse
argument_list|(
name|bmSafeMode
operator|.
name|isInSafeMode
argument_list|()
argument_list|)
expr_stmt|;
comment|// the increment will be a no-op if safe mode is OFF
name|assertEquals
argument_list|(
name|BLOCK_THRESHOLD
argument_list|,
name|getblockSafe
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Test that the block safe increases up to block threshold.    *    * Once the block threshold is reached, the block manger leaves safe mode and    * increment will be a no-op.    * The safe mode status lifecycle: OFF -> PENDING_THRESHOLD -> EXTENSION-> OFF    */
annotation|@
name|Test
argument_list|(
name|timeout
operator|=
literal|30000
argument_list|)
DECL|method|testIncrementSafeBlockCountWithExtension ()
specifier|public
name|void
name|testIncrementSafeBlockCountWithExtension
parameter_list|()
throws|throws
name|Exception
block|{
name|bmSafeMode
operator|.
name|activate
argument_list|(
name|BLOCK_TOTAL
argument_list|)
expr_stmt|;
for|for
control|(
name|long
name|i
init|=
literal|1
init|;
name|i
operator|<=
name|BLOCK_TOTAL
condition|;
name|i
operator|++
control|)
block|{
name|BlockInfo
name|blockInfo
init|=
name|mock
argument_list|(
name|BlockInfo
operator|.
name|class
argument_list|)
decl_stmt|;
name|doReturn
argument_list|(
literal|false
argument_list|)
operator|.
name|when
argument_list|(
name|blockInfo
argument_list|)
operator|.
name|isStriped
argument_list|()
expr_stmt|;
name|bmSafeMode
operator|.
name|incrementSafeBlockCount
argument_list|(
literal|1
argument_list|,
name|blockInfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|BLOCK_THRESHOLD
condition|)
block|{
name|assertTrue
argument_list|(
name|bmSafeMode
operator|.
name|isInSafeMode
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|waitForExtensionPeriod
argument_list|()
expr_stmt|;
name|assertFalse
argument_list|(
name|bmSafeMode
operator|.
name|isInSafeMode
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Test that the block safe decreases the block safe.    *    * The block manager stays in safe mode.    * The safe mode status lifecycle: OFF -> PENDING_THRESHOLD    */
annotation|@
name|Test
argument_list|(
name|timeout
operator|=
literal|30000
argument_list|)
DECL|method|testDecrementSafeBlockCount ()
specifier|public
name|void
name|testDecrementSafeBlockCount
parameter_list|()
block|{
name|bmSafeMode
operator|.
name|activate
argument_list|(
name|BLOCK_TOTAL
argument_list|)
expr_stmt|;
name|Whitebox
operator|.
name|setInternalState
argument_list|(
name|bmSafeMode
argument_list|,
literal|"extension"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mockBlockManagerForBlockSafeDecrement
argument_list|()
expr_stmt|;
name|setBlockSafe
argument_list|(
name|BLOCK_THRESHOLD
argument_list|)
expr_stmt|;
for|for
control|(
name|long
name|i
init|=
name|BLOCK_THRESHOLD
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|BlockInfo
name|blockInfo
init|=
name|mock
argument_list|(
name|BlockInfo
operator|.
name|class
argument_list|)
decl_stmt|;
name|bmSafeMode
operator|.
name|decrementSafeBlockCount
argument_list|(
name|blockInfo
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|i
operator|-
literal|1
argument_list|,
name|getblockSafe
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|bmSafeMode
operator|.
name|isInSafeMode
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Test when the block safe increment and decrement interleave.    *    * Both the increment and decrement will be a no-op if the safe mode is OFF.    * The safe mode status lifecycle: OFF -> PENDING_THRESHOLD -> OFF    */
annotation|@
name|Test
argument_list|(
name|timeout
operator|=
literal|30000
argument_list|)
DECL|method|testIncrementAndDecrementSafeBlockCount ()
specifier|public
name|void
name|testIncrementAndDecrementSafeBlockCount
parameter_list|()
block|{
name|bmSafeMode
operator|.
name|activate
argument_list|(
name|BLOCK_TOTAL
argument_list|)
expr_stmt|;
name|Whitebox
operator|.
name|setInternalState
argument_list|(
name|bmSafeMode
argument_list|,
literal|"extension"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mockBlockManagerForBlockSafeDecrement
argument_list|()
expr_stmt|;
for|for
control|(
name|long
name|i
init|=
literal|1
init|;
name|i
operator|<=
name|BLOCK_TOTAL
condition|;
name|i
operator|++
control|)
block|{
name|BlockInfo
name|blockInfo
init|=
name|mock
argument_list|(
name|BlockInfo
operator|.
name|class
argument_list|)
decl_stmt|;
name|doReturn
argument_list|(
literal|false
argument_list|)
operator|.
name|when
argument_list|(
name|blockInfo
argument_list|)
operator|.
name|isStriped
argument_list|()
expr_stmt|;
name|bmSafeMode
operator|.
name|incrementSafeBlockCount
argument_list|(
literal|1
argument_list|,
name|blockInfo
argument_list|)
expr_stmt|;
name|bmSafeMode
operator|.
name|decrementSafeBlockCount
argument_list|(
name|blockInfo
argument_list|)
expr_stmt|;
name|bmSafeMode
operator|.
name|incrementSafeBlockCount
argument_list|(
literal|1
argument_list|,
name|blockInfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|BLOCK_THRESHOLD
condition|)
block|{
name|assertEquals
argument_list|(
name|i
argument_list|,
name|getblockSafe
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|bmSafeMode
operator|.
name|isInSafeMode
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// block manager leaves safe mode if block threshold is met
name|assertEquals
argument_list|(
name|BLOCK_THRESHOLD
argument_list|,
name|getblockSafe
argument_list|()
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|bmSafeMode
operator|.
name|isInSafeMode
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Test the safe mode monitor.    *    * The monitor will make block manager leave the safe mode after  extension    * period.    */
annotation|@
name|Test
argument_list|(
name|timeout
operator|=
literal|30000
argument_list|)
DECL|method|testSafeModeMonitor ()
specifier|public
name|void
name|testSafeModeMonitor
parameter_list|()
throws|throws
name|Exception
block|{
name|bmSafeMode
operator|.
name|activate
argument_list|(
name|BLOCK_TOTAL
argument_list|)
expr_stmt|;
name|setBlockSafe
argument_list|(
name|BLOCK_THRESHOLD
argument_list|)
expr_stmt|;
comment|// PENDING_THRESHOLD -> EXTENSION
name|bmSafeMode
operator|.
name|checkSafeMode
argument_list|()
expr_stmt|;
name|assertTrue
argument_list|(
name|bmSafeMode
operator|.
name|isInSafeMode
argument_list|()
argument_list|)
expr_stmt|;
name|waitForExtensionPeriod
argument_list|()
expr_stmt|;
name|assertFalse
argument_list|(
name|bmSafeMode
operator|.
name|isInSafeMode
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Test block manager won't leave safe mode if datanode threshold is not met.    */
annotation|@
name|Test
argument_list|(
name|timeout
operator|=
literal|30000
argument_list|)
DECL|method|testDatanodeThreshodShouldBeMet ()
specifier|public
name|void
name|testDatanodeThreshodShouldBeMet
parameter_list|()
throws|throws
name|Exception
block|{
name|bmSafeMode
operator|.
name|activate
argument_list|(
name|BLOCK_TOTAL
argument_list|)
expr_stmt|;
comment|// All datanode have not registered yet.
name|when
argument_list|(
name|dn
operator|.
name|getNumLiveDataNodes
argument_list|()
argument_list|)
operator|.
name|thenReturn
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|setBlockSafe
argument_list|(
name|BLOCK_THRESHOLD
argument_list|)
expr_stmt|;
name|bmSafeMode
operator|.
name|checkSafeMode
argument_list|()
expr_stmt|;
name|assertTrue
argument_list|(
name|bmSafeMode
operator|.
name|isInSafeMode
argument_list|()
argument_list|)
expr_stmt|;
comment|// The datanode number reaches threshold after all data nodes register
name|when
argument_list|(
name|dn
operator|.
name|getNumLiveDataNodes
argument_list|()
argument_list|)
operator|.
name|thenReturn
argument_list|(
name|DATANODE_NUM
argument_list|)
expr_stmt|;
name|bmSafeMode
operator|.
name|checkSafeMode
argument_list|()
expr_stmt|;
name|waitForExtensionPeriod
argument_list|()
expr_stmt|;
name|assertFalse
argument_list|(
name|bmSafeMode
operator|.
name|isInSafeMode
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Test block manager won't leave safe mode if there are blocks with    * generation stamp (GS) in future.    */
annotation|@
name|Test
argument_list|(
name|timeout
operator|=
literal|30000
argument_list|)
DECL|method|testStayInSafeModeWhenBytesInFuture ()
specifier|public
name|void
name|testStayInSafeModeWhenBytesInFuture
parameter_list|()
throws|throws
name|Exception
block|{
name|bmSafeMode
operator|.
name|activate
argument_list|(
name|BLOCK_TOTAL
argument_list|)
expr_stmt|;
comment|// Inject blocks with future GS
name|injectBlocksWithFugureGS
argument_list|(
literal|100L
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|100L
argument_list|,
name|bmSafeMode
operator|.
name|getBytesInFuture
argument_list|()
argument_list|)
expr_stmt|;
comment|// safe blocks are enough
name|setBlockSafe
argument_list|(
name|BLOCK_THRESHOLD
argument_list|)
expr_stmt|;
comment|// PENDING_THRESHOLD -> EXTENSION
name|bmSafeMode
operator|.
name|checkSafeMode
argument_list|()
expr_stmt|;
name|assertFalse
argument_list|(
literal|"Shouldn't leave safe mode in case of blocks with future GS! "
argument_list|,
name|bmSafeMode
operator|.
name|leaveSafeMode
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"Leaving safe mode forcefully should succeed regardless of "
operator|+
literal|"blocks with future GS."
argument_list|,
name|bmSafeMode
operator|.
name|leaveSafeMode
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Number of blocks with future GS should have been cleared "
operator|+
literal|"after leaving safe mode"
argument_list|,
literal|0L
argument_list|,
name|bmSafeMode
operator|.
name|getBytesInFuture
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"Leaving safe mode should succeed after blocks with future GS "
operator|+
literal|"are cleared."
argument_list|,
name|bmSafeMode
operator|.
name|leaveSafeMode
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Test get safe mode tip.    */
annotation|@
name|Test
argument_list|(
name|timeout
operator|=
literal|30000
argument_list|)
DECL|method|testGetSafeModeTip ()
specifier|public
name|void
name|testGetSafeModeTip
parameter_list|()
throws|throws
name|Exception
block|{
name|bmSafeMode
operator|.
name|activate
argument_list|(
name|BLOCK_TOTAL
argument_list|)
expr_stmt|;
name|String
name|tip
init|=
name|bmSafeMode
operator|.
name|getSafeModeTip
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
name|tip
operator|.
name|contains
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"The reported blocks %d needs additional %d blocks to reach the "
operator|+
literal|"threshold %.4f of total blocks %d.%n"
argument_list|,
literal|0
argument_list|,
name|BLOCK_THRESHOLD
argument_list|,
name|THRESHOLD
argument_list|,
name|BLOCK_TOTAL
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|tip
operator|.
name|contains
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"The number of live datanodes %d has reached the "
operator|+
literal|"minimum number %d. "
argument_list|,
name|dn
operator|.
name|getNumLiveDataNodes
argument_list|()
argument_list|,
name|DATANODE_NUM
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|tip
operator|.
name|contains
argument_list|(
literal|"Safe mode will be turned off automatically once "
operator|+
literal|"the thresholds have been reached."
argument_list|)
argument_list|)
expr_stmt|;
comment|// safe blocks are enough
name|setBlockSafe
argument_list|(
name|BLOCK_THRESHOLD
argument_list|)
expr_stmt|;
name|bmSafeMode
operator|.
name|checkSafeMode
argument_list|()
expr_stmt|;
name|tip
operator|=
name|bmSafeMode
operator|.
name|getSafeModeTip
argument_list|()
expr_stmt|;
name|assertTrue
argument_list|(
name|tip
operator|.
name|contains
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"The reported blocks %d has reached the threshold"
operator|+
literal|" %.4f of total blocks %d. "
argument_list|,
name|getblockSafe
argument_list|()
argument_list|,
name|THRESHOLD
argument_list|,
name|BLOCK_TOTAL
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|tip
operator|.
name|contains
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"The number of live datanodes %d has reached the "
operator|+
literal|"minimum number %d. "
argument_list|,
name|dn
operator|.
name|getNumLiveDataNodes
argument_list|()
argument_list|,
name|DATANODE_NUM
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|tip
operator|.
name|contains
argument_list|(
literal|"In safe mode extension. Safe mode will be turned"
operator|+
literal|" off automatically in"
argument_list|)
argument_list|)
expr_stmt|;
name|waitForExtensionPeriod
argument_list|()
expr_stmt|;
name|tip
operator|=
name|bmSafeMode
operator|.
name|getSafeModeTip
argument_list|()
expr_stmt|;
name|assertTrue
argument_list|(
name|tip
operator|.
name|contains
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"The reported blocks %d has reached the threshold"
operator|+
literal|" %.4f of total blocks %d. "
argument_list|,
name|getblockSafe
argument_list|()
argument_list|,
name|THRESHOLD
argument_list|,
name|BLOCK_TOTAL
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|tip
operator|.
name|contains
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"The number of live datanodes %d has reached the "
operator|+
literal|"minimum number %d. "
argument_list|,
name|dn
operator|.
name|getNumLiveDataNodes
argument_list|()
argument_list|,
name|DATANODE_NUM
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|tip
operator|.
name|contains
argument_list|(
literal|"Safe mode will be turned off automatically soon"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Test get safe mode tip in case of blocks with future GS.    */
annotation|@
name|Test
argument_list|(
name|timeout
operator|=
literal|30000
argument_list|)
DECL|method|testGetSafeModeTipForBlocksWithFutureGS ()
specifier|public
name|void
name|testGetSafeModeTipForBlocksWithFutureGS
parameter_list|()
throws|throws
name|Exception
block|{
name|bmSafeMode
operator|.
name|activate
argument_list|(
name|BLOCK_TOTAL
argument_list|)
expr_stmt|;
name|injectBlocksWithFugureGS
argument_list|(
literal|40L
argument_list|)
expr_stmt|;
name|String
name|tip
init|=
name|bmSafeMode
operator|.
name|getSafeModeTip
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
name|tip
operator|.
name|contains
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"The reported blocks %d needs additional %d blocks to reach the "
operator|+
literal|"threshold %.4f of total blocks %d.%n"
argument_list|,
literal|0
argument_list|,
name|BLOCK_THRESHOLD
argument_list|,
name|THRESHOLD
argument_list|,
name|BLOCK_TOTAL
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|tip
operator|.
name|contains
argument_list|(
literal|"Name node detected blocks with generation stamps "
operator|+
literal|"in future. This means that Name node metadata is inconsistent. "
operator|+
literal|"This can happen if Name node metadata files have been manually "
operator|+
literal|"replaced. Exiting safe mode will cause loss of "
operator|+
literal|40
operator|+
literal|" byte(s). Please restart name node with "
operator|+
literal|"right metadata or use \"hdfs dfsadmin -safemode forceExit\" "
operator|+
literal|"if you are certain that the NameNode was started with the "
operator|+
literal|"correct FsImage and edit logs. If you encountered this during "
operator|+
literal|"a rollback, it is safe to exit with -safemode forceExit."
argument_list|)
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|tip
operator|.
name|contains
argument_list|(
literal|"Safe mode will be turned off"
argument_list|)
argument_list|)
expr_stmt|;
comment|// blocks with future GS were already injected before.
name|setBlockSafe
argument_list|(
name|BLOCK_THRESHOLD
argument_list|)
expr_stmt|;
name|tip
operator|=
name|bmSafeMode
operator|.
name|getSafeModeTip
argument_list|()
expr_stmt|;
name|assertTrue
argument_list|(
name|tip
operator|.
name|contains
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"The reported blocks %d has reached the threshold"
operator|+
literal|" %.4f of total blocks %d. "
argument_list|,
name|getblockSafe
argument_list|()
argument_list|,
name|THRESHOLD
argument_list|,
name|BLOCK_TOTAL
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|tip
operator|.
name|contains
argument_list|(
literal|"Name node detected blocks with generation stamps "
operator|+
literal|"in future. This means that Name node metadata is inconsistent. "
operator|+
literal|"This can happen if Name node metadata files have been manually "
operator|+
literal|"replaced. Exiting safe mode will cause loss of "
operator|+
literal|40
operator|+
literal|" byte(s). Please restart name node with "
operator|+
literal|"right metadata or use \"hdfs dfsadmin -safemode forceExit\" "
operator|+
literal|"if you are certain that the NameNode was started with the "
operator|+
literal|"correct FsImage and edit logs. If you encountered this during "
operator|+
literal|"a rollback, it is safe to exit with -safemode forceExit."
argument_list|)
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|tip
operator|.
name|contains
argument_list|(
literal|"Safe mode will be turned off"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Mock block manager internal state for decrement safe block.    */
DECL|method|mockBlockManagerForBlockSafeDecrement ()
specifier|private
name|void
name|mockBlockManagerForBlockSafeDecrement
parameter_list|()
block|{
name|BlockInfo
name|storedBlock
init|=
name|mock
argument_list|(
name|BlockInfo
operator|.
name|class
argument_list|)
decl_stmt|;
name|when
argument_list|(
name|storedBlock
operator|.
name|isComplete
argument_list|()
argument_list|)
operator|.
name|thenReturn
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|doReturn
argument_list|(
name|storedBlock
argument_list|)
operator|.
name|when
argument_list|(
name|bm
argument_list|)
operator|.
name|getStoredBlock
argument_list|(
name|any
argument_list|(
name|Block
operator|.
name|class
argument_list|)
argument_list|)
expr_stmt|;
name|NumberReplicas
name|numberReplicas
init|=
name|mock
argument_list|(
name|NumberReplicas
operator|.
name|class
argument_list|)
decl_stmt|;
name|when
argument_list|(
name|numberReplicas
operator|.
name|liveReplicas
argument_list|()
argument_list|)
operator|.
name|thenReturn
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|doReturn
argument_list|(
name|numberReplicas
argument_list|)
operator|.
name|when
argument_list|(
name|bm
argument_list|)
operator|.
name|countNodes
argument_list|(
name|any
argument_list|(
name|Block
operator|.
name|class
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Wait the bmSafeMode monitor for the extension period.    * @throws InterruptedIOException    * @throws TimeoutException    */
DECL|method|waitForExtensionPeriod ()
specifier|private
name|void
name|waitForExtensionPeriod
parameter_list|()
throws|throws
name|Exception
block|{
name|assertEquals
argument_list|(
name|BMSafeModeStatus
operator|.
name|EXTENSION
argument_list|,
name|getSafeModeStatus
argument_list|()
argument_list|)
expr_stmt|;
name|GenericTestUtils
operator|.
name|waitFor
argument_list|(
operator|new
name|Supplier
argument_list|<
name|Boolean
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Boolean
name|get
parameter_list|()
block|{
return|return
name|getSafeModeStatus
argument_list|()
operator|!=
name|BMSafeModeStatus
operator|.
name|EXTENSION
return|;
block|}
block|}
argument_list|,
name|EXTENSION
operator|/
literal|10
argument_list|,
name|EXTENSION
operator|*
literal|2
argument_list|)
expr_stmt|;
block|}
DECL|method|injectBlocksWithFugureGS (long numBytesInFuture)
specifier|private
name|void
name|injectBlocksWithFugureGS
parameter_list|(
name|long
name|numBytesInFuture
parameter_list|)
block|{
name|BlockReportReplica
name|brr
init|=
name|mock
argument_list|(
name|BlockReportReplica
operator|.
name|class
argument_list|)
decl_stmt|;
name|when
argument_list|(
name|brr
operator|.
name|getBytesOnDisk
argument_list|()
argument_list|)
operator|.
name|thenReturn
argument_list|(
name|numBytesInFuture
argument_list|)
expr_stmt|;
name|bmSafeMode
operator|.
name|checkBlocksWithFutureGS
argument_list|(
name|brr
argument_list|)
expr_stmt|;
block|}
DECL|method|setSafeModeStatus (BMSafeModeStatus status)
specifier|private
name|void
name|setSafeModeStatus
parameter_list|(
name|BMSafeModeStatus
name|status
parameter_list|)
block|{
name|Whitebox
operator|.
name|setInternalState
argument_list|(
name|bmSafeMode
argument_list|,
literal|"status"
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
DECL|method|getSafeModeStatus ()
specifier|private
name|BMSafeModeStatus
name|getSafeModeStatus
parameter_list|()
block|{
return|return
operator|(
name|BMSafeModeStatus
operator|)
name|Whitebox
operator|.
name|getInternalState
argument_list|(
name|bmSafeMode
argument_list|,
literal|"status"
argument_list|)
return|;
block|}
DECL|method|setBlockSafe (long blockSafe)
specifier|private
name|void
name|setBlockSafe
parameter_list|(
name|long
name|blockSafe
parameter_list|)
block|{
name|Whitebox
operator|.
name|setInternalState
argument_list|(
name|bmSafeMode
argument_list|,
literal|"blockSafe"
argument_list|,
name|blockSafe
argument_list|)
expr_stmt|;
block|}
DECL|method|getblockSafe ()
specifier|private
name|long
name|getblockSafe
parameter_list|()
block|{
return|return
operator|(
name|long
operator|)
name|Whitebox
operator|.
name|getInternalState
argument_list|(
name|bmSafeMode
argument_list|,
literal|"blockSafe"
argument_list|)
return|;
block|}
block|}
end_class

end_unit

