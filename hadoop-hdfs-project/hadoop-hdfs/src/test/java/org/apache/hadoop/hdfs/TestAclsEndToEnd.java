begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdfs
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|BufferedReader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileWriter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStreamReader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStreamWriter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|PrintWriter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Writer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URI
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|NoSuchAlgorithmException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|PrivilegedAction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|crypto
operator|.
name|key
operator|.
name|kms
operator|.
name|KMSClientProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|crypto
operator|.
name|key
operator|.
name|kms
operator|.
name|server
operator|.
name|KMSConfiguration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|crypto
operator|.
name|key
operator|.
name|kms
operator|.
name|server
operator|.
name|KeyAuthorizationKeyProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|crypto
operator|.
name|key
operator|.
name|kms
operator|.
name|server
operator|.
name|MiniKMS
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FSDataInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FSDataOutputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystemTestHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|UserGroupInformation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|authorize
operator|.
name|ProxyUsers
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Assert
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertEquals
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertFalse
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertTrue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|BeforeClass
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Test
import|;
end_import

begin_comment
comment|/**  * This class tests the ACLs system through the full code path.  It overlaps  * slightly with the ACL tests in common, but the approach is more holistic.  *  *<b>NOTE:</b> Because of the mechanics of JAXP, when the KMS config files are  * written to disk, a config param with a blank value ("") will be written in a  * way that the KMS will read as unset, which is different from blank. For this  * reason, when testing the effects of blank config params, this test class  * sets the values of those config params to a space (" ").  A whitespace value  * will be preserved by JAXP when writing out the config files and will be  * interpreted by KMS as a blank value. (The KMS strips whitespace from ACL  * values before interpreting them.)  */
end_comment

begin_class
DECL|class|TestAclsEndToEnd
specifier|public
class|class
name|TestAclsEndToEnd
block|{
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|TestAclsEndToEnd
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
DECL|field|TEXT
specifier|private
specifier|static
specifier|final
name|String
name|TEXT
init|=
literal|"The blue zone is for loading and unloading only. "
operator|+
literal|"Please park in the red zone."
decl_stmt|;
DECL|field|ZONE1
specifier|private
specifier|static
specifier|final
name|Path
name|ZONE1
init|=
operator|new
name|Path
argument_list|(
literal|"/tmp/BLUEZONE"
argument_list|)
decl_stmt|;
DECL|field|ZONE2
specifier|private
specifier|static
specifier|final
name|Path
name|ZONE2
init|=
operator|new
name|Path
argument_list|(
literal|"/tmp/REDZONE"
argument_list|)
decl_stmt|;
DECL|field|ZONE3
specifier|private
specifier|static
specifier|final
name|Path
name|ZONE3
init|=
operator|new
name|Path
argument_list|(
literal|"/tmp/LOADINGZONE"
argument_list|)
decl_stmt|;
DECL|field|ZONE4
specifier|private
specifier|static
specifier|final
name|Path
name|ZONE4
init|=
operator|new
name|Path
argument_list|(
literal|"/tmp/UNLOADINGZONE"
argument_list|)
decl_stmt|;
DECL|field|FILE1
specifier|private
specifier|static
specifier|final
name|Path
name|FILE1
init|=
operator|new
name|Path
argument_list|(
name|ZONE1
argument_list|,
literal|"file1"
argument_list|)
decl_stmt|;
DECL|field|FILE1A
specifier|private
specifier|static
specifier|final
name|Path
name|FILE1A
init|=
operator|new
name|Path
argument_list|(
name|ZONE1
argument_list|,
literal|"file1a"
argument_list|)
decl_stmt|;
DECL|field|FILE2
specifier|private
specifier|static
specifier|final
name|Path
name|FILE2
init|=
operator|new
name|Path
argument_list|(
name|ZONE2
argument_list|,
literal|"file2"
argument_list|)
decl_stmt|;
DECL|field|FILE3
specifier|private
specifier|static
specifier|final
name|Path
name|FILE3
init|=
operator|new
name|Path
argument_list|(
name|ZONE3
argument_list|,
literal|"file3"
argument_list|)
decl_stmt|;
DECL|field|FILE4
specifier|private
specifier|static
specifier|final
name|Path
name|FILE4
init|=
operator|new
name|Path
argument_list|(
name|ZONE4
argument_list|,
literal|"file4"
argument_list|)
decl_stmt|;
DECL|field|KEY1
specifier|private
specifier|static
specifier|final
name|String
name|KEY1
init|=
literal|"key1"
decl_stmt|;
DECL|field|KEY2
specifier|private
specifier|static
specifier|final
name|String
name|KEY2
init|=
literal|"key2"
decl_stmt|;
DECL|field|KEY3
specifier|private
specifier|static
specifier|final
name|String
name|KEY3
init|=
literal|"key3"
decl_stmt|;
DECL|field|realUgi
specifier|private
specifier|static
name|UserGroupInformation
name|realUgi
decl_stmt|;
DECL|field|realUser
specifier|private
specifier|static
name|String
name|realUser
decl_stmt|;
DECL|field|miniKMS
specifier|private
name|MiniKMS
name|miniKMS
decl_stmt|;
DECL|field|kmsDir
specifier|private
name|File
name|kmsDir
decl_stmt|;
DECL|field|cluster
specifier|private
name|MiniDFSCluster
name|cluster
decl_stmt|;
DECL|field|fs
specifier|private
name|DistributedFileSystem
name|fs
decl_stmt|;
annotation|@
name|BeforeClass
DECL|method|captureUser ()
specifier|public
specifier|static
name|void
name|captureUser
parameter_list|()
throws|throws
name|IOException
block|{
name|realUgi
operator|=
name|UserGroupInformation
operator|.
name|getCurrentUser
argument_list|()
expr_stmt|;
name|realUser
operator|=
name|System
operator|.
name|getProperty
argument_list|(
literal|"user.name"
argument_list|)
expr_stmt|;
block|}
comment|/**    * Extract the URI for the miniKMS.    *    * @return the URI for the miniKMS    */
DECL|method|getKeyProviderURI ()
specifier|private
name|String
name|getKeyProviderURI
parameter_list|()
block|{
return|return
name|KMSClientProvider
operator|.
name|SCHEME_NAME
operator|+
literal|"://"
operator|+
name|miniKMS
operator|.
name|getKMSUrl
argument_list|()
operator|.
name|toExternalForm
argument_list|()
operator|.
name|replace
argument_list|(
literal|"://"
argument_list|,
literal|"@"
argument_list|)
return|;
block|}
comment|/**    * Write out the config files needed by the miniKMS.  The miniKMS doesn't    * provide a way to set the configs directly, so the only way to pass config    * parameters is to write them out into config files.    *    * @param confDir the directory into which to write the configs    * @param conf the config to write.    * @throws IOException    */
DECL|method|writeConf (File confDir, Configuration conf)
specifier|private
name|void
name|writeConf
parameter_list|(
name|File
name|confDir
parameter_list|,
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|URI
name|keystore
init|=
operator|new
name|Path
argument_list|(
name|kmsDir
operator|.
name|getAbsolutePath
argument_list|()
argument_list|,
literal|"kms.keystore"
argument_list|)
operator|.
name|toUri
argument_list|()
decl_stmt|;
name|conf
operator|.
name|set
argument_list|(
name|KMSConfiguration
operator|.
name|KEY_PROVIDER_URI
argument_list|,
literal|"jceks://file@"
operator|+
name|keystore
argument_list|)
expr_stmt|;
name|conf
operator|.
name|set
argument_list|(
literal|"hadoop.kms.authentication.type"
argument_list|,
literal|"simple"
argument_list|)
expr_stmt|;
name|Writer
name|writer
init|=
operator|new
name|FileWriter
argument_list|(
operator|new
name|File
argument_list|(
name|confDir
argument_list|,
name|KMSConfiguration
operator|.
name|KMS_SITE_XML
argument_list|)
argument_list|)
decl_stmt|;
name|conf
operator|.
name|writeXml
argument_list|(
name|writer
argument_list|)
expr_stmt|;
name|writer
operator|.
name|close
argument_list|()
expr_stmt|;
name|writer
operator|=
operator|new
name|FileWriter
argument_list|(
operator|new
name|File
argument_list|(
name|confDir
argument_list|,
name|KMSConfiguration
operator|.
name|KMS_ACLS_XML
argument_list|)
argument_list|)
expr_stmt|;
name|conf
operator|.
name|writeXml
argument_list|(
name|writer
argument_list|)
expr_stmt|;
name|writer
operator|.
name|close
argument_list|()
expr_stmt|;
comment|//create empty core-site.xml
name|writer
operator|=
operator|new
name|FileWriter
argument_list|(
operator|new
name|File
argument_list|(
name|confDir
argument_list|,
literal|"core-site.xml"
argument_list|)
argument_list|)
expr_stmt|;
operator|new
name|Configuration
argument_list|(
literal|false
argument_list|)
operator|.
name|writeXml
argument_list|(
name|writer
argument_list|)
expr_stmt|;
name|writer
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|/**    * Setup a fresh miniKMS and miniDFS.    *    * @param conf the configuration to use for both the miniKMS and miniDFS    * @throws Exception thrown if setup fails    */
DECL|method|setup (Configuration conf)
specifier|private
name|void
name|setup
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|Exception
block|{
name|setup
argument_list|(
name|conf
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**    * Setup a fresh miniDFS and a miniKMS.  The resetKms parameter controls    * whether the miniKMS will start fresh or reuse the existing data.    *    * @param conf the configuration to use for both the miniKMS and miniDFS    * @param resetKms whether to start a fresh miniKMS    * @throws Exception thrown if setup fails    */
DECL|method|setup (Configuration conf, boolean resetKms)
specifier|private
name|void
name|setup
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|boolean
name|resetKms
parameter_list|)
throws|throws
name|Exception
block|{
name|setup
argument_list|(
name|conf
argument_list|,
name|resetKms
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**    * Setup a miniDFS and miniKMS.  The resetKms and resetDfs parameters control    * whether the services will start fresh or reuse the existing data.    *    * @param conf the configuration to use for both the miniKMS and miniDFS    * @param resetKms whether to start a fresh miniKMS    * @param resetDfs whether to start a fresh miniDFS    * @throws Exception thrown if setup fails    */
DECL|method|setup (Configuration conf, boolean resetKms, boolean resetDfs)
specifier|private
name|void
name|setup
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|boolean
name|resetKms
parameter_list|,
name|boolean
name|resetDfs
parameter_list|)
throws|throws
name|Exception
block|{
if|if
condition|(
name|resetKms
condition|)
block|{
name|FileSystemTestHelper
name|fsHelper
init|=
operator|new
name|FileSystemTestHelper
argument_list|()
decl_stmt|;
name|kmsDir
operator|=
operator|new
name|File
argument_list|(
name|fsHelper
operator|.
name|getTestRootDir
argument_list|()
argument_list|)
operator|.
name|getAbsoluteFile
argument_list|()
expr_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
name|kmsDir
operator|.
name|mkdirs
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|writeConf
argument_list|(
name|kmsDir
argument_list|,
name|conf
argument_list|)
expr_stmt|;
name|MiniKMS
operator|.
name|Builder
name|miniKMSBuilder
init|=
operator|new
name|MiniKMS
operator|.
name|Builder
argument_list|()
decl_stmt|;
name|miniKMS
operator|=
name|miniKMSBuilder
operator|.
name|setKmsConfDir
argument_list|(
name|kmsDir
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
name|miniKMS
operator|.
name|start
argument_list|()
expr_stmt|;
name|conf
operator|=
operator|new
name|HdfsConfiguration
argument_list|()
expr_stmt|;
comment|// Set up java key store
name|conf
operator|.
name|set
argument_list|(
name|ProxyUsers
operator|.
name|CONF_HADOOP_PROXYUSER
operator|+
literal|"."
operator|+
name|realUser
operator|+
literal|".users"
argument_list|,
literal|"keyadmin,hdfs,user"
argument_list|)
expr_stmt|;
name|conf
operator|.
name|set
argument_list|(
name|ProxyUsers
operator|.
name|CONF_HADOOP_PROXYUSER
operator|+
literal|"."
operator|+
name|realUser
operator|+
literal|".hosts"
argument_list|,
literal|"*"
argument_list|)
expr_stmt|;
name|conf
operator|.
name|set
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_ENCRYPTION_KEY_PROVIDER_URI
argument_list|,
name|getKeyProviderURI
argument_list|()
argument_list|)
expr_stmt|;
name|conf
operator|.
name|setBoolean
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_DELEGATION_TOKEN_ALWAYS_USE_KEY
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|MiniDFSCluster
operator|.
name|Builder
name|clusterBuilder
init|=
operator|new
name|MiniDFSCluster
operator|.
name|Builder
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|cluster
operator|=
name|clusterBuilder
operator|.
name|numDataNodes
argument_list|(
literal|1
argument_list|)
operator|.
name|format
argument_list|(
name|resetDfs
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
name|fs
operator|=
name|cluster
operator|.
name|getFileSystem
argument_list|()
expr_stmt|;
block|}
comment|/**    * Stop the miniKMS and miniDFS.    */
DECL|method|teardown ()
specifier|private
name|void
name|teardown
parameter_list|()
block|{
comment|// Restore login user
name|UserGroupInformation
operator|.
name|setLoginUser
argument_list|(
name|realUgi
argument_list|)
expr_stmt|;
if|if
condition|(
name|cluster
operator|!=
literal|null
condition|)
block|{
name|cluster
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
name|miniKMS
operator|.
name|stop
argument_list|()
expr_stmt|;
block|}
comment|/**    * Return a new {@link Configuration} with KMS ACLs appropriate to pass the    * full ACL test in {@link #doFullAclTest()} set.    *    * @param hdfsUgi the hdfs user    * @param keyadminUgi the keyadmin user    * @return the configuration    */
DECL|method|getBaseConf (UserGroupInformation hdfsUgi, UserGroupInformation keyadminUgi)
specifier|private
specifier|static
name|Configuration
name|getBaseConf
parameter_list|(
name|UserGroupInformation
name|hdfsUgi
parameter_list|,
name|UserGroupInformation
name|keyadminUgi
parameter_list|)
block|{
name|Configuration
name|conf
init|=
operator|new
name|Configuration
argument_list|()
decl_stmt|;
name|conf
operator|.
name|set
argument_list|(
name|KMSConfiguration
operator|.
name|CONFIG_PREFIX
operator|+
literal|"acl.CREATE"
argument_list|,
name|keyadminUgi
operator|.
name|getUserName
argument_list|()
argument_list|)
expr_stmt|;
name|conf
operator|.
name|set
argument_list|(
name|KMSConfiguration
operator|.
name|CONFIG_PREFIX
operator|+
literal|"acl.DELETE"
argument_list|,
name|keyadminUgi
operator|.
name|getUserName
argument_list|()
argument_list|)
expr_stmt|;
name|conf
operator|.
name|set
argument_list|(
name|KMSConfiguration
operator|.
name|CONFIG_PREFIX
operator|+
literal|"acl.ROLLOVER"
argument_list|,
name|keyadminUgi
operator|.
name|getUserName
argument_list|()
argument_list|)
expr_stmt|;
name|conf
operator|.
name|set
argument_list|(
name|KMSConfiguration
operator|.
name|CONFIG_PREFIX
operator|+
literal|"acl.GET"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|conf
operator|.
name|set
argument_list|(
name|KMSConfiguration
operator|.
name|CONFIG_PREFIX
operator|+
literal|"acl.GET_KEYS"
argument_list|,
name|keyadminUgi
operator|.
name|getUserName
argument_list|()
argument_list|)
expr_stmt|;
name|conf
operator|.
name|set
argument_list|(
name|KMSConfiguration
operator|.
name|CONFIG_PREFIX
operator|+
literal|"acl.GET_METADATA"
argument_list|,
name|hdfsUgi
operator|.
name|getUserName
argument_list|()
argument_list|)
expr_stmt|;
name|conf
operator|.
name|set
argument_list|(
name|KMSConfiguration
operator|.
name|CONFIG_PREFIX
operator|+
literal|"acl.SET_KEY_MATERIAL"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|conf
operator|.
name|set
argument_list|(
name|KMSConfiguration
operator|.
name|CONFIG_PREFIX
operator|+
literal|"acl.GENERATE_EEK"
argument_list|,
name|hdfsUgi
operator|.
name|getUserName
argument_list|()
argument_list|)
expr_stmt|;
name|conf
operator|.
name|set
argument_list|(
name|KMSConfiguration
operator|.
name|CONFIG_PREFIX
operator|+
literal|"acl.DECRYPT_EEK"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return
name|conf
return|;
block|}
comment|/**    * Set the recommended blacklists.    *    * @param hdfsUgi the hdfs user    */
DECL|method|setBlacklistAcls (Configuration conf, UserGroupInformation hdfsUgi)
specifier|private
specifier|static
name|void
name|setBlacklistAcls
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|UserGroupInformation
name|hdfsUgi
parameter_list|)
block|{
name|conf
operator|.
name|set
argument_list|(
name|KMSConfiguration
operator|.
name|CONFIG_PREFIX
operator|+
literal|"blacklist.CREATE"
argument_list|,
name|hdfsUgi
operator|.
name|getUserName
argument_list|()
argument_list|)
expr_stmt|;
name|conf
operator|.
name|set
argument_list|(
name|KMSConfiguration
operator|.
name|CONFIG_PREFIX
operator|+
literal|"blacklist.DELETE"
argument_list|,
name|hdfsUgi
operator|.
name|getUserName
argument_list|()
argument_list|)
expr_stmt|;
name|conf
operator|.
name|set
argument_list|(
name|KMSConfiguration
operator|.
name|CONFIG_PREFIX
operator|+
literal|"blacklist.ROLLOVER"
argument_list|,
name|hdfsUgi
operator|.
name|getUserName
argument_list|()
argument_list|)
expr_stmt|;
name|conf
operator|.
name|set
argument_list|(
name|KMSConfiguration
operator|.
name|CONFIG_PREFIX
operator|+
literal|"blacklist.GET"
argument_list|,
literal|"*"
argument_list|)
expr_stmt|;
name|conf
operator|.
name|set
argument_list|(
name|KMSConfiguration
operator|.
name|CONFIG_PREFIX
operator|+
literal|"blacklist.SET_KEY_MATERIAL"
argument_list|,
literal|"*"
argument_list|)
expr_stmt|;
name|conf
operator|.
name|set
argument_list|(
name|KMSConfiguration
operator|.
name|CONFIG_PREFIX
operator|+
literal|"blacklist.DECRYPT_EEK"
argument_list|,
name|hdfsUgi
operator|.
name|getUserName
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Set the key ACLs appropriate to pass the full ACL test in    * {@link #doFullAclTest()} using the specified prefix.  The prefix should    * either be "whitelist.key.acl." or "key.acl.key1.".    *    * @param conf the configuration    * @param prefix the ACL prefix    * @param hdfsUgi the hdfs user    * @param keyadminUgi the keyadmin user    * @param userUgi the normal user    */
DECL|method|setKeyAcls (Configuration conf, String prefix, UserGroupInformation hdfsUgi, UserGroupInformation keyadminUgi, UserGroupInformation userUgi)
specifier|private
specifier|static
name|void
name|setKeyAcls
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|String
name|prefix
parameter_list|,
name|UserGroupInformation
name|hdfsUgi
parameter_list|,
name|UserGroupInformation
name|keyadminUgi
parameter_list|,
name|UserGroupInformation
name|userUgi
parameter_list|)
block|{
name|conf
operator|.
name|set
argument_list|(
name|prefix
operator|+
literal|"MANAGEMENT"
argument_list|,
name|keyadminUgi
operator|.
name|getUserName
argument_list|()
argument_list|)
expr_stmt|;
name|conf
operator|.
name|set
argument_list|(
name|prefix
operator|+
literal|"READ"
argument_list|,
name|hdfsUgi
operator|.
name|getUserName
argument_list|()
argument_list|)
expr_stmt|;
name|conf
operator|.
name|set
argument_list|(
name|prefix
operator|+
literal|"GENERATE_EEK"
argument_list|,
name|hdfsUgi
operator|.
name|getUserName
argument_list|()
argument_list|)
expr_stmt|;
name|conf
operator|.
name|set
argument_list|(
name|KeyAuthorizationKeyProvider
operator|.
name|KEY_ACL
operator|+
name|KEY1
operator|+
literal|".DECRYPT_EEK"
argument_list|,
name|userUgi
operator|.
name|getUserName
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Test the full life cycle of a key using a config with whitelist key ACLs.    * The configuration used is the correct configuration to pass the full ACL    * test in {@link #doFullAclTest()}.    *    * @throws Exception thrown on test failure    */
annotation|@
name|Test
DECL|method|testGoodWithWhitelist ()
specifier|public
name|void
name|testGoodWithWhitelist
parameter_list|()
throws|throws
name|Exception
block|{
name|UserGroupInformation
name|hdfsUgi
init|=
name|UserGroupInformation
operator|.
name|createProxyUserForTesting
argument_list|(
literal|"hdfs"
argument_list|,
name|realUgi
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"supergroup"
block|}
argument_list|)
decl_stmt|;
name|UserGroupInformation
name|keyadminUgi
init|=
name|UserGroupInformation
operator|.
name|createProxyUserForTesting
argument_list|(
literal|"keyadmin"
argument_list|,
name|realUgi
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"keyadmin"
block|}
argument_list|)
decl_stmt|;
name|UserGroupInformation
name|userUgi
init|=
name|UserGroupInformation
operator|.
name|createProxyUserForTesting
argument_list|(
literal|"user"
argument_list|,
name|realUgi
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"staff"
block|}
argument_list|)
decl_stmt|;
name|Configuration
name|conf
init|=
name|getBaseConf
argument_list|(
name|hdfsUgi
argument_list|,
name|keyadminUgi
argument_list|)
decl_stmt|;
name|setBlacklistAcls
argument_list|(
name|conf
argument_list|,
name|hdfsUgi
argument_list|)
expr_stmt|;
name|setKeyAcls
argument_list|(
name|conf
argument_list|,
name|KMSConfiguration
operator|.
name|WHITELIST_KEY_ACL_PREFIX
argument_list|,
name|hdfsUgi
argument_list|,
name|keyadminUgi
argument_list|,
name|userUgi
argument_list|)
expr_stmt|;
name|doFullAclTest
argument_list|(
name|conf
argument_list|,
name|hdfsUgi
argument_list|,
name|keyadminUgi
argument_list|,
name|userUgi
argument_list|)
expr_stmt|;
block|}
comment|/**    * Test the full life cycle of a key using a config with key ACLs.    * The configuration used is the correct configuration to pass the full ACL    * test in {@link #doFullAclTest()}.    *    * @throws Exception thrown on test failure    */
annotation|@
name|Test
DECL|method|testGoodWithKeyAcls ()
specifier|public
name|void
name|testGoodWithKeyAcls
parameter_list|()
throws|throws
name|Exception
block|{
name|UserGroupInformation
name|hdfsUgi
init|=
name|UserGroupInformation
operator|.
name|createProxyUserForTesting
argument_list|(
literal|"hdfs"
argument_list|,
name|realUgi
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"supergroup"
block|}
argument_list|)
decl_stmt|;
name|UserGroupInformation
name|keyadminUgi
init|=
name|UserGroupInformation
operator|.
name|createProxyUserForTesting
argument_list|(
literal|"keyadmin"
argument_list|,
name|realUgi
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"keyadmin"
block|}
argument_list|)
decl_stmt|;
name|UserGroupInformation
name|userUgi
init|=
name|UserGroupInformation
operator|.
name|createProxyUserForTesting
argument_list|(
literal|"user"
argument_list|,
name|realUgi
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"staff"
block|}
argument_list|)
decl_stmt|;
name|Configuration
name|conf
init|=
name|getBaseConf
argument_list|(
name|hdfsUgi
argument_list|,
name|keyadminUgi
argument_list|)
decl_stmt|;
name|setBlacklistAcls
argument_list|(
name|conf
argument_list|,
name|hdfsUgi
argument_list|)
expr_stmt|;
name|setKeyAcls
argument_list|(
name|conf
argument_list|,
name|KeyAuthorizationKeyProvider
operator|.
name|KEY_ACL
operator|+
name|KEY1
operator|+
literal|"."
argument_list|,
name|hdfsUgi
argument_list|,
name|keyadminUgi
argument_list|,
name|userUgi
argument_list|)
expr_stmt|;
name|doFullAclTest
argument_list|(
name|conf
argument_list|,
name|hdfsUgi
argument_list|,
name|keyadminUgi
argument_list|,
name|userUgi
argument_list|)
expr_stmt|;
block|}
comment|/**    * Test the full life cycle of a key using a config with whitelist key ACLs    * and without blacklist ACLs.  The configuration used is the correct    * configuration to pass the full ACL test in {@link #doFullAclTest()}.    *    * @throws Exception thrown on test failure    */
annotation|@
name|Test
DECL|method|testGoodWithWhitelistWithoutBlacklist ()
specifier|public
name|void
name|testGoodWithWhitelistWithoutBlacklist
parameter_list|()
throws|throws
name|Exception
block|{
name|UserGroupInformation
name|hdfsUgi
init|=
name|UserGroupInformation
operator|.
name|createProxyUserForTesting
argument_list|(
literal|"hdfs"
argument_list|,
name|realUgi
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"supergroup"
block|}
argument_list|)
decl_stmt|;
name|UserGroupInformation
name|keyadminUgi
init|=
name|UserGroupInformation
operator|.
name|createProxyUserForTesting
argument_list|(
literal|"keyadmin"
argument_list|,
name|realUgi
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"keyadmin"
block|}
argument_list|)
decl_stmt|;
name|UserGroupInformation
name|userUgi
init|=
name|UserGroupInformation
operator|.
name|createProxyUserForTesting
argument_list|(
literal|"user"
argument_list|,
name|realUgi
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"staff"
block|}
argument_list|)
decl_stmt|;
name|Configuration
name|conf
init|=
name|getBaseConf
argument_list|(
name|hdfsUgi
argument_list|,
name|keyadminUgi
argument_list|)
decl_stmt|;
name|setKeyAcls
argument_list|(
name|conf
argument_list|,
name|KMSConfiguration
operator|.
name|WHITELIST_KEY_ACL_PREFIX
argument_list|,
name|hdfsUgi
argument_list|,
name|keyadminUgi
argument_list|,
name|userUgi
argument_list|)
expr_stmt|;
name|doFullAclTest
argument_list|(
name|conf
argument_list|,
name|hdfsUgi
argument_list|,
name|keyadminUgi
argument_list|,
name|userUgi
argument_list|)
expr_stmt|;
block|}
comment|/**    * Test the full life cycle of a key using a config with whitelist key ACLs    * and without blacklist ACLs. The configuration used is the correct    * configuration to pass the full ACL test in {@link #doFullAclTest()}.    *    * @throws Exception thrown on test failure    */
annotation|@
name|Test
DECL|method|testGoodWithKeyAclsWithoutBlacklist ()
specifier|public
name|void
name|testGoodWithKeyAclsWithoutBlacklist
parameter_list|()
throws|throws
name|Exception
block|{
name|UserGroupInformation
name|hdfsUgi
init|=
name|UserGroupInformation
operator|.
name|createProxyUserForTesting
argument_list|(
literal|"hdfs"
argument_list|,
name|realUgi
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"supergroup"
block|}
argument_list|)
decl_stmt|;
name|UserGroupInformation
name|keyadminUgi
init|=
name|UserGroupInformation
operator|.
name|createProxyUserForTesting
argument_list|(
literal|"keyadmin"
argument_list|,
name|realUgi
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"keyadmin"
block|}
argument_list|)
decl_stmt|;
name|UserGroupInformation
name|userUgi
init|=
name|UserGroupInformation
operator|.
name|createProxyUserForTesting
argument_list|(
literal|"user"
argument_list|,
name|realUgi
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"staff"
block|}
argument_list|)
decl_stmt|;
name|Configuration
name|conf
init|=
name|getBaseConf
argument_list|(
name|hdfsUgi
argument_list|,
name|keyadminUgi
argument_list|)
decl_stmt|;
name|setKeyAcls
argument_list|(
name|conf
argument_list|,
name|KeyAuthorizationKeyProvider
operator|.
name|KEY_ACL
operator|+
name|KEY1
operator|+
literal|"."
argument_list|,
name|hdfsUgi
argument_list|,
name|keyadminUgi
argument_list|,
name|userUgi
argument_list|)
expr_stmt|;
name|doFullAclTest
argument_list|(
name|conf
argument_list|,
name|hdfsUgi
argument_list|,
name|keyadminUgi
argument_list|,
name|userUgi
argument_list|)
expr_stmt|;
block|}
comment|/**    * Run a full key life cycle test using the provided configuration and users.    *    * @param conf the configuration    * @param hdfs the user to use as the hdfs user    * @param keyadmin the user to use as the keyadmin user    * @param user the user to use as the normal user    * @throws Exception thrown if there is a test failure    */
DECL|method|doFullAclTest (final Configuration conf, final UserGroupInformation hdfsUgi, final UserGroupInformation keyadminUgi, final UserGroupInformation userUgi)
specifier|private
name|void
name|doFullAclTest
parameter_list|(
specifier|final
name|Configuration
name|conf
parameter_list|,
specifier|final
name|UserGroupInformation
name|hdfsUgi
parameter_list|,
specifier|final
name|UserGroupInformation
name|keyadminUgi
parameter_list|,
specifier|final
name|UserGroupInformation
name|userUgi
parameter_list|)
throws|throws
name|Exception
block|{
try|try
block|{
name|setup
argument_list|(
name|conf
argument_list|)
expr_stmt|;
comment|// Create a test key
name|assertTrue
argument_list|(
literal|"Exception during creation of key "
operator|+
name|KEY1
operator|+
literal|" by "
operator|+
name|keyadminUgi
operator|.
name|getUserName
argument_list|()
argument_list|,
name|createKey
argument_list|(
name|keyadminUgi
argument_list|,
name|KEY1
argument_list|,
name|conf
argument_list|)
argument_list|)
expr_stmt|;
comment|// Fail to create a test key
name|assertFalse
argument_list|(
literal|"Allowed creation of key "
operator|+
name|KEY2
operator|+
literal|" by "
operator|+
name|hdfsUgi
operator|.
name|getUserName
argument_list|()
argument_list|,
name|createKey
argument_list|(
name|hdfsUgi
argument_list|,
name|KEY2
argument_list|,
name|conf
argument_list|)
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
literal|"Allowed creation of key "
operator|+
name|KEY2
operator|+
literal|" by "
operator|+
name|userUgi
operator|.
name|getUserName
argument_list|()
argument_list|,
name|createKey
argument_list|(
name|userUgi
argument_list|,
name|KEY2
argument_list|,
name|conf
argument_list|)
argument_list|)
expr_stmt|;
comment|// Create a directory and chown it to the normal user.
name|fs
operator|.
name|mkdirs
argument_list|(
name|ZONE1
argument_list|)
expr_stmt|;
name|fs
operator|.
name|setOwner
argument_list|(
name|ZONE1
argument_list|,
name|userUgi
operator|.
name|getUserName
argument_list|()
argument_list|,
name|userUgi
operator|.
name|getPrimaryGroupName
argument_list|()
argument_list|)
expr_stmt|;
comment|// Create an EZ
name|assertTrue
argument_list|(
literal|"Exception during creation of EZ "
operator|+
name|ZONE1
operator|+
literal|" by "
operator|+
name|hdfsUgi
operator|.
name|getUserName
argument_list|()
operator|+
literal|" using key "
operator|+
name|KEY1
argument_list|,
name|createEncryptionZone
argument_list|(
name|hdfsUgi
argument_list|,
name|KEY1
argument_list|,
name|ZONE1
argument_list|)
argument_list|)
expr_stmt|;
comment|// Fail to create an EZ
name|assertFalse
argument_list|(
literal|"Allowed creation of EZ "
operator|+
name|ZONE2
operator|+
literal|" by "
operator|+
name|keyadminUgi
operator|.
name|getUserName
argument_list|()
operator|+
literal|" using key "
operator|+
name|KEY1
argument_list|,
name|createEncryptionZone
argument_list|(
name|keyadminUgi
argument_list|,
name|KEY1
argument_list|,
name|ZONE2
argument_list|)
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
literal|"Allowed creation of EZ "
operator|+
name|ZONE2
operator|+
literal|" by "
operator|+
name|userUgi
operator|.
name|getUserName
argument_list|()
operator|+
literal|" using key "
operator|+
name|KEY1
argument_list|,
name|createEncryptionZone
argument_list|(
name|userUgi
argument_list|,
name|KEY1
argument_list|,
name|ZONE2
argument_list|)
argument_list|)
expr_stmt|;
comment|// Create a file in the zone
name|assertTrue
argument_list|(
literal|"Exception during creation of file "
operator|+
name|FILE1
operator|+
literal|" by "
operator|+
name|userUgi
operator|.
name|getUserName
argument_list|()
argument_list|,
name|createFile
argument_list|(
name|userUgi
argument_list|,
name|FILE1
argument_list|,
name|TEXT
argument_list|)
argument_list|)
expr_stmt|;
comment|// Fail to create a file in the zone
name|assertFalse
argument_list|(
literal|"Allowed creation of file "
operator|+
name|FILE1A
operator|+
literal|" by "
operator|+
name|hdfsUgi
operator|.
name|getUserName
argument_list|()
argument_list|,
name|createFile
argument_list|(
name|hdfsUgi
argument_list|,
name|FILE1A
argument_list|,
name|TEXT
argument_list|)
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
literal|"Allowed creation of file "
operator|+
name|FILE1A
operator|+
literal|" by "
operator|+
name|keyadminUgi
operator|.
name|getUserName
argument_list|()
argument_list|,
name|createFile
argument_list|(
name|keyadminUgi
argument_list|,
name|FILE1A
argument_list|,
name|TEXT
argument_list|)
argument_list|)
expr_stmt|;
comment|// Read a file in the zone
name|assertTrue
argument_list|(
literal|"Exception while reading file "
operator|+
name|FILE1
operator|+
literal|" by "
operator|+
name|userUgi
operator|.
name|getUserName
argument_list|()
argument_list|,
name|compareFile
argument_list|(
name|userUgi
argument_list|,
name|FILE1
argument_list|,
name|TEXT
argument_list|)
argument_list|)
expr_stmt|;
comment|// Fail to read a file in the zone
name|assertFalse
argument_list|(
literal|"Allowed reading of file "
operator|+
name|FILE1
operator|+
literal|" by "
operator|+
name|hdfsUgi
operator|.
name|getUserName
argument_list|()
argument_list|,
name|compareFile
argument_list|(
name|hdfsUgi
argument_list|,
name|FILE1
argument_list|,
name|TEXT
argument_list|)
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
literal|"Allowed reading of file "
operator|+
name|FILE1
operator|+
literal|" by "
operator|+
name|keyadminUgi
operator|.
name|getUserName
argument_list|()
argument_list|,
name|compareFile
argument_list|(
name|keyadminUgi
argument_list|,
name|FILE1
argument_list|,
name|TEXT
argument_list|)
argument_list|)
expr_stmt|;
comment|// Remove the zone
name|fs
operator|.
name|delete
argument_list|(
name|ZONE1
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|// Fail to remove the key
name|assertFalse
argument_list|(
literal|"Allowed deletion of file "
operator|+
name|FILE1
operator|+
literal|" by "
operator|+
name|hdfsUgi
operator|.
name|getUserName
argument_list|()
argument_list|,
name|deleteKey
argument_list|(
name|hdfsUgi
argument_list|,
name|KEY1
argument_list|)
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
literal|"Allowed deletion of file "
operator|+
name|FILE1
operator|+
literal|" by "
operator|+
name|userUgi
operator|.
name|getUserName
argument_list|()
argument_list|,
name|deleteKey
argument_list|(
name|userUgi
argument_list|,
name|KEY1
argument_list|)
argument_list|)
expr_stmt|;
comment|// Remove
name|assertTrue
argument_list|(
literal|"Exception during deletion of file "
operator|+
name|FILE1
operator|+
literal|" by "
operator|+
name|keyadminUgi
operator|.
name|getUserName
argument_list|()
argument_list|,
name|deleteKey
argument_list|(
name|keyadminUgi
argument_list|,
name|KEY1
argument_list|)
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|fs
operator|.
name|delete
argument_list|(
name|ZONE1
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|fs
operator|.
name|delete
argument_list|(
name|ZONE2
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|teardown
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Create a key as the specified user.    *    * @param ugi the target user    * @param key the target key    * @param conf the configuration    * @return whether the key creation succeeded    */
DECL|method|createKey (UserGroupInformation ugi, final String key, final Configuration conf)
specifier|private
name|boolean
name|createKey
parameter_list|(
name|UserGroupInformation
name|ugi
parameter_list|,
specifier|final
name|String
name|key
parameter_list|,
specifier|final
name|Configuration
name|conf
parameter_list|)
block|{
return|return
name|doUserOp
argument_list|(
name|ugi
argument_list|,
operator|new
name|UserOp
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|execute
parameter_list|()
throws|throws
name|IOException
block|{
try|try
block|{
name|DFSTestUtil
operator|.
name|createKey
argument_list|(
name|key
argument_list|,
name|cluster
argument_list|,
name|conf
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NoSuchAlgorithmException
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|ex
argument_list|)
throw|;
block|}
block|}
block|}
argument_list|)
return|;
block|}
comment|/**    * Create a zone as the specified user.    *    * @param ugi the target user    * @param key the target key    * @param zone the target zone    * @return whether the zone creation succeeded    */
DECL|method|createEncryptionZone (UserGroupInformation ugi, final String key, final Path zone)
specifier|private
name|boolean
name|createEncryptionZone
parameter_list|(
name|UserGroupInformation
name|ugi
parameter_list|,
specifier|final
name|String
name|key
parameter_list|,
specifier|final
name|Path
name|zone
parameter_list|)
block|{
return|return
name|doUserOp
argument_list|(
name|ugi
argument_list|,
operator|new
name|UserOp
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|execute
parameter_list|()
throws|throws
name|IOException
block|{
name|cluster
operator|.
name|getFileSystem
argument_list|()
operator|.
name|createEncryptionZone
argument_list|(
name|zone
argument_list|,
name|key
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
return|;
block|}
comment|/**    * Create a file as the specified user.    *    * @param ugi the target user    * @param file the target file    * @param text the target file contents    * @return whether the file creation succeeded    */
DECL|method|createFile (UserGroupInformation ugi, final Path file, final String text)
specifier|private
name|boolean
name|createFile
parameter_list|(
name|UserGroupInformation
name|ugi
parameter_list|,
specifier|final
name|Path
name|file
parameter_list|,
specifier|final
name|String
name|text
parameter_list|)
block|{
return|return
name|doUserOp
argument_list|(
name|ugi
argument_list|,
operator|new
name|UserOp
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|execute
parameter_list|()
throws|throws
name|IOException
block|{
name|FSDataOutputStream
name|dout
init|=
name|cluster
operator|.
name|getFileSystem
argument_list|()
operator|.
name|create
argument_list|(
name|file
argument_list|)
decl_stmt|;
name|PrintWriter
name|out
init|=
operator|new
name|PrintWriter
argument_list|(
operator|new
name|OutputStreamWriter
argument_list|(
name|dout
argument_list|)
argument_list|)
decl_stmt|;
name|out
operator|.
name|println
argument_list|(
name|text
argument_list|)
expr_stmt|;
name|out
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
argument_list|)
return|;
block|}
comment|/**    * Read a file as the specified user and compare the contents to expectations.    *    * @param ugi the target user    * @param file the target file    * @param text the expected file contents    * @return true if the file read succeeded and the contents were as expected    */
DECL|method|compareFile (UserGroupInformation ugi, final Path file, final String text)
specifier|private
name|boolean
name|compareFile
parameter_list|(
name|UserGroupInformation
name|ugi
parameter_list|,
specifier|final
name|Path
name|file
parameter_list|,
specifier|final
name|String
name|text
parameter_list|)
block|{
return|return
name|doUserOp
argument_list|(
name|ugi
argument_list|,
operator|new
name|UserOp
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|execute
parameter_list|()
throws|throws
name|IOException
block|{
name|FSDataInputStream
name|din
init|=
name|cluster
operator|.
name|getFileSystem
argument_list|()
operator|.
name|open
argument_list|(
name|file
argument_list|)
decl_stmt|;
name|BufferedReader
name|in
init|=
operator|new
name|BufferedReader
argument_list|(
operator|new
name|InputStreamReader
argument_list|(
name|din
argument_list|)
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|"The text read does not match the text written"
argument_list|,
name|text
argument_list|,
name|in
operator|.
name|readLine
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
return|;
block|}
comment|/**    * Delete a key as the specified user.    *    * @param ugi the target user    * @param key the target key    * @return whether the key deletion succeeded    */
DECL|method|deleteKey (UserGroupInformation ugi, final String key)
specifier|private
name|boolean
name|deleteKey
parameter_list|(
name|UserGroupInformation
name|ugi
parameter_list|,
specifier|final
name|String
name|key
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
return|return
name|doUserOp
argument_list|(
name|ugi
argument_list|,
operator|new
name|UserOp
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|execute
parameter_list|()
throws|throws
name|IOException
block|{
name|cluster
operator|.
name|getNameNode
argument_list|()
operator|.
name|getNamesystem
argument_list|()
operator|.
name|getProvider
argument_list|()
operator|.
name|deleteKey
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
return|;
block|}
comment|/**    * Perform an operation as the given user.  This method requires setting the    * login user. This method does not restore the login user to the setting    * from prior to the method call.    *    * @param ugi the target user    * @param op the operation to perform    * @return true if the operation succeeded without throwing an exception    */
DECL|method|doUserOp (UserGroupInformation ugi, final UserOp op)
specifier|private
name|boolean
name|doUserOp
parameter_list|(
name|UserGroupInformation
name|ugi
parameter_list|,
specifier|final
name|UserOp
name|op
parameter_list|)
block|{
name|UserGroupInformation
operator|.
name|setLoginUser
argument_list|(
name|ugi
argument_list|)
expr_stmt|;
comment|// Create a test key
return|return
name|ugi
operator|.
name|doAs
argument_list|(
operator|new
name|PrivilegedAction
argument_list|<
name|Boolean
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Boolean
name|run
parameter_list|()
block|{
try|try
block|{
name|op
operator|.
name|execute
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"IOException thrown during doAs() operation"
argument_list|,
name|ex
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
block|}
argument_list|)
return|;
block|}
comment|/**    * Simple interface that defines an operation to perform.    */
DECL|interface|UserOp
specifier|private
specifier|static
interface|interface
name|UserOp
block|{
DECL|method|execute ()
specifier|public
name|void
name|execute
parameter_list|()
throws|throws
name|IOException
function_decl|;
block|}
block|}
end_class

end_unit

