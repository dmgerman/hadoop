begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdfs.qjournal.client
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|qjournal
operator|.
name|client
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|qjournal
operator|.
name|QJMTestUtil
operator|.
name|FAKE_NSINFO
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|qjournal
operator|.
name|QJMTestUtil
operator|.
name|JID
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|qjournal
operator|.
name|QJMTestUtil
operator|.
name|writeSegment
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertEquals
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertTrue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Closeable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|InvocationTargetException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|InetSocketAddress
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URI
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URISyntaxException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|UnknownHostException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Random
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|SortedSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Callable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutorService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|CommonConfigurationKeysPublic
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|qjournal
operator|.
name|MiniJournalCluster
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|qjournal
operator|.
name|QJMTestUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|qjournal
operator|.
name|protocol
operator|.
name|QJournalProtocol
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|qjournal
operator|.
name|server
operator|.
name|JournalFaultInjector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|EditLogFileOutputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|EditLogOutputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|NameNodeLayoutVersion
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|NamespaceInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|util
operator|.
name|Holder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|ProtobufRpcEngine
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|test
operator|.
name|GenericTestUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|log4j
operator|.
name|Level
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Rule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Test
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|rules
operator|.
name|ExpectedException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|mockito
operator|.
name|Mockito
import|;
end_import

begin_import
import|import
name|org
operator|.
name|mockito
operator|.
name|invocation
operator|.
name|InvocationOnMock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|mockito
operator|.
name|stubbing
operator|.
name|Answer
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Maps
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Sets
import|;
end_import

begin_class
DECL|class|TestQJMWithFaults
specifier|public
class|class
name|TestQJMWithFaults
block|{
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|TestQJMWithFaults
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|RAND_SEED_PROPERTY
specifier|private
specifier|static
specifier|final
name|String
name|RAND_SEED_PROPERTY
init|=
literal|"TestQJMWithFaults.random-seed"
decl_stmt|;
DECL|field|NUM_WRITER_ITERS
specifier|private
specifier|static
specifier|final
name|int
name|NUM_WRITER_ITERS
init|=
literal|500
decl_stmt|;
DECL|field|SEGMENTS_PER_WRITER
specifier|private
specifier|static
specifier|final
name|int
name|SEGMENTS_PER_WRITER
init|=
literal|2
decl_stmt|;
DECL|field|conf
specifier|private
specifier|static
specifier|final
name|Configuration
name|conf
init|=
operator|new
name|Configuration
argument_list|()
decl_stmt|;
static|static
block|{
comment|// Don't retry connections - it just slows down the tests.
name|conf
operator|.
name|setInt
argument_list|(
name|CommonConfigurationKeysPublic
operator|.
name|IPC_CLIENT_CONNECT_MAX_RETRIES_KEY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|// Make tests run faster by avoiding fsync()
name|EditLogFileOutputStream
operator|.
name|setShouldSkipFsyncForTesting
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
comment|// Set up fault injection mock.
DECL|field|faultInjector
specifier|private
specifier|static
specifier|final
name|JournalFaultInjector
name|faultInjector
init|=
name|JournalFaultInjector
operator|.
name|instance
operator|=
name|Mockito
operator|.
name|mock
argument_list|(
name|JournalFaultInjector
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/**    * Run through the creation of a log without any faults injected,    * and count how many RPCs are made to each node. This sets the    * bounds for the other test cases, so they can exhaustively explore    * the space of potential failures.    */
DECL|method|determineMaxIpcNumber ()
specifier|private
specifier|static
name|long
name|determineMaxIpcNumber
parameter_list|()
throws|throws
name|Exception
block|{
name|Configuration
name|conf
init|=
operator|new
name|Configuration
argument_list|()
decl_stmt|;
name|MiniJournalCluster
name|cluster
init|=
operator|new
name|MiniJournalCluster
operator|.
name|Builder
argument_list|(
name|conf
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|cluster
operator|.
name|waitActive
argument_list|()
expr_stmt|;
name|QuorumJournalManager
name|qjm
init|=
literal|null
decl_stmt|;
name|long
name|ret
decl_stmt|;
try|try
block|{
name|qjm
operator|=
name|createInjectableQJM
argument_list|(
name|cluster
argument_list|)
expr_stmt|;
name|qjm
operator|.
name|format
argument_list|(
name|FAKE_NSINFO
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|doWorkload
argument_list|(
name|cluster
argument_list|,
name|qjm
argument_list|)
expr_stmt|;
name|SortedSet
argument_list|<
name|Integer
argument_list|>
name|ipcCounts
init|=
name|Sets
operator|.
name|newTreeSet
argument_list|()
decl_stmt|;
for|for
control|(
name|AsyncLogger
name|l
range|:
name|qjm
operator|.
name|getLoggerSetForTests
argument_list|()
operator|.
name|getLoggersForTests
argument_list|()
control|)
block|{
name|InvocationCountingChannel
name|ch
init|=
operator|(
name|InvocationCountingChannel
operator|)
name|l
decl_stmt|;
name|ch
operator|.
name|waitForAllPendingCalls
argument_list|()
expr_stmt|;
name|ipcCounts
operator|.
name|add
argument_list|(
name|ch
operator|.
name|getRpcCount
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// All of the loggers should have sent the same number of RPCs, since there
comment|// were no failures.
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|ipcCounts
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ipcCounts
operator|.
name|first
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Max IPC count = "
operator|+
name|ret
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|IOUtils
operator|.
name|closeStream
argument_list|(
name|qjm
argument_list|)
expr_stmt|;
name|cluster
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
annotation|@
name|Rule
DECL|field|expectedException
specifier|public
name|ExpectedException
name|expectedException
init|=
name|ExpectedException
operator|.
name|none
argument_list|()
decl_stmt|;
comment|/**    * Sets up two of the nodes to each drop a single RPC, at all    * possible combinations of RPCs. This may result in the    * active writer failing to write. After this point, a new writer    * should be able to recover and continue writing without    * data loss.    */
annotation|@
name|Test
DECL|method|testRecoverAfterDoubleFailures ()
specifier|public
name|void
name|testRecoverAfterDoubleFailures
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|long
name|MAX_IPC_NUMBER
init|=
name|determineMaxIpcNumber
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|failA
init|=
literal|1
init|;
name|failA
operator|<=
name|MAX_IPC_NUMBER
condition|;
name|failA
operator|++
control|)
block|{
for|for
control|(
name|int
name|failB
init|=
literal|1
init|;
name|failB
operator|<=
name|MAX_IPC_NUMBER
condition|;
name|failB
operator|++
control|)
block|{
name|String
name|injectionStr
init|=
literal|"("
operator|+
name|failA
operator|+
literal|", "
operator|+
name|failB
operator|+
literal|")"
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"\n\n-------------------------------------------\n"
operator|+
literal|"Beginning test, failing at "
operator|+
name|injectionStr
operator|+
literal|"\n"
operator|+
literal|"-------------------------------------------\n\n"
argument_list|)
expr_stmt|;
name|MiniJournalCluster
name|cluster
init|=
operator|new
name|MiniJournalCluster
operator|.
name|Builder
argument_list|(
name|conf
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|cluster
operator|.
name|waitActive
argument_list|()
expr_stmt|;
name|QuorumJournalManager
name|qjm
init|=
literal|null
decl_stmt|;
try|try
block|{
name|qjm
operator|=
name|createInjectableQJM
argument_list|(
name|cluster
argument_list|)
expr_stmt|;
name|qjm
operator|.
name|format
argument_list|(
name|FAKE_NSINFO
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|AsyncLogger
argument_list|>
name|loggers
init|=
name|qjm
operator|.
name|getLoggerSetForTests
argument_list|()
operator|.
name|getLoggersForTests
argument_list|()
decl_stmt|;
name|failIpcNumber
argument_list|(
name|loggers
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|failA
argument_list|)
expr_stmt|;
name|failIpcNumber
argument_list|(
name|loggers
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|,
name|failB
argument_list|)
expr_stmt|;
name|int
name|lastAckedTxn
init|=
name|doWorkload
argument_list|(
name|cluster
argument_list|,
name|qjm
argument_list|)
decl_stmt|;
if|if
condition|(
name|lastAckedTxn
operator|<
literal|6
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Failed after injecting failures at "
operator|+
name|injectionStr
operator|+
literal|". This is expected since we injected a failure in the "
operator|+
literal|"majority."
argument_list|)
expr_stmt|;
block|}
name|qjm
operator|.
name|close
argument_list|()
expr_stmt|;
name|qjm
operator|=
literal|null
expr_stmt|;
comment|// Now should be able to recover
name|qjm
operator|=
name|createInjectableQJM
argument_list|(
name|cluster
argument_list|)
expr_stmt|;
name|long
name|lastRecoveredTxn
init|=
name|QJMTestUtil
operator|.
name|recoverAndReturnLastTxn
argument_list|(
name|qjm
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|lastRecoveredTxn
operator|>=
name|lastAckedTxn
argument_list|)
expr_stmt|;
name|writeSegment
argument_list|(
name|cluster
argument_list|,
name|qjm
argument_list|,
name|lastRecoveredTxn
operator|+
literal|1
argument_list|,
literal|3
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
comment|// Test failure! Rethrow with the test setup info so it can be
comment|// easily triaged.
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Test failed with injection: "
operator|+
name|injectionStr
argument_list|,
name|t
argument_list|)
throw|;
block|}
finally|finally
block|{
name|cluster
operator|.
name|shutdown
argument_list|()
expr_stmt|;
name|cluster
operator|=
literal|null
expr_stmt|;
name|IOUtils
operator|.
name|closeStream
argument_list|(
name|qjm
argument_list|)
expr_stmt|;
name|qjm
operator|=
literal|null
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**    * Expect {@link UnknownHostException} if a hostname can't be resolved.    */
annotation|@
name|Test
DECL|method|testUnresolvableHostName ()
specifier|public
name|void
name|testUnresolvableHostName
parameter_list|()
throws|throws
name|Exception
block|{
name|expectedException
operator|.
name|expect
argument_list|(
name|UnknownHostException
operator|.
name|class
argument_list|)
expr_stmt|;
operator|new
name|QuorumJournalManager
argument_list|(
name|conf
argument_list|,
operator|new
name|URI
argument_list|(
literal|"qjournal://"
operator|+
literal|"bogus:12345"
operator|+
literal|"/"
operator|+
name|JID
argument_list|)
argument_list|,
name|FAKE_NSINFO
argument_list|)
expr_stmt|;
block|}
comment|/**    * Test case in which three JournalNodes randomly flip flop between    * up and down states every time they get an RPC.    *     * The writer keeps track of the latest ACKed edit, and on every    * recovery operation, ensures that it recovers at least to that    * point or higher. Since at any given point, a majority of JNs    * may be injecting faults, any writer operation is allowed to fail,    * so long as the exception message indicates it failed due to injected    * faults.    *     * Given a random seed, the test should be entirely deterministic.    */
annotation|@
name|Test
DECL|method|testRandomized ()
specifier|public
name|void
name|testRandomized
parameter_list|()
throws|throws
name|Exception
block|{
name|long
name|seed
decl_stmt|;
name|Long
name|userSpecifiedSeed
init|=
name|Long
operator|.
name|getLong
argument_list|(
name|RAND_SEED_PROPERTY
argument_list|)
decl_stmt|;
if|if
condition|(
name|userSpecifiedSeed
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Using seed specified in system property"
argument_list|)
expr_stmt|;
name|seed
operator|=
name|userSpecifiedSeed
expr_stmt|;
comment|// If the user specifies a seed, then we should gather all the
comment|// IPC trace information so that debugging is easier. This makes
comment|// the test run about 25% slower otherwise.
name|GenericTestUtils
operator|.
name|setLogLevel
argument_list|(
name|ProtobufRpcEngine
operator|.
name|LOG
argument_list|,
name|Level
operator|.
name|ALL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|seed
operator|=
operator|new
name|Random
argument_list|()
operator|.
name|nextLong
argument_list|()
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Random seed: "
operator|+
name|seed
argument_list|)
expr_stmt|;
name|Random
name|r
init|=
operator|new
name|Random
argument_list|(
name|seed
argument_list|)
decl_stmt|;
name|MiniJournalCluster
name|cluster
init|=
operator|new
name|MiniJournalCluster
operator|.
name|Builder
argument_list|(
name|conf
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|cluster
operator|.
name|waitActive
argument_list|()
expr_stmt|;
comment|// Format the cluster using a non-faulty QJM.
name|QuorumJournalManager
name|qjmForInitialFormat
init|=
name|createInjectableQJM
argument_list|(
name|cluster
argument_list|)
decl_stmt|;
name|qjmForInitialFormat
operator|.
name|format
argument_list|(
name|FAKE_NSINFO
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|qjmForInitialFormat
operator|.
name|close
argument_list|()
expr_stmt|;
try|try
block|{
name|long
name|txid
init|=
literal|0
decl_stmt|;
name|long
name|lastAcked
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|NUM_WRITER_ITERS
condition|;
name|i
operator|++
control|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Starting writer "
operator|+
name|i
operator|+
literal|"\n-------------------"
argument_list|)
expr_stmt|;
name|QuorumJournalManager
name|qjm
init|=
name|createRandomFaultyQJM
argument_list|(
name|cluster
argument_list|,
name|r
argument_list|)
decl_stmt|;
try|try
block|{
name|long
name|recovered
decl_stmt|;
try|try
block|{
name|recovered
operator|=
name|QJMTestUtil
operator|.
name|recoverAndReturnLastTxn
argument_list|(
name|qjm
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Failed recovery"
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|checkException
argument_list|(
name|t
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|assertTrue
argument_list|(
literal|"Recovered only up to txnid "
operator|+
name|recovered
operator|+
literal|" but had gotten an ack for "
operator|+
name|lastAcked
argument_list|,
name|recovered
operator|>=
name|lastAcked
argument_list|)
expr_stmt|;
name|txid
operator|=
name|recovered
operator|+
literal|1
expr_stmt|;
comment|// Periodically purge old data on disk so it's easier to look
comment|// at failure cases.
if|if
condition|(
name|txid
operator|>
literal|100
operator|&&
name|i
operator|%
literal|10
operator|==
literal|1
condition|)
block|{
name|qjm
operator|.
name|purgeLogsOlderThan
argument_list|(
name|txid
operator|-
literal|100
argument_list|)
expr_stmt|;
block|}
name|Holder
argument_list|<
name|Throwable
argument_list|>
name|thrown
init|=
operator|new
name|Holder
argument_list|<
name|Throwable
argument_list|>
argument_list|(
literal|null
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|SEGMENTS_PER_WRITER
condition|;
name|j
operator|++
control|)
block|{
name|lastAcked
operator|=
name|writeSegmentUntilCrash
argument_list|(
name|cluster
argument_list|,
name|qjm
argument_list|,
name|txid
argument_list|,
literal|4
argument_list|,
name|thrown
argument_list|)
expr_stmt|;
if|if
condition|(
name|thrown
operator|.
name|held
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Failed write"
argument_list|,
name|thrown
operator|.
name|held
argument_list|)
expr_stmt|;
name|checkException
argument_list|(
name|thrown
operator|.
name|held
argument_list|)
expr_stmt|;
break|break;
block|}
name|txid
operator|+=
literal|4
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|qjm
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
name|cluster
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|checkException (Throwable t)
specifier|private
name|void
name|checkException
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|GenericTestUtils
operator|.
name|assertExceptionContains
argument_list|(
literal|"Injected"
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|.
name|toString
argument_list|()
operator|.
name|contains
argument_list|(
literal|"AssertionError"
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Should never see AssertionError in fault test!"
argument_list|,
name|t
argument_list|)
throw|;
block|}
block|}
DECL|method|writeSegmentUntilCrash (MiniJournalCluster cluster, QuorumJournalManager qjm, long txid, int numTxns, Holder<Throwable> thrown)
specifier|private
name|long
name|writeSegmentUntilCrash
parameter_list|(
name|MiniJournalCluster
name|cluster
parameter_list|,
name|QuorumJournalManager
name|qjm
parameter_list|,
name|long
name|txid
parameter_list|,
name|int
name|numTxns
parameter_list|,
name|Holder
argument_list|<
name|Throwable
argument_list|>
name|thrown
parameter_list|)
block|{
name|long
name|firstTxId
init|=
name|txid
decl_stmt|;
name|long
name|lastAcked
init|=
name|txid
operator|-
literal|1
decl_stmt|;
try|try
block|{
name|EditLogOutputStream
name|stm
init|=
name|qjm
operator|.
name|startLogSegment
argument_list|(
name|txid
argument_list|,
name|NameNodeLayoutVersion
operator|.
name|CURRENT_LAYOUT_VERSION
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numTxns
condition|;
name|i
operator|++
control|)
block|{
name|QJMTestUtil
operator|.
name|writeTxns
argument_list|(
name|stm
argument_list|,
name|txid
operator|++
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|lastAcked
operator|++
expr_stmt|;
block|}
name|stm
operator|.
name|close
argument_list|()
expr_stmt|;
name|qjm
operator|.
name|finalizeLogSegment
argument_list|(
name|firstTxId
argument_list|,
name|lastAcked
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|thrown
operator|.
name|held
operator|=
name|t
expr_stmt|;
block|}
return|return
name|lastAcked
return|;
block|}
comment|/**    * Run a simple workload of becoming the active writer and writing    * two log segments: 1-3 and 4-6.    */
DECL|method|doWorkload (MiniJournalCluster cluster, QuorumJournalManager qjm)
specifier|private
specifier|static
name|int
name|doWorkload
parameter_list|(
name|MiniJournalCluster
name|cluster
parameter_list|,
name|QuorumJournalManager
name|qjm
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|lastAcked
init|=
literal|0
decl_stmt|;
try|try
block|{
name|qjm
operator|.
name|recoverUnfinalizedSegments
argument_list|()
expr_stmt|;
name|writeSegment
argument_list|(
name|cluster
argument_list|,
name|qjm
argument_list|,
literal|1
argument_list|,
literal|3
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|lastAcked
operator|=
literal|3
expr_stmt|;
name|writeSegment
argument_list|(
name|cluster
argument_list|,
name|qjm
argument_list|,
literal|4
argument_list|,
literal|3
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|lastAcked
operator|=
literal|6
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|QuorumException
name|qe
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Failed to write at txid "
operator|+
name|lastAcked
argument_list|,
name|qe
argument_list|)
expr_stmt|;
block|}
return|return
name|lastAcked
return|;
block|}
comment|/**    * Inject a failure at the given IPC number, such that the JN never    * receives the RPC. The client side sees an IOException. Future    * IPCs after this number will be received as usual.    */
DECL|method|failIpcNumber (AsyncLogger logger, int idx)
specifier|private
name|void
name|failIpcNumber
parameter_list|(
name|AsyncLogger
name|logger
parameter_list|,
name|int
name|idx
parameter_list|)
block|{
operator|(
operator|(
name|InvocationCountingChannel
operator|)
name|logger
operator|)
operator|.
name|failIpcNumber
argument_list|(
name|idx
argument_list|)
expr_stmt|;
block|}
DECL|class|RandomFaultyChannel
specifier|private
specifier|static
class|class
name|RandomFaultyChannel
extends|extends
name|IPCLoggerChannel
block|{
DECL|field|random
specifier|private
specifier|final
name|Random
name|random
decl_stmt|;
DECL|field|injectionProbability
specifier|private
specifier|final
name|float
name|injectionProbability
init|=
literal|0.1f
decl_stmt|;
DECL|field|isUp
specifier|private
name|boolean
name|isUp
init|=
literal|true
decl_stmt|;
DECL|method|RandomFaultyChannel (Configuration conf, NamespaceInfo nsInfo, String journalId, InetSocketAddress addr, long seed)
specifier|public
name|RandomFaultyChannel
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|NamespaceInfo
name|nsInfo
parameter_list|,
name|String
name|journalId
parameter_list|,
name|InetSocketAddress
name|addr
parameter_list|,
name|long
name|seed
parameter_list|)
block|{
name|super
argument_list|(
name|conf
argument_list|,
name|nsInfo
argument_list|,
name|journalId
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|this
operator|.
name|random
operator|=
operator|new
name|Random
argument_list|(
name|seed
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|createProxy ()
specifier|protected
name|QJournalProtocol
name|createProxy
parameter_list|()
throws|throws
name|IOException
block|{
name|QJournalProtocol
name|realProxy
init|=
name|super
operator|.
name|createProxy
argument_list|()
decl_stmt|;
return|return
name|mockProxy
argument_list|(
operator|new
name|WrapEveryCall
argument_list|<
name|Object
argument_list|>
argument_list|(
name|realProxy
argument_list|)
block|{
annotation|@
name|Override
name|void
name|beforeCall
parameter_list|(
name|InvocationOnMock
name|invocation
parameter_list|)
throws|throws
name|Exception
block|{
if|if
condition|(
name|random
operator|.
name|nextFloat
argument_list|()
operator|<
name|injectionProbability
condition|)
block|{
name|isUp
operator|=
operator|!
name|isUp
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"transitioned "
operator|+
name|addr
operator|+
literal|" to "
operator|+
operator|(
name|isUp
condition|?
literal|"up"
else|:
literal|"down"
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|isUp
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Injected - faking being down"
argument_list|)
throw|;
block|}
if|if
condition|(
name|invocation
operator|.
name|getMethod
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
literal|"acceptRecovery"
argument_list|)
condition|)
block|{
if|if
condition|(
name|random
operator|.
name|nextFloat
argument_list|()
operator|<
name|injectionProbability
condition|)
block|{
name|Mockito
operator|.
name|doThrow
argument_list|(
operator|new
name|IOException
argument_list|(
literal|"Injected - faking fault before persisting paxos data"
argument_list|)
argument_list|)
operator|.
name|when
argument_list|(
name|faultInjector
argument_list|)
operator|.
name|beforePersistPaxosData
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|random
operator|.
name|nextFloat
argument_list|()
operator|<
name|injectionProbability
condition|)
block|{
name|Mockito
operator|.
name|doThrow
argument_list|(
operator|new
name|IOException
argument_list|(
literal|"Injected - faking fault after persisting paxos data"
argument_list|)
argument_list|)
operator|.
name|when
argument_list|(
name|faultInjector
argument_list|)
operator|.
name|afterPersistPaxosData
argument_list|()
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|afterCall
parameter_list|(
name|InvocationOnMock
name|invocation
parameter_list|,
name|boolean
name|succeeded
parameter_list|)
block|{
name|Mockito
operator|.
name|reset
argument_list|(
name|faultInjector
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|createSingleThreadExecutor ()
specifier|protected
name|ExecutorService
name|createSingleThreadExecutor
parameter_list|()
block|{
return|return
operator|new
name|DirectExecutorService
argument_list|()
return|;
block|}
block|}
DECL|class|InvocationCountingChannel
specifier|private
specifier|static
class|class
name|InvocationCountingChannel
extends|extends
name|IPCLoggerChannel
block|{
DECL|field|rpcCount
specifier|private
name|int
name|rpcCount
init|=
literal|0
decl_stmt|;
DECL|field|injections
specifier|private
specifier|final
name|Map
argument_list|<
name|Integer
argument_list|,
name|Callable
argument_list|<
name|Void
argument_list|>
argument_list|>
name|injections
init|=
name|Maps
operator|.
name|newHashMap
argument_list|()
decl_stmt|;
DECL|method|InvocationCountingChannel (Configuration conf, NamespaceInfo nsInfo, String journalId, InetSocketAddress addr)
specifier|public
name|InvocationCountingChannel
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|NamespaceInfo
name|nsInfo
parameter_list|,
name|String
name|journalId
parameter_list|,
name|InetSocketAddress
name|addr
parameter_list|)
block|{
name|super
argument_list|(
name|conf
argument_list|,
name|nsInfo
argument_list|,
name|journalId
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
DECL|method|getRpcCount ()
name|int
name|getRpcCount
parameter_list|()
block|{
return|return
name|rpcCount
return|;
block|}
DECL|method|failIpcNumber (final int idx)
name|void
name|failIpcNumber
parameter_list|(
specifier|final
name|int
name|idx
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|idx
operator|>
literal|0
argument_list|,
literal|"id must be positive"
argument_list|)
expr_stmt|;
name|inject
argument_list|(
name|idx
argument_list|,
operator|new
name|Callable
argument_list|<
name|Void
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Void
name|call
parameter_list|()
throws|throws
name|Exception
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"injected failed IPC at "
operator|+
name|idx
argument_list|)
throw|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
DECL|method|inject (int beforeRpcNumber, Callable<Void> injectedCode)
specifier|private
name|void
name|inject
parameter_list|(
name|int
name|beforeRpcNumber
parameter_list|,
name|Callable
argument_list|<
name|Void
argument_list|>
name|injectedCode
parameter_list|)
block|{
name|injections
operator|.
name|put
argument_list|(
name|beforeRpcNumber
argument_list|,
name|injectedCode
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|createProxy ()
specifier|protected
name|QJournalProtocol
name|createProxy
parameter_list|()
throws|throws
name|IOException
block|{
specifier|final
name|QJournalProtocol
name|realProxy
init|=
name|super
operator|.
name|createProxy
argument_list|()
decl_stmt|;
name|QJournalProtocol
name|mock
init|=
name|mockProxy
argument_list|(
operator|new
name|WrapEveryCall
argument_list|<
name|Object
argument_list|>
argument_list|(
name|realProxy
argument_list|)
block|{
name|void
name|beforeCall
parameter_list|(
name|InvocationOnMock
name|invocation
parameter_list|)
throws|throws
name|Exception
block|{
name|rpcCount
operator|++
expr_stmt|;
name|String
name|param
init|=
literal|""
decl_stmt|;
for|for
control|(
name|Object
name|val
range|:
name|invocation
operator|.
name|getArguments
argument_list|()
control|)
block|{
name|param
operator|+=
name|val
operator|+
literal|","
expr_stmt|;
block|}
name|String
name|callStr
init|=
literal|"["
operator|+
name|addr
operator|+
literal|"] "
operator|+
name|invocation
operator|.
name|getMethod
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|"("
operator|+
name|param
operator|+
literal|")"
decl_stmt|;
name|Callable
argument_list|<
name|Void
argument_list|>
name|inject
init|=
name|injections
operator|.
name|get
argument_list|(
name|rpcCount
argument_list|)
decl_stmt|;
if|if
condition|(
name|inject
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Injecting code before IPC #"
operator|+
name|rpcCount
operator|+
literal|": "
operator|+
name|callStr
argument_list|)
expr_stmt|;
name|inject
operator|.
name|call
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"IPC call #"
operator|+
name|rpcCount
operator|+
literal|": "
operator|+
name|callStr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
argument_list|)
decl_stmt|;
return|return
name|mock
return|;
block|}
block|}
DECL|method|mockProxy (WrapEveryCall<Object> wrapper)
specifier|private
specifier|static
name|QJournalProtocol
name|mockProxy
parameter_list|(
name|WrapEveryCall
argument_list|<
name|Object
argument_list|>
name|wrapper
parameter_list|)
throws|throws
name|IOException
block|{
name|QJournalProtocol
name|mock
init|=
name|Mockito
operator|.
name|mock
argument_list|(
name|QJournalProtocol
operator|.
name|class
argument_list|,
name|Mockito
operator|.
name|withSettings
argument_list|()
operator|.
name|defaultAnswer
argument_list|(
name|wrapper
argument_list|)
operator|.
name|extraInterfaces
argument_list|(
name|Closeable
operator|.
name|class
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|mock
return|;
block|}
DECL|class|WrapEveryCall
specifier|private
specifier|static
specifier|abstract
class|class
name|WrapEveryCall
parameter_list|<
name|T
parameter_list|>
implements|implements
name|Answer
argument_list|<
name|T
argument_list|>
block|{
DECL|field|realObj
specifier|private
specifier|final
name|Object
name|realObj
decl_stmt|;
DECL|method|WrapEveryCall (Object realObj)
name|WrapEveryCall
parameter_list|(
name|Object
name|realObj
parameter_list|)
block|{
name|this
operator|.
name|realObj
operator|=
name|realObj
expr_stmt|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
annotation|@
name|Override
DECL|method|answer (InvocationOnMock invocation)
specifier|public
name|T
name|answer
parameter_list|(
name|InvocationOnMock
name|invocation
parameter_list|)
throws|throws
name|Throwable
block|{
comment|// Don't want to inject an error on close() since that isn't
comment|// actually an IPC call!
if|if
condition|(
operator|!
name|Closeable
operator|.
name|class
operator|.
name|equals
argument_list|(
name|invocation
operator|.
name|getMethod
argument_list|()
operator|.
name|getDeclaringClass
argument_list|()
argument_list|)
condition|)
block|{
name|beforeCall
argument_list|(
name|invocation
argument_list|)
expr_stmt|;
block|}
name|boolean
name|success
init|=
literal|false
decl_stmt|;
try|try
block|{
name|T
name|ret
init|=
operator|(
name|T
operator|)
name|invocation
operator|.
name|getMethod
argument_list|()
operator|.
name|invoke
argument_list|(
name|realObj
argument_list|,
name|invocation
operator|.
name|getArguments
argument_list|()
argument_list|)
decl_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
return|return
name|ret
return|;
block|}
catch|catch
parameter_list|(
name|InvocationTargetException
name|ite
parameter_list|)
block|{
throw|throw
name|ite
operator|.
name|getCause
argument_list|()
throw|;
block|}
finally|finally
block|{
name|afterCall
argument_list|(
name|invocation
argument_list|,
name|success
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|beforeCall (InvocationOnMock invocation)
specifier|abstract
name|void
name|beforeCall
parameter_list|(
name|InvocationOnMock
name|invocation
parameter_list|)
throws|throws
name|Exception
function_decl|;
DECL|method|afterCall (InvocationOnMock invocation, boolean succeeded)
name|void
name|afterCall
parameter_list|(
name|InvocationOnMock
name|invocation
parameter_list|,
name|boolean
name|succeeded
parameter_list|)
block|{}
block|}
DECL|method|createInjectableQJM (MiniJournalCluster cluster)
specifier|private
specifier|static
name|QuorumJournalManager
name|createInjectableQJM
parameter_list|(
name|MiniJournalCluster
name|cluster
parameter_list|)
throws|throws
name|IOException
throws|,
name|URISyntaxException
block|{
name|AsyncLogger
operator|.
name|Factory
name|spyFactory
init|=
operator|new
name|AsyncLogger
operator|.
name|Factory
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|AsyncLogger
name|createLogger
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|NamespaceInfo
name|nsInfo
parameter_list|,
name|String
name|journalId
parameter_list|,
name|String
name|nameserviceId
parameter_list|,
name|InetSocketAddress
name|addr
parameter_list|)
block|{
return|return
operator|new
name|InvocationCountingChannel
argument_list|(
name|conf
argument_list|,
name|nsInfo
argument_list|,
name|journalId
argument_list|,
name|addr
argument_list|)
return|;
block|}
block|}
decl_stmt|;
return|return
operator|new
name|QuorumJournalManager
argument_list|(
name|conf
argument_list|,
name|cluster
operator|.
name|getQuorumJournalURI
argument_list|(
name|JID
argument_list|)
argument_list|,
name|FAKE_NSINFO
argument_list|,
name|spyFactory
argument_list|)
return|;
block|}
DECL|method|createRandomFaultyQJM ( MiniJournalCluster cluster, final Random seedGenerator)
specifier|private
specifier|static
name|QuorumJournalManager
name|createRandomFaultyQJM
parameter_list|(
name|MiniJournalCluster
name|cluster
parameter_list|,
specifier|final
name|Random
name|seedGenerator
parameter_list|)
throws|throws
name|IOException
throws|,
name|URISyntaxException
block|{
name|AsyncLogger
operator|.
name|Factory
name|spyFactory
init|=
operator|new
name|AsyncLogger
operator|.
name|Factory
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|AsyncLogger
name|createLogger
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|NamespaceInfo
name|nsInfo
parameter_list|,
name|String
name|journalId
parameter_list|,
name|String
name|nameServiceId
parameter_list|,
name|InetSocketAddress
name|addr
parameter_list|)
block|{
return|return
operator|new
name|RandomFaultyChannel
argument_list|(
name|conf
argument_list|,
name|nsInfo
argument_list|,
name|journalId
argument_list|,
name|addr
argument_list|,
name|seedGenerator
operator|.
name|nextLong
argument_list|()
argument_list|)
return|;
block|}
block|}
decl_stmt|;
return|return
operator|new
name|QuorumJournalManager
argument_list|(
name|conf
argument_list|,
name|cluster
operator|.
name|getQuorumJournalURI
argument_list|(
name|JID
argument_list|)
argument_list|,
name|FAKE_NSINFO
argument_list|,
name|spyFactory
argument_list|)
return|;
block|}
block|}
end_class

end_unit

