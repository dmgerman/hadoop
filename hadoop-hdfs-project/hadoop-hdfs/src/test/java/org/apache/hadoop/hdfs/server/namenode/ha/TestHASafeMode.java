begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdfs.server.namenode.ha
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|ha
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|impl
operator|.
name|Log4JLogger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FSDataOutputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ha
operator|.
name|HAServiceProtocol
operator|.
name|RequestSource
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ha
operator|.
name|HAServiceProtocol
operator|.
name|StateChangeRequestInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSTestUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|MiniDFSCluster
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|MiniDFSNNTopology
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|HdfsConstants
operator|.
name|SafeModeAction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|blockmanagement
operator|.
name|BlockManagerTestUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|FSImage
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|FSNamesystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|NameNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|NameNodeAdapter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|test
operator|.
name|GenericTestUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|log4j
operator|.
name|Level
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|After
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Before
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Test
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Supplier
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_comment
comment|/**  * Tests that exercise safemode in an HA cluster.  */
end_comment

begin_class
DECL|class|TestHASafeMode
specifier|public
class|class
name|TestHASafeMode
block|{
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|TestHASafeMode
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|BLOCK_SIZE
specifier|private
specifier|static
specifier|final
name|int
name|BLOCK_SIZE
init|=
literal|1024
decl_stmt|;
DECL|field|nn0
specifier|private
name|NameNode
name|nn0
decl_stmt|;
DECL|field|nn1
specifier|private
name|NameNode
name|nn1
decl_stmt|;
DECL|field|fs
specifier|private
name|FileSystem
name|fs
decl_stmt|;
DECL|field|cluster
specifier|private
name|MiniDFSCluster
name|cluster
decl_stmt|;
static|static
block|{
operator|(
operator|(
name|Log4JLogger
operator|)
name|LogFactory
operator|.
name|getLog
argument_list|(
name|FSImage
operator|.
name|class
argument_list|)
operator|)
operator|.
name|getLogger
argument_list|()
operator|.
name|setLevel
argument_list|(
name|Level
operator|.
name|ALL
argument_list|)
expr_stmt|;
operator|(
operator|(
name|Log4JLogger
operator|)
name|LogFactory
operator|.
name|getLog
argument_list|(
name|FSNamesystem
operator|.
name|class
argument_list|)
operator|)
operator|.
name|getLogger
argument_list|()
operator|.
name|setLevel
argument_list|(
name|Level
operator|.
name|ALL
argument_list|)
expr_stmt|;
operator|(
operator|(
name|Log4JLogger
operator|)
name|NameNode
operator|.
name|stateChangeLog
operator|)
operator|.
name|getLogger
argument_list|()
operator|.
name|setLevel
argument_list|(
name|Level
operator|.
name|ALL
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Before
DECL|method|setupCluster ()
specifier|public
name|void
name|setupCluster
parameter_list|()
throws|throws
name|Exception
block|{
name|Configuration
name|conf
init|=
operator|new
name|Configuration
argument_list|()
decl_stmt|;
name|conf
operator|.
name|setInt
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_BLOCK_SIZE_KEY
argument_list|,
name|BLOCK_SIZE
argument_list|)
expr_stmt|;
name|conf
operator|.
name|setInt
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_HEARTBEAT_INTERVAL_KEY
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|conf
operator|.
name|setInt
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_HA_TAILEDITS_PERIOD_KEY
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cluster
operator|=
operator|new
name|MiniDFSCluster
operator|.
name|Builder
argument_list|(
name|conf
argument_list|)
operator|.
name|nnTopology
argument_list|(
name|MiniDFSNNTopology
operator|.
name|simpleHATopology
argument_list|()
argument_list|)
operator|.
name|numDataNodes
argument_list|(
literal|3
argument_list|)
operator|.
name|waitSafeMode
argument_list|(
literal|false
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
name|cluster
operator|.
name|waitActive
argument_list|()
expr_stmt|;
name|nn0
operator|=
name|cluster
operator|.
name|getNameNode
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|nn1
operator|=
name|cluster
operator|.
name|getNameNode
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|fs
operator|=
name|HATestUtil
operator|.
name|configureFailoverFs
argument_list|(
name|cluster
argument_list|,
name|conf
argument_list|)
expr_stmt|;
name|cluster
operator|.
name|transitionToActive
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
annotation|@
name|After
DECL|method|shutdownCluster ()
specifier|public
name|void
name|shutdownCluster
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|cluster
operator|!=
literal|null
condition|)
block|{
name|cluster
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|restartStandby ()
specifier|private
name|void
name|restartStandby
parameter_list|()
throws|throws
name|IOException
block|{
name|cluster
operator|.
name|shutdownNameNode
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|// Set the safemode extension to be lengthy, so that the tests
comment|// can check the safemode message after the safemode conditions
comment|// have been achieved, without being racy.
name|cluster
operator|.
name|getConfiguration
argument_list|(
literal|1
argument_list|)
operator|.
name|setInt
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_SAFEMODE_EXTENSION_KEY
argument_list|,
literal|30000
argument_list|)
expr_stmt|;
name|cluster
operator|.
name|getConfiguration
argument_list|(
literal|1
argument_list|)
operator|.
name|setInt
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_HA_TAILEDITS_PERIOD_KEY
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cluster
operator|.
name|restartNameNode
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|nn1
operator|=
name|cluster
operator|.
name|getNameNode
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|nn1
operator|.
name|getNamesystem
argument_list|()
operator|.
name|getTransactionsSinceLastLogRoll
argument_list|()
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
block|}
comment|/**    * Test case for enter safemode in active namenode, when it is already in startup safemode.    * It is a regression test for HDFS-2747.    */
annotation|@
name|Test
DECL|method|testEnterSafeModeInANNShouldNotThrowNPE ()
specifier|public
name|void
name|testEnterSafeModeInANNShouldNotThrowNPE
parameter_list|()
throws|throws
name|Exception
block|{
name|banner
argument_list|(
literal|"Restarting active"
argument_list|)
expr_stmt|;
name|DFSTestUtil
operator|.
name|createFile
argument_list|(
name|fs
argument_list|,
operator|new
name|Path
argument_list|(
literal|"/test"
argument_list|)
argument_list|,
literal|3
operator|*
name|BLOCK_SIZE
argument_list|,
operator|(
name|short
operator|)
literal|3
argument_list|,
literal|1L
argument_list|)
expr_stmt|;
name|restartActive
argument_list|()
expr_stmt|;
name|nn0
operator|.
name|getRpcServer
argument_list|()
operator|.
name|transitionToActive
argument_list|(
operator|new
name|StateChangeRequestInfo
argument_list|(
name|RequestSource
operator|.
name|REQUEST_BY_USER
argument_list|)
argument_list|)
expr_stmt|;
name|FSNamesystem
name|namesystem
init|=
name|nn0
operator|.
name|getNamesystem
argument_list|()
decl_stmt|;
name|String
name|status
init|=
name|namesystem
operator|.
name|getSafemode
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
literal|"Bad safemode status: '"
operator|+
name|status
operator|+
literal|"'"
argument_list|,
name|status
operator|.
name|startsWith
argument_list|(
literal|"Safe mode is ON."
argument_list|)
argument_list|)
expr_stmt|;
name|NameNodeAdapter
operator|.
name|enterSafeMode
argument_list|(
name|nn0
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"Failed to enter into safemode in active"
argument_list|,
name|namesystem
operator|.
name|isInSafeMode
argument_list|()
argument_list|)
expr_stmt|;
name|NameNodeAdapter
operator|.
name|enterSafeMode
argument_list|(
name|nn0
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"Failed to enter into safemode in active"
argument_list|,
name|namesystem
operator|.
name|isInSafeMode
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Test case for enter safemode in standby namenode, when it is already in startup safemode.    * It is a regression test for HDFS-2747.    */
annotation|@
name|Test
DECL|method|testEnterSafeModeInSBNShouldNotThrowNPE ()
specifier|public
name|void
name|testEnterSafeModeInSBNShouldNotThrowNPE
parameter_list|()
throws|throws
name|Exception
block|{
name|banner
argument_list|(
literal|"Starting with NN0 active and NN1 standby, creating some blocks"
argument_list|)
expr_stmt|;
name|DFSTestUtil
operator|.
name|createFile
argument_list|(
name|fs
argument_list|,
operator|new
name|Path
argument_list|(
literal|"/test"
argument_list|)
argument_list|,
literal|3
operator|*
name|BLOCK_SIZE
argument_list|,
operator|(
name|short
operator|)
literal|3
argument_list|,
literal|1L
argument_list|)
expr_stmt|;
comment|// Roll edit log so that, when the SBN restarts, it will load
comment|// the namespace during startup and enter safemode.
name|nn0
operator|.
name|getRpcServer
argument_list|()
operator|.
name|rollEditLog
argument_list|()
expr_stmt|;
name|banner
argument_list|(
literal|"Creating some blocks that won't be in the edit log"
argument_list|)
expr_stmt|;
name|DFSTestUtil
operator|.
name|createFile
argument_list|(
name|fs
argument_list|,
operator|new
name|Path
argument_list|(
literal|"/test2"
argument_list|)
argument_list|,
literal|5
operator|*
name|BLOCK_SIZE
argument_list|,
operator|(
name|short
operator|)
literal|3
argument_list|,
literal|1L
argument_list|)
expr_stmt|;
name|banner
argument_list|(
literal|"Deleting the original blocks"
argument_list|)
expr_stmt|;
name|fs
operator|.
name|delete
argument_list|(
operator|new
name|Path
argument_list|(
literal|"/test"
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|banner
argument_list|(
literal|"Restarting standby"
argument_list|)
expr_stmt|;
name|restartStandby
argument_list|()
expr_stmt|;
name|FSNamesystem
name|namesystem
init|=
name|nn1
operator|.
name|getNamesystem
argument_list|()
decl_stmt|;
name|String
name|status
init|=
name|namesystem
operator|.
name|getSafemode
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
literal|"Bad safemode status: '"
operator|+
name|status
operator|+
literal|"'"
argument_list|,
name|status
operator|.
name|startsWith
argument_list|(
literal|"Safe mode is ON."
argument_list|)
argument_list|)
expr_stmt|;
name|NameNodeAdapter
operator|.
name|enterSafeMode
argument_list|(
name|nn1
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"Failed to enter into safemode in standby"
argument_list|,
name|namesystem
operator|.
name|isInSafeMode
argument_list|()
argument_list|)
expr_stmt|;
name|NameNodeAdapter
operator|.
name|enterSafeMode
argument_list|(
name|nn1
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"Failed to enter into safemode in standby"
argument_list|,
name|namesystem
operator|.
name|isInSafeMode
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|restartActive ()
specifier|private
name|void
name|restartActive
parameter_list|()
throws|throws
name|IOException
block|{
name|cluster
operator|.
name|shutdownNameNode
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|// Set the safemode extension to be lengthy, so that the tests
comment|// can check the safemode message after the safemode conditions
comment|// have been achieved, without being racy.
name|cluster
operator|.
name|getConfiguration
argument_list|(
literal|0
argument_list|)
operator|.
name|setInt
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_SAFEMODE_EXTENSION_KEY
argument_list|,
literal|30000
argument_list|)
expr_stmt|;
name|cluster
operator|.
name|restartNameNode
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|nn0
operator|=
name|cluster
operator|.
name|getNameNode
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/**    * Tests the case where, while a standby is down, more blocks are    * added to the namespace, but not rolled. So, when it starts up,    * it receives notification about the new blocks during    * the safemode extension period.    */
annotation|@
name|Test
DECL|method|testBlocksAddedBeforeStandbyRestart ()
specifier|public
name|void
name|testBlocksAddedBeforeStandbyRestart
parameter_list|()
throws|throws
name|Exception
block|{
name|banner
argument_list|(
literal|"Starting with NN0 active and NN1 standby, creating some blocks"
argument_list|)
expr_stmt|;
name|DFSTestUtil
operator|.
name|createFile
argument_list|(
name|fs
argument_list|,
operator|new
name|Path
argument_list|(
literal|"/test"
argument_list|)
argument_list|,
literal|3
operator|*
name|BLOCK_SIZE
argument_list|,
operator|(
name|short
operator|)
literal|3
argument_list|,
literal|1L
argument_list|)
expr_stmt|;
comment|// Roll edit log so that, when the SBN restarts, it will load
comment|// the namespace during startup.
name|nn0
operator|.
name|getRpcServer
argument_list|()
operator|.
name|rollEditLog
argument_list|()
expr_stmt|;
name|banner
argument_list|(
literal|"Creating some blocks that won't be in the edit log"
argument_list|)
expr_stmt|;
name|DFSTestUtil
operator|.
name|createFile
argument_list|(
name|fs
argument_list|,
operator|new
name|Path
argument_list|(
literal|"/test2"
argument_list|)
argument_list|,
literal|5
operator|*
name|BLOCK_SIZE
argument_list|,
operator|(
name|short
operator|)
literal|3
argument_list|,
literal|1L
argument_list|)
expr_stmt|;
name|banner
argument_list|(
literal|"Restarting standby"
argument_list|)
expr_stmt|;
name|restartStandby
argument_list|()
expr_stmt|;
comment|// We expect it not to be stuck in safemode, since those blocks
comment|// that are already visible to the SBN should be processed
comment|// in the initial block reports.
name|assertSafeMode
argument_list|(
name|nn1
argument_list|,
literal|3
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|banner
argument_list|(
literal|"Waiting for standby to catch up to active namespace"
argument_list|)
expr_stmt|;
name|HATestUtil
operator|.
name|waitForStandbyToCatchUp
argument_list|(
name|nn0
argument_list|,
name|nn1
argument_list|)
expr_stmt|;
name|assertSafeMode
argument_list|(
name|nn1
argument_list|,
literal|8
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
comment|/**    * Similar to {@link #testBlocksAddedBeforeStandbyRestart()} except that    * the new blocks are allocated after the SBN has restarted. So, the    * blocks were not present in the original block reports at startup    * but are reported separately by blockReceived calls.    */
annotation|@
name|Test
DECL|method|testBlocksAddedWhileInSafeMode ()
specifier|public
name|void
name|testBlocksAddedWhileInSafeMode
parameter_list|()
throws|throws
name|Exception
block|{
name|banner
argument_list|(
literal|"Starting with NN0 active and NN1 standby, creating some blocks"
argument_list|)
expr_stmt|;
name|DFSTestUtil
operator|.
name|createFile
argument_list|(
name|fs
argument_list|,
operator|new
name|Path
argument_list|(
literal|"/test"
argument_list|)
argument_list|,
literal|3
operator|*
name|BLOCK_SIZE
argument_list|,
operator|(
name|short
operator|)
literal|3
argument_list|,
literal|1L
argument_list|)
expr_stmt|;
comment|// Roll edit log so that, when the SBN restarts, it will load
comment|// the namespace during startup.
name|nn0
operator|.
name|getRpcServer
argument_list|()
operator|.
name|rollEditLog
argument_list|()
expr_stmt|;
name|banner
argument_list|(
literal|"Restarting standby"
argument_list|)
expr_stmt|;
name|restartStandby
argument_list|()
expr_stmt|;
name|assertSafeMode
argument_list|(
name|nn1
argument_list|,
literal|3
argument_list|,
literal|3
argument_list|)
expr_stmt|;
comment|// Create a few blocks which will send blockReceived calls to the
comment|// SBN.
name|banner
argument_list|(
literal|"Creating some blocks while SBN is in safe mode"
argument_list|)
expr_stmt|;
name|DFSTestUtil
operator|.
name|createFile
argument_list|(
name|fs
argument_list|,
operator|new
name|Path
argument_list|(
literal|"/test2"
argument_list|)
argument_list|,
literal|5
operator|*
name|BLOCK_SIZE
argument_list|,
operator|(
name|short
operator|)
literal|3
argument_list|,
literal|1L
argument_list|)
expr_stmt|;
name|banner
argument_list|(
literal|"Waiting for standby to catch up to active namespace"
argument_list|)
expr_stmt|;
name|HATestUtil
operator|.
name|waitForStandbyToCatchUp
argument_list|(
name|nn0
argument_list|,
name|nn1
argument_list|)
expr_stmt|;
name|assertSafeMode
argument_list|(
name|nn1
argument_list|,
literal|8
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
comment|/**    * Test for the following case proposed by ATM:    * 1. Both NNs are up, one is active. There are 100 blocks. Both are    *    out of safemode.    * 2. 10 block deletions get processed by NN1. NN2 enqueues these DN messages    *     until it next reads from a checkpointed edits file.    * 3. NN2 gets restarted. Its queues are lost.    * 4. NN2 comes up, reads from all the finalized edits files. Concludes there    *    should still be 100 blocks.    * 5. NN2 receives a block report from all the DNs, which only accounts for    *    90 blocks. It doesn't leave safemode.    * 6. NN1 dies or is transitioned to standby.    * 7. NN2 is transitioned to active. It reads all the edits from NN1. It now    *    knows there should only be 90 blocks, but it's still in safemode.    * 8. NN2 doesn't ever recheck whether it should leave safemode.    *     * This is essentially the inverse of {@link #testBlocksAddedBeforeStandbyRestart()}    */
annotation|@
name|Test
DECL|method|testBlocksRemovedBeforeStandbyRestart ()
specifier|public
name|void
name|testBlocksRemovedBeforeStandbyRestart
parameter_list|()
throws|throws
name|Exception
block|{
name|banner
argument_list|(
literal|"Starting with NN0 active and NN1 standby, creating some blocks"
argument_list|)
expr_stmt|;
name|DFSTestUtil
operator|.
name|createFile
argument_list|(
name|fs
argument_list|,
operator|new
name|Path
argument_list|(
literal|"/test"
argument_list|)
argument_list|,
literal|5
operator|*
name|BLOCK_SIZE
argument_list|,
operator|(
name|short
operator|)
literal|3
argument_list|,
literal|1L
argument_list|)
expr_stmt|;
comment|// Roll edit log so that, when the SBN restarts, it will load
comment|// the namespace during startup.
name|nn0
operator|.
name|getRpcServer
argument_list|()
operator|.
name|rollEditLog
argument_list|()
expr_stmt|;
comment|// Delete those blocks again, so they won't get reported to the SBN
comment|// once it starts up
name|banner
argument_list|(
literal|"Removing the blocks without rolling the edit log"
argument_list|)
expr_stmt|;
name|fs
operator|.
name|delete
argument_list|(
operator|new
name|Path
argument_list|(
literal|"/test"
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|BlockManagerTestUtil
operator|.
name|computeAllPendingWork
argument_list|(
name|nn0
operator|.
name|getNamesystem
argument_list|()
operator|.
name|getBlockManager
argument_list|()
argument_list|)
expr_stmt|;
name|cluster
operator|.
name|triggerHeartbeats
argument_list|()
expr_stmt|;
name|banner
argument_list|(
literal|"Restarting standby"
argument_list|)
expr_stmt|;
name|restartStandby
argument_list|()
expr_stmt|;
name|assertSafeMode
argument_list|(
name|nn1
argument_list|,
literal|0
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|banner
argument_list|(
literal|"Waiting for standby to catch up to active namespace"
argument_list|)
expr_stmt|;
name|HATestUtil
operator|.
name|waitForStandbyToCatchUp
argument_list|(
name|nn0
argument_list|,
name|nn1
argument_list|)
expr_stmt|;
name|assertSafeMode
argument_list|(
name|nn1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/**    * Similar to {@link #testBlocksRemovedBeforeStandbyRestart()} except that    * the blocks are removed after the SBN has restarted. So, the    * blocks were present in the original block reports at startup    * but are deleted separately later by deletion reports.    */
annotation|@
name|Test
DECL|method|testBlocksRemovedWhileInSafeMode ()
specifier|public
name|void
name|testBlocksRemovedWhileInSafeMode
parameter_list|()
throws|throws
name|Exception
block|{
name|banner
argument_list|(
literal|"Starting with NN0 active and NN1 standby, creating some blocks"
argument_list|)
expr_stmt|;
name|DFSTestUtil
operator|.
name|createFile
argument_list|(
name|fs
argument_list|,
operator|new
name|Path
argument_list|(
literal|"/test"
argument_list|)
argument_list|,
literal|10
operator|*
name|BLOCK_SIZE
argument_list|,
operator|(
name|short
operator|)
literal|3
argument_list|,
literal|1L
argument_list|)
expr_stmt|;
comment|// Roll edit log so that, when the SBN restarts, it will load
comment|// the namespace during startup.
name|nn0
operator|.
name|getRpcServer
argument_list|()
operator|.
name|rollEditLog
argument_list|()
expr_stmt|;
name|banner
argument_list|(
literal|"Restarting standby"
argument_list|)
expr_stmt|;
name|restartStandby
argument_list|()
expr_stmt|;
comment|// It will initially have all of the blocks necessary.
name|assertSafeMode
argument_list|(
name|nn1
argument_list|,
literal|10
argument_list|,
literal|10
argument_list|)
expr_stmt|;
comment|// Delete those blocks while the SBN is in safe mode.
comment|// This doesn't affect the SBN, since deletions are not
comment|// ACKed when due to block removals.
name|banner
argument_list|(
literal|"Removing the blocks without rolling the edit log"
argument_list|)
expr_stmt|;
name|fs
operator|.
name|delete
argument_list|(
operator|new
name|Path
argument_list|(
literal|"/test"
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|BlockManagerTestUtil
operator|.
name|computeAllPendingWork
argument_list|(
name|nn0
operator|.
name|getNamesystem
argument_list|()
operator|.
name|getBlockManager
argument_list|()
argument_list|)
expr_stmt|;
name|banner
argument_list|(
literal|"Triggering deletions on DNs and Deletion Reports"
argument_list|)
expr_stmt|;
name|cluster
operator|.
name|triggerHeartbeats
argument_list|()
expr_stmt|;
name|HATestUtil
operator|.
name|waitForDNDeletions
argument_list|(
name|cluster
argument_list|)
expr_stmt|;
name|cluster
operator|.
name|triggerDeletionReports
argument_list|()
expr_stmt|;
name|assertSafeMode
argument_list|(
name|nn1
argument_list|,
literal|10
argument_list|,
literal|10
argument_list|)
expr_stmt|;
comment|// When we catch up to active namespace, it will restore back
comment|// to 0 blocks.
name|banner
argument_list|(
literal|"Waiting for standby to catch up to active namespace"
argument_list|)
expr_stmt|;
name|HATestUtil
operator|.
name|waitForStandbyToCatchUp
argument_list|(
name|nn0
argument_list|,
name|nn1
argument_list|)
expr_stmt|;
name|assertSafeMode
argument_list|(
name|nn1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/**    * Tests that the standby node properly tracks the number of total    * and safe blocks while it is in safe mode. Since safe-mode only    * counts completed blocks, append needs to decrement the total    * number of blocks and then re-increment when the file is closed    * again.    */
annotation|@
name|Test
DECL|method|testAppendWhileInSafeMode ()
specifier|public
name|void
name|testAppendWhileInSafeMode
parameter_list|()
throws|throws
name|Exception
block|{
name|banner
argument_list|(
literal|"Starting with NN0 active and NN1 standby, creating some blocks"
argument_list|)
expr_stmt|;
comment|// Make 4.5 blocks so that append() will re-open an existing block
comment|// instead of just adding a new one
name|DFSTestUtil
operator|.
name|createFile
argument_list|(
name|fs
argument_list|,
operator|new
name|Path
argument_list|(
literal|"/test"
argument_list|)
argument_list|,
literal|4
operator|*
name|BLOCK_SIZE
operator|+
name|BLOCK_SIZE
operator|/
literal|2
argument_list|,
operator|(
name|short
operator|)
literal|3
argument_list|,
literal|1L
argument_list|)
expr_stmt|;
comment|// Roll edit log so that, when the SBN restarts, it will load
comment|// the namespace during startup.
name|nn0
operator|.
name|getRpcServer
argument_list|()
operator|.
name|rollEditLog
argument_list|()
expr_stmt|;
name|banner
argument_list|(
literal|"Restarting standby"
argument_list|)
expr_stmt|;
name|restartStandby
argument_list|()
expr_stmt|;
comment|// It will initially have all of the blocks necessary.
name|assertSafeMode
argument_list|(
name|nn1
argument_list|,
literal|5
argument_list|,
literal|5
argument_list|)
expr_stmt|;
comment|// Append to a block while SBN is in safe mode. This should
comment|// not affect safemode initially, since the DN message
comment|// will get queued.
name|FSDataOutputStream
name|stm
init|=
name|fs
operator|.
name|append
argument_list|(
operator|new
name|Path
argument_list|(
literal|"/test"
argument_list|)
argument_list|)
decl_stmt|;
try|try
block|{
name|assertSafeMode
argument_list|(
name|nn1
argument_list|,
literal|5
argument_list|,
literal|5
argument_list|)
expr_stmt|;
comment|// if we roll edits now, the SBN should see that it's under construction
comment|// and change its total count and safe count down by one, since UC
comment|// blocks are not counted by safe mode.
name|HATestUtil
operator|.
name|waitForStandbyToCatchUp
argument_list|(
name|nn0
argument_list|,
name|nn1
argument_list|)
expr_stmt|;
name|assertSafeMode
argument_list|(
name|nn1
argument_list|,
literal|4
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|IOUtils
operator|.
name|closeStream
argument_list|(
name|stm
argument_list|)
expr_stmt|;
block|}
comment|// Delete those blocks while the SBN is in safe mode.
comment|// This will not ACK the deletions to the SBN, so it won't
comment|// notice until we roll the edit log.
name|banner
argument_list|(
literal|"Removing the blocks without rolling the edit log"
argument_list|)
expr_stmt|;
name|fs
operator|.
name|delete
argument_list|(
operator|new
name|Path
argument_list|(
literal|"/test"
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|BlockManagerTestUtil
operator|.
name|computeAllPendingWork
argument_list|(
name|nn0
operator|.
name|getNamesystem
argument_list|()
operator|.
name|getBlockManager
argument_list|()
argument_list|)
expr_stmt|;
name|banner
argument_list|(
literal|"Triggering deletions on DNs and Deletion Reports"
argument_list|)
expr_stmt|;
name|cluster
operator|.
name|triggerHeartbeats
argument_list|()
expr_stmt|;
name|HATestUtil
operator|.
name|waitForDNDeletions
argument_list|(
name|cluster
argument_list|)
expr_stmt|;
name|cluster
operator|.
name|triggerDeletionReports
argument_list|()
expr_stmt|;
name|assertSafeMode
argument_list|(
name|nn1
argument_list|,
literal|4
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|// When we roll the edit log, the deletions will go through.
name|banner
argument_list|(
literal|"Waiting for standby to catch up to active namespace"
argument_list|)
expr_stmt|;
name|HATestUtil
operator|.
name|waitForStandbyToCatchUp
argument_list|(
name|nn0
argument_list|,
name|nn1
argument_list|)
expr_stmt|;
name|assertSafeMode
argument_list|(
name|nn1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/**    * Regression test for a bug experienced while developing    * HDFS-2742. The scenario here is:    * - image contains some blocks    * - edits log contains at least one block addition, followed    *   by deletion of more blocks than were added.    * - When node starts up, some incorrect accounting of block    *   totals caused an assertion failure.    */
annotation|@
name|Test
DECL|method|testBlocksDeletedInEditLog ()
specifier|public
name|void
name|testBlocksDeletedInEditLog
parameter_list|()
throws|throws
name|Exception
block|{
name|banner
argument_list|(
literal|"Starting with NN0 active and NN1 standby, creating some blocks"
argument_list|)
expr_stmt|;
comment|// Make 4 blocks persisted in the image.
name|DFSTestUtil
operator|.
name|createFile
argument_list|(
name|fs
argument_list|,
operator|new
name|Path
argument_list|(
literal|"/test"
argument_list|)
argument_list|,
literal|4
operator|*
name|BLOCK_SIZE
argument_list|,
operator|(
name|short
operator|)
literal|3
argument_list|,
literal|1L
argument_list|)
expr_stmt|;
name|NameNodeAdapter
operator|.
name|enterSafeMode
argument_list|(
name|nn0
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|NameNodeAdapter
operator|.
name|saveNamespace
argument_list|(
name|nn0
argument_list|)
expr_stmt|;
name|NameNodeAdapter
operator|.
name|leaveSafeMode
argument_list|(
name|nn0
argument_list|,
literal|false
argument_list|)
expr_stmt|;
comment|// OP_ADD for 2 blocks
name|DFSTestUtil
operator|.
name|createFile
argument_list|(
name|fs
argument_list|,
operator|new
name|Path
argument_list|(
literal|"/test2"
argument_list|)
argument_list|,
literal|2
operator|*
name|BLOCK_SIZE
argument_list|,
operator|(
name|short
operator|)
literal|3
argument_list|,
literal|1L
argument_list|)
expr_stmt|;
comment|// OP_DELETE for 4 blocks
name|fs
operator|.
name|delete
argument_list|(
operator|new
name|Path
argument_list|(
literal|"/test"
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|restartActive
argument_list|()
expr_stmt|;
block|}
DECL|method|assertSafeMode (NameNode nn, int safe, int total)
specifier|private
name|void
name|assertSafeMode
parameter_list|(
name|NameNode
name|nn
parameter_list|,
name|int
name|safe
parameter_list|,
name|int
name|total
parameter_list|)
block|{
name|String
name|status
init|=
name|nn1
operator|.
name|getNamesystem
argument_list|()
operator|.
name|getSafemode
argument_list|()
decl_stmt|;
if|if
condition|(
name|safe
operator|==
name|total
condition|)
block|{
name|assertTrue
argument_list|(
literal|"Bad safemode status: '"
operator|+
name|status
operator|+
literal|"'"
argument_list|,
name|status
operator|.
name|startsWith
argument_list|(
literal|"Safe mode is ON."
operator|+
literal|"The reported blocks "
operator|+
name|safe
operator|+
literal|" has reached the threshold "
operator|+
literal|"0.9990 of total blocks "
operator|+
name|total
operator|+
literal|". Safe mode will be "
operator|+
literal|"turned off automatically"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|additional
init|=
name|total
operator|-
name|safe
decl_stmt|;
name|assertTrue
argument_list|(
literal|"Bad safemode status: '"
operator|+
name|status
operator|+
literal|"'"
argument_list|,
name|status
operator|.
name|startsWith
argument_list|(
literal|"Safe mode is ON."
operator|+
literal|"The reported blocks "
operator|+
name|safe
operator|+
literal|" needs additional "
operator|+
name|additional
operator|+
literal|" blocks"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Set up a namesystem with several edits, both deletions and    * additions, and failover to a new NN while that NN is in    * safemode. Ensure that it will exit safemode.    */
annotation|@
name|Test
DECL|method|testComplexFailoverIntoSafemode ()
specifier|public
name|void
name|testComplexFailoverIntoSafemode
parameter_list|()
throws|throws
name|Exception
block|{
name|banner
argument_list|(
literal|"Starting with NN0 active and NN1 standby, creating some blocks"
argument_list|)
expr_stmt|;
name|DFSTestUtil
operator|.
name|createFile
argument_list|(
name|fs
argument_list|,
operator|new
name|Path
argument_list|(
literal|"/test"
argument_list|)
argument_list|,
literal|3
operator|*
name|BLOCK_SIZE
argument_list|,
operator|(
name|short
operator|)
literal|3
argument_list|,
literal|1L
argument_list|)
expr_stmt|;
comment|// Roll edit log so that, when the SBN restarts, it will load
comment|// the namespace during startup and enter safemode.
name|nn0
operator|.
name|getRpcServer
argument_list|()
operator|.
name|rollEditLog
argument_list|()
expr_stmt|;
name|banner
argument_list|(
literal|"Creating some blocks that won't be in the edit log"
argument_list|)
expr_stmt|;
name|DFSTestUtil
operator|.
name|createFile
argument_list|(
name|fs
argument_list|,
operator|new
name|Path
argument_list|(
literal|"/test2"
argument_list|)
argument_list|,
literal|5
operator|*
name|BLOCK_SIZE
argument_list|,
operator|(
name|short
operator|)
literal|3
argument_list|,
literal|1L
argument_list|)
expr_stmt|;
name|banner
argument_list|(
literal|"Deleting the original blocks"
argument_list|)
expr_stmt|;
name|fs
operator|.
name|delete
argument_list|(
operator|new
name|Path
argument_list|(
literal|"/test"
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|banner
argument_list|(
literal|"Restarting standby"
argument_list|)
expr_stmt|;
name|restartStandby
argument_list|()
expr_stmt|;
comment|// We expect it to be on its way out of safemode, since all of the blocks
comment|// from the edit log have been reported.
name|assertSafeMode
argument_list|(
name|nn1
argument_list|,
literal|3
argument_list|,
literal|3
argument_list|)
expr_stmt|;
comment|// Initiate a failover into it while it's in safemode
name|banner
argument_list|(
literal|"Initiating a failover into NN1 in safemode"
argument_list|)
expr_stmt|;
name|NameNodeAdapter
operator|.
name|abortEditLogs
argument_list|(
name|nn0
argument_list|)
expr_stmt|;
name|cluster
operator|.
name|transitionToActive
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|assertSafeMode
argument_list|(
name|nn1
argument_list|,
literal|5
argument_list|,
literal|5
argument_list|)
expr_stmt|;
block|}
comment|/**    * Similar to {@link #testBlocksRemovedWhileInSafeMode()} except that    * the OP_DELETE edits arrive at the SBN before the block deletion reports.    * The tracking of safe blocks needs to properly account for the removal    * of the blocks as well as the safe count. This is a regression test for    * HDFS-2742.    */
annotation|@
name|Test
DECL|method|testBlocksRemovedWhileInSafeModeEditsArriveFirst ()
specifier|public
name|void
name|testBlocksRemovedWhileInSafeModeEditsArriveFirst
parameter_list|()
throws|throws
name|Exception
block|{
name|banner
argument_list|(
literal|"Starting with NN0 active and NN1 standby, creating some blocks"
argument_list|)
expr_stmt|;
name|DFSTestUtil
operator|.
name|createFile
argument_list|(
name|fs
argument_list|,
operator|new
name|Path
argument_list|(
literal|"/test"
argument_list|)
argument_list|,
literal|10
operator|*
name|BLOCK_SIZE
argument_list|,
operator|(
name|short
operator|)
literal|3
argument_list|,
literal|1L
argument_list|)
expr_stmt|;
comment|// Roll edit log so that, when the SBN restarts, it will load
comment|// the namespace during startup.
name|nn0
operator|.
name|getRpcServer
argument_list|()
operator|.
name|rollEditLog
argument_list|()
expr_stmt|;
name|banner
argument_list|(
literal|"Restarting standby"
argument_list|)
expr_stmt|;
name|restartStandby
argument_list|()
expr_stmt|;
comment|// It will initially have all of the blocks necessary.
name|String
name|status
init|=
name|nn1
operator|.
name|getNamesystem
argument_list|()
operator|.
name|getSafemode
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
literal|"Bad safemode status: '"
operator|+
name|status
operator|+
literal|"'"
argument_list|,
name|status
operator|.
name|startsWith
argument_list|(
literal|"Safe mode is ON."
operator|+
literal|"The reported blocks 10 has reached the threshold 0.9990 of "
operator|+
literal|"total blocks 10. Safe mode will be turned off automatically"
argument_list|)
argument_list|)
expr_stmt|;
comment|// Delete those blocks while the SBN is in safe mode.
comment|// Immediately roll the edit log before the actual deletions are sent
comment|// to the DNs.
name|banner
argument_list|(
literal|"Removing the blocks without rolling the edit log"
argument_list|)
expr_stmt|;
name|fs
operator|.
name|delete
argument_list|(
operator|new
name|Path
argument_list|(
literal|"/test"
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|HATestUtil
operator|.
name|waitForStandbyToCatchUp
argument_list|(
name|nn0
argument_list|,
name|nn1
argument_list|)
expr_stmt|;
comment|// Should see removal of the blocks as well as their contribution to safe block count.
name|assertSafeMode
argument_list|(
name|nn1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|banner
argument_list|(
literal|"Triggering sending deletions to DNs and Deletion Reports"
argument_list|)
expr_stmt|;
name|BlockManagerTestUtil
operator|.
name|computeAllPendingWork
argument_list|(
name|nn0
operator|.
name|getNamesystem
argument_list|()
operator|.
name|getBlockManager
argument_list|()
argument_list|)
expr_stmt|;
name|cluster
operator|.
name|triggerHeartbeats
argument_list|()
expr_stmt|;
name|HATestUtil
operator|.
name|waitForDNDeletions
argument_list|(
name|cluster
argument_list|)
expr_stmt|;
name|cluster
operator|.
name|triggerDeletionReports
argument_list|()
expr_stmt|;
comment|// No change in assertion status here, but some of the consistency checks
comment|// in safemode will fire here if we accidentally decrement safe block count
comment|// below 0.
name|assertSafeMode
argument_list|(
name|nn1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/**    * Test that the number of safe blocks is accounted correctly even when    * blocks move between under-construction state and completed state.    * If a FINALIZED report arrives at the SBN before the block is marked    * COMPLETE, then when we get the OP_CLOSE we need to count it as "safe"    * at that point. This is a regression test for HDFS-2742.    */
annotation|@
name|Test
DECL|method|testSafeBlockTracking ()
specifier|public
name|void
name|testSafeBlockTracking
parameter_list|()
throws|throws
name|Exception
block|{
name|banner
argument_list|(
literal|"Starting with NN0 active and NN1 standby, creating some "
operator|+
literal|"UC blocks plus some other blocks to force safemode"
argument_list|)
expr_stmt|;
name|DFSTestUtil
operator|.
name|createFile
argument_list|(
name|fs
argument_list|,
operator|new
name|Path
argument_list|(
literal|"/other-blocks"
argument_list|)
argument_list|,
literal|10
operator|*
name|BLOCK_SIZE
argument_list|,
operator|(
name|short
operator|)
literal|3
argument_list|,
literal|1L
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|FSDataOutputStream
argument_list|>
name|stms
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
try|try
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
block|{
name|FSDataOutputStream
name|stm
init|=
name|fs
operator|.
name|create
argument_list|(
operator|new
name|Path
argument_list|(
literal|"/test-uc-"
operator|+
name|i
argument_list|)
argument_list|)
decl_stmt|;
name|stms
operator|.
name|add
argument_list|(
name|stm
argument_list|)
expr_stmt|;
name|stm
operator|.
name|write
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|stm
operator|.
name|hflush
argument_list|()
expr_stmt|;
block|}
comment|// Roll edit log so that, when the SBN restarts, it will load
comment|// the namespace during startup and enter safemode.
name|nn0
operator|.
name|getRpcServer
argument_list|()
operator|.
name|rollEditLog
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
for|for
control|(
name|FSDataOutputStream
name|stm
range|:
name|stms
control|)
block|{
name|IOUtils
operator|.
name|closeStream
argument_list|(
name|stm
argument_list|)
expr_stmt|;
block|}
block|}
name|banner
argument_list|(
literal|"Restarting SBN"
argument_list|)
expr_stmt|;
name|restartStandby
argument_list|()
expr_stmt|;
name|assertSafeMode
argument_list|(
name|nn1
argument_list|,
literal|10
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|banner
argument_list|(
literal|"Allowing SBN to catch up"
argument_list|)
expr_stmt|;
name|HATestUtil
operator|.
name|waitForStandbyToCatchUp
argument_list|(
name|nn0
argument_list|,
name|nn1
argument_list|)
expr_stmt|;
name|assertSafeMode
argument_list|(
name|nn1
argument_list|,
literal|15
argument_list|,
literal|15
argument_list|)
expr_stmt|;
block|}
comment|/**    * Regression test for HDFS-2753. In this bug, the following sequence was    * observed:    * - Some blocks are written to DNs while the SBN was down. This causes    *   the blockReceived messages to get queued in the BPServiceActor on the    *   DN.    * - When the SBN returns, the DN re-registers with the SBN, and then    *   flushes its blockReceived queue to the SBN before it sends its    *   first block report. This caused the first block report to be    *   incorrect ignored.    * - The SBN would become stuck in safemode.    */
annotation|@
name|Test
DECL|method|testBlocksAddedWhileStandbyIsDown ()
specifier|public
name|void
name|testBlocksAddedWhileStandbyIsDown
parameter_list|()
throws|throws
name|Exception
block|{
name|DFSTestUtil
operator|.
name|createFile
argument_list|(
name|fs
argument_list|,
operator|new
name|Path
argument_list|(
literal|"/test"
argument_list|)
argument_list|,
literal|3
operator|*
name|BLOCK_SIZE
argument_list|,
operator|(
name|short
operator|)
literal|3
argument_list|,
literal|1L
argument_list|)
expr_stmt|;
name|banner
argument_list|(
literal|"Stopping standby"
argument_list|)
expr_stmt|;
name|cluster
operator|.
name|shutdownNameNode
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|DFSTestUtil
operator|.
name|createFile
argument_list|(
name|fs
argument_list|,
operator|new
name|Path
argument_list|(
literal|"/test2"
argument_list|)
argument_list|,
literal|3
operator|*
name|BLOCK_SIZE
argument_list|,
operator|(
name|short
operator|)
literal|3
argument_list|,
literal|1L
argument_list|)
expr_stmt|;
name|banner
argument_list|(
literal|"Rolling edit log so standby gets all edits on restart"
argument_list|)
expr_stmt|;
name|nn0
operator|.
name|getRpcServer
argument_list|()
operator|.
name|rollEditLog
argument_list|()
expr_stmt|;
name|restartStandby
argument_list|()
expr_stmt|;
name|assertSafeMode
argument_list|(
name|nn1
argument_list|,
literal|6
argument_list|,
literal|6
argument_list|)
expr_stmt|;
block|}
comment|/**    * Regression test for HDFS-2804: standby should not populate replication    * queues when exiting safe mode.    */
annotation|@
name|Test
DECL|method|testNoPopulatingReplQueuesWhenExitingSafemode ()
specifier|public
name|void
name|testNoPopulatingReplQueuesWhenExitingSafemode
parameter_list|()
throws|throws
name|Exception
block|{
name|DFSTestUtil
operator|.
name|createFile
argument_list|(
name|fs
argument_list|,
operator|new
name|Path
argument_list|(
literal|"/test"
argument_list|)
argument_list|,
literal|15
operator|*
name|BLOCK_SIZE
argument_list|,
operator|(
name|short
operator|)
literal|3
argument_list|,
literal|1L
argument_list|)
expr_stmt|;
name|HATestUtil
operator|.
name|waitForStandbyToCatchUp
argument_list|(
name|nn0
argument_list|,
name|nn1
argument_list|)
expr_stmt|;
comment|// get some blocks in the SBN's image
name|nn1
operator|.
name|getRpcServer
argument_list|()
operator|.
name|setSafeMode
argument_list|(
name|SafeModeAction
operator|.
name|SAFEMODE_ENTER
argument_list|)
expr_stmt|;
name|NameNodeAdapter
operator|.
name|saveNamespace
argument_list|(
name|nn1
argument_list|)
expr_stmt|;
name|nn1
operator|.
name|getRpcServer
argument_list|()
operator|.
name|setSafeMode
argument_list|(
name|SafeModeAction
operator|.
name|SAFEMODE_LEAVE
argument_list|)
expr_stmt|;
comment|// and some blocks in the edit logs
name|DFSTestUtil
operator|.
name|createFile
argument_list|(
name|fs
argument_list|,
operator|new
name|Path
argument_list|(
literal|"/test2"
argument_list|)
argument_list|,
literal|15
operator|*
name|BLOCK_SIZE
argument_list|,
operator|(
name|short
operator|)
literal|3
argument_list|,
literal|1L
argument_list|)
expr_stmt|;
name|nn0
operator|.
name|getRpcServer
argument_list|()
operator|.
name|rollEditLog
argument_list|()
expr_stmt|;
name|cluster
operator|.
name|stopDataNode
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|cluster
operator|.
name|shutdownNameNode
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|//Configuration sbConf = cluster.getConfiguration(1);
comment|//sbConf.setInt(DFSConfigKeys.DFS_NAMENODE_SAFEMODE_EXTENSION_KEY, 1);
name|cluster
operator|.
name|restartNameNode
argument_list|(
literal|1
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|nn1
operator|=
name|cluster
operator|.
name|getNameNode
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|GenericTestUtils
operator|.
name|waitFor
argument_list|(
operator|new
name|Supplier
argument_list|<
name|Boolean
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Boolean
name|get
parameter_list|()
block|{
return|return
operator|!
name|nn1
operator|.
name|isInSafeMode
argument_list|()
return|;
block|}
block|}
argument_list|,
literal|100
argument_list|,
literal|10000
argument_list|)
expr_stmt|;
name|BlockManagerTestUtil
operator|.
name|updateState
argument_list|(
name|nn1
operator|.
name|getNamesystem
argument_list|()
operator|.
name|getBlockManager
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0L
argument_list|,
name|nn1
operator|.
name|getNamesystem
argument_list|()
operator|.
name|getUnderReplicatedBlocks
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0L
argument_list|,
name|nn1
operator|.
name|getNamesystem
argument_list|()
operator|.
name|getPendingReplicationBlocks
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Print a big banner in the test log to make debug easier.    */
DECL|method|banner (String string)
specifier|static
name|void
name|banner
parameter_list|(
name|String
name|string
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"\n\n\n\n================================================\n"
operator|+
name|string
operator|+
literal|"\n"
operator|+
literal|"==================================================\n\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_class

end_unit

