begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdfs.server.namenode.ha
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|ha
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_HA_NN_NOT_BECOME_ACTIVE_IN_SAFEMODE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertEquals
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertFalse
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertTrue
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|fail
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|InetSocketAddress
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URI
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ha
operator|.
name|ServiceFailedException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|test
operator|.
name|LambdaTestUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FSDataInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FSDataOutputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|permission
operator|.
name|FsPermission
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ha
operator|.
name|HAServiceProtocol
operator|.
name|RequestSource
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ha
operator|.
name|HAServiceProtocol
operator|.
name|StateChangeRequestInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSClient
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSClientAdapter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSOutputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSTestUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DistributedFileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|MiniDFSCluster
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|MiniDFSNNTopology
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|DatanodeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|ExtendedBlock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|HdfsConstants
operator|.
name|SafeModeAction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|blockmanagement
operator|.
name|BlockManagerTestUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|FSImage
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|FSNamesystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|NameNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|NameNodeAdapter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|RemoteException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|StandbyException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|protobuf
operator|.
name|RpcHeaderProtos
operator|.
name|RpcResponseHeaderProto
operator|.
name|RpcErrorCodeProto
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|test
operator|.
name|GenericTestUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|test
operator|.
name|Whitebox
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|event
operator|.
name|Level
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|After
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Before
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Test
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Supplier
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_comment
comment|/**  * Tests that exercise safemode in an HA cluster.  */
end_comment

begin_class
DECL|class|TestHASafeMode
specifier|public
class|class
name|TestHASafeMode
block|{
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|TestHASafeMode
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|BLOCK_SIZE
specifier|private
specifier|static
specifier|final
name|int
name|BLOCK_SIZE
init|=
literal|1024
decl_stmt|;
DECL|field|nn0
specifier|private
name|NameNode
name|nn0
decl_stmt|;
DECL|field|nn1
specifier|private
name|NameNode
name|nn1
decl_stmt|;
DECL|field|fs
specifier|private
name|FileSystem
name|fs
decl_stmt|;
DECL|field|cluster
specifier|private
name|MiniDFSCluster
name|cluster
decl_stmt|;
static|static
block|{
name|DFSTestUtil
operator|.
name|setNameNodeLogLevel
argument_list|(
name|org
operator|.
name|apache
operator|.
name|log4j
operator|.
name|Level
operator|.
name|TRACE
argument_list|)
expr_stmt|;
name|GenericTestUtils
operator|.
name|setLogLevel
argument_list|(
name|FSImage
operator|.
name|LOG
argument_list|,
name|Level
operator|.
name|TRACE
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Before
DECL|method|setupCluster ()
specifier|public
name|void
name|setupCluster
parameter_list|()
throws|throws
name|Exception
block|{
name|Configuration
name|conf
init|=
operator|new
name|Configuration
argument_list|()
decl_stmt|;
name|conf
operator|.
name|setInt
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_BLOCK_SIZE_KEY
argument_list|,
name|BLOCK_SIZE
argument_list|)
expr_stmt|;
name|conf
operator|.
name|setInt
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_HEARTBEAT_INTERVAL_KEY
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|conf
operator|.
name|setInt
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_HA_TAILEDITS_PERIOD_KEY
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cluster
operator|=
operator|new
name|MiniDFSCluster
operator|.
name|Builder
argument_list|(
name|conf
argument_list|)
operator|.
name|nnTopology
argument_list|(
name|MiniDFSNNTopology
operator|.
name|simpleHATopology
argument_list|()
argument_list|)
operator|.
name|numDataNodes
argument_list|(
literal|3
argument_list|)
operator|.
name|waitSafeMode
argument_list|(
literal|false
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
name|cluster
operator|.
name|waitActive
argument_list|()
expr_stmt|;
name|nn0
operator|=
name|cluster
operator|.
name|getNameNode
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|nn1
operator|=
name|cluster
operator|.
name|getNameNode
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|fs
operator|=
name|HATestUtil
operator|.
name|configureFailoverFs
argument_list|(
name|cluster
argument_list|,
name|conf
argument_list|)
expr_stmt|;
name|cluster
operator|.
name|transitionToActive
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
annotation|@
name|After
DECL|method|shutdownCluster ()
specifier|public
name|void
name|shutdownCluster
parameter_list|()
block|{
if|if
condition|(
name|cluster
operator|!=
literal|null
condition|)
block|{
name|cluster
operator|.
name|shutdown
argument_list|()
expr_stmt|;
name|cluster
operator|=
literal|null
expr_stmt|;
block|}
block|}
comment|/**    * Make sure the client retries when the active NN is in safemode    */
annotation|@
name|Test
argument_list|(
name|timeout
operator|=
literal|300000
argument_list|)
DECL|method|testClientRetrySafeMode ()
specifier|public
name|void
name|testClientRetrySafeMode
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|Map
argument_list|<
name|Path
argument_list|,
name|Boolean
argument_list|>
name|results
init|=
name|Collections
operator|.
name|synchronizedMap
argument_list|(
operator|new
name|HashMap
argument_list|<
name|Path
argument_list|,
name|Boolean
argument_list|>
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|Path
name|test
init|=
operator|new
name|Path
argument_list|(
literal|"/test"
argument_list|)
decl_stmt|;
comment|// let nn0 enter safemode
name|cluster
operator|.
name|getConfiguration
argument_list|(
literal|0
argument_list|)
operator|.
name|setInt
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_SAFEMODE_MIN_DATANODES_KEY
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|NameNodeAdapter
operator|.
name|enterSafeMode
argument_list|(
name|nn0
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|Whitebox
operator|.
name|setInternalState
argument_list|(
name|nn0
operator|.
name|getNamesystem
argument_list|()
argument_list|,
literal|"manualSafeMode"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|BlockManagerTestUtil
operator|.
name|setStartupSafeModeForTest
argument_list|(
name|nn0
operator|.
name|getNamesystem
argument_list|()
operator|.
name|getBlockManager
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|nn0
operator|.
name|getNamesystem
argument_list|()
operator|.
name|isInStartupSafeMode
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"enter safemode"
argument_list|)
expr_stmt|;
operator|new
name|Thread
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
try|try
block|{
name|boolean
name|mkdir
init|=
name|fs
operator|.
name|mkdirs
argument_list|(
name|test
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"mkdir finished, result is "
operator|+
name|mkdir
argument_list|)
expr_stmt|;
synchronized|synchronized
init|(
name|TestHASafeMode
operator|.
name|this
init|)
block|{
name|results
operator|.
name|put
argument_list|(
name|test
argument_list|,
name|mkdir
argument_list|)
expr_stmt|;
name|TestHASafeMode
operator|.
name|this
operator|.
name|notifyAll
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Got Exception while calling mkdir"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
operator|.
name|start
argument_list|()
expr_stmt|;
comment|// make sure the client's call has actually been handled by the active NN
name|assertFalse
argument_list|(
literal|"The directory should not be created while NN in safemode"
argument_list|,
name|fs
operator|.
name|exists
argument_list|(
name|test
argument_list|)
argument_list|)
expr_stmt|;
name|Thread
operator|.
name|sleep
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
comment|// let nn0 leave safemode
name|NameNodeAdapter
operator|.
name|leaveSafeMode
argument_list|(
name|nn0
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"leave safemode"
argument_list|)
expr_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
while|while
condition|(
operator|!
name|results
operator|.
name|containsKey
argument_list|(
name|test
argument_list|)
condition|)
block|{
name|this
operator|.
name|wait
argument_list|()
expr_stmt|;
block|}
name|assertTrue
argument_list|(
name|results
operator|.
name|get
argument_list|(
name|test
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|restartStandby ()
specifier|private
name|void
name|restartStandby
parameter_list|()
throws|throws
name|IOException
block|{
name|cluster
operator|.
name|shutdownNameNode
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|// Set the safemode extension to be lengthy, so that the tests
comment|// can check the safemode message after the safemode conditions
comment|// have been achieved, without being racy.
name|cluster
operator|.
name|getConfiguration
argument_list|(
literal|1
argument_list|)
operator|.
name|setInt
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_SAFEMODE_EXTENSION_KEY
argument_list|,
literal|30000
argument_list|)
expr_stmt|;
name|cluster
operator|.
name|getConfiguration
argument_list|(
literal|1
argument_list|)
operator|.
name|setInt
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_HA_TAILEDITS_PERIOD_KEY
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cluster
operator|.
name|restartNameNode
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|nn1
operator|=
name|cluster
operator|.
name|getNameNode
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|nn1
operator|.
name|getNamesystem
argument_list|()
operator|.
name|getTransactionsSinceLastLogRoll
argument_list|()
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
block|}
comment|/**    * Test case for enter safemode in active namenode, when it is already in startup safemode.    * It is a regression test for HDFS-2747.    */
annotation|@
name|Test
DECL|method|testEnterSafeModeInANNShouldNotThrowNPE ()
specifier|public
name|void
name|testEnterSafeModeInANNShouldNotThrowNPE
parameter_list|()
throws|throws
name|Exception
block|{
name|banner
argument_list|(
literal|"Restarting active"
argument_list|)
expr_stmt|;
name|DFSTestUtil
operator|.
name|createFile
argument_list|(
name|fs
argument_list|,
operator|new
name|Path
argument_list|(
literal|"/test"
argument_list|)
argument_list|,
literal|3
operator|*
name|BLOCK_SIZE
argument_list|,
operator|(
name|short
operator|)
literal|3
argument_list|,
literal|1L
argument_list|)
expr_stmt|;
name|restartActive
argument_list|()
expr_stmt|;
name|nn0
operator|.
name|getRpcServer
argument_list|()
operator|.
name|transitionToActive
argument_list|(
operator|new
name|StateChangeRequestInfo
argument_list|(
name|RequestSource
operator|.
name|REQUEST_BY_USER
argument_list|)
argument_list|)
expr_stmt|;
name|FSNamesystem
name|namesystem
init|=
name|nn0
operator|.
name|getNamesystem
argument_list|()
decl_stmt|;
name|String
name|status
init|=
name|namesystem
operator|.
name|getSafemode
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
literal|"Bad safemode status: '"
operator|+
name|status
operator|+
literal|"'"
argument_list|,
name|status
operator|.
name|startsWith
argument_list|(
literal|"Safe mode is ON."
argument_list|)
argument_list|)
expr_stmt|;
name|NameNodeAdapter
operator|.
name|enterSafeMode
argument_list|(
name|nn0
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"Failed to enter into safemode in active"
argument_list|,
name|namesystem
operator|.
name|isInSafeMode
argument_list|()
argument_list|)
expr_stmt|;
name|NameNodeAdapter
operator|.
name|enterSafeMode
argument_list|(
name|nn0
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"Failed to enter into safemode in active"
argument_list|,
name|namesystem
operator|.
name|isInSafeMode
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Test case for enter safemode in standby namenode, when it is already in startup safemode.    * It is a regression test for HDFS-2747.    */
annotation|@
name|Test
DECL|method|testEnterSafeModeInSBNShouldNotThrowNPE ()
specifier|public
name|void
name|testEnterSafeModeInSBNShouldNotThrowNPE
parameter_list|()
throws|throws
name|Exception
block|{
name|banner
argument_list|(
literal|"Starting with NN0 active and NN1 standby, creating some blocks"
argument_list|)
expr_stmt|;
name|DFSTestUtil
operator|.
name|createFile
argument_list|(
name|fs
argument_list|,
operator|new
name|Path
argument_list|(
literal|"/test"
argument_list|)
argument_list|,
literal|3
operator|*
name|BLOCK_SIZE
argument_list|,
operator|(
name|short
operator|)
literal|3
argument_list|,
literal|1L
argument_list|)
expr_stmt|;
comment|// Roll edit log so that, when the SBN restarts, it will load
comment|// the namespace during startup and enter safemode.
name|nn0
operator|.
name|getRpcServer
argument_list|()
operator|.
name|rollEditLog
argument_list|()
expr_stmt|;
name|banner
argument_list|(
literal|"Creating some blocks that won't be in the edit log"
argument_list|)
expr_stmt|;
name|DFSTestUtil
operator|.
name|createFile
argument_list|(
name|fs
argument_list|,
operator|new
name|Path
argument_list|(
literal|"/test2"
argument_list|)
argument_list|,
literal|5
operator|*
name|BLOCK_SIZE
argument_list|,
operator|(
name|short
operator|)
literal|3
argument_list|,
literal|1L
argument_list|)
expr_stmt|;
name|banner
argument_list|(
literal|"Deleting the original blocks"
argument_list|)
expr_stmt|;
name|fs
operator|.
name|delete
argument_list|(
operator|new
name|Path
argument_list|(
literal|"/test"
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|banner
argument_list|(
literal|"Restarting standby"
argument_list|)
expr_stmt|;
name|restartStandby
argument_list|()
expr_stmt|;
name|FSNamesystem
name|namesystem
init|=
name|nn1
operator|.
name|getNamesystem
argument_list|()
decl_stmt|;
name|String
name|status
init|=
name|namesystem
operator|.
name|getSafemode
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
literal|"Bad safemode status: '"
operator|+
name|status
operator|+
literal|"'"
argument_list|,
name|status
operator|.
name|startsWith
argument_list|(
literal|"Safe mode is ON."
argument_list|)
argument_list|)
expr_stmt|;
name|NameNodeAdapter
operator|.
name|enterSafeMode
argument_list|(
name|nn1
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"Failed to enter into safemode in standby"
argument_list|,
name|namesystem
operator|.
name|isInSafeMode
argument_list|()
argument_list|)
expr_stmt|;
name|NameNodeAdapter
operator|.
name|enterSafeMode
argument_list|(
name|nn1
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"Failed to enter into safemode in standby"
argument_list|,
name|namesystem
operator|.
name|isInSafeMode
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|restartActive ()
specifier|private
name|void
name|restartActive
parameter_list|()
throws|throws
name|IOException
block|{
name|cluster
operator|.
name|shutdownNameNode
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|// Set the safemode extension to be lengthy, so that the tests
comment|// can check the safemode message after the safemode conditions
comment|// have been achieved, without being racy.
name|cluster
operator|.
name|getConfiguration
argument_list|(
literal|0
argument_list|)
operator|.
name|setInt
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_SAFEMODE_EXTENSION_KEY
argument_list|,
literal|30000
argument_list|)
expr_stmt|;
name|cluster
operator|.
name|restartNameNode
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|nn0
operator|=
name|cluster
operator|.
name|getNameNode
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/**    * Tests the case where, while a standby is down, more blocks are    * added to the namespace, but not rolled. So, when it starts up,    * it receives notification about the new blocks during    * the safemode extension period.    */
annotation|@
name|Test
DECL|method|testBlocksAddedBeforeStandbyRestart ()
specifier|public
name|void
name|testBlocksAddedBeforeStandbyRestart
parameter_list|()
throws|throws
name|Exception
block|{
name|banner
argument_list|(
literal|"Starting with NN0 active and NN1 standby, creating some blocks"
argument_list|)
expr_stmt|;
name|DFSTestUtil
operator|.
name|createFile
argument_list|(
name|fs
argument_list|,
operator|new
name|Path
argument_list|(
literal|"/test"
argument_list|)
argument_list|,
literal|3
operator|*
name|BLOCK_SIZE
argument_list|,
operator|(
name|short
operator|)
literal|3
argument_list|,
literal|1L
argument_list|)
expr_stmt|;
comment|// Roll edit log so that, when the SBN restarts, it will load
comment|// the namespace during startup.
name|nn0
operator|.
name|getRpcServer
argument_list|()
operator|.
name|rollEditLog
argument_list|()
expr_stmt|;
name|banner
argument_list|(
literal|"Creating some blocks that won't be in the edit log"
argument_list|)
expr_stmt|;
name|DFSTestUtil
operator|.
name|createFile
argument_list|(
name|fs
argument_list|,
operator|new
name|Path
argument_list|(
literal|"/test2"
argument_list|)
argument_list|,
literal|5
operator|*
name|BLOCK_SIZE
argument_list|,
operator|(
name|short
operator|)
literal|3
argument_list|,
literal|1L
argument_list|)
expr_stmt|;
name|banner
argument_list|(
literal|"Restarting standby"
argument_list|)
expr_stmt|;
name|restartStandby
argument_list|()
expr_stmt|;
comment|// We expect it not to be stuck in safemode, since those blocks
comment|// that are already visible to the SBN should be processed
comment|// in the initial block reports.
name|assertSafeMode
argument_list|(
name|nn1
argument_list|,
literal|3
argument_list|,
literal|3
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|banner
argument_list|(
literal|"Waiting for standby to catch up to active namespace"
argument_list|)
expr_stmt|;
name|HATestUtil
operator|.
name|waitForStandbyToCatchUp
argument_list|(
name|nn0
argument_list|,
name|nn1
argument_list|)
expr_stmt|;
name|assertSafeMode
argument_list|(
name|nn1
argument_list|,
literal|8
argument_list|,
literal|8
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/**    * Similar to {@link #testBlocksAddedBeforeStandbyRestart()} except that    * the new blocks are allocated after the SBN has restarted. So, the    * blocks were not present in the original block reports at startup    * but are reported separately by blockReceived calls.    */
annotation|@
name|Test
DECL|method|testBlocksAddedWhileInSafeMode ()
specifier|public
name|void
name|testBlocksAddedWhileInSafeMode
parameter_list|()
throws|throws
name|Exception
block|{
name|banner
argument_list|(
literal|"Starting with NN0 active and NN1 standby, creating some blocks"
argument_list|)
expr_stmt|;
name|DFSTestUtil
operator|.
name|createFile
argument_list|(
name|fs
argument_list|,
operator|new
name|Path
argument_list|(
literal|"/test"
argument_list|)
argument_list|,
literal|3
operator|*
name|BLOCK_SIZE
argument_list|,
operator|(
name|short
operator|)
literal|3
argument_list|,
literal|1L
argument_list|)
expr_stmt|;
comment|// Roll edit log so that, when the SBN restarts, it will load
comment|// the namespace during startup.
name|nn0
operator|.
name|getRpcServer
argument_list|()
operator|.
name|rollEditLog
argument_list|()
expr_stmt|;
name|banner
argument_list|(
literal|"Restarting standby"
argument_list|)
expr_stmt|;
name|restartStandby
argument_list|()
expr_stmt|;
name|assertSafeMode
argument_list|(
name|nn1
argument_list|,
literal|3
argument_list|,
literal|3
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|// Create a few blocks which will send blockReceived calls to the
comment|// SBN.
name|banner
argument_list|(
literal|"Creating some blocks while SBN is in safe mode"
argument_list|)
expr_stmt|;
name|DFSTestUtil
operator|.
name|createFile
argument_list|(
name|fs
argument_list|,
operator|new
name|Path
argument_list|(
literal|"/test2"
argument_list|)
argument_list|,
literal|5
operator|*
name|BLOCK_SIZE
argument_list|,
operator|(
name|short
operator|)
literal|3
argument_list|,
literal|1L
argument_list|)
expr_stmt|;
name|banner
argument_list|(
literal|"Waiting for standby to catch up to active namespace"
argument_list|)
expr_stmt|;
name|HATestUtil
operator|.
name|waitForStandbyToCatchUp
argument_list|(
name|nn0
argument_list|,
name|nn1
argument_list|)
expr_stmt|;
name|assertSafeMode
argument_list|(
name|nn1
argument_list|,
literal|8
argument_list|,
literal|8
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/**    * Test for the following case proposed by ATM:    * 1. Both NNs are up, one is active. There are 100 blocks. Both are    *    out of safemode.    * 2. 10 block deletions get processed by NN1. NN2 enqueues these DN messages    *     until it next reads from a checkpointed edits file.    * 3. NN2 gets restarted. Its queues are lost.    * 4. NN2 comes up, reads from all the finalized edits files. Concludes there    *    should still be 100 blocks.    * 5. NN2 receives a block report from all the DNs, which only accounts for    *    90 blocks. It doesn't leave safemode.    * 6. NN1 dies or is transitioned to standby.    * 7. NN2 is transitioned to active. It reads all the edits from NN1. It now    *    knows there should only be 90 blocks, but it's still in safemode.    * 8. NN2 doesn't ever recheck whether it should leave safemode.    *     * This is essentially the inverse of {@link #testBlocksAddedBeforeStandbyRestart()}    */
annotation|@
name|Test
DECL|method|testBlocksRemovedBeforeStandbyRestart ()
specifier|public
name|void
name|testBlocksRemovedBeforeStandbyRestart
parameter_list|()
throws|throws
name|Exception
block|{
name|banner
argument_list|(
literal|"Starting with NN0 active and NN1 standby, creating some blocks"
argument_list|)
expr_stmt|;
name|DFSTestUtil
operator|.
name|createFile
argument_list|(
name|fs
argument_list|,
operator|new
name|Path
argument_list|(
literal|"/test"
argument_list|)
argument_list|,
literal|5
operator|*
name|BLOCK_SIZE
argument_list|,
operator|(
name|short
operator|)
literal|3
argument_list|,
literal|1L
argument_list|)
expr_stmt|;
comment|// Roll edit log so that, when the SBN restarts, it will load
comment|// the namespace during startup.
name|nn0
operator|.
name|getRpcServer
argument_list|()
operator|.
name|rollEditLog
argument_list|()
expr_stmt|;
comment|// Delete those blocks again, so they won't get reported to the SBN
comment|// once it starts up
name|banner
argument_list|(
literal|"Removing the blocks without rolling the edit log"
argument_list|)
expr_stmt|;
name|fs
operator|.
name|delete
argument_list|(
operator|new
name|Path
argument_list|(
literal|"/test"
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|BlockManagerTestUtil
operator|.
name|computeAllPendingWork
argument_list|(
name|nn0
operator|.
name|getNamesystem
argument_list|()
operator|.
name|getBlockManager
argument_list|()
argument_list|)
expr_stmt|;
name|cluster
operator|.
name|triggerHeartbeats
argument_list|()
expr_stmt|;
name|banner
argument_list|(
literal|"Restarting standby"
argument_list|)
expr_stmt|;
name|restartStandby
argument_list|()
expr_stmt|;
name|assertSafeMode
argument_list|(
name|nn1
argument_list|,
literal|0
argument_list|,
literal|5
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|banner
argument_list|(
literal|"Waiting for standby to catch up to active namespace"
argument_list|)
expr_stmt|;
name|HATestUtil
operator|.
name|waitForStandbyToCatchUp
argument_list|(
name|nn0
argument_list|,
name|nn1
argument_list|)
expr_stmt|;
name|assertSafeMode
argument_list|(
name|nn1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/**    * Similar to {@link #testBlocksRemovedBeforeStandbyRestart()} except that    * the blocks are removed after the SBN has restarted. So, the    * blocks were present in the original block reports at startup    * but are deleted separately later by deletion reports.    */
annotation|@
name|Test
DECL|method|testBlocksRemovedWhileInSafeMode ()
specifier|public
name|void
name|testBlocksRemovedWhileInSafeMode
parameter_list|()
throws|throws
name|Exception
block|{
name|banner
argument_list|(
literal|"Starting with NN0 active and NN1 standby, creating some blocks"
argument_list|)
expr_stmt|;
name|DFSTestUtil
operator|.
name|createFile
argument_list|(
name|fs
argument_list|,
operator|new
name|Path
argument_list|(
literal|"/test"
argument_list|)
argument_list|,
literal|10
operator|*
name|BLOCK_SIZE
argument_list|,
operator|(
name|short
operator|)
literal|3
argument_list|,
literal|1L
argument_list|)
expr_stmt|;
comment|// Roll edit log so that, when the SBN restarts, it will load
comment|// the namespace during startup.
name|nn0
operator|.
name|getRpcServer
argument_list|()
operator|.
name|rollEditLog
argument_list|()
expr_stmt|;
name|banner
argument_list|(
literal|"Restarting standby"
argument_list|)
expr_stmt|;
name|restartStandby
argument_list|()
expr_stmt|;
comment|// It will initially have all of the blocks necessary.
name|assertSafeMode
argument_list|(
name|nn1
argument_list|,
literal|10
argument_list|,
literal|10
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|// Delete those blocks while the SBN is in safe mode.
comment|// This doesn't affect the SBN, since deletions are not
comment|// ACKed when due to block removals.
name|banner
argument_list|(
literal|"Removing the blocks without rolling the edit log"
argument_list|)
expr_stmt|;
name|fs
operator|.
name|delete
argument_list|(
operator|new
name|Path
argument_list|(
literal|"/test"
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|BlockManagerTestUtil
operator|.
name|computeAllPendingWork
argument_list|(
name|nn0
operator|.
name|getNamesystem
argument_list|()
operator|.
name|getBlockManager
argument_list|()
argument_list|)
expr_stmt|;
name|banner
argument_list|(
literal|"Triggering deletions on DNs and Deletion Reports"
argument_list|)
expr_stmt|;
name|cluster
operator|.
name|triggerHeartbeats
argument_list|()
expr_stmt|;
name|HATestUtil
operator|.
name|waitForDNDeletions
argument_list|(
name|cluster
argument_list|)
expr_stmt|;
name|cluster
operator|.
name|triggerDeletionReports
argument_list|()
expr_stmt|;
name|assertSafeMode
argument_list|(
name|nn1
argument_list|,
literal|10
argument_list|,
literal|10
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|// When we catch up to active namespace, it will restore back
comment|// to 0 blocks.
name|banner
argument_list|(
literal|"Waiting for standby to catch up to active namespace"
argument_list|)
expr_stmt|;
name|HATestUtil
operator|.
name|waitForStandbyToCatchUp
argument_list|(
name|nn0
argument_list|,
name|nn1
argument_list|)
expr_stmt|;
name|assertSafeMode
argument_list|(
name|nn1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/**    * Tests that the standby node properly tracks the number of total    * and safe blocks while it is in safe mode. Since safe-mode only    * counts completed blocks, append needs to decrement the total    * number of blocks and then re-increment when the file is closed    * again.    */
annotation|@
name|Test
DECL|method|testAppendWhileInSafeMode ()
specifier|public
name|void
name|testAppendWhileInSafeMode
parameter_list|()
throws|throws
name|Exception
block|{
name|banner
argument_list|(
literal|"Starting with NN0 active and NN1 standby, creating some blocks"
argument_list|)
expr_stmt|;
comment|// Make 4.5 blocks so that append() will re-open an existing block
comment|// instead of just adding a new one
name|DFSTestUtil
operator|.
name|createFile
argument_list|(
name|fs
argument_list|,
operator|new
name|Path
argument_list|(
literal|"/test"
argument_list|)
argument_list|,
literal|4
operator|*
name|BLOCK_SIZE
operator|+
name|BLOCK_SIZE
operator|/
literal|2
argument_list|,
operator|(
name|short
operator|)
literal|3
argument_list|,
literal|1L
argument_list|)
expr_stmt|;
comment|// Roll edit log so that, when the SBN restarts, it will load
comment|// the namespace during startup.
name|nn0
operator|.
name|getRpcServer
argument_list|()
operator|.
name|rollEditLog
argument_list|()
expr_stmt|;
name|banner
argument_list|(
literal|"Restarting standby"
argument_list|)
expr_stmt|;
name|restartStandby
argument_list|()
expr_stmt|;
comment|// It will initially have all of the blocks necessary.
name|assertSafeMode
argument_list|(
name|nn1
argument_list|,
literal|5
argument_list|,
literal|5
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|// Append to a block while SBN is in safe mode. This should
comment|// not affect safemode initially, since the DN message
comment|// will get queued.
name|FSDataOutputStream
name|stm
init|=
name|fs
operator|.
name|append
argument_list|(
operator|new
name|Path
argument_list|(
literal|"/test"
argument_list|)
argument_list|)
decl_stmt|;
try|try
block|{
name|assertSafeMode
argument_list|(
name|nn1
argument_list|,
literal|5
argument_list|,
literal|5
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|// if we roll edits now, the SBN should see that it's under construction
comment|// and change its total count and safe count down by one, since UC
comment|// blocks are not counted by safe mode.
name|HATestUtil
operator|.
name|waitForStandbyToCatchUp
argument_list|(
name|nn0
argument_list|,
name|nn1
argument_list|)
expr_stmt|;
name|assertSafeMode
argument_list|(
name|nn1
argument_list|,
literal|4
argument_list|,
literal|4
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|IOUtils
operator|.
name|closeStream
argument_list|(
name|stm
argument_list|)
expr_stmt|;
block|}
comment|// Delete those blocks while the SBN is in safe mode.
comment|// This will not ACK the deletions to the SBN, so it won't
comment|// notice until we roll the edit log.
name|banner
argument_list|(
literal|"Removing the blocks without rolling the edit log"
argument_list|)
expr_stmt|;
name|fs
operator|.
name|delete
argument_list|(
operator|new
name|Path
argument_list|(
literal|"/test"
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|BlockManagerTestUtil
operator|.
name|computeAllPendingWork
argument_list|(
name|nn0
operator|.
name|getNamesystem
argument_list|()
operator|.
name|getBlockManager
argument_list|()
argument_list|)
expr_stmt|;
name|banner
argument_list|(
literal|"Triggering deletions on DNs and Deletion Reports"
argument_list|)
expr_stmt|;
name|cluster
operator|.
name|triggerHeartbeats
argument_list|()
expr_stmt|;
name|HATestUtil
operator|.
name|waitForDNDeletions
argument_list|(
name|cluster
argument_list|)
expr_stmt|;
name|cluster
operator|.
name|triggerDeletionReports
argument_list|()
expr_stmt|;
name|assertSafeMode
argument_list|(
name|nn1
argument_list|,
literal|4
argument_list|,
literal|4
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|// When we roll the edit log, the deletions will go through.
name|banner
argument_list|(
literal|"Waiting for standby to catch up to active namespace"
argument_list|)
expr_stmt|;
name|HATestUtil
operator|.
name|waitForStandbyToCatchUp
argument_list|(
name|nn0
argument_list|,
name|nn1
argument_list|)
expr_stmt|;
name|assertSafeMode
argument_list|(
name|nn1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/**    * Regression test for a bug experienced while developing    * HDFS-2742. The scenario here is:    * - image contains some blocks    * - edits log contains at least one block addition, followed    *   by deletion of more blocks than were added.    * - When node starts up, some incorrect accounting of block    *   totals caused an assertion failure.    */
annotation|@
name|Test
DECL|method|testBlocksDeletedInEditLog ()
specifier|public
name|void
name|testBlocksDeletedInEditLog
parameter_list|()
throws|throws
name|Exception
block|{
name|banner
argument_list|(
literal|"Starting with NN0 active and NN1 standby, creating some blocks"
argument_list|)
expr_stmt|;
comment|// Make 4 blocks persisted in the image.
name|DFSTestUtil
operator|.
name|createFile
argument_list|(
name|fs
argument_list|,
operator|new
name|Path
argument_list|(
literal|"/test"
argument_list|)
argument_list|,
literal|4
operator|*
name|BLOCK_SIZE
argument_list|,
operator|(
name|short
operator|)
literal|3
argument_list|,
literal|1L
argument_list|)
expr_stmt|;
name|NameNodeAdapter
operator|.
name|enterSafeMode
argument_list|(
name|nn0
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|NameNodeAdapter
operator|.
name|saveNamespace
argument_list|(
name|nn0
argument_list|)
expr_stmt|;
name|NameNodeAdapter
operator|.
name|leaveSafeMode
argument_list|(
name|nn0
argument_list|)
expr_stmt|;
comment|// OP_ADD for 2 blocks
name|DFSTestUtil
operator|.
name|createFile
argument_list|(
name|fs
argument_list|,
operator|new
name|Path
argument_list|(
literal|"/test2"
argument_list|)
argument_list|,
literal|2
operator|*
name|BLOCK_SIZE
argument_list|,
operator|(
name|short
operator|)
literal|3
argument_list|,
literal|1L
argument_list|)
expr_stmt|;
comment|// OP_DELETE for 4 blocks
name|fs
operator|.
name|delete
argument_list|(
operator|new
name|Path
argument_list|(
literal|"/test"
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|restartActive
argument_list|()
expr_stmt|;
block|}
DECL|method|assertSafeMode (NameNode nn, int safe, int total, int numNodes, int nodeThresh)
specifier|private
specifier|static
name|void
name|assertSafeMode
parameter_list|(
name|NameNode
name|nn
parameter_list|,
name|int
name|safe
parameter_list|,
name|int
name|total
parameter_list|,
name|int
name|numNodes
parameter_list|,
name|int
name|nodeThresh
parameter_list|)
block|{
name|String
name|status
init|=
name|nn
operator|.
name|getNamesystem
argument_list|()
operator|.
name|getSafemode
argument_list|()
decl_stmt|;
if|if
condition|(
name|total
operator|==
literal|0
operator|&&
name|nodeThresh
operator|==
literal|0
condition|)
block|{
name|assertTrue
argument_list|(
literal|"Bad safemode status: '"
operator|+
name|status
operator|+
literal|"'"
argument_list|,
name|status
operator|.
name|isEmpty
argument_list|()
operator|||
name|status
operator|.
name|startsWith
argument_list|(
literal|"Safe mode is ON. The reported blocks 0 "
operator|+
literal|"has reached the threshold 0.9990 of total blocks 0. The "
operator|+
literal|"minimum number of live datanodes is not required. In safe "
operator|+
literal|"mode extension. Safe mode will be turned off automatically "
operator|+
literal|"in 0 seconds."
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|safe
operator|==
name|total
condition|)
block|{
if|if
condition|(
name|nodeThresh
operator|==
literal|0
condition|)
block|{
name|assertTrue
argument_list|(
literal|"Bad safemode status: '"
operator|+
name|status
operator|+
literal|"'"
argument_list|,
name|status
operator|.
name|startsWith
argument_list|(
literal|"Safe mode is ON. The reported blocks "
operator|+
name|safe
operator|+
literal|" has reached the "
operator|+
literal|"threshold 0.9990 of total blocks "
operator|+
name|total
operator|+
literal|". The minimum number of live datanodes is not "
operator|+
literal|"required. In safe mode extension. Safe mode will be turned "
operator|+
literal|"off automatically"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|assertTrue
argument_list|(
literal|"Bad safemode status: '"
operator|+
name|status
operator|+
literal|"'"
argument_list|,
name|status
operator|.
name|startsWith
argument_list|(
literal|"Safe mode is ON. The reported blocks "
operator|+
name|safe
operator|+
literal|" has reached "
operator|+
literal|"the threshold 0.9990 of total blocks "
operator|+
name|total
operator|+
literal|". The "
operator|+
literal|"number of live datanodes "
operator|+
name|numNodes
operator|+
literal|" has reached "
operator|+
literal|"the minimum number "
operator|+
name|nodeThresh
operator|+
literal|". In safe mode "
operator|+
literal|"extension. Safe mode will be turned off automatically"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|int
name|additional
init|=
call|(
name|int
call|)
argument_list|(
name|total
operator|*
literal|0.9990
argument_list|)
operator|-
name|safe
decl_stmt|;
name|assertTrue
argument_list|(
literal|"Bad safemode status: '"
operator|+
name|status
operator|+
literal|"'"
argument_list|,
name|status
operator|.
name|startsWith
argument_list|(
literal|"Safe mode is ON. "
operator|+
literal|"The reported blocks "
operator|+
name|safe
operator|+
literal|" needs additional "
operator|+
name|additional
operator|+
literal|" blocks"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Set up a namesystem with several edits, both deletions and    * additions, and failover to a new NN while that NN is in    * safemode. Ensure that it will exit safemode.    */
annotation|@
name|Test
DECL|method|testComplexFailoverIntoSafemode ()
specifier|public
name|void
name|testComplexFailoverIntoSafemode
parameter_list|()
throws|throws
name|Exception
block|{
name|banner
argument_list|(
literal|"Starting with NN0 active and NN1 standby, creating some blocks"
argument_list|)
expr_stmt|;
name|DFSTestUtil
operator|.
name|createFile
argument_list|(
name|fs
argument_list|,
operator|new
name|Path
argument_list|(
literal|"/test"
argument_list|)
argument_list|,
literal|3
operator|*
name|BLOCK_SIZE
argument_list|,
operator|(
name|short
operator|)
literal|3
argument_list|,
literal|1L
argument_list|)
expr_stmt|;
comment|// Roll edit log so that, when the SBN restarts, it will load
comment|// the namespace during startup and enter safemode.
name|nn0
operator|.
name|getRpcServer
argument_list|()
operator|.
name|rollEditLog
argument_list|()
expr_stmt|;
name|banner
argument_list|(
literal|"Creating some blocks that won't be in the edit log"
argument_list|)
expr_stmt|;
name|DFSTestUtil
operator|.
name|createFile
argument_list|(
name|fs
argument_list|,
operator|new
name|Path
argument_list|(
literal|"/test2"
argument_list|)
argument_list|,
literal|5
operator|*
name|BLOCK_SIZE
argument_list|,
operator|(
name|short
operator|)
literal|3
argument_list|,
literal|1L
argument_list|)
expr_stmt|;
name|banner
argument_list|(
literal|"Deleting the original blocks"
argument_list|)
expr_stmt|;
name|fs
operator|.
name|delete
argument_list|(
operator|new
name|Path
argument_list|(
literal|"/test"
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|banner
argument_list|(
literal|"Restarting standby"
argument_list|)
expr_stmt|;
name|restartStandby
argument_list|()
expr_stmt|;
comment|// We expect it to be on its way out of safemode, since all of the blocks
comment|// from the edit log have been reported.
name|assertSafeMode
argument_list|(
name|nn1
argument_list|,
literal|3
argument_list|,
literal|3
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|// Initiate a failover into it while it's in safemode
name|banner
argument_list|(
literal|"Initiating a failover into NN1 in safemode"
argument_list|)
expr_stmt|;
name|NameNodeAdapter
operator|.
name|abortEditLogs
argument_list|(
name|nn0
argument_list|)
expr_stmt|;
name|cluster
operator|.
name|transitionToActive
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|assertSafeMode
argument_list|(
name|nn1
argument_list|,
literal|5
argument_list|,
literal|5
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/**    * Similar to {@link #testBlocksRemovedWhileInSafeMode()} except that    * the OP_DELETE edits arrive at the SBN before the block deletion reports.    * The tracking of safe blocks needs to properly account for the removal    * of the blocks as well as the safe count. This is a regression test for    * HDFS-2742.    */
annotation|@
name|Test
DECL|method|testBlocksRemovedWhileInSafeModeEditsArriveFirst ()
specifier|public
name|void
name|testBlocksRemovedWhileInSafeModeEditsArriveFirst
parameter_list|()
throws|throws
name|Exception
block|{
name|banner
argument_list|(
literal|"Starting with NN0 active and NN1 standby, creating some blocks"
argument_list|)
expr_stmt|;
name|DFSTestUtil
operator|.
name|createFile
argument_list|(
name|fs
argument_list|,
operator|new
name|Path
argument_list|(
literal|"/test"
argument_list|)
argument_list|,
literal|10
operator|*
name|BLOCK_SIZE
argument_list|,
operator|(
name|short
operator|)
literal|3
argument_list|,
literal|1L
argument_list|)
expr_stmt|;
comment|// Roll edit log so that, when the SBN restarts, it will load
comment|// the namespace during startup.
name|nn0
operator|.
name|getRpcServer
argument_list|()
operator|.
name|rollEditLog
argument_list|()
expr_stmt|;
name|banner
argument_list|(
literal|"Restarting standby"
argument_list|)
expr_stmt|;
name|restartStandby
argument_list|()
expr_stmt|;
comment|// It will initially have all of the blocks necessary.
name|String
name|status
init|=
name|nn1
operator|.
name|getNamesystem
argument_list|()
operator|.
name|getSafemode
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
literal|"Bad safemode status: '"
operator|+
name|status
operator|+
literal|"'"
argument_list|,
name|status
operator|.
name|startsWith
argument_list|(
literal|"Safe mode is ON. The reported blocks 10 has reached the threshold "
operator|+
literal|"0.9990 of total blocks 10. The minimum number of live datanodes is "
operator|+
literal|"not required. In safe mode extension. Safe mode will be turned off "
operator|+
literal|"automatically"
argument_list|)
argument_list|)
expr_stmt|;
comment|// Delete those blocks while the SBN is in safe mode.
comment|// Immediately roll the edit log before the actual deletions are sent
comment|// to the DNs.
name|banner
argument_list|(
literal|"Removing the blocks without rolling the edit log"
argument_list|)
expr_stmt|;
name|fs
operator|.
name|delete
argument_list|(
operator|new
name|Path
argument_list|(
literal|"/test"
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|HATestUtil
operator|.
name|waitForStandbyToCatchUp
argument_list|(
name|nn0
argument_list|,
name|nn1
argument_list|)
expr_stmt|;
comment|// Should see removal of the blocks as well as their contribution to safe block count.
name|assertSafeMode
argument_list|(
name|nn1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|banner
argument_list|(
literal|"Triggering sending deletions to DNs and Deletion Reports"
argument_list|)
expr_stmt|;
name|BlockManagerTestUtil
operator|.
name|computeAllPendingWork
argument_list|(
name|nn0
operator|.
name|getNamesystem
argument_list|()
operator|.
name|getBlockManager
argument_list|()
argument_list|)
expr_stmt|;
name|cluster
operator|.
name|triggerHeartbeats
argument_list|()
expr_stmt|;
name|HATestUtil
operator|.
name|waitForDNDeletions
argument_list|(
name|cluster
argument_list|)
expr_stmt|;
name|cluster
operator|.
name|triggerDeletionReports
argument_list|()
expr_stmt|;
comment|// No change in assertion status here, but some of the consistency checks
comment|// in safemode will fire here if we accidentally decrement safe block count
comment|// below 0.
name|assertSafeMode
argument_list|(
name|nn1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testSafeBlockTracking ()
specifier|public
name|void
name|testSafeBlockTracking
parameter_list|()
throws|throws
name|Exception
block|{
name|testSafeBlockTracking
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testSafeBlockTracking2 ()
specifier|public
name|void
name|testSafeBlockTracking2
parameter_list|()
throws|throws
name|Exception
block|{
name|testSafeBlockTracking
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**    * Test that the number of safe blocks is accounted correctly even when    * blocks move between under-construction state and completed state.    * If a FINALIZED report arrives at the SBN before the block is marked    * COMPLETE, then when we get the OP_CLOSE we need to count it as "safe"    * at that point. This is a regression test for HDFS-2742.    *     * @param noFirstBlockReport If this is set to true, we shutdown NN1 before    * closing the writing streams. In this way, when NN1 restarts, all DNs will    * first send it incremental block report before the first full block report.    * And NN1 will not treat the full block report as the first block report    * in BlockManager#processReport.     */
DECL|method|testSafeBlockTracking (boolean noFirstBlockReport)
specifier|private
name|void
name|testSafeBlockTracking
parameter_list|(
name|boolean
name|noFirstBlockReport
parameter_list|)
throws|throws
name|Exception
block|{
name|banner
argument_list|(
literal|"Starting with NN0 active and NN1 standby, creating some "
operator|+
literal|"UC blocks plus some other blocks to force safemode"
argument_list|)
expr_stmt|;
name|DFSTestUtil
operator|.
name|createFile
argument_list|(
name|fs
argument_list|,
operator|new
name|Path
argument_list|(
literal|"/other-blocks"
argument_list|)
argument_list|,
literal|10
operator|*
name|BLOCK_SIZE
argument_list|,
operator|(
name|short
operator|)
literal|3
argument_list|,
literal|1L
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|FSDataOutputStream
argument_list|>
name|stms
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
try|try
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
block|{
name|FSDataOutputStream
name|stm
init|=
name|fs
operator|.
name|create
argument_list|(
operator|new
name|Path
argument_list|(
literal|"/test-uc-"
operator|+
name|i
argument_list|)
argument_list|)
decl_stmt|;
name|stms
operator|.
name|add
argument_list|(
name|stm
argument_list|)
expr_stmt|;
name|stm
operator|.
name|write
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|stm
operator|.
name|hflush
argument_list|()
expr_stmt|;
block|}
comment|// Roll edit log so that, when the SBN restarts, it will load
comment|// the namespace during startup and enter safemode.
name|nn0
operator|.
name|getRpcServer
argument_list|()
operator|.
name|rollEditLog
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|noFirstBlockReport
condition|)
block|{
name|cluster
operator|.
name|shutdownNameNode
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|FSDataOutputStream
name|stm
range|:
name|stms
control|)
block|{
name|IOUtils
operator|.
name|closeStream
argument_list|(
name|stm
argument_list|)
expr_stmt|;
block|}
block|}
name|banner
argument_list|(
literal|"Restarting SBN"
argument_list|)
expr_stmt|;
name|restartStandby
argument_list|()
expr_stmt|;
name|assertSafeMode
argument_list|(
name|nn1
argument_list|,
literal|10
argument_list|,
literal|10
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|banner
argument_list|(
literal|"Allowing SBN to catch up"
argument_list|)
expr_stmt|;
name|HATestUtil
operator|.
name|waitForStandbyToCatchUp
argument_list|(
name|nn0
argument_list|,
name|nn1
argument_list|)
expr_stmt|;
name|assertSafeMode
argument_list|(
name|nn1
argument_list|,
literal|15
argument_list|,
literal|15
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/**    * Regression test for HDFS-2753. In this bug, the following sequence was    * observed:    * - Some blocks are written to DNs while the SBN was down. This causes    *   the blockReceived messages to get queued in the BPServiceActor on the    *   DN.    * - When the SBN returns, the DN re-registers with the SBN, and then    *   flushes its blockReceived queue to the SBN before it sends its    *   first block report. This caused the first block report to be    *   incorrect ignored.    * - The SBN would become stuck in safemode.    */
annotation|@
name|Test
DECL|method|testBlocksAddedWhileStandbyIsDown ()
specifier|public
name|void
name|testBlocksAddedWhileStandbyIsDown
parameter_list|()
throws|throws
name|Exception
block|{
name|DFSTestUtil
operator|.
name|createFile
argument_list|(
name|fs
argument_list|,
operator|new
name|Path
argument_list|(
literal|"/test"
argument_list|)
argument_list|,
literal|3
operator|*
name|BLOCK_SIZE
argument_list|,
operator|(
name|short
operator|)
literal|3
argument_list|,
literal|1L
argument_list|)
expr_stmt|;
name|banner
argument_list|(
literal|"Stopping standby"
argument_list|)
expr_stmt|;
name|cluster
operator|.
name|shutdownNameNode
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|DFSTestUtil
operator|.
name|createFile
argument_list|(
name|fs
argument_list|,
operator|new
name|Path
argument_list|(
literal|"/test2"
argument_list|)
argument_list|,
literal|3
operator|*
name|BLOCK_SIZE
argument_list|,
operator|(
name|short
operator|)
literal|3
argument_list|,
literal|1L
argument_list|)
expr_stmt|;
name|banner
argument_list|(
literal|"Rolling edit log so standby gets all edits on restart"
argument_list|)
expr_stmt|;
name|nn0
operator|.
name|getRpcServer
argument_list|()
operator|.
name|rollEditLog
argument_list|()
expr_stmt|;
name|restartStandby
argument_list|()
expr_stmt|;
name|assertSafeMode
argument_list|(
name|nn1
argument_list|,
literal|6
argument_list|,
literal|6
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/**    * Regression test for HDFS-2804: standby should not populate replication    * queues when exiting safe mode.    */
annotation|@
name|Test
DECL|method|testNoPopulatingReplQueuesWhenExitingSafemode ()
specifier|public
name|void
name|testNoPopulatingReplQueuesWhenExitingSafemode
parameter_list|()
throws|throws
name|Exception
block|{
name|DFSTestUtil
operator|.
name|createFile
argument_list|(
name|fs
argument_list|,
operator|new
name|Path
argument_list|(
literal|"/test"
argument_list|)
argument_list|,
literal|15
operator|*
name|BLOCK_SIZE
argument_list|,
operator|(
name|short
operator|)
literal|3
argument_list|,
literal|1L
argument_list|)
expr_stmt|;
name|HATestUtil
operator|.
name|waitForStandbyToCatchUp
argument_list|(
name|nn0
argument_list|,
name|nn1
argument_list|)
expr_stmt|;
comment|// get some blocks in the SBN's image
name|nn1
operator|.
name|getRpcServer
argument_list|()
operator|.
name|setSafeMode
argument_list|(
name|SafeModeAction
operator|.
name|SAFEMODE_ENTER
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|NameNodeAdapter
operator|.
name|saveNamespace
argument_list|(
name|nn1
argument_list|)
expr_stmt|;
name|nn1
operator|.
name|getRpcServer
argument_list|()
operator|.
name|setSafeMode
argument_list|(
name|SafeModeAction
operator|.
name|SAFEMODE_LEAVE
argument_list|,
literal|false
argument_list|)
expr_stmt|;
comment|// and some blocks in the edit logs
name|DFSTestUtil
operator|.
name|createFile
argument_list|(
name|fs
argument_list|,
operator|new
name|Path
argument_list|(
literal|"/test2"
argument_list|)
argument_list|,
literal|15
operator|*
name|BLOCK_SIZE
argument_list|,
operator|(
name|short
operator|)
literal|3
argument_list|,
literal|1L
argument_list|)
expr_stmt|;
name|nn0
operator|.
name|getRpcServer
argument_list|()
operator|.
name|rollEditLog
argument_list|()
expr_stmt|;
name|cluster
operator|.
name|stopDataNode
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|cluster
operator|.
name|shutdownNameNode
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|//Configuration sbConf = cluster.getConfiguration(1);
comment|//sbConf.setInt(DFSConfigKeys.DFS_NAMENODE_SAFEMODE_EXTENSION_KEY, 1);
name|cluster
operator|.
name|restartNameNode
argument_list|(
literal|1
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|nn1
operator|=
name|cluster
operator|.
name|getNameNode
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|GenericTestUtils
operator|.
name|waitFor
argument_list|(
operator|new
name|Supplier
argument_list|<
name|Boolean
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Boolean
name|get
parameter_list|()
block|{
return|return
operator|!
name|nn1
operator|.
name|isInSafeMode
argument_list|()
return|;
block|}
block|}
argument_list|,
literal|100
argument_list|,
literal|10000
argument_list|)
expr_stmt|;
name|BlockManagerTestUtil
operator|.
name|updateState
argument_list|(
name|nn1
operator|.
name|getNamesystem
argument_list|()
operator|.
name|getBlockManager
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0L
argument_list|,
name|nn1
operator|.
name|getNamesystem
argument_list|()
operator|.
name|getUnderReplicatedBlocks
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0L
argument_list|,
name|nn1
operator|.
name|getNamesystem
argument_list|()
operator|.
name|getPendingReplicationBlocks
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Make sure that when we transition to active in safe mode that we don't    * prematurely consider blocks missing just because not all DNs have reported    * yet.    *     * This is a regression test for HDFS-3921.    */
annotation|@
name|Test
DECL|method|testNoPopulatingReplQueuesWhenStartingActiveInSafeMode ()
specifier|public
name|void
name|testNoPopulatingReplQueuesWhenStartingActiveInSafeMode
parameter_list|()
throws|throws
name|IOException
block|{
name|DFSTestUtil
operator|.
name|createFile
argument_list|(
name|fs
argument_list|,
operator|new
name|Path
argument_list|(
literal|"/test"
argument_list|)
argument_list|,
literal|15
operator|*
name|BLOCK_SIZE
argument_list|,
operator|(
name|short
operator|)
literal|3
argument_list|,
literal|1L
argument_list|)
expr_stmt|;
comment|// Stop the DN so that when the NN restarts not all blocks wil be reported
comment|// and the NN won't leave safe mode.
name|cluster
operator|.
name|stopDataNode
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|// Restart the namenode but don't wait for it to hear from all DNs (since
comment|// one DN is deliberately shut down.)
name|cluster
operator|.
name|restartNameNode
argument_list|(
literal|0
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|cluster
operator|.
name|transitionToActive
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|cluster
operator|.
name|getNameNode
argument_list|(
literal|0
argument_list|)
operator|.
name|isInSafeMode
argument_list|()
argument_list|)
expr_stmt|;
comment|// We shouldn't yet consider any blocks "missing" since we're in startup
comment|// safemode, i.e. not all DNs may have reported.
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|cluster
operator|.
name|getNamesystem
argument_list|(
literal|0
argument_list|)
operator|.
name|getMissingBlocksCount
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Print a big banner in the test log to make debug easier.    */
DECL|method|banner (String string)
specifier|static
name|void
name|banner
parameter_list|(
name|String
name|string
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"\n\n\n\n================================================\n"
operator|+
name|string
operator|+
literal|"\n"
operator|+
literal|"==================================================\n\n"
argument_list|)
expr_stmt|;
block|}
comment|/**    * DFS#isInSafeMode should check the ActiveNNs safemode in HA enabled cluster. HDFS-3507    *     * @throws Exception    */
annotation|@
name|Test
DECL|method|testIsInSafemode ()
specifier|public
name|void
name|testIsInSafemode
parameter_list|()
throws|throws
name|Exception
block|{
comment|// Check for the standby nn without client failover.
name|NameNode
name|nn2
init|=
name|cluster
operator|.
name|getNameNode
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
literal|"nn2 should be in standby state"
argument_list|,
name|nn2
operator|.
name|isStandbyState
argument_list|()
argument_list|)
expr_stmt|;
name|InetSocketAddress
name|nameNodeAddress
init|=
name|nn2
operator|.
name|getNameNodeAddress
argument_list|()
decl_stmt|;
name|Configuration
name|conf
init|=
operator|new
name|Configuration
argument_list|()
decl_stmt|;
name|DistributedFileSystem
name|dfs
init|=
operator|new
name|DistributedFileSystem
argument_list|()
decl_stmt|;
try|try
block|{
name|dfs
operator|.
name|initialize
argument_list|(
name|URI
operator|.
name|create
argument_list|(
literal|"hdfs://"
operator|+
name|nameNodeAddress
operator|.
name|getHostName
argument_list|()
operator|+
literal|":"
operator|+
name|nameNodeAddress
operator|.
name|getPort
argument_list|()
argument_list|)
argument_list|,
name|conf
argument_list|)
expr_stmt|;
name|dfs
operator|.
name|isInSafeMode
argument_list|()
expr_stmt|;
name|fail
argument_list|(
literal|"StandBy should throw exception for isInSafeMode"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
if|if
condition|(
name|e
operator|instanceof
name|RemoteException
condition|)
block|{
name|assertEquals
argument_list|(
literal|"RPC Error code should indicate app failure."
argument_list|,
name|RpcErrorCodeProto
operator|.
name|ERROR_APPLICATION
argument_list|,
operator|(
operator|(
name|RemoteException
operator|)
name|e
operator|)
operator|.
name|getErrorCode
argument_list|()
argument_list|)
expr_stmt|;
name|IOException
name|sbExcpetion
init|=
operator|(
operator|(
name|RemoteException
operator|)
name|e
operator|)
operator|.
name|unwrapRemoteException
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
literal|"StandBy nn should not support isInSafeMode"
argument_list|,
name|sbExcpetion
operator|instanceof
name|StandbyException
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
name|e
throw|;
block|}
block|}
finally|finally
block|{
if|if
condition|(
literal|null
operator|!=
name|dfs
condition|)
block|{
name|dfs
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|// Check with Client FailOver
name|cluster
operator|.
name|transitionToStandby
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|cluster
operator|.
name|transitionToActive
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|cluster
operator|.
name|getNameNodeRpc
argument_list|(
literal|1
argument_list|)
operator|.
name|setSafeMode
argument_list|(
name|SafeModeAction
operator|.
name|SAFEMODE_ENTER
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|DistributedFileSystem
name|dfsWithFailOver
init|=
operator|(
name|DistributedFileSystem
operator|)
name|fs
decl_stmt|;
name|assertTrue
argument_list|(
literal|"ANN should be in SafeMode"
argument_list|,
name|dfsWithFailOver
operator|.
name|isInSafeMode
argument_list|()
argument_list|)
expr_stmt|;
name|cluster
operator|.
name|getNameNodeRpc
argument_list|(
literal|1
argument_list|)
operator|.
name|setSafeMode
argument_list|(
name|SafeModeAction
operator|.
name|SAFEMODE_LEAVE
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
literal|"ANN should be out of SafeMode"
argument_list|,
name|dfsWithFailOver
operator|.
name|isInSafeMode
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/** Test NN crash and client crash/stuck immediately after block allocation */
annotation|@
name|Test
argument_list|(
name|timeout
operator|=
literal|100000
argument_list|)
DECL|method|testOpenFileWhenNNAndClientCrashAfterAddBlock ()
specifier|public
name|void
name|testOpenFileWhenNNAndClientCrashAfterAddBlock
parameter_list|()
throws|throws
name|Exception
block|{
name|cluster
operator|.
name|getConfiguration
argument_list|(
literal|0
argument_list|)
operator|.
name|set
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_SAFEMODE_THRESHOLD_PCT_KEY
argument_list|,
literal|"1.0f"
argument_list|)
expr_stmt|;
name|String
name|testData
init|=
literal|"testData"
decl_stmt|;
comment|// to make sure we write the full block before creating dummy block at NN.
name|cluster
operator|.
name|getConfiguration
argument_list|(
literal|0
argument_list|)
operator|.
name|setInt
argument_list|(
literal|"io.bytes.per.checksum"
argument_list|,
name|testData
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
name|cluster
operator|.
name|restartNameNode
argument_list|(
literal|0
argument_list|)
expr_stmt|;
try|try
block|{
name|cluster
operator|.
name|waitActive
argument_list|()
expr_stmt|;
name|cluster
operator|.
name|transitionToActive
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|cluster
operator|.
name|transitionToStandby
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|DistributedFileSystem
name|dfs
init|=
name|cluster
operator|.
name|getFileSystem
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|String
name|pathString
init|=
literal|"/tmp1.txt"
decl_stmt|;
name|Path
name|filePath
init|=
operator|new
name|Path
argument_list|(
name|pathString
argument_list|)
decl_stmt|;
name|FSDataOutputStream
name|create
init|=
name|dfs
operator|.
name|create
argument_list|(
name|filePath
argument_list|,
name|FsPermission
operator|.
name|getDefault
argument_list|()
argument_list|,
literal|true
argument_list|,
literal|1024
argument_list|,
operator|(
name|short
operator|)
literal|3
argument_list|,
name|testData
operator|.
name|length
argument_list|()
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|create
operator|.
name|write
argument_list|(
name|testData
operator|.
name|getBytes
argument_list|()
argument_list|)
expr_stmt|;
name|create
operator|.
name|hflush
argument_list|()
expr_stmt|;
name|long
name|fileId
init|=
operator|(
operator|(
name|DFSOutputStream
operator|)
name|create
operator|.
name|getWrappedStream
argument_list|()
operator|)
operator|.
name|getFileId
argument_list|()
decl_stmt|;
name|FileStatus
name|fileStatus
init|=
name|dfs
operator|.
name|getFileStatus
argument_list|(
name|filePath
argument_list|)
decl_stmt|;
name|DFSClient
name|client
init|=
name|DFSClientAdapter
operator|.
name|getClient
argument_list|(
name|dfs
argument_list|)
decl_stmt|;
comment|// add one dummy block at NN, but not write to DataNode
name|ExtendedBlock
name|previousBlock
init|=
name|DFSClientAdapter
operator|.
name|getPreviousBlock
argument_list|(
name|client
argument_list|,
name|fileId
argument_list|)
decl_stmt|;
name|DFSClientAdapter
operator|.
name|getNamenode
argument_list|(
name|client
argument_list|)
operator|.
name|addBlock
argument_list|(
name|pathString
argument_list|,
name|client
operator|.
name|getClientName
argument_list|()
argument_list|,
operator|new
name|ExtendedBlock
argument_list|(
name|previousBlock
argument_list|)
argument_list|,
operator|new
name|DatanodeInfo
index|[
literal|0
index|]
argument_list|,
name|DFSClientAdapter
operator|.
name|getFileId
argument_list|(
operator|(
name|DFSOutputStream
operator|)
name|create
operator|.
name|getWrappedStream
argument_list|()
argument_list|)
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|cluster
operator|.
name|restartNameNode
argument_list|(
literal|0
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|cluster
operator|.
name|restartDataNode
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|cluster
operator|.
name|transitionToActive
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|// let the block reports be processed.
name|Thread
operator|.
name|sleep
argument_list|(
literal|2000
argument_list|)
expr_stmt|;
name|FSDataInputStream
name|is
init|=
name|dfs
operator|.
name|open
argument_list|(
name|filePath
argument_list|)
decl_stmt|;
name|is
operator|.
name|close
argument_list|()
expr_stmt|;
name|dfs
operator|.
name|recoverLease
argument_list|(
name|filePath
argument_list|)
expr_stmt|;
comment|// initiate recovery
name|assertTrue
argument_list|(
literal|"Recovery also should be success"
argument_list|,
name|dfs
operator|.
name|recoverLease
argument_list|(
name|filePath
argument_list|)
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|cluster
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Test
argument_list|(
name|timeout
operator|=
literal|60000
argument_list|)
DECL|method|testSafeModeExitAfterTransition ()
specifier|public
name|void
name|testSafeModeExitAfterTransition
parameter_list|()
throws|throws
name|Exception
block|{
name|DFSTestUtil
operator|.
name|createFile
argument_list|(
name|fs
argument_list|,
operator|new
name|Path
argument_list|(
literal|"/test"
argument_list|)
argument_list|,
literal|5
operator|*
name|BLOCK_SIZE
argument_list|,
operator|(
name|short
operator|)
literal|3
argument_list|,
literal|1L
argument_list|)
expr_stmt|;
name|banner
argument_list|(
literal|"Stopping standby"
argument_list|)
expr_stmt|;
name|cluster
operator|.
name|shutdownNameNode
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|DFSTestUtil
operator|.
name|createFile
argument_list|(
name|fs
argument_list|,
operator|new
name|Path
argument_list|(
literal|"/test2"
argument_list|)
argument_list|,
literal|3
operator|*
name|BLOCK_SIZE
argument_list|,
operator|(
name|short
operator|)
literal|3
argument_list|,
literal|1L
argument_list|)
expr_stmt|;
comment|// Roll edit logs to be read by standby
name|nn0
operator|.
name|getRpcServer
argument_list|()
operator|.
name|rollEditLog
argument_list|()
expr_stmt|;
name|fs
operator|.
name|delete
argument_list|(
operator|new
name|Path
argument_list|(
literal|"/test"
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|// Wait till the blocks are deleted from all DNs
name|GenericTestUtils
operator|.
name|waitFor
argument_list|(
operator|new
name|Supplier
argument_list|<
name|Boolean
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Boolean
name|get
parameter_list|()
block|{
return|return
name|cluster
operator|.
name|getNamesystem
argument_list|(
literal|0
argument_list|)
operator|.
name|getBlockManager
argument_list|()
operator|.
name|getPendingDeletionBlocksCount
argument_list|()
operator|==
literal|0
return|;
block|}
block|}
argument_list|,
literal|1000
argument_list|,
literal|10000
argument_list|)
expr_stmt|;
name|restartStandby
argument_list|()
expr_stmt|;
comment|// Wait till all the datanodes are registered.
name|GenericTestUtils
operator|.
name|waitFor
argument_list|(
operator|new
name|Supplier
argument_list|<
name|Boolean
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Boolean
name|get
parameter_list|()
block|{
return|return
name|cluster
operator|.
name|getNamesystem
argument_list|(
literal|1
argument_list|)
operator|.
name|getNumLiveDataNodes
argument_list|()
operator|==
literal|3
return|;
block|}
block|}
argument_list|,
literal|1000
argument_list|,
literal|10000
argument_list|)
expr_stmt|;
name|cluster
operator|.
name|triggerBlockReports
argument_list|()
expr_stmt|;
name|NameNodeAdapter
operator|.
name|abortEditLogs
argument_list|(
name|nn0
argument_list|)
expr_stmt|;
name|cluster
operator|.
name|shutdownNameNode
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|banner
argument_list|(
name|nn1
operator|.
name|getNamesystem
argument_list|()
operator|.
name|getSafemode
argument_list|()
argument_list|)
expr_stmt|;
name|cluster
operator|.
name|transitionToActive
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|assertSafeMode
argument_list|(
name|nn1
argument_list|,
literal|3
argument_list|,
literal|3
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/**    * Test transition to active when namenode in safemode.    *    * @throws IOException    */
annotation|@
name|Test
DECL|method|testTransitionToActiveWhenSafeMode ()
specifier|public
name|void
name|testTransitionToActiveWhenSafeMode
parameter_list|()
throws|throws
name|Exception
block|{
name|Configuration
name|config
init|=
operator|new
name|Configuration
argument_list|()
decl_stmt|;
name|config
operator|.
name|setBoolean
argument_list|(
name|DFS_HA_NN_NOT_BECOME_ACTIVE_IN_SAFEMODE
argument_list|,
literal|true
argument_list|)
expr_stmt|;
try|try
init|(
name|MiniDFSCluster
name|miniCluster
init|=
operator|new
name|MiniDFSCluster
operator|.
name|Builder
argument_list|(
name|config
argument_list|,
operator|new
name|File
argument_list|(
name|GenericTestUtils
operator|.
name|getRandomizedTempPath
argument_list|()
argument_list|)
argument_list|)
operator|.
name|nnTopology
argument_list|(
name|MiniDFSNNTopology
operator|.
name|simpleHATopology
argument_list|()
argument_list|)
operator|.
name|numDataNodes
argument_list|(
literal|1
argument_list|)
operator|.
name|build
argument_list|()
init|)
block|{
name|miniCluster
operator|.
name|waitActive
argument_list|()
expr_stmt|;
name|miniCluster
operator|.
name|transitionToStandby
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|miniCluster
operator|.
name|transitionToStandby
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|NameNode
name|namenode0
init|=
name|miniCluster
operator|.
name|getNameNode
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|NameNode
name|namenode1
init|=
name|miniCluster
operator|.
name|getNameNode
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|NameNodeAdapter
operator|.
name|enterSafeMode
argument_list|(
name|namenode0
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|NameNodeAdapter
operator|.
name|enterSafeMode
argument_list|(
name|namenode1
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|LambdaTestUtils
operator|.
name|intercept
argument_list|(
name|ServiceFailedException
operator|.
name|class
argument_list|,
literal|"NameNode still not leave safemode"
argument_list|,
parameter_list|()
lambda|->
name|miniCluster
operator|.
name|transitionToActive
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

