begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdfs.server.blockmanagement
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|blockmanagement
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|StorageType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSTestUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|StripedFileTestUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|DatanodeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|DatanodeInfo
operator|.
name|AdminStates
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|ErasureCodingPolicy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|ExtendedBlock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|LocatedBlock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|LocatedStripedBlock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|security
operator|.
name|token
operator|.
name|block
operator|.
name|BlockTokenIdentifier
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|FSNamesystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|token
operator|.
name|Token
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Time
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Assert
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|BeforeClass
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Test
import|;
end_import

begin_import
import|import
name|org
operator|.
name|mockito
operator|.
name|Mockito
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_comment
comment|/**  * This class tests the sorting of located striped blocks based on  * decommissioned states.  */
end_comment

begin_class
DECL|class|TestSortLocatedStripedBlock
specifier|public
class|class
name|TestSortLocatedStripedBlock
block|{
DECL|field|LOG
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|TestSortLocatedStripedBlock
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|ecPolicy
specifier|private
specifier|final
name|ErasureCodingPolicy
name|ecPolicy
init|=
name|StripedFileTestUtil
operator|.
name|getDefaultECPolicy
argument_list|()
decl_stmt|;
DECL|field|cellSize
specifier|private
specifier|final
name|int
name|cellSize
init|=
name|ecPolicy
operator|.
name|getCellSize
argument_list|()
decl_stmt|;
DECL|field|dataBlocks
specifier|private
specifier|final
name|short
name|dataBlocks
init|=
operator|(
name|short
operator|)
name|ecPolicy
operator|.
name|getNumDataUnits
argument_list|()
decl_stmt|;
DECL|field|parityBlocks
specifier|private
specifier|final
name|short
name|parityBlocks
init|=
operator|(
name|short
operator|)
name|ecPolicy
operator|.
name|getNumParityUnits
argument_list|()
decl_stmt|;
DECL|field|groupSize
specifier|private
specifier|final
name|int
name|groupSize
init|=
name|dataBlocks
operator|+
name|parityBlocks
decl_stmt|;
DECL|field|dm
specifier|static
name|DatanodeManager
name|dm
decl_stmt|;
DECL|field|STALE_INTERVAL
specifier|static
specifier|final
name|long
name|STALE_INTERVAL
init|=
literal|30
operator|*
literal|1000
operator|*
literal|60
decl_stmt|;
annotation|@
name|BeforeClass
DECL|method|setup ()
specifier|public
specifier|static
name|void
name|setup
parameter_list|()
throws|throws
name|IOException
block|{
name|dm
operator|=
name|mockDatanodeManager
argument_list|()
expr_stmt|;
block|}
comment|/**    * Test to verify sorting with multiple decommissioned datanodes exists in    * storage lists.    *    * We have storage list, marked decommissioned internal blocks with a '    * d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12    * mapping to indices    * 0', 1', 2, 3, 4, 5, 6, 7', 8', 0, 1, 7, 8    *    * Decommissioned node indices: 0, 1, 7, 8    *    * So in the original list nodes d0, d1, d7, d8 are decommissioned state.    *    * After sorting the expected block indices list should be,    * 0, 1, 2, 3, 4, 5, 6, 7, 8, 0', 1', 7', 8'    *    * After sorting the expected storage list will be,    * d9, d10, d2, d3, d4, d5, d6, d11, d12, d0, d1, d7, d8.    *    * Note: after sorting block indices will not be in ascending order.    */
annotation|@
name|Test
argument_list|(
name|timeout
operator|=
literal|10000
argument_list|)
DECL|method|testWithMultipleDecommnDatanodes ()
specifier|public
name|void
name|testWithMultipleDecommnDatanodes
parameter_list|()
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Starting test testSortWithMultipleDecommnDatanodes"
argument_list|)
expr_stmt|;
name|int
name|lbsCount
init|=
literal|2
decl_stmt|;
comment|// two located block groups
name|List
argument_list|<
name|Integer
argument_list|>
name|decommnNodeIndices
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|decommnNodeIndices
operator|.
name|add
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|decommnNodeIndices
operator|.
name|add
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|decommnNodeIndices
operator|.
name|add
argument_list|(
literal|7
argument_list|)
expr_stmt|;
name|decommnNodeIndices
operator|.
name|add
argument_list|(
literal|8
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|Integer
argument_list|>
name|targetNodeIndices
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|targetNodeIndices
operator|.
name|addAll
argument_list|(
name|decommnNodeIndices
argument_list|)
expr_stmt|;
comment|// map contains decommissioned node details in each located strip block
comment|// which will be used for assertions
name|HashMap
argument_list|<
name|Integer
argument_list|,
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|decommissionedNodes
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|(
name|lbsCount
operator|*
name|decommnNodeIndices
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|LocatedBlock
argument_list|>
name|lbs
init|=
name|createLocatedStripedBlocks
argument_list|(
name|lbsCount
argument_list|,
name|dataBlocks
argument_list|,
name|parityBlocks
argument_list|,
name|decommnNodeIndices
argument_list|,
name|targetNodeIndices
argument_list|,
name|decommissionedNodes
argument_list|)
decl_stmt|;
comment|// prepare expected block index and token list.
name|List
argument_list|<
name|HashMap
argument_list|<
name|DatanodeInfo
argument_list|,
name|Byte
argument_list|>
argument_list|>
name|locToIndexList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|HashMap
argument_list|<
name|DatanodeInfo
argument_list|,
name|Token
argument_list|<
name|BlockTokenIdentifier
argument_list|>
argument_list|>
argument_list|>
name|locToTokenList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|prepareBlockIndexAndTokenList
argument_list|(
name|lbs
argument_list|,
name|locToIndexList
argument_list|,
name|locToTokenList
argument_list|)
expr_stmt|;
name|dm
operator|.
name|sortLocatedBlocks
argument_list|(
literal|null
argument_list|,
name|lbs
argument_list|)
expr_stmt|;
name|assertDecommnNodePosition
argument_list|(
name|groupSize
argument_list|,
name|decommissionedNodes
argument_list|,
name|lbs
argument_list|)
expr_stmt|;
name|assertBlockIndexAndTokenPosition
argument_list|(
name|lbs
argument_list|,
name|locToIndexList
argument_list|,
name|locToTokenList
argument_list|)
expr_stmt|;
block|}
comment|/**    * Test to verify sorting with two decommissioned datanodes exists in    * storage lists for the same block index.    *    * We have storage list, marked decommissioned internal blocks with a '    * d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13    * mapping to indices    * 0', 1', 2, 3, 4', 5', 6, 7, 8, 0, 1', 4, 5, 1    *    * Decommissioned node indices: 0', 1', 4', 5', 1'    *    * Here decommissioned has done twice to the datanode block index 1.    * So in the original list nodes d0, d1, d4, d5, d10 are decommissioned state.    *    * After sorting the expected block indices list will be,    * 0, 1, 2, 3, 4, 5, 6, 7, 8, 0', 1', 1', 4', 5'    *    * After sorting the expected storage list will be,    * d9, d13, d2, d3, d11, d12, d6, d7, d8, d0, d1, d10, d4, d5.    *    * Note: after sorting block indices will not be in ascending order.    */
annotation|@
name|Test
argument_list|(
name|timeout
operator|=
literal|10000
argument_list|)
DECL|method|testTwoDatanodesWithSameBlockIndexAreDecommn ()
specifier|public
name|void
name|testTwoDatanodesWithSameBlockIndexAreDecommn
parameter_list|()
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Starting test testTwoDatanodesWithSameBlockIndexAreDecommn"
argument_list|)
expr_stmt|;
name|int
name|lbsCount
init|=
literal|2
decl_stmt|;
comment|// two located block groups
name|List
argument_list|<
name|Integer
argument_list|>
name|decommnNodeIndices
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|decommnNodeIndices
operator|.
name|add
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|decommnNodeIndices
operator|.
name|add
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|decommnNodeIndices
operator|.
name|add
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|decommnNodeIndices
operator|.
name|add
argument_list|(
literal|5
argument_list|)
expr_stmt|;
comment|// representing blockIndex 1, later this also decommissioned
name|decommnNodeIndices
operator|.
name|add
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|Integer
argument_list|>
name|targetNodeIndices
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|targetNodeIndices
operator|.
name|addAll
argument_list|(
name|decommnNodeIndices
argument_list|)
expr_stmt|;
comment|// map contains decommissioned node details in each located strip block
comment|// which will be used for assertions
name|HashMap
argument_list|<
name|Integer
argument_list|,
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|decommissionedNodes
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|(
name|lbsCount
operator|*
name|decommnNodeIndices
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|LocatedBlock
argument_list|>
name|lbs
init|=
name|createLocatedStripedBlocks
argument_list|(
name|lbsCount
argument_list|,
name|dataBlocks
argument_list|,
name|parityBlocks
argument_list|,
name|decommnNodeIndices
argument_list|,
name|targetNodeIndices
argument_list|,
name|decommissionedNodes
argument_list|)
decl_stmt|;
comment|// prepare expected block index and token list.
name|List
argument_list|<
name|HashMap
argument_list|<
name|DatanodeInfo
argument_list|,
name|Byte
argument_list|>
argument_list|>
name|locToIndexList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|HashMap
argument_list|<
name|DatanodeInfo
argument_list|,
name|Token
argument_list|<
name|BlockTokenIdentifier
argument_list|>
argument_list|>
argument_list|>
name|locToTokenList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|prepareBlockIndexAndTokenList
argument_list|(
name|lbs
argument_list|,
name|locToIndexList
argument_list|,
name|locToTokenList
argument_list|)
expr_stmt|;
name|dm
operator|.
name|sortLocatedBlocks
argument_list|(
literal|null
argument_list|,
name|lbs
argument_list|)
expr_stmt|;
name|assertDecommnNodePosition
argument_list|(
name|groupSize
argument_list|,
name|decommissionedNodes
argument_list|,
name|lbs
argument_list|)
expr_stmt|;
name|assertBlockIndexAndTokenPosition
argument_list|(
name|lbs
argument_list|,
name|locToIndexList
argument_list|,
name|locToTokenList
argument_list|)
expr_stmt|;
block|}
comment|/**    * Test to verify sorting with decommissioned datanodes exists in storage    * list which is smaller than stripe size.    *    * We have storage list, marked decommissioned internal blocks with a '    * d0, d1, d2, d3, d6, d7, d8, d9, d10, d11    * mapping to indices    * 0', 1, 2', 3, 6, 7, 8, 0, 2', 2    *    * Decommissioned node indices: 0', 2', 2'    *    * Here decommissioned has done twice to the datanode block index 2.    * So in the original list nodes d0, d2, d10 are decommissioned state.    *    * After sorting the expected block indices list should be,    * 0, 1, 2, 3, 6, 7, 8, 0', 2', 2'    *    * After sorting the expected storage list will be,    * d9, d1, d11, d3, d6, d7, d8, d0, d2, d10.    *    * Note: after sorting block indices will not be in ascending order.    */
annotation|@
name|Test
argument_list|(
name|timeout
operator|=
literal|10000
argument_list|)
DECL|method|testSmallerThanOneStripeWithMultpleDecommnNodes ()
specifier|public
name|void
name|testSmallerThanOneStripeWithMultpleDecommnNodes
parameter_list|()
throws|throws
name|Exception
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Starting test testSmallerThanOneStripeWithDecommn"
argument_list|)
expr_stmt|;
name|int
name|lbsCount
init|=
literal|2
decl_stmt|;
comment|// two located block groups
name|List
argument_list|<
name|Integer
argument_list|>
name|decommnNodeIndices
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|decommnNodeIndices
operator|.
name|add
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|decommnNodeIndices
operator|.
name|add
argument_list|(
literal|2
argument_list|)
expr_stmt|;
comment|// representing blockIndex 1, later this also decommissioned
name|decommnNodeIndices
operator|.
name|add
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|Integer
argument_list|>
name|targetNodeIndices
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|targetNodeIndices
operator|.
name|addAll
argument_list|(
name|decommnNodeIndices
argument_list|)
expr_stmt|;
comment|// map contains decommissioned node details in each located strip block
comment|// which will be used for assertions
name|HashMap
argument_list|<
name|Integer
argument_list|,
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|decommissionedNodes
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|(
name|lbsCount
operator|*
name|decommnNodeIndices
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|dataBlksNum
init|=
name|dataBlocks
operator|-
literal|2
decl_stmt|;
name|List
argument_list|<
name|LocatedBlock
argument_list|>
name|lbs
init|=
name|createLocatedStripedBlocks
argument_list|(
name|lbsCount
argument_list|,
name|dataBlksNum
argument_list|,
name|parityBlocks
argument_list|,
name|decommnNodeIndices
argument_list|,
name|targetNodeIndices
argument_list|,
name|decommissionedNodes
argument_list|)
decl_stmt|;
comment|// prepare expected block index and token list.
name|List
argument_list|<
name|HashMap
argument_list|<
name|DatanodeInfo
argument_list|,
name|Byte
argument_list|>
argument_list|>
name|locToIndexList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|HashMap
argument_list|<
name|DatanodeInfo
argument_list|,
name|Token
argument_list|<
name|BlockTokenIdentifier
argument_list|>
argument_list|>
argument_list|>
name|locToTokenList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|prepareBlockIndexAndTokenList
argument_list|(
name|lbs
argument_list|,
name|locToIndexList
argument_list|,
name|locToTokenList
argument_list|)
expr_stmt|;
name|dm
operator|.
name|sortLocatedBlocks
argument_list|(
literal|null
argument_list|,
name|lbs
argument_list|)
expr_stmt|;
comment|// After this index all are decommissioned nodes.
name|int
name|blkGrpWidth
init|=
name|dataBlksNum
operator|+
name|parityBlocks
decl_stmt|;
name|assertDecommnNodePosition
argument_list|(
name|blkGrpWidth
argument_list|,
name|decommissionedNodes
argument_list|,
name|lbs
argument_list|)
expr_stmt|;
name|assertBlockIndexAndTokenPosition
argument_list|(
name|lbs
argument_list|,
name|locToIndexList
argument_list|,
name|locToTokenList
argument_list|)
expr_stmt|;
block|}
comment|/**    * Test to verify sorting with decommissioned datanodes exists in storage    * list but the corresponding new target datanode doesn't exists.    *    * We have storage list, marked decommissioned internal blocks with a '    * d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11    * mapping to indices    * 0', 1', 2', 3, 4', 5', 6, 7, 8, 0, 2, 4    *    * Decommissioned node indices: 0', 1', 2', 4', 5'    *    * 1 and 5 nodes doesn't exists in the target list. This can happen, the    * target node block corrupted or lost after the successful decommissioning.    * So in the original list nodes corresponding to the decommissioned block    * index 1 and 5 doesn't have any target entries.    *    * After sorting the expected block indices list should be,    * 0, 2, 3, 4, 6, 7, 8, 0', 1', 2', 4', 5'    *    * After sorting the expected storage list will be,    * d9, d10, d3, d11, d6, d7, d8, d0, d1, d2, d4, d5.    *    * Note: after sorting block indices will not be in ascending order.    */
annotation|@
name|Test
argument_list|(
name|timeout
operator|=
literal|10000
argument_list|)
DECL|method|testTargetDecommnDatanodeDoesntExists ()
specifier|public
name|void
name|testTargetDecommnDatanodeDoesntExists
parameter_list|()
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Starting test testTargetDecommnDatanodeDoesntExists"
argument_list|)
expr_stmt|;
name|int
name|lbsCount
init|=
literal|2
decl_stmt|;
comment|// two located block groups
name|List
argument_list|<
name|Integer
argument_list|>
name|decommnNodeIndices
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|decommnNodeIndices
operator|.
name|add
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|decommnNodeIndices
operator|.
name|add
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|decommnNodeIndices
operator|.
name|add
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|decommnNodeIndices
operator|.
name|add
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|decommnNodeIndices
operator|.
name|add
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|Integer
argument_list|>
name|targetNodeIndices
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|targetNodeIndices
operator|.
name|add
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|targetNodeIndices
operator|.
name|add
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|targetNodeIndices
operator|.
name|add
argument_list|(
literal|4
argument_list|)
expr_stmt|;
comment|// 1 and 5 nodes doesn't exists in the target list. One such case is, the
comment|// target node block corrupted or lost after the successful decommissioning
comment|// map contains decommissioned node details in each located strip block
comment|// which will be used for assertions
name|HashMap
argument_list|<
name|Integer
argument_list|,
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|decommissionedNodes
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|(
name|lbsCount
operator|*
name|decommnNodeIndices
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|LocatedBlock
argument_list|>
name|lbs
init|=
name|createLocatedStripedBlocks
argument_list|(
name|lbsCount
argument_list|,
name|dataBlocks
argument_list|,
name|parityBlocks
argument_list|,
name|decommnNodeIndices
argument_list|,
name|targetNodeIndices
argument_list|,
name|decommissionedNodes
argument_list|)
decl_stmt|;
comment|// prepare expected block index and token list.
name|List
argument_list|<
name|HashMap
argument_list|<
name|DatanodeInfo
argument_list|,
name|Byte
argument_list|>
argument_list|>
name|locToIndexList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|HashMap
argument_list|<
name|DatanodeInfo
argument_list|,
name|Token
argument_list|<
name|BlockTokenIdentifier
argument_list|>
argument_list|>
argument_list|>
name|locToTokenList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|prepareBlockIndexAndTokenList
argument_list|(
name|lbs
argument_list|,
name|locToIndexList
argument_list|,
name|locToTokenList
argument_list|)
expr_stmt|;
name|dm
operator|.
name|sortLocatedBlocks
argument_list|(
literal|null
argument_list|,
name|lbs
argument_list|)
expr_stmt|;
comment|// After this index all are decommissioned nodes. Needs to reconstruct two
comment|// more block indices.
name|int
name|blkGrpWidth
init|=
name|dataBlocks
operator|+
name|parityBlocks
operator|-
literal|2
decl_stmt|;
name|assertDecommnNodePosition
argument_list|(
name|blkGrpWidth
argument_list|,
name|decommissionedNodes
argument_list|,
name|lbs
argument_list|)
expr_stmt|;
name|assertBlockIndexAndTokenPosition
argument_list|(
name|lbs
argument_list|,
name|locToIndexList
argument_list|,
name|locToTokenList
argument_list|)
expr_stmt|;
block|}
comment|/**    * Test to verify sorting with multiple in-service and decommissioned    * datanodes exists in storage lists.    *    * We have storage list, marked decommissioned internal blocks with a '    * d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13    * mapping to indices    * 0', 1', 2, 3, 4, 5, 6, 7', 8', 0, 1, 7, 8, 1    *    * Decommissioned node indices: 0', 1', 7', 8'    *    * Additional In-Service node d13 at the end, block index: 1    *    * So in the original list nodes d0, d1, d7, d8 are decommissioned state.    *    * After sorting the expected block indices list will be,    * 0, 1, 2, 3, 4, 5, 6, 7, 8, 1, 0', 1', 7', 8'    *    * After sorting the expected storage list will be,    * d9, d10, d2, d3, d4, d5, d6, d11, d12, d13, d0, d1, d7, d8.    *    * Note: after sorting block indices will not be in ascending order.    */
annotation|@
name|Test
argument_list|(
name|timeout
operator|=
literal|10000
argument_list|)
DECL|method|testWithMultipleInServiceAndDecommnDatanodes ()
specifier|public
name|void
name|testWithMultipleInServiceAndDecommnDatanodes
parameter_list|()
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Starting test testWithMultipleInServiceAndDecommnDatanodes"
argument_list|)
expr_stmt|;
name|int
name|lbsCount
init|=
literal|2
decl_stmt|;
comment|// two located block groups
name|List
argument_list|<
name|Integer
argument_list|>
name|decommnNodeIndices
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|decommnNodeIndices
operator|.
name|add
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|decommnNodeIndices
operator|.
name|add
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|decommnNodeIndices
operator|.
name|add
argument_list|(
literal|7
argument_list|)
expr_stmt|;
name|decommnNodeIndices
operator|.
name|add
argument_list|(
literal|8
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|Integer
argument_list|>
name|targetNodeIndices
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|targetNodeIndices
operator|.
name|addAll
argument_list|(
name|decommnNodeIndices
argument_list|)
expr_stmt|;
comment|// at the end add an additional In-Service node to blockIndex=1
name|targetNodeIndices
operator|.
name|add
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|// map contains decommissioned node details in each located strip block
comment|// which will be used for assertions
name|HashMap
argument_list|<
name|Integer
argument_list|,
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|decommissionedNodes
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|(
name|lbsCount
operator|*
name|decommnNodeIndices
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|LocatedBlock
argument_list|>
name|lbs
init|=
name|createLocatedStripedBlocks
argument_list|(
name|lbsCount
argument_list|,
name|dataBlocks
argument_list|,
name|parityBlocks
argument_list|,
name|decommnNodeIndices
argument_list|,
name|targetNodeIndices
argument_list|,
name|decommissionedNodes
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|DatanodeInfo
argument_list|>
name|staleDns
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|LocatedBlock
name|lb
range|:
name|lbs
control|)
block|{
name|DatanodeInfo
index|[]
name|locations
init|=
name|lb
operator|.
name|getLocations
argument_list|()
decl_stmt|;
name|DatanodeInfo
name|staleDn
init|=
name|locations
index|[
name|locations
operator|.
name|length
operator|-
literal|1
index|]
decl_stmt|;
name|staleDn
operator|.
name|setLastUpdateMonotonic
argument_list|(
name|Time
operator|.
name|monotonicNow
argument_list|()
operator|-
operator|(
name|STALE_INTERVAL
operator|*
literal|2
operator|)
argument_list|)
expr_stmt|;
name|staleDns
operator|.
name|add
argument_list|(
name|staleDn
argument_list|)
expr_stmt|;
block|}
comment|// prepare expected block index and token list.
name|List
argument_list|<
name|HashMap
argument_list|<
name|DatanodeInfo
argument_list|,
name|Byte
argument_list|>
argument_list|>
name|locToIndexList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|HashMap
argument_list|<
name|DatanodeInfo
argument_list|,
name|Token
argument_list|<
name|BlockTokenIdentifier
argument_list|>
argument_list|>
argument_list|>
name|locToTokenList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|prepareBlockIndexAndTokenList
argument_list|(
name|lbs
argument_list|,
name|locToIndexList
argument_list|,
name|locToTokenList
argument_list|)
expr_stmt|;
name|dm
operator|.
name|sortLocatedBlocks
argument_list|(
literal|null
argument_list|,
name|lbs
argument_list|)
expr_stmt|;
name|assertDecommnNodePosition
argument_list|(
name|groupSize
operator|+
literal|1
argument_list|,
name|decommissionedNodes
argument_list|,
name|lbs
argument_list|)
expr_stmt|;
name|assertBlockIndexAndTokenPosition
argument_list|(
name|lbs
argument_list|,
name|locToIndexList
argument_list|,
name|locToTokenList
argument_list|)
expr_stmt|;
for|for
control|(
name|LocatedBlock
name|lb
range|:
name|lbs
control|)
block|{
name|byte
index|[]
name|blockIndices
init|=
operator|(
operator|(
name|LocatedStripedBlock
operator|)
name|lb
operator|)
operator|.
name|getBlockIndices
argument_list|()
decl_stmt|;
comment|// after sorting stale block index will be placed after normal nodes.
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"Failed to move stale node to bottom!"
argument_list|,
literal|1
argument_list|,
name|blockIndices
index|[
literal|9
index|]
argument_list|)
expr_stmt|;
name|DatanodeInfo
index|[]
name|locations
init|=
name|lb
operator|.
name|getLocations
argument_list|()
decl_stmt|;
comment|// After sorting stale node d13 will be placed after normal nodes
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"Failed to move stale dn after normal one!"
argument_list|,
name|staleDns
operator|.
name|remove
argument_list|(
literal|0
argument_list|)
argument_list|,
name|locations
index|[
literal|9
index|]
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Verify that decommissioned/stale nodes must be positioned after normal    * nodes.    */
DECL|method|assertDecommnNodePosition (int blkGrpWidth, HashMap<Integer, List<String>> decommissionedNodes, List<LocatedBlock> lbs)
specifier|private
name|void
name|assertDecommnNodePosition
parameter_list|(
name|int
name|blkGrpWidth
parameter_list|,
name|HashMap
argument_list|<
name|Integer
argument_list|,
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|decommissionedNodes
parameter_list|,
name|List
argument_list|<
name|LocatedBlock
argument_list|>
name|lbs
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|lbs
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
comment|// for each block
name|LocatedBlock
name|blk
init|=
name|lbs
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|DatanodeInfo
index|[]
name|nodes
init|=
name|blk
operator|.
name|getLocations
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|decommissionedNodeList
init|=
name|decommissionedNodes
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|nodes
operator|.
name|length
condition|;
name|j
operator|++
control|)
block|{
comment|// for each replica
name|DatanodeInfo
name|dnInfo
init|=
name|nodes
index|[
name|j
index|]
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Block Locations size={}, locs={}, j="
argument_list|,
name|nodes
operator|.
name|length
argument_list|,
name|dnInfo
operator|.
name|toString
argument_list|()
argument_list|,
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|<
name|blkGrpWidth
condition|)
block|{
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"Node shouldn't be decommissioned"
argument_list|,
name|AdminStates
operator|.
name|NORMAL
argument_list|,
name|dnInfo
operator|.
name|getAdminState
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// check against decommissioned list
name|Assert
operator|.
name|assertTrue
argument_list|(
literal|"For block "
operator|+
name|blk
operator|.
name|getBlock
argument_list|()
operator|+
literal|" decommissioned node "
operator|+
name|dnInfo
operator|+
literal|" is not last node in list: "
operator|+
name|j
operator|+
literal|"th index of "
operator|+
name|nodes
operator|.
name|length
argument_list|,
name|decommissionedNodeList
operator|.
name|contains
argument_list|(
name|dnInfo
operator|.
name|getXferAddr
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"Node should be decommissioned"
argument_list|,
name|AdminStates
operator|.
name|DECOMMISSIONED
argument_list|,
name|dnInfo
operator|.
name|getAdminState
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
DECL|method|createLocatedStripedBlocks (int blkGrpCount, int dataNumBlk, int numParityBlk, List<Integer> decommnNodeIndices, List<Integer> targetNodeIndices, HashMap<Integer, List<String>> decommissionedNodes)
specifier|private
name|List
argument_list|<
name|LocatedBlock
argument_list|>
name|createLocatedStripedBlocks
parameter_list|(
name|int
name|blkGrpCount
parameter_list|,
name|int
name|dataNumBlk
parameter_list|,
name|int
name|numParityBlk
parameter_list|,
name|List
argument_list|<
name|Integer
argument_list|>
name|decommnNodeIndices
parameter_list|,
name|List
argument_list|<
name|Integer
argument_list|>
name|targetNodeIndices
parameter_list|,
name|HashMap
argument_list|<
name|Integer
argument_list|,
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|decommissionedNodes
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|LocatedBlock
argument_list|>
name|lbs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|blkGrpCount
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|blkGrpCount
condition|;
name|i
operator|++
control|)
block|{
name|ArrayList
argument_list|<
name|String
argument_list|>
name|decommNodeInfo
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|decommissionedNodes
operator|.
name|put
argument_list|(
operator|new
name|Integer
argument_list|(
name|i
argument_list|)
argument_list|,
name|decommNodeInfo
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|Integer
argument_list|>
name|dummyDecommnNodeIndices
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|dummyDecommnNodeIndices
operator|.
name|addAll
argument_list|(
name|decommnNodeIndices
argument_list|)
expr_stmt|;
name|LocatedStripedBlock
name|lsb
init|=
name|createEachLocatedBlock
argument_list|(
name|dataNumBlk
argument_list|,
name|numParityBlk
argument_list|,
name|dummyDecommnNodeIndices
argument_list|,
name|targetNodeIndices
argument_list|,
name|decommNodeInfo
argument_list|)
decl_stmt|;
name|lbs
operator|.
name|add
argument_list|(
name|lsb
argument_list|)
expr_stmt|;
block|}
return|return
name|lbs
return|;
block|}
DECL|method|createEachLocatedBlock (int numDataBlk, int numParityBlk, List<Integer> decommnNodeIndices, List<Integer> targetNodeIndices, ArrayList<String> decommNodeInfo)
specifier|private
name|LocatedStripedBlock
name|createEachLocatedBlock
parameter_list|(
name|int
name|numDataBlk
parameter_list|,
name|int
name|numParityBlk
parameter_list|,
name|List
argument_list|<
name|Integer
argument_list|>
name|decommnNodeIndices
parameter_list|,
name|List
argument_list|<
name|Integer
argument_list|>
name|targetNodeIndices
parameter_list|,
name|ArrayList
argument_list|<
name|String
argument_list|>
name|decommNodeInfo
parameter_list|)
block|{
specifier|final
name|long
name|blockGroupID
init|=
name|Long
operator|.
name|MIN_VALUE
decl_stmt|;
name|int
name|totalDns
init|=
name|numDataBlk
operator|+
name|numParityBlk
operator|+
name|targetNodeIndices
operator|.
name|size
argument_list|()
decl_stmt|;
name|DatanodeInfo
index|[]
name|locs
init|=
operator|new
name|DatanodeInfo
index|[
name|totalDns
index|]
decl_stmt|;
name|String
index|[]
name|storageIDs
init|=
operator|new
name|String
index|[
name|totalDns
index|]
decl_stmt|;
name|StorageType
index|[]
name|storageTypes
init|=
operator|new
name|StorageType
index|[
name|totalDns
index|]
decl_stmt|;
name|byte
index|[]
name|blkIndices
init|=
operator|new
name|byte
index|[
name|totalDns
index|]
decl_stmt|;
comment|// Adding data blocks
name|int
name|index
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
name|index
operator|<
name|numDataBlk
condition|;
name|index
operator|++
control|)
block|{
name|blkIndices
index|[
name|index
index|]
operator|=
operator|(
name|byte
operator|)
name|index
expr_stmt|;
comment|// Location port always equal to logical index of a block,
comment|// for easier verification
name|locs
index|[
name|index
index|]
operator|=
name|DFSTestUtil
operator|.
name|getLocalDatanodeInfo
argument_list|(
name|blkIndices
index|[
name|index
index|]
argument_list|)
expr_stmt|;
name|locs
index|[
name|index
index|]
operator|.
name|setLastUpdateMonotonic
argument_list|(
name|Time
operator|.
name|monotonicNow
argument_list|()
argument_list|)
expr_stmt|;
name|storageIDs
index|[
name|index
index|]
operator|=
name|locs
index|[
name|index
index|]
operator|.
name|getDatanodeUuid
argument_list|()
expr_stmt|;
name|storageTypes
index|[
name|index
index|]
operator|=
name|StorageType
operator|.
name|DISK
expr_stmt|;
comment|// set decommissioned state
if|if
condition|(
name|decommnNodeIndices
operator|.
name|contains
argument_list|(
name|index
argument_list|)
condition|)
block|{
name|locs
index|[
name|index
index|]
operator|.
name|setDecommissioned
argument_list|()
expr_stmt|;
name|decommNodeInfo
operator|.
name|add
argument_list|(
name|locs
index|[
name|index
index|]
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
comment|// Removing it from the list to ensure that all the given nodes are
comment|// successfully marked as decomissioned.
name|decommnNodeIndices
operator|.
name|remove
argument_list|(
operator|new
name|Integer
argument_list|(
name|index
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Adding parity blocks after data blocks
name|index
operator|=
name|dataBlocks
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
name|numDataBlk
init|;
name|j
operator|<
name|numDataBlk
operator|+
name|numParityBlk
condition|;
name|j
operator|++
operator|,
name|index
operator|++
control|)
block|{
name|blkIndices
index|[
name|j
index|]
operator|=
operator|(
name|byte
operator|)
name|index
expr_stmt|;
comment|// Location port always equal to logical index of a block,
comment|// for easier verification
name|locs
index|[
name|j
index|]
operator|=
name|DFSTestUtil
operator|.
name|getLocalDatanodeInfo
argument_list|(
name|blkIndices
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|locs
index|[
name|j
index|]
operator|.
name|setLastUpdateMonotonic
argument_list|(
name|Time
operator|.
name|monotonicNow
argument_list|()
argument_list|)
expr_stmt|;
name|storageIDs
index|[
name|j
index|]
operator|=
name|locs
index|[
name|j
index|]
operator|.
name|getDatanodeUuid
argument_list|()
expr_stmt|;
name|storageTypes
index|[
name|j
index|]
operator|=
name|StorageType
operator|.
name|DISK
expr_stmt|;
comment|// set decommissioned state
if|if
condition|(
name|decommnNodeIndices
operator|.
name|contains
argument_list|(
name|index
argument_list|)
condition|)
block|{
name|locs
index|[
name|j
index|]
operator|.
name|setDecommissioned
argument_list|()
expr_stmt|;
name|decommNodeInfo
operator|.
name|add
argument_list|(
name|locs
index|[
name|j
index|]
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
comment|// Removing it from the list to ensure that all the given nodes are
comment|// successfully marked as decomissioned.
name|decommnNodeIndices
operator|.
name|remove
argument_list|(
operator|new
name|Integer
argument_list|(
name|index
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Add extra target nodes to storage list after the parity blocks
name|int
name|basePortValue
init|=
name|dataBlocks
operator|+
name|parityBlocks
decl_stmt|;
name|index
operator|=
name|numDataBlk
operator|+
name|numParityBlk
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|targetNodeIndices
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
operator|,
name|index
operator|++
control|)
block|{
name|int
name|blkIndexPos
init|=
name|targetNodeIndices
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|blkIndices
index|[
name|index
index|]
operator|=
operator|(
name|byte
operator|)
name|blkIndexPos
expr_stmt|;
comment|// Location port always equal to logical index of a block,
comment|// for easier verification
name|locs
index|[
name|index
index|]
operator|=
name|DFSTestUtil
operator|.
name|getLocalDatanodeInfo
argument_list|(
name|basePortValue
operator|++
argument_list|)
expr_stmt|;
name|locs
index|[
name|index
index|]
operator|.
name|setLastUpdateMonotonic
argument_list|(
name|Time
operator|.
name|monotonicNow
argument_list|()
argument_list|)
expr_stmt|;
name|storageIDs
index|[
name|index
index|]
operator|=
name|locs
index|[
name|index
index|]
operator|.
name|getDatanodeUuid
argument_list|()
expr_stmt|;
name|storageTypes
index|[
name|index
index|]
operator|=
name|StorageType
operator|.
name|DISK
expr_stmt|;
comment|// set decommissioned state. This can happen, the target node is again
comment|// decommissioned by administrator
if|if
condition|(
name|decommnNodeIndices
operator|.
name|contains
argument_list|(
name|blkIndexPos
argument_list|)
condition|)
block|{
name|locs
index|[
name|index
index|]
operator|.
name|setDecommissioned
argument_list|()
expr_stmt|;
name|decommNodeInfo
operator|.
name|add
argument_list|(
name|locs
index|[
name|index
index|]
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
comment|// Removing it from the list to ensure that all the given nodes are
comment|// successfully marked as decomissioned.
name|decommnNodeIndices
operator|.
name|remove
argument_list|(
operator|new
name|Integer
argument_list|(
name|blkIndexPos
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|new
name|LocatedStripedBlock
argument_list|(
operator|new
name|ExtendedBlock
argument_list|(
literal|"pool"
argument_list|,
name|blockGroupID
argument_list|,
name|cellSize
argument_list|,
literal|1001
argument_list|)
argument_list|,
name|locs
argument_list|,
name|storageIDs
argument_list|,
name|storageTypes
argument_list|,
name|blkIndices
argument_list|,
literal|0
argument_list|,
literal|false
argument_list|,
literal|null
argument_list|)
return|;
block|}
DECL|method|mockDatanodeManager ()
specifier|private
specifier|static
name|DatanodeManager
name|mockDatanodeManager
parameter_list|()
throws|throws
name|IOException
block|{
name|Configuration
name|conf
init|=
operator|new
name|Configuration
argument_list|()
decl_stmt|;
name|conf
operator|.
name|setBoolean
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_AVOID_STALE_DATANODE_FOR_READ_KEY
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|conf
operator|.
name|setLong
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_STALE_DATANODE_INTERVAL_KEY
argument_list|,
name|STALE_INTERVAL
argument_list|)
expr_stmt|;
name|FSNamesystem
name|fsn
init|=
name|Mockito
operator|.
name|mock
argument_list|(
name|FSNamesystem
operator|.
name|class
argument_list|)
decl_stmt|;
name|BlockManager
name|bm
init|=
name|Mockito
operator|.
name|mock
argument_list|(
name|BlockManager
operator|.
name|class
argument_list|)
decl_stmt|;
name|BlockReportLeaseManager
name|blm
init|=
operator|new
name|BlockReportLeaseManager
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|Mockito
operator|.
name|when
argument_list|(
name|bm
operator|.
name|getBlockReportLeaseManager
argument_list|()
argument_list|)
operator|.
name|thenReturn
argument_list|(
name|blm
argument_list|)
expr_stmt|;
name|DatanodeManager
name|dm
init|=
operator|new
name|DatanodeManager
argument_list|(
name|bm
argument_list|,
name|fsn
argument_list|,
name|conf
argument_list|)
decl_stmt|;
return|return
name|dm
return|;
block|}
DECL|method|prepareBlockIndexAndTokenList (List<LocatedBlock> lbs, List<HashMap<DatanodeInfo, Byte>> locToIndexList, List<HashMap<DatanodeInfo, Token<BlockTokenIdentifier>>> locToTokenList)
specifier|private
name|void
name|prepareBlockIndexAndTokenList
parameter_list|(
name|List
argument_list|<
name|LocatedBlock
argument_list|>
name|lbs
parameter_list|,
name|List
argument_list|<
name|HashMap
argument_list|<
name|DatanodeInfo
argument_list|,
name|Byte
argument_list|>
argument_list|>
name|locToIndexList
parameter_list|,
name|List
argument_list|<
name|HashMap
argument_list|<
name|DatanodeInfo
argument_list|,
name|Token
argument_list|<
name|BlockTokenIdentifier
argument_list|>
argument_list|>
argument_list|>
name|locToTokenList
parameter_list|)
block|{
for|for
control|(
name|LocatedBlock
name|lb
range|:
name|lbs
control|)
block|{
name|HashMap
argument_list|<
name|DatanodeInfo
argument_list|,
name|Byte
argument_list|>
name|locToIndex
init|=
operator|new
name|HashMap
argument_list|<
name|DatanodeInfo
argument_list|,
name|Byte
argument_list|>
argument_list|()
decl_stmt|;
name|locToIndexList
operator|.
name|add
argument_list|(
name|locToIndex
argument_list|)
expr_stmt|;
name|HashMap
argument_list|<
name|DatanodeInfo
argument_list|,
name|Token
argument_list|<
name|BlockTokenIdentifier
argument_list|>
argument_list|>
name|locToToken
init|=
operator|new
name|HashMap
argument_list|<
name|DatanodeInfo
argument_list|,
name|Token
argument_list|<
name|BlockTokenIdentifier
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|locToTokenList
operator|.
name|add
argument_list|(
name|locToToken
argument_list|)
expr_stmt|;
name|DatanodeInfo
index|[]
name|di
init|=
name|lb
operator|.
name|getLocations
argument_list|()
decl_stmt|;
name|LocatedStripedBlock
name|stripedBlk
init|=
operator|(
name|LocatedStripedBlock
operator|)
name|lb
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|di
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|locToIndex
operator|.
name|put
argument_list|(
name|di
index|[
name|i
index|]
argument_list|,
name|stripedBlk
operator|.
name|getBlockIndices
argument_list|()
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|locToToken
operator|.
name|put
argument_list|(
name|di
index|[
name|i
index|]
argument_list|,
name|stripedBlk
operator|.
name|getBlockTokens
argument_list|()
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Verify block index and token values. Must update block indices and block    * tokens after sorting.    */
DECL|method|assertBlockIndexAndTokenPosition (List<LocatedBlock> lbs, List<HashMap<DatanodeInfo, Byte>> locToIndexList, List<HashMap<DatanodeInfo, Token<BlockTokenIdentifier>>> locToTokenList)
specifier|private
name|void
name|assertBlockIndexAndTokenPosition
parameter_list|(
name|List
argument_list|<
name|LocatedBlock
argument_list|>
name|lbs
parameter_list|,
name|List
argument_list|<
name|HashMap
argument_list|<
name|DatanodeInfo
argument_list|,
name|Byte
argument_list|>
argument_list|>
name|locToIndexList
parameter_list|,
name|List
argument_list|<
name|HashMap
argument_list|<
name|DatanodeInfo
argument_list|,
name|Token
argument_list|<
name|BlockTokenIdentifier
argument_list|>
argument_list|>
argument_list|>
name|locToTokenList
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|lbs
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|LocatedBlock
name|lb
init|=
name|lbs
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|LocatedStripedBlock
name|stripedBlk
init|=
operator|(
name|LocatedStripedBlock
operator|)
name|lb
decl_stmt|;
name|HashMap
argument_list|<
name|DatanodeInfo
argument_list|,
name|Byte
argument_list|>
name|locToIndex
init|=
name|locToIndexList
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|HashMap
argument_list|<
name|DatanodeInfo
argument_list|,
name|Token
argument_list|<
name|BlockTokenIdentifier
argument_list|>
argument_list|>
name|locToToken
init|=
name|locToTokenList
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|DatanodeInfo
index|[]
name|di
init|=
name|lb
operator|.
name|getLocations
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|di
operator|.
name|length
condition|;
name|j
operator|++
control|)
block|{
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"Block index value mismatches after sorting"
argument_list|,
operator|(
name|byte
operator|)
name|locToIndex
operator|.
name|get
argument_list|(
name|di
index|[
name|j
index|]
argument_list|)
argument_list|,
name|stripedBlk
operator|.
name|getBlockIndices
argument_list|()
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"Block token value mismatches after sorting"
argument_list|,
name|locToToken
operator|.
name|get
argument_list|(
name|di
index|[
name|j
index|]
argument_list|)
argument_list|,
name|stripedBlk
operator|.
name|getBlockTokens
argument_list|()
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_class

end_unit

