begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.raid
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|raid
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileNotFoundException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Random
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Matcher
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Pattern
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|Thread
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|InetSocketAddress
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URI
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Constructor
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|InvocationTargetException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|xml
operator|.
name|sax
operator|.
name|SAXException
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|parsers
operator|.
name|ParserConfigurationException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|tools
operator|.
name|HadoopArchives
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Daemon
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|ToolRunner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|net
operator|.
name|NetUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|HarFileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|BlockLocation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FSDataInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FSDataOutputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Progressable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|raid
operator|.
name|protocol
operator|.
name|PolicyInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|raid
operator|.
name|protocol
operator|.
name|PolicyList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|raid
operator|.
name|protocol
operator|.
name|RaidProtocol
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|raid
operator|.
name|protocol
operator|.
name|PolicyInfo
operator|.
name|ErasureCodeType
import|;
end_import

begin_comment
comment|/**  * A base class that implements {@link RaidProtocol}.  *  * use raid.classname to specify which implementation to use  */
end_comment

begin_class
DECL|class|RaidNode
specifier|public
specifier|abstract
class|class
name|RaidNode
implements|implements
name|RaidProtocol
block|{
static|static
block|{
name|Configuration
operator|.
name|addDefaultResource
argument_list|(
literal|"hdfs-default.xml"
argument_list|)
expr_stmt|;
name|Configuration
operator|.
name|addDefaultResource
argument_list|(
literal|"hdfs-site.xml"
argument_list|)
expr_stmt|;
name|Configuration
operator|.
name|addDefaultResource
argument_list|(
literal|"mapred-default.xml"
argument_list|)
expr_stmt|;
name|Configuration
operator|.
name|addDefaultResource
argument_list|(
literal|"mapred-site.xml"
argument_list|)
expr_stmt|;
block|}
DECL|field|LOG
specifier|public
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
literal|"org.apache.hadoop.raid.RaidNode"
argument_list|)
decl_stmt|;
DECL|field|SLEEP_TIME
specifier|public
specifier|static
specifier|final
name|long
name|SLEEP_TIME
init|=
literal|10000L
decl_stmt|;
comment|// 10 seconds
DECL|field|TRIGGER_MONITOR_SLEEP_TIME_KEY
specifier|public
specifier|static
specifier|final
name|String
name|TRIGGER_MONITOR_SLEEP_TIME_KEY
init|=
literal|"hdfs.raid.trigger.monitor.sleep.time"
decl_stmt|;
DECL|field|DEFAULT_PORT
specifier|public
specifier|static
specifier|final
name|int
name|DEFAULT_PORT
init|=
literal|60000
decl_stmt|;
comment|// Default stripe length = 5, parity length for RS code = 3
DECL|field|DEFAULT_STRIPE_LENGTH
specifier|public
specifier|static
specifier|final
name|int
name|DEFAULT_STRIPE_LENGTH
init|=
literal|5
decl_stmt|;
DECL|field|RS_PARITY_LENGTH_DEFAULT
specifier|public
specifier|static
specifier|final
name|int
name|RS_PARITY_LENGTH_DEFAULT
init|=
literal|3
decl_stmt|;
DECL|field|RS_PARITY_LENGTH_KEY
specifier|public
specifier|static
specifier|final
name|String
name|RS_PARITY_LENGTH_KEY
init|=
literal|"hdfs.raidrs.paritylength"
decl_stmt|;
DECL|field|STRIPE_LENGTH_KEY
specifier|public
specifier|static
specifier|final
name|String
name|STRIPE_LENGTH_KEY
init|=
literal|"hdfs.raid.stripeLength"
decl_stmt|;
DECL|field|DEFAULT_RAID_LOCATION
specifier|public
specifier|static
specifier|final
name|String
name|DEFAULT_RAID_LOCATION
init|=
literal|"/raid"
decl_stmt|;
DECL|field|RAID_LOCATION_KEY
specifier|public
specifier|static
specifier|final
name|String
name|RAID_LOCATION_KEY
init|=
literal|"hdfs.raid.locations"
decl_stmt|;
DECL|field|DEFAULT_RAID_TMP_LOCATION
specifier|public
specifier|static
specifier|final
name|String
name|DEFAULT_RAID_TMP_LOCATION
init|=
literal|"/tmp/raid"
decl_stmt|;
DECL|field|RAID_TMP_LOCATION_KEY
specifier|public
specifier|static
specifier|final
name|String
name|RAID_TMP_LOCATION_KEY
init|=
literal|"fs.raid.tmpdir"
decl_stmt|;
DECL|field|DEFAULT_RAID_HAR_TMP_LOCATION
specifier|public
specifier|static
specifier|final
name|String
name|DEFAULT_RAID_HAR_TMP_LOCATION
init|=
literal|"/tmp/raid_har"
decl_stmt|;
DECL|field|RAID_HAR_TMP_LOCATION_KEY
specifier|public
specifier|static
specifier|final
name|String
name|RAID_HAR_TMP_LOCATION_KEY
init|=
literal|"fs.raid.hartmpdir"
decl_stmt|;
DECL|field|DEFAULT_RAIDRS_LOCATION
specifier|public
specifier|static
specifier|final
name|String
name|DEFAULT_RAIDRS_LOCATION
init|=
literal|"/raidrs"
decl_stmt|;
DECL|field|RAIDRS_LOCATION_KEY
specifier|public
specifier|static
specifier|final
name|String
name|RAIDRS_LOCATION_KEY
init|=
literal|"hdfs.raidrs.locations"
decl_stmt|;
DECL|field|DEFAULT_RAIDRS_TMP_LOCATION
specifier|public
specifier|static
specifier|final
name|String
name|DEFAULT_RAIDRS_TMP_LOCATION
init|=
literal|"/tmp/raidrs"
decl_stmt|;
DECL|field|RAIDRS_TMP_LOCATION_KEY
specifier|public
specifier|static
specifier|final
name|String
name|RAIDRS_TMP_LOCATION_KEY
init|=
literal|"fs.raidrs.tmpdir"
decl_stmt|;
DECL|field|DEFAULT_RAIDRS_HAR_TMP_LOCATION
specifier|public
specifier|static
specifier|final
name|String
name|DEFAULT_RAIDRS_HAR_TMP_LOCATION
init|=
literal|"/tmp/raidrs_har"
decl_stmt|;
DECL|field|RAIDRS_HAR_TMP_LOCATION_KEY
specifier|public
specifier|static
specifier|final
name|String
name|RAIDRS_HAR_TMP_LOCATION_KEY
init|=
literal|"fs.raidrs.hartmpdir"
decl_stmt|;
DECL|field|HAR_SUFFIX
specifier|public
specifier|static
specifier|final
name|String
name|HAR_SUFFIX
init|=
literal|"_raid.har"
decl_stmt|;
DECL|field|PARITY_HAR_PARTFILE_PATTERN
specifier|public
specifier|static
specifier|final
name|Pattern
name|PARITY_HAR_PARTFILE_PATTERN
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|".*"
operator|+
name|HAR_SUFFIX
operator|+
literal|"/part-.*"
argument_list|)
decl_stmt|;
DECL|field|RAIDNODE_CLASSNAME_KEY
specifier|public
specifier|static
specifier|final
name|String
name|RAIDNODE_CLASSNAME_KEY
init|=
literal|"raid.classname"
decl_stmt|;
comment|/** RPC server */
DECL|field|server
specifier|private
name|Server
name|server
decl_stmt|;
comment|/** RPC server address */
DECL|field|serverAddress
specifier|private
name|InetSocketAddress
name|serverAddress
init|=
literal|null
decl_stmt|;
comment|/** only used for testing purposes  */
DECL|field|stopRequested
specifier|protected
name|boolean
name|stopRequested
init|=
literal|false
decl_stmt|;
comment|/** Configuration Manager */
DECL|field|configMgr
specifier|private
name|ConfigManager
name|configMgr
decl_stmt|;
comment|/** hadoop configuration */
DECL|field|conf
specifier|protected
name|Configuration
name|conf
decl_stmt|;
DECL|field|initialized
specifier|protected
name|boolean
name|initialized
decl_stmt|;
comment|// Are we initialized?
DECL|field|running
specifier|protected
specifier|volatile
name|boolean
name|running
decl_stmt|;
comment|// Are we running?
comment|/** Deamon thread to trigger policies */
DECL|field|triggerThread
name|Daemon
name|triggerThread
init|=
literal|null
decl_stmt|;
DECL|field|triggerMonitorSleepTime
specifier|public
specifier|static
name|long
name|triggerMonitorSleepTime
init|=
name|SLEEP_TIME
decl_stmt|;
comment|/** Deamon thread to delete obsolete parity files */
DECL|field|purgeMonitor
name|PurgeMonitor
name|purgeMonitor
init|=
literal|null
decl_stmt|;
DECL|field|purgeThread
name|Daemon
name|purgeThread
init|=
literal|null
decl_stmt|;
comment|/** Deamon thread to har raid directories */
DECL|field|harThread
name|Daemon
name|harThread
init|=
literal|null
decl_stmt|;
comment|/** Daemon thread to fix corrupt files */
DECL|field|blockFixer
name|BlockFixer
name|blockFixer
init|=
literal|null
decl_stmt|;
DECL|field|blockFixerThread
name|Daemon
name|blockFixerThread
init|=
literal|null
decl_stmt|;
comment|// statistics about RAW hdfs blocks. This counts all replicas of a block.
DECL|class|Statistics
specifier|public
specifier|static
class|class
name|Statistics
block|{
DECL|field|numProcessedBlocks
name|long
name|numProcessedBlocks
decl_stmt|;
comment|// total blocks encountered in namespace
DECL|field|processedSize
name|long
name|processedSize
decl_stmt|;
comment|// disk space occupied by all blocks
DECL|field|remainingSize
name|long
name|remainingSize
decl_stmt|;
comment|// total disk space post RAID
DECL|field|numMetaBlocks
name|long
name|numMetaBlocks
decl_stmt|;
comment|// total blocks in metafile
DECL|field|metaSize
name|long
name|metaSize
decl_stmt|;
comment|// total disk space for meta files
DECL|method|clear ()
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|numProcessedBlocks
operator|=
literal|0
expr_stmt|;
name|processedSize
operator|=
literal|0
expr_stmt|;
name|remainingSize
operator|=
literal|0
expr_stmt|;
name|numMetaBlocks
operator|=
literal|0
expr_stmt|;
name|metaSize
operator|=
literal|0
expr_stmt|;
block|}
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|long
name|save
init|=
name|processedSize
operator|-
operator|(
name|remainingSize
operator|+
name|metaSize
operator|)
decl_stmt|;
name|long
name|savep
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|processedSize
operator|>
literal|0
condition|)
block|{
name|savep
operator|=
operator|(
name|save
operator|*
literal|100
operator|)
operator|/
name|processedSize
expr_stmt|;
block|}
name|String
name|msg
init|=
literal|" numProcessedBlocks = "
operator|+
name|numProcessedBlocks
operator|+
literal|" processedSize = "
operator|+
name|processedSize
operator|+
literal|" postRaidSize = "
operator|+
name|remainingSize
operator|+
literal|" numMetaBlocks = "
operator|+
name|numMetaBlocks
operator|+
literal|" metaSize = "
operator|+
name|metaSize
operator|+
literal|" %save in raw disk space = "
operator|+
name|savep
decl_stmt|;
return|return
name|msg
return|;
block|}
block|}
comment|// Startup options
DECL|enum|StartupOption
specifier|static
specifier|public
enum|enum
name|StartupOption
block|{
DECL|enumConstant|TEST
name|TEST
argument_list|(
literal|"-test"
argument_list|)
block|,
DECL|enumConstant|REGULAR
name|REGULAR
argument_list|(
literal|"-regular"
argument_list|)
block|;
DECL|field|name
specifier|private
name|String
name|name
init|=
literal|null
decl_stmt|;
DECL|method|StartupOption (String arg)
specifier|private
name|StartupOption
parameter_list|(
name|String
name|arg
parameter_list|)
block|{
name|this
operator|.
name|name
operator|=
name|arg
expr_stmt|;
block|}
DECL|method|getName ()
specifier|public
name|String
name|getName
parameter_list|()
block|{
return|return
name|name
return|;
block|}
block|}
comment|/**    * Start RaidNode.    *<p>    * The raid-node can be started with one of the following startup options:    *<ul>     *<li>{@link StartupOption#REGULAR REGULAR} - normal raid node startup</li>    *</ul>    * The option is passed via configuration field:     *<tt>fs.raidnode.startup</tt>    *     * The conf will be modified to reflect the actual ports on which     * the RaidNode is up and running if the user passes the port as    *<code>zero</code> in the conf.    *     * @param conf  confirguration    * @throws IOException    */
DECL|method|RaidNode (Configuration conf)
name|RaidNode
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
name|initialize
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|stop
argument_list|()
expr_stmt|;
throw|throw
name|e
throw|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|this
operator|.
name|stop
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
DECL|method|getProtocolVersion (String protocol, long clientVersion)
specifier|public
name|long
name|getProtocolVersion
parameter_list|(
name|String
name|protocol
parameter_list|,
name|long
name|clientVersion
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|protocol
operator|.
name|equals
argument_list|(
name|RaidProtocol
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|RaidProtocol
operator|.
name|versionID
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unknown protocol to name node: "
operator|+
name|protocol
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
DECL|method|getProtocolSignature (String protocol, long clientVersion, int clientMethodsHash)
specifier|public
name|ProtocolSignature
name|getProtocolSignature
parameter_list|(
name|String
name|protocol
parameter_list|,
name|long
name|clientVersion
parameter_list|,
name|int
name|clientMethodsHash
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|ProtocolSignature
operator|.
name|getProtocolSignature
argument_list|(
name|this
argument_list|,
name|protocol
argument_list|,
name|clientVersion
argument_list|,
name|clientMethodsHash
argument_list|)
return|;
block|}
comment|/**    * Wait for service to finish.    * (Normally, it runs forever.)    */
DECL|method|join ()
specifier|public
name|void
name|join
parameter_list|()
block|{
try|try
block|{
if|if
condition|(
name|server
operator|!=
literal|null
condition|)
name|server
operator|.
name|join
argument_list|()
expr_stmt|;
if|if
condition|(
name|triggerThread
operator|!=
literal|null
condition|)
name|triggerThread
operator|.
name|join
argument_list|()
expr_stmt|;
if|if
condition|(
name|blockFixerThread
operator|!=
literal|null
condition|)
name|blockFixerThread
operator|.
name|join
argument_list|()
expr_stmt|;
if|if
condition|(
name|purgeThread
operator|!=
literal|null
condition|)
name|purgeThread
operator|.
name|join
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
comment|// do nothing
block|}
block|}
comment|/**    * Stop all RaidNode threads and wait for all to finish.    */
DECL|method|stop ()
specifier|public
name|void
name|stop
parameter_list|()
block|{
if|if
condition|(
name|stopRequested
condition|)
block|{
return|return;
block|}
name|stopRequested
operator|=
literal|true
expr_stmt|;
name|running
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|server
operator|!=
literal|null
condition|)
name|server
operator|.
name|stop
argument_list|()
expr_stmt|;
if|if
condition|(
name|triggerThread
operator|!=
literal|null
condition|)
name|triggerThread
operator|.
name|interrupt
argument_list|()
expr_stmt|;
if|if
condition|(
name|blockFixer
operator|!=
literal|null
condition|)
name|blockFixer
operator|.
name|running
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|blockFixerThread
operator|!=
literal|null
condition|)
name|blockFixerThread
operator|.
name|interrupt
argument_list|()
expr_stmt|;
if|if
condition|(
name|purgeThread
operator|!=
literal|null
condition|)
name|purgeThread
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
DECL|method|getAddress (String address)
specifier|private
specifier|static
name|InetSocketAddress
name|getAddress
parameter_list|(
name|String
name|address
parameter_list|)
block|{
return|return
name|NetUtils
operator|.
name|createSocketAddr
argument_list|(
name|address
argument_list|)
return|;
block|}
DECL|method|getAddress (Configuration conf)
specifier|public
specifier|static
name|InetSocketAddress
name|getAddress
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
name|String
name|nodeport
init|=
name|conf
operator|.
name|get
argument_list|(
literal|"raid.server.address"
argument_list|)
decl_stmt|;
if|if
condition|(
name|nodeport
operator|==
literal|null
condition|)
block|{
name|nodeport
operator|=
literal|"localhost:"
operator|+
name|DEFAULT_PORT
expr_stmt|;
block|}
return|return
name|getAddress
argument_list|(
name|nodeport
argument_list|)
return|;
block|}
DECL|method|getListenerAddress ()
specifier|public
name|InetSocketAddress
name|getListenerAddress
parameter_list|()
block|{
return|return
name|server
operator|.
name|getListenerAddress
argument_list|()
return|;
block|}
DECL|method|initialize (Configuration conf)
specifier|private
name|void
name|initialize
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
throws|,
name|SAXException
throws|,
name|InterruptedException
throws|,
name|RaidConfigurationException
throws|,
name|ClassNotFoundException
throws|,
name|ParserConfigurationException
block|{
name|this
operator|.
name|conf
operator|=
name|conf
expr_stmt|;
name|InetSocketAddress
name|socAddr
init|=
name|RaidNode
operator|.
name|getAddress
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|int
name|handlerCount
init|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"fs.raidnode.handler.count"
argument_list|,
literal|10
argument_list|)
decl_stmt|;
comment|// read in the configuration
name|configMgr
operator|=
operator|new
name|ConfigManager
argument_list|(
name|conf
argument_list|)
expr_stmt|;
comment|// create rpc server
name|this
operator|.
name|server
operator|=
name|RPC
operator|.
name|getServer
argument_list|(
name|this
argument_list|,
name|socAddr
operator|.
name|getHostName
argument_list|()
argument_list|,
name|socAddr
operator|.
name|getPort
argument_list|()
argument_list|,
name|handlerCount
argument_list|,
literal|false
argument_list|,
name|conf
argument_list|)
expr_stmt|;
comment|// The rpc-server port can be ephemeral... ensure we have the correct info
name|this
operator|.
name|serverAddress
operator|=
name|this
operator|.
name|server
operator|.
name|getListenerAddress
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"RaidNode up at: "
operator|+
name|this
operator|.
name|serverAddress
argument_list|)
expr_stmt|;
name|initialized
operator|=
literal|true
expr_stmt|;
name|running
operator|=
literal|true
expr_stmt|;
name|this
operator|.
name|server
operator|.
name|start
argument_list|()
expr_stmt|;
comment|// start RPC server
name|this
operator|.
name|blockFixer
operator|=
name|BlockFixer
operator|.
name|createBlockFixer
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|blockFixerThread
operator|=
operator|new
name|Daemon
argument_list|(
name|this
operator|.
name|blockFixer
argument_list|)
expr_stmt|;
name|this
operator|.
name|blockFixerThread
operator|.
name|start
argument_list|()
expr_stmt|;
comment|// start the deamon thread to fire polcies appropriately
name|RaidNode
operator|.
name|triggerMonitorSleepTime
operator|=
name|conf
operator|.
name|getLong
argument_list|(
name|TRIGGER_MONITOR_SLEEP_TIME_KEY
argument_list|,
name|SLEEP_TIME
argument_list|)
expr_stmt|;
comment|// start the deamon thread to fire polcies appropriately
name|this
operator|.
name|triggerThread
operator|=
operator|new
name|Daemon
argument_list|(
operator|new
name|TriggerMonitor
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|triggerThread
operator|.
name|start
argument_list|()
expr_stmt|;
comment|// start the thread that deletes obsolete parity files
name|this
operator|.
name|purgeMonitor
operator|=
operator|new
name|PurgeMonitor
argument_list|()
expr_stmt|;
name|this
operator|.
name|purgeThread
operator|=
operator|new
name|Daemon
argument_list|(
name|purgeMonitor
argument_list|)
expr_stmt|;
name|this
operator|.
name|purgeThread
operator|.
name|start
argument_list|()
expr_stmt|;
comment|// start the thread that creates HAR files
name|this
operator|.
name|harThread
operator|=
operator|new
name|Daemon
argument_list|(
operator|new
name|HarMonitor
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|harThread
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
comment|/**    * Implement RaidProtocol methods    */
comment|/** {@inheritDoc} */
DECL|method|getAllPolicies ()
specifier|public
name|PolicyList
index|[]
name|getAllPolicies
parameter_list|()
throws|throws
name|IOException
block|{
name|Collection
argument_list|<
name|PolicyList
argument_list|>
name|list
init|=
name|configMgr
operator|.
name|getAllPolicies
argument_list|()
decl_stmt|;
return|return
name|list
operator|.
name|toArray
argument_list|(
operator|new
name|PolicyList
index|[
name|list
operator|.
name|size
argument_list|()
index|]
argument_list|)
return|;
block|}
comment|/** {@inheritDoc} */
DECL|method|recoverFile (String inStr, long corruptOffset)
specifier|public
name|String
name|recoverFile
parameter_list|(
name|String
name|inStr
parameter_list|,
name|long
name|corruptOffset
parameter_list|)
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Recover File for "
operator|+
name|inStr
operator|+
literal|" for corrupt offset "
operator|+
name|corruptOffset
argument_list|)
expr_stmt|;
name|Path
name|inputPath
init|=
operator|new
name|Path
argument_list|(
name|inStr
argument_list|)
decl_stmt|;
name|Path
name|srcPath
init|=
name|inputPath
operator|.
name|makeQualified
argument_list|(
name|inputPath
operator|.
name|getFileSystem
argument_list|(
name|conf
argument_list|)
argument_list|)
decl_stmt|;
comment|// find stripe length from config
name|int
name|stripeLength
init|=
name|getStripeLength
argument_list|(
name|conf
argument_list|)
decl_stmt|;
comment|// first try decode using XOR code
name|Path
name|destPref
init|=
name|xorDestinationPath
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|Decoder
name|decoder
init|=
operator|new
name|XORDecoder
argument_list|(
name|conf
argument_list|,
name|RaidNode
operator|.
name|getStripeLength
argument_list|(
name|conf
argument_list|)
argument_list|)
decl_stmt|;
name|Path
name|unraided
init|=
name|unRaid
argument_list|(
name|conf
argument_list|,
name|srcPath
argument_list|,
name|destPref
argument_list|,
name|decoder
argument_list|,
name|stripeLength
argument_list|,
name|corruptOffset
argument_list|)
decl_stmt|;
if|if
condition|(
name|unraided
operator|!=
literal|null
condition|)
block|{
return|return
name|unraided
operator|.
name|toString
argument_list|()
return|;
block|}
comment|// try decode using ReedSolomon code
name|destPref
operator|=
name|rsDestinationPath
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|decoder
operator|=
operator|new
name|ReedSolomonDecoder
argument_list|(
name|conf
argument_list|,
name|RaidNode
operator|.
name|getStripeLength
argument_list|(
name|conf
argument_list|)
argument_list|,
name|RaidNode
operator|.
name|rsParityLength
argument_list|(
name|conf
argument_list|)
argument_list|)
expr_stmt|;
name|unraided
operator|=
name|unRaid
argument_list|(
name|conf
argument_list|,
name|srcPath
argument_list|,
name|destPref
argument_list|,
name|decoder
argument_list|,
name|stripeLength
argument_list|,
name|corruptOffset
argument_list|)
expr_stmt|;
if|if
condition|(
name|unraided
operator|!=
literal|null
condition|)
block|{
return|return
name|unraided
operator|.
name|toString
argument_list|()
return|;
block|}
return|return
literal|null
return|;
block|}
comment|/**    * returns the number of raid jobs running for a particular policy    */
DECL|method|getRunningJobsForPolicy (String policyName)
specifier|abstract
name|int
name|getRunningJobsForPolicy
parameter_list|(
name|String
name|policyName
parameter_list|)
function_decl|;
comment|/**    * Periodically checks to see which policies should be fired.    */
DECL|class|TriggerMonitor
class|class
name|TriggerMonitor
implements|implements
name|Runnable
block|{
DECL|class|ScanState
class|class
name|ScanState
block|{
DECL|field|fullScanStartTime
name|long
name|fullScanStartTime
decl_stmt|;
DECL|field|pendingTraversal
name|DirectoryTraversal
name|pendingTraversal
decl_stmt|;
DECL|field|stats
name|RaidFilter
operator|.
name|Statistics
name|stats
decl_stmt|;
DECL|method|ScanState ()
name|ScanState
parameter_list|()
block|{
name|fullScanStartTime
operator|=
literal|0
expr_stmt|;
name|pendingTraversal
operator|=
literal|null
expr_stmt|;
name|stats
operator|=
operator|new
name|RaidFilter
operator|.
name|Statistics
argument_list|()
expr_stmt|;
block|}
block|}
DECL|field|scanStateMap
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|ScanState
argument_list|>
name|scanStateMap
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|ScanState
argument_list|>
argument_list|()
decl_stmt|;
comment|/**      */
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
while|while
condition|(
name|running
condition|)
block|{
try|try
block|{
name|doProcess
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Trigger thread continuing to run..."
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Should we select more files for a policy.      */
DECL|method|shouldSelectFiles (PolicyInfo info)
specifier|private
name|boolean
name|shouldSelectFiles
parameter_list|(
name|PolicyInfo
name|info
parameter_list|)
block|{
name|String
name|policyName
init|=
name|info
operator|.
name|getName
argument_list|()
decl_stmt|;
name|ScanState
name|scanState
init|=
name|scanStateMap
operator|.
name|get
argument_list|(
name|policyName
argument_list|)
decl_stmt|;
name|int
name|runningJobsCount
init|=
name|getRunningJobsForPolicy
argument_list|(
name|policyName
argument_list|)
decl_stmt|;
comment|// Is there a scan in progress for this policy?
if|if
condition|(
name|scanState
operator|.
name|pendingTraversal
operator|!=
literal|null
condition|)
block|{
name|int
name|maxJobsPerPolicy
init|=
name|configMgr
operator|.
name|getMaxJobsPerPolicy
argument_list|()
decl_stmt|;
comment|// If there is a scan in progress for this policy, we can have
comment|// upto maxJobsPerPolicy running jobs.
return|return
operator|(
name|runningJobsCount
operator|<
name|maxJobsPerPolicy
operator|)
return|;
block|}
else|else
block|{
comment|// If there isn't a scan in progress for this policy, we don't
comment|// want to start a fresh scan if there is even one running job.
if|if
condition|(
name|runningJobsCount
operator|>=
literal|1
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// Check the time of the last full traversal before starting a fresh
comment|// traversal.
name|long
name|lastScan
init|=
name|scanState
operator|.
name|fullScanStartTime
decl_stmt|;
return|return
operator|(
name|now
argument_list|()
operator|>
name|lastScan
operator|+
name|configMgr
operator|.
name|getPeriodicity
argument_list|()
operator|)
return|;
block|}
block|}
comment|/**     * Returns a list of pathnames that needs raiding.     * The list of paths could be obtained by resuming a previously suspended     * traversal.     * The number of paths returned is limited by raid.distraid.max.jobs.     */
DECL|method|selectFiles ( PolicyInfo info, ArrayList<PolicyInfo> allPolicies)
specifier|private
name|List
argument_list|<
name|FileStatus
argument_list|>
name|selectFiles
parameter_list|(
name|PolicyInfo
name|info
parameter_list|,
name|ArrayList
argument_list|<
name|PolicyInfo
argument_list|>
name|allPolicies
parameter_list|)
throws|throws
name|IOException
block|{
name|Path
name|destPrefix
init|=
name|getDestinationPath
argument_list|(
name|info
operator|.
name|getErasureCode
argument_list|()
argument_list|,
name|conf
argument_list|)
decl_stmt|;
name|String
name|policyName
init|=
name|info
operator|.
name|getName
argument_list|()
decl_stmt|;
name|Path
name|srcPath
init|=
name|info
operator|.
name|getSrcPath
argument_list|()
decl_stmt|;
name|long
name|modTimePeriod
init|=
name|Long
operator|.
name|parseLong
argument_list|(
name|info
operator|.
name|getProperty
argument_list|(
literal|"modTimePeriod"
argument_list|)
argument_list|)
decl_stmt|;
comment|// Max number of files returned.
name|int
name|selectLimit
init|=
name|configMgr
operator|.
name|getMaxFilesPerJob
argument_list|()
decl_stmt|;
name|int
name|targetRepl
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|info
operator|.
name|getProperty
argument_list|(
literal|"targetReplication"
argument_list|)
argument_list|)
decl_stmt|;
name|long
name|selectStartTime
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|ScanState
name|scanState
init|=
name|scanStateMap
operator|.
name|get
argument_list|(
name|policyName
argument_list|)
decl_stmt|;
comment|// If we have a pending traversal, resume it.
if|if
condition|(
name|scanState
operator|.
name|pendingTraversal
operator|!=
literal|null
condition|)
block|{
name|DirectoryTraversal
name|dt
init|=
name|scanState
operator|.
name|pendingTraversal
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Resuming traversal for policy "
operator|+
name|policyName
argument_list|)
expr_stmt|;
name|DirectoryTraversal
operator|.
name|FileFilter
name|filter
init|=
name|filterForPolicy
argument_list|(
name|selectStartTime
argument_list|,
name|info
argument_list|,
name|allPolicies
argument_list|,
name|scanState
operator|.
name|stats
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|FileStatus
argument_list|>
name|returnSet
init|=
name|dt
operator|.
name|getFilteredFiles
argument_list|(
name|filter
argument_list|,
name|selectLimit
argument_list|)
decl_stmt|;
if|if
condition|(
name|dt
operator|.
name|doneTraversal
argument_list|()
condition|)
block|{
name|scanState
operator|.
name|pendingTraversal
operator|=
literal|null
expr_stmt|;
block|}
return|return
name|returnSet
return|;
block|}
comment|// Expand destination prefix path.
name|String
name|destpstr
init|=
name|destPrefix
operator|.
name|toString
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|destpstr
operator|.
name|endsWith
argument_list|(
name|Path
operator|.
name|SEPARATOR
argument_list|)
condition|)
block|{
name|destpstr
operator|+=
name|Path
operator|.
name|SEPARATOR
expr_stmt|;
block|}
name|List
argument_list|<
name|FileStatus
argument_list|>
name|returnSet
init|=
operator|new
name|LinkedList
argument_list|<
name|FileStatus
argument_list|>
argument_list|()
decl_stmt|;
name|FileSystem
name|fs
init|=
name|srcPath
operator|.
name|getFileSystem
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|FileStatus
index|[]
name|gpaths
init|=
name|fs
operator|.
name|globStatus
argument_list|(
name|srcPath
argument_list|)
decl_stmt|;
if|if
condition|(
name|gpaths
operator|!=
literal|null
condition|)
block|{
name|List
argument_list|<
name|FileStatus
argument_list|>
name|selectedPaths
init|=
operator|new
name|LinkedList
argument_list|<
name|FileStatus
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|FileStatus
name|onepath
range|:
name|gpaths
control|)
block|{
name|String
name|pathstr
init|=
name|onepath
operator|.
name|getPath
argument_list|()
operator|.
name|makeQualified
argument_list|(
name|fs
argument_list|)
operator|.
name|toString
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|pathstr
operator|.
name|endsWith
argument_list|(
name|Path
operator|.
name|SEPARATOR
argument_list|)
condition|)
block|{
name|pathstr
operator|+=
name|Path
operator|.
name|SEPARATOR
expr_stmt|;
block|}
if|if
condition|(
name|pathstr
operator|.
name|startsWith
argument_list|(
name|destpstr
argument_list|)
operator|||
name|destpstr
operator|.
name|startsWith
argument_list|(
name|pathstr
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Skipping source "
operator|+
name|pathstr
operator|+
literal|" because it conflicts with raid directory "
operator|+
name|destpstr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|selectedPaths
operator|.
name|add
argument_list|(
name|onepath
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Set the time for a new traversal.
name|scanState
operator|.
name|fullScanStartTime
operator|=
name|now
argument_list|()
expr_stmt|;
name|DirectoryTraversal
name|dt
init|=
operator|new
name|DirectoryTraversal
argument_list|(
name|fs
argument_list|,
name|selectedPaths
argument_list|,
name|conf
operator|.
name|getInt
argument_list|(
literal|"raid.directorytraversal.threads"
argument_list|,
literal|4
argument_list|)
argument_list|)
decl_stmt|;
name|DirectoryTraversal
operator|.
name|FileFilter
name|filter
init|=
name|filterForPolicy
argument_list|(
name|selectStartTime
argument_list|,
name|info
argument_list|,
name|allPolicies
argument_list|,
name|scanState
operator|.
name|stats
argument_list|)
decl_stmt|;
name|returnSet
operator|=
name|dt
operator|.
name|getFilteredFiles
argument_list|(
name|filter
argument_list|,
name|selectLimit
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dt
operator|.
name|doneTraversal
argument_list|()
condition|)
block|{
name|scanState
operator|.
name|pendingTraversal
operator|=
name|dt
expr_stmt|;
block|}
block|}
return|return
name|returnSet
return|;
block|}
comment|/**      * Keep processing policies.      * If the config file has changed, then reload config file and start afresh.      */
DECL|method|doProcess ()
specifier|private
name|void
name|doProcess
parameter_list|()
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|ArrayList
argument_list|<
name|PolicyInfo
argument_list|>
name|allPolicies
init|=
operator|new
name|ArrayList
argument_list|<
name|PolicyInfo
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|PolicyList
name|category
range|:
name|configMgr
operator|.
name|getAllPolicies
argument_list|()
control|)
block|{
for|for
control|(
name|PolicyInfo
name|info
range|:
name|category
operator|.
name|getAll
argument_list|()
control|)
block|{
name|allPolicies
operator|.
name|add
argument_list|(
name|info
argument_list|)
expr_stmt|;
block|}
block|}
while|while
condition|(
name|running
condition|)
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|RaidNode
operator|.
name|triggerMonitorSleepTime
argument_list|)
expr_stmt|;
name|boolean
name|reloaded
init|=
name|configMgr
operator|.
name|reloadConfigsIfNecessary
argument_list|()
decl_stmt|;
if|if
condition|(
name|reloaded
condition|)
block|{
name|allPolicies
operator|.
name|clear
argument_list|()
expr_stmt|;
for|for
control|(
name|PolicyList
name|category
range|:
name|configMgr
operator|.
name|getAllPolicies
argument_list|()
control|)
block|{
for|for
control|(
name|PolicyInfo
name|info
range|:
name|category
operator|.
name|getAll
argument_list|()
control|)
block|{
name|allPolicies
operator|.
name|add
argument_list|(
name|info
argument_list|)
expr_stmt|;
block|}
block|}
block|}
for|for
control|(
name|PolicyInfo
name|info
range|:
name|allPolicies
control|)
block|{
if|if
condition|(
operator|!
name|scanStateMap
operator|.
name|containsKey
argument_list|(
name|info
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
name|scanStateMap
operator|.
name|put
argument_list|(
name|info
operator|.
name|getName
argument_list|()
argument_list|,
operator|new
name|ScanState
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|shouldSelectFiles
argument_list|(
name|info
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Triggering Policy Filter "
operator|+
name|info
operator|.
name|getName
argument_list|()
operator|+
literal|" "
operator|+
name|info
operator|.
name|getSrcPath
argument_list|()
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|FileStatus
argument_list|>
name|filteredPaths
init|=
literal|null
decl_stmt|;
try|try
block|{
name|filteredPaths
operator|=
name|selectFiles
argument_list|(
name|info
argument_list|,
name|allPolicies
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Exception while invoking filter on policy "
operator|+
name|info
operator|.
name|getName
argument_list|()
operator|+
literal|" srcPath "
operator|+
name|info
operator|.
name|getSrcPath
argument_list|()
operator|+
literal|" exception "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|filteredPaths
operator|==
literal|null
operator|||
name|filteredPaths
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"No filtered paths for policy "
operator|+
name|info
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|// Apply the action on accepted paths
name|LOG
operator|.
name|info
argument_list|(
literal|"Triggering Policy Action "
operator|+
name|info
operator|.
name|getName
argument_list|()
operator|+
literal|" "
operator|+
name|info
operator|.
name|getSrcPath
argument_list|()
operator|+
literal|" raid "
operator|+
name|filteredPaths
operator|.
name|size
argument_list|()
operator|+
literal|" files"
argument_list|)
expr_stmt|;
try|try
block|{
name|raidFiles
argument_list|(
name|info
argument_list|,
name|filteredPaths
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Exception while invoking action on policy "
operator|+
name|info
operator|.
name|getName
argument_list|()
operator|+
literal|" srcPath "
operator|+
name|info
operator|.
name|getSrcPath
argument_list|()
operator|+
literal|" exception "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
block|}
block|}
DECL|method|filterForPolicy ( long startTime, PolicyInfo info, List<PolicyInfo> allPolicies, RaidFilter.Statistics stats)
name|DirectoryTraversal
operator|.
name|FileFilter
name|filterForPolicy
parameter_list|(
name|long
name|startTime
parameter_list|,
name|PolicyInfo
name|info
parameter_list|,
name|List
argument_list|<
name|PolicyInfo
argument_list|>
name|allPolicies
parameter_list|,
name|RaidFilter
operator|.
name|Statistics
name|stats
parameter_list|)
throws|throws
name|IOException
block|{
switch|switch
condition|(
name|info
operator|.
name|getErasureCode
argument_list|()
condition|)
block|{
case|case
name|XOR
case|:
comment|// Return a preference-based filter that prefers RS parity files
comment|// over XOR parity files.
return|return
operator|new
name|RaidFilter
operator|.
name|PreferenceFilter
argument_list|(
name|conf
argument_list|,
name|rsDestinationPath
argument_list|(
name|conf
argument_list|)
argument_list|,
name|xorDestinationPath
argument_list|(
name|conf
argument_list|)
argument_list|,
name|info
argument_list|,
name|allPolicies
argument_list|,
name|startTime
argument_list|,
name|stats
argument_list|)
return|;
case|case
name|RS
case|:
return|return
operator|new
name|RaidFilter
operator|.
name|TimeBasedFilter
argument_list|(
name|conf
argument_list|,
name|rsDestinationPath
argument_list|(
name|conf
argument_list|)
argument_list|,
name|info
argument_list|,
name|allPolicies
argument_list|,
name|startTime
argument_list|,
name|stats
argument_list|)
return|;
default|default:
return|return
literal|null
return|;
block|}
block|}
block|}
comment|/**    * raid a list of files, this will be overridden by subclasses of RaidNode    */
DECL|method|raidFiles (PolicyInfo info, List<FileStatus> paths)
specifier|abstract
name|void
name|raidFiles
parameter_list|(
name|PolicyInfo
name|info
parameter_list|,
name|List
argument_list|<
name|FileStatus
argument_list|>
name|paths
parameter_list|)
throws|throws
name|IOException
function_decl|;
DECL|method|getOriginalParityFile (Path destPathPrefix, Path srcPath)
specifier|static
specifier|private
name|Path
name|getOriginalParityFile
parameter_list|(
name|Path
name|destPathPrefix
parameter_list|,
name|Path
name|srcPath
parameter_list|)
block|{
return|return
operator|new
name|Path
argument_list|(
name|destPathPrefix
argument_list|,
name|makeRelative
argument_list|(
name|srcPath
argument_list|)
argument_list|)
return|;
block|}
DECL|class|ParityFilePair
specifier|static
class|class
name|ParityFilePair
block|{
DECL|field|path
specifier|private
name|Path
name|path
decl_stmt|;
DECL|field|fs
specifier|private
name|FileSystem
name|fs
decl_stmt|;
DECL|method|ParityFilePair ( Path path, FileSystem fs)
specifier|public
name|ParityFilePair
parameter_list|(
name|Path
name|path
parameter_list|,
name|FileSystem
name|fs
parameter_list|)
block|{
name|this
operator|.
name|path
operator|=
name|path
expr_stmt|;
name|this
operator|.
name|fs
operator|=
name|fs
expr_stmt|;
block|}
DECL|method|getPath ()
specifier|public
name|Path
name|getPath
parameter_list|()
block|{
return|return
name|this
operator|.
name|path
return|;
block|}
DECL|method|getFileSystem ()
specifier|public
name|FileSystem
name|getFileSystem
parameter_list|()
block|{
return|return
name|this
operator|.
name|fs
return|;
block|}
block|}
comment|/**    * Returns the Path to the parity file of a given file    *     * @param destPathPrefix Destination prefix defined by some policy    * @param srcPath Path to the original source file    * @param create Boolean value telling whether a new parity file should be created    * @return Path object representing the parity file of the source    * @throws IOException    */
DECL|method|getParityFile (Path destPathPrefix, Path srcPath, Configuration conf)
specifier|static
name|ParityFilePair
name|getParityFile
parameter_list|(
name|Path
name|destPathPrefix
parameter_list|,
name|Path
name|srcPath
parameter_list|,
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|Path
name|srcParent
init|=
name|srcPath
operator|.
name|getParent
argument_list|()
decl_stmt|;
name|FileSystem
name|fsDest
init|=
name|destPathPrefix
operator|.
name|getFileSystem
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|FileSystem
name|fsSrc
init|=
name|srcPath
operator|.
name|getFileSystem
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|FileStatus
name|srcStatus
init|=
literal|null
decl_stmt|;
try|try
block|{
name|srcStatus
operator|=
name|fsSrc
operator|.
name|getFileStatus
argument_list|(
name|srcPath
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|java
operator|.
name|io
operator|.
name|FileNotFoundException
name|e
parameter_list|)
block|{
return|return
literal|null
return|;
block|}
name|Path
name|outDir
init|=
name|destPathPrefix
decl_stmt|;
if|if
condition|(
name|srcParent
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|srcParent
operator|.
name|getParent
argument_list|()
operator|==
literal|null
condition|)
block|{
name|outDir
operator|=
name|destPathPrefix
expr_stmt|;
block|}
else|else
block|{
name|outDir
operator|=
operator|new
name|Path
argument_list|(
name|destPathPrefix
argument_list|,
name|makeRelative
argument_list|(
name|srcParent
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|//CASE 1: CHECK HAR - Must be checked first because har is created after
comment|// parity file and returning the parity file could result in error while
comment|// reading it.
name|Path
name|outPath
init|=
name|getOriginalParityFile
argument_list|(
name|destPathPrefix
argument_list|,
name|srcPath
argument_list|)
decl_stmt|;
name|String
name|harDirName
init|=
name|srcParent
operator|.
name|getName
argument_list|()
operator|+
name|HAR_SUFFIX
decl_stmt|;
name|Path
name|HarPath
init|=
operator|new
name|Path
argument_list|(
name|outDir
argument_list|,
name|harDirName
argument_list|)
decl_stmt|;
if|if
condition|(
name|fsDest
operator|.
name|exists
argument_list|(
name|HarPath
argument_list|)
condition|)
block|{
name|URI
name|HarPathUri
init|=
name|HarPath
operator|.
name|toUri
argument_list|()
decl_stmt|;
name|Path
name|inHarPath
init|=
operator|new
name|Path
argument_list|(
literal|"har://"
argument_list|,
name|HarPathUri
operator|.
name|getPath
argument_list|()
operator|+
literal|"/"
operator|+
name|outPath
operator|.
name|toUri
argument_list|()
operator|.
name|getPath
argument_list|()
argument_list|)
decl_stmt|;
name|FileSystem
name|fsHar
init|=
operator|new
name|HarFileSystem
argument_list|(
name|fsDest
argument_list|)
decl_stmt|;
name|fsHar
operator|.
name|initialize
argument_list|(
name|inHarPath
operator|.
name|toUri
argument_list|()
argument_list|,
name|conf
argument_list|)
expr_stmt|;
if|if
condition|(
name|fsHar
operator|.
name|exists
argument_list|(
name|inHarPath
argument_list|)
condition|)
block|{
name|FileStatus
name|inHar
init|=
name|fsHar
operator|.
name|getFileStatus
argument_list|(
name|inHarPath
argument_list|)
decl_stmt|;
if|if
condition|(
name|inHar
operator|.
name|getModificationTime
argument_list|()
operator|==
name|srcStatus
operator|.
name|getModificationTime
argument_list|()
condition|)
block|{
return|return
operator|new
name|ParityFilePair
argument_list|(
name|inHarPath
argument_list|,
name|fsHar
argument_list|)
return|;
block|}
block|}
block|}
comment|//CASE 2: CHECK PARITY
try|try
block|{
name|FileStatus
name|outHar
init|=
name|fsDest
operator|.
name|getFileStatus
argument_list|(
name|outPath
argument_list|)
decl_stmt|;
if|if
condition|(
name|outHar
operator|.
name|getModificationTime
argument_list|()
operator|==
name|srcStatus
operator|.
name|getModificationTime
argument_list|()
condition|)
block|{
return|return
operator|new
name|ParityFilePair
argument_list|(
name|outPath
argument_list|,
name|fsDest
argument_list|)
return|;
block|}
block|}
catch|catch
parameter_list|(
name|java
operator|.
name|io
operator|.
name|FileNotFoundException
name|e
parameter_list|)
block|{     }
return|return
literal|null
return|;
comment|// NULL if no parity file
block|}
DECL|method|xorParityForSource (Path srcPath, Configuration conf)
specifier|static
name|ParityFilePair
name|xorParityForSource
parameter_list|(
name|Path
name|srcPath
parameter_list|,
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
name|Path
name|destPath
init|=
name|xorDestinationPath
argument_list|(
name|conf
argument_list|)
decl_stmt|;
return|return
name|getParityFile
argument_list|(
name|destPath
argument_list|,
name|srcPath
argument_list|,
name|conf
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|e
parameter_list|)
block|{     }
return|return
literal|null
return|;
block|}
DECL|method|rsParityForSource (Path srcPath, Configuration conf)
specifier|static
name|ParityFilePair
name|rsParityForSource
parameter_list|(
name|Path
name|srcPath
parameter_list|,
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
name|Path
name|destPath
init|=
name|rsDestinationPath
argument_list|(
name|conf
argument_list|)
decl_stmt|;
return|return
name|getParityFile
argument_list|(
name|destPath
argument_list|,
name|srcPath
argument_list|,
name|conf
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|e
parameter_list|)
block|{     }
return|return
literal|null
return|;
block|}
DECL|method|getParityFile (Path destPathPrefix, Path srcPath)
specifier|private
name|ParityFilePair
name|getParityFile
parameter_list|(
name|Path
name|destPathPrefix
parameter_list|,
name|Path
name|srcPath
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|getParityFile
argument_list|(
name|destPathPrefix
argument_list|,
name|srcPath
argument_list|,
name|conf
argument_list|)
return|;
block|}
comment|/**    * RAID a list of files.    */
DECL|method|doRaid (Configuration conf, PolicyInfo info, List<FileStatus> paths)
name|void
name|doRaid
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|PolicyInfo
name|info
parameter_list|,
name|List
argument_list|<
name|FileStatus
argument_list|>
name|paths
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|targetRepl
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|info
operator|.
name|getProperty
argument_list|(
literal|"targetReplication"
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|metaRepl
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|info
operator|.
name|getProperty
argument_list|(
literal|"metaReplication"
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|stripeLength
init|=
name|getStripeLength
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|Path
name|destPref
init|=
name|getDestinationPath
argument_list|(
name|info
operator|.
name|getErasureCode
argument_list|()
argument_list|,
name|conf
argument_list|)
decl_stmt|;
name|String
name|simulate
init|=
name|info
operator|.
name|getProperty
argument_list|(
literal|"simulate"
argument_list|)
decl_stmt|;
name|boolean
name|doSimulate
init|=
name|simulate
operator|==
literal|null
condition|?
literal|false
else|:
name|Boolean
operator|.
name|parseBoolean
argument_list|(
name|simulate
argument_list|)
decl_stmt|;
name|Statistics
name|statistics
init|=
operator|new
name|Statistics
argument_list|()
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
for|for
control|(
name|FileStatus
name|s
range|:
name|paths
control|)
block|{
name|doRaid
argument_list|(
name|conf
argument_list|,
name|s
argument_list|,
name|destPref
argument_list|,
name|info
operator|.
name|getErasureCode
argument_list|()
argument_list|,
name|statistics
argument_list|,
operator|new
name|RaidUtils
operator|.
name|DummyProgressable
argument_list|()
argument_list|,
name|doSimulate
argument_list|,
name|targetRepl
argument_list|,
name|metaRepl
argument_list|,
name|stripeLength
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|%
literal|1000
operator|==
literal|0
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"RAID statistics "
operator|+
name|statistics
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|count
operator|++
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"RAID statistics "
operator|+
name|statistics
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * RAID an individual file    */
DECL|method|doRaid (Configuration conf, PolicyInfo info, FileStatus src, Statistics statistics, Progressable reporter)
specifier|static
specifier|public
name|void
name|doRaid
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|PolicyInfo
name|info
parameter_list|,
name|FileStatus
name|src
parameter_list|,
name|Statistics
name|statistics
parameter_list|,
name|Progressable
name|reporter
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|targetRepl
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|info
operator|.
name|getProperty
argument_list|(
literal|"targetReplication"
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|metaRepl
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|info
operator|.
name|getProperty
argument_list|(
literal|"metaReplication"
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|stripeLength
init|=
name|getStripeLength
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|Path
name|destPref
init|=
name|getDestinationPath
argument_list|(
name|info
operator|.
name|getErasureCode
argument_list|()
argument_list|,
name|conf
argument_list|)
decl_stmt|;
name|String
name|simulate
init|=
name|info
operator|.
name|getProperty
argument_list|(
literal|"simulate"
argument_list|)
decl_stmt|;
name|boolean
name|doSimulate
init|=
name|simulate
operator|==
literal|null
condition|?
literal|false
else|:
name|Boolean
operator|.
name|parseBoolean
argument_list|(
name|simulate
argument_list|)
decl_stmt|;
name|doRaid
argument_list|(
name|conf
argument_list|,
name|src
argument_list|,
name|destPref
argument_list|,
name|info
operator|.
name|getErasureCode
argument_list|()
argument_list|,
name|statistics
argument_list|,
name|reporter
argument_list|,
name|doSimulate
argument_list|,
name|targetRepl
argument_list|,
name|metaRepl
argument_list|,
name|stripeLength
argument_list|)
expr_stmt|;
block|}
comment|/**    * RAID an individual file    */
DECL|method|doRaid (Configuration conf, FileStatus stat, Path destPath, PolicyInfo.ErasureCodeType code, Statistics statistics, Progressable reporter, boolean doSimulate, int targetRepl, int metaRepl, int stripeLength)
specifier|static
specifier|public
name|void
name|doRaid
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|FileStatus
name|stat
parameter_list|,
name|Path
name|destPath
parameter_list|,
name|PolicyInfo
operator|.
name|ErasureCodeType
name|code
parameter_list|,
name|Statistics
name|statistics
parameter_list|,
name|Progressable
name|reporter
parameter_list|,
name|boolean
name|doSimulate
parameter_list|,
name|int
name|targetRepl
parameter_list|,
name|int
name|metaRepl
parameter_list|,
name|int
name|stripeLength
parameter_list|)
throws|throws
name|IOException
block|{
name|Path
name|p
init|=
name|stat
operator|.
name|getPath
argument_list|()
decl_stmt|;
name|FileSystem
name|srcFs
init|=
name|p
operator|.
name|getFileSystem
argument_list|(
name|conf
argument_list|)
decl_stmt|;
comment|// extract block locations from File system
name|BlockLocation
index|[]
name|locations
init|=
name|srcFs
operator|.
name|getFileBlockLocations
argument_list|(
name|stat
argument_list|,
literal|0
argument_list|,
name|stat
operator|.
name|getLen
argument_list|()
argument_list|)
decl_stmt|;
comment|// if the file has fewer than 2 blocks, then nothing to do
if|if
condition|(
name|locations
operator|.
name|length
operator|<=
literal|2
condition|)
block|{
return|return;
block|}
comment|// add up the raw disk space occupied by this file
name|long
name|diskSpace
init|=
literal|0
decl_stmt|;
for|for
control|(
name|BlockLocation
name|l
range|:
name|locations
control|)
block|{
name|diskSpace
operator|+=
operator|(
name|l
operator|.
name|getLength
argument_list|()
operator|*
name|stat
operator|.
name|getReplication
argument_list|()
operator|)
expr_stmt|;
block|}
name|statistics
operator|.
name|numProcessedBlocks
operator|+=
name|locations
operator|.
name|length
expr_stmt|;
name|statistics
operator|.
name|processedSize
operator|+=
name|diskSpace
expr_stmt|;
comment|// generate parity file
name|generateParityFile
argument_list|(
name|conf
argument_list|,
name|stat
argument_list|,
name|reporter
argument_list|,
name|srcFs
argument_list|,
name|destPath
argument_list|,
name|code
argument_list|,
name|locations
argument_list|,
name|metaRepl
argument_list|,
name|stripeLength
argument_list|)
expr_stmt|;
comment|// reduce the replication factor of the source file
if|if
condition|(
operator|!
name|doSimulate
condition|)
block|{
if|if
condition|(
name|srcFs
operator|.
name|setReplication
argument_list|(
name|p
argument_list|,
operator|(
name|short
operator|)
name|targetRepl
argument_list|)
operator|==
literal|false
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Error in reducing relication factor of file "
operator|+
name|p
operator|+
literal|" to "
operator|+
name|targetRepl
argument_list|)
expr_stmt|;
name|statistics
operator|.
name|remainingSize
operator|+=
name|diskSpace
expr_stmt|;
comment|// no change in disk space usage
return|return;
block|}
block|}
name|diskSpace
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|BlockLocation
name|l
range|:
name|locations
control|)
block|{
name|diskSpace
operator|+=
operator|(
name|l
operator|.
name|getLength
argument_list|()
operator|*
name|targetRepl
operator|)
expr_stmt|;
block|}
name|statistics
operator|.
name|remainingSize
operator|+=
name|diskSpace
expr_stmt|;
comment|// the metafile will have this many number of blocks
name|int
name|numMeta
init|=
name|locations
operator|.
name|length
operator|/
name|stripeLength
decl_stmt|;
if|if
condition|(
name|locations
operator|.
name|length
operator|%
name|stripeLength
operator|!=
literal|0
condition|)
block|{
name|numMeta
operator|++
expr_stmt|;
block|}
comment|// we create numMeta for every file. This metablock has metaRepl # replicas.
comment|// the last block of the metafile might not be completely filled up, but we
comment|// ignore that for now.
name|statistics
operator|.
name|numMetaBlocks
operator|+=
operator|(
name|numMeta
operator|*
name|metaRepl
operator|)
expr_stmt|;
name|statistics
operator|.
name|metaSize
operator|+=
operator|(
name|numMeta
operator|*
name|metaRepl
operator|*
name|stat
operator|.
name|getBlockSize
argument_list|()
operator|)
expr_stmt|;
block|}
comment|/**    * Create the parity file.    */
DECL|method|generateParityFile (Configuration conf, FileStatus stat, Progressable reporter, FileSystem inFs, Path destPathPrefix, ErasureCodeType code, BlockLocation[] locations, int metaRepl, int stripeLength)
specifier|static
specifier|private
name|void
name|generateParityFile
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|FileStatus
name|stat
parameter_list|,
name|Progressable
name|reporter
parameter_list|,
name|FileSystem
name|inFs
parameter_list|,
name|Path
name|destPathPrefix
parameter_list|,
name|ErasureCodeType
name|code
parameter_list|,
name|BlockLocation
index|[]
name|locations
parameter_list|,
name|int
name|metaRepl
parameter_list|,
name|int
name|stripeLength
parameter_list|)
throws|throws
name|IOException
block|{
name|Path
name|inpath
init|=
name|stat
operator|.
name|getPath
argument_list|()
decl_stmt|;
name|Path
name|outpath
init|=
name|getOriginalParityFile
argument_list|(
name|destPathPrefix
argument_list|,
name|inpath
argument_list|)
decl_stmt|;
name|FileSystem
name|outFs
init|=
name|outpath
operator|.
name|getFileSystem
argument_list|(
name|conf
argument_list|)
decl_stmt|;
comment|// If the parity file is already upto-date, then nothing to do
try|try
block|{
name|FileStatus
name|stmp
init|=
name|outFs
operator|.
name|getFileStatus
argument_list|(
name|outpath
argument_list|)
decl_stmt|;
if|if
condition|(
name|stmp
operator|.
name|getModificationTime
argument_list|()
operator|==
name|stat
operator|.
name|getModificationTime
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Parity file for "
operator|+
name|inpath
operator|+
literal|"("
operator|+
name|locations
operator|.
name|length
operator|+
literal|") is "
operator|+
name|outpath
operator|+
literal|" already upto-date. Nothing more to do."
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// ignore errors because the raid file might not exist yet.
block|}
name|Encoder
name|encoder
init|=
name|encoderForCode
argument_list|(
name|conf
argument_list|,
name|code
argument_list|)
decl_stmt|;
name|encoder
operator|.
name|encodeFile
argument_list|(
name|inFs
argument_list|,
name|inpath
argument_list|,
name|outFs
argument_list|,
name|outpath
argument_list|,
operator|(
name|short
operator|)
name|metaRepl
argument_list|,
name|reporter
argument_list|)
expr_stmt|;
comment|// set the modification time of the RAID file. This is done so that the modTime of the
comment|// RAID file reflects that contents of the source file that it has RAIDed. This should
comment|// also work for files that are being appended to. This is necessary because the time on
comment|// on the destination namenode may not be synchronised with the timestamp of the
comment|// source namenode.
name|outFs
operator|.
name|setTimes
argument_list|(
name|outpath
argument_list|,
name|stat
operator|.
name|getModificationTime
argument_list|()
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|inFs
operator|.
name|setTimes
argument_list|(
name|inpath
argument_list|,
name|stat
operator|.
name|getModificationTime
argument_list|()
argument_list|,
name|stat
operator|.
name|getAccessTime
argument_list|()
argument_list|)
expr_stmt|;
name|FileStatus
name|outstat
init|=
name|outFs
operator|.
name|getFileStatus
argument_list|(
name|outpath
argument_list|)
decl_stmt|;
name|FileStatus
name|inStat
init|=
name|inFs
operator|.
name|getFileStatus
argument_list|(
name|inpath
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Source file "
operator|+
name|inpath
operator|+
literal|" of size "
operator|+
name|inStat
operator|.
name|getLen
argument_list|()
operator|+
literal|" Parity file "
operator|+
name|outpath
operator|+
literal|" of size "
operator|+
name|outstat
operator|.
name|getLen
argument_list|()
operator|+
literal|" src mtime "
operator|+
name|stat
operator|.
name|getModificationTime
argument_list|()
operator|+
literal|" parity mtime "
operator|+
name|outstat
operator|.
name|getModificationTime
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Extract a good block from the parity block. This assumes that the    * corruption is in the main file and the parity file is always good.    */
DECL|method|unRaid (Configuration conf, Path srcPath, Path destPathPrefix, Decoder decoder, int stripeLength, long corruptOffset)
specifier|public
specifier|static
name|Path
name|unRaid
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|Path
name|srcPath
parameter_list|,
name|Path
name|destPathPrefix
parameter_list|,
name|Decoder
name|decoder
parameter_list|,
name|int
name|stripeLength
parameter_list|,
name|long
name|corruptOffset
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Test if parity file exists
name|ParityFilePair
name|ppair
init|=
name|getParityFile
argument_list|(
name|destPathPrefix
argument_list|,
name|srcPath
argument_list|,
name|conf
argument_list|)
decl_stmt|;
if|if
condition|(
name|ppair
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
specifier|final
name|Path
name|recoveryDestination
init|=
operator|new
name|Path
argument_list|(
name|RaidNode
operator|.
name|unraidTmpDirectory
argument_list|(
name|conf
argument_list|)
argument_list|)
decl_stmt|;
name|FileSystem
name|destFs
init|=
name|recoveryDestination
operator|.
name|getFileSystem
argument_list|(
name|conf
argument_list|)
decl_stmt|;
specifier|final
name|Path
name|recoveredPrefix
init|=
name|destFs
operator|.
name|makeQualified
argument_list|(
operator|new
name|Path
argument_list|(
name|recoveryDestination
argument_list|,
name|makeRelative
argument_list|(
name|srcPath
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|Path
name|recoveredPath
init|=
operator|new
name|Path
argument_list|(
name|recoveredPrefix
operator|+
literal|"."
operator|+
operator|new
name|Random
argument_list|()
operator|.
name|nextLong
argument_list|()
operator|+
literal|".recovered"
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Creating recovered file "
operator|+
name|recoveredPath
argument_list|)
expr_stmt|;
name|FileSystem
name|srcFs
init|=
name|srcPath
operator|.
name|getFileSystem
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|decoder
operator|.
name|decodeFile
argument_list|(
name|srcFs
argument_list|,
name|srcPath
argument_list|,
name|ppair
operator|.
name|getFileSystem
argument_list|()
argument_list|,
name|ppair
operator|.
name|getPath
argument_list|()
argument_list|,
name|corruptOffset
argument_list|,
name|recoveredPath
argument_list|)
expr_stmt|;
return|return
name|recoveredPath
return|;
block|}
DECL|method|unRaidCorruptBlock (Configuration conf, Path srcPath, Path destPathPrefix, Decoder decoder, int stripeLength, long corruptOffset)
specifier|public
specifier|static
name|Path
name|unRaidCorruptBlock
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|Path
name|srcPath
parameter_list|,
name|Path
name|destPathPrefix
parameter_list|,
name|Decoder
name|decoder
parameter_list|,
name|int
name|stripeLength
parameter_list|,
name|long
name|corruptOffset
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Test if parity file exists
name|ParityFilePair
name|ppair
init|=
name|getParityFile
argument_list|(
name|destPathPrefix
argument_list|,
name|srcPath
argument_list|,
name|conf
argument_list|)
decl_stmt|;
if|if
condition|(
name|ppair
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Could not find parity file for "
operator|+
name|srcPath
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
specifier|final
name|Path
name|recoveryDestination
init|=
operator|new
name|Path
argument_list|(
name|RaidNode
operator|.
name|xorTempPrefix
argument_list|(
name|conf
argument_list|)
argument_list|)
decl_stmt|;
name|FileSystem
name|destFs
init|=
name|recoveryDestination
operator|.
name|getFileSystem
argument_list|(
name|conf
argument_list|)
decl_stmt|;
specifier|final
name|Path
name|recoveredPrefix
init|=
name|destFs
operator|.
name|makeQualified
argument_list|(
operator|new
name|Path
argument_list|(
name|recoveryDestination
argument_list|,
name|makeRelative
argument_list|(
name|srcPath
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|Path
name|recoveredBlock
init|=
operator|new
name|Path
argument_list|(
name|recoveredPrefix
operator|+
literal|"."
operator|+
operator|new
name|Random
argument_list|()
operator|.
name|nextLong
argument_list|()
operator|+
literal|".recovered"
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Creating recovered Block "
operator|+
name|recoveredBlock
argument_list|)
expr_stmt|;
name|FileSystem
name|srcFs
init|=
name|srcPath
operator|.
name|getFileSystem
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|FileStatus
name|stat
init|=
name|srcFs
operator|.
name|getFileStatus
argument_list|(
name|srcPath
argument_list|)
decl_stmt|;
name|long
name|limit
init|=
name|Math
operator|.
name|min
argument_list|(
name|stat
operator|.
name|getBlockSize
argument_list|()
argument_list|,
name|stat
operator|.
name|getLen
argument_list|()
operator|-
name|corruptOffset
argument_list|)
decl_stmt|;
name|java
operator|.
name|io
operator|.
name|OutputStream
name|out
init|=
name|ppair
operator|.
name|getFileSystem
argument_list|()
operator|.
name|create
argument_list|(
name|recoveredBlock
argument_list|)
decl_stmt|;
name|decoder
operator|.
name|fixErasedBlock
argument_list|(
name|srcFs
argument_list|,
name|srcPath
argument_list|,
name|ppair
operator|.
name|getFileSystem
argument_list|()
argument_list|,
name|ppair
operator|.
name|getPath
argument_list|()
argument_list|,
name|stat
operator|.
name|getBlockSize
argument_list|()
argument_list|,
name|corruptOffset
argument_list|,
literal|0
argument_list|,
name|limit
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|out
operator|.
name|close
argument_list|()
expr_stmt|;
return|return
name|recoveredBlock
return|;
block|}
comment|/**    * Periodically delete orphaned parity files.    */
DECL|class|PurgeMonitor
class|class
name|PurgeMonitor
implements|implements
name|Runnable
block|{
comment|/**      */
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
while|while
condition|(
name|running
condition|)
block|{
try|try
block|{
name|doPurge
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Purge parity files thread continuing to run..."
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Traverse the parity destination directory, removing directories that      * no longer existing in the source.      * @throws IOException      */
DECL|method|purgeDirectories (FileSystem fs, Path root)
specifier|private
name|void
name|purgeDirectories
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Path
name|root
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|prefix
init|=
name|root
operator|.
name|toUri
argument_list|()
operator|.
name|getPath
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|FileStatus
argument_list|>
name|startPaths
init|=
operator|new
name|LinkedList
argument_list|<
name|FileStatus
argument_list|>
argument_list|()
decl_stmt|;
try|try
block|{
name|startPaths
operator|.
name|add
argument_list|(
name|fs
operator|.
name|getFileStatus
argument_list|(
name|root
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|e
parameter_list|)
block|{
return|return;
block|}
name|DirectoryTraversal
name|dt
init|=
operator|new
name|DirectoryTraversal
argument_list|(
name|fs
argument_list|,
name|startPaths
argument_list|)
decl_stmt|;
name|FileStatus
name|dir
init|=
name|dt
operator|.
name|getNextDirectory
argument_list|()
decl_stmt|;
for|for
control|(
init|;
name|dir
operator|!=
literal|null
condition|;
name|dir
operator|=
name|dt
operator|.
name|getNextDirectory
argument_list|()
control|)
block|{
name|Path
name|dirPath
init|=
name|dir
operator|.
name|getPath
argument_list|()
decl_stmt|;
if|if
condition|(
name|dirPath
operator|.
name|toUri
argument_list|()
operator|.
name|getPath
argument_list|()
operator|.
name|endsWith
argument_list|(
name|HAR_SUFFIX
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|String
name|dirStr
init|=
name|dirPath
operator|.
name|toUri
argument_list|()
operator|.
name|getPath
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|dirStr
operator|.
name|startsWith
argument_list|(
name|prefix
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|String
name|src
init|=
name|dirStr
operator|.
name|replaceFirst
argument_list|(
name|prefix
argument_list|,
literal|""
argument_list|)
decl_stmt|;
if|if
condition|(
name|src
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
continue|continue;
name|Path
name|srcPath
init|=
operator|new
name|Path
argument_list|(
name|src
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|fs
operator|.
name|exists
argument_list|(
name|srcPath
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Purging directory "
operator|+
name|dirPath
argument_list|)
expr_stmt|;
name|boolean
name|done
init|=
name|fs
operator|.
name|delete
argument_list|(
name|dirPath
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|done
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Could not purge "
operator|+
name|dirPath
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**      * Delete orphaned files. The reason this is done by a separate thread       * is to not burden the TriggerMonitor with scanning the       * destination directories.      */
DECL|method|doPurge ()
specifier|private
name|void
name|doPurge
parameter_list|()
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|long
name|prevExec
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|running
condition|)
block|{
comment|// The config may be reloaded by the TriggerMonitor.
comment|// This thread uses whatever config is currently active.
while|while
condition|(
name|now
argument_list|()
operator|<
name|prevExec
operator|+
name|configMgr
operator|.
name|getPeriodicity
argument_list|()
condition|)
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|SLEEP_TIME
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Started purge scan"
argument_list|)
expr_stmt|;
name|prevExec
operator|=
name|now
argument_list|()
expr_stmt|;
comment|// expand destination prefix path
name|Path
name|destPref
init|=
name|xorDestinationPath
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|FileSystem
name|destFs
init|=
name|destPref
operator|.
name|getFileSystem
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|purgeDirectories
argument_list|(
name|destFs
argument_list|,
name|destPref
argument_list|)
expr_stmt|;
name|destPref
operator|=
name|rsDestinationPath
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|destFs
operator|=
name|destPref
operator|.
name|getFileSystem
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|purgeDirectories
argument_list|(
name|destFs
argument_list|,
name|destPref
argument_list|)
expr_stmt|;
comment|// fetch all categories
for|for
control|(
name|PolicyList
name|category
range|:
name|configMgr
operator|.
name|getAllPolicies
argument_list|()
control|)
block|{
for|for
control|(
name|PolicyInfo
name|info
range|:
name|category
operator|.
name|getAll
argument_list|()
control|)
block|{
try|try
block|{
comment|// expand destination prefix path
name|destPref
operator|=
name|getDestinationPath
argument_list|(
name|info
operator|.
name|getErasureCode
argument_list|()
argument_list|,
name|conf
argument_list|)
expr_stmt|;
name|destFs
operator|=
name|destPref
operator|.
name|getFileSystem
argument_list|(
name|conf
argument_list|)
expr_stmt|;
comment|//get srcPaths
name|Path
index|[]
name|srcPaths
init|=
name|info
operator|.
name|getSrcPathExpanded
argument_list|()
decl_stmt|;
if|if
condition|(
name|srcPaths
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|Path
name|srcPath
range|:
name|srcPaths
control|)
block|{
comment|// expand destination prefix
name|Path
name|destPath
init|=
name|getOriginalParityFile
argument_list|(
name|destPref
argument_list|,
name|srcPath
argument_list|)
decl_stmt|;
name|FileSystem
name|srcFs
init|=
name|info
operator|.
name|getSrcPath
argument_list|()
operator|.
name|getFileSystem
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|FileStatus
name|stat
init|=
literal|null
decl_stmt|;
try|try
block|{
name|stat
operator|=
name|destFs
operator|.
name|getFileStatus
argument_list|(
name|destPath
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|e
parameter_list|)
block|{
comment|// do nothing, leave stat = null;
block|}
if|if
condition|(
name|stat
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Purging obsolete parity files for policy "
operator|+
name|info
operator|.
name|getName
argument_list|()
operator|+
literal|" "
operator|+
name|destPath
argument_list|)
expr_stmt|;
name|recursePurge
argument_list|(
name|info
operator|.
name|getErasureCode
argument_list|()
argument_list|,
name|srcFs
argument_list|,
name|destFs
argument_list|,
name|destPref
operator|.
name|toUri
argument_list|()
operator|.
name|getPath
argument_list|()
argument_list|,
name|stat
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Ignoring Exception while processing policy "
operator|+
name|info
operator|.
name|getName
argument_list|()
operator|+
literal|" "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
comment|/**      * The destPrefix is the absolute pathname of the destinationPath      * specified in the policy (without the host:port)      */
DECL|method|recursePurge (ErasureCodeType code, FileSystem srcFs, FileSystem destFs, String destPrefix, FileStatus dest)
name|void
name|recursePurge
parameter_list|(
name|ErasureCodeType
name|code
parameter_list|,
name|FileSystem
name|srcFs
parameter_list|,
name|FileSystem
name|destFs
parameter_list|,
name|String
name|destPrefix
parameter_list|,
name|FileStatus
name|dest
parameter_list|)
throws|throws
name|IOException
block|{
name|Path
name|destPath
init|=
name|dest
operator|.
name|getPath
argument_list|()
decl_stmt|;
comment|// pathname, no host:port
name|String
name|destStr
init|=
name|destPath
operator|.
name|toUri
argument_list|()
operator|.
name|getPath
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Checking "
operator|+
name|destPath
operator|+
literal|" prefix "
operator|+
name|destPrefix
argument_list|)
expr_stmt|;
comment|// Verify if it is a har file
if|if
condition|(
name|dest
operator|.
name|isDirectory
argument_list|()
operator|&&
name|destStr
operator|.
name|endsWith
argument_list|(
name|HAR_SUFFIX
argument_list|)
condition|)
block|{
try|try
block|{
name|int
name|harUsedPercent
init|=
name|usefulHar
argument_list|(
name|code
argument_list|,
name|srcFs
argument_list|,
name|destFs
argument_list|,
name|destPath
argument_list|,
name|destPrefix
argument_list|,
name|conf
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Useful percentage of "
operator|+
name|destStr
operator|+
literal|" "
operator|+
name|harUsedPercent
argument_list|)
expr_stmt|;
comment|// Delete the har if its usefulness reaches a threshold.
if|if
condition|(
name|harUsedPercent
operator|<=
name|conf
operator|.
name|getInt
argument_list|(
literal|"raid.har.usage.threshold"
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Purging "
operator|+
name|destStr
operator|+
literal|" at usage "
operator|+
name|harUsedPercent
argument_list|)
expr_stmt|;
name|boolean
name|done
init|=
name|destFs
operator|.
name|delete
argument_list|(
name|destPath
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|done
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to purge directory "
operator|+
name|destPath
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Error during purging "
operator|+
name|destStr
operator|+
literal|" "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
comment|// Verify the destPrefix is a prefix of the destPath
if|if
condition|(
operator|!
name|destStr
operator|.
name|startsWith
argument_list|(
name|destPrefix
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Destination path "
operator|+
name|destStr
operator|+
literal|" should have "
operator|+
name|destPrefix
operator|+
literal|" as its prefix."
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|dest
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
name|FileStatus
index|[]
name|files
init|=
literal|null
decl_stmt|;
name|files
operator|=
name|destFs
operator|.
name|listStatus
argument_list|(
name|destPath
argument_list|)
expr_stmt|;
if|if
condition|(
name|files
operator|==
literal|null
operator|||
name|files
operator|.
name|length
operator|==
literal|0
condition|)
block|{
name|boolean
name|done
init|=
name|destFs
operator|.
name|delete
argument_list|(
name|destPath
argument_list|,
literal|true
argument_list|)
decl_stmt|;
comment|// ideal is false, but
comment|// DFSClient only deletes directories if it is recursive
if|if
condition|(
name|done
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Purged directory "
operator|+
name|destPath
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to purge directory "
operator|+
name|destPath
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|files
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|FileStatus
name|one
range|:
name|files
control|)
block|{
name|recursePurge
argument_list|(
name|code
argument_list|,
name|srcFs
argument_list|,
name|destFs
argument_list|,
name|destPrefix
argument_list|,
name|one
argument_list|)
expr_stmt|;
block|}
block|}
comment|// If the directory is empty now, it will be purged the next time this
comment|// thread runs.
return|return;
comment|// the code below does the file checking
block|}
name|String
name|src
init|=
name|destStr
operator|.
name|replaceFirst
argument_list|(
name|destPrefix
argument_list|,
literal|""
argument_list|)
decl_stmt|;
name|Path
name|srcPath
init|=
operator|new
name|Path
argument_list|(
name|src
argument_list|)
decl_stmt|;
name|boolean
name|shouldDelete
init|=
literal|false
decl_stmt|;
if|if
condition|(
operator|!
name|srcFs
operator|.
name|exists
argument_list|(
name|srcPath
argument_list|)
condition|)
block|{
name|shouldDelete
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
try|try
block|{
comment|// If there is a RS parity file, the XOR parity can be deleted.
if|if
condition|(
name|code
operator|==
name|ErasureCodeType
operator|.
name|XOR
condition|)
block|{
name|ParityFilePair
name|ppair
init|=
name|getParityFile
argument_list|(
name|getDestinationPath
argument_list|(
name|ErasureCodeType
operator|.
name|RS
argument_list|,
name|conf
argument_list|)
argument_list|,
name|srcPath
argument_list|,
name|conf
argument_list|)
decl_stmt|;
if|if
condition|(
name|ppair
operator|!=
literal|null
condition|)
block|{
name|shouldDelete
operator|=
literal|true
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|shouldDelete
condition|)
block|{
name|Path
name|dstPath
init|=
operator|(
operator|new
name|Path
argument_list|(
name|destPrefix
operator|.
name|trim
argument_list|()
argument_list|)
operator|)
operator|.
name|makeQualified
argument_list|(
name|destFs
argument_list|)
decl_stmt|;
name|ParityFilePair
name|ppair
init|=
name|getParityFile
argument_list|(
name|dstPath
argument_list|,
name|srcPath
argument_list|)
decl_stmt|;
comment|// If the parity file is not the appropriate one for the source or
comment|// the parityFs is not the same as this file's filesystem
comment|// (it is a HAR), this file can be deleted.
if|if
condition|(
name|ppair
operator|==
literal|null
operator|||
operator|!
name|destFs
operator|.
name|equals
argument_list|(
name|ppair
operator|.
name|getFileSystem
argument_list|()
argument_list|)
operator|||
operator|!
name|destPath
operator|.
name|equals
argument_list|(
name|ppair
operator|.
name|getPath
argument_list|()
argument_list|)
condition|)
block|{
name|shouldDelete
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Error during purging "
operator|+
name|src
operator|+
literal|" "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|shouldDelete
condition|)
block|{
name|boolean
name|done
init|=
name|destFs
operator|.
name|delete
argument_list|(
name|destPath
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|done
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Purged file "
operator|+
name|destPath
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to purge file "
operator|+
name|destPath
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|//
comment|// Returns the number of up-to-date files in the har as a percentage of the
comment|// total number of files in the har.
comment|//
DECL|method|usefulHar ( ErasureCodeType code, FileSystem srcFs, FileSystem destFs, Path harPath, String destPrefix, Configuration conf)
specifier|protected
specifier|static
name|int
name|usefulHar
parameter_list|(
name|ErasureCodeType
name|code
parameter_list|,
name|FileSystem
name|srcFs
parameter_list|,
name|FileSystem
name|destFs
parameter_list|,
name|Path
name|harPath
parameter_list|,
name|String
name|destPrefix
parameter_list|,
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|FileSystem
name|fsHar
init|=
operator|new
name|HarFileSystem
argument_list|(
name|destFs
argument_list|)
decl_stmt|;
name|String
name|harURIPath
init|=
name|harPath
operator|.
name|toUri
argument_list|()
operator|.
name|getPath
argument_list|()
decl_stmt|;
name|Path
name|qualifiedPath
init|=
operator|new
name|Path
argument_list|(
literal|"har://"
argument_list|,
name|harURIPath
operator|+
name|Path
operator|.
name|SEPARATOR
operator|+
name|harPath
operator|.
name|getParent
argument_list|()
operator|.
name|toUri
argument_list|()
operator|.
name|getPath
argument_list|()
argument_list|)
decl_stmt|;
name|fsHar
operator|.
name|initialize
argument_list|(
name|qualifiedPath
operator|.
name|toUri
argument_list|()
argument_list|,
name|conf
argument_list|)
expr_stmt|;
name|FileStatus
index|[]
name|filesInHar
init|=
name|fsHar
operator|.
name|listStatus
argument_list|(
name|qualifiedPath
argument_list|)
decl_stmt|;
if|if
condition|(
name|filesInHar
operator|.
name|length
operator|==
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
name|int
name|numUseless
init|=
literal|0
decl_stmt|;
for|for
control|(
name|FileStatus
name|one
range|:
name|filesInHar
control|)
block|{
name|Path
name|parityPath
init|=
name|one
operator|.
name|getPath
argument_list|()
decl_stmt|;
name|String
name|parityStr
init|=
name|parityPath
operator|.
name|toUri
argument_list|()
operator|.
name|getPath
argument_list|()
decl_stmt|;
if|if
condition|(
name|parityStr
operator|.
name|startsWith
argument_list|(
literal|"har:/"
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unexpected prefix har:/ for "
operator|+
name|parityStr
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|String
name|prefixToReplace
init|=
name|harURIPath
operator|+
name|destPrefix
decl_stmt|;
if|if
condition|(
operator|!
name|parityStr
operator|.
name|startsWith
argument_list|(
name|prefixToReplace
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|String
name|src
init|=
name|parityStr
operator|.
name|substring
argument_list|(
name|prefixToReplace
operator|.
name|length
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|ErasureCodeType
operator|.
name|XOR
condition|)
block|{
name|ParityFilePair
name|ppair
init|=
name|getParityFile
argument_list|(
name|getDestinationPath
argument_list|(
name|ErasureCodeType
operator|.
name|RS
argument_list|,
name|conf
argument_list|)
argument_list|,
operator|new
name|Path
argument_list|(
name|src
argument_list|)
argument_list|,
name|conf
argument_list|)
decl_stmt|;
if|if
condition|(
name|ppair
operator|!=
literal|null
condition|)
block|{
comment|// There is a valid RS parity file, so the XOR one is useless.
name|numUseless
operator|++
expr_stmt|;
continue|continue;
block|}
block|}
try|try
block|{
name|FileStatus
name|srcStatus
init|=
name|srcFs
operator|.
name|getFileStatus
argument_list|(
operator|new
name|Path
argument_list|(
name|src
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|srcStatus
operator|==
literal|null
condition|)
block|{
name|numUseless
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|one
operator|.
name|getModificationTime
argument_list|()
operator|!=
name|srcStatus
operator|.
name|getModificationTime
argument_list|()
condition|)
block|{
name|numUseless
operator|++
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"File not found: "
operator|+
name|e
argument_list|)
expr_stmt|;
name|numUseless
operator|++
expr_stmt|;
block|}
block|}
name|int
name|uselessPercent
init|=
name|numUseless
operator|*
literal|100
operator|/
name|filesInHar
operator|.
name|length
decl_stmt|;
return|return
literal|100
operator|-
name|uselessPercent
return|;
block|}
DECL|method|doHar ()
specifier|private
name|void
name|doHar
parameter_list|()
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|long
name|prevExec
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|running
condition|)
block|{
comment|// The config may be reloaded by the TriggerMonitor.
comment|// This thread uses whatever config is currently active.
while|while
condition|(
name|now
argument_list|()
operator|<
name|prevExec
operator|+
name|configMgr
operator|.
name|getPeriodicity
argument_list|()
condition|)
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|SLEEP_TIME
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Started archive scan"
argument_list|)
expr_stmt|;
name|prevExec
operator|=
name|now
argument_list|()
expr_stmt|;
comment|// fetch all categories
for|for
control|(
name|PolicyList
name|category
range|:
name|configMgr
operator|.
name|getAllPolicies
argument_list|()
control|)
block|{
for|for
control|(
name|PolicyInfo
name|info
range|:
name|category
operator|.
name|getAll
argument_list|()
control|)
block|{
name|String
name|tmpHarPath
init|=
name|tmpHarPathForCode
argument_list|(
name|conf
argument_list|,
name|info
operator|.
name|getErasureCode
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|str
init|=
name|info
operator|.
name|getProperty
argument_list|(
literal|"time_before_har"
argument_list|)
decl_stmt|;
if|if
condition|(
name|str
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|long
name|cutoff
init|=
name|now
argument_list|()
operator|-
operator|(
name|Long
operator|.
name|parseLong
argument_list|(
name|str
argument_list|)
operator|*
literal|24L
operator|*
literal|3600000L
operator|)
decl_stmt|;
name|Path
name|destPref
init|=
name|getDestinationPath
argument_list|(
name|info
operator|.
name|getErasureCode
argument_list|()
argument_list|,
name|conf
argument_list|)
decl_stmt|;
name|FileSystem
name|destFs
init|=
name|destPref
operator|.
name|getFileSystem
argument_list|(
name|conf
argument_list|)
decl_stmt|;
comment|//get srcPaths
name|Path
index|[]
name|srcPaths
init|=
name|info
operator|.
name|getSrcPathExpanded
argument_list|()
decl_stmt|;
if|if
condition|(
name|srcPaths
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|Path
name|srcPath
range|:
name|srcPaths
control|)
block|{
comment|// expand destination prefix
name|Path
name|destPath
init|=
name|getOriginalParityFile
argument_list|(
name|destPref
argument_list|,
name|srcPath
argument_list|)
decl_stmt|;
name|FileStatus
name|stat
init|=
literal|null
decl_stmt|;
try|try
block|{
name|stat
operator|=
name|destFs
operator|.
name|getFileStatus
argument_list|(
name|destPath
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|e
parameter_list|)
block|{
comment|// do nothing, leave stat = null;
block|}
if|if
condition|(
name|stat
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Haring parity files for policy "
operator|+
name|info
operator|.
name|getName
argument_list|()
operator|+
literal|" "
operator|+
name|destPath
argument_list|)
expr_stmt|;
name|recurseHar
argument_list|(
name|info
argument_list|,
name|destFs
argument_list|,
name|stat
argument_list|,
name|destPref
operator|.
name|toUri
argument_list|()
operator|.
name|getPath
argument_list|()
argument_list|,
name|srcPath
operator|.
name|getFileSystem
argument_list|(
name|conf
argument_list|)
argument_list|,
name|cutoff
argument_list|,
name|tmpHarPath
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Ignoring Exception while processing policy "
operator|+
name|info
operator|.
name|getName
argument_list|()
operator|+
literal|" "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
return|return;
block|}
DECL|method|recurseHar (PolicyInfo info, FileSystem destFs, FileStatus dest, String destPrefix, FileSystem srcFs, long cutoff, String tmpHarPath)
name|void
name|recurseHar
parameter_list|(
name|PolicyInfo
name|info
parameter_list|,
name|FileSystem
name|destFs
parameter_list|,
name|FileStatus
name|dest
parameter_list|,
name|String
name|destPrefix
parameter_list|,
name|FileSystem
name|srcFs
parameter_list|,
name|long
name|cutoff
parameter_list|,
name|String
name|tmpHarPath
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|dest
operator|.
name|isFile
argument_list|()
condition|)
block|{
return|return;
block|}
name|Path
name|destPath
init|=
name|dest
operator|.
name|getPath
argument_list|()
decl_stmt|;
comment|// pathname, no host:port
name|String
name|destStr
init|=
name|destPath
operator|.
name|toUri
argument_list|()
operator|.
name|getPath
argument_list|()
decl_stmt|;
comment|// Verify if it already contains a HAR directory
if|if
condition|(
name|destFs
operator|.
name|exists
argument_list|(
operator|new
name|Path
argument_list|(
name|destPath
argument_list|,
name|destPath
operator|.
name|getName
argument_list|()
operator|+
name|HAR_SUFFIX
argument_list|)
argument_list|)
condition|)
block|{
return|return;
block|}
name|FileStatus
index|[]
name|files
init|=
literal|null
decl_stmt|;
name|files
operator|=
name|destFs
operator|.
name|listStatus
argument_list|(
name|destPath
argument_list|)
expr_stmt|;
name|boolean
name|shouldHar
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|files
operator|!=
literal|null
condition|)
block|{
name|shouldHar
operator|=
name|files
operator|.
name|length
operator|>
literal|0
expr_stmt|;
for|for
control|(
name|FileStatus
name|one
range|:
name|files
control|)
block|{
if|if
condition|(
name|one
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
name|recurseHar
argument_list|(
name|info
argument_list|,
name|destFs
argument_list|,
name|one
argument_list|,
name|destPrefix
argument_list|,
name|srcFs
argument_list|,
name|cutoff
argument_list|,
name|tmpHarPath
argument_list|)
expr_stmt|;
name|shouldHar
operator|=
literal|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|one
operator|.
name|getModificationTime
argument_list|()
operator|>
name|cutoff
condition|)
block|{
if|if
condition|(
name|shouldHar
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Cannot archive "
operator|+
name|destPath
operator|+
literal|" because "
operator|+
name|one
operator|.
name|getPath
argument_list|()
operator|+
literal|" was modified after cutoff"
argument_list|)
expr_stmt|;
name|shouldHar
operator|=
literal|false
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|shouldHar
condition|)
block|{
name|String
name|src
init|=
name|destStr
operator|.
name|replaceFirst
argument_list|(
name|destPrefix
argument_list|,
literal|""
argument_list|)
decl_stmt|;
name|Path
name|srcPath
init|=
operator|new
name|Path
argument_list|(
name|src
argument_list|)
decl_stmt|;
name|FileStatus
index|[]
name|statuses
init|=
name|srcFs
operator|.
name|listStatus
argument_list|(
name|srcPath
argument_list|)
decl_stmt|;
name|Path
name|destPathPrefix
init|=
operator|new
name|Path
argument_list|(
name|destPrefix
argument_list|)
operator|.
name|makeQualified
argument_list|(
name|destFs
argument_list|)
decl_stmt|;
if|if
condition|(
name|statuses
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|FileStatus
name|status
range|:
name|statuses
control|)
block|{
if|if
condition|(
name|getParityFile
argument_list|(
name|destPathPrefix
argument_list|,
name|status
operator|.
name|getPath
argument_list|()
operator|.
name|makeQualified
argument_list|(
name|srcFs
argument_list|)
argument_list|)
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Cannot archive "
operator|+
name|destPath
operator|+
literal|" because it doesn't contain parity file for "
operator|+
name|status
operator|.
name|getPath
argument_list|()
operator|.
name|makeQualified
argument_list|(
name|srcFs
argument_list|)
operator|+
literal|" on destination "
operator|+
name|destPathPrefix
argument_list|)
expr_stmt|;
name|shouldHar
operator|=
literal|false
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
block|}
if|if
condition|(
name|shouldHar
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Archiving "
operator|+
name|dest
operator|.
name|getPath
argument_list|()
operator|+
literal|" to "
operator|+
name|tmpHarPath
argument_list|)
expr_stmt|;
name|singleHar
argument_list|(
name|info
argument_list|,
name|destFs
argument_list|,
name|dest
argument_list|,
name|tmpHarPath
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|singleHar (PolicyInfo info, FileSystem destFs, FileStatus dest, String tmpHarPath)
specifier|private
name|void
name|singleHar
parameter_list|(
name|PolicyInfo
name|info
parameter_list|,
name|FileSystem
name|destFs
parameter_list|,
name|FileStatus
name|dest
parameter_list|,
name|String
name|tmpHarPath
parameter_list|)
throws|throws
name|IOException
block|{
name|Random
name|rand
init|=
operator|new
name|Random
argument_list|()
decl_stmt|;
name|Path
name|root
init|=
operator|new
name|Path
argument_list|(
literal|"/"
argument_list|)
decl_stmt|;
name|Path
name|qualifiedPath
init|=
name|dest
operator|.
name|getPath
argument_list|()
operator|.
name|makeQualified
argument_list|(
name|destFs
argument_list|)
decl_stmt|;
name|String
name|harFileDst
init|=
name|qualifiedPath
operator|.
name|getName
argument_list|()
operator|+
name|HAR_SUFFIX
decl_stmt|;
name|String
name|harFileSrc
init|=
name|qualifiedPath
operator|.
name|getName
argument_list|()
operator|+
literal|"-"
operator|+
name|rand
operator|.
name|nextLong
argument_list|()
operator|+
literal|"-"
operator|+
name|HAR_SUFFIX
decl_stmt|;
name|short
name|metaReplication
init|=
operator|(
name|short
operator|)
name|Integer
operator|.
name|parseInt
argument_list|(
name|info
operator|.
name|getProperty
argument_list|(
literal|"metaReplication"
argument_list|)
argument_list|)
decl_stmt|;
comment|// HadoopArchives.HAR_PARTFILE_LABEL is private, so hard-coding the label.
name|conf
operator|.
name|setLong
argument_list|(
literal|"har.partfile.size"
argument_list|,
name|configMgr
operator|.
name|getHarPartfileSize
argument_list|()
argument_list|)
expr_stmt|;
name|HadoopArchives
name|har
init|=
operator|new
name|HadoopArchives
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|String
index|[]
name|args
init|=
operator|new
name|String
index|[
literal|7
index|]
decl_stmt|;
name|args
index|[
literal|0
index|]
operator|=
literal|"-Ddfs.replication="
operator|+
name|metaReplication
expr_stmt|;
name|args
index|[
literal|1
index|]
operator|=
literal|"-archiveName"
expr_stmt|;
name|args
index|[
literal|2
index|]
operator|=
name|harFileSrc
expr_stmt|;
name|args
index|[
literal|3
index|]
operator|=
literal|"-p"
expr_stmt|;
name|args
index|[
literal|4
index|]
operator|=
name|root
operator|.
name|makeQualified
argument_list|(
name|destFs
argument_list|)
operator|.
name|toString
argument_list|()
expr_stmt|;
name|args
index|[
literal|5
index|]
operator|=
name|qualifiedPath
operator|.
name|toUri
argument_list|()
operator|.
name|getPath
argument_list|()
operator|.
name|substring
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|args
index|[
literal|6
index|]
operator|=
name|tmpHarPath
operator|.
name|toString
argument_list|()
expr_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
try|try
block|{
name|ret
operator|=
name|ToolRunner
operator|.
name|run
argument_list|(
name|har
argument_list|,
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
operator|&&
operator|!
name|destFs
operator|.
name|rename
argument_list|(
operator|new
name|Path
argument_list|(
name|tmpHarPath
operator|+
literal|"/"
operator|+
name|harFileSrc
argument_list|)
argument_list|,
operator|new
name|Path
argument_list|(
name|qualifiedPath
argument_list|,
name|harFileDst
argument_list|)
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"HAR rename didn't succeed from "
operator|+
name|tmpHarPath
operator|+
literal|"/"
operator|+
name|harFileSrc
operator|+
literal|" to "
operator|+
name|qualifiedPath
operator|+
literal|"/"
operator|+
name|harFileDst
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
literal|2
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|exc
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Error while creating archive "
operator|+
name|ret
argument_list|,
name|exc
argument_list|)
throw|;
block|}
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Error while creating archive "
operator|+
name|ret
argument_list|)
throw|;
block|}
return|return;
block|}
comment|/**    * Periodically generates HAR files    */
DECL|class|HarMonitor
class|class
name|HarMonitor
implements|implements
name|Runnable
block|{
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
while|while
condition|(
name|running
condition|)
block|{
try|try
block|{
name|doHar
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Har parity files thread continuing to run..."
argument_list|)
expr_stmt|;
block|}
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Leaving Har thread."
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Return the temp path for XOR parity files    */
DECL|method|unraidTmpDirectory (Configuration conf)
specifier|public
specifier|static
name|String
name|unraidTmpDirectory
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
return|return
name|conf
operator|.
name|get
argument_list|(
name|RAID_TMP_LOCATION_KEY
argument_list|,
name|DEFAULT_RAID_TMP_LOCATION
argument_list|)
return|;
block|}
comment|/**    * Return the temp path for ReedSolomonEncoder parity files    */
DECL|method|rsTempPrefix (Configuration conf)
specifier|public
specifier|static
name|String
name|rsTempPrefix
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
return|return
name|conf
operator|.
name|get
argument_list|(
name|RAIDRS_TMP_LOCATION_KEY
argument_list|,
name|DEFAULT_RAIDRS_TMP_LOCATION
argument_list|)
return|;
block|}
comment|/**    * Return the temp path for XOR parity files    */
DECL|method|xorTempPrefix (Configuration conf)
specifier|public
specifier|static
name|String
name|xorTempPrefix
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
return|return
name|conf
operator|.
name|get
argument_list|(
name|RAID_TMP_LOCATION_KEY
argument_list|,
name|DEFAULT_RAID_TMP_LOCATION
argument_list|)
return|;
block|}
comment|/**    * Return the temp path for XOR parity files    */
DECL|method|xorHarTempPrefix (Configuration conf)
specifier|public
specifier|static
name|String
name|xorHarTempPrefix
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
return|return
name|conf
operator|.
name|get
argument_list|(
name|RAID_HAR_TMP_LOCATION_KEY
argument_list|,
name|DEFAULT_RAID_HAR_TMP_LOCATION
argument_list|)
return|;
block|}
comment|/**    * Return the temp path for ReedSolomonEncoder parity files    */
DECL|method|rsHarTempPrefix (Configuration conf)
specifier|public
specifier|static
name|String
name|rsHarTempPrefix
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
return|return
name|conf
operator|.
name|get
argument_list|(
name|RAIDRS_HAR_TMP_LOCATION_KEY
argument_list|,
name|DEFAULT_RAIDRS_HAR_TMP_LOCATION
argument_list|)
return|;
block|}
comment|/**    * Return the destination path for ReedSolomon parity files    */
DECL|method|rsDestinationPath (Configuration conf, FileSystem fs)
specifier|public
specifier|static
name|Path
name|rsDestinationPath
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|FileSystem
name|fs
parameter_list|)
block|{
name|String
name|loc
init|=
name|conf
operator|.
name|get
argument_list|(
name|RAIDRS_LOCATION_KEY
argument_list|,
name|DEFAULT_RAIDRS_LOCATION
argument_list|)
decl_stmt|;
name|Path
name|p
init|=
operator|new
name|Path
argument_list|(
name|loc
operator|.
name|trim
argument_list|()
argument_list|)
decl_stmt|;
name|p
operator|=
name|p
operator|.
name|makeQualified
argument_list|(
name|fs
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
comment|/**    * Return the destination path for ReedSolomon parity files    */
DECL|method|rsDestinationPath (Configuration conf)
specifier|public
specifier|static
name|Path
name|rsDestinationPath
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|loc
init|=
name|conf
operator|.
name|get
argument_list|(
name|RAIDRS_LOCATION_KEY
argument_list|,
name|DEFAULT_RAIDRS_LOCATION
argument_list|)
decl_stmt|;
name|Path
name|p
init|=
operator|new
name|Path
argument_list|(
name|loc
operator|.
name|trim
argument_list|()
argument_list|)
decl_stmt|;
name|FileSystem
name|fs
init|=
name|FileSystem
operator|.
name|get
argument_list|(
name|p
operator|.
name|toUri
argument_list|()
argument_list|,
name|conf
argument_list|)
decl_stmt|;
name|p
operator|=
name|p
operator|.
name|makeQualified
argument_list|(
name|fs
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
comment|/**    * Return the destination path for XOR parity files    */
DECL|method|xorDestinationPath (Configuration conf, FileSystem fs)
specifier|public
specifier|static
name|Path
name|xorDestinationPath
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|FileSystem
name|fs
parameter_list|)
block|{
name|String
name|loc
init|=
name|conf
operator|.
name|get
argument_list|(
name|RAID_LOCATION_KEY
argument_list|,
name|DEFAULT_RAID_LOCATION
argument_list|)
decl_stmt|;
name|Path
name|p
init|=
operator|new
name|Path
argument_list|(
name|loc
operator|.
name|trim
argument_list|()
argument_list|)
decl_stmt|;
name|p
operator|=
name|p
operator|.
name|makeQualified
argument_list|(
name|fs
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
comment|/**    * Return the destination path for XOR parity files    */
DECL|method|xorDestinationPath (Configuration conf)
specifier|public
specifier|static
name|Path
name|xorDestinationPath
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|loc
init|=
name|conf
operator|.
name|get
argument_list|(
name|RAID_LOCATION_KEY
argument_list|,
name|DEFAULT_RAID_LOCATION
argument_list|)
decl_stmt|;
name|Path
name|p
init|=
operator|new
name|Path
argument_list|(
name|loc
operator|.
name|trim
argument_list|()
argument_list|)
decl_stmt|;
name|FileSystem
name|fs
init|=
name|FileSystem
operator|.
name|get
argument_list|(
name|p
operator|.
name|toUri
argument_list|()
argument_list|,
name|conf
argument_list|)
decl_stmt|;
name|p
operator|=
name|p
operator|.
name|makeQualified
argument_list|(
name|fs
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
comment|/**    * Return the path prefix that stores the parity files    */
DECL|method|getDestinationPath (ErasureCodeType code, Configuration conf)
specifier|static
name|Path
name|getDestinationPath
parameter_list|(
name|ErasureCodeType
name|code
parameter_list|,
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|XOR
case|:
return|return
name|xorDestinationPath
argument_list|(
name|conf
argument_list|)
return|;
case|case
name|RS
case|:
return|return
name|rsDestinationPath
argument_list|(
name|conf
argument_list|)
return|;
default|default:
return|return
literal|null
return|;
block|}
block|}
DECL|method|encoderForCode (Configuration conf, ErasureCodeType code)
specifier|static
name|Encoder
name|encoderForCode
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|ErasureCodeType
name|code
parameter_list|)
block|{
name|int
name|stripeLength
init|=
name|getStripeLength
argument_list|(
name|conf
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|XOR
case|:
return|return
operator|new
name|XOREncoder
argument_list|(
name|conf
argument_list|,
name|stripeLength
argument_list|)
return|;
case|case
name|RS
case|:
return|return
operator|new
name|ReedSolomonEncoder
argument_list|(
name|conf
argument_list|,
name|stripeLength
argument_list|,
name|rsParityLength
argument_list|(
name|conf
argument_list|)
argument_list|)
return|;
default|default:
return|return
literal|null
return|;
block|}
block|}
DECL|method|tmpHarPathForCode (Configuration conf, ErasureCodeType code)
specifier|static
name|String
name|tmpHarPathForCode
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|ErasureCodeType
name|code
parameter_list|)
block|{
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|XOR
case|:
return|return
name|xorHarTempPrefix
argument_list|(
name|conf
argument_list|)
return|;
case|case
name|RS
case|:
return|return
name|rsHarTempPrefix
argument_list|(
name|conf
argument_list|)
return|;
default|default:
return|return
literal|null
return|;
block|}
block|}
comment|/**    * Obtain stripe length from configuration    */
DECL|method|getStripeLength (Configuration conf)
specifier|public
specifier|static
name|int
name|getStripeLength
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
return|return
name|conf
operator|.
name|getInt
argument_list|(
name|STRIPE_LENGTH_KEY
argument_list|,
name|DEFAULT_STRIPE_LENGTH
argument_list|)
return|;
block|}
comment|/**    * Obtain stripe length from configuration    */
DECL|method|rsParityLength (Configuration conf)
specifier|public
specifier|static
name|int
name|rsParityLength
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
return|return
name|conf
operator|.
name|getInt
argument_list|(
name|RS_PARITY_LENGTH_KEY
argument_list|,
name|RS_PARITY_LENGTH_DEFAULT
argument_list|)
return|;
block|}
DECL|method|isParityHarPartFile (Path p)
specifier|static
name|boolean
name|isParityHarPartFile
parameter_list|(
name|Path
name|p
parameter_list|)
block|{
name|Matcher
name|m
init|=
name|PARITY_HAR_PARTFILE_PATTERN
operator|.
name|matcher
argument_list|(
name|p
operator|.
name|toUri
argument_list|()
operator|.
name|getPath
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|m
operator|.
name|matches
argument_list|()
return|;
block|}
comment|/**    * Returns current time.    */
DECL|method|now ()
specifier|static
name|long
name|now
parameter_list|()
block|{
return|return
name|System
operator|.
name|currentTimeMillis
argument_list|()
return|;
block|}
comment|/**                           * Make an absolute path relative by stripping the leading /    */
DECL|method|makeRelative (Path path)
specifier|static
specifier|private
name|Path
name|makeRelative
parameter_list|(
name|Path
name|path
parameter_list|)
block|{
if|if
condition|(
operator|!
name|path
operator|.
name|isAbsolute
argument_list|()
condition|)
block|{
return|return
name|path
return|;
block|}
name|String
name|p
init|=
name|path
operator|.
name|toUri
argument_list|()
operator|.
name|getPath
argument_list|()
decl_stmt|;
name|String
name|relative
init|=
name|p
operator|.
name|substring
argument_list|(
literal|1
argument_list|,
name|p
operator|.
name|length
argument_list|()
argument_list|)
decl_stmt|;
return|return
operator|new
name|Path
argument_list|(
name|relative
argument_list|)
return|;
block|}
DECL|method|printUsage ()
specifier|private
specifier|static
name|void
name|printUsage
parameter_list|()
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Usage: java RaidNode "
argument_list|)
expr_stmt|;
block|}
DECL|method|parseArguments (String args[])
specifier|private
specifier|static
name|StartupOption
name|parseArguments
parameter_list|(
name|String
name|args
index|[]
parameter_list|)
block|{
name|int
name|argsLen
init|=
operator|(
name|args
operator|==
literal|null
operator|)
condition|?
literal|0
else|:
name|args
operator|.
name|length
decl_stmt|;
name|StartupOption
name|startOpt
init|=
name|StartupOption
operator|.
name|REGULAR
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|argsLen
condition|;
name|i
operator|++
control|)
block|{
name|String
name|cmd
init|=
name|args
index|[
name|i
index|]
decl_stmt|;
comment|// We have to parse command line args in future.
block|}
return|return
name|startOpt
return|;
block|}
comment|/**    * Convert command line options to configuration parameters    */
DECL|method|setStartupOption (Configuration conf, StartupOption opt)
specifier|private
specifier|static
name|void
name|setStartupOption
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|StartupOption
name|opt
parameter_list|)
block|{
name|conf
operator|.
name|set
argument_list|(
literal|"fs.raidnode.startup"
argument_list|,
name|opt
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Create an instance of the appropriate subclass of RaidNode     */
DECL|method|createRaidNode (Configuration conf)
specifier|public
specifier|static
name|RaidNode
name|createRaidNode
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|ClassNotFoundException
block|{
try|try
block|{
comment|// default to distributed raid node
name|Class
argument_list|<
name|?
argument_list|>
name|raidNodeClass
init|=
name|conf
operator|.
name|getClass
argument_list|(
name|RAIDNODE_CLASSNAME_KEY
argument_list|,
name|DistRaidNode
operator|.
name|class
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|RaidNode
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|raidNodeClass
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|ClassNotFoundException
argument_list|(
literal|"not an implementation of RaidNode"
argument_list|)
throw|;
block|}
name|Constructor
argument_list|<
name|?
argument_list|>
name|constructor
init|=
name|raidNodeClass
operator|.
name|getConstructor
argument_list|(
operator|new
name|Class
index|[]
block|{
name|Configuration
operator|.
name|class
block|}
argument_list|)
decl_stmt|;
return|return
operator|(
name|RaidNode
operator|)
name|constructor
operator|.
name|newInstance
argument_list|(
name|conf
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|NoSuchMethodException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|ClassNotFoundException
argument_list|(
literal|"cannot construct blockfixer"
argument_list|,
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|InstantiationException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|ClassNotFoundException
argument_list|(
literal|"cannot construct blockfixer"
argument_list|,
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|IllegalAccessException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|ClassNotFoundException
argument_list|(
literal|"cannot construct blockfixer"
argument_list|,
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|InvocationTargetException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|ClassNotFoundException
argument_list|(
literal|"cannot construct blockfixer"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**    * Create an instance of the RaidNode     */
DECL|method|createRaidNode (String argv[], Configuration conf)
specifier|public
specifier|static
name|RaidNode
name|createRaidNode
parameter_list|(
name|String
name|argv
index|[]
parameter_list|,
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
throws|,
name|ClassNotFoundException
block|{
if|if
condition|(
name|conf
operator|==
literal|null
condition|)
block|{
name|conf
operator|=
operator|new
name|Configuration
argument_list|()
expr_stmt|;
block|}
name|StartupOption
name|startOpt
init|=
name|parseArguments
argument_list|(
name|argv
argument_list|)
decl_stmt|;
if|if
condition|(
name|startOpt
operator|==
literal|null
condition|)
block|{
name|printUsage
argument_list|()
expr_stmt|;
return|return
literal|null
return|;
block|}
name|setStartupOption
argument_list|(
name|conf
argument_list|,
name|startOpt
argument_list|)
expr_stmt|;
name|RaidNode
name|node
init|=
name|createRaidNode
argument_list|(
name|conf
argument_list|)
decl_stmt|;
return|return
name|node
return|;
block|}
comment|/**    */
DECL|method|main (String argv[])
specifier|public
specifier|static
name|void
name|main
parameter_list|(
name|String
name|argv
index|[]
parameter_list|)
throws|throws
name|Exception
block|{
try|try
block|{
name|StringUtils
operator|.
name|startupShutdownMessage
argument_list|(
name|RaidNode
operator|.
name|class
argument_list|,
name|argv
argument_list|,
name|LOG
argument_list|)
expr_stmt|;
name|RaidNode
name|raid
init|=
name|createRaidNode
argument_list|(
name|argv
argument_list|,
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|raid
operator|!=
literal|null
condition|)
block|{
name|raid
operator|.
name|join
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
name|System
operator|.
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

