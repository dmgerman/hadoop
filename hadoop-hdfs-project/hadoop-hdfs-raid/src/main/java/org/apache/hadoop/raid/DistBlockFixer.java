begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.raid
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|raid
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|PrintStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStreamReader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|BufferedReader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Date
import|;
end_import

begin_import
import|import
name|java
operator|.
name|text
operator|.
name|SimpleDateFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FSDataOutputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DistributedFileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|RaidDFSUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|SequenceFile
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|Text
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|WritableComparable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|LongWritable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|Writable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Time
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|Mapper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|InputFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|Job
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|JobContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|InputSplit
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|lib
operator|.
name|input
operator|.
name|FileInputFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|lib
operator|.
name|input
operator|.
name|TextInputFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|lib
operator|.
name|input
operator|.
name|SequenceFileInputFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|lib
operator|.
name|input
operator|.
name|FileSplit
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|lib
operator|.
name|output
operator|.
name|TextOutputFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|lib
operator|.
name|output
operator|.
name|SequenceFileOutputFormat
import|;
end_import

begin_comment
comment|/**  * distributed block fixer, uses map reduce jobs to fix corrupt files  *  * configuration options  * raid.blockfix.filespertask       - number of corrupt files to fix in a single  *                                    map reduce task (i.e., at one mapper node)  *  * raid.blockfix.maxpendingfiles    - maximum number of files to fix   *                                    simultaneously  */
end_comment

begin_class
DECL|class|DistBlockFixer
specifier|public
class|class
name|DistBlockFixer
extends|extends
name|BlockFixer
block|{
comment|// volatile should be sufficient since only the block fixer thread
comment|// updates numJobsRunning (other threads may read)
DECL|field|numJobsRunning
specifier|private
specifier|volatile
name|int
name|numJobsRunning
init|=
literal|0
decl_stmt|;
DECL|field|WORK_DIR_PREFIX
specifier|private
specifier|static
specifier|final
name|String
name|WORK_DIR_PREFIX
init|=
literal|"blockfixer"
decl_stmt|;
DECL|field|IN_FILE_SUFFIX
specifier|private
specifier|static
specifier|final
name|String
name|IN_FILE_SUFFIX
init|=
literal|".in"
decl_stmt|;
DECL|field|PART_PREFIX
specifier|private
specifier|static
specifier|final
name|String
name|PART_PREFIX
init|=
literal|"part-"
decl_stmt|;
DECL|field|BLOCKFIX_FILES_PER_TASK
specifier|private
specifier|static
specifier|final
name|String
name|BLOCKFIX_FILES_PER_TASK
init|=
literal|"raid.blockfix.filespertask"
decl_stmt|;
DECL|field|BLOCKFIX_MAX_PENDING_FILES
specifier|private
specifier|static
specifier|final
name|String
name|BLOCKFIX_MAX_PENDING_FILES
init|=
literal|"raid.blockfix.maxpendingfiles"
decl_stmt|;
comment|// default number of files to fix in a task
DECL|field|DEFAULT_BLOCKFIX_FILES_PER_TASK
specifier|private
specifier|static
specifier|final
name|long
name|DEFAULT_BLOCKFIX_FILES_PER_TASK
init|=
literal|10L
decl_stmt|;
comment|// default number of files to fix simultaneously
DECL|field|DEFAULT_BLOCKFIX_MAX_PENDING_FILES
specifier|private
specifier|static
specifier|final
name|long
name|DEFAULT_BLOCKFIX_MAX_PENDING_FILES
init|=
literal|1000L
decl_stmt|;
DECL|field|LOG
specifier|protected
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|DistBlockFixer
operator|.
name|class
argument_list|)
decl_stmt|;
comment|// number of files to fix in a task
DECL|field|filesPerTask
specifier|private
name|long
name|filesPerTask
decl_stmt|;
comment|// number of files to fix simultaneously
DECL|field|maxPendingFiles
specifier|final
specifier|private
name|long
name|maxPendingFiles
decl_stmt|;
comment|// number of files being fixed right now
DECL|field|pendingFiles
specifier|private
name|long
name|pendingFiles
decl_stmt|;
DECL|field|lastCheckTime
specifier|private
name|long
name|lastCheckTime
decl_stmt|;
DECL|field|dateFormat
specifier|private
specifier|final
name|SimpleDateFormat
name|dateFormat
init|=
operator|new
name|SimpleDateFormat
argument_list|(
literal|"yyyy-MM-dd HH:mm:ss"
argument_list|)
decl_stmt|;
DECL|field|fileIndex
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|CorruptFileInfo
argument_list|>
name|fileIndex
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|CorruptFileInfo
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|jobIndex
specifier|private
name|Map
argument_list|<
name|Job
argument_list|,
name|List
argument_list|<
name|CorruptFileInfo
argument_list|>
argument_list|>
name|jobIndex
init|=
operator|new
name|HashMap
argument_list|<
name|Job
argument_list|,
name|List
argument_list|<
name|CorruptFileInfo
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
DECL|enum|Counter
specifier|static
enum|enum
name|Counter
block|{
DECL|enumConstant|FILES_SUCCEEDED
DECL|enumConstant|FILES_FAILED
DECL|enumConstant|FILES_NOACTION
name|FILES_SUCCEEDED
block|,
name|FILES_FAILED
block|,
name|FILES_NOACTION
block|}
DECL|method|DistBlockFixer (Configuration conf)
specifier|public
name|DistBlockFixer
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
name|super
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|filesPerTask
operator|=
name|DistBlockFixer
operator|.
name|filesPerTask
argument_list|(
name|getConf
argument_list|()
argument_list|)
expr_stmt|;
name|maxPendingFiles
operator|=
name|DistBlockFixer
operator|.
name|maxPendingFiles
argument_list|(
name|getConf
argument_list|()
argument_list|)
expr_stmt|;
name|pendingFiles
operator|=
literal|0L
expr_stmt|;
comment|// start off due for the first iteration
name|lastCheckTime
operator|=
name|Time
operator|.
name|now
argument_list|()
operator|-
name|blockFixInterval
expr_stmt|;
block|}
comment|/**    * determines how many files to fix in a single task    */
DECL|method|filesPerTask (Configuration conf)
specifier|protected
specifier|static
name|long
name|filesPerTask
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
return|return
name|conf
operator|.
name|getLong
argument_list|(
name|BLOCKFIX_FILES_PER_TASK
argument_list|,
name|DEFAULT_BLOCKFIX_FILES_PER_TASK
argument_list|)
return|;
block|}
comment|/**    * determines how many files to fix simultaneously    */
DECL|method|maxPendingFiles (Configuration conf)
specifier|protected
specifier|static
name|long
name|maxPendingFiles
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
return|return
name|conf
operator|.
name|getLong
argument_list|(
name|BLOCKFIX_MAX_PENDING_FILES
argument_list|,
name|DEFAULT_BLOCKFIX_MAX_PENDING_FILES
argument_list|)
return|;
block|}
comment|/**    * runs the block fixer periodically    */
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
while|while
condition|(
name|running
condition|)
block|{
comment|// check if it is time to run the block fixer
name|long
name|now
init|=
name|Time
operator|.
name|now
argument_list|()
decl_stmt|;
if|if
condition|(
name|now
operator|>=
name|lastCheckTime
operator|+
name|blockFixInterval
condition|)
block|{
name|lastCheckTime
operator|=
name|now
expr_stmt|;
try|try
block|{
name|checkAndFixBlocks
argument_list|(
name|now
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ignore
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"interrupted"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
comment|// log exceptions and keep running
name|LOG
operator|.
name|error
argument_list|(
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Error
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
comment|// try to sleep for the remainder of the interval
name|long
name|sleepPeriod
init|=
operator|(
name|lastCheckTime
operator|-
name|Time
operator|.
name|now
argument_list|()
operator|)
operator|+
name|blockFixInterval
decl_stmt|;
if|if
condition|(
operator|(
name|sleepPeriod
operator|>
literal|0L
operator|)
operator|&&
name|running
condition|)
block|{
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|sleepPeriod
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ignore
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"interrupted"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**    * checks for corrupt blocks and fixes them (if any)    */
DECL|method|checkAndFixBlocks (long startTime)
specifier|private
name|void
name|checkAndFixBlocks
parameter_list|(
name|long
name|startTime
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
throws|,
name|ClassNotFoundException
block|{
name|checkJobs
argument_list|()
expr_stmt|;
if|if
condition|(
name|pendingFiles
operator|>=
name|maxPendingFiles
condition|)
block|{
return|return;
block|}
name|List
argument_list|<
name|Path
argument_list|>
name|corruptFiles
init|=
name|getCorruptFiles
argument_list|()
decl_stmt|;
name|filterUnfixableSourceFiles
argument_list|(
name|corruptFiles
operator|.
name|iterator
argument_list|()
argument_list|)
expr_stmt|;
name|String
name|startTimeStr
init|=
name|dateFormat
operator|.
name|format
argument_list|(
operator|new
name|Date
argument_list|(
name|startTime
argument_list|)
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"found "
operator|+
name|corruptFiles
operator|.
name|size
argument_list|()
operator|+
literal|" corrupt files"
argument_list|)
expr_stmt|;
if|if
condition|(
name|corruptFiles
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|String
name|jobName
init|=
literal|"blockfixer."
operator|+
name|startTime
decl_stmt|;
name|startJob
argument_list|(
name|jobName
argument_list|,
name|corruptFiles
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Handle a failed job.    */
DECL|method|failJob (Job job)
specifier|private
name|void
name|failJob
parameter_list|(
name|Job
name|job
parameter_list|)
throws|throws
name|IOException
block|{
comment|// assume no files have been fixed
name|LOG
operator|.
name|error
argument_list|(
literal|"DistBlockFixer job "
operator|+
name|job
operator|.
name|getJobID
argument_list|()
operator|+
literal|"("
operator|+
name|job
operator|.
name|getJobName
argument_list|()
operator|+
literal|") finished (failed)"
argument_list|)
expr_stmt|;
for|for
control|(
name|CorruptFileInfo
name|fileInfo
range|:
name|jobIndex
operator|.
name|get
argument_list|(
name|job
argument_list|)
control|)
block|{
name|fileInfo
operator|.
name|fail
argument_list|()
expr_stmt|;
block|}
name|numJobsRunning
operator|--
expr_stmt|;
block|}
comment|/**    * Handle a successful job.    */
DECL|method|succeedJob (Job job, long filesSucceeded, long filesFailed)
specifier|private
name|void
name|succeedJob
parameter_list|(
name|Job
name|job
parameter_list|,
name|long
name|filesSucceeded
parameter_list|,
name|long
name|filesFailed
parameter_list|)
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"DistBlockFixer job "
operator|+
name|job
operator|.
name|getJobID
argument_list|()
operator|+
literal|"("
operator|+
name|job
operator|.
name|getJobName
argument_list|()
operator|+
literal|") finished (succeeded)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|filesFailed
operator|==
literal|0
condition|)
block|{
comment|// no files have failed
for|for
control|(
name|CorruptFileInfo
name|fileInfo
range|:
name|jobIndex
operator|.
name|get
argument_list|(
name|job
argument_list|)
control|)
block|{
name|fileInfo
operator|.
name|succeed
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// we have to look at the output to check which files have failed
name|Set
argument_list|<
name|String
argument_list|>
name|failedFiles
init|=
name|getFailedFiles
argument_list|(
name|job
argument_list|)
decl_stmt|;
for|for
control|(
name|CorruptFileInfo
name|fileInfo
range|:
name|jobIndex
operator|.
name|get
argument_list|(
name|job
argument_list|)
control|)
block|{
if|if
condition|(
name|failedFiles
operator|.
name|contains
argument_list|(
name|fileInfo
operator|.
name|getFile
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
condition|)
block|{
name|fileInfo
operator|.
name|fail
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// call succeed for files that have succeeded or for which no action
comment|// was taken
name|fileInfo
operator|.
name|succeed
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|// report succeeded files to metrics
name|incrFilesFixed
argument_list|(
name|filesSucceeded
argument_list|)
expr_stmt|;
name|numJobsRunning
operator|--
expr_stmt|;
block|}
comment|/**    * checks if jobs have completed and updates job and file index    * returns a list of failed files for restarting    */
DECL|method|checkJobs ()
specifier|private
name|void
name|checkJobs
parameter_list|()
throws|throws
name|IOException
block|{
name|Iterator
argument_list|<
name|Job
argument_list|>
name|jobIter
init|=
name|jobIndex
operator|.
name|keySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|jobIter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Job
name|job
init|=
name|jobIter
operator|.
name|next
argument_list|()
decl_stmt|;
try|try
block|{
if|if
condition|(
name|job
operator|.
name|isComplete
argument_list|()
condition|)
block|{
name|long
name|filesSucceeded
init|=
name|job
operator|.
name|getCounters
argument_list|()
operator|.
name|findCounter
argument_list|(
name|Counter
operator|.
name|FILES_SUCCEEDED
argument_list|)
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|long
name|filesFailed
init|=
name|job
operator|.
name|getCounters
argument_list|()
operator|.
name|findCounter
argument_list|(
name|Counter
operator|.
name|FILES_FAILED
argument_list|)
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|long
name|filesNoAction
init|=
name|job
operator|.
name|getCounters
argument_list|()
operator|.
name|findCounter
argument_list|(
name|Counter
operator|.
name|FILES_NOACTION
argument_list|)
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|int
name|files
init|=
name|jobIndex
operator|.
name|get
argument_list|(
name|job
argument_list|)
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|job
operator|.
name|isSuccessful
argument_list|()
operator|&&
operator|(
name|filesSucceeded
operator|+
name|filesFailed
operator|+
name|filesNoAction
operator|==
operator|(
operator|(
name|long
operator|)
name|files
operator|)
operator|)
condition|)
block|{
comment|// job has processed all files
name|succeedJob
argument_list|(
name|job
argument_list|,
name|filesSucceeded
argument_list|,
name|filesFailed
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|failJob
argument_list|(
name|job
argument_list|)
expr_stmt|;
block|}
name|jobIter
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"job "
operator|+
name|job
operator|.
name|getJobName
argument_list|()
operator|+
literal|" still running"
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
name|failJob
argument_list|(
name|job
argument_list|)
expr_stmt|;
try|try
block|{
name|job
operator|.
name|killJob
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ee
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|ee
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|jobIter
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
name|purgeFileIndex
argument_list|()
expr_stmt|;
block|}
comment|/**    * determines which files have failed for a given job    */
DECL|method|getFailedFiles (Job job)
specifier|private
name|Set
argument_list|<
name|String
argument_list|>
name|getFailedFiles
parameter_list|(
name|Job
name|job
parameter_list|)
throws|throws
name|IOException
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|failedFiles
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|Path
name|outDir
init|=
name|SequenceFileOutputFormat
operator|.
name|getOutputPath
argument_list|(
name|job
argument_list|)
decl_stmt|;
name|FileSystem
name|fs
init|=
name|outDir
operator|.
name|getFileSystem
argument_list|(
name|getConf
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|fs
operator|.
name|getFileStatus
argument_list|(
name|outDir
argument_list|)
operator|.
name|isDir
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|outDir
operator|.
name|toString
argument_list|()
operator|+
literal|" is not a directory"
argument_list|)
throw|;
block|}
name|FileStatus
index|[]
name|files
init|=
name|fs
operator|.
name|listStatus
argument_list|(
name|outDir
argument_list|)
decl_stmt|;
for|for
control|(
name|FileStatus
name|f
range|:
name|files
control|)
block|{
name|Path
name|fPath
init|=
name|f
operator|.
name|getPath
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
operator|!
name|f
operator|.
name|isDir
argument_list|()
operator|)
operator|&&
operator|(
name|fPath
operator|.
name|getName
argument_list|()
operator|.
name|startsWith
argument_list|(
name|PART_PREFIX
argument_list|)
operator|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"opening "
operator|+
name|fPath
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|SequenceFile
operator|.
name|Reader
name|reader
init|=
operator|new
name|SequenceFile
operator|.
name|Reader
argument_list|(
name|fs
argument_list|,
name|fPath
argument_list|,
name|getConf
argument_list|()
argument_list|)
decl_stmt|;
name|Text
name|key
init|=
operator|new
name|Text
argument_list|()
decl_stmt|;
name|Text
name|value
init|=
operator|new
name|Text
argument_list|()
decl_stmt|;
while|while
condition|(
name|reader
operator|.
name|next
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
condition|)
block|{
name|failedFiles
operator|.
name|add
argument_list|(
name|key
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|reader
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|failedFiles
return|;
block|}
comment|/**    * purge expired jobs from the file index    */
DECL|method|purgeFileIndex ()
specifier|private
name|void
name|purgeFileIndex
parameter_list|()
block|{
name|Iterator
argument_list|<
name|String
argument_list|>
name|fileIter
init|=
name|fileIndex
operator|.
name|keySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|fileIter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|String
name|file
init|=
name|fileIter
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|fileIndex
operator|.
name|get
argument_list|(
name|file
argument_list|)
operator|.
name|isExpired
argument_list|()
condition|)
block|{
name|fileIter
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**    * creates and submits a job, updates file index and job index    */
DECL|method|startJob (String jobName, List<Path> corruptFiles)
specifier|private
name|Job
name|startJob
parameter_list|(
name|String
name|jobName
parameter_list|,
name|List
argument_list|<
name|Path
argument_list|>
name|corruptFiles
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
throws|,
name|ClassNotFoundException
block|{
name|Path
name|inDir
init|=
operator|new
name|Path
argument_list|(
name|WORK_DIR_PREFIX
operator|+
literal|"/in/"
operator|+
name|jobName
argument_list|)
decl_stmt|;
name|Path
name|outDir
init|=
operator|new
name|Path
argument_list|(
name|WORK_DIR_PREFIX
operator|+
literal|"/out/"
operator|+
name|jobName
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Path
argument_list|>
name|filesInJob
init|=
name|createInputFile
argument_list|(
name|jobName
argument_list|,
name|inDir
argument_list|,
name|corruptFiles
argument_list|)
decl_stmt|;
name|Configuration
name|jobConf
init|=
operator|new
name|Configuration
argument_list|(
name|getConf
argument_list|()
argument_list|)
decl_stmt|;
name|Job
name|job
init|=
operator|new
name|Job
argument_list|(
name|jobConf
argument_list|,
name|jobName
argument_list|)
decl_stmt|;
name|job
operator|.
name|setJarByClass
argument_list|(
name|getClass
argument_list|()
argument_list|)
expr_stmt|;
name|job
operator|.
name|setMapperClass
argument_list|(
name|DistBlockFixerMapper
operator|.
name|class
argument_list|)
expr_stmt|;
name|job
operator|.
name|setNumReduceTasks
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|job
operator|.
name|setInputFormatClass
argument_list|(
name|DistBlockFixerInputFormat
operator|.
name|class
argument_list|)
expr_stmt|;
name|job
operator|.
name|setOutputFormatClass
argument_list|(
name|SequenceFileOutputFormat
operator|.
name|class
argument_list|)
expr_stmt|;
name|job
operator|.
name|setOutputKeyClass
argument_list|(
name|Text
operator|.
name|class
argument_list|)
expr_stmt|;
name|job
operator|.
name|setOutputValueClass
argument_list|(
name|Text
operator|.
name|class
argument_list|)
expr_stmt|;
name|DistBlockFixerInputFormat
operator|.
name|setInputPaths
argument_list|(
name|job
argument_list|,
name|inDir
argument_list|)
expr_stmt|;
name|SequenceFileOutputFormat
operator|.
name|setOutputPath
argument_list|(
name|job
argument_list|,
name|outDir
argument_list|)
expr_stmt|;
name|job
operator|.
name|submit
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"DistBlockFixer job "
operator|+
name|job
operator|.
name|getJobID
argument_list|()
operator|+
literal|"("
operator|+
name|job
operator|.
name|getJobName
argument_list|()
operator|+
literal|") started"
argument_list|)
expr_stmt|;
comment|// submit the job before inserting it into the index
comment|// this way, if submit fails, we won't have added anything to the index
name|insertJob
argument_list|(
name|job
argument_list|,
name|filesInJob
argument_list|)
expr_stmt|;
return|return
name|job
return|;
block|}
comment|/**    * inserts new job into file index and job index    */
DECL|method|insertJob (Job job, List<Path> corruptFiles)
specifier|private
name|void
name|insertJob
parameter_list|(
name|Job
name|job
parameter_list|,
name|List
argument_list|<
name|Path
argument_list|>
name|corruptFiles
parameter_list|)
block|{
name|List
argument_list|<
name|CorruptFileInfo
argument_list|>
name|fileInfos
init|=
operator|new
name|LinkedList
argument_list|<
name|CorruptFileInfo
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Path
name|file
range|:
name|corruptFiles
control|)
block|{
name|CorruptFileInfo
name|fileInfo
init|=
operator|new
name|CorruptFileInfo
argument_list|(
name|file
argument_list|,
name|job
argument_list|)
decl_stmt|;
name|fileInfos
operator|.
name|add
argument_list|(
name|fileInfo
argument_list|)
expr_stmt|;
name|fileIndex
operator|.
name|put
argument_list|(
name|file
operator|.
name|toString
argument_list|()
argument_list|,
name|fileInfo
argument_list|)
expr_stmt|;
block|}
name|jobIndex
operator|.
name|put
argument_list|(
name|job
argument_list|,
name|fileInfos
argument_list|)
expr_stmt|;
name|numJobsRunning
operator|++
expr_stmt|;
block|}
comment|/**    * creates the input file (containing the names of the files to be fixed    */
DECL|method|createInputFile (String jobName, Path inDir, List<Path> corruptFiles)
specifier|private
name|List
argument_list|<
name|Path
argument_list|>
name|createInputFile
parameter_list|(
name|String
name|jobName
parameter_list|,
name|Path
name|inDir
parameter_list|,
name|List
argument_list|<
name|Path
argument_list|>
name|corruptFiles
parameter_list|)
throws|throws
name|IOException
block|{
name|Path
name|file
init|=
operator|new
name|Path
argument_list|(
name|inDir
argument_list|,
name|jobName
operator|+
name|IN_FILE_SUFFIX
argument_list|)
decl_stmt|;
name|FileSystem
name|fs
init|=
name|file
operator|.
name|getFileSystem
argument_list|(
name|getConf
argument_list|()
argument_list|)
decl_stmt|;
name|SequenceFile
operator|.
name|Writer
name|fileOut
init|=
name|SequenceFile
operator|.
name|createWriter
argument_list|(
name|fs
argument_list|,
name|getConf
argument_list|()
argument_list|,
name|file
argument_list|,
name|LongWritable
operator|.
name|class
argument_list|,
name|Text
operator|.
name|class
argument_list|)
decl_stmt|;
name|long
name|index
init|=
literal|0L
decl_stmt|;
name|List
argument_list|<
name|Path
argument_list|>
name|filesAdded
init|=
operator|new
name|LinkedList
argument_list|<
name|Path
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Path
name|corruptFile
range|:
name|corruptFiles
control|)
block|{
if|if
condition|(
name|pendingFiles
operator|>=
name|maxPendingFiles
condition|)
block|{
break|break;
block|}
name|String
name|corruptFileName
init|=
name|corruptFile
operator|.
name|toString
argument_list|()
decl_stmt|;
name|fileOut
operator|.
name|append
argument_list|(
operator|new
name|LongWritable
argument_list|(
name|index
operator|++
argument_list|)
argument_list|,
operator|new
name|Text
argument_list|(
name|corruptFileName
argument_list|)
argument_list|)
expr_stmt|;
name|filesAdded
operator|.
name|add
argument_list|(
name|corruptFile
argument_list|)
expr_stmt|;
name|pendingFiles
operator|++
expr_stmt|;
if|if
condition|(
name|index
operator|%
name|filesPerTask
operator|==
literal|0
condition|)
block|{
name|fileOut
operator|.
name|sync
argument_list|()
expr_stmt|;
comment|// create sync point to make sure we can split here
block|}
block|}
name|fileOut
operator|.
name|close
argument_list|()
expr_stmt|;
return|return
name|filesAdded
return|;
block|}
comment|/**    * gets a list of corrupt files from the name node    * and filters out files that are currently being fixed or     * that were recently fixed    */
DECL|method|getCorruptFiles ()
specifier|private
name|List
argument_list|<
name|Path
argument_list|>
name|getCorruptFiles
parameter_list|()
throws|throws
name|IOException
block|{
name|DistributedFileSystem
name|dfs
init|=
call|(
name|DistributedFileSystem
call|)
argument_list|(
operator|new
name|Path
argument_list|(
literal|"/"
argument_list|)
argument_list|)
operator|.
name|getFileSystem
argument_list|(
name|getConf
argument_list|()
argument_list|)
decl_stmt|;
name|String
index|[]
name|files
init|=
name|RaidDFSUtil
operator|.
name|getCorruptFiles
argument_list|(
name|dfs
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Path
argument_list|>
name|corruptFiles
init|=
operator|new
name|LinkedList
argument_list|<
name|Path
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|f
range|:
name|files
control|)
block|{
name|Path
name|p
init|=
operator|new
name|Path
argument_list|(
name|f
argument_list|)
decl_stmt|;
comment|// filter out files that are being fixed or that were recently fixed
if|if
condition|(
operator|!
name|fileIndex
operator|.
name|containsKey
argument_list|(
name|p
operator|.
name|toString
argument_list|()
argument_list|)
condition|)
block|{
name|corruptFiles
operator|.
name|add
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
name|RaidUtils
operator|.
name|filterTrash
argument_list|(
name|getConf
argument_list|()
argument_list|,
name|corruptFiles
argument_list|)
expr_stmt|;
return|return
name|corruptFiles
return|;
block|}
comment|/**    * returns the number of map reduce jobs running    */
DECL|method|jobsRunning ()
specifier|public
name|int
name|jobsRunning
parameter_list|()
block|{
return|return
name|numJobsRunning
return|;
block|}
comment|/**    * hold information about a corrupt file that is being fixed    */
DECL|class|CorruptFileInfo
class|class
name|CorruptFileInfo
block|{
DECL|field|file
specifier|private
name|Path
name|file
decl_stmt|;
DECL|field|job
specifier|private
name|Job
name|job
decl_stmt|;
DECL|field|done
specifier|private
name|boolean
name|done
decl_stmt|;
DECL|field|time
specifier|private
name|long
name|time
decl_stmt|;
DECL|method|CorruptFileInfo (Path file, Job job)
specifier|public
name|CorruptFileInfo
parameter_list|(
name|Path
name|file
parameter_list|,
name|Job
name|job
parameter_list|)
block|{
name|this
operator|.
name|file
operator|=
name|file
expr_stmt|;
name|this
operator|.
name|job
operator|=
name|job
expr_stmt|;
name|this
operator|.
name|done
operator|=
literal|false
expr_stmt|;
name|this
operator|.
name|time
operator|=
literal|0
expr_stmt|;
block|}
DECL|method|isDone ()
specifier|public
name|boolean
name|isDone
parameter_list|()
block|{
return|return
name|done
return|;
block|}
DECL|method|isExpired ()
specifier|public
name|boolean
name|isExpired
parameter_list|()
block|{
return|return
name|done
operator|&&
operator|(
operator|(
name|Time
operator|.
name|now
argument_list|()
operator|-
name|time
operator|)
operator|>
name|historyInterval
operator|)
return|;
block|}
DECL|method|getFile ()
specifier|public
name|Path
name|getFile
parameter_list|()
block|{
return|return
name|file
return|;
block|}
comment|/**      * updates file index to record a failed attempt at fixing a file,      * immediately removes the entry from the file index       * (instead of letting it expire)      * so that we can retry right away      */
DECL|method|fail ()
specifier|public
name|void
name|fail
parameter_list|()
block|{
comment|// remove this file from the index
name|CorruptFileInfo
name|removed
init|=
name|fileIndex
operator|.
name|remove
argument_list|(
name|file
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|removed
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"trying to remove file not in file index: "
operator|+
name|file
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"fixing "
operator|+
name|file
operator|.
name|toString
argument_list|()
operator|+
literal|" failed"
argument_list|)
expr_stmt|;
block|}
name|pendingFiles
operator|--
expr_stmt|;
block|}
comment|/**      * marks a file as fixed successfully      * and sets time stamp for expiry after specified interval      */
DECL|method|succeed ()
specifier|public
name|void
name|succeed
parameter_list|()
block|{
comment|// leave the file in the index,
comment|// will be pruged later
name|job
operator|=
literal|null
expr_stmt|;
name|done
operator|=
literal|true
expr_stmt|;
name|time
operator|=
name|Time
operator|.
name|now
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"fixing "
operator|+
name|file
operator|.
name|toString
argument_list|()
operator|+
literal|" succeeded"
argument_list|)
expr_stmt|;
name|pendingFiles
operator|--
expr_stmt|;
block|}
block|}
DECL|class|DistBlockFixerInputFormat
specifier|static
class|class
name|DistBlockFixerInputFormat
extends|extends
name|SequenceFileInputFormat
argument_list|<
name|LongWritable
argument_list|,
name|Text
argument_list|>
block|{
DECL|field|LOG
specifier|protected
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|DistBlockFixerMapper
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/**      * splits the input files into tasks handled by a single node      * we have to read the input files to do this based on a number of       * items in a sequence      */
annotation|@
name|Override
DECL|method|getSplits (JobContext job)
specifier|public
name|List
argument_list|<
name|InputSplit
argument_list|>
name|getSplits
parameter_list|(
name|JobContext
name|job
parameter_list|)
throws|throws
name|IOException
block|{
name|long
name|filesPerTask
init|=
name|DistBlockFixer
operator|.
name|filesPerTask
argument_list|(
name|job
operator|.
name|getConfiguration
argument_list|()
argument_list|)
decl_stmt|;
name|Path
index|[]
name|inPaths
init|=
name|getInputPaths
argument_list|(
name|job
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|InputSplit
argument_list|>
name|splits
init|=
operator|new
name|LinkedList
argument_list|<
name|InputSplit
argument_list|>
argument_list|()
decl_stmt|;
name|long
name|fileCounter
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Path
name|inPath
range|:
name|inPaths
control|)
block|{
name|FileSystem
name|fs
init|=
name|inPath
operator|.
name|getFileSystem
argument_list|(
name|job
operator|.
name|getConfiguration
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|fs
operator|.
name|getFileStatus
argument_list|(
name|inPath
argument_list|)
operator|.
name|isDir
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|inPath
operator|.
name|toString
argument_list|()
operator|+
literal|" is not a directory"
argument_list|)
throw|;
block|}
name|FileStatus
index|[]
name|inFiles
init|=
name|fs
operator|.
name|listStatus
argument_list|(
name|inPath
argument_list|)
decl_stmt|;
for|for
control|(
name|FileStatus
name|inFileStatus
range|:
name|inFiles
control|)
block|{
name|Path
name|inFile
init|=
name|inFileStatus
operator|.
name|getPath
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|inFileStatus
operator|.
name|isDir
argument_list|()
operator|&&
operator|(
name|inFile
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|job
operator|.
name|getJobName
argument_list|()
operator|+
name|IN_FILE_SUFFIX
argument_list|)
operator|)
condition|)
block|{
name|fileCounter
operator|++
expr_stmt|;
name|SequenceFile
operator|.
name|Reader
name|inFileReader
init|=
operator|new
name|SequenceFile
operator|.
name|Reader
argument_list|(
name|fs
argument_list|,
name|inFile
argument_list|,
name|job
operator|.
name|getConfiguration
argument_list|()
argument_list|)
decl_stmt|;
name|long
name|startPos
init|=
name|inFileReader
operator|.
name|getPosition
argument_list|()
decl_stmt|;
name|long
name|counter
init|=
literal|0
decl_stmt|;
comment|// create an input split every filesPerTask items in the sequence
name|LongWritable
name|key
init|=
operator|new
name|LongWritable
argument_list|()
decl_stmt|;
name|Text
name|value
init|=
operator|new
name|Text
argument_list|()
decl_stmt|;
try|try
block|{
while|while
condition|(
name|inFileReader
operator|.
name|next
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
condition|)
block|{
if|if
condition|(
name|counter
operator|%
name|filesPerTask
operator|==
name|filesPerTask
operator|-
literal|1L
condition|)
block|{
name|splits
operator|.
name|add
argument_list|(
operator|new
name|FileSplit
argument_list|(
name|inFile
argument_list|,
name|startPos
argument_list|,
name|inFileReader
operator|.
name|getPosition
argument_list|()
operator|-
name|startPos
argument_list|,
literal|null
argument_list|)
argument_list|)
expr_stmt|;
name|startPos
operator|=
name|inFileReader
operator|.
name|getPosition
argument_list|()
expr_stmt|;
block|}
name|counter
operator|++
expr_stmt|;
block|}
comment|// create input split for remaining items if necessary
comment|// this includes the case where no splits were created by the loop
if|if
condition|(
name|startPos
operator|!=
name|inFileReader
operator|.
name|getPosition
argument_list|()
condition|)
block|{
name|splits
operator|.
name|add
argument_list|(
operator|new
name|FileSplit
argument_list|(
name|inFile
argument_list|,
name|startPos
argument_list|,
name|inFileReader
operator|.
name|getPosition
argument_list|()
operator|-
name|startPos
argument_list|,
literal|null
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|inFileReader
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"created "
operator|+
name|splits
operator|.
name|size
argument_list|()
operator|+
literal|" input splits from "
operator|+
name|fileCounter
operator|+
literal|" files"
argument_list|)
expr_stmt|;
return|return
name|splits
return|;
block|}
comment|/**      * indicates that input file can be split      */
annotation|@
name|Override
DECL|method|isSplitable (JobContext job, Path file)
specifier|public
name|boolean
name|isSplitable
parameter_list|(
name|JobContext
name|job
parameter_list|,
name|Path
name|file
parameter_list|)
block|{
return|return
literal|true
return|;
block|}
block|}
comment|/**    * mapper for fixing stripes with corrupt blocks    */
DECL|class|DistBlockFixerMapper
specifier|static
class|class
name|DistBlockFixerMapper
extends|extends
name|Mapper
argument_list|<
name|LongWritable
argument_list|,
name|Text
argument_list|,
name|Text
argument_list|,
name|Text
argument_list|>
block|{
DECL|field|LOG
specifier|protected
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|DistBlockFixerMapper
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/**      * fix a stripe      */
annotation|@
name|Override
DECL|method|map (LongWritable key, Text fileText, Context context)
specifier|public
name|void
name|map
parameter_list|(
name|LongWritable
name|key
parameter_list|,
name|Text
name|fileText
parameter_list|,
name|Context
name|context
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|BlockFixerHelper
name|helper
init|=
operator|new
name|BlockFixerHelper
argument_list|(
name|context
operator|.
name|getConfiguration
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|fileStr
init|=
name|fileText
operator|.
name|toString
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"fixing "
operator|+
name|fileStr
argument_list|)
expr_stmt|;
name|Path
name|file
init|=
operator|new
name|Path
argument_list|(
name|fileStr
argument_list|)
decl_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
try|try
block|{
name|boolean
name|fixed
init|=
name|helper
operator|.
name|fixFile
argument_list|(
name|file
argument_list|,
name|context
argument_list|)
decl_stmt|;
if|if
condition|(
name|fixed
condition|)
block|{
name|context
operator|.
name|getCounter
argument_list|(
name|Counter
operator|.
name|FILES_SUCCEEDED
argument_list|)
operator|.
name|increment
argument_list|(
literal|1L
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|context
operator|.
name|getCounter
argument_list|(
name|Counter
operator|.
name|FILES_NOACTION
argument_list|)
operator|.
name|increment
argument_list|(
literal|1L
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
comment|// report file as failed
name|context
operator|.
name|getCounter
argument_list|(
name|Counter
operator|.
name|FILES_FAILED
argument_list|)
operator|.
name|increment
argument_list|(
literal|1L
argument_list|)
expr_stmt|;
name|String
name|outkey
init|=
name|fileStr
decl_stmt|;
name|String
name|outval
init|=
literal|"failed"
decl_stmt|;
name|context
operator|.
name|write
argument_list|(
operator|new
name|Text
argument_list|(
name|outkey
argument_list|)
argument_list|,
operator|new
name|Text
argument_list|(
name|outval
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|context
operator|.
name|progress
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

