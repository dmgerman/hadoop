begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_package
DECL|package|org.apache.hadoop.cmake.maven.ng
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|cmake
operator|.
name|maven
operator|.
name|ng
package|;
end_package

begin_comment
comment|/*  * Copyright 2012 The Apache Software Foundation.  *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|maven
operator|.
name|plugin
operator|.
name|MojoExecutionException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|BufferedWriter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStreamReader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStreamWriter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|UnsupportedEncodingException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_comment
comment|/**  * Utilities.  */
end_comment

begin_class
DECL|class|Utils
specifier|public
class|class
name|Utils
block|{
DECL|method|validatePlatform ()
specifier|static
name|void
name|validatePlatform
parameter_list|()
throws|throws
name|MojoExecutionException
block|{
if|if
condition|(
name|System
operator|.
name|getProperty
argument_list|(
literal|"os.name"
argument_list|)
operator|.
name|toLowerCase
argument_list|()
operator|.
name|startsWith
argument_list|(
literal|"windows"
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|MojoExecutionException
argument_list|(
literal|"CMake-NG does not (yet) support "
operator|+
literal|"the Windows platform."
argument_list|)
throw|;
block|}
block|}
comment|/**    * Validate that the parameters look sane.    */
DECL|method|validateParams (File output, File source)
specifier|static
name|void
name|validateParams
parameter_list|(
name|File
name|output
parameter_list|,
name|File
name|source
parameter_list|)
throws|throws
name|MojoExecutionException
block|{
name|String
name|cOutput
init|=
literal|null
decl_stmt|,
name|cSource
init|=
literal|null
decl_stmt|;
try|try
block|{
name|cOutput
operator|=
name|output
operator|.
name|getCanonicalPath
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|MojoExecutionException
argument_list|(
literal|"error getting canonical path "
operator|+
literal|"for output"
argument_list|)
throw|;
block|}
try|try
block|{
name|cSource
operator|=
name|source
operator|.
name|getCanonicalPath
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|MojoExecutionException
argument_list|(
literal|"error getting canonical path "
operator|+
literal|"for source"
argument_list|)
throw|;
block|}
comment|// This doesn't catch all the bad cases-- we could be following symlinks or
comment|// hardlinks, etc.  However, this will usually catch a common mistake.
if|if
condition|(
name|cSource
operator|.
name|startsWith
argument_list|(
name|cOutput
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|MojoExecutionException
argument_list|(
literal|"The source directory must not be "
operator|+
literal|"inside the output directory (it would be destroyed by "
operator|+
literal|"'mvn clean')"
argument_list|)
throw|;
block|}
block|}
comment|/**    * Add environment variables to a ProcessBuilder.    */
DECL|method|addEnvironment (ProcessBuilder pb, Map<String, String> env)
specifier|static
name|void
name|addEnvironment
parameter_list|(
name|ProcessBuilder
name|pb
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|env
parameter_list|)
block|{
if|if
condition|(
name|env
operator|==
literal|null
condition|)
block|{
return|return;
block|}
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|processEnv
init|=
name|pb
operator|.
name|environment
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|entry
range|:
name|env
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|String
name|val
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|val
operator|==
literal|null
condition|)
block|{
name|val
operator|=
literal|""
expr_stmt|;
block|}
name|processEnv
operator|.
name|put
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Pretty-print the environment.    */
DECL|method|envronmentToString (StringBuilder bld, Map<String, String> env)
specifier|static
name|void
name|envronmentToString
parameter_list|(
name|StringBuilder
name|bld
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|env
parameter_list|)
block|{
if|if
condition|(
operator|(
name|env
operator|==
literal|null
operator|)
operator|||
operator|(
name|env
operator|.
name|isEmpty
argument_list|()
operator|)
condition|)
block|{
return|return;
block|}
name|bld
operator|.
name|append
argument_list|(
literal|"ENV: "
argument_list|)
expr_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|entry
range|:
name|env
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|String
name|val
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|val
operator|==
literal|null
condition|)
block|{
name|val
operator|=
literal|""
expr_stmt|;
block|}
name|bld
operator|.
name|append
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|" = "
argument_list|)
operator|.
name|append
argument_list|(
name|val
argument_list|)
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|bld
operator|.
name|append
argument_list|(
literal|"======================================="
operator|+
literal|"========================================\n"
argument_list|)
expr_stmt|;
block|}
comment|/**    * This thread reads the output of the a subprocess and buffers it.    *    * Note that because of the way the Java Process APIs are designed, even    * if we didn't intend to ever display this output, we still would    * have to read it.  We are connected to the subprocess via a blocking pipe,    * and if we stop draining our end of the pipe, the subprocess will    * eventually be blocked if it writes enough to stdout/stderr.    */
DECL|class|OutputBufferThread
specifier|public
specifier|static
class|class
name|OutputBufferThread
extends|extends
name|Thread
block|{
DECL|field|reader
specifier|private
name|InputStreamReader
name|reader
decl_stmt|;
DECL|field|bufs
specifier|private
name|ArrayList
argument_list|<
name|char
index|[]
argument_list|>
name|bufs
decl_stmt|;
DECL|method|OutputBufferThread (InputStream is)
specifier|public
name|OutputBufferThread
parameter_list|(
name|InputStream
name|is
parameter_list|)
throws|throws
name|UnsupportedEncodingException
block|{
name|this
operator|.
name|reader
operator|=
operator|new
name|InputStreamReader
argument_list|(
name|is
argument_list|,
literal|"UTF8"
argument_list|)
expr_stmt|;
name|this
operator|.
name|bufs
operator|=
operator|new
name|ArrayList
argument_list|<
name|char
index|[]
argument_list|>
argument_list|()
expr_stmt|;
block|}
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
try|try
block|{
name|char
index|[]
name|arr
init|=
operator|new
name|char
index|[
literal|8192
index|]
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|int
name|amt
init|=
name|reader
operator|.
name|read
argument_list|(
name|arr
argument_list|)
decl_stmt|;
if|if
condition|(
name|amt
operator|<
literal|0
condition|)
return|return;
name|char
index|[]
name|arr2
init|=
operator|new
name|char
index|[
name|amt
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|amt
condition|;
name|i
operator|++
control|)
block|{
name|arr2
index|[
name|i
index|]
operator|=
name|arr
index|[
name|i
index|]
expr_stmt|;
block|}
name|bufs
operator|.
name|add
argument_list|(
name|arr2
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|e
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
try|try
block|{
name|reader
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|e
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
block|}
block|}
DECL|method|printBufs ()
specifier|public
name|void
name|printBufs
parameter_list|()
block|{
for|for
control|(
name|char
index|[]
name|b
range|:
name|bufs
control|)
block|{
name|System
operator|.
name|out
operator|.
name|print
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * This thread reads the output of the a subprocess and writes it to a    * thread.  There is an easier way to do this in Java 7, but we want to stay    * compatible with old JDK versions.    */
DECL|class|OutputToFileThread
specifier|public
specifier|static
class|class
name|OutputToFileThread
extends|extends
name|Thread
block|{
DECL|field|is
specifier|private
name|InputStream
name|is
decl_stmt|;
DECL|field|out
specifier|private
name|FileOutputStream
name|out
decl_stmt|;
DECL|method|writePrefix (File outFile, String prefix)
specifier|private
specifier|static
name|void
name|writePrefix
parameter_list|(
name|File
name|outFile
parameter_list|,
name|String
name|prefix
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|(
name|prefix
operator|==
literal|null
operator|)
operator|||
operator|(
name|prefix
operator|.
name|equals
argument_list|(
literal|""
argument_list|)
operator|)
condition|)
block|{
return|return;
block|}
name|FileOutputStream
name|fos
init|=
operator|new
name|FileOutputStream
argument_list|(
name|outFile
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|BufferedWriter
name|wr
init|=
literal|null
decl_stmt|;
try|try
block|{
name|wr
operator|=
operator|new
name|BufferedWriter
argument_list|(
operator|new
name|OutputStreamWriter
argument_list|(
name|fos
argument_list|,
literal|"UTF8"
argument_list|)
argument_list|)
expr_stmt|;
name|wr
operator|.
name|write
argument_list|(
name|prefix
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|wr
operator|!=
literal|null
condition|)
block|{
name|wr
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|fos
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
block|}
DECL|method|OutputToFileThread (InputStream is, File outFile, String prefix)
specifier|public
name|OutputToFileThread
parameter_list|(
name|InputStream
name|is
parameter_list|,
name|File
name|outFile
parameter_list|,
name|String
name|prefix
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|is
operator|=
name|is
expr_stmt|;
name|writePrefix
argument_list|(
name|outFile
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
name|this
operator|.
name|out
operator|=
operator|new
name|FileOutputStream
argument_list|(
name|outFile
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
name|byte
index|[]
name|arr
init|=
operator|new
name|byte
index|[
literal|8192
index|]
decl_stmt|;
try|try
block|{
while|while
condition|(
literal|true
condition|)
block|{
name|int
name|amt
init|=
name|is
operator|.
name|read
argument_list|(
name|arr
argument_list|)
decl_stmt|;
if|if
condition|(
name|amt
operator|<
literal|0
condition|)
return|return;
name|out
operator|.
name|write
argument_list|(
name|arr
argument_list|,
literal|0
argument_list|,
name|amt
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|e
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|close
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|close ()
specifier|public
name|void
name|close
parameter_list|()
block|{
if|if
condition|(
name|is
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|is
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|e
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|is
operator|=
literal|null
expr_stmt|;
block|}
block|}
if|if
condition|(
name|out
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|out
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|e
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|out
operator|=
literal|null
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_class

end_unit

