begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.fs.slive
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|slive
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|ByteBuffer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Random
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|slive
operator|.
name|Constants
operator|.
name|BYTES_PER_LONG
import|;
end_import

begin_comment
comment|/**  * Class which handles generating data (creating and appending) along with  * ensuring the correct data is written out for the given path name so that it  * can be later verified  */
end_comment

begin_class
DECL|class|DataWriter
class|class
name|DataWriter
block|{
comment|/**    * Header size in bytes    */
DECL|field|HEADER_LENGTH
specifier|private
specifier|static
specifier|final
name|int
name|HEADER_LENGTH
init|=
operator|(
name|BYTES_PER_LONG
operator|*
literal|2
operator|)
decl_stmt|;
DECL|field|bufferSize
specifier|private
name|int
name|bufferSize
decl_stmt|;
DECL|field|rnd
specifier|private
name|Random
name|rnd
decl_stmt|;
comment|/**    * Class used to hold the number of bytes written and time taken for write    * operations for callers to use    */
DECL|class|GenerateOutput
specifier|static
class|class
name|GenerateOutput
block|{
DECL|field|bytes
specifier|private
name|long
name|bytes
decl_stmt|;
DECL|field|time
specifier|private
name|long
name|time
decl_stmt|;
DECL|method|GenerateOutput (long bytesWritten, long timeTaken)
name|GenerateOutput
parameter_list|(
name|long
name|bytesWritten
parameter_list|,
name|long
name|timeTaken
parameter_list|)
block|{
name|this
operator|.
name|bytes
operator|=
name|bytesWritten
expr_stmt|;
name|this
operator|.
name|time
operator|=
name|timeTaken
expr_stmt|;
block|}
DECL|method|getBytesWritten ()
name|long
name|getBytesWritten
parameter_list|()
block|{
return|return
name|bytes
return|;
block|}
DECL|method|getTimeTaken ()
name|long
name|getTimeTaken
parameter_list|()
block|{
return|return
name|time
return|;
block|}
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"Wrote "
operator|+
name|getBytesWritten
argument_list|()
operator|+
literal|" bytes "
operator|+
literal|" which took "
operator|+
name|getTimeTaken
argument_list|()
operator|+
literal|" milliseconds"
return|;
block|}
block|}
comment|/**    * Class used to hold a byte buffer and offset position for generating data    */
DECL|class|GenerateResult
specifier|private
specifier|static
class|class
name|GenerateResult
block|{
DECL|field|offset
specifier|private
name|long
name|offset
decl_stmt|;
DECL|field|buffer
specifier|private
name|ByteBuffer
name|buffer
decl_stmt|;
DECL|method|GenerateResult (long offset, ByteBuffer buffer)
name|GenerateResult
parameter_list|(
name|long
name|offset
parameter_list|,
name|ByteBuffer
name|buffer
parameter_list|)
block|{
name|this
operator|.
name|offset
operator|=
name|offset
expr_stmt|;
name|this
operator|.
name|buffer
operator|=
name|buffer
expr_stmt|;
block|}
DECL|method|getOffset ()
name|long
name|getOffset
parameter_list|()
block|{
return|return
name|offset
return|;
block|}
DECL|method|getBuffer ()
name|ByteBuffer
name|getBuffer
parameter_list|()
block|{
return|return
name|buffer
return|;
block|}
block|}
comment|/**    * What a header write output returns need the hash value to use and the time    * taken to perform the write + bytes written    */
DECL|class|WriteInfo
specifier|private
specifier|static
class|class
name|WriteInfo
block|{
DECL|field|hashValue
specifier|private
name|long
name|hashValue
decl_stmt|;
DECL|field|bytesWritten
specifier|private
name|long
name|bytesWritten
decl_stmt|;
DECL|field|timeTaken
specifier|private
name|long
name|timeTaken
decl_stmt|;
DECL|method|WriteInfo (long hashValue, long bytesWritten, long timeTaken)
name|WriteInfo
parameter_list|(
name|long
name|hashValue
parameter_list|,
name|long
name|bytesWritten
parameter_list|,
name|long
name|timeTaken
parameter_list|)
block|{
name|this
operator|.
name|hashValue
operator|=
name|hashValue
expr_stmt|;
name|this
operator|.
name|bytesWritten
operator|=
name|bytesWritten
expr_stmt|;
name|this
operator|.
name|timeTaken
operator|=
name|timeTaken
expr_stmt|;
block|}
DECL|method|getHashValue ()
name|long
name|getHashValue
parameter_list|()
block|{
return|return
name|hashValue
return|;
block|}
DECL|method|getTimeTaken ()
name|long
name|getTimeTaken
parameter_list|()
block|{
return|return
name|timeTaken
return|;
block|}
DECL|method|getBytesWritten ()
name|long
name|getBytesWritten
parameter_list|()
block|{
return|return
name|bytesWritten
return|;
block|}
block|}
comment|/**    * Inits with given buffer size (must be greater than bytes per long and a    * multiple of bytes per long)    *     * @param rnd    *          random number generator to use for hash value creation    *     * @param bufferSize    *          size which must be greater than BYTES_PER_LONG and which also must    *          be a multiple of BYTES_PER_LONG    */
DECL|method|DataWriter (Random rnd, int bufferSize)
name|DataWriter
parameter_list|(
name|Random
name|rnd
parameter_list|,
name|int
name|bufferSize
parameter_list|)
block|{
if|if
condition|(
name|bufferSize
operator|<
name|BYTES_PER_LONG
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Buffer size must be greater than or equal to "
operator|+
name|BYTES_PER_LONG
argument_list|)
throw|;
block|}
if|if
condition|(
operator|(
name|bufferSize
operator|%
name|BYTES_PER_LONG
operator|)
operator|!=
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Buffer size must be a multiple of "
operator|+
name|BYTES_PER_LONG
argument_list|)
throw|;
block|}
name|this
operator|.
name|bufferSize
operator|=
name|bufferSize
expr_stmt|;
name|this
operator|.
name|rnd
operator|=
name|rnd
expr_stmt|;
block|}
comment|/**    * Inits with default buffer size    */
DECL|method|DataWriter (Random rnd)
name|DataWriter
parameter_list|(
name|Random
name|rnd
parameter_list|)
block|{
name|this
argument_list|(
name|rnd
argument_list|,
name|Constants
operator|.
name|BUFFERSIZE
argument_list|)
expr_stmt|;
block|}
comment|/**    * Generates a partial segment which is less than bytes per long size    *     * @param byteAm    *          the number of bytes to generate (less than bytes per long)    * @param offset    *          the staring offset    * @param hasher    *          hasher to use for generating data given an offset    *     * @return GenerateResult containing new offset and byte buffer    */
DECL|method|generatePartialSegment (int byteAm, long offset, DataHasher hasher)
specifier|private
name|GenerateResult
name|generatePartialSegment
parameter_list|(
name|int
name|byteAm
parameter_list|,
name|long
name|offset
parameter_list|,
name|DataHasher
name|hasher
parameter_list|)
block|{
if|if
condition|(
name|byteAm
operator|>
name|BYTES_PER_LONG
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Partial bytes must be less or equal to "
operator|+
name|BYTES_PER_LONG
argument_list|)
throw|;
block|}
if|if
condition|(
name|byteAm
operator|<=
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Partial bytes must be greater than zero and not "
operator|+
name|byteAm
argument_list|)
throw|;
block|}
name|ByteBuffer
name|buf
init|=
name|ByteBuffer
operator|.
name|wrap
argument_list|(
operator|new
name|byte
index|[
name|BYTES_PER_LONG
index|]
argument_list|)
decl_stmt|;
name|buf
operator|.
name|putLong
argument_list|(
name|hasher
operator|.
name|generate
argument_list|(
name|offset
argument_list|)
argument_list|)
expr_stmt|;
name|ByteBuffer
name|allBytes
init|=
name|ByteBuffer
operator|.
name|wrap
argument_list|(
operator|new
name|byte
index|[
name|byteAm
index|]
argument_list|)
decl_stmt|;
name|buf
operator|.
name|rewind
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|byteAm
condition|;
operator|++
name|i
control|)
block|{
name|allBytes
operator|.
name|put
argument_list|(
name|buf
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|allBytes
operator|.
name|rewind
argument_list|()
expr_stmt|;
return|return
operator|new
name|GenerateResult
argument_list|(
name|offset
argument_list|,
name|allBytes
argument_list|)
return|;
block|}
comment|/**    * Generates a full segment (aligned to bytes per long) of the given byte    * amount size    *     * @param byteAm    *          long aligned size    * @param startOffset    *          starting hash offset    * @param hasher    *          hasher to use for generating data given an offset    * @return GenerateResult containing new offset and byte buffer    */
DECL|method|generateFullSegment (int byteAm, long startOffset, DataHasher hasher)
specifier|private
name|GenerateResult
name|generateFullSegment
parameter_list|(
name|int
name|byteAm
parameter_list|,
name|long
name|startOffset
parameter_list|,
name|DataHasher
name|hasher
parameter_list|)
block|{
if|if
condition|(
name|byteAm
operator|<=
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Byte amount must be greater than zero and not "
operator|+
name|byteAm
argument_list|)
throw|;
block|}
if|if
condition|(
operator|(
name|byteAm
operator|%
name|BYTES_PER_LONG
operator|)
operator|!=
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Byte amount "
operator|+
name|byteAm
operator|+
literal|" must be a multiple of "
operator|+
name|BYTES_PER_LONG
argument_list|)
throw|;
block|}
comment|// generate all the segments
name|ByteBuffer
name|allBytes
init|=
name|ByteBuffer
operator|.
name|wrap
argument_list|(
operator|new
name|byte
index|[
name|byteAm
index|]
argument_list|)
decl_stmt|;
name|long
name|offset
init|=
name|startOffset
decl_stmt|;
name|ByteBuffer
name|buf
init|=
name|ByteBuffer
operator|.
name|wrap
argument_list|(
operator|new
name|byte
index|[
name|BYTES_PER_LONG
index|]
argument_list|)
decl_stmt|;
for|for
control|(
name|long
name|i
init|=
literal|0
init|;
name|i
operator|<
name|byteAm
condition|;
name|i
operator|+=
name|BYTES_PER_LONG
control|)
block|{
name|buf
operator|.
name|rewind
argument_list|()
expr_stmt|;
name|buf
operator|.
name|putLong
argument_list|(
name|hasher
operator|.
name|generate
argument_list|(
name|offset
argument_list|)
argument_list|)
expr_stmt|;
name|buf
operator|.
name|rewind
argument_list|()
expr_stmt|;
name|allBytes
operator|.
name|put
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|BYTES_PER_LONG
expr_stmt|;
block|}
name|allBytes
operator|.
name|rewind
argument_list|()
expr_stmt|;
return|return
operator|new
name|GenerateResult
argument_list|(
name|offset
argument_list|,
name|allBytes
argument_list|)
return|;
block|}
comment|/**    * Writes a set of bytes to the output stream, for full segments it will write    * out the complete segment but for partial segments, ie when the last    * position does not fill up a full long then a partial set will be written    * out containing the needed bytes from the expected full segment    *     * @param byteAm    *          the amount of bytes to write    * @param startPos    *          a BYTES_PER_LONG aligned start position    * @param hasher    *          hasher to use for generating data given an offset    * @param out    *          the output stream to write to    * @return how many bytes were written    * @throws IOException    */
DECL|method|writePieces (long byteAm, long startPos, DataHasher hasher, OutputStream out)
specifier|private
name|GenerateOutput
name|writePieces
parameter_list|(
name|long
name|byteAm
parameter_list|,
name|long
name|startPos
parameter_list|,
name|DataHasher
name|hasher
parameter_list|,
name|OutputStream
name|out
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|byteAm
operator|<=
literal|0
condition|)
block|{
return|return
operator|new
name|GenerateOutput
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
if|if
condition|(
name|startPos
operator|<
literal|0
condition|)
block|{
name|startPos
operator|=
literal|0
expr_stmt|;
block|}
name|int
name|leftOver
init|=
call|(
name|int
call|)
argument_list|(
name|byteAm
operator|%
name|bufferSize
argument_list|)
decl_stmt|;
name|long
name|fullPieces
init|=
name|byteAm
operator|/
name|bufferSize
decl_stmt|;
name|long
name|offset
init|=
name|startPos
decl_stmt|;
name|long
name|bytesWritten
init|=
literal|0
decl_stmt|;
name|long
name|timeTaken
init|=
literal|0
decl_stmt|;
comment|// write the full pieces that fit in the buffer size
for|for
control|(
name|long
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fullPieces
condition|;
operator|++
name|i
control|)
block|{
name|GenerateResult
name|genData
init|=
name|generateFullSegment
argument_list|(
name|bufferSize
argument_list|,
name|offset
argument_list|,
name|hasher
argument_list|)
decl_stmt|;
name|offset
operator|=
name|genData
operator|.
name|getOffset
argument_list|()
expr_stmt|;
name|ByteBuffer
name|gBuf
init|=
name|genData
operator|.
name|getBuffer
argument_list|()
decl_stmt|;
block|{
name|byte
index|[]
name|buf
init|=
name|gBuf
operator|.
name|array
argument_list|()
decl_stmt|;
name|long
name|startTime
init|=
name|Timer
operator|.
name|now
argument_list|()
decl_stmt|;
name|out
operator|.
name|write
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|Constants
operator|.
name|FLUSH_WRITES
condition|)
block|{
name|out
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
name|timeTaken
operator|+=
name|Timer
operator|.
name|elapsed
argument_list|(
name|startTime
argument_list|)
expr_stmt|;
name|bytesWritten
operator|+=
name|buf
operator|.
name|length
expr_stmt|;
block|}
block|}
if|if
condition|(
name|leftOver
operator|>
literal|0
condition|)
block|{
name|ByteBuffer
name|leftOverBuf
init|=
name|ByteBuffer
operator|.
name|wrap
argument_list|(
operator|new
name|byte
index|[
name|leftOver
index|]
argument_list|)
decl_stmt|;
name|int
name|bytesLeft
init|=
name|leftOver
operator|%
name|BYTES_PER_LONG
decl_stmt|;
name|leftOver
operator|=
name|leftOver
operator|-
name|bytesLeft
expr_stmt|;
comment|// collect the piece which do not fit in the buffer size but is
comment|// also greater or eq than BYTES_PER_LONG and a multiple of it
if|if
condition|(
name|leftOver
operator|>
literal|0
condition|)
block|{
name|GenerateResult
name|genData
init|=
name|generateFullSegment
argument_list|(
name|leftOver
argument_list|,
name|offset
argument_list|,
name|hasher
argument_list|)
decl_stmt|;
name|offset
operator|=
name|genData
operator|.
name|getOffset
argument_list|()
expr_stmt|;
name|leftOverBuf
operator|.
name|put
argument_list|(
name|genData
operator|.
name|getBuffer
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// collect any single partial byte segment
if|if
condition|(
name|bytesLeft
operator|>
literal|0
condition|)
block|{
name|GenerateResult
name|genData
init|=
name|generatePartialSegment
argument_list|(
name|bytesLeft
argument_list|,
name|offset
argument_list|,
name|hasher
argument_list|)
decl_stmt|;
name|offset
operator|=
name|genData
operator|.
name|getOffset
argument_list|()
expr_stmt|;
name|leftOverBuf
operator|.
name|put
argument_list|(
name|genData
operator|.
name|getBuffer
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// do the write of both
name|leftOverBuf
operator|.
name|rewind
argument_list|()
expr_stmt|;
block|{
name|byte
index|[]
name|buf
init|=
name|leftOverBuf
operator|.
name|array
argument_list|()
decl_stmt|;
name|long
name|startTime
init|=
name|Timer
operator|.
name|now
argument_list|()
decl_stmt|;
name|out
operator|.
name|write
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|Constants
operator|.
name|FLUSH_WRITES
condition|)
block|{
name|out
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
name|timeTaken
operator|+=
name|Timer
operator|.
name|elapsed
argument_list|(
name|startTime
argument_list|)
expr_stmt|;
name|bytesWritten
operator|+=
name|buf
operator|.
name|length
expr_stmt|;
block|}
block|}
return|return
operator|new
name|GenerateOutput
argument_list|(
name|bytesWritten
argument_list|,
name|timeTaken
argument_list|)
return|;
block|}
comment|/**    * Writes to a stream the given number of bytes specified    *     * @param byteAm    *          the file size in number of bytes to write    *     * @param out    *          the outputstream to write to    *     * @return the number of bytes written + time taken    *     * @throws IOException    */
DECL|method|writeSegment (long byteAm, OutputStream out)
name|GenerateOutput
name|writeSegment
parameter_list|(
name|long
name|byteAm
parameter_list|,
name|OutputStream
name|out
parameter_list|)
throws|throws
name|IOException
block|{
name|long
name|headerLen
init|=
name|getHeaderLength
argument_list|()
decl_stmt|;
if|if
condition|(
name|byteAm
operator|<
name|headerLen
condition|)
block|{
comment|// not enough bytes to write even the header
return|return
operator|new
name|GenerateOutput
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
comment|// adjust for header length
name|byteAm
operator|-=
name|headerLen
expr_stmt|;
if|if
condition|(
name|byteAm
operator|<
literal|0
condition|)
block|{
name|byteAm
operator|=
literal|0
expr_stmt|;
block|}
name|WriteInfo
name|header
init|=
name|writeHeader
argument_list|(
name|out
argument_list|,
name|byteAm
argument_list|)
decl_stmt|;
name|DataHasher
name|hasher
init|=
operator|new
name|DataHasher
argument_list|(
name|header
operator|.
name|getHashValue
argument_list|()
argument_list|)
decl_stmt|;
name|GenerateOutput
name|pRes
init|=
name|writePieces
argument_list|(
name|byteAm
argument_list|,
literal|0
argument_list|,
name|hasher
argument_list|,
name|out
argument_list|)
decl_stmt|;
name|long
name|bytesWritten
init|=
name|pRes
operator|.
name|getBytesWritten
argument_list|()
operator|+
name|header
operator|.
name|getBytesWritten
argument_list|()
decl_stmt|;
name|long
name|timeTaken
init|=
name|header
operator|.
name|getTimeTaken
argument_list|()
operator|+
name|pRes
operator|.
name|getTimeTaken
argument_list|()
decl_stmt|;
return|return
operator|new
name|GenerateOutput
argument_list|(
name|bytesWritten
argument_list|,
name|timeTaken
argument_list|)
return|;
block|}
comment|/**    * Gets the header length    *     * @return int    */
DECL|method|getHeaderLength ()
specifier|static
name|int
name|getHeaderLength
parameter_list|()
block|{
return|return
name|HEADER_LENGTH
return|;
block|}
comment|/**    * Writes a header to the given output stream    *     * @param os    *          output stream to write to    *     * @param fileSize    *          the file size to write    *     * @return WriteInfo    *     * @throws IOException    *           if a write failure occurs    */
DECL|method|writeHeader (OutputStream os, long fileSize)
name|WriteInfo
name|writeHeader
parameter_list|(
name|OutputStream
name|os
parameter_list|,
name|long
name|fileSize
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|headerLen
init|=
name|getHeaderLength
argument_list|()
decl_stmt|;
name|ByteBuffer
name|buf
init|=
name|ByteBuffer
operator|.
name|wrap
argument_list|(
operator|new
name|byte
index|[
name|headerLen
index|]
argument_list|)
decl_stmt|;
name|long
name|hash
init|=
name|rnd
operator|.
name|nextLong
argument_list|()
decl_stmt|;
name|buf
operator|.
name|putLong
argument_list|(
name|hash
argument_list|)
expr_stmt|;
name|buf
operator|.
name|putLong
argument_list|(
name|fileSize
argument_list|)
expr_stmt|;
name|buf
operator|.
name|rewind
argument_list|()
expr_stmt|;
name|byte
index|[]
name|headerData
init|=
name|buf
operator|.
name|array
argument_list|()
decl_stmt|;
name|long
name|elapsed
init|=
literal|0
decl_stmt|;
block|{
name|long
name|startTime
init|=
name|Timer
operator|.
name|now
argument_list|()
decl_stmt|;
name|os
operator|.
name|write
argument_list|(
name|headerData
argument_list|)
expr_stmt|;
if|if
condition|(
name|Constants
operator|.
name|FLUSH_WRITES
condition|)
block|{
name|os
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
name|elapsed
operator|+=
name|Timer
operator|.
name|elapsed
argument_list|(
name|startTime
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|WriteInfo
argument_list|(
name|hash
argument_list|,
name|headerLen
argument_list|,
name|elapsed
argument_list|)
return|;
block|}
block|}
end_class

end_unit

