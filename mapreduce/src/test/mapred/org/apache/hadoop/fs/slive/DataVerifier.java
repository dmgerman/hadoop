begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.fs.slive
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|slive
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|EOFException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|ByteBuffer
import|;
end_import

begin_comment
comment|/**  * Class which reads in and verifies bytes that have been read in  */
end_comment

begin_class
DECL|class|DataVerifier
class|class
name|DataVerifier
block|{
DECL|field|BYTES_PER_LONG
specifier|private
specifier|static
specifier|final
name|int
name|BYTES_PER_LONG
init|=
name|Constants
operator|.
name|BYTES_PER_LONG
decl_stmt|;
DECL|field|bufferSize
specifier|private
name|int
name|bufferSize
decl_stmt|;
comment|/**    * The output from verification includes the number of chunks that were the    * same as expected and the number of segments that were different than what    * was expected and the number of total bytes read    */
DECL|class|VerifyOutput
specifier|static
class|class
name|VerifyOutput
block|{
DECL|field|same
specifier|private
name|long
name|same
decl_stmt|;
DECL|field|different
specifier|private
name|long
name|different
decl_stmt|;
DECL|field|read
specifier|private
name|long
name|read
decl_stmt|;
DECL|field|readTime
specifier|private
name|long
name|readTime
decl_stmt|;
DECL|method|VerifyOutput (long sameChunks, long differentChunks, long readBytes, long readTime)
name|VerifyOutput
parameter_list|(
name|long
name|sameChunks
parameter_list|,
name|long
name|differentChunks
parameter_list|,
name|long
name|readBytes
parameter_list|,
name|long
name|readTime
parameter_list|)
block|{
name|this
operator|.
name|same
operator|=
name|sameChunks
expr_stmt|;
name|this
operator|.
name|different
operator|=
name|differentChunks
expr_stmt|;
name|this
operator|.
name|read
operator|=
name|readBytes
expr_stmt|;
name|this
operator|.
name|readTime
operator|=
name|readTime
expr_stmt|;
block|}
DECL|method|getReadTime ()
name|long
name|getReadTime
parameter_list|()
block|{
return|return
name|this
operator|.
name|readTime
return|;
block|}
DECL|method|getBytesRead ()
name|long
name|getBytesRead
parameter_list|()
block|{
return|return
name|this
operator|.
name|read
return|;
block|}
DECL|method|getChunksSame ()
name|long
name|getChunksSame
parameter_list|()
block|{
return|return
name|same
return|;
block|}
DECL|method|getChunksDifferent ()
name|long
name|getChunksDifferent
parameter_list|()
block|{
return|return
name|different
return|;
block|}
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"Bytes read = "
operator|+
name|getBytesRead
argument_list|()
operator|+
literal|" same = "
operator|+
name|getChunksSame
argument_list|()
operator|+
literal|" different = "
operator|+
name|getChunksDifferent
argument_list|()
operator|+
literal|" in "
operator|+
name|getReadTime
argument_list|()
operator|+
literal|" milliseconds"
return|;
block|}
block|}
comment|/**    * Class used to hold the result of a read on a header    */
DECL|class|ReadInfo
specifier|private
specifier|static
class|class
name|ReadInfo
block|{
DECL|field|byteAm
specifier|private
name|long
name|byteAm
decl_stmt|;
DECL|field|hash
specifier|private
name|long
name|hash
decl_stmt|;
DECL|field|timeTaken
specifier|private
name|long
name|timeTaken
decl_stmt|;
DECL|field|bytesRead
specifier|private
name|long
name|bytesRead
decl_stmt|;
DECL|method|ReadInfo (long byteAm, long hash, long timeTaken, long bytesRead)
name|ReadInfo
parameter_list|(
name|long
name|byteAm
parameter_list|,
name|long
name|hash
parameter_list|,
name|long
name|timeTaken
parameter_list|,
name|long
name|bytesRead
parameter_list|)
block|{
name|this
operator|.
name|byteAm
operator|=
name|byteAm
expr_stmt|;
name|this
operator|.
name|hash
operator|=
name|hash
expr_stmt|;
name|this
operator|.
name|timeTaken
operator|=
name|timeTaken
expr_stmt|;
name|this
operator|.
name|bytesRead
operator|=
name|bytesRead
expr_stmt|;
block|}
DECL|method|getByteAm ()
name|long
name|getByteAm
parameter_list|()
block|{
return|return
name|byteAm
return|;
block|}
DECL|method|getHashValue ()
name|long
name|getHashValue
parameter_list|()
block|{
return|return
name|hash
return|;
block|}
DECL|method|getTimeTaken ()
name|long
name|getTimeTaken
parameter_list|()
block|{
return|return
name|timeTaken
return|;
block|}
DECL|method|getBytesRead ()
name|long
name|getBytesRead
parameter_list|()
block|{
return|return
name|bytesRead
return|;
block|}
block|}
comment|/**    * Storage class used to hold the chunks same and different for buffered reads    * and the resultant verification    */
DECL|class|VerifyInfo
specifier|private
specifier|static
class|class
name|VerifyInfo
block|{
DECL|method|VerifyInfo (long same, long different)
name|VerifyInfo
parameter_list|(
name|long
name|same
parameter_list|,
name|long
name|different
parameter_list|)
block|{
name|this
operator|.
name|same
operator|=
name|same
expr_stmt|;
name|this
operator|.
name|different
operator|=
name|different
expr_stmt|;
block|}
DECL|method|getSame ()
name|long
name|getSame
parameter_list|()
block|{
return|return
name|same
return|;
block|}
DECL|method|getDifferent ()
name|long
name|getDifferent
parameter_list|()
block|{
return|return
name|different
return|;
block|}
DECL|field|same
specifier|private
name|long
name|same
decl_stmt|;
DECL|field|different
specifier|private
name|long
name|different
decl_stmt|;
block|}
comment|/**    * Inits with given buffer size (must be greater than bytes per long and a    * multiple of bytes per long)    *     * @param bufferSize    *          size which must be greater than BYTES_PER_LONG and which also must    *          be a multiple of BYTES_PER_LONG    */
DECL|method|DataVerifier (int bufferSize)
name|DataVerifier
parameter_list|(
name|int
name|bufferSize
parameter_list|)
block|{
if|if
condition|(
name|bufferSize
operator|<
name|BYTES_PER_LONG
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Buffer size must be greater than or equal to "
operator|+
name|BYTES_PER_LONG
argument_list|)
throw|;
block|}
if|if
condition|(
operator|(
name|bufferSize
operator|%
name|BYTES_PER_LONG
operator|)
operator|!=
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Buffer size must be a multiple of "
operator|+
name|BYTES_PER_LONG
argument_list|)
throw|;
block|}
name|this
operator|.
name|bufferSize
operator|=
name|bufferSize
expr_stmt|;
block|}
comment|/**    * Inits with the default buffer size    */
DECL|method|DataVerifier ()
name|DataVerifier
parameter_list|()
block|{
name|this
argument_list|(
name|Constants
operator|.
name|BUFFERSIZE
argument_list|)
expr_stmt|;
block|}
comment|/**    * Verifies a buffer of a given size using the given start hash offset    *     * @param buf    *          the buffer to verify    * @param size    *          the number of bytes to be used in that buffer    * @param startOffset    *          the start hash offset    * @param hasher    *          the hasher to use for calculating expected values    *     * @return ResumeBytes a set of data about the next offset and chunks analyzed    */
DECL|method|verifyBuffer (ByteBuffer buf, int size, long startOffset, DataHasher hasher)
specifier|private
name|VerifyInfo
name|verifyBuffer
parameter_list|(
name|ByteBuffer
name|buf
parameter_list|,
name|int
name|size
parameter_list|,
name|long
name|startOffset
parameter_list|,
name|DataHasher
name|hasher
parameter_list|)
block|{
name|ByteBuffer
name|cmpBuf
init|=
name|ByteBuffer
operator|.
name|wrap
argument_list|(
operator|new
name|byte
index|[
name|BYTES_PER_LONG
index|]
argument_list|)
decl_stmt|;
name|long
name|hashOffset
init|=
name|startOffset
decl_stmt|;
name|long
name|chunksSame
init|=
literal|0
decl_stmt|;
name|long
name|chunksDifferent
init|=
literal|0
decl_stmt|;
for|for
control|(
name|long
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
operator|++
name|i
control|)
block|{
name|cmpBuf
operator|.
name|put
argument_list|(
name|buf
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cmpBuf
operator|.
name|hasRemaining
argument_list|()
condition|)
block|{
name|cmpBuf
operator|.
name|rewind
argument_list|()
expr_stmt|;
name|long
name|receivedData
init|=
name|cmpBuf
operator|.
name|getLong
argument_list|()
decl_stmt|;
name|cmpBuf
operator|.
name|rewind
argument_list|()
expr_stmt|;
name|long
name|expected
init|=
name|hasher
operator|.
name|generate
argument_list|(
name|hashOffset
argument_list|)
decl_stmt|;
name|hashOffset
operator|+=
name|BYTES_PER_LONG
expr_stmt|;
if|if
condition|(
name|receivedData
operator|==
name|expected
condition|)
block|{
operator|++
name|chunksSame
expr_stmt|;
block|}
else|else
block|{
operator|++
name|chunksDifferent
expr_stmt|;
block|}
block|}
block|}
comment|// any left over??
if|if
condition|(
name|cmpBuf
operator|.
name|hasRemaining
argument_list|()
operator|&&
name|cmpBuf
operator|.
name|position
argument_list|()
operator|!=
literal|0
condition|)
block|{
comment|// partial capture
comment|// zero fill and compare with zero filled
name|int
name|curSize
init|=
name|cmpBuf
operator|.
name|position
argument_list|()
decl_stmt|;
while|while
condition|(
name|cmpBuf
operator|.
name|hasRemaining
argument_list|()
condition|)
block|{
name|cmpBuf
operator|.
name|put
argument_list|(
operator|(
name|byte
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
name|long
name|expected
init|=
name|hasher
operator|.
name|generate
argument_list|(
name|hashOffset
argument_list|)
decl_stmt|;
name|ByteBuffer
name|tempBuf
init|=
name|ByteBuffer
operator|.
name|wrap
argument_list|(
operator|new
name|byte
index|[
name|BYTES_PER_LONG
index|]
argument_list|)
decl_stmt|;
name|tempBuf
operator|.
name|putLong
argument_list|(
name|expected
argument_list|)
expr_stmt|;
name|tempBuf
operator|.
name|position
argument_list|(
name|curSize
argument_list|)
expr_stmt|;
while|while
condition|(
name|tempBuf
operator|.
name|hasRemaining
argument_list|()
condition|)
block|{
name|tempBuf
operator|.
name|put
argument_list|(
operator|(
name|byte
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
name|cmpBuf
operator|.
name|rewind
argument_list|()
expr_stmt|;
name|tempBuf
operator|.
name|rewind
argument_list|()
expr_stmt|;
if|if
condition|(
name|cmpBuf
operator|.
name|equals
argument_list|(
name|tempBuf
argument_list|)
condition|)
block|{
operator|++
name|chunksSame
expr_stmt|;
block|}
else|else
block|{
operator|++
name|chunksDifferent
expr_stmt|;
block|}
block|}
return|return
operator|new
name|VerifyInfo
argument_list|(
name|chunksSame
argument_list|,
name|chunksDifferent
argument_list|)
return|;
block|}
comment|/**    * Determines the offset to use given a byte counter    *     * @param byteRead    *     * @return offset position    */
DECL|method|determineOffset (long byteRead)
specifier|private
name|long
name|determineOffset
parameter_list|(
name|long
name|byteRead
parameter_list|)
block|{
if|if
condition|(
name|byteRead
operator|<
literal|0
condition|)
block|{
name|byteRead
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|byteRead
operator|/
name|BYTES_PER_LONG
operator|)
operator|*
name|BYTES_PER_LONG
return|;
block|}
comment|/**    * Verifies a given number of bytes from a file - less number of bytes may be    * read if a header can not be read in due to the byte limit    *     * @param byteAm    *          the byte amount to limit to (should be less than or equal to file    *          size)    *     * @param in    *          the input stream to read from    *     * @return VerifyOutput with data about reads    *     * @throws IOException    *           if a read failure occurs    *     * @throws BadFileException    *           if a header can not be read or end of file is reached    *           unexpectedly    */
DECL|method|verifyFile (long byteAm, DataInputStream in)
name|VerifyOutput
name|verifyFile
parameter_list|(
name|long
name|byteAm
parameter_list|,
name|DataInputStream
name|in
parameter_list|)
throws|throws
name|IOException
throws|,
name|BadFileException
block|{
return|return
name|verifyBytes
argument_list|(
name|byteAm
argument_list|,
literal|0
argument_list|,
name|in
argument_list|)
return|;
block|}
comment|/**    * Verifies a given number of bytes from a file - less number of bytes may be    * read if a header can not be read in due to the byte limit    *     * @param byteAm    *          the byte amount to limit to (should be less than or equal to file    *          size)    *     * @param bytesRead    *          the starting byte location    *     * @param in    *          the input stream to read from    *     * @return VerifyOutput with data about reads    *     * @throws IOException    *           if a read failure occurs    *     * @throws BadFileException    *           if a header can not be read or end of file is reached    *           unexpectedly    */
DECL|method|verifyBytes (long byteAm, long bytesRead, DataInputStream in)
specifier|private
name|VerifyOutput
name|verifyBytes
parameter_list|(
name|long
name|byteAm
parameter_list|,
name|long
name|bytesRead
parameter_list|,
name|DataInputStream
name|in
parameter_list|)
throws|throws
name|IOException
throws|,
name|BadFileException
block|{
if|if
condition|(
name|byteAm
operator|<=
literal|0
condition|)
block|{
return|return
operator|new
name|VerifyOutput
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
name|long
name|chunksSame
init|=
literal|0
decl_stmt|;
name|long
name|chunksDifferent
init|=
literal|0
decl_stmt|;
name|long
name|readTime
init|=
literal|0
decl_stmt|;
name|long
name|bytesLeft
init|=
name|byteAm
decl_stmt|;
name|long
name|bufLeft
init|=
literal|0
decl_stmt|;
name|long
name|bufRead
init|=
literal|0
decl_stmt|;
name|long
name|seqNum
init|=
literal|0
decl_stmt|;
name|DataHasher
name|hasher
init|=
literal|null
decl_stmt|;
name|ByteBuffer
name|readBuf
init|=
name|ByteBuffer
operator|.
name|wrap
argument_list|(
operator|new
name|byte
index|[
name|bufferSize
index|]
argument_list|)
decl_stmt|;
while|while
condition|(
name|bytesLeft
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|bufLeft
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|bytesLeft
operator|<
name|DataWriter
operator|.
name|getHeaderLength
argument_list|()
condition|)
block|{
comment|// no bytes left to read a header
break|break;
block|}
comment|// time to read a new header
name|ReadInfo
name|header
init|=
literal|null
decl_stmt|;
try|try
block|{
name|header
operator|=
name|readHeader
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|EOFException
name|e
parameter_list|)
block|{
comment|// eof ok on header reads
comment|// but not on data readers
break|break;
block|}
operator|++
name|seqNum
expr_stmt|;
name|hasher
operator|=
operator|new
name|DataHasher
argument_list|(
name|header
operator|.
name|getHashValue
argument_list|()
argument_list|)
expr_stmt|;
name|bufLeft
operator|=
name|header
operator|.
name|getByteAm
argument_list|()
expr_stmt|;
name|readTime
operator|+=
name|header
operator|.
name|getTimeTaken
argument_list|()
expr_stmt|;
name|bytesRead
operator|+=
name|header
operator|.
name|getBytesRead
argument_list|()
expr_stmt|;
name|bytesLeft
operator|-=
name|header
operator|.
name|getBytesRead
argument_list|()
expr_stmt|;
name|bufRead
operator|=
literal|0
expr_stmt|;
comment|// number of bytes to read greater than how many we want to read
if|if
condition|(
name|bufLeft
operator|>
name|bytesLeft
condition|)
block|{
name|bufLeft
operator|=
name|bytesLeft
expr_stmt|;
block|}
comment|// does the buffer amount have anything??
if|if
condition|(
name|bufLeft
operator|<=
literal|0
condition|)
block|{
continue|continue;
block|}
block|}
comment|// figure out the buffer size to read
name|int
name|bufSize
init|=
name|bufferSize
decl_stmt|;
if|if
condition|(
name|bytesLeft
operator|<
name|bufSize
condition|)
block|{
name|bufSize
operator|=
operator|(
name|int
operator|)
name|bytesLeft
expr_stmt|;
block|}
if|if
condition|(
name|bufLeft
operator|<
name|bufSize
condition|)
block|{
name|bufSize
operator|=
operator|(
name|int
operator|)
name|bufLeft
expr_stmt|;
block|}
comment|// read it in
try|try
block|{
name|readBuf
operator|.
name|rewind
argument_list|()
expr_stmt|;
name|long
name|startTime
init|=
name|Timer
operator|.
name|now
argument_list|()
decl_stmt|;
name|in
operator|.
name|readFully
argument_list|(
name|readBuf
operator|.
name|array
argument_list|()
argument_list|,
literal|0
argument_list|,
name|bufSize
argument_list|)
expr_stmt|;
name|readTime
operator|+=
name|Timer
operator|.
name|elapsed
argument_list|(
name|startTime
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|EOFException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|BadFileException
argument_list|(
literal|"Could not read the number of expected data bytes "
operator|+
name|bufSize
operator|+
literal|" due to unexpected end of file during sequence "
operator|+
name|seqNum
argument_list|,
name|e
argument_list|)
throw|;
block|}
comment|// update the counters
name|bytesRead
operator|+=
name|bufSize
expr_stmt|;
name|bytesLeft
operator|-=
name|bufSize
expr_stmt|;
name|bufLeft
operator|-=
name|bufSize
expr_stmt|;
comment|// verify what we read
name|readBuf
operator|.
name|rewind
argument_list|()
expr_stmt|;
comment|// figure out the expected hash offset start point
name|long
name|vOffset
init|=
name|determineOffset
argument_list|(
name|bufRead
argument_list|)
decl_stmt|;
comment|// now update for new position
name|bufRead
operator|+=
name|bufSize
expr_stmt|;
comment|// verify
name|VerifyInfo
name|verifyRes
init|=
name|verifyBuffer
argument_list|(
name|readBuf
argument_list|,
name|bufSize
argument_list|,
name|vOffset
argument_list|,
name|hasher
argument_list|)
decl_stmt|;
comment|// update the verification counters
name|chunksSame
operator|+=
name|verifyRes
operator|.
name|getSame
argument_list|()
expr_stmt|;
name|chunksDifferent
operator|+=
name|verifyRes
operator|.
name|getDifferent
argument_list|()
expr_stmt|;
block|}
return|return
operator|new
name|VerifyOutput
argument_list|(
name|chunksSame
argument_list|,
name|chunksDifferent
argument_list|,
name|bytesRead
argument_list|,
name|readTime
argument_list|)
return|;
block|}
comment|/**    * Reads a header from the given input stream    *     * @param in    *          input stream to read from    *     * @return ReadInfo    *     * @throws IOException    *           if a read error occurs or EOF occurs    *     * @throws BadFileException    *           if end of file occurs or the byte amount read is invalid    */
DECL|method|readHeader (DataInputStream in)
name|ReadInfo
name|readHeader
parameter_list|(
name|DataInputStream
name|in
parameter_list|)
throws|throws
name|IOException
throws|,
name|BadFileException
block|{
name|int
name|headerLen
init|=
name|DataWriter
operator|.
name|getHeaderLength
argument_list|()
decl_stmt|;
name|ByteBuffer
name|headerBuf
init|=
name|ByteBuffer
operator|.
name|wrap
argument_list|(
operator|new
name|byte
index|[
name|headerLen
index|]
argument_list|)
decl_stmt|;
name|long
name|elapsed
init|=
literal|0
decl_stmt|;
block|{
name|long
name|startTime
init|=
name|Timer
operator|.
name|now
argument_list|()
decl_stmt|;
name|in
operator|.
name|readFully
argument_list|(
name|headerBuf
operator|.
name|array
argument_list|()
argument_list|)
expr_stmt|;
name|elapsed
operator|+=
name|Timer
operator|.
name|elapsed
argument_list|(
name|startTime
argument_list|)
expr_stmt|;
block|}
name|headerBuf
operator|.
name|rewind
argument_list|()
expr_stmt|;
name|long
name|hashValue
init|=
name|headerBuf
operator|.
name|getLong
argument_list|()
decl_stmt|;
name|long
name|byteAvailable
init|=
name|headerBuf
operator|.
name|getLong
argument_list|()
decl_stmt|;
if|if
condition|(
name|byteAvailable
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|BadFileException
argument_list|(
literal|"Invalid negative amount "
operator|+
name|byteAvailable
operator|+
literal|" determined for header data amount"
argument_list|)
throw|;
block|}
return|return
operator|new
name|ReadInfo
argument_list|(
name|byteAvailable
argument_list|,
name|hashValue
argument_list|,
name|elapsed
argument_list|,
name|headerLen
argument_list|)
return|;
block|}
block|}
end_class

end_unit

