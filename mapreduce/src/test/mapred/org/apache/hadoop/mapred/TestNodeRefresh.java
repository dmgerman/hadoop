begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.mapred
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|BufferedWriter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStreamWriter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|junit
operator|.
name|framework
operator|.
name|TestCase
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|permission
operator|.
name|FsPermission
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSTestUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|MiniDFSCluster
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|Writable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|WritableComparable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|RPC
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|lib
operator|.
name|IdentityReducer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|MRConfig
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|MRJobConfig
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|server
operator|.
name|jobtracker
operator|.
name|JTConfig
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|net
operator|.
name|NetUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|UserGroupInformation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Shell
operator|.
name|ShellCommandExecutor
import|;
end_import

begin_comment
comment|/**  * Test node decommissioning and recommissioning via refresh. Also check if the   * nodes are decommissioned upon refresh.   */
end_comment

begin_class
DECL|class|TestNodeRefresh
specifier|public
class|class
name|TestNodeRefresh
extends|extends
name|TestCase
block|{
DECL|field|namenode
specifier|private
name|String
name|namenode
init|=
literal|null
decl_stmt|;
DECL|field|dfs
specifier|private
name|MiniDFSCluster
name|dfs
init|=
literal|null
decl_stmt|;
DECL|field|mr
specifier|private
name|MiniMRCluster
name|mr
init|=
literal|null
decl_stmt|;
DECL|field|jt
specifier|private
name|JobTracker
name|jt
init|=
literal|null
decl_stmt|;
DECL|field|hosts
specifier|private
name|String
index|[]
name|hosts
init|=
literal|null
decl_stmt|;
DECL|field|trackerHosts
specifier|private
name|String
index|[]
name|trackerHosts
init|=
literal|null
decl_stmt|;
DECL|field|owner
DECL|field|user1
DECL|field|user2
DECL|field|user3
DECL|field|user4
DECL|field|user5
specifier|private
name|UserGroupInformation
name|owner
decl_stmt|,
name|user1
decl_stmt|,
name|user2
decl_stmt|,
name|user3
decl_stmt|,
name|user4
decl_stmt|,
name|user5
decl_stmt|;
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|TestNodeRefresh
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|method|getHostname (int i)
specifier|private
name|String
name|getHostname
parameter_list|(
name|int
name|i
parameter_list|)
block|{
return|return
literal|"host"
operator|+
name|i
operator|+
literal|".com"
return|;
block|}
DECL|method|startCluster (int numHosts, int numTrackerPerHost, int numExcluded, UserGroupInformation clusterUgi, Configuration conf)
specifier|private
name|void
name|startCluster
parameter_list|(
name|int
name|numHosts
parameter_list|,
name|int
name|numTrackerPerHost
parameter_list|,
name|int
name|numExcluded
parameter_list|,
name|UserGroupInformation
name|clusterUgi
parameter_list|,
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
comment|// create fake mapping for the groups
name|owner
operator|=
name|UserGroupInformation
operator|.
name|getLoginUser
argument_list|()
expr_stmt|;
name|user1
operator|=
name|UserGroupInformation
operator|.
name|createUserForTesting
argument_list|(
literal|"user1"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"user1"
block|}
argument_list|)
expr_stmt|;
name|user2
operator|=
name|UserGroupInformation
operator|.
name|createUserForTesting
argument_list|(
literal|"user2"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"user2"
block|}
argument_list|)
expr_stmt|;
name|user3
operator|=
name|UserGroupInformation
operator|.
name|createUserForTesting
argument_list|(
literal|"user3"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"abc"
block|}
argument_list|)
expr_stmt|;
name|user4
operator|=
name|UserGroupInformation
operator|.
name|createUserForTesting
argument_list|(
literal|"user4"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"supergroup"
block|}
argument_list|)
expr_stmt|;
name|user5
operator|=
name|UserGroupInformation
operator|.
name|createUserForTesting
argument_list|(
literal|"user5"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"user5"
block|}
argument_list|)
expr_stmt|;
name|conf
operator|.
name|setBoolean
argument_list|(
literal|"dfs.replication.considerLoad"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
comment|// prepare hosts info
name|hosts
operator|=
operator|new
name|String
index|[
name|numHosts
index|]
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<=
name|numHosts
condition|;
operator|++
name|i
control|)
block|{
name|hosts
index|[
name|i
operator|-
literal|1
index|]
operator|=
name|getHostname
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
comment|// start dfs
name|dfs
operator|=
operator|new
name|MiniDFSCluster
argument_list|(
name|conf
argument_list|,
literal|1
argument_list|,
literal|true
argument_list|,
literal|null
argument_list|,
name|hosts
argument_list|)
expr_stmt|;
name|dfs
operator|.
name|waitActive
argument_list|()
expr_stmt|;
name|dfs
operator|.
name|startDataNodes
argument_list|(
name|conf
argument_list|,
name|numHosts
argument_list|,
literal|true
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|hosts
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|dfs
operator|.
name|waitActive
argument_list|()
expr_stmt|;
name|FileSystem
operator|.
name|mkdirs
argument_list|(
name|dfs
operator|.
name|getFileSystem
argument_list|()
argument_list|,
operator|new
name|Path
argument_list|(
literal|"/"
argument_list|)
argument_list|,
operator|new
name|FsPermission
argument_list|(
operator|(
name|short
operator|)
literal|0777
argument_list|)
argument_list|)
expr_stmt|;
name|namenode
operator|=
operator|(
name|dfs
operator|.
name|getFileSystem
argument_list|()
operator|)
operator|.
name|getUri
argument_list|()
operator|.
name|getHost
argument_list|()
operator|+
literal|":"
operator|+
operator|(
name|dfs
operator|.
name|getFileSystem
argument_list|()
operator|)
operator|.
name|getUri
argument_list|()
operator|.
name|getPort
argument_list|()
expr_stmt|;
comment|// create tracker hosts
name|trackerHosts
operator|=
operator|new
name|String
index|[
name|numHosts
operator|*
name|numTrackerPerHost
index|]
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<=
operator|(
name|numHosts
operator|*
name|numTrackerPerHost
operator|)
condition|;
operator|++
name|i
control|)
block|{
name|trackerHosts
index|[
name|i
operator|-
literal|1
index|]
operator|=
name|getHostname
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
comment|// start mini mr
name|JobConf
name|jtConf
init|=
operator|new
name|JobConf
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|mr
operator|=
operator|new
name|MiniMRCluster
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|numHosts
operator|*
name|numTrackerPerHost
argument_list|,
name|namenode
argument_list|,
literal|1
argument_list|,
literal|null
argument_list|,
name|trackerHosts
argument_list|,
name|clusterUgi
argument_list|,
name|jtConf
argument_list|,
name|numExcluded
operator|*
name|numTrackerPerHost
argument_list|)
expr_stmt|;
name|jt
operator|=
name|mr
operator|.
name|getJobTrackerRunner
argument_list|()
operator|.
name|getJobTracker
argument_list|()
expr_stmt|;
comment|// check if trackers from all the desired hosts have connected
name|Set
argument_list|<
name|String
argument_list|>
name|hostsSeen
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|TaskTrackerStatus
name|status
range|:
name|jt
operator|.
name|taskTrackers
argument_list|()
control|)
block|{
name|hostsSeen
operator|.
name|add
argument_list|(
name|status
operator|.
name|getHost
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|assertEquals
argument_list|(
literal|"Not all hosts are up"
argument_list|,
name|numHosts
operator|-
name|numExcluded
argument_list|,
name|hostsSeen
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|stopCluster
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|stopCluster ()
specifier|private
name|void
name|stopCluster
parameter_list|()
block|{
name|hosts
operator|=
literal|null
expr_stmt|;
name|trackerHosts
operator|=
literal|null
expr_stmt|;
if|if
condition|(
name|dfs
operator|!=
literal|null
condition|)
block|{
name|dfs
operator|.
name|shutdown
argument_list|()
expr_stmt|;
name|dfs
operator|=
literal|null
expr_stmt|;
name|namenode
operator|=
literal|null
expr_stmt|;
block|}
if|if
condition|(
name|mr
operator|!=
literal|null
condition|)
block|{
name|mr
operator|.
name|shutdown
argument_list|()
expr_stmt|;
name|mr
operator|=
literal|null
expr_stmt|;
name|jt
operator|=
literal|null
expr_stmt|;
block|}
block|}
DECL|method|getClient (Configuration conf, UserGroupInformation ugi)
specifier|private
name|AdminOperationsProtocol
name|getClient
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|UserGroupInformation
name|ugi
parameter_list|)
throws|throws
name|IOException
block|{
return|return
operator|(
name|AdminOperationsProtocol
operator|)
name|RPC
operator|.
name|getProxy
argument_list|(
name|AdminOperationsProtocol
operator|.
name|class
argument_list|,
name|AdminOperationsProtocol
operator|.
name|versionID
argument_list|,
name|JobTracker
operator|.
name|getAddress
argument_list|(
name|conf
argument_list|)
argument_list|,
name|ugi
argument_list|,
name|conf
argument_list|,
name|NetUtils
operator|.
name|getSocketFactory
argument_list|(
name|conf
argument_list|,
name|AdminOperationsProtocol
operator|.
name|class
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Check default value of HOSTS_EXCLUDE. Also check if only     * owner is allowed to this command.    */
DECL|method|testMRRefreshDefault ()
specifier|public
name|void
name|testMRRefreshDefault
parameter_list|()
throws|throws
name|IOException
block|{
comment|// start a cluster with 2 hosts and no exclude-hosts file
name|Configuration
name|conf
init|=
operator|new
name|Configuration
argument_list|()
decl_stmt|;
name|conf
operator|.
name|set
argument_list|(
name|JTConfig
operator|.
name|JT_HOSTS_EXCLUDE_FILENAME
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|startCluster
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|UserGroupInformation
operator|.
name|getLoginUser
argument_list|()
argument_list|,
name|conf
argument_list|)
expr_stmt|;
name|conf
operator|=
name|mr
operator|.
name|createJobConf
argument_list|(
operator|new
name|JobConf
argument_list|(
name|conf
argument_list|)
argument_list|)
expr_stmt|;
comment|// refresh with wrong user
name|AdminOperationsProtocol
name|client
init|=
name|getClient
argument_list|(
name|conf
argument_list|,
name|user1
argument_list|)
decl_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
try|try
block|{
comment|// Also try tool runner
name|client
operator|.
name|refreshNodes
argument_list|()
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{}
name|assertFalse
argument_list|(
literal|"Invalid user performed privileged refresh operation"
argument_list|,
name|success
argument_list|)
expr_stmt|;
comment|// refresh with correct user
name|success
operator|=
literal|false
expr_stmt|;
name|client
operator|=
name|getClient
argument_list|(
name|conf
argument_list|,
name|owner
argument_list|)
expr_stmt|;
try|try
block|{
name|client
operator|.
name|refreshNodes
argument_list|()
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{}
name|assertTrue
argument_list|(
literal|"Privileged user denied permission for refresh operation"
argument_list|,
name|success
argument_list|)
expr_stmt|;
comment|// refresh with invalid user
name|success
operator|=
literal|false
expr_stmt|;
name|client
operator|=
name|getClient
argument_list|(
name|conf
argument_list|,
name|user4
argument_list|)
expr_stmt|;
try|try
block|{
name|client
operator|.
name|refreshNodes
argument_list|()
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{}
name|assertFalse
argument_list|(
literal|"Invalid user performed privileged refresh operation"
argument_list|,
name|success
argument_list|)
expr_stmt|;
comment|// check the cluster status and tracker size
name|assertEquals
argument_list|(
literal|"Trackers are lost upon refresh with empty hosts.exclude"
argument_list|,
literal|2
argument_list|,
name|jt
operator|.
name|getClusterStatus
argument_list|(
literal|false
argument_list|)
operator|.
name|getTaskTrackers
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Excluded node count is incorrect"
argument_list|,
literal|0
argument_list|,
name|jt
operator|.
name|getClusterStatus
argument_list|(
literal|false
argument_list|)
operator|.
name|getNumExcludedNodes
argument_list|()
argument_list|)
expr_stmt|;
comment|// check if the host is disallowed
name|Set
argument_list|<
name|String
argument_list|>
name|hosts
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|TaskTrackerStatus
name|status
range|:
name|jt
operator|.
name|taskTrackers
argument_list|()
control|)
block|{
name|hosts
operator|.
name|add
argument_list|(
name|status
operator|.
name|getHost
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|assertEquals
argument_list|(
literal|"Host is excluded upon refresh with empty hosts.exclude"
argument_list|,
literal|2
argument_list|,
name|hosts
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|stopCluster
argument_list|()
expr_stmt|;
block|}
comment|/**    * Check refresh with a specific user/group set in the conf    */
DECL|method|testMRSuperUsers ()
specifier|public
name|void
name|testMRSuperUsers
parameter_list|()
throws|throws
name|IOException
block|{
comment|// start a cluster with 1 host and specified cluster administrators
name|Configuration
name|conf
init|=
operator|new
name|Configuration
argument_list|()
decl_stmt|;
comment|// set the supergroup
name|conf
operator|.
name|set
argument_list|(
name|MRConfig
operator|.
name|MR_SUPERGROUP
argument_list|,
literal|"supergroup"
argument_list|)
expr_stmt|;
comment|// set the admin acl
name|conf
operator|.
name|set
argument_list|(
name|MRConfig
operator|.
name|MR_ADMINS
argument_list|,
literal|"user5 abc"
argument_list|)
expr_stmt|;
name|startCluster
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|UserGroupInformation
operator|.
name|createRemoteUser
argument_list|(
literal|"user1"
argument_list|)
argument_list|,
name|conf
argument_list|)
expr_stmt|;
name|conf
operator|=
name|mr
operator|.
name|createJobConf
argument_list|(
operator|new
name|JobConf
argument_list|(
name|conf
argument_list|)
argument_list|)
expr_stmt|;
comment|// refresh with wrong user
name|AdminOperationsProtocol
name|client
init|=
name|getClient
argument_list|(
name|conf
argument_list|,
name|user2
argument_list|)
decl_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
try|try
block|{
comment|// Also try tool runner
name|client
operator|.
name|refreshNodes
argument_list|()
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{}
name|assertFalse
argument_list|(
literal|"Invalid user performed privileged refresh operation"
argument_list|,
name|success
argument_list|)
expr_stmt|;
comment|// refresh with correct user
name|success
operator|=
literal|false
expr_stmt|;
name|client
operator|=
name|getClient
argument_list|(
name|conf
argument_list|,
name|user1
argument_list|)
expr_stmt|;
try|try
block|{
name|client
operator|.
name|refreshNodes
argument_list|()
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{}
name|assertTrue
argument_list|(
literal|"Privileged user denied permission for refresh operation"
argument_list|,
name|success
argument_list|)
expr_stmt|;
comment|// refresh with admin group
name|success
operator|=
literal|false
expr_stmt|;
name|client
operator|=
name|getClient
argument_list|(
name|conf
argument_list|,
name|user3
argument_list|)
expr_stmt|;
try|try
block|{
name|client
operator|.
name|refreshNodes
argument_list|()
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{}
name|assertTrue
argument_list|(
literal|"Admin group member denied permission for refresh operation"
argument_list|,
name|success
argument_list|)
expr_stmt|;
comment|// refresh with admin user
name|success
operator|=
literal|false
expr_stmt|;
name|client
operator|=
name|getClient
argument_list|(
name|conf
argument_list|,
name|user5
argument_list|)
expr_stmt|;
try|try
block|{
name|client
operator|.
name|refreshNodes
argument_list|()
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{}
name|assertTrue
argument_list|(
literal|"Admin user denied permission for refresh operation"
argument_list|,
name|success
argument_list|)
expr_stmt|;
comment|// refresh with deprecated super group member
name|success
operator|=
literal|false
expr_stmt|;
name|client
operator|=
name|getClient
argument_list|(
name|conf
argument_list|,
name|user4
argument_list|)
expr_stmt|;
try|try
block|{
name|client
operator|.
name|refreshNodes
argument_list|()
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{}
name|assertTrue
argument_list|(
literal|"Deprecated Super group member denied permission for refresh"
operator|+
literal|" operation"
argument_list|,
name|success
argument_list|)
expr_stmt|;
name|stopCluster
argument_list|()
expr_stmt|;
block|}
comment|/**    * Check node refresh for decommissioning. Check if an allowed host is     * disallowed upon refresh. Also check if only owner/cluster administrator is     * allowed to fire this command.    */
DECL|method|testMRRefreshDecommissioning ()
specifier|public
name|void
name|testMRRefreshDecommissioning
parameter_list|()
throws|throws
name|IOException
block|{
comment|// start a cluster with 2 hosts and empty exclude-hosts file
name|Configuration
name|conf
init|=
operator|new
name|Configuration
argument_list|()
decl_stmt|;
name|File
name|file
init|=
operator|new
name|File
argument_list|(
literal|"hosts.exclude"
argument_list|)
decl_stmt|;
name|file
operator|.
name|delete
argument_list|()
expr_stmt|;
name|startCluster
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|UserGroupInformation
operator|.
name|getLoginUser
argument_list|()
argument_list|,
name|conf
argument_list|)
expr_stmt|;
name|String
name|hostToDecommission
init|=
name|getHostname
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|conf
operator|=
name|mr
operator|.
name|createJobConf
argument_list|(
operator|new
name|JobConf
argument_list|(
name|conf
argument_list|)
argument_list|)
expr_stmt|;
comment|// change the exclude-hosts file to include one host
name|FileOutputStream
name|out
init|=
operator|new
name|FileOutputStream
argument_list|(
name|file
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Writing excluded nodes to log file "
operator|+
name|file
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|BufferedWriter
name|writer
init|=
literal|null
decl_stmt|;
try|try
block|{
name|writer
operator|=
operator|new
name|BufferedWriter
argument_list|(
operator|new
name|OutputStreamWriter
argument_list|(
name|out
argument_list|)
argument_list|)
expr_stmt|;
name|writer
operator|.
name|write
argument_list|(
name|hostToDecommission
operator|+
literal|"\n"
argument_list|)
expr_stmt|;
comment|// decommission first host
block|}
finally|finally
block|{
if|if
condition|(
name|writer
operator|!=
literal|null
condition|)
block|{
name|writer
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
name|out
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
name|file
operator|.
name|deleteOnExit
argument_list|()
expr_stmt|;
name|AdminOperationsProtocol
name|client
init|=
name|getClient
argument_list|(
name|conf
argument_list|,
name|owner
argument_list|)
decl_stmt|;
try|try
block|{
name|client
operator|.
name|refreshNodes
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{}
comment|// check the cluster status and tracker size
name|assertEquals
argument_list|(
literal|"Tracker is not lost upon host decommissioning"
argument_list|,
literal|1
argument_list|,
name|jt
operator|.
name|getClusterStatus
argument_list|(
literal|false
argument_list|)
operator|.
name|getTaskTrackers
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Excluded node count is incorrect"
argument_list|,
literal|1
argument_list|,
name|jt
operator|.
name|getClusterStatus
argument_list|(
literal|false
argument_list|)
operator|.
name|getNumExcludedNodes
argument_list|()
argument_list|)
expr_stmt|;
comment|// check if the host is disallowed
for|for
control|(
name|TaskTrackerStatus
name|status
range|:
name|jt
operator|.
name|taskTrackers
argument_list|()
control|)
block|{
name|assertFalse
argument_list|(
literal|"Tracker from decommissioned host still exist"
argument_list|,
name|status
operator|.
name|getHost
argument_list|()
operator|.
name|equals
argument_list|(
name|hostToDecommission
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|stopCluster
argument_list|()
expr_stmt|;
block|}
comment|/**    * Check node refresh for recommissioning. Check if an disallowed host is     * allowed upon refresh.    */
DECL|method|testMRRefreshRecommissioning ()
specifier|public
name|void
name|testMRRefreshRecommissioning
parameter_list|()
throws|throws
name|IOException
block|{
name|String
name|hostToInclude
init|=
name|getHostname
argument_list|(
literal|1
argument_list|)
decl_stmt|;
comment|// start a cluster with 2 hosts and exclude-hosts file having one hostname
name|Configuration
name|conf
init|=
operator|new
name|Configuration
argument_list|()
decl_stmt|;
comment|// create a exclude-hosts file to include one host
name|File
name|file
init|=
operator|new
name|File
argument_list|(
literal|"hosts.exclude"
argument_list|)
decl_stmt|;
name|file
operator|.
name|delete
argument_list|()
expr_stmt|;
name|FileOutputStream
name|out
init|=
operator|new
name|FileOutputStream
argument_list|(
name|file
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Writing excluded nodes to log file "
operator|+
name|file
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|BufferedWriter
name|writer
init|=
literal|null
decl_stmt|;
try|try
block|{
name|writer
operator|=
operator|new
name|BufferedWriter
argument_list|(
operator|new
name|OutputStreamWriter
argument_list|(
name|out
argument_list|)
argument_list|)
expr_stmt|;
name|writer
operator|.
name|write
argument_list|(
name|hostToInclude
operator|+
literal|"\n"
argument_list|)
expr_stmt|;
comment|// exclude first host
block|}
finally|finally
block|{
if|if
condition|(
name|writer
operator|!=
literal|null
condition|)
block|{
name|writer
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
name|out
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
name|startCluster
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|UserGroupInformation
operator|.
name|getLoginUser
argument_list|()
argument_list|,
name|conf
argument_list|)
expr_stmt|;
name|file
operator|.
name|delete
argument_list|()
expr_stmt|;
comment|// change the exclude-hosts file to include no hosts
comment|// note that this will also test hosts file with no content
name|out
operator|=
operator|new
name|FileOutputStream
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Clearing hosts.exclude file "
operator|+
name|file
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|writer
operator|=
literal|null
expr_stmt|;
try|try
block|{
name|writer
operator|=
operator|new
name|BufferedWriter
argument_list|(
operator|new
name|OutputStreamWriter
argument_list|(
name|out
argument_list|)
argument_list|)
expr_stmt|;
name|writer
operator|.
name|write
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|writer
operator|!=
literal|null
condition|)
block|{
name|writer
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
name|out
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
name|file
operator|.
name|deleteOnExit
argument_list|()
expr_stmt|;
name|conf
operator|=
name|mr
operator|.
name|createJobConf
argument_list|(
operator|new
name|JobConf
argument_list|(
name|conf
argument_list|)
argument_list|)
expr_stmt|;
name|AdminOperationsProtocol
name|client
init|=
name|getClient
argument_list|(
name|conf
argument_list|,
name|owner
argument_list|)
decl_stmt|;
try|try
block|{
name|client
operator|.
name|refreshNodes
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{}
comment|// start a tracker
name|mr
operator|.
name|startTaskTracker
argument_list|(
name|hostToInclude
argument_list|,
literal|null
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|// wait for the tracker to join the jt
while|while
condition|(
name|jt
operator|.
name|taskTrackers
argument_list|()
operator|.
name|size
argument_list|()
operator|<
literal|2
condition|)
block|{
name|UtilsForTests
operator|.
name|waitFor
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
name|assertEquals
argument_list|(
literal|"Excluded node count is incorrect"
argument_list|,
literal|0
argument_list|,
name|jt
operator|.
name|getClusterStatus
argument_list|(
literal|false
argument_list|)
operator|.
name|getNumExcludedNodes
argument_list|()
argument_list|)
expr_stmt|;
comment|// check if the host is disallowed
name|boolean
name|seen
init|=
literal|false
decl_stmt|;
for|for
control|(
name|TaskTrackerStatus
name|status
range|:
name|jt
operator|.
name|taskTrackers
argument_list|()
control|)
block|{
if|if
condition|(
name|status
operator|.
name|getHost
argument_list|()
operator|.
name|equals
argument_list|(
name|hostToInclude
argument_list|)
condition|)
block|{
name|seen
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
name|assertTrue
argument_list|(
literal|"Tracker from excluded host doesnt exist"
argument_list|,
name|seen
argument_list|)
expr_stmt|;
name|stopCluster
argument_list|()
expr_stmt|;
block|}
comment|// Mapper that fails once for the first time
DECL|class|FailOnceMapper
specifier|static
class|class
name|FailOnceMapper
extends|extends
name|MapReduceBase
implements|implements
name|Mapper
argument_list|<
name|WritableComparable
argument_list|,
name|Writable
argument_list|,
name|WritableComparable
argument_list|,
name|Writable
argument_list|>
block|{
DECL|field|shouldFail
specifier|private
name|boolean
name|shouldFail
init|=
literal|false
decl_stmt|;
DECL|method|map (WritableComparable key, Writable value, OutputCollector<WritableComparable, Writable> out, Reporter reporter)
specifier|public
name|void
name|map
parameter_list|(
name|WritableComparable
name|key
parameter_list|,
name|Writable
name|value
parameter_list|,
name|OutputCollector
argument_list|<
name|WritableComparable
argument_list|,
name|Writable
argument_list|>
name|out
parameter_list|,
name|Reporter
name|reporter
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|shouldFail
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"failing map"
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
DECL|method|configure (JobConf conf)
specifier|public
name|void
name|configure
parameter_list|(
name|JobConf
name|conf
parameter_list|)
block|{
name|TaskAttemptID
name|id
init|=
name|TaskAttemptID
operator|.
name|forName
argument_list|(
name|conf
operator|.
name|get
argument_list|(
literal|"mapred.task.id"
argument_list|)
argument_list|)
decl_stmt|;
name|shouldFail
operator|=
name|id
operator|.
name|getId
argument_list|()
operator|==
literal|0
operator|&&
name|id
operator|.
name|getTaskID
argument_list|()
operator|.
name|getId
argument_list|()
operator|==
literal|0
expr_stmt|;
block|}
block|}
comment|/**    * Check refreshNodes for decommissioning blacklisted nodes.     */
DECL|method|testBlacklistedNodeDecommissioning ()
specifier|public
name|void
name|testBlacklistedNodeDecommissioning
parameter_list|()
throws|throws
name|Exception
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Testing blacklisted node decommissioning"
argument_list|)
expr_stmt|;
name|Configuration
name|conf
init|=
operator|new
name|Configuration
argument_list|()
decl_stmt|;
name|conf
operator|.
name|set
argument_list|(
name|JTConfig
operator|.
name|JT_MAX_TRACKER_BLACKLISTS
argument_list|,
literal|"1"
argument_list|)
expr_stmt|;
name|startCluster
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|UserGroupInformation
operator|.
name|getLoginUser
argument_list|()
argument_list|,
name|conf
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Trackers not up"
argument_list|,
literal|2
argument_list|,
name|mr
operator|.
name|getJobTrackerRunner
argument_list|()
operator|.
name|getJobTracker
argument_list|()
operator|.
name|getActiveTrackers
argument_list|()
operator|.
name|length
argument_list|)
expr_stmt|;
comment|// validate the total tracker count
name|assertEquals
argument_list|(
literal|"Active tracker count mismatch"
argument_list|,
literal|2
argument_list|,
name|jt
operator|.
name|getClusterStatus
argument_list|(
literal|false
argument_list|)
operator|.
name|getTaskTrackers
argument_list|()
argument_list|)
expr_stmt|;
comment|// validate blacklisted count
name|assertEquals
argument_list|(
literal|"Blacklisted tracker count mismatch"
argument_list|,
literal|0
argument_list|,
name|jt
operator|.
name|getClusterStatus
argument_list|(
literal|false
argument_list|)
operator|.
name|getBlacklistedTrackers
argument_list|()
argument_list|)
expr_stmt|;
comment|// run a failing job to blacklist the tracker
name|JobConf
name|jConf
init|=
name|mr
operator|.
name|createJobConf
argument_list|()
decl_stmt|;
name|jConf
operator|.
name|set
argument_list|(
name|MRJobConfig
operator|.
name|MAX_TASK_FAILURES_PER_TRACKER
argument_list|,
literal|"1"
argument_list|)
expr_stmt|;
name|jConf
operator|.
name|setJobName
argument_list|(
literal|"test-job-fail-once"
argument_list|)
expr_stmt|;
name|jConf
operator|.
name|setMapperClass
argument_list|(
name|FailOnceMapper
operator|.
name|class
argument_list|)
expr_stmt|;
name|jConf
operator|.
name|setReducerClass
argument_list|(
name|IdentityReducer
operator|.
name|class
argument_list|)
expr_stmt|;
name|jConf
operator|.
name|setNumMapTasks
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|jConf
operator|.
name|setNumReduceTasks
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|RunningJob
name|job
init|=
name|UtilsForTests
operator|.
name|runJob
argument_list|(
name|jConf
argument_list|,
operator|new
name|Path
argument_list|(
literal|"in"
argument_list|)
argument_list|,
operator|new
name|Path
argument_list|(
literal|"out"
argument_list|)
argument_list|)
decl_stmt|;
name|job
operator|.
name|waitForCompletion
argument_list|()
expr_stmt|;
comment|// check if the tracker is lost
comment|// validate the total tracker count
name|assertEquals
argument_list|(
literal|"Active tracker count mismatch"
argument_list|,
literal|1
argument_list|,
name|jt
operator|.
name|getClusterStatus
argument_list|(
literal|false
argument_list|)
operator|.
name|getTaskTrackers
argument_list|()
argument_list|)
expr_stmt|;
comment|// validate blacklisted count
name|assertEquals
argument_list|(
literal|"Blacklisted tracker count mismatch"
argument_list|,
literal|1
argument_list|,
name|jt
operator|.
name|getClusterStatus
argument_list|(
literal|false
argument_list|)
operator|.
name|getBlacklistedTrackers
argument_list|()
argument_list|)
expr_stmt|;
comment|// find the tracker to decommission
name|String
name|hostToDecommission
init|=
name|JobInProgress
operator|.
name|convertTrackerNameToHostName
argument_list|(
name|jt
operator|.
name|getBlacklistedTrackers
argument_list|()
index|[
literal|0
index|]
operator|.
name|getTaskTrackerName
argument_list|()
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Decommissioning host "
operator|+
name|hostToDecommission
argument_list|)
expr_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|decom
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|decom
operator|.
name|add
argument_list|(
name|hostToDecommission
argument_list|)
expr_stmt|;
name|jt
operator|.
name|decommissionNodes
argument_list|(
name|decom
argument_list|)
expr_stmt|;
comment|// check the cluster status and tracker size
name|assertEquals
argument_list|(
literal|"Tracker is not lost upon host decommissioning"
argument_list|,
literal|1
argument_list|,
name|jt
operator|.
name|getClusterStatus
argument_list|(
literal|false
argument_list|)
operator|.
name|getTaskTrackers
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Blacklisted tracker count incorrect in cluster status after "
operator|+
literal|"decommissioning"
argument_list|,
literal|0
argument_list|,
name|jt
operator|.
name|getClusterStatus
argument_list|(
literal|false
argument_list|)
operator|.
name|getBlacklistedTrackers
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Tracker is not lost upon host decommissioning"
argument_list|,
literal|1
argument_list|,
name|jt
operator|.
name|taskTrackers
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|stopCluster
argument_list|()
expr_stmt|;
block|}
block|}
end_class

end_unit

