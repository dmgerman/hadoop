begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.mapred
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Executors
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutorService
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|http
operator|.
name|HttpServer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|TaskType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|server
operator|.
name|jobtracker
operator|.
name|TaskTracker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|ReflectionUtils
import|;
end_import

begin_comment
comment|/**  * A {@link TaskScheduler} that implements fair sharing.  */
end_comment

begin_class
DECL|class|FairScheduler
specifier|public
class|class
name|FairScheduler
extends|extends
name|TaskScheduler
block|{
DECL|field|LOG
specifier|public
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
literal|"org.apache.hadoop.mapred.FairScheduler"
argument_list|)
decl_stmt|;
comment|// How often fair shares are re-calculated
DECL|field|updateInterval
specifier|protected
name|long
name|updateInterval
init|=
literal|500
decl_stmt|;
comment|// How often to dump scheduler state to the event log
DECL|field|dumpInterval
specifier|protected
name|long
name|dumpInterval
init|=
literal|10000
decl_stmt|;
comment|// How often tasks are preempted (must be longer than a couple
comment|// of heartbeats to give task-kill commands a chance to act).
DECL|field|preemptionInterval
specifier|protected
name|long
name|preemptionInterval
init|=
literal|15000
decl_stmt|;
comment|// Used to iterate through map and reduce task types
DECL|field|MAP_AND_REDUCE
specifier|private
specifier|static
specifier|final
name|TaskType
index|[]
name|MAP_AND_REDUCE
init|=
operator|new
name|TaskType
index|[]
block|{
name|TaskType
operator|.
name|MAP
block|,
name|TaskType
operator|.
name|REDUCE
block|}
decl_stmt|;
comment|// Maximum locality delay when auto-computing locality delays
DECL|field|MAX_AUTOCOMPUTED_LOCALITY_DELAY
specifier|private
specifier|static
specifier|final
name|long
name|MAX_AUTOCOMPUTED_LOCALITY_DELAY
init|=
literal|15000
decl_stmt|;
DECL|field|poolMgr
specifier|protected
name|PoolManager
name|poolMgr
decl_stmt|;
DECL|field|loadMgr
specifier|protected
name|LoadManager
name|loadMgr
decl_stmt|;
DECL|field|taskSelector
specifier|protected
name|TaskSelector
name|taskSelector
decl_stmt|;
DECL|field|weightAdjuster
specifier|protected
name|WeightAdjuster
name|weightAdjuster
decl_stmt|;
comment|// Can be null for no weight adjuster
DECL|field|infos
specifier|protected
name|Map
argument_list|<
name|JobInProgress
argument_list|,
name|JobInfo
argument_list|>
name|infos
init|=
comment|// per-job scheduling variables
operator|new
name|HashMap
argument_list|<
name|JobInProgress
argument_list|,
name|JobInfo
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|lastUpdateTime
specifier|protected
name|long
name|lastUpdateTime
decl_stmt|;
comment|// Time when we last updated infos
DECL|field|initialized
specifier|protected
name|boolean
name|initialized
decl_stmt|;
comment|// Are we initialized?
DECL|field|running
specifier|protected
specifier|volatile
name|boolean
name|running
decl_stmt|;
comment|// Are we running?
DECL|field|assignMultiple
specifier|protected
name|boolean
name|assignMultiple
decl_stmt|;
comment|// Simultaneously assign map and reduce?
DECL|field|mapAssignCap
specifier|protected
name|int
name|mapAssignCap
init|=
operator|-
literal|1
decl_stmt|;
comment|// Max maps to launch per heartbeat
DECL|field|reduceAssignCap
specifier|protected
name|int
name|reduceAssignCap
init|=
operator|-
literal|1
decl_stmt|;
comment|// Max reduces to launch per heartbeat
DECL|field|nodeLocalityDelay
specifier|protected
name|long
name|nodeLocalityDelay
decl_stmt|;
comment|// Time to wait for node locality
DECL|field|rackLocalityDelay
specifier|protected
name|long
name|rackLocalityDelay
decl_stmt|;
comment|// Time to wait for rack locality
DECL|field|autoComputeLocalityDelay
specifier|protected
name|boolean
name|autoComputeLocalityDelay
init|=
literal|false
decl_stmt|;
comment|// Compute locality delay
comment|// from heartbeat interval
DECL|field|sizeBasedWeight
specifier|protected
name|boolean
name|sizeBasedWeight
decl_stmt|;
comment|// Give larger weights to larger jobs
DECL|field|waitForMapsBeforeLaunchingReduces
specifier|protected
name|boolean
name|waitForMapsBeforeLaunchingReduces
init|=
literal|true
decl_stmt|;
DECL|field|preemptionEnabled
specifier|protected
name|boolean
name|preemptionEnabled
decl_stmt|;
DECL|field|onlyLogPreemption
specifier|protected
name|boolean
name|onlyLogPreemption
decl_stmt|;
comment|// Only log when tasks should be killed
DECL|field|clock
specifier|private
name|Clock
name|clock
decl_stmt|;
DECL|field|jobListener
specifier|private
name|JobListener
name|jobListener
decl_stmt|;
DECL|field|jobInitializer
specifier|private
name|JobInitializer
name|jobInitializer
decl_stmt|;
DECL|field|mockMode
specifier|private
name|boolean
name|mockMode
decl_stmt|;
comment|// Used for unit tests; disables background updates
comment|// and scheduler event log
DECL|field|eventLog
specifier|private
name|FairSchedulerEventLog
name|eventLog
decl_stmt|;
DECL|field|lastDumpTime
specifier|protected
name|long
name|lastDumpTime
decl_stmt|;
comment|// Time when we last dumped state to log
DECL|field|lastHeartbeatTime
specifier|protected
name|long
name|lastHeartbeatTime
decl_stmt|;
comment|// Time we last ran assignTasks
DECL|field|lastPreemptCheckTime
specifier|private
name|long
name|lastPreemptCheckTime
decl_stmt|;
comment|// Time we last ran preemptTasksIfNecessary
comment|/**    * A class for holding per-job scheduler variables. These always contain the    * values of the variables at the last update(), and are used along with a    * time delta to update the map and reduce deficits before a new update().    */
DECL|class|JobInfo
specifier|static
class|class
name|JobInfo
block|{
DECL|field|runnable
name|boolean
name|runnable
init|=
literal|false
decl_stmt|;
comment|// Can the job run given user/pool limits?
comment|// Does this job need to be initialized?
DECL|field|needsInitializing
specifier|volatile
name|boolean
name|needsInitializing
init|=
literal|true
decl_stmt|;
DECL|field|mapSchedulable
specifier|public
name|JobSchedulable
name|mapSchedulable
decl_stmt|;
DECL|field|reduceSchedulable
specifier|public
name|JobSchedulable
name|reduceSchedulable
decl_stmt|;
comment|// Variables used for delay scheduling
DECL|field|lastMapLocalityLevel
name|LocalityLevel
name|lastMapLocalityLevel
decl_stmt|;
comment|// Locality level of last map launched
DECL|field|timeWaitedForLocalMap
name|long
name|timeWaitedForLocalMap
decl_stmt|;
comment|// Time waiting for local map since last map
DECL|field|skippedAtLastHeartbeat
name|boolean
name|skippedAtLastHeartbeat
decl_stmt|;
comment|// Was job skipped at previous assignTasks?
comment|// (used to update timeWaitedForLocalMap)
DECL|method|JobInfo (JobSchedulable mapSched, JobSchedulable reduceSched)
specifier|public
name|JobInfo
parameter_list|(
name|JobSchedulable
name|mapSched
parameter_list|,
name|JobSchedulable
name|reduceSched
parameter_list|)
block|{
name|this
operator|.
name|mapSchedulable
operator|=
name|mapSched
expr_stmt|;
name|this
operator|.
name|reduceSchedulable
operator|=
name|reduceSched
expr_stmt|;
name|this
operator|.
name|lastMapLocalityLevel
operator|=
name|LocalityLevel
operator|.
name|NODE
expr_stmt|;
block|}
block|}
DECL|method|FairScheduler ()
specifier|public
name|FairScheduler
parameter_list|()
block|{
name|this
argument_list|(
operator|new
name|Clock
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/**    * Constructor used for tests, which can change the clock and disable updates.    */
DECL|method|FairScheduler (Clock clock, boolean mockMode)
specifier|protected
name|FairScheduler
parameter_list|(
name|Clock
name|clock
parameter_list|,
name|boolean
name|mockMode
parameter_list|)
block|{
name|this
operator|.
name|clock
operator|=
name|clock
expr_stmt|;
name|this
operator|.
name|mockMode
operator|=
name|mockMode
expr_stmt|;
name|this
operator|.
name|jobListener
operator|=
operator|new
name|JobListener
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|start ()
specifier|public
name|void
name|start
parameter_list|()
block|{
try|try
block|{
name|Configuration
name|conf
init|=
name|getConf
argument_list|()
decl_stmt|;
comment|// Create scheduling log and initialize it if it is enabled
name|eventLog
operator|=
operator|new
name|FairSchedulerEventLog
argument_list|()
expr_stmt|;
name|boolean
name|logEnabled
init|=
name|conf
operator|.
name|getBoolean
argument_list|(
literal|"mapred.fairscheduler.eventlog.enabled"
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|mockMode
operator|&&
name|logEnabled
condition|)
block|{
name|String
name|hostname
init|=
literal|"localhost"
decl_stmt|;
if|if
condition|(
name|taskTrackerManager
operator|instanceof
name|JobTracker
condition|)
block|{
name|hostname
operator|=
operator|(
operator|(
name|JobTracker
operator|)
name|taskTrackerManager
operator|)
operator|.
name|getJobTrackerMachine
argument_list|()
expr_stmt|;
block|}
name|eventLog
operator|.
name|init
argument_list|(
name|conf
argument_list|,
name|hostname
argument_list|)
expr_stmt|;
block|}
comment|// Initialize other pieces of the scheduler
name|jobInitializer
operator|=
operator|new
name|JobInitializer
argument_list|(
name|conf
argument_list|,
name|taskTrackerManager
argument_list|)
expr_stmt|;
name|taskTrackerManager
operator|.
name|addJobInProgressListener
argument_list|(
name|jobListener
argument_list|)
expr_stmt|;
name|poolMgr
operator|=
operator|new
name|PoolManager
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|poolMgr
operator|.
name|initialize
argument_list|()
expr_stmt|;
name|loadMgr
operator|=
operator|(
name|LoadManager
operator|)
name|ReflectionUtils
operator|.
name|newInstance
argument_list|(
name|conf
operator|.
name|getClass
argument_list|(
literal|"mapred.fairscheduler.loadmanager"
argument_list|,
name|CapBasedLoadManager
operator|.
name|class
argument_list|,
name|LoadManager
operator|.
name|class
argument_list|)
argument_list|,
name|conf
argument_list|)
expr_stmt|;
name|loadMgr
operator|.
name|setTaskTrackerManager
argument_list|(
name|taskTrackerManager
argument_list|)
expr_stmt|;
name|loadMgr
operator|.
name|setEventLog
argument_list|(
name|eventLog
argument_list|)
expr_stmt|;
name|loadMgr
operator|.
name|start
argument_list|()
expr_stmt|;
name|taskSelector
operator|=
operator|(
name|TaskSelector
operator|)
name|ReflectionUtils
operator|.
name|newInstance
argument_list|(
name|conf
operator|.
name|getClass
argument_list|(
literal|"mapred.fairscheduler.taskselector"
argument_list|,
name|DefaultTaskSelector
operator|.
name|class
argument_list|,
name|TaskSelector
operator|.
name|class
argument_list|)
argument_list|,
name|conf
argument_list|)
expr_stmt|;
name|taskSelector
operator|.
name|setTaskTrackerManager
argument_list|(
name|taskTrackerManager
argument_list|)
expr_stmt|;
name|taskSelector
operator|.
name|start
argument_list|()
expr_stmt|;
name|Class
argument_list|<
name|?
argument_list|>
name|weightAdjClass
init|=
name|conf
operator|.
name|getClass
argument_list|(
literal|"mapred.fairscheduler.weightadjuster"
argument_list|,
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|weightAdjClass
operator|!=
literal|null
condition|)
block|{
name|weightAdjuster
operator|=
operator|(
name|WeightAdjuster
operator|)
name|ReflectionUtils
operator|.
name|newInstance
argument_list|(
name|weightAdjClass
argument_list|,
name|conf
argument_list|)
expr_stmt|;
block|}
name|updateInterval
operator|=
name|conf
operator|.
name|getLong
argument_list|(
literal|"mapred.fairscheduler.update.interval"
argument_list|,
literal|500
argument_list|)
expr_stmt|;
name|dumpInterval
operator|=
name|conf
operator|.
name|getLong
argument_list|(
literal|"mapred.fairscheduler.dump.interval"
argument_list|,
literal|10000
argument_list|)
expr_stmt|;
name|preemptionInterval
operator|=
name|conf
operator|.
name|getLong
argument_list|(
literal|"mapred.fairscheduler.preemption.interval"
argument_list|,
literal|15000
argument_list|)
expr_stmt|;
name|assignMultiple
operator|=
name|conf
operator|.
name|getBoolean
argument_list|(
literal|"mapred.fairscheduler.assignmultiple"
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|mapAssignCap
operator|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"mapred.fairscheduler.assignmultiple.maps"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|reduceAssignCap
operator|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"mapred.fairscheduler.assignmultiple.reduces"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|sizeBasedWeight
operator|=
name|conf
operator|.
name|getBoolean
argument_list|(
literal|"mapred.fairscheduler.sizebasedweight"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|preemptionEnabled
operator|=
name|conf
operator|.
name|getBoolean
argument_list|(
literal|"mapred.fairscheduler.preemption"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|onlyLogPreemption
operator|=
name|conf
operator|.
name|getBoolean
argument_list|(
literal|"mapred.fairscheduler.preemption.only.log"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|long
name|defaultDelay
init|=
name|conf
operator|.
name|getLong
argument_list|(
literal|"mapred.fairscheduler.locality.delay"
argument_list|,
operator|-
literal|1
argument_list|)
decl_stmt|;
name|nodeLocalityDelay
operator|=
name|conf
operator|.
name|getLong
argument_list|(
literal|"mapred.fairscheduler.locality.delay.node"
argument_list|,
name|defaultDelay
argument_list|)
expr_stmt|;
name|rackLocalityDelay
operator|=
name|conf
operator|.
name|getLong
argument_list|(
literal|"mapred.fairscheduler.locality.delay.rack"
argument_list|,
name|defaultDelay
argument_list|)
expr_stmt|;
if|if
condition|(
name|defaultDelay
operator|==
operator|-
literal|1
operator|&&
operator|(
name|nodeLocalityDelay
operator|==
operator|-
literal|1
operator|||
name|rackLocalityDelay
operator|==
operator|-
literal|1
operator|)
condition|)
block|{
name|autoComputeLocalityDelay
operator|=
literal|true
expr_stmt|;
comment|// Compute from heartbeat interval
block|}
name|initialized
operator|=
literal|true
expr_stmt|;
name|running
operator|=
literal|true
expr_stmt|;
name|lastUpdateTime
operator|=
name|clock
operator|.
name|getTime
argument_list|()
expr_stmt|;
comment|// Start a thread to update deficits every UPDATE_INTERVAL
if|if
condition|(
operator|!
name|mockMode
condition|)
block|{
operator|new
name|UpdateThread
argument_list|()
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
comment|// Register servlet with JobTracker's Jetty server
if|if
condition|(
name|taskTrackerManager
operator|instanceof
name|JobTracker
condition|)
block|{
name|JobTracker
name|jobTracker
init|=
operator|(
name|JobTracker
operator|)
name|taskTrackerManager
decl_stmt|;
name|HttpServer
name|infoServer
init|=
name|jobTracker
operator|.
name|infoServer
decl_stmt|;
name|infoServer
operator|.
name|setAttribute
argument_list|(
literal|"scheduler"
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|infoServer
operator|.
name|addServlet
argument_list|(
literal|"scheduler"
argument_list|,
literal|"/scheduler"
argument_list|,
name|FairSchedulerServlet
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
name|eventLog
operator|.
name|log
argument_list|(
literal|"INITIALIZED"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
comment|// Can't load one of the managers - crash the JobTracker now while it is
comment|// starting up so that the user notices.
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Failed to start FairScheduler"
argument_list|,
name|e
argument_list|)
throw|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Successfully configured FairScheduler"
argument_list|)
expr_stmt|;
block|}
comment|/**    * Returns the LoadManager object used by the Fair Share scheduler    */
DECL|method|getLoadManager ()
name|LoadManager
name|getLoadManager
parameter_list|()
block|{
return|return
name|loadMgr
return|;
block|}
annotation|@
name|Override
DECL|method|terminate ()
specifier|public
name|void
name|terminate
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|eventLog
operator|!=
literal|null
condition|)
name|eventLog
operator|.
name|log
argument_list|(
literal|"SHUTDOWN"
argument_list|)
expr_stmt|;
name|running
operator|=
literal|false
expr_stmt|;
name|jobInitializer
operator|.
name|terminate
argument_list|()
expr_stmt|;
if|if
condition|(
name|jobListener
operator|!=
literal|null
condition|)
name|taskTrackerManager
operator|.
name|removeJobInProgressListener
argument_list|(
name|jobListener
argument_list|)
expr_stmt|;
if|if
condition|(
name|eventLog
operator|!=
literal|null
condition|)
name|eventLog
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
DECL|class|JobInitializer
specifier|private
class|class
name|JobInitializer
block|{
DECL|field|DEFAULT_NUM_THREADS
specifier|private
specifier|final
name|int
name|DEFAULT_NUM_THREADS
init|=
literal|1
decl_stmt|;
DECL|field|threadPool
specifier|private
name|ExecutorService
name|threadPool
decl_stmt|;
DECL|field|ttm
specifier|private
name|TaskTrackerManager
name|ttm
decl_stmt|;
DECL|method|JobInitializer (Configuration conf, TaskTrackerManager ttm)
specifier|public
name|JobInitializer
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|TaskTrackerManager
name|ttm
parameter_list|)
block|{
name|int
name|numThreads
init|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"mapred.jobinit.threads"
argument_list|,
name|DEFAULT_NUM_THREADS
argument_list|)
decl_stmt|;
name|threadPool
operator|=
name|Executors
operator|.
name|newFixedThreadPool
argument_list|(
name|numThreads
argument_list|)
expr_stmt|;
name|this
operator|.
name|ttm
operator|=
name|ttm
expr_stmt|;
block|}
DECL|method|initJob (JobInfo jobInfo, JobInProgress job)
specifier|public
name|void
name|initJob
parameter_list|(
name|JobInfo
name|jobInfo
parameter_list|,
name|JobInProgress
name|job
parameter_list|)
block|{
if|if
condition|(
operator|!
name|mockMode
condition|)
block|{
name|threadPool
operator|.
name|execute
argument_list|(
operator|new
name|InitJob
argument_list|(
name|jobInfo
argument_list|,
name|job
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|new
name|InitJob
argument_list|(
name|jobInfo
argument_list|,
name|job
argument_list|)
operator|.
name|run
argument_list|()
expr_stmt|;
block|}
block|}
DECL|class|InitJob
class|class
name|InitJob
implements|implements
name|Runnable
block|{
DECL|field|jobInfo
specifier|private
name|JobInfo
name|jobInfo
decl_stmt|;
DECL|field|job
specifier|private
name|JobInProgress
name|job
decl_stmt|;
DECL|method|InitJob (JobInfo jobInfo, JobInProgress job)
specifier|public
name|InitJob
parameter_list|(
name|JobInfo
name|jobInfo
parameter_list|,
name|JobInProgress
name|job
parameter_list|)
block|{
name|this
operator|.
name|jobInfo
operator|=
name|jobInfo
expr_stmt|;
name|this
operator|.
name|job
operator|=
name|job
expr_stmt|;
block|}
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
name|ttm
operator|.
name|initJob
argument_list|(
name|job
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|terminate ()
name|void
name|terminate
parameter_list|()
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Shutting down thread pool"
argument_list|)
expr_stmt|;
name|threadPool
operator|.
name|shutdownNow
argument_list|()
expr_stmt|;
try|try
block|{
name|threadPool
operator|.
name|awaitTermination
argument_list|(
literal|1
argument_list|,
name|TimeUnit
operator|.
name|MINUTES
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
comment|// Ignore, we are in shutdown anyway.
block|}
block|}
block|}
comment|/**    * Used to listen for jobs added/removed by our {@link TaskTrackerManager}.    */
DECL|class|JobListener
specifier|private
class|class
name|JobListener
extends|extends
name|JobInProgressListener
block|{
annotation|@
name|Override
DECL|method|jobAdded (JobInProgress job)
specifier|public
name|void
name|jobAdded
parameter_list|(
name|JobInProgress
name|job
parameter_list|)
block|{
synchronized|synchronized
init|(
name|FairScheduler
operator|.
name|this
init|)
block|{
name|eventLog
operator|.
name|log
argument_list|(
literal|"JOB_ADDED"
argument_list|,
name|job
operator|.
name|getJobID
argument_list|()
argument_list|)
expr_stmt|;
name|JobInfo
name|info
init|=
operator|new
name|JobInfo
argument_list|(
operator|new
name|JobSchedulable
argument_list|(
name|FairScheduler
operator|.
name|this
argument_list|,
name|job
argument_list|,
name|TaskType
operator|.
name|MAP
argument_list|)
argument_list|,
operator|new
name|JobSchedulable
argument_list|(
name|FairScheduler
operator|.
name|this
argument_list|,
name|job
argument_list|,
name|TaskType
operator|.
name|REDUCE
argument_list|)
argument_list|)
decl_stmt|;
name|infos
operator|.
name|put
argument_list|(
name|job
argument_list|,
name|info
argument_list|)
expr_stmt|;
name|poolMgr
operator|.
name|addJob
argument_list|(
name|job
argument_list|)
expr_stmt|;
comment|// Also adds job into the right PoolScheduable
name|update
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|jobRemoved (JobInProgress job)
specifier|public
name|void
name|jobRemoved
parameter_list|(
name|JobInProgress
name|job
parameter_list|)
block|{
synchronized|synchronized
init|(
name|FairScheduler
operator|.
name|this
init|)
block|{
name|eventLog
operator|.
name|log
argument_list|(
literal|"JOB_REMOVED"
argument_list|,
name|job
operator|.
name|getJobID
argument_list|()
argument_list|)
expr_stmt|;
name|poolMgr
operator|.
name|removeJob
argument_list|(
name|job
argument_list|)
expr_stmt|;
name|infos
operator|.
name|remove
argument_list|(
name|job
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|jobUpdated (JobChangeEvent event)
specifier|public
name|void
name|jobUpdated
parameter_list|(
name|JobChangeEvent
name|event
parameter_list|)
block|{
name|eventLog
operator|.
name|log
argument_list|(
literal|"JOB_UPDATED"
argument_list|,
name|event
operator|.
name|getJobInProgress
argument_list|()
operator|.
name|getJobID
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * A thread which calls {@link FairScheduler#update()} ever    *<code>UPDATE_INTERVAL</code> milliseconds.    */
DECL|class|UpdateThread
specifier|private
class|class
name|UpdateThread
extends|extends
name|Thread
block|{
DECL|method|UpdateThread ()
specifier|private
name|UpdateThread
parameter_list|()
block|{
name|super
argument_list|(
literal|"FairScheduler update thread"
argument_list|)
expr_stmt|;
block|}
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
while|while
condition|(
name|running
condition|)
block|{
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|updateInterval
argument_list|)
expr_stmt|;
name|update
argument_list|()
expr_stmt|;
name|dumpIfNecessary
argument_list|()
expr_stmt|;
name|preemptTasksIfNecessary
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Exception in fair scheduler UpdateThread"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
annotation|@
name|Override
DECL|method|assignTasks (TaskTracker tracker)
specifier|public
specifier|synchronized
name|List
argument_list|<
name|Task
argument_list|>
name|assignTasks
parameter_list|(
name|TaskTracker
name|tracker
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|initialized
condition|)
comment|// Don't try to assign tasks if we haven't yet started up
return|return
literal|null
return|;
name|String
name|trackerName
init|=
name|tracker
operator|.
name|getTrackerName
argument_list|()
decl_stmt|;
name|eventLog
operator|.
name|log
argument_list|(
literal|"HEARTBEAT"
argument_list|,
name|trackerName
argument_list|)
expr_stmt|;
name|long
name|currentTime
init|=
name|clock
operator|.
name|getTime
argument_list|()
decl_stmt|;
comment|// Compute total runnable maps and reduces, and currently running ones
name|int
name|runnableMaps
init|=
literal|0
decl_stmt|;
name|int
name|runningMaps
init|=
literal|0
decl_stmt|;
name|int
name|runnableReduces
init|=
literal|0
decl_stmt|;
name|int
name|runningReduces
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Pool
name|pool
range|:
name|poolMgr
operator|.
name|getPools
argument_list|()
control|)
block|{
name|runnableMaps
operator|+=
name|pool
operator|.
name|getMapSchedulable
argument_list|()
operator|.
name|getDemand
argument_list|()
expr_stmt|;
name|runningMaps
operator|+=
name|pool
operator|.
name|getMapSchedulable
argument_list|()
operator|.
name|getRunningTasks
argument_list|()
expr_stmt|;
name|runnableReduces
operator|+=
name|pool
operator|.
name|getReduceSchedulable
argument_list|()
operator|.
name|getDemand
argument_list|()
expr_stmt|;
name|runningReduces
operator|+=
name|pool
operator|.
name|getReduceSchedulable
argument_list|()
operator|.
name|getRunningTasks
argument_list|()
expr_stmt|;
block|}
name|ClusterStatus
name|clusterStatus
init|=
name|taskTrackerManager
operator|.
name|getClusterStatus
argument_list|()
decl_stmt|;
comment|// Compute total map/reduce slots
comment|// In the future we can precompute this if the Scheduler becomes a
comment|// listener of tracker join/leave events.
name|int
name|totalMapSlots
init|=
name|getTotalSlots
argument_list|(
name|TaskType
operator|.
name|MAP
argument_list|,
name|clusterStatus
argument_list|)
decl_stmt|;
name|int
name|totalReduceSlots
init|=
name|getTotalSlots
argument_list|(
name|TaskType
operator|.
name|REDUCE
argument_list|,
name|clusterStatus
argument_list|)
decl_stmt|;
name|eventLog
operator|.
name|log
argument_list|(
literal|"RUNNABLE_TASKS"
argument_list|,
name|runnableMaps
argument_list|,
name|runningMaps
argument_list|,
name|runnableReduces
argument_list|,
name|runningReduces
argument_list|)
expr_stmt|;
comment|// Update time waited for local maps for jobs skipped on last heartbeat
name|updateLocalityWaitTimes
argument_list|(
name|currentTime
argument_list|)
expr_stmt|;
name|TaskTrackerStatus
name|tts
init|=
name|tracker
operator|.
name|getStatus
argument_list|()
decl_stmt|;
name|int
name|mapsAssigned
init|=
literal|0
decl_stmt|;
comment|// loop counter for map in the below while loop
name|int
name|reducesAssigned
init|=
literal|0
decl_stmt|;
comment|// loop counter for reduce in the below while
name|int
name|mapCapacity
init|=
name|maxTasksToAssign
argument_list|(
name|TaskType
operator|.
name|MAP
argument_list|,
name|tts
argument_list|)
decl_stmt|;
name|int
name|reduceCapacity
init|=
name|maxTasksToAssign
argument_list|(
name|TaskType
operator|.
name|REDUCE
argument_list|,
name|tts
argument_list|)
decl_stmt|;
name|boolean
name|mapRejected
init|=
literal|false
decl_stmt|;
comment|// flag used for ending the loop
name|boolean
name|reduceRejected
init|=
literal|false
decl_stmt|;
comment|// flag used for ending the loop
comment|// Keep track of which jobs were visited for map tasks and which had tasks
comment|// launched, so that we can later mark skipped jobs for delay scheduling
name|Set
argument_list|<
name|JobInProgress
argument_list|>
name|visitedForMap
init|=
operator|new
name|HashSet
argument_list|<
name|JobInProgress
argument_list|>
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|JobInProgress
argument_list|>
name|visitedForReduce
init|=
operator|new
name|HashSet
argument_list|<
name|JobInProgress
argument_list|>
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|JobInProgress
argument_list|>
name|launchedMap
init|=
operator|new
name|HashSet
argument_list|<
name|JobInProgress
argument_list|>
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|Task
argument_list|>
name|tasks
init|=
operator|new
name|ArrayList
argument_list|<
name|Task
argument_list|>
argument_list|()
decl_stmt|;
comment|// Scan jobs to assign tasks until neither maps nor reduces can be assigned
while|while
condition|(
literal|true
condition|)
block|{
comment|// Computing the ending conditions for the loop
comment|// Reject a task type if one of the following condition happens
comment|// 1. number of assigned task reaches per heatbeat limit
comment|// 2. number of running tasks reaches runnable tasks
comment|// 3. task is rejected by the LoadManager.canAssign
if|if
condition|(
operator|!
name|mapRejected
condition|)
block|{
if|if
condition|(
name|mapsAssigned
operator|==
name|mapCapacity
operator|||
name|runningMaps
operator|==
name|runnableMaps
operator|||
operator|!
name|loadMgr
operator|.
name|canAssignMap
argument_list|(
name|tts
argument_list|,
name|runnableMaps
argument_list|,
name|totalMapSlots
argument_list|)
condition|)
block|{
name|eventLog
operator|.
name|log
argument_list|(
literal|"INFO"
argument_list|,
literal|"Can't assign another MAP to "
operator|+
name|trackerName
argument_list|)
expr_stmt|;
name|mapRejected
operator|=
literal|true
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|reduceRejected
condition|)
block|{
if|if
condition|(
name|reducesAssigned
operator|==
name|reduceCapacity
operator|||
name|runningReduces
operator|==
name|runnableReduces
operator|||
operator|!
name|loadMgr
operator|.
name|canAssignReduce
argument_list|(
name|tts
argument_list|,
name|runnableReduces
argument_list|,
name|totalReduceSlots
argument_list|)
condition|)
block|{
name|eventLog
operator|.
name|log
argument_list|(
literal|"INFO"
argument_list|,
literal|"Can't assign another REDUCE to "
operator|+
name|trackerName
argument_list|)
expr_stmt|;
name|reduceRejected
operator|=
literal|true
expr_stmt|;
block|}
block|}
comment|// Exit while (true) loop if
comment|// 1. neither maps nor reduces can be assigned
comment|// 2. assignMultiple is off and we already assigned one task
if|if
condition|(
name|mapRejected
operator|&&
name|reduceRejected
operator|||
operator|!
name|assignMultiple
operator|&&
name|tasks
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
break|break;
comment|// This is the only exit of the while (true) loop
block|}
comment|// Determine which task type to assign this time
comment|// First try choosing a task type which is not rejected
name|TaskType
name|taskType
decl_stmt|;
if|if
condition|(
name|mapRejected
condition|)
block|{
name|taskType
operator|=
name|TaskType
operator|.
name|REDUCE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|reduceRejected
condition|)
block|{
name|taskType
operator|=
name|TaskType
operator|.
name|MAP
expr_stmt|;
block|}
else|else
block|{
comment|// If both types are available, choose the task type with fewer running
comment|// tasks on the task tracker to prevent that task type from starving
if|if
condition|(
name|tts
operator|.
name|countMapTasks
argument_list|()
operator|<=
name|tts
operator|.
name|countReduceTasks
argument_list|()
condition|)
block|{
name|taskType
operator|=
name|TaskType
operator|.
name|MAP
expr_stmt|;
block|}
else|else
block|{
name|taskType
operator|=
name|TaskType
operator|.
name|REDUCE
expr_stmt|;
block|}
block|}
comment|// Get the map or reduce schedulables and sort them by fair sharing
name|List
argument_list|<
name|PoolSchedulable
argument_list|>
name|scheds
init|=
name|getPoolSchedulables
argument_list|(
name|taskType
argument_list|)
decl_stmt|;
name|Collections
operator|.
name|sort
argument_list|(
name|scheds
argument_list|,
operator|new
name|SchedulingAlgorithms
operator|.
name|FairShareComparator
argument_list|()
argument_list|)
expr_stmt|;
name|boolean
name|foundTask
init|=
literal|false
decl_stmt|;
for|for
control|(
name|Schedulable
name|sched
range|:
name|scheds
control|)
block|{
comment|// This loop will assign only one task
name|eventLog
operator|.
name|log
argument_list|(
literal|"INFO"
argument_list|,
literal|"Checking for "
operator|+
name|taskType
operator|+
literal|" task in "
operator|+
name|sched
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|Task
name|task
init|=
name|taskType
operator|==
name|TaskType
operator|.
name|MAP
condition|?
name|sched
operator|.
name|assignTask
argument_list|(
name|tts
argument_list|,
name|currentTime
argument_list|,
name|visitedForMap
argument_list|)
else|:
name|sched
operator|.
name|assignTask
argument_list|(
name|tts
argument_list|,
name|currentTime
argument_list|,
name|visitedForReduce
argument_list|)
decl_stmt|;
if|if
condition|(
name|task
operator|!=
literal|null
condition|)
block|{
name|foundTask
operator|=
literal|true
expr_stmt|;
name|JobInProgress
name|job
init|=
name|taskTrackerManager
operator|.
name|getJob
argument_list|(
name|task
operator|.
name|getJobID
argument_list|()
argument_list|)
decl_stmt|;
name|eventLog
operator|.
name|log
argument_list|(
literal|"ASSIGN"
argument_list|,
name|trackerName
argument_list|,
name|taskType
argument_list|,
name|job
operator|.
name|getJobID
argument_list|()
argument_list|,
name|task
operator|.
name|getTaskID
argument_list|()
argument_list|)
expr_stmt|;
comment|// Update running task counts, and the job's locality level
if|if
condition|(
name|taskType
operator|==
name|TaskType
operator|.
name|MAP
condition|)
block|{
name|launchedMap
operator|.
name|add
argument_list|(
name|job
argument_list|)
expr_stmt|;
name|mapsAssigned
operator|++
expr_stmt|;
name|runningMaps
operator|++
expr_stmt|;
name|updateLastMapLocalityLevel
argument_list|(
name|job
argument_list|,
name|task
argument_list|,
name|tts
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|reducesAssigned
operator|++
expr_stmt|;
name|runningReduces
operator|++
expr_stmt|;
block|}
comment|// Add task to the list of assignments
name|tasks
operator|.
name|add
argument_list|(
name|task
argument_list|)
expr_stmt|;
break|break;
comment|// This break makes this loop assign only one task
block|}
comment|// end if(task != null)
block|}
comment|// end for(Schedulable sched: scheds)
comment|// Reject the task type if we cannot find a task
if|if
condition|(
operator|!
name|foundTask
condition|)
block|{
if|if
condition|(
name|taskType
operator|==
name|TaskType
operator|.
name|MAP
condition|)
block|{
name|mapRejected
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|reduceRejected
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
comment|// end while (true)
comment|// Mark any jobs that were visited for map tasks but did not launch a task
comment|// as skipped on this heartbeat
for|for
control|(
name|JobInProgress
name|job
range|:
name|visitedForMap
control|)
block|{
if|if
condition|(
operator|!
name|launchedMap
operator|.
name|contains
argument_list|(
name|job
argument_list|)
condition|)
block|{
name|infos
operator|.
name|get
argument_list|(
name|job
argument_list|)
operator|.
name|skippedAtLastHeartbeat
operator|=
literal|true
expr_stmt|;
block|}
block|}
comment|// If no tasks were found, return null
return|return
name|tasks
operator|.
name|isEmpty
argument_list|()
condition|?
literal|null
else|:
name|tasks
return|;
block|}
comment|/**    * Get maximum number of tasks to assign on a TaskTracker on a heartbeat.    * The scheduler may launch fewer than this many tasks if the LoadManager    * says not to launch more, but it will never launch more than this number.    */
DECL|method|maxTasksToAssign (TaskType type, TaskTrackerStatus tts)
specifier|private
name|int
name|maxTasksToAssign
parameter_list|(
name|TaskType
name|type
parameter_list|,
name|TaskTrackerStatus
name|tts
parameter_list|)
block|{
if|if
condition|(
operator|!
name|assignMultiple
condition|)
return|return
literal|1
return|;
name|int
name|cap
init|=
operator|(
name|type
operator|==
name|TaskType
operator|.
name|MAP
operator|)
condition|?
name|mapAssignCap
else|:
name|reduceAssignCap
decl_stmt|;
if|if
condition|(
name|cap
operator|==
operator|-
literal|1
condition|)
comment|// Infinite cap; use the TaskTracker's slot count
return|return
operator|(
name|type
operator|==
name|TaskType
operator|.
name|MAP
operator|)
condition|?
name|tts
operator|.
name|getAvailableMapSlots
argument_list|()
else|:
name|tts
operator|.
name|getAvailableReduceSlots
argument_list|()
return|;
else|else
return|return
name|cap
return|;
block|}
comment|/**    * Update locality wait times for jobs that were skipped at last heartbeat.    */
DECL|method|updateLocalityWaitTimes (long currentTime)
specifier|private
name|void
name|updateLocalityWaitTimes
parameter_list|(
name|long
name|currentTime
parameter_list|)
block|{
name|long
name|timeSinceLastHeartbeat
init|=
operator|(
name|lastHeartbeatTime
operator|==
literal|0
condition|?
literal|0
else|:
name|currentTime
operator|-
name|lastHeartbeatTime
operator|)
decl_stmt|;
name|lastHeartbeatTime
operator|=
name|currentTime
expr_stmt|;
for|for
control|(
name|JobInfo
name|info
range|:
name|infos
operator|.
name|values
argument_list|()
control|)
block|{
if|if
condition|(
name|info
operator|.
name|skippedAtLastHeartbeat
condition|)
block|{
name|info
operator|.
name|timeWaitedForLocalMap
operator|+=
name|timeSinceLastHeartbeat
expr_stmt|;
name|info
operator|.
name|skippedAtLastHeartbeat
operator|=
literal|false
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Update a job's locality level and locality wait variables given that that     * it has just launched a map task on a given task tracker.    */
DECL|method|updateLastMapLocalityLevel (JobInProgress job, Task mapTaskLaunched, TaskTrackerStatus tracker)
specifier|private
name|void
name|updateLastMapLocalityLevel
parameter_list|(
name|JobInProgress
name|job
parameter_list|,
name|Task
name|mapTaskLaunched
parameter_list|,
name|TaskTrackerStatus
name|tracker
parameter_list|)
block|{
name|JobInfo
name|info
init|=
name|infos
operator|.
name|get
argument_list|(
name|job
argument_list|)
decl_stmt|;
name|LocalityLevel
name|localityLevel
init|=
name|LocalityLevel
operator|.
name|fromTask
argument_list|(
name|job
argument_list|,
name|mapTaskLaunched
argument_list|,
name|tracker
argument_list|)
decl_stmt|;
name|info
operator|.
name|lastMapLocalityLevel
operator|=
name|localityLevel
expr_stmt|;
name|info
operator|.
name|timeWaitedForLocalMap
operator|=
literal|0
expr_stmt|;
name|eventLog
operator|.
name|log
argument_list|(
literal|"ASSIGNED_LOC_LEVEL"
argument_list|,
name|job
operator|.
name|getJobID
argument_list|()
argument_list|,
name|localityLevel
argument_list|)
expr_stmt|;
block|}
comment|/**    * Get the maximum locality level at which a given job is allowed to    * launch tasks, based on how long it has been waiting for local tasks.    * This is used to implement the "delay scheduling" feature of the Fair    * Scheduler for optimizing data locality.    * If the job has no locality information (e.g. it does not use HDFS), this     * method returns LocalityLevel.ANY, allowing tasks at any level.    * Otherwise, the job can only launch tasks at its current locality level    * or lower, unless it has waited at least nodeLocalityDelay or    * rackLocalityDelay milliseconds depends on the current level. If it    * has waited (nodeLocalityDelay + rackLocalityDelay) milliseconds,    * it can go to any level.    */
DECL|method|getAllowedLocalityLevel (JobInProgress job, long currentTime)
specifier|protected
name|LocalityLevel
name|getAllowedLocalityLevel
parameter_list|(
name|JobInProgress
name|job
parameter_list|,
name|long
name|currentTime
parameter_list|)
block|{
name|JobInfo
name|info
init|=
name|infos
operator|.
name|get
argument_list|(
name|job
argument_list|)
decl_stmt|;
if|if
condition|(
name|info
operator|==
literal|null
condition|)
block|{
comment|// Job not in infos (shouldn't happen)
name|LOG
operator|.
name|error
argument_list|(
literal|"getAllowedLocalityLevel called on job "
operator|+
name|job
operator|+
literal|", which does not have a JobInfo in infos"
argument_list|)
expr_stmt|;
return|return
name|LocalityLevel
operator|.
name|ANY
return|;
block|}
if|if
condition|(
name|job
operator|.
name|nonLocalMaps
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
comment|// Job doesn't have locality information
return|return
name|LocalityLevel
operator|.
name|ANY
return|;
block|}
comment|// Don't wait for locality if the job's pool is starving for maps
name|Pool
name|pool
init|=
name|poolMgr
operator|.
name|getPool
argument_list|(
name|job
argument_list|)
decl_stmt|;
name|PoolSchedulable
name|sched
init|=
name|pool
operator|.
name|getMapSchedulable
argument_list|()
decl_stmt|;
name|long
name|minShareTimeout
init|=
name|poolMgr
operator|.
name|getMinSharePreemptionTimeout
argument_list|(
name|pool
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
name|long
name|fairShareTimeout
init|=
name|poolMgr
operator|.
name|getFairSharePreemptionTimeout
argument_list|()
decl_stmt|;
if|if
condition|(
name|currentTime
operator|-
name|sched
operator|.
name|getLastTimeAtMinShare
argument_list|()
operator|>
name|minShareTimeout
operator|||
name|currentTime
operator|-
name|sched
operator|.
name|getLastTimeAtHalfFairShare
argument_list|()
operator|>
name|fairShareTimeout
condition|)
block|{
name|eventLog
operator|.
name|log
argument_list|(
literal|"INFO"
argument_list|,
literal|"No delay scheduling for "
operator|+
name|job
operator|.
name|getJobID
argument_list|()
operator|+
literal|" because it is being starved"
argument_list|)
expr_stmt|;
return|return
name|LocalityLevel
operator|.
name|ANY
return|;
block|}
comment|// In the common case, compute locality level based on time waited
switch|switch
condition|(
name|info
operator|.
name|lastMapLocalityLevel
condition|)
block|{
case|case
name|NODE
case|:
comment|// Last task launched was node-local
if|if
condition|(
name|info
operator|.
name|timeWaitedForLocalMap
operator|>=
name|nodeLocalityDelay
operator|+
name|rackLocalityDelay
condition|)
return|return
name|LocalityLevel
operator|.
name|ANY
return|;
elseif|else
if|if
condition|(
name|info
operator|.
name|timeWaitedForLocalMap
operator|>=
name|nodeLocalityDelay
condition|)
return|return
name|LocalityLevel
operator|.
name|RACK
return|;
else|else
return|return
name|LocalityLevel
operator|.
name|NODE
return|;
case|case
name|RACK
case|:
comment|// Last task launched was rack-local
if|if
condition|(
name|info
operator|.
name|timeWaitedForLocalMap
operator|>=
name|rackLocalityDelay
condition|)
return|return
name|LocalityLevel
operator|.
name|ANY
return|;
else|else
return|return
name|LocalityLevel
operator|.
name|RACK
return|;
default|default:
comment|// Last task was non-local; can launch anywhere
return|return
name|LocalityLevel
operator|.
name|ANY
return|;
block|}
block|}
comment|/**    * Recompute the internal variables used by the scheduler - per-job weights,    * fair shares, deficits, minimum slot allocations, and numbers of running    * and needed tasks of each type.     */
DECL|method|update ()
specifier|protected
name|void
name|update
parameter_list|()
block|{
comment|// Making more granular locking so that clusterStatus can be fetched
comment|// from Jobtracker without locking the scheduler.
name|ClusterStatus
name|clusterStatus
init|=
name|taskTrackerManager
operator|.
name|getClusterStatus
argument_list|()
decl_stmt|;
comment|// Recompute locality delay from JobTracker heartbeat interval if enabled.
comment|// This will also lock the JT, so do it outside of a fair scheduler lock.
if|if
condition|(
name|autoComputeLocalityDelay
condition|)
block|{
name|JobTracker
name|jobTracker
init|=
operator|(
name|JobTracker
operator|)
name|taskTrackerManager
decl_stmt|;
name|nodeLocalityDelay
operator|=
name|Math
operator|.
name|min
argument_list|(
name|MAX_AUTOCOMPUTED_LOCALITY_DELAY
argument_list|,
call|(
name|long
call|)
argument_list|(
literal|1.5
operator|*
name|jobTracker
operator|.
name|getNextHeartbeatInterval
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|rackLocalityDelay
operator|=
name|nodeLocalityDelay
expr_stmt|;
block|}
comment|// Got clusterStatus hence acquiring scheduler lock now.
synchronized|synchronized
init|(
name|this
init|)
block|{
comment|// Reload allocations file if it hasn't been loaded in a while
name|poolMgr
operator|.
name|reloadAllocsIfNecessary
argument_list|()
expr_stmt|;
comment|// Remove any jobs that have stopped running
name|List
argument_list|<
name|JobInProgress
argument_list|>
name|toRemove
init|=
operator|new
name|ArrayList
argument_list|<
name|JobInProgress
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|JobInProgress
name|job
range|:
name|infos
operator|.
name|keySet
argument_list|()
control|)
block|{
name|int
name|runState
init|=
name|job
operator|.
name|getStatus
argument_list|()
operator|.
name|getRunState
argument_list|()
decl_stmt|;
if|if
condition|(
name|runState
operator|==
name|JobStatus
operator|.
name|SUCCEEDED
operator|||
name|runState
operator|==
name|JobStatus
operator|.
name|FAILED
operator|||
name|runState
operator|==
name|JobStatus
operator|.
name|KILLED
condition|)
block|{
name|toRemove
operator|.
name|add
argument_list|(
name|job
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|JobInProgress
name|job
range|:
name|toRemove
control|)
block|{
name|infos
operator|.
name|remove
argument_list|(
name|job
argument_list|)
expr_stmt|;
name|poolMgr
operator|.
name|removeJob
argument_list|(
name|job
argument_list|)
expr_stmt|;
block|}
name|updateRunnability
argument_list|()
expr_stmt|;
comment|// Set job runnability based on user/pool limits
comment|// Update demands of jobs and pools
for|for
control|(
name|Pool
name|pool
range|:
name|poolMgr
operator|.
name|getPools
argument_list|()
control|)
block|{
name|pool
operator|.
name|getMapSchedulable
argument_list|()
operator|.
name|updateDemand
argument_list|()
expr_stmt|;
name|pool
operator|.
name|getReduceSchedulable
argument_list|()
operator|.
name|updateDemand
argument_list|()
expr_stmt|;
block|}
comment|// Compute fair shares based on updated demands
name|List
argument_list|<
name|PoolSchedulable
argument_list|>
name|mapScheds
init|=
name|getPoolSchedulables
argument_list|(
name|TaskType
operator|.
name|MAP
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|PoolSchedulable
argument_list|>
name|reduceScheds
init|=
name|getPoolSchedulables
argument_list|(
name|TaskType
operator|.
name|REDUCE
argument_list|)
decl_stmt|;
name|SchedulingAlgorithms
operator|.
name|computeFairShares
argument_list|(
name|mapScheds
argument_list|,
name|clusterStatus
operator|.
name|getMaxMapTasks
argument_list|()
argument_list|)
expr_stmt|;
name|SchedulingAlgorithms
operator|.
name|computeFairShares
argument_list|(
name|reduceScheds
argument_list|,
name|clusterStatus
operator|.
name|getMaxReduceTasks
argument_list|()
argument_list|)
expr_stmt|;
comment|// Use the computed shares to assign shares within each pool
for|for
control|(
name|Pool
name|pool
range|:
name|poolMgr
operator|.
name|getPools
argument_list|()
control|)
block|{
name|pool
operator|.
name|getMapSchedulable
argument_list|()
operator|.
name|redistributeShare
argument_list|()
expr_stmt|;
name|pool
operator|.
name|getReduceSchedulable
argument_list|()
operator|.
name|redistributeShare
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|preemptionEnabled
condition|)
name|updatePreemptionVariables
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|getPoolSchedulables (TaskType type)
specifier|public
name|List
argument_list|<
name|PoolSchedulable
argument_list|>
name|getPoolSchedulables
parameter_list|(
name|TaskType
name|type
parameter_list|)
block|{
name|List
argument_list|<
name|PoolSchedulable
argument_list|>
name|scheds
init|=
operator|new
name|ArrayList
argument_list|<
name|PoolSchedulable
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Pool
name|pool
range|:
name|poolMgr
operator|.
name|getPools
argument_list|()
control|)
block|{
name|scheds
operator|.
name|add
argument_list|(
name|pool
operator|.
name|getSchedulable
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|scheds
return|;
block|}
DECL|method|updateRunnability ()
specifier|private
name|void
name|updateRunnability
parameter_list|()
block|{
comment|// Start by marking everything as not runnable
for|for
control|(
name|JobInfo
name|info
range|:
name|infos
operator|.
name|values
argument_list|()
control|)
block|{
name|info
operator|.
name|runnable
operator|=
literal|false
expr_stmt|;
block|}
comment|// Create a list of sorted jobs in order of start time and priority
name|List
argument_list|<
name|JobInProgress
argument_list|>
name|jobs
init|=
operator|new
name|ArrayList
argument_list|<
name|JobInProgress
argument_list|>
argument_list|(
name|infos
operator|.
name|keySet
argument_list|()
argument_list|)
decl_stmt|;
name|Collections
operator|.
name|sort
argument_list|(
name|jobs
argument_list|,
operator|new
name|FifoJobComparator
argument_list|()
argument_list|)
expr_stmt|;
comment|// Mark jobs as runnable in order of start time and priority, until
comment|// user or pool limits have been reached.
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|userJobs
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|poolJobs
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|JobInProgress
name|job
range|:
name|jobs
control|)
block|{
name|String
name|user
init|=
name|job
operator|.
name|getJobConf
argument_list|()
operator|.
name|getUser
argument_list|()
decl_stmt|;
name|String
name|pool
init|=
name|poolMgr
operator|.
name|getPoolName
argument_list|(
name|job
argument_list|)
decl_stmt|;
name|int
name|userCount
init|=
name|userJobs
operator|.
name|containsKey
argument_list|(
name|user
argument_list|)
condition|?
name|userJobs
operator|.
name|get
argument_list|(
name|user
argument_list|)
else|:
literal|0
decl_stmt|;
name|int
name|poolCount
init|=
name|poolJobs
operator|.
name|containsKey
argument_list|(
name|pool
argument_list|)
condition|?
name|poolJobs
operator|.
name|get
argument_list|(
name|pool
argument_list|)
else|:
literal|0
decl_stmt|;
if|if
condition|(
name|userCount
operator|<
name|poolMgr
operator|.
name|getUserMaxJobs
argument_list|(
name|user
argument_list|)
operator|&&
name|poolCount
operator|<
name|poolMgr
operator|.
name|getPoolMaxJobs
argument_list|(
name|pool
argument_list|)
condition|)
block|{
if|if
condition|(
name|job
operator|.
name|getStatus
argument_list|()
operator|.
name|getRunState
argument_list|()
operator|==
name|JobStatus
operator|.
name|RUNNING
operator|||
name|job
operator|.
name|getStatus
argument_list|()
operator|.
name|getRunState
argument_list|()
operator|==
name|JobStatus
operator|.
name|PREP
condition|)
block|{
name|userJobs
operator|.
name|put
argument_list|(
name|user
argument_list|,
name|userCount
operator|+
literal|1
argument_list|)
expr_stmt|;
name|poolJobs
operator|.
name|put
argument_list|(
name|pool
argument_list|,
name|poolCount
operator|+
literal|1
argument_list|)
expr_stmt|;
name|JobInfo
name|jobInfo
init|=
name|infos
operator|.
name|get
argument_list|(
name|job
argument_list|)
decl_stmt|;
if|if
condition|(
name|job
operator|.
name|getStatus
argument_list|()
operator|.
name|getRunState
argument_list|()
operator|==
name|JobStatus
operator|.
name|RUNNING
condition|)
block|{
name|jobInfo
operator|.
name|runnable
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
comment|// The job is in the PREP state. Give it to the job initializer
comment|// for initialization if we have not already done it.
if|if
condition|(
name|jobInfo
operator|.
name|needsInitializing
condition|)
block|{
name|jobInfo
operator|.
name|needsInitializing
operator|=
literal|false
expr_stmt|;
name|jobInitializer
operator|.
name|initJob
argument_list|(
name|jobInfo
argument_list|,
name|job
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
DECL|method|getJobWeight (JobInProgress job, TaskType taskType)
specifier|public
name|double
name|getJobWeight
parameter_list|(
name|JobInProgress
name|job
parameter_list|,
name|TaskType
name|taskType
parameter_list|)
block|{
if|if
condition|(
operator|!
name|isRunnable
argument_list|(
name|job
argument_list|)
condition|)
block|{
comment|// Job won't launch tasks, but don't return 0 to avoid division errors
return|return
literal|1.0
return|;
block|}
else|else
block|{
name|double
name|weight
init|=
literal|1.0
decl_stmt|;
if|if
condition|(
name|sizeBasedWeight
condition|)
block|{
comment|// Set weight based on runnable tasks
name|JobInfo
name|info
init|=
name|infos
operator|.
name|get
argument_list|(
name|job
argument_list|)
decl_stmt|;
name|int
name|runnableTasks
init|=
operator|(
name|taskType
operator|==
name|TaskType
operator|.
name|MAP
operator|)
condition|?
name|info
operator|.
name|mapSchedulable
operator|.
name|getDemand
argument_list|()
else|:
name|info
operator|.
name|reduceSchedulable
operator|.
name|getDemand
argument_list|()
decl_stmt|;
name|weight
operator|=
name|Math
operator|.
name|log1p
argument_list|(
name|runnableTasks
argument_list|)
operator|/
name|Math
operator|.
name|log
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
name|weight
operator|*=
name|getPriorityFactor
argument_list|(
name|job
operator|.
name|getPriority
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|weightAdjuster
operator|!=
literal|null
condition|)
block|{
comment|// Run weight through the user-supplied weightAdjuster
name|weight
operator|=
name|weightAdjuster
operator|.
name|adjustWeight
argument_list|(
name|job
argument_list|,
name|taskType
argument_list|,
name|weight
argument_list|)
expr_stmt|;
block|}
return|return
name|weight
return|;
block|}
block|}
DECL|method|getPriorityFactor (JobPriority priority)
specifier|private
name|double
name|getPriorityFactor
parameter_list|(
name|JobPriority
name|priority
parameter_list|)
block|{
switch|switch
condition|(
name|priority
condition|)
block|{
case|case
name|VERY_HIGH
case|:
return|return
literal|4.0
return|;
case|case
name|HIGH
case|:
return|return
literal|2.0
return|;
case|case
name|NORMAL
case|:
return|return
literal|1.0
return|;
case|case
name|LOW
case|:
return|return
literal|0.5
return|;
default|default:
return|return
literal|0.25
return|;
comment|// priority = VERY_LOW
block|}
block|}
DECL|method|getPoolManager ()
specifier|public
name|PoolManager
name|getPoolManager
parameter_list|()
block|{
return|return
name|poolMgr
return|;
block|}
DECL|method|getTotalSlots (TaskType type, ClusterStatus clusterStatus)
specifier|private
name|int
name|getTotalSlots
parameter_list|(
name|TaskType
name|type
parameter_list|,
name|ClusterStatus
name|clusterStatus
parameter_list|)
block|{
return|return
operator|(
name|type
operator|==
name|TaskType
operator|.
name|MAP
condition|?
name|clusterStatus
operator|.
name|getMaxMapTasks
argument_list|()
else|:
name|clusterStatus
operator|.
name|getMaxReduceTasks
argument_list|()
operator|)
return|;
block|}
comment|/**    * Update the preemption fields for all PoolScheduables, i.e. the times since    * each pool last was at its guaranteed share and at> 1/2 of its fair share    * for each type of task.    */
DECL|method|updatePreemptionVariables ()
specifier|private
name|void
name|updatePreemptionVariables
parameter_list|()
block|{
name|long
name|now
init|=
name|clock
operator|.
name|getTime
argument_list|()
decl_stmt|;
for|for
control|(
name|TaskType
name|type
range|:
name|MAP_AND_REDUCE
control|)
block|{
for|for
control|(
name|PoolSchedulable
name|sched
range|:
name|getPoolSchedulables
argument_list|(
name|type
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|isStarvedForMinShare
argument_list|(
name|sched
argument_list|)
condition|)
block|{
name|sched
operator|.
name|setLastTimeAtMinShare
argument_list|(
name|now
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|isStarvedForFairShare
argument_list|(
name|sched
argument_list|)
condition|)
block|{
name|sched
operator|.
name|setLastTimeAtHalfFairShare
argument_list|(
name|now
argument_list|)
expr_stmt|;
block|}
name|eventLog
operator|.
name|log
argument_list|(
literal|"PREEMPT_VARS"
argument_list|,
name|sched
operator|.
name|getName
argument_list|()
argument_list|,
name|type
argument_list|,
name|now
operator|-
name|sched
operator|.
name|getLastTimeAtMinShare
argument_list|()
argument_list|,
name|now
operator|-
name|sched
operator|.
name|getLastTimeAtHalfFairShare
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Is a pool below its min share for the given task type?    */
DECL|method|isStarvedForMinShare (PoolSchedulable sched)
name|boolean
name|isStarvedForMinShare
parameter_list|(
name|PoolSchedulable
name|sched
parameter_list|)
block|{
name|int
name|desiredShare
init|=
name|Math
operator|.
name|min
argument_list|(
name|sched
operator|.
name|getMinShare
argument_list|()
argument_list|,
name|sched
operator|.
name|getDemand
argument_list|()
argument_list|)
decl_stmt|;
return|return
operator|(
name|sched
operator|.
name|getRunningTasks
argument_list|()
operator|<
name|desiredShare
operator|)
return|;
block|}
comment|/**    * Is a pool being starved for fair share for the given task type?    * This is defined as being below half its fair share.    */
DECL|method|isStarvedForFairShare (PoolSchedulable sched)
name|boolean
name|isStarvedForFairShare
parameter_list|(
name|PoolSchedulable
name|sched
parameter_list|)
block|{
name|int
name|desiredFairShare
init|=
operator|(
name|int
operator|)
name|Math
operator|.
name|floor
argument_list|(
name|Math
operator|.
name|min
argument_list|(
name|sched
operator|.
name|getFairShare
argument_list|()
operator|/
literal|2
argument_list|,
name|sched
operator|.
name|getDemand
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
return|return
operator|(
name|sched
operator|.
name|getRunningTasks
argument_list|()
operator|<
name|desiredFairShare
operator|)
return|;
block|}
comment|/**    * Check for pools that need tasks preempted, either because they have been    * below their guaranteed share for minSharePreemptionTimeout or they    * have been below half their fair share for the fairSharePreemptionTimeout.    * If such pools exist, compute how many tasks of each type need to be    * preempted and then select the right ones using preemptTasks.    *     * This method computes and logs the number of tasks we want to preempt even    * if preemption is disabled, for debugging purposes.    */
DECL|method|preemptTasksIfNecessary ()
specifier|protected
name|void
name|preemptTasksIfNecessary
parameter_list|()
block|{
if|if
condition|(
operator|!
name|preemptionEnabled
condition|)
return|return;
name|long
name|curTime
init|=
name|clock
operator|.
name|getTime
argument_list|()
decl_stmt|;
if|if
condition|(
name|curTime
operator|-
name|lastPreemptCheckTime
operator|<
name|preemptionInterval
condition|)
return|return;
name|lastPreemptCheckTime
operator|=
name|curTime
expr_stmt|;
comment|// Acquire locks on both the JobTracker (task tracker manager) and this
comment|// because we might need to call some JobTracker methods (killTask).
synchronized|synchronized
init|(
name|taskTrackerManager
init|)
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
for|for
control|(
name|TaskType
name|type
range|:
name|MAP_AND_REDUCE
control|)
block|{
name|List
argument_list|<
name|PoolSchedulable
argument_list|>
name|scheds
init|=
name|getPoolSchedulables
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|int
name|tasksToPreempt
init|=
literal|0
decl_stmt|;
for|for
control|(
name|PoolSchedulable
name|sched
range|:
name|scheds
control|)
block|{
name|tasksToPreempt
operator|+=
name|tasksToPreempt
argument_list|(
name|sched
argument_list|,
name|curTime
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tasksToPreempt
operator|>
literal|0
condition|)
block|{
name|eventLog
operator|.
name|log
argument_list|(
literal|"SHOULD_PREEMPT"
argument_list|,
name|type
argument_list|,
name|tasksToPreempt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|onlyLogPreemption
condition|)
block|{
name|preemptTasks
argument_list|(
name|scheds
argument_list|,
name|tasksToPreempt
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
comment|/**    * Preempt a given number of tasks from a list of PoolSchedulables.     * The policy for this is to pick tasks from pools that are over their fair     * share, but make sure that no pool is placed below its fair share in the     * process. Furthermore, we want to minimize the amount of computation    * wasted by preemption, so out of the tasks in over-scheduled pools, we    * prefer to preempt tasks that started most recently.    */
DECL|method|preemptTasks (List<PoolSchedulable> scheds, int tasksToPreempt)
specifier|private
name|void
name|preemptTasks
parameter_list|(
name|List
argument_list|<
name|PoolSchedulable
argument_list|>
name|scheds
parameter_list|,
name|int
name|tasksToPreempt
parameter_list|)
block|{
if|if
condition|(
name|scheds
operator|.
name|isEmpty
argument_list|()
operator|||
name|tasksToPreempt
operator|==
literal|0
condition|)
return|return;
name|TaskType
name|taskType
init|=
name|scheds
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getTaskType
argument_list|()
decl_stmt|;
comment|// Collect running tasks of our type from over-scheduled pools
name|List
argument_list|<
name|TaskStatus
argument_list|>
name|runningTasks
init|=
operator|new
name|ArrayList
argument_list|<
name|TaskStatus
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|PoolSchedulable
name|sched
range|:
name|scheds
control|)
block|{
if|if
condition|(
name|sched
operator|.
name|getRunningTasks
argument_list|()
operator|>
name|sched
operator|.
name|getFairShare
argument_list|()
condition|)
for|for
control|(
name|JobSchedulable
name|js
range|:
name|sched
operator|.
name|getJobSchedulables
argument_list|()
control|)
block|{
name|runningTasks
operator|.
name|addAll
argument_list|(
name|getRunningTasks
argument_list|(
name|js
operator|.
name|getJob
argument_list|()
argument_list|,
name|taskType
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Sort tasks into reverse order of start time
name|Collections
operator|.
name|sort
argument_list|(
name|runningTasks
argument_list|,
operator|new
name|Comparator
argument_list|<
name|TaskStatus
argument_list|>
argument_list|()
block|{
specifier|public
name|int
name|compare
parameter_list|(
name|TaskStatus
name|t1
parameter_list|,
name|TaskStatus
name|t2
parameter_list|)
block|{
if|if
condition|(
name|t1
operator|.
name|getStartTime
argument_list|()
operator|<
name|t2
operator|.
name|getStartTime
argument_list|()
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|t1
operator|.
name|getStartTime
argument_list|()
operator|==
name|t2
operator|.
name|getStartTime
argument_list|()
condition|)
return|return
literal|0
return|;
else|else
return|return
operator|-
literal|1
return|;
block|}
block|}
argument_list|)
expr_stmt|;
comment|// Maintain a count of tasks left in each pool; this is a bit
comment|// faster than calling runningTasks() on the pool repeatedly
comment|// because the latter must scan through jobs in the pool
name|HashMap
argument_list|<
name|Pool
argument_list|,
name|Integer
argument_list|>
name|tasksLeft
init|=
operator|new
name|HashMap
argument_list|<
name|Pool
argument_list|,
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Pool
name|p
range|:
name|poolMgr
operator|.
name|getPools
argument_list|()
control|)
block|{
name|tasksLeft
operator|.
name|put
argument_list|(
name|p
argument_list|,
name|p
operator|.
name|getSchedulable
argument_list|(
name|taskType
argument_list|)
operator|.
name|getRunningTasks
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Scan down the sorted list of task statuses until we've killed enough
comment|// tasks, making sure we don't kill too many from any pool
for|for
control|(
name|TaskStatus
name|status
range|:
name|runningTasks
control|)
block|{
name|JobID
name|jobID
init|=
name|status
operator|.
name|getTaskID
argument_list|()
operator|.
name|getJobID
argument_list|()
decl_stmt|;
name|JobInProgress
name|job
init|=
name|taskTrackerManager
operator|.
name|getJob
argument_list|(
name|jobID
argument_list|)
decl_stmt|;
name|Pool
name|pool
init|=
name|poolMgr
operator|.
name|getPool
argument_list|(
name|job
argument_list|)
decl_stmt|;
name|PoolSchedulable
name|sched
init|=
name|pool
operator|.
name|getSchedulable
argument_list|(
name|taskType
argument_list|)
decl_stmt|;
name|int
name|tasksLeftForPool
init|=
name|tasksLeft
operator|.
name|get
argument_list|(
name|pool
argument_list|)
decl_stmt|;
if|if
condition|(
name|tasksLeftForPool
operator|>
name|sched
operator|.
name|getFairShare
argument_list|()
condition|)
block|{
name|eventLog
operator|.
name|log
argument_list|(
literal|"PREEMPT"
argument_list|,
name|status
operator|.
name|getTaskID
argument_list|()
argument_list|,
name|status
operator|.
name|getTaskTracker
argument_list|()
argument_list|)
expr_stmt|;
try|try
block|{
name|taskTrackerManager
operator|.
name|killTask
argument_list|(
name|status
operator|.
name|getTaskID
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|tasksToPreempt
operator|--
expr_stmt|;
if|if
condition|(
name|tasksToPreempt
operator|==
literal|0
condition|)
break|break;
comment|// reduce tasks left for pool
name|tasksLeft
operator|.
name|put
argument_list|(
name|pool
argument_list|,
operator|--
name|tasksLeftForPool
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Failed to kill task "
operator|+
name|status
operator|.
name|getTaskID
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**    * Count how many tasks of a given type the pool needs to preempt, if any.    * If the pool has been below its min share for at least its preemption    * timeout, it should preempt the difference between its current share and    * this min share. If it has been below half its fair share for at least the    * fairSharePreemptionTimeout, it should preempt enough tasks to get up to    * its full fair share. If both conditions hold, we preempt the max of the    * two amounts (this shouldn't happen unless someone sets the timeouts to    * be identical for some reason).    */
DECL|method|tasksToPreempt (PoolSchedulable sched, long curTime)
specifier|protected
name|int
name|tasksToPreempt
parameter_list|(
name|PoolSchedulable
name|sched
parameter_list|,
name|long
name|curTime
parameter_list|)
block|{
name|String
name|pool
init|=
name|sched
operator|.
name|getName
argument_list|()
decl_stmt|;
name|long
name|minShareTimeout
init|=
name|poolMgr
operator|.
name|getMinSharePreemptionTimeout
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|long
name|fairShareTimeout
init|=
name|poolMgr
operator|.
name|getFairSharePreemptionTimeout
argument_list|()
decl_stmt|;
name|int
name|tasksDueToMinShare
init|=
literal|0
decl_stmt|;
name|int
name|tasksDueToFairShare
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|curTime
operator|-
name|sched
operator|.
name|getLastTimeAtMinShare
argument_list|()
operator|>
name|minShareTimeout
condition|)
block|{
name|int
name|target
init|=
name|Math
operator|.
name|min
argument_list|(
name|sched
operator|.
name|getMinShare
argument_list|()
argument_list|,
name|sched
operator|.
name|getDemand
argument_list|()
argument_list|)
decl_stmt|;
name|tasksDueToMinShare
operator|=
name|Math
operator|.
name|max
argument_list|(
literal|0
argument_list|,
name|target
operator|-
name|sched
operator|.
name|getRunningTasks
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|curTime
operator|-
name|sched
operator|.
name|getLastTimeAtHalfFairShare
argument_list|()
operator|>
name|fairShareTimeout
condition|)
block|{
name|int
name|target
init|=
operator|(
name|int
operator|)
name|Math
operator|.
name|min
argument_list|(
name|sched
operator|.
name|getFairShare
argument_list|()
argument_list|,
name|sched
operator|.
name|getDemand
argument_list|()
argument_list|)
decl_stmt|;
name|tasksDueToFairShare
operator|=
name|Math
operator|.
name|max
argument_list|(
literal|0
argument_list|,
name|target
operator|-
name|sched
operator|.
name|getRunningTasks
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|int
name|tasksToPreempt
init|=
name|Math
operator|.
name|max
argument_list|(
name|tasksDueToMinShare
argument_list|,
name|tasksDueToFairShare
argument_list|)
decl_stmt|;
if|if
condition|(
name|tasksToPreempt
operator|>
literal|0
condition|)
block|{
name|String
name|message
init|=
literal|"Should preempt "
operator|+
name|tasksToPreempt
operator|+
literal|" "
operator|+
name|sched
operator|.
name|getTaskType
argument_list|()
operator|+
literal|" tasks for pool "
operator|+
name|sched
operator|.
name|getName
argument_list|()
operator|+
literal|": tasksDueToMinShare = "
operator|+
name|tasksDueToMinShare
operator|+
literal|", tasksDueToFairShare = "
operator|+
name|tasksDueToFairShare
decl_stmt|;
name|eventLog
operator|.
name|log
argument_list|(
literal|"INFO"
argument_list|,
name|message
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|message
argument_list|)
expr_stmt|;
block|}
return|return
name|tasksToPreempt
return|;
block|}
DECL|method|getRunningTasks (JobInProgress job, TaskType type)
specifier|private
name|List
argument_list|<
name|TaskStatus
argument_list|>
name|getRunningTasks
parameter_list|(
name|JobInProgress
name|job
parameter_list|,
name|TaskType
name|type
parameter_list|)
block|{
comment|// Create a list of all running TaskInProgress'es in the job
name|Set
argument_list|<
name|TaskInProgress
argument_list|>
name|tips
init|=
operator|new
name|HashSet
argument_list|<
name|TaskInProgress
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|TaskType
operator|.
name|MAP
condition|)
block|{
comment|// Jobs may have both "non-local maps" which have a split with no locality
comment|// info (e.g. the input file is not in HDFS), and maps with locality info,
comment|// which are stored in the runningMapCache map from location to task list
name|tips
operator|.
name|addAll
argument_list|(
name|job
operator|.
name|nonLocalRunningMaps
argument_list|)
expr_stmt|;
for|for
control|(
name|Set
argument_list|<
name|TaskInProgress
argument_list|>
name|set
range|:
name|job
operator|.
name|runningMapCache
operator|.
name|values
argument_list|()
control|)
block|{
name|tips
operator|.
name|addAll
argument_list|(
name|set
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|tips
operator|.
name|addAll
argument_list|(
name|job
operator|.
name|runningReduces
argument_list|)
expr_stmt|;
block|}
comment|// Get the active TaskStatus'es for each TaskInProgress (there may be
comment|// more than one if the task has multiple copies active due to speculation)
name|List
argument_list|<
name|TaskStatus
argument_list|>
name|statuses
init|=
operator|new
name|ArrayList
argument_list|<
name|TaskStatus
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|TaskInProgress
name|tip
range|:
name|tips
control|)
block|{
for|for
control|(
name|TaskAttemptID
name|id
range|:
name|tip
operator|.
name|getActiveTasks
argument_list|()
operator|.
name|keySet
argument_list|()
control|)
block|{
name|TaskStatus
name|stat
init|=
name|tip
operator|.
name|getTaskStatus
argument_list|(
name|id
argument_list|)
decl_stmt|;
comment|// status is null when the task has been scheduled but not yet running
if|if
condition|(
name|stat
operator|!=
literal|null
condition|)
block|{
name|statuses
operator|.
name|add
argument_list|(
name|stat
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|statuses
return|;
block|}
DECL|method|isRunnable (JobInProgress job)
specifier|protected
name|boolean
name|isRunnable
parameter_list|(
name|JobInProgress
name|job
parameter_list|)
block|{
name|JobInfo
name|info
init|=
name|infos
operator|.
name|get
argument_list|(
name|job
argument_list|)
decl_stmt|;
if|if
condition|(
name|info
operator|==
literal|null
condition|)
return|return
literal|false
return|;
return|return
name|info
operator|.
name|runnable
return|;
block|}
annotation|@
name|Override
DECL|method|getJobs (String queueName)
specifier|public
specifier|synchronized
name|Collection
argument_list|<
name|JobInProgress
argument_list|>
name|getJobs
parameter_list|(
name|String
name|queueName
parameter_list|)
block|{
name|Pool
name|myJobPool
init|=
name|poolMgr
operator|.
name|getPool
argument_list|(
name|queueName
argument_list|)
decl_stmt|;
return|return
name|myJobPool
operator|.
name|getJobs
argument_list|()
return|;
block|}
DECL|method|dumpIfNecessary ()
specifier|protected
name|void
name|dumpIfNecessary
parameter_list|()
block|{
name|long
name|now
init|=
name|clock
operator|.
name|getTime
argument_list|()
decl_stmt|;
name|long
name|timeDelta
init|=
name|now
operator|-
name|lastDumpTime
decl_stmt|;
if|if
condition|(
name|timeDelta
operator|>
name|dumpInterval
operator|&&
name|eventLog
operator|.
name|isEnabled
argument_list|()
condition|)
block|{
name|dump
argument_list|()
expr_stmt|;
name|lastDumpTime
operator|=
name|now
expr_stmt|;
block|}
block|}
comment|/**    * Dump scheduler state to the fairscheduler log.    */
DECL|method|dump ()
specifier|private
specifier|synchronized
name|void
name|dump
parameter_list|()
block|{
synchronized|synchronized
init|(
name|eventLog
init|)
block|{
name|eventLog
operator|.
name|log
argument_list|(
literal|"BEGIN_DUMP"
argument_list|)
expr_stmt|;
comment|// List jobs in order of submit time
name|ArrayList
argument_list|<
name|JobInProgress
argument_list|>
name|jobs
init|=
operator|new
name|ArrayList
argument_list|<
name|JobInProgress
argument_list|>
argument_list|(
name|infos
operator|.
name|keySet
argument_list|()
argument_list|)
decl_stmt|;
name|Collections
operator|.
name|sort
argument_list|(
name|jobs
argument_list|,
operator|new
name|Comparator
argument_list|<
name|JobInProgress
argument_list|>
argument_list|()
block|{
specifier|public
name|int
name|compare
parameter_list|(
name|JobInProgress
name|j1
parameter_list|,
name|JobInProgress
name|j2
parameter_list|)
block|{
return|return
operator|(
name|int
operator|)
name|Math
operator|.
name|signum
argument_list|(
name|j1
operator|.
name|getStartTime
argument_list|()
operator|-
name|j2
operator|.
name|getStartTime
argument_list|()
argument_list|)
return|;
block|}
block|}
argument_list|)
expr_stmt|;
comment|// Dump info for each job
for|for
control|(
name|JobInProgress
name|job
range|:
name|jobs
control|)
block|{
name|JobProfile
name|profile
init|=
name|job
operator|.
name|getProfile
argument_list|()
decl_stmt|;
name|JobInfo
name|info
init|=
name|infos
operator|.
name|get
argument_list|(
name|job
argument_list|)
decl_stmt|;
name|Schedulable
name|ms
init|=
name|info
operator|.
name|mapSchedulable
decl_stmt|;
name|Schedulable
name|rs
init|=
name|info
operator|.
name|reduceSchedulable
decl_stmt|;
name|eventLog
operator|.
name|log
argument_list|(
literal|"JOB"
argument_list|,
name|profile
operator|.
name|getJobID
argument_list|()
argument_list|,
name|profile
operator|.
name|name
argument_list|,
name|profile
operator|.
name|user
argument_list|,
name|job
operator|.
name|getPriority
argument_list|()
argument_list|,
name|poolMgr
operator|.
name|getPoolName
argument_list|(
name|job
argument_list|)
argument_list|,
name|job
operator|.
name|numMapTasks
argument_list|,
name|ms
operator|.
name|getRunningTasks
argument_list|()
argument_list|,
name|ms
operator|.
name|getDemand
argument_list|()
argument_list|,
name|ms
operator|.
name|getFairShare
argument_list|()
argument_list|,
name|ms
operator|.
name|getWeight
argument_list|()
argument_list|,
name|job
operator|.
name|numReduceTasks
argument_list|,
name|rs
operator|.
name|getRunningTasks
argument_list|()
argument_list|,
name|rs
operator|.
name|getDemand
argument_list|()
argument_list|,
name|rs
operator|.
name|getFairShare
argument_list|()
argument_list|,
name|rs
operator|.
name|getWeight
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// List pools in alphabetical order
name|List
argument_list|<
name|Pool
argument_list|>
name|pools
init|=
operator|new
name|ArrayList
argument_list|<
name|Pool
argument_list|>
argument_list|(
name|poolMgr
operator|.
name|getPools
argument_list|()
argument_list|)
decl_stmt|;
name|Collections
operator|.
name|sort
argument_list|(
name|pools
argument_list|,
operator|new
name|Comparator
argument_list|<
name|Pool
argument_list|>
argument_list|()
block|{
specifier|public
name|int
name|compare
parameter_list|(
name|Pool
name|p1
parameter_list|,
name|Pool
name|p2
parameter_list|)
block|{
if|if
condition|(
name|p1
operator|.
name|isDefaultPool
argument_list|()
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|p2
operator|.
name|isDefaultPool
argument_list|()
condition|)
return|return
operator|-
literal|1
return|;
else|else
return|return
name|p1
operator|.
name|getName
argument_list|()
operator|.
name|compareTo
argument_list|(
name|p2
operator|.
name|getName
argument_list|()
argument_list|)
return|;
block|}
block|}
argument_list|)
expr_stmt|;
for|for
control|(
name|Pool
name|pool
range|:
name|pools
control|)
block|{
name|int
name|runningMaps
init|=
literal|0
decl_stmt|;
name|int
name|runningReduces
init|=
literal|0
decl_stmt|;
for|for
control|(
name|JobInProgress
name|job
range|:
name|pool
operator|.
name|getJobs
argument_list|()
control|)
block|{
name|JobInfo
name|info
init|=
name|infos
operator|.
name|get
argument_list|(
name|job
argument_list|)
decl_stmt|;
if|if
condition|(
name|info
operator|!=
literal|null
condition|)
block|{
comment|// TODO: Fix
comment|//runningMaps += info.runningMaps;
comment|//runningReduces += info.runningReduces;
block|}
block|}
name|String
name|name
init|=
name|pool
operator|.
name|getName
argument_list|()
decl_stmt|;
name|eventLog
operator|.
name|log
argument_list|(
literal|"POOL"
argument_list|,
name|name
argument_list|,
name|poolMgr
operator|.
name|getPoolWeight
argument_list|(
name|name
argument_list|)
argument_list|,
name|pool
operator|.
name|getJobs
argument_list|()
operator|.
name|size
argument_list|()
argument_list|,
name|poolMgr
operator|.
name|getAllocation
argument_list|(
name|name
argument_list|,
name|TaskType
operator|.
name|MAP
argument_list|)
argument_list|,
name|runningMaps
argument_list|,
name|poolMgr
operator|.
name|getAllocation
argument_list|(
name|name
argument_list|,
name|TaskType
operator|.
name|REDUCE
argument_list|)
argument_list|,
name|runningReduces
argument_list|)
expr_stmt|;
block|}
comment|// Dump info for each pool
name|eventLog
operator|.
name|log
argument_list|(
literal|"END_DUMP"
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|getClock ()
specifier|public
name|Clock
name|getClock
parameter_list|()
block|{
return|return
name|clock
return|;
block|}
DECL|method|getEventLog ()
specifier|public
name|FairSchedulerEventLog
name|getEventLog
parameter_list|()
block|{
return|return
name|eventLog
return|;
block|}
DECL|method|getJobInfo (JobInProgress job)
specifier|public
name|JobInfo
name|getJobInfo
parameter_list|(
name|JobInProgress
name|job
parameter_list|)
block|{
return|return
name|infos
operator|.
name|get
argument_list|(
name|job
argument_list|)
return|;
block|}
block|}
end_class

end_unit

