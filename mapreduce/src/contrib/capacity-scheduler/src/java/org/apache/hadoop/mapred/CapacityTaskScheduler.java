begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.mapred
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|AbstractQueue
operator|.
name|AbstractQueueComparator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|JobTracker
operator|.
name|IllegalStateException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|TaskType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|server
operator|.
name|jobtracker
operator|.
name|TaskTracker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
import|;
end_import

begin_comment
comment|/**  * A {@link TaskScheduler} that implements the requirements in HADOOP-3421  * and provides a HOD-less way to share large clusters. This scheduler   * provides the following features:   *  * support for queues, where a job is submitted to a queue.   *  * Queues are assigned a fraction of the capacity of the grid (their  *  'capacity') in the sense that a certain capacity of resources   *  will be at their disposal. All jobs submitted to the queues of an Org   *  will have access to the capacity to the Org.  *  * Free resources can be allocated to any queue beyond its   *  capacity.  *  * Queues optionally support job priorities (disabled by default).   *  * Within a queue, jobs with higher priority will have access to the   *  queue's resources before jobs with lower priority. However, once a job   *  is running, it will not be preempted for a higher priority job.  *  * In order to prevent one or more users from monopolizing its resources,   *  each queue enforces a limit on the percentage of resources allocated to a   *  user at any given time, if there is competition for them.  *    */
end_comment

begin_class
DECL|class|CapacityTaskScheduler
class|class
name|CapacityTaskScheduler
extends|extends
name|TaskScheduler
block|{
comment|/** quick way to get qsc object given a queue name */
DECL|field|queueInfoMap
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|QueueSchedulingContext
argument_list|>
name|queueInfoMap
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|QueueSchedulingContext
argument_list|>
argument_list|()
decl_stmt|;
comment|//Root level queue . It has all the
comment|//cluster capacity at its disposal.
comment|//Queues declared by users would
comment|//be children of this queue.
comment|//CS would have handle to root.
DECL|field|root
specifier|private
name|AbstractQueue
name|root
init|=
literal|null
decl_stmt|;
comment|/**    * This class captures scheduling information we want to display or log.    */
DECL|class|SchedulingDisplayInfo
specifier|private
specifier|static
class|class
name|SchedulingDisplayInfo
block|{
DECL|field|queueName
specifier|private
name|String
name|queueName
decl_stmt|;
DECL|field|scheduler
name|CapacityTaskScheduler
name|scheduler
decl_stmt|;
DECL|method|SchedulingDisplayInfo (String queueName, CapacityTaskScheduler scheduler)
name|SchedulingDisplayInfo
parameter_list|(
name|String
name|queueName
parameter_list|,
name|CapacityTaskScheduler
name|scheduler
parameter_list|)
block|{
name|this
operator|.
name|queueName
operator|=
name|queueName
expr_stmt|;
name|this
operator|.
name|scheduler
operator|=
name|scheduler
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
comment|// note that we do not call updateContextObjects() here for performance
comment|// reasons. This means that the data we print out may be slightly
comment|// stale. This data is updated whenever assignTasks() is called
comment|// If this doesn't happen, the data gets stale. If we see
comment|// this often, we may need to detect this situation and call
comment|// updateContextObjects(), or just call it each time.
return|return
name|scheduler
operator|.
name|getDisplayInfo
argument_list|(
name|queueName
argument_list|)
return|;
block|}
block|}
comment|// this class encapsulates the result of a task lookup
DECL|class|TaskLookupResult
specifier|private
specifier|static
class|class
name|TaskLookupResult
block|{
DECL|enum|LookUpStatus
specifier|static
enum|enum
name|LookUpStatus
block|{
DECL|enumConstant|TASK_FOUND
name|TASK_FOUND
block|,
DECL|enumConstant|NO_TASK_FOUND
name|NO_TASK_FOUND
block|,
DECL|enumConstant|TASK_FAILING_MEMORY_REQUIREMENT
name|TASK_FAILING_MEMORY_REQUIREMENT
block|,     }
comment|// constant TaskLookupResult objects. Should not be accessed directly.
DECL|field|NoTaskLookupResult
specifier|private
specifier|static
specifier|final
name|TaskLookupResult
name|NoTaskLookupResult
init|=
operator|new
name|TaskLookupResult
argument_list|(
literal|null
argument_list|,
name|TaskLookupResult
operator|.
name|LookUpStatus
operator|.
name|NO_TASK_FOUND
argument_list|)
decl_stmt|;
DECL|field|MemFailedLookupResult
specifier|private
specifier|static
specifier|final
name|TaskLookupResult
name|MemFailedLookupResult
init|=
operator|new
name|TaskLookupResult
argument_list|(
literal|null
argument_list|,
name|TaskLookupResult
operator|.
name|LookUpStatus
operator|.
name|TASK_FAILING_MEMORY_REQUIREMENT
argument_list|)
decl_stmt|;
DECL|field|lookUpStatus
specifier|private
name|LookUpStatus
name|lookUpStatus
decl_stmt|;
DECL|field|task
specifier|private
name|Task
name|task
decl_stmt|;
comment|// should not call this constructor directly. use static factory methods.
DECL|method|TaskLookupResult (Task t, LookUpStatus lUStatus)
specifier|private
name|TaskLookupResult
parameter_list|(
name|Task
name|t
parameter_list|,
name|LookUpStatus
name|lUStatus
parameter_list|)
block|{
name|this
operator|.
name|task
operator|=
name|t
expr_stmt|;
name|this
operator|.
name|lookUpStatus
operator|=
name|lUStatus
expr_stmt|;
block|}
DECL|method|getTaskFoundResult (Task t)
specifier|static
name|TaskLookupResult
name|getTaskFoundResult
parameter_list|(
name|Task
name|t
parameter_list|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Returning task "
operator|+
name|t
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|TaskLookupResult
argument_list|(
name|t
argument_list|,
name|LookUpStatus
operator|.
name|TASK_FOUND
argument_list|)
return|;
block|}
DECL|method|getNoTaskFoundResult ()
specifier|static
name|TaskLookupResult
name|getNoTaskFoundResult
parameter_list|()
block|{
return|return
name|NoTaskLookupResult
return|;
block|}
DECL|method|getMemFailedResult ()
specifier|static
name|TaskLookupResult
name|getMemFailedResult
parameter_list|()
block|{
return|return
name|MemFailedLookupResult
return|;
block|}
DECL|method|getTask ()
name|Task
name|getTask
parameter_list|()
block|{
return|return
name|task
return|;
block|}
DECL|method|getLookUpStatus ()
name|LookUpStatus
name|getLookUpStatus
parameter_list|()
block|{
return|return
name|lookUpStatus
return|;
block|}
block|}
comment|/**    * This class handles the scheduling algorithms.    * The algos are the same for both Map and Reduce tasks.    * There may be slight variations later, in which case we can make this    * an abstract base class and have derived classes for Map and Reduce.    */
DECL|class|TaskSchedulingMgr
specifier|private
specifier|static
specifier|abstract
class|class
name|TaskSchedulingMgr
block|{
comment|/** our TaskScheduler object */
DECL|field|scheduler
specifier|protected
name|CapacityTaskScheduler
name|scheduler
decl_stmt|;
DECL|field|type
specifier|protected
name|TaskType
name|type
init|=
literal|null
decl_stmt|;
DECL|method|obtainNewTask (TaskTrackerStatus taskTracker, JobInProgress job)
specifier|abstract
name|Task
name|obtainNewTask
parameter_list|(
name|TaskTrackerStatus
name|taskTracker
parameter_list|,
name|JobInProgress
name|job
parameter_list|)
throws|throws
name|IOException
function_decl|;
DECL|method|getClusterCapacity ()
specifier|abstract
name|int
name|getClusterCapacity
parameter_list|()
function_decl|;
DECL|method|getTSC ( QueueSchedulingContext qsc)
specifier|abstract
name|TaskSchedulingContext
name|getTSC
parameter_list|(
name|QueueSchedulingContext
name|qsc
parameter_list|)
function_decl|;
comment|/**      * To check if job has a speculative task on the particular tracker.      *      * @param job job to check for speculative tasks.      * @param tts task tracker on which speculative task would run.      * @return true if there is a speculative task to run on the tracker.      */
DECL|method|hasSpeculativeTask (JobInProgress job, TaskTrackerStatus tts)
specifier|abstract
name|boolean
name|hasSpeculativeTask
parameter_list|(
name|JobInProgress
name|job
parameter_list|,
name|TaskTrackerStatus
name|tts
parameter_list|)
function_decl|;
comment|/**      * Comparator to sort queues.      * For maps, we need to sort on QueueSchedulingContext.mapTSC. For      * reducers, we use reduceTSC. So we'll need separate comparators.      */
DECL|class|QueueComparator
specifier|private
specifier|static
specifier|abstract
class|class
name|QueueComparator
implements|implements
name|Comparator
argument_list|<
name|AbstractQueue
argument_list|>
block|{
DECL|method|getTSC ( QueueSchedulingContext qsi)
specifier|abstract
name|TaskSchedulingContext
name|getTSC
parameter_list|(
name|QueueSchedulingContext
name|qsi
parameter_list|)
function_decl|;
DECL|method|compare (AbstractQueue q1, AbstractQueue q2)
specifier|public
name|int
name|compare
parameter_list|(
name|AbstractQueue
name|q1
parameter_list|,
name|AbstractQueue
name|q2
parameter_list|)
block|{
name|TaskSchedulingContext
name|t1
init|=
name|getTSC
argument_list|(
name|q1
operator|.
name|getQueueSchedulingContext
argument_list|()
argument_list|)
decl_stmt|;
name|TaskSchedulingContext
name|t2
init|=
name|getTSC
argument_list|(
name|q2
operator|.
name|getQueueSchedulingContext
argument_list|()
argument_list|)
decl_stmt|;
comment|// look at how much capacity they've filled. Treat a queue with
comment|// capacity=0 equivalent to a queue running at capacity
name|double
name|r1
init|=
operator|(
literal|0
operator|==
name|t1
operator|.
name|getCapacity
argument_list|()
operator|)
condition|?
literal|1.0f
else|:
operator|(
name|double
operator|)
name|t1
operator|.
name|getNumSlotsOccupied
argument_list|()
operator|/
operator|(
name|double
operator|)
name|t1
operator|.
name|getCapacity
argument_list|()
decl_stmt|;
name|double
name|r2
init|=
operator|(
literal|0
operator|==
name|t2
operator|.
name|getCapacity
argument_list|()
operator|)
condition|?
literal|1.0f
else|:
operator|(
name|double
operator|)
name|t2
operator|.
name|getNumSlotsOccupied
argument_list|()
operator|/
operator|(
name|double
operator|)
name|t2
operator|.
name|getCapacity
argument_list|()
decl_stmt|;
if|if
condition|(
name|r1
operator|<
name|r2
condition|)
return|return
operator|-
literal|1
return|;
elseif|else
if|if
condition|(
name|r1
operator|>
name|r2
condition|)
return|return
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
block|}
comment|// subclass for map and reduce comparators
DECL|class|MapQueueComparator
specifier|private
specifier|static
specifier|final
class|class
name|MapQueueComparator
extends|extends
name|QueueComparator
block|{
DECL|method|getTSC (QueueSchedulingContext qsi)
name|TaskSchedulingContext
name|getTSC
parameter_list|(
name|QueueSchedulingContext
name|qsi
parameter_list|)
block|{
return|return
name|qsi
operator|.
name|getMapTSC
argument_list|()
return|;
block|}
block|}
DECL|class|ReduceQueueComparator
specifier|private
specifier|static
specifier|final
class|class
name|ReduceQueueComparator
extends|extends
name|QueueComparator
block|{
DECL|method|getTSC (QueueSchedulingContext qsi)
name|TaskSchedulingContext
name|getTSC
parameter_list|(
name|QueueSchedulingContext
name|qsi
parameter_list|)
block|{
return|return
name|qsi
operator|.
name|getReduceTSC
argument_list|()
return|;
block|}
block|}
comment|// these are our comparator instances
DECL|field|mapComparator
specifier|protected
specifier|final
specifier|static
name|MapQueueComparator
name|mapComparator
init|=
operator|new
name|MapQueueComparator
argument_list|()
decl_stmt|;
DECL|field|reduceComparator
specifier|protected
specifier|final
specifier|static
name|ReduceQueueComparator
name|reduceComparator
init|=
operator|new
name|ReduceQueueComparator
argument_list|()
decl_stmt|;
comment|// and this is the comparator to use
DECL|field|queueComparator
specifier|protected
name|QueueComparator
name|queueComparator
decl_stmt|;
comment|// Returns queues sorted according to the QueueComparator.
comment|// Mainly for testing purposes.
DECL|method|getOrderedQueues ()
name|String
index|[]
name|getOrderedQueues
parameter_list|()
block|{
name|List
argument_list|<
name|AbstractQueue
argument_list|>
name|queueList
init|=
name|getOrderedJobQueues
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|queues
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|(
name|queueList
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|AbstractQueue
name|q
range|:
name|queueList
control|)
block|{
name|queues
operator|.
name|add
argument_list|(
name|q
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|queues
operator|.
name|toArray
argument_list|(
operator|new
name|String
index|[
name|queues
operator|.
name|size
argument_list|()
index|]
argument_list|)
return|;
block|}
comment|/**      * Return an ordered list of {@link JobQueue}s wrapped as      * {@link AbstractQueue}s. Ordering is according to {@link QueueComparator}.      * To reflect the true ordering of the JobQueues, the complete hierarchy is      * sorted such that {@link AbstractQueue}s are ordered according to their      * needs at each level in the hierarchy, after which only the leaf level      * {@link JobQueue}s are returned.      *       * @return a list of {@link JobQueue}s wrapped as {@link AbstractQueue}s      *         sorted by their needs.      */
DECL|method|getOrderedJobQueues ()
name|List
argument_list|<
name|AbstractQueue
argument_list|>
name|getOrderedJobQueues
parameter_list|()
block|{
name|scheduler
operator|.
name|root
operator|.
name|sort
argument_list|(
name|queueComparator
argument_list|)
expr_stmt|;
return|return
name|scheduler
operator|.
name|root
operator|.
name|getDescendentJobQueues
argument_list|()
return|;
block|}
DECL|method|TaskSchedulingMgr (CapacityTaskScheduler sched)
name|TaskSchedulingMgr
parameter_list|(
name|CapacityTaskScheduler
name|sched
parameter_list|)
block|{
name|scheduler
operator|=
name|sched
expr_stmt|;
block|}
comment|/**      * Ceil of result of dividing two integers.      *       * This is *not* a utility method.       * Neither<code>a</code> or<code>b</code> should be negative.      *        * @param a      * @param b      * @return ceil of the result of a/b      */
DECL|method|divideAndCeil (int a, int b)
specifier|private
name|int
name|divideAndCeil
parameter_list|(
name|int
name|a
parameter_list|,
name|int
name|b
parameter_list|)
block|{
if|if
condition|(
name|b
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|a
operator|+
operator|(
name|b
operator|-
literal|1
operator|)
operator|)
operator|/
name|b
return|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"divideAndCeil called with a="
operator|+
name|a
operator|+
literal|" b="
operator|+
name|b
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
DECL|method|isUserOverLimit (JobInProgress j, QueueSchedulingContext qsc)
specifier|private
name|boolean
name|isUserOverLimit
parameter_list|(
name|JobInProgress
name|j
parameter_list|,
name|QueueSchedulingContext
name|qsc
parameter_list|)
block|{
comment|// what is our current capacity? It is equal to the queue-capacity if
comment|// we're running below capacity. If we're running over capacity, then its
comment|// #running plus slotPerTask of the job (which is the number of extra
comment|// slots we're getting).
name|int
name|currentCapacity
decl_stmt|;
name|TaskSchedulingContext
name|tsi
init|=
name|getTSC
argument_list|(
name|qsc
argument_list|)
decl_stmt|;
if|if
condition|(
name|tsi
operator|.
name|getNumSlotsOccupied
argument_list|()
operator|<
name|tsi
operator|.
name|getCapacity
argument_list|()
condition|)
block|{
name|currentCapacity
operator|=
name|tsi
operator|.
name|getCapacity
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|currentCapacity
operator|=
name|tsi
operator|.
name|getNumSlotsOccupied
argument_list|()
operator|+
name|TaskDataView
operator|.
name|getTaskDataView
argument_list|(
name|type
argument_list|)
operator|.
name|getSlotsPerTask
argument_list|(
name|j
argument_list|)
expr_stmt|;
block|}
name|int
name|limit
init|=
name|Math
operator|.
name|max
argument_list|(
name|divideAndCeil
argument_list|(
name|currentCapacity
argument_list|,
name|qsc
operator|.
name|getNumJobsByUser
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
argument_list|,
name|divideAndCeil
argument_list|(
name|qsc
operator|.
name|getUlMin
argument_list|()
operator|*
name|currentCapacity
argument_list|,
literal|100
argument_list|)
argument_list|)
decl_stmt|;
name|String
name|user
init|=
name|j
operator|.
name|getProfile
argument_list|()
operator|.
name|getUser
argument_list|()
decl_stmt|;
if|if
condition|(
name|tsi
operator|.
name|getNumSlotsOccupiedByUser
argument_list|()
operator|.
name|get
argument_list|(
name|user
argument_list|)
operator|>=
name|limit
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"User "
operator|+
name|user
operator|+
literal|" is over limit, num slots occupied = "
operator|+
name|tsi
operator|.
name|getNumSlotsOccupiedByUser
argument_list|()
operator|.
name|get
argument_list|(
name|user
argument_list|)
operator|+
literal|", limit = "
operator|+
name|limit
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
comment|/*      * This is the central scheduling method.      * It tries to get a task from jobs in a single queue.      * Always return a TaskLookupResult object. Don't return null.      */
DECL|method|getTaskFromQueue (TaskTracker taskTracker, QueueSchedulingContext qsi)
specifier|private
name|TaskLookupResult
name|getTaskFromQueue
parameter_list|(
name|TaskTracker
name|taskTracker
parameter_list|,
name|QueueSchedulingContext
name|qsi
parameter_list|)
throws|throws
name|IOException
block|{
name|TaskTrackerStatus
name|taskTrackerStatus
init|=
name|taskTracker
operator|.
name|getStatus
argument_list|()
decl_stmt|;
comment|// we only look at jobs in the running queues, as these are the ones
comment|// who have been potentially initialized
for|for
control|(
name|JobInProgress
name|j
range|:
name|scheduler
operator|.
name|jobQueuesManager
operator|.
name|getJobQueue
argument_list|(
name|qsi
operator|.
name|getQueueName
argument_list|()
argument_list|)
operator|.
name|getRunningJobs
argument_list|()
control|)
block|{
comment|// only look at jobs that can be run. We ignore jobs that haven't
comment|// initialized, or have completed but haven't been removed from the
comment|// running queue.
comment|//Check queue for maximum capacity .
if|if
condition|(
name|areTasksInQueueOverMaxCapacity
argument_list|(
name|qsi
argument_list|,
name|j
operator|.
name|getNumSlotsPerTask
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|j
operator|.
name|getStatus
argument_list|()
operator|.
name|getRunState
argument_list|()
operator|!=
name|JobStatus
operator|.
name|RUNNING
condition|)
block|{
continue|continue;
block|}
comment|// check if the job's user is over limit
if|if
condition|(
name|isUserOverLimit
argument_list|(
name|j
argument_list|,
name|qsi
argument_list|)
condition|)
block|{
continue|continue;
block|}
comment|//If this job meets memory requirements. Ask the JobInProgress for
comment|//a task to be scheduled on the task tracker.
comment|//if we find a job then we pass it on.
if|if
condition|(
name|scheduler
operator|.
name|memoryMatcher
operator|.
name|matchesMemoryRequirements
argument_list|(
name|j
argument_list|,
name|type
argument_list|,
name|taskTrackerStatus
argument_list|)
condition|)
block|{
comment|// We found a suitable job. Get task from it.
name|Task
name|t
init|=
name|obtainNewTask
argument_list|(
name|taskTrackerStatus
argument_list|,
name|j
argument_list|)
decl_stmt|;
comment|//if there is a task return it immediately.
if|if
condition|(
name|t
operator|!=
literal|null
condition|)
block|{
comment|// we're successful in getting a task
return|return
name|TaskLookupResult
operator|.
name|getTaskFoundResult
argument_list|(
name|t
argument_list|)
return|;
block|}
else|else
block|{
comment|//skip to the next job in the queue.
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Job "
operator|+
name|j
operator|.
name|getJobID
argument_list|()
operator|.
name|toString
argument_list|()
operator|+
literal|" returned no tasks of type "
operator|+
name|type
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|// if memory requirements don't match then we check if the job has
comment|// pending tasks and has insufficient number of 'reserved'
comment|// tasktrackers to cover all pending tasks. If so we reserve the
comment|// current tasktracker for this job so that high memory jobs are not
comment|// starved
name|TaskDataView
name|view
init|=
name|TaskDataView
operator|.
name|getTaskDataView
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|view
operator|.
name|getPendingTasks
argument_list|(
name|j
argument_list|)
operator|!=
literal|0
operator|&&
operator|!
name|view
operator|.
name|hasSufficientReservedTaskTrackers
argument_list|(
name|j
argument_list|)
operator|)
condition|)
block|{
comment|// Reserve all available slots on this tasktracker
name|LOG
operator|.
name|info
argument_list|(
name|j
operator|.
name|getJobID
argument_list|()
operator|+
literal|": Reserving "
operator|+
name|taskTracker
operator|.
name|getTrackerName
argument_list|()
operator|+
literal|" since memory-requirements don't match"
argument_list|)
expr_stmt|;
name|taskTracker
operator|.
name|reserveSlots
argument_list|(
name|type
argument_list|,
name|j
argument_list|,
name|taskTracker
operator|.
name|getAvailableSlots
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
comment|// Block
return|return
name|TaskLookupResult
operator|.
name|getMemFailedResult
argument_list|()
return|;
block|}
block|}
comment|//end of memory check block
comment|// if we're here, this job has no task to run. Look at the next job.
block|}
comment|//end of for loop
comment|// if we're here, we haven't found any task to run among all jobs in
comment|// the queue. This could be because there is nothing to run, or that
comment|// the user limit for some user is too strict, i.e., there's at least
comment|// one user who doesn't have enough tasks to satisfy his limit. If
comment|// it's the latter case, re-look at jobs without considering user
comment|// limits, and get a task from the first eligible job; however
comment|// we do not 'reserve' slots on tasktrackers anymore since the user is
comment|// already over the limit
comment|// Note: some of the code from above is repeated here. This is on
comment|// purpose as it improves overall readability.
comment|// Note: we walk through jobs again. Some of these jobs, which weren't
comment|// considered in the first pass, shouldn't be considered here again,
comment|// but we still check for their viability to keep the code simple. In
comment|// some cases, for high mem jobs that have nothing to run, we call
comment|// obtainNewTask() unnecessarily. Should this be a problem, we can
comment|// create a list of jobs to look at (those whose users were over
comment|// limit) in the first pass and walk through that list only.
for|for
control|(
name|JobInProgress
name|j
range|:
name|scheduler
operator|.
name|jobQueuesManager
operator|.
name|getJobQueue
argument_list|(
name|qsi
operator|.
name|getQueueName
argument_list|()
argument_list|)
operator|.
name|getRunningJobs
argument_list|()
control|)
block|{
if|if
condition|(
name|j
operator|.
name|getStatus
argument_list|()
operator|.
name|getRunState
argument_list|()
operator|!=
name|JobStatus
operator|.
name|RUNNING
condition|)
block|{
continue|continue;
block|}
comment|//Check for the maximum-capacity.
if|if
condition|(
name|areTasksInQueueOverMaxCapacity
argument_list|(
name|qsi
argument_list|,
name|j
operator|.
name|getNumSlotsPerTask
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|scheduler
operator|.
name|memoryMatcher
operator|.
name|matchesMemoryRequirements
argument_list|(
name|j
argument_list|,
name|type
argument_list|,
name|taskTrackerStatus
argument_list|)
condition|)
block|{
comment|// We found a suitable job. Get task from it.
name|Task
name|t
init|=
name|obtainNewTask
argument_list|(
name|taskTrackerStatus
argument_list|,
name|j
argument_list|)
decl_stmt|;
comment|//if there is a task return it immediately.
if|if
condition|(
name|t
operator|!=
literal|null
condition|)
block|{
comment|// we're successful in getting a task
return|return
name|TaskLookupResult
operator|.
name|getTaskFoundResult
argument_list|(
name|t
argument_list|)
return|;
block|}
else|else
block|{           }
block|}
else|else
block|{
comment|//if memory requirements don't match then we check if the
comment|//job has either pending or speculative task. If the job
comment|//has pending or speculative task we block till this job
comment|//tasks get scheduled, so that high memory jobs are not
comment|//starved
if|if
condition|(
name|TaskDataView
operator|.
name|getTaskDataView
argument_list|(
name|type
argument_list|)
operator|.
name|getPendingTasks
argument_list|(
name|j
argument_list|)
operator|!=
literal|0
operator|||
name|hasSpeculativeTask
argument_list|(
name|j
argument_list|,
name|taskTrackerStatus
argument_list|)
condition|)
block|{
return|return
name|TaskLookupResult
operator|.
name|getMemFailedResult
argument_list|()
return|;
block|}
block|}
comment|//end of memory check block
block|}
comment|//end of for loop
comment|// found nothing for this queue, look at the next one.
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|String
name|msg
init|=
literal|"Found no task from the queue "
operator|+
name|qsi
operator|.
name|getQueueName
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
name|msg
argument_list|)
expr_stmt|;
block|}
return|return
name|TaskLookupResult
operator|.
name|getNoTaskFoundResult
argument_list|()
return|;
block|}
comment|// Always return a TaskLookupResult object. Don't return null.
comment|// The caller is responsible for ensuring that the QSC objects and the
comment|// collections are up-to-date.
DECL|method|assignTasks (TaskTracker taskTracker)
specifier|private
name|TaskLookupResult
name|assignTasks
parameter_list|(
name|TaskTracker
name|taskTracker
parameter_list|)
throws|throws
name|IOException
block|{
name|TaskTrackerStatus
name|taskTrackerStatus
init|=
name|taskTracker
operator|.
name|getStatus
argument_list|()
decl_stmt|;
name|printQSCs
argument_list|()
expr_stmt|;
comment|// Check if this tasktracker has been reserved for a job...
name|JobInProgress
name|job
init|=
name|taskTracker
operator|.
name|getJobForFallowSlot
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|job
operator|!=
literal|null
condition|)
block|{
name|int
name|availableSlots
init|=
name|taskTracker
operator|.
name|getAvailableSlots
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|job
operator|.
name|getJobID
argument_list|()
operator|+
literal|": Checking 'reserved' tasktracker "
operator|+
name|taskTracker
operator|.
name|getTrackerName
argument_list|()
operator|+
literal|" with "
operator|+
name|availableSlots
operator|+
literal|" '"
operator|+
name|type
operator|+
literal|"' slots"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|availableSlots
operator|>=
name|job
operator|.
name|getNumSlotsPerTask
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|// Unreserve
name|taskTracker
operator|.
name|unreserveSlots
argument_list|(
name|type
argument_list|,
name|job
argument_list|)
expr_stmt|;
comment|// We found a suitable job. Get task from it.
name|Task
name|t
init|=
name|obtainNewTask
argument_list|(
name|taskTrackerStatus
argument_list|,
name|job
argument_list|)
decl_stmt|;
comment|//if there is a task return it immediately.
if|if
condition|(
name|t
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
name|job
operator|.
name|getJobID
argument_list|()
operator|+
literal|": Got "
operator|+
name|t
operator|.
name|getTaskID
argument_list|()
operator|+
literal|" for reserved tasktracker "
operator|+
name|taskTracker
operator|.
name|getTrackerName
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// we're successful in getting a task
return|return
name|TaskLookupResult
operator|.
name|getTaskFoundResult
argument_list|(
name|t
argument_list|)
return|;
block|}
block|}
else|else
block|{
comment|// Re-reserve the current tasktracker
name|taskTracker
operator|.
name|reserveSlots
argument_list|(
name|type
argument_list|,
name|job
argument_list|,
name|availableSlots
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|job
operator|.
name|getJobID
argument_list|()
operator|+
literal|": Re-reserving "
operator|+
name|taskTracker
operator|.
name|getTrackerName
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|TaskLookupResult
operator|.
name|getMemFailedResult
argument_list|()
return|;
block|}
block|}
for|for
control|(
name|AbstractQueue
name|q
range|:
name|getOrderedJobQueues
argument_list|()
control|)
block|{
name|QueueSchedulingContext
name|qsc
init|=
name|q
operator|.
name|getQueueSchedulingContext
argument_list|()
decl_stmt|;
comment|// we may have queues with capacity=0. We shouldn't look at jobs from
comment|// these queues
if|if
condition|(
literal|0
operator|==
name|getTSC
argument_list|(
name|qsc
argument_list|)
operator|.
name|getCapacity
argument_list|()
condition|)
block|{
continue|continue;
block|}
comment|//This call is important for optimization purposes , if we
comment|//have reached the limit already no need for traversing the queue.
if|if
condition|(
name|this
operator|.
name|areTasksInQueueOverMaxCapacity
argument_list|(
name|qsc
argument_list|,
literal|1
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|TaskLookupResult
name|tlr
init|=
name|getTaskFromQueue
argument_list|(
name|taskTracker
argument_list|,
name|qsc
argument_list|)
decl_stmt|;
name|TaskLookupResult
operator|.
name|LookUpStatus
name|lookUpStatus
init|=
name|tlr
operator|.
name|getLookUpStatus
argument_list|()
decl_stmt|;
if|if
condition|(
name|lookUpStatus
operator|==
name|TaskLookupResult
operator|.
name|LookUpStatus
operator|.
name|NO_TASK_FOUND
condition|)
block|{
continue|continue;
comment|// Look in other queues.
block|}
comment|// if we find a task, return
if|if
condition|(
name|lookUpStatus
operator|==
name|TaskLookupResult
operator|.
name|LookUpStatus
operator|.
name|TASK_FOUND
condition|)
block|{
return|return
name|tlr
return|;
block|}
comment|// if there was a memory mismatch, return
elseif|else
if|if
condition|(
name|lookUpStatus
operator|==
name|TaskLookupResult
operator|.
name|LookUpStatus
operator|.
name|TASK_FAILING_MEMORY_REQUIREMENT
condition|)
block|{
return|return
name|tlr
return|;
block|}
block|}
comment|// nothing to give
return|return
name|TaskLookupResult
operator|.
name|getNoTaskFoundResult
argument_list|()
return|;
block|}
comment|/**      * Check if maximum-capacity is set  for this queue.      * If set and greater than 0 ,      * check if numofslotsoccupied+numSlotsPerTask is greater than      * maximum-Capacity ,if yes , implies this queue is over limit.      *      * Incase noOfSlotsOccupied is less than maximum-capacity ,but ,      * numOfSlotsOccupied+noSlotsPerTask is more than maximum-capacity we still      * dont assign the task . This may lead to under utilization of very small      * set of slots. But this is ok ,as we strictly respect the maximum-capacity      * @param qsc      * @param noOfSlotsPerTask      * @return true if queue is over maximum-capacity      */
DECL|method|areTasksInQueueOverMaxCapacity ( QueueSchedulingContext qsc,int noOfSlotsPerTask)
specifier|private
name|boolean
name|areTasksInQueueOverMaxCapacity
parameter_list|(
name|QueueSchedulingContext
name|qsc
parameter_list|,
name|int
name|noOfSlotsPerTask
parameter_list|)
block|{
name|TaskSchedulingContext
name|tsi
init|=
name|getTSC
argument_list|(
name|qsc
argument_list|)
decl_stmt|;
comment|//check for maximum-capacity
if|if
condition|(
name|tsi
operator|.
name|getMaxCapacity
argument_list|()
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|tsi
operator|.
name|getNumSlotsOccupied
argument_list|()
operator|+
name|noOfSlotsPerTask
operator|)
operator|>
name|tsi
operator|.
name|getMaxCapacity
argument_list|()
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Queue "
operator|+
name|qsc
operator|.
name|getQueueName
argument_list|()
operator|+
literal|" "
operator|+
literal|"has reached its  max "
operator|+
name|type
operator|+
literal|"Capacity"
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Current running tasks "
operator|+
name|tsi
operator|.
name|getCapacity
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|// for debugging.
DECL|method|printQSCs ()
specifier|private
name|void
name|printQSCs
parameter_list|()
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|StringBuffer
name|s
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
for|for
control|(
name|AbstractQueue
name|aq
range|:
name|getOrderedJobQueues
argument_list|()
control|)
block|{
name|QueueSchedulingContext
name|qsi
init|=
name|aq
operator|.
name|getQueueSchedulingContext
argument_list|()
decl_stmt|;
name|TaskSchedulingContext
name|tsi
init|=
name|getTSC
argument_list|(
name|qsi
argument_list|)
decl_stmt|;
name|Collection
argument_list|<
name|JobInProgress
argument_list|>
name|runJobs
init|=
name|scheduler
operator|.
name|jobQueuesManager
operator|.
name|getJobQueue
argument_list|(
name|qsi
operator|.
name|getQueueName
argument_list|()
argument_list|)
operator|.
name|getRunningJobs
argument_list|()
decl_stmt|;
name|s
operator|.
name|append
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|" Queue '%s'(%s): runningTasks=%d, "
operator|+
literal|"occupiedSlots=%d, capacity=%d, runJobs=%d  maximumCapacity=%d "
argument_list|,
name|qsi
operator|.
name|getQueueName
argument_list|()
argument_list|,
name|this
operator|.
name|type
argument_list|,
name|tsi
operator|.
name|getNumRunningTasks
argument_list|()
argument_list|,
name|tsi
operator|.
name|getNumSlotsOccupied
argument_list|()
argument_list|,
name|tsi
operator|.
name|getCapacity
argument_list|()
argument_list|,
operator|(
name|runJobs
operator|.
name|size
argument_list|()
operator|)
argument_list|,
name|tsi
operator|.
name|getMaxCapacity
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Check if one of the tasks have a speculative task to execute on the      * particular task tracker.      *      * @param tips tasks of a job      * @param tts task tracker status for which we are asking speculative tip      * @return true if job has a speculative task to run on particular TT.      */
DECL|method|hasSpeculativeTask ( TaskInProgress[] tips, TaskTrackerStatus tts)
name|boolean
name|hasSpeculativeTask
parameter_list|(
name|TaskInProgress
index|[]
name|tips
parameter_list|,
name|TaskTrackerStatus
name|tts
parameter_list|)
block|{
name|long
name|currentTime
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
for|for
control|(
name|TaskInProgress
name|tip
range|:
name|tips
control|)
block|{
if|if
condition|(
name|tip
operator|.
name|isRunning
argument_list|()
operator|&&
operator|!
operator|(
name|tip
operator|.
name|hasRunOnMachine
argument_list|(
name|tts
operator|.
name|getHost
argument_list|()
argument_list|,
name|tts
operator|.
name|getTrackerName
argument_list|()
argument_list|)
operator|)
operator|&&
name|tip
operator|.
name|canBeSpeculated
argument_list|(
name|currentTime
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
block|}
comment|/**    * The scheduling algorithms for map tasks.    */
DECL|class|MapSchedulingMgr
specifier|private
specifier|static
class|class
name|MapSchedulingMgr
extends|extends
name|TaskSchedulingMgr
block|{
DECL|method|MapSchedulingMgr (CapacityTaskScheduler schedulr)
name|MapSchedulingMgr
parameter_list|(
name|CapacityTaskScheduler
name|schedulr
parameter_list|)
block|{
name|super
argument_list|(
name|schedulr
argument_list|)
expr_stmt|;
name|type
operator|=
name|TaskType
operator|.
name|MAP
expr_stmt|;
name|queueComparator
operator|=
name|mapComparator
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|obtainNewTask (TaskTrackerStatus taskTracker, JobInProgress job)
name|Task
name|obtainNewTask
parameter_list|(
name|TaskTrackerStatus
name|taskTracker
parameter_list|,
name|JobInProgress
name|job
parameter_list|)
throws|throws
name|IOException
block|{
synchronized|synchronized
init|(
name|scheduler
init|)
block|{
name|ClusterStatus
name|clusterStatus
init|=
name|scheduler
operator|.
name|taskTrackerManager
operator|.
name|getClusterStatus
argument_list|()
decl_stmt|;
name|int
name|numTaskTrackers
init|=
name|clusterStatus
operator|.
name|getTaskTrackers
argument_list|()
decl_stmt|;
return|return
name|job
operator|.
name|obtainNewMapTask
argument_list|(
name|taskTracker
argument_list|,
name|numTaskTrackers
argument_list|,
name|scheduler
operator|.
name|taskTrackerManager
operator|.
name|getNumberOfUniqueHosts
argument_list|()
argument_list|)
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|getClusterCapacity ()
name|int
name|getClusterCapacity
parameter_list|()
block|{
synchronized|synchronized
init|(
name|scheduler
init|)
block|{
return|return
name|scheduler
operator|.
name|taskTrackerManager
operator|.
name|getClusterStatus
argument_list|()
operator|.
name|getMaxMapTasks
argument_list|()
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|getTSC (QueueSchedulingContext qsi)
name|TaskSchedulingContext
name|getTSC
parameter_list|(
name|QueueSchedulingContext
name|qsi
parameter_list|)
block|{
return|return
name|qsi
operator|.
name|getMapTSC
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|hasSpeculativeTask (JobInProgress job, TaskTrackerStatus tts)
name|boolean
name|hasSpeculativeTask
parameter_list|(
name|JobInProgress
name|job
parameter_list|,
name|TaskTrackerStatus
name|tts
parameter_list|)
block|{
comment|//Check if job supports speculative map execution first then
comment|//check if job has speculative maps.
return|return
operator|(
name|job
operator|.
name|getMapSpeculativeExecution
argument_list|()
operator|)
operator|&&
operator|(
name|hasSpeculativeTask
argument_list|(
name|job
operator|.
name|getTasks
argument_list|(
name|TaskType
operator|.
name|MAP
argument_list|)
argument_list|,
name|tts
argument_list|)
operator|)
return|;
block|}
block|}
comment|/**    * The scheduling algorithms for reduce tasks.    */
DECL|class|ReduceSchedulingMgr
specifier|private
specifier|static
class|class
name|ReduceSchedulingMgr
extends|extends
name|TaskSchedulingMgr
block|{
DECL|method|ReduceSchedulingMgr (CapacityTaskScheduler schedulr)
name|ReduceSchedulingMgr
parameter_list|(
name|CapacityTaskScheduler
name|schedulr
parameter_list|)
block|{
name|super
argument_list|(
name|schedulr
argument_list|)
expr_stmt|;
name|type
operator|=
name|TaskType
operator|.
name|REDUCE
expr_stmt|;
name|queueComparator
operator|=
name|reduceComparator
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|obtainNewTask (TaskTrackerStatus taskTracker, JobInProgress job)
name|Task
name|obtainNewTask
parameter_list|(
name|TaskTrackerStatus
name|taskTracker
parameter_list|,
name|JobInProgress
name|job
parameter_list|)
throws|throws
name|IOException
block|{
synchronized|synchronized
init|(
name|scheduler
init|)
block|{
name|ClusterStatus
name|clusterStatus
init|=
name|scheduler
operator|.
name|taskTrackerManager
operator|.
name|getClusterStatus
argument_list|()
decl_stmt|;
name|int
name|numTaskTrackers
init|=
name|clusterStatus
operator|.
name|getTaskTrackers
argument_list|()
decl_stmt|;
return|return
name|job
operator|.
name|obtainNewReduceTask
argument_list|(
name|taskTracker
argument_list|,
name|numTaskTrackers
argument_list|,
name|scheduler
operator|.
name|taskTrackerManager
operator|.
name|getNumberOfUniqueHosts
argument_list|()
argument_list|)
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|getClusterCapacity ()
name|int
name|getClusterCapacity
parameter_list|()
block|{
synchronized|synchronized
init|(
name|scheduler
init|)
block|{
return|return
name|scheduler
operator|.
name|taskTrackerManager
operator|.
name|getClusterStatus
argument_list|()
operator|.
name|getMaxReduceTasks
argument_list|()
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|getTSC (QueueSchedulingContext qsi)
name|TaskSchedulingContext
name|getTSC
parameter_list|(
name|QueueSchedulingContext
name|qsi
parameter_list|)
block|{
return|return
name|qsi
operator|.
name|getReduceTSC
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|hasSpeculativeTask (JobInProgress job, TaskTrackerStatus tts)
name|boolean
name|hasSpeculativeTask
parameter_list|(
name|JobInProgress
name|job
parameter_list|,
name|TaskTrackerStatus
name|tts
parameter_list|)
block|{
comment|//check if the job supports reduce speculative execution first then
comment|//check if the job has speculative tasks.
return|return
operator|(
name|job
operator|.
name|getReduceSpeculativeExecution
argument_list|()
operator|)
operator|&&
operator|(
name|hasSpeculativeTask
argument_list|(
name|job
operator|.
name|getTasks
argument_list|(
name|TaskType
operator|.
name|REDUCE
argument_list|)
argument_list|,
name|tts
argument_list|)
operator|)
return|;
block|}
block|}
comment|/** the scheduling mgrs for Map and Reduce tasks */
DECL|field|mapScheduler
specifier|protected
name|TaskSchedulingMgr
name|mapScheduler
init|=
operator|new
name|MapSchedulingMgr
argument_list|(
name|this
argument_list|)
decl_stmt|;
DECL|field|reduceScheduler
specifier|protected
name|TaskSchedulingMgr
name|reduceScheduler
init|=
operator|new
name|ReduceSchedulingMgr
argument_list|(
name|this
argument_list|)
decl_stmt|;
DECL|field|memoryMatcher
name|MemoryMatcher
name|memoryMatcher
init|=
operator|new
name|MemoryMatcher
argument_list|()
decl_stmt|;
DECL|field|LOG
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|CapacityTaskScheduler
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|jobQueuesManager
specifier|protected
name|JobQueuesManager
name|jobQueuesManager
decl_stmt|;
comment|/** whether scheduler has started or not */
DECL|field|started
specifier|private
name|boolean
name|started
init|=
literal|false
decl_stmt|;
comment|/**    * A clock class - can be mocked out for testing.    */
DECL|class|Clock
specifier|static
class|class
name|Clock
block|{
DECL|method|getTime ()
name|long
name|getTime
parameter_list|()
block|{
return|return
name|System
operator|.
name|currentTimeMillis
argument_list|()
return|;
block|}
block|}
DECL|field|clock
specifier|private
name|Clock
name|clock
decl_stmt|;
DECL|field|initializationPoller
specifier|private
name|JobInitializationPoller
name|initializationPoller
decl_stmt|;
DECL|class|CapacitySchedulerQueueRefresher
class|class
name|CapacitySchedulerQueueRefresher
extends|extends
name|QueueRefresher
block|{
annotation|@
name|Override
DECL|method|refreshQueues (List<JobQueueInfo> newRootQueues)
name|void
name|refreshQueues
parameter_list|(
name|List
argument_list|<
name|JobQueueInfo
argument_list|>
name|newRootQueues
parameter_list|)
throws|throws
name|Throwable
block|{
if|if
condition|(
operator|!
name|started
condition|)
block|{
name|String
name|msg
init|=
literal|"Capacity Scheduler is not in the 'started' state."
operator|+
literal|" Cannot refresh queues."
decl_stmt|;
name|LOG
operator|.
name|error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
name|msg
argument_list|)
throw|;
block|}
name|CapacitySchedulerConf
name|schedConf
init|=
operator|new
name|CapacitySchedulerConf
argument_list|()
decl_stmt|;
name|initializeQueues
argument_list|(
name|newRootQueues
argument_list|,
name|schedConf
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|initializationPoller
operator|.
name|refreshQueueInfo
argument_list|(
name|schedConf
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|CapacityTaskScheduler ()
specifier|public
name|CapacityTaskScheduler
parameter_list|()
block|{
name|this
argument_list|(
operator|new
name|Clock
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// for testing
DECL|method|CapacityTaskScheduler (Clock clock)
specifier|public
name|CapacityTaskScheduler
parameter_list|(
name|Clock
name|clock
parameter_list|)
block|{
name|this
operator|.
name|jobQueuesManager
operator|=
operator|new
name|JobQueuesManager
argument_list|()
expr_stmt|;
name|this
operator|.
name|clock
operator|=
name|clock
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getQueueRefresher ()
name|QueueRefresher
name|getQueueRefresher
parameter_list|()
block|{
return|return
operator|new
name|CapacitySchedulerQueueRefresher
argument_list|()
return|;
block|}
comment|/**    * Only for testing.    * @param type    * @return    */
DECL|method|getOrderedQueues (TaskType type)
name|String
index|[]
name|getOrderedQueues
parameter_list|(
name|TaskType
name|type
parameter_list|)
block|{
if|if
condition|(
name|type
operator|==
name|TaskType
operator|.
name|MAP
condition|)
block|{
return|return
name|mapScheduler
operator|.
name|getOrderedQueues
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|TaskType
operator|.
name|REDUCE
condition|)
block|{
return|return
name|reduceScheduler
operator|.
name|getOrderedQueues
argument_list|()
return|;
block|}
return|return
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|start ()
specifier|public
specifier|synchronized
name|void
name|start
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|started
condition|)
return|return;
name|super
operator|.
name|start
argument_list|()
expr_stmt|;
comment|// Initialize MemoryMatcher
name|MemoryMatcher
operator|.
name|initializeMemoryRelatedConf
argument_list|(
name|conf
argument_list|)
expr_stmt|;
comment|// read queue info from config file
name|QueueManager
name|queueManager
init|=
name|taskTrackerManager
operator|.
name|getQueueManager
argument_list|()
decl_stmt|;
comment|// initialize our queues from the config settings
name|CapacitySchedulerConf
name|schedConf
init|=
operator|new
name|CapacitySchedulerConf
argument_list|()
decl_stmt|;
try|try
block|{
name|initializeQueues
argument_list|(
name|queueManager
operator|.
name|getRoot
argument_list|()
operator|.
name|getJobQueueInfo
argument_list|()
operator|.
name|getChildren
argument_list|()
argument_list|,
name|schedConf
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Couldn't initialize queues because of the excecption : "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
name|e
argument_list|)
throw|;
block|}
comment|// Queues are ready. Now register jobQueuesManager with the JobTracker so as
comment|// to listen to job changes
name|taskTrackerManager
operator|.
name|addJobInProgressListener
argument_list|(
name|jobQueuesManager
argument_list|)
expr_stmt|;
comment|//Start thread for initialization
if|if
condition|(
name|initializationPoller
operator|==
literal|null
condition|)
block|{
name|this
operator|.
name|initializationPoller
operator|=
operator|new
name|JobInitializationPoller
argument_list|(
name|jobQueuesManager
argument_list|,
name|taskTrackerManager
argument_list|)
expr_stmt|;
block|}
name|initializationPoller
operator|.
name|init
argument_list|(
name|jobQueuesManager
operator|.
name|getJobQueueNames
argument_list|()
argument_list|,
name|schedConf
argument_list|)
expr_stmt|;
name|initializationPoller
operator|.
name|setDaemon
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|initializationPoller
operator|.
name|start
argument_list|()
expr_stmt|;
name|started
operator|=
literal|true
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Capacity scheduler started successfully"
argument_list|)
expr_stmt|;
block|}
comment|/**    * Read the configuration and initialize the queues. This operation should be    * done only when either the scheduler is starting or a request is received    * from {@link QueueManager} to refresh the queue configuration.    *     *<p>    *     * Even in case of refresh, we do not explicitly destroy AbstractQueue items,    * or the info maps, they will be automatically garbage-collected.    *     *<p>    *     * We don't explicitly lock the scheduler completely. This method is called at    * two times. 1) When the scheduler is starting. During this time, the lock    * sequence is JT->scheduler and so we don't need any more locking here. 2)    * When refresh is issued to {@link QueueManager}. When this happens, parallel    * refreshes are guarded by {@link QueueManager} itself by taking its lock.    *     * @param newRootQueues    * @param schedConf    * @param refreshingQueues    * @throws Throwable    */
DECL|method|initializeQueues (List<JobQueueInfo> newRootQueues, CapacitySchedulerConf schedConf, boolean refreshingQueues)
specifier|private
name|void
name|initializeQueues
parameter_list|(
name|List
argument_list|<
name|JobQueueInfo
argument_list|>
name|newRootQueues
parameter_list|,
name|CapacitySchedulerConf
name|schedConf
parameter_list|,
name|boolean
name|refreshingQueues
parameter_list|)
throws|throws
name|Throwable
block|{
if|if
condition|(
name|newRootQueues
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Cannot initialize the queues with null root-queues!"
argument_list|)
throw|;
block|}
comment|// Sanity check: there should be at least one queue.
if|if
condition|(
literal|0
operator|==
name|newRootQueues
operator|.
name|size
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"System has no queue configured!"
argument_list|)
throw|;
block|}
comment|// Create a new queue-hierarchy builder and try loading the complete
comment|// hierarchy of queues.
name|AbstractQueue
name|newRootAbstractQueue
decl_stmt|;
try|try
block|{
name|newRootAbstractQueue
operator|=
operator|new
name|QueueHierarchyBuilder
argument_list|()
operator|.
name|createHierarchy
argument_list|(
name|newRootQueues
argument_list|,
name|schedConf
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Exception while tryign to (re)initializing queues : "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"(Re)initializing the queues with the new configuration "
operator|+
literal|"failed, so keeping the old configuration."
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
comment|// New configuration is successfully validated and applied, set the new
comment|// configuration to the current queue-hierarchy.
if|if
condition|(
name|refreshingQueues
condition|)
block|{
comment|// Scheduler is being refreshed.
comment|// Going to commit the changes to the hierarchy. Lock the scheduler.
synchronized|synchronized
init|(
name|this
init|)
block|{
name|AbstractQueueComparator
name|comparator
init|=
operator|new
name|AbstractQueueComparator
argument_list|()
decl_stmt|;
name|this
operator|.
name|root
operator|.
name|sort
argument_list|(
name|comparator
argument_list|)
expr_stmt|;
name|newRootAbstractQueue
operator|.
name|sort
argument_list|(
name|comparator
argument_list|)
expr_stmt|;
name|root
operator|.
name|validateAndCopyQueueContexts
argument_list|(
name|newRootAbstractQueue
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// Scheduler is just starting.
name|this
operator|.
name|root
operator|=
name|newRootAbstractQueue
expr_stmt|;
comment|// JobQueue objects are created. Inform the JobQueuesManager so that it
comment|// can track the running/waiting jobs. JobQueuesManager is still not added
comment|// as a listener to JobTracker, so no locking needed.
name|addJobQueuesToJobQueuesManager
argument_list|()
expr_stmt|;
block|}
name|List
argument_list|<
name|AbstractQueue
argument_list|>
name|allQueues
init|=
operator|new
name|ArrayList
argument_list|<
name|AbstractQueue
argument_list|>
argument_list|()
decl_stmt|;
name|allQueues
operator|.
name|addAll
argument_list|(
name|getRoot
argument_list|()
operator|.
name|getDescendantContainerQueues
argument_list|()
argument_list|)
expr_stmt|;
name|allQueues
operator|.
name|addAll
argument_list|(
name|getRoot
argument_list|()
operator|.
name|getDescendentJobQueues
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|AbstractQueue
name|queue
range|:
name|allQueues
control|)
block|{
if|if
condition|(
operator|!
name|refreshingQueues
condition|)
block|{
comment|// Scheduler is just starting, create the display info also
name|createDisplayInfo
argument_list|(
name|taskTrackerManager
operator|.
name|getQueueManager
argument_list|()
argument_list|,
name|queue
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// QueueSchedulingContext objects are created/have changed. Put them
comment|// (back) in the queue-info so as to be consumed by the UI.
name|addToQueueInfoMap
argument_list|(
name|queue
operator|.
name|getQueueSchedulingContext
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Inform the {@link JobQueuesManager} about the newly constructed    * {@link JobQueue}s.    */
DECL|method|addJobQueuesToJobQueuesManager ()
specifier|private
name|void
name|addJobQueuesToJobQueuesManager
parameter_list|()
block|{
name|List
argument_list|<
name|AbstractQueue
argument_list|>
name|allJobQueues
init|=
name|getRoot
argument_list|()
operator|.
name|getDescendentJobQueues
argument_list|()
decl_stmt|;
for|for
control|(
name|AbstractQueue
name|jobQ
range|:
name|allJobQueues
control|)
block|{
name|jobQueuesManager
operator|.
name|addQueue
argument_list|(
operator|(
name|JobQueue
operator|)
name|jobQ
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** mostly for testing purposes */
DECL|method|setInitializationPoller (JobInitializationPoller p)
specifier|synchronized
name|void
name|setInitializationPoller
parameter_list|(
name|JobInitializationPoller
name|p
parameter_list|)
block|{
name|this
operator|.
name|initializationPoller
operator|=
name|p
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|terminate ()
specifier|public
specifier|synchronized
name|void
name|terminate
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|started
condition|)
return|return;
if|if
condition|(
name|jobQueuesManager
operator|!=
literal|null
condition|)
block|{
name|taskTrackerManager
operator|.
name|removeJobInProgressListener
argument_list|(
name|jobQueuesManager
argument_list|)
expr_stmt|;
block|}
name|started
operator|=
literal|false
expr_stmt|;
name|initializationPoller
operator|.
name|terminate
argument_list|()
expr_stmt|;
name|super
operator|.
name|terminate
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|setConf (Configuration conf)
specifier|public
specifier|synchronized
name|void
name|setConf
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
name|super
operator|.
name|setConf
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
comment|/**    * provided for the test classes    * lets you update the QSI objects and sorted collections    */
DECL|method|updateContextInfoForTests ()
specifier|synchronized
name|void
name|updateContextInfoForTests
parameter_list|()
block|{
name|ClusterStatus
name|c
init|=
name|taskTrackerManager
operator|.
name|getClusterStatus
argument_list|()
decl_stmt|;
name|int
name|mapClusterCapacity
init|=
name|c
operator|.
name|getMaxMapTasks
argument_list|()
decl_stmt|;
name|int
name|reduceClusterCapacity
init|=
name|c
operator|.
name|getMaxReduceTasks
argument_list|()
decl_stmt|;
comment|// update the QSI objects
name|updateContextObjects
argument_list|(
name|mapClusterCapacity
argument_list|,
name|reduceClusterCapacity
argument_list|)
expr_stmt|;
name|mapScheduler
operator|.
name|scheduler
operator|.
name|root
operator|.
name|sort
argument_list|(
name|mapScheduler
operator|.
name|queueComparator
argument_list|)
expr_stmt|;
name|reduceScheduler
operator|.
name|scheduler
operator|.
name|root
operator|.
name|sort
argument_list|(
name|reduceScheduler
operator|.
name|queueComparator
argument_list|)
expr_stmt|;
block|}
comment|/**    * Update individual QSC objects.    * We don't need exact information for all variables, just enough for us    * to make scheduling decisions. For example, we don't need an exact count    * of numRunningTasks. Once we count upto the grid capacity, any    * number beyond that will make no difference.    *    **/
DECL|method|updateContextObjects (int mapClusterCapacity, int reduceClusterCapacity)
specifier|private
specifier|synchronized
name|void
name|updateContextObjects
parameter_list|(
name|int
name|mapClusterCapacity
parameter_list|,
name|int
name|reduceClusterCapacity
parameter_list|)
block|{
name|root
operator|.
name|update
argument_list|(
name|mapClusterCapacity
argument_list|,
name|reduceClusterCapacity
argument_list|)
expr_stmt|;
block|}
comment|/*    * The grand plan for assigning a task.     * Always assigns 1 reduce and 1 map , if sufficient slots are    * available for each of types.    * If not , then which ever type of slots are available , that type of task is    * assigned.    * Next, pick a queue. We only look at queues that need a slot. Among these,    * we first look at queues whose (# of running tasks)/capacity is the least.    * Next, pick a job in a queue. we pick the job at the front of the queue    * unless its user is over the user limit.     * Finally, given a job, pick a task from the job.     *      */
annotation|@
name|Override
DECL|method|assignTasks (TaskTracker taskTracker)
specifier|public
specifier|synchronized
name|List
argument_list|<
name|Task
argument_list|>
name|assignTasks
parameter_list|(
name|TaskTracker
name|taskTracker
parameter_list|)
throws|throws
name|IOException
block|{
name|TaskLookupResult
name|tlr
decl_stmt|;
name|TaskTrackerStatus
name|taskTrackerStatus
init|=
name|taskTracker
operator|.
name|getStatus
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Task
argument_list|>
name|result
init|=
operator|new
name|ArrayList
argument_list|<
name|Task
argument_list|>
argument_list|()
decl_stmt|;
comment|/*       * If TT has Map and Reduce slot free, we assign 1 map and 1 reduce      * We  base decision on how much is needed      * versus how much is used      */
name|ClusterStatus
name|c
init|=
name|taskTrackerManager
operator|.
name|getClusterStatus
argument_list|()
decl_stmt|;
name|int
name|mapClusterCapacity
init|=
name|c
operator|.
name|getMaxMapTasks
argument_list|()
decl_stmt|;
name|int
name|reduceClusterCapacity
init|=
name|c
operator|.
name|getMaxReduceTasks
argument_list|()
decl_stmt|;
name|int
name|maxMapSlots
init|=
name|taskTrackerStatus
operator|.
name|getMaxMapSlots
argument_list|()
decl_stmt|;
name|int
name|currentMapSlots
init|=
name|taskTrackerStatus
operator|.
name|countOccupiedMapSlots
argument_list|()
decl_stmt|;
name|int
name|maxReduceSlots
init|=
name|taskTrackerStatus
operator|.
name|getMaxReduceSlots
argument_list|()
decl_stmt|;
name|int
name|currentReduceSlots
init|=
name|taskTrackerStatus
operator|.
name|countOccupiedReduceSlots
argument_list|()
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"TT asking for task, max maps="
operator|+
name|taskTrackerStatus
operator|.
name|getMaxMapSlots
argument_list|()
operator|+
literal|", run maps="
operator|+
name|taskTrackerStatus
operator|.
name|countMapTasks
argument_list|()
operator|+
literal|", max reds="
operator|+
name|taskTrackerStatus
operator|.
name|getMaxReduceSlots
argument_list|()
operator|+
literal|", run reds="
operator|+
name|taskTrackerStatus
operator|.
name|countReduceTasks
argument_list|()
operator|+
literal|", map cap="
operator|+
name|mapClusterCapacity
operator|+
literal|", red cap = "
operator|+
name|reduceClusterCapacity
argument_list|)
expr_stmt|;
block|}
comment|/*       * update all our QSC objects.      * This involves updating each qsC structure. This operation depends      * on the number of running jobs in a queue, and some waiting jobs. If it      * becomes expensive, do it once every few heartbeats only.      */
name|updateContextObjects
argument_list|(
name|mapClusterCapacity
argument_list|,
name|reduceClusterCapacity
argument_list|)
expr_stmt|;
comment|// make sure we get our map or reduce scheduling object to update its
comment|// collection of QSC objects too.
if|if
condition|(
name|maxReduceSlots
operator|>
name|currentReduceSlots
condition|)
block|{
comment|//reduce slot available , try to get a
comment|//reduce task
name|tlr
operator|=
name|reduceScheduler
operator|.
name|assignTasks
argument_list|(
name|taskTracker
argument_list|)
expr_stmt|;
if|if
condition|(
name|TaskLookupResult
operator|.
name|LookUpStatus
operator|.
name|TASK_FOUND
operator|==
name|tlr
operator|.
name|getLookUpStatus
argument_list|()
condition|)
block|{
name|result
operator|.
name|add
argument_list|(
name|tlr
operator|.
name|getTask
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|maxMapSlots
operator|>
name|currentMapSlots
condition|)
block|{
comment|//map slot available , try to get a map task
name|tlr
operator|=
name|mapScheduler
operator|.
name|assignTasks
argument_list|(
name|taskTracker
argument_list|)
expr_stmt|;
if|if
condition|(
name|TaskLookupResult
operator|.
name|LookUpStatus
operator|.
name|TASK_FOUND
operator|==
name|tlr
operator|.
name|getLookUpStatus
argument_list|()
condition|)
block|{
name|result
operator|.
name|add
argument_list|(
name|tlr
operator|.
name|getTask
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|result
operator|.
name|isEmpty
argument_list|()
operator|)
condition|?
literal|null
else|:
name|result
return|;
block|}
annotation|@
name|Override
DECL|method|getJobs (String queueName)
specifier|public
specifier|synchronized
name|Collection
argument_list|<
name|JobInProgress
argument_list|>
name|getJobs
parameter_list|(
name|String
name|queueName
parameter_list|)
block|{
name|Collection
argument_list|<
name|JobInProgress
argument_list|>
name|jobCollection
init|=
operator|new
name|ArrayList
argument_list|<
name|JobInProgress
argument_list|>
argument_list|()
decl_stmt|;
name|JobQueue
name|jobQueue
init|=
name|jobQueuesManager
operator|.
name|getJobQueue
argument_list|(
name|queueName
argument_list|)
decl_stmt|;
if|if
condition|(
name|jobQueue
operator|==
literal|null
condition|)
block|{
return|return
name|jobCollection
return|;
block|}
name|Collection
argument_list|<
name|JobInProgress
argument_list|>
name|runningJobs
init|=
name|jobQueue
operator|.
name|getRunningJobs
argument_list|()
decl_stmt|;
if|if
condition|(
name|runningJobs
operator|!=
literal|null
condition|)
block|{
name|jobCollection
operator|.
name|addAll
argument_list|(
name|runningJobs
argument_list|)
expr_stmt|;
block|}
name|Collection
argument_list|<
name|JobInProgress
argument_list|>
name|waitingJobs
init|=
name|jobQueue
operator|.
name|getWaitingJobs
argument_list|()
decl_stmt|;
name|Collection
argument_list|<
name|JobInProgress
argument_list|>
name|tempCollection
init|=
operator|new
name|ArrayList
argument_list|<
name|JobInProgress
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|waitingJobs
operator|!=
literal|null
condition|)
block|{
name|tempCollection
operator|.
name|addAll
argument_list|(
name|waitingJobs
argument_list|)
expr_stmt|;
block|}
name|tempCollection
operator|.
name|removeAll
argument_list|(
name|runningJobs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tempCollection
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|jobCollection
operator|.
name|addAll
argument_list|(
name|tempCollection
argument_list|)
expr_stmt|;
block|}
return|return
name|jobCollection
return|;
block|}
DECL|method|getInitializationPoller ()
specifier|synchronized
name|JobInitializationPoller
name|getInitializationPoller
parameter_list|()
block|{
return|return
name|initializationPoller
return|;
block|}
DECL|method|getDisplayInfo (String queueName)
specifier|private
specifier|synchronized
name|String
name|getDisplayInfo
parameter_list|(
name|String
name|queueName
parameter_list|)
block|{
name|QueueSchedulingContext
name|qsi
init|=
name|queueInfoMap
operator|.
name|get
argument_list|(
name|queueName
argument_list|)
decl_stmt|;
if|if
condition|(
literal|null
operator|==
name|qsi
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|qsi
operator|.
name|toString
argument_list|()
return|;
block|}
DECL|method|addToQueueInfoMap (QueueSchedulingContext qsc)
specifier|private
specifier|synchronized
name|void
name|addToQueueInfoMap
parameter_list|(
name|QueueSchedulingContext
name|qsc
parameter_list|)
block|{
name|queueInfoMap
operator|.
name|put
argument_list|(
name|qsc
operator|.
name|getQueueName
argument_list|()
argument_list|,
name|qsc
argument_list|)
expr_stmt|;
block|}
comment|/**    * Create the scheduler information and set it in the {@link QueueManager}.    * this should be only called when the scheduler is starting.    *     * @param queueManager    * @param queueName    */
DECL|method|createDisplayInfo (QueueManager queueManager, String queueName)
specifier|private
name|void
name|createDisplayInfo
parameter_list|(
name|QueueManager
name|queueManager
parameter_list|,
name|String
name|queueName
parameter_list|)
block|{
if|if
condition|(
name|queueManager
operator|!=
literal|null
condition|)
block|{
name|SchedulingDisplayInfo
name|schedulingInfo
init|=
operator|new
name|SchedulingDisplayInfo
argument_list|(
name|queueName
argument_list|,
name|this
argument_list|)
decl_stmt|;
name|queueManager
operator|.
name|setSchedulerInfo
argument_list|(
name|queueName
argument_list|,
name|schedulingInfo
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Use for testing purposes.    * returns the root    * @return    */
DECL|method|getRoot ()
name|AbstractQueue
name|getRoot
parameter_list|()
block|{
return|return
name|this
operator|.
name|root
return|;
block|}
comment|/**    * This is used for testing purpose only    * Dont use this method.    * @param rt    */
DECL|method|setRoot (AbstractQueue rt)
name|void
name|setRoot
parameter_list|(
name|AbstractQueue
name|rt
parameter_list|)
block|{
name|this
operator|.
name|root
operator|=
name|rt
expr_stmt|;
block|}
block|}
end_class

end_unit

