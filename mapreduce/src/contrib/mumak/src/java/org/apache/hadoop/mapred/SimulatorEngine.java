begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.mapred
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|PrintStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Random
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Pattern
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configured
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|JobStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|SimulatorEvent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|SimulatorEventQueue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|JobCompleteEvent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|SimulatorJobClient
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|SimulatorJobTracker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|SimulatorTaskTracker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|net
operator|.
name|DNSToSwitchMapping
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|net
operator|.
name|StaticMapping
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|tools
operator|.
name|rumen
operator|.
name|ClusterStory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|tools
operator|.
name|rumen
operator|.
name|ClusterTopologyReader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|tools
operator|.
name|rumen
operator|.
name|JobStoryProducer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|tools
operator|.
name|rumen
operator|.
name|LoggedNetworkTopology
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|tools
operator|.
name|rumen
operator|.
name|MachineNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|tools
operator|.
name|rumen
operator|.
name|RackNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|tools
operator|.
name|rumen
operator|.
name|ZombieCluster
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|tools
operator|.
name|rumen
operator|.
name|RandomSeedGenerator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Tool
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|ToolRunner
import|;
end_import

begin_comment
comment|/**  * {@link SimulatorEngine} is the main class of the simulator. To launch the  * simulator, user can either run the main class directly with two parameters,  * input trace file and corresponding topology file, or use the script  * "bin/mumak.sh trace.json topology.json". Trace file and topology file are  * produced by rumen.  */
end_comment

begin_class
DECL|class|SimulatorEngine
specifier|public
class|class
name|SimulatorEngine
extends|extends
name|Configured
implements|implements
name|Tool
block|{
DECL|field|EMPTY_EVENTS
specifier|public
specifier|static
specifier|final
name|List
argument_list|<
name|SimulatorEvent
argument_list|>
name|EMPTY_EVENTS
init|=
operator|new
name|ArrayList
argument_list|<
name|SimulatorEvent
argument_list|>
argument_list|()
decl_stmt|;
comment|/** Default number of milliseconds required to boot up the entire cluster. */
DECL|field|DEFAULT_CLUSTER_STARTUP_DURATION
specifier|public
specifier|static
specifier|final
name|int
name|DEFAULT_CLUSTER_STARTUP_DURATION
init|=
literal|100
operator|*
literal|1000
decl_stmt|;
DECL|field|queue
specifier|protected
specifier|final
name|SimulatorEventQueue
name|queue
init|=
operator|new
name|SimulatorEventQueue
argument_list|()
decl_stmt|;
DECL|field|traceFile
name|String
name|traceFile
decl_stmt|;
DECL|field|topologyFile
name|String
name|topologyFile
decl_stmt|;
DECL|field|jt
name|SimulatorJobTracker
name|jt
decl_stmt|;
DECL|field|jc
name|SimulatorJobClient
name|jc
decl_stmt|;
DECL|field|shutdown
name|boolean
name|shutdown
init|=
literal|false
decl_stmt|;
DECL|field|terminateTime
name|long
name|terminateTime
init|=
name|Long
operator|.
name|MAX_VALUE
decl_stmt|;
DECL|field|currentTime
name|long
name|currentTime
decl_stmt|;
comment|/** The HashSet for storing all the simulated threads useful for     * job initialization for capacity scheduler.    */
DECL|field|threadSet
name|HashSet
argument_list|<
name|SimulatorCSJobInitializationThread
argument_list|>
name|threadSet
decl_stmt|;
comment|/** The log object to send our messages to; only used for debugging. */
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|SimulatorEngine
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/**     * Master random seed read from the configuration file, if present.    * It is (only) used for creating sub seeds for all the random number     * generators.    */
DECL|field|masterRandomSeed
name|long
name|masterRandomSeed
decl_stmt|;
comment|/**    * Start simulated task trackers based on topology.    * @param clusterStory the cluster topology.    * @param jobConf configuration object.    * @param now    *    time stamp when the simulator is started, {@link SimulatorTaskTracker}s    *    are started uniformly randomly spread in [now,now+startDuration).    * @return time stamp by which the entire cluster is booted up and all task    *    trackers are sending hearbeats in their steady rate.    */
DECL|method|startTaskTrackers (ClusterStory cluster, JobConf jobConf, long now)
name|long
name|startTaskTrackers
parameter_list|(
name|ClusterStory
name|cluster
parameter_list|,
name|JobConf
name|jobConf
parameter_list|,
name|long
name|now
parameter_list|)
block|{
comment|/** port assigned to TTs, incremented by 1 for each TT */
name|int
name|port
init|=
literal|10000
decl_stmt|;
name|int
name|numTaskTrackers
init|=
literal|0
decl_stmt|;
name|Random
name|random
init|=
operator|new
name|Random
argument_list|(
name|RandomSeedGenerator
operator|.
name|getSeed
argument_list|(
literal|"forStartTaskTrackers()"
argument_list|,
name|masterRandomSeed
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|int
name|startDuration
init|=
name|jobConf
operator|.
name|getInt
argument_list|(
literal|"mumak.cluster.startup.duration"
argument_list|,
name|DEFAULT_CLUSTER_STARTUP_DURATION
argument_list|)
decl_stmt|;
for|for
control|(
name|MachineNode
name|node
range|:
name|cluster
operator|.
name|getMachines
argument_list|()
control|)
block|{
name|jobConf
operator|.
name|set
argument_list|(
literal|"mumak.tasktracker.host.name"
argument_list|,
name|node
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|jobConf
operator|.
name|set
argument_list|(
literal|"mumak.tasktracker.tracker.name"
argument_list|,
literal|"tracker_"
operator|+
name|node
operator|.
name|getName
argument_list|()
operator|+
literal|":localhost/127.0.0.1:"
operator|+
name|port
argument_list|)
expr_stmt|;
name|long
name|subRandomSeed
init|=
name|RandomSeedGenerator
operator|.
name|getSeed
argument_list|(
literal|"forTaskTracker"
operator|+
name|numTaskTrackers
argument_list|,
name|masterRandomSeed
argument_list|)
decl_stmt|;
name|jobConf
operator|.
name|setLong
argument_list|(
literal|"mumak.tasktracker.random.seed"
argument_list|,
name|subRandomSeed
argument_list|)
expr_stmt|;
name|numTaskTrackers
operator|++
expr_stmt|;
name|port
operator|++
expr_stmt|;
name|SimulatorTaskTracker
name|tt
init|=
operator|new
name|SimulatorTaskTracker
argument_list|(
name|jt
argument_list|,
name|jobConf
argument_list|)
decl_stmt|;
name|long
name|firstHeartbeat
init|=
name|now
operator|+
name|random
operator|.
name|nextInt
argument_list|(
name|startDuration
argument_list|)
decl_stmt|;
name|queue
operator|.
name|addAll
argument_list|(
name|tt
operator|.
name|init
argument_list|(
name|firstHeartbeat
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// In startDuration + heartbeat interval of the full cluster time each
comment|// TT is started up and told on its 2nd heartbeat to beat at a rate
comment|// corresponding to the steady state of the cluster
name|long
name|clusterSteady
init|=
name|now
operator|+
name|startDuration
operator|+
name|jt
operator|.
name|getNextHeartbeatInterval
argument_list|()
decl_stmt|;
return|return
name|clusterSteady
return|;
block|}
comment|/**    * Reads a positive long integer from a configuration.    *    * @param Configuration conf configuration objects    * @param String propertyName name of the property    * @return time    */
DECL|method|getTimeProperty (Configuration conf, String propertyName, long defaultValue)
name|long
name|getTimeProperty
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|String
name|propertyName
parameter_list|,
name|long
name|defaultValue
parameter_list|)
throws|throws
name|IllegalArgumentException
block|{
comment|// possible improvement: change date format to human readable ?
name|long
name|time
init|=
name|conf
operator|.
name|getLong
argument_list|(
name|propertyName
argument_list|,
name|defaultValue
argument_list|)
decl_stmt|;
if|if
condition|(
name|time
operator|<=
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|propertyName
operator|+
literal|"time must be positive: "
operator|+
name|time
argument_list|)
throw|;
block|}
return|return
name|time
return|;
block|}
comment|/**    * Creates the configuration for mumak simulation. This is kept modular mostly for     * testing purposes. so that the standard configuration can be modified before passing    * it to the init() function.    * @return JobConf: the configuration for the SimulatorJobTracker     */
DECL|method|createMumakConf ()
name|JobConf
name|createMumakConf
parameter_list|()
block|{
name|JobConf
name|jobConf
init|=
operator|new
name|JobConf
argument_list|(
name|getConf
argument_list|()
argument_list|)
decl_stmt|;
name|jobConf
operator|.
name|setClass
argument_list|(
literal|"topology.node.switch.mapping.impl"
argument_list|,
name|StaticMapping
operator|.
name|class
argument_list|,
name|DNSToSwitchMapping
operator|.
name|class
argument_list|)
expr_stmt|;
name|jobConf
operator|.
name|set
argument_list|(
literal|"fs.default.name"
argument_list|,
literal|"file:///"
argument_list|)
expr_stmt|;
name|jobConf
operator|.
name|set
argument_list|(
literal|"mapred.job.tracker"
argument_list|,
literal|"localhost:8012"
argument_list|)
expr_stmt|;
name|jobConf
operator|.
name|setInt
argument_list|(
literal|"mapred.jobtracker.job.history.block.size"
argument_list|,
literal|512
argument_list|)
expr_stmt|;
name|jobConf
operator|.
name|setInt
argument_list|(
literal|"mapred.jobtracker.job.history.buffer.size"
argument_list|,
literal|512
argument_list|)
expr_stmt|;
name|jobConf
operator|.
name|setLong
argument_list|(
literal|"mapred.tasktracker.expiry.interval"
argument_list|,
literal|5000
argument_list|)
expr_stmt|;
name|jobConf
operator|.
name|setInt
argument_list|(
literal|"mapred.reduce.copy.backoff"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|jobConf
operator|.
name|setLong
argument_list|(
literal|"mapred.job.reuse.jvm.num.tasks"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|jobConf
operator|.
name|setUser
argument_list|(
literal|"mumak"
argument_list|)
expr_stmt|;
name|jobConf
operator|.
name|set
argument_list|(
literal|"mapred.system.dir"
argument_list|,
name|jobConf
operator|.
name|get
argument_list|(
literal|"hadoop.log.dir"
argument_list|,
literal|"/tmp/hadoop-"
operator|+
name|jobConf
operator|.
name|getUser
argument_list|()
argument_list|)
operator|+
literal|"/mapred/system"
argument_list|)
expr_stmt|;
return|return
name|jobConf
return|;
block|}
comment|/**    * Initialize components in the simulation.    * @throws InterruptedException    * @throws IOException if trace or topology files cannot be opened.    */
DECL|method|init ()
name|void
name|init
parameter_list|()
throws|throws
name|InterruptedException
throws|,
name|IOException
block|{
name|JobConf
name|jobConf
init|=
name|createMumakConf
argument_list|()
decl_stmt|;
name|init
argument_list|(
name|jobConf
argument_list|)
expr_stmt|;
block|}
comment|/**    * Initiate components in the simulation. The JobConf is    * create separately and passed to the init().    * @param JobConf: The configuration for the jobtracker.    * @throws InterruptedException    * @throws IOException if trace or topology files cannot be opened.    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"deprecation"
argument_list|)
DECL|method|init (JobConf jobConf)
name|void
name|init
parameter_list|(
name|JobConf
name|jobConf
parameter_list|)
throws|throws
name|InterruptedException
throws|,
name|IOException
block|{
name|FileSystem
name|lfs
init|=
name|FileSystem
operator|.
name|getLocal
argument_list|(
name|getConf
argument_list|()
argument_list|)
decl_stmt|;
name|Path
name|logPath
init|=
operator|new
name|Path
argument_list|(
name|System
operator|.
name|getProperty
argument_list|(
literal|"hadoop.log.dir"
argument_list|)
argument_list|)
operator|.
name|makeQualified
argument_list|(
name|lfs
argument_list|)
decl_stmt|;
name|jobConf
operator|.
name|set
argument_list|(
literal|"mapred.system.dir"
argument_list|,
name|logPath
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|jobConf
operator|.
name|set
argument_list|(
literal|"hadoop.job.history.location"
argument_list|,
operator|(
operator|new
name|Path
argument_list|(
name|logPath
argument_list|,
literal|"history"
argument_list|)
operator|.
name|toString
argument_list|()
operator|)
argument_list|)
expr_stmt|;
comment|// start time for virtual clock
comment|// possible improvement: set default value to sth more meaningful based on
comment|// the 1st job
name|long
name|now
init|=
name|getTimeProperty
argument_list|(
name|jobConf
argument_list|,
literal|"mumak.start.time"
argument_list|,
name|System
operator|.
name|currentTimeMillis
argument_list|()
argument_list|)
decl_stmt|;
name|jt
operator|=
name|SimulatorJobTracker
operator|.
name|startTracker
argument_list|(
name|jobConf
argument_list|,
name|now
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|jt
operator|.
name|offerService
argument_list|()
expr_stmt|;
name|masterRandomSeed
operator|=
name|jobConf
operator|.
name|getLong
argument_list|(
literal|"mumak.random.seed"
argument_list|,
name|System
operator|.
name|nanoTime
argument_list|()
argument_list|)
expr_stmt|;
comment|// max Map/Reduce tasks per node
name|int
name|maxMaps
init|=
name|getConf
argument_list|()
operator|.
name|getInt
argument_list|(
literal|"mapred.tasktracker.map.tasks.maximum"
argument_list|,
name|SimulatorTaskTracker
operator|.
name|DEFAULT_MAP_SLOTS
argument_list|)
decl_stmt|;
name|int
name|maxReduces
init|=
name|getConf
argument_list|()
operator|.
name|getInt
argument_list|(
literal|"mapred.tasktracker.reduce.tasks.maximum"
argument_list|,
name|SimulatorTaskTracker
operator|.
name|DEFAULT_REDUCE_SLOTS
argument_list|)
decl_stmt|;
name|MachineNode
name|defaultNode
init|=
operator|new
name|MachineNode
operator|.
name|Builder
argument_list|(
literal|"default"
argument_list|,
literal|2
argument_list|)
operator|.
name|setMapSlots
argument_list|(
name|maxMaps
argument_list|)
operator|.
name|setReduceSlots
argument_list|(
name|maxReduces
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|LoggedNetworkTopology
name|topology
init|=
operator|new
name|ClusterTopologyReader
argument_list|(
operator|new
name|Path
argument_list|(
name|topologyFile
argument_list|)
argument_list|,
name|jobConf
argument_list|)
operator|.
name|get
argument_list|()
decl_stmt|;
comment|// Setting the static mapping before removing numeric IP hosts.
name|setStaticMapping
argument_list|(
name|topology
argument_list|)
expr_stmt|;
if|if
condition|(
name|getConf
argument_list|()
operator|.
name|getBoolean
argument_list|(
literal|"mumak.topology.filter-numeric-ips"
argument_list|,
literal|true
argument_list|)
condition|)
block|{
name|removeIpHosts
argument_list|(
name|topology
argument_list|)
expr_stmt|;
block|}
name|ZombieCluster
name|cluster
init|=
operator|new
name|ZombieCluster
argument_list|(
name|topology
argument_list|,
name|defaultNode
argument_list|)
decl_stmt|;
comment|// create TTs based on topology.json
name|long
name|firstJobStartTime
init|=
name|startTaskTrackers
argument_list|(
name|cluster
argument_list|,
name|jobConf
argument_list|,
name|now
argument_list|)
decl_stmt|;
name|long
name|subRandomSeed
init|=
name|RandomSeedGenerator
operator|.
name|getSeed
argument_list|(
literal|"forSimulatorJobStoryProducer"
argument_list|,
name|masterRandomSeed
argument_list|)
decl_stmt|;
name|JobStoryProducer
name|jobStoryProducer
init|=
operator|new
name|SimulatorJobStoryProducer
argument_list|(
operator|new
name|Path
argument_list|(
name|traceFile
argument_list|)
argument_list|,
name|cluster
argument_list|,
name|firstJobStartTime
argument_list|,
name|jobConf
argument_list|,
name|subRandomSeed
argument_list|)
decl_stmt|;
specifier|final
name|SimulatorJobSubmissionPolicy
name|submissionPolicy
init|=
name|SimulatorJobSubmissionPolicy
operator|.
name|getPolicy
argument_list|(
name|jobConf
argument_list|)
decl_stmt|;
name|jc
operator|=
operator|new
name|SimulatorJobClient
argument_list|(
name|jt
argument_list|,
name|jobStoryProducer
argument_list|,
name|submissionPolicy
argument_list|)
expr_stmt|;
name|queue
operator|.
name|addAll
argument_list|(
name|jc
operator|.
name|init
argument_list|(
name|firstJobStartTime
argument_list|)
argument_list|)
expr_stmt|;
comment|//if the taskScheduler is CapacityTaskScheduler start off the JobInitialization
comment|//threads too
if|if
condition|(
name|jobConf
operator|.
name|get
argument_list|(
literal|"mapred.jobtracker.taskScheduler"
argument_list|)
operator|.
name|equals
argument_list|(
name|CapacityTaskScheduler
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"CapacityScheduler used: starting simulatorThreads"
argument_list|)
expr_stmt|;
name|startSimulatorThreadsCapSched
argument_list|(
name|now
argument_list|)
expr_stmt|;
block|}
name|terminateTime
operator|=
name|getTimeProperty
argument_list|(
name|jobConf
argument_list|,
literal|"mumak.terminate.time"
argument_list|,
name|Long
operator|.
name|MAX_VALUE
argument_list|)
expr_stmt|;
block|}
comment|/**    * In this function, we collect the set of leaf queues from JobTracker, and     * for each of them creates a simulated thread that performs the same    * check as JobInitializationPoller.JobInitializationThread in Capacity Scheduler.      * @param now    * @throws IOException    */
DECL|method|startSimulatorThreadsCapSched (long now)
specifier|private
name|void
name|startSimulatorThreadsCapSched
parameter_list|(
name|long
name|now
parameter_list|)
throws|throws
name|IOException
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|queueNames
init|=
name|jt
operator|.
name|getQueueManager
argument_list|()
operator|.
name|getLeafQueueNames
argument_list|()
decl_stmt|;
name|TaskScheduler
name|taskScheduler
init|=
name|jt
operator|.
name|getTaskScheduler
argument_list|()
decl_stmt|;
name|threadSet
operator|=
operator|new
name|HashSet
argument_list|<
name|SimulatorCSJobInitializationThread
argument_list|>
argument_list|()
expr_stmt|;
comment|// We create a different thread for each queue and hold a
comment|//reference to  each of them
for|for
control|(
name|String
name|jobQueue
range|:
name|queueNames
control|)
block|{
name|SimulatorCSJobInitializationThread
name|capThread
init|=
operator|new
name|SimulatorCSJobInitializationThread
argument_list|(
name|taskScheduler
argument_list|,
name|jobQueue
argument_list|)
decl_stmt|;
name|threadSet
operator|.
name|add
argument_list|(
name|capThread
argument_list|)
expr_stmt|;
name|queue
operator|.
name|addAll
argument_list|(
name|capThread
operator|.
name|init
argument_list|(
name|now
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * The main loop of the simulation. First call init() to get objects ready,    * then go into the main loop, where {@link SimulatorEvent}s are handled removed from    * the {@link SimulatorEventQueue}, and new {@link SimulatorEvent}s are created and inserted    * into the {@link SimulatorEventQueue}.    * @throws IOException    * @throws InterruptedException    */
DECL|method|run ()
name|void
name|run
parameter_list|()
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|init
argument_list|()
expr_stmt|;
for|for
control|(
name|SimulatorEvent
name|next
init|=
name|queue
operator|.
name|get
argument_list|()
init|;
name|next
operator|!=
literal|null
operator|&&
name|next
operator|.
name|getTimeStamp
argument_list|()
operator|<
name|terminateTime
operator|&&
operator|!
name|shutdown
condition|;
name|next
operator|=
name|queue
operator|.
name|get
argument_list|()
control|)
block|{
name|currentTime
operator|=
name|next
operator|.
name|getTimeStamp
argument_list|()
expr_stmt|;
assert|assert
operator|(
name|currentTime
operator|==
name|queue
operator|.
name|getCurrentTime
argument_list|()
operator|)
assert|;
name|SimulatorEventListener
name|listener
init|=
name|next
operator|.
name|getListener
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|SimulatorEvent
argument_list|>
name|response
init|=
name|listener
operator|.
name|accept
argument_list|(
name|next
argument_list|)
decl_stmt|;
name|queue
operator|.
name|addAll
argument_list|(
name|response
argument_list|)
expr_stmt|;
block|}
name|summary
argument_list|(
name|System
operator|.
name|out
argument_list|)
expr_stmt|;
block|}
comment|/**    * Run after the main loop.    * @param out stream to output information about the simulation    */
DECL|method|summary (PrintStream out)
name|void
name|summary
parameter_list|(
name|PrintStream
name|out
parameter_list|)
block|{
name|out
operator|.
name|println
argument_list|(
literal|"Done, total events processed: "
operator|+
name|queue
operator|.
name|getEventCount
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|main (String[] args)
specifier|public
specifier|static
name|void
name|main
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
throws|throws
name|Exception
block|{
name|int
name|res
init|=
name|ToolRunner
operator|.
name|run
argument_list|(
operator|new
name|Configuration
argument_list|()
argument_list|,
operator|new
name|SimulatorEngine
argument_list|()
argument_list|,
name|args
argument_list|)
decl_stmt|;
name|System
operator|.
name|exit
argument_list|(
name|res
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|run (String[] args)
specifier|public
name|int
name|run
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
throws|throws
name|Exception
block|{
name|parseParameters
argument_list|(
name|args
argument_list|)
expr_stmt|;
try|try
block|{
name|run
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
finally|finally
block|{
if|if
condition|(
name|jt
operator|!=
literal|null
condition|)
block|{
name|jt
operator|.
name|getTaskScheduler
argument_list|()
operator|.
name|terminate
argument_list|()
expr_stmt|;
block|}
block|}
block|}
DECL|method|parseParameters (String[] args)
name|void
name|parseParameters
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
block|{
if|if
condition|(
name|args
operator|.
name|length
operator|!=
literal|2
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Usage: java ... SimulatorEngine trace.json topology.json"
argument_list|)
throw|;
block|}
name|traceFile
operator|=
name|args
index|[
literal|0
index|]
expr_stmt|;
name|topologyFile
operator|=
name|args
index|[
literal|1
index|]
expr_stmt|;
block|}
comment|/**    * Called when a job is completed. Insert a {@link JobCompleteEvent} into the    * {@link SimulatorEventQueue}. This event will be picked up by    * {@link SimulatorJobClient}, which will in turn decide whether the    * simulation is done.    * @param jobStatus final status of a job, SUCCEEDED or FAILED    * @param timestamp time stamp when the job is completed    */
DECL|method|markCompletedJob (JobStatus jobStatus, long timestamp)
name|void
name|markCompletedJob
parameter_list|(
name|JobStatus
name|jobStatus
parameter_list|,
name|long
name|timestamp
parameter_list|)
block|{
name|queue
operator|.
name|add
argument_list|(
operator|new
name|JobCompleteEvent
argument_list|(
name|jc
argument_list|,
name|timestamp
argument_list|,
name|jobStatus
argument_list|,
name|this
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Called by {@link SimulatorJobClient} when the simulation is completed and    * should be stopped.    */
DECL|method|shutdown ()
name|void
name|shutdown
parameter_list|()
block|{
name|shutdown
operator|=
literal|true
expr_stmt|;
block|}
comment|/**    * Get the current virtual time of the on-going simulation. It is defined by    * the time stamp of the last event handled.    * @return the current virtual time    */
DECL|method|getCurrentTime ()
name|long
name|getCurrentTime
parameter_list|()
block|{
return|return
name|currentTime
return|;
block|}
comment|// Due to HDFS-778, a node may appear in job history logs as both numeric
comment|// ips and as host names. We remove them from the parsed network topology
comment|// before feeding it to ZombieCluster.
DECL|method|removeIpHosts (LoggedNetworkTopology topology)
specifier|static
name|void
name|removeIpHosts
parameter_list|(
name|LoggedNetworkTopology
name|topology
parameter_list|)
block|{
for|for
control|(
name|Iterator
argument_list|<
name|LoggedNetworkTopology
argument_list|>
name|rackIt
init|=
name|topology
operator|.
name|getChildren
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|rackIt
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|LoggedNetworkTopology
name|rack
init|=
name|rackIt
operator|.
name|next
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|LoggedNetworkTopology
argument_list|>
name|nodes
init|=
name|rack
operator|.
name|getChildren
argument_list|()
decl_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|LoggedNetworkTopology
argument_list|>
name|it
init|=
name|nodes
operator|.
name|iterator
argument_list|()
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|LoggedNetworkTopology
name|node
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|isIPAddress
argument_list|(
name|node
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
name|it
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|nodes
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|rackIt
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
block|}
DECL|field|IP_PATTERN
specifier|static
name|Pattern
name|IP_PATTERN
decl_stmt|;
static|static
block|{
comment|// 0-255
name|String
name|IPV4BK1
init|=
literal|"(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)"
decl_stmt|;
comment|// .b.c.d - where b/c/d are 0-255, and optionally adding two more
comment|// backslashes before each period
name|String
name|IPV4BKN
init|=
literal|"(?:\\\\?\\."
operator|+
name|IPV4BK1
operator|+
literal|"){3}"
decl_stmt|;
name|String
name|IPV4_PATTERN
init|=
name|IPV4BK1
operator|+
name|IPV4BKN
decl_stmt|;
comment|// first hexadecimal number
name|String
name|IPV6BK1
init|=
literal|"(?:[0-9a-fA-F]{1,4})"
decl_stmt|;
comment|// remaining 7 hexadecimal numbers, each preceded with ":".
name|String
name|IPV6BKN
init|=
literal|"(?::"
operator|+
name|IPV6BK1
operator|+
literal|"){7}"
decl_stmt|;
name|String
name|IPV6_PATTERN
init|=
name|IPV6BK1
operator|+
name|IPV6BKN
decl_stmt|;
name|IP_PATTERN
operator|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"^(?:"
operator|+
name|IPV4_PATTERN
operator|+
literal|"|"
operator|+
name|IPV6_PATTERN
operator|+
literal|")$"
argument_list|)
expr_stmt|;
block|}
DECL|method|isIPAddress (String hostname)
specifier|static
name|boolean
name|isIPAddress
parameter_list|(
name|String
name|hostname
parameter_list|)
block|{
return|return
name|IP_PATTERN
operator|.
name|matcher
argument_list|(
name|hostname
argument_list|)
operator|.
name|matches
argument_list|()
return|;
block|}
DECL|method|setStaticMapping (LoggedNetworkTopology topology)
specifier|static
name|void
name|setStaticMapping
parameter_list|(
name|LoggedNetworkTopology
name|topology
parameter_list|)
block|{
for|for
control|(
name|LoggedNetworkTopology
name|rack
range|:
name|topology
operator|.
name|getChildren
argument_list|()
control|)
block|{
for|for
control|(
name|LoggedNetworkTopology
name|node
range|:
name|rack
operator|.
name|getChildren
argument_list|()
control|)
block|{
name|StaticMapping
operator|.
name|addNodeToRack
argument_list|(
name|node
operator|.
name|getName
argument_list|()
argument_list|,
operator|new
name|RackNode
argument_list|(
name|rack
operator|.
name|getName
argument_list|()
argument_list|,
literal|1
argument_list|)
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_class

end_unit

