begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.mapred
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|IdentityHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|ClusterMetrics
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|JobID
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|JobStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|protocol
operator|.
name|ClientProtocol
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|tools
operator|.
name|rumen
operator|.
name|JobStory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|tools
operator|.
name|rumen
operator|.
name|JobStoryProducer
import|;
end_import

begin_comment
comment|/**  * Class that simulates a job client. It's main functionality is to submit jobs  * to the simulation engine, and shutdown the simulation engine if the job  * producer runs out of jobs.  */
end_comment

begin_class
DECL|class|SimulatorJobClient
specifier|public
class|class
name|SimulatorJobClient
implements|implements
name|SimulatorEventListener
block|{
DECL|class|JobSketchInfo
specifier|protected
specifier|static
class|class
name|JobSketchInfo
block|{
DECL|field|numMaps
specifier|protected
name|int
name|numMaps
decl_stmt|;
DECL|field|numReduces
specifier|protected
name|int
name|numReduces
decl_stmt|;
DECL|method|JobSketchInfo (int numMaps, int numReduces)
name|JobSketchInfo
parameter_list|(
name|int
name|numMaps
parameter_list|,
name|int
name|numReduces
parameter_list|)
block|{
name|this
operator|.
name|numMaps
operator|=
name|numMaps
expr_stmt|;
name|this
operator|.
name|numReduces
operator|=
name|numReduces
expr_stmt|;
block|}
block|}
DECL|field|jobTracker
specifier|private
specifier|final
name|ClientProtocol
name|jobTracker
decl_stmt|;
DECL|field|jobStoryProducer
specifier|private
specifier|final
name|JobStoryProducer
name|jobStoryProducer
decl_stmt|;
DECL|field|submissionPolicy
specifier|private
specifier|final
name|SimulatorJobSubmissionPolicy
name|submissionPolicy
decl_stmt|;
DECL|field|LOAD_PROB_INTERVAL_START
specifier|private
specifier|static
specifier|final
name|int
name|LOAD_PROB_INTERVAL_START
init|=
literal|1000
decl_stmt|;
DECL|field|LOAD_PROB_INTERVAL_MAX
specifier|private
specifier|static
specifier|final
name|int
name|LOAD_PROB_INTERVAL_MAX
init|=
literal|320000
decl_stmt|;
DECL|field|loadProbingInterval
specifier|private
name|int
name|loadProbingInterval
init|=
name|LOAD_PROB_INTERVAL_START
decl_stmt|;
comment|/**    * The minimum ratio between pending+running map tasks (aka. incomplete map    * tasks) and cluster map slot capacity for us to consider the cluster is    * overloaded. For running maps, we only count them partially. Namely, a 40%    * completed map is counted as 0.6 map tasks in our calculation.    */
DECL|field|OVERLAOD_MAPTASK_MAPSLOT_RATIO
specifier|private
specifier|static
specifier|final
name|float
name|OVERLAOD_MAPTASK_MAPSLOT_RATIO
init|=
literal|2.0f
decl_stmt|;
comment|/**    * Keep track of the in-flight load-probing event.    */
DECL|field|inFlightLPE
specifier|private
name|LoadProbingEvent
name|inFlightLPE
init|=
literal|null
decl_stmt|;
comment|/**    * We do not have handle to the SimulatorEventQueue, and thus cannot cancel    * events directly. Instead, we keep an identity-map (should have been an    * identity-set except that JDK does not provide an identity-set) to skip    * events that are cancelled.    */
DECL|field|cancelledLPE
specifier|private
name|Map
argument_list|<
name|LoadProbingEvent
argument_list|,
name|Boolean
argument_list|>
name|cancelledLPE
init|=
operator|new
name|IdentityHashMap
argument_list|<
name|LoadProbingEvent
argument_list|,
name|Boolean
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|runningJobs
specifier|private
name|Map
argument_list|<
name|JobID
argument_list|,
name|JobSketchInfo
argument_list|>
name|runningJobs
init|=
operator|new
name|LinkedHashMap
argument_list|<
name|JobID
argument_list|,
name|JobSketchInfo
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|noMoreJobs
specifier|private
name|boolean
name|noMoreJobs
init|=
literal|false
decl_stmt|;
DECL|field|nextJob
specifier|private
name|JobStory
name|nextJob
decl_stmt|;
comment|/**    * Constructor.    *     * @param jobTracker    *          The job tracker where we submit job to. Note that the {@link    *          SimulatorJobClient} interacts with the JobTracker through the    *          {@link ClientProtocol}.    * @param jobStoryProducer    * @param submissionPolicy How should we submit jobs to the JobTracker?    */
DECL|method|SimulatorJobClient (ClientProtocol jobTracker, JobStoryProducer jobStoryProducer, SimulatorJobSubmissionPolicy submissionPolicy)
specifier|public
name|SimulatorJobClient
parameter_list|(
name|ClientProtocol
name|jobTracker
parameter_list|,
name|JobStoryProducer
name|jobStoryProducer
parameter_list|,
name|SimulatorJobSubmissionPolicy
name|submissionPolicy
parameter_list|)
block|{
name|this
operator|.
name|jobTracker
operator|=
name|jobTracker
expr_stmt|;
name|this
operator|.
name|jobStoryProducer
operator|=
name|jobStoryProducer
expr_stmt|;
name|this
operator|.
name|submissionPolicy
operator|=
name|submissionPolicy
expr_stmt|;
block|}
comment|/**    * Constructor.    *     * @param jobTracker    *          The job tracker where we submit job to. Note that the {@link    *          SimulatorJobClient} interacts with the JobTracker through the    *          {@link ClientProtocol}.    * @param jobStoryProducer    */
DECL|method|SimulatorJobClient (ClientProtocol jobTracker, JobStoryProducer jobStoryProducer)
specifier|public
name|SimulatorJobClient
parameter_list|(
name|ClientProtocol
name|jobTracker
parameter_list|,
name|JobStoryProducer
name|jobStoryProducer
parameter_list|)
block|{
name|this
argument_list|(
name|jobTracker
argument_list|,
name|jobStoryProducer
argument_list|,
name|SimulatorJobSubmissionPolicy
operator|.
name|REPLAY
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|init (long when)
specifier|public
name|List
argument_list|<
name|SimulatorEvent
argument_list|>
name|init
parameter_list|(
name|long
name|when
parameter_list|)
throws|throws
name|IOException
block|{
name|JobStory
name|job
init|=
name|jobStoryProducer
operator|.
name|getNextJob
argument_list|()
decl_stmt|;
if|if
condition|(
name|submissionPolicy
operator|==
name|SimulatorJobSubmissionPolicy
operator|.
name|REPLAY
operator|&&
name|job
operator|.
name|getSubmissionTime
argument_list|()
operator|!=
name|when
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Inconsistent submission time for the first job: "
operator|+
name|when
operator|+
literal|" != "
operator|+
name|job
operator|.
name|getSubmissionTime
argument_list|()
operator|+
literal|"."
argument_list|)
throw|;
block|}
name|JobSubmissionEvent
name|event
init|=
operator|new
name|JobSubmissionEvent
argument_list|(
name|this
argument_list|,
name|when
argument_list|,
name|job
argument_list|)
decl_stmt|;
if|if
condition|(
name|submissionPolicy
operator|!=
name|SimulatorJobSubmissionPolicy
operator|.
name|STRESS
condition|)
block|{
return|return
name|Collections
operator|.
expr|<
name|SimulatorEvent
operator|>
name|singletonList
argument_list|(
name|event
argument_list|)
return|;
block|}
else|else
block|{
name|ArrayList
argument_list|<
name|SimulatorEvent
argument_list|>
name|ret
init|=
operator|new
name|ArrayList
argument_list|<
name|SimulatorEvent
argument_list|>
argument_list|(
literal|2
argument_list|)
decl_stmt|;
name|ret
operator|.
name|add
argument_list|(
name|event
argument_list|)
expr_stmt|;
name|inFlightLPE
operator|=
operator|new
name|LoadProbingEvent
argument_list|(
name|this
argument_list|,
name|when
operator|+
name|loadProbingInterval
argument_list|)
expr_stmt|;
name|ret
operator|.
name|add
argument_list|(
name|inFlightLPE
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
block|}
comment|/**    * Doing exponential back-off probing because load probing could be pretty    * expensive if we have many pending jobs.    *     * @param overloaded Is the job tracker currently overloaded?    */
DECL|method|adjustLoadProbingInterval (boolean overloaded)
specifier|private
name|void
name|adjustLoadProbingInterval
parameter_list|(
name|boolean
name|overloaded
parameter_list|)
block|{
if|if
condition|(
name|overloaded
condition|)
block|{
comment|/**        * We should only extend LPE interval when there is no in-flight LPE.        */
if|if
condition|(
name|inFlightLPE
operator|==
literal|null
condition|)
block|{
name|loadProbingInterval
operator|=
name|Math
operator|.
name|min
argument_list|(
name|loadProbingInterval
operator|*
literal|2
argument_list|,
name|LOAD_PROB_INTERVAL_MAX
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|loadProbingInterval
operator|=
name|LOAD_PROB_INTERVAL_START
expr_stmt|;
block|}
block|}
comment|/**    * We try to use some light-weight mechanism to determine cluster load.    * @return Whether, from job client perspective, the cluster is overloaded.    */
DECL|method|isOverloaded (long now)
specifier|private
name|boolean
name|isOverloaded
parameter_list|(
name|long
name|now
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
name|ClusterMetrics
name|clusterMetrics
init|=
name|jobTracker
operator|.
name|getClusterMetrics
argument_list|()
decl_stmt|;
comment|// If there are more jobs than number of task trackers, we assume the
comment|// cluster is overloaded. This is to bound the memory usage of the
comment|// simulator job tracker, in situations where we have jobs with small
comment|// number of map tasks and large number of reduce tasks.
if|if
condition|(
name|runningJobs
operator|.
name|size
argument_list|()
operator|>=
name|clusterMetrics
operator|.
name|getTaskTrackerCount
argument_list|()
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|printf
argument_list|(
literal|"%d Overloaded is %s: "
operator|+
literal|"#runningJobs>= taskTrackerCount (%d>= %d)\n"
argument_list|,
name|now
argument_list|,
name|Boolean
operator|.
name|TRUE
operator|.
name|toString
argument_list|()
argument_list|,
name|runningJobs
operator|.
name|size
argument_list|()
argument_list|,
name|clusterMetrics
operator|.
name|getTaskTrackerCount
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
name|float
name|incompleteMapTasks
init|=
literal|0
decl_stmt|;
comment|// include pending& running map tasks.
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|JobID
argument_list|,
name|JobSketchInfo
argument_list|>
name|entry
range|:
name|runningJobs
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|JobStatus
name|jobStatus
init|=
name|jobTracker
operator|.
name|getJobStatus
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
decl_stmt|;
name|incompleteMapTasks
operator|+=
operator|(
literal|1
operator|-
name|Math
operator|.
name|min
argument_list|(
name|jobStatus
operator|.
name|getMapProgress
argument_list|()
argument_list|,
literal|1.0
argument_list|)
operator|)
operator|*
name|entry
operator|.
name|getValue
argument_list|()
operator|.
name|numMaps
expr_stmt|;
block|}
name|boolean
name|overloaded
init|=
name|incompleteMapTasks
operator|>
name|OVERLAOD_MAPTASK_MAPSLOT_RATIO
operator|*
name|clusterMetrics
operator|.
name|getMapSlotCapacity
argument_list|()
decl_stmt|;
name|String
name|relOp
init|=
operator|(
name|overloaded
operator|)
condition|?
literal|">"
else|:
literal|"<="
decl_stmt|;
name|System
operator|.
name|out
operator|.
name|printf
argument_list|(
literal|"%d Overloaded is %s: "
operator|+
literal|"incompleteMapTasks %s %.1f*mapSlotCapacity (%.1f %s %.1f*%d)\n"
argument_list|,
name|now
argument_list|,
name|Boolean
operator|.
name|toString
argument_list|(
name|overloaded
argument_list|)
argument_list|,
name|relOp
argument_list|,
name|OVERLAOD_MAPTASK_MAPSLOT_RATIO
argument_list|,
name|incompleteMapTasks
argument_list|,
name|relOp
argument_list|,
name|OVERLAOD_MAPTASK_MAPSLOT_RATIO
argument_list|,
name|clusterMetrics
operator|.
name|getMapSlotCapacity
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|overloaded
return|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"InterruptedException"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**    * Handles a simulation event that is either JobSubmissionEvent or     * JobCompletionEvent.    *    * @param event SimulatorEvent to respond to    * @return list of events generated in response    */
annotation|@
name|Override
DECL|method|accept (SimulatorEvent event)
specifier|public
name|List
argument_list|<
name|SimulatorEvent
argument_list|>
name|accept
parameter_list|(
name|SimulatorEvent
name|event
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|event
operator|instanceof
name|JobSubmissionEvent
condition|)
block|{
return|return
name|processJobSubmissionEvent
argument_list|(
operator|(
name|JobSubmissionEvent
operator|)
name|event
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|event
operator|instanceof
name|JobCompleteEvent
condition|)
block|{
return|return
name|processJobCompleteEvent
argument_list|(
operator|(
name|JobCompleteEvent
operator|)
name|event
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|event
operator|instanceof
name|LoadProbingEvent
condition|)
block|{
return|return
name|processLoadProbingEvent
argument_list|(
operator|(
name|LoadProbingEvent
operator|)
name|event
argument_list|)
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"unknown event type: "
operator|+
name|event
operator|.
name|getClass
argument_list|()
argument_list|)
throw|;
block|}
block|}
comment|/**    * Responds to a job submission event by submitting the job to the     * job tracker. If serializeJobSubmissions is true, it postpones the    * submission until after the previous job finished instead.    *     * @param submitEvent the submission event to respond to    */
DECL|method|processJobSubmissionEvent ( JobSubmissionEvent submitEvent)
specifier|private
name|List
argument_list|<
name|SimulatorEvent
argument_list|>
name|processJobSubmissionEvent
parameter_list|(
name|JobSubmissionEvent
name|submitEvent
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Submit job
name|JobStatus
name|status
init|=
literal|null
decl_stmt|;
name|JobStory
name|story
init|=
name|submitEvent
operator|.
name|getJob
argument_list|()
decl_stmt|;
try|try
block|{
name|status
operator|=
name|submitJob
argument_list|(
name|story
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|e
argument_list|)
throw|;
block|}
name|runningJobs
operator|.
name|put
argument_list|(
name|status
operator|.
name|getJobID
argument_list|()
argument_list|,
operator|new
name|JobSketchInfo
argument_list|(
name|story
operator|.
name|getNumberMaps
argument_list|()
argument_list|,
name|story
operator|.
name|getNumberReduces
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Job "
operator|+
name|status
operator|.
name|getJobID
argument_list|()
operator|+
literal|" is submitted at "
operator|+
name|submitEvent
operator|.
name|getTimeStamp
argument_list|()
argument_list|)
expr_stmt|;
comment|// Find the next job to submit
name|nextJob
operator|=
name|jobStoryProducer
operator|.
name|getNextJob
argument_list|()
expr_stmt|;
if|if
condition|(
name|nextJob
operator|==
literal|null
condition|)
block|{
name|noMoreJobs
operator|=
literal|true
expr_stmt|;
return|return
name|SimulatorEngine
operator|.
name|EMPTY_EVENTS
return|;
block|}
elseif|else
if|if
condition|(
name|submissionPolicy
operator|==
name|SimulatorJobSubmissionPolicy
operator|.
name|REPLAY
condition|)
block|{
comment|// enqueue next submission event
return|return
name|Collections
operator|.
expr|<
name|SimulatorEvent
operator|>
name|singletonList
argument_list|(
operator|new
name|JobSubmissionEvent
argument_list|(
name|this
argument_list|,
name|nextJob
operator|.
name|getSubmissionTime
argument_list|()
argument_list|,
name|nextJob
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|submissionPolicy
operator|==
name|SimulatorJobSubmissionPolicy
operator|.
name|STRESS
condition|)
block|{
return|return
name|checkLoadAndSubmitJob
argument_list|(
name|submitEvent
operator|.
name|getTimeStamp
argument_list|()
argument_list|)
return|;
block|}
return|return
name|SimulatorEngine
operator|.
name|EMPTY_EVENTS
return|;
block|}
comment|/**    * Handles a job completion event.     *     * @param jobCompleteEvent the submission event to respond to    * @throws IOException     */
DECL|method|processJobCompleteEvent ( JobCompleteEvent jobCompleteEvent)
specifier|private
name|List
argument_list|<
name|SimulatorEvent
argument_list|>
name|processJobCompleteEvent
parameter_list|(
name|JobCompleteEvent
name|jobCompleteEvent
parameter_list|)
throws|throws
name|IOException
block|{
name|JobStatus
name|jobStatus
init|=
name|jobCompleteEvent
operator|.
name|getJobStatus
argument_list|()
decl_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Job "
operator|+
name|jobStatus
operator|.
name|getJobID
argument_list|()
operator|+
literal|" completed at "
operator|+
name|jobCompleteEvent
operator|.
name|getTimeStamp
argument_list|()
operator|+
literal|" with status: "
operator|+
name|jobStatus
operator|.
name|getState
argument_list|()
operator|+
literal|" runtime: "
operator|+
operator|(
name|jobCompleteEvent
operator|.
name|getTimeStamp
argument_list|()
operator|-
name|jobStatus
operator|.
name|getStartTime
argument_list|()
operator|)
argument_list|)
expr_stmt|;
name|runningJobs
operator|.
name|remove
argument_list|(
name|jobCompleteEvent
operator|.
name|getJobStatus
argument_list|()
operator|.
name|getJobID
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|noMoreJobs
operator|&&
name|runningJobs
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|jobCompleteEvent
operator|.
name|getEngine
argument_list|()
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|noMoreJobs
condition|)
block|{
if|if
condition|(
name|submissionPolicy
operator|==
name|SimulatorJobSubmissionPolicy
operator|.
name|SERIAL
condition|)
block|{
name|long
name|submissionTime
init|=
name|jobCompleteEvent
operator|.
name|getTimeStamp
argument_list|()
operator|+
literal|1
decl_stmt|;
name|JobStory
name|story
init|=
operator|new
name|SimulatorJobStory
argument_list|(
name|nextJob
argument_list|,
name|submissionTime
argument_list|)
decl_stmt|;
return|return
name|Collections
operator|.
expr|<
name|SimulatorEvent
operator|>
name|singletonList
argument_list|(
operator|new
name|JobSubmissionEvent
argument_list|(
name|this
argument_list|,
name|submissionTime
argument_list|,
name|story
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|submissionPolicy
operator|==
name|SimulatorJobSubmissionPolicy
operator|.
name|STRESS
condition|)
block|{
return|return
name|checkLoadAndSubmitJob
argument_list|(
name|jobCompleteEvent
operator|.
name|getTimeStamp
argument_list|()
argument_list|)
return|;
block|}
block|}
return|return
name|SimulatorEngine
operator|.
name|EMPTY_EVENTS
return|;
block|}
comment|/**    * Check whether job tracker is overloaded. If not, submit the next job.    * Pre-condition: noMoreJobs == false    * @return A list of {@link SimulatorEvent}'s as the follow-up actions.    */
DECL|method|checkLoadAndSubmitJob (long now)
specifier|private
name|List
argument_list|<
name|SimulatorEvent
argument_list|>
name|checkLoadAndSubmitJob
parameter_list|(
name|long
name|now
parameter_list|)
throws|throws
name|IOException
block|{
name|List
argument_list|<
name|SimulatorEvent
argument_list|>
name|ret
init|=
operator|new
name|ArrayList
argument_list|<
name|SimulatorEvent
argument_list|>
argument_list|(
literal|2
argument_list|)
decl_stmt|;
name|boolean
name|overloaded
init|=
name|isOverloaded
argument_list|(
name|now
argument_list|)
decl_stmt|;
name|adjustLoadProbingInterval
argument_list|(
name|overloaded
argument_list|)
expr_stmt|;
if|if
condition|(
name|inFlightLPE
operator|!=
literal|null
operator|&&
operator|(
name|inFlightLPE
operator|.
name|getTimeStamp
argument_list|()
operator|>
name|now
operator|+
name|loadProbingInterval
operator|)
condition|)
block|{
name|cancelledLPE
operator|.
name|put
argument_list|(
name|inFlightLPE
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|inFlightLPE
operator|=
literal|null
expr_stmt|;
block|}
if|if
condition|(
name|inFlightLPE
operator|==
literal|null
condition|)
block|{
name|inFlightLPE
operator|=
operator|new
name|LoadProbingEvent
argument_list|(
name|this
argument_list|,
name|now
operator|+
name|loadProbingInterval
argument_list|)
expr_stmt|;
name|ret
operator|.
name|add
argument_list|(
name|inFlightLPE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|overloaded
condition|)
block|{
name|long
name|submissionTime
init|=
name|now
operator|+
literal|1
decl_stmt|;
name|JobStory
name|story
init|=
operator|new
name|SimulatorJobStory
argument_list|(
name|nextJob
argument_list|,
name|submissionTime
argument_list|)
decl_stmt|;
name|ret
operator|.
name|add
argument_list|(
operator|new
name|JobSubmissionEvent
argument_list|(
name|this
argument_list|,
name|submissionTime
argument_list|,
name|story
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
comment|/**    * Handles a load probing event. If cluster is not overloaded, submit a new job.    *     * @param loadProbingEvent the load probing event    */
DECL|method|processLoadProbingEvent ( LoadProbingEvent loadProbingEvent)
specifier|private
name|List
argument_list|<
name|SimulatorEvent
argument_list|>
name|processLoadProbingEvent
parameter_list|(
name|LoadProbingEvent
name|loadProbingEvent
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|cancelledLPE
operator|.
name|containsKey
argument_list|(
name|loadProbingEvent
argument_list|)
condition|)
block|{
name|cancelledLPE
operator|.
name|remove
argument_list|(
name|loadProbingEvent
argument_list|)
expr_stmt|;
return|return
name|SimulatorEngine
operator|.
name|EMPTY_EVENTS
return|;
block|}
assert|assert
operator|(
name|loadProbingEvent
operator|==
name|inFlightLPE
operator|)
assert|;
name|inFlightLPE
operator|=
literal|null
expr_stmt|;
if|if
condition|(
name|noMoreJobs
condition|)
block|{
return|return
name|SimulatorEngine
operator|.
name|EMPTY_EVENTS
return|;
block|}
return|return
name|checkLoadAndSubmitJob
argument_list|(
name|loadProbingEvent
operator|.
name|getTimeStamp
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"deprecation"
argument_list|)
DECL|method|submitJob (JobStory job)
specifier|private
name|JobStatus
name|submitJob
parameter_list|(
name|JobStory
name|job
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
comment|// honor the JobID from JobStory first.
name|JobID
name|jobId
init|=
name|job
operator|.
name|getJobID
argument_list|()
decl_stmt|;
if|if
condition|(
name|jobId
operator|==
literal|null
condition|)
block|{
comment|// If not available, obtain JobID from JobTracker.
name|jobId
operator|=
name|jobTracker
operator|.
name|getNewJobID
argument_list|()
expr_stmt|;
block|}
name|SimulatorJobCache
operator|.
name|put
argument_list|(
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|JobID
operator|.
name|downgrade
argument_list|(
name|jobId
argument_list|)
argument_list|,
name|job
argument_list|)
expr_stmt|;
return|return
name|jobTracker
operator|.
name|submitJob
argument_list|(
name|jobId
argument_list|,
literal|"dummy-path"
argument_list|,
literal|null
argument_list|)
return|;
block|}
block|}
end_class

end_unit

