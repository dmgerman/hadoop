begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.mapred
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Random
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|TaskStatus
operator|.
name|Phase
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|TaskStatus
operator|.
name|State
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|tools
operator|.
name|rumen
operator|.
name|TaskAttemptInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|tools
operator|.
name|rumen
operator|.
name|ReduceTaskAttemptInfo
import|;
end_import

begin_comment
comment|// Explicitly use the new api, older o.a.h.mapred.TaskAttemptID is deprecated
end_comment

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|TaskAttemptID
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_comment
comment|/**  * This class simulates a {@link TaskTracker}. Its main purpose is to call heartbeat()  * of the simulated Job Tracker with apropriately updated statuses of the   * tasks assigned to it.  *  * The events emitted and consumed are HeartbeatEvent and   * TaskAttemptCompletionEvent .  *  * Internal naming convention: accept() dispatches simulation events to   * process*Event() methods. heartbeat() dispactches task tracker actions to   * handle*Action() methods.  */
end_comment

begin_class
DECL|class|SimulatorTaskTracker
specifier|public
class|class
name|SimulatorTaskTracker
implements|implements
name|SimulatorEventListener
block|{
comment|/** Default host name. */
DECL|field|DEFAULT_HOST_NAME
specifier|public
specifier|static
name|String
name|DEFAULT_HOST_NAME
init|=
literal|"unknown"
decl_stmt|;
comment|/** Default task tracker name. */
DECL|field|DEFAULT_TRACKER_NAME
specifier|public
specifier|static
name|String
name|DEFAULT_TRACKER_NAME
init|=
literal|"tracker_unknown:localhost/127.0.0.1:10000"
decl_stmt|;
comment|/** Default number of map slots per task tracker. */
DECL|field|DEFAULT_MAP_SLOTS
specifier|public
specifier|static
specifier|final
name|int
name|DEFAULT_MAP_SLOTS
init|=
literal|2
decl_stmt|;
comment|/** Default number of reduce slots per task tracker. */
DECL|field|DEFAULT_REDUCE_SLOTS
specifier|public
specifier|static
specifier|final
name|int
name|DEFAULT_REDUCE_SLOTS
init|=
literal|2
decl_stmt|;
comment|/** Default range of heartbeat response perturbations + 1 in milliseconds. */
DECL|field|DEFAULT_HEARTBEAT_FUZZ
specifier|public
specifier|static
specifier|final
name|int
name|DEFAULT_HEARTBEAT_FUZZ
init|=
literal|11
decl_stmt|;
comment|/** The name of the task tracker. */
DECL|field|taskTrackerName
specifier|protected
specifier|final
name|String
name|taskTrackerName
decl_stmt|;
comment|/** The name of the host the task tracker is running on. */
DECL|field|hostName
specifier|protected
specifier|final
name|String
name|hostName
decl_stmt|;
comment|/** The http port the simulated task tracker reports to the jobtracker. */
DECL|field|httpPort
specifier|protected
specifier|final
name|int
name|httpPort
init|=
literal|80
decl_stmt|;
comment|/** Number of map slots. */
DECL|field|maxMapSlots
specifier|protected
specifier|final
name|int
name|maxMapSlots
decl_stmt|;
comment|/** Number of reduce slots. */
DECL|field|maxReduceSlots
specifier|protected
specifier|final
name|int
name|maxReduceSlots
decl_stmt|;
comment|/** The job tracker this task tracker is a slave of. */
DECL|field|jobTracker
specifier|protected
specifier|final
name|InterTrackerProtocol
name|jobTracker
decl_stmt|;
comment|/**    * State of and bookkeeping information for all tasks assigned to the task     * tracker. Contains all the information about running or completed but    * not yet reported tasks. We manage it in a mark& sweep garbage collector     * manner. We insert tasks on launch, mark them on completion, and remove    * completed tasks at heartbeat() reports.    * We use LinkedHashMap instead of HashMap so that the order of iteration    * is deterministic.    */
DECL|field|tasks
specifier|protected
name|Map
argument_list|<
name|TaskAttemptID
argument_list|,
name|SimulatorTaskInProgress
argument_list|>
name|tasks
init|=
operator|new
name|LinkedHashMap
argument_list|<
name|TaskAttemptID
argument_list|,
name|SimulatorTaskInProgress
argument_list|>
argument_list|()
decl_stmt|;
comment|/**     * Number of map slots allocated to tasks in RUNNING state on this task     * tracker. Must be in sync with the tasks map above.     */
DECL|field|usedMapSlots
specifier|private
name|int
name|usedMapSlots
init|=
literal|0
decl_stmt|;
comment|/**    * Number of reduce slots allocated to tasks in RUNNING state on this task    * tracker. Must be in sync with the tasks map above.    */
DECL|field|usedReduceSlots
specifier|private
name|int
name|usedReduceSlots
init|=
literal|0
decl_stmt|;
comment|/**    * True if the jobTracker.heartbeat() call to be made is the first one.    * We need this to mimick the InterTrackerProtocol properly.    */
DECL|field|firstHeartbeat
specifier|private
name|boolean
name|firstHeartbeat
init|=
literal|true
decl_stmt|;
comment|// last heartbeat response received
DECL|field|heartbeatResponseId
specifier|private
name|short
name|heartbeatResponseId
init|=
operator|-
literal|1
decl_stmt|;
comment|/**    * Task attempt ids for which TaskAttemptCompletionEvent was created but the     * task attempt got killed.    * We use LinkedHashSet to get deterministic iterators, should ever use one.    */
DECL|field|orphanTaskCompletions
specifier|private
name|Set
argument_list|<
name|TaskAttemptID
argument_list|>
name|orphanTaskCompletions
init|=
operator|new
name|LinkedHashSet
argument_list|<
name|TaskAttemptID
argument_list|>
argument_list|()
decl_stmt|;
comment|/** The log object to send our messages to; only used for debugging. */
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|SimulatorTaskTracker
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/**     * Number of milliseconds to perturb the requested heartbeat intervals with    * to simulate network latency, etc.    * If<= 1 then there is no pertrubation. This option is also useful for     * testing.    * If> 1 then hearbeats are perturbed with a uniformly random integer in     * (-heartbeatIntervalFuzz,+heartbeatIntervalFuzz), not including     * the bounds.    */
DECL|field|heartbeatIntervalFuzz
specifier|private
name|int
name|heartbeatIntervalFuzz
init|=
operator|-
literal|1
decl_stmt|;
comment|/** Used for randomly perturbing the heartbeat timings. */
DECL|field|random
specifier|private
name|Random
name|random
decl_stmt|;
comment|/**    * Constructs a task tracker.     *    * @param jobTracker the SimulatorJobTracker we talk to    * @param conf Configuration object. Parameters read are:    *<dl>    *<dt> mumak.tasktracker.tracker.name<dd>     *      the task tracker name to report, otherwise unused    *<dt> mumak.tasktracker.host.name<dd>     *      the host name to report, otherwise unused    *<dt> mapred.tasktracker.map.tasks.maximum<dd>     *      the number of map slots    *<dt> mapred.tasktracker.reduce.tasks.maximum<dd>     *      the number of reduce slots    *<dt> mumak.tasktracker.heartbeat.fuzz<dd>    *      Perturbation for the heartbeats.     *      None if<= 1 else perturbations are uniformly randomly generated     *      in (-heartbeat.fuzz,+heartbeat.fuzz), not including the bounds.    *</dl>    */
DECL|method|SimulatorTaskTracker (InterTrackerProtocol jobTracker, Configuration conf)
specifier|public
name|SimulatorTaskTracker
parameter_list|(
name|InterTrackerProtocol
name|jobTracker
parameter_list|,
name|Configuration
name|conf
parameter_list|)
block|{
name|this
operator|.
name|taskTrackerName
operator|=
name|conf
operator|.
name|get
argument_list|(
literal|"mumak.tasktracker.tracker.name"
argument_list|,
name|DEFAULT_TRACKER_NAME
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"SimulatorTaskTracker constructor, taskTrackerName="
operator|+
name|taskTrackerName
argument_list|)
expr_stmt|;
name|this
operator|.
name|jobTracker
operator|=
name|jobTracker
expr_stmt|;
name|this
operator|.
name|hostName
operator|=
name|conf
operator|.
name|get
argument_list|(
literal|"mumak.tasktracker.host.name"
argument_list|,
name|DEFAULT_HOST_NAME
argument_list|)
expr_stmt|;
name|this
operator|.
name|maxMapSlots
operator|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"mapred.tasktracker.map.tasks.maximum"
argument_list|,
name|DEFAULT_MAP_SLOTS
argument_list|)
expr_stmt|;
name|this
operator|.
name|maxReduceSlots
operator|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"mapred.tasktracker.reduce.tasks.maximum"
argument_list|,
name|DEFAULT_REDUCE_SLOTS
argument_list|)
expr_stmt|;
name|this
operator|.
name|heartbeatIntervalFuzz
operator|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"mumak.tasktracker.heartbeat.fuzz"
argument_list|,
name|DEFAULT_HEARTBEAT_FUZZ
argument_list|)
expr_stmt|;
name|long
name|seed
init|=
name|conf
operator|.
name|getLong
argument_list|(
literal|"mumak.tasktracker.random.seed"
argument_list|,
name|System
operator|.
name|nanoTime
argument_list|()
argument_list|)
decl_stmt|;
name|this
operator|.
name|random
operator|=
operator|new
name|Random
argument_list|(
name|seed
argument_list|)
expr_stmt|;
block|}
comment|/**    * Processes a simulation event.     *    * @param event the event to process, should be an instance of HeartbeatEvent    *        or TaskAttemptCompletionEvent    * @return the list of new events generated in response    */
annotation|@
name|Override
DECL|method|accept (SimulatorEvent event)
specifier|public
name|List
argument_list|<
name|SimulatorEvent
argument_list|>
name|accept
parameter_list|(
name|SimulatorEvent
name|event
parameter_list|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Accepted event "
operator|+
name|event
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|event
operator|instanceof
name|HeartbeatEvent
condition|)
block|{
return|return
name|processHeartbeatEvent
argument_list|(
operator|(
name|HeartbeatEvent
operator|)
name|event
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|event
operator|instanceof
name|TaskAttemptCompletionEvent
condition|)
block|{
return|return
name|processTaskAttemptCompletionEvent
argument_list|(
operator|(
name|TaskAttemptCompletionEvent
operator|)
name|event
argument_list|)
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Unhandled event "
operator|+
name|event
argument_list|)
throw|;
block|}
block|}
comment|/**    * Called once at the start of the simulation.    *    * @param when Time when the task tracker starts.    * @return the initial HeartbeatEvent for ourselves.    */
DECL|method|init (long when)
specifier|public
name|List
argument_list|<
name|SimulatorEvent
argument_list|>
name|init
parameter_list|(
name|long
name|when
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"TaskTracker starting up, current simulation time="
operator|+
name|when
argument_list|)
expr_stmt|;
return|return
name|Collections
operator|.
expr|<
name|SimulatorEvent
operator|>
name|singletonList
argument_list|(
operator|new
name|HeartbeatEvent
argument_list|(
name|this
argument_list|,
name|when
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Stops running a task attempt on the task tracker. It also updates the     * number of available slots accordingly.    *     * @param finalStatus the TaskStatus containing the task id and final     *        status of the task attempt. This rountine asserts a lot of the    *        finalStatus params, in case it is coming from a task attempt    *        completion event sent to ourselves. Only the run state, finish time,    *        and progress fields of the task attempt are updated.    * @param now Current simulation time, used for assert only    */
DECL|method|finishRunningTask (TaskStatus finalStatus, long now)
specifier|private
name|void
name|finishRunningTask
parameter_list|(
name|TaskStatus
name|finalStatus
parameter_list|,
name|long
name|now
parameter_list|)
block|{
name|TaskAttemptID
name|taskId
init|=
name|finalStatus
operator|.
name|getTaskID
argument_list|()
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Finishing running task id="
operator|+
name|taskId
operator|+
literal|", now="
operator|+
name|now
argument_list|)
expr_stmt|;
block|}
name|SimulatorTaskInProgress
name|tip
init|=
name|tasks
operator|.
name|get
argument_list|(
name|taskId
argument_list|)
decl_stmt|;
if|if
condition|(
name|tip
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Unknown task attempt "
operator|+
name|taskId
operator|+
literal|" completed"
argument_list|)
throw|;
block|}
name|TaskStatus
name|currentStatus
init|=
name|tip
operator|.
name|getTaskStatus
argument_list|()
decl_stmt|;
if|if
condition|(
name|currentStatus
operator|.
name|getRunState
argument_list|()
operator|!=
name|State
operator|.
name|RUNNING
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Task attempt to finish is not running: "
operator|+
name|tip
argument_list|)
throw|;
block|}
comment|// Check that finalStatus describes a task attempt that has just been
comment|// completed
name|State
name|finalRunState
init|=
name|finalStatus
operator|.
name|getRunState
argument_list|()
decl_stmt|;
if|if
condition|(
name|finalRunState
operator|!=
name|State
operator|.
name|SUCCEEDED
operator|&&
name|finalRunState
operator|!=
name|State
operator|.
name|FAILED
operator|&&
name|finalRunState
operator|!=
name|State
operator|.
name|KILLED
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Final run state for completed task can't be : "
operator|+
name|finalRunState
operator|+
literal|" "
operator|+
name|tip
argument_list|)
throw|;
block|}
if|if
condition|(
name|now
operator|!=
name|finalStatus
operator|.
name|getFinishTime
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Current time does not match task finish time: now="
operator|+
name|now
operator|+
literal|", finish="
operator|+
name|finalStatus
operator|.
name|getFinishTime
argument_list|()
argument_list|)
throw|;
block|}
if|if
condition|(
name|currentStatus
operator|.
name|getIsMap
argument_list|()
operator|!=
name|finalStatus
operator|.
name|getIsMap
argument_list|()
operator|||
name|currentStatus
operator|.
name|getNumSlots
argument_list|()
operator|!=
name|finalStatus
operator|.
name|getNumSlots
argument_list|()
operator|||
name|currentStatus
operator|.
name|getPhase
argument_list|()
operator|!=
name|finalStatus
operator|.
name|getPhase
argument_list|()
operator|||
name|currentStatus
operator|.
name|getStartTime
argument_list|()
operator|!=
name|finalStatus
operator|.
name|getStartTime
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Current status does not match final status"
argument_list|)
throw|;
block|}
comment|// We can't assert getShuffleFinishTime() and getSortFinishTime() for
comment|// reduces as those were unknown when the task attempt completion event
comment|// was created. We have not called setMapFinishTime() for maps either.
comment|// If we were really thorough we could update the progress of the task
comment|// and check if it is consistent with finalStatus.
comment|// If we've got this far it is safe to update the task status
name|currentStatus
operator|.
name|setRunState
argument_list|(
name|finalStatus
operator|.
name|getRunState
argument_list|()
argument_list|)
expr_stmt|;
name|currentStatus
operator|.
name|setFinishTime
argument_list|(
name|finalStatus
operator|.
name|getFinishTime
argument_list|()
argument_list|)
expr_stmt|;
name|currentStatus
operator|.
name|setProgress
argument_list|(
name|finalStatus
operator|.
name|getProgress
argument_list|()
argument_list|)
expr_stmt|;
comment|// and update the free slots
name|int
name|numSlots
init|=
name|currentStatus
operator|.
name|getNumSlots
argument_list|()
decl_stmt|;
if|if
condition|(
name|tip
operator|.
name|isMapTask
argument_list|()
condition|)
block|{
name|usedMapSlots
operator|-=
name|numSlots
expr_stmt|;
if|if
condition|(
name|usedMapSlots
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"TaskTracker reaches negative map slots: "
operator|+
name|usedMapSlots
argument_list|)
throw|;
block|}
block|}
else|else
block|{
name|usedReduceSlots
operator|-=
name|numSlots
expr_stmt|;
if|if
condition|(
name|usedReduceSlots
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"TaskTracker reaches negative reduce slots: "
operator|+
name|usedReduceSlots
argument_list|)
throw|;
block|}
block|}
block|}
comment|/**    * Records that a task attempt has completed. Ignores the event for tasks    * that got killed after the creation of the completion event.    *     * @param event the TaskAttemptCompletionEvent the tracker sent to itself    * @return the list of response events, empty    */
DECL|method|processTaskAttemptCompletionEvent ( TaskAttemptCompletionEvent event)
specifier|private
name|List
argument_list|<
name|SimulatorEvent
argument_list|>
name|processTaskAttemptCompletionEvent
parameter_list|(
name|TaskAttemptCompletionEvent
name|event
parameter_list|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Processing task attempt completion event"
operator|+
name|event
argument_list|)
expr_stmt|;
block|}
name|long
name|now
init|=
name|event
operator|.
name|getTimeStamp
argument_list|()
decl_stmt|;
name|TaskStatus
name|finalStatus
init|=
name|event
operator|.
name|getStatus
argument_list|()
decl_stmt|;
name|TaskAttemptID
name|taskID
init|=
name|finalStatus
operator|.
name|getTaskID
argument_list|()
decl_stmt|;
name|boolean
name|killedEarlier
init|=
name|orphanTaskCompletions
operator|.
name|remove
argument_list|(
name|taskID
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|killedEarlier
condition|)
block|{
name|finishRunningTask
argument_list|(
name|finalStatus
argument_list|,
name|now
argument_list|)
expr_stmt|;
block|}
return|return
name|SimulatorEngine
operator|.
name|EMPTY_EVENTS
return|;
block|}
comment|/**     * Creates a signal for itself marking the completion of a task attempt.     * It assumes that the task attempt hasn't made any progress in the user     * space code so far, i.e. it is called right at launch for map tasks and    * immediately after all maps completed for reduce tasks.    *    * @param tip the simulator task in progress    * @param now the current simulation time    * @return the TaskAttemptCompletionEvent we are sending to ourselves    */
DECL|method|createTaskAttemptCompletionEvent ( SimulatorTaskInProgress tip, long now)
specifier|private
name|TaskAttemptCompletionEvent
name|createTaskAttemptCompletionEvent
parameter_list|(
name|SimulatorTaskInProgress
name|tip
parameter_list|,
name|long
name|now
parameter_list|)
block|{
comment|// We need to clone() status as we modify and it goes into an Event
name|TaskStatus
name|status
init|=
operator|(
name|TaskStatus
operator|)
name|tip
operator|.
name|getTaskStatus
argument_list|()
operator|.
name|clone
argument_list|()
decl_stmt|;
name|long
name|delta
init|=
name|tip
operator|.
name|getUserSpaceRunTime
argument_list|()
decl_stmt|;
assert|assert
name|delta
operator|>=
literal|0
operator|:
literal|"TaskAttempt "
operator|+
name|tip
operator|.
name|getTaskStatus
argument_list|()
operator|.
name|getTaskID
argument_list|()
operator|+
literal|" has negative UserSpaceRunTime = "
operator|+
name|delta
assert|;
name|long
name|finishTime
init|=
name|now
operator|+
name|delta
decl_stmt|;
name|status
operator|.
name|setFinishTime
argument_list|(
name|finishTime
argument_list|)
expr_stmt|;
if|if
condition|(
name|tip
operator|.
name|isMapTask
argument_list|()
condition|)
block|{
name|status
operator|.
name|setMapFinishTime
argument_list|(
name|finishTime
argument_list|)
expr_stmt|;
block|}
name|status
operator|.
name|setProgress
argument_list|(
literal|1.0f
argument_list|)
expr_stmt|;
name|status
operator|.
name|setRunState
argument_list|(
name|tip
operator|.
name|getFinalRunState
argument_list|()
argument_list|)
expr_stmt|;
name|TaskAttemptCompletionEvent
name|event
init|=
operator|new
name|TaskAttemptCompletionEvent
argument_list|(
name|this
argument_list|,
name|status
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Created task attempt completion event "
operator|+
name|event
argument_list|)
expr_stmt|;
block|}
return|return
name|event
return|;
block|}
comment|/**    * Launches a task on the simulated task tracker.     *     * @param action SimulatorLaunchTaskAction sent by the job tracker    * @param now current simulation time    * @return new events generated, a TaskAttemptCompletionEvent for map    *         tasks, empty otherwise    */
DECL|method|handleSimulatorLaunchTaskAction ( SimulatorLaunchTaskAction action, long now)
specifier|private
name|List
argument_list|<
name|SimulatorEvent
argument_list|>
name|handleSimulatorLaunchTaskAction
parameter_list|(
name|SimulatorLaunchTaskAction
name|action
parameter_list|,
name|long
name|now
parameter_list|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Handling launch task action "
operator|+
name|action
argument_list|)
expr_stmt|;
block|}
comment|// First, create statuses and update used slots for map and reduce
comment|// task separately
name|Task
name|task
init|=
name|action
operator|.
name|getTask
argument_list|()
decl_stmt|;
name|TaskAttemptID
name|taskId
init|=
name|task
operator|.
name|getTaskID
argument_list|()
decl_stmt|;
if|if
condition|(
name|tasks
operator|.
name|containsKey
argument_list|(
name|taskId
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Multiple launch of task id ="
operator|+
name|taskId
argument_list|)
throw|;
block|}
comment|// Ctor of MapTaskStatus and ReduceTaskStatus need deprecated
comment|// o.a.h.mapred.TaskAttemptID, hence the downgrade
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|TaskAttemptID
name|taskIdOldApi
init|=
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|TaskAttemptID
operator|.
name|downgrade
argument_list|(
name|taskId
argument_list|)
decl_stmt|;
name|TaskStatus
name|status
decl_stmt|;
name|int
name|numSlotsRequired
init|=
name|task
operator|.
name|getNumSlotsRequired
argument_list|()
decl_stmt|;
name|Counters
name|emptyCounters
init|=
operator|new
name|Counters
argument_list|()
decl_stmt|;
if|if
condition|(
name|task
operator|.
name|isMapTask
argument_list|()
condition|)
block|{
name|status
operator|=
operator|new
name|MapTaskStatus
argument_list|(
name|taskIdOldApi
argument_list|,
literal|0f
argument_list|,
name|numSlotsRequired
argument_list|,
name|State
operator|.
name|RUNNING
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
name|taskTrackerName
argument_list|,
name|Phase
operator|.
name|MAP
argument_list|,
name|emptyCounters
argument_list|)
expr_stmt|;
name|usedMapSlots
operator|+=
name|numSlotsRequired
expr_stmt|;
if|if
condition|(
name|usedMapSlots
operator|>
name|maxMapSlots
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"usedMapSlots exceeds maxMapSlots: "
operator|+
name|usedMapSlots
operator|+
literal|"> "
operator|+
name|maxMapSlots
argument_list|)
throw|;
block|}
block|}
else|else
block|{
name|status
operator|=
operator|new
name|ReduceTaskStatus
argument_list|(
name|taskIdOldApi
argument_list|,
literal|0f
argument_list|,
name|numSlotsRequired
argument_list|,
name|State
operator|.
name|RUNNING
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
name|taskTrackerName
argument_list|,
name|Phase
operator|.
name|SHUFFLE
argument_list|,
name|emptyCounters
argument_list|)
expr_stmt|;
name|usedReduceSlots
operator|+=
name|numSlotsRequired
expr_stmt|;
if|if
condition|(
name|usedReduceSlots
operator|>
name|maxReduceSlots
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"usedReduceSlots exceeds usedReduceSlots: "
operator|+
name|usedReduceSlots
operator|+
literal|"> "
operator|+
name|usedReduceSlots
argument_list|)
throw|;
block|}
block|}
comment|//  Second, create and store a TIP
name|status
operator|.
name|setStartTime
argument_list|(
name|now
argument_list|)
expr_stmt|;
name|SimulatorTaskInProgress
name|tip
init|=
operator|new
name|SimulatorTaskInProgress
argument_list|(
name|action
argument_list|,
name|status
argument_list|,
name|now
argument_list|)
decl_stmt|;
name|tasks
operator|.
name|put
argument_list|(
name|taskId
argument_list|,
name|tip
argument_list|)
expr_stmt|;
comment|// Third, schedule events for ourselves
if|if
condition|(
name|task
operator|.
name|isMapTask
argument_list|()
condition|)
block|{
comment|// we know when this task attempts ends iff it is a map
name|TaskAttemptCompletionEvent
name|e
init|=
name|createTaskAttemptCompletionEvent
argument_list|(
name|tip
argument_list|,
name|now
argument_list|)
decl_stmt|;
return|return
name|Collections
operator|.
expr|<
name|SimulatorEvent
operator|>
name|singletonList
argument_list|(
name|e
argument_list|)
return|;
block|}
else|else
block|{
comment|// reduce, completion time can only be determined when all maps are done
return|return
name|SimulatorEngine
operator|.
name|EMPTY_EVENTS
return|;
block|}
block|}
comment|/**     * Kills a task attempt.    *    * @param action contains the task attempt to kill    * @param now current simulation time    * @return new events generated in response, empty    */
DECL|method|handleKillTaskAction (KillTaskAction action, long now)
specifier|private
name|List
argument_list|<
name|SimulatorEvent
argument_list|>
name|handleKillTaskAction
parameter_list|(
name|KillTaskAction
name|action
parameter_list|,
name|long
name|now
parameter_list|)
block|{
name|TaskAttemptID
name|taskId
init|=
name|action
operator|.
name|getTaskID
argument_list|()
decl_stmt|;
comment|// we don't have a nice(r) toString() in Hadoop's TaskActions
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Handling kill task action, taskId="
operator|+
name|taskId
operator|+
literal|", now="
operator|+
name|now
argument_list|)
expr_stmt|;
block|}
name|SimulatorTaskInProgress
name|tip
init|=
name|tasks
operator|.
name|get
argument_list|(
name|taskId
argument_list|)
decl_stmt|;
comment|// Safety check: We might get a KillTaskAction even for completed reduces
if|if
condition|(
name|tip
operator|==
literal|null
condition|)
block|{
return|return
name|SimulatorEngine
operator|.
name|EMPTY_EVENTS
return|;
block|}
name|progressTaskStatus
argument_list|(
name|tip
argument_list|,
name|now
argument_list|)
expr_stmt|;
comment|// make progress up to date
name|TaskStatus
name|finalStatus
init|=
operator|(
name|TaskStatus
operator|)
name|tip
operator|.
name|getTaskStatus
argument_list|()
operator|.
name|clone
argument_list|()
decl_stmt|;
name|finalStatus
operator|.
name|setFinishTime
argument_list|(
name|now
argument_list|)
expr_stmt|;
name|finalStatus
operator|.
name|setRunState
argument_list|(
name|State
operator|.
name|KILLED
argument_list|)
expr_stmt|;
name|finishRunningTask
argument_list|(
name|finalStatus
argument_list|,
name|now
argument_list|)
expr_stmt|;
if|if
condition|(
name|finalStatus
operator|.
name|getIsMap
argument_list|()
operator|||
name|finalStatus
operator|.
name|getPhase
argument_list|()
operator|==
name|Phase
operator|.
name|REDUCE
condition|)
block|{
comment|// if we have already created a task attempt completion event we remember
comment|// the task id, so that we can safely ignore the event when its delivered
name|orphanTaskCompletions
operator|.
name|add
argument_list|(
name|taskId
argument_list|)
expr_stmt|;
block|}
return|return
name|SimulatorEngine
operator|.
name|EMPTY_EVENTS
return|;
block|}
comment|/**     * Starts "running" the REDUCE phase of reduce upon being notified that     * all map tasks are (successfully) done.    *    * @param action contains the notification for one of the reduce tasks    * @param now current simulation time    * @return new events generated, a single TaskAttemptCompletionEvent for the    *         reduce    */
DECL|method|handleAllMapsCompletedTaskAction ( AllMapsCompletedTaskAction action, long now)
specifier|private
name|List
argument_list|<
name|SimulatorEvent
argument_list|>
name|handleAllMapsCompletedTaskAction
parameter_list|(
name|AllMapsCompletedTaskAction
name|action
parameter_list|,
name|long
name|now
parameter_list|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Handling all maps completed task action "
operator|+
name|action
argument_list|)
expr_stmt|;
block|}
name|TaskAttemptID
name|taskId
init|=
name|action
operator|.
name|getTaskID
argument_list|()
decl_stmt|;
name|SimulatorTaskInProgress
name|tip
init|=
name|tasks
operator|.
name|get
argument_list|(
name|taskId
argument_list|)
decl_stmt|;
comment|// If tip is null here it is because the task attempt to be notified is
comment|// unknown to this TaskTracker.
name|TaskStatus
name|status
init|=
name|tip
operator|.
name|getTaskStatus
argument_list|()
decl_stmt|;
if|if
condition|(
name|status
operator|.
name|getIsMap
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Invalid AllMapsCompletedTaskAction, task attempt "
operator|+
literal|"to be notified is a map: "
operator|+
name|taskId
operator|+
literal|" "
operator|+
name|status
argument_list|)
throw|;
block|}
if|if
condition|(
name|status
operator|.
name|getPhase
argument_list|()
operator|!=
name|Phase
operator|.
name|SHUFFLE
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Reducer task attempt already notified: "
operator|+
name|taskId
operator|+
literal|" "
operator|+
name|status
argument_list|)
throw|;
block|}
comment|// Warning: setPhase() uses System.currentTimeMillis() internally to
comment|// set shuffle and sort times, but we overwrite that manually anyway
name|status
operator|.
name|setPhase
argument_list|(
name|Phase
operator|.
name|REDUCE
argument_list|)
expr_stmt|;
name|status
operator|.
name|setShuffleFinishTime
argument_list|(
name|now
argument_list|)
expr_stmt|;
name|status
operator|.
name|setSortFinishTime
argument_list|(
name|now
argument_list|)
expr_stmt|;
comment|// Forecast the completion of this reduce
name|TaskAttemptCompletionEvent
name|e
init|=
name|createTaskAttemptCompletionEvent
argument_list|(
name|tip
argument_list|,
name|now
argument_list|)
decl_stmt|;
return|return
name|Collections
operator|.
expr|<
name|SimulatorEvent
operator|>
name|singletonList
argument_list|(
name|e
argument_list|)
return|;
block|}
comment|/**     * Updates the progress indicator of a task if it is running.    *     * @param tip simulator task in progress whose progress is to be updated    * @param now current simulation time    */
DECL|method|progressTaskStatus (SimulatorTaskInProgress tip, long now)
specifier|private
name|void
name|progressTaskStatus
parameter_list|(
name|SimulatorTaskInProgress
name|tip
parameter_list|,
name|long
name|now
parameter_list|)
block|{
name|TaskStatus
name|status
init|=
name|tip
operator|.
name|getTaskStatus
argument_list|()
decl_stmt|;
if|if
condition|(
name|status
operator|.
name|getRunState
argument_list|()
operator|!=
name|State
operator|.
name|RUNNING
condition|)
block|{
return|return;
comment|// nothing to be done
block|}
name|boolean
name|isMap
init|=
name|tip
operator|.
name|isMapTask
argument_list|()
decl_stmt|;
comment|// Time when the user space code started
name|long
name|startTime
init|=
operator|-
literal|1
decl_stmt|;
comment|// Time spent in map or just in the REDUCE phase of a reduce task
name|long
name|runTime
init|=
name|tip
operator|.
name|getUserSpaceRunTime
argument_list|()
decl_stmt|;
name|float
name|progress
init|=
literal|0.0f
decl_stmt|;
if|if
condition|(
name|isMap
condition|)
block|{
comment|// We linearly estimate the progress of maps since their start
name|startTime
operator|=
name|status
operator|.
name|getStartTime
argument_list|()
expr_stmt|;
name|progress
operator|=
operator|(
call|(
name|float
call|)
argument_list|(
name|now
operator|-
name|startTime
argument_list|)
operator|)
operator|/
name|runTime
expr_stmt|;
block|}
else|else
block|{
comment|// We don't model reduce progress in the SHUFFLE or SORT phases
comment|// We use linear estimate for the 3rd, REDUCE phase
name|Phase
name|reducePhase
init|=
name|status
operator|.
name|getPhase
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|reducePhase
condition|)
block|{
case|case
name|SHUFFLE
case|:
name|progress
operator|=
literal|0.0f
expr_stmt|;
comment|// 0 phase is done out of 3
break|break;
case|case
name|SORT
case|:
name|progress
operator|=
literal|1.0f
operator|/
literal|3
expr_stmt|;
comment|// 1 phase is done out of 3
break|break;
case|case
name|REDUCE
case|:
block|{
comment|// REDUCE phase with the user code started when sort finished
name|startTime
operator|=
name|status
operator|.
name|getSortFinishTime
argument_list|()
expr_stmt|;
comment|// 0.66f : 2 phases are done out of of 3
name|progress
operator|=
literal|2.0f
operator|/
literal|3
operator|+
operator|(
operator|(
call|(
name|float
call|)
argument_list|(
name|now
operator|-
name|startTime
argument_list|)
operator|)
operator|/
name|runTime
operator|)
operator|/
literal|3.0f
expr_stmt|;
block|}
break|break;
default|default:
comment|// should never get here
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Invalid reducePhase="
operator|+
name|reducePhase
argument_list|)
throw|;
block|}
block|}
specifier|final
name|float
name|EPSILON
init|=
literal|0.0001f
decl_stmt|;
if|if
condition|(
name|progress
argument_list|<
operator|-
name|EPSILON
operator|||
name|progress
argument_list|>
literal|1
operator|+
name|EPSILON
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Task progress out of range: "
operator|+
name|progress
argument_list|)
throw|;
block|}
name|progress
operator|=
name|Math
operator|.
name|max
argument_list|(
name|Math
operator|.
name|min
argument_list|(
literal|1.0f
argument_list|,
name|progress
argument_list|)
argument_list|,
literal|0.0f
argument_list|)
expr_stmt|;
name|status
operator|.
name|setProgress
argument_list|(
name|progress
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Updated task progress, taskId="
operator|+
name|status
operator|.
name|getTaskID
argument_list|()
operator|+
literal|", progress="
operator|+
name|status
operator|.
name|getProgress
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Updates the progress indicator of all running tasks.     *    * @param now current simulation time    */
DECL|method|progressTaskStatuses (long now)
specifier|private
name|void
name|progressTaskStatuses
parameter_list|(
name|long
name|now
parameter_list|)
block|{
for|for
control|(
name|SimulatorTaskInProgress
name|tip
range|:
name|tasks
operator|.
name|values
argument_list|()
control|)
block|{
name|progressTaskStatus
argument_list|(
name|tip
argument_list|,
name|now
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**     * Frees up bookkeping memory used by completed tasks.     * Has no effect on the events or logs produced by the SimulatorTaskTracker.    * We need this in order not to report completed task multiple times and     * to ensure that we do not run out of Java heap memory in larger     * simulations.    */
DECL|method|garbageCollectCompletedTasks ()
specifier|private
name|void
name|garbageCollectCompletedTasks
parameter_list|()
block|{
for|for
control|(
name|Iterator
argument_list|<
name|TaskAttemptID
argument_list|>
name|iter
init|=
name|tasks
operator|.
name|keySet
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|iter
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|TaskAttemptID
name|taskId
init|=
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
name|SimulatorTaskInProgress
name|tip
init|=
name|tasks
operator|.
name|get
argument_list|(
name|taskId
argument_list|)
decl_stmt|;
if|if
condition|(
name|tip
operator|.
name|getTaskStatus
argument_list|()
operator|.
name|getRunState
argument_list|()
operator|!=
name|State
operator|.
name|RUNNING
condition|)
block|{
name|iter
operator|.
name|remove
argument_list|()
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Garbage collected SimulatorTIP, taskId="
operator|+
name|taskId
argument_list|)
expr_stmt|;
block|}
comment|// We don't have to / must not touch usedMapSlots and usedReduceSlots
comment|// as those were already updated by processTaskAttemptCompletionEvent()
comment|// when the task switched its state from running
block|}
block|}
block|}
comment|/**    * Creates a list of task statuses suitable for transmission via heartbeat().    * The task statuses are cloned() so that the heartbeat() callee, the job     * tracker, can't mess up the SimulatorTaskTracker's internal data.    *    * @return the list of running and recently completed task statuses     * on the tracker    */
DECL|method|collectAndCloneTaskStatuses ()
specifier|private
name|List
argument_list|<
name|TaskStatus
argument_list|>
name|collectAndCloneTaskStatuses
parameter_list|()
block|{
name|ArrayList
argument_list|<
name|TaskStatus
argument_list|>
name|statuses
init|=
operator|new
name|ArrayList
argument_list|<
name|TaskStatus
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|SimulatorTaskInProgress
name|tip
range|:
name|tasks
operator|.
name|values
argument_list|()
control|)
block|{
name|statuses
operator|.
name|add
argument_list|(
operator|(
name|TaskStatus
operator|)
name|tip
operator|.
name|getTaskStatus
argument_list|()
operator|.
name|clone
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|statuses
return|;
block|}
comment|/**    * Handles the HeartbeatResponse received from the job tracker upon     * heartbeat(). Dispatches to handle*Action() methods.    *    * @param response HeartbeatResponse received from the job tracker    * @param now current simulation time    * @return list of new events generated in response to the task actions    */
DECL|method|handleHeartbeatResponse (HeartbeatResponse response, long now)
specifier|private
name|List
argument_list|<
name|SimulatorEvent
argument_list|>
name|handleHeartbeatResponse
parameter_list|(
name|HeartbeatResponse
name|response
parameter_list|,
name|long
name|now
parameter_list|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Handling heartbeat response "
operator|+
name|response
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|SimulatorEvent
argument_list|>
name|events
init|=
operator|new
name|ArrayList
argument_list|<
name|SimulatorEvent
argument_list|>
argument_list|()
decl_stmt|;
name|TaskTrackerAction
index|[]
name|actions
init|=
name|response
operator|.
name|getActions
argument_list|()
decl_stmt|;
for|for
control|(
name|TaskTrackerAction
name|action
range|:
name|actions
control|)
block|{
name|List
argument_list|<
name|SimulatorEvent
argument_list|>
name|actionEvents
decl_stmt|;
if|if
condition|(
name|action
operator|instanceof
name|SimulatorLaunchTaskAction
condition|)
block|{
name|actionEvents
operator|=
name|handleSimulatorLaunchTaskAction
argument_list|(
operator|(
name|SimulatorLaunchTaskAction
operator|)
name|action
argument_list|,
name|now
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|action
operator|instanceof
name|KillTaskAction
condition|)
block|{
name|actionEvents
operator|=
name|handleKillTaskAction
argument_list|(
operator|(
name|KillTaskAction
operator|)
name|action
argument_list|,
name|now
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|action
operator|instanceof
name|AllMapsCompletedTaskAction
condition|)
block|{
comment|// our extra task action for notifying the reducers
name|actionEvents
operator|=
name|handleAllMapsCompletedTaskAction
argument_list|(
operator|(
name|AllMapsCompletedTaskAction
operator|)
name|action
argument_list|,
name|now
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Should never get here.
comment|// CommitTaskAction is not implemented in the simulator
comment|// LaunchTaskAction has to be SimulatorLaunchTaskAction
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"Unimplemented TaskAction: "
operator|+
name|action
argument_list|)
throw|;
block|}
name|events
operator|.
name|addAll
argument_list|(
name|actionEvents
argument_list|)
expr_stmt|;
block|}
return|return
name|events
return|;
block|}
comment|/**     * Transmits a heartbeat event to the jobtracker and processes the response.    *    * @param event HeartbeatEvent to process    * @return list of new events generated in response    */
DECL|method|processHeartbeatEvent (HeartbeatEvent event)
specifier|private
name|List
argument_list|<
name|SimulatorEvent
argument_list|>
name|processHeartbeatEvent
parameter_list|(
name|HeartbeatEvent
name|event
parameter_list|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Processing heartbeat event "
operator|+
name|event
argument_list|)
expr_stmt|;
block|}
name|long
name|now
init|=
name|event
operator|.
name|getTimeStamp
argument_list|()
decl_stmt|;
comment|// Create the TaskTrackerStatus to report
name|progressTaskStatuses
argument_list|(
name|now
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|TaskStatus
argument_list|>
name|taskStatuses
init|=
name|collectAndCloneTaskStatuses
argument_list|()
decl_stmt|;
name|boolean
name|askForNewTask
init|=
operator|(
name|usedMapSlots
operator|<
name|maxMapSlots
operator|||
name|usedReduceSlots
operator|<
name|maxReduceSlots
operator|)
decl_stmt|;
comment|// 0 means failures == 0 here. Undocumented in TaskTracker, but does not
comment|// seem to be used at all in org.apache.hadoop.mapred .
name|TaskTrackerStatus
name|taskTrackerStatus
init|=
operator|new
name|SimulatorTaskTrackerStatus
argument_list|(
name|taskTrackerName
argument_list|,
name|hostName
argument_list|,
name|httpPort
argument_list|,
name|taskStatuses
argument_list|,
literal|0
argument_list|,
name|maxMapSlots
argument_list|,
name|maxReduceSlots
argument_list|,
name|now
argument_list|)
decl_stmt|;
comment|// This is the right, and only, place to release bookkeping memory held
comment|// by completed tasks: after collectAndCloneTaskStatuses() and before
comment|// heartbeat().
comment|// The status of TIPs to be purged is already cloned& copied to
comment|// taskStatuses for reporting
comment|// We shouldn't run the gc after heartbeat() since  KillTaskAction might
comment|// produce new completed tasks that we have not yet reported back and
comment|// don't want to purge immediately.
name|garbageCollectCompletedTasks
argument_list|()
expr_stmt|;
comment|// Transmit the heartbeat
name|HeartbeatResponse
name|response
init|=
literal|null
decl_stmt|;
try|try
block|{
name|response
operator|=
name|jobTracker
operator|.
name|heartbeat
argument_list|(
name|taskTrackerStatus
argument_list|,
literal|false
argument_list|,
name|firstHeartbeat
argument_list|,
name|askForNewTask
argument_list|,
name|heartbeatResponseId
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Internal error"
argument_list|,
name|ioe
argument_list|)
throw|;
block|}
name|firstHeartbeat
operator|=
literal|false
expr_stmt|;
comment|// The heartbeat got through successfully!
name|heartbeatResponseId
operator|=
name|response
operator|.
name|getResponseId
argument_list|()
expr_stmt|;
comment|// Process the heartbeat response
name|List
argument_list|<
name|SimulatorEvent
argument_list|>
name|events
init|=
name|handleHeartbeatResponse
argument_list|(
name|response
argument_list|,
name|now
argument_list|)
decl_stmt|;
comment|// Next heartbeat
name|int
name|heartbeatInterval
init|=
name|response
operator|.
name|getHeartbeatInterval
argument_list|()
decl_stmt|;
if|if
condition|(
name|heartbeatIntervalFuzz
operator|>
literal|1
condition|)
block|{
comment|// Add some randomness to heartbeat timings to simulate network latency,
comment|// time spent servicing this heartbeat request, etc.
comment|// randomFuzz is in (-heartbeatIntervalFuzz,+heartbeatIntervalFuzz)
name|int
name|randomFuzz
init|=
name|random
operator|.
name|nextInt
argument_list|(
literal|2
operator|*
name|heartbeatIntervalFuzz
operator|-
literal|1
argument_list|)
operator|-
name|heartbeatIntervalFuzz
decl_stmt|;
name|heartbeatInterval
operator|+=
name|randomFuzz
expr_stmt|;
comment|// make sure we never schedule a heartbeat in the past
name|heartbeatInterval
operator|=
name|Math
operator|.
name|max
argument_list|(
literal|1
argument_list|,
name|heartbeatInterval
argument_list|)
expr_stmt|;
block|}
name|events
operator|.
name|add
argument_list|(
operator|new
name|HeartbeatEvent
argument_list|(
name|this
argument_list|,
name|now
operator|+
name|heartbeatInterval
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|events
return|;
block|}
comment|/**    * Internal helper class used for storing the current status and other    * auxilliary information associated with a task attempt assigned to    * a simulator task tracker.    * WARNING: This is a completely different inner class than the one with    *          the same name in SimulatorJobTracker.    */
DECL|class|SimulatorTaskInProgress
specifier|static
class|class
name|SimulatorTaskInProgress
block|{
comment|/**      * Current status of the task attempt.       * We store the start time, the start time of reduce phases and the      * run state of the task in this object.      */
DECL|field|taskStatus
specifier|private
name|TaskStatus
name|taskStatus
decl_stmt|;
comment|/**       * Object storing the run time and the final state of the task attempt.      * It is never read directly by the SimulatorTaskTracker.      */
DECL|field|taskAttempInfo
specifier|private
name|TaskAttemptInfo
name|taskAttempInfo
decl_stmt|;
comment|/**      * Runtime of the user-space code of the task attempt. This is the full      * runtime for map tasks, and only that of the REDUCE phase for reduce      * tasks.      */
DECL|field|userSpaceRunTime
specifier|private
specifier|final
name|long
name|userSpaceRunTime
decl_stmt|;
comment|/**       * Constructs an object by copying most of the fields from a      * SimulatorTaskAction.      */
DECL|method|SimulatorTaskInProgress (SimulatorLaunchTaskAction action, TaskStatus taskStatus, long now)
specifier|public
name|SimulatorTaskInProgress
parameter_list|(
name|SimulatorLaunchTaskAction
name|action
parameter_list|,
name|TaskStatus
name|taskStatus
parameter_list|,
name|long
name|now
parameter_list|)
block|{
name|this
operator|.
name|taskStatus
operator|=
name|taskStatus
expr_stmt|;
name|this
operator|.
name|taskAttempInfo
operator|=
name|action
operator|.
name|getTaskAttemptInfo
argument_list|()
expr_stmt|;
if|if
condition|(
name|taskStatus
operator|.
name|getIsMap
argument_list|()
condition|)
block|{
name|this
operator|.
name|userSpaceRunTime
operator|=
name|taskAttempInfo
operator|.
name|getRuntime
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|userSpaceRunTime
operator|=
operator|(
operator|(
name|ReduceTaskAttemptInfo
operator|)
name|taskAttempInfo
operator|)
operator|.
name|getReduceRuntime
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Returns whether the task attempt is a map.       *       * @return true iff the task attempt is a map      */
DECL|method|isMapTask ()
specifier|public
name|boolean
name|isMapTask
parameter_list|()
block|{
return|return
name|taskStatus
operator|.
name|getIsMap
argument_list|()
return|;
block|}
comment|/*      * Returns the current status of the task attempt.       *      * @return current task status      */
DECL|method|getTaskStatus ()
specifier|public
name|TaskStatus
name|getTaskStatus
parameter_list|()
block|{
return|return
name|taskStatus
return|;
block|}
comment|/**       * Sets the status of the task attempt.      *      * @param status the new task status      */
DECL|method|setTaskStatus (TaskStatus status)
specifier|public
name|void
name|setTaskStatus
parameter_list|(
name|TaskStatus
name|status
parameter_list|)
block|{
name|this
operator|.
name|taskStatus
operator|=
name|status
expr_stmt|;
block|}
comment|/**       * Returns the final state of the completed task.      *       * @return the final state of the completed task;       *        it is either State.SUCCEEDED or State.FAILED      */
DECL|method|getFinalRunState ()
specifier|public
name|State
name|getFinalRunState
parameter_list|()
block|{
return|return
name|taskAttempInfo
operator|.
name|getRunState
argument_list|()
return|;
block|}
comment|/**      * Gets the time spent in the user space code of the task attempt.      * This is the full runtime for map tasks, and only that of the REDUCE       * phase for reduce tasks.      *      * @return the user space runtime       */
DECL|method|getUserSpaceRunTime ()
specifier|public
name|long
name|getUserSpaceRunTime
parameter_list|()
block|{
return|return
name|userSpaceRunTime
return|;
block|}
block|}
block|}
end_class

end_unit

