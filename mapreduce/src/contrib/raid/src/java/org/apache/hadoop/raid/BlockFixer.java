begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.raid
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|raid
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|BufferedOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Random
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|InetSocketAddress
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|Socket
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|channels
operator|.
name|SocketChannel
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Constructor
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|InvocationTargetException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|DataChecksum
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DistributedFileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|datatransfer
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|DatanodeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|ExtendedBlock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|FSConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|FSConstants
operator|.
name|DatanodeReportType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|LocatedBlock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|LocatedBlocks
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|HdfsConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|FSDataset
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|RaidBlockSender
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configured
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|RaidDFSUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Progressable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|net
operator|.
name|NetUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|raid
operator|.
name|RaidNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|raid
operator|.
name|RaidUtils
import|;
end_import

begin_comment
comment|/**  * contains the core functionality of the block fixer  *  * configuration options:  * raid.blockfix.classname         - the class name of the block fixer   *                                   implementation to use  *  * raid.blockfix.interval          - interval between checks for corrupt files  *  * raid.blockfix.history.interval  - interval before fixing same file again  *  * raid.blockfix.read.timeout      - read time out  *  * raid.blockfix.write.timeout     - write time out  */
end_comment

begin_class
DECL|class|BlockFixer
specifier|public
specifier|abstract
class|class
name|BlockFixer
extends|extends
name|Configured
implements|implements
name|Runnable
block|{
DECL|field|BLOCKFIX_CLASSNAME
specifier|public
specifier|static
specifier|final
name|String
name|BLOCKFIX_CLASSNAME
init|=
literal|"raid.blockfix.classname"
decl_stmt|;
DECL|field|BLOCKFIX_INTERVAL
specifier|public
specifier|static
specifier|final
name|String
name|BLOCKFIX_INTERVAL
init|=
literal|"raid.blockfix.interval"
decl_stmt|;
DECL|field|BLOCKFIX_HISTORY_INTERVAL
specifier|public
specifier|static
specifier|final
name|String
name|BLOCKFIX_HISTORY_INTERVAL
init|=
literal|"raid.blockfix.history.interval"
decl_stmt|;
DECL|field|BLOCKFIX_READ_TIMEOUT
specifier|public
specifier|static
specifier|final
name|String
name|BLOCKFIX_READ_TIMEOUT
init|=
literal|"raid.blockfix.read.timeout"
decl_stmt|;
DECL|field|BLOCKFIX_WRITE_TIMEOUT
specifier|public
specifier|static
specifier|final
name|String
name|BLOCKFIX_WRITE_TIMEOUT
init|=
literal|"raid.blockfix.write.timeout"
decl_stmt|;
DECL|field|DEFAULT_BLOCKFIX_INTERVAL
specifier|public
specifier|static
specifier|final
name|long
name|DEFAULT_BLOCKFIX_INTERVAL
init|=
literal|60
operator|*
literal|1000
decl_stmt|;
comment|// 1 min
DECL|field|DEFAULT_BLOCKFIX_HISTORY_INTERVAL
specifier|public
specifier|static
specifier|final
name|long
name|DEFAULT_BLOCKFIX_HISTORY_INTERVAL
init|=
literal|60
operator|*
literal|60
operator|*
literal|1000
decl_stmt|;
comment|// 60 mins
DECL|method|createBlockFixer (Configuration conf)
specifier|public
specifier|static
name|BlockFixer
name|createBlockFixer
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|ClassNotFoundException
block|{
try|try
block|{
comment|// default to distributed block fixer
name|Class
argument_list|<
name|?
argument_list|>
name|blockFixerClass
init|=
name|conf
operator|.
name|getClass
argument_list|(
name|BLOCKFIX_CLASSNAME
argument_list|,
name|DistBlockFixer
operator|.
name|class
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|BlockFixer
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|blockFixerClass
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|ClassNotFoundException
argument_list|(
literal|"not an implementation of blockfixer"
argument_list|)
throw|;
block|}
name|Constructor
argument_list|<
name|?
argument_list|>
name|constructor
init|=
name|blockFixerClass
operator|.
name|getConstructor
argument_list|(
operator|new
name|Class
index|[]
block|{
name|Configuration
operator|.
name|class
block|}
argument_list|)
decl_stmt|;
return|return
operator|(
name|BlockFixer
operator|)
name|constructor
operator|.
name|newInstance
argument_list|(
name|conf
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|NoSuchMethodException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|ClassNotFoundException
argument_list|(
literal|"cannot construct blockfixer"
argument_list|,
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|InstantiationException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|ClassNotFoundException
argument_list|(
literal|"cannot construct blockfixer"
argument_list|,
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|IllegalAccessException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|ClassNotFoundException
argument_list|(
literal|"cannot construct blockfixer"
argument_list|,
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|InvocationTargetException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|ClassNotFoundException
argument_list|(
literal|"cannot construct blockfixer"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
DECL|field|numFilesFixed
specifier|private
name|long
name|numFilesFixed
init|=
literal|0
decl_stmt|;
DECL|field|running
specifier|public
specifier|volatile
name|boolean
name|running
init|=
literal|true
decl_stmt|;
comment|// interval between checks for corrupt files
DECL|field|blockFixInterval
specifier|protected
name|long
name|blockFixInterval
decl_stmt|;
comment|// interval before fixing same file again
DECL|field|historyInterval
specifier|protected
name|long
name|historyInterval
decl_stmt|;
DECL|method|BlockFixer (Configuration conf)
specifier|public
name|BlockFixer
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
name|super
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|blockFixInterval
operator|=
name|getConf
argument_list|()
operator|.
name|getLong
argument_list|(
name|BLOCKFIX_INTERVAL
argument_list|,
name|DEFAULT_BLOCKFIX_INTERVAL
argument_list|)
expr_stmt|;
name|historyInterval
operator|=
name|getConf
argument_list|()
operator|.
name|getLong
argument_list|(
name|BLOCKFIX_HISTORY_INTERVAL
argument_list|,
name|DEFAULT_BLOCKFIX_HISTORY_INTERVAL
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|run ()
specifier|public
specifier|abstract
name|void
name|run
parameter_list|()
function_decl|;
comment|/**    * returns the number of files that have been fixed by this block fixer    */
DECL|method|filesFixed ()
specifier|public
specifier|synchronized
name|long
name|filesFixed
parameter_list|()
block|{
return|return
name|numFilesFixed
return|;
block|}
comment|/**    * increments the number of files that have been fixed by this block fixer    */
DECL|method|incrFilesFixed ()
specifier|protected
specifier|synchronized
name|void
name|incrFilesFixed
parameter_list|()
block|{
name|numFilesFixed
operator|++
expr_stmt|;
block|}
comment|/**    * increments the number of files that have been fixed by this block fixer    */
DECL|method|incrFilesFixed (long incr)
specifier|protected
specifier|synchronized
name|void
name|incrFilesFixed
parameter_list|(
name|long
name|incr
parameter_list|)
block|{
if|if
condition|(
name|incr
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"cannot increment by negative value "
operator|+
name|incr
argument_list|)
throw|;
block|}
name|numFilesFixed
operator|+=
name|incr
expr_stmt|;
block|}
DECL|method|isSourceFile (Path p, String[] destPrefixes)
specifier|static
name|boolean
name|isSourceFile
parameter_list|(
name|Path
name|p
parameter_list|,
name|String
index|[]
name|destPrefixes
parameter_list|)
block|{
name|String
name|pathStr
init|=
name|p
operator|.
name|toUri
argument_list|()
operator|.
name|getPath
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|destPrefix
range|:
name|destPrefixes
control|)
block|{
if|if
condition|(
name|pathStr
operator|.
name|startsWith
argument_list|(
name|destPrefix
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
DECL|method|filterUnfixableSourceFiles (Iterator<Path> it)
name|void
name|filterUnfixableSourceFiles
parameter_list|(
name|Iterator
argument_list|<
name|Path
argument_list|>
name|it
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|xorPrefix
init|=
name|RaidNode
operator|.
name|xorDestinationPath
argument_list|(
name|getConf
argument_list|()
argument_list|)
operator|.
name|toUri
argument_list|()
operator|.
name|getPath
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|xorPrefix
operator|.
name|endsWith
argument_list|(
name|Path
operator|.
name|SEPARATOR
argument_list|)
condition|)
block|{
name|xorPrefix
operator|+=
name|Path
operator|.
name|SEPARATOR
expr_stmt|;
block|}
name|String
name|rsPrefix
init|=
name|RaidNode
operator|.
name|rsDestinationPath
argument_list|(
name|getConf
argument_list|()
argument_list|)
operator|.
name|toUri
argument_list|()
operator|.
name|getPath
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|rsPrefix
operator|.
name|endsWith
argument_list|(
name|Path
operator|.
name|SEPARATOR
argument_list|)
condition|)
block|{
name|rsPrefix
operator|+=
name|Path
operator|.
name|SEPARATOR
expr_stmt|;
block|}
name|String
index|[]
name|destPrefixes
init|=
operator|new
name|String
index|[]
block|{
name|xorPrefix
block|,
name|rsPrefix
block|}
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Path
name|p
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|isSourceFile
argument_list|(
name|p
argument_list|,
name|destPrefixes
argument_list|)
operator|&&
name|RaidNode
operator|.
name|xorParityForSource
argument_list|(
name|p
argument_list|,
name|getConf
argument_list|()
argument_list|)
operator|==
literal|null
operator|&&
name|RaidNode
operator|.
name|rsParityForSource
argument_list|(
name|p
argument_list|,
name|getConf
argument_list|()
argument_list|)
operator|==
literal|null
condition|)
block|{
name|it
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**    * this class implements the actual fixing functionality    * we keep this in a separate class so that     * the distributed block fixer can use it    */
DECL|class|BlockFixerHelper
specifier|static
class|class
name|BlockFixerHelper
extends|extends
name|Configured
block|{
DECL|field|LOG
specifier|public
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|BlockFixer
operator|.
name|BlockFixerHelper
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|xorPrefix
specifier|private
name|String
name|xorPrefix
decl_stmt|;
DECL|field|rsPrefix
specifier|private
name|String
name|rsPrefix
decl_stmt|;
DECL|field|xorEncoder
specifier|private
name|XOREncoder
name|xorEncoder
decl_stmt|;
DECL|field|xorDecoder
specifier|private
name|XORDecoder
name|xorDecoder
decl_stmt|;
DECL|field|rsEncoder
specifier|private
name|ReedSolomonEncoder
name|rsEncoder
decl_stmt|;
DECL|field|rsDecoder
specifier|private
name|ReedSolomonDecoder
name|rsDecoder
decl_stmt|;
DECL|method|BlockFixerHelper (Configuration conf)
specifier|public
name|BlockFixerHelper
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|super
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|xorPrefix
operator|=
name|RaidNode
operator|.
name|xorDestinationPath
argument_list|(
name|getConf
argument_list|()
argument_list|)
operator|.
name|toUri
argument_list|()
operator|.
name|getPath
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|xorPrefix
operator|.
name|endsWith
argument_list|(
name|Path
operator|.
name|SEPARATOR
argument_list|)
condition|)
block|{
name|xorPrefix
operator|+=
name|Path
operator|.
name|SEPARATOR
expr_stmt|;
block|}
name|rsPrefix
operator|=
name|RaidNode
operator|.
name|rsDestinationPath
argument_list|(
name|getConf
argument_list|()
argument_list|)
operator|.
name|toUri
argument_list|()
operator|.
name|getPath
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|rsPrefix
operator|.
name|endsWith
argument_list|(
name|Path
operator|.
name|SEPARATOR
argument_list|)
condition|)
block|{
name|rsPrefix
operator|+=
name|Path
operator|.
name|SEPARATOR
expr_stmt|;
block|}
name|int
name|stripeLength
init|=
name|RaidNode
operator|.
name|getStripeLength
argument_list|(
name|getConf
argument_list|()
argument_list|)
decl_stmt|;
name|xorEncoder
operator|=
operator|new
name|XOREncoder
argument_list|(
name|getConf
argument_list|()
argument_list|,
name|stripeLength
argument_list|)
expr_stmt|;
name|xorDecoder
operator|=
operator|new
name|XORDecoder
argument_list|(
name|getConf
argument_list|()
argument_list|,
name|stripeLength
argument_list|)
expr_stmt|;
name|int
name|parityLength
init|=
name|RaidNode
operator|.
name|rsParityLength
argument_list|(
name|getConf
argument_list|()
argument_list|)
decl_stmt|;
name|rsEncoder
operator|=
operator|new
name|ReedSolomonEncoder
argument_list|(
name|getConf
argument_list|()
argument_list|,
name|stripeLength
argument_list|,
name|parityLength
argument_list|)
expr_stmt|;
name|rsDecoder
operator|=
operator|new
name|ReedSolomonDecoder
argument_list|(
name|getConf
argument_list|()
argument_list|,
name|stripeLength
argument_list|,
name|parityLength
argument_list|)
expr_stmt|;
block|}
comment|/**      * checks whether file is xor parity file      */
DECL|method|isXorParityFile (Path p)
name|boolean
name|isXorParityFile
parameter_list|(
name|Path
name|p
parameter_list|)
block|{
name|String
name|pathStr
init|=
name|p
operator|.
name|toUri
argument_list|()
operator|.
name|getPath
argument_list|()
decl_stmt|;
if|if
condition|(
name|pathStr
operator|.
name|contains
argument_list|(
name|RaidNode
operator|.
name|HAR_SUFFIX
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
name|pathStr
operator|.
name|startsWith
argument_list|(
name|xorPrefix
argument_list|)
return|;
block|}
comment|/**      * checks whether file is rs parity file      */
DECL|method|isRsParityFile (Path p)
name|boolean
name|isRsParityFile
parameter_list|(
name|Path
name|p
parameter_list|)
block|{
name|String
name|pathStr
init|=
name|p
operator|.
name|toUri
argument_list|()
operator|.
name|getPath
argument_list|()
decl_stmt|;
if|if
condition|(
name|pathStr
operator|.
name|contains
argument_list|(
name|RaidNode
operator|.
name|HAR_SUFFIX
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
name|pathStr
operator|.
name|startsWith
argument_list|(
name|rsPrefix
argument_list|)
return|;
block|}
comment|/**      * Fix a file, do not report progess.      *      * @return true if file has been fixed, false if no fixing       * was necessary or possible.      */
DECL|method|fixFile (Path srcPath)
name|boolean
name|fixFile
parameter_list|(
name|Path
name|srcPath
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|fixFile
argument_list|(
name|srcPath
argument_list|,
operator|new
name|RaidUtils
operator|.
name|DummyProgressable
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Fix a file, report progess.      *      * @return true if file has been fixed, false if no fixing       * was necessary or possible.      */
DECL|method|fixFile (Path srcPath, Progressable progress)
name|boolean
name|fixFile
parameter_list|(
name|Path
name|srcPath
parameter_list|,
name|Progressable
name|progress
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|RaidNode
operator|.
name|isParityHarPartFile
argument_list|(
name|srcPath
argument_list|)
condition|)
block|{
return|return
name|processCorruptParityHarPartFile
argument_list|(
name|srcPath
argument_list|,
name|progress
argument_list|)
return|;
block|}
comment|// The corrupted file is a XOR parity file
if|if
condition|(
name|isXorParityFile
argument_list|(
name|srcPath
argument_list|)
condition|)
block|{
return|return
name|processCorruptParityFile
argument_list|(
name|srcPath
argument_list|,
name|xorEncoder
argument_list|,
name|progress
argument_list|)
return|;
block|}
comment|// The corrupted file is a ReedSolomon parity file
if|if
condition|(
name|isRsParityFile
argument_list|(
name|srcPath
argument_list|)
condition|)
block|{
return|return
name|processCorruptParityFile
argument_list|(
name|srcPath
argument_list|,
name|rsEncoder
argument_list|,
name|progress
argument_list|)
return|;
block|}
comment|// The corrupted file is a source file
name|RaidNode
operator|.
name|ParityFilePair
name|ppair
init|=
name|RaidNode
operator|.
name|xorParityForSource
argument_list|(
name|srcPath
argument_list|,
name|getConf
argument_list|()
argument_list|)
decl_stmt|;
name|Decoder
name|decoder
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|ppair
operator|!=
literal|null
condition|)
block|{
name|decoder
operator|=
name|xorDecoder
expr_stmt|;
block|}
else|else
block|{
name|ppair
operator|=
name|RaidNode
operator|.
name|rsParityForSource
argument_list|(
name|srcPath
argument_list|,
name|getConf
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|ppair
operator|!=
literal|null
condition|)
block|{
name|decoder
operator|=
name|rsDecoder
expr_stmt|;
block|}
block|}
comment|// If we have a parity file, process the file and fix it.
if|if
condition|(
name|ppair
operator|!=
literal|null
condition|)
block|{
return|return
name|processCorruptFile
argument_list|(
name|srcPath
argument_list|,
name|ppair
argument_list|,
name|decoder
argument_list|,
name|progress
argument_list|)
return|;
block|}
comment|// there was nothing to do
return|return
literal|false
return|;
block|}
comment|/**      * Sorts source files ahead of parity files.      */
DECL|method|sortCorruptFiles (List<Path> files)
name|void
name|sortCorruptFiles
parameter_list|(
name|List
argument_list|<
name|Path
argument_list|>
name|files
parameter_list|)
block|{
comment|// TODO: We should first fix the files that lose more blocks
name|Comparator
argument_list|<
name|Path
argument_list|>
name|comp
init|=
operator|new
name|Comparator
argument_list|<
name|Path
argument_list|>
argument_list|()
block|{
specifier|public
name|int
name|compare
parameter_list|(
name|Path
name|p1
parameter_list|,
name|Path
name|p2
parameter_list|)
block|{
if|if
condition|(
name|isXorParityFile
argument_list|(
name|p2
argument_list|)
operator|||
name|isRsParityFile
argument_list|(
name|p2
argument_list|)
condition|)
block|{
comment|// If p2 is a parity file, p1 is smaller.
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|isXorParityFile
argument_list|(
name|p1
argument_list|)
operator|||
name|isRsParityFile
argument_list|(
name|p1
argument_list|)
condition|)
block|{
comment|// If p1 is a parity file, p2 is smaller.
return|return
literal|1
return|;
block|}
comment|// If both are source files, they are equal.
return|return
literal|0
return|;
block|}
block|}
decl_stmt|;
name|Collections
operator|.
name|sort
argument_list|(
name|files
argument_list|,
name|comp
argument_list|)
expr_stmt|;
block|}
comment|/**      * Returns a DistributedFileSystem hosting the path supplied.      */
DECL|method|getDFS (Path p)
specifier|protected
name|DistributedFileSystem
name|getDFS
parameter_list|(
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
return|return
operator|(
name|DistributedFileSystem
operator|)
name|p
operator|.
name|getFileSystem
argument_list|(
name|getConf
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Reads through a corrupt source file fixing corrupt blocks on the way.      * @param srcPath Path identifying the corrupt file.      * @throws IOException      * @return true if file has been fixed, false if no fixing       * was necessary or possible.      */
DECL|method|processCorruptFile (Path srcPath, RaidNode.ParityFilePair parityPair, Decoder decoder, Progressable progress)
name|boolean
name|processCorruptFile
parameter_list|(
name|Path
name|srcPath
parameter_list|,
name|RaidNode
operator|.
name|ParityFilePair
name|parityPair
parameter_list|,
name|Decoder
name|decoder
parameter_list|,
name|Progressable
name|progress
parameter_list|)
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Processing corrupt file "
operator|+
name|srcPath
argument_list|)
expr_stmt|;
name|DistributedFileSystem
name|srcFs
init|=
name|getDFS
argument_list|(
name|srcPath
argument_list|)
decl_stmt|;
name|FileStatus
name|srcStat
init|=
name|srcFs
operator|.
name|getFileStatus
argument_list|(
name|srcPath
argument_list|)
decl_stmt|;
name|long
name|blockSize
init|=
name|srcStat
operator|.
name|getBlockSize
argument_list|()
decl_stmt|;
name|long
name|srcFileSize
init|=
name|srcStat
operator|.
name|getLen
argument_list|()
decl_stmt|;
name|String
name|uriPath
init|=
name|srcPath
operator|.
name|toUri
argument_list|()
operator|.
name|getPath
argument_list|()
decl_stmt|;
name|int
name|numBlocksFixed
init|=
literal|0
decl_stmt|;
name|List
argument_list|<
name|LocatedBlock
argument_list|>
name|corrupt
init|=
name|RaidDFSUtil
operator|.
name|corruptBlocksInFile
argument_list|(
name|srcFs
argument_list|,
name|uriPath
argument_list|,
literal|0
argument_list|,
name|srcFileSize
argument_list|)
decl_stmt|;
if|if
condition|(
name|corrupt
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
literal|false
return|;
block|}
for|for
control|(
name|LocatedBlock
name|lb
range|:
name|corrupt
control|)
block|{
name|ExtendedBlock
name|corruptBlock
init|=
name|lb
operator|.
name|getBlock
argument_list|()
decl_stmt|;
name|long
name|corruptOffset
init|=
name|lb
operator|.
name|getStartOffset
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Found corrupt block "
operator|+
name|corruptBlock
operator|+
literal|", offset "
operator|+
name|corruptOffset
argument_list|)
expr_stmt|;
specifier|final
name|long
name|blockContentsSize
init|=
name|Math
operator|.
name|min
argument_list|(
name|blockSize
argument_list|,
name|srcFileSize
operator|-
name|corruptOffset
argument_list|)
decl_stmt|;
name|File
name|localBlockFile
init|=
name|File
operator|.
name|createTempFile
argument_list|(
name|corruptBlock
operator|.
name|getBlockName
argument_list|()
argument_list|,
literal|".tmp"
argument_list|)
decl_stmt|;
name|localBlockFile
operator|.
name|deleteOnExit
argument_list|()
expr_stmt|;
try|try
block|{
name|decoder
operator|.
name|recoverBlockToFile
argument_list|(
name|srcFs
argument_list|,
name|srcPath
argument_list|,
name|parityPair
operator|.
name|getFileSystem
argument_list|()
argument_list|,
name|parityPair
operator|.
name|getPath
argument_list|()
argument_list|,
name|blockSize
argument_list|,
name|corruptOffset
argument_list|,
name|localBlockFile
argument_list|,
name|blockContentsSize
argument_list|)
expr_stmt|;
comment|// We have a the contents of the block, send them.
name|DatanodeInfo
name|datanode
init|=
name|chooseDatanode
argument_list|(
name|lb
operator|.
name|getLocations
argument_list|()
argument_list|)
decl_stmt|;
name|computeMetadataAndSendFixedBlock
argument_list|(
name|datanode
argument_list|,
name|localBlockFile
argument_list|,
name|lb
argument_list|,
name|blockContentsSize
argument_list|)
expr_stmt|;
name|numBlocksFixed
operator|++
expr_stmt|;
block|}
finally|finally
block|{
name|localBlockFile
operator|.
name|delete
argument_list|()
expr_stmt|;
block|}
name|progress
operator|.
name|progress
argument_list|()
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Fixed "
operator|+
name|numBlocksFixed
operator|+
literal|" blocks in "
operator|+
name|srcPath
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|/**      * Fixes corrupt blocks in a parity file.      * This function uses the corresponding source file to regenerate parity      * file blocks.      * @return true if file has been fixed, false if no fixing       * was necessary or possible.      */
DECL|method|processCorruptParityFile (Path parityPath, Encoder encoder, Progressable progress)
name|boolean
name|processCorruptParityFile
parameter_list|(
name|Path
name|parityPath
parameter_list|,
name|Encoder
name|encoder
parameter_list|,
name|Progressable
name|progress
parameter_list|)
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Processing corrupt file "
operator|+
name|parityPath
argument_list|)
expr_stmt|;
name|Path
name|srcPath
init|=
name|sourcePathFromParityPath
argument_list|(
name|parityPath
argument_list|)
decl_stmt|;
if|if
condition|(
name|srcPath
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Unusable parity file "
operator|+
name|parityPath
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|DistributedFileSystem
name|parityFs
init|=
name|getDFS
argument_list|(
name|parityPath
argument_list|)
decl_stmt|;
name|FileStatus
name|parityStat
init|=
name|parityFs
operator|.
name|getFileStatus
argument_list|(
name|parityPath
argument_list|)
decl_stmt|;
name|long
name|blockSize
init|=
name|parityStat
operator|.
name|getBlockSize
argument_list|()
decl_stmt|;
name|long
name|parityFileSize
init|=
name|parityStat
operator|.
name|getLen
argument_list|()
decl_stmt|;
name|FileStatus
name|srcStat
init|=
name|getDFS
argument_list|(
name|srcPath
argument_list|)
operator|.
name|getFileStatus
argument_list|(
name|srcPath
argument_list|)
decl_stmt|;
name|long
name|srcFileSize
init|=
name|srcStat
operator|.
name|getLen
argument_list|()
decl_stmt|;
comment|// Check timestamp.
if|if
condition|(
name|srcStat
operator|.
name|getModificationTime
argument_list|()
operator|!=
name|parityStat
operator|.
name|getModificationTime
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Mismatching timestamp for "
operator|+
name|srcPath
operator|+
literal|" and "
operator|+
name|parityPath
operator|+
literal|", moving on..."
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|String
name|uriPath
init|=
name|parityPath
operator|.
name|toUri
argument_list|()
operator|.
name|getPath
argument_list|()
decl_stmt|;
name|int
name|numBlocksFixed
init|=
literal|0
decl_stmt|;
name|List
argument_list|<
name|LocatedBlock
argument_list|>
name|corrupt
init|=
name|RaidDFSUtil
operator|.
name|corruptBlocksInFile
argument_list|(
name|parityFs
argument_list|,
name|uriPath
argument_list|,
literal|0
argument_list|,
name|parityFileSize
argument_list|)
decl_stmt|;
if|if
condition|(
name|corrupt
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
literal|false
return|;
block|}
for|for
control|(
name|LocatedBlock
name|lb
range|:
name|corrupt
control|)
block|{
name|ExtendedBlock
name|corruptBlock
init|=
name|lb
operator|.
name|getBlock
argument_list|()
decl_stmt|;
name|long
name|corruptOffset
init|=
name|lb
operator|.
name|getStartOffset
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Found corrupt block "
operator|+
name|corruptBlock
operator|+
literal|", offset "
operator|+
name|corruptOffset
argument_list|)
expr_stmt|;
name|File
name|localBlockFile
init|=
name|File
operator|.
name|createTempFile
argument_list|(
name|corruptBlock
operator|.
name|getBlockName
argument_list|()
argument_list|,
literal|".tmp"
argument_list|)
decl_stmt|;
name|localBlockFile
operator|.
name|deleteOnExit
argument_list|()
expr_stmt|;
try|try
block|{
name|encoder
operator|.
name|recoverParityBlockToFile
argument_list|(
name|parityFs
argument_list|,
name|srcPath
argument_list|,
name|srcFileSize
argument_list|,
name|blockSize
argument_list|,
name|parityPath
argument_list|,
name|corruptOffset
argument_list|,
name|localBlockFile
argument_list|)
expr_stmt|;
comment|// We have a the contents of the block, send them.
name|DatanodeInfo
name|datanode
init|=
name|chooseDatanode
argument_list|(
name|lb
operator|.
name|getLocations
argument_list|()
argument_list|)
decl_stmt|;
name|computeMetadataAndSendFixedBlock
argument_list|(
name|datanode
argument_list|,
name|localBlockFile
argument_list|,
name|lb
argument_list|,
name|blockSize
argument_list|)
expr_stmt|;
name|numBlocksFixed
operator|++
expr_stmt|;
block|}
finally|finally
block|{
name|localBlockFile
operator|.
name|delete
argument_list|()
expr_stmt|;
block|}
name|progress
operator|.
name|progress
argument_list|()
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Fixed "
operator|+
name|numBlocksFixed
operator|+
literal|" blocks in "
operator|+
name|parityPath
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|/**      * Reads through a parity HAR part file, fixing corrupt blocks on the way.      * A HAR block can contain many file blocks, as long as the HAR part file      * block size is a multiple of the file block size.      * @return true if file has been fixed, false if no fixing       * was necessary or possible.      */
DECL|method|processCorruptParityHarPartFile (Path partFile, Progressable progress)
name|boolean
name|processCorruptParityHarPartFile
parameter_list|(
name|Path
name|partFile
parameter_list|,
name|Progressable
name|progress
parameter_list|)
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Processing corrupt file "
operator|+
name|partFile
argument_list|)
expr_stmt|;
comment|// Get some basic information.
name|DistributedFileSystem
name|dfs
init|=
name|getDFS
argument_list|(
name|partFile
argument_list|)
decl_stmt|;
name|FileStatus
name|partFileStat
init|=
name|dfs
operator|.
name|getFileStatus
argument_list|(
name|partFile
argument_list|)
decl_stmt|;
name|long
name|partFileSize
init|=
name|partFileStat
operator|.
name|getLen
argument_list|()
decl_stmt|;
name|long
name|partFileBlockSize
init|=
name|partFileStat
operator|.
name|getBlockSize
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|partFile
operator|+
literal|" has block size "
operator|+
name|partFileBlockSize
argument_list|)
expr_stmt|;
comment|// Find the path to the index file.
comment|// Parity file HARs are only one level deep, so the index files is at the
comment|// same level as the part file.
name|String
name|harDirectory
init|=
name|partFile
operator|.
name|toUri
argument_list|()
operator|.
name|getPath
argument_list|()
decl_stmt|;
comment|// Temporarily.
name|harDirectory
operator|=
name|harDirectory
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|harDirectory
operator|.
name|lastIndexOf
argument_list|(
name|Path
operator|.
name|SEPARATOR
argument_list|)
argument_list|)
expr_stmt|;
name|Path
name|indexFile
init|=
operator|new
name|Path
argument_list|(
name|harDirectory
operator|+
literal|"/"
operator|+
name|HarIndex
operator|.
name|indexFileName
argument_list|)
decl_stmt|;
name|FileStatus
name|indexStat
init|=
name|dfs
operator|.
name|getFileStatus
argument_list|(
name|indexFile
argument_list|)
decl_stmt|;
comment|// Parses through the HAR index file.
name|HarIndex
name|harIndex
init|=
operator|new
name|HarIndex
argument_list|(
name|dfs
operator|.
name|open
argument_list|(
name|indexFile
argument_list|)
argument_list|,
name|indexStat
operator|.
name|getLen
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|uriPath
init|=
name|partFile
operator|.
name|toUri
argument_list|()
operator|.
name|getPath
argument_list|()
decl_stmt|;
name|int
name|numBlocksFixed
init|=
literal|0
decl_stmt|;
name|List
argument_list|<
name|LocatedBlock
argument_list|>
name|corrupt
init|=
name|RaidDFSUtil
operator|.
name|corruptBlocksInFile
argument_list|(
name|dfs
argument_list|,
name|uriPath
argument_list|,
literal|0
argument_list|,
name|partFileSize
argument_list|)
decl_stmt|;
if|if
condition|(
name|corrupt
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
literal|false
return|;
block|}
for|for
control|(
name|LocatedBlock
name|lb
range|:
name|corrupt
control|)
block|{
name|ExtendedBlock
name|corruptBlock
init|=
name|lb
operator|.
name|getBlock
argument_list|()
decl_stmt|;
name|long
name|corruptOffset
init|=
name|lb
operator|.
name|getStartOffset
argument_list|()
decl_stmt|;
name|File
name|localBlockFile
init|=
name|File
operator|.
name|createTempFile
argument_list|(
name|corruptBlock
operator|.
name|getBlockName
argument_list|()
argument_list|,
literal|".tmp"
argument_list|)
decl_stmt|;
name|localBlockFile
operator|.
name|deleteOnExit
argument_list|()
expr_stmt|;
name|processCorruptParityHarPartBlock
argument_list|(
name|dfs
argument_list|,
name|partFile
argument_list|,
name|corruptBlock
argument_list|,
name|corruptOffset
argument_list|,
name|partFileStat
argument_list|,
name|harIndex
argument_list|,
name|localBlockFile
argument_list|,
name|progress
argument_list|)
expr_stmt|;
comment|// Now we have recovered the part file block locally, send it.
try|try
block|{
name|DatanodeInfo
name|datanode
init|=
name|chooseDatanode
argument_list|(
name|lb
operator|.
name|getLocations
argument_list|()
argument_list|)
decl_stmt|;
name|computeMetadataAndSendFixedBlock
argument_list|(
name|datanode
argument_list|,
name|localBlockFile
argument_list|,
name|lb
argument_list|,
name|localBlockFile
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
name|numBlocksFixed
operator|++
expr_stmt|;
block|}
finally|finally
block|{
name|localBlockFile
operator|.
name|delete
argument_list|()
expr_stmt|;
block|}
name|progress
operator|.
name|progress
argument_list|()
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Fixed "
operator|+
name|numBlocksFixed
operator|+
literal|" blocks in "
operator|+
name|partFile
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|/**      * This fixes a single part file block by recovering in sequence each      * parity block in the part file block.      */
DECL|method|processCorruptParityHarPartBlock (FileSystem dfs, Path partFile, ExtendedBlock corruptBlock, long corruptOffset, FileStatus partFileStat, HarIndex harIndex, File localBlockFile, Progressable progress)
specifier|private
name|void
name|processCorruptParityHarPartBlock
parameter_list|(
name|FileSystem
name|dfs
parameter_list|,
name|Path
name|partFile
parameter_list|,
name|ExtendedBlock
name|corruptBlock
parameter_list|,
name|long
name|corruptOffset
parameter_list|,
name|FileStatus
name|partFileStat
parameter_list|,
name|HarIndex
name|harIndex
parameter_list|,
name|File
name|localBlockFile
parameter_list|,
name|Progressable
name|progress
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|partName
init|=
name|partFile
operator|.
name|toUri
argument_list|()
operator|.
name|getPath
argument_list|()
decl_stmt|;
comment|// Temporarily.
name|partName
operator|=
name|partName
operator|.
name|substring
argument_list|(
literal|1
operator|+
name|partName
operator|.
name|lastIndexOf
argument_list|(
name|Path
operator|.
name|SEPARATOR
argument_list|)
argument_list|)
expr_stmt|;
name|OutputStream
name|out
init|=
operator|new
name|FileOutputStream
argument_list|(
name|localBlockFile
argument_list|)
decl_stmt|;
try|try
block|{
comment|// A HAR part file block could map to several parity files. We need to
comment|// use all of them to recover this block.
specifier|final
name|long
name|corruptEnd
init|=
name|Math
operator|.
name|min
argument_list|(
name|corruptOffset
operator|+
name|partFileStat
operator|.
name|getBlockSize
argument_list|()
argument_list|,
name|partFileStat
operator|.
name|getLen
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|long
name|offset
init|=
name|corruptOffset
init|;
name|offset
operator|<
name|corruptEnd
condition|;
control|)
block|{
name|HarIndex
operator|.
name|IndexEntry
name|entry
init|=
name|harIndex
operator|.
name|findEntry
argument_list|(
name|partName
argument_list|,
name|offset
argument_list|)
decl_stmt|;
if|if
condition|(
name|entry
operator|==
literal|null
condition|)
block|{
name|String
name|msg
init|=
literal|"Corrupt index file has no matching index entry for "
operator|+
name|partName
operator|+
literal|":"
operator|+
name|offset
decl_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
name|msg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
name|msg
argument_list|)
throw|;
block|}
name|Path
name|parityFile
init|=
operator|new
name|Path
argument_list|(
name|entry
operator|.
name|fileName
argument_list|)
decl_stmt|;
name|Encoder
name|encoder
decl_stmt|;
if|if
condition|(
name|isXorParityFile
argument_list|(
name|parityFile
argument_list|)
condition|)
block|{
name|encoder
operator|=
name|xorEncoder
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isRsParityFile
argument_list|(
name|parityFile
argument_list|)
condition|)
block|{
name|encoder
operator|=
name|rsEncoder
expr_stmt|;
block|}
else|else
block|{
name|String
name|msg
init|=
literal|"Could not figure out parity file correctly"
decl_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
name|msg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
name|msg
argument_list|)
throw|;
block|}
name|Path
name|srcFile
init|=
name|sourcePathFromParityPath
argument_list|(
name|parityFile
argument_list|)
decl_stmt|;
name|FileStatus
name|srcStat
init|=
name|dfs
operator|.
name|getFileStatus
argument_list|(
name|srcFile
argument_list|)
decl_stmt|;
if|if
condition|(
name|srcStat
operator|.
name|getModificationTime
argument_list|()
operator|!=
name|entry
operator|.
name|mtime
condition|)
block|{
name|String
name|msg
init|=
literal|"Modification times of "
operator|+
name|parityFile
operator|+
literal|" and "
operator|+
name|srcFile
operator|+
literal|" do not match."
decl_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
name|msg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
name|msg
argument_list|)
throw|;
block|}
name|long
name|corruptOffsetInParity
init|=
name|offset
operator|-
name|entry
operator|.
name|startOffset
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|partFile
operator|+
literal|":"
operator|+
name|offset
operator|+
literal|" maps to "
operator|+
name|parityFile
operator|+
literal|":"
operator|+
name|corruptOffsetInParity
operator|+
literal|" and will be recovered from "
operator|+
name|srcFile
argument_list|)
expr_stmt|;
name|encoder
operator|.
name|recoverParityBlockToStream
argument_list|(
name|dfs
argument_list|,
name|srcFile
argument_list|,
name|srcStat
operator|.
name|getLen
argument_list|()
argument_list|,
name|srcStat
operator|.
name|getBlockSize
argument_list|()
argument_list|,
name|parityFile
argument_list|,
name|corruptOffsetInParity
argument_list|,
name|out
argument_list|)
expr_stmt|;
comment|// Finished recovery of one parity block. Since a parity block has the
comment|// same size as a source block, we can move offset by source block size.
name|offset
operator|+=
name|srcStat
operator|.
name|getBlockSize
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Recovered "
operator|+
name|srcStat
operator|.
name|getBlockSize
argument_list|()
operator|+
literal|" part file bytes "
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|>
name|corruptEnd
condition|)
block|{
name|String
name|msg
init|=
literal|"Recovered block spills across part file blocks. Cannot continue."
decl_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
name|msg
argument_list|)
throw|;
block|}
name|progress
operator|.
name|progress
argument_list|()
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|out
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Choose a datanode (hostname:portnumber). The datanode is chosen at      * random from the live datanodes.      * @param locationsToAvoid locations to avoid.      * @return A datanode      * @throws IOException      */
DECL|method|chooseDatanode (DatanodeInfo[] locationsToAvoid)
specifier|private
name|DatanodeInfo
name|chooseDatanode
parameter_list|(
name|DatanodeInfo
index|[]
name|locationsToAvoid
parameter_list|)
throws|throws
name|IOException
block|{
name|DistributedFileSystem
name|dfs
init|=
name|getDFS
argument_list|(
operator|new
name|Path
argument_list|(
literal|"/"
argument_list|)
argument_list|)
decl_stmt|;
name|DatanodeInfo
index|[]
name|live
init|=
name|dfs
operator|.
name|getClient
argument_list|()
operator|.
name|datanodeReport
argument_list|(
name|DatanodeReportType
operator|.
name|LIVE
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Choosing a datanode from "
operator|+
name|live
operator|.
name|length
operator|+
literal|" live nodes while avoiding "
operator|+
name|locationsToAvoid
operator|.
name|length
argument_list|)
expr_stmt|;
name|Random
name|rand
init|=
operator|new
name|Random
argument_list|()
decl_stmt|;
name|DatanodeInfo
name|chosen
init|=
literal|null
decl_stmt|;
name|int
name|maxAttempts
init|=
literal|1000
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|maxAttempts
operator|&&
name|chosen
operator|==
literal|null
condition|;
name|i
operator|++
control|)
block|{
name|int
name|idx
init|=
name|rand
operator|.
name|nextInt
argument_list|(
name|live
operator|.
name|length
argument_list|)
decl_stmt|;
name|chosen
operator|=
name|live
index|[
name|idx
index|]
expr_stmt|;
for|for
control|(
name|DatanodeInfo
name|avoid
range|:
name|locationsToAvoid
control|)
block|{
if|if
condition|(
name|chosen
operator|.
name|name
operator|.
name|equals
argument_list|(
name|avoid
operator|.
name|name
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Avoiding "
operator|+
name|avoid
operator|.
name|name
argument_list|)
expr_stmt|;
name|chosen
operator|=
literal|null
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|chosen
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Could not choose datanode"
argument_list|)
throw|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Choosing datanode "
operator|+
name|chosen
operator|.
name|name
argument_list|)
expr_stmt|;
return|return
name|chosen
return|;
block|}
comment|/**      * Reads data from the data stream provided and computes metadata.      */
DECL|method|computeMetadata (Configuration conf, InputStream dataStream)
specifier|static
name|DataInputStream
name|computeMetadata
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|InputStream
name|dataStream
parameter_list|)
throws|throws
name|IOException
block|{
name|ByteArrayOutputStream
name|mdOutBase
init|=
operator|new
name|ByteArrayOutputStream
argument_list|(
literal|1024
operator|*
literal|1024
argument_list|)
decl_stmt|;
name|DataOutputStream
name|mdOut
init|=
operator|new
name|DataOutputStream
argument_list|(
name|mdOutBase
argument_list|)
decl_stmt|;
comment|// First, write out the version.
name|mdOut
operator|.
name|writeShort
argument_list|(
name|FSDataset
operator|.
name|METADATA_VERSION
argument_list|)
expr_stmt|;
comment|// Create a summer and write out its header.
name|int
name|bytesPerChecksum
init|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"io.bytes.per.checksum"
argument_list|,
literal|512
argument_list|)
decl_stmt|;
name|DataChecksum
name|sum
init|=
name|DataChecksum
operator|.
name|newDataChecksum
argument_list|(
name|DataChecksum
operator|.
name|CHECKSUM_CRC32
argument_list|,
name|bytesPerChecksum
argument_list|)
decl_stmt|;
name|sum
operator|.
name|writeHeader
argument_list|(
name|mdOut
argument_list|)
expr_stmt|;
comment|// Buffer to read in a chunk of data.
name|byte
index|[]
name|buf
init|=
operator|new
name|byte
index|[
name|bytesPerChecksum
index|]
decl_stmt|;
comment|// Buffer to store the checksum bytes.
name|byte
index|[]
name|chk
init|=
operator|new
name|byte
index|[
name|sum
operator|.
name|getChecksumSize
argument_list|()
index|]
decl_stmt|;
comment|// Read data till we reach the end of the input stream.
name|int
name|bytesSinceFlush
init|=
literal|0
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
comment|// Read some bytes.
name|int
name|bytesRead
init|=
name|dataStream
operator|.
name|read
argument_list|(
name|buf
argument_list|,
name|bytesSinceFlush
argument_list|,
name|bytesPerChecksum
operator|-
name|bytesSinceFlush
argument_list|)
decl_stmt|;
if|if
condition|(
name|bytesRead
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|bytesSinceFlush
operator|>
literal|0
condition|)
block|{
name|boolean
name|reset
init|=
literal|true
decl_stmt|;
name|sum
operator|.
name|writeValue
argument_list|(
name|chk
argument_list|,
literal|0
argument_list|,
name|reset
argument_list|)
expr_stmt|;
comment|// This also resets the sum.
comment|// Write the checksum to the stream.
name|mdOut
operator|.
name|write
argument_list|(
name|chk
argument_list|,
literal|0
argument_list|,
name|chk
operator|.
name|length
argument_list|)
expr_stmt|;
name|bytesSinceFlush
operator|=
literal|0
expr_stmt|;
block|}
break|break;
block|}
comment|// Update the checksum.
name|sum
operator|.
name|update
argument_list|(
name|buf
argument_list|,
name|bytesSinceFlush
argument_list|,
name|bytesRead
argument_list|)
expr_stmt|;
name|bytesSinceFlush
operator|+=
name|bytesRead
expr_stmt|;
comment|// Flush the checksum if necessary.
if|if
condition|(
name|bytesSinceFlush
operator|==
name|bytesPerChecksum
condition|)
block|{
name|boolean
name|reset
init|=
literal|true
decl_stmt|;
name|sum
operator|.
name|writeValue
argument_list|(
name|chk
argument_list|,
literal|0
argument_list|,
name|reset
argument_list|)
expr_stmt|;
comment|// This also resets the sum.
comment|// Write the checksum to the stream.
name|mdOut
operator|.
name|write
argument_list|(
name|chk
argument_list|,
literal|0
argument_list|,
name|chk
operator|.
name|length
argument_list|)
expr_stmt|;
name|bytesSinceFlush
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|byte
index|[]
name|mdBytes
init|=
name|mdOutBase
operator|.
name|toByteArray
argument_list|()
decl_stmt|;
return|return
operator|new
name|DataInputStream
argument_list|(
operator|new
name|ByteArrayInputStream
argument_list|(
name|mdBytes
argument_list|)
argument_list|)
return|;
block|}
DECL|method|computeMetadataAndSendFixedBlock (DatanodeInfo datanode, File localBlockFile, LocatedBlock block, long blockSize)
specifier|private
name|void
name|computeMetadataAndSendFixedBlock
parameter_list|(
name|DatanodeInfo
name|datanode
parameter_list|,
name|File
name|localBlockFile
parameter_list|,
name|LocatedBlock
name|block
parameter_list|,
name|long
name|blockSize
parameter_list|)
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Computing metdata"
argument_list|)
expr_stmt|;
name|InputStream
name|blockContents
init|=
literal|null
decl_stmt|;
name|DataInputStream
name|blockMetadata
init|=
literal|null
decl_stmt|;
try|try
block|{
name|blockContents
operator|=
operator|new
name|FileInputStream
argument_list|(
name|localBlockFile
argument_list|)
expr_stmt|;
name|blockMetadata
operator|=
name|computeMetadata
argument_list|(
name|getConf
argument_list|()
argument_list|,
name|blockContents
argument_list|)
expr_stmt|;
name|blockContents
operator|.
name|close
argument_list|()
expr_stmt|;
comment|// Reopen
name|blockContents
operator|=
operator|new
name|FileInputStream
argument_list|(
name|localBlockFile
argument_list|)
expr_stmt|;
name|sendFixedBlock
argument_list|(
name|datanode
argument_list|,
name|blockContents
argument_list|,
name|blockMetadata
argument_list|,
name|block
argument_list|,
name|blockSize
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|blockContents
operator|!=
literal|null
condition|)
block|{
name|blockContents
operator|.
name|close
argument_list|()
expr_stmt|;
name|blockContents
operator|=
literal|null
expr_stmt|;
block|}
if|if
condition|(
name|blockMetadata
operator|!=
literal|null
condition|)
block|{
name|blockMetadata
operator|.
name|close
argument_list|()
expr_stmt|;
name|blockMetadata
operator|=
literal|null
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Send a generated block to a datanode.      * @param datanode Chosen datanode name in host:port form.      * @param blockContents Stream with the block contents.      * @param corruptBlock Block identifying the block to be sent.      * @param blockSize size of the block.      * @throws IOException      */
DECL|method|sendFixedBlock (DatanodeInfo datanode, final InputStream blockContents, DataInputStream metadataIn, LocatedBlock block, long blockSize)
specifier|private
name|void
name|sendFixedBlock
parameter_list|(
name|DatanodeInfo
name|datanode
parameter_list|,
specifier|final
name|InputStream
name|blockContents
parameter_list|,
name|DataInputStream
name|metadataIn
parameter_list|,
name|LocatedBlock
name|block
parameter_list|,
name|long
name|blockSize
parameter_list|)
throws|throws
name|IOException
block|{
name|InetSocketAddress
name|target
init|=
name|NetUtils
operator|.
name|createSocketAddr
argument_list|(
name|datanode
operator|.
name|name
argument_list|)
decl_stmt|;
name|Socket
name|sock
init|=
name|SocketChannel
operator|.
name|open
argument_list|()
operator|.
name|socket
argument_list|()
decl_stmt|;
name|int
name|readTimeout
init|=
name|getConf
argument_list|()
operator|.
name|getInt
argument_list|(
name|BLOCKFIX_READ_TIMEOUT
argument_list|,
name|HdfsConstants
operator|.
name|READ_TIMEOUT
argument_list|)
decl_stmt|;
name|NetUtils
operator|.
name|connect
argument_list|(
name|sock
argument_list|,
name|target
argument_list|,
name|readTimeout
argument_list|)
expr_stmt|;
name|sock
operator|.
name|setSoTimeout
argument_list|(
name|readTimeout
argument_list|)
expr_stmt|;
name|int
name|writeTimeout
init|=
name|getConf
argument_list|()
operator|.
name|getInt
argument_list|(
name|BLOCKFIX_WRITE_TIMEOUT
argument_list|,
name|HdfsConstants
operator|.
name|WRITE_TIMEOUT
argument_list|)
decl_stmt|;
name|OutputStream
name|baseStream
init|=
name|NetUtils
operator|.
name|getOutputStream
argument_list|(
name|sock
argument_list|,
name|writeTimeout
argument_list|)
decl_stmt|;
name|DataOutputStream
name|out
init|=
operator|new
name|DataOutputStream
argument_list|(
operator|new
name|BufferedOutputStream
argument_list|(
name|baseStream
argument_list|,
name|FSConstants
operator|.
name|SMALL_BUFFER_SIZE
argument_list|)
argument_list|)
decl_stmt|;
name|boolean
name|corruptChecksumOk
init|=
literal|false
decl_stmt|;
name|boolean
name|chunkOffsetOK
init|=
literal|false
decl_stmt|;
name|boolean
name|verifyChecksum
init|=
literal|true
decl_stmt|;
name|boolean
name|transferToAllowed
init|=
literal|false
decl_stmt|;
try|try
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Sending block "
operator|+
name|block
operator|.
name|getBlock
argument_list|()
operator|+
literal|" from "
operator|+
name|sock
operator|.
name|getLocalSocketAddress
argument_list|()
operator|.
name|toString
argument_list|()
operator|+
literal|" to "
operator|+
name|sock
operator|.
name|getRemoteSocketAddress
argument_list|()
operator|.
name|toString
argument_list|()
operator|+
literal|" "
operator|+
name|blockSize
operator|+
literal|" bytes"
argument_list|)
expr_stmt|;
name|RaidBlockSender
name|blockSender
init|=
operator|new
name|RaidBlockSender
argument_list|(
name|block
operator|.
name|getBlock
argument_list|()
argument_list|,
name|blockSize
argument_list|,
literal|0
argument_list|,
name|blockSize
argument_list|,
name|corruptChecksumOk
argument_list|,
name|chunkOffsetOK
argument_list|,
name|verifyChecksum
argument_list|,
name|transferToAllowed
argument_list|,
name|metadataIn
argument_list|,
operator|new
name|RaidBlockSender
operator|.
name|InputStreamFactory
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|InputStream
name|createStream
parameter_list|(
name|long
name|offset
parameter_list|)
throws|throws
name|IOException
block|{
comment|// we are passing 0 as the offset above,
comment|// so we can safely ignore
comment|// the offset passed
return|return
name|blockContents
return|;
block|}
block|}
argument_list|)
decl_stmt|;
name|DatanodeInfo
index|[]
name|nodes
init|=
operator|new
name|DatanodeInfo
index|[]
block|{
name|datanode
block|}
decl_stmt|;
name|Sender
operator|.
name|opWriteBlock
argument_list|(
name|out
argument_list|,
name|block
operator|.
name|getBlock
argument_list|()
argument_list|,
literal|1
argument_list|,
name|BlockConstructionStage
operator|.
name|PIPELINE_SETUP_CREATE
argument_list|,
literal|0
argument_list|,
name|blockSize
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|,
literal|null
argument_list|,
name|nodes
argument_list|,
name|block
operator|.
name|getBlockToken
argument_list|()
argument_list|)
expr_stmt|;
name|blockSender
operator|.
name|sendBlock
argument_list|(
name|out
argument_list|,
name|baseStream
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Sent block "
operator|+
name|block
operator|.
name|getBlock
argument_list|()
operator|+
literal|" to "
operator|+
name|datanode
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|out
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * returns the source file corresponding to a parity file      */
DECL|method|sourcePathFromParityPath (Path parityPath)
name|Path
name|sourcePathFromParityPath
parameter_list|(
name|Path
name|parityPath
parameter_list|)
block|{
name|String
name|parityPathStr
init|=
name|parityPath
operator|.
name|toUri
argument_list|()
operator|.
name|getPath
argument_list|()
decl_stmt|;
if|if
condition|(
name|parityPathStr
operator|.
name|startsWith
argument_list|(
name|xorPrefix
argument_list|)
condition|)
block|{
comment|// Remove the prefix to get the source file.
name|String
name|src
init|=
name|parityPathStr
operator|.
name|replaceFirst
argument_list|(
name|xorPrefix
argument_list|,
literal|"/"
argument_list|)
decl_stmt|;
return|return
operator|new
name|Path
argument_list|(
name|src
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|parityPathStr
operator|.
name|startsWith
argument_list|(
name|rsPrefix
argument_list|)
condition|)
block|{
comment|// Remove the prefix to get the source file.
name|String
name|src
init|=
name|parityPathStr
operator|.
name|replaceFirst
argument_list|(
name|rsPrefix
argument_list|,
literal|"/"
argument_list|)
decl_stmt|;
return|return
operator|new
name|Path
argument_list|(
name|src
argument_list|)
return|;
block|}
return|return
literal|null
return|;
block|}
comment|/**      * Returns the corrupt blocks in a file.      */
DECL|method|corruptBlocksInFile (DistributedFileSystem fs, String uriPath, FileStatus stat)
name|List
argument_list|<
name|LocatedBlock
argument_list|>
name|corruptBlocksInFile
parameter_list|(
name|DistributedFileSystem
name|fs
parameter_list|,
name|String
name|uriPath
parameter_list|,
name|FileStatus
name|stat
parameter_list|)
throws|throws
name|IOException
block|{
name|List
argument_list|<
name|LocatedBlock
argument_list|>
name|corrupt
init|=
operator|new
name|LinkedList
argument_list|<
name|LocatedBlock
argument_list|>
argument_list|()
decl_stmt|;
name|LocatedBlocks
name|locatedBlocks
init|=
name|RaidDFSUtil
operator|.
name|getBlockLocations
argument_list|(
name|fs
argument_list|,
name|uriPath
argument_list|,
literal|0
argument_list|,
name|stat
operator|.
name|getLen
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|LocatedBlock
name|b
range|:
name|locatedBlocks
operator|.
name|getLocatedBlocks
argument_list|()
control|)
block|{
if|if
condition|(
name|b
operator|.
name|isCorrupt
argument_list|()
operator|||
operator|(
name|b
operator|.
name|getLocations
argument_list|()
operator|.
name|length
operator|==
literal|0
operator|&&
name|b
operator|.
name|getBlockSize
argument_list|()
operator|>
literal|0
operator|)
condition|)
block|{
name|corrupt
operator|.
name|add
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|corrupt
return|;
block|}
block|}
block|}
end_class

end_unit

