begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.vertica
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|vertica
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|Connection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|ResultSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|Statement
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|Text
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|Job
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|JobContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|OutputCommitter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|OutputFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|RecordWriter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|TaskAttemptContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|lib
operator|.
name|output
operator|.
name|FileOutputCommitter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|lib
operator|.
name|output
operator|.
name|FileOutputFormat
import|;
end_import

begin_comment
comment|/**  * Output formatter for loading reducer output to Vertica  *   */
end_comment

begin_class
DECL|class|VerticaOutputFormat
specifier|public
class|class
name|VerticaOutputFormat
extends|extends
name|OutputFormat
argument_list|<
name|Text
argument_list|,
name|VerticaRecord
argument_list|>
block|{
DECL|field|delimiter
name|String
name|delimiter
init|=
name|VerticaConfiguration
operator|.
name|DELIMITER
decl_stmt|;
DECL|field|terminator
name|String
name|terminator
init|=
name|VerticaConfiguration
operator|.
name|RECORD_TERMINATER
decl_stmt|;
comment|/**    * Set the output table    *     * @param job    * @param tableName    */
DECL|method|setOutput (Job job, String tableName)
specifier|public
specifier|static
name|void
name|setOutput
parameter_list|(
name|Job
name|job
parameter_list|,
name|String
name|tableName
parameter_list|)
block|{
name|setOutput
argument_list|(
name|job
argument_list|,
name|tableName
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/**    * Set the output table and whether to drop it before loading    *     * @param job    * @param tableName    * @param dropTable    */
DECL|method|setOutput (Job job, String tableName, boolean dropTable)
specifier|public
specifier|static
name|void
name|setOutput
parameter_list|(
name|Job
name|job
parameter_list|,
name|String
name|tableName
parameter_list|,
name|boolean
name|dropTable
parameter_list|)
block|{
name|setOutput
argument_list|(
name|job
argument_list|,
name|tableName
argument_list|,
name|dropTable
argument_list|,
operator|(
name|String
index|[]
operator|)
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**    * Set the output table, whether to drop it before loading and the create    * table specification if it doesn't exist    *     * @param job    * @param tableName    * @param dropTable    * @param tableDef    *          list of column definitions such as "foo int", "bar varchar(10)"    */
DECL|method|setOutput (Job job, String tableName, boolean dropTable, String... tableDef)
specifier|public
specifier|static
name|void
name|setOutput
parameter_list|(
name|Job
name|job
parameter_list|,
name|String
name|tableName
parameter_list|,
name|boolean
name|dropTable
parameter_list|,
name|String
modifier|...
name|tableDef
parameter_list|)
block|{
name|VerticaConfiguration
name|vtconfig
init|=
operator|new
name|VerticaConfiguration
argument_list|(
name|job
operator|.
name|getConfiguration
argument_list|()
argument_list|)
decl_stmt|;
name|vtconfig
operator|.
name|setOutputTableName
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
name|vtconfig
operator|.
name|setOutputTableDef
argument_list|(
name|tableDef
argument_list|)
expr_stmt|;
name|vtconfig
operator|.
name|setDropTable
argument_list|(
name|dropTable
argument_list|)
expr_stmt|;
block|}
comment|// TODO: handle collection of output tables private class VerticaTable {
comment|/** {@inheritDoc} */
DECL|method|checkOutputSpecs (JobContext context)
specifier|public
name|void
name|checkOutputSpecs
parameter_list|(
name|JobContext
name|context
parameter_list|)
throws|throws
name|IOException
block|{
name|VerticaUtil
operator|.
name|checkOutputSpecs
argument_list|(
name|context
operator|.
name|getConfiguration
argument_list|()
argument_list|)
expr_stmt|;
name|VerticaConfiguration
name|vtconfig
init|=
operator|new
name|VerticaConfiguration
argument_list|(
name|context
operator|.
name|getConfiguration
argument_list|()
argument_list|)
decl_stmt|;
name|delimiter
operator|=
name|vtconfig
operator|.
name|getOutputDelimiter
argument_list|()
expr_stmt|;
name|terminator
operator|=
name|vtconfig
operator|.
name|getOutputRecordTerminator
argument_list|()
expr_stmt|;
block|}
comment|/**    * Test check specs (don't connect to db)    *     * @param context    * @param test    *          true if testing    * @throws IOException    */
DECL|method|checkOutputSpecs (JobContext context, boolean test)
specifier|public
name|void
name|checkOutputSpecs
parameter_list|(
name|JobContext
name|context
parameter_list|,
name|boolean
name|test
parameter_list|)
throws|throws
name|IOException
block|{
name|VerticaUtil
operator|.
name|checkOutputSpecs
argument_list|(
name|context
operator|.
name|getConfiguration
argument_list|()
argument_list|)
expr_stmt|;
name|VerticaConfiguration
name|vtconfig
init|=
operator|new
name|VerticaConfiguration
argument_list|(
name|context
operator|.
name|getConfiguration
argument_list|()
argument_list|)
decl_stmt|;
name|delimiter
operator|=
name|vtconfig
operator|.
name|getOutputDelimiter
argument_list|()
expr_stmt|;
name|terminator
operator|=
name|vtconfig
operator|.
name|getOutputRecordTerminator
argument_list|()
expr_stmt|;
block|}
comment|/** {@inheritDoc} */
DECL|method|getRecordWriter ( TaskAttemptContext context)
specifier|public
name|RecordWriter
argument_list|<
name|Text
argument_list|,
name|VerticaRecord
argument_list|>
name|getRecordWriter
parameter_list|(
name|TaskAttemptContext
name|context
parameter_list|)
throws|throws
name|IOException
block|{
name|VerticaConfiguration
name|config
init|=
operator|new
name|VerticaConfiguration
argument_list|(
name|context
operator|.
name|getConfiguration
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|name
init|=
name|context
operator|.
name|getJobName
argument_list|()
decl_stmt|;
comment|// TODO: use explicit date formats
name|String
name|table
init|=
name|config
operator|.
name|getOutputTableName
argument_list|()
decl_stmt|;
name|String
name|copyStmt
init|=
literal|"COPY "
operator|+
name|table
operator|+
literal|" FROM STDIN"
operator|+
literal|" DELIMITER '"
operator|+
name|delimiter
operator|+
literal|"' RECORD TERMINATOR '"
operator|+
name|terminator
operator|+
literal|"' STREAM NAME '"
operator|+
name|name
operator|+
literal|"' DIRECT"
decl_stmt|;
try|try
block|{
name|Connection
name|conn
init|=
name|config
operator|.
name|getConnection
argument_list|(
literal|true
argument_list|)
decl_stmt|;
return|return
operator|new
name|VerticaRecordWriter
argument_list|(
name|conn
argument_list|,
name|copyStmt
argument_list|,
name|table
argument_list|,
name|delimiter
argument_list|,
name|terminator
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
DECL|method|getValue (Configuration conf)
specifier|public
specifier|static
name|VerticaRecord
name|getValue
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|Exception
block|{
name|VerticaConfiguration
name|config
init|=
operator|new
name|VerticaConfiguration
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|String
name|table
init|=
name|config
operator|.
name|getOutputTableName
argument_list|()
decl_stmt|;
name|Connection
name|conn
init|=
name|config
operator|.
name|getConnection
argument_list|(
literal|true
argument_list|)
decl_stmt|;
return|return
operator|(
operator|new
name|VerticaRecordWriter
argument_list|(
name|conn
argument_list|,
literal|""
argument_list|,
name|table
argument_list|,
name|config
operator|.
name|getOutputDelimiter
argument_list|()
argument_list|,
name|config
operator|.
name|getOutputRecordTerminator
argument_list|()
argument_list|)
operator|)
operator|.
name|getValue
argument_list|()
return|;
block|}
comment|/**    * Optionally called at the end of a job to optimize any newly created and    * loaded tables. Useful for new tables with more than 100k records.    *     * @param conf    * @throws Exception    */
DECL|method|optimize (Configuration conf)
specifier|public
specifier|static
name|void
name|optimize
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|Exception
block|{
name|VerticaConfiguration
name|vtconfig
init|=
operator|new
name|VerticaConfiguration
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|Connection
name|conn
init|=
name|vtconfig
operator|.
name|getConnection
argument_list|(
literal|true
argument_list|)
decl_stmt|;
comment|// TODO: consider more tables and skip tables with non-temp projections
name|String
name|tableName
init|=
name|vtconfig
operator|.
name|getOutputTableName
argument_list|()
decl_stmt|;
name|Statement
name|stmt
init|=
name|conn
operator|.
name|createStatement
argument_list|()
decl_stmt|;
name|ResultSet
name|rs
init|=
literal|null
decl_stmt|;
name|StringBuffer
name|designTables
init|=
operator|new
name|StringBuffer
argument_list|(
name|tableName
argument_list|)
decl_stmt|;
name|HashSet
argument_list|<
name|String
argument_list|>
name|tablesWithTemp
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
comment|//fully qualify the table name - defaults to public.<table>
if|if
condition|(
name|tableName
operator|.
name|indexOf
argument_list|(
literal|"."
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|tableName
operator|=
literal|"public."
operator|+
name|tableName
expr_stmt|;
block|}
comment|//for now just add the single output table
name|tablesWithTemp
operator|.
name|add
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
comment|// map from table name to set of projection names
name|HashMap
argument_list|<
name|String
argument_list|,
name|Collection
argument_list|<
name|String
argument_list|>
argument_list|>
name|tableProj
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Collection
argument_list|<
name|String
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|rs
operator|=
name|stmt
operator|.
name|executeQuery
argument_list|(
literal|"select schemaname, anchortablename, projname from vt_projection;"
argument_list|)
expr_stmt|;
while|while
condition|(
name|rs
operator|.
name|next
argument_list|()
condition|)
block|{
name|String
name|ptable
init|=
name|rs
operator|.
name|getString
argument_list|(
literal|1
argument_list|)
operator|+
literal|"."
operator|+
name|rs
operator|.
name|getString
argument_list|(
literal|2
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|tableProj
operator|.
name|containsKey
argument_list|(
name|ptable
argument_list|)
condition|)
block|{
name|tableProj
operator|.
name|put
argument_list|(
name|ptable
argument_list|,
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|tableProj
operator|.
name|get
argument_list|(
name|ptable
argument_list|)
operator|.
name|add
argument_list|(
name|rs
operator|.
name|getString
argument_list|(
literal|3
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|String
name|table
range|:
name|tablesWithTemp
control|)
block|{
if|if
condition|(
operator|!
name|tableProj
operator|.
name|containsKey
argument_list|(
name|table
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Cannot optimize table with no data: "
operator|+
name|table
argument_list|)
throw|;
block|}
block|}
name|String
name|designName
init|=
operator|(
operator|new
name|Integer
argument_list|(
name|conn
operator|.
name|hashCode
argument_list|()
argument_list|)
operator|)
operator|.
name|toString
argument_list|()
decl_stmt|;
name|stmt
operator|.
name|execute
argument_list|(
literal|"select create_projection_design('"
operator|+
name|designName
operator|+
literal|"', '', '"
operator|+
name|designTables
operator|.
name|toString
argument_list|()
operator|+
literal|"')"
argument_list|)
expr_stmt|;
if|if
condition|(
name|VerticaUtil
operator|.
name|verticaVersion
argument_list|(
name|conf
argument_list|,
literal|true
argument_list|)
operator|>=
name|VerticaConfiguration
operator|.
name|VERSION_3_5
condition|)
block|{
name|stmt
operator|.
name|execute
argument_list|(
literal|"select deploy_design('"
operator|+
name|designName
operator|+
literal|"', '"
operator|+
name|designName
operator|+
literal|"')"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rs
operator|=
name|stmt
operator|.
name|executeQuery
argument_list|(
literal|"select get_design_script('"
operator|+
name|designName
operator|+
literal|"', '"
operator|+
name|designName
operator|+
literal|"')"
argument_list|)
expr_stmt|;
name|rs
operator|.
name|next
argument_list|()
expr_stmt|;
name|String
index|[]
name|projSet
init|=
name|rs
operator|.
name|getString
argument_list|(
literal|1
argument_list|)
operator|.
name|split
argument_list|(
literal|";"
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|proj
range|:
name|projSet
control|)
block|{
name|stmt
operator|.
name|execute
argument_list|(
name|proj
argument_list|)
expr_stmt|;
block|}
name|stmt
operator|.
name|execute
argument_list|(
literal|"select start_refresh()"
argument_list|)
expr_stmt|;
comment|// poll for refresh complete
name|boolean
name|refreshing
init|=
literal|true
decl_stmt|;
name|Long
name|timeout
init|=
name|vtconfig
operator|.
name|getOptimizePollTimeout
argument_list|()
decl_stmt|;
while|while
condition|(
name|refreshing
condition|)
block|{
name|refreshing
operator|=
literal|false
expr_stmt|;
name|rs
operator|=
name|stmt
operator|.
name|executeQuery
argument_list|(
literal|"select table_name, status from vt_projection_refresh"
argument_list|)
expr_stmt|;
while|while
condition|(
name|rs
operator|.
name|next
argument_list|()
condition|)
block|{
name|String
name|table
init|=
name|rs
operator|.
name|getString
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|String
name|stat
init|=
name|rs
operator|.
name|getString
argument_list|(
literal|2
argument_list|)
decl_stmt|;
if|if
condition|(
name|stat
operator|.
name|equals
argument_list|(
literal|"refreshing"
argument_list|)
operator|&&
name|tablesWithTemp
operator|.
name|contains
argument_list|(
name|table
argument_list|)
condition|)
name|refreshing
operator|=
literal|true
expr_stmt|;
block|}
name|rs
operator|.
name|close
argument_list|()
expr_stmt|;
name|Thread
operator|.
name|sleep
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
block|}
comment|// refresh done, move the ancient history mark (ahm) and drop the temp projections
name|stmt
operator|.
name|execute
argument_list|(
literal|"select make_ahm_now()"
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|table
range|:
name|tablesWithTemp
control|)
block|{
for|for
control|(
name|String
name|proj
range|:
name|tableProj
operator|.
name|get
argument_list|(
name|table
argument_list|)
control|)
block|{
name|stmt
operator|.
name|execute
argument_list|(
literal|"DROP PROJECTION "
operator|+
name|proj
argument_list|)
expr_stmt|;
block|}
block|}
name|stmt
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** (@inheritDoc) */
DECL|method|getOutputCommitter (TaskAttemptContext context)
specifier|public
name|OutputCommitter
name|getOutputCommitter
parameter_list|(
name|TaskAttemptContext
name|context
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
return|return
operator|new
name|FileOutputCommitter
argument_list|(
name|FileOutputFormat
operator|.
name|getOutputPath
argument_list|(
name|context
argument_list|)
argument_list|,
name|context
argument_list|)
return|;
block|}
block|}
end_class

end_unit

