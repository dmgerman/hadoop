begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.examples.pi.math
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|examples
operator|.
name|pi
operator|.
name|math
package|;
end_package

begin_comment
comment|/** Modular arithmetics */
end_comment

begin_class
DECL|class|Modular
specifier|public
class|class
name|Modular
block|{
DECL|field|MAX_SQRT_LONG
specifier|static
specifier|final
name|long
name|MAX_SQRT_LONG
init|=
operator|(
name|long
operator|)
name|Math
operator|.
name|sqrt
argument_list|(
name|Long
operator|.
name|MAX_VALUE
argument_list|)
decl_stmt|;
comment|/** Compute 2^e mod n */
DECL|method|mod (long e, long n)
specifier|public
specifier|static
name|long
name|mod
parameter_list|(
name|long
name|e
parameter_list|,
name|long
name|n
parameter_list|)
block|{
specifier|final
name|int
name|HALF
init|=
operator|(
literal|63
operator|-
name|Long
operator|.
name|numberOfLeadingZeros
argument_list|(
name|n
argument_list|)
operator|)
operator|>>
literal|1
decl_stmt|;
specifier|final
name|int
name|FULL
init|=
name|HALF
operator|<<
literal|1
decl_stmt|;
specifier|final
name|long
name|ONES
init|=
operator|(
literal|1
operator|<<
name|HALF
operator|)
operator|-
literal|1
decl_stmt|;
name|long
name|r
init|=
literal|2
decl_stmt|;
for|for
control|(
name|long
name|mask
init|=
name|Long
operator|.
name|highestOneBit
argument_list|(
name|e
argument_list|)
operator|>>
literal|1
init|;
name|mask
operator|>
literal|0
condition|;
name|mask
operator|>>=
literal|1
control|)
block|{
if|if
condition|(
name|r
operator|<=
name|MAX_SQRT_LONG
condition|)
block|{
name|r
operator|*=
name|r
expr_stmt|;
if|if
condition|(
name|r
operator|>=
name|n
condition|)
name|r
operator|%=
name|n
expr_stmt|;
block|}
else|else
block|{
comment|// r^2 will overflow
specifier|final
name|long
name|high
init|=
name|r
operator|>>>
name|HALF
decl_stmt|;
specifier|final
name|long
name|low
init|=
name|r
operator|&=
name|ONES
decl_stmt|;
name|r
operator|*=
name|r
expr_stmt|;
if|if
condition|(
name|r
operator|>=
name|n
condition|)
name|r
operator|%=
name|n
expr_stmt|;
if|if
condition|(
name|high
operator|!=
literal|0
condition|)
block|{
name|long
name|s
init|=
name|high
operator|*
name|high
decl_stmt|;
if|if
condition|(
name|s
operator|>=
name|n
condition|)
name|s
operator|%=
name|n
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|FULL
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|s
operator|<<=
literal|1
operator|)
operator|>=
name|n
condition|)
name|s
operator|-=
name|n
expr_stmt|;
if|if
condition|(
name|low
operator|==
literal|0
condition|)
name|r
operator|=
name|s
expr_stmt|;
else|else
block|{
name|long
name|t
init|=
name|high
operator|*
name|low
decl_stmt|;
if|if
condition|(
name|t
operator|>=
name|n
condition|)
name|t
operator|%=
name|n
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
operator|-
literal|1
init|;
name|i
operator|<
name|HALF
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|t
operator|<<=
literal|1
operator|)
operator|>=
name|n
condition|)
name|t
operator|-=
name|n
expr_stmt|;
name|r
operator|+=
name|s
expr_stmt|;
if|if
condition|(
name|r
operator|>=
name|n
condition|)
name|r
operator|-=
name|n
expr_stmt|;
name|r
operator|+=
name|t
expr_stmt|;
if|if
condition|(
name|r
operator|>=
name|n
condition|)
name|r
operator|-=
name|n
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|(
name|e
operator|&
name|mask
operator|)
operator|!=
literal|0
condition|)
block|{
name|r
operator|<<=
literal|1
expr_stmt|;
if|if
condition|(
name|r
operator|>=
name|n
condition|)
name|r
operator|-=
name|n
expr_stmt|;
block|}
block|}
return|return
name|r
return|;
block|}
comment|/** Given x in [0,1) and a in (-1,1),    * return (x, a) mod 1.0.     */
DECL|method|addMod (double x, final double a)
specifier|public
specifier|static
name|double
name|addMod
parameter_list|(
name|double
name|x
parameter_list|,
specifier|final
name|double
name|a
parameter_list|)
block|{
name|x
operator|+=
name|a
expr_stmt|;
return|return
name|x
operator|>=
literal|1
condition|?
name|x
operator|-
literal|1
else|:
name|x
operator|<
literal|0
condition|?
name|x
operator|+
literal|1
else|:
name|x
return|;
block|}
comment|/** Given 0< x< y,    * return x^(-1) mod y.    */
DECL|method|modInverse (final long x, final long y)
specifier|public
specifier|static
name|long
name|modInverse
parameter_list|(
specifier|final
name|long
name|x
parameter_list|,
specifier|final
name|long
name|y
parameter_list|)
block|{
if|if
condition|(
name|x
operator|==
literal|1
condition|)
return|return
literal|1
return|;
name|long
name|a
init|=
literal|1
decl_stmt|;
name|long
name|b
init|=
literal|0
decl_stmt|;
name|long
name|c
init|=
name|x
decl_stmt|;
name|long
name|u
init|=
literal|0
decl_stmt|;
name|long
name|v
init|=
literal|1
decl_stmt|;
name|long
name|w
init|=
name|y
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
block|{
specifier|final
name|long
name|q
init|=
name|w
operator|/
name|c
decl_stmt|;
name|w
operator|-=
name|q
operator|*
name|c
expr_stmt|;
name|u
operator|-=
name|q
operator|*
name|a
expr_stmt|;
if|if
condition|(
name|w
operator|==
literal|1
condition|)
return|return
name|u
operator|>
literal|0
condition|?
name|u
else|:
name|u
operator|+
name|y
return|;
name|v
operator|-=
name|q
operator|*
name|b
expr_stmt|;
block|}
block|{
specifier|final
name|long
name|q
init|=
name|c
operator|/
name|w
decl_stmt|;
name|c
operator|-=
name|q
operator|*
name|w
expr_stmt|;
name|a
operator|-=
name|q
operator|*
name|u
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|1
condition|)
return|return
name|a
operator|>
literal|0
condition|?
name|a
else|:
name|a
operator|+
name|y
return|;
name|b
operator|-=
name|q
operator|*
name|v
expr_stmt|;
block|}
block|}
block|}
block|}
end_class

end_unit

