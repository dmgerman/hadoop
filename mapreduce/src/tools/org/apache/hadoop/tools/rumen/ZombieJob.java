begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.tools.rumen
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|tools
operator|.
name|rumen
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Random
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|JobConf
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|TaskStatus
operator|.
name|State
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|InputSplit
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|JobID
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|TaskAttemptID
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|TaskID
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|TaskType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|lib
operator|.
name|input
operator|.
name|FileSplit
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|tools
operator|.
name|rumen
operator|.
name|Pre21JobHistoryConstants
operator|.
name|Values
import|;
end_import

begin_comment
comment|/**  * {@link ZombieJob} is a layer above {@link LoggedJob} raw JSON objects.  *   * Each {@link ZombieJob} object represents a job in job history. For everything  * that exists in job history, contents are returned unchanged faithfully. To  * get input splits of a non-exist task, a non-exist task attempt, or an  * ill-formed task attempt, proper objects are made up from statistical  * sketches.  */
end_comment

begin_class
annotation|@
name|SuppressWarnings
argument_list|(
literal|"deprecation"
argument_list|)
DECL|class|ZombieJob
specifier|public
class|class
name|ZombieJob
implements|implements
name|JobStory
block|{
DECL|field|LOG
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|ZombieJob
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|job
specifier|private
specifier|final
name|LoggedJob
name|job
decl_stmt|;
DECL|field|loggedTaskMap
specifier|private
name|Map
argument_list|<
name|TaskID
argument_list|,
name|LoggedTask
argument_list|>
name|loggedTaskMap
decl_stmt|;
DECL|field|loggedTaskAttemptMap
specifier|private
name|Map
argument_list|<
name|TaskAttemptID
argument_list|,
name|LoggedTaskAttempt
argument_list|>
name|loggedTaskAttemptMap
decl_stmt|;
DECL|field|random
specifier|private
specifier|final
name|Random
name|random
decl_stmt|;
DECL|field|splits
specifier|private
name|InputSplit
index|[]
name|splits
decl_stmt|;
DECL|field|cluster
specifier|private
specifier|final
name|ClusterStory
name|cluster
decl_stmt|;
DECL|field|jobConf
specifier|private
name|JobConf
name|jobConf
decl_stmt|;
DECL|field|seed
specifier|private
name|long
name|seed
decl_stmt|;
DECL|field|numRandomSeeds
specifier|private
name|long
name|numRandomSeeds
init|=
literal|0
decl_stmt|;
DECL|field|hasRandomSeed
specifier|private
name|boolean
name|hasRandomSeed
init|=
literal|false
decl_stmt|;
DECL|field|interpolatorMap
specifier|private
name|Map
argument_list|<
name|LoggedDiscreteCDF
argument_list|,
name|CDFRandomGenerator
argument_list|>
name|interpolatorMap
init|=
operator|new
name|HashMap
argument_list|<
name|LoggedDiscreteCDF
argument_list|,
name|CDFRandomGenerator
argument_list|>
argument_list|()
decl_stmt|;
comment|// TODO: Fix ZombieJob to initialize this correctly from observed data
DECL|field|rackLocalOverNodeLocal
name|double
name|rackLocalOverNodeLocal
init|=
literal|1.5
decl_stmt|;
DECL|field|rackRemoteOverNodeLocal
name|double
name|rackRemoteOverNodeLocal
init|=
literal|3.0
decl_stmt|;
comment|/**    * This constructor creates a {@link ZombieJob} with the same semantics as the    * {@link LoggedJob} passed in this parameter    *     * @param job    *          The dead job this ZombieJob instance is based on.    * @param cluster    *          The cluster topology where the dead job ran on. This argument can    *          be null if we do not have knowledge of the cluster topology.    * @param seed    *          Seed for the random number generator for filling in information    *          not available from the ZombieJob.    */
DECL|method|ZombieJob (LoggedJob job, ClusterStory cluster, long seed)
specifier|public
name|ZombieJob
parameter_list|(
name|LoggedJob
name|job
parameter_list|,
name|ClusterStory
name|cluster
parameter_list|,
name|long
name|seed
parameter_list|)
block|{
if|if
condition|(
name|job
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"job is null"
argument_list|)
throw|;
block|}
name|this
operator|.
name|job
operator|=
name|job
expr_stmt|;
name|this
operator|.
name|cluster
operator|=
name|cluster
expr_stmt|;
name|random
operator|=
operator|new
name|Random
argument_list|(
name|seed
argument_list|)
expr_stmt|;
name|this
operator|.
name|seed
operator|=
name|seed
expr_stmt|;
name|hasRandomSeed
operator|=
literal|true
expr_stmt|;
block|}
comment|/**    * This constructor creates a {@link ZombieJob} with the same semantics as the    * {@link LoggedJob} passed in this parameter    *     * @param job    *          The dead job this ZombieJob instance is based on.    * @param cluster    *          The cluster topology where the dead job ran on. This argument can    *          be null if we do not have knowledge of the cluster topology.    */
DECL|method|ZombieJob (LoggedJob job, ClusterStory cluster)
specifier|public
name|ZombieJob
parameter_list|(
name|LoggedJob
name|job
parameter_list|,
name|ClusterStory
name|cluster
parameter_list|)
block|{
name|this
argument_list|(
name|job
argument_list|,
name|cluster
argument_list|,
name|System
operator|.
name|nanoTime
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|convertState (Values status)
specifier|private
specifier|static
name|State
name|convertState
parameter_list|(
name|Values
name|status
parameter_list|)
block|{
if|if
condition|(
name|status
operator|==
name|Values
operator|.
name|SUCCESS
condition|)
block|{
return|return
name|State
operator|.
name|SUCCEEDED
return|;
block|}
elseif|else
if|if
condition|(
name|status
operator|==
name|Values
operator|.
name|FAILED
condition|)
block|{
return|return
name|State
operator|.
name|FAILED
return|;
block|}
elseif|else
if|if
condition|(
name|status
operator|==
name|Values
operator|.
name|KILLED
condition|)
block|{
return|return
name|State
operator|.
name|KILLED
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"unknown status "
operator|+
name|status
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
DECL|method|getJobConf ()
specifier|public
specifier|synchronized
name|JobConf
name|getJobConf
parameter_list|()
block|{
if|if
condition|(
name|jobConf
operator|==
literal|null
condition|)
block|{
name|jobConf
operator|=
operator|new
name|JobConf
argument_list|()
expr_stmt|;
comment|// Add parameters from the configuration in the job trace
comment|//
comment|// The reason why the job configuration parameters, as seen in the jobconf
comment|// file, are added first because the specialized values obtained from
comment|// Rumen should override the job conf values.
comment|//
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|>
name|entry
range|:
name|job
operator|.
name|getJobProperties
argument_list|()
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|jobConf
operator|.
name|set
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|//TODO Eliminate parameters that are already copied from the job's
comment|// configuration file.
name|jobConf
operator|.
name|setJobName
argument_list|(
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|jobConf
operator|.
name|setUser
argument_list|(
name|getUser
argument_list|()
argument_list|)
expr_stmt|;
name|jobConf
operator|.
name|setNumMapTasks
argument_list|(
name|getNumberMaps
argument_list|()
argument_list|)
expr_stmt|;
name|jobConf
operator|.
name|setNumReduceTasks
argument_list|(
name|getNumberReduces
argument_list|()
argument_list|)
expr_stmt|;
name|jobConf
operator|.
name|setQueueName
argument_list|(
name|getQueueName
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|jobConf
return|;
block|}
annotation|@
name|Override
DECL|method|getInputSplits ()
specifier|public
name|InputSplit
index|[]
name|getInputSplits
parameter_list|()
block|{
if|if
condition|(
name|splits
operator|==
literal|null
condition|)
block|{
name|List
argument_list|<
name|InputSplit
argument_list|>
name|splitsList
init|=
operator|new
name|ArrayList
argument_list|<
name|InputSplit
argument_list|>
argument_list|()
decl_stmt|;
name|Path
name|emptyPath
init|=
operator|new
name|Path
argument_list|(
literal|"/"
argument_list|)
decl_stmt|;
name|int
name|totalHosts
init|=
literal|0
decl_stmt|;
comment|// use to determine avg # of hosts per split.
for|for
control|(
name|LoggedTask
name|mapTask
range|:
name|job
operator|.
name|getMapTasks
argument_list|()
control|)
block|{
name|Pre21JobHistoryConstants
operator|.
name|Values
name|taskType
init|=
name|mapTask
operator|.
name|getTaskType
argument_list|()
decl_stmt|;
if|if
condition|(
name|taskType
operator|!=
name|Pre21JobHistoryConstants
operator|.
name|Values
operator|.
name|MAP
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"TaskType for a MapTask is not Map. task="
operator|+
name|mapTask
operator|.
name|getTaskID
argument_list|()
operator|+
literal|" type="
operator|+
operator|(
operator|(
name|taskType
operator|==
literal|null
operator|)
condition|?
literal|"null"
else|:
name|taskType
operator|.
name|toString
argument_list|()
operator|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|List
argument_list|<
name|LoggedLocation
argument_list|>
name|locations
init|=
name|mapTask
operator|.
name|getPreferredLocations
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|hostList
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|locations
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|LoggedLocation
name|location
range|:
name|locations
control|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|layers
init|=
name|location
operator|.
name|getLayers
argument_list|()
decl_stmt|;
if|if
condition|(
name|layers
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Bad location layer format for task "
operator|+
name|mapTask
operator|.
name|getTaskID
argument_list|()
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|String
name|host
init|=
name|layers
operator|.
name|get
argument_list|(
name|layers
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|host
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Bad location layer format for task "
operator|+
name|mapTask
operator|.
name|getTaskID
argument_list|()
operator|+
literal|": "
operator|+
name|layers
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|hostList
operator|.
name|add
argument_list|(
name|host
argument_list|)
expr_stmt|;
block|}
block|}
name|String
index|[]
name|hosts
init|=
name|hostList
operator|.
name|toArray
argument_list|(
operator|new
name|String
index|[
name|hostList
operator|.
name|size
argument_list|()
index|]
argument_list|)
decl_stmt|;
name|totalHosts
operator|+=
name|hosts
operator|.
name|length
expr_stmt|;
name|long
name|mapInputBytes
init|=
name|getTaskInfo
argument_list|(
name|mapTask
argument_list|)
operator|.
name|getInputBytes
argument_list|()
decl_stmt|;
if|if
condition|(
name|mapInputBytes
operator|<
literal|0
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"InputBytes for task "
operator|+
name|mapTask
operator|.
name|getTaskID
argument_list|()
operator|+
literal|" is not defined."
argument_list|)
expr_stmt|;
name|mapInputBytes
operator|=
literal|0
expr_stmt|;
block|}
name|splitsList
operator|.
name|add
argument_list|(
operator|new
name|FileSplit
argument_list|(
name|emptyPath
argument_list|,
literal|0
argument_list|,
name|mapInputBytes
argument_list|,
name|hosts
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// If not all map tasks are in job trace, should make up some splits
comment|// for missing map tasks.
name|int
name|totalMaps
init|=
name|job
operator|.
name|getTotalMaps
argument_list|()
decl_stmt|;
if|if
condition|(
name|totalMaps
operator|<
name|splitsList
operator|.
name|size
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"TotalMaps for job "
operator|+
name|job
operator|.
name|getJobID
argument_list|()
operator|+
literal|" is less than the total number of map task descriptions ("
operator|+
name|totalMaps
operator|+
literal|"<"
operator|+
name|splitsList
operator|.
name|size
argument_list|()
operator|+
literal|")."
argument_list|)
expr_stmt|;
block|}
name|int
name|avgHostPerSplit
decl_stmt|;
if|if
condition|(
name|splitsList
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
name|avgHostPerSplit
operator|=
literal|3
expr_stmt|;
block|}
else|else
block|{
name|avgHostPerSplit
operator|=
name|totalHosts
operator|/
name|splitsList
operator|.
name|size
argument_list|()
expr_stmt|;
if|if
condition|(
name|avgHostPerSplit
operator|==
literal|0
condition|)
block|{
name|avgHostPerSplit
operator|=
literal|3
expr_stmt|;
block|}
block|}
for|for
control|(
name|int
name|i
init|=
name|splitsList
operator|.
name|size
argument_list|()
init|;
name|i
operator|<
name|totalMaps
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|cluster
operator|==
literal|null
condition|)
block|{
name|splitsList
operator|.
name|add
argument_list|(
operator|new
name|FileSplit
argument_list|(
name|emptyPath
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|new
name|String
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|MachineNode
index|[]
name|mNodes
init|=
name|cluster
operator|.
name|getRandomMachines
argument_list|(
name|avgHostPerSplit
argument_list|,
name|random
argument_list|)
decl_stmt|;
name|String
index|[]
name|hosts
init|=
operator|new
name|String
index|[
name|mNodes
operator|.
name|length
index|]
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|hosts
operator|.
name|length
condition|;
operator|++
name|j
control|)
block|{
name|hosts
index|[
name|j
index|]
operator|=
name|mNodes
index|[
name|j
index|]
operator|.
name|getName
argument_list|()
expr_stmt|;
block|}
comment|// TODO set size of a split to 0 now.
name|splitsList
operator|.
name|add
argument_list|(
operator|new
name|FileSplit
argument_list|(
name|emptyPath
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|hosts
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|splits
operator|=
name|splitsList
operator|.
name|toArray
argument_list|(
operator|new
name|InputSplit
index|[
name|splitsList
operator|.
name|size
argument_list|()
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|splits
return|;
block|}
annotation|@
name|Override
DECL|method|getName ()
specifier|public
name|String
name|getName
parameter_list|()
block|{
name|String
name|jobName
init|=
name|job
operator|.
name|getJobName
argument_list|()
decl_stmt|;
if|if
condition|(
name|jobName
operator|==
literal|null
condition|)
block|{
return|return
literal|"(name unknown)"
return|;
block|}
else|else
block|{
return|return
name|jobName
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|getJobID ()
specifier|public
name|JobID
name|getJobID
parameter_list|()
block|{
return|return
name|JobID
operator|.
name|forName
argument_list|(
name|getLoggedJob
argument_list|()
operator|.
name|getJobID
argument_list|()
argument_list|)
return|;
block|}
DECL|method|sanitizeValue (int oldVal, int defaultVal, String name, String id)
specifier|private
name|int
name|sanitizeValue
parameter_list|(
name|int
name|oldVal
parameter_list|,
name|int
name|defaultVal
parameter_list|,
name|String
name|name
parameter_list|,
name|String
name|id
parameter_list|)
block|{
if|if
condition|(
name|oldVal
operator|==
operator|-
literal|1
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|name
operator|+
literal|" not defined for "
operator|+
name|id
argument_list|)
expr_stmt|;
return|return
name|defaultVal
return|;
block|}
return|return
name|oldVal
return|;
block|}
annotation|@
name|Override
DECL|method|getNumberMaps ()
specifier|public
name|int
name|getNumberMaps
parameter_list|()
block|{
return|return
name|sanitizeValue
argument_list|(
name|job
operator|.
name|getTotalMaps
argument_list|()
argument_list|,
literal|0
argument_list|,
literal|"NumberMaps"
argument_list|,
name|job
operator|.
name|getJobID
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|getNumberReduces ()
specifier|public
name|int
name|getNumberReduces
parameter_list|()
block|{
return|return
name|sanitizeValue
argument_list|(
name|job
operator|.
name|getTotalReduces
argument_list|()
argument_list|,
literal|0
argument_list|,
literal|"NumberReduces"
argument_list|,
name|job
operator|.
name|getJobID
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|getOutcome ()
specifier|public
name|Values
name|getOutcome
parameter_list|()
block|{
return|return
name|job
operator|.
name|getOutcome
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|getSubmissionTime ()
specifier|public
name|long
name|getSubmissionTime
parameter_list|()
block|{
return|return
name|job
operator|.
name|getSubmitTime
argument_list|()
operator|-
name|job
operator|.
name|getRelativeTime
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|getQueueName ()
specifier|public
name|String
name|getQueueName
parameter_list|()
block|{
name|String
name|queue
init|=
name|job
operator|.
name|getQueue
argument_list|()
decl_stmt|;
return|return
operator|(
name|queue
operator|==
literal|null
operator|)
condition|?
name|JobConf
operator|.
name|DEFAULT_QUEUE_NAME
else|:
name|queue
return|;
block|}
comment|/**    * Getting the number of map tasks that are actually logged in the trace.    * @return The number of map tasks that are actually logged in the trace.    */
DECL|method|getNumLoggedMaps ()
specifier|public
name|int
name|getNumLoggedMaps
parameter_list|()
block|{
return|return
name|job
operator|.
name|getMapTasks
argument_list|()
operator|.
name|size
argument_list|()
return|;
block|}
comment|/**    * Getting the number of reduce tasks that are actually logged in the trace.    * @return The number of map tasks that are actually logged in the trace.    */
DECL|method|getNumLoggedReduces ()
specifier|public
name|int
name|getNumLoggedReduces
parameter_list|()
block|{
return|return
name|job
operator|.
name|getReduceTasks
argument_list|()
operator|.
name|size
argument_list|()
return|;
block|}
comment|/**    * Mask the job ID part in a {@link TaskID}.    *     * @param taskId    *          raw {@link TaskID} read from trace    * @return masked {@link TaskID} with empty {@link JobID}.    */
DECL|method|maskTaskID (TaskID taskId)
specifier|private
name|TaskID
name|maskTaskID
parameter_list|(
name|TaskID
name|taskId
parameter_list|)
block|{
name|JobID
name|jobId
init|=
operator|new
name|JobID
argument_list|()
decl_stmt|;
name|TaskType
name|taskType
init|=
name|taskId
operator|.
name|getTaskType
argument_list|()
decl_stmt|;
return|return
operator|new
name|TaskID
argument_list|(
name|jobId
argument_list|,
name|taskType
argument_list|,
name|taskId
operator|.
name|getId
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Mask the job ID part in a {@link TaskAttemptID}.    *     * @param attemptId    *          raw {@link TaskAttemptID} read from trace    * @return masked {@link TaskAttemptID} with empty {@link JobID}.    */
DECL|method|maskAttemptID (TaskAttemptID attemptId)
specifier|private
name|TaskAttemptID
name|maskAttemptID
parameter_list|(
name|TaskAttemptID
name|attemptId
parameter_list|)
block|{
name|JobID
name|jobId
init|=
operator|new
name|JobID
argument_list|()
decl_stmt|;
name|TaskType
name|taskType
init|=
name|attemptId
operator|.
name|getTaskType
argument_list|()
decl_stmt|;
name|TaskID
name|taskId
init|=
name|attemptId
operator|.
name|getTaskID
argument_list|()
decl_stmt|;
return|return
operator|new
name|TaskAttemptID
argument_list|(
name|jobId
operator|.
name|getJtIdentifier
argument_list|()
argument_list|,
name|jobId
operator|.
name|getId
argument_list|()
argument_list|,
name|taskType
argument_list|,
name|taskId
operator|.
name|getId
argument_list|()
argument_list|,
name|attemptId
operator|.
name|getId
argument_list|()
argument_list|)
return|;
block|}
DECL|method|sanitizeLoggedTask (LoggedTask task)
specifier|private
name|LoggedTask
name|sanitizeLoggedTask
parameter_list|(
name|LoggedTask
name|task
parameter_list|)
block|{
if|if
condition|(
name|task
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
name|task
operator|.
name|getTaskType
argument_list|()
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Task "
operator|+
name|task
operator|.
name|getTaskID
argument_list|()
operator|+
literal|" has nulll TaskType"
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
if|if
condition|(
name|task
operator|.
name|getTaskStatus
argument_list|()
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Task "
operator|+
name|task
operator|.
name|getTaskID
argument_list|()
operator|+
literal|" has nulll TaskStatus"
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
return|return
name|task
return|;
block|}
DECL|method|sanitizeLoggedTaskAttempt (LoggedTaskAttempt attempt)
specifier|private
name|LoggedTaskAttempt
name|sanitizeLoggedTaskAttempt
parameter_list|(
name|LoggedTaskAttempt
name|attempt
parameter_list|)
block|{
if|if
condition|(
name|attempt
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
name|attempt
operator|.
name|getResult
argument_list|()
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"TaskAttempt "
operator|+
name|attempt
operator|.
name|getResult
argument_list|()
operator|+
literal|" has nulll Result"
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
return|return
name|attempt
return|;
block|}
comment|/**    * Build task mapping and task attempt mapping, to be later used to find    * information of a particular {@link TaskID} or {@link TaskAttemptID}.    */
DECL|method|buildMaps ()
specifier|private
specifier|synchronized
name|void
name|buildMaps
parameter_list|()
block|{
if|if
condition|(
name|loggedTaskMap
operator|==
literal|null
condition|)
block|{
name|loggedTaskMap
operator|=
operator|new
name|HashMap
argument_list|<
name|TaskID
argument_list|,
name|LoggedTask
argument_list|>
argument_list|()
expr_stmt|;
name|loggedTaskAttemptMap
operator|=
operator|new
name|HashMap
argument_list|<
name|TaskAttemptID
argument_list|,
name|LoggedTaskAttempt
argument_list|>
argument_list|()
expr_stmt|;
for|for
control|(
name|LoggedTask
name|map
range|:
name|job
operator|.
name|getMapTasks
argument_list|()
control|)
block|{
name|map
operator|=
name|sanitizeLoggedTask
argument_list|(
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|map
operator|!=
literal|null
condition|)
block|{
name|loggedTaskMap
operator|.
name|put
argument_list|(
name|maskTaskID
argument_list|(
name|TaskID
operator|.
name|forName
argument_list|(
name|map
operator|.
name|taskID
argument_list|)
argument_list|)
argument_list|,
name|map
argument_list|)
expr_stmt|;
for|for
control|(
name|LoggedTaskAttempt
name|mapAttempt
range|:
name|map
operator|.
name|getAttempts
argument_list|()
control|)
block|{
name|mapAttempt
operator|=
name|sanitizeLoggedTaskAttempt
argument_list|(
name|mapAttempt
argument_list|)
expr_stmt|;
if|if
condition|(
name|mapAttempt
operator|!=
literal|null
condition|)
block|{
name|TaskAttemptID
name|id
init|=
name|TaskAttemptID
operator|.
name|forName
argument_list|(
name|mapAttempt
operator|.
name|getAttemptID
argument_list|()
argument_list|)
decl_stmt|;
name|loggedTaskAttemptMap
operator|.
name|put
argument_list|(
name|maskAttemptID
argument_list|(
name|id
argument_list|)
argument_list|,
name|mapAttempt
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
for|for
control|(
name|LoggedTask
name|reduce
range|:
name|job
operator|.
name|getReduceTasks
argument_list|()
control|)
block|{
name|reduce
operator|=
name|sanitizeLoggedTask
argument_list|(
name|reduce
argument_list|)
expr_stmt|;
if|if
condition|(
name|reduce
operator|!=
literal|null
condition|)
block|{
name|loggedTaskMap
operator|.
name|put
argument_list|(
name|maskTaskID
argument_list|(
name|TaskID
operator|.
name|forName
argument_list|(
name|reduce
operator|.
name|taskID
argument_list|)
argument_list|)
argument_list|,
name|reduce
argument_list|)
expr_stmt|;
for|for
control|(
name|LoggedTaskAttempt
name|reduceAttempt
range|:
name|reduce
operator|.
name|getAttempts
argument_list|()
control|)
block|{
name|reduceAttempt
operator|=
name|sanitizeLoggedTaskAttempt
argument_list|(
name|reduceAttempt
argument_list|)
expr_stmt|;
if|if
condition|(
name|reduceAttempt
operator|!=
literal|null
condition|)
block|{
name|TaskAttemptID
name|id
init|=
name|TaskAttemptID
operator|.
name|forName
argument_list|(
name|reduceAttempt
operator|.
name|getAttemptID
argument_list|()
argument_list|)
decl_stmt|;
name|loggedTaskAttemptMap
operator|.
name|put
argument_list|(
name|maskAttemptID
argument_list|(
name|id
argument_list|)
argument_list|,
name|reduceAttempt
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|// TODO: do not care about "other" tasks, "setup" or "clean"
block|}
block|}
annotation|@
name|Override
DECL|method|getUser ()
specifier|public
name|String
name|getUser
parameter_list|()
block|{
name|String
name|retval
init|=
name|job
operator|.
name|getUser
argument_list|()
decl_stmt|;
return|return
operator|(
name|retval
operator|==
literal|null
operator|)
condition|?
literal|"(unknown)"
else|:
name|retval
return|;
block|}
comment|/**    * Get the underlining {@link LoggedJob} object read directly from the trace.    * This is mainly for debugging.    *     * @return the underlining {@link LoggedJob} object    */
DECL|method|getLoggedJob ()
specifier|public
name|LoggedJob
name|getLoggedJob
parameter_list|()
block|{
return|return
name|job
return|;
block|}
comment|/**    * Get a {@link TaskAttemptInfo} with a {@link TaskAttemptID} associated with    * taskType, taskNumber, and taskAttemptNumber. This function does not care    * about locality, and follows the following decision logic: 1. Make up a    * {@link TaskAttemptInfo} if the task attempt is missing in trace, 2. Make up    * a {@link TaskAttemptInfo} if the task attempt has a KILLED final status in    * trace, 3. Otherwise (final state is SUCCEEDED or FAILED), construct the    * {@link TaskAttemptInfo} from the trace.    */
DECL|method|getTaskAttemptInfo (TaskType taskType, int taskNumber, int taskAttemptNumber)
specifier|public
name|TaskAttemptInfo
name|getTaskAttemptInfo
parameter_list|(
name|TaskType
name|taskType
parameter_list|,
name|int
name|taskNumber
parameter_list|,
name|int
name|taskAttemptNumber
parameter_list|)
block|{
comment|// does not care about locality. assume default locality is NODE_LOCAL.
comment|// But if both task and task attempt exist in trace, use logged locality.
name|int
name|locality
init|=
literal|0
decl_stmt|;
name|LoggedTask
name|loggedTask
init|=
name|getLoggedTask
argument_list|(
name|taskType
argument_list|,
name|taskNumber
argument_list|)
decl_stmt|;
if|if
condition|(
name|loggedTask
operator|==
literal|null
condition|)
block|{
comment|// TODO insert parameters
name|TaskInfo
name|taskInfo
init|=
operator|new
name|TaskInfo
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
return|return
name|makeUpTaskAttemptInfo
argument_list|(
name|taskType
argument_list|,
name|taskInfo
argument_list|,
name|taskAttemptNumber
argument_list|,
name|taskNumber
argument_list|,
name|locality
argument_list|)
return|;
block|}
name|LoggedTaskAttempt
name|loggedAttempt
init|=
name|getLoggedTaskAttempt
argument_list|(
name|taskType
argument_list|,
name|taskNumber
argument_list|,
name|taskAttemptNumber
argument_list|)
decl_stmt|;
if|if
condition|(
name|loggedAttempt
operator|==
literal|null
condition|)
block|{
comment|// Task exists, but attempt is missing.
name|TaskInfo
name|taskInfo
init|=
name|getTaskInfo
argument_list|(
name|loggedTask
argument_list|)
decl_stmt|;
return|return
name|makeUpTaskAttemptInfo
argument_list|(
name|taskType
argument_list|,
name|taskInfo
argument_list|,
name|taskAttemptNumber
argument_list|,
name|taskNumber
argument_list|,
name|locality
argument_list|)
return|;
block|}
else|else
block|{
comment|// TODO should we handle killed attempts later?
if|if
condition|(
name|loggedAttempt
operator|.
name|getResult
argument_list|()
operator|==
name|Values
operator|.
name|KILLED
condition|)
block|{
name|TaskInfo
name|taskInfo
init|=
name|getTaskInfo
argument_list|(
name|loggedTask
argument_list|)
decl_stmt|;
return|return
name|makeUpTaskAttemptInfo
argument_list|(
name|taskType
argument_list|,
name|taskInfo
argument_list|,
name|taskAttemptNumber
argument_list|,
name|taskNumber
argument_list|,
name|locality
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|getTaskAttemptInfo
argument_list|(
name|loggedTask
argument_list|,
name|loggedAttempt
argument_list|)
return|;
block|}
block|}
block|}
annotation|@
name|Override
DECL|method|getTaskInfo (TaskType taskType, int taskNumber)
specifier|public
name|TaskInfo
name|getTaskInfo
parameter_list|(
name|TaskType
name|taskType
parameter_list|,
name|int
name|taskNumber
parameter_list|)
block|{
return|return
name|getTaskInfo
argument_list|(
name|getLoggedTask
argument_list|(
name|taskType
argument_list|,
name|taskNumber
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Get a {@link TaskAttemptInfo} with a {@link TaskAttemptID} associated with    * taskType, taskNumber, and taskAttemptNumber. This function considers    * locality, and follows the following decision logic: 1. Make up a    * {@link TaskAttemptInfo} if the task attempt is missing in trace, 2. Make up    * a {@link TaskAttemptInfo} if the task attempt has a KILLED final status in    * trace, 3. If final state is FAILED, construct a {@link TaskAttemptInfo}    * from the trace, without considering locality. 4. If final state is    * SUCCEEDED, construct a {@link TaskAttemptInfo} from the trace, with runtime    * scaled according to locality in simulation and locality in trace.    */
annotation|@
name|Override
DECL|method|getMapTaskAttemptInfoAdjusted (int taskNumber, int taskAttemptNumber, int locality)
specifier|public
name|TaskAttemptInfo
name|getMapTaskAttemptInfoAdjusted
parameter_list|(
name|int
name|taskNumber
parameter_list|,
name|int
name|taskAttemptNumber
parameter_list|,
name|int
name|locality
parameter_list|)
block|{
name|TaskType
name|taskType
init|=
name|TaskType
operator|.
name|MAP
decl_stmt|;
name|LoggedTask
name|loggedTask
init|=
name|getLoggedTask
argument_list|(
name|taskType
argument_list|,
name|taskNumber
argument_list|)
decl_stmt|;
if|if
condition|(
name|loggedTask
operator|==
literal|null
condition|)
block|{
comment|// TODO insert parameters
name|TaskInfo
name|taskInfo
init|=
operator|new
name|TaskInfo
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
return|return
name|makeUpTaskAttemptInfo
argument_list|(
name|taskType
argument_list|,
name|taskInfo
argument_list|,
name|taskAttemptNumber
argument_list|,
name|taskNumber
argument_list|,
name|locality
argument_list|)
return|;
block|}
name|LoggedTaskAttempt
name|loggedAttempt
init|=
name|getLoggedTaskAttempt
argument_list|(
name|taskType
argument_list|,
name|taskNumber
argument_list|,
name|taskAttemptNumber
argument_list|)
decl_stmt|;
if|if
condition|(
name|loggedAttempt
operator|==
literal|null
condition|)
block|{
comment|// Task exists, but attempt is missing.
name|TaskInfo
name|taskInfo
init|=
name|getTaskInfo
argument_list|(
name|loggedTask
argument_list|)
decl_stmt|;
return|return
name|makeUpTaskAttemptInfo
argument_list|(
name|taskType
argument_list|,
name|taskInfo
argument_list|,
name|taskAttemptNumber
argument_list|,
name|taskNumber
argument_list|,
name|locality
argument_list|)
return|;
block|}
else|else
block|{
comment|// Task and TaskAttempt both exist.
if|if
condition|(
name|loggedAttempt
operator|.
name|getResult
argument_list|()
operator|==
name|Values
operator|.
name|KILLED
condition|)
block|{
name|TaskInfo
name|taskInfo
init|=
name|getTaskInfo
argument_list|(
name|loggedTask
argument_list|)
decl_stmt|;
return|return
name|makeUpTaskAttemptInfo
argument_list|(
name|taskType
argument_list|,
name|taskInfo
argument_list|,
name|taskAttemptNumber
argument_list|,
name|taskNumber
argument_list|,
name|locality
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|loggedAttempt
operator|.
name|getResult
argument_list|()
operator|==
name|Values
operator|.
name|FAILED
condition|)
block|{
comment|/**          * FAILED attempt is not affected by locality however, made-up FAILED          * attempts ARE affected by locality, since statistics are present for          * attempts of different locality.          */
return|return
name|getTaskAttemptInfo
argument_list|(
name|loggedTask
argument_list|,
name|loggedAttempt
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|loggedAttempt
operator|.
name|getResult
argument_list|()
operator|==
name|Values
operator|.
name|SUCCESS
condition|)
block|{
name|int
name|loggedLocality
init|=
name|getLocality
argument_list|(
name|loggedTask
argument_list|,
name|loggedAttempt
argument_list|)
decl_stmt|;
if|if
condition|(
name|locality
operator|==
name|loggedLocality
condition|)
block|{
return|return
name|getTaskAttemptInfo
argument_list|(
name|loggedTask
argument_list|,
name|loggedAttempt
argument_list|)
return|;
block|}
else|else
block|{
comment|// attempt succeeded in trace. It is scheduled in simulation with
comment|// a different locality.
return|return
name|scaleInfo
argument_list|(
name|loggedTask
argument_list|,
name|loggedAttempt
argument_list|,
name|locality
argument_list|,
name|loggedLocality
argument_list|,
name|rackLocalOverNodeLocal
argument_list|,
name|rackRemoteOverNodeLocal
argument_list|)
return|;
block|}
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"attempt result is not SUCCEEDED, FAILED or KILLED: "
operator|+
name|loggedAttempt
operator|.
name|getResult
argument_list|()
argument_list|)
throw|;
block|}
block|}
block|}
DECL|method|sanitizeTaskRuntime (long time, String id)
specifier|private
name|long
name|sanitizeTaskRuntime
parameter_list|(
name|long
name|time
parameter_list|,
name|String
name|id
parameter_list|)
block|{
if|if
condition|(
name|time
operator|<
literal|0
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Negative running time for task "
operator|+
name|id
operator|+
literal|": "
operator|+
name|time
argument_list|)
expr_stmt|;
return|return
literal|100L
return|;
comment|// set default to 100ms.
block|}
return|return
name|time
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"hiding"
argument_list|)
DECL|method|scaleInfo (LoggedTask loggedTask, LoggedTaskAttempt loggedAttempt, int locality, int loggedLocality, double rackLocalOverNodeLocal, double rackRemoteOverNodeLocal)
specifier|private
name|TaskAttemptInfo
name|scaleInfo
parameter_list|(
name|LoggedTask
name|loggedTask
parameter_list|,
name|LoggedTaskAttempt
name|loggedAttempt
parameter_list|,
name|int
name|locality
parameter_list|,
name|int
name|loggedLocality
parameter_list|,
name|double
name|rackLocalOverNodeLocal
parameter_list|,
name|double
name|rackRemoteOverNodeLocal
parameter_list|)
block|{
name|TaskInfo
name|taskInfo
init|=
name|getTaskInfo
argument_list|(
name|loggedTask
argument_list|)
decl_stmt|;
name|double
index|[]
name|factors
init|=
operator|new
name|double
index|[]
block|{
literal|1.0
block|,
name|rackLocalOverNodeLocal
block|,
name|rackRemoteOverNodeLocal
block|}
decl_stmt|;
name|double
name|scaleFactor
init|=
name|factors
index|[
name|locality
index|]
operator|/
name|factors
index|[
name|loggedLocality
index|]
decl_stmt|;
name|State
name|state
init|=
name|convertState
argument_list|(
name|loggedAttempt
operator|.
name|getResult
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|loggedTask
operator|.
name|getTaskType
argument_list|()
operator|==
name|Values
operator|.
name|MAP
condition|)
block|{
name|long
name|taskTime
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|loggedAttempt
operator|.
name|getStartTime
argument_list|()
operator|==
literal|0
condition|)
block|{
name|taskTime
operator|=
name|makeUpMapRuntime
argument_list|(
name|state
argument_list|,
name|locality
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|taskTime
operator|=
name|loggedAttempt
operator|.
name|getFinishTime
argument_list|()
operator|-
name|loggedAttempt
operator|.
name|getStartTime
argument_list|()
expr_stmt|;
block|}
name|taskTime
operator|=
name|sanitizeTaskRuntime
argument_list|(
name|taskTime
argument_list|,
name|loggedAttempt
operator|.
name|getAttemptID
argument_list|()
argument_list|)
expr_stmt|;
name|taskTime
operator|*=
name|scaleFactor
expr_stmt|;
return|return
operator|new
name|MapTaskAttemptInfo
argument_list|(
name|state
argument_list|,
name|taskInfo
argument_list|,
name|taskTime
argument_list|,
name|loggedAttempt
operator|.
name|allSplitVectors
argument_list|()
argument_list|)
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"taskType can only be MAP: "
operator|+
name|loggedTask
operator|.
name|getTaskType
argument_list|()
argument_list|)
throw|;
block|}
block|}
DECL|method|getLocality (LoggedTask loggedTask, LoggedTaskAttempt loggedAttempt)
specifier|private
name|int
name|getLocality
parameter_list|(
name|LoggedTask
name|loggedTask
parameter_list|,
name|LoggedTaskAttempt
name|loggedAttempt
parameter_list|)
block|{
name|int
name|distance
init|=
name|cluster
operator|.
name|getMaximumDistance
argument_list|()
decl_stmt|;
name|String
name|rackHostName
init|=
name|loggedAttempt
operator|.
name|getHostName
argument_list|()
decl_stmt|;
if|if
condition|(
name|rackHostName
operator|==
literal|null
condition|)
block|{
return|return
name|distance
return|;
block|}
name|MachineNode
name|mn
init|=
name|getMachineNode
argument_list|(
name|rackHostName
argument_list|)
decl_stmt|;
if|if
condition|(
name|mn
operator|==
literal|null
condition|)
block|{
return|return
name|distance
return|;
block|}
name|List
argument_list|<
name|LoggedLocation
argument_list|>
name|locations
init|=
name|loggedTask
operator|.
name|getPreferredLocations
argument_list|()
decl_stmt|;
if|if
condition|(
name|locations
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|LoggedLocation
name|location
range|:
name|locations
control|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|layers
init|=
name|location
operator|.
name|getLayers
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|layers
operator|==
literal|null
operator|)
operator|||
operator|(
name|layers
operator|.
name|isEmpty
argument_list|()
operator|)
condition|)
block|{
continue|continue;
block|}
name|String
name|dataNodeName
init|=
name|layers
operator|.
name|get
argument_list|(
name|layers
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
name|MachineNode
name|dataNode
init|=
name|cluster
operator|.
name|getMachineByName
argument_list|(
name|dataNodeName
argument_list|)
decl_stmt|;
if|if
condition|(
name|dataNode
operator|!=
literal|null
condition|)
block|{
name|distance
operator|=
name|Math
operator|.
name|min
argument_list|(
name|distance
argument_list|,
name|cluster
operator|.
name|distance
argument_list|(
name|mn
argument_list|,
name|dataNode
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|distance
return|;
block|}
DECL|method|getMachineNode (String rackHostName)
specifier|private
name|MachineNode
name|getMachineNode
parameter_list|(
name|String
name|rackHostName
parameter_list|)
block|{
name|ParsedHost
name|parsedHost
init|=
name|ParsedHost
operator|.
name|parse
argument_list|(
name|rackHostName
argument_list|)
decl_stmt|;
name|String
name|hostName
init|=
operator|(
name|parsedHost
operator|==
literal|null
operator|)
condition|?
name|rackHostName
else|:
name|parsedHost
operator|.
name|getNodeName
argument_list|()
decl_stmt|;
if|if
condition|(
name|hostName
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
operator|(
name|cluster
operator|==
literal|null
operator|)
condition|?
literal|null
else|:
name|cluster
operator|.
name|getMachineByName
argument_list|(
name|hostName
argument_list|)
return|;
block|}
DECL|method|getTaskAttemptInfo (LoggedTask loggedTask, LoggedTaskAttempt loggedAttempt)
specifier|private
name|TaskAttemptInfo
name|getTaskAttemptInfo
parameter_list|(
name|LoggedTask
name|loggedTask
parameter_list|,
name|LoggedTaskAttempt
name|loggedAttempt
parameter_list|)
block|{
name|TaskInfo
name|taskInfo
init|=
name|getTaskInfo
argument_list|(
name|loggedTask
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|List
argument_list|<
name|Integer
argument_list|>
argument_list|>
name|allSplitVectors
init|=
name|loggedAttempt
operator|.
name|allSplitVectors
argument_list|()
decl_stmt|;
name|State
name|state
init|=
name|convertState
argument_list|(
name|loggedAttempt
operator|.
name|getResult
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|loggedTask
operator|.
name|getTaskType
argument_list|()
operator|==
name|Values
operator|.
name|MAP
condition|)
block|{
name|long
name|taskTime
decl_stmt|;
if|if
condition|(
name|loggedAttempt
operator|.
name|getStartTime
argument_list|()
operator|==
literal|0
condition|)
block|{
name|int
name|locality
init|=
name|getLocality
argument_list|(
name|loggedTask
argument_list|,
name|loggedAttempt
argument_list|)
decl_stmt|;
name|taskTime
operator|=
name|makeUpMapRuntime
argument_list|(
name|state
argument_list|,
name|locality
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|taskTime
operator|=
name|loggedAttempt
operator|.
name|getFinishTime
argument_list|()
operator|-
name|loggedAttempt
operator|.
name|getStartTime
argument_list|()
expr_stmt|;
block|}
name|taskTime
operator|=
name|sanitizeTaskRuntime
argument_list|(
name|taskTime
argument_list|,
name|loggedAttempt
operator|.
name|getAttemptID
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|new
name|MapTaskAttemptInfo
argument_list|(
name|state
argument_list|,
name|taskInfo
argument_list|,
name|taskTime
argument_list|,
name|allSplitVectors
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|loggedTask
operator|.
name|getTaskType
argument_list|()
operator|==
name|Values
operator|.
name|REDUCE
condition|)
block|{
name|long
name|startTime
init|=
name|loggedAttempt
operator|.
name|getStartTime
argument_list|()
decl_stmt|;
name|long
name|mergeDone
init|=
name|loggedAttempt
operator|.
name|getSortFinished
argument_list|()
decl_stmt|;
name|long
name|shuffleDone
init|=
name|loggedAttempt
operator|.
name|getShuffleFinished
argument_list|()
decl_stmt|;
name|long
name|finishTime
init|=
name|loggedAttempt
operator|.
name|getFinishTime
argument_list|()
decl_stmt|;
if|if
condition|(
name|startTime
operator|<=
literal|0
operator|||
name|startTime
operator|>=
name|finishTime
condition|)
block|{
comment|// have seen startTime>finishTime.
comment|// haven't seen reduce task with startTime=0 ever. But if this happens,
comment|// make up a reduceTime with no shuffle/merge.
name|long
name|reduceTime
init|=
name|makeUpReduceRuntime
argument_list|(
name|state
argument_list|)
decl_stmt|;
return|return
operator|new
name|ReduceTaskAttemptInfo
argument_list|(
name|state
argument_list|,
name|taskInfo
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|reduceTime
argument_list|,
name|allSplitVectors
argument_list|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|shuffleDone
operator|<=
literal|0
condition|)
block|{
name|shuffleDone
operator|=
name|startTime
expr_stmt|;
block|}
if|if
condition|(
name|mergeDone
operator|<=
literal|0
condition|)
block|{
name|mergeDone
operator|=
name|finishTime
expr_stmt|;
block|}
name|long
name|shuffleTime
init|=
name|shuffleDone
operator|-
name|startTime
decl_stmt|;
name|long
name|mergeTime
init|=
name|mergeDone
operator|-
name|shuffleDone
decl_stmt|;
name|long
name|reduceTime
init|=
name|finishTime
operator|-
name|mergeDone
decl_stmt|;
name|reduceTime
operator|=
name|sanitizeTaskRuntime
argument_list|(
name|reduceTime
argument_list|,
name|loggedAttempt
operator|.
name|getAttemptID
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|new
name|ReduceTaskAttemptInfo
argument_list|(
name|state
argument_list|,
name|taskInfo
argument_list|,
name|shuffleTime
argument_list|,
name|mergeTime
argument_list|,
name|reduceTime
argument_list|,
name|allSplitVectors
argument_list|)
return|;
block|}
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"taskType for "
operator|+
name|loggedTask
operator|.
name|getTaskID
argument_list|()
operator|+
literal|" is neither MAP nor REDUCE: "
operator|+
name|loggedTask
operator|.
name|getTaskType
argument_list|()
argument_list|)
throw|;
block|}
block|}
DECL|method|getTaskInfo (LoggedTask loggedTask)
specifier|private
name|TaskInfo
name|getTaskInfo
parameter_list|(
name|LoggedTask
name|loggedTask
parameter_list|)
block|{
name|List
argument_list|<
name|LoggedTaskAttempt
argument_list|>
name|attempts
init|=
name|loggedTask
operator|.
name|getAttempts
argument_list|()
decl_stmt|;
name|long
name|inputBytes
init|=
operator|-
literal|1
decl_stmt|;
name|long
name|inputRecords
init|=
operator|-
literal|1
decl_stmt|;
name|long
name|outputBytes
init|=
operator|-
literal|1
decl_stmt|;
name|long
name|outputRecords
init|=
operator|-
literal|1
decl_stmt|;
name|long
name|heapMegabytes
init|=
operator|-
literal|1
decl_stmt|;
name|ResourceUsageMetrics
name|metrics
init|=
operator|new
name|ResourceUsageMetrics
argument_list|()
decl_stmt|;
name|Values
name|type
init|=
name|loggedTask
operator|.
name|getTaskType
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|type
operator|!=
name|Values
operator|.
name|MAP
operator|)
operator|&&
operator|(
name|type
operator|!=
name|Values
operator|.
name|REDUCE
operator|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"getTaskInfo only supports MAP or REDUCE tasks: "
operator|+
name|type
operator|.
name|toString
argument_list|()
operator|+
literal|" for task = "
operator|+
name|loggedTask
operator|.
name|getTaskID
argument_list|()
argument_list|)
throw|;
block|}
for|for
control|(
name|LoggedTaskAttempt
name|attempt
range|:
name|attempts
control|)
block|{
name|attempt
operator|=
name|sanitizeLoggedTaskAttempt
argument_list|(
name|attempt
argument_list|)
expr_stmt|;
comment|// ignore bad attempts or unsuccessful attempts.
if|if
condition|(
operator|(
name|attempt
operator|==
literal|null
operator|)
operator|||
operator|(
name|attempt
operator|.
name|getResult
argument_list|()
operator|!=
name|Values
operator|.
name|SUCCESS
operator|)
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|type
operator|==
name|Values
operator|.
name|MAP
condition|)
block|{
name|inputBytes
operator|=
name|attempt
operator|.
name|getHdfsBytesRead
argument_list|()
expr_stmt|;
name|inputRecords
operator|=
name|attempt
operator|.
name|getMapInputRecords
argument_list|()
expr_stmt|;
name|outputBytes
operator|=
operator|(
name|job
operator|.
name|getTotalReduces
argument_list|()
operator|>
literal|0
operator|)
condition|?
name|attempt
operator|.
name|getMapOutputBytes
argument_list|()
else|:
name|attempt
operator|.
name|getHdfsBytesWritten
argument_list|()
expr_stmt|;
name|outputRecords
operator|=
name|attempt
operator|.
name|getMapOutputRecords
argument_list|()
expr_stmt|;
name|heapMegabytes
operator|=
operator|(
name|job
operator|.
name|getJobMapMB
argument_list|()
operator|>
literal|0
operator|)
condition|?
name|job
operator|.
name|getJobMapMB
argument_list|()
else|:
name|job
operator|.
name|getHeapMegabytes
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|inputBytes
operator|=
name|attempt
operator|.
name|getReduceShuffleBytes
argument_list|()
expr_stmt|;
name|inputRecords
operator|=
name|attempt
operator|.
name|getReduceInputRecords
argument_list|()
expr_stmt|;
name|outputBytes
operator|=
name|attempt
operator|.
name|getHdfsBytesWritten
argument_list|()
expr_stmt|;
name|outputRecords
operator|=
name|attempt
operator|.
name|getReduceOutputRecords
argument_list|()
expr_stmt|;
name|heapMegabytes
operator|=
operator|(
name|job
operator|.
name|getJobReduceMB
argument_list|()
operator|>
literal|0
operator|)
condition|?
name|job
operator|.
name|getJobReduceMB
argument_list|()
else|:
name|job
operator|.
name|getHeapMegabytes
argument_list|()
expr_stmt|;
block|}
comment|// set the resource usage metrics
name|metrics
operator|=
name|attempt
operator|.
name|getResourceUsageMetrics
argument_list|()
expr_stmt|;
break|break;
block|}
name|TaskInfo
name|taskInfo
init|=
operator|new
name|TaskInfo
argument_list|(
name|inputBytes
argument_list|,
operator|(
name|int
operator|)
name|inputRecords
argument_list|,
name|outputBytes
argument_list|,
operator|(
name|int
operator|)
name|outputRecords
argument_list|,
operator|(
name|int
operator|)
name|heapMegabytes
argument_list|,
name|metrics
argument_list|)
decl_stmt|;
return|return
name|taskInfo
return|;
block|}
DECL|method|makeTaskAttemptID (TaskType taskType, int taskNumber, int taskAttemptNumber)
specifier|private
name|TaskAttemptID
name|makeTaskAttemptID
parameter_list|(
name|TaskType
name|taskType
parameter_list|,
name|int
name|taskNumber
parameter_list|,
name|int
name|taskAttemptNumber
parameter_list|)
block|{
return|return
operator|new
name|TaskAttemptID
argument_list|(
operator|new
name|TaskID
argument_list|(
name|JobID
operator|.
name|forName
argument_list|(
name|job
operator|.
name|getJobID
argument_list|()
argument_list|)
argument_list|,
name|taskType
argument_list|,
name|taskNumber
argument_list|)
argument_list|,
name|taskAttemptNumber
argument_list|)
return|;
block|}
DECL|method|makeUpTaskAttemptInfo (TaskType taskType, TaskInfo taskInfo, int taskAttemptNumber, int taskNumber, int locality)
specifier|private
name|TaskAttemptInfo
name|makeUpTaskAttemptInfo
parameter_list|(
name|TaskType
name|taskType
parameter_list|,
name|TaskInfo
name|taskInfo
parameter_list|,
name|int
name|taskAttemptNumber
parameter_list|,
name|int
name|taskNumber
parameter_list|,
name|int
name|locality
parameter_list|)
block|{
if|if
condition|(
name|taskType
operator|==
name|TaskType
operator|.
name|MAP
condition|)
block|{
name|State
name|state
init|=
name|State
operator|.
name|SUCCEEDED
decl_stmt|;
name|long
name|runtime
init|=
literal|0
decl_stmt|;
comment|// make up state
name|state
operator|=
name|makeUpState
argument_list|(
name|taskAttemptNumber
argument_list|,
name|job
operator|.
name|getMapperTriesToSucceed
argument_list|()
argument_list|)
expr_stmt|;
name|runtime
operator|=
name|makeUpMapRuntime
argument_list|(
name|state
argument_list|,
name|locality
argument_list|)
expr_stmt|;
name|runtime
operator|=
name|sanitizeTaskRuntime
argument_list|(
name|runtime
argument_list|,
name|makeTaskAttemptID
argument_list|(
name|taskType
argument_list|,
name|taskNumber
argument_list|,
name|taskAttemptNumber
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|TaskAttemptInfo
name|tai
init|=
operator|new
name|MapTaskAttemptInfo
argument_list|(
name|state
argument_list|,
name|taskInfo
argument_list|,
name|runtime
argument_list|,
literal|null
argument_list|)
decl_stmt|;
return|return
name|tai
return|;
block|}
elseif|else
if|if
condition|(
name|taskType
operator|==
name|TaskType
operator|.
name|REDUCE
condition|)
block|{
name|State
name|state
init|=
name|State
operator|.
name|SUCCEEDED
decl_stmt|;
name|long
name|shuffleTime
init|=
literal|0
decl_stmt|;
name|long
name|sortTime
init|=
literal|0
decl_stmt|;
name|long
name|reduceTime
init|=
literal|0
decl_stmt|;
comment|// TODO make up state
comment|// state = makeUpState(taskAttemptNumber, job.getReducerTriesToSucceed());
name|reduceTime
operator|=
name|makeUpReduceRuntime
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|TaskAttemptInfo
name|tai
init|=
operator|new
name|ReduceTaskAttemptInfo
argument_list|(
name|state
argument_list|,
name|taskInfo
argument_list|,
name|shuffleTime
argument_list|,
name|sortTime
argument_list|,
name|reduceTime
argument_list|,
literal|null
argument_list|)
decl_stmt|;
return|return
name|tai
return|;
block|}
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"taskType is neither MAP nor REDUCE: "
operator|+
name|taskType
argument_list|)
throw|;
block|}
DECL|method|makeUpReduceRuntime (State state)
specifier|private
name|long
name|makeUpReduceRuntime
parameter_list|(
name|State
name|state
parameter_list|)
block|{
name|long
name|reduceTime
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
block|{
name|reduceTime
operator|=
name|doMakeUpReduceRuntime
argument_list|(
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
name|reduceTime
operator|>=
literal|0
condition|)
block|{
return|return
name|reduceTime
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
DECL|method|doMakeUpReduceRuntime (State state)
specifier|private
name|long
name|doMakeUpReduceRuntime
parameter_list|(
name|State
name|state
parameter_list|)
block|{
name|long
name|reduceTime
decl_stmt|;
try|try
block|{
if|if
condition|(
name|state
operator|==
name|State
operator|.
name|SUCCEEDED
condition|)
block|{
name|reduceTime
operator|=
name|makeUpRuntime
argument_list|(
name|job
operator|.
name|getSuccessfulReduceAttemptCDF
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|state
operator|==
name|State
operator|.
name|FAILED
condition|)
block|{
name|reduceTime
operator|=
name|makeUpRuntime
argument_list|(
name|job
operator|.
name|getFailedReduceAttemptCDF
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"state is neither SUCCEEDED nor FAILED: "
operator|+
name|state
argument_list|)
throw|;
block|}
return|return
name|reduceTime
return|;
block|}
catch|catch
parameter_list|(
name|NoValueToMakeUpRuntime
name|e
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
block|}
DECL|method|makeUpMapRuntime (State state, int locality)
specifier|private
name|long
name|makeUpMapRuntime
parameter_list|(
name|State
name|state
parameter_list|,
name|int
name|locality
parameter_list|)
block|{
name|long
name|runtime
decl_stmt|;
comment|// make up runtime
if|if
condition|(
name|state
operator|==
name|State
operator|.
name|SUCCEEDED
operator|||
name|state
operator|==
name|State
operator|.
name|FAILED
condition|)
block|{
name|List
argument_list|<
name|LoggedDiscreteCDF
argument_list|>
name|cdfList
init|=
name|state
operator|==
name|State
operator|.
name|SUCCEEDED
condition|?
name|job
operator|.
name|getSuccessfulMapAttemptCDFs
argument_list|()
else|:
name|job
operator|.
name|getFailedMapAttemptCDFs
argument_list|()
decl_stmt|;
comment|// XXX MapCDFs is a ArrayList of 4 possible groups: distance=0, 1, 2, and
comment|// the last group is "distance cannot be determined". All pig jobs
comment|// would have only the 4th group, and pig tasks usually do not have
comment|// any locality, so this group should count as "distance=2".
comment|// However, setup/cleanup tasks are also counted in the 4th group.
comment|// These tasks do not make sense.
if|if
condition|(
name|cdfList
operator|==
literal|null
condition|)
block|{
name|runtime
operator|=
operator|-
literal|1
expr_stmt|;
return|return
name|runtime
return|;
block|}
try|try
block|{
name|runtime
operator|=
name|makeUpRuntime
argument_list|(
name|cdfList
operator|.
name|get
argument_list|(
name|locality
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NoValueToMakeUpRuntime
name|e
parameter_list|)
block|{
name|runtime
operator|=
name|makeUpRuntime
argument_list|(
name|cdfList
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"state is neither SUCCEEDED nor FAILED: "
operator|+
name|state
argument_list|)
throw|;
block|}
return|return
name|runtime
return|;
block|}
comment|/**    * Perform a weighted random selection on a list of CDFs, and produce a random    * variable using the selected CDF.    *     * @param mapAttemptCDFs    *          A list of CDFs for the distribution of runtime for the 1st, 2nd,    *          ... map attempts for the job.    */
DECL|method|makeUpRuntime (List<LoggedDiscreteCDF> mapAttemptCDFs)
specifier|private
name|long
name|makeUpRuntime
parameter_list|(
name|List
argument_list|<
name|LoggedDiscreteCDF
argument_list|>
name|mapAttemptCDFs
parameter_list|)
block|{
name|int
name|total
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|mapAttemptCDFs
operator|==
literal|null
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
for|for
control|(
name|LoggedDiscreteCDF
name|cdf
range|:
name|mapAttemptCDFs
control|)
block|{
name|total
operator|+=
name|cdf
operator|.
name|getNumberValues
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|total
operator|==
literal|0
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
name|int
name|index
init|=
name|random
operator|.
name|nextInt
argument_list|(
name|total
argument_list|)
decl_stmt|;
for|for
control|(
name|LoggedDiscreteCDF
name|cdf
range|:
name|mapAttemptCDFs
control|)
block|{
if|if
condition|(
name|index
operator|>=
name|cdf
operator|.
name|getNumberValues
argument_list|()
condition|)
block|{
name|index
operator|-=
name|cdf
operator|.
name|getNumberValues
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|index
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"application error"
argument_list|)
throw|;
block|}
return|return
name|makeUpRuntime
argument_list|(
name|cdf
argument_list|)
return|;
block|}
block|}
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"not possible to get here"
argument_list|)
throw|;
block|}
DECL|method|makeUpRuntime (LoggedDiscreteCDF loggedDiscreteCDF)
specifier|private
name|long
name|makeUpRuntime
parameter_list|(
name|LoggedDiscreteCDF
name|loggedDiscreteCDF
parameter_list|)
block|{
comment|/*      * We need this odd-looking code because if a seed exists we need to ensure      * that only one interpolator is generated per LoggedDiscreteCDF, but if no      * seed exists then the potentially lengthy process of making an      * interpolator can happen outside the lock. makeUpRuntimeCore only locks      * around the two hash map accesses.      */
if|if
condition|(
name|hasRandomSeed
condition|)
block|{
synchronized|synchronized
init|(
name|interpolatorMap
init|)
block|{
return|return
name|makeUpRuntimeCore
argument_list|(
name|loggedDiscreteCDF
argument_list|)
return|;
block|}
block|}
return|return
name|makeUpRuntimeCore
argument_list|(
name|loggedDiscreteCDF
argument_list|)
return|;
block|}
DECL|method|getNextRandomSeed ()
specifier|private
specifier|synchronized
name|long
name|getNextRandomSeed
parameter_list|()
block|{
name|numRandomSeeds
operator|++
expr_stmt|;
return|return
name|RandomSeedGenerator
operator|.
name|getSeed
argument_list|(
literal|"forZombieJob"
operator|+
name|job
operator|.
name|getJobID
argument_list|()
argument_list|,
name|numRandomSeeds
argument_list|)
return|;
block|}
DECL|method|makeUpRuntimeCore (LoggedDiscreteCDF loggedDiscreteCDF)
specifier|private
name|long
name|makeUpRuntimeCore
parameter_list|(
name|LoggedDiscreteCDF
name|loggedDiscreteCDF
parameter_list|)
block|{
name|CDFRandomGenerator
name|interpolator
decl_stmt|;
synchronized|synchronized
init|(
name|interpolatorMap
init|)
block|{
name|interpolator
operator|=
name|interpolatorMap
operator|.
name|get
argument_list|(
name|loggedDiscreteCDF
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|interpolator
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|loggedDiscreteCDF
operator|.
name|getNumberValues
argument_list|()
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|NoValueToMakeUpRuntime
argument_list|(
literal|"no value to use to make up runtime"
argument_list|)
throw|;
block|}
name|interpolator
operator|=
name|hasRandomSeed
condition|?
operator|new
name|CDFPiecewiseLinearRandomGenerator
argument_list|(
name|loggedDiscreteCDF
argument_list|,
name|getNextRandomSeed
argument_list|()
argument_list|)
else|:
operator|new
name|CDFPiecewiseLinearRandomGenerator
argument_list|(
name|loggedDiscreteCDF
argument_list|)
expr_stmt|;
comment|/*        * It doesn't matter if we compute and store an interpolator twice because        * the two instances will be semantically identical and stateless, unless        * we're seeded, in which case we're not stateless but this code will be        * called synchronizedly.        */
synchronized|synchronized
init|(
name|interpolatorMap
init|)
block|{
name|interpolatorMap
operator|.
name|put
argument_list|(
name|loggedDiscreteCDF
argument_list|,
name|interpolator
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|interpolator
operator|.
name|randomValue
argument_list|()
return|;
block|}
DECL|class|NoValueToMakeUpRuntime
specifier|static
specifier|private
class|class
name|NoValueToMakeUpRuntime
extends|extends
name|IllegalArgumentException
block|{
DECL|field|serialVersionUID
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|1L
decl_stmt|;
DECL|method|NoValueToMakeUpRuntime ()
name|NoValueToMakeUpRuntime
parameter_list|()
block|{
name|super
argument_list|()
expr_stmt|;
block|}
DECL|method|NoValueToMakeUpRuntime (String detailMessage)
name|NoValueToMakeUpRuntime
parameter_list|(
name|String
name|detailMessage
parameter_list|)
block|{
name|super
argument_list|(
name|detailMessage
argument_list|)
expr_stmt|;
block|}
DECL|method|NoValueToMakeUpRuntime (String detailMessage, Throwable cause)
name|NoValueToMakeUpRuntime
parameter_list|(
name|String
name|detailMessage
parameter_list|,
name|Throwable
name|cause
parameter_list|)
block|{
name|super
argument_list|(
name|detailMessage
argument_list|,
name|cause
argument_list|)
expr_stmt|;
block|}
DECL|method|NoValueToMakeUpRuntime (Throwable cause)
name|NoValueToMakeUpRuntime
parameter_list|(
name|Throwable
name|cause
parameter_list|)
block|{
name|super
argument_list|(
name|cause
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|makeUpState (int taskAttemptNumber, double[] numAttempts)
specifier|private
name|State
name|makeUpState
parameter_list|(
name|int
name|taskAttemptNumber
parameter_list|,
name|double
index|[]
name|numAttempts
parameter_list|)
block|{
comment|// if numAttempts == null we are returning FAILED.
if|if
condition|(
name|numAttempts
operator|==
literal|null
condition|)
block|{
return|return
name|State
operator|.
name|FAILED
return|;
block|}
if|if
condition|(
name|taskAttemptNumber
operator|>=
name|numAttempts
operator|.
name|length
operator|-
literal|1
condition|)
block|{
comment|// always succeed
return|return
name|State
operator|.
name|SUCCEEDED
return|;
block|}
else|else
block|{
name|double
name|pSucceed
init|=
name|numAttempts
index|[
name|taskAttemptNumber
index|]
decl_stmt|;
name|double
name|pFail
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|taskAttemptNumber
operator|+
literal|1
init|;
name|i
operator|<
name|numAttempts
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|pFail
operator|+=
name|numAttempts
index|[
name|i
index|]
expr_stmt|;
block|}
return|return
operator|(
name|random
operator|.
name|nextDouble
argument_list|()
operator|<
name|pSucceed
operator|/
operator|(
name|pSucceed
operator|+
name|pFail
operator|)
operator|)
condition|?
name|State
operator|.
name|SUCCEEDED
else|:
name|State
operator|.
name|FAILED
return|;
block|}
block|}
DECL|method|getMaskedTaskID (TaskType taskType, int taskNumber)
specifier|private
name|TaskID
name|getMaskedTaskID
parameter_list|(
name|TaskType
name|taskType
parameter_list|,
name|int
name|taskNumber
parameter_list|)
block|{
return|return
operator|new
name|TaskID
argument_list|(
operator|new
name|JobID
argument_list|()
argument_list|,
name|taskType
argument_list|,
name|taskNumber
argument_list|)
return|;
block|}
DECL|method|getLoggedTask (TaskType taskType, int taskNumber)
specifier|private
name|LoggedTask
name|getLoggedTask
parameter_list|(
name|TaskType
name|taskType
parameter_list|,
name|int
name|taskNumber
parameter_list|)
block|{
name|buildMaps
argument_list|()
expr_stmt|;
return|return
name|loggedTaskMap
operator|.
name|get
argument_list|(
name|getMaskedTaskID
argument_list|(
name|taskType
argument_list|,
name|taskNumber
argument_list|)
argument_list|)
return|;
block|}
DECL|method|getLoggedTaskAttempt (TaskType taskType, int taskNumber, int taskAttemptNumber)
specifier|private
name|LoggedTaskAttempt
name|getLoggedTaskAttempt
parameter_list|(
name|TaskType
name|taskType
parameter_list|,
name|int
name|taskNumber
parameter_list|,
name|int
name|taskAttemptNumber
parameter_list|)
block|{
name|buildMaps
argument_list|()
expr_stmt|;
name|TaskAttemptID
name|id
init|=
operator|new
name|TaskAttemptID
argument_list|(
name|getMaskedTaskID
argument_list|(
name|taskType
argument_list|,
name|taskNumber
argument_list|)
argument_list|,
name|taskAttemptNumber
argument_list|)
decl_stmt|;
return|return
name|loggedTaskAttemptMap
operator|.
name|get
argument_list|(
name|id
argument_list|)
return|;
block|}
block|}
end_class

end_unit

