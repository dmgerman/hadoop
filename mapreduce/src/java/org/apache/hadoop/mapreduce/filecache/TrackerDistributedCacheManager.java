begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.mapreduce.filecache
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|filecache
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URI
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Random
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|TaskController
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|TaskController
operator|.
name|DistributedCacheFileContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|MRJobConfig
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|server
operator|.
name|tasktracker
operator|.
name|TTConfig
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|util
operator|.
name|MRAsyncDiskService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|LocalDirAllocator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|LocalFileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|UserGroupInformation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|RunJar
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_comment
comment|/**  * Manages a single machine's instance of a cross-job  * cache.  This class would typically be instantiated  * by a TaskTracker (or something that emulates it,  * like LocalJobRunner).  *   */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
DECL|class|TrackerDistributedCacheManager
specifier|public
class|class
name|TrackerDistributedCacheManager
block|{
comment|// cacheID to cacheStatus mapping
DECL|field|cachedArchives
specifier|private
name|LinkedHashMap
argument_list|<
name|String
argument_list|,
name|CacheStatus
argument_list|>
name|cachedArchives
init|=
operator|new
name|LinkedHashMap
argument_list|<
name|String
argument_list|,
name|CacheStatus
argument_list|>
argument_list|()
decl_stmt|;
comment|// default total cache size (10GB)
DECL|field|DEFAULT_CACHE_SIZE
specifier|private
specifier|static
specifier|final
name|long
name|DEFAULT_CACHE_SIZE
init|=
literal|10737418240L
decl_stmt|;
DECL|field|DEFAULT_CACHE_SUBDIR_LIMIT
specifier|private
specifier|static
specifier|final
name|long
name|DEFAULT_CACHE_SUBDIR_LIMIT
init|=
literal|10000
decl_stmt|;
comment|// This default of 75 % was just pulled out of the air, it should be set
comment|// based off of read world use cases.
DECL|field|DEFAULT_CACHE_KEEP_AROUND_PCT
specifier|private
specifier|static
specifier|final
name|float
name|DEFAULT_CACHE_KEEP_AROUND_PCT
init|=
literal|0.75f
decl_stmt|;
DECL|field|allowedCacheSize
specifier|private
name|long
name|allowedCacheSize
decl_stmt|;
DECL|field|allowedCacheSubdirs
specifier|private
name|long
name|allowedCacheSubdirs
decl_stmt|;
DECL|field|allowedCacheSizeCleanupGoal
specifier|private
name|long
name|allowedCacheSizeCleanupGoal
decl_stmt|;
DECL|field|allowedCacheSubdirsCleanupGoal
specifier|private
name|long
name|allowedCacheSubdirsCleanupGoal
decl_stmt|;
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|TrackerDistributedCacheManager
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|localFs
specifier|private
specifier|final
name|LocalFileSystem
name|localFs
decl_stmt|;
DECL|field|lDirAllocator
specifier|private
name|LocalDirAllocator
name|lDirAllocator
decl_stmt|;
DECL|field|taskController
specifier|private
name|TaskController
name|taskController
decl_stmt|;
DECL|field|trackerConf
specifier|private
name|Configuration
name|trackerConf
decl_stmt|;
DECL|field|random
specifier|private
name|Random
name|random
init|=
operator|new
name|Random
argument_list|()
decl_stmt|;
DECL|field|asyncDiskService
specifier|private
name|MRAsyncDiskService
name|asyncDiskService
decl_stmt|;
DECL|field|baseDirManager
specifier|protected
name|BaseDirManager
name|baseDirManager
init|=
operator|new
name|BaseDirManager
argument_list|()
decl_stmt|;
DECL|field|cleanupThread
specifier|protected
name|CleanupThread
name|cleanupThread
decl_stmt|;
DECL|method|TrackerDistributedCacheManager (Configuration conf, TaskController taskController)
specifier|public
name|TrackerDistributedCacheManager
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|TaskController
name|taskController
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|localFs
operator|=
name|FileSystem
operator|.
name|getLocal
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|trackerConf
operator|=
name|conf
expr_stmt|;
name|this
operator|.
name|lDirAllocator
operator|=
operator|new
name|LocalDirAllocator
argument_list|(
name|TTConfig
operator|.
name|LOCAL_DIR
argument_list|)
expr_stmt|;
name|this
operator|.
name|taskController
operator|=
name|taskController
expr_stmt|;
comment|// setting the cache size to a default of 10GB
name|this
operator|.
name|allowedCacheSize
operator|=
name|conf
operator|.
name|getLong
argument_list|(
name|TTConfig
operator|.
name|TT_LOCAL_CACHE_SIZE
argument_list|,
name|DEFAULT_CACHE_SIZE
argument_list|)
expr_stmt|;
comment|// setting the cache number of subdirectories limit to a default of 10000
name|this
operator|.
name|allowedCacheSubdirs
operator|=
name|conf
operator|.
name|getLong
argument_list|(
name|TTConfig
operator|.
name|TT_LOCAL_CACHE_SUBDIRS_LIMIT
argument_list|,
name|DEFAULT_CACHE_SUBDIR_LIMIT
argument_list|)
expr_stmt|;
name|double
name|cleanupPct
init|=
name|conf
operator|.
name|getFloat
argument_list|(
name|TTConfig
operator|.
name|TT_LOCAL_CACHE_KEEP_AROUND_PCT
argument_list|,
name|DEFAULT_CACHE_KEEP_AROUND_PCT
argument_list|)
decl_stmt|;
name|this
operator|.
name|allowedCacheSizeCleanupGoal
operator|=
call|(
name|long
call|)
argument_list|(
name|this
operator|.
name|allowedCacheSize
operator|*
name|cleanupPct
argument_list|)
expr_stmt|;
name|this
operator|.
name|allowedCacheSubdirsCleanupGoal
operator|=
call|(
name|long
call|)
argument_list|(
name|this
operator|.
name|allowedCacheSubdirs
operator|*
name|cleanupPct
argument_list|)
expr_stmt|;
name|this
operator|.
name|cleanupThread
operator|=
operator|new
name|CleanupThread
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
comment|/**    * Creates a TrackerDistributedCacheManager with a MRAsyncDiskService.    * @param asyncDiskService Provides a set of ThreadPools for async disk     *                         operations.      */
DECL|method|TrackerDistributedCacheManager (Configuration conf, TaskController taskController, MRAsyncDiskService asyncDiskService)
specifier|public
name|TrackerDistributedCacheManager
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|TaskController
name|taskController
parameter_list|,
name|MRAsyncDiskService
name|asyncDiskService
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|(
name|conf
argument_list|,
name|taskController
argument_list|)
expr_stmt|;
name|this
operator|.
name|asyncDiskService
operator|=
name|asyncDiskService
expr_stmt|;
block|}
comment|/**    * Get the locally cached file or archive; it could either be    * previously cached (and valid) or copy it from the {@link FileSystem} now.    *    * @param cache the cache to be localized, this should be specified as    * new URI(scheme://scheme-specific-part/absolute_path_to_file#LINKNAME).    * @param conf The Configuration file which contains the filesystem    * @param subDir The base cache subDir where you want to localize the     *  files/archives    * @param fileStatus The file status on the dfs.    * @param isArchive if the cache is an archive or a file. In case it is an    *  archive with a .zip or .jar or .tar or .tgz or .tar.gz extension it will    *  be unzipped/unjarred/untarred automatically    *  and the directory where the archive is unzipped/unjarred/untarred is    *  returned as the Path.    *  In case of a file, the path to the file is returned    * @param confFileStamp this is the hdfs file modification timestamp to verify    * that the file to be cached hasn't changed since the job started    * @param currentWorkDir this is the directory where you would want to create    * symlinks for the locally cached files/archives    * @param honorSymLinkConf if this is false, then the symlinks are not    * created even if conf says so (this is required for an optimization in task    * launches    * NOTE: This is effectively always on since r696957, since there is no code    * path that does not use this.    * @param isPublic to know the cache file is accessible to public or private    * @return the path to directory where the archives are unjarred in case of    * archives, the path to the file where the file is copied locally    * @throws IOException    */
DECL|method|getLocalCache (URI cache, Configuration conf, String subDir, FileStatus fileStatus, boolean isArchive, long confFileStamp, Path currentWorkDir, boolean honorSymLinkConf, boolean isPublic)
name|Path
name|getLocalCache
parameter_list|(
name|URI
name|cache
parameter_list|,
name|Configuration
name|conf
parameter_list|,
name|String
name|subDir
parameter_list|,
name|FileStatus
name|fileStatus
parameter_list|,
name|boolean
name|isArchive
parameter_list|,
name|long
name|confFileStamp
parameter_list|,
name|Path
name|currentWorkDir
parameter_list|,
name|boolean
name|honorSymLinkConf
parameter_list|,
name|boolean
name|isPublic
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|key
decl_stmt|;
name|key
operator|=
name|getKey
argument_list|(
name|cache
argument_list|,
name|conf
argument_list|,
name|confFileStamp
argument_list|,
name|getLocalizedCacheOwner
argument_list|(
name|isPublic
argument_list|)
argument_list|,
name|isArchive
argument_list|)
expr_stmt|;
name|CacheStatus
name|lcacheStatus
decl_stmt|;
synchronized|synchronized
init|(
name|cachedArchives
init|)
block|{
name|lcacheStatus
operator|=
name|cachedArchives
operator|.
name|get
argument_list|(
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|lcacheStatus
operator|==
literal|null
condition|)
block|{
comment|// was never localized
name|String
name|uniqueString
init|=
name|String
operator|.
name|valueOf
argument_list|(
name|random
operator|.
name|nextLong
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|cachePath
init|=
operator|new
name|Path
argument_list|(
name|subDir
argument_list|,
operator|new
name|Path
argument_list|(
name|uniqueString
argument_list|,
name|makeRelative
argument_list|(
name|cache
argument_list|,
name|conf
argument_list|)
argument_list|)
argument_list|)
operator|.
name|toString
argument_list|()
decl_stmt|;
name|Path
name|localPath
init|=
name|lDirAllocator
operator|.
name|getLocalPathForWrite
argument_list|(
name|cachePath
argument_list|,
name|fileStatus
operator|.
name|getLen
argument_list|()
argument_list|,
name|trackerConf
argument_list|)
decl_stmt|;
name|lcacheStatus
operator|=
operator|new
name|CacheStatus
argument_list|(
operator|new
name|Path
argument_list|(
name|localPath
operator|.
name|toString
argument_list|()
operator|.
name|replace
argument_list|(
name|cachePath
argument_list|,
literal|""
argument_list|)
argument_list|)
argument_list|,
name|localPath
argument_list|,
operator|new
name|Path
argument_list|(
name|subDir
argument_list|)
argument_list|,
name|uniqueString
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|cachedArchives
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|lcacheStatus
argument_list|)
expr_stmt|;
block|}
comment|//mark the cache for use.
name|lcacheStatus
operator|.
name|incRefCount
argument_list|()
expr_stmt|;
block|}
name|boolean
name|initSuccessful
init|=
literal|false
decl_stmt|;
try|try
block|{
comment|// do the localization, after releasing the global lock
synchronized|synchronized
init|(
name|lcacheStatus
init|)
block|{
if|if
condition|(
operator|!
name|lcacheStatus
operator|.
name|isInited
argument_list|()
condition|)
block|{
name|FileSystem
name|fs
init|=
name|FileSystem
operator|.
name|get
argument_list|(
name|cache
argument_list|,
name|conf
argument_list|)
decl_stmt|;
name|checkStampSinceJobStarted
argument_list|(
name|conf
argument_list|,
name|fs
argument_list|,
name|cache
argument_list|,
name|confFileStamp
argument_list|,
name|lcacheStatus
argument_list|,
name|fileStatus
argument_list|)
expr_stmt|;
name|localizeCache
argument_list|(
name|conf
argument_list|,
name|cache
argument_list|,
name|confFileStamp
argument_list|,
name|lcacheStatus
argument_list|,
name|isArchive
argument_list|,
name|isPublic
argument_list|)
expr_stmt|;
name|lcacheStatus
operator|.
name|initComplete
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|checkCacheStatusValidity
argument_list|(
name|conf
argument_list|,
name|cache
argument_list|,
name|confFileStamp
argument_list|,
name|lcacheStatus
argument_list|,
name|fileStatus
argument_list|,
name|isArchive
argument_list|)
expr_stmt|;
block|}
name|createSymlink
argument_list|(
name|conf
argument_list|,
name|cache
argument_list|,
name|lcacheStatus
argument_list|,
name|isArchive
argument_list|,
name|currentWorkDir
argument_list|,
name|honorSymLinkConf
argument_list|)
expr_stmt|;
block|}
name|initSuccessful
operator|=
literal|true
expr_stmt|;
return|return
name|lcacheStatus
operator|.
name|localizedLoadPath
return|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|initSuccessful
condition|)
block|{
name|lcacheStatus
operator|.
name|decRefCount
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**    * This is the opposite of getlocalcache. When you are done with    * using the cache, you need to release the cache    * @param cache The cache URI to be released    * @param conf configuration which contains the filesystem the cache    * @param timeStamp the timestamp on the file represented by the cache URI    * @param owner the owner of the localized file    * is contained in.    * @throws IOException    */
DECL|method|releaseCache (URI cache, Configuration conf, long timeStamp, String owner, boolean isArchive)
name|void
name|releaseCache
parameter_list|(
name|URI
name|cache
parameter_list|,
name|Configuration
name|conf
parameter_list|,
name|long
name|timeStamp
parameter_list|,
name|String
name|owner
parameter_list|,
name|boolean
name|isArchive
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|key
init|=
name|getKey
argument_list|(
name|cache
argument_list|,
name|conf
argument_list|,
name|timeStamp
argument_list|,
name|owner
argument_list|,
name|isArchive
argument_list|)
decl_stmt|;
synchronized|synchronized
init|(
name|cachedArchives
init|)
block|{
name|CacheStatus
name|lcacheStatus
init|=
name|cachedArchives
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|lcacheStatus
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Cannot find localized cache: "
operator|+
name|cache
operator|+
literal|" (key: "
operator|+
name|key
operator|+
literal|") in releaseCache!"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// decrement ref count
name|lcacheStatus
operator|.
name|decRefCount
argument_list|()
expr_stmt|;
block|}
block|}
comment|/*    * This method is called from unit tests.     */
DECL|method|getReferenceCount (URI cache, Configuration conf, long timeStamp, String owner, boolean isArchive)
name|int
name|getReferenceCount
parameter_list|(
name|URI
name|cache
parameter_list|,
name|Configuration
name|conf
parameter_list|,
name|long
name|timeStamp
parameter_list|,
name|String
name|owner
parameter_list|,
name|boolean
name|isArchive
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|key
init|=
name|getKey
argument_list|(
name|cache
argument_list|,
name|conf
argument_list|,
name|timeStamp
argument_list|,
name|owner
argument_list|,
name|isArchive
argument_list|)
decl_stmt|;
synchronized|synchronized
init|(
name|cachedArchives
init|)
block|{
name|CacheStatus
name|lcacheStatus
init|=
name|cachedArchives
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|lcacheStatus
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Cannot find localized cache: "
operator|+
name|cache
argument_list|)
throw|;
block|}
return|return
name|lcacheStatus
operator|.
name|getRefCount
argument_list|()
return|;
block|}
block|}
comment|/**    * Get the user who should "own" the localized distributed cache file.    * If the cache is public, the tasktracker user is the owner. If private,    * the user that the task is running as, is the owner.    * @param isPublic    * @return the owner as a shortname string    * @throws IOException    */
DECL|method|getLocalizedCacheOwner (boolean isPublic)
specifier|static
name|String
name|getLocalizedCacheOwner
parameter_list|(
name|boolean
name|isPublic
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|user
decl_stmt|;
if|if
condition|(
name|isPublic
condition|)
block|{
name|user
operator|=
name|UserGroupInformation
operator|.
name|getLoginUser
argument_list|()
operator|.
name|getShortUserName
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|user
operator|=
name|UserGroupInformation
operator|.
name|getCurrentUser
argument_list|()
operator|.
name|getShortUserName
argument_list|()
expr_stmt|;
block|}
return|return
name|user
return|;
block|}
comment|/**    * Delete a local path with asyncDiskService if available,    * or otherwise synchronously with local file system.    */
DECL|method|deleteLocalPath (MRAsyncDiskService asyncDiskService, LocalFileSystem fs, Path path)
specifier|private
specifier|static
name|void
name|deleteLocalPath
parameter_list|(
name|MRAsyncDiskService
name|asyncDiskService
parameter_list|,
name|LocalFileSystem
name|fs
parameter_list|,
name|Path
name|path
parameter_list|)
throws|throws
name|IOException
block|{
name|boolean
name|deleted
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|asyncDiskService
operator|!=
literal|null
condition|)
block|{
comment|// Try to delete using asyncDiskService
name|String
name|localPathToDelete
init|=
name|path
operator|.
name|toUri
argument_list|()
operator|.
name|getPath
argument_list|()
decl_stmt|;
name|deleted
operator|=
name|asyncDiskService
operator|.
name|moveAndDeleteAbsolutePath
argument_list|(
name|localPathToDelete
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|deleted
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Cannot find DistributedCache path "
operator|+
name|localPathToDelete
operator|+
literal|" on any of the asyncDiskService volumes!"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|deleted
condition|)
block|{
comment|// If no asyncDiskService, we will delete the files synchronously
name|fs
operator|.
name|delete
argument_list|(
name|path
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Deleted path "
operator|+
name|path
argument_list|)
expr_stmt|;
block|}
comment|/*    * Returns the relative path of the dir this cache will be localized in    * relative path that this cache will be localized in. For    * hdfs://hostname:port/absolute_path -- the relative path is    * hostname/absolute path -- if it is just /absolute_path -- then the    * relative path is hostname of DFS this mapred cluster is running    * on/absolute_path    */
DECL|method|makeRelative (URI cache, Configuration conf)
name|String
name|makeRelative
parameter_list|(
name|URI
name|cache
parameter_list|,
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|host
init|=
name|cache
operator|.
name|getHost
argument_list|()
decl_stmt|;
if|if
condition|(
name|host
operator|==
literal|null
condition|)
block|{
name|host
operator|=
name|cache
operator|.
name|getScheme
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|host
operator|==
literal|null
condition|)
block|{
name|URI
name|defaultUri
init|=
name|FileSystem
operator|.
name|get
argument_list|(
name|conf
argument_list|)
operator|.
name|getUri
argument_list|()
decl_stmt|;
name|host
operator|=
name|defaultUri
operator|.
name|getHost
argument_list|()
expr_stmt|;
if|if
condition|(
name|host
operator|==
literal|null
condition|)
block|{
name|host
operator|=
name|defaultUri
operator|.
name|getScheme
argument_list|()
expr_stmt|;
block|}
block|}
name|String
name|path
init|=
name|host
operator|+
name|cache
operator|.
name|getPath
argument_list|()
decl_stmt|;
name|path
operator|=
name|path
operator|.
name|replace
argument_list|(
literal|":/"
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
comment|// remove windows device colon
return|return
name|path
return|;
block|}
DECL|method|getKey (URI cache, Configuration conf, long timeStamp, String user, boolean isArchive)
name|String
name|getKey
parameter_list|(
name|URI
name|cache
parameter_list|,
name|Configuration
name|conf
parameter_list|,
name|long
name|timeStamp
parameter_list|,
name|String
name|user
parameter_list|,
name|boolean
name|isArchive
parameter_list|)
throws|throws
name|IOException
block|{
return|return
operator|(
name|isArchive
condition|?
literal|"a"
else|:
literal|"f"
operator|)
operator|+
literal|"^"
operator|+
name|makeRelative
argument_list|(
name|cache
argument_list|,
name|conf
argument_list|)
operator|+
name|String
operator|.
name|valueOf
argument_list|(
name|timeStamp
argument_list|)
operator|+
name|user
return|;
block|}
comment|/**    * Returns {@link FileStatus} of a given cache file on hdfs.    *     * @param conf configuration    * @param cache cache file     * @return {@link FileStatus} of a given cache file on hdfs    * @throws IOException    */
DECL|method|getFileStatus (Configuration conf, URI cache)
specifier|static
name|FileStatus
name|getFileStatus
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|URI
name|cache
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|ClientDistributedCacheManager
operator|.
name|getFileStatus
argument_list|(
name|conf
argument_list|,
name|cache
argument_list|)
return|;
block|}
comment|/**    * Returns mtime of a given cache file on hdfs.    *    * @param conf configuration    * @param cache cache file    * @return mtime of a given cache file on hdfs    * @throws IOException    */
DECL|method|getTimestamp (Configuration conf, URI cache)
name|long
name|getTimestamp
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|URI
name|cache
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|getFileStatus
argument_list|(
name|conf
argument_list|,
name|cache
argument_list|)
operator|.
name|getModificationTime
argument_list|()
return|;
block|}
DECL|method|checkCacheStatusValidity (Configuration conf, URI cache, long confFileStamp, CacheStatus cacheStatus, FileStatus fileStatus, boolean isArchive )
name|void
name|checkCacheStatusValidity
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|URI
name|cache
parameter_list|,
name|long
name|confFileStamp
parameter_list|,
name|CacheStatus
name|cacheStatus
parameter_list|,
name|FileStatus
name|fileStatus
parameter_list|,
name|boolean
name|isArchive
parameter_list|)
throws|throws
name|IOException
block|{
name|FileSystem
name|fs
init|=
name|FileSystem
operator|.
name|get
argument_list|(
name|cache
argument_list|,
name|conf
argument_list|)
decl_stmt|;
comment|// Has to be
if|if
condition|(
operator|!
name|ifExistsAndFresh
argument_list|(
name|conf
argument_list|,
name|fs
argument_list|,
name|cache
argument_list|,
name|confFileStamp
argument_list|,
name|cacheStatus
argument_list|,
name|fileStatus
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Stale cache file: "
operator|+
name|cacheStatus
operator|.
name|localizedLoadPath
operator|+
literal|" for cache-file: "
operator|+
name|cache
argument_list|)
throw|;
block|}
name|LOG
operator|.
name|info
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Using existing cache of %s->%s"
argument_list|,
name|cache
operator|.
name|toString
argument_list|()
argument_list|,
name|cacheStatus
operator|.
name|localizedLoadPath
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|createSymlink (Configuration conf, URI cache, CacheStatus cacheStatus, boolean isArchive, Path currentWorkDir, boolean honorSymLinkConf)
specifier|private
name|void
name|createSymlink
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|URI
name|cache
parameter_list|,
name|CacheStatus
name|cacheStatus
parameter_list|,
name|boolean
name|isArchive
parameter_list|,
name|Path
name|currentWorkDir
parameter_list|,
name|boolean
name|honorSymLinkConf
parameter_list|)
throws|throws
name|IOException
block|{
name|boolean
name|doSymlink
init|=
name|honorSymLinkConf
operator|&&
name|DistributedCache
operator|.
name|getSymlink
argument_list|(
name|conf
argument_list|)
decl_stmt|;
if|if
condition|(
name|cache
operator|.
name|getFragment
argument_list|()
operator|==
literal|null
condition|)
block|{
name|doSymlink
operator|=
literal|false
expr_stmt|;
block|}
name|String
name|link
init|=
name|currentWorkDir
operator|.
name|toString
argument_list|()
operator|+
name|Path
operator|.
name|SEPARATOR
operator|+
name|cache
operator|.
name|getFragment
argument_list|()
decl_stmt|;
name|File
name|flink
init|=
operator|new
name|File
argument_list|(
name|link
argument_list|)
decl_stmt|;
if|if
condition|(
name|doSymlink
condition|)
block|{
if|if
condition|(
operator|!
name|flink
operator|.
name|exists
argument_list|()
condition|)
block|{
name|FileUtil
operator|.
name|symLink
argument_list|(
name|cacheStatus
operator|.
name|localizedLoadPath
operator|.
name|toString
argument_list|()
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// the method which actually copies the caches locally and unjars/unzips them
comment|// and does chmod for the files
DECL|method|localizeCache (Configuration conf, URI cache, long confFileStamp, CacheStatus cacheStatus, boolean isArchive, boolean isPublic)
name|Path
name|localizeCache
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|URI
name|cache
parameter_list|,
name|long
name|confFileStamp
parameter_list|,
name|CacheStatus
name|cacheStatus
parameter_list|,
name|boolean
name|isArchive
parameter_list|,
name|boolean
name|isPublic
parameter_list|)
throws|throws
name|IOException
block|{
name|FileSystem
name|fs
init|=
name|FileSystem
operator|.
name|get
argument_list|(
name|cache
argument_list|,
name|conf
argument_list|)
decl_stmt|;
name|FileSystem
name|localFs
init|=
name|FileSystem
operator|.
name|getLocal
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|Path
name|parchive
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|isArchive
condition|)
block|{
name|parchive
operator|=
operator|new
name|Path
argument_list|(
name|cacheStatus
operator|.
name|localizedLoadPath
argument_list|,
operator|new
name|Path
argument_list|(
name|cacheStatus
operator|.
name|localizedLoadPath
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|parchive
operator|=
name|cacheStatus
operator|.
name|localizedLoadPath
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|localFs
operator|.
name|mkdirs
argument_list|(
name|parchive
operator|.
name|getParent
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Mkdirs failed to create directory "
operator|+
name|cacheStatus
operator|.
name|localizedLoadPath
operator|.
name|toString
argument_list|()
argument_list|)
throw|;
block|}
name|String
name|cacheId
init|=
name|cache
operator|.
name|getPath
argument_list|()
decl_stmt|;
name|fs
operator|.
name|copyToLocalFile
argument_list|(
operator|new
name|Path
argument_list|(
name|cacheId
argument_list|)
argument_list|,
name|parchive
argument_list|)
expr_stmt|;
if|if
condition|(
name|isArchive
condition|)
block|{
name|String
name|tmpArchive
init|=
name|parchive
operator|.
name|toString
argument_list|()
operator|.
name|toLowerCase
argument_list|()
decl_stmt|;
name|File
name|srcFile
init|=
operator|new
name|File
argument_list|(
name|parchive
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
name|File
name|destDir
init|=
operator|new
name|File
argument_list|(
name|parchive
operator|.
name|getParent
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Extracting %s to %s"
argument_list|,
name|srcFile
operator|.
name|toString
argument_list|()
argument_list|,
name|destDir
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpArchive
operator|.
name|endsWith
argument_list|(
literal|".jar"
argument_list|)
condition|)
block|{
name|RunJar
operator|.
name|unJar
argument_list|(
name|srcFile
argument_list|,
name|destDir
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tmpArchive
operator|.
name|endsWith
argument_list|(
literal|".zip"
argument_list|)
condition|)
block|{
name|FileUtil
operator|.
name|unZip
argument_list|(
name|srcFile
argument_list|,
name|destDir
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isTarFile
argument_list|(
name|tmpArchive
argument_list|)
condition|)
block|{
name|FileUtil
operator|.
name|unTar
argument_list|(
name|srcFile
argument_list|,
name|destDir
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Cache file %s specified as archive, but not valid extension."
argument_list|,
name|srcFile
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|// else will not do anyhting
comment|// and copy the file into the dir as it is
block|}
block|}
name|long
name|cacheSize
init|=
name|FileUtil
operator|.
name|getDU
argument_list|(
operator|new
name|File
argument_list|(
name|parchive
operator|.
name|getParent
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|cacheStatus
operator|.
name|size
operator|=
name|cacheSize
expr_stmt|;
comment|// Increase the size and sub directory count of the cache
comment|// from baseDirSize and baseDirNumberSubDir.
name|baseDirManager
operator|.
name|addCacheUpdate
argument_list|(
name|cacheStatus
argument_list|)
expr_stmt|;
comment|// set proper permissions for the localized directory
name|setPermissions
argument_list|(
name|conf
argument_list|,
name|cacheStatus
argument_list|,
name|isPublic
argument_list|)
expr_stmt|;
comment|// update cacheStatus to reflect the newly cached file
name|cacheStatus
operator|.
name|mtime
operator|=
name|getTimestamp
argument_list|(
name|conf
argument_list|,
name|cache
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Cached %s as %s"
argument_list|,
name|cache
operator|.
name|toString
argument_list|()
argument_list|,
name|cacheStatus
operator|.
name|localizedLoadPath
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|cacheStatus
operator|.
name|localizedLoadPath
return|;
block|}
DECL|method|setPermissions (Configuration conf, CacheStatus cacheStatus, boolean isPublic)
specifier|private
name|void
name|setPermissions
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|CacheStatus
name|cacheStatus
parameter_list|,
name|boolean
name|isPublic
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|isPublic
condition|)
block|{
name|Path
name|localizedUniqueDir
init|=
name|cacheStatus
operator|.
name|getLocalizedUniqueDir
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Doing chmod on localdir :"
operator|+
name|localizedUniqueDir
argument_list|)
expr_stmt|;
try|try
block|{
name|FileUtil
operator|.
name|chmod
argument_list|(
name|localizedUniqueDir
operator|.
name|toString
argument_list|()
argument_list|,
literal|"ugo+rx"
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Exception in chmod"
operator|+
name|e
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
else|else
block|{
comment|// invoke taskcontroller to set permissions
name|DistributedCacheFileContext
name|context
init|=
operator|new
name|DistributedCacheFileContext
argument_list|(
name|conf
operator|.
name|get
argument_list|(
name|MRJobConfig
operator|.
name|USER_NAME
argument_list|)
argument_list|,
operator|new
name|File
argument_list|(
name|cacheStatus
operator|.
name|localizedBaseDir
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|,
name|cacheStatus
operator|.
name|localizedBaseDir
argument_list|,
name|cacheStatus
operator|.
name|uniqueString
argument_list|)
decl_stmt|;
name|taskController
operator|.
name|initializeDistributedCacheFile
argument_list|(
name|context
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|isTarFile (String filename)
specifier|private
specifier|static
name|boolean
name|isTarFile
parameter_list|(
name|String
name|filename
parameter_list|)
block|{
return|return
operator|(
name|filename
operator|.
name|endsWith
argument_list|(
literal|".tgz"
argument_list|)
operator|||
name|filename
operator|.
name|endsWith
argument_list|(
literal|".tar.gz"
argument_list|)
operator|||
name|filename
operator|.
name|endsWith
argument_list|(
literal|".tar"
argument_list|)
operator|)
return|;
block|}
comment|// ensure that the file on hdfs hasn't been modified since the job started
DECL|method|checkStampSinceJobStarted (Configuration conf, FileSystem fs, URI cache, long confFileStamp, CacheStatus lcacheStatus, FileStatus fileStatus)
name|long
name|checkStampSinceJobStarted
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|FileSystem
name|fs
parameter_list|,
name|URI
name|cache
parameter_list|,
name|long
name|confFileStamp
parameter_list|,
name|CacheStatus
name|lcacheStatus
parameter_list|,
name|FileStatus
name|fileStatus
parameter_list|)
throws|throws
name|IOException
block|{
name|long
name|dfsFileStamp
decl_stmt|;
if|if
condition|(
name|fileStatus
operator|!=
literal|null
condition|)
block|{
name|dfsFileStamp
operator|=
name|fileStatus
operator|.
name|getModificationTime
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|dfsFileStamp
operator|=
name|getTimestamp
argument_list|(
name|conf
argument_list|,
name|cache
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dfsFileStamp
operator|!=
name|confFileStamp
condition|)
block|{
name|LOG
operator|.
name|fatal
argument_list|(
literal|"File: "
operator|+
name|cache
operator|+
literal|" has changed on HDFS since job started"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
literal|"File: "
operator|+
name|cache
operator|+
literal|" has changed on HDFS since job started"
argument_list|)
throw|;
block|}
return|return
name|dfsFileStamp
return|;
block|}
comment|// Checks if the cache has already been localized and is fresh
DECL|method|ifExistsAndFresh (Configuration conf, FileSystem fs, URI cache, long confFileStamp, CacheStatus lcacheStatus, FileStatus fileStatus)
specifier|private
name|boolean
name|ifExistsAndFresh
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|FileSystem
name|fs
parameter_list|,
name|URI
name|cache
parameter_list|,
name|long
name|confFileStamp
parameter_list|,
name|CacheStatus
name|lcacheStatus
parameter_list|,
name|FileStatus
name|fileStatus
parameter_list|)
throws|throws
name|IOException
block|{
name|long
name|dfsFileStamp
init|=
name|checkStampSinceJobStarted
argument_list|(
name|conf
argument_list|,
name|fs
argument_list|,
name|cache
argument_list|,
name|confFileStamp
argument_list|,
name|lcacheStatus
argument_list|,
name|fileStatus
argument_list|)
decl_stmt|;
if|if
condition|(
name|dfsFileStamp
operator|!=
name|lcacheStatus
operator|.
name|mtime
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
comment|/**    * This method create symlinks for all files in a given dir in another     * directory.    *     * Should not be used outside of DistributedCache code.    *     * @param conf the configuration    * @param jobCacheDir the target directory for creating symlinks    * @param workDir the directory in which the symlinks are created    * @throws IOException    */
DECL|method|createAllSymlink (Configuration conf, File jobCacheDir, File workDir)
specifier|public
specifier|static
name|void
name|createAllSymlink
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|File
name|jobCacheDir
parameter_list|,
name|File
name|workDir
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|(
name|jobCacheDir
operator|==
literal|null
operator|||
operator|!
name|jobCacheDir
operator|.
name|isDirectory
argument_list|()
operator|)
operator|||
name|workDir
operator|==
literal|null
operator|||
operator|(
operator|!
name|workDir
operator|.
name|isDirectory
argument_list|()
operator|)
condition|)
block|{
return|return;
block|}
name|boolean
name|createSymlink
init|=
name|DistributedCache
operator|.
name|getSymlink
argument_list|(
name|conf
argument_list|)
decl_stmt|;
if|if
condition|(
name|createSymlink
condition|)
block|{
name|File
index|[]
name|list
init|=
name|jobCacheDir
operator|.
name|listFiles
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|list
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|String
name|target
init|=
name|list
index|[
name|i
index|]
operator|.
name|getAbsolutePath
argument_list|()
decl_stmt|;
name|String
name|link
init|=
operator|new
name|File
argument_list|(
name|workDir
argument_list|,
name|list
index|[
name|i
index|]
operator|.
name|getName
argument_list|()
argument_list|)
operator|.
name|toString
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Creating symlink: %s<- %s"
argument_list|,
name|target
argument_list|,
name|link
argument_list|)
argument_list|)
expr_stmt|;
name|int
name|ret
init|=
name|FileUtil
operator|.
name|symLink
argument_list|(
name|target
argument_list|,
name|link
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Failed to create symlink: %s<- %s"
argument_list|,
name|target
argument_list|,
name|link
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
DECL|class|CacheStatus
class|class
name|CacheStatus
block|{
comment|//
comment|// This field should be accessed under global cachedArchives lock.
comment|//
DECL|field|refcount
specifier|private
name|int
name|refcount
decl_stmt|;
comment|// number of instances using this cache.
comment|//
comment|// The following three fields should be accessed under
comment|// individual cacheStatus lock.
comment|//
DECL|field|size
name|long
name|size
decl_stmt|;
comment|//the size of this cache.
DECL|field|mtime
name|long
name|mtime
decl_stmt|;
comment|// the cache-file modification time
DECL|field|inited
name|boolean
name|inited
init|=
literal|false
decl_stmt|;
comment|// is it initialized ?
comment|//
comment|// The following four fields are Immutable.
comment|//
comment|// The sub directory (tasktracker/archive or tasktracker/user/archive),
comment|// under which the file will be localized
DECL|field|subDir
specifier|final
name|Path
name|subDir
decl_stmt|;
comment|// unique string used in the construction of local load path
DECL|field|uniqueString
specifier|final
name|String
name|uniqueString
decl_stmt|;
comment|// the local load path of this cache
DECL|field|localizedLoadPath
specifier|final
name|Path
name|localizedLoadPath
decl_stmt|;
comment|//the base dir where the cache lies
DECL|field|localizedBaseDir
specifier|final
name|Path
name|localizedBaseDir
decl_stmt|;
comment|//The key of this in the cachedArchives.
DECL|field|key
specifier|private
specifier|final
name|String
name|key
decl_stmt|;
DECL|method|CacheStatus (Path baseDir, Path localLoadPath, Path subDir, String uniqueString, String key)
specifier|public
name|CacheStatus
parameter_list|(
name|Path
name|baseDir
parameter_list|,
name|Path
name|localLoadPath
parameter_list|,
name|Path
name|subDir
parameter_list|,
name|String
name|uniqueString
parameter_list|,
name|String
name|key
parameter_list|)
block|{
name|super
argument_list|()
expr_stmt|;
name|this
operator|.
name|localizedLoadPath
operator|=
name|localLoadPath
expr_stmt|;
name|this
operator|.
name|refcount
operator|=
literal|0
expr_stmt|;
name|this
operator|.
name|mtime
operator|=
operator|-
literal|1
expr_stmt|;
name|this
operator|.
name|localizedBaseDir
operator|=
name|baseDir
expr_stmt|;
name|this
operator|.
name|size
operator|=
literal|0
expr_stmt|;
name|this
operator|.
name|subDir
operator|=
name|subDir
expr_stmt|;
name|this
operator|.
name|uniqueString
operator|=
name|uniqueString
expr_stmt|;
name|this
operator|.
name|key
operator|=
name|key
expr_stmt|;
block|}
DECL|method|incRefCount ()
specifier|public
specifier|synchronized
name|void
name|incRefCount
parameter_list|()
block|{
name|refcount
operator|+=
literal|1
expr_stmt|;
block|}
DECL|method|decRefCount ()
specifier|public
name|void
name|decRefCount
parameter_list|()
block|{
synchronized|synchronized
init|(
name|cachedArchives
init|)
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
name|refcount
operator|-=
literal|1
expr_stmt|;
if|if
condition|(
name|refcount
operator|<=
literal|0
condition|)
block|{
name|String
name|key
init|=
name|this
operator|.
name|key
decl_stmt|;
name|cachedArchives
operator|.
name|remove
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|cachedArchives
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
DECL|method|getRefCount ()
specifier|public
name|int
name|getRefCount
parameter_list|()
block|{
return|return
name|refcount
return|;
block|}
DECL|method|isUsed ()
specifier|public
specifier|synchronized
name|boolean
name|isUsed
parameter_list|()
block|{
return|return
name|refcount
operator|>
literal|0
return|;
block|}
DECL|method|getBaseDir ()
name|Path
name|getBaseDir
parameter_list|()
block|{
return|return
name|this
operator|.
name|localizedBaseDir
return|;
block|}
comment|// mark it as initialized
DECL|method|initComplete ()
name|void
name|initComplete
parameter_list|()
block|{
name|inited
operator|=
literal|true
expr_stmt|;
block|}
comment|// is it initialized?
DECL|method|isInited ()
name|boolean
name|isInited
parameter_list|()
block|{
return|return
name|inited
return|;
block|}
DECL|method|getLocalizedUniqueDir ()
name|Path
name|getLocalizedUniqueDir
parameter_list|()
block|{
return|return
operator|new
name|Path
argument_list|(
name|localizedBaseDir
argument_list|,
operator|new
name|Path
argument_list|(
name|subDir
argument_list|,
name|uniqueString
argument_list|)
argument_list|)
return|;
block|}
block|}
comment|/**    * Clear the entire contents of the cache and delete the backing files. This    * should only be used when the server is reinitializing, because the users    * are going to lose their files.    */
DECL|method|purgeCache ()
specifier|public
name|void
name|purgeCache
parameter_list|()
block|{
synchronized|synchronized
init|(
name|cachedArchives
init|)
block|{
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|CacheStatus
argument_list|>
name|f
range|:
name|cachedArchives
operator|.
name|entrySet
argument_list|()
control|)
block|{
try|try
block|{
name|deleteLocalPath
argument_list|(
name|asyncDiskService
argument_list|,
name|localFs
argument_list|,
name|f
operator|.
name|getValue
argument_list|()
operator|.
name|localizedLoadPath
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ie
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Error cleaning up cache"
argument_list|,
name|ie
argument_list|)
expr_stmt|;
block|}
block|}
name|cachedArchives
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|newTaskDistributedCacheManager ( Configuration taskConf)
specifier|public
name|TaskDistributedCacheManager
name|newTaskDistributedCacheManager
parameter_list|(
name|Configuration
name|taskConf
parameter_list|)
throws|throws
name|IOException
block|{
return|return
operator|new
name|TaskDistributedCacheManager
argument_list|(
name|this
argument_list|,
name|taskConf
argument_list|)
return|;
block|}
comment|/**    * Get the booleans on whether the files are public or not.  Used by     * internal DistributedCache and MapReduce code.    * @param conf The configuration which stored the timestamps    * @return a string array of booleans     * @throws IOException    */
DECL|method|getFileVisibilities (Configuration conf)
specifier|static
name|String
index|[]
name|getFileVisibilities
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
return|return
name|conf
operator|.
name|getStrings
argument_list|(
name|MRJobConfig
operator|.
name|CACHE_FILE_VISIBILITIES
argument_list|)
return|;
block|}
comment|/**    * Get the booleans on whether the archives are public or not.  Used by     * internal DistributedCache and MapReduce code.    * @param conf The configuration which stored the timestamps    * @return a string array of booleans     */
DECL|method|getArchiveVisibilities (Configuration conf)
specifier|static
name|String
index|[]
name|getArchiveVisibilities
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
return|return
name|conf
operator|.
name|getStrings
argument_list|(
name|MRJobConfig
operator|.
name|CACHE_ARCHIVES_VISIBILITIES
argument_list|)
return|;
block|}
comment|/**    * Set the conf to contain the location for localized archives.    *     * @param conf The conf to modify to contain the localized caches    * @param str a comma separated list of local archives    */
DECL|method|setLocalArchives (Configuration conf, String str)
specifier|static
name|void
name|setLocalArchives
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|String
name|str
parameter_list|)
block|{
name|conf
operator|.
name|set
argument_list|(
name|MRJobConfig
operator|.
name|CACHE_LOCALARCHIVES
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
comment|/**    * Set the conf to contain the location for localized files.    *     * @param conf The conf to modify to contain the localized caches    * @param str a comma separated list of local files    */
DECL|method|setLocalFiles (Configuration conf, String str)
specifier|public
specifier|static
name|void
name|setLocalFiles
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|String
name|str
parameter_list|)
block|{
name|conf
operator|.
name|set
argument_list|(
name|MRJobConfig
operator|.
name|CACHE_LOCALFILES
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
comment|/**    * A thread to check and cleanup the unused files periodically    */
DECL|class|CleanupThread
specifier|protected
class|class
name|CleanupThread
extends|extends
name|Thread
block|{
comment|// How often do we check if we need to clean up cache files?
DECL|field|cleanUpCheckPeriod
specifier|private
name|long
name|cleanUpCheckPeriod
init|=
literal|60000L
decl_stmt|;
comment|// 1 minute
DECL|method|CleanupThread (Configuration conf)
specifier|public
name|CleanupThread
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
name|cleanUpCheckPeriod
operator|=
name|conf
operator|.
name|getLong
argument_list|(
name|TTConfig
operator|.
name|TT_DISTRIBUTED_CACHE_CHECK_PERIOD
argument_list|,
name|cleanUpCheckPeriod
argument_list|)
expr_stmt|;
block|}
DECL|field|running
specifier|private
specifier|volatile
name|boolean
name|running
init|=
literal|true
decl_stmt|;
DECL|method|stopRunning ()
specifier|public
name|void
name|stopRunning
parameter_list|()
block|{
name|running
operator|=
literal|false
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
while|while
condition|(
name|running
condition|)
block|{
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|cleanUpCheckPeriod
argument_list|)
expr_stmt|;
name|baseDirManager
operator|.
name|checkAndCleanup
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Exception in DistributedCache CleanupThread."
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Cleanup..."
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|//To force us to exit cleanly
name|running
operator|=
literal|false
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|exitTaskTracker
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Exit the task tracker because of a fatal error.      */
DECL|method|exitTaskTracker (Throwable t)
specifier|protected
name|void
name|exitTaskTracker
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|LOG
operator|.
name|fatal
argument_list|(
literal|"Distributed Cache cleanup thread received runtime exception."
operator|+
literal|" Exiting the TaskTracker"
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|Runtime
operator|.
name|getRuntime
argument_list|()
operator|.
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
DECL|class|CacheDir
specifier|private
specifier|static
class|class
name|CacheDir
block|{
DECL|field|size
name|long
name|size
decl_stmt|;
DECL|field|subdirs
name|long
name|subdirs
decl_stmt|;
block|}
comment|/**    * This class holds properties of each base directories and is responsible    * for clean up unused cache files in base directories.    */
DECL|class|BaseDirManager
specifier|protected
class|class
name|BaseDirManager
block|{
DECL|field|properties
specifier|private
name|TreeMap
argument_list|<
name|Path
argument_list|,
name|CacheDir
argument_list|>
name|properties
init|=
operator|new
name|TreeMap
argument_list|<
name|Path
argument_list|,
name|CacheDir
argument_list|>
argument_list|()
decl_stmt|;
comment|/**      * Check each base directory to see if the size or number of subdirectories      * are exceed the limit. If the limit is exceeded, start deleting caches      * with zero reference count. This method synchronizes cachedArchives.      */
DECL|method|checkAndCleanup ()
specifier|public
name|void
name|checkAndCleanup
parameter_list|()
throws|throws
name|IOException
block|{
name|Collection
argument_list|<
name|CacheStatus
argument_list|>
name|toBeDeletedCache
init|=
operator|new
name|LinkedList
argument_list|<
name|CacheStatus
argument_list|>
argument_list|()
decl_stmt|;
name|HashMap
argument_list|<
name|Path
argument_list|,
name|CacheDir
argument_list|>
name|toBeCleanedBaseDir
init|=
operator|new
name|HashMap
argument_list|<
name|Path
argument_list|,
name|CacheDir
argument_list|>
argument_list|()
decl_stmt|;
synchronized|synchronized
init|(
name|properties
init|)
block|{
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|Path
argument_list|,
name|CacheDir
argument_list|>
name|baseDir
range|:
name|properties
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|CacheDir
name|baseDirCounts
init|=
name|baseDir
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|allowedCacheSize
operator|<
name|baseDirCounts
operator|.
name|size
operator|||
name|allowedCacheSubdirs
operator|<
name|baseDirCounts
operator|.
name|subdirs
condition|)
block|{
name|CacheDir
name|tcc
init|=
operator|new
name|CacheDir
argument_list|()
decl_stmt|;
name|tcc
operator|.
name|size
operator|=
name|baseDirCounts
operator|.
name|size
operator|-
name|allowedCacheSizeCleanupGoal
expr_stmt|;
name|tcc
operator|.
name|subdirs
operator|=
name|baseDirCounts
operator|.
name|subdirs
operator|-
name|allowedCacheSubdirsCleanupGoal
expr_stmt|;
name|toBeCleanedBaseDir
operator|.
name|put
argument_list|(
name|baseDir
operator|.
name|getKey
argument_list|()
argument_list|,
name|tcc
argument_list|)
expr_stmt|;
block|}
block|}
block|}
synchronized|synchronized
init|(
name|cachedArchives
init|)
block|{
for|for
control|(
name|Iterator
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|CacheStatus
argument_list|>
argument_list|>
name|it
init|=
name|cachedArchives
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|CacheStatus
argument_list|>
name|entry
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|String
name|cacheId
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|CacheStatus
name|cacheStatus
init|=
name|cachedArchives
operator|.
name|get
argument_list|(
name|cacheId
argument_list|)
decl_stmt|;
name|CacheDir
name|leftToClean
init|=
name|toBeCleanedBaseDir
operator|.
name|get
argument_list|(
name|cacheStatus
operator|.
name|getBaseDir
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|leftToClean
operator|!=
literal|null
operator|&&
operator|(
name|leftToClean
operator|.
name|size
operator|>
literal|0
operator|||
name|leftToClean
operator|.
name|subdirs
operator|>
literal|0
operator|)
condition|)
block|{
comment|// if reference count is zero mark the cache for deletion
if|if
condition|(
operator|!
name|cacheStatus
operator|.
name|isUsed
argument_list|()
condition|)
block|{
name|leftToClean
operator|.
name|size
operator|-=
name|cacheStatus
operator|.
name|size
expr_stmt|;
name|leftToClean
operator|.
name|subdirs
operator|--
expr_stmt|;
comment|// delete this cache entry from the global list
comment|// and mark the localized file for deletion
name|toBeDeletedCache
operator|.
name|add
argument_list|(
name|cacheStatus
argument_list|)
expr_stmt|;
name|it
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
comment|// do the deletion, after releasing the global lock
for|for
control|(
name|CacheStatus
name|cacheStatus
range|:
name|toBeDeletedCache
control|)
block|{
synchronized|synchronized
init|(
name|cacheStatus
init|)
block|{
name|deleteLocalPath
argument_list|(
name|asyncDiskService
argument_list|,
name|FileSystem
operator|.
name|getLocal
argument_list|(
name|trackerConf
argument_list|)
argument_list|,
name|cacheStatus
operator|.
name|getLocalizedUniqueDir
argument_list|()
argument_list|)
expr_stmt|;
comment|// Update the maps baseDirSize and baseDirNumberSubDir
name|deleteCacheUpdate
argument_list|(
name|cacheStatus
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Decrement the size and sub directory count of the cache from baseDirSize      * and baseDirNumberSubDir. Have to synchronize cacheStatus before calling      * this method      * @param cacheStatus cache status of the cache is deleted      */
DECL|method|deleteCacheUpdate (CacheStatus cacheStatus)
specifier|public
name|void
name|deleteCacheUpdate
parameter_list|(
name|CacheStatus
name|cacheStatus
parameter_list|)
block|{
if|if
condition|(
operator|!
name|cacheStatus
operator|.
name|inited
condition|)
block|{
comment|// if it is not created yet, do nothing.
return|return;
block|}
synchronized|synchronized
init|(
name|properties
init|)
block|{
name|CacheDir
name|cacheDir
init|=
name|properties
operator|.
name|get
argument_list|(
name|cacheStatus
operator|.
name|getBaseDir
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|cacheDir
operator|!=
literal|null
condition|)
block|{
name|cacheDir
operator|.
name|size
operator|-=
name|cacheStatus
operator|.
name|size
expr_stmt|;
name|cacheDir
operator|.
name|subdirs
operator|--
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Cannot find size and number of subdirectories of"
operator|+
literal|" baseDir: "
operator|+
name|cacheStatus
operator|.
name|getBaseDir
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Update the maps baseDirSize and baseDirNumberSubDir when adding cache.      * Increase the size and sub directory count of the cache from baseDirSize      * and baseDirNumberSubDir. Have to synchronize cacheStatus before calling      * this method.      * @param cacheStatus cache status of the cache is added      */
DECL|method|addCacheUpdate (CacheStatus cacheStatus)
specifier|public
name|void
name|addCacheUpdate
parameter_list|(
name|CacheStatus
name|cacheStatus
parameter_list|)
block|{
name|long
name|cacheSize
init|=
name|cacheStatus
operator|.
name|size
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Adding in cache "
operator|+
name|cacheStatus
operator|.
name|localizedLoadPath
operator|+
literal|" at "
operator|+
name|cacheStatus
operator|.
name|localizedBaseDir
operator|+
literal|" size:"
operator|+
name|cacheStatus
operator|.
name|size
argument_list|)
expr_stmt|;
synchronized|synchronized
init|(
name|properties
init|)
block|{
name|CacheDir
name|cacheDir
init|=
name|properties
operator|.
name|get
argument_list|(
name|cacheStatus
operator|.
name|getBaseDir
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|cacheDir
operator|!=
literal|null
condition|)
block|{
name|cacheDir
operator|.
name|size
operator|+=
name|cacheSize
expr_stmt|;
name|cacheDir
operator|.
name|subdirs
operator|++
expr_stmt|;
block|}
else|else
block|{
name|cacheDir
operator|=
operator|new
name|CacheDir
argument_list|()
expr_stmt|;
name|cacheDir
operator|.
name|size
operator|=
name|cacheSize
expr_stmt|;
name|cacheDir
operator|.
name|subdirs
operator|=
literal|1
expr_stmt|;
name|properties
operator|.
name|put
argument_list|(
name|cacheStatus
operator|.
name|getBaseDir
argument_list|()
argument_list|,
name|cacheDir
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**    * Start the background thread    */
DECL|method|startCleanupThread ()
specifier|public
name|void
name|startCleanupThread
parameter_list|()
block|{
name|this
operator|.
name|cleanupThread
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
comment|/**    * Stop the background thread    */
DECL|method|stopCleanupThread ()
specifier|public
name|void
name|stopCleanupThread
parameter_list|()
block|{
name|cleanupThread
operator|.
name|stopRunning
argument_list|()
expr_stmt|;
name|cleanupThread
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
block|}
end_class

end_unit

