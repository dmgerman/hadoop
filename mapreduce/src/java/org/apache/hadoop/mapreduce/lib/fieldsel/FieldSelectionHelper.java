begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.mapreduce.lib.fieldsel
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|lib
operator|.
name|fieldsel
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceStability
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|Text
import|;
end_import

begin_comment
comment|/**  * This class implements a mapper/reducer class that can be used to perform  * field selections in a manner similar to unix cut. The input data is treated  * as fields separated by a user specified separator (the default value is  * "\t"). The user can specify a list of fields that form the map output keys,  * and a list of fields that form the map output values. If the inputformat is  * TextInputFormat, the mapper will ignore the key to the map function. and the  * fields are from the value only. Otherwise, the fields are the union of those  * from the key and those from the value.  *   * The field separator is under attribute "mapreduce.fieldsel.data.field.separator"  *   * The map output field list spec is under attribute   * "mapreduce.fieldsel.map.output.key.value.fields.spec".  * The value is expected to be like "keyFieldsSpec:valueFieldsSpec"  * key/valueFieldsSpec are comma (,) separated field spec: fieldSpec,fieldSpec,fieldSpec ...  * Each field spec can be a simple number (e.g. 5) specifying a specific field, or a range  * (like 2-5) to specify a range of fields, or an open range (like 3-) specifying all   * the fields starting from field 3. The open range field spec applies value fields only.  * They have no effect on the key fields.  *   * Here is an example: "4,3,0,1:6,5,1-3,7-". It specifies to use fields 4,3,0 and 1 for keys,  * and use fields 6,5,1,2,3,7 and above for values.  *   * The reduce output field list spec is under attribute   * "mapreduce.fieldsel.reduce.output.key.value.fields.spec".  *   * The reducer extracts output key/value pairs in a similar manner, except that  * the key is never ignored.  *   */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Public
annotation|@
name|InterfaceStability
operator|.
name|Stable
DECL|class|FieldSelectionHelper
specifier|public
class|class
name|FieldSelectionHelper
block|{
DECL|field|emptyText
specifier|public
specifier|static
name|Text
name|emptyText
init|=
operator|new
name|Text
argument_list|(
literal|""
argument_list|)
decl_stmt|;
DECL|field|DATA_FIELD_SEPERATOR
specifier|public
specifier|static
specifier|final
name|String
name|DATA_FIELD_SEPERATOR
init|=
literal|"mapreduce.fieldsel.data.field.separator"
decl_stmt|;
DECL|field|MAP_OUTPUT_KEY_VALUE_SPEC
specifier|public
specifier|static
specifier|final
name|String
name|MAP_OUTPUT_KEY_VALUE_SPEC
init|=
literal|"mapreduce.fieldsel.map.output.key.value.fields.spec"
decl_stmt|;
DECL|field|REDUCE_OUTPUT_KEY_VALUE_SPEC
specifier|public
specifier|static
specifier|final
name|String
name|REDUCE_OUTPUT_KEY_VALUE_SPEC
init|=
literal|"mapreduce.fieldsel.reduce.output.key.value.fields.spec"
decl_stmt|;
comment|/**    * Extract the actual field numbers from the given field specs.    * If a field spec is in the form of "n-" (like 3-), then n will be the     * return value. Otherwise, -1 will be returned.      * @param fieldListSpec an array of field specs    * @param fieldList an array of field numbers extracted from the specs.    * @return number n if some field spec is in the form of "n-", -1 otherwise.    */
DECL|method|extractFields (String[] fieldListSpec, List<Integer> fieldList)
specifier|private
specifier|static
name|int
name|extractFields
parameter_list|(
name|String
index|[]
name|fieldListSpec
parameter_list|,
name|List
argument_list|<
name|Integer
argument_list|>
name|fieldList
parameter_list|)
block|{
name|int
name|allFieldsFrom
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|int
name|j
init|=
literal|0
decl_stmt|;
name|int
name|pos
init|=
operator|-
literal|1
decl_stmt|;
name|String
name|fieldSpec
init|=
literal|null
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fieldListSpec
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|fieldSpec
operator|=
name|fieldListSpec
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|fieldSpec
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
continue|continue;
block|}
name|pos
operator|=
name|fieldSpec
operator|.
name|indexOf
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|<
literal|0
condition|)
block|{
name|Integer
name|fn
init|=
operator|new
name|Integer
argument_list|(
name|fieldSpec
argument_list|)
decl_stmt|;
name|fieldList
operator|.
name|add
argument_list|(
name|fn
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|String
name|start
init|=
name|fieldSpec
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|pos
argument_list|)
decl_stmt|;
name|String
name|end
init|=
name|fieldSpec
operator|.
name|substring
argument_list|(
name|pos
operator|+
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|start
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
name|start
operator|=
literal|"0"
expr_stmt|;
block|}
if|if
condition|(
name|end
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
name|allFieldsFrom
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|start
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|int
name|startPos
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|start
argument_list|)
decl_stmt|;
name|int
name|endPos
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|end
argument_list|)
decl_stmt|;
for|for
control|(
name|j
operator|=
name|startPos
init|;
name|j
operator|<=
name|endPos
condition|;
name|j
operator|++
control|)
block|{
name|fieldList
operator|.
name|add
argument_list|(
name|j
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|allFieldsFrom
return|;
block|}
DECL|method|selectFields (String[] fields, List<Integer> fieldList, int allFieldsFrom, String separator)
specifier|private
specifier|static
name|String
name|selectFields
parameter_list|(
name|String
index|[]
name|fields
parameter_list|,
name|List
argument_list|<
name|Integer
argument_list|>
name|fieldList
parameter_list|,
name|int
name|allFieldsFrom
parameter_list|,
name|String
name|separator
parameter_list|)
block|{
name|String
name|retv
init|=
literal|null
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|StringBuffer
name|sb
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|fieldList
operator|!=
literal|null
operator|&&
name|fieldList
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|sb
operator|==
literal|null
condition|)
block|{
name|sb
operator|=
operator|new
name|StringBuffer
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|Integer
name|index
range|:
name|fieldList
control|)
block|{
if|if
condition|(
name|index
operator|<
name|fields
operator|.
name|length
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|fields
index|[
name|index
index|]
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
name|separator
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|allFieldsFrom
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|sb
operator|==
literal|null
condition|)
block|{
name|sb
operator|=
operator|new
name|StringBuffer
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|allFieldsFrom
init|;
name|i
operator|<
name|fields
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|fields
index|[
name|i
index|]
argument_list|)
operator|.
name|append
argument_list|(
name|separator
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sb
operator|!=
literal|null
condition|)
block|{
name|retv
operator|=
name|sb
operator|.
name|toString
argument_list|()
expr_stmt|;
if|if
condition|(
name|retv
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|retv
operator|=
name|retv
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|retv
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|retv
return|;
block|}
DECL|method|parseOutputKeyValueSpec (String keyValueSpec, List<Integer> keyFieldList, List<Integer> valueFieldList)
specifier|public
specifier|static
name|int
name|parseOutputKeyValueSpec
parameter_list|(
name|String
name|keyValueSpec
parameter_list|,
name|List
argument_list|<
name|Integer
argument_list|>
name|keyFieldList
parameter_list|,
name|List
argument_list|<
name|Integer
argument_list|>
name|valueFieldList
parameter_list|)
block|{
name|String
index|[]
name|keyValSpecs
init|=
name|keyValueSpec
operator|.
name|split
argument_list|(
literal|":"
argument_list|,
operator|-
literal|1
argument_list|)
decl_stmt|;
name|String
index|[]
name|keySpec
init|=
name|keyValSpecs
index|[
literal|0
index|]
operator|.
name|split
argument_list|(
literal|","
argument_list|)
decl_stmt|;
name|String
index|[]
name|valSpec
init|=
operator|new
name|String
index|[
literal|0
index|]
decl_stmt|;
if|if
condition|(
name|keyValSpecs
operator|.
name|length
operator|>
literal|1
condition|)
block|{
name|valSpec
operator|=
name|keyValSpecs
index|[
literal|1
index|]
operator|.
name|split
argument_list|(
literal|","
argument_list|)
expr_stmt|;
block|}
name|FieldSelectionHelper
operator|.
name|extractFields
argument_list|(
name|keySpec
argument_list|,
name|keyFieldList
argument_list|)
expr_stmt|;
return|return
name|FieldSelectionHelper
operator|.
name|extractFields
argument_list|(
name|valSpec
argument_list|,
name|valueFieldList
argument_list|)
return|;
block|}
DECL|method|specToString (String fieldSeparator, String keyValueSpec, int allValueFieldsFrom, List<Integer> keyFieldList, List<Integer> valueFieldList)
specifier|public
specifier|static
name|String
name|specToString
parameter_list|(
name|String
name|fieldSeparator
parameter_list|,
name|String
name|keyValueSpec
parameter_list|,
name|int
name|allValueFieldsFrom
parameter_list|,
name|List
argument_list|<
name|Integer
argument_list|>
name|keyFieldList
parameter_list|,
name|List
argument_list|<
name|Integer
argument_list|>
name|valueFieldList
parameter_list|)
block|{
name|StringBuffer
name|sb
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"fieldSeparator: "
argument_list|)
operator|.
name|append
argument_list|(
name|fieldSeparator
argument_list|)
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"keyValueSpec: "
argument_list|)
operator|.
name|append
argument_list|(
name|keyValueSpec
argument_list|)
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"allValueFieldsFrom: "
argument_list|)
operator|.
name|append
argument_list|(
name|allValueFieldsFrom
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"keyFieldList.length: "
argument_list|)
operator|.
name|append
argument_list|(
name|keyFieldList
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|Integer
name|field
range|:
name|keyFieldList
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|"\t"
argument_list|)
operator|.
name|append
argument_list|(
name|field
argument_list|)
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
literal|"valueFieldList.length: "
argument_list|)
operator|.
name|append
argument_list|(
name|valueFieldList
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|Integer
name|field
range|:
name|valueFieldList
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|"\t"
argument_list|)
operator|.
name|append
argument_list|(
name|field
argument_list|)
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
DECL|field|key
specifier|private
name|Text
name|key
init|=
literal|null
decl_stmt|;
DECL|field|value
specifier|private
name|Text
name|value
init|=
literal|null
decl_stmt|;
DECL|method|FieldSelectionHelper ()
specifier|public
name|FieldSelectionHelper
parameter_list|()
block|{   }
DECL|method|FieldSelectionHelper (Text key, Text val)
specifier|public
name|FieldSelectionHelper
parameter_list|(
name|Text
name|key
parameter_list|,
name|Text
name|val
parameter_list|)
block|{
name|this
operator|.
name|key
operator|=
name|key
expr_stmt|;
name|this
operator|.
name|value
operator|=
name|val
expr_stmt|;
block|}
DECL|method|getKey ()
specifier|public
name|Text
name|getKey
parameter_list|()
block|{
return|return
name|key
return|;
block|}
DECL|method|getValue ()
specifier|public
name|Text
name|getValue
parameter_list|()
block|{
return|return
name|value
return|;
block|}
DECL|method|extractOutputKeyValue (String key, String val, String fieldSep, List<Integer> keyFieldList, List<Integer> valFieldList, int allValueFieldsFrom, boolean ignoreKey, boolean isMap)
specifier|public
name|void
name|extractOutputKeyValue
parameter_list|(
name|String
name|key
parameter_list|,
name|String
name|val
parameter_list|,
name|String
name|fieldSep
parameter_list|,
name|List
argument_list|<
name|Integer
argument_list|>
name|keyFieldList
parameter_list|,
name|List
argument_list|<
name|Integer
argument_list|>
name|valFieldList
parameter_list|,
name|int
name|allValueFieldsFrom
parameter_list|,
name|boolean
name|ignoreKey
parameter_list|,
name|boolean
name|isMap
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ignoreKey
condition|)
block|{
name|val
operator|=
name|key
operator|+
name|val
expr_stmt|;
block|}
name|String
index|[]
name|fields
init|=
name|val
operator|.
name|split
argument_list|(
name|fieldSep
argument_list|)
decl_stmt|;
name|String
name|newKey
init|=
name|selectFields
argument_list|(
name|fields
argument_list|,
name|keyFieldList
argument_list|,
operator|-
literal|1
argument_list|,
name|fieldSep
argument_list|)
decl_stmt|;
name|String
name|newVal
init|=
name|selectFields
argument_list|(
name|fields
argument_list|,
name|valFieldList
argument_list|,
name|allValueFieldsFrom
argument_list|,
name|fieldSep
argument_list|)
decl_stmt|;
if|if
condition|(
name|isMap
operator|&&
name|newKey
operator|==
literal|null
condition|)
block|{
name|newKey
operator|=
name|newVal
expr_stmt|;
name|newVal
operator|=
literal|null
expr_stmt|;
block|}
if|if
condition|(
name|newKey
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|key
operator|=
operator|new
name|Text
argument_list|(
name|newKey
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|newVal
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|value
operator|=
operator|new
name|Text
argument_list|(
name|newVal
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

