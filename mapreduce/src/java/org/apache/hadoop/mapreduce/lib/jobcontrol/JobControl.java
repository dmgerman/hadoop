begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.mapreduce.lib.jobcontrol
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|lib
operator|.
name|jobcontrol
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Hashtable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceStability
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|lib
operator|.
name|jobcontrol
operator|.
name|ControlledJob
operator|.
name|State
import|;
end_import

begin_comment
comment|/**   *  This class encapsulates a set of MapReduce jobs and its dependency.  *     *  It tracks the states of the jobs by placing them into different tables  *  according to their states.   *    *  This class provides APIs for the client app to add a job to the group   *  and to get the jobs in the group in different states. When a job is   *  added, an ID unique to the group is assigned to the job.   *    *  This class has a thread that submits jobs when they become ready,   *  monitors the states of the running jobs, and updates the states of jobs  *  based on the state changes of their depending jobs states. The class   *  provides APIs for suspending/resuming the thread, and   *  for stopping the thread.  *    */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Public
annotation|@
name|InterfaceStability
operator|.
name|Evolving
DECL|class|JobControl
specifier|public
class|class
name|JobControl
implements|implements
name|Runnable
block|{
comment|// The thread can be in one of the following state
DECL|enum|ThreadState
DECL|enumConstant|RUNNING
DECL|enumConstant|SUSPENDED
DECL|enumConstant|STOPPED
DECL|enumConstant|STOPPING
DECL|enumConstant|READY
specifier|public
specifier|static
enum|enum
name|ThreadState
block|{
name|RUNNING
block|,
name|SUSPENDED
block|,
name|STOPPED
block|,
name|STOPPING
block|,
name|READY
block|}
empty_stmt|;
DECL|field|runnerState
specifier|private
name|ThreadState
name|runnerState
decl_stmt|;
comment|// the thread state
DECL|field|waitingJobs
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|ControlledJob
argument_list|>
name|waitingJobs
decl_stmt|;
DECL|field|readyJobs
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|ControlledJob
argument_list|>
name|readyJobs
decl_stmt|;
DECL|field|runningJobs
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|ControlledJob
argument_list|>
name|runningJobs
decl_stmt|;
DECL|field|successfulJobs
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|ControlledJob
argument_list|>
name|successfulJobs
decl_stmt|;
DECL|field|failedJobs
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|ControlledJob
argument_list|>
name|failedJobs
decl_stmt|;
DECL|field|nextJobID
specifier|private
name|long
name|nextJobID
decl_stmt|;
DECL|field|groupName
specifier|private
name|String
name|groupName
decl_stmt|;
comment|/**     * Construct a job control for a group of jobs.    * @param groupName a name identifying this group    */
DECL|method|JobControl (String groupName)
specifier|public
name|JobControl
parameter_list|(
name|String
name|groupName
parameter_list|)
block|{
name|this
operator|.
name|waitingJobs
operator|=
operator|new
name|Hashtable
argument_list|<
name|String
argument_list|,
name|ControlledJob
argument_list|>
argument_list|()
expr_stmt|;
name|this
operator|.
name|readyJobs
operator|=
operator|new
name|Hashtable
argument_list|<
name|String
argument_list|,
name|ControlledJob
argument_list|>
argument_list|()
expr_stmt|;
name|this
operator|.
name|runningJobs
operator|=
operator|new
name|Hashtable
argument_list|<
name|String
argument_list|,
name|ControlledJob
argument_list|>
argument_list|()
expr_stmt|;
name|this
operator|.
name|successfulJobs
operator|=
operator|new
name|Hashtable
argument_list|<
name|String
argument_list|,
name|ControlledJob
argument_list|>
argument_list|()
expr_stmt|;
name|this
operator|.
name|failedJobs
operator|=
operator|new
name|Hashtable
argument_list|<
name|String
argument_list|,
name|ControlledJob
argument_list|>
argument_list|()
expr_stmt|;
name|this
operator|.
name|nextJobID
operator|=
operator|-
literal|1
expr_stmt|;
name|this
operator|.
name|groupName
operator|=
name|groupName
expr_stmt|;
name|this
operator|.
name|runnerState
operator|=
name|ThreadState
operator|.
name|READY
expr_stmt|;
block|}
DECL|method|toList ( Map<String, ControlledJob> jobs)
specifier|private
specifier|static
name|List
argument_list|<
name|ControlledJob
argument_list|>
name|toList
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|ControlledJob
argument_list|>
name|jobs
parameter_list|)
block|{
name|ArrayList
argument_list|<
name|ControlledJob
argument_list|>
name|retv
init|=
operator|new
name|ArrayList
argument_list|<
name|ControlledJob
argument_list|>
argument_list|()
decl_stmt|;
synchronized|synchronized
init|(
name|jobs
init|)
block|{
for|for
control|(
name|ControlledJob
name|job
range|:
name|jobs
operator|.
name|values
argument_list|()
control|)
block|{
name|retv
operator|.
name|add
argument_list|(
name|job
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|retv
return|;
block|}
comment|/**    * @return the jobs in the waiting state    */
DECL|method|getWaitingJobList ()
specifier|public
name|List
argument_list|<
name|ControlledJob
argument_list|>
name|getWaitingJobList
parameter_list|()
block|{
return|return
name|toList
argument_list|(
name|this
operator|.
name|waitingJobs
argument_list|)
return|;
block|}
comment|/**    * @return the jobs in the running state    */
DECL|method|getRunningJobList ()
specifier|public
name|List
argument_list|<
name|ControlledJob
argument_list|>
name|getRunningJobList
parameter_list|()
block|{
return|return
name|toList
argument_list|(
name|this
operator|.
name|runningJobs
argument_list|)
return|;
block|}
comment|/**    * @return the jobs in the ready state    */
DECL|method|getReadyJobsList ()
specifier|public
name|List
argument_list|<
name|ControlledJob
argument_list|>
name|getReadyJobsList
parameter_list|()
block|{
return|return
name|toList
argument_list|(
name|this
operator|.
name|readyJobs
argument_list|)
return|;
block|}
comment|/**    * @return the jobs in the success state    */
DECL|method|getSuccessfulJobList ()
specifier|public
name|List
argument_list|<
name|ControlledJob
argument_list|>
name|getSuccessfulJobList
parameter_list|()
block|{
return|return
name|toList
argument_list|(
name|this
operator|.
name|successfulJobs
argument_list|)
return|;
block|}
DECL|method|getFailedJobList ()
specifier|public
name|List
argument_list|<
name|ControlledJob
argument_list|>
name|getFailedJobList
parameter_list|()
block|{
return|return
name|toList
argument_list|(
name|this
operator|.
name|failedJobs
argument_list|)
return|;
block|}
DECL|method|getNextJobID ()
specifier|private
name|String
name|getNextJobID
parameter_list|()
block|{
name|nextJobID
operator|+=
literal|1
expr_stmt|;
return|return
name|this
operator|.
name|groupName
operator|+
name|this
operator|.
name|nextJobID
return|;
block|}
DECL|method|addToQueue (ControlledJob aJob, Map<String, ControlledJob> queue)
specifier|private
specifier|static
name|void
name|addToQueue
parameter_list|(
name|ControlledJob
name|aJob
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|ControlledJob
argument_list|>
name|queue
parameter_list|)
block|{
synchronized|synchronized
init|(
name|queue
init|)
block|{
name|queue
operator|.
name|put
argument_list|(
name|aJob
operator|.
name|getJobID
argument_list|()
argument_list|,
name|aJob
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|addToQueue (ControlledJob aJob)
specifier|private
name|void
name|addToQueue
parameter_list|(
name|ControlledJob
name|aJob
parameter_list|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|ControlledJob
argument_list|>
name|queue
init|=
name|getQueue
argument_list|(
name|aJob
operator|.
name|getJobState
argument_list|()
argument_list|)
decl_stmt|;
name|addToQueue
argument_list|(
name|aJob
argument_list|,
name|queue
argument_list|)
expr_stmt|;
block|}
DECL|method|getQueue (State state)
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|ControlledJob
argument_list|>
name|getQueue
parameter_list|(
name|State
name|state
parameter_list|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|ControlledJob
argument_list|>
name|retv
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|state
operator|==
name|State
operator|.
name|WAITING
condition|)
block|{
name|retv
operator|=
name|this
operator|.
name|waitingJobs
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|state
operator|==
name|State
operator|.
name|READY
condition|)
block|{
name|retv
operator|=
name|this
operator|.
name|readyJobs
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|state
operator|==
name|State
operator|.
name|RUNNING
condition|)
block|{
name|retv
operator|=
name|this
operator|.
name|runningJobs
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|state
operator|==
name|State
operator|.
name|SUCCESS
condition|)
block|{
name|retv
operator|=
name|this
operator|.
name|successfulJobs
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|state
operator|==
name|State
operator|.
name|FAILED
operator|||
name|state
operator|==
name|State
operator|.
name|DEPENDENT_FAILED
condition|)
block|{
name|retv
operator|=
name|this
operator|.
name|failedJobs
expr_stmt|;
block|}
return|return
name|retv
return|;
block|}
comment|/**    * Add a new job.    * @param aJob the new job    */
DECL|method|addJob (ControlledJob aJob)
specifier|synchronized
specifier|public
name|String
name|addJob
parameter_list|(
name|ControlledJob
name|aJob
parameter_list|)
block|{
name|String
name|id
init|=
name|this
operator|.
name|getNextJobID
argument_list|()
decl_stmt|;
name|aJob
operator|.
name|setJobID
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|aJob
operator|.
name|setJobState
argument_list|(
name|State
operator|.
name|WAITING
argument_list|)
expr_stmt|;
name|this
operator|.
name|addToQueue
argument_list|(
name|aJob
argument_list|)
expr_stmt|;
return|return
name|id
return|;
block|}
comment|/**    * Add a collection of jobs    *     * @param jobs    */
DECL|method|addJobCollection (Collection<ControlledJob> jobs)
specifier|public
name|void
name|addJobCollection
parameter_list|(
name|Collection
argument_list|<
name|ControlledJob
argument_list|>
name|jobs
parameter_list|)
block|{
for|for
control|(
name|ControlledJob
name|job
range|:
name|jobs
control|)
block|{
name|addJob
argument_list|(
name|job
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * @return the thread state    */
DECL|method|getThreadState ()
specifier|public
name|ThreadState
name|getThreadState
parameter_list|()
block|{
return|return
name|this
operator|.
name|runnerState
return|;
block|}
comment|/**    * set the thread state to STOPPING so that the     * thread will stop when it wakes up.    */
DECL|method|stop ()
specifier|public
name|void
name|stop
parameter_list|()
block|{
name|this
operator|.
name|runnerState
operator|=
name|ThreadState
operator|.
name|STOPPING
expr_stmt|;
block|}
comment|/**    * suspend the running thread    */
DECL|method|suspend ()
specifier|public
name|void
name|suspend
parameter_list|()
block|{
if|if
condition|(
name|this
operator|.
name|runnerState
operator|==
name|ThreadState
operator|.
name|RUNNING
condition|)
block|{
name|this
operator|.
name|runnerState
operator|=
name|ThreadState
operator|.
name|SUSPENDED
expr_stmt|;
block|}
block|}
comment|/**    * resume the suspended thread    */
DECL|method|resume ()
specifier|public
name|void
name|resume
parameter_list|()
block|{
if|if
condition|(
name|this
operator|.
name|runnerState
operator|==
name|ThreadState
operator|.
name|SUSPENDED
condition|)
block|{
name|this
operator|.
name|runnerState
operator|=
name|ThreadState
operator|.
name|RUNNING
expr_stmt|;
block|}
block|}
DECL|method|checkRunningJobs ()
specifier|synchronized
specifier|private
name|void
name|checkRunningJobs
parameter_list|()
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|ControlledJob
argument_list|>
name|oldJobs
init|=
literal|null
decl_stmt|;
name|oldJobs
operator|=
name|this
operator|.
name|runningJobs
expr_stmt|;
name|this
operator|.
name|runningJobs
operator|=
operator|new
name|Hashtable
argument_list|<
name|String
argument_list|,
name|ControlledJob
argument_list|>
argument_list|()
expr_stmt|;
for|for
control|(
name|ControlledJob
name|nextJob
range|:
name|oldJobs
operator|.
name|values
argument_list|()
control|)
block|{
name|nextJob
operator|.
name|checkState
argument_list|()
expr_stmt|;
name|this
operator|.
name|addToQueue
argument_list|(
name|nextJob
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|checkWaitingJobs ()
specifier|synchronized
specifier|private
name|void
name|checkWaitingJobs
parameter_list|()
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|ControlledJob
argument_list|>
name|oldJobs
init|=
literal|null
decl_stmt|;
name|oldJobs
operator|=
name|this
operator|.
name|waitingJobs
expr_stmt|;
name|this
operator|.
name|waitingJobs
operator|=
operator|new
name|Hashtable
argument_list|<
name|String
argument_list|,
name|ControlledJob
argument_list|>
argument_list|()
expr_stmt|;
for|for
control|(
name|ControlledJob
name|nextJob
range|:
name|oldJobs
operator|.
name|values
argument_list|()
control|)
block|{
name|nextJob
operator|.
name|checkState
argument_list|()
expr_stmt|;
name|this
operator|.
name|addToQueue
argument_list|(
name|nextJob
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|startReadyJobs ()
specifier|synchronized
specifier|private
name|void
name|startReadyJobs
parameter_list|()
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|ControlledJob
argument_list|>
name|oldJobs
init|=
literal|null
decl_stmt|;
name|oldJobs
operator|=
name|this
operator|.
name|readyJobs
expr_stmt|;
name|this
operator|.
name|readyJobs
operator|=
operator|new
name|Hashtable
argument_list|<
name|String
argument_list|,
name|ControlledJob
argument_list|>
argument_list|()
expr_stmt|;
for|for
control|(
name|ControlledJob
name|nextJob
range|:
name|oldJobs
operator|.
name|values
argument_list|()
control|)
block|{
comment|//Submitting Job to Hadoop
name|nextJob
operator|.
name|submit
argument_list|()
expr_stmt|;
name|this
operator|.
name|addToQueue
argument_list|(
name|nextJob
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|allFinished ()
specifier|synchronized
specifier|public
name|boolean
name|allFinished
parameter_list|()
block|{
return|return
name|this
operator|.
name|waitingJobs
operator|.
name|size
argument_list|()
operator|==
literal|0
operator|&&
name|this
operator|.
name|readyJobs
operator|.
name|size
argument_list|()
operator|==
literal|0
operator|&&
name|this
operator|.
name|runningJobs
operator|.
name|size
argument_list|()
operator|==
literal|0
return|;
block|}
comment|/**    *  The main loop for the thread.    *  The loop does the following:    *  	Check the states of the running jobs    *  	Update the states of waiting jobs    *  	Submit the jobs in ready state    */
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
name|this
operator|.
name|runnerState
operator|=
name|ThreadState
operator|.
name|RUNNING
expr_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
while|while
condition|(
name|this
operator|.
name|runnerState
operator|==
name|ThreadState
operator|.
name|SUSPENDED
condition|)
block|{
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
literal|5000
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{ 					         }
block|}
try|try
block|{
name|checkRunningJobs
argument_list|()
expr_stmt|;
name|checkWaitingJobs
argument_list|()
expr_stmt|;
name|startReadyJobs
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|this
operator|.
name|runnerState
operator|=
name|ThreadState
operator|.
name|STOPPED
expr_stmt|;
block|}
if|if
condition|(
name|this
operator|.
name|runnerState
operator|!=
name|ThreadState
operator|.
name|RUNNING
operator|&&
name|this
operator|.
name|runnerState
operator|!=
name|ThreadState
operator|.
name|SUSPENDED
condition|)
block|{
break|break;
block|}
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
literal|5000
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{ 				       }
if|if
condition|(
name|this
operator|.
name|runnerState
operator|!=
name|ThreadState
operator|.
name|RUNNING
operator|&&
name|this
operator|.
name|runnerState
operator|!=
name|ThreadState
operator|.
name|SUSPENDED
condition|)
block|{
break|break;
block|}
block|}
name|this
operator|.
name|runnerState
operator|=
name|ThreadState
operator|.
name|STOPPED
expr_stmt|;
block|}
block|}
end_class

end_unit

