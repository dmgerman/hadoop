begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.mapred
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileNotFoundException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|PrintWriter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Writer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|BindException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|InetSocketAddress
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|UnknownHostException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|PrivilegedExceptionAction
import|;
end_import

begin_import
import|import
name|java
operator|.
name|text
operator|.
name|ParseException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|text
operator|.
name|SimpleDateFormat
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Date
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Properties
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Vector
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|CopyOnWriteArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|security
operator|.
name|auth
operator|.
name|login
operator|.
name|LoginException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceStability
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|CommonConfigurationKeys
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FSDataInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FSDataOutputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|LocalFileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|permission
operator|.
name|FsPermission
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|http
operator|.
name|HttpServer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|Text
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|ProtocolSignature
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|RPC
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|Server
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|RPC
operator|.
name|VersionMismatch
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|AuditLogger
operator|.
name|Constants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|ClusterStatus
operator|.
name|BlackListInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|JobInProgress
operator|.
name|KillInterruptedException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|JobStatusChangeEvent
operator|.
name|EventType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|JobTrackerStatistics
operator|.
name|TaskTrackerStat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|TaskTrackerStatus
operator|.
name|TaskTrackerHealthStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|ClusterMetrics
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|MRConfig
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|QueueInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|TaskTrackerInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|TaskType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|Cluster
operator|.
name|JobTrackerStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|jobhistory
operator|.
name|JobHistory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|protocol
operator|.
name|ClientProtocol
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|security
operator|.
name|token
operator|.
name|DelegationTokenRenewal
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|security
operator|.
name|token
operator|.
name|JobTokenSecretManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|security
operator|.
name|token
operator|.
name|delegation
operator|.
name|DelegationTokenIdentifier
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|security
operator|.
name|token
operator|.
name|delegation
operator|.
name|DelegationTokenSecretManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|server
operator|.
name|jobtracker
operator|.
name|JTConfig
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|server
operator|.
name|jobtracker
operator|.
name|State
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|server
operator|.
name|jobtracker
operator|.
name|TaskTracker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|util
operator|.
name|ConfigUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|util
operator|.
name|MRAsyncDiskService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|net
operator|.
name|DNSToSwitchMapping
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|net
operator|.
name|NetUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|net
operator|.
name|NetworkTopology
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|net
operator|.
name|Node
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|net
operator|.
name|NodeBase
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|net
operator|.
name|ScriptBasedMapping
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|AccessControlException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|Groups
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|RefreshUserMappingsProtocol
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|Credentials
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|SecurityUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|UserGroupInformation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|UserGroupInformation
operator|.
name|AuthenticationMethod
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|authorize
operator|.
name|AccessControlList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|authorize
operator|.
name|AuthorizationException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|authorize
operator|.
name|ProxyUsers
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|authorize
operator|.
name|RefreshAuthorizationPolicyProtocol
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|authorize
operator|.
name|ServiceAuthorizationManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|token
operator|.
name|Token
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|tools
operator|.
name|GetUserMappingsProtocol
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|HostsFileReader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|ReflectionUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|ServicePlugin
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|VersionInfo
import|;
end_import

begin_comment
comment|/*******************************************************  * JobTracker is the central location for submitting and   * tracking MR jobs in a network environment.  *  *******************************************************/
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
annotation|@
name|InterfaceStability
operator|.
name|Unstable
DECL|class|JobTracker
specifier|public
class|class
name|JobTracker
implements|implements
name|MRConstants
implements|,
name|InterTrackerProtocol
implements|,
name|ClientProtocol
implements|,
name|TaskTrackerManager
implements|,
name|RefreshUserMappingsProtocol
implements|,
name|RefreshAuthorizationPolicyProtocol
implements|,
name|AdminOperationsProtocol
implements|,
name|GetUserMappingsProtocol
implements|,
name|JTConfig
block|{
static|static
block|{
name|ConfigUtil
operator|.
name|loadResources
argument_list|()
expr_stmt|;
block|}
DECL|field|tasktrackerExpiryInterval
specifier|private
specifier|final
name|long
name|tasktrackerExpiryInterval
decl_stmt|;
DECL|field|DELEGATION_TOKEN_GC_INTERVAL
specifier|private
specifier|final
name|long
name|DELEGATION_TOKEN_GC_INTERVAL
init|=
literal|3600000
decl_stmt|;
comment|// 1 hour
DECL|field|secretManager
specifier|private
specifier|final
name|DelegationTokenSecretManager
name|secretManager
decl_stmt|;
comment|// The interval after which one fault of a tracker will be discarded,
comment|// if there are no faults during this.
DECL|field|UPDATE_FAULTY_TRACKER_INTERVAL
specifier|private
specifier|static
name|long
name|UPDATE_FAULTY_TRACKER_INTERVAL
init|=
literal|24
operator|*
literal|60
operator|*
literal|60
operator|*
literal|1000
decl_stmt|;
comment|// The maximum percentage of trackers in cluster added
comment|// to the 'blacklist' across all the jobs.
DECL|field|MAX_BLACKLIST_PERCENT
specifier|private
specifier|static
name|double
name|MAX_BLACKLIST_PERCENT
init|=
literal|0.50
decl_stmt|;
comment|// A tracker is blacklisted across jobs only if number of
comment|// blacklists are X% above the average number of blacklists.
comment|// X is the blacklist threshold here.
DECL|field|AVERAGE_BLACKLIST_THRESHOLD
specifier|private
name|double
name|AVERAGE_BLACKLIST_THRESHOLD
init|=
literal|0.50
decl_stmt|;
comment|// The maximum number of blacklists for a tracker after which the
comment|// tracker could be blacklisted across all jobs
DECL|field|MAX_BLACKLISTS_PER_TRACKER
specifier|private
name|int
name|MAX_BLACKLISTS_PER_TRACKER
init|=
literal|4
decl_stmt|;
comment|// Approximate number of heartbeats that could arrive JobTracker
comment|// in a second
DECL|field|NUM_HEARTBEATS_IN_SECOND
specifier|private
name|int
name|NUM_HEARTBEATS_IN_SECOND
decl_stmt|;
DECL|field|DEFAULT_NUM_HEARTBEATS_IN_SECOND
specifier|private
specifier|final
name|int
name|DEFAULT_NUM_HEARTBEATS_IN_SECOND
init|=
literal|100
decl_stmt|;
DECL|field|MIN_NUM_HEARTBEATS_IN_SECOND
specifier|private
specifier|final
name|int
name|MIN_NUM_HEARTBEATS_IN_SECOND
init|=
literal|1
decl_stmt|;
comment|// Scaling factor for heartbeats, used for testing only
DECL|field|HEARTBEATS_SCALING_FACTOR
specifier|private
name|float
name|HEARTBEATS_SCALING_FACTOR
decl_stmt|;
DECL|field|MIN_HEARTBEATS_SCALING_FACTOR
specifier|private
specifier|final
name|float
name|MIN_HEARTBEATS_SCALING_FACTOR
init|=
literal|0.01f
decl_stmt|;
DECL|field|DEFAULT_HEARTBEATS_SCALING_FACTOR
specifier|private
specifier|final
name|float
name|DEFAULT_HEARTBEATS_SCALING_FACTOR
init|=
literal|1.0f
decl_stmt|;
comment|// Minimum interval for heartbeats regardless of cluster size.
DECL|field|HEARTBEAT_INTERVAL_MIN
specifier|private
name|int
name|HEARTBEAT_INTERVAL_MIN
decl_stmt|;
annotation|@
name|InterfaceAudience
operator|.
name|Private
annotation|@
name|InterfaceStability
operator|.
name|Unstable
DECL|enum|State
DECL|enumConstant|INITIALIZING
DECL|enumConstant|RUNNING
specifier|public
specifier|static
enum|enum
name|State
block|{
name|INITIALIZING
block|,
name|RUNNING
block|}
DECL|field|state
name|State
name|state
init|=
name|State
operator|.
name|INITIALIZING
decl_stmt|;
DECL|field|FS_ACCESS_RETRY_PERIOD
specifier|private
specifier|static
specifier|final
name|int
name|FS_ACCESS_RETRY_PERIOD
init|=
literal|10000
decl_stmt|;
DECL|field|JOB_INFO_FILE
specifier|static
specifier|final
name|String
name|JOB_INFO_FILE
init|=
literal|"job-info"
decl_stmt|;
DECL|field|dnsToSwitchMapping
specifier|private
name|DNSToSwitchMapping
name|dnsToSwitchMapping
decl_stmt|;
DECL|field|clusterMap
name|NetworkTopology
name|clusterMap
init|=
operator|new
name|NetworkTopology
argument_list|()
decl_stmt|;
DECL|field|numTaskCacheLevels
specifier|private
name|int
name|numTaskCacheLevels
decl_stmt|;
comment|// the max level to which we cache tasks
comment|/**    * {@link #nodesAtMaxLevel} is using the keySet from {@link ConcurrentHashMap}    * so that it can be safely written to and iterated on via 2 separate threads.    * Note: It can only be iterated from a single thread which is feasible since    *       the only iteration is done in {@link JobInProgress} under the     *       {@link JobTracker} lock.    */
DECL|field|nodesAtMaxLevel
specifier|private
name|Set
argument_list|<
name|Node
argument_list|>
name|nodesAtMaxLevel
init|=
name|Collections
operator|.
name|newSetFromMap
argument_list|(
operator|new
name|ConcurrentHashMap
argument_list|<
name|Node
argument_list|,
name|Boolean
argument_list|>
argument_list|()
argument_list|)
decl_stmt|;
DECL|field|taskScheduler
specifier|final
name|TaskScheduler
name|taskScheduler
decl_stmt|;
DECL|field|jobInProgressListeners
specifier|private
specifier|final
name|List
argument_list|<
name|JobInProgressListener
argument_list|>
name|jobInProgressListeners
init|=
operator|new
name|CopyOnWriteArrayList
argument_list|<
name|JobInProgressListener
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|plugins
specifier|private
name|List
argument_list|<
name|ServicePlugin
argument_list|>
name|plugins
decl_stmt|;
comment|// system directory is completely owned by the JobTracker
DECL|field|SYSTEM_DIR_PERMISSION
specifier|final
specifier|static
name|FsPermission
name|SYSTEM_DIR_PERMISSION
init|=
name|FsPermission
operator|.
name|createImmutable
argument_list|(
operator|(
name|short
operator|)
literal|0700
argument_list|)
decl_stmt|;
comment|// rwx------
comment|// system files should have 700 permission
DECL|field|SYSTEM_FILE_PERMISSION
specifier|final
specifier|static
name|FsPermission
name|SYSTEM_FILE_PERMISSION
init|=
name|FsPermission
operator|.
name|createImmutable
argument_list|(
operator|(
name|short
operator|)
literal|0700
argument_list|)
decl_stmt|;
comment|// rwx------
DECL|field|clock
specifier|private
specifier|static
name|Clock
name|clock
init|=
literal|null
decl_stmt|;
DECL|field|DEFAULT_CLOCK
specifier|static
specifier|final
name|Clock
name|DEFAULT_CLOCK
init|=
operator|new
name|Clock
argument_list|()
decl_stmt|;
DECL|field|jobHistory
specifier|private
specifier|final
name|JobHistory
name|jobHistory
decl_stmt|;
DECL|field|jobTokenSecretManager
specifier|private
specifier|final
name|JobTokenSecretManager
name|jobTokenSecretManager
init|=
operator|new
name|JobTokenSecretManager
argument_list|()
decl_stmt|;
DECL|method|getJobTokenSecretManager ()
name|JobTokenSecretManager
name|getJobTokenSecretManager
parameter_list|()
block|{
return|return
name|jobTokenSecretManager
return|;
block|}
DECL|field|asyncDiskService
specifier|private
name|MRAsyncDiskService
name|asyncDiskService
decl_stmt|;
comment|/**    * Returns the delegation token secret manager instance in JobTracker.    *     * @return DelegationTokenSecretManager object    */
DECL|method|getDelegationTokenSecretManager ()
specifier|public
name|DelegationTokenSecretManager
name|getDelegationTokenSecretManager
parameter_list|()
block|{
return|return
name|secretManager
return|;
block|}
comment|/**    * A client tried to submit a job before the Job Tracker was ready.    */
annotation|@
name|InterfaceAudience
operator|.
name|Private
annotation|@
name|InterfaceStability
operator|.
name|Unstable
DECL|class|IllegalStateException
specifier|public
specifier|static
class|class
name|IllegalStateException
extends|extends
name|IOException
block|{
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|1L
decl_stmt|;
DECL|method|IllegalStateException (String msg)
specifier|public
name|IllegalStateException
parameter_list|(
name|String
name|msg
parameter_list|)
block|{
name|super
argument_list|(
name|msg
argument_list|)
expr_stmt|;
block|}
block|}
DECL|field|nextJobId
specifier|private
specifier|final
name|AtomicInteger
name|nextJobId
init|=
operator|new
name|AtomicInteger
argument_list|(
literal|1
argument_list|)
decl_stmt|;
DECL|field|LOG
specifier|public
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|JobTracker
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/**    * Returns JobTracker's clock. Note that the correct clock implementation will    * be obtained only when the JobTracker is initialized. If the JobTracker is    * not initialized then the default clock i.e {@link Clock} is returned.     */
DECL|method|getClock ()
specifier|static
name|Clock
name|getClock
parameter_list|()
block|{
return|return
name|clock
operator|==
literal|null
condition|?
name|DEFAULT_CLOCK
else|:
name|clock
return|;
block|}
comment|/**    * Return the JT's job history handle.    * @return the jobhistory handle    */
DECL|method|getJobHistory ()
name|JobHistory
name|getJobHistory
parameter_list|()
block|{
return|return
name|jobHistory
return|;
block|}
comment|/**    * Start the JobTracker with given configuration.    *     * The conf will be modified to reflect the actual ports on which     * the JobTracker is up and running if the user passes the port as    *<code>zero</code>.    *       * @param conf configuration for the JobTracker.    * @throws IOException    */
DECL|method|startTracker (JobConf conf)
specifier|public
specifier|static
name|JobTracker
name|startTracker
parameter_list|(
name|JobConf
name|conf
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
return|return
name|startTracker
argument_list|(
name|conf
argument_list|,
name|DEFAULT_CLOCK
argument_list|)
return|;
block|}
DECL|method|startTracker (JobConf conf, Clock clock)
specifier|static
name|JobTracker
name|startTracker
parameter_list|(
name|JobConf
name|conf
parameter_list|,
name|Clock
name|clock
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
return|return
name|startTracker
argument_list|(
name|conf
argument_list|,
name|clock
argument_list|,
name|generateNewIdentifier
argument_list|()
argument_list|)
return|;
block|}
DECL|method|startTracker (JobConf conf, Clock clock, String identifier)
specifier|static
name|JobTracker
name|startTracker
parameter_list|(
name|JobConf
name|conf
parameter_list|,
name|Clock
name|clock
parameter_list|,
name|String
name|identifier
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|JobTracker
name|result
init|=
literal|null
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
try|try
block|{
name|result
operator|=
operator|new
name|JobTracker
argument_list|(
name|conf
argument_list|,
name|clock
argument_list|,
name|identifier
argument_list|)
expr_stmt|;
name|result
operator|.
name|taskScheduler
operator|.
name|setTaskTrackerManager
argument_list|(
name|result
argument_list|)
expr_stmt|;
break|break;
block|}
catch|catch
parameter_list|(
name|VersionMismatch
name|e
parameter_list|)
block|{
throw|throw
name|e
throw|;
block|}
catch|catch
parameter_list|(
name|BindException
name|e
parameter_list|)
block|{
throw|throw
name|e
throw|;
block|}
catch|catch
parameter_list|(
name|UnknownHostException
name|e
parameter_list|)
block|{
throw|throw
name|e
throw|;
block|}
catch|catch
parameter_list|(
name|AccessControlException
name|ace
parameter_list|)
block|{
comment|// in case of jobtracker not having right access
comment|// bail out
throw|throw
name|ace
throw|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Error starting tracker: "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Thread
operator|.
name|sleep
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|!=
literal|null
condition|)
block|{
name|JobEndNotifier
operator|.
name|startNotifier
argument_list|()
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
DECL|method|stopTracker ()
specifier|public
name|void
name|stopTracker
parameter_list|()
throws|throws
name|IOException
block|{
name|JobEndNotifier
operator|.
name|stopNotifier
argument_list|()
expr_stmt|;
name|close
argument_list|()
expr_stmt|;
block|}
DECL|method|getProtocolVersion (String protocol, long clientVersion)
specifier|public
name|long
name|getProtocolVersion
parameter_list|(
name|String
name|protocol
parameter_list|,
name|long
name|clientVersion
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|protocol
operator|.
name|equals
argument_list|(
name|InterTrackerProtocol
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|InterTrackerProtocol
operator|.
name|versionID
return|;
block|}
elseif|else
if|if
condition|(
name|protocol
operator|.
name|equals
argument_list|(
name|ClientProtocol
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|ClientProtocol
operator|.
name|versionID
return|;
block|}
elseif|else
if|if
condition|(
name|protocol
operator|.
name|equals
argument_list|(
name|RefreshAuthorizationPolicyProtocol
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|RefreshAuthorizationPolicyProtocol
operator|.
name|versionID
return|;
block|}
elseif|else
if|if
condition|(
name|protocol
operator|.
name|equals
argument_list|(
name|AdminOperationsProtocol
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|AdminOperationsProtocol
operator|.
name|versionID
return|;
block|}
elseif|else
if|if
condition|(
name|protocol
operator|.
name|equals
argument_list|(
name|RefreshUserMappingsProtocol
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|RefreshUserMappingsProtocol
operator|.
name|versionID
return|;
block|}
elseif|else
if|if
condition|(
name|protocol
operator|.
name|equals
argument_list|(
name|GetUserMappingsProtocol
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|GetUserMappingsProtocol
operator|.
name|versionID
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unknown protocol to job tracker: "
operator|+
name|protocol
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
DECL|method|getProtocolSignature (String protocol, long clientVersion, int clientMethodsHash)
specifier|public
name|ProtocolSignature
name|getProtocolSignature
parameter_list|(
name|String
name|protocol
parameter_list|,
name|long
name|clientVersion
parameter_list|,
name|int
name|clientMethodsHash
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|ProtocolSignature
operator|.
name|getProtocolSignature
argument_list|(
name|this
argument_list|,
name|protocol
argument_list|,
name|clientVersion
argument_list|,
name|clientMethodsHash
argument_list|)
return|;
block|}
comment|/**    * A thread to timeout tasks that have been assigned to task trackers,    * but that haven't reported back yet.    * Note that I included a stop() method, even though there is no place    * where JobTrackers are cleaned up.    */
DECL|class|ExpireLaunchingTasks
specifier|private
class|class
name|ExpireLaunchingTasks
implements|implements
name|Runnable
block|{
comment|/**      * This is a map of the tasks that have been assigned to task trackers,      * but that have not yet been seen in a status report.      * map: task-id -> time-assigned       */
DECL|field|launchingTasks
specifier|private
name|Map
argument_list|<
name|TaskAttemptID
argument_list|,
name|Long
argument_list|>
name|launchingTasks
init|=
operator|new
name|LinkedHashMap
argument_list|<
name|TaskAttemptID
argument_list|,
name|Long
argument_list|>
argument_list|()
decl_stmt|;
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
while|while
condition|(
literal|true
condition|)
block|{
try|try
block|{
comment|// Every 3 minutes check for any tasks that are overdue
name|Thread
operator|.
name|sleep
argument_list|(
name|tasktrackerExpiryInterval
operator|/
literal|3
argument_list|)
expr_stmt|;
name|long
name|now
init|=
name|clock
operator|.
name|getTime
argument_list|()
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Starting launching task sweep"
argument_list|)
expr_stmt|;
block|}
synchronized|synchronized
init|(
name|JobTracker
operator|.
name|this
init|)
block|{
synchronized|synchronized
init|(
name|launchingTasks
init|)
block|{
name|Iterator
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|TaskAttemptID
argument_list|,
name|Long
argument_list|>
argument_list|>
name|itr
init|=
name|launchingTasks
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|itr
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Map
operator|.
name|Entry
argument_list|<
name|TaskAttemptID
argument_list|,
name|Long
argument_list|>
name|pair
init|=
name|itr
operator|.
name|next
argument_list|()
decl_stmt|;
name|TaskAttemptID
name|taskId
init|=
name|pair
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|long
name|age
init|=
name|now
operator|-
operator|(
name|pair
operator|.
name|getValue
argument_list|()
operator|)
operator|.
name|longValue
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|taskId
operator|+
literal|" is "
operator|+
name|age
operator|+
literal|" ms debug."
argument_list|)
expr_stmt|;
if|if
condition|(
name|age
operator|>
name|tasktrackerExpiryInterval
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Launching task "
operator|+
name|taskId
operator|+
literal|" timed out."
argument_list|)
expr_stmt|;
name|TaskInProgress
name|tip
init|=
literal|null
decl_stmt|;
name|tip
operator|=
name|taskidToTIPMap
operator|.
name|get
argument_list|(
name|taskId
argument_list|)
expr_stmt|;
if|if
condition|(
name|tip
operator|!=
literal|null
condition|)
block|{
name|JobInProgress
name|job
init|=
name|tip
operator|.
name|getJob
argument_list|()
decl_stmt|;
name|String
name|trackerName
init|=
name|getAssignedTracker
argument_list|(
name|taskId
argument_list|)
decl_stmt|;
name|TaskTrackerStatus
name|trackerStatus
init|=
name|getTaskTrackerStatus
argument_list|(
name|trackerName
argument_list|)
decl_stmt|;
comment|// This might happen when the tasktracker has already
comment|// expired and this thread tries to call failedtask
comment|// again. expire tasktracker should have called failed
comment|// task!
if|if
condition|(
name|trackerStatus
operator|!=
literal|null
condition|)
name|job
operator|.
name|failedTask
argument_list|(
name|tip
argument_list|,
name|taskId
argument_list|,
literal|"Error launching task"
argument_list|,
name|tip
operator|.
name|isMapTask
argument_list|()
condition|?
name|TaskStatus
operator|.
name|Phase
operator|.
name|MAP
else|:
name|TaskStatus
operator|.
name|Phase
operator|.
name|STARTING
argument_list|,
name|TaskStatus
operator|.
name|State
operator|.
name|FAILED
argument_list|,
name|trackerName
argument_list|)
expr_stmt|;
block|}
name|itr
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// the tasks are sorted by start time, so once we find
comment|// one that we want to keep, we are done for this cycle.
break|break;
block|}
block|}
block|}
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
comment|// all done
break|break;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Expire Launching Task Thread got exception: "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|addNewTask (TaskAttemptID taskName)
specifier|public
name|void
name|addNewTask
parameter_list|(
name|TaskAttemptID
name|taskName
parameter_list|)
block|{
synchronized|synchronized
init|(
name|launchingTasks
init|)
block|{
name|launchingTasks
operator|.
name|put
argument_list|(
name|taskName
argument_list|,
name|clock
operator|.
name|getTime
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|removeTask (TaskAttemptID taskName)
specifier|public
name|void
name|removeTask
parameter_list|(
name|TaskAttemptID
name|taskName
parameter_list|)
block|{
synchronized|synchronized
init|(
name|launchingTasks
init|)
block|{
name|launchingTasks
operator|.
name|remove
argument_list|(
name|taskName
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|///////////////////////////////////////////////////////
comment|// Used to expire TaskTrackers that have gone down
comment|///////////////////////////////////////////////////////
DECL|class|ExpireTrackers
class|class
name|ExpireTrackers
implements|implements
name|Runnable
block|{
DECL|method|ExpireTrackers ()
specifier|public
name|ExpireTrackers
parameter_list|()
block|{     }
comment|/**      * The run method lives for the life of the JobTracker, and removes TaskTrackers      * that have not checked in for some time.      */
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
while|while
condition|(
literal|true
condition|)
block|{
try|try
block|{
comment|//
comment|// Thread runs periodically to check whether trackers should be expired.
comment|// The sleep interval must be no more than half the maximum expiry time
comment|// for a task tracker.
comment|//
name|Thread
operator|.
name|sleep
argument_list|(
name|tasktrackerExpiryInterval
operator|/
literal|3
argument_list|)
expr_stmt|;
name|checkExpiredTrackers
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|iex
parameter_list|)
block|{
break|break;
block|}
catch|catch
parameter_list|(
name|Exception
name|t
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Tracker Expiry Thread got exception: "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
DECL|method|checkExpiredTrackers ()
name|void
name|checkExpiredTrackers
parameter_list|()
block|{
comment|//
comment|// Loop through all expired items in the queue
comment|//
comment|// Need to lock the JobTracker here since we are
comment|// manipulating it's data-structures via
comment|// ExpireTrackers.run -> JobTracker.lostTaskTracker ->
comment|// JobInProgress.failedTask -> JobTracker.markCompleteTaskAttempt
comment|// Also need to lock JobTracker before locking 'taskTracker'&
comment|// 'trackerExpiryQueue' to prevent deadlock:
comment|// @see {@link JobTracker.processHeartbeat(TaskTrackerStatus, boolean)}
synchronized|synchronized
init|(
name|JobTracker
operator|.
name|this
init|)
block|{
synchronized|synchronized
init|(
name|taskTrackers
init|)
block|{
synchronized|synchronized
init|(
name|trackerExpiryQueue
init|)
block|{
name|long
name|now
init|=
name|clock
operator|.
name|getTime
argument_list|()
decl_stmt|;
name|TaskTrackerStatus
name|leastRecent
init|=
literal|null
decl_stmt|;
while|while
condition|(
operator|(
name|trackerExpiryQueue
operator|.
name|size
argument_list|()
operator|>
literal|0
operator|)
operator|&&
operator|(
name|leastRecent
operator|=
name|trackerExpiryQueue
operator|.
name|first
argument_list|()
operator|)
operator|!=
literal|null
operator|&&
operator|(
operator|(
name|now
operator|-
name|leastRecent
operator|.
name|getLastSeen
argument_list|()
operator|)
operator|>
name|tasktrackerExpiryInterval
operator|)
condition|)
block|{
comment|// Remove profile from head of queue
name|trackerExpiryQueue
operator|.
name|remove
argument_list|(
name|leastRecent
argument_list|)
expr_stmt|;
name|String
name|trackerName
init|=
name|leastRecent
operator|.
name|getTrackerName
argument_list|()
decl_stmt|;
comment|// Figure out if last-seen time should be updated, or if
comment|// tracker is dead
name|TaskTracker
name|current
init|=
name|getTaskTracker
argument_list|(
name|trackerName
argument_list|)
decl_stmt|;
name|TaskTrackerStatus
name|newProfile
init|=
operator|(
name|current
operator|==
literal|null
operator|)
condition|?
literal|null
else|:
name|current
operator|.
name|getStatus
argument_list|()
decl_stmt|;
comment|// Items might leave the taskTracker set through other means; the
comment|// status stored in 'taskTrackers' might be null, which means the
comment|// tracker has already been destroyed.
if|if
condition|(
name|newProfile
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
operator|(
name|now
operator|-
name|newProfile
operator|.
name|getLastSeen
argument_list|()
operator|)
operator|>
name|tasktrackerExpiryInterval
condition|)
block|{
comment|// Remove completely after marking the tasks as 'KILLED'
name|removeTracker
argument_list|(
name|current
argument_list|)
expr_stmt|;
comment|// remove the mapping from the hosts list
name|String
name|hostname
init|=
name|newProfile
operator|.
name|getHost
argument_list|()
decl_stmt|;
name|hostnameToTaskTracker
operator|.
name|get
argument_list|(
name|hostname
argument_list|)
operator|.
name|remove
argument_list|(
name|trackerName
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Update time by inserting latest profile
name|trackerExpiryQueue
operator|.
name|add
argument_list|(
name|newProfile
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
block|}
comment|// Assumes JobTracker, taskTrackers and trackerExpiryQueue are locked on entry
DECL|method|removeTracker (TaskTracker tracker)
specifier|private
name|void
name|removeTracker
parameter_list|(
name|TaskTracker
name|tracker
parameter_list|)
block|{
name|lostTaskTracker
argument_list|(
name|tracker
argument_list|)
expr_stmt|;
name|String
name|trackerName
init|=
name|tracker
operator|.
name|getStatus
argument_list|()
operator|.
name|getTrackerName
argument_list|()
decl_stmt|;
name|String
name|hostName
init|=
name|JobInProgress
operator|.
name|convertTrackerNameToHostName
argument_list|(
name|trackerName
argument_list|)
decl_stmt|;
comment|// tracker is lost, and if it is blacklisted, remove
comment|// it from the count of blacklisted trackers in the cluster
if|if
condition|(
name|isBlacklisted
argument_list|(
name|trackerName
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Removing "
operator|+
name|hostName
operator|+
literal|" from blacklist"
argument_list|)
expr_stmt|;
name|faultyTrackers
operator|.
name|decrBlackListedTrackers
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|updateTaskTrackerStatus
argument_list|(
name|trackerName
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|statistics
operator|.
name|taskTrackerRemoved
argument_list|(
name|trackerName
argument_list|)
expr_stmt|;
name|getInstrumentation
argument_list|()
operator|.
name|decTrackers
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
DECL|method|retireJob (JobID jobid, String historyFile)
specifier|public
specifier|synchronized
name|void
name|retireJob
parameter_list|(
name|JobID
name|jobid
parameter_list|,
name|String
name|historyFile
parameter_list|)
block|{
synchronized|synchronized
init|(
name|jobs
init|)
block|{
name|JobInProgress
name|job
init|=
name|jobs
operator|.
name|get
argument_list|(
name|jobid
argument_list|)
decl_stmt|;
if|if
condition|(
name|job
operator|!=
literal|null
condition|)
block|{
name|JobStatus
name|status
init|=
name|job
operator|.
name|getStatus
argument_list|()
decl_stmt|;
comment|//set the historyfile
if|if
condition|(
name|historyFile
operator|!=
literal|null
condition|)
block|{
name|status
operator|.
name|setHistoryFile
argument_list|(
name|historyFile
argument_list|)
expr_stmt|;
block|}
comment|// clean up job files from the local disk
name|job
operator|.
name|cleanupLocalizedJobConf
argument_list|(
name|job
operator|.
name|getProfile
argument_list|()
operator|.
name|getJobID
argument_list|()
argument_list|)
expr_stmt|;
comment|//this configuration is primarily for testing
comment|//test cases can set this to false to validate job data structures on
comment|//job completion
name|boolean
name|retireJob
init|=
name|conf
operator|.
name|getBoolean
argument_list|(
name|JT_RETIREJOBS
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|retireJob
condition|)
block|{
comment|//purge the job from memory
name|removeJobTasks
argument_list|(
name|job
argument_list|)
expr_stmt|;
name|jobs
operator|.
name|remove
argument_list|(
name|job
operator|.
name|getProfile
argument_list|()
operator|.
name|getJobID
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|JobInProgressListener
name|l
range|:
name|jobInProgressListeners
control|)
block|{
name|l
operator|.
name|jobRemoved
argument_list|(
name|job
argument_list|)
expr_stmt|;
block|}
name|String
name|jobUser
init|=
name|job
operator|.
name|getProfile
argument_list|()
operator|.
name|getUser
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Retired job with id: '"
operator|+
name|job
operator|.
name|getProfile
argument_list|()
operator|.
name|getJobID
argument_list|()
operator|+
literal|"' of user '"
operator|+
name|jobUser
operator|+
literal|"'"
argument_list|)
expr_stmt|;
comment|//add the job status to retired cache
name|retireJobs
operator|.
name|addToCache
argument_list|(
name|job
operator|.
name|getStatus
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|///////////////////////////////////////////////////////
comment|// Used to remove old finished Jobs that have been around for too long
comment|///////////////////////////////////////////////////////
DECL|class|RetireJobs
class|class
name|RetireJobs
block|{
DECL|field|jobIDStatusMap
specifier|private
specifier|final
name|Map
argument_list|<
name|JobID
argument_list|,
name|JobStatus
argument_list|>
name|jobIDStatusMap
init|=
operator|new
name|HashMap
argument_list|<
name|JobID
argument_list|,
name|JobStatus
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|jobStatusQ
specifier|private
specifier|final
name|LinkedList
argument_list|<
name|JobStatus
argument_list|>
name|jobStatusQ
init|=
operator|new
name|LinkedList
argument_list|<
name|JobStatus
argument_list|>
argument_list|()
decl_stmt|;
DECL|method|RetireJobs ()
specifier|public
name|RetireJobs
parameter_list|()
block|{     }
DECL|method|addToCache (JobStatus status)
specifier|synchronized
name|void
name|addToCache
parameter_list|(
name|JobStatus
name|status
parameter_list|)
block|{
name|status
operator|.
name|setRetired
argument_list|()
expr_stmt|;
name|jobStatusQ
operator|.
name|add
argument_list|(
name|status
argument_list|)
expr_stmt|;
name|jobIDStatusMap
operator|.
name|put
argument_list|(
name|status
operator|.
name|getJobID
argument_list|()
argument_list|,
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|jobStatusQ
operator|.
name|size
argument_list|()
operator|>
name|retiredJobsCacheSize
condition|)
block|{
name|JobStatus
name|removed
init|=
name|jobStatusQ
operator|.
name|remove
argument_list|()
decl_stmt|;
name|jobIDStatusMap
operator|.
name|remove
argument_list|(
name|removed
operator|.
name|getJobID
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Retired job removed from cache "
operator|+
name|removed
operator|.
name|getJobID
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|get (JobID jobId)
specifier|synchronized
name|JobStatus
name|get
parameter_list|(
name|JobID
name|jobId
parameter_list|)
block|{
return|return
name|jobIDStatusMap
operator|.
name|get
argument_list|(
name|jobId
argument_list|)
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|getAll ()
specifier|synchronized
name|LinkedList
argument_list|<
name|JobStatus
argument_list|>
name|getAll
parameter_list|()
block|{
return|return
operator|(
name|LinkedList
argument_list|<
name|JobStatus
argument_list|>
operator|)
name|jobStatusQ
operator|.
name|clone
argument_list|()
return|;
block|}
block|}
DECL|enum|ReasonForBlackListing
enum|enum
name|ReasonForBlackListing
block|{
DECL|enumConstant|EXCEEDING_FAILURES
name|EXCEEDING_FAILURES
block|,
DECL|enumConstant|NODE_UNHEALTHY
name|NODE_UNHEALTHY
block|}
comment|// The FaultInfo which indicates the number of faults of a tracker
comment|// and when the last fault occurred
comment|// and whether the tracker is blacklisted across all jobs or not
DECL|class|FaultInfo
specifier|private
specifier|static
class|class
name|FaultInfo
block|{
DECL|field|FAULT_FORMAT_STRING
specifier|static
specifier|final
name|String
name|FAULT_FORMAT_STRING
init|=
literal|"%d failures on the tracker"
decl_stmt|;
DECL|field|numFaults
name|int
name|numFaults
init|=
literal|0
decl_stmt|;
DECL|field|lastUpdated
name|long
name|lastUpdated
decl_stmt|;
DECL|field|blacklisted
name|boolean
name|blacklisted
decl_stmt|;
DECL|field|isHealthy
specifier|private
name|boolean
name|isHealthy
decl_stmt|;
DECL|field|rfbMap
specifier|private
name|HashMap
argument_list|<
name|ReasonForBlackListing
argument_list|,
name|String
argument_list|>
name|rfbMap
decl_stmt|;
DECL|method|FaultInfo (long time)
name|FaultInfo
parameter_list|(
name|long
name|time
parameter_list|)
block|{
name|numFaults
operator|=
literal|0
expr_stmt|;
name|lastUpdated
operator|=
name|time
expr_stmt|;
name|blacklisted
operator|=
literal|false
expr_stmt|;
name|rfbMap
operator|=
operator|new
name|HashMap
argument_list|<
name|ReasonForBlackListing
argument_list|,
name|String
argument_list|>
argument_list|()
expr_stmt|;
block|}
DECL|method|setFaultCount (int num)
name|void
name|setFaultCount
parameter_list|(
name|int
name|num
parameter_list|)
block|{
name|numFaults
operator|=
name|num
expr_stmt|;
block|}
DECL|method|setLastUpdated (long timeStamp)
name|void
name|setLastUpdated
parameter_list|(
name|long
name|timeStamp
parameter_list|)
block|{
name|lastUpdated
operator|=
name|timeStamp
expr_stmt|;
block|}
DECL|method|getFaultCount ()
name|int
name|getFaultCount
parameter_list|()
block|{
return|return
name|numFaults
return|;
block|}
DECL|method|getLastUpdated ()
name|long
name|getLastUpdated
parameter_list|()
block|{
return|return
name|lastUpdated
return|;
block|}
DECL|method|isBlacklisted ()
name|boolean
name|isBlacklisted
parameter_list|()
block|{
return|return
name|blacklisted
return|;
block|}
DECL|method|setBlacklist (ReasonForBlackListing rfb, String trackerFaultReport)
name|void
name|setBlacklist
parameter_list|(
name|ReasonForBlackListing
name|rfb
parameter_list|,
name|String
name|trackerFaultReport
parameter_list|)
block|{
name|blacklisted
operator|=
literal|true
expr_stmt|;
name|this
operator|.
name|rfbMap
operator|.
name|put
argument_list|(
name|rfb
argument_list|,
name|trackerFaultReport
argument_list|)
expr_stmt|;
block|}
DECL|method|setHealthy (boolean isHealthy)
specifier|public
name|void
name|setHealthy
parameter_list|(
name|boolean
name|isHealthy
parameter_list|)
block|{
name|this
operator|.
name|isHealthy
operator|=
name|isHealthy
expr_stmt|;
block|}
DECL|method|isHealthy ()
specifier|public
name|boolean
name|isHealthy
parameter_list|()
block|{
return|return
name|isHealthy
return|;
block|}
DECL|method|getTrackerFaultReport ()
specifier|public
name|String
name|getTrackerFaultReport
parameter_list|()
block|{
name|StringBuffer
name|sb
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|reasons
range|:
name|rfbMap
operator|.
name|values
argument_list|()
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|reasons
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sb
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|sb
operator|.
name|replace
argument_list|(
name|sb
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|,
name|sb
operator|.
name|length
argument_list|()
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
DECL|method|getReasonforblacklisting ()
name|Set
argument_list|<
name|ReasonForBlackListing
argument_list|>
name|getReasonforblacklisting
parameter_list|()
block|{
return|return
name|this
operator|.
name|rfbMap
operator|.
name|keySet
argument_list|()
return|;
block|}
DECL|method|unBlacklist ()
specifier|public
name|void
name|unBlacklist
parameter_list|()
block|{
name|this
operator|.
name|blacklisted
operator|=
literal|false
expr_stmt|;
name|this
operator|.
name|rfbMap
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
DECL|method|removeBlackListedReason (ReasonForBlackListing rfb)
specifier|public
name|boolean
name|removeBlackListedReason
parameter_list|(
name|ReasonForBlackListing
name|rfb
parameter_list|)
block|{
name|String
name|str
init|=
name|rfbMap
operator|.
name|remove
argument_list|(
name|rfb
argument_list|)
decl_stmt|;
return|return
name|str
operator|!=
literal|null
return|;
block|}
DECL|method|addBlackListedReason (ReasonForBlackListing rfb, String reason)
specifier|public
name|void
name|addBlackListedReason
parameter_list|(
name|ReasonForBlackListing
name|rfb
parameter_list|,
name|String
name|reason
parameter_list|)
block|{
name|this
operator|.
name|rfbMap
operator|.
name|put
argument_list|(
name|rfb
argument_list|,
name|reason
argument_list|)
expr_stmt|;
block|}
block|}
DECL|class|FaultyTrackersInfo
specifier|private
class|class
name|FaultyTrackersInfo
block|{
comment|// A map from hostName to its faults
DECL|field|potentiallyFaultyTrackers
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|FaultInfo
argument_list|>
name|potentiallyFaultyTrackers
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|FaultInfo
argument_list|>
argument_list|()
decl_stmt|;
comment|// This count gives the number of blacklisted trackers in the cluster
comment|// at any time. This is maintained to avoid iteration over
comment|// the potentiallyFaultyTrackers to get blacklisted trackers. And also
comment|// this count doesn't include blacklisted trackers which are lost,
comment|// although the fault info is maintained for lost trackers.
DECL|field|numBlacklistedTrackers
specifier|private
specifier|volatile
name|int
name|numBlacklistedTrackers
init|=
literal|0
decl_stmt|;
comment|/**      * Increments faults(blacklist by job) for the tracker by one.      *       * Adds the tracker to the potentially faulty list.       * Assumes JobTracker is locked on the entry.      *       * @param hostName       */
DECL|method|incrementFaults (String hostName)
name|void
name|incrementFaults
parameter_list|(
name|String
name|hostName
parameter_list|)
block|{
synchronized|synchronized
init|(
name|potentiallyFaultyTrackers
init|)
block|{
name|FaultInfo
name|fi
init|=
name|getFaultInfo
argument_list|(
name|hostName
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|long
name|now
init|=
name|clock
operator|.
name|getTime
argument_list|()
decl_stmt|;
name|int
name|numFaults
init|=
name|fi
operator|.
name|getFaultCount
argument_list|()
decl_stmt|;
operator|++
name|numFaults
expr_stmt|;
name|fi
operator|.
name|setFaultCount
argument_list|(
name|numFaults
argument_list|)
expr_stmt|;
name|fi
operator|.
name|setLastUpdated
argument_list|(
name|now
argument_list|)
expr_stmt|;
if|if
condition|(
name|exceedsFaults
argument_list|(
name|fi
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Adding "
operator|+
name|hostName
operator|+
literal|" to the blacklist"
operator|+
literal|" across all jobs"
argument_list|)
expr_stmt|;
name|String
name|reason
init|=
name|String
operator|.
name|format
argument_list|(
name|FaultInfo
operator|.
name|FAULT_FORMAT_STRING
argument_list|,
name|numFaults
argument_list|)
decl_stmt|;
name|blackListTracker
argument_list|(
name|hostName
argument_list|,
name|reason
argument_list|,
name|ReasonForBlackListing
operator|.
name|EXCEEDING_FAILURES
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|incrBlackListedTrackers (int count)
specifier|private
name|void
name|incrBlackListedTrackers
parameter_list|(
name|int
name|count
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Incrementing blacklisted trackers by "
operator|+
name|count
argument_list|)
expr_stmt|;
name|numBlacklistedTrackers
operator|+=
name|count
expr_stmt|;
name|getInstrumentation
argument_list|()
operator|.
name|addBlackListedTrackers
argument_list|(
name|count
argument_list|)
expr_stmt|;
block|}
DECL|method|decrBlackListedTrackers (int count)
specifier|private
name|void
name|decrBlackListedTrackers
parameter_list|(
name|int
name|count
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Decrementing blacklisted trackers by "
operator|+
name|count
argument_list|)
expr_stmt|;
name|numBlacklistedTrackers
operator|-=
name|count
expr_stmt|;
name|getInstrumentation
argument_list|()
operator|.
name|decBlackListedTrackers
argument_list|(
name|count
argument_list|)
expr_stmt|;
block|}
DECL|method|blackListTracker (String hostName, String reason, ReasonForBlackListing rfb)
specifier|private
name|void
name|blackListTracker
parameter_list|(
name|String
name|hostName
parameter_list|,
name|String
name|reason
parameter_list|,
name|ReasonForBlackListing
name|rfb
parameter_list|)
block|{
name|FaultInfo
name|fi
init|=
name|getFaultInfo
argument_list|(
name|hostName
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|boolean
name|blackListed
init|=
name|fi
operator|.
name|isBlacklisted
argument_list|()
decl_stmt|;
if|if
condition|(
name|blackListed
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Adding blacklisted reason for tracker : "
operator|+
name|hostName
operator|+
literal|" Reason for blacklisting is : "
operator|+
name|rfb
operator|+
literal|" Reason details : "
operator|+
name|reason
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|fi
operator|.
name|getReasonforblacklisting
argument_list|()
operator|.
name|contains
argument_list|(
name|rfb
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Adding blacklisted reason for tracker : "
operator|+
name|hostName
operator|+
literal|" Reason for blacklisting is : "
operator|+
name|rfb
operator|+
literal|" Reason details : "
operator|+
name|reason
argument_list|)
expr_stmt|;
block|}
name|fi
operator|.
name|addBlackListedReason
argument_list|(
name|rfb
argument_list|,
name|reason
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Blacklisting tracker : "
operator|+
name|hostName
operator|+
literal|" Reason for blacklisting is : "
operator|+
name|rfb
operator|+
literal|" Reason details : "
operator|+
name|reason
argument_list|)
expr_stmt|;
name|Set
argument_list|<
name|TaskTracker
argument_list|>
name|trackers
init|=
name|hostnameToTaskTracker
operator|.
name|get
argument_list|(
name|hostName
argument_list|)
decl_stmt|;
synchronized|synchronized
init|(
name|trackers
init|)
block|{
for|for
control|(
name|TaskTracker
name|tracker
range|:
name|trackers
control|)
block|{
name|tracker
operator|.
name|cancelAllReservations
argument_list|()
expr_stmt|;
block|}
block|}
name|removeHostCapacity
argument_list|(
name|hostName
argument_list|)
expr_stmt|;
name|fi
operator|.
name|setBlacklist
argument_list|(
name|rfb
argument_list|,
name|reason
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|canUnBlackListTracker (String hostName, ReasonForBlackListing rfb)
specifier|private
name|boolean
name|canUnBlackListTracker
parameter_list|(
name|String
name|hostName
parameter_list|,
name|ReasonForBlackListing
name|rfb
parameter_list|)
block|{
name|FaultInfo
name|fi
init|=
name|getFaultInfo
argument_list|(
name|hostName
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|fi
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
name|Set
argument_list|<
name|ReasonForBlackListing
argument_list|>
name|rfbSet
init|=
name|fi
operator|.
name|getReasonforblacklisting
argument_list|()
decl_stmt|;
return|return
name|fi
operator|.
name|isBlacklisted
argument_list|()
operator|&&
name|rfbSet
operator|.
name|contains
argument_list|(
name|rfb
argument_list|)
return|;
block|}
DECL|method|unBlackListTracker (String hostName, ReasonForBlackListing rfb)
specifier|private
name|void
name|unBlackListTracker
parameter_list|(
name|String
name|hostName
parameter_list|,
name|ReasonForBlackListing
name|rfb
parameter_list|)
block|{
comment|// check if you can black list the tracker then call this methods
name|FaultInfo
name|fi
init|=
name|getFaultInfo
argument_list|(
name|hostName
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|fi
operator|.
name|removeBlackListedReason
argument_list|(
name|rfb
argument_list|)
condition|)
block|{
if|if
condition|(
name|fi
operator|.
name|getReasonforblacklisting
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Unblacklisting tracker : "
operator|+
name|hostName
argument_list|)
expr_stmt|;
name|addHostCapacity
argument_list|(
name|hostName
argument_list|)
expr_stmt|;
name|fi
operator|.
name|unBlacklist
argument_list|()
expr_stmt|;
comment|//We have unBlackListed tracker, so tracker should
comment|//definitely be healthy. Check fault count if fault count
comment|//is zero don't keep it memory.
if|if
condition|(
name|fi
operator|.
name|numFaults
operator|==
literal|0
condition|)
block|{
name|potentiallyFaultyTrackers
operator|.
name|remove
argument_list|(
name|hostName
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|// Assumes JobTracker is locked on entry.
DECL|method|getFaultInfo (String hostName, boolean createIfNeccessary)
specifier|private
name|FaultInfo
name|getFaultInfo
parameter_list|(
name|String
name|hostName
parameter_list|,
name|boolean
name|createIfNeccessary
parameter_list|)
block|{
name|FaultInfo
name|fi
init|=
literal|null
decl_stmt|;
synchronized|synchronized
init|(
name|potentiallyFaultyTrackers
init|)
block|{
name|fi
operator|=
name|potentiallyFaultyTrackers
operator|.
name|get
argument_list|(
name|hostName
argument_list|)
expr_stmt|;
name|long
name|now
init|=
name|clock
operator|.
name|getTime
argument_list|()
decl_stmt|;
if|if
condition|(
name|fi
operator|==
literal|null
operator|&&
name|createIfNeccessary
condition|)
block|{
name|fi
operator|=
operator|new
name|FaultInfo
argument_list|(
name|now
argument_list|)
expr_stmt|;
name|potentiallyFaultyTrackers
operator|.
name|put
argument_list|(
name|hostName
argument_list|,
name|fi
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|fi
return|;
block|}
comment|/**      * Blacklists the tracker across all jobs if      *<ol>      *<li>#faults are more than       *     MAX_BLACKLISTS_PER_TRACKER (configurable) blacklists</li>      *<li>#faults is 50% (configurable) above the average #faults</li>      *<li>50% the cluster is not blacklisted yet</li>      *</ol>      */
DECL|method|exceedsFaults (FaultInfo fi)
specifier|private
name|boolean
name|exceedsFaults
parameter_list|(
name|FaultInfo
name|fi
parameter_list|)
block|{
name|int
name|faultCount
init|=
name|fi
operator|.
name|getFaultCount
argument_list|()
decl_stmt|;
if|if
condition|(
name|faultCount
operator|>=
name|MAX_BLACKLISTS_PER_TRACKER
condition|)
block|{
comment|// calculate avgBlackLists
name|long
name|clusterSize
init|=
name|getClusterStatus
argument_list|()
operator|.
name|getTaskTrackers
argument_list|()
decl_stmt|;
name|long
name|sum
init|=
literal|0
decl_stmt|;
for|for
control|(
name|FaultInfo
name|f
range|:
name|potentiallyFaultyTrackers
operator|.
name|values
argument_list|()
control|)
block|{
name|sum
operator|+=
name|f
operator|.
name|getFaultCount
argument_list|()
expr_stmt|;
block|}
name|double
name|avg
init|=
operator|(
name|double
operator|)
name|sum
operator|/
name|clusterSize
decl_stmt|;
name|long
name|totalCluster
init|=
name|clusterSize
operator|+
name|numBlacklistedTrackers
decl_stmt|;
if|if
condition|(
operator|(
name|faultCount
operator|-
name|avg
operator|)
operator|>
operator|(
name|AVERAGE_BLACKLIST_THRESHOLD
operator|*
name|avg
operator|)
operator|&&
name|numBlacklistedTrackers
operator|<
operator|(
name|totalCluster
operator|*
name|MAX_BLACKLIST_PERCENT
operator|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/**      * Removes the tracker from blacklist and      * from potentially faulty list, when it is restarted.      *       * Assumes JobTracker is locked on the entry.      *       * @param hostName      */
DECL|method|markTrackerHealthy (String hostName)
name|void
name|markTrackerHealthy
parameter_list|(
name|String
name|hostName
parameter_list|)
block|{
synchronized|synchronized
init|(
name|potentiallyFaultyTrackers
init|)
block|{
name|FaultInfo
name|fi
init|=
name|potentiallyFaultyTrackers
operator|.
name|remove
argument_list|(
name|hostName
argument_list|)
decl_stmt|;
if|if
condition|(
name|fi
operator|!=
literal|null
operator|&&
name|fi
operator|.
name|isBlacklisted
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Marking "
operator|+
name|hostName
operator|+
literal|" healthy from blacklist"
argument_list|)
expr_stmt|;
name|addHostCapacity
argument_list|(
name|hostName
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Check whether tasks can be assigned to the tracker.      *      * One fault of the tracker is discarded if there      * are no faults during one day. So, the tracker will get a       * chance again to run tasks of a job.      * Assumes JobTracker is locked on the entry.      *       * @param hostName The tracker name      * @param now The current time      *       * @return true if the tracker is blacklisted       *         false otherwise      */
DECL|method|shouldAssignTasksToTracker (String hostName, long now)
name|boolean
name|shouldAssignTasksToTracker
parameter_list|(
name|String
name|hostName
parameter_list|,
name|long
name|now
parameter_list|)
block|{
synchronized|synchronized
init|(
name|potentiallyFaultyTrackers
init|)
block|{
name|FaultInfo
name|fi
init|=
name|potentiallyFaultyTrackers
operator|.
name|get
argument_list|(
name|hostName
argument_list|)
decl_stmt|;
if|if
condition|(
name|fi
operator|!=
literal|null
operator|&&
operator|(
name|now
operator|-
name|fi
operator|.
name|getLastUpdated
argument_list|()
operator|)
operator|>
name|UPDATE_FAULTY_TRACKER_INTERVAL
condition|)
block|{
name|int
name|numFaults
init|=
name|fi
operator|.
name|getFaultCount
argument_list|()
operator|-
literal|1
decl_stmt|;
name|fi
operator|.
name|setFaultCount
argument_list|(
name|numFaults
argument_list|)
expr_stmt|;
name|fi
operator|.
name|setLastUpdated
argument_list|(
name|now
argument_list|)
expr_stmt|;
if|if
condition|(
name|canUnBlackListTracker
argument_list|(
name|hostName
argument_list|,
name|ReasonForBlackListing
operator|.
name|EXCEEDING_FAILURES
argument_list|)
condition|)
block|{
name|unBlackListTracker
argument_list|(
name|hostName
argument_list|,
name|ReasonForBlackListing
operator|.
name|EXCEEDING_FAILURES
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|fi
operator|!=
literal|null
operator|&&
name|fi
operator|.
name|isBlacklisted
argument_list|()
operator|)
return|;
block|}
block|}
DECL|method|removeHostCapacity (String hostName)
specifier|private
name|void
name|removeHostCapacity
parameter_list|(
name|String
name|hostName
parameter_list|)
block|{
synchronized|synchronized
init|(
name|taskTrackers
init|)
block|{
comment|// remove the capacity of trackers on this host
name|int
name|numTrackersOnHost
init|=
literal|0
decl_stmt|;
for|for
control|(
name|TaskTrackerStatus
name|status
range|:
name|getStatusesOnHost
argument_list|(
name|hostName
argument_list|)
control|)
block|{
name|int
name|mapSlots
init|=
name|status
operator|.
name|getMaxMapSlots
argument_list|()
decl_stmt|;
name|totalMapTaskCapacity
operator|-=
name|mapSlots
expr_stmt|;
name|int
name|reduceSlots
init|=
name|status
operator|.
name|getMaxReduceSlots
argument_list|()
decl_stmt|;
name|totalReduceTaskCapacity
operator|-=
name|reduceSlots
expr_stmt|;
operator|++
name|numTrackersOnHost
expr_stmt|;
name|getInstrumentation
argument_list|()
operator|.
name|addBlackListedMapSlots
argument_list|(
name|mapSlots
argument_list|)
expr_stmt|;
name|getInstrumentation
argument_list|()
operator|.
name|addBlackListedReduceSlots
argument_list|(
name|reduceSlots
argument_list|)
expr_stmt|;
block|}
comment|// remove the host
name|uniqueHostsMap
operator|.
name|remove
argument_list|(
name|hostName
argument_list|)
expr_stmt|;
name|incrBlackListedTrackers
argument_list|(
name|numTrackersOnHost
argument_list|)
expr_stmt|;
block|}
block|}
comment|// This is called on tracker's restart or after a day of blacklist.
DECL|method|addHostCapacity (String hostName)
specifier|private
name|void
name|addHostCapacity
parameter_list|(
name|String
name|hostName
parameter_list|)
block|{
synchronized|synchronized
init|(
name|taskTrackers
init|)
block|{
name|int
name|numTrackersOnHost
init|=
literal|0
decl_stmt|;
comment|// add the capacity of trackers on the host
for|for
control|(
name|TaskTrackerStatus
name|status
range|:
name|getStatusesOnHost
argument_list|(
name|hostName
argument_list|)
control|)
block|{
name|int
name|mapSlots
init|=
name|status
operator|.
name|getMaxMapSlots
argument_list|()
decl_stmt|;
name|totalMapTaskCapacity
operator|+=
name|mapSlots
expr_stmt|;
name|int
name|reduceSlots
init|=
name|status
operator|.
name|getMaxReduceSlots
argument_list|()
decl_stmt|;
name|totalReduceTaskCapacity
operator|+=
name|reduceSlots
expr_stmt|;
name|numTrackersOnHost
operator|++
expr_stmt|;
name|getInstrumentation
argument_list|()
operator|.
name|decBlackListedMapSlots
argument_list|(
name|mapSlots
argument_list|)
expr_stmt|;
name|getInstrumentation
argument_list|()
operator|.
name|decBlackListedReduceSlots
argument_list|(
name|reduceSlots
argument_list|)
expr_stmt|;
block|}
name|uniqueHostsMap
operator|.
name|put
argument_list|(
name|hostName
argument_list|,
name|numTrackersOnHost
argument_list|)
expr_stmt|;
name|decrBlackListedTrackers
argument_list|(
name|numTrackersOnHost
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Whether a host is blacklisted across all the jobs.       *       * Assumes JobTracker is locked on the entry.      * @param hostName      * @return      */
DECL|method|isBlacklisted (String hostName)
name|boolean
name|isBlacklisted
parameter_list|(
name|String
name|hostName
parameter_list|)
block|{
synchronized|synchronized
init|(
name|potentiallyFaultyTrackers
init|)
block|{
name|FaultInfo
name|fi
init|=
literal|null
decl_stmt|;
if|if
condition|(
operator|(
name|fi
operator|=
name|potentiallyFaultyTrackers
operator|.
name|get
argument_list|(
name|hostName
argument_list|)
operator|)
operator|!=
literal|null
condition|)
block|{
return|return
name|fi
operator|.
name|isBlacklisted
argument_list|()
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|// Assumes JobTracker is locked on the entry.
DECL|method|getFaultCount (String hostName)
name|int
name|getFaultCount
parameter_list|(
name|String
name|hostName
parameter_list|)
block|{
synchronized|synchronized
init|(
name|potentiallyFaultyTrackers
init|)
block|{
name|FaultInfo
name|fi
init|=
literal|null
decl_stmt|;
if|if
condition|(
operator|(
name|fi
operator|=
name|potentiallyFaultyTrackers
operator|.
name|get
argument_list|(
name|hostName
argument_list|)
operator|)
operator|!=
literal|null
condition|)
block|{
return|return
name|fi
operator|.
name|getFaultCount
argument_list|()
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
comment|// Assumes JobTracker is locked on the entry.
DECL|method|getReasonForBlackListing (String hostName)
name|Set
argument_list|<
name|ReasonForBlackListing
argument_list|>
name|getReasonForBlackListing
parameter_list|(
name|String
name|hostName
parameter_list|)
block|{
synchronized|synchronized
init|(
name|potentiallyFaultyTrackers
init|)
block|{
name|FaultInfo
name|fi
init|=
literal|null
decl_stmt|;
if|if
condition|(
operator|(
name|fi
operator|=
name|potentiallyFaultyTrackers
operator|.
name|get
argument_list|(
name|hostName
argument_list|)
operator|)
operator|!=
literal|null
condition|)
block|{
return|return
name|fi
operator|.
name|getReasonforblacklisting
argument_list|()
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
comment|// Assumes JobTracker is locked on the entry.
DECL|method|setNodeHealthStatus (String hostName, boolean isHealthy, String reason)
name|void
name|setNodeHealthStatus
parameter_list|(
name|String
name|hostName
parameter_list|,
name|boolean
name|isHealthy
parameter_list|,
name|String
name|reason
parameter_list|)
block|{
name|FaultInfo
name|fi
init|=
literal|null
decl_stmt|;
comment|// If tracker is not healthy, create a fault info object
comment|// blacklist it.
if|if
condition|(
operator|!
name|isHealthy
condition|)
block|{
name|fi
operator|=
name|getFaultInfo
argument_list|(
name|hostName
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|fi
operator|.
name|setHealthy
argument_list|(
name|isHealthy
argument_list|)
expr_stmt|;
name|updateNodeHealthFailureStatistics
argument_list|(
name|hostName
argument_list|,
name|fi
argument_list|)
expr_stmt|;
synchronized|synchronized
init|(
name|potentiallyFaultyTrackers
init|)
block|{
name|blackListTracker
argument_list|(
name|hostName
argument_list|,
name|reason
argument_list|,
name|ReasonForBlackListing
operator|.
name|NODE_UNHEALTHY
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|fi
operator|=
name|getFaultInfo
argument_list|(
name|hostName
argument_list|,
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|fi
operator|==
literal|null
condition|)
block|{
return|return;
block|}
else|else
block|{
if|if
condition|(
name|canUnBlackListTracker
argument_list|(
name|hostName
argument_list|,
name|ReasonForBlackListing
operator|.
name|NODE_UNHEALTHY
argument_list|)
condition|)
block|{
name|unBlackListTracker
argument_list|(
name|hostName
argument_list|,
name|ReasonForBlackListing
operator|.
name|NODE_UNHEALTHY
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**      * Update the node health failure statistics of the given      * host.      *       * We increment the count only when the host transitions      * from healthy -> unhealthy.       *       * @param hostName      * @param fi Fault info object for the host.      */
DECL|method|updateNodeHealthFailureStatistics (String hostName, FaultInfo fi)
specifier|private
name|void
name|updateNodeHealthFailureStatistics
parameter_list|(
name|String
name|hostName
parameter_list|,
name|FaultInfo
name|fi
parameter_list|)
block|{
comment|//Check if the node was already blacklisted due to
comment|//unhealthy reason. If so dont increment the count.
if|if
condition|(
operator|!
name|fi
operator|.
name|getReasonforblacklisting
argument_list|()
operator|.
name|contains
argument_list|(
name|ReasonForBlackListing
operator|.
name|NODE_UNHEALTHY
argument_list|)
condition|)
block|{
name|Set
argument_list|<
name|TaskTracker
argument_list|>
name|trackers
init|=
name|hostnameToTaskTracker
operator|.
name|get
argument_list|(
name|hostName
argument_list|)
decl_stmt|;
synchronized|synchronized
init|(
name|trackers
init|)
block|{
for|for
control|(
name|TaskTracker
name|t
range|:
name|trackers
control|)
block|{
name|TaskTrackerStat
name|stat
init|=
name|statistics
operator|.
name|getTaskTrackerStat
argument_list|(
name|t
operator|.
name|getTrackerName
argument_list|()
argument_list|)
decl_stmt|;
name|stat
operator|.
name|incrHealthCheckFailed
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
comment|/**    * Get all task tracker statuses on given host    *     * Assumes JobTracker is locked on the entry    * @param hostName    * @return {@link java.util.List} of {@link TaskTrackerStatus}    */
DECL|method|getStatusesOnHost (String hostName)
specifier|private
name|List
argument_list|<
name|TaskTrackerStatus
argument_list|>
name|getStatusesOnHost
parameter_list|(
name|String
name|hostName
parameter_list|)
block|{
name|List
argument_list|<
name|TaskTrackerStatus
argument_list|>
name|statuses
init|=
operator|new
name|ArrayList
argument_list|<
name|TaskTrackerStatus
argument_list|>
argument_list|()
decl_stmt|;
synchronized|synchronized
init|(
name|taskTrackers
init|)
block|{
for|for
control|(
name|TaskTracker
name|tt
range|:
name|taskTrackers
operator|.
name|values
argument_list|()
control|)
block|{
name|TaskTrackerStatus
name|status
init|=
name|tt
operator|.
name|getStatus
argument_list|()
decl_stmt|;
if|if
condition|(
name|hostName
operator|.
name|equals
argument_list|(
name|status
operator|.
name|getHost
argument_list|()
argument_list|)
condition|)
block|{
name|statuses
operator|.
name|add
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|statuses
return|;
block|}
comment|///////////////////////////////////////////////////////
comment|// Used to recover the jobs upon restart
comment|///////////////////////////////////////////////////////
DECL|class|RecoveryManager
class|class
name|RecoveryManager
block|{
DECL|field|jobsToRecover
specifier|private
name|Set
argument_list|<
name|JobID
argument_list|>
name|jobsToRecover
decl_stmt|;
comment|// set of jobs to be recovered
DECL|field|recovered
specifier|private
name|int
name|recovered
decl_stmt|;
DECL|field|restartCount
specifier|private
name|int
name|restartCount
init|=
literal|0
decl_stmt|;
DECL|field|shouldRecover
specifier|private
name|boolean
name|shouldRecover
init|=
literal|false
decl_stmt|;
DECL|method|RecoveryManager ()
specifier|public
name|RecoveryManager
parameter_list|()
block|{
name|jobsToRecover
operator|=
operator|new
name|TreeSet
argument_list|<
name|JobID
argument_list|>
argument_list|()
expr_stmt|;
block|}
DECL|method|contains (JobID id)
specifier|public
name|boolean
name|contains
parameter_list|(
name|JobID
name|id
parameter_list|)
block|{
return|return
name|jobsToRecover
operator|.
name|contains
argument_list|(
name|id
argument_list|)
return|;
block|}
DECL|method|getRecovered ()
name|int
name|getRecovered
parameter_list|()
block|{
return|return
name|recovered
return|;
block|}
DECL|method|addJobForRecovery (JobID id)
name|void
name|addJobForRecovery
parameter_list|(
name|JobID
name|id
parameter_list|)
block|{
name|jobsToRecover
operator|.
name|add
argument_list|(
name|id
argument_list|)
expr_stmt|;
block|}
DECL|method|shouldRecover ()
specifier|public
name|boolean
name|shouldRecover
parameter_list|()
block|{
return|return
name|shouldRecover
return|;
block|}
DECL|method|getJobsToRecover ()
name|Set
argument_list|<
name|JobID
argument_list|>
name|getJobsToRecover
parameter_list|()
block|{
return|return
name|jobsToRecover
return|;
block|}
comment|// add the job
DECL|method|addJobForRecovery (FileStatus status)
name|void
name|addJobForRecovery
parameter_list|(
name|FileStatus
name|status
parameter_list|)
throws|throws
name|IOException
block|{
name|recoveryManager
operator|.
name|addJobForRecovery
argument_list|(
name|JobID
operator|.
name|forName
argument_list|(
name|status
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|shouldRecover
operator|=
literal|true
expr_stmt|;
comment|// enable actual recovery if num-files> 1
block|}
DECL|method|getRestartCountFile ()
name|Path
name|getRestartCountFile
parameter_list|()
block|{
return|return
operator|new
name|Path
argument_list|(
name|getSystemDir
argument_list|()
argument_list|,
literal|"jobtracker.info"
argument_list|)
return|;
block|}
DECL|method|getTempRestartCountFile ()
name|Path
name|getTempRestartCountFile
parameter_list|()
block|{
return|return
operator|new
name|Path
argument_list|(
name|getSystemDir
argument_list|()
argument_list|,
literal|"jobtracker.info.recover"
argument_list|)
return|;
block|}
comment|/**      * Initialize the recovery process. It simply creates a jobtracker.info file      * in the jobtracker's system directory and writes its restart count in it.      * For the first start, the jobtracker writes '0' in it. Upon subsequent       * restarts the jobtracker replaces the count with its current count which       * is (old count + 1). The whole purpose of this api is to obtain restart       * counts across restarts to avoid attempt-id clashes.      *       * Note that in between if the jobtracker.info files goes missing then the      * jobtracker will disable recovery and continue.       *        */
DECL|method|updateRestartCount ()
name|void
name|updateRestartCount
parameter_list|()
throws|throws
name|IOException
block|{
name|Path
name|restartFile
init|=
name|getRestartCountFile
argument_list|()
decl_stmt|;
name|Path
name|tmpRestartFile
init|=
name|getTempRestartCountFile
argument_list|()
decl_stmt|;
name|FsPermission
name|filePerm
init|=
operator|new
name|FsPermission
argument_list|(
name|SYSTEM_FILE_PERMISSION
argument_list|)
decl_stmt|;
comment|// read the count from the jobtracker info file
if|if
condition|(
name|fs
operator|.
name|exists
argument_list|(
name|restartFile
argument_list|)
condition|)
block|{
name|fs
operator|.
name|delete
argument_list|(
name|tmpRestartFile
argument_list|,
literal|false
argument_list|)
expr_stmt|;
comment|// delete the tmp file
block|}
elseif|else
if|if
condition|(
name|fs
operator|.
name|exists
argument_list|(
name|tmpRestartFile
argument_list|)
condition|)
block|{
comment|// if .rec exists then delete the main file and rename the .rec to main
name|fs
operator|.
name|rename
argument_list|(
name|tmpRestartFile
argument_list|,
name|restartFile
argument_list|)
expr_stmt|;
comment|// rename .rec to main file
block|}
else|else
block|{
comment|// For the very first time the jobtracker will create a jobtracker.info
comment|// file. If the jobtracker has restarted then disable recovery as files'
comment|// needed for recovery are missing.
comment|// disable recovery if this is a restart
name|shouldRecover
operator|=
literal|false
expr_stmt|;
comment|// write the jobtracker.info file
try|try
block|{
name|FSDataOutputStream
name|out
init|=
name|FileSystem
operator|.
name|create
argument_list|(
name|fs
argument_list|,
name|restartFile
argument_list|,
name|filePerm
argument_list|)
decl_stmt|;
name|out
operator|.
name|writeInt
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|out
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Writing to file "
operator|+
name|restartFile
operator|+
literal|" failed!"
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
literal|"FileSystem is not ready yet!"
argument_list|)
expr_stmt|;
name|fs
operator|.
name|delete
argument_list|(
name|restartFile
argument_list|,
literal|false
argument_list|)
expr_stmt|;
throw|throw
name|ioe
throw|;
block|}
return|return;
block|}
name|FSDataInputStream
name|in
init|=
name|fs
operator|.
name|open
argument_list|(
name|restartFile
argument_list|)
decl_stmt|;
try|try
block|{
comment|// read the old count
name|restartCount
operator|=
name|in
operator|.
name|readInt
argument_list|()
expr_stmt|;
operator|++
name|restartCount
expr_stmt|;
comment|// increment the restart count
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"System directory is garbled. Failed to read file "
operator|+
name|restartFile
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
literal|"Jobtracker recovery is not possible with garbled"
operator|+
literal|" system directory! Please delete the system directory and"
operator|+
literal|" restart the jobtracker. Note that deleting the system"
operator|+
literal|" directory will result in loss of all the running jobs."
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|ioe
argument_list|)
throw|;
block|}
finally|finally
block|{
if|if
condition|(
name|in
operator|!=
literal|null
condition|)
block|{
name|in
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|// Write back the new restart count and rename the old info file
comment|//TODO This is similar to jobhistory recovery, maybe this common code
comment|//      can be factored out.
comment|// write to the tmp file
name|FSDataOutputStream
name|out
init|=
name|FileSystem
operator|.
name|create
argument_list|(
name|fs
argument_list|,
name|tmpRestartFile
argument_list|,
name|filePerm
argument_list|)
decl_stmt|;
name|out
operator|.
name|writeInt
argument_list|(
name|restartCount
argument_list|)
expr_stmt|;
name|out
operator|.
name|close
argument_list|()
expr_stmt|;
comment|// delete the main file
name|fs
operator|.
name|delete
argument_list|(
name|restartFile
argument_list|,
literal|false
argument_list|)
expr_stmt|;
comment|// rename the .rec to main file
name|fs
operator|.
name|rename
argument_list|(
name|tmpRestartFile
argument_list|,
name|restartFile
argument_list|)
expr_stmt|;
block|}
DECL|method|recover ()
specifier|public
name|void
name|recover
parameter_list|()
block|{
name|long
name|recoveryProcessStartTime
init|=
name|clock
operator|.
name|getTime
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|shouldRecover
argument_list|()
condition|)
block|{
comment|// clean up jobs structure
name|jobsToRecover
operator|.
name|clear
argument_list|()
expr_stmt|;
return|return;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Starting the recovery process for "
operator|+
name|jobsToRecover
operator|.
name|size
argument_list|()
operator|+
literal|" jobs ..."
argument_list|)
expr_stmt|;
for|for
control|(
name|JobID
name|jobId
range|:
name|jobsToRecover
control|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Submitting job "
operator|+
name|jobId
argument_list|)
expr_stmt|;
try|try
block|{
name|Path
name|jobInfoFile
init|=
name|getSystemFileForJob
argument_list|(
name|jobId
argument_list|)
decl_stmt|;
name|FSDataInputStream
name|in
init|=
name|fs
operator|.
name|open
argument_list|(
name|jobInfoFile
argument_list|)
decl_stmt|;
name|JobInfo
name|token
init|=
operator|new
name|JobInfo
argument_list|()
decl_stmt|;
name|token
operator|.
name|readFields
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|in
operator|.
name|close
argument_list|()
expr_stmt|;
name|UserGroupInformation
name|ugi
init|=
name|UserGroupInformation
operator|.
name|createRemoteUser
argument_list|(
name|token
operator|.
name|getUser
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
name|submitJob
argument_list|(
name|token
operator|.
name|getJobID
argument_list|()
argument_list|,
name|restartCount
argument_list|,
name|ugi
argument_list|,
name|token
operator|.
name|getJobSubmitDir
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|,
literal|true
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|recovered
operator|++
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Could not recover job "
operator|+
name|jobId
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
name|recoveryDuration
operator|=
name|clock
operator|.
name|getTime
argument_list|()
operator|-
name|recoveryProcessStartTime
expr_stmt|;
name|hasRecovered
operator|=
literal|true
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Recovery done! Recoverd "
operator|+
name|recovered
operator|+
literal|" of "
operator|+
name|jobsToRecover
operator|.
name|size
argument_list|()
operator|+
literal|" jobs."
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Recovery Duration (ms):"
operator|+
name|recoveryDuration
argument_list|)
expr_stmt|;
block|}
block|}
DECL|field|myInstrumentation
specifier|private
specifier|final
name|JobTrackerInstrumentation
name|myInstrumentation
decl_stmt|;
comment|/////////////////////////////////////////////////////////////////
comment|// The real JobTracker
comment|////////////////////////////////////////////////////////////////
DECL|field|port
name|int
name|port
decl_stmt|;
DECL|field|localMachine
name|String
name|localMachine
decl_stmt|;
DECL|field|trackerIdentifier
specifier|private
specifier|final
name|String
name|trackerIdentifier
decl_stmt|;
DECL|field|startTime
name|long
name|startTime
decl_stmt|;
DECL|field|totalSubmissions
name|int
name|totalSubmissions
init|=
literal|0
decl_stmt|;
DECL|field|totalMapTaskCapacity
specifier|private
name|int
name|totalMapTaskCapacity
decl_stmt|;
DECL|field|totalReduceTaskCapacity
specifier|private
name|int
name|totalReduceTaskCapacity
decl_stmt|;
DECL|field|hostsReader
specifier|private
specifier|final
name|HostsFileReader
name|hostsReader
decl_stmt|;
comment|// JobTracker recovery variables
DECL|field|hasRecovered
specifier|private
specifier|volatile
name|boolean
name|hasRecovered
init|=
literal|false
decl_stmt|;
DECL|field|recoveryDuration
specifier|private
specifier|volatile
name|long
name|recoveryDuration
decl_stmt|;
comment|//
comment|// Properties to maintain while running Jobs and Tasks:
comment|//
comment|// 1.  Each Task is always contained in a single Job.  A Job succeeds when all its
comment|//     Tasks are complete.
comment|//
comment|// 2.  Every running or successful Task is assigned to a Tracker.  Idle Tasks are not.
comment|//
comment|// 3.  When a Tracker fails, all of its assigned Tasks are marked as failures.
comment|//
comment|// 4.  A Task might need to be reexecuted if it (or the machine it's hosted on) fails
comment|//     before the Job is 100% complete.  Sometimes an upstream Task can fail without
comment|//     reexecution if all downstream Tasks that require its output have already obtained
comment|//     the necessary files.
comment|//
comment|// All the known jobs.  (jobid->JobInProgress)
DECL|field|jobs
name|Map
argument_list|<
name|JobID
argument_list|,
name|JobInProgress
argument_list|>
name|jobs
init|=
name|Collections
operator|.
name|synchronizedMap
argument_list|(
operator|new
name|TreeMap
argument_list|<
name|JobID
argument_list|,
name|JobInProgress
argument_list|>
argument_list|()
argument_list|)
decl_stmt|;
comment|// (trackerID --> list of jobs to cleanup)
DECL|field|trackerToJobsToCleanup
name|Map
argument_list|<
name|String
argument_list|,
name|Set
argument_list|<
name|JobID
argument_list|>
argument_list|>
name|trackerToJobsToCleanup
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Set
argument_list|<
name|JobID
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
comment|// (trackerID --> list of tasks to cleanup)
DECL|field|trackerToTasksToCleanup
name|Map
argument_list|<
name|String
argument_list|,
name|Set
argument_list|<
name|TaskAttemptID
argument_list|>
argument_list|>
name|trackerToTasksToCleanup
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Set
argument_list|<
name|TaskAttemptID
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
comment|// All the known TaskInProgress items, mapped to by taskids (taskid->TIP)
DECL|field|taskidToTIPMap
name|Map
argument_list|<
name|TaskAttemptID
argument_list|,
name|TaskInProgress
argument_list|>
name|taskidToTIPMap
init|=
operator|new
name|TreeMap
argument_list|<
name|TaskAttemptID
argument_list|,
name|TaskInProgress
argument_list|>
argument_list|()
decl_stmt|;
comment|// (taskid --> trackerID)
DECL|field|taskidToTrackerMap
name|TreeMap
argument_list|<
name|TaskAttemptID
argument_list|,
name|String
argument_list|>
name|taskidToTrackerMap
init|=
operator|new
name|TreeMap
argument_list|<
name|TaskAttemptID
argument_list|,
name|String
argument_list|>
argument_list|()
decl_stmt|;
comment|// (trackerID->TreeSet of taskids running at that tracker)
DECL|field|trackerToTaskMap
name|TreeMap
argument_list|<
name|String
argument_list|,
name|Set
argument_list|<
name|TaskAttemptID
argument_list|>
argument_list|>
name|trackerToTaskMap
init|=
operator|new
name|TreeMap
argument_list|<
name|String
argument_list|,
name|Set
argument_list|<
name|TaskAttemptID
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
comment|// (trackerID -> TreeSet of completed taskids running at that tracker)
DECL|field|trackerToMarkedTasksMap
name|TreeMap
argument_list|<
name|String
argument_list|,
name|Set
argument_list|<
name|TaskAttemptID
argument_list|>
argument_list|>
name|trackerToMarkedTasksMap
init|=
operator|new
name|TreeMap
argument_list|<
name|String
argument_list|,
name|Set
argument_list|<
name|TaskAttemptID
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
comment|// (trackerID --> last sent HeartBeatResponse)
DECL|field|trackerToHeartbeatResponseMap
name|Map
argument_list|<
name|String
argument_list|,
name|HeartbeatResponse
argument_list|>
name|trackerToHeartbeatResponseMap
init|=
operator|new
name|TreeMap
argument_list|<
name|String
argument_list|,
name|HeartbeatResponse
argument_list|>
argument_list|()
decl_stmt|;
comment|// (hostname --> Node (NetworkTopology))
DECL|field|hostnameToNodeMap
name|Map
argument_list|<
name|String
argument_list|,
name|Node
argument_list|>
name|hostnameToNodeMap
init|=
name|Collections
operator|.
name|synchronizedMap
argument_list|(
operator|new
name|TreeMap
argument_list|<
name|String
argument_list|,
name|Node
argument_list|>
argument_list|()
argument_list|)
decl_stmt|;
comment|// (hostname --> Set(tasktracker))
comment|// This is used to keep track of all trackers running on one host. While
comment|// decommissioning the host, all the trackers on the host will be lost.
DECL|field|hostnameToTaskTracker
name|Map
argument_list|<
name|String
argument_list|,
name|Set
argument_list|<
name|TaskTracker
argument_list|>
argument_list|>
name|hostnameToTaskTracker
init|=
name|Collections
operator|.
name|synchronizedMap
argument_list|(
operator|new
name|TreeMap
argument_list|<
name|String
argument_list|,
name|Set
argument_list|<
name|TaskTracker
argument_list|>
argument_list|>
argument_list|()
argument_list|)
decl_stmt|;
comment|// Number of resolved entries
DECL|field|numResolved
name|int
name|numResolved
decl_stmt|;
DECL|field|faultyTrackers
specifier|private
name|FaultyTrackersInfo
name|faultyTrackers
init|=
operator|new
name|FaultyTrackersInfo
argument_list|()
decl_stmt|;
DECL|field|statistics
specifier|private
name|JobTrackerStatistics
name|statistics
init|=
operator|new
name|JobTrackerStatistics
argument_list|()
decl_stmt|;
comment|//
comment|// Watch and expire TaskTracker objects using these structures.
comment|// We can map from Name->TaskTrackerStatus, or we can expire by time.
comment|//
DECL|field|totalMaps
name|int
name|totalMaps
init|=
literal|0
decl_stmt|;
DECL|field|totalReduces
name|int
name|totalReduces
init|=
literal|0
decl_stmt|;
DECL|field|occupiedMapSlots
specifier|private
name|int
name|occupiedMapSlots
init|=
literal|0
decl_stmt|;
DECL|field|occupiedReduceSlots
specifier|private
name|int
name|occupiedReduceSlots
init|=
literal|0
decl_stmt|;
DECL|field|reservedMapSlots
specifier|private
name|int
name|reservedMapSlots
init|=
literal|0
decl_stmt|;
DECL|field|reservedReduceSlots
specifier|private
name|int
name|reservedReduceSlots
init|=
literal|0
decl_stmt|;
DECL|field|taskTrackers
specifier|private
name|HashMap
argument_list|<
name|String
argument_list|,
name|TaskTracker
argument_list|>
name|taskTrackers
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|TaskTracker
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|uniqueHostsMap
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|uniqueHostsMap
init|=
operator|new
name|ConcurrentHashMap
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|expireTrackers
name|ExpireTrackers
name|expireTrackers
init|=
operator|new
name|ExpireTrackers
argument_list|()
decl_stmt|;
DECL|field|expireTrackersThread
name|Thread
name|expireTrackersThread
init|=
literal|null
decl_stmt|;
DECL|field|retireJobs
name|RetireJobs
name|retireJobs
init|=
operator|new
name|RetireJobs
argument_list|()
decl_stmt|;
DECL|field|retiredJobsCacheSize
specifier|final
name|int
name|retiredJobsCacheSize
decl_stmt|;
DECL|field|expireLaunchingTasks
name|ExpireLaunchingTasks
name|expireLaunchingTasks
init|=
operator|new
name|ExpireLaunchingTasks
argument_list|()
decl_stmt|;
DECL|field|expireLaunchingTaskThread
name|Thread
name|expireLaunchingTaskThread
init|=
operator|new
name|Thread
argument_list|(
name|expireLaunchingTasks
argument_list|,
literal|"expireLaunchingTasks"
argument_list|)
decl_stmt|;
DECL|field|completedJobStatusStore
specifier|final
name|CompletedJobStatusStore
name|completedJobStatusStore
decl_stmt|;
DECL|field|completedJobsStoreThread
name|Thread
name|completedJobsStoreThread
init|=
literal|null
decl_stmt|;
DECL|field|recoveryManager
specifier|final
name|RecoveryManager
name|recoveryManager
decl_stmt|;
comment|/**    * It might seem like a bug to maintain a TreeSet of tasktracker objects,    * which can be updated at any time.  But that's not what happens!  We    * only update status objects in the taskTrackers table.  Status objects    * are never updated once they enter the expiry queue.  Instead, we wait    * for them to expire and remove them from the expiry queue.  If a status    * object has been updated in the taskTracker table, the latest status is     * reinserted.  Otherwise, we assume the tracker has expired.    */
DECL|field|trackerExpiryQueue
name|TreeSet
argument_list|<
name|TaskTrackerStatus
argument_list|>
name|trackerExpiryQueue
init|=
operator|new
name|TreeSet
argument_list|<
name|TaskTrackerStatus
argument_list|>
argument_list|(
operator|new
name|Comparator
argument_list|<
name|TaskTrackerStatus
argument_list|>
argument_list|()
block|{
specifier|public
name|int
name|compare
parameter_list|(
name|TaskTrackerStatus
name|p1
parameter_list|,
name|TaskTrackerStatus
name|p2
parameter_list|)
block|{
if|if
condition|(
name|p1
operator|.
name|getLastSeen
argument_list|()
operator|<
name|p2
operator|.
name|getLastSeen
argument_list|()
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|p1
operator|.
name|getLastSeen
argument_list|()
operator|>
name|p2
operator|.
name|getLastSeen
argument_list|()
condition|)
block|{
return|return
literal|1
return|;
block|}
else|else
block|{
return|return
operator|(
name|p1
operator|.
name|getTrackerName
argument_list|()
operator|.
name|compareTo
argument_list|(
name|p2
operator|.
name|getTrackerName
argument_list|()
argument_list|)
operator|)
return|;
block|}
block|}
block|}
argument_list|)
decl_stmt|;
comment|// Used to provide an HTML view on Job, Task, and TaskTracker structures
DECL|field|infoServer
specifier|final
name|HttpServer
name|infoServer
decl_stmt|;
DECL|field|infoPort
name|int
name|infoPort
decl_stmt|;
DECL|field|interTrackerServer
name|Server
name|interTrackerServer
decl_stmt|;
comment|// Some jobs are stored in a local system directory.  We can delete
comment|// the files when we're done with the job.
DECL|field|SUBDIR
specifier|static
specifier|final
name|String
name|SUBDIR
init|=
literal|"jobTracker"
decl_stmt|;
DECL|field|localFs
specifier|final
name|LocalFileSystem
name|localFs
decl_stmt|;
DECL|field|fs
name|FileSystem
name|fs
init|=
literal|null
decl_stmt|;
DECL|field|systemDir
name|Path
name|systemDir
init|=
literal|null
decl_stmt|;
DECL|field|conf
name|JobConf
name|conf
decl_stmt|;
DECL|field|aclsManager
specifier|private
specifier|final
name|ACLsManager
name|aclsManager
decl_stmt|;
DECL|field|limitMaxMemForMapTasks
name|long
name|limitMaxMemForMapTasks
decl_stmt|;
DECL|field|limitMaxMemForReduceTasks
name|long
name|limitMaxMemForReduceTasks
decl_stmt|;
DECL|field|memSizeForMapSlotOnJT
name|long
name|memSizeForMapSlotOnJT
decl_stmt|;
DECL|field|memSizeForReduceSlotOnJT
name|long
name|memSizeForReduceSlotOnJT
decl_stmt|;
DECL|field|queueManager
specifier|private
specifier|final
name|QueueManager
name|queueManager
decl_stmt|;
comment|//TO BE USED BY TEST CLASSES ONLY
comment|//ONLY BUILD THE STATE WHICH IS REQUIRED BY TESTS
DECL|method|JobTracker ()
name|JobTracker
parameter_list|()
block|{
name|hostsReader
operator|=
literal|null
expr_stmt|;
name|retiredJobsCacheSize
operator|=
literal|0
expr_stmt|;
name|infoServer
operator|=
literal|null
expr_stmt|;
name|queueManager
operator|=
literal|null
expr_stmt|;
name|aclsManager
operator|=
literal|null
expr_stmt|;
name|taskScheduler
operator|=
literal|null
expr_stmt|;
name|trackerIdentifier
operator|=
literal|null
expr_stmt|;
name|recoveryManager
operator|=
literal|null
expr_stmt|;
name|jobHistory
operator|=
literal|null
expr_stmt|;
name|completedJobStatusStore
operator|=
literal|null
expr_stmt|;
name|tasktrackerExpiryInterval
operator|=
literal|0
expr_stmt|;
name|myInstrumentation
operator|=
operator|new
name|JobTrackerMetricsInst
argument_list|(
name|this
argument_list|,
operator|new
name|JobConf
argument_list|()
argument_list|)
expr_stmt|;
name|secretManager
operator|=
literal|null
expr_stmt|;
name|localFs
operator|=
literal|null
expr_stmt|;
block|}
DECL|method|JobTracker (JobConf conf)
name|JobTracker
parameter_list|(
name|JobConf
name|conf
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|this
argument_list|(
name|conf
argument_list|,
operator|new
name|Clock
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Start the JobTracker process, listen on the indicated port    */
DECL|method|JobTracker (JobConf conf, Clock clock)
name|JobTracker
parameter_list|(
name|JobConf
name|conf
parameter_list|,
name|Clock
name|clock
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|this
argument_list|(
name|conf
argument_list|,
name|clock
argument_list|,
name|generateNewIdentifier
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|JobTracker (final JobConf conf, Clock newClock, String jobtrackerIndentifier)
name|JobTracker
parameter_list|(
specifier|final
name|JobConf
name|conf
parameter_list|,
name|Clock
name|newClock
parameter_list|,
name|String
name|jobtrackerIndentifier
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
comment|// Set ports, start RPC servers, setup security policy etc.
name|InetSocketAddress
name|addr
init|=
name|getAddress
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|this
operator|.
name|localMachine
operator|=
name|addr
operator|.
name|getHostName
argument_list|()
expr_stmt|;
name|this
operator|.
name|port
operator|=
name|addr
operator|.
name|getPort
argument_list|()
expr_stmt|;
name|UserGroupInformation
operator|.
name|setConfiguration
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|SecurityUtil
operator|.
name|login
argument_list|(
name|conf
argument_list|,
name|JTConfig
operator|.
name|JT_KEYTAB_FILE
argument_list|,
name|JTConfig
operator|.
name|JT_USER_NAME
argument_list|,
name|localMachine
argument_list|)
expr_stmt|;
name|clock
operator|=
name|newClock
expr_stmt|;
name|long
name|secretKeyInterval
init|=
name|conf
operator|.
name|getLong
argument_list|(
name|MRConfig
operator|.
name|DELEGATION_KEY_UPDATE_INTERVAL_KEY
argument_list|,
name|MRConfig
operator|.
name|DELEGATION_KEY_UPDATE_INTERVAL_DEFAULT
argument_list|)
decl_stmt|;
name|long
name|tokenMaxLifetime
init|=
name|conf
operator|.
name|getLong
argument_list|(
name|MRConfig
operator|.
name|DELEGATION_TOKEN_MAX_LIFETIME_KEY
argument_list|,
name|MRConfig
operator|.
name|DELEGATION_TOKEN_MAX_LIFETIME_DEFAULT
argument_list|)
decl_stmt|;
name|long
name|tokenRenewInterval
init|=
name|conf
operator|.
name|getLong
argument_list|(
name|MRConfig
operator|.
name|DELEGATION_TOKEN_RENEW_INTERVAL_KEY
argument_list|,
name|MRConfig
operator|.
name|DELEGATION_TOKEN_RENEW_INTERVAL_DEFAULT
argument_list|)
decl_stmt|;
name|secretManager
operator|=
operator|new
name|DelegationTokenSecretManager
argument_list|(
name|secretKeyInterval
argument_list|,
name|tokenMaxLifetime
argument_list|,
name|tokenRenewInterval
argument_list|,
name|DELEGATION_TOKEN_GC_INTERVAL
argument_list|)
expr_stmt|;
name|secretManager
operator|.
name|startThreads
argument_list|()
expr_stmt|;
comment|//
comment|// Grab some static constants
comment|//
name|tasktrackerExpiryInterval
operator|=
name|conf
operator|.
name|getLong
argument_list|(
name|JT_TRACKER_EXPIRY_INTERVAL
argument_list|,
literal|10
operator|*
literal|60
operator|*
literal|1000
argument_list|)
expr_stmt|;
name|retiredJobsCacheSize
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|JT_RETIREJOB_CACHE_SIZE
argument_list|,
literal|1000
argument_list|)
expr_stmt|;
name|MAX_BLACKLISTS_PER_TRACKER
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|JTConfig
operator|.
name|JT_MAX_TRACKER_BLACKLISTS
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|NUM_HEARTBEATS_IN_SECOND
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|JT_HEARTBEATS_IN_SECOND
argument_list|,
name|DEFAULT_NUM_HEARTBEATS_IN_SECOND
argument_list|)
expr_stmt|;
if|if
condition|(
name|NUM_HEARTBEATS_IN_SECOND
operator|<
name|MIN_NUM_HEARTBEATS_IN_SECOND
condition|)
block|{
name|NUM_HEARTBEATS_IN_SECOND
operator|=
name|DEFAULT_NUM_HEARTBEATS_IN_SECOND
expr_stmt|;
block|}
name|HEARTBEATS_SCALING_FACTOR
operator|=
name|conf
operator|.
name|getFloat
argument_list|(
name|JT_HEARTBEATS_SCALING_FACTOR
argument_list|,
name|DEFAULT_HEARTBEATS_SCALING_FACTOR
argument_list|)
expr_stmt|;
if|if
condition|(
name|HEARTBEATS_SCALING_FACTOR
operator|<
name|MIN_HEARTBEATS_SCALING_FACTOR
condition|)
block|{
name|HEARTBEATS_SCALING_FACTOR
operator|=
name|DEFAULT_HEARTBEATS_SCALING_FACTOR
expr_stmt|;
block|}
name|HEARTBEAT_INTERVAL_MIN
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|JT_HEARTBEAT_INTERVAL_MIN
argument_list|,
name|JT_HEARTBEAT_INTERVAL_MIN_DEFAULT
argument_list|)
expr_stmt|;
comment|//This configuration is there solely for tuning purposes and
comment|//once this feature has been tested in real clusters and an appropriate
comment|//value for the threshold has been found, this config might be taken out.
name|AVERAGE_BLACKLIST_THRESHOLD
operator|=
name|conf
operator|.
name|getFloat
argument_list|(
name|JTConfig
operator|.
name|JT_AVG_BLACKLIST_THRESHOLD
argument_list|,
literal|0.5f
argument_list|)
expr_stmt|;
comment|// This is a directory of temporary submission files.  We delete it
comment|// on startup, and can delete any files that we're done with
name|this
operator|.
name|conf
operator|=
name|conf
expr_stmt|;
name|JobConf
name|jobConf
init|=
operator|new
name|JobConf
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|initializeTaskMemoryRelatedConfig
argument_list|()
expr_stmt|;
comment|// Read the hosts/exclude files to restrict access to the jobtracker.
name|this
operator|.
name|hostsReader
operator|=
operator|new
name|HostsFileReader
argument_list|(
name|conf
operator|.
name|get
argument_list|(
name|JTConfig
operator|.
name|JT_HOSTS_FILENAME
argument_list|,
literal|""
argument_list|)
argument_list|,
name|conf
operator|.
name|get
argument_list|(
name|JTConfig
operator|.
name|JT_HOSTS_EXCLUDE_FILENAME
argument_list|,
literal|""
argument_list|)
argument_list|)
expr_stmt|;
name|Configuration
name|clusterConf
init|=
operator|new
name|Configuration
argument_list|(
name|this
operator|.
name|conf
argument_list|)
decl_stmt|;
name|queueManager
operator|=
operator|new
name|QueueManager
argument_list|(
name|clusterConf
argument_list|)
expr_stmt|;
name|aclsManager
operator|=
operator|new
name|ACLsManager
argument_list|(
name|conf
argument_list|,
operator|new
name|JobACLsManager
argument_list|(
name|conf
argument_list|)
argument_list|,
name|queueManager
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Starting jobtracker with owner as "
operator|+
name|getMROwner
argument_list|()
operator|.
name|getShortUserName
argument_list|()
argument_list|)
expr_stmt|;
comment|// Create the scheduler
name|Class
argument_list|<
name|?
extends|extends
name|TaskScheduler
argument_list|>
name|schedulerClass
init|=
name|conf
operator|.
name|getClass
argument_list|(
name|JT_TASK_SCHEDULER
argument_list|,
name|JobQueueTaskScheduler
operator|.
name|class
argument_list|,
name|TaskScheduler
operator|.
name|class
argument_list|)
decl_stmt|;
name|taskScheduler
operator|=
operator|(
name|TaskScheduler
operator|)
name|ReflectionUtils
operator|.
name|newInstance
argument_list|(
name|schedulerClass
argument_list|,
name|conf
argument_list|)
expr_stmt|;
name|int
name|handlerCount
init|=
name|conf
operator|.
name|getInt
argument_list|(
name|JT_IPC_HANDLER_COUNT
argument_list|,
literal|10
argument_list|)
decl_stmt|;
name|this
operator|.
name|interTrackerServer
operator|=
name|RPC
operator|.
name|getServer
argument_list|(
name|ClientProtocol
operator|.
name|class
argument_list|,
name|this
argument_list|,
name|addr
operator|.
name|getHostName
argument_list|()
argument_list|,
name|addr
operator|.
name|getPort
argument_list|()
argument_list|,
name|handlerCount
argument_list|,
literal|false
argument_list|,
name|conf
argument_list|,
name|secretManager
argument_list|)
expr_stmt|;
comment|// Set service-level authorization security policy
if|if
condition|(
name|conf
operator|.
name|getBoolean
argument_list|(
name|CommonConfigurationKeys
operator|.
name|HADOOP_SECURITY_AUTHORIZATION
argument_list|,
literal|false
argument_list|)
condition|)
block|{
name|this
operator|.
name|interTrackerServer
operator|.
name|refreshServiceAcl
argument_list|(
name|conf
argument_list|,
operator|new
name|MapReducePolicyProvider
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|Properties
name|p
init|=
name|System
operator|.
name|getProperties
argument_list|()
decl_stmt|;
for|for
control|(
name|Iterator
name|it
init|=
name|p
operator|.
name|keySet
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|String
name|key
init|=
operator|(
name|String
operator|)
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|String
name|val
init|=
name|p
operator|.
name|getProperty
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Property '"
operator|+
name|key
operator|+
literal|"' is "
operator|+
name|val
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|InetSocketAddress
name|infoSocAddr
init|=
name|NetUtils
operator|.
name|createSocketAddr
argument_list|(
name|conf
operator|.
name|get
argument_list|(
name|JT_HTTP_ADDRESS
argument_list|,
literal|"0.0.0.0:50030"
argument_list|)
argument_list|)
decl_stmt|;
name|String
name|infoBindAddress
init|=
name|infoSocAddr
operator|.
name|getHostName
argument_list|()
decl_stmt|;
name|int
name|tmpInfoPort
init|=
name|infoSocAddr
operator|.
name|getPort
argument_list|()
decl_stmt|;
name|this
operator|.
name|startTime
operator|=
name|clock
operator|.
name|getTime
argument_list|()
expr_stmt|;
name|infoServer
operator|=
operator|new
name|HttpServer
argument_list|(
literal|"job"
argument_list|,
name|infoBindAddress
argument_list|,
name|tmpInfoPort
argument_list|,
name|tmpInfoPort
operator|==
literal|0
argument_list|,
name|conf
argument_list|,
name|aclsManager
operator|.
name|getAdminsAcl
argument_list|()
argument_list|)
expr_stmt|;
name|infoServer
operator|.
name|setAttribute
argument_list|(
literal|"job.tracker"
argument_list|,
name|this
argument_list|)
expr_stmt|;
comment|// initialize history parameters.
name|jobHistory
operator|=
operator|new
name|JobHistory
argument_list|()
expr_stmt|;
name|jobHistory
operator|.
name|init
argument_list|(
name|this
argument_list|,
name|conf
argument_list|,
name|this
operator|.
name|localMachine
argument_list|,
name|this
operator|.
name|startTime
argument_list|)
expr_stmt|;
name|infoServer
operator|.
name|addServlet
argument_list|(
literal|"reducegraph"
argument_list|,
literal|"/taskgraph"
argument_list|,
name|TaskGraphServlet
operator|.
name|class
argument_list|)
expr_stmt|;
name|infoServer
operator|.
name|start
argument_list|()
expr_stmt|;
name|this
operator|.
name|trackerIdentifier
operator|=
name|jobtrackerIndentifier
expr_stmt|;
comment|// Initialize instrumentation
name|JobTrackerInstrumentation
name|tmp
decl_stmt|;
try|try
block|{
name|Class
argument_list|<
name|?
extends|extends
name|JobTrackerInstrumentation
argument_list|>
name|metricsInst
init|=
name|getInstrumentationClass
argument_list|(
name|jobConf
argument_list|)
decl_stmt|;
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Constructor
argument_list|<
name|?
extends|extends
name|JobTrackerInstrumentation
argument_list|>
name|c
init|=
name|metricsInst
operator|.
name|getConstructor
argument_list|(
operator|new
name|Class
index|[]
block|{
name|JobTracker
operator|.
name|class
block|,
name|JobConf
operator|.
name|class
block|}
argument_list|)
decl_stmt|;
name|tmp
operator|=
name|c
operator|.
name|newInstance
argument_list|(
name|this
argument_list|,
name|jobConf
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
comment|//Reflection can throw lots of exceptions -- handle them all by
comment|//falling back on the default.
name|LOG
operator|.
name|error
argument_list|(
literal|"failed to initialize job tracker metrics"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|tmp
operator|=
operator|new
name|JobTrackerMetricsInst
argument_list|(
name|this
argument_list|,
name|jobConf
argument_list|)
expr_stmt|;
block|}
name|myInstrumentation
operator|=
name|tmp
expr_stmt|;
comment|// The rpc/web-server ports can be ephemeral ports...
comment|// ... ensure we have the correct info
name|this
operator|.
name|port
operator|=
name|interTrackerServer
operator|.
name|getListenerAddress
argument_list|()
operator|.
name|getPort
argument_list|()
expr_stmt|;
name|this
operator|.
name|conf
operator|.
name|set
argument_list|(
name|JT_IPC_ADDRESS
argument_list|,
operator|(
name|this
operator|.
name|localMachine
operator|+
literal|":"
operator|+
name|this
operator|.
name|port
operator|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|localFs
operator|=
name|FileSystem
operator|.
name|getLocal
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"JobTracker up at: "
operator|+
name|this
operator|.
name|port
argument_list|)
expr_stmt|;
name|this
operator|.
name|infoPort
operator|=
name|this
operator|.
name|infoServer
operator|.
name|getPort
argument_list|()
expr_stmt|;
name|this
operator|.
name|conf
operator|.
name|set
argument_list|(
name|JT_HTTP_ADDRESS
argument_list|,
name|infoBindAddress
operator|+
literal|":"
operator|+
name|this
operator|.
name|infoPort
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"JobTracker webserver: "
operator|+
name|this
operator|.
name|infoServer
operator|.
name|getPort
argument_list|()
argument_list|)
expr_stmt|;
comment|// start the recovery manager
name|recoveryManager
operator|=
operator|new
name|RecoveryManager
argument_list|()
expr_stmt|;
while|while
condition|(
operator|!
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|isInterrupted
argument_list|()
condition|)
block|{
try|try
block|{
comment|// if we haven't contacted the namenode go ahead and do it
if|if
condition|(
name|fs
operator|==
literal|null
condition|)
block|{
name|fs
operator|=
name|getMROwner
argument_list|()
operator|.
name|doAs
argument_list|(
operator|new
name|PrivilegedExceptionAction
argument_list|<
name|FileSystem
argument_list|>
argument_list|()
block|{
specifier|public
name|FileSystem
name|run
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|FileSystem
operator|.
name|get
argument_list|(
name|conf
argument_list|)
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
comment|// clean up the system dir, which will only work if hdfs is out of
comment|// safe mode
if|if
condition|(
name|systemDir
operator|==
literal|null
condition|)
block|{
name|systemDir
operator|=
operator|new
name|Path
argument_list|(
name|getSystemDir
argument_list|()
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|FileStatus
name|systemDirStatus
init|=
name|fs
operator|.
name|getFileStatus
argument_list|(
name|systemDir
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|systemDirStatus
operator|.
name|getOwner
argument_list|()
operator|.
name|equals
argument_list|(
name|getMROwner
argument_list|()
operator|.
name|getShortUserName
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|AccessControlException
argument_list|(
literal|"The systemdir "
operator|+
name|systemDir
operator|+
literal|" is not owned by "
operator|+
name|getMROwner
argument_list|()
operator|.
name|getShortUserName
argument_list|()
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|systemDirStatus
operator|.
name|getPermission
argument_list|()
operator|.
name|equals
argument_list|(
name|SYSTEM_DIR_PERMISSION
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Incorrect permissions on "
operator|+
name|systemDir
operator|+
literal|". Setting it to "
operator|+
name|SYSTEM_DIR_PERMISSION
argument_list|)
expr_stmt|;
name|fs
operator|.
name|setPermission
argument_list|(
name|systemDir
argument_list|,
operator|new
name|FsPermission
argument_list|(
name|SYSTEM_DIR_PERMISSION
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|fnf
parameter_list|)
block|{}
comment|//ignore
comment|// Make sure that the backup data is preserved
name|FileStatus
index|[]
name|systemDirData
decl_stmt|;
try|try
block|{
name|systemDirData
operator|=
name|fs
operator|.
name|listStatus
argument_list|(
name|this
operator|.
name|systemDir
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|fnfe
parameter_list|)
block|{
name|systemDirData
operator|=
literal|null
expr_stmt|;
block|}
comment|// Check if the history is enabled .. as we can't have persistence with
comment|// history disabled
if|if
condition|(
name|conf
operator|.
name|getBoolean
argument_list|(
name|JT_RESTART_ENABLED
argument_list|,
literal|false
argument_list|)
operator|&&
name|systemDirData
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|FileStatus
name|status
range|:
name|systemDirData
control|)
block|{
try|try
block|{
name|recoveryManager
operator|.
name|addJobForRecovery
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to add the job "
operator|+
name|status
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Check if there are jobs to be recovered
if|if
condition|(
name|recoveryManager
operator|.
name|shouldRecover
argument_list|()
condition|)
block|{
break|break;
comment|// if there is something to recover else clean the sys dir
block|}
block|}
if|if
condition|(
operator|!
name|fs
operator|.
name|exists
argument_list|(
name|systemDir
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Creating the system directory"
argument_list|)
expr_stmt|;
if|if
condition|(
name|FileSystem
operator|.
name|mkdirs
argument_list|(
name|fs
argument_list|,
name|systemDir
argument_list|,
operator|new
name|FsPermission
argument_list|(
name|SYSTEM_DIR_PERMISSION
argument_list|)
argument_list|)
condition|)
block|{
comment|// success
break|break;
block|}
else|else
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Mkdirs failed to create "
operator|+
name|systemDir
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// It exists, just set permissions and clean the contents up
name|LOG
operator|.
name|info
argument_list|(
literal|"Cleaning up the system directory"
argument_list|)
expr_stmt|;
name|fs
operator|.
name|setPermission
argument_list|(
name|systemDir
argument_list|,
operator|new
name|FsPermission
argument_list|(
name|SYSTEM_DIR_PERMISSION
argument_list|)
argument_list|)
expr_stmt|;
name|deleteContents
argument_list|(
name|fs
argument_list|,
name|systemDir
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
catch|catch
parameter_list|(
name|AccessControlException
name|ace
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to operate on "
operator|+
name|JTConfig
operator|.
name|JT_SYSTEM_DIR
operator|+
literal|"("
operator|+
name|systemDir
operator|.
name|makeQualified
argument_list|(
name|fs
argument_list|)
operator|+
literal|") because of permissions."
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
literal|"This directory should exist and be owned by the user '"
operator|+
name|UserGroupInformation
operator|.
name|getCurrentUser
argument_list|()
operator|+
literal|"'"
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
literal|"Bailing out ... "
argument_list|)
expr_stmt|;
throw|throw
name|ace
throw|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ie
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"problem cleaning system directory: "
operator|+
name|systemDir
operator|.
name|makeQualified
argument_list|(
name|fs
argument_list|)
argument_list|,
name|ie
argument_list|)
expr_stmt|;
block|}
name|Thread
operator|.
name|sleep
argument_list|(
name|FS_ACCESS_RETRY_PERIOD
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|isInterrupted
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|InterruptedException
argument_list|()
throw|;
block|}
comment|// Same with 'localDir' except it's always on the local disk.
name|asyncDiskService
operator|=
operator|new
name|MRAsyncDiskService
argument_list|(
name|FileSystem
operator|.
name|getLocal
argument_list|(
name|conf
argument_list|)
argument_list|,
name|conf
operator|.
name|getLocalDirs
argument_list|()
argument_list|)
expr_stmt|;
name|asyncDiskService
operator|.
name|moveAndDeleteFromEachVolume
argument_list|(
name|SUBDIR
argument_list|)
expr_stmt|;
comment|// Initialize history DONE folder
name|jobHistory
operator|.
name|initDone
argument_list|(
name|conf
argument_list|,
name|fs
argument_list|)
expr_stmt|;
specifier|final
name|String
name|historyLogDir
init|=
name|jobHistory
operator|.
name|getCompletedJobHistoryLocation
argument_list|()
operator|.
name|toString
argument_list|()
decl_stmt|;
name|infoServer
operator|.
name|setAttribute
argument_list|(
literal|"historyLogDir"
argument_list|,
name|historyLogDir
argument_list|)
expr_stmt|;
name|FileSystem
name|historyFS
init|=
name|getMROwner
argument_list|()
operator|.
name|doAs
argument_list|(
operator|new
name|PrivilegedExceptionAction
argument_list|<
name|FileSystem
argument_list|>
argument_list|()
block|{
specifier|public
name|FileSystem
name|run
parameter_list|()
throws|throws
name|IOException
block|{
return|return
operator|new
name|Path
argument_list|(
name|historyLogDir
argument_list|)
operator|.
name|getFileSystem
argument_list|(
name|conf
argument_list|)
return|;
block|}
block|}
argument_list|)
decl_stmt|;
name|infoServer
operator|.
name|setAttribute
argument_list|(
literal|"fileSys"
argument_list|,
name|historyFS
argument_list|)
expr_stmt|;
name|this
operator|.
name|dnsToSwitchMapping
operator|=
name|ReflectionUtils
operator|.
name|newInstance
argument_list|(
name|conf
operator|.
name|getClass
argument_list|(
name|CommonConfigurationKeys
operator|.
name|NET_TOPOLOGY_NODE_SWITCH_MAPPING_IMPL_KEY
argument_list|,
name|ScriptBasedMapping
operator|.
name|class
argument_list|,
name|DNSToSwitchMapping
operator|.
name|class
argument_list|)
argument_list|,
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|numTaskCacheLevels
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|JT_TASKCACHE_LEVELS
argument_list|,
name|NetworkTopology
operator|.
name|DEFAULT_HOST_LEVEL
argument_list|)
expr_stmt|;
comment|//initializes the job status store
name|completedJobStatusStore
operator|=
operator|new
name|CompletedJobStatusStore
argument_list|(
name|conf
argument_list|,
name|aclsManager
argument_list|)
expr_stmt|;
name|plugins
operator|=
name|conf
operator|.
name|getInstances
argument_list|(
name|JT_PLUGINS
argument_list|,
name|ServicePlugin
operator|.
name|class
argument_list|)
expr_stmt|;
for|for
control|(
name|ServicePlugin
name|p
range|:
name|plugins
control|)
block|{
try|try
block|{
name|p
operator|.
name|start
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Started plug-in "
operator|+
name|p
operator|+
literal|" of type "
operator|+
name|p
operator|.
name|getClass
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"ServicePlugin "
operator|+
name|p
operator|+
literal|" of type "
operator|+
name|p
operator|.
name|getClass
argument_list|()
operator|+
literal|" could not be started"
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Recursively delete the contents of a directory without deleting the    * directory itself.    */
DECL|method|deleteContents (FileSystem fs, Path dir)
specifier|private
name|void
name|deleteContents
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Path
name|dir
parameter_list|)
throws|throws
name|IOException
block|{
for|for
control|(
name|FileStatus
name|stat
range|:
name|fs
operator|.
name|listStatus
argument_list|(
name|dir
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|fs
operator|.
name|delete
argument_list|(
name|stat
operator|.
name|getPath
argument_list|()
argument_list|,
literal|true
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unable to delete "
operator|+
name|stat
operator|.
name|getPath
argument_list|()
argument_list|)
throw|;
block|}
block|}
block|}
DECL|method|getDateFormat ()
specifier|private
specifier|static
name|SimpleDateFormat
name|getDateFormat
parameter_list|()
block|{
return|return
operator|new
name|SimpleDateFormat
argument_list|(
literal|"yyyyMMddHHmm"
argument_list|)
return|;
block|}
DECL|method|generateNewIdentifier ()
specifier|private
specifier|static
name|String
name|generateNewIdentifier
parameter_list|()
block|{
return|return
name|getDateFormat
argument_list|()
operator|.
name|format
argument_list|(
operator|new
name|Date
argument_list|()
argument_list|)
return|;
block|}
DECL|method|validateIdentifier (String id)
specifier|static
name|boolean
name|validateIdentifier
parameter_list|(
name|String
name|id
parameter_list|)
block|{
try|try
block|{
comment|// the jobtracker id should be 'date' parseable
name|getDateFormat
argument_list|()
operator|.
name|parse
argument_list|(
name|id
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
catch|catch
parameter_list|(
name|ParseException
name|pe
parameter_list|)
block|{}
return|return
literal|false
return|;
block|}
DECL|method|validateJobNumber (String id)
specifier|static
name|boolean
name|validateJobNumber
parameter_list|(
name|String
name|id
parameter_list|)
block|{
try|try
block|{
comment|// the job number should be integer parseable
name|Integer
operator|.
name|parseInt
argument_list|(
name|id
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|pe
parameter_list|)
block|{}
return|return
literal|false
return|;
block|}
comment|/**    * Whether the JT has recovered upon restart    */
DECL|method|hasRecovered ()
specifier|public
name|boolean
name|hasRecovered
parameter_list|()
block|{
return|return
name|hasRecovered
return|;
block|}
comment|/**    * How long the jobtracker took to recover from restart.    */
DECL|method|getRecoveryDuration ()
specifier|public
name|long
name|getRecoveryDuration
parameter_list|()
block|{
return|return
name|recoveryDuration
return|;
block|}
comment|/**    * Get JobTracker's FileSystem. This is the filesystem for mapreduce.system.dir.    */
DECL|method|getFileSystem ()
name|FileSystem
name|getFileSystem
parameter_list|()
block|{
return|return
name|fs
return|;
block|}
comment|/**    * Get JobTracker's LocalFileSystem handle. This is used by jobs for     * localizing job files to the local disk.    */
DECL|method|getLocalFileSystem ()
name|LocalFileSystem
name|getLocalFileSystem
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|localFs
return|;
block|}
DECL|method|getScheduler ()
name|TaskScheduler
name|getScheduler
parameter_list|()
block|{
return|return
name|taskScheduler
return|;
block|}
DECL|method|getInstrumentationClass (Configuration conf)
specifier|public
specifier|static
name|Class
argument_list|<
name|?
extends|extends
name|JobTrackerInstrumentation
argument_list|>
name|getInstrumentationClass
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
return|return
name|conf
operator|.
name|getClass
argument_list|(
name|JT_INSTRUMENTATION
argument_list|,
name|JobTrackerMetricsInst
operator|.
name|class
argument_list|,
name|JobTrackerInstrumentation
operator|.
name|class
argument_list|)
return|;
block|}
DECL|method|setInstrumentationClass (Configuration conf, Class<? extends JobTrackerInstrumentation> t)
specifier|public
specifier|static
name|void
name|setInstrumentationClass
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|Class
argument_list|<
name|?
extends|extends
name|JobTrackerInstrumentation
argument_list|>
name|t
parameter_list|)
block|{
name|conf
operator|.
name|setClass
argument_list|(
name|JT_INSTRUMENTATION
argument_list|,
name|t
argument_list|,
name|JobTrackerInstrumentation
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
DECL|method|getInstrumentation ()
name|JobTrackerInstrumentation
name|getInstrumentation
parameter_list|()
block|{
return|return
name|myInstrumentation
return|;
block|}
DECL|method|getAddress (Configuration conf)
specifier|public
specifier|static
name|InetSocketAddress
name|getAddress
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
name|String
name|jobTrackerStr
init|=
name|conf
operator|.
name|get
argument_list|(
name|JT_IPC_ADDRESS
argument_list|,
literal|"localhost:8012"
argument_list|)
decl_stmt|;
return|return
name|NetUtils
operator|.
name|createSocketAddr
argument_list|(
name|jobTrackerStr
argument_list|)
return|;
block|}
DECL|method|startExpireTrackersThread ()
name|void
name|startExpireTrackersThread
parameter_list|()
block|{
name|this
operator|.
name|expireTrackersThread
operator|=
operator|new
name|Thread
argument_list|(
name|this
operator|.
name|expireTrackers
argument_list|,
literal|"expireTrackers"
argument_list|)
expr_stmt|;
name|this
operator|.
name|expireTrackersThread
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
comment|/**    * Run forever    */
DECL|method|offerService ()
specifier|public
name|void
name|offerService
parameter_list|()
throws|throws
name|InterruptedException
throws|,
name|IOException
block|{
comment|// Prepare for recovery. This is done irrespective of the status of restart
comment|// flag.
while|while
condition|(
literal|true
condition|)
block|{
try|try
block|{
name|recoveryManager
operator|.
name|updateRestartCount
argument_list|()
expr_stmt|;
break|break;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to initialize recovery manager. "
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
comment|// wait for some time
name|Thread
operator|.
name|sleep
argument_list|(
name|FS_ACCESS_RETRY_PERIOD
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
literal|"Retrying..."
argument_list|)
expr_stmt|;
block|}
block|}
name|taskScheduler
operator|.
name|start
argument_list|()
expr_stmt|;
name|recoveryManager
operator|.
name|recover
argument_list|()
expr_stmt|;
comment|// refresh the node list as the recovery manager might have added
comment|// disallowed trackers
name|refreshHosts
argument_list|()
expr_stmt|;
name|startExpireTrackersThread
argument_list|()
expr_stmt|;
name|expireLaunchingTaskThread
operator|.
name|start
argument_list|()
expr_stmt|;
if|if
condition|(
name|completedJobStatusStore
operator|.
name|isActive
argument_list|()
condition|)
block|{
name|completedJobsStoreThread
operator|=
operator|new
name|Thread
argument_list|(
name|completedJobStatusStore
argument_list|,
literal|"completedjobsStore-housekeeper"
argument_list|)
expr_stmt|;
name|completedJobsStoreThread
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
comment|// start the inter-tracker server once the jt is ready
name|this
operator|.
name|interTrackerServer
operator|.
name|start
argument_list|()
expr_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
name|state
operator|=
name|State
operator|.
name|RUNNING
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Starting RUNNING"
argument_list|)
expr_stmt|;
name|this
operator|.
name|interTrackerServer
operator|.
name|join
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Stopped interTrackerServer"
argument_list|)
expr_stmt|;
block|}
DECL|method|close ()
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|plugins
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|ServicePlugin
name|p
range|:
name|plugins
control|)
block|{
try|try
block|{
name|p
operator|.
name|stop
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Stopped plug-in "
operator|+
name|p
operator|+
literal|" of type "
operator|+
name|p
operator|.
name|getClass
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"ServicePlugin "
operator|+
name|p
operator|+
literal|" of type "
operator|+
name|p
operator|.
name|getClass
argument_list|()
operator|+
literal|" could not be stopped"
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|this
operator|.
name|infoServer
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Stopping infoServer"
argument_list|)
expr_stmt|;
try|try
block|{
name|this
operator|.
name|infoServer
operator|.
name|stop
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Exception shutting down JobTracker"
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|this
operator|.
name|interTrackerServer
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Stopping interTrackerServer"
argument_list|)
expr_stmt|;
name|this
operator|.
name|interTrackerServer
operator|.
name|stop
argument_list|()
expr_stmt|;
block|}
name|stopExpireTrackersThread
argument_list|()
expr_stmt|;
if|if
condition|(
name|taskScheduler
operator|!=
literal|null
condition|)
block|{
name|taskScheduler
operator|.
name|terminate
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|this
operator|.
name|expireLaunchingTaskThread
operator|!=
literal|null
operator|&&
name|this
operator|.
name|expireLaunchingTaskThread
operator|.
name|isAlive
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Stopping expireLaunchingTasks"
argument_list|)
expr_stmt|;
name|this
operator|.
name|expireLaunchingTaskThread
operator|.
name|interrupt
argument_list|()
expr_stmt|;
try|try
block|{
name|this
operator|.
name|expireLaunchingTaskThread
operator|.
name|join
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ex
parameter_list|)
block|{
name|ex
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|this
operator|.
name|completedJobsStoreThread
operator|!=
literal|null
operator|&&
name|this
operator|.
name|completedJobsStoreThread
operator|.
name|isAlive
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Stopping completedJobsStore thread"
argument_list|)
expr_stmt|;
name|this
operator|.
name|completedJobsStoreThread
operator|.
name|interrupt
argument_list|()
expr_stmt|;
try|try
block|{
name|this
operator|.
name|completedJobsStoreThread
operator|.
name|join
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ex
parameter_list|)
block|{
name|ex
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|jobHistory
operator|!=
literal|null
condition|)
block|{
name|jobHistory
operator|.
name|shutDown
argument_list|()
expr_stmt|;
block|}
name|DelegationTokenRenewal
operator|.
name|close
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"stopped all jobtracker services"
argument_list|)
expr_stmt|;
return|return;
block|}
DECL|method|stopExpireTrackersThread ()
name|void
name|stopExpireTrackersThread
parameter_list|()
block|{
if|if
condition|(
name|this
operator|.
name|expireTrackersThread
operator|!=
literal|null
operator|&&
name|this
operator|.
name|expireTrackersThread
operator|.
name|isAlive
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Stopping expireTrackers"
argument_list|)
expr_stmt|;
name|this
operator|.
name|expireTrackersThread
operator|.
name|interrupt
argument_list|()
expr_stmt|;
try|try
block|{
name|this
operator|.
name|expireTrackersThread
operator|.
name|join
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ex
parameter_list|)
block|{
name|ex
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|///////////////////////////////////////////////////////
comment|// Maintain lookup tables; called by JobInProgress
comment|// and TaskInProgress
comment|///////////////////////////////////////////////////////
DECL|method|createTaskEntry (TaskAttemptID taskid, String taskTracker, TaskInProgress tip)
name|void
name|createTaskEntry
parameter_list|(
name|TaskAttemptID
name|taskid
parameter_list|,
name|String
name|taskTracker
parameter_list|,
name|TaskInProgress
name|tip
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Adding task ("
operator|+
name|tip
operator|.
name|getAttemptType
argument_list|(
name|taskid
argument_list|)
operator|+
literal|") "
operator|+
literal|"'"
operator|+
name|taskid
operator|+
literal|"' to tip "
operator|+
name|tip
operator|.
name|getTIPId
argument_list|()
operator|+
literal|", for tracker '"
operator|+
name|taskTracker
operator|+
literal|"'"
argument_list|)
expr_stmt|;
comment|// taskid --> tracker
name|taskidToTrackerMap
operator|.
name|put
argument_list|(
name|taskid
argument_list|,
name|taskTracker
argument_list|)
expr_stmt|;
comment|// tracker --> taskid
name|Set
argument_list|<
name|TaskAttemptID
argument_list|>
name|taskset
init|=
name|trackerToTaskMap
operator|.
name|get
argument_list|(
name|taskTracker
argument_list|)
decl_stmt|;
if|if
condition|(
name|taskset
operator|==
literal|null
condition|)
block|{
name|taskset
operator|=
operator|new
name|TreeSet
argument_list|<
name|TaskAttemptID
argument_list|>
argument_list|()
expr_stmt|;
name|trackerToTaskMap
operator|.
name|put
argument_list|(
name|taskTracker
argument_list|,
name|taskset
argument_list|)
expr_stmt|;
block|}
name|taskset
operator|.
name|add
argument_list|(
name|taskid
argument_list|)
expr_stmt|;
comment|// taskid --> TIP
name|taskidToTIPMap
operator|.
name|put
argument_list|(
name|taskid
argument_list|,
name|tip
argument_list|)
expr_stmt|;
block|}
DECL|method|removeTaskEntry (TaskAttemptID taskid)
name|void
name|removeTaskEntry
parameter_list|(
name|TaskAttemptID
name|taskid
parameter_list|)
block|{
comment|// taskid --> tracker
name|String
name|tracker
init|=
name|taskidToTrackerMap
operator|.
name|remove
argument_list|(
name|taskid
argument_list|)
decl_stmt|;
comment|// tracker --> taskid
if|if
condition|(
name|tracker
operator|!=
literal|null
condition|)
block|{
name|Set
argument_list|<
name|TaskAttemptID
argument_list|>
name|trackerSet
init|=
name|trackerToTaskMap
operator|.
name|get
argument_list|(
name|tracker
argument_list|)
decl_stmt|;
if|if
condition|(
name|trackerSet
operator|!=
literal|null
condition|)
block|{
name|trackerSet
operator|.
name|remove
argument_list|(
name|taskid
argument_list|)
expr_stmt|;
block|}
block|}
comment|// taskid --> TIP
if|if
condition|(
name|taskidToTIPMap
operator|.
name|remove
argument_list|(
name|taskid
argument_list|)
operator|!=
literal|null
condition|)
block|{
comment|// log the task removal in case of success
name|LOG
operator|.
name|info
argument_list|(
literal|"Removing task '"
operator|+
name|taskid
operator|+
literal|"'"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Mark a 'task' for removal later.    * This function assumes that the JobTracker is locked on entry.    *     * @param taskTracker the tasktracker at which the 'task' was running    * @param taskid completed (success/failure/killed) task    */
DECL|method|markCompletedTaskAttempt (String taskTracker, TaskAttemptID taskid)
name|void
name|markCompletedTaskAttempt
parameter_list|(
name|String
name|taskTracker
parameter_list|,
name|TaskAttemptID
name|taskid
parameter_list|)
block|{
comment|// tracker --> taskid
name|Set
argument_list|<
name|TaskAttemptID
argument_list|>
name|taskset
init|=
name|trackerToMarkedTasksMap
operator|.
name|get
argument_list|(
name|taskTracker
argument_list|)
decl_stmt|;
if|if
condition|(
name|taskset
operator|==
literal|null
condition|)
block|{
name|taskset
operator|=
operator|new
name|TreeSet
argument_list|<
name|TaskAttemptID
argument_list|>
argument_list|()
expr_stmt|;
name|trackerToMarkedTasksMap
operator|.
name|put
argument_list|(
name|taskTracker
argument_list|,
name|taskset
argument_list|)
expr_stmt|;
block|}
name|taskset
operator|.
name|add
argument_list|(
name|taskid
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Marked '"
operator|+
name|taskid
operator|+
literal|"' from '"
operator|+
name|taskTracker
operator|+
literal|"'"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Mark all 'non-running' jobs of the job for pruning.    * This function assumes that the JobTracker is locked on entry.    *     * @param job the completed job    */
DECL|method|markCompletedJob (JobInProgress job)
name|void
name|markCompletedJob
parameter_list|(
name|JobInProgress
name|job
parameter_list|)
block|{
for|for
control|(
name|TaskInProgress
name|tip
range|:
name|job
operator|.
name|getTasks
argument_list|(
name|TaskType
operator|.
name|JOB_SETUP
argument_list|)
control|)
block|{
for|for
control|(
name|TaskStatus
name|taskStatus
range|:
name|tip
operator|.
name|getTaskStatuses
argument_list|()
control|)
block|{
if|if
condition|(
name|taskStatus
operator|.
name|getRunState
argument_list|()
operator|!=
name|TaskStatus
operator|.
name|State
operator|.
name|RUNNING
operator|&&
name|taskStatus
operator|.
name|getRunState
argument_list|()
operator|!=
name|TaskStatus
operator|.
name|State
operator|.
name|COMMIT_PENDING
operator|&&
name|taskStatus
operator|.
name|getRunState
argument_list|()
operator|!=
name|TaskStatus
operator|.
name|State
operator|.
name|UNASSIGNED
condition|)
block|{
name|markCompletedTaskAttempt
argument_list|(
name|taskStatus
operator|.
name|getTaskTracker
argument_list|()
argument_list|,
name|taskStatus
operator|.
name|getTaskID
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
for|for
control|(
name|TaskInProgress
name|tip
range|:
name|job
operator|.
name|getTasks
argument_list|(
name|TaskType
operator|.
name|MAP
argument_list|)
control|)
block|{
for|for
control|(
name|TaskStatus
name|taskStatus
range|:
name|tip
operator|.
name|getTaskStatuses
argument_list|()
control|)
block|{
if|if
condition|(
name|taskStatus
operator|.
name|getRunState
argument_list|()
operator|!=
name|TaskStatus
operator|.
name|State
operator|.
name|RUNNING
operator|&&
name|taskStatus
operator|.
name|getRunState
argument_list|()
operator|!=
name|TaskStatus
operator|.
name|State
operator|.
name|COMMIT_PENDING
operator|&&
name|taskStatus
operator|.
name|getRunState
argument_list|()
operator|!=
name|TaskStatus
operator|.
name|State
operator|.
name|FAILED_UNCLEAN
operator|&&
name|taskStatus
operator|.
name|getRunState
argument_list|()
operator|!=
name|TaskStatus
operator|.
name|State
operator|.
name|KILLED_UNCLEAN
operator|&&
name|taskStatus
operator|.
name|getRunState
argument_list|()
operator|!=
name|TaskStatus
operator|.
name|State
operator|.
name|UNASSIGNED
condition|)
block|{
name|markCompletedTaskAttempt
argument_list|(
name|taskStatus
operator|.
name|getTaskTracker
argument_list|()
argument_list|,
name|taskStatus
operator|.
name|getTaskID
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
for|for
control|(
name|TaskInProgress
name|tip
range|:
name|job
operator|.
name|getTasks
argument_list|(
name|TaskType
operator|.
name|REDUCE
argument_list|)
control|)
block|{
for|for
control|(
name|TaskStatus
name|taskStatus
range|:
name|tip
operator|.
name|getTaskStatuses
argument_list|()
control|)
block|{
if|if
condition|(
name|taskStatus
operator|.
name|getRunState
argument_list|()
operator|!=
name|TaskStatus
operator|.
name|State
operator|.
name|RUNNING
operator|&&
name|taskStatus
operator|.
name|getRunState
argument_list|()
operator|!=
name|TaskStatus
operator|.
name|State
operator|.
name|COMMIT_PENDING
operator|&&
name|taskStatus
operator|.
name|getRunState
argument_list|()
operator|!=
name|TaskStatus
operator|.
name|State
operator|.
name|FAILED_UNCLEAN
operator|&&
name|taskStatus
operator|.
name|getRunState
argument_list|()
operator|!=
name|TaskStatus
operator|.
name|State
operator|.
name|KILLED_UNCLEAN
operator|&&
name|taskStatus
operator|.
name|getRunState
argument_list|()
operator|!=
name|TaskStatus
operator|.
name|State
operator|.
name|UNASSIGNED
condition|)
block|{
name|markCompletedTaskAttempt
argument_list|(
name|taskStatus
operator|.
name|getTaskTracker
argument_list|()
argument_list|,
name|taskStatus
operator|.
name|getTaskID
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**    * Remove all 'marked' tasks running on a given {@link TaskTracker}    * from the {@link JobTracker}'s data-structures.    * This function assumes that the JobTracker is locked on entry.    *     * @param taskTracker tasktracker whose 'non-running' tasks are to be purged    */
DECL|method|removeMarkedTasks (String taskTracker)
name|void
name|removeMarkedTasks
parameter_list|(
name|String
name|taskTracker
parameter_list|)
block|{
comment|// Purge all the 'marked' tasks which were running at taskTracker
name|Set
argument_list|<
name|TaskAttemptID
argument_list|>
name|markedTaskSet
init|=
name|trackerToMarkedTasksMap
operator|.
name|get
argument_list|(
name|taskTracker
argument_list|)
decl_stmt|;
if|if
condition|(
name|markedTaskSet
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|TaskAttemptID
name|taskid
range|:
name|markedTaskSet
control|)
block|{
name|removeTaskEntry
argument_list|(
name|taskid
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Removed marked completed task '"
operator|+
name|taskid
operator|+
literal|"' from '"
operator|+
name|taskTracker
operator|+
literal|"'"
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Clear
name|trackerToMarkedTasksMap
operator|.
name|remove
argument_list|(
name|taskTracker
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Call {@link #removeTaskEntry(String)} for each of the    * job's tasks.    * When the job is retiring we can afford to nuke all it's tasks    *     * @param job the job about to be 'retired'    */
DECL|method|removeJobTasks (JobInProgress job)
specifier|synchronized
name|void
name|removeJobTasks
parameter_list|(
name|JobInProgress
name|job
parameter_list|)
block|{
comment|// iterate over all the task types
for|for
control|(
name|TaskType
name|type
range|:
name|TaskType
operator|.
name|values
argument_list|()
control|)
block|{
comment|// iterate over all the tips of the type under consideration
for|for
control|(
name|TaskInProgress
name|tip
range|:
name|job
operator|.
name|getTasks
argument_list|(
name|type
argument_list|)
control|)
block|{
comment|// iterate over all the task-ids in the tip under consideration
for|for
control|(
name|TaskAttemptID
name|id
range|:
name|tip
operator|.
name|getAllTaskAttemptIDs
argument_list|()
control|)
block|{
comment|// remove the task-id entry from the jobtracker
name|removeTaskEntry
argument_list|(
name|id
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**    * Safe clean-up all data structures at the end of the     * job (success/failure/killed).    * Here we also ensure that for a given user we maintain     * information for only MAX_COMPLETE_USER_JOBS_IN_MEMORY jobs     * on the JobTracker.    *      * @param job completed job.    */
DECL|method|finalizeJob (JobInProgress job)
specifier|synchronized
name|void
name|finalizeJob
parameter_list|(
name|JobInProgress
name|job
parameter_list|)
block|{
comment|// Mark the 'non-running' tasks for pruning
name|markCompletedJob
argument_list|(
name|job
argument_list|)
expr_stmt|;
name|JobEndNotifier
operator|.
name|registerNotification
argument_list|(
name|job
operator|.
name|getJobConf
argument_list|()
argument_list|,
name|job
operator|.
name|getStatus
argument_list|()
argument_list|)
expr_stmt|;
comment|// start the merge of log files
name|JobID
name|id
init|=
name|job
operator|.
name|getStatus
argument_list|()
operator|.
name|getJobID
argument_list|()
decl_stmt|;
comment|// mark the job as completed
try|try
block|{
name|jobHistory
operator|.
name|markCompleted
argument_list|(
name|id
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Failed to mark job "
operator|+
name|id
operator|+
literal|" as completed!"
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
block|}
specifier|final
name|JobTrackerInstrumentation
name|metrics
init|=
name|getInstrumentation
argument_list|()
decl_stmt|;
name|metrics
operator|.
name|finalizeJob
argument_list|(
name|conf
argument_list|,
name|id
argument_list|)
expr_stmt|;
comment|// mark the job for cleanup at all the trackers
name|addJobForCleanup
argument_list|(
name|id
argument_list|)
expr_stmt|;
comment|// add the blacklisted trackers to potentially faulty list
if|if
condition|(
name|job
operator|.
name|getStatus
argument_list|()
operator|.
name|getRunState
argument_list|()
operator|==
name|JobStatus
operator|.
name|SUCCEEDED
condition|)
block|{
if|if
condition|(
name|job
operator|.
name|getNoOfBlackListedTrackers
argument_list|()
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|String
name|hostName
range|:
name|job
operator|.
name|getBlackListedTrackers
argument_list|()
control|)
block|{
name|faultyTrackers
operator|.
name|incrementFaults
argument_list|(
name|hostName
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|///////////////////////////////////////////////////////
comment|// Accessors for objects that want info on jobs, tasks,
comment|// trackers, etc.
comment|///////////////////////////////////////////////////////
DECL|method|getTotalSubmissions ()
specifier|public
name|int
name|getTotalSubmissions
parameter_list|()
block|{
return|return
name|totalSubmissions
return|;
block|}
DECL|method|getJobTrackerMachine ()
specifier|public
name|String
name|getJobTrackerMachine
parameter_list|()
block|{
return|return
name|localMachine
return|;
block|}
comment|/**    * Get the unique identifier (ie. timestamp) of this job tracker start.    * @return a string with a unique identifier    */
DECL|method|getTrackerIdentifier ()
specifier|public
name|String
name|getTrackerIdentifier
parameter_list|()
block|{
return|return
name|trackerIdentifier
return|;
block|}
DECL|method|getTrackerPort ()
specifier|public
name|int
name|getTrackerPort
parameter_list|()
block|{
return|return
name|port
return|;
block|}
DECL|method|getInfoPort ()
specifier|public
name|int
name|getInfoPort
parameter_list|()
block|{
return|return
name|infoPort
return|;
block|}
DECL|method|getStartTime ()
specifier|public
name|long
name|getStartTime
parameter_list|()
block|{
return|return
name|startTime
return|;
block|}
DECL|method|runningJobs ()
specifier|public
name|Vector
argument_list|<
name|JobInProgress
argument_list|>
name|runningJobs
parameter_list|()
block|{
name|Vector
argument_list|<
name|JobInProgress
argument_list|>
name|v
init|=
operator|new
name|Vector
argument_list|<
name|JobInProgress
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Iterator
name|it
init|=
name|jobs
operator|.
name|values
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|JobInProgress
name|jip
init|=
operator|(
name|JobInProgress
operator|)
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|JobStatus
name|status
init|=
name|jip
operator|.
name|getStatus
argument_list|()
decl_stmt|;
if|if
condition|(
name|status
operator|.
name|getRunState
argument_list|()
operator|==
name|JobStatus
operator|.
name|RUNNING
condition|)
block|{
name|v
operator|.
name|add
argument_list|(
name|jip
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|v
return|;
block|}
comment|/**    * Version that is called from a timer thread, and therefore needs to be    * careful to synchronize.    */
DECL|method|getRunningJobs ()
specifier|public
specifier|synchronized
name|List
argument_list|<
name|JobInProgress
argument_list|>
name|getRunningJobs
parameter_list|()
block|{
synchronized|synchronized
init|(
name|jobs
init|)
block|{
return|return
name|runningJobs
argument_list|()
return|;
block|}
block|}
DECL|method|failedJobs ()
specifier|public
name|Vector
argument_list|<
name|JobInProgress
argument_list|>
name|failedJobs
parameter_list|()
block|{
name|Vector
argument_list|<
name|JobInProgress
argument_list|>
name|v
init|=
operator|new
name|Vector
argument_list|<
name|JobInProgress
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Iterator
name|it
init|=
name|jobs
operator|.
name|values
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|JobInProgress
name|jip
init|=
operator|(
name|JobInProgress
operator|)
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|JobStatus
name|status
init|=
name|jip
operator|.
name|getStatus
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|status
operator|.
name|getRunState
argument_list|()
operator|==
name|JobStatus
operator|.
name|FAILED
operator|)
operator|||
operator|(
name|status
operator|.
name|getRunState
argument_list|()
operator|==
name|JobStatus
operator|.
name|KILLED
operator|)
condition|)
block|{
name|v
operator|.
name|add
argument_list|(
name|jip
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|v
return|;
block|}
DECL|method|getFailedJobs ()
specifier|public
specifier|synchronized
name|List
argument_list|<
name|JobInProgress
argument_list|>
name|getFailedJobs
parameter_list|()
block|{
synchronized|synchronized
init|(
name|jobs
init|)
block|{
return|return
name|failedJobs
argument_list|()
return|;
block|}
block|}
DECL|method|completedJobs ()
specifier|public
name|Vector
argument_list|<
name|JobInProgress
argument_list|>
name|completedJobs
parameter_list|()
block|{
name|Vector
argument_list|<
name|JobInProgress
argument_list|>
name|v
init|=
operator|new
name|Vector
argument_list|<
name|JobInProgress
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Iterator
name|it
init|=
name|jobs
operator|.
name|values
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|JobInProgress
name|jip
init|=
operator|(
name|JobInProgress
operator|)
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|JobStatus
name|status
init|=
name|jip
operator|.
name|getStatus
argument_list|()
decl_stmt|;
if|if
condition|(
name|status
operator|.
name|getRunState
argument_list|()
operator|==
name|JobStatus
operator|.
name|SUCCEEDED
condition|)
block|{
name|v
operator|.
name|add
argument_list|(
name|jip
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|v
return|;
block|}
DECL|method|getCompletedJobs ()
specifier|public
specifier|synchronized
name|List
argument_list|<
name|JobInProgress
argument_list|>
name|getCompletedJobs
parameter_list|()
block|{
synchronized|synchronized
init|(
name|jobs
init|)
block|{
return|return
name|completedJobs
argument_list|()
return|;
block|}
block|}
comment|/**    * Get all the task trackers in the cluster    *     * @return {@link Collection} of {@link TaskTrackerStatus}     */
comment|// lock to taskTrackers should hold JT lock first.
DECL|method|taskTrackers ()
specifier|public
specifier|synchronized
name|Collection
argument_list|<
name|TaskTrackerStatus
argument_list|>
name|taskTrackers
parameter_list|()
block|{
name|Collection
argument_list|<
name|TaskTrackerStatus
argument_list|>
name|ttStatuses
decl_stmt|;
synchronized|synchronized
init|(
name|taskTrackers
init|)
block|{
name|ttStatuses
operator|=
operator|new
name|ArrayList
argument_list|<
name|TaskTrackerStatus
argument_list|>
argument_list|(
name|taskTrackers
operator|.
name|values
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|TaskTracker
name|tt
range|:
name|taskTrackers
operator|.
name|values
argument_list|()
control|)
block|{
name|ttStatuses
operator|.
name|add
argument_list|(
name|tt
operator|.
name|getStatus
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|ttStatuses
return|;
block|}
comment|/**    * Get the active task tracker statuses in the cluster    *      * @return {@link Collection} of active {@link TaskTrackerStatus}     */
comment|// This method is synchronized to make sure that the locking order
comment|// "taskTrackers lock followed by faultyTrackers.potentiallyFaultyTrackers
comment|// lock" is under JobTracker lock to avoid deadlocks.
DECL|method|activeTaskTrackers ()
specifier|synchronized
specifier|public
name|Collection
argument_list|<
name|TaskTrackerStatus
argument_list|>
name|activeTaskTrackers
parameter_list|()
block|{
name|Collection
argument_list|<
name|TaskTrackerStatus
argument_list|>
name|activeTrackers
init|=
operator|new
name|ArrayList
argument_list|<
name|TaskTrackerStatus
argument_list|>
argument_list|()
decl_stmt|;
synchronized|synchronized
init|(
name|taskTrackers
init|)
block|{
for|for
control|(
name|TaskTracker
name|tt
range|:
name|taskTrackers
operator|.
name|values
argument_list|()
control|)
block|{
name|TaskTrackerStatus
name|status
init|=
name|tt
operator|.
name|getStatus
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|faultyTrackers
operator|.
name|isBlacklisted
argument_list|(
name|status
operator|.
name|getHost
argument_list|()
argument_list|)
condition|)
block|{
name|activeTrackers
operator|.
name|add
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|activeTrackers
return|;
block|}
comment|/**    * Get the active and blacklisted task tracker names in the cluster. The first    * element in the returned list contains the list of active tracker names.    * The second element in the returned list contains the list of blacklisted    * tracker names.     */
comment|// This method is synchronized to make sure that the locking order
comment|// "taskTrackers lock followed by faultyTrackers.potentiallyFaultyTrackers
comment|// lock" is under JobTracker lock to avoid deadlocks.
DECL|method|taskTrackerNames ()
specifier|synchronized
specifier|public
name|List
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|taskTrackerNames
parameter_list|()
block|{
name|List
argument_list|<
name|String
argument_list|>
name|activeTrackers
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|blacklistedTrackers
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
synchronized|synchronized
init|(
name|taskTrackers
init|)
block|{
for|for
control|(
name|TaskTracker
name|tt
range|:
name|taskTrackers
operator|.
name|values
argument_list|()
control|)
block|{
name|TaskTrackerStatus
name|status
init|=
name|tt
operator|.
name|getStatus
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|faultyTrackers
operator|.
name|isBlacklisted
argument_list|(
name|status
operator|.
name|getHost
argument_list|()
argument_list|)
condition|)
block|{
name|activeTrackers
operator|.
name|add
argument_list|(
name|status
operator|.
name|getTrackerName
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|blacklistedTrackers
operator|.
name|add
argument_list|(
name|status
operator|.
name|getTrackerName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|List
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|result
init|=
operator|new
name|ArrayList
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
argument_list|(
literal|2
argument_list|)
decl_stmt|;
name|result
operator|.
name|add
argument_list|(
name|activeTrackers
argument_list|)
expr_stmt|;
name|result
operator|.
name|add
argument_list|(
name|blacklistedTrackers
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
comment|/**    * Get the blacklisted task tracker statuses in the cluster    *      * @return {@link Collection} of blacklisted {@link TaskTrackerStatus}     */
comment|// This method is synchronized to make sure that the locking order
comment|// "taskTrackers lock followed by faultyTrackers.potentiallyFaultyTrackers
comment|// lock" is under JobTracker lock to avoid deadlocks.
DECL|method|blacklistedTaskTrackers ()
specifier|synchronized
specifier|public
name|Collection
argument_list|<
name|TaskTrackerStatus
argument_list|>
name|blacklistedTaskTrackers
parameter_list|()
block|{
name|Collection
argument_list|<
name|TaskTrackerStatus
argument_list|>
name|blacklistedTrackers
init|=
operator|new
name|ArrayList
argument_list|<
name|TaskTrackerStatus
argument_list|>
argument_list|()
decl_stmt|;
synchronized|synchronized
init|(
name|taskTrackers
init|)
block|{
for|for
control|(
name|TaskTracker
name|tt
range|:
name|taskTrackers
operator|.
name|values
argument_list|()
control|)
block|{
name|TaskTrackerStatus
name|status
init|=
name|tt
operator|.
name|getStatus
argument_list|()
decl_stmt|;
if|if
condition|(
name|faultyTrackers
operator|.
name|isBlacklisted
argument_list|(
name|status
operator|.
name|getHost
argument_list|()
argument_list|)
condition|)
block|{
name|blacklistedTrackers
operator|.
name|add
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|blacklistedTrackers
return|;
block|}
DECL|method|getFaultCount (String hostName)
specifier|synchronized
name|int
name|getFaultCount
parameter_list|(
name|String
name|hostName
parameter_list|)
block|{
return|return
name|faultyTrackers
operator|.
name|getFaultCount
argument_list|(
name|hostName
argument_list|)
return|;
block|}
comment|/**    * Get the number of blacklisted trackers across all the jobs    *     * @return    */
DECL|method|getBlacklistedTrackerCount ()
name|int
name|getBlacklistedTrackerCount
parameter_list|()
block|{
return|return
name|faultyTrackers
operator|.
name|numBlacklistedTrackers
return|;
block|}
comment|/**    * Whether the tracker is blacklisted or not    *     * @param trackerID    *     * @return true if blacklisted, false otherwise    */
DECL|method|isBlacklisted (String trackerID)
specifier|synchronized
specifier|public
name|boolean
name|isBlacklisted
parameter_list|(
name|String
name|trackerID
parameter_list|)
block|{
name|TaskTrackerStatus
name|status
init|=
name|getTaskTrackerStatus
argument_list|(
name|trackerID
argument_list|)
decl_stmt|;
if|if
condition|(
name|status
operator|!=
literal|null
condition|)
block|{
return|return
name|faultyTrackers
operator|.
name|isBlacklisted
argument_list|(
name|status
operator|.
name|getHost
argument_list|()
argument_list|)
return|;
block|}
return|return
literal|false
return|;
block|}
comment|// lock to taskTrackers should hold JT lock first.
DECL|method|getTaskTrackerStatus (String trackerID)
specifier|synchronized
specifier|public
name|TaskTrackerStatus
name|getTaskTrackerStatus
parameter_list|(
name|String
name|trackerID
parameter_list|)
block|{
name|TaskTracker
name|taskTracker
decl_stmt|;
synchronized|synchronized
init|(
name|taskTrackers
init|)
block|{
name|taskTracker
operator|=
name|taskTrackers
operator|.
name|get
argument_list|(
name|trackerID
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|taskTracker
operator|==
literal|null
operator|)
condition|?
literal|null
else|:
name|taskTracker
operator|.
name|getStatus
argument_list|()
return|;
block|}
comment|// lock to taskTrackers should hold JT lock first.
DECL|method|getTaskTracker (String trackerID)
specifier|synchronized
specifier|public
name|TaskTracker
name|getTaskTracker
parameter_list|(
name|String
name|trackerID
parameter_list|)
block|{
synchronized|synchronized
init|(
name|taskTrackers
init|)
block|{
return|return
name|taskTrackers
operator|.
name|get
argument_list|(
name|trackerID
argument_list|)
return|;
block|}
block|}
DECL|method|getStatistics ()
name|JobTrackerStatistics
name|getStatistics
parameter_list|()
block|{
return|return
name|statistics
return|;
block|}
comment|/**    * Adds a new node to the jobtracker. It involves adding it to the expiry    * thread and adding it for resolution    *     * Assumes JobTracker, taskTrackers and trackerExpiryQueue are locked on entry    *     * @param status Task Tracker's status    */
DECL|method|addNewTracker (TaskTracker taskTracker)
name|void
name|addNewTracker
parameter_list|(
name|TaskTracker
name|taskTracker
parameter_list|)
block|{
name|TaskTrackerStatus
name|status
init|=
name|taskTracker
operator|.
name|getStatus
argument_list|()
decl_stmt|;
name|trackerExpiryQueue
operator|.
name|add
argument_list|(
name|status
argument_list|)
expr_stmt|;
comment|//  Register the tracker if its not registered
name|String
name|hostname
init|=
name|status
operator|.
name|getHost
argument_list|()
decl_stmt|;
if|if
condition|(
name|getNode
argument_list|(
name|status
operator|.
name|getTrackerName
argument_list|()
argument_list|)
operator|==
literal|null
condition|)
block|{
comment|// Making the network location resolution inline ..
name|resolveAndAddToTopology
argument_list|(
name|hostname
argument_list|)
expr_stmt|;
block|}
comment|// add it to the set of tracker per host
name|Set
argument_list|<
name|TaskTracker
argument_list|>
name|trackers
init|=
name|hostnameToTaskTracker
operator|.
name|get
argument_list|(
name|hostname
argument_list|)
decl_stmt|;
if|if
condition|(
name|trackers
operator|==
literal|null
condition|)
block|{
name|trackers
operator|=
name|Collections
operator|.
name|synchronizedSet
argument_list|(
operator|new
name|HashSet
argument_list|<
name|TaskTracker
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
name|hostnameToTaskTracker
operator|.
name|put
argument_list|(
name|hostname
argument_list|,
name|trackers
argument_list|)
expr_stmt|;
block|}
name|statistics
operator|.
name|taskTrackerAdded
argument_list|(
name|status
operator|.
name|getTrackerName
argument_list|()
argument_list|)
expr_stmt|;
name|getInstrumentation
argument_list|()
operator|.
name|addTrackers
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Adding tracker "
operator|+
name|status
operator|.
name|getTrackerName
argument_list|()
operator|+
literal|" to host "
operator|+
name|hostname
argument_list|)
expr_stmt|;
name|trackers
operator|.
name|add
argument_list|(
name|taskTracker
argument_list|)
expr_stmt|;
block|}
DECL|method|resolveAndAddToTopology (String name)
specifier|public
name|Node
name|resolveAndAddToTopology
parameter_list|(
name|String
name|name
parameter_list|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|tmpList
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|tmpList
operator|.
name|add
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|rNameList
init|=
name|dnsToSwitchMapping
operator|.
name|resolve
argument_list|(
name|tmpList
argument_list|)
decl_stmt|;
name|String
name|rName
init|=
name|rNameList
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|String
name|networkLoc
init|=
name|NodeBase
operator|.
name|normalize
argument_list|(
name|rName
argument_list|)
decl_stmt|;
return|return
name|addHostToNodeMapping
argument_list|(
name|name
argument_list|,
name|networkLoc
argument_list|)
return|;
block|}
DECL|method|addHostToNodeMapping (String host, String networkLoc)
specifier|private
name|Node
name|addHostToNodeMapping
parameter_list|(
name|String
name|host
parameter_list|,
name|String
name|networkLoc
parameter_list|)
block|{
name|Node
name|node
init|=
literal|null
decl_stmt|;
synchronized|synchronized
init|(
name|nodesAtMaxLevel
init|)
block|{
if|if
condition|(
operator|(
name|node
operator|=
name|clusterMap
operator|.
name|getNode
argument_list|(
name|networkLoc
operator|+
literal|"/"
operator|+
name|host
argument_list|)
operator|)
operator|==
literal|null
condition|)
block|{
name|node
operator|=
operator|new
name|NodeBase
argument_list|(
name|host
argument_list|,
name|networkLoc
argument_list|)
expr_stmt|;
name|clusterMap
operator|.
name|add
argument_list|(
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|.
name|getLevel
argument_list|()
operator|<
name|getNumTaskCacheLevels
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|fatal
argument_list|(
literal|"Got a host whose level is: "
operator|+
name|node
operator|.
name|getLevel
argument_list|()
operator|+
literal|"."
operator|+
literal|" Should get at least a level of value: "
operator|+
name|getNumTaskCacheLevels
argument_list|()
argument_list|)
expr_stmt|;
try|try
block|{
name|stopTracker
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ie
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Exception encountered during shutdown: "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|ie
argument_list|)
argument_list|)
expr_stmt|;
name|System
operator|.
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|hostnameToNodeMap
operator|.
name|put
argument_list|(
name|host
argument_list|,
name|node
argument_list|)
expr_stmt|;
comment|// Make an entry for the node at the max level in the cache
name|nodesAtMaxLevel
operator|.
name|add
argument_list|(
name|getParentNode
argument_list|(
name|node
argument_list|,
name|getNumTaskCacheLevels
argument_list|()
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|node
return|;
block|}
comment|/**    * Returns a collection of nodes at the max level    */
DECL|method|getNodesAtMaxLevel ()
specifier|public
name|Collection
argument_list|<
name|Node
argument_list|>
name|getNodesAtMaxLevel
parameter_list|()
block|{
return|return
name|nodesAtMaxLevel
return|;
block|}
DECL|method|getParentNode (Node node, int level)
specifier|public
specifier|static
name|Node
name|getParentNode
parameter_list|(
name|Node
name|node
parameter_list|,
name|int
name|level
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|level
condition|;
operator|++
name|i
control|)
block|{
name|node
operator|=
name|node
operator|.
name|getParent
argument_list|()
expr_stmt|;
block|}
return|return
name|node
return|;
block|}
comment|/**    * Return the Node in the network topology that corresponds to the hostname    */
DECL|method|getNode (String name)
specifier|public
name|Node
name|getNode
parameter_list|(
name|String
name|name
parameter_list|)
block|{
return|return
name|hostnameToNodeMap
operator|.
name|get
argument_list|(
name|name
argument_list|)
return|;
block|}
DECL|method|getNumTaskCacheLevels ()
specifier|public
name|int
name|getNumTaskCacheLevels
parameter_list|()
block|{
return|return
name|numTaskCacheLevels
return|;
block|}
DECL|method|getNumResolvedTaskTrackers ()
specifier|public
name|int
name|getNumResolvedTaskTrackers
parameter_list|()
block|{
return|return
name|numResolved
return|;
block|}
DECL|method|getNumberOfUniqueHosts ()
specifier|public
name|int
name|getNumberOfUniqueHosts
parameter_list|()
block|{
return|return
name|uniqueHostsMap
operator|.
name|size
argument_list|()
return|;
block|}
DECL|method|addJobInProgressListener (JobInProgressListener listener)
specifier|public
name|void
name|addJobInProgressListener
parameter_list|(
name|JobInProgressListener
name|listener
parameter_list|)
block|{
name|jobInProgressListeners
operator|.
name|add
argument_list|(
name|listener
argument_list|)
expr_stmt|;
block|}
DECL|method|removeJobInProgressListener (JobInProgressListener listener)
specifier|public
name|void
name|removeJobInProgressListener
parameter_list|(
name|JobInProgressListener
name|listener
parameter_list|)
block|{
name|jobInProgressListeners
operator|.
name|remove
argument_list|(
name|listener
argument_list|)
expr_stmt|;
block|}
comment|// Update the listeners about the job
comment|// Assuming JobTracker is locked on entry.
DECL|method|updateJobInProgressListeners (JobChangeEvent event)
name|void
name|updateJobInProgressListeners
parameter_list|(
name|JobChangeEvent
name|event
parameter_list|)
block|{
for|for
control|(
name|JobInProgressListener
name|listener
range|:
name|jobInProgressListeners
control|)
block|{
name|listener
operator|.
name|jobUpdated
argument_list|(
name|event
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Return the {@link QueueManager} associated with the JobTracker.    */
DECL|method|getQueueManager ()
specifier|public
name|QueueManager
name|getQueueManager
parameter_list|()
block|{
return|return
name|queueManager
return|;
block|}
comment|////////////////////////////////////////////////////
comment|// InterTrackerProtocol
comment|////////////////////////////////////////////////////
DECL|method|getBuildVersion ()
specifier|public
name|String
name|getBuildVersion
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|VersionInfo
operator|.
name|getBuildVersion
argument_list|()
return|;
block|}
comment|/**    * The periodic heartbeat mechanism between the {@link TaskTracker} and    * the {@link JobTracker}.    *     * The {@link JobTracker} processes the status information sent by the     * {@link TaskTracker} and responds with instructions to start/stop     * tasks or jobs, and also 'reset' instructions during contingencies.     */
DECL|method|heartbeat (TaskTrackerStatus status, boolean restarted, boolean initialContact, boolean acceptNewTasks, short responseId)
specifier|public
specifier|synchronized
name|HeartbeatResponse
name|heartbeat
parameter_list|(
name|TaskTrackerStatus
name|status
parameter_list|,
name|boolean
name|restarted
parameter_list|,
name|boolean
name|initialContact
parameter_list|,
name|boolean
name|acceptNewTasks
parameter_list|,
name|short
name|responseId
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Got heartbeat from: "
operator|+
name|status
operator|.
name|getTrackerName
argument_list|()
operator|+
literal|" (restarted: "
operator|+
name|restarted
operator|+
literal|" initialContact: "
operator|+
name|initialContact
operator|+
literal|" acceptNewTasks: "
operator|+
name|acceptNewTasks
operator|+
literal|")"
operator|+
literal|" with responseId: "
operator|+
name|responseId
argument_list|)
expr_stmt|;
block|}
comment|// Make sure heartbeat is from a tasktracker allowed by the jobtracker.
if|if
condition|(
operator|!
name|acceptTaskTracker
argument_list|(
name|status
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|DisallowedTaskTrackerException
argument_list|(
name|status
argument_list|)
throw|;
block|}
comment|// First check if the last heartbeat response got through
name|String
name|trackerName
init|=
name|status
operator|.
name|getTrackerName
argument_list|()
decl_stmt|;
name|long
name|now
init|=
name|clock
operator|.
name|getTime
argument_list|()
decl_stmt|;
name|boolean
name|isBlacklisted
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|restarted
condition|)
block|{
name|faultyTrackers
operator|.
name|markTrackerHealthy
argument_list|(
name|status
operator|.
name|getHost
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|isBlacklisted
operator|=
name|faultyTrackers
operator|.
name|shouldAssignTasksToTracker
argument_list|(
name|status
operator|.
name|getHost
argument_list|()
argument_list|,
name|now
argument_list|)
expr_stmt|;
block|}
name|HeartbeatResponse
name|prevHeartbeatResponse
init|=
name|trackerToHeartbeatResponseMap
operator|.
name|get
argument_list|(
name|trackerName
argument_list|)
decl_stmt|;
if|if
condition|(
name|initialContact
operator|!=
literal|true
condition|)
block|{
comment|// If this isn't the 'initial contact' from the tasktracker,
comment|// there is something seriously wrong if the JobTracker has
comment|// no record of the 'previous heartbeat'; if so, ask the
comment|// tasktracker to re-initialize itself.
if|if
condition|(
name|prevHeartbeatResponse
operator|==
literal|null
condition|)
block|{
comment|// This is the first heartbeat from the old tracker to the newly
comment|// started JobTracker
comment|// Jobtracker might have restarted but no recovery is needed
comment|// otherwise this code should not be reached
name|LOG
operator|.
name|warn
argument_list|(
literal|"Serious problem, cannot find record of 'previous' "
operator|+
literal|"heartbeat for '"
operator|+
name|trackerName
operator|+
literal|"'; reinitializing the tasktracker"
argument_list|)
expr_stmt|;
return|return
operator|new
name|HeartbeatResponse
argument_list|(
name|responseId
argument_list|,
operator|new
name|TaskTrackerAction
index|[]
block|{
operator|new
name|ReinitTrackerAction
argument_list|()
block|}
argument_list|)
return|;
block|}
else|else
block|{
comment|// It is completely safe to not process a 'duplicate' heartbeat from a
comment|// {@link TaskTracker} since it resends the heartbeat when rpcs are
comment|// lost see {@link TaskTracker.transmitHeartbeat()};
comment|// acknowledge it by re-sending the previous response to let the
comment|// {@link TaskTracker} go forward.
if|if
condition|(
name|prevHeartbeatResponse
operator|.
name|getResponseId
argument_list|()
operator|!=
name|responseId
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Ignoring 'duplicate' heartbeat from '"
operator|+
name|trackerName
operator|+
literal|"'; resending the previous 'lost' response"
argument_list|)
expr_stmt|;
return|return
name|prevHeartbeatResponse
return|;
block|}
block|}
block|}
comment|// Process this heartbeat
name|short
name|newResponseId
init|=
call|(
name|short
call|)
argument_list|(
name|responseId
operator|+
literal|1
argument_list|)
decl_stmt|;
name|status
operator|.
name|setLastSeen
argument_list|(
name|now
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|processHeartbeat
argument_list|(
name|status
argument_list|,
name|initialContact
argument_list|)
condition|)
block|{
if|if
condition|(
name|prevHeartbeatResponse
operator|!=
literal|null
condition|)
block|{
name|trackerToHeartbeatResponseMap
operator|.
name|remove
argument_list|(
name|trackerName
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|HeartbeatResponse
argument_list|(
name|newResponseId
argument_list|,
operator|new
name|TaskTrackerAction
index|[]
block|{
operator|new
name|ReinitTrackerAction
argument_list|()
block|}
argument_list|)
return|;
block|}
comment|// Initialize the response to be sent for the heartbeat
name|HeartbeatResponse
name|response
init|=
operator|new
name|HeartbeatResponse
argument_list|(
name|newResponseId
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|TaskTrackerAction
argument_list|>
name|actions
init|=
operator|new
name|ArrayList
argument_list|<
name|TaskTrackerAction
argument_list|>
argument_list|()
decl_stmt|;
name|isBlacklisted
operator|=
name|faultyTrackers
operator|.
name|isBlacklisted
argument_list|(
name|status
operator|.
name|getHost
argument_list|()
argument_list|)
expr_stmt|;
comment|// Check for new tasks to be executed on the tasktracker
if|if
condition|(
name|acceptNewTasks
operator|&&
operator|!
name|isBlacklisted
condition|)
block|{
name|TaskTrackerStatus
name|taskTrackerStatus
init|=
name|getTaskTrackerStatus
argument_list|(
name|trackerName
argument_list|)
decl_stmt|;
if|if
condition|(
name|taskTrackerStatus
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Unknown task tracker polling; ignoring: "
operator|+
name|trackerName
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|List
argument_list|<
name|Task
argument_list|>
name|tasks
init|=
name|getSetupAndCleanupTasks
argument_list|(
name|taskTrackerStatus
argument_list|)
decl_stmt|;
if|if
condition|(
name|tasks
operator|==
literal|null
condition|)
block|{
name|tasks
operator|=
name|taskScheduler
operator|.
name|assignTasks
argument_list|(
name|taskTrackers
operator|.
name|get
argument_list|(
name|trackerName
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tasks
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|Task
name|task
range|:
name|tasks
control|)
block|{
name|expireLaunchingTasks
operator|.
name|addNewTask
argument_list|(
name|task
operator|.
name|getTaskID
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|trackerName
operator|+
literal|" -> LaunchTask: "
operator|+
name|task
operator|.
name|getTaskID
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|actions
operator|.
name|add
argument_list|(
operator|new
name|LaunchTaskAction
argument_list|(
name|task
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|// Check for tasks to be killed
name|List
argument_list|<
name|TaskTrackerAction
argument_list|>
name|killTasksList
init|=
name|getTasksToKill
argument_list|(
name|trackerName
argument_list|)
decl_stmt|;
if|if
condition|(
name|killTasksList
operator|!=
literal|null
condition|)
block|{
name|actions
operator|.
name|addAll
argument_list|(
name|killTasksList
argument_list|)
expr_stmt|;
block|}
comment|// Check for jobs to be killed/cleanedup
name|List
argument_list|<
name|TaskTrackerAction
argument_list|>
name|killJobsList
init|=
name|getJobsForCleanup
argument_list|(
name|trackerName
argument_list|)
decl_stmt|;
if|if
condition|(
name|killJobsList
operator|!=
literal|null
condition|)
block|{
name|actions
operator|.
name|addAll
argument_list|(
name|killJobsList
argument_list|)
expr_stmt|;
block|}
comment|// Check for tasks whose outputs can be saved
name|List
argument_list|<
name|TaskTrackerAction
argument_list|>
name|commitTasksList
init|=
name|getTasksToSave
argument_list|(
name|status
argument_list|)
decl_stmt|;
if|if
condition|(
name|commitTasksList
operator|!=
literal|null
condition|)
block|{
name|actions
operator|.
name|addAll
argument_list|(
name|commitTasksList
argument_list|)
expr_stmt|;
block|}
comment|// calculate next heartbeat interval and put in heartbeat response
name|int
name|nextInterval
init|=
name|getNextHeartbeatInterval
argument_list|()
decl_stmt|;
name|response
operator|.
name|setHeartbeatInterval
argument_list|(
name|nextInterval
argument_list|)
expr_stmt|;
name|response
operator|.
name|setActions
argument_list|(
name|actions
operator|.
name|toArray
argument_list|(
operator|new
name|TaskTrackerAction
index|[
name|actions
operator|.
name|size
argument_list|()
index|]
argument_list|)
argument_list|)
expr_stmt|;
comment|// Update the trackerToHeartbeatResponseMap
name|trackerToHeartbeatResponseMap
operator|.
name|put
argument_list|(
name|trackerName
argument_list|,
name|response
argument_list|)
expr_stmt|;
comment|// Done processing the hearbeat, now remove 'marked' tasks
name|removeMarkedTasks
argument_list|(
name|trackerName
argument_list|)
expr_stmt|;
return|return
name|response
return|;
block|}
comment|/**    * Calculates next heartbeat interval using cluster size.    * Heartbeat interval is incremented by 1 second for every 100 nodes by default.     * @return next heartbeat interval.    */
DECL|method|getNextHeartbeatInterval ()
specifier|public
name|int
name|getNextHeartbeatInterval
parameter_list|()
block|{
comment|// get the no of task trackers
name|int
name|clusterSize
init|=
name|getClusterStatus
argument_list|()
operator|.
name|getTaskTrackers
argument_list|()
decl_stmt|;
name|int
name|heartbeatInterval
init|=
name|Math
operator|.
name|max
argument_list|(
call|(
name|int
call|)
argument_list|(
literal|1000
operator|*
name|HEARTBEATS_SCALING_FACTOR
operator|*
operator|(
operator|(
name|double
operator|)
name|clusterSize
operator|/
name|NUM_HEARTBEATS_IN_SECOND
operator|)
argument_list|)
argument_list|,
name|HEARTBEAT_INTERVAL_MIN
argument_list|)
decl_stmt|;
return|return
name|heartbeatInterval
return|;
block|}
comment|/**    * Return if the specified tasktracker is in the hosts list,     * if one was configured.  If none was configured, then this     * returns true.    */
DECL|method|inHostsList (TaskTrackerStatus status)
specifier|private
name|boolean
name|inHostsList
parameter_list|(
name|TaskTrackerStatus
name|status
parameter_list|)
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|hostsList
init|=
name|hostsReader
operator|.
name|getHosts
argument_list|()
decl_stmt|;
return|return
operator|(
name|hostsList
operator|.
name|isEmpty
argument_list|()
operator|||
name|hostsList
operator|.
name|contains
argument_list|(
name|status
operator|.
name|getHost
argument_list|()
argument_list|)
operator|)
return|;
block|}
comment|/**    * Return if the specified tasktracker is in the exclude list.    */
DECL|method|inExcludedHostsList (TaskTrackerStatus status)
specifier|private
name|boolean
name|inExcludedHostsList
parameter_list|(
name|TaskTrackerStatus
name|status
parameter_list|)
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|excludeList
init|=
name|hostsReader
operator|.
name|getExcludedHosts
argument_list|()
decl_stmt|;
return|return
name|excludeList
operator|.
name|contains
argument_list|(
name|status
operator|.
name|getHost
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Returns true if the tasktracker is in the hosts list and     * not in the exclude list.     */
DECL|method|acceptTaskTracker (TaskTrackerStatus status)
specifier|private
name|boolean
name|acceptTaskTracker
parameter_list|(
name|TaskTrackerStatus
name|status
parameter_list|)
block|{
return|return
operator|(
name|inHostsList
argument_list|(
name|status
argument_list|)
operator|&&
operator|!
name|inExcludedHostsList
argument_list|(
name|status
argument_list|)
operator|)
return|;
block|}
comment|/**    * Update the last recorded status for the given task tracker.    * It assumes that the taskTrackers are locked on entry.    * @param trackerName The name of the tracker    * @param status The new status for the task tracker    * @return Was an old status found?    */
DECL|method|updateTaskTrackerStatus (String trackerName, TaskTrackerStatus status)
name|boolean
name|updateTaskTrackerStatus
parameter_list|(
name|String
name|trackerName
parameter_list|,
name|TaskTrackerStatus
name|status
parameter_list|)
block|{
name|TaskTracker
name|tt
init|=
name|getTaskTracker
argument_list|(
name|trackerName
argument_list|)
decl_stmt|;
name|TaskTrackerStatus
name|oldStatus
init|=
operator|(
name|tt
operator|==
literal|null
operator|)
condition|?
literal|null
else|:
name|tt
operator|.
name|getStatus
argument_list|()
decl_stmt|;
if|if
condition|(
name|oldStatus
operator|!=
literal|null
condition|)
block|{
name|totalMaps
operator|-=
name|oldStatus
operator|.
name|countMapTasks
argument_list|()
expr_stmt|;
name|totalReduces
operator|-=
name|oldStatus
operator|.
name|countReduceTasks
argument_list|()
expr_stmt|;
name|occupiedMapSlots
operator|-=
name|oldStatus
operator|.
name|countOccupiedMapSlots
argument_list|()
expr_stmt|;
name|occupiedReduceSlots
operator|-=
name|oldStatus
operator|.
name|countOccupiedReduceSlots
argument_list|()
expr_stmt|;
name|getInstrumentation
argument_list|()
operator|.
name|decRunningMaps
argument_list|(
name|oldStatus
operator|.
name|countMapTasks
argument_list|()
argument_list|)
expr_stmt|;
name|getInstrumentation
argument_list|()
operator|.
name|decRunningReduces
argument_list|(
name|oldStatus
operator|.
name|countReduceTasks
argument_list|()
argument_list|)
expr_stmt|;
name|getInstrumentation
argument_list|()
operator|.
name|decOccupiedMapSlots
argument_list|(
name|oldStatus
operator|.
name|countOccupiedMapSlots
argument_list|()
argument_list|)
expr_stmt|;
name|getInstrumentation
argument_list|()
operator|.
name|decOccupiedReduceSlots
argument_list|(
name|oldStatus
operator|.
name|countOccupiedReduceSlots
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|faultyTrackers
operator|.
name|isBlacklisted
argument_list|(
name|oldStatus
operator|.
name|getHost
argument_list|()
argument_list|)
condition|)
block|{
name|int
name|mapSlots
init|=
name|oldStatus
operator|.
name|getMaxMapSlots
argument_list|()
decl_stmt|;
name|totalMapTaskCapacity
operator|-=
name|mapSlots
expr_stmt|;
name|int
name|reduceSlots
init|=
name|oldStatus
operator|.
name|getMaxReduceSlots
argument_list|()
decl_stmt|;
name|totalReduceTaskCapacity
operator|-=
name|reduceSlots
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|==
literal|null
condition|)
block|{
name|taskTrackers
operator|.
name|remove
argument_list|(
name|trackerName
argument_list|)
expr_stmt|;
name|Integer
name|numTaskTrackersInHost
init|=
name|uniqueHostsMap
operator|.
name|get
argument_list|(
name|oldStatus
operator|.
name|getHost
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|numTaskTrackersInHost
operator|!=
literal|null
condition|)
block|{
name|numTaskTrackersInHost
operator|--
expr_stmt|;
if|if
condition|(
name|numTaskTrackersInHost
operator|>
literal|0
condition|)
block|{
name|uniqueHostsMap
operator|.
name|put
argument_list|(
name|oldStatus
operator|.
name|getHost
argument_list|()
argument_list|,
name|numTaskTrackersInHost
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|uniqueHostsMap
operator|.
name|remove
argument_list|(
name|oldStatus
operator|.
name|getHost
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|status
operator|!=
literal|null
condition|)
block|{
name|totalMaps
operator|+=
name|status
operator|.
name|countMapTasks
argument_list|()
expr_stmt|;
name|totalReduces
operator|+=
name|status
operator|.
name|countReduceTasks
argument_list|()
expr_stmt|;
name|occupiedMapSlots
operator|+=
name|status
operator|.
name|countOccupiedMapSlots
argument_list|()
expr_stmt|;
name|occupiedReduceSlots
operator|+=
name|status
operator|.
name|countOccupiedReduceSlots
argument_list|()
expr_stmt|;
name|getInstrumentation
argument_list|()
operator|.
name|addRunningMaps
argument_list|(
name|status
operator|.
name|countMapTasks
argument_list|()
argument_list|)
expr_stmt|;
name|getInstrumentation
argument_list|()
operator|.
name|addRunningReduces
argument_list|(
name|status
operator|.
name|countReduceTasks
argument_list|()
argument_list|)
expr_stmt|;
name|getInstrumentation
argument_list|()
operator|.
name|addOccupiedMapSlots
argument_list|(
name|status
operator|.
name|countOccupiedMapSlots
argument_list|()
argument_list|)
expr_stmt|;
name|getInstrumentation
argument_list|()
operator|.
name|addOccupiedReduceSlots
argument_list|(
name|status
operator|.
name|countOccupiedReduceSlots
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|faultyTrackers
operator|.
name|isBlacklisted
argument_list|(
name|status
operator|.
name|getHost
argument_list|()
argument_list|)
condition|)
block|{
name|int
name|mapSlots
init|=
name|status
operator|.
name|getMaxMapSlots
argument_list|()
decl_stmt|;
name|totalMapTaskCapacity
operator|+=
name|mapSlots
expr_stmt|;
name|int
name|reduceSlots
init|=
name|status
operator|.
name|getMaxReduceSlots
argument_list|()
decl_stmt|;
name|totalReduceTaskCapacity
operator|+=
name|reduceSlots
expr_stmt|;
block|}
name|boolean
name|alreadyPresent
init|=
literal|false
decl_stmt|;
name|TaskTracker
name|taskTracker
init|=
name|taskTrackers
operator|.
name|get
argument_list|(
name|trackerName
argument_list|)
decl_stmt|;
if|if
condition|(
name|taskTracker
operator|!=
literal|null
condition|)
block|{
name|alreadyPresent
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|taskTracker
operator|=
operator|new
name|TaskTracker
argument_list|(
name|trackerName
argument_list|)
expr_stmt|;
block|}
name|taskTracker
operator|.
name|setStatus
argument_list|(
name|status
argument_list|)
expr_stmt|;
name|taskTrackers
operator|.
name|put
argument_list|(
name|trackerName
argument_list|,
name|taskTracker
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|int
name|runningMaps
init|=
literal|0
decl_stmt|,
name|runningReduces
init|=
literal|0
decl_stmt|;
name|int
name|commitPendingMaps
init|=
literal|0
decl_stmt|,
name|commitPendingReduces
init|=
literal|0
decl_stmt|;
name|int
name|unassignedMaps
init|=
literal|0
decl_stmt|,
name|unassignedReduces
init|=
literal|0
decl_stmt|;
name|int
name|miscMaps
init|=
literal|0
decl_stmt|,
name|miscReduces
init|=
literal|0
decl_stmt|;
name|List
argument_list|<
name|TaskStatus
argument_list|>
name|taskReports
init|=
name|status
operator|.
name|getTaskReports
argument_list|()
decl_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|TaskStatus
argument_list|>
name|it
init|=
name|taskReports
operator|.
name|iterator
argument_list|()
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|TaskStatus
name|ts
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|boolean
name|isMap
init|=
name|ts
operator|.
name|getIsMap
argument_list|()
decl_stmt|;
name|TaskStatus
operator|.
name|State
name|state
init|=
name|ts
operator|.
name|getRunState
argument_list|()
decl_stmt|;
if|if
condition|(
name|state
operator|==
name|TaskStatus
operator|.
name|State
operator|.
name|RUNNING
condition|)
block|{
if|if
condition|(
name|isMap
condition|)
block|{
operator|++
name|runningMaps
expr_stmt|;
block|}
else|else
block|{
operator|++
name|runningReduces
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|state
operator|==
name|TaskStatus
operator|.
name|State
operator|.
name|UNASSIGNED
condition|)
block|{
if|if
condition|(
name|isMap
condition|)
block|{
operator|++
name|unassignedMaps
expr_stmt|;
block|}
else|else
block|{
operator|++
name|unassignedReduces
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|state
operator|==
name|TaskStatus
operator|.
name|State
operator|.
name|COMMIT_PENDING
condition|)
block|{
if|if
condition|(
name|isMap
condition|)
block|{
operator|++
name|commitPendingMaps
expr_stmt|;
block|}
else|else
block|{
operator|++
name|commitPendingReduces
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|isMap
condition|)
block|{
operator|++
name|miscMaps
expr_stmt|;
block|}
else|else
block|{
operator|++
name|miscReduces
expr_stmt|;
block|}
block|}
block|}
name|LOG
operator|.
name|debug
argument_list|(
name|trackerName
operator|+
literal|": Status -"
operator|+
literal|" running(m) = "
operator|+
name|runningMaps
operator|+
literal|" unassigned(m) = "
operator|+
name|unassignedMaps
operator|+
literal|" commit_pending(m) = "
operator|+
name|commitPendingMaps
operator|+
literal|" misc(m) = "
operator|+
name|miscMaps
operator|+
literal|" running(r) = "
operator|+
name|runningReduces
operator|+
literal|" unassigned(r) = "
operator|+
name|unassignedReduces
operator|+
literal|" commit_pending(r) = "
operator|+
name|commitPendingReduces
operator|+
literal|" misc(r) = "
operator|+
name|miscReduces
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|alreadyPresent
condition|)
block|{
name|Integer
name|numTaskTrackersInHost
init|=
name|uniqueHostsMap
operator|.
name|get
argument_list|(
name|status
operator|.
name|getHost
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|numTaskTrackersInHost
operator|==
literal|null
condition|)
block|{
name|numTaskTrackersInHost
operator|=
literal|0
expr_stmt|;
block|}
name|numTaskTrackersInHost
operator|++
expr_stmt|;
name|uniqueHostsMap
operator|.
name|put
argument_list|(
name|status
operator|.
name|getHost
argument_list|()
argument_list|,
name|numTaskTrackersInHost
argument_list|)
expr_stmt|;
block|}
block|}
name|getInstrumentation
argument_list|()
operator|.
name|setMapSlots
argument_list|(
name|totalMapTaskCapacity
argument_list|)
expr_stmt|;
name|getInstrumentation
argument_list|()
operator|.
name|setReduceSlots
argument_list|(
name|totalReduceTaskCapacity
argument_list|)
expr_stmt|;
return|return
name|oldStatus
operator|!=
literal|null
return|;
block|}
comment|// Increment the number of reserved slots in the cluster.
comment|// This method assumes the caller has JobTracker lock.
DECL|method|incrementReservations (TaskType type, int reservedSlots)
name|void
name|incrementReservations
parameter_list|(
name|TaskType
name|type
parameter_list|,
name|int
name|reservedSlots
parameter_list|)
block|{
if|if
condition|(
name|type
operator|.
name|equals
argument_list|(
name|TaskType
operator|.
name|MAP
argument_list|)
condition|)
block|{
name|reservedMapSlots
operator|+=
name|reservedSlots
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|.
name|equals
argument_list|(
name|TaskType
operator|.
name|REDUCE
argument_list|)
condition|)
block|{
name|reservedReduceSlots
operator|+=
name|reservedSlots
expr_stmt|;
block|}
block|}
comment|// Decrement the number of reserved slots in the cluster.
comment|// This method assumes the caller has JobTracker lock.
DECL|method|decrementReservations (TaskType type, int reservedSlots)
name|void
name|decrementReservations
parameter_list|(
name|TaskType
name|type
parameter_list|,
name|int
name|reservedSlots
parameter_list|)
block|{
if|if
condition|(
name|type
operator|.
name|equals
argument_list|(
name|TaskType
operator|.
name|MAP
argument_list|)
condition|)
block|{
name|reservedMapSlots
operator|-=
name|reservedSlots
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|.
name|equals
argument_list|(
name|TaskType
operator|.
name|REDUCE
argument_list|)
condition|)
block|{
name|reservedReduceSlots
operator|-=
name|reservedSlots
expr_stmt|;
block|}
block|}
DECL|method|updateNodeHealthStatus (TaskTrackerStatus trackerStatus)
specifier|private
name|void
name|updateNodeHealthStatus
parameter_list|(
name|TaskTrackerStatus
name|trackerStatus
parameter_list|)
block|{
name|TaskTrackerHealthStatus
name|status
init|=
name|trackerStatus
operator|.
name|getHealthStatus
argument_list|()
decl_stmt|;
synchronized|synchronized
init|(
name|faultyTrackers
init|)
block|{
name|faultyTrackers
operator|.
name|setNodeHealthStatus
argument_list|(
name|trackerStatus
operator|.
name|getHost
argument_list|()
argument_list|,
name|status
operator|.
name|isNodeHealthy
argument_list|()
argument_list|,
name|status
operator|.
name|getHealthReport
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Process incoming heartbeat messages from the task trackers.    */
DECL|method|processHeartbeat ( TaskTrackerStatus trackerStatus, boolean initialContact)
specifier|synchronized
name|boolean
name|processHeartbeat
parameter_list|(
name|TaskTrackerStatus
name|trackerStatus
parameter_list|,
name|boolean
name|initialContact
parameter_list|)
throws|throws
name|UnknownHostException
block|{
name|getInstrumentation
argument_list|()
operator|.
name|heartbeat
argument_list|()
expr_stmt|;
name|String
name|trackerName
init|=
name|trackerStatus
operator|.
name|getTrackerName
argument_list|()
decl_stmt|;
synchronized|synchronized
init|(
name|taskTrackers
init|)
block|{
synchronized|synchronized
init|(
name|trackerExpiryQueue
init|)
block|{
name|boolean
name|seenBefore
init|=
name|updateTaskTrackerStatus
argument_list|(
name|trackerName
argument_list|,
name|trackerStatus
argument_list|)
decl_stmt|;
name|TaskTracker
name|taskTracker
init|=
name|getTaskTracker
argument_list|(
name|trackerName
argument_list|)
decl_stmt|;
if|if
condition|(
name|initialContact
condition|)
block|{
comment|// If it's first contact, then clear out
comment|// any state hanging around
if|if
condition|(
name|seenBefore
condition|)
block|{
name|lostTaskTracker
argument_list|(
name|taskTracker
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// If not first contact, there should be some record of the tracker
if|if
condition|(
operator|!
name|seenBefore
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Status from unknown Tracker : "
operator|+
name|trackerName
argument_list|)
expr_stmt|;
name|updateTaskTrackerStatus
argument_list|(
name|trackerName
argument_list|,
literal|null
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
if|if
condition|(
name|initialContact
condition|)
block|{
comment|// if this is lost tracker that came back now, and if it blacklisted
comment|// increment the count of blacklisted trackers in the cluster
if|if
condition|(
name|isBlacklisted
argument_list|(
name|trackerName
argument_list|)
condition|)
block|{
name|faultyTrackers
operator|.
name|incrBlackListedTrackers
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|addNewTracker
argument_list|(
name|taskTracker
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|updateTaskStatuses
argument_list|(
name|trackerStatus
argument_list|)
expr_stmt|;
name|updateNodeHealthStatus
argument_list|(
name|trackerStatus
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|/**    * A tracker wants to know if any of its Tasks have been    * closed (because the job completed, whether successfully or not)    */
DECL|method|getTasksToKill (String taskTracker)
specifier|synchronized
name|List
argument_list|<
name|TaskTrackerAction
argument_list|>
name|getTasksToKill
parameter_list|(
name|String
name|taskTracker
parameter_list|)
block|{
name|Set
argument_list|<
name|TaskAttemptID
argument_list|>
name|taskIds
init|=
name|trackerToTaskMap
operator|.
name|get
argument_list|(
name|taskTracker
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|TaskTrackerAction
argument_list|>
name|killList
init|=
operator|new
name|ArrayList
argument_list|<
name|TaskTrackerAction
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|taskIds
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|TaskAttemptID
name|killTaskId
range|:
name|taskIds
control|)
block|{
name|TaskInProgress
name|tip
init|=
name|taskidToTIPMap
operator|.
name|get
argument_list|(
name|killTaskId
argument_list|)
decl_stmt|;
if|if
condition|(
name|tip
operator|==
literal|null
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|tip
operator|.
name|shouldClose
argument_list|(
name|killTaskId
argument_list|)
condition|)
block|{
comment|//
comment|// This is how the JobTracker ends a task at the TaskTracker.
comment|// It may be successfully completed, or may be killed in
comment|// mid-execution.
comment|//
if|if
condition|(
operator|!
name|tip
operator|.
name|getJob
argument_list|()
operator|.
name|isComplete
argument_list|()
condition|)
block|{
name|killList
operator|.
name|add
argument_list|(
operator|new
name|KillTaskAction
argument_list|(
name|killTaskId
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|taskTracker
operator|+
literal|" -> KillTaskAction: "
operator|+
name|killTaskId
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
comment|// add the stray attempts for uninited jobs
synchronized|synchronized
init|(
name|trackerToTasksToCleanup
init|)
block|{
name|Set
argument_list|<
name|TaskAttemptID
argument_list|>
name|set
init|=
name|trackerToTasksToCleanup
operator|.
name|remove
argument_list|(
name|taskTracker
argument_list|)
decl_stmt|;
if|if
condition|(
name|set
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|TaskAttemptID
name|id
range|:
name|set
control|)
block|{
name|killList
operator|.
name|add
argument_list|(
operator|new
name|KillTaskAction
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|killList
return|;
block|}
comment|/**    * Add a job to cleanup for the tracker.    */
DECL|method|addJobForCleanup (JobID id)
specifier|private
name|void
name|addJobForCleanup
parameter_list|(
name|JobID
name|id
parameter_list|)
block|{
for|for
control|(
name|String
name|taskTracker
range|:
name|taskTrackers
operator|.
name|keySet
argument_list|()
control|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Marking job "
operator|+
name|id
operator|+
literal|" for cleanup by tracker "
operator|+
name|taskTracker
argument_list|)
expr_stmt|;
block|}
synchronized|synchronized
init|(
name|trackerToJobsToCleanup
init|)
block|{
name|Set
argument_list|<
name|JobID
argument_list|>
name|jobsToKill
init|=
name|trackerToJobsToCleanup
operator|.
name|get
argument_list|(
name|taskTracker
argument_list|)
decl_stmt|;
if|if
condition|(
name|jobsToKill
operator|==
literal|null
condition|)
block|{
name|jobsToKill
operator|=
operator|new
name|HashSet
argument_list|<
name|JobID
argument_list|>
argument_list|()
expr_stmt|;
name|trackerToJobsToCleanup
operator|.
name|put
argument_list|(
name|taskTracker
argument_list|,
name|jobsToKill
argument_list|)
expr_stmt|;
block|}
name|jobsToKill
operator|.
name|add
argument_list|(
name|id
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * A tracker wants to know if any job needs cleanup because the job completed.    */
DECL|method|getJobsForCleanup (String taskTracker)
specifier|private
name|List
argument_list|<
name|TaskTrackerAction
argument_list|>
name|getJobsForCleanup
parameter_list|(
name|String
name|taskTracker
parameter_list|)
block|{
name|Set
argument_list|<
name|JobID
argument_list|>
name|jobs
init|=
literal|null
decl_stmt|;
synchronized|synchronized
init|(
name|trackerToJobsToCleanup
init|)
block|{
name|jobs
operator|=
name|trackerToJobsToCleanup
operator|.
name|remove
argument_list|(
name|taskTracker
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|jobs
operator|!=
literal|null
condition|)
block|{
comment|// prepare the actions list
name|List
argument_list|<
name|TaskTrackerAction
argument_list|>
name|killList
init|=
operator|new
name|ArrayList
argument_list|<
name|TaskTrackerAction
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|JobID
name|killJobId
range|:
name|jobs
control|)
block|{
name|killList
operator|.
name|add
argument_list|(
operator|new
name|KillJobAction
argument_list|(
name|killJobId
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|taskTracker
operator|+
literal|" -> KillJobAction: "
operator|+
name|killJobId
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|killList
return|;
block|}
return|return
literal|null
return|;
block|}
comment|/**    * A tracker wants to know if any of its Tasks can be committed     */
DECL|method|getTasksToSave ( TaskTrackerStatus tts)
specifier|synchronized
name|List
argument_list|<
name|TaskTrackerAction
argument_list|>
name|getTasksToSave
parameter_list|(
name|TaskTrackerStatus
name|tts
parameter_list|)
block|{
name|List
argument_list|<
name|TaskStatus
argument_list|>
name|taskStatuses
init|=
name|tts
operator|.
name|getTaskReports
argument_list|()
decl_stmt|;
if|if
condition|(
name|taskStatuses
operator|!=
literal|null
condition|)
block|{
name|List
argument_list|<
name|TaskTrackerAction
argument_list|>
name|saveList
init|=
operator|new
name|ArrayList
argument_list|<
name|TaskTrackerAction
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|TaskStatus
name|taskStatus
range|:
name|taskStatuses
control|)
block|{
if|if
condition|(
name|taskStatus
operator|.
name|getRunState
argument_list|()
operator|==
name|TaskStatus
operator|.
name|State
operator|.
name|COMMIT_PENDING
condition|)
block|{
name|TaskAttemptID
name|taskId
init|=
name|taskStatus
operator|.
name|getTaskID
argument_list|()
decl_stmt|;
name|TaskInProgress
name|tip
init|=
name|taskidToTIPMap
operator|.
name|get
argument_list|(
name|taskId
argument_list|)
decl_stmt|;
if|if
condition|(
name|tip
operator|==
literal|null
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|tip
operator|.
name|shouldCommit
argument_list|(
name|taskId
argument_list|)
condition|)
block|{
name|saveList
operator|.
name|add
argument_list|(
operator|new
name|CommitTaskAction
argument_list|(
name|taskId
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|tts
operator|.
name|getTrackerName
argument_list|()
operator|+
literal|" -> CommitTaskAction: "
operator|+
name|taskId
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
name|saveList
return|;
block|}
return|return
literal|null
return|;
block|}
comment|// returns cleanup tasks first, then setup tasks.
DECL|method|getSetupAndCleanupTasks ( TaskTrackerStatus taskTracker)
specifier|synchronized
name|List
argument_list|<
name|Task
argument_list|>
name|getSetupAndCleanupTasks
parameter_list|(
name|TaskTrackerStatus
name|taskTracker
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|maxMapTasks
init|=
name|taskTracker
operator|.
name|getMaxMapSlots
argument_list|()
decl_stmt|;
name|int
name|maxReduceTasks
init|=
name|taskTracker
operator|.
name|getMaxReduceSlots
argument_list|()
decl_stmt|;
name|int
name|numMaps
init|=
name|taskTracker
operator|.
name|countOccupiedMapSlots
argument_list|()
decl_stmt|;
name|int
name|numReduces
init|=
name|taskTracker
operator|.
name|countOccupiedReduceSlots
argument_list|()
decl_stmt|;
name|int
name|numTaskTrackers
init|=
name|getClusterStatus
argument_list|()
operator|.
name|getTaskTrackers
argument_list|()
decl_stmt|;
name|int
name|numUniqueHosts
init|=
name|getNumberOfUniqueHosts
argument_list|()
decl_stmt|;
name|boolean
name|hasFailedUncleanTask
init|=
name|hasFailedUncleanTask
argument_list|(
name|taskTracker
argument_list|)
decl_stmt|;
name|Task
name|t
init|=
literal|null
decl_stmt|;
synchronized|synchronized
init|(
name|jobs
init|)
block|{
if|if
condition|(
name|numMaps
operator|<
name|maxMapTasks
condition|)
block|{
for|for
control|(
name|Iterator
argument_list|<
name|JobInProgress
argument_list|>
name|it
init|=
name|jobs
operator|.
name|values
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|JobInProgress
name|job
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|t
operator|=
name|job
operator|.
name|obtainJobCleanupTask
argument_list|(
name|taskTracker
argument_list|,
name|numTaskTrackers
argument_list|,
name|numUniqueHosts
argument_list|,
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|!=
literal|null
condition|)
block|{
return|return
name|Collections
operator|.
name|singletonList
argument_list|(
name|t
argument_list|)
return|;
block|}
block|}
comment|// Don't schedule task-cleanup task on the node that the task just failed.
if|if
condition|(
operator|!
name|hasFailedUncleanTask
condition|)
block|{
for|for
control|(
name|Iterator
argument_list|<
name|JobInProgress
argument_list|>
name|it
init|=
name|jobs
operator|.
name|values
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|JobInProgress
name|job
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|t
operator|=
name|job
operator|.
name|obtainTaskCleanupTask
argument_list|(
name|taskTracker
argument_list|,
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|!=
literal|null
condition|)
block|{
return|return
name|Collections
operator|.
name|singletonList
argument_list|(
name|t
argument_list|)
return|;
block|}
block|}
block|}
for|for
control|(
name|Iterator
argument_list|<
name|JobInProgress
argument_list|>
name|it
init|=
name|jobs
operator|.
name|values
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|JobInProgress
name|job
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|t
operator|=
name|job
operator|.
name|obtainJobSetupTask
argument_list|(
name|taskTracker
argument_list|,
name|numTaskTrackers
argument_list|,
name|numUniqueHosts
argument_list|,
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|!=
literal|null
condition|)
block|{
return|return
name|Collections
operator|.
name|singletonList
argument_list|(
name|t
argument_list|)
return|;
block|}
block|}
block|}
if|if
condition|(
name|numReduces
operator|<
name|maxReduceTasks
condition|)
block|{
for|for
control|(
name|Iterator
argument_list|<
name|JobInProgress
argument_list|>
name|it
init|=
name|jobs
operator|.
name|values
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|JobInProgress
name|job
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|t
operator|=
name|job
operator|.
name|obtainJobCleanupTask
argument_list|(
name|taskTracker
argument_list|,
name|numTaskTrackers
argument_list|,
name|numUniqueHosts
argument_list|,
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|!=
literal|null
condition|)
block|{
return|return
name|Collections
operator|.
name|singletonList
argument_list|(
name|t
argument_list|)
return|;
block|}
block|}
comment|// Don't schedule task-cleanup task on the node that the task just failed.
if|if
condition|(
operator|!
name|hasFailedUncleanTask
condition|)
block|{
for|for
control|(
name|Iterator
argument_list|<
name|JobInProgress
argument_list|>
name|it
init|=
name|jobs
operator|.
name|values
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|JobInProgress
name|job
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|t
operator|=
name|job
operator|.
name|obtainTaskCleanupTask
argument_list|(
name|taskTracker
argument_list|,
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|!=
literal|null
condition|)
block|{
return|return
name|Collections
operator|.
name|singletonList
argument_list|(
name|t
argument_list|)
return|;
block|}
block|}
block|}
for|for
control|(
name|Iterator
argument_list|<
name|JobInProgress
argument_list|>
name|it
init|=
name|jobs
operator|.
name|values
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|JobInProgress
name|job
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|t
operator|=
name|job
operator|.
name|obtainJobSetupTask
argument_list|(
name|taskTracker
argument_list|,
name|numTaskTrackers
argument_list|,
name|numUniqueHosts
argument_list|,
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|!=
literal|null
condition|)
block|{
return|return
name|Collections
operator|.
name|singletonList
argument_list|(
name|t
argument_list|)
return|;
block|}
block|}
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/**    * Whether this tracker has tasks with FAILED_UNCLEAN state.       */
DECL|method|hasFailedUncleanTask (TaskTrackerStatus taskTracker)
specifier|static
name|boolean
name|hasFailedUncleanTask
parameter_list|(
name|TaskTrackerStatus
name|taskTracker
parameter_list|)
block|{
for|for
control|(
name|TaskStatus
name|taskStatus
range|:
name|taskTracker
operator|.
name|getTaskReports
argument_list|()
control|)
block|{
if|if
condition|(
name|taskStatus
operator|.
name|getRunState
argument_list|()
operator|==
name|TaskStatus
operator|.
name|State
operator|.
name|FAILED_UNCLEAN
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/**    * Grab the local fs name    */
DECL|method|getFilesystemName ()
specifier|public
specifier|synchronized
name|String
name|getFilesystemName
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|fs
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"FileSystem object not available yet"
argument_list|)
throw|;
block|}
return|return
name|fs
operator|.
name|getUri
argument_list|()
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * Returns a handle to the JobTracker's Configuration    */
DECL|method|getConf ()
specifier|public
name|JobConf
name|getConf
parameter_list|()
block|{
return|return
name|conf
return|;
block|}
DECL|method|reportTaskTrackerError (String taskTracker, String errorClass, String errorMessage)
specifier|public
name|void
name|reportTaskTrackerError
parameter_list|(
name|String
name|taskTracker
parameter_list|,
name|String
name|errorClass
parameter_list|,
name|String
name|errorMessage
parameter_list|)
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Report from "
operator|+
name|taskTracker
operator|+
literal|": "
operator|+
name|errorMessage
argument_list|)
expr_stmt|;
block|}
comment|/**    * Remove the job_ from jobids to get the unique string.    */
DECL|method|getJobUniqueString (String jobid)
specifier|static
name|String
name|getJobUniqueString
parameter_list|(
name|String
name|jobid
parameter_list|)
block|{
return|return
name|jobid
operator|.
name|substring
argument_list|(
literal|4
argument_list|)
return|;
block|}
comment|////////////////////////////////////////////////////
comment|// JobSubmissionProtocol
comment|////////////////////////////////////////////////////
comment|/**    * Allocates a new JobId string.    * @deprecated use {@link #getNewJobID()} instead    */
annotation|@
name|Deprecated
DECL|method|getNewJobId ()
specifier|public
name|JobID
name|getNewJobId
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|JobID
operator|.
name|downgrade
argument_list|(
name|getNewJobID
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Allocates a new JobId string.    */
DECL|method|getNewJobID ()
specifier|public
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|JobID
name|getNewJobID
parameter_list|()
throws|throws
name|IOException
block|{
return|return
operator|new
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|JobID
argument_list|(
name|getTrackerIdentifier
argument_list|()
argument_list|,
name|nextJobId
operator|.
name|getAndIncrement
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * JobTracker.submitJob() kicks off a new job.      *    * Create a 'JobInProgress' object, which contains both JobProfile    * and JobStatus.  Those two sub-objects are sometimes shipped outside    * of the JobTracker.  But JobInProgress adds info that's useful for    * the JobTracker alone.    */
specifier|public
specifier|synchronized
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|JobStatus
DECL|method|submitJob (org.apache.hadoop.mapreduce.JobID jobId, String jobSubmitDir, Credentials ts )
name|submitJob
parameter_list|(
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|JobID
name|jobId
parameter_list|,
name|String
name|jobSubmitDir
parameter_list|,
name|Credentials
name|ts
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
return|return
name|submitJob
argument_list|(
name|JobID
operator|.
name|downgrade
argument_list|(
name|jobId
argument_list|)
argument_list|,
name|jobSubmitDir
argument_list|,
name|ts
argument_list|)
return|;
block|}
comment|/**    * JobTracker.submitJob() kicks off a new job.      *    * Create a 'JobInProgress' object, which contains both JobProfile    * and JobStatus.  Those two sub-objects are sometimes shipped outside    * of the JobTracker.  But JobInProgress adds info that's useful for    * the JobTracker alone.    * @deprecated Use     * {@link #submitJob(org.apache.hadoop.mapreduce.JobID, String, Credentials)}    *  instead    */
annotation|@
name|Deprecated
DECL|method|submitJob (JobID jobId, String jobSubmitDir, Credentials ts)
specifier|public
name|JobStatus
name|submitJob
parameter_list|(
name|JobID
name|jobId
parameter_list|,
name|String
name|jobSubmitDir
parameter_list|,
name|Credentials
name|ts
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
return|return
name|submitJob
argument_list|(
name|jobId
argument_list|,
literal|0
argument_list|,
name|UserGroupInformation
operator|.
name|getCurrentUser
argument_list|()
argument_list|,
name|jobSubmitDir
argument_list|,
literal|false
argument_list|,
name|ts
argument_list|)
return|;
block|}
comment|/**    * Submits either a new job or a job from an earlier run.    */
DECL|method|submitJob (org.apache.hadoop.mapreduce.JobID jobID, int restartCount, UserGroupInformation ugi, String jobSubmitDir, boolean recovered, Credentials ts )
specifier|private
name|JobStatus
name|submitJob
parameter_list|(
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|JobID
name|jobID
parameter_list|,
name|int
name|restartCount
parameter_list|,
name|UserGroupInformation
name|ugi
parameter_list|,
name|String
name|jobSubmitDir
parameter_list|,
name|boolean
name|recovered
parameter_list|,
name|Credentials
name|ts
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|JobID
name|jobId
init|=
literal|null
decl_stmt|;
name|JobInfo
name|jobInfo
decl_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
name|jobId
operator|=
name|JobID
operator|.
name|downgrade
argument_list|(
name|jobID
argument_list|)
expr_stmt|;
if|if
condition|(
name|jobs
operator|.
name|containsKey
argument_list|(
name|jobId
argument_list|)
condition|)
block|{
comment|// job already running, don't start twice
return|return
name|jobs
operator|.
name|get
argument_list|(
name|jobId
argument_list|)
operator|.
name|getStatus
argument_list|()
return|;
block|}
comment|// the conversion from String to Text for the UGI's username will
comment|// not be required when we have the UGI to return us the username as
comment|// Text.
name|jobInfo
operator|=
operator|new
name|JobInfo
argument_list|(
name|jobId
argument_list|,
operator|new
name|Text
argument_list|(
name|ugi
operator|.
name|getShortUserName
argument_list|()
argument_list|)
argument_list|,
operator|new
name|Path
argument_list|(
name|jobSubmitDir
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Create the JobInProgress, temporarily unlock the JobTracker since
comment|// we are about to copy job.xml from HDFSJobInProgress
name|JobInProgress
name|job
init|=
operator|new
name|JobInProgress
argument_list|(
name|this
argument_list|,
name|this
operator|.
name|conf
argument_list|,
name|restartCount
argument_list|,
name|jobInfo
argument_list|,
name|ts
argument_list|)
decl_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
try|try
block|{
name|checkQueueValidity
argument_list|(
name|job
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Queue given for job "
operator|+
name|job
operator|.
name|getJobID
argument_list|()
operator|+
literal|" is not valid: "
operator|+
name|ioe
argument_list|)
expr_stmt|;
throw|throw
name|ioe
throw|;
block|}
try|try
block|{
name|aclsManager
operator|.
name|checkAccess
argument_list|(
name|job
argument_list|,
name|ugi
argument_list|,
name|Operation
operator|.
name|SUBMIT_JOB
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|AccessControlException
name|ace
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Access denied for user "
operator|+
name|job
operator|.
name|getJobConf
argument_list|()
operator|.
name|getUser
argument_list|()
operator|+
literal|". Ignoring job "
operator|+
name|jobId
argument_list|,
name|ace
argument_list|)
expr_stmt|;
throw|throw
name|ace
throw|;
block|}
comment|// Check the job if it cannot run in the cluster because of invalid memory
comment|// requirements.
try|try
block|{
name|checkMemoryRequirements
argument_list|(
name|job
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
throw|throw
name|ioe
throw|;
block|}
if|if
condition|(
operator|!
name|recovered
condition|)
block|{
comment|// Store the information in a file so that the job can be recovered
comment|// later (if at all)
name|Path
name|jobDir
init|=
name|getSystemDirectoryForJob
argument_list|(
name|jobId
argument_list|)
decl_stmt|;
name|FileSystem
operator|.
name|mkdirs
argument_list|(
name|fs
argument_list|,
name|jobDir
argument_list|,
operator|new
name|FsPermission
argument_list|(
name|SYSTEM_DIR_PERMISSION
argument_list|)
argument_list|)
expr_stmt|;
name|FSDataOutputStream
name|out
init|=
name|fs
operator|.
name|create
argument_list|(
name|getSystemFileForJob
argument_list|(
name|jobId
argument_list|)
argument_list|)
decl_stmt|;
name|jobInfo
operator|.
name|write
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|out
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
return|return
name|addJob
argument_list|(
name|jobId
argument_list|,
name|job
argument_list|)
return|;
block|}
block|}
comment|/**    * Adds a job to the jobtracker. Make sure that the checks are inplace before    * adding a job. This is the core job submission logic    * @param jobId The id for the job submitted which needs to be added    */
DECL|method|addJob (JobID jobId, JobInProgress job)
specifier|synchronized
name|JobStatus
name|addJob
parameter_list|(
name|JobID
name|jobId
parameter_list|,
name|JobInProgress
name|job
parameter_list|)
block|{
name|totalSubmissions
operator|++
expr_stmt|;
synchronized|synchronized
init|(
name|jobs
init|)
block|{
synchronized|synchronized
init|(
name|taskScheduler
init|)
block|{
name|jobs
operator|.
name|put
argument_list|(
name|job
operator|.
name|getProfile
argument_list|()
operator|.
name|getJobID
argument_list|()
argument_list|,
name|job
argument_list|)
expr_stmt|;
for|for
control|(
name|JobInProgressListener
name|listener
range|:
name|jobInProgressListeners
control|)
block|{
try|try
block|{
name|listener
operator|.
name|jobAdded
argument_list|(
name|job
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to add and so skipping the job : "
operator|+
name|job
operator|.
name|getJobID
argument_list|()
operator|+
literal|". Exception : "
operator|+
name|ioe
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|myInstrumentation
operator|.
name|submitJob
argument_list|(
name|job
operator|.
name|getJobConf
argument_list|()
argument_list|,
name|jobId
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Job "
operator|+
name|jobId
operator|+
literal|" added successfully for user '"
operator|+
name|job
operator|.
name|getJobConf
argument_list|()
operator|.
name|getUser
argument_list|()
operator|+
literal|"' to queue '"
operator|+
name|job
operator|.
name|getJobConf
argument_list|()
operator|.
name|getQueueName
argument_list|()
operator|+
literal|"'"
argument_list|)
expr_stmt|;
return|return
name|job
operator|.
name|getStatus
argument_list|()
return|;
block|}
comment|/**    * For a JobInProgress that is being submitted, check whether     * queue that the job has been submitted to exists and is RUNNING.    * @param job The JobInProgress object being submitted.    * @throws IOException    */
DECL|method|checkQueueValidity (JobInProgress job)
specifier|public
name|void
name|checkQueueValidity
parameter_list|(
name|JobInProgress
name|job
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|queue
init|=
name|job
operator|.
name|getProfile
argument_list|()
operator|.
name|getQueueName
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|queueManager
operator|.
name|getLeafQueueNames
argument_list|()
operator|.
name|contains
argument_list|(
name|queue
argument_list|)
operator|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Queue \""
operator|+
name|queue
operator|+
literal|"\" does not exist"
argument_list|)
throw|;
block|}
comment|// check if queue is RUNNING
if|if
condition|(
operator|!
name|queueManager
operator|.
name|isRunning
argument_list|(
name|queue
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Queue \""
operator|+
name|queue
operator|+
literal|"\" is not running"
argument_list|)
throw|;
block|}
block|}
comment|/**    * Are ACLs for authorization checks enabled on the MR cluster ?    *    * @return true if ACLs(job acls and queue acls) are enabled    */
DECL|method|areACLsEnabled ()
name|boolean
name|areACLsEnabled
parameter_list|()
block|{
return|return
name|conf
operator|.
name|getBoolean
argument_list|(
name|MRConfig
operator|.
name|MR_ACLS_ENABLED
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**@deprecated use {@link #getClusterStatus(boolean)}*/
annotation|@
name|Deprecated
DECL|method|getClusterStatus ()
specifier|public
specifier|synchronized
name|ClusterStatus
name|getClusterStatus
parameter_list|()
block|{
return|return
name|getClusterStatus
argument_list|(
literal|false
argument_list|)
return|;
block|}
DECL|method|getClusterStatus (boolean detailed)
specifier|public
specifier|synchronized
name|ClusterStatus
name|getClusterStatus
parameter_list|(
name|boolean
name|detailed
parameter_list|)
block|{
synchronized|synchronized
init|(
name|taskTrackers
init|)
block|{
if|if
condition|(
name|detailed
condition|)
block|{
name|List
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|trackerNames
init|=
name|taskTrackerNames
argument_list|()
decl_stmt|;
name|Collection
argument_list|<
name|BlackListInfo
argument_list|>
name|blackListedTrackers
init|=
name|getBlackListedTrackers
argument_list|()
decl_stmt|;
return|return
operator|new
name|ClusterStatus
argument_list|(
name|trackerNames
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|blackListedTrackers
argument_list|,
name|tasktrackerExpiryInterval
argument_list|,
name|totalMaps
argument_list|,
name|totalReduces
argument_list|,
name|totalMapTaskCapacity
argument_list|,
name|totalReduceTaskCapacity
argument_list|,
name|JobTrackerStatus
operator|.
name|valueOf
argument_list|(
name|state
operator|.
name|name
argument_list|()
argument_list|)
argument_list|,
name|getExcludedNodes
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
return|;
block|}
else|else
block|{
return|return
operator|new
name|ClusterStatus
argument_list|(
name|taskTrackers
operator|.
name|size
argument_list|()
operator|-
name|getBlacklistedTrackerCount
argument_list|()
argument_list|,
name|getBlacklistedTrackerCount
argument_list|()
argument_list|,
name|tasktrackerExpiryInterval
argument_list|,
name|totalMaps
argument_list|,
name|totalReduces
argument_list|,
name|totalMapTaskCapacity
argument_list|,
name|totalReduceTaskCapacity
argument_list|,
name|JobTrackerStatus
operator|.
name|valueOf
argument_list|(
name|state
operator|.
name|name
argument_list|()
argument_list|)
argument_list|,
name|getExcludedNodes
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
return|;
block|}
block|}
block|}
DECL|method|getClusterMetrics ()
specifier|public
specifier|synchronized
name|ClusterMetrics
name|getClusterMetrics
parameter_list|()
block|{
return|return
operator|new
name|ClusterMetrics
argument_list|(
name|totalMaps
argument_list|,
name|totalReduces
argument_list|,
name|occupiedMapSlots
argument_list|,
name|occupiedReduceSlots
argument_list|,
name|reservedMapSlots
argument_list|,
name|reservedReduceSlots
argument_list|,
name|totalMapTaskCapacity
argument_list|,
name|totalReduceTaskCapacity
argument_list|,
name|totalSubmissions
argument_list|,
name|taskTrackers
operator|.
name|size
argument_list|()
operator|-
name|getBlacklistedTrackerCount
argument_list|()
argument_list|,
name|getBlacklistedTrackerCount
argument_list|()
argument_list|,
name|getExcludedNodes
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * @deprecated Use {@link #getJobTrackerStatus()} instead.    */
annotation|@
name|Deprecated
specifier|public
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|server
operator|.
name|jobtracker
operator|.
name|State
DECL|method|getJobTrackerState ()
name|getJobTrackerState
parameter_list|()
block|{
return|return
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|server
operator|.
name|jobtracker
operator|.
name|State
operator|.
name|valueOf
argument_list|(
name|state
operator|.
name|name
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|getJobTrackerStatus ()
specifier|public
name|JobTrackerStatus
name|getJobTrackerStatus
parameter_list|()
block|{
return|return
name|JobTrackerStatus
operator|.
name|valueOf
argument_list|(
name|state
operator|.
name|name
argument_list|()
argument_list|)
return|;
block|}
DECL|method|getTaskTrackerExpiryInterval ()
specifier|public
name|long
name|getTaskTrackerExpiryInterval
parameter_list|()
block|{
return|return
name|tasktrackerExpiryInterval
return|;
block|}
comment|/**     * Get all active trackers in cluster.     * @return array of TaskTrackerInfo    */
DECL|method|getActiveTrackers ()
specifier|public
name|TaskTrackerInfo
index|[]
name|getActiveTrackers
parameter_list|()
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|List
argument_list|<
name|String
argument_list|>
name|activeTrackers
init|=
name|taskTrackerNames
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|TaskTrackerInfo
index|[]
name|info
init|=
operator|new
name|TaskTrackerInfo
index|[
name|activeTrackers
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|activeTrackers
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|info
index|[
name|i
index|]
operator|=
operator|new
name|TaskTrackerInfo
argument_list|(
name|activeTrackers
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|info
return|;
block|}
comment|/**     * Get all blacklisted trackers in cluster.     * @return array of TaskTrackerInfo    */
DECL|method|getBlacklistedTrackers ()
specifier|public
name|TaskTrackerInfo
index|[]
name|getBlacklistedTrackers
parameter_list|()
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|Collection
argument_list|<
name|BlackListInfo
argument_list|>
name|blackListed
init|=
name|getBlackListedTrackers
argument_list|()
decl_stmt|;
name|TaskTrackerInfo
index|[]
name|info
init|=
operator|new
name|TaskTrackerInfo
index|[
name|blackListed
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|BlackListInfo
name|binfo
range|:
name|blackListed
control|)
block|{
name|info
index|[
name|i
operator|++
index|]
operator|=
operator|new
name|TaskTrackerInfo
argument_list|(
name|binfo
operator|.
name|getTrackerName
argument_list|()
argument_list|,
name|binfo
operator|.
name|getReasonForBlackListing
argument_list|()
argument_list|,
name|binfo
operator|.
name|getBlackListReport
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|info
return|;
block|}
comment|/**    * @see ClientProtocol#killJob(org.apache.hadoop.mapreduce.JobID)    */
annotation|@
name|Override
DECL|method|killJob (org.apache.hadoop.mapreduce.JobID jobid)
specifier|public
specifier|synchronized
name|void
name|killJob
parameter_list|(
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|JobID
name|jobid
parameter_list|)
throws|throws
name|IOException
block|{
name|killJob
argument_list|(
name|JobID
operator|.
name|downgrade
argument_list|(
name|jobid
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * @deprecated Use {@link #killJob(org.apache.hadoop.mapreduce.JobID)} instead     */
annotation|@
name|Deprecated
DECL|method|killJob (JobID jobid)
specifier|public
specifier|synchronized
name|void
name|killJob
parameter_list|(
name|JobID
name|jobid
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
literal|null
operator|==
name|jobid
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Null jobid object sent to JobTracker.killJob()"
argument_list|)
expr_stmt|;
return|return;
block|}
name|JobInProgress
name|job
init|=
name|jobs
operator|.
name|get
argument_list|(
name|jobid
argument_list|)
decl_stmt|;
if|if
condition|(
literal|null
operator|==
name|job
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"killJob(): JobId "
operator|+
name|jobid
operator|.
name|toString
argument_list|()
operator|+
literal|" is not a valid job"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// check both queue-level and job-level access
name|aclsManager
operator|.
name|checkAccess
argument_list|(
name|job
argument_list|,
name|UserGroupInformation
operator|.
name|getCurrentUser
argument_list|()
argument_list|,
name|Operation
operator|.
name|KILL_JOB
argument_list|)
expr_stmt|;
name|killJob
argument_list|(
name|job
argument_list|)
expr_stmt|;
block|}
DECL|method|killJob (JobInProgress job)
specifier|private
specifier|synchronized
name|void
name|killJob
parameter_list|(
name|JobInProgress
name|job
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Killing job "
operator|+
name|job
operator|.
name|getJobID
argument_list|()
argument_list|)
expr_stmt|;
name|JobStatus
name|prevStatus
init|=
operator|(
name|JobStatus
operator|)
name|job
operator|.
name|getStatus
argument_list|()
operator|.
name|clone
argument_list|()
decl_stmt|;
name|job
operator|.
name|kill
argument_list|()
expr_stmt|;
comment|// Inform the listeners if the job is killed
comment|// Note :
comment|//   If the job is killed in the PREP state then the listeners will be
comment|//   invoked
comment|//   If the job is killed in the RUNNING state then cleanup tasks will be
comment|//   launched and the updateTaskStatuses() will take care of it
name|JobStatus
name|newStatus
init|=
operator|(
name|JobStatus
operator|)
name|job
operator|.
name|getStatus
argument_list|()
operator|.
name|clone
argument_list|()
decl_stmt|;
if|if
condition|(
name|prevStatus
operator|.
name|getRunState
argument_list|()
operator|!=
name|newStatus
operator|.
name|getRunState
argument_list|()
operator|&&
name|newStatus
operator|.
name|getRunState
argument_list|()
operator|==
name|JobStatus
operator|.
name|KILLED
condition|)
block|{
name|JobStatusChangeEvent
name|event
init|=
operator|new
name|JobStatusChangeEvent
argument_list|(
name|job
argument_list|,
name|EventType
operator|.
name|RUN_STATE_CHANGED
argument_list|,
name|prevStatus
argument_list|,
name|newStatus
argument_list|)
decl_stmt|;
name|updateJobInProgressListeners
argument_list|(
name|event
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Initialize a job and inform the listeners about a state change, if any.    * Other components in the framework should use this api to initialize a job.    */
DECL|method|initJob (JobInProgress job)
specifier|public
name|void
name|initJob
parameter_list|(
name|JobInProgress
name|job
parameter_list|)
block|{
if|if
condition|(
literal|null
operator|==
name|job
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Init on null job is not valid"
argument_list|)
expr_stmt|;
return|return;
block|}
try|try
block|{
name|JobStatus
name|prevStatus
init|=
operator|(
name|JobStatus
operator|)
name|job
operator|.
name|getStatus
argument_list|()
operator|.
name|clone
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Initializing "
operator|+
name|job
operator|.
name|getJobID
argument_list|()
argument_list|)
expr_stmt|;
name|job
operator|.
name|initTasks
argument_list|()
expr_stmt|;
comment|// Here the job *should* be in the PREP state.
comment|// From here there are 3 ways :
comment|//  - job requires setup : the job remains in PREP state and
comment|//    setup is launched to move the job in RUNNING state
comment|//  - job is complete (no setup required and no tasks) : complete
comment|//    the job and move it to SUCCEEDED
comment|//  - job has tasks but doesnt require setup : make the job RUNNING.
if|if
condition|(
name|job
operator|.
name|isJobEmpty
argument_list|()
condition|)
block|{
comment|// is the job empty?
name|completeEmptyJob
argument_list|(
name|job
argument_list|)
expr_stmt|;
comment|// complete it
block|}
elseif|else
if|if
condition|(
operator|!
name|job
operator|.
name|isSetupCleanupRequired
argument_list|()
condition|)
block|{
comment|// setup/cleanup not required
name|job
operator|.
name|completeSetup
argument_list|()
expr_stmt|;
comment|// complete setup and make job running
block|}
comment|// Inform the listeners if the job state has changed
comment|// Note :
comment|//   If job does not require setup, job state will be RUNNING
comment|//   If job is configured with 0 maps, 0 reduces and no setup-cleanup then
comment|//   the job state will be SUCCEEDED
comment|//   otherwise, job state is PREP.
name|JobStatus
name|newStatus
init|=
operator|(
name|JobStatus
operator|)
name|job
operator|.
name|getStatus
argument_list|()
operator|.
name|clone
argument_list|()
decl_stmt|;
if|if
condition|(
name|prevStatus
operator|.
name|getRunState
argument_list|()
operator|!=
name|newStatus
operator|.
name|getRunState
argument_list|()
condition|)
block|{
name|JobStatusChangeEvent
name|event
init|=
operator|new
name|JobStatusChangeEvent
argument_list|(
name|job
argument_list|,
name|EventType
operator|.
name|RUN_STATE_CHANGED
argument_list|,
name|prevStatus
argument_list|,
name|newStatus
argument_list|)
decl_stmt|;
synchronized|synchronized
init|(
name|JobTracker
operator|.
name|this
init|)
block|{
name|updateJobInProgressListeners
argument_list|(
name|event
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|KillInterruptedException
name|kie
parameter_list|)
block|{
comment|//   If job was killed during initialization, job state will be KILLED
name|LOG
operator|.
name|error
argument_list|(
literal|"Job initialization interrupted :\n"
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|kie
argument_list|)
argument_list|)
expr_stmt|;
name|killJob
argument_list|(
name|job
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
comment|//    If the job initialization is failed, job state will be FAILED
name|LOG
operator|.
name|error
argument_list|(
literal|"Job initialization failed:\n"
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|failJob
argument_list|(
name|job
argument_list|)
expr_stmt|;
block|}
block|}
comment|// This simply marks the job as completed. Note that the caller is responsible
comment|// for raising events.
DECL|method|completeEmptyJob (JobInProgress job)
specifier|private
specifier|synchronized
name|void
name|completeEmptyJob
parameter_list|(
name|JobInProgress
name|job
parameter_list|)
block|{
name|job
operator|.
name|completeEmptyJob
argument_list|()
expr_stmt|;
block|}
comment|/**    * Fail a job and inform the listeners. Other components in the framework     * should use this to fail a job.    */
DECL|method|failJob (JobInProgress job)
specifier|public
specifier|synchronized
name|void
name|failJob
parameter_list|(
name|JobInProgress
name|job
parameter_list|)
block|{
if|if
condition|(
literal|null
operator|==
name|job
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Fail on null job is not valid"
argument_list|)
expr_stmt|;
return|return;
block|}
name|JobStatus
name|prevStatus
init|=
operator|(
name|JobStatus
operator|)
name|job
operator|.
name|getStatus
argument_list|()
operator|.
name|clone
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Failing job "
operator|+
name|job
operator|.
name|getJobID
argument_list|()
argument_list|)
expr_stmt|;
name|job
operator|.
name|fail
argument_list|()
expr_stmt|;
comment|// Inform the listeners if the job state has changed
name|JobStatus
name|newStatus
init|=
operator|(
name|JobStatus
operator|)
name|job
operator|.
name|getStatus
argument_list|()
operator|.
name|clone
argument_list|()
decl_stmt|;
if|if
condition|(
name|prevStatus
operator|.
name|getRunState
argument_list|()
operator|!=
name|newStatus
operator|.
name|getRunState
argument_list|()
condition|)
block|{
name|JobStatusChangeEvent
name|event
init|=
operator|new
name|JobStatusChangeEvent
argument_list|(
name|job
argument_list|,
name|EventType
operator|.
name|RUN_STATE_CHANGED
argument_list|,
name|prevStatus
argument_list|,
name|newStatus
argument_list|)
decl_stmt|;
name|updateJobInProgressListeners
argument_list|(
name|event
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Set the priority of a job    * @param jobid    * @param priority    * @throws IOException    */
DECL|method|setJobPriority (org.apache.hadoop.mapreduce.JobID jobid, String priority)
specifier|public
specifier|synchronized
name|void
name|setJobPriority
parameter_list|(
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|JobID
name|jobid
parameter_list|,
name|String
name|priority
parameter_list|)
throws|throws
name|IOException
block|{
name|setJobPriority
argument_list|(
name|JobID
operator|.
name|downgrade
argument_list|(
name|jobid
argument_list|)
argument_list|,
name|priority
argument_list|)
expr_stmt|;
block|}
comment|/**    * Set the priority of a job    * @param jobid id of the job    * @param priority new priority of the job    * @deprecated Use     * {@link #setJobPriority(org.apache.hadoop.mapreduce.JobID, String)} instead    */
annotation|@
name|Deprecated
DECL|method|setJobPriority (JobID jobid, String priority)
specifier|public
specifier|synchronized
name|void
name|setJobPriority
parameter_list|(
name|JobID
name|jobid
parameter_list|,
name|String
name|priority
parameter_list|)
throws|throws
name|IOException
block|{
name|JobInProgress
name|job
init|=
name|jobs
operator|.
name|get
argument_list|(
name|jobid
argument_list|)
decl_stmt|;
if|if
condition|(
literal|null
operator|==
name|job
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"setJobPriority(): JobId "
operator|+
name|jobid
operator|.
name|toString
argument_list|()
operator|+
literal|" is not a valid job"
argument_list|)
expr_stmt|;
return|return;
block|}
name|JobPriority
name|newPriority
init|=
name|JobPriority
operator|.
name|valueOf
argument_list|(
name|priority
argument_list|)
decl_stmt|;
name|setJobPriority
argument_list|(
name|jobid
argument_list|,
name|newPriority
argument_list|)
expr_stmt|;
block|}
DECL|method|storeCompletedJob (JobInProgress job)
name|void
name|storeCompletedJob
parameter_list|(
name|JobInProgress
name|job
parameter_list|)
block|{
comment|//persists the job info in DFS
name|completedJobStatusStore
operator|.
name|store
argument_list|(
name|job
argument_list|)
expr_stmt|;
block|}
DECL|method|getJobProfile (org.apache.hadoop.mapreduce.JobID jobid)
specifier|public
name|JobProfile
name|getJobProfile
parameter_list|(
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|JobID
name|jobid
parameter_list|)
block|{
return|return
name|getJobProfile
argument_list|(
name|JobID
operator|.
name|downgrade
argument_list|(
name|jobid
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Check if the<code>job</code> has been initialized.    *     * @param job {@link JobInProgress} to be checked    * @return<code>true</code> if the job has been initialized,    *<code>false</code> otherwise    */
DECL|method|isJobInited (JobInProgress job)
specifier|private
name|boolean
name|isJobInited
parameter_list|(
name|JobInProgress
name|job
parameter_list|)
block|{
return|return
name|job
operator|.
name|inited
argument_list|()
return|;
block|}
comment|/**    * @deprecated Use {@link #getJobProfile(org.apache.hadoop.mapreduce.JobID)}     * instead    */
annotation|@
name|Deprecated
DECL|method|getJobProfile (JobID jobid)
specifier|public
name|JobProfile
name|getJobProfile
parameter_list|(
name|JobID
name|jobid
parameter_list|)
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
name|JobInProgress
name|job
init|=
name|jobs
operator|.
name|get
argument_list|(
name|jobid
argument_list|)
decl_stmt|;
if|if
condition|(
name|job
operator|!=
literal|null
condition|)
block|{
comment|// Safe to call JobInProgress.getProfile while holding the lock
comment|// on the JobTracker since it isn't a synchronized method
return|return
name|job
operator|.
name|getProfile
argument_list|()
return|;
block|}
block|}
return|return
name|completedJobStatusStore
operator|.
name|readJobProfile
argument_list|(
name|jobid
argument_list|)
return|;
block|}
comment|/**    * see {@link ClientProtocol#getJobStatus(org.apache.hadoop.mapreduce.JobID)}    */
annotation|@
name|Override
DECL|method|getJobStatus (org.apache.hadoop.mapreduce.JobID jobid)
specifier|public
name|JobStatus
name|getJobStatus
parameter_list|(
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|JobID
name|jobid
parameter_list|)
block|{
return|return
name|getJobStatus
argument_list|(
name|JobID
operator|.
name|downgrade
argument_list|(
name|jobid
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * @deprecated Use     * {@link #getJobStatus(org.apache.hadoop.mapreduce.JobID)} instead    */
annotation|@
name|Deprecated
DECL|method|getJobStatus (JobID jobid)
specifier|public
name|JobStatus
name|getJobStatus
parameter_list|(
name|JobID
name|jobid
parameter_list|)
block|{
if|if
condition|(
literal|null
operator|==
name|jobid
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"JobTracker.getJobStatus() cannot get status for null jobid"
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
synchronized|synchronized
init|(
name|this
init|)
block|{
name|JobInProgress
name|job
init|=
name|jobs
operator|.
name|get
argument_list|(
name|jobid
argument_list|)
decl_stmt|;
if|if
condition|(
name|job
operator|!=
literal|null
condition|)
block|{
comment|// Safe to call JobInProgress.getStatus while holding the lock
comment|// on the JobTracker since it isn't a synchronized method
return|return
name|job
operator|.
name|getStatus
argument_list|()
return|;
block|}
else|else
block|{
name|JobStatus
name|status
init|=
name|retireJobs
operator|.
name|get
argument_list|(
name|jobid
argument_list|)
decl_stmt|;
if|if
condition|(
name|status
operator|!=
literal|null
condition|)
block|{
return|return
name|status
return|;
block|}
block|}
block|}
return|return
name|completedJobStatusStore
operator|.
name|readJobStatus
argument_list|(
name|jobid
argument_list|)
return|;
block|}
DECL|field|EMPTY_COUNTERS
specifier|private
specifier|static
specifier|final
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|Counters
name|EMPTY_COUNTERS
init|=
operator|new
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|Counters
argument_list|()
decl_stmt|;
comment|/**    * see    * {@link ClientProtocol#getJobCounters(org.apache.hadoop.mapreduce.JobID)}    *     * @throws IOException    * @throws AccessControlException    */
annotation|@
name|Override
DECL|method|getJobCounters ( org.apache.hadoop.mapreduce.JobID jobid)
specifier|public
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|Counters
name|getJobCounters
parameter_list|(
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|JobID
name|jobid
parameter_list|)
throws|throws
name|AccessControlException
throws|,
name|IOException
block|{
name|JobID
name|oldJobID
init|=
name|JobID
operator|.
name|downgrade
argument_list|(
name|jobid
argument_list|)
decl_stmt|;
name|JobInProgress
name|job
decl_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
name|job
operator|=
name|jobs
operator|.
name|get
argument_list|(
name|oldJobID
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|job
operator|!=
literal|null
condition|)
block|{
comment|// check the job-access
name|aclsManager
operator|.
name|checkAccess
argument_list|(
name|job
argument_list|,
name|UserGroupInformation
operator|.
name|getCurrentUser
argument_list|()
argument_list|,
name|Operation
operator|.
name|VIEW_JOB_COUNTERS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isJobInited
argument_list|(
name|job
argument_list|)
condition|)
block|{
return|return
name|EMPTY_COUNTERS
return|;
block|}
name|Counters
name|counters
init|=
name|job
operator|.
name|getCounters
argument_list|()
decl_stmt|;
if|if
condition|(
name|counters
operator|!=
literal|null
condition|)
block|{
return|return
operator|new
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|Counters
argument_list|(
name|counters
argument_list|)
return|;
block|}
return|return
literal|null
return|;
block|}
name|Counters
name|counters
init|=
name|completedJobStatusStore
operator|.
name|readCounters
argument_list|(
name|oldJobID
argument_list|)
decl_stmt|;
if|if
condition|(
name|counters
operator|!=
literal|null
condition|)
block|{
return|return
operator|new
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|Counters
argument_list|(
name|counters
argument_list|)
return|;
block|}
return|return
literal|null
return|;
block|}
comment|/**    * @deprecated Use     * {@link #getJobCounters(org.apache.hadoop.mapreduce.JobID)} instead    */
annotation|@
name|Deprecated
DECL|method|getJobCounters (JobID jobid)
specifier|public
name|Counters
name|getJobCounters
parameter_list|(
name|JobID
name|jobid
parameter_list|)
block|{
try|try
block|{
return|return
name|Counters
operator|.
name|downgrade
argument_list|(
name|getJobCounters
argument_list|(
operator|(
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|JobID
operator|)
name|jobid
argument_list|)
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|AccessControlException
name|e
parameter_list|)
block|{
return|return
literal|null
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
return|return
literal|null
return|;
block|}
block|}
DECL|field|EMPTY_TASK_REPORTS
specifier|private
specifier|static
specifier|final
name|TaskReport
index|[]
name|EMPTY_TASK_REPORTS
init|=
operator|new
name|TaskReport
index|[
literal|0
index|]
decl_stmt|;
comment|/**    * @param jobid    * @return array of TaskReport    * @deprecated Use     * {@link #getTaskReports(org.apache.hadoop.mapreduce.JobID, TaskType)}     * instead    */
annotation|@
name|Deprecated
DECL|method|getMapTaskReports (JobID jobid)
specifier|public
specifier|synchronized
name|TaskReport
index|[]
name|getMapTaskReports
parameter_list|(
name|JobID
name|jobid
parameter_list|)
block|{
name|JobInProgress
name|job
init|=
name|jobs
operator|.
name|get
argument_list|(
name|jobid
argument_list|)
decl_stmt|;
if|if
condition|(
name|job
operator|==
literal|null
operator|||
operator|!
name|isJobInited
argument_list|(
name|job
argument_list|)
condition|)
block|{
return|return
name|EMPTY_TASK_REPORTS
return|;
block|}
else|else
block|{
name|Vector
argument_list|<
name|TaskReport
argument_list|>
name|reports
init|=
operator|new
name|Vector
argument_list|<
name|TaskReport
argument_list|>
argument_list|()
decl_stmt|;
name|Vector
argument_list|<
name|TaskInProgress
argument_list|>
name|completeMapTasks
init|=
name|job
operator|.
name|reportTasksInProgress
argument_list|(
literal|true
argument_list|,
literal|true
argument_list|)
decl_stmt|;
for|for
control|(
name|Iterator
name|it
init|=
name|completeMapTasks
operator|.
name|iterator
argument_list|()
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|TaskInProgress
name|tip
init|=
operator|(
name|TaskInProgress
operator|)
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|reports
operator|.
name|add
argument_list|(
name|tip
operator|.
name|generateSingleReport
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|Vector
argument_list|<
name|TaskInProgress
argument_list|>
name|incompleteMapTasks
init|=
name|job
operator|.
name|reportTasksInProgress
argument_list|(
literal|true
argument_list|,
literal|false
argument_list|)
decl_stmt|;
for|for
control|(
name|Iterator
name|it
init|=
name|incompleteMapTasks
operator|.
name|iterator
argument_list|()
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|TaskInProgress
name|tip
init|=
operator|(
name|TaskInProgress
operator|)
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|reports
operator|.
name|add
argument_list|(
name|tip
operator|.
name|generateSingleReport
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|reports
operator|.
name|toArray
argument_list|(
operator|new
name|TaskReport
index|[
name|reports
operator|.
name|size
argument_list|()
index|]
argument_list|)
return|;
block|}
block|}
comment|/**    * @param jobid    * @return array of TaskReport    * @deprecated Use     * {@link #getTaskReports(org.apache.hadoop.mapreduce.JobID, TaskType)}     * instead    */
annotation|@
name|Deprecated
DECL|method|getReduceTaskReports (JobID jobid)
specifier|public
specifier|synchronized
name|TaskReport
index|[]
name|getReduceTaskReports
parameter_list|(
name|JobID
name|jobid
parameter_list|)
block|{
name|JobInProgress
name|job
init|=
name|jobs
operator|.
name|get
argument_list|(
name|jobid
argument_list|)
decl_stmt|;
if|if
condition|(
name|job
operator|==
literal|null
operator|||
operator|!
name|isJobInited
argument_list|(
name|job
argument_list|)
condition|)
block|{
return|return
name|EMPTY_TASK_REPORTS
return|;
block|}
else|else
block|{
name|Vector
argument_list|<
name|TaskReport
argument_list|>
name|reports
init|=
operator|new
name|Vector
argument_list|<
name|TaskReport
argument_list|>
argument_list|()
decl_stmt|;
name|Vector
name|completeReduceTasks
init|=
name|job
operator|.
name|reportTasksInProgress
argument_list|(
literal|false
argument_list|,
literal|true
argument_list|)
decl_stmt|;
for|for
control|(
name|Iterator
name|it
init|=
name|completeReduceTasks
operator|.
name|iterator
argument_list|()
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|TaskInProgress
name|tip
init|=
operator|(
name|TaskInProgress
operator|)
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|reports
operator|.
name|add
argument_list|(
name|tip
operator|.
name|generateSingleReport
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|Vector
name|incompleteReduceTasks
init|=
name|job
operator|.
name|reportTasksInProgress
argument_list|(
literal|false
argument_list|,
literal|false
argument_list|)
decl_stmt|;
for|for
control|(
name|Iterator
name|it
init|=
name|incompleteReduceTasks
operator|.
name|iterator
argument_list|()
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|TaskInProgress
name|tip
init|=
operator|(
name|TaskInProgress
operator|)
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|reports
operator|.
name|add
argument_list|(
name|tip
operator|.
name|generateSingleReport
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|reports
operator|.
name|toArray
argument_list|(
operator|new
name|TaskReport
index|[
name|reports
operator|.
name|size
argument_list|()
index|]
argument_list|)
return|;
block|}
block|}
comment|/**    * @param jobid    * @return array of TaskReport    * @deprecated Use     * {@link #getTaskReports(org.apache.hadoop.mapreduce.JobID, TaskType)}     * instead    */
annotation|@
name|Deprecated
DECL|method|getCleanupTaskReports (JobID jobid)
specifier|public
specifier|synchronized
name|TaskReport
index|[]
name|getCleanupTaskReports
parameter_list|(
name|JobID
name|jobid
parameter_list|)
block|{
name|JobInProgress
name|job
init|=
name|jobs
operator|.
name|get
argument_list|(
name|jobid
argument_list|)
decl_stmt|;
if|if
condition|(
name|job
operator|==
literal|null
operator|||
operator|!
name|isJobInited
argument_list|(
name|job
argument_list|)
condition|)
block|{
return|return
name|EMPTY_TASK_REPORTS
return|;
block|}
else|else
block|{
name|Vector
argument_list|<
name|TaskReport
argument_list|>
name|reports
init|=
operator|new
name|Vector
argument_list|<
name|TaskReport
argument_list|>
argument_list|()
decl_stmt|;
name|Vector
argument_list|<
name|TaskInProgress
argument_list|>
name|completeTasks
init|=
name|job
operator|.
name|reportCleanupTIPs
argument_list|(
literal|true
argument_list|)
decl_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|TaskInProgress
argument_list|>
name|it
init|=
name|completeTasks
operator|.
name|iterator
argument_list|()
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|TaskInProgress
name|tip
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|reports
operator|.
name|add
argument_list|(
name|tip
operator|.
name|generateSingleReport
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|Vector
argument_list|<
name|TaskInProgress
argument_list|>
name|incompleteTasks
init|=
name|job
operator|.
name|reportCleanupTIPs
argument_list|(
literal|false
argument_list|)
decl_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|TaskInProgress
argument_list|>
name|it
init|=
name|incompleteTasks
operator|.
name|iterator
argument_list|()
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|TaskInProgress
name|tip
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|reports
operator|.
name|add
argument_list|(
name|tip
operator|.
name|generateSingleReport
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|reports
operator|.
name|toArray
argument_list|(
operator|new
name|TaskReport
index|[
name|reports
operator|.
name|size
argument_list|()
index|]
argument_list|)
return|;
block|}
block|}
comment|/**    * @param jobid    * @return array of TaskReport    * @deprecated Use     * {@link #getTaskReports(org.apache.hadoop.mapreduce.JobID, TaskType)}     * instead    */
annotation|@
name|Deprecated
DECL|method|getSetupTaskReports (JobID jobid)
specifier|public
specifier|synchronized
name|TaskReport
index|[]
name|getSetupTaskReports
parameter_list|(
name|JobID
name|jobid
parameter_list|)
block|{
name|JobInProgress
name|job
init|=
name|jobs
operator|.
name|get
argument_list|(
name|jobid
argument_list|)
decl_stmt|;
if|if
condition|(
name|job
operator|==
literal|null
operator|||
operator|!
name|isJobInited
argument_list|(
name|job
argument_list|)
condition|)
block|{
return|return
name|EMPTY_TASK_REPORTS
return|;
block|}
else|else
block|{
name|Vector
argument_list|<
name|TaskReport
argument_list|>
name|reports
init|=
operator|new
name|Vector
argument_list|<
name|TaskReport
argument_list|>
argument_list|()
decl_stmt|;
name|Vector
argument_list|<
name|TaskInProgress
argument_list|>
name|completeTasks
init|=
name|job
operator|.
name|reportSetupTIPs
argument_list|(
literal|true
argument_list|)
decl_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|TaskInProgress
argument_list|>
name|it
init|=
name|completeTasks
operator|.
name|iterator
argument_list|()
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|TaskInProgress
name|tip
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|reports
operator|.
name|add
argument_list|(
name|tip
operator|.
name|generateSingleReport
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|Vector
argument_list|<
name|TaskInProgress
argument_list|>
name|incompleteTasks
init|=
name|job
operator|.
name|reportSetupTIPs
argument_list|(
literal|false
argument_list|)
decl_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|TaskInProgress
argument_list|>
name|it
init|=
name|incompleteTasks
operator|.
name|iterator
argument_list|()
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|TaskInProgress
name|tip
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|reports
operator|.
name|add
argument_list|(
name|tip
operator|.
name|generateSingleReport
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|reports
operator|.
name|toArray
argument_list|(
operator|new
name|TaskReport
index|[
name|reports
operator|.
name|size
argument_list|()
index|]
argument_list|)
return|;
block|}
block|}
comment|/**    * see    * {@link ClientProtocol#getTaskReports(org.apache.hadoop.mapreduce.JobID, TaskType)}    * @throws IOException     * @throws AccessControlException     */
annotation|@
name|Override
DECL|method|getTaskReports ( org.apache.hadoop.mapreduce.JobID jobid, TaskType type)
specifier|public
specifier|synchronized
name|TaskReport
index|[]
name|getTaskReports
parameter_list|(
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|JobID
name|jobid
parameter_list|,
name|TaskType
name|type
parameter_list|)
throws|throws
name|AccessControlException
throws|,
name|IOException
block|{
comment|// Check authorization
name|JobInProgress
name|job
init|=
name|jobs
operator|.
name|get
argument_list|(
name|jobid
argument_list|)
decl_stmt|;
if|if
condition|(
name|job
operator|!=
literal|null
condition|)
block|{
name|aclsManager
operator|.
name|checkAccess
argument_list|(
name|job
argument_list|,
name|UserGroupInformation
operator|.
name|getCurrentUser
argument_list|()
argument_list|,
name|Operation
operator|.
name|VIEW_JOB_DETAILS
argument_list|)
expr_stmt|;
block|}
else|else
block|{
return|return
name|EMPTY_TASK_REPORTS
return|;
block|}
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|MAP
case|:
return|return
name|getMapTaskReports
argument_list|(
name|JobID
operator|.
name|downgrade
argument_list|(
name|jobid
argument_list|)
argument_list|)
return|;
case|case
name|REDUCE
case|:
return|return
name|getReduceTaskReports
argument_list|(
name|JobID
operator|.
name|downgrade
argument_list|(
name|jobid
argument_list|)
argument_list|)
return|;
case|case
name|JOB_CLEANUP
case|:
return|return
name|getCleanupTaskReports
argument_list|(
name|JobID
operator|.
name|downgrade
argument_list|(
name|jobid
argument_list|)
argument_list|)
return|;
case|case
name|JOB_SETUP
case|:
return|return
name|getSetupTaskReports
argument_list|(
name|JobID
operator|.
name|downgrade
argument_list|(
name|jobid
argument_list|)
argument_list|)
return|;
block|}
return|return
name|EMPTY_TASK_REPORTS
return|;
block|}
comment|/*     * Returns a list of TaskCompletionEvent for the given job,     * starting from fromEventId.    */
DECL|method|getTaskCompletionEvents ( org.apache.hadoop.mapreduce.JobID jobid, int fromEventId, int maxEvents)
specifier|public
name|TaskCompletionEvent
index|[]
name|getTaskCompletionEvents
parameter_list|(
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|JobID
name|jobid
parameter_list|,
name|int
name|fromEventId
parameter_list|,
name|int
name|maxEvents
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|getTaskCompletionEvents
argument_list|(
name|JobID
operator|.
name|downgrade
argument_list|(
name|jobid
argument_list|)
argument_list|,
name|fromEventId
argument_list|,
name|maxEvents
argument_list|)
return|;
block|}
comment|/*     * Returns a list of TaskCompletionEvent for the given job,     * starting from fromEventId.    * @see org.apache.hadoop.mapred.JobSubmissionProtocol#getTaskCompletionEvents(java.lang.String, int, int)    */
annotation|@
name|Deprecated
DECL|method|getTaskCompletionEvents ( JobID jobid, int fromEventId, int maxEvents)
specifier|public
name|TaskCompletionEvent
index|[]
name|getTaskCompletionEvents
parameter_list|(
name|JobID
name|jobid
parameter_list|,
name|int
name|fromEventId
parameter_list|,
name|int
name|maxEvents
parameter_list|)
throws|throws
name|IOException
block|{
name|JobInProgress
name|job
init|=
name|this
operator|.
name|jobs
operator|.
name|get
argument_list|(
name|jobid
argument_list|)
decl_stmt|;
if|if
condition|(
literal|null
operator|!=
name|job
condition|)
block|{
return|return
name|job
operator|.
name|inited
argument_list|()
condition|?
name|job
operator|.
name|getTaskCompletionEvents
argument_list|(
name|fromEventId
argument_list|,
name|maxEvents
argument_list|)
else|:
name|TaskCompletionEvent
operator|.
name|EMPTY_ARRAY
return|;
block|}
return|return
name|completedJobStatusStore
operator|.
name|readJobTaskCompletionEvents
argument_list|(
name|jobid
argument_list|,
name|fromEventId
argument_list|,
name|maxEvents
argument_list|)
return|;
block|}
DECL|field|EMPTY_TASK_DIAGNOSTICS
specifier|private
specifier|static
specifier|final
name|String
index|[]
name|EMPTY_TASK_DIAGNOSTICS
init|=
operator|new
name|String
index|[
literal|0
index|]
decl_stmt|;
comment|/**    * Get the diagnostics for a given task    * @param taskId the id of the task    * @return an array of the diagnostic messages    */
DECL|method|getTaskDiagnostics ( org.apache.hadoop.mapreduce.TaskAttemptID taskId)
specifier|public
specifier|synchronized
name|String
index|[]
name|getTaskDiagnostics
parameter_list|(
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|TaskAttemptID
name|taskId
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|getTaskDiagnostics
argument_list|(
name|TaskAttemptID
operator|.
name|downgrade
argument_list|(
name|taskId
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Get the diagnostics for a given task    * @param taskId the id of the task    * @return an array of the diagnostic messages    */
annotation|@
name|Deprecated
DECL|method|getTaskDiagnostics (TaskAttemptID taskId)
specifier|public
specifier|synchronized
name|String
index|[]
name|getTaskDiagnostics
parameter_list|(
name|TaskAttemptID
name|taskId
parameter_list|)
throws|throws
name|IOException
block|{
name|List
argument_list|<
name|String
argument_list|>
name|taskDiagnosticInfo
init|=
literal|null
decl_stmt|;
name|JobID
name|jobId
init|=
name|taskId
operator|.
name|getJobID
argument_list|()
decl_stmt|;
name|TaskID
name|tipId
init|=
name|taskId
operator|.
name|getTaskID
argument_list|()
decl_stmt|;
name|JobInProgress
name|job
init|=
name|jobs
operator|.
name|get
argument_list|(
name|jobId
argument_list|)
decl_stmt|;
if|if
condition|(
name|job
operator|!=
literal|null
condition|)
block|{
comment|// check the access to the job.
name|aclsManager
operator|.
name|checkAccess
argument_list|(
name|job
argument_list|,
name|UserGroupInformation
operator|.
name|getCurrentUser
argument_list|()
argument_list|,
name|Operation
operator|.
name|VIEW_JOB_DETAILS
argument_list|)
expr_stmt|;
if|if
condition|(
name|isJobInited
argument_list|(
name|job
argument_list|)
condition|)
block|{
name|TaskInProgress
name|tip
init|=
name|job
operator|.
name|getTaskInProgress
argument_list|(
name|tipId
argument_list|)
decl_stmt|;
if|if
condition|(
name|tip
operator|!=
literal|null
condition|)
block|{
name|taskDiagnosticInfo
operator|=
name|tip
operator|.
name|getDiagnosticInfo
argument_list|(
name|taskId
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
operator|(
operator|(
name|taskDiagnosticInfo
operator|==
literal|null
operator|)
condition|?
name|EMPTY_TASK_DIAGNOSTICS
else|:
name|taskDiagnosticInfo
operator|.
name|toArray
argument_list|(
operator|new
name|String
index|[
name|taskDiagnosticInfo
operator|.
name|size
argument_list|()
index|]
argument_list|)
operator|)
return|;
block|}
comment|/** Get all the TaskStatuses from the tipid. */
DECL|method|getTaskStatuses (TaskID tipid)
name|TaskStatus
index|[]
name|getTaskStatuses
parameter_list|(
name|TaskID
name|tipid
parameter_list|)
block|{
name|TaskInProgress
name|tip
init|=
name|getTip
argument_list|(
name|tipid
argument_list|)
decl_stmt|;
return|return
operator|(
name|tip
operator|==
literal|null
condition|?
operator|new
name|TaskStatus
index|[
literal|0
index|]
else|:
name|tip
operator|.
name|getTaskStatuses
argument_list|()
operator|)
return|;
block|}
comment|/** Returns the TaskStatus for a particular taskid. */
DECL|method|getTaskStatus (TaskAttemptID taskid)
name|TaskStatus
name|getTaskStatus
parameter_list|(
name|TaskAttemptID
name|taskid
parameter_list|)
block|{
name|TaskInProgress
name|tip
init|=
name|getTip
argument_list|(
name|taskid
operator|.
name|getTaskID
argument_list|()
argument_list|)
decl_stmt|;
return|return
operator|(
name|tip
operator|==
literal|null
condition|?
literal|null
else|:
name|tip
operator|.
name|getTaskStatus
argument_list|(
name|taskid
argument_list|)
operator|)
return|;
block|}
comment|/**    * Returns the counters for the specified task in progress.    */
DECL|method|getTipCounters (TaskID tipid)
name|Counters
name|getTipCounters
parameter_list|(
name|TaskID
name|tipid
parameter_list|)
block|{
name|TaskInProgress
name|tip
init|=
name|getTip
argument_list|(
name|tipid
argument_list|)
decl_stmt|;
return|return
operator|(
name|tip
operator|==
literal|null
condition|?
literal|null
else|:
name|tip
operator|.
name|getCounters
argument_list|()
operator|)
return|;
block|}
comment|/**    * Returns the configured task scheduler for this job tracker.    * @return the configured task scheduler    */
DECL|method|getTaskScheduler ()
name|TaskScheduler
name|getTaskScheduler
parameter_list|()
block|{
return|return
name|taskScheduler
return|;
block|}
comment|/**    * Returns specified TaskInProgress, or null.    */
DECL|method|getTip (TaskID tipid)
specifier|public
name|TaskInProgress
name|getTip
parameter_list|(
name|TaskID
name|tipid
parameter_list|)
block|{
name|JobInProgress
name|job
init|=
name|jobs
operator|.
name|get
argument_list|(
name|tipid
operator|.
name|getJobID
argument_list|()
argument_list|)
decl_stmt|;
return|return
operator|(
name|job
operator|==
literal|null
condition|?
literal|null
else|:
name|job
operator|.
name|getTaskInProgress
argument_list|(
name|tipid
argument_list|)
operator|)
return|;
block|}
comment|/**    * @see org.apache.hadoop.mapreduce.protocol.ClientProtocol#killTask(org.apache.hadoop.mapreduce.TaskAttemptID,    *      boolean)    */
annotation|@
name|Override
DECL|method|killTask ( org.apache.hadoop.mapreduce.TaskAttemptID taskid, boolean shouldFail)
specifier|public
specifier|synchronized
name|boolean
name|killTask
parameter_list|(
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|TaskAttemptID
name|taskid
parameter_list|,
name|boolean
name|shouldFail
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|killTask
argument_list|(
name|TaskAttemptID
operator|.
name|downgrade
argument_list|(
name|taskid
argument_list|)
argument_list|,
name|shouldFail
argument_list|)
return|;
block|}
comment|/** Mark a Task to be killed */
annotation|@
name|Deprecated
DECL|method|killTask (TaskAttemptID taskid, boolean shouldFail)
specifier|public
specifier|synchronized
name|boolean
name|killTask
parameter_list|(
name|TaskAttemptID
name|taskid
parameter_list|,
name|boolean
name|shouldFail
parameter_list|)
throws|throws
name|IOException
block|{
name|TaskInProgress
name|tip
init|=
name|taskidToTIPMap
operator|.
name|get
argument_list|(
name|taskid
argument_list|)
decl_stmt|;
if|if
condition|(
name|tip
operator|!=
literal|null
condition|)
block|{
comment|// check both queue-level and job-level access
name|aclsManager
operator|.
name|checkAccess
argument_list|(
name|tip
operator|.
name|getJob
argument_list|()
argument_list|,
name|UserGroupInformation
operator|.
name|getCurrentUser
argument_list|()
argument_list|,
name|shouldFail
condition|?
name|Operation
operator|.
name|FAIL_TASK
else|:
name|Operation
operator|.
name|KILL_TASK
argument_list|)
expr_stmt|;
return|return
name|tip
operator|.
name|killTask
argument_list|(
name|taskid
argument_list|,
name|shouldFail
argument_list|)
return|;
block|}
else|else
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Kill task attempt failed since task "
operator|+
name|taskid
operator|+
literal|" was not found"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
comment|/**    * Get tracker name for a given task id.    * @param taskId the name of the task    * @return The name of the task tracker    */
DECL|method|getAssignedTracker (TaskAttemptID taskId)
specifier|public
specifier|synchronized
name|String
name|getAssignedTracker
parameter_list|(
name|TaskAttemptID
name|taskId
parameter_list|)
block|{
return|return
name|taskidToTrackerMap
operator|.
name|get
argument_list|(
name|taskId
argument_list|)
return|;
block|}
DECL|method|jobsToComplete ()
specifier|public
name|JobStatus
index|[]
name|jobsToComplete
parameter_list|()
block|{
return|return
name|getJobStatus
argument_list|(
name|jobs
operator|.
name|values
argument_list|()
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|/**    * @see org.apache.hadoop.mapreduce.protocol.ClientProtocol#getSystemDir()    */
DECL|method|getAllJobs ()
specifier|public
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|JobStatus
index|[]
name|getAllJobs
parameter_list|()
block|{
name|List
argument_list|<
name|JobStatus
argument_list|>
name|list
init|=
operator|new
name|ArrayList
argument_list|<
name|JobStatus
argument_list|>
argument_list|()
decl_stmt|;
name|list
operator|.
name|addAll
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|getJobStatus
argument_list|(
name|jobs
operator|.
name|values
argument_list|()
argument_list|,
literal|false
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|list
operator|.
name|addAll
argument_list|(
name|retireJobs
operator|.
name|getAll
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|list
operator|.
name|toArray
argument_list|(
operator|new
name|JobStatus
index|[
name|list
operator|.
name|size
argument_list|()
index|]
argument_list|)
return|;
block|}
comment|/**    * @see org.apache.hadoop.mapreduce.protocol.ClientProtocol#getSystemDir()    */
DECL|method|getSystemDir ()
specifier|public
name|String
name|getSystemDir
parameter_list|()
block|{
name|Path
name|sysDir
init|=
operator|new
name|Path
argument_list|(
name|conf
operator|.
name|get
argument_list|(
name|JTConfig
operator|.
name|JT_SYSTEM_DIR
argument_list|,
literal|"/tmp/hadoop/mapred/system"
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|fs
operator|.
name|makeQualified
argument_list|(
name|sysDir
argument_list|)
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * @throws LoginException     * @see org.apache.hadoop.mapreduce.protocol.ClientProtocol#getStagingAreaDir()    */
DECL|method|getStagingAreaDir ()
specifier|public
name|String
name|getStagingAreaDir
parameter_list|()
throws|throws
name|IOException
block|{
try|try
block|{
specifier|final
name|String
name|user
init|=
name|UserGroupInformation
operator|.
name|getCurrentUser
argument_list|()
operator|.
name|getShortUserName
argument_list|()
decl_stmt|;
return|return
name|getMROwner
argument_list|()
operator|.
name|doAs
argument_list|(
operator|new
name|PrivilegedExceptionAction
argument_list|<
name|String
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|String
name|run
parameter_list|()
throws|throws
name|Exception
block|{
name|Path
name|stagingRootDir
init|=
operator|new
name|Path
argument_list|(
name|conf
operator|.
name|get
argument_list|(
name|JTConfig
operator|.
name|JT_STAGING_AREA_ROOT
argument_list|,
literal|"/tmp/hadoop/mapred/staging"
argument_list|)
argument_list|)
decl_stmt|;
name|FileSystem
name|fs
init|=
name|stagingRootDir
operator|.
name|getFileSystem
argument_list|(
name|conf
argument_list|)
decl_stmt|;
return|return
name|fs
operator|.
name|makeQualified
argument_list|(
operator|new
name|Path
argument_list|(
name|stagingRootDir
argument_list|,
name|user
operator|+
literal|"/.staging"
argument_list|)
argument_list|)
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|ie
argument_list|)
throw|;
block|}
block|}
comment|/**    * @see     * org.apache.hadoop.mapreduce.protocol.ClientProtocol#getJobHistoryDir()    */
DECL|method|getJobHistoryDir ()
specifier|public
name|String
name|getJobHistoryDir
parameter_list|()
block|{
return|return
name|jobHistory
operator|.
name|getCompletedJobHistoryLocation
argument_list|()
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * @see org.apache.hadoop.mapreduce.protocol.ClientProtocol#getQueueAdmins(String)    */
DECL|method|getQueueAdmins (String queueName)
specifier|public
name|AccessControlList
name|getQueueAdmins
parameter_list|(
name|String
name|queueName
parameter_list|)
throws|throws
name|IOException
block|{
name|AccessControlList
name|acl
init|=
name|queueManager
operator|.
name|getQueueACL
argument_list|(
name|queueName
argument_list|,
name|QueueACL
operator|.
name|ADMINISTER_JOBS
argument_list|)
decl_stmt|;
if|if
condition|(
name|acl
operator|==
literal|null
condition|)
block|{
name|acl
operator|=
operator|new
name|AccessControlList
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
block|}
return|return
name|acl
return|;
block|}
comment|///////////////////////////////////////////////////////////////
comment|// JobTracker methods
comment|///////////////////////////////////////////////////////////////
DECL|method|getJob (JobID jobid)
specifier|public
name|JobInProgress
name|getJob
parameter_list|(
name|JobID
name|jobid
parameter_list|)
block|{
return|return
name|jobs
operator|.
name|get
argument_list|(
name|jobid
argument_list|)
return|;
block|}
comment|//Get the job directory in system directory
DECL|method|getSystemDirectoryForJob (JobID id)
name|Path
name|getSystemDirectoryForJob
parameter_list|(
name|JobID
name|id
parameter_list|)
block|{
return|return
operator|new
name|Path
argument_list|(
name|getSystemDir
argument_list|()
argument_list|,
name|id
operator|.
name|toString
argument_list|()
argument_list|)
return|;
block|}
comment|//Get the job token file in system directory
DECL|method|getSystemFileForJob (JobID id)
name|Path
name|getSystemFileForJob
parameter_list|(
name|JobID
name|id
parameter_list|)
block|{
return|return
operator|new
name|Path
argument_list|(
name|getSystemDirectoryForJob
argument_list|(
name|id
argument_list|)
operator|+
literal|"/"
operator|+
name|JOB_INFO_FILE
argument_list|)
return|;
block|}
comment|/**    * Change the run-time priority of the given job.    *     * @param jobId job id    * @param priority new {@link JobPriority} for the job    * @throws IOException    * @throws AccessControlException    */
DECL|method|setJobPriority (JobID jobId, JobPriority priority)
specifier|synchronized
name|void
name|setJobPriority
parameter_list|(
name|JobID
name|jobId
parameter_list|,
name|JobPriority
name|priority
parameter_list|)
throws|throws
name|AccessControlException
throws|,
name|IOException
block|{
name|JobInProgress
name|job
init|=
name|jobs
operator|.
name|get
argument_list|(
name|jobId
argument_list|)
decl_stmt|;
if|if
condition|(
name|job
operator|!=
literal|null
condition|)
block|{
comment|// check both queue-level and job-level access
name|aclsManager
operator|.
name|checkAccess
argument_list|(
name|job
argument_list|,
name|UserGroupInformation
operator|.
name|getCurrentUser
argument_list|()
argument_list|,
name|Operation
operator|.
name|SET_JOB_PRIORITY
argument_list|)
expr_stmt|;
synchronized|synchronized
init|(
name|taskScheduler
init|)
block|{
name|JobStatus
name|oldStatus
init|=
operator|(
name|JobStatus
operator|)
name|job
operator|.
name|getStatus
argument_list|()
operator|.
name|clone
argument_list|()
decl_stmt|;
name|job
operator|.
name|setPriority
argument_list|(
name|priority
argument_list|)
expr_stmt|;
name|JobStatus
name|newStatus
init|=
operator|(
name|JobStatus
operator|)
name|job
operator|.
name|getStatus
argument_list|()
operator|.
name|clone
argument_list|()
decl_stmt|;
name|JobStatusChangeEvent
name|event
init|=
operator|new
name|JobStatusChangeEvent
argument_list|(
name|job
argument_list|,
name|EventType
operator|.
name|PRIORITY_CHANGED
argument_list|,
name|oldStatus
argument_list|,
name|newStatus
argument_list|)
decl_stmt|;
name|updateJobInProgressListeners
argument_list|(
name|event
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Trying to change the priority of an unknown job: "
operator|+
name|jobId
argument_list|)
expr_stmt|;
block|}
block|}
comment|////////////////////////////////////////////////////
comment|// Methods to track all the TaskTrackers
comment|////////////////////////////////////////////////////
comment|/**    * Accept and process a new TaskTracker profile.  We might    * have known about the TaskTracker previously, or it might    * be brand-new.  All task-tracker structures have already    * been updated.  Just process the contained tasks and any    * jobs that might be affected.    */
DECL|method|updateTaskStatuses (TaskTrackerStatus status)
name|void
name|updateTaskStatuses
parameter_list|(
name|TaskTrackerStatus
name|status
parameter_list|)
block|{
name|String
name|trackerName
init|=
name|status
operator|.
name|getTrackerName
argument_list|()
decl_stmt|;
for|for
control|(
name|TaskStatus
name|report
range|:
name|status
operator|.
name|getTaskReports
argument_list|()
control|)
block|{
name|report
operator|.
name|setTaskTracker
argument_list|(
name|trackerName
argument_list|)
expr_stmt|;
name|TaskAttemptID
name|taskId
init|=
name|report
operator|.
name|getTaskID
argument_list|()
decl_stmt|;
comment|// expire it
name|expireLaunchingTasks
operator|.
name|removeTask
argument_list|(
name|taskId
argument_list|)
expr_stmt|;
name|JobInProgress
name|job
init|=
name|getJob
argument_list|(
name|taskId
operator|.
name|getJobID
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|job
operator|==
literal|null
condition|)
block|{
comment|// if job is not there in the cleanup list ... add it
synchronized|synchronized
init|(
name|trackerToJobsToCleanup
init|)
block|{
name|Set
argument_list|<
name|JobID
argument_list|>
name|jobs
init|=
name|trackerToJobsToCleanup
operator|.
name|get
argument_list|(
name|trackerName
argument_list|)
decl_stmt|;
if|if
condition|(
name|jobs
operator|==
literal|null
condition|)
block|{
name|jobs
operator|=
operator|new
name|HashSet
argument_list|<
name|JobID
argument_list|>
argument_list|()
expr_stmt|;
name|trackerToJobsToCleanup
operator|.
name|put
argument_list|(
name|trackerName
argument_list|,
name|jobs
argument_list|)
expr_stmt|;
block|}
name|jobs
operator|.
name|add
argument_list|(
name|taskId
operator|.
name|getJobID
argument_list|()
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
if|if
condition|(
operator|!
name|job
operator|.
name|inited
argument_list|()
condition|)
block|{
comment|// if job is not yet initialized ... kill the attempt
synchronized|synchronized
init|(
name|trackerToTasksToCleanup
init|)
block|{
name|Set
argument_list|<
name|TaskAttemptID
argument_list|>
name|tasks
init|=
name|trackerToTasksToCleanup
operator|.
name|get
argument_list|(
name|trackerName
argument_list|)
decl_stmt|;
if|if
condition|(
name|tasks
operator|==
literal|null
condition|)
block|{
name|tasks
operator|=
operator|new
name|HashSet
argument_list|<
name|TaskAttemptID
argument_list|>
argument_list|()
expr_stmt|;
name|trackerToTasksToCleanup
operator|.
name|put
argument_list|(
name|trackerName
argument_list|,
name|tasks
argument_list|)
expr_stmt|;
block|}
name|tasks
operator|.
name|add
argument_list|(
name|taskId
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
name|TaskInProgress
name|tip
init|=
name|taskidToTIPMap
operator|.
name|get
argument_list|(
name|taskId
argument_list|)
decl_stmt|;
if|if
condition|(
name|tip
operator|!=
literal|null
condition|)
block|{
comment|// Update the job and inform the listeners if necessary
name|JobStatus
name|prevStatus
init|=
operator|(
name|JobStatus
operator|)
name|job
operator|.
name|getStatus
argument_list|()
operator|.
name|clone
argument_list|()
decl_stmt|;
comment|// Clone TaskStatus object here, because JobInProgress
comment|// or TaskInProgress can modify this object and
comment|// the changes should not get reflected in TaskTrackerStatus.
comment|// An old TaskTrackerStatus is used later in countMapTasks, etc.
name|job
operator|.
name|updateTaskStatus
argument_list|(
name|tip
argument_list|,
operator|(
name|TaskStatus
operator|)
name|report
operator|.
name|clone
argument_list|()
argument_list|)
expr_stmt|;
name|JobStatus
name|newStatus
init|=
operator|(
name|JobStatus
operator|)
name|job
operator|.
name|getStatus
argument_list|()
operator|.
name|clone
argument_list|()
decl_stmt|;
comment|// Update the listeners if an incomplete job completes
if|if
condition|(
name|prevStatus
operator|.
name|getRunState
argument_list|()
operator|!=
name|newStatus
operator|.
name|getRunState
argument_list|()
condition|)
block|{
name|JobStatusChangeEvent
name|event
init|=
operator|new
name|JobStatusChangeEvent
argument_list|(
name|job
argument_list|,
name|EventType
operator|.
name|RUN_STATE_CHANGED
argument_list|,
name|prevStatus
argument_list|,
name|newStatus
argument_list|)
decl_stmt|;
name|updateJobInProgressListeners
argument_list|(
name|event
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Serious problem.  While updating status, cannot find taskid "
operator|+
name|report
operator|.
name|getTaskID
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Process 'failed fetch' notifications
name|List
argument_list|<
name|TaskAttemptID
argument_list|>
name|failedFetchMaps
init|=
name|report
operator|.
name|getFetchFailedMaps
argument_list|()
decl_stmt|;
if|if
condition|(
name|failedFetchMaps
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|TaskAttemptID
name|mapTaskId
range|:
name|failedFetchMaps
control|)
block|{
name|TaskInProgress
name|failedFetchMap
init|=
name|taskidToTIPMap
operator|.
name|get
argument_list|(
name|mapTaskId
argument_list|)
decl_stmt|;
if|if
condition|(
name|failedFetchMap
operator|!=
literal|null
condition|)
block|{
comment|// Gather information about the map which has to be failed, if need be
name|String
name|failedFetchTrackerName
init|=
name|getAssignedTracker
argument_list|(
name|mapTaskId
argument_list|)
decl_stmt|;
if|if
condition|(
name|failedFetchTrackerName
operator|==
literal|null
condition|)
block|{
name|failedFetchTrackerName
operator|=
literal|"Lost task tracker"
expr_stmt|;
block|}
name|failedFetchMap
operator|.
name|getJob
argument_list|()
operator|.
name|fetchFailureNotification
argument_list|(
name|failedFetchMap
argument_list|,
name|mapTaskId
argument_list|,
name|failedFetchTrackerName
argument_list|,
name|taskId
argument_list|,
name|trackerName
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
comment|/**    * We lost the task tracker!  All task-tracker structures have     * already been updated.  Just process the contained tasks and any    * jobs that might be affected.    */
DECL|method|lostTaskTracker (TaskTracker taskTracker)
name|void
name|lostTaskTracker
parameter_list|(
name|TaskTracker
name|taskTracker
parameter_list|)
block|{
name|String
name|trackerName
init|=
name|taskTracker
operator|.
name|getTrackerName
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Lost tracker '"
operator|+
name|trackerName
operator|+
literal|"'"
argument_list|)
expr_stmt|;
comment|// remove the tracker from the local structures
synchronized|synchronized
init|(
name|trackerToJobsToCleanup
init|)
block|{
name|trackerToJobsToCleanup
operator|.
name|remove
argument_list|(
name|trackerName
argument_list|)
expr_stmt|;
block|}
synchronized|synchronized
init|(
name|trackerToTasksToCleanup
init|)
block|{
name|trackerToTasksToCleanup
operator|.
name|remove
argument_list|(
name|trackerName
argument_list|)
expr_stmt|;
block|}
name|Set
argument_list|<
name|TaskAttemptID
argument_list|>
name|lostTasks
init|=
name|trackerToTaskMap
operator|.
name|get
argument_list|(
name|trackerName
argument_list|)
decl_stmt|;
name|trackerToTaskMap
operator|.
name|remove
argument_list|(
name|trackerName
argument_list|)
expr_stmt|;
if|if
condition|(
name|lostTasks
operator|!=
literal|null
condition|)
block|{
comment|// List of jobs which had any of their tasks fail on this tracker
name|Set
argument_list|<
name|JobInProgress
argument_list|>
name|jobsWithFailures
init|=
operator|new
name|HashSet
argument_list|<
name|JobInProgress
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|TaskAttemptID
name|taskId
range|:
name|lostTasks
control|)
block|{
name|TaskInProgress
name|tip
init|=
name|taskidToTIPMap
operator|.
name|get
argument_list|(
name|taskId
argument_list|)
decl_stmt|;
name|JobInProgress
name|job
init|=
name|tip
operator|.
name|getJob
argument_list|()
decl_stmt|;
comment|// Completed reduce tasks never need to be failed, because
comment|// their outputs go to dfs
comment|// And completed maps with zero reducers of the job
comment|// never need to be failed.
if|if
condition|(
operator|!
name|tip
operator|.
name|isComplete
argument_list|()
operator|||
operator|(
name|tip
operator|.
name|isMapTask
argument_list|()
operator|&&
operator|!
name|tip
operator|.
name|isJobSetupTask
argument_list|()
operator|&&
name|job
operator|.
name|desiredReduces
argument_list|()
operator|!=
literal|0
operator|)
condition|)
block|{
comment|// if the job is done, we don't want to change anything
if|if
condition|(
name|job
operator|.
name|getStatus
argument_list|()
operator|.
name|getRunState
argument_list|()
operator|==
name|JobStatus
operator|.
name|RUNNING
operator|||
name|job
operator|.
name|getStatus
argument_list|()
operator|.
name|getRunState
argument_list|()
operator|==
name|JobStatus
operator|.
name|PREP
condition|)
block|{
comment|// the state will be KILLED_UNCLEAN, if the task(map or reduce)
comment|// was RUNNING on the tracker
name|TaskStatus
operator|.
name|State
name|killState
init|=
operator|(
name|tip
operator|.
name|isRunningTask
argument_list|(
name|taskId
argument_list|)
operator|&&
operator|!
name|tip
operator|.
name|isJobSetupTask
argument_list|()
operator|&&
operator|!
name|tip
operator|.
name|isJobCleanupTask
argument_list|()
operator|)
condition|?
name|TaskStatus
operator|.
name|State
operator|.
name|KILLED_UNCLEAN
else|:
name|TaskStatus
operator|.
name|State
operator|.
name|KILLED
decl_stmt|;
name|job
operator|.
name|failedTask
argument_list|(
name|tip
argument_list|,
name|taskId
argument_list|,
operator|(
literal|"Lost task tracker: "
operator|+
name|trackerName
operator|)
argument_list|,
operator|(
name|tip
operator|.
name|isMapTask
argument_list|()
condition|?
name|TaskStatus
operator|.
name|Phase
operator|.
name|MAP
else|:
name|TaskStatus
operator|.
name|Phase
operator|.
name|REDUCE
operator|)
argument_list|,
name|killState
argument_list|,
name|trackerName
argument_list|)
expr_stmt|;
name|jobsWithFailures
operator|.
name|add
argument_list|(
name|job
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// Completed 'reduce' task and completed 'maps' with zero
comment|// reducers of the job, not failed;
comment|// only removed from data-structures.
name|markCompletedTaskAttempt
argument_list|(
name|trackerName
argument_list|,
name|taskId
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Penalize this tracker for each of the jobs which
comment|// had any tasks running on it when it was 'lost'
comment|// Also, remove any reserved slots on this tasktracker
for|for
control|(
name|JobInProgress
name|job
range|:
name|jobsWithFailures
control|)
block|{
name|job
operator|.
name|addTrackerTaskFailure
argument_list|(
name|trackerName
argument_list|,
name|taskTracker
argument_list|)
expr_stmt|;
block|}
comment|// Cleanup
name|taskTracker
operator|.
name|cancelAllReservations
argument_list|()
expr_stmt|;
comment|// Purge 'marked' tasks, needs to be done
comment|// here to prevent hanging references!
name|removeMarkedTasks
argument_list|(
name|trackerName
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Rereads the config to get hosts and exclude list file names.    * Rereads the files to update the hosts and exclude lists.    */
DECL|method|refreshNodes ()
specifier|public
specifier|synchronized
name|void
name|refreshNodes
parameter_list|()
throws|throws
name|IOException
block|{
name|String
name|user
init|=
name|UserGroupInformation
operator|.
name|getCurrentUser
argument_list|()
operator|.
name|getShortUserName
argument_list|()
decl_stmt|;
comment|// check access
if|if
condition|(
operator|!
name|aclsManager
operator|.
name|isMRAdmin
argument_list|(
name|UserGroupInformation
operator|.
name|getCurrentUser
argument_list|()
argument_list|)
condition|)
block|{
name|AuditLogger
operator|.
name|logFailure
argument_list|(
name|user
argument_list|,
name|Constants
operator|.
name|REFRESH_NODES
argument_list|,
name|aclsManager
operator|.
name|getAdminsAcl
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|,
name|Constants
operator|.
name|JOBTRACKER
argument_list|,
name|Constants
operator|.
name|UNAUTHORIZED_USER
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|AccessControlException
argument_list|(
name|user
operator|+
literal|" is not authorized to refresh nodes."
argument_list|)
throw|;
block|}
name|AuditLogger
operator|.
name|logSuccess
argument_list|(
name|user
argument_list|,
name|Constants
operator|.
name|REFRESH_NODES
argument_list|,
name|Constants
operator|.
name|JOBTRACKER
argument_list|)
expr_stmt|;
comment|// call the actual api
name|refreshHosts
argument_list|()
expr_stmt|;
block|}
DECL|method|getMROwner ()
name|UserGroupInformation
name|getMROwner
parameter_list|()
block|{
return|return
name|aclsManager
operator|.
name|getMROwner
argument_list|()
return|;
block|}
DECL|method|refreshHosts ()
specifier|private
specifier|synchronized
name|void
name|refreshHosts
parameter_list|()
throws|throws
name|IOException
block|{
comment|// Reread the config to get HOSTS and HOSTS_EXCLUDE filenames.
comment|// Update the file names and refresh internal includes and excludes list
name|LOG
operator|.
name|info
argument_list|(
literal|"Refreshing hosts information"
argument_list|)
expr_stmt|;
name|Configuration
name|conf
init|=
operator|new
name|Configuration
argument_list|()
decl_stmt|;
name|hostsReader
operator|.
name|updateFileNames
argument_list|(
name|conf
operator|.
name|get
argument_list|(
name|JTConfig
operator|.
name|JT_HOSTS_FILENAME
argument_list|,
literal|""
argument_list|)
argument_list|,
name|conf
operator|.
name|get
argument_list|(
name|JTConfig
operator|.
name|JT_HOSTS_EXCLUDE_FILENAME
argument_list|,
literal|""
argument_list|)
argument_list|)
expr_stmt|;
name|hostsReader
operator|.
name|refresh
argument_list|()
expr_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|excludeSet
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|TaskTracker
argument_list|>
name|eSet
range|:
name|taskTrackers
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|String
name|trackerName
init|=
name|eSet
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|TaskTrackerStatus
name|status
init|=
name|eSet
operator|.
name|getValue
argument_list|()
operator|.
name|getStatus
argument_list|()
decl_stmt|;
comment|// Check if not include i.e not in host list or in hosts list but excluded
if|if
condition|(
operator|!
name|inHostsList
argument_list|(
name|status
argument_list|)
operator|||
name|inExcludedHostsList
argument_list|(
name|status
argument_list|)
condition|)
block|{
name|excludeSet
operator|.
name|add
argument_list|(
name|status
operator|.
name|getHost
argument_list|()
argument_list|)
expr_stmt|;
comment|// add to rejected trackers
block|}
block|}
name|decommissionNodes
argument_list|(
name|excludeSet
argument_list|)
expr_stmt|;
block|}
comment|// main decommission
DECL|method|decommissionNodes (Set<String> hosts)
specifier|synchronized
name|void
name|decommissionNodes
parameter_list|(
name|Set
argument_list|<
name|String
argument_list|>
name|hosts
parameter_list|)
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Decommissioning "
operator|+
name|hosts
operator|.
name|size
argument_list|()
operator|+
literal|" nodes"
argument_list|)
expr_stmt|;
comment|// create a list of tracker hostnames
synchronized|synchronized
init|(
name|taskTrackers
init|)
block|{
synchronized|synchronized
init|(
name|trackerExpiryQueue
init|)
block|{
name|int
name|trackersDecommissioned
init|=
literal|0
decl_stmt|;
for|for
control|(
name|String
name|host
range|:
name|hosts
control|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Decommissioning host "
operator|+
name|host
argument_list|)
expr_stmt|;
name|Set
argument_list|<
name|TaskTracker
argument_list|>
name|trackers
init|=
name|hostnameToTaskTracker
operator|.
name|remove
argument_list|(
name|host
argument_list|)
decl_stmt|;
if|if
condition|(
name|trackers
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|TaskTracker
name|tracker
range|:
name|trackers
control|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Decommission: Losing tracker "
operator|+
name|tracker
operator|.
name|getTrackerName
argument_list|()
operator|+
literal|" on host "
operator|+
name|host
argument_list|)
expr_stmt|;
name|removeTracker
argument_list|(
name|tracker
argument_list|)
expr_stmt|;
block|}
name|trackersDecommissioned
operator|+=
name|trackers
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Host "
operator|+
name|host
operator|+
literal|" is ready for decommissioning"
argument_list|)
expr_stmt|;
block|}
name|getInstrumentation
argument_list|()
operator|.
name|setDecommissionedTrackers
argument_list|(
name|trackersDecommissioned
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Returns a set of excluded nodes.    */
DECL|method|getExcludedNodes ()
name|Collection
argument_list|<
name|String
argument_list|>
name|getExcludedNodes
parameter_list|()
block|{
return|return
name|hostsReader
operator|.
name|getExcludedHosts
argument_list|()
return|;
block|}
comment|////////////////////////////////////////////////////////////
comment|// main()
comment|////////////////////////////////////////////////////////////
comment|/**    * Start the JobTracker process.  This is used only for debugging.  As a rule,    * JobTracker should be run as part of the DFS Namenode process.    */
DECL|method|main (String argv[] )
specifier|public
specifier|static
name|void
name|main
parameter_list|(
name|String
name|argv
index|[]
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|StringUtils
operator|.
name|startupShutdownMessage
argument_list|(
name|JobTracker
operator|.
name|class
argument_list|,
name|argv
argument_list|,
name|LOG
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
name|argv
operator|.
name|length
operator|==
literal|0
condition|)
block|{
name|JobTracker
name|tracker
init|=
name|startTracker
argument_list|(
operator|new
name|JobConf
argument_list|()
argument_list|)
decl_stmt|;
name|tracker
operator|.
name|offerService
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
literal|"-dumpConfiguration"
operator|.
name|equals
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
operator|&&
name|argv
operator|.
name|length
operator|==
literal|1
condition|)
block|{
name|dumpConfiguration
argument_list|(
operator|new
name|PrintWriter
argument_list|(
name|System
operator|.
name|out
argument_list|)
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|()
expr_stmt|;
name|Configuration
name|conf
init|=
operator|new
name|Configuration
argument_list|()
decl_stmt|;
name|QueueManager
operator|.
name|dumpConfiguration
argument_list|(
operator|new
name|PrintWriter
argument_list|(
name|System
operator|.
name|out
argument_list|)
argument_list|,
name|conf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"usage: JobTracker [-dumpConfiguration]"
argument_list|)
expr_stmt|;
name|System
operator|.
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|fatal
argument_list|(
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
name|System
operator|.
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Dumps the configuration properties in Json format    * @param writer {@link}Writer object to which the output is written    * @throws IOException    */
DECL|method|dumpConfiguration (Writer writer)
specifier|private
specifier|static
name|void
name|dumpConfiguration
parameter_list|(
name|Writer
name|writer
parameter_list|)
throws|throws
name|IOException
block|{
name|Configuration
operator|.
name|dumpConfiguration
argument_list|(
operator|new
name|JobConf
argument_list|()
argument_list|,
name|writer
argument_list|)
expr_stmt|;
name|writer
operator|.
name|write
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
comment|/**    * Gets the root level queues.    *    * @return array of QueueInfo object.    * @throws java.io.IOException    */
annotation|@
name|Override
DECL|method|getRootQueues ()
specifier|public
name|QueueInfo
index|[]
name|getRootQueues
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|getQueueInfoArray
argument_list|(
name|queueManager
operator|.
name|getRootQueues
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Returns immediate children of queueName.    *    * @param queueName    * @return array of QueueInfo which are children of queueName    * @throws java.io.IOException    */
annotation|@
name|Override
DECL|method|getChildQueues (String queueName)
specifier|public
name|QueueInfo
index|[]
name|getChildQueues
parameter_list|(
name|String
name|queueName
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|getQueueInfoArray
argument_list|(
name|queueManager
operator|.
name|getChildQueues
argument_list|(
name|queueName
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Gets the root level queues.    *    * @return array of JobQueueInfo object.    * @throws java.io.IOException    */
annotation|@
name|Deprecated
DECL|method|getRootJobQueues ()
specifier|public
name|JobQueueInfo
index|[]
name|getRootJobQueues
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|queueManager
operator|.
name|getRootQueues
argument_list|()
return|;
block|}
annotation|@
name|Deprecated
DECL|method|getJobQueues ()
specifier|public
name|JobQueueInfo
index|[]
name|getJobQueues
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|queueManager
operator|.
name|getJobQueueInfos
argument_list|()
return|;
block|}
annotation|@
name|Deprecated
DECL|method|getQueueInfo (String queue)
specifier|public
name|JobQueueInfo
name|getQueueInfo
parameter_list|(
name|String
name|queue
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|queueManager
operator|.
name|getJobQueueInfo
argument_list|(
name|queue
argument_list|)
return|;
block|}
DECL|method|getQueueInfoArray (JobQueueInfo[] queues)
specifier|private
name|QueueInfo
index|[]
name|getQueueInfoArray
parameter_list|(
name|JobQueueInfo
index|[]
name|queues
parameter_list|)
throws|throws
name|IOException
block|{
for|for
control|(
name|JobQueueInfo
name|queue
range|:
name|queues
control|)
block|{
name|queue
operator|.
name|setJobStatuses
argument_list|(
name|getJobsFromQueue
argument_list|(
name|queue
operator|.
name|getQueueName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|queues
return|;
block|}
annotation|@
name|Override
DECL|method|getQueues ()
specifier|public
name|QueueInfo
index|[]
name|getQueues
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|getQueueInfoArray
argument_list|(
name|queueManager
operator|.
name|getJobQueueInfos
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|getQueue (String queue)
specifier|public
name|QueueInfo
name|getQueue
parameter_list|(
name|String
name|queue
parameter_list|)
throws|throws
name|IOException
block|{
name|JobQueueInfo
name|jqueue
init|=
name|queueManager
operator|.
name|getJobQueueInfo
argument_list|(
name|queue
argument_list|)
decl_stmt|;
if|if
condition|(
name|jqueue
operator|!=
literal|null
condition|)
block|{
name|jqueue
operator|.
name|setJobStatuses
argument_list|(
name|getJobsFromQueue
argument_list|(
name|jqueue
operator|.
name|getQueueName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|jqueue
return|;
block|}
DECL|method|getJobsFromQueue (String queue)
specifier|public
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|JobStatus
index|[]
name|getJobsFromQueue
parameter_list|(
name|String
name|queue
parameter_list|)
throws|throws
name|IOException
block|{
name|Collection
argument_list|<
name|JobInProgress
argument_list|>
name|jips
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|queueManager
operator|.
name|getLeafQueueNames
argument_list|()
operator|.
name|contains
argument_list|(
name|queue
argument_list|)
condition|)
block|{
name|jips
operator|=
name|taskScheduler
operator|.
name|getJobs
argument_list|(
name|queue
argument_list|)
expr_stmt|;
block|}
return|return
name|getJobStatus
argument_list|(
name|jips
argument_list|,
literal|false
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|QueueAclsInfo
index|[]
DECL|method|getQueueAclsForCurrentUser ()
name|getQueueAclsForCurrentUser
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|queueManager
operator|.
name|getQueueAcls
argument_list|(
name|UserGroupInformation
operator|.
name|getCurrentUser
argument_list|()
argument_list|)
return|;
block|}
DECL|method|getJobStatus (Collection<JobInProgress> jips, boolean toComplete)
specifier|private
specifier|synchronized
name|JobStatus
index|[]
name|getJobStatus
parameter_list|(
name|Collection
argument_list|<
name|JobInProgress
argument_list|>
name|jips
parameter_list|,
name|boolean
name|toComplete
parameter_list|)
block|{
if|if
condition|(
name|jips
operator|==
literal|null
operator|||
name|jips
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
operator|new
name|JobStatus
index|[]
block|{}
return|;
block|}
name|ArrayList
argument_list|<
name|JobStatus
argument_list|>
name|jobStatusList
init|=
operator|new
name|ArrayList
argument_list|<
name|JobStatus
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|JobInProgress
name|jip
range|:
name|jips
control|)
block|{
name|JobStatus
name|status
init|=
name|jip
operator|.
name|getStatus
argument_list|()
decl_stmt|;
name|status
operator|.
name|setStartTime
argument_list|(
name|jip
operator|.
name|getStartTime
argument_list|()
argument_list|)
expr_stmt|;
name|status
operator|.
name|setUsername
argument_list|(
name|jip
operator|.
name|getProfile
argument_list|()
operator|.
name|getUser
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|toComplete
condition|)
block|{
if|if
condition|(
name|status
operator|.
name|getRunState
argument_list|()
operator|==
name|JobStatus
operator|.
name|RUNNING
operator|||
name|status
operator|.
name|getRunState
argument_list|()
operator|==
name|JobStatus
operator|.
name|PREP
condition|)
block|{
name|jobStatusList
operator|.
name|add
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|jobStatusList
operator|.
name|add
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|jobStatusList
operator|.
name|toArray
argument_list|(
operator|new
name|JobStatus
index|[
name|jobStatusList
operator|.
name|size
argument_list|()
index|]
argument_list|)
return|;
block|}
comment|/**    * Returns the confgiured maximum number of tasks for a single job    */
DECL|method|getMaxTasksPerJob ()
name|int
name|getMaxTasksPerJob
parameter_list|()
block|{
return|return
name|conf
operator|.
name|getInt
argument_list|(
name|JT_TASKS_PER_JOB
argument_list|,
operator|-
literal|1
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|refreshServiceAcl ()
specifier|public
name|void
name|refreshServiceAcl
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|conf
operator|.
name|getBoolean
argument_list|(
name|CommonConfigurationKeys
operator|.
name|HADOOP_SECURITY_AUTHORIZATION
argument_list|,
literal|false
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|AuthorizationException
argument_list|(
literal|"Service Level Authorization not enabled!"
argument_list|)
throw|;
block|}
name|this
operator|.
name|interTrackerServer
operator|.
name|refreshServiceAcl
argument_list|(
name|conf
argument_list|,
operator|new
name|MapReducePolicyProvider
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|refreshQueues ()
specifier|public
name|void
name|refreshQueues
parameter_list|()
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Refreshing queue information. requested by : "
operator|+
name|UserGroupInformation
operator|.
name|getCurrentUser
argument_list|()
operator|.
name|getShortUserName
argument_list|()
argument_list|)
expr_stmt|;
synchronized|synchronized
init|(
name|taskScheduler
init|)
block|{
name|queueManager
operator|.
name|refreshQueues
argument_list|(
operator|new
name|Configuration
argument_list|(
name|this
operator|.
name|conf
argument_list|)
argument_list|,
name|taskScheduler
operator|.
name|getQueueRefresher
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|initializeTaskMemoryRelatedConfig ()
specifier|private
name|void
name|initializeTaskMemoryRelatedConfig
parameter_list|()
block|{
name|memSizeForMapSlotOnJT
operator|=
name|JobConf
operator|.
name|normalizeMemoryConfigValue
argument_list|(
name|conf
operator|.
name|getLong
argument_list|(
name|MAPMEMORY_MB
argument_list|,
name|JobConf
operator|.
name|DISABLED_MEMORY_LIMIT
argument_list|)
argument_list|)
expr_stmt|;
name|memSizeForReduceSlotOnJT
operator|=
name|JobConf
operator|.
name|normalizeMemoryConfigValue
argument_list|(
name|conf
operator|.
name|getLong
argument_list|(
name|REDUCEMEMORY_MB
argument_list|,
name|JobConf
operator|.
name|DISABLED_MEMORY_LIMIT
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|conf
operator|.
name|get
argument_list|(
name|JobConf
operator|.
name|UPPER_LIMIT_ON_TASK_VMEM_PROPERTY
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|JobConf
operator|.
name|deprecatedString
argument_list|(
name|JobConf
operator|.
name|UPPER_LIMIT_ON_TASK_VMEM_PROPERTY
argument_list|)
operator|+
literal|" instead use "
operator|+
name|JTConfig
operator|.
name|JT_MAX_MAPMEMORY_MB
operator|+
literal|" and "
operator|+
name|JTConfig
operator|.
name|JT_MAX_REDUCEMEMORY_MB
argument_list|)
expr_stmt|;
name|limitMaxMemForMapTasks
operator|=
name|limitMaxMemForReduceTasks
operator|=
name|JobConf
operator|.
name|normalizeMemoryConfigValue
argument_list|(
name|conf
operator|.
name|getLong
argument_list|(
name|JobConf
operator|.
name|UPPER_LIMIT_ON_TASK_VMEM_PROPERTY
argument_list|,
name|JobConf
operator|.
name|DISABLED_MEMORY_LIMIT
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|limitMaxMemForMapTasks
operator|!=
name|JobConf
operator|.
name|DISABLED_MEMORY_LIMIT
operator|&&
name|limitMaxMemForMapTasks
operator|>=
literal|0
condition|)
block|{
name|limitMaxMemForMapTasks
operator|=
name|limitMaxMemForReduceTasks
operator|=
name|limitMaxMemForMapTasks
operator|/
operator|(
literal|1024
operator|*
literal|1024
operator|)
expr_stmt|;
comment|//Converting old values in bytes to MB
block|}
block|}
else|else
block|{
name|limitMaxMemForMapTasks
operator|=
name|JobConf
operator|.
name|normalizeMemoryConfigValue
argument_list|(
name|conf
operator|.
name|getLong
argument_list|(
name|JTConfig
operator|.
name|JT_MAX_MAPMEMORY_MB
argument_list|,
name|JobConf
operator|.
name|DISABLED_MEMORY_LIMIT
argument_list|)
argument_list|)
expr_stmt|;
name|limitMaxMemForReduceTasks
operator|=
name|JobConf
operator|.
name|normalizeMemoryConfigValue
argument_list|(
name|conf
operator|.
name|getLong
argument_list|(
name|JTConfig
operator|.
name|JT_MAX_REDUCEMEMORY_MB
argument_list|,
name|JobConf
operator|.
name|DISABLED_MEMORY_LIMIT
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
operator|new
name|StringBuilder
argument_list|()
operator|.
name|append
argument_list|(
literal|"Scheduler configured with "
argument_list|)
operator|.
name|append
argument_list|(
literal|"(memSizeForMapSlotOnJT, memSizeForReduceSlotOnJT,"
argument_list|)
operator|.
name|append
argument_list|(
literal|" limitMaxMemForMapTasks, limitMaxMemForReduceTasks) ("
argument_list|)
operator|.
name|append
argument_list|(
name|memSizeForMapSlotOnJT
argument_list|)
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
operator|.
name|append
argument_list|(
name|memSizeForReduceSlotOnJT
argument_list|)
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
operator|.
name|append
argument_list|(
name|limitMaxMemForMapTasks
argument_list|)
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
operator|.
name|append
argument_list|(
name|limitMaxMemForReduceTasks
argument_list|)
operator|.
name|append
argument_list|(
literal|")"
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|refreshSuperUserGroupsConfiguration ()
specifier|public
name|void
name|refreshSuperUserGroupsConfiguration
parameter_list|()
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Refreshing superuser proxy groups mapping "
argument_list|)
expr_stmt|;
name|ProxyUsers
operator|.
name|refreshSuperUserGroupsConfiguration
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getGroupsForUser (String user)
specifier|public
name|String
index|[]
name|getGroupsForUser
parameter_list|(
name|String
name|user
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Getting groups for user "
operator|+
name|user
argument_list|)
expr_stmt|;
block|}
return|return
name|UserGroupInformation
operator|.
name|createRemoteUser
argument_list|(
name|user
argument_list|)
operator|.
name|getGroupNames
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|refreshUserToGroupsMappings ()
specifier|public
name|void
name|refreshUserToGroupsMappings
parameter_list|()
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Refreshing all user-to-groups mappings. Requested by user: "
operator|+
name|UserGroupInformation
operator|.
name|getCurrentUser
argument_list|()
operator|.
name|getShortUserName
argument_list|()
argument_list|)
expr_stmt|;
name|Groups
operator|.
name|getUserToGroupsMappingService
argument_list|()
operator|.
name|refresh
argument_list|()
expr_stmt|;
block|}
DECL|method|perTaskMemoryConfigurationSetOnJT ()
specifier|private
name|boolean
name|perTaskMemoryConfigurationSetOnJT
parameter_list|()
block|{
if|if
condition|(
name|limitMaxMemForMapTasks
operator|==
name|JobConf
operator|.
name|DISABLED_MEMORY_LIMIT
operator|||
name|limitMaxMemForReduceTasks
operator|==
name|JobConf
operator|.
name|DISABLED_MEMORY_LIMIT
operator|||
name|memSizeForMapSlotOnJT
operator|==
name|JobConf
operator|.
name|DISABLED_MEMORY_LIMIT
operator|||
name|memSizeForReduceSlotOnJT
operator|==
name|JobConf
operator|.
name|DISABLED_MEMORY_LIMIT
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Check the job if it has invalid requirements and throw and IOException if does have.    *     * @param job    * @throws IOException     */
DECL|method|checkMemoryRequirements (JobInProgress job)
name|void
name|checkMemoryRequirements
parameter_list|(
name|JobInProgress
name|job
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|perTaskMemoryConfigurationSetOnJT
argument_list|()
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Per-Task memory configuration is not set on JT. "
operator|+
literal|"Not checking the job for invalid memory requirements."
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
name|boolean
name|invalidJob
init|=
literal|false
decl_stmt|;
name|String
name|msg
init|=
literal|""
decl_stmt|;
name|long
name|maxMemForMapTask
init|=
name|job
operator|.
name|getMemoryForMapTask
argument_list|()
decl_stmt|;
name|long
name|maxMemForReduceTask
init|=
name|job
operator|.
name|getMemoryForReduceTask
argument_list|()
decl_stmt|;
if|if
condition|(
name|maxMemForMapTask
operator|==
name|JobConf
operator|.
name|DISABLED_MEMORY_LIMIT
operator|||
name|maxMemForReduceTask
operator|==
name|JobConf
operator|.
name|DISABLED_MEMORY_LIMIT
condition|)
block|{
name|invalidJob
operator|=
literal|true
expr_stmt|;
name|msg
operator|=
literal|"Invalid job requirements."
expr_stmt|;
block|}
if|if
condition|(
name|maxMemForMapTask
operator|>
name|limitMaxMemForMapTasks
operator|||
name|maxMemForReduceTask
operator|>
name|limitMaxMemForReduceTasks
condition|)
block|{
name|invalidJob
operator|=
literal|true
expr_stmt|;
name|msg
operator|=
literal|"Exceeds the cluster's max-memory-limit."
expr_stmt|;
block|}
if|if
condition|(
name|invalidJob
condition|)
block|{
name|StringBuilder
name|jobStr
init|=
operator|new
name|StringBuilder
argument_list|()
operator|.
name|append
argument_list|(
name|job
operator|.
name|getJobID
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|"("
argument_list|)
operator|.
name|append
argument_list|(
name|maxMemForMapTask
argument_list|)
operator|.
name|append
argument_list|(
literal|" memForMapTasks "
argument_list|)
operator|.
name|append
argument_list|(
name|maxMemForReduceTask
argument_list|)
operator|.
name|append
argument_list|(
literal|" memForReduceTasks): "
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
name|jobStr
operator|.
name|toString
argument_list|()
operator|+
name|msg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
name|jobStr
operator|.
name|toString
argument_list|()
operator|+
name|msg
argument_list|)
throw|;
block|}
block|}
DECL|method|getFaultReport (String host)
specifier|synchronized
name|String
name|getFaultReport
parameter_list|(
name|String
name|host
parameter_list|)
block|{
name|FaultInfo
name|fi
init|=
name|faultyTrackers
operator|.
name|getFaultInfo
argument_list|(
name|host
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|fi
operator|==
literal|null
condition|)
block|{
return|return
literal|""
return|;
block|}
return|return
name|fi
operator|.
name|getTrackerFaultReport
argument_list|()
return|;
block|}
DECL|method|getReasonForBlackList (String host)
specifier|synchronized
name|Set
argument_list|<
name|ReasonForBlackListing
argument_list|>
name|getReasonForBlackList
parameter_list|(
name|String
name|host
parameter_list|)
block|{
name|FaultInfo
name|fi
init|=
name|faultyTrackers
operator|.
name|getFaultInfo
argument_list|(
name|host
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|fi
operator|==
literal|null
condition|)
block|{
return|return
operator|new
name|HashSet
argument_list|<
name|ReasonForBlackListing
argument_list|>
argument_list|()
return|;
block|}
return|return
name|fi
operator|.
name|getReasonforblacklisting
argument_list|()
return|;
block|}
DECL|method|getBlackListedTrackers ()
specifier|synchronized
name|Collection
argument_list|<
name|BlackListInfo
argument_list|>
name|getBlackListedTrackers
parameter_list|()
block|{
name|Collection
argument_list|<
name|BlackListInfo
argument_list|>
name|blackListedTrackers
init|=
operator|new
name|ArrayList
argument_list|<
name|BlackListInfo
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|TaskTrackerStatus
name|tracker
range|:
name|blacklistedTaskTrackers
argument_list|()
control|)
block|{
name|String
name|hostName
init|=
name|tracker
operator|.
name|getHost
argument_list|()
decl_stmt|;
name|BlackListInfo
name|bi
init|=
operator|new
name|BlackListInfo
argument_list|()
decl_stmt|;
name|bi
operator|.
name|setTrackerName
argument_list|(
name|tracker
operator|.
name|getTrackerName
argument_list|()
argument_list|)
expr_stmt|;
name|Set
argument_list|<
name|ReasonForBlackListing
argument_list|>
name|rfbs
init|=
name|getReasonForBlackList
argument_list|(
name|hostName
argument_list|)
decl_stmt|;
name|StringBuffer
name|sb
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
for|for
control|(
name|ReasonForBlackListing
name|rfb
range|:
name|rfbs
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|rfb
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|","
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sb
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|sb
operator|.
name|replace
argument_list|(
name|sb
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|,
name|sb
operator|.
name|length
argument_list|()
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
name|bi
operator|.
name|setReasonForBlackListing
argument_list|(
name|sb
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|bi
operator|.
name|setBlackListReport
argument_list|(
name|getFaultReport
argument_list|(
name|hostName
argument_list|)
argument_list|)
expr_stmt|;
name|blackListedTrackers
operator|.
name|add
argument_list|(
name|bi
argument_list|)
expr_stmt|;
block|}
return|return
name|blackListedTrackers
return|;
block|}
comment|/** Test method to increment the fault    * This method is synchronized to make sure that the locking order     * "faultyTrackers.potentiallyFaultyTrackers lock followed by taskTrackers     * lock" is under JobTracker lock to avoid deadlocks.    */
DECL|method|incrementFaults (String hostName)
specifier|synchronized
name|void
name|incrementFaults
parameter_list|(
name|String
name|hostName
parameter_list|)
block|{
name|faultyTrackers
operator|.
name|incrementFaults
argument_list|(
name|hostName
argument_list|)
expr_stmt|;
block|}
DECL|method|JobTracker (final JobConf conf, Clock clock, boolean ignoredForSimulation)
name|JobTracker
parameter_list|(
specifier|final
name|JobConf
name|conf
parameter_list|,
name|Clock
name|clock
parameter_list|,
name|boolean
name|ignoredForSimulation
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|clock
operator|=
name|clock
expr_stmt|;
name|this
operator|.
name|conf
operator|=
name|conf
expr_stmt|;
name|trackerIdentifier
operator|=
name|getDateFormat
argument_list|()
operator|.
name|format
argument_list|(
operator|new
name|Date
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|fs
operator|==
literal|null
condition|)
block|{
name|fs
operator|=
name|FileSystem
operator|.
name|get
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|localFs
operator|=
name|FileSystem
operator|.
name|getLocal
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|tasktrackerExpiryInterval
operator|=
name|conf
operator|.
name|getLong
argument_list|(
literal|"mapred.tasktracker.expiry.interval"
argument_list|,
literal|10
operator|*
literal|60
operator|*
literal|1000
argument_list|)
expr_stmt|;
name|retiredJobsCacheSize
operator|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"mapred.job.tracker.retiredjobs.cache.size"
argument_list|,
literal|1000
argument_list|)
expr_stmt|;
comment|// min time before retire
name|MAX_BLACKLISTS_PER_TRACKER
operator|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"mapred.max.tracker.blacklists"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|NUM_HEARTBEATS_IN_SECOND
operator|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"mapred.heartbeats.in.second"
argument_list|,
literal|100
argument_list|)
expr_stmt|;
comment|// Set ports, start RPC servers, setup security policy etc.
name|InetSocketAddress
name|addr
init|=
name|getAddress
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|this
operator|.
name|localMachine
operator|=
name|addr
operator|.
name|getHostName
argument_list|()
expr_stmt|;
name|this
operator|.
name|port
operator|=
name|addr
operator|.
name|getPort
argument_list|()
expr_stmt|;
name|UserGroupInformation
operator|.
name|setConfiguration
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|SecurityUtil
operator|.
name|login
argument_list|(
name|conf
argument_list|,
name|JTConfig
operator|.
name|JT_KEYTAB_FILE
argument_list|,
name|JTConfig
operator|.
name|JT_USER_NAME
argument_list|,
name|localMachine
argument_list|)
expr_stmt|;
name|secretManager
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|hostsReader
operator|=
operator|new
name|HostsFileReader
argument_list|(
name|conf
operator|.
name|get
argument_list|(
name|JTConfig
operator|.
name|JT_HOSTS_FILENAME
argument_list|,
literal|""
argument_list|)
argument_list|,
name|conf
operator|.
name|get
argument_list|(
name|JTConfig
operator|.
name|JT_HOSTS_EXCLUDE_FILENAME
argument_list|,
literal|""
argument_list|)
argument_list|)
expr_stmt|;
comment|// queue manager
name|Configuration
name|clusterConf
init|=
operator|new
name|Configuration
argument_list|(
name|this
operator|.
name|conf
argument_list|)
decl_stmt|;
name|queueManager
operator|=
operator|new
name|QueueManager
argument_list|(
name|clusterConf
argument_list|)
expr_stmt|;
name|aclsManager
operator|=
operator|new
name|ACLsManager
argument_list|(
name|conf
argument_list|,
operator|new
name|JobACLsManager
argument_list|(
name|conf
argument_list|)
argument_list|,
name|queueManager
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Starting jobtracker with owner as "
operator|+
name|getMROwner
argument_list|()
operator|.
name|getShortUserName
argument_list|()
argument_list|)
expr_stmt|;
comment|// Create the scheduler
name|Class
argument_list|<
name|?
extends|extends
name|TaskScheduler
argument_list|>
name|schedulerClass
init|=
name|conf
operator|.
name|getClass
argument_list|(
name|JTConfig
operator|.
name|JT_TASK_SCHEDULER
argument_list|,
name|JobQueueTaskScheduler
operator|.
name|class
argument_list|,
name|TaskScheduler
operator|.
name|class
argument_list|)
decl_stmt|;
name|taskScheduler
operator|=
operator|(
name|TaskScheduler
operator|)
name|ReflectionUtils
operator|.
name|newInstance
argument_list|(
name|schedulerClass
argument_list|,
name|conf
argument_list|)
expr_stmt|;
comment|// Create the jetty server
name|InetSocketAddress
name|infoSocAddr
init|=
name|NetUtils
operator|.
name|createSocketAddr
argument_list|(
name|conf
operator|.
name|get
argument_list|(
name|JTConfig
operator|.
name|JT_HTTP_ADDRESS
argument_list|,
literal|"0.0.0.0:50030"
argument_list|)
argument_list|)
decl_stmt|;
name|String
name|infoBindAddress
init|=
name|infoSocAddr
operator|.
name|getHostName
argument_list|()
decl_stmt|;
name|int
name|tmpInfoPort
init|=
name|infoSocAddr
operator|.
name|getPort
argument_list|()
decl_stmt|;
name|this
operator|.
name|startTime
operator|=
name|clock
operator|.
name|getTime
argument_list|()
expr_stmt|;
name|infoServer
operator|=
operator|new
name|HttpServer
argument_list|(
literal|"job"
argument_list|,
name|infoBindAddress
argument_list|,
name|tmpInfoPort
argument_list|,
name|tmpInfoPort
operator|==
literal|0
argument_list|,
name|conf
argument_list|)
expr_stmt|;
name|infoServer
operator|.
name|setAttribute
argument_list|(
literal|"job.tracker"
argument_list|,
name|this
argument_list|)
expr_stmt|;
comment|// initialize history parameters.
name|FileSystem
name|historyFS
init|=
literal|null
decl_stmt|;
name|jobHistory
operator|=
operator|new
name|JobHistory
argument_list|()
expr_stmt|;
specifier|final
name|JobTracker
name|jtFinal
init|=
name|this
decl_stmt|;
try|try
block|{
name|historyFS
operator|=
name|getMROwner
argument_list|()
operator|.
name|doAs
argument_list|(
operator|new
name|PrivilegedExceptionAction
argument_list|<
name|FileSystem
argument_list|>
argument_list|()
block|{
specifier|public
name|FileSystem
name|run
parameter_list|()
throws|throws
name|IOException
block|{
name|jobHistory
operator|.
name|init
argument_list|(
name|jtFinal
argument_list|,
name|conf
argument_list|,
name|jtFinal
operator|.
name|localMachine
argument_list|,
name|jtFinal
operator|.
name|startTime
argument_list|)
expr_stmt|;
name|jobHistory
operator|.
name|initDone
argument_list|(
name|conf
argument_list|,
name|fs
argument_list|)
expr_stmt|;
specifier|final
name|String
name|historyLogDir
init|=
name|jobHistory
operator|.
name|getCompletedJobHistoryLocation
argument_list|()
operator|.
name|toString
argument_list|()
decl_stmt|;
name|infoServer
operator|.
name|setAttribute
argument_list|(
literal|"historyLogDir"
argument_list|,
name|historyLogDir
argument_list|)
expr_stmt|;
return|return
operator|new
name|Path
argument_list|(
name|historyLogDir
argument_list|)
operator|.
name|getFileSystem
argument_list|(
name|conf
argument_list|)
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e1
parameter_list|)
block|{
throw|throw
operator|(
name|IOException
operator|)
operator|new
name|IOException
argument_list|()
operator|.
name|initCause
argument_list|(
name|e1
argument_list|)
throw|;
block|}
name|infoServer
operator|.
name|setAttribute
argument_list|(
literal|"fileSys"
argument_list|,
name|historyFS
argument_list|)
expr_stmt|;
name|infoServer
operator|.
name|addServlet
argument_list|(
literal|"reducegraph"
argument_list|,
literal|"/taskgraph"
argument_list|,
name|TaskGraphServlet
operator|.
name|class
argument_list|)
expr_stmt|;
name|infoServer
operator|.
name|start
argument_list|()
expr_stmt|;
name|this
operator|.
name|infoPort
operator|=
name|this
operator|.
name|infoServer
operator|.
name|getPort
argument_list|()
expr_stmt|;
comment|// Initialize instrumentation
name|JobTrackerInstrumentation
name|tmp
decl_stmt|;
try|try
block|{
name|Class
argument_list|<
name|?
extends|extends
name|JobTrackerInstrumentation
argument_list|>
name|metricsInst
init|=
name|getInstrumentationClass
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Constructor
argument_list|<
name|?
extends|extends
name|JobTrackerInstrumentation
argument_list|>
name|c
init|=
name|metricsInst
operator|.
name|getConstructor
argument_list|(
operator|new
name|Class
index|[]
block|{
name|JobTracker
operator|.
name|class
block|,
name|JobConf
operator|.
name|class
block|}
argument_list|)
decl_stmt|;
name|tmp
operator|=
name|c
operator|.
name|newInstance
argument_list|(
name|this
argument_list|,
name|conf
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
comment|//Reflection can throw lots of exceptions -- handle them all by
comment|//falling back on the default.
name|LOG
operator|.
name|error
argument_list|(
literal|"failed to initialize job tracker metrics"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|tmp
operator|=
operator|new
name|JobTrackerMetricsInst
argument_list|(
name|this
argument_list|,
name|conf
argument_list|)
expr_stmt|;
block|}
name|myInstrumentation
operator|=
name|tmp
expr_stmt|;
comment|// start the recovery manager
name|recoveryManager
operator|=
operator|new
name|RecoveryManager
argument_list|()
expr_stmt|;
name|this
operator|.
name|dnsToSwitchMapping
operator|=
name|ReflectionUtils
operator|.
name|newInstance
argument_list|(
name|conf
operator|.
name|getClass
argument_list|(
name|CommonConfigurationKeys
operator|.
name|NET_TOPOLOGY_NODE_SWITCH_MAPPING_IMPL_KEY
argument_list|,
name|ScriptBasedMapping
operator|.
name|class
argument_list|,
name|DNSToSwitchMapping
operator|.
name|class
argument_list|)
argument_list|,
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|numTaskCacheLevels
operator|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"mapred.task.cache.levels"
argument_list|,
name|NetworkTopology
operator|.
name|DEFAULT_HOST_LEVEL
argument_list|)
expr_stmt|;
comment|//initializes the job status store
name|completedJobStatusStore
operator|=
operator|new
name|CompletedJobStatusStore
argument_list|(
name|conf
argument_list|,
name|aclsManager
argument_list|)
expr_stmt|;
block|}
comment|/**    * Get the path of the locally stored job file    * @param jobId id of the job    * @return the path of the job file on the local file system     */
DECL|method|getLocalJobFilePath (org.apache.hadoop.mapreduce.JobID jobId)
name|String
name|getLocalJobFilePath
parameter_list|(
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|JobID
name|jobId
parameter_list|)
block|{
return|return
name|System
operator|.
name|getProperty
argument_list|(
literal|"hadoop.log.dir"
argument_list|)
operator|+
name|File
operator|.
name|separator
operator|+
name|jobId
operator|+
literal|"_conf.xml"
return|;
block|}
comment|/**    * Discard a current delegation token.    */
annotation|@
name|Override
DECL|method|cancelDelegationToken (Token<DelegationTokenIdentifier> token )
specifier|public
name|void
name|cancelDelegationToken
parameter_list|(
name|Token
argument_list|<
name|DelegationTokenIdentifier
argument_list|>
name|token
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|String
name|user
init|=
name|UserGroupInformation
operator|.
name|getCurrentUser
argument_list|()
operator|.
name|getUserName
argument_list|()
decl_stmt|;
name|secretManager
operator|.
name|cancelToken
argument_list|(
name|token
argument_list|,
name|user
argument_list|)
expr_stmt|;
block|}
comment|/**    * Get a new delegation token.    */
annotation|@
name|Override
specifier|public
name|Token
argument_list|<
name|DelegationTokenIdentifier
argument_list|>
DECL|method|getDelegationToken (Text renewer )
name|getDelegationToken
parameter_list|(
name|Text
name|renewer
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
if|if
condition|(
operator|!
name|isAllowedDelegationTokenOp
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Delegation Token can be issued only with kerberos authentication"
argument_list|)
throw|;
block|}
name|UserGroupInformation
name|ugi
init|=
name|UserGroupInformation
operator|.
name|getCurrentUser
argument_list|()
decl_stmt|;
name|Text
name|owner
init|=
operator|new
name|Text
argument_list|(
name|ugi
operator|.
name|getUserName
argument_list|()
argument_list|)
decl_stmt|;
name|Text
name|realUser
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|ugi
operator|.
name|getRealUser
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|realUser
operator|=
operator|new
name|Text
argument_list|(
name|ugi
operator|.
name|getRealUser
argument_list|()
operator|.
name|getUserName
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|DelegationTokenIdentifier
name|ident
init|=
operator|new
name|DelegationTokenIdentifier
argument_list|(
name|owner
argument_list|,
name|renewer
argument_list|,
name|realUser
argument_list|)
decl_stmt|;
return|return
operator|new
name|Token
argument_list|<
name|DelegationTokenIdentifier
argument_list|>
argument_list|(
name|ident
argument_list|,
name|secretManager
argument_list|)
return|;
block|}
comment|/**    * Renew a delegation token to extend its lifetime.    */
annotation|@
name|Override
DECL|method|renewDelegationToken (Token<DelegationTokenIdentifier> token )
specifier|public
name|long
name|renewDelegationToken
parameter_list|(
name|Token
argument_list|<
name|DelegationTokenIdentifier
argument_list|>
name|token
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
if|if
condition|(
operator|!
name|isAllowedDelegationTokenOp
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Delegation Token can be renewed only with kerberos authentication"
argument_list|)
throw|;
block|}
name|String
name|user
init|=
name|UserGroupInformation
operator|.
name|getCurrentUser
argument_list|()
operator|.
name|getUserName
argument_list|()
decl_stmt|;
return|return
name|secretManager
operator|.
name|renewToken
argument_list|(
name|token
argument_list|,
name|user
argument_list|)
return|;
block|}
DECL|method|getJobACLsManager ()
name|JobACLsManager
name|getJobACLsManager
parameter_list|()
block|{
return|return
name|aclsManager
operator|.
name|getJobACLsManager
argument_list|()
return|;
block|}
DECL|method|getACLsManager ()
name|ACLsManager
name|getACLsManager
parameter_list|()
block|{
return|return
name|aclsManager
return|;
block|}
comment|/**    *     * @return true if delegation token operation is allowed    */
DECL|method|isAllowedDelegationTokenOp ()
specifier|private
name|boolean
name|isAllowedDelegationTokenOp
parameter_list|()
throws|throws
name|IOException
block|{
name|AuthenticationMethod
name|authMethod
init|=
name|UserGroupInformation
operator|.
name|getRealAuthenticationMethod
argument_list|(
name|UserGroupInformation
operator|.
name|getCurrentUser
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|UserGroupInformation
operator|.
name|isSecurityEnabled
argument_list|()
operator|&&
operator|(
name|authMethod
operator|!=
name|AuthenticationMethod
operator|.
name|KERBEROS
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
block|}
end_class

end_unit

