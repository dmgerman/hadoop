begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.mapred
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|PrintStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|InetSocketAddress
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URI
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|PrivilegedExceptionAction
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Vector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|MRConfig
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|MRJobConfig
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|filecache
operator|.
name|DistributedCache
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|filecache
operator|.
name|TaskDistributedCacheManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|filecache
operator|.
name|TrackerDistributedCacheManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|security
operator|.
name|TokenCache
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FSError
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|LocalDirAllocator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|permission
operator|.
name|FsPermission
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|UserGroupInformation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Shell
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|log4j
operator|.
name|Level
import|;
end_import

begin_comment
comment|/** Base class that runs a task in a separate process.  Tasks are run in a  * separate process in order to isolate the map/reduce system code from bugs in  * user supplied map and reduce functions.  */
end_comment

begin_class
DECL|class|TaskRunner
specifier|abstract
class|class
name|TaskRunner
extends|extends
name|Thread
block|{
DECL|field|LOG
specifier|public
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|TaskRunner
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|killed
specifier|volatile
name|boolean
name|killed
init|=
literal|false
decl_stmt|;
DECL|field|tip
specifier|private
name|TaskTracker
operator|.
name|TaskInProgress
name|tip
decl_stmt|;
DECL|field|t
specifier|private
name|Task
name|t
decl_stmt|;
DECL|field|lock
specifier|private
name|Object
name|lock
init|=
operator|new
name|Object
argument_list|()
decl_stmt|;
DECL|field|done
specifier|private
specifier|volatile
name|boolean
name|done
init|=
literal|false
decl_stmt|;
DECL|field|exitCode
specifier|private
name|int
name|exitCode
init|=
operator|-
literal|1
decl_stmt|;
DECL|field|exitCodeSet
specifier|private
name|boolean
name|exitCodeSet
init|=
literal|false
decl_stmt|;
DECL|field|SYSTEM_PATH_SEPARATOR
specifier|private
specifier|static
name|String
name|SYSTEM_PATH_SEPARATOR
init|=
name|System
operator|.
name|getProperty
argument_list|(
literal|"path.separator"
argument_list|)
decl_stmt|;
DECL|field|tracker
specifier|private
name|TaskTracker
name|tracker
decl_stmt|;
DECL|field|taskDistributedCacheManager
specifier|private
name|TaskDistributedCacheManager
name|taskDistributedCacheManager
decl_stmt|;
DECL|field|conf
specifier|protected
name|JobConf
name|conf
decl_stmt|;
DECL|field|jvmManager
name|JvmManager
name|jvmManager
decl_stmt|;
DECL|method|TaskRunner (TaskTracker.TaskInProgress tip, TaskTracker tracker, JobConf conf)
specifier|public
name|TaskRunner
parameter_list|(
name|TaskTracker
operator|.
name|TaskInProgress
name|tip
parameter_list|,
name|TaskTracker
name|tracker
parameter_list|,
name|JobConf
name|conf
parameter_list|)
block|{
name|this
operator|.
name|tip
operator|=
name|tip
expr_stmt|;
name|this
operator|.
name|t
operator|=
name|tip
operator|.
name|getTask
argument_list|()
expr_stmt|;
name|this
operator|.
name|tracker
operator|=
name|tracker
expr_stmt|;
name|this
operator|.
name|conf
operator|=
name|conf
expr_stmt|;
name|this
operator|.
name|jvmManager
operator|=
name|tracker
operator|.
name|getJvmManagerInstance
argument_list|()
expr_stmt|;
block|}
DECL|method|getTask ()
specifier|public
name|Task
name|getTask
parameter_list|()
block|{
return|return
name|t
return|;
block|}
DECL|method|getTaskInProgress ()
specifier|public
name|TaskTracker
operator|.
name|TaskInProgress
name|getTaskInProgress
parameter_list|()
block|{
return|return
name|tip
return|;
block|}
DECL|method|getTracker ()
specifier|public
name|TaskTracker
name|getTracker
parameter_list|()
block|{
return|return
name|tracker
return|;
block|}
DECL|method|getJvmManager ()
specifier|public
name|JvmManager
name|getJvmManager
parameter_list|()
block|{
return|return
name|jvmManager
return|;
block|}
comment|/** Called when this task's output is no longer needed.    * This method is run in the parent process after the child exits.  It should    * not execute user code, only system code.    */
DECL|method|close ()
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{}
comment|/**    * Get the java command line options for the child map/reduce tasks.    * @param jobConf job configuration    * @param defaultValue default value    * @return the java command line options for child map/reduce tasks    * @deprecated Use command line options specific to map or reduce tasks set     *             via {@link JobConf#MAPRED_MAP_TASK_JAVA_OPTS} or     *             {@link JobConf#MAPRED_REDUCE_TASK_JAVA_OPTS}    */
annotation|@
name|Deprecated
DECL|method|getChildJavaOpts (JobConf jobConf, String defaultValue)
specifier|public
name|String
name|getChildJavaOpts
parameter_list|(
name|JobConf
name|jobConf
parameter_list|,
name|String
name|defaultValue
parameter_list|)
block|{
return|return
name|jobConf
operator|.
name|get
argument_list|(
name|JobConf
operator|.
name|MAPRED_TASK_JAVA_OPTS
argument_list|,
name|defaultValue
argument_list|)
return|;
block|}
comment|/**    * Get the maximum virtual memory of the child map/reduce tasks.    * @param jobConf job configuration    * @return the maximum virtual memory of the child task or<code>-1</code> if    *         none is specified    * @deprecated Use limits specific to the map or reduce tasks set via    *             {@link JobConf#MAPRED_MAP_TASK_ULIMIT} or    *             {@link JobConf#MAPRED_REDUCE_TASK_ULIMIT}     */
annotation|@
name|Deprecated
DECL|method|getChildUlimit (JobConf jobConf)
specifier|public
name|int
name|getChildUlimit
parameter_list|(
name|JobConf
name|jobConf
parameter_list|)
block|{
return|return
name|jobConf
operator|.
name|getInt
argument_list|(
name|JobConf
operator|.
name|MAPRED_TASK_ULIMIT
argument_list|,
operator|-
literal|1
argument_list|)
return|;
block|}
comment|/**    * Get the environment variables for the child map/reduce tasks.    * @param jobConf job configuration    * @return the environment variables for the child map/reduce tasks or    *<code>null</code> if unspecified    * @deprecated Use environment variables specific to the map or reduce tasks    *             set via {@link JobConf#MAPRED_MAP_TASK_ENV} or    *             {@link JobConf#MAPRED_REDUCE_TASK_ENV}    */
annotation|@
name|Deprecated
DECL|method|getChildEnv (JobConf jobConf)
specifier|public
name|String
name|getChildEnv
parameter_list|(
name|JobConf
name|jobConf
parameter_list|)
block|{
return|return
name|jobConf
operator|.
name|get
argument_list|(
name|JobConf
operator|.
name|MAPRED_TASK_ENV
argument_list|)
return|;
block|}
comment|/**    * Get the log {@link Level} for the child map/reduce tasks.    * @param jobConf    * @return the log-level for the child map/reduce tasks    */
DECL|method|getLogLevel (JobConf jobConf)
specifier|public
specifier|abstract
name|Level
name|getLogLevel
parameter_list|(
name|JobConf
name|jobConf
parameter_list|)
function_decl|;
annotation|@
name|Override
DECL|method|run ()
specifier|public
specifier|final
name|void
name|run
parameter_list|()
block|{
name|String
name|errorInfo
init|=
literal|"Child Error"
decl_stmt|;
try|try
block|{
comment|//before preparing the job localize
comment|//all the archives
name|TaskAttemptID
name|taskid
init|=
name|t
operator|.
name|getTaskID
argument_list|()
decl_stmt|;
specifier|final
name|LocalDirAllocator
name|lDirAlloc
init|=
operator|new
name|LocalDirAllocator
argument_list|(
name|MRConfig
operator|.
name|LOCAL_DIR
argument_list|)
decl_stmt|;
specifier|final
name|File
name|workDir
init|=
name|formWorkDir
argument_list|(
name|lDirAlloc
argument_list|,
name|taskid
argument_list|,
name|t
operator|.
name|isTaskCleanupTask
argument_list|()
argument_list|,
name|conf
argument_list|)
decl_stmt|;
comment|// We don't create any symlinks yet, so presence/absence of workDir
comment|// actually on the file system doesn't matter.
name|tip
operator|.
name|getUGI
argument_list|()
operator|.
name|doAs
argument_list|(
operator|new
name|PrivilegedExceptionAction
argument_list|<
name|Void
argument_list|>
argument_list|()
block|{
specifier|public
name|Void
name|run
parameter_list|()
throws|throws
name|IOException
block|{
name|taskDistributedCacheManager
operator|=
name|tracker
operator|.
name|getTrackerDistributedCacheManager
argument_list|()
operator|.
name|newTaskDistributedCacheManager
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|taskDistributedCacheManager
operator|.
name|setup
argument_list|(
name|lDirAlloc
argument_list|,
name|workDir
argument_list|,
name|TaskTracker
operator|.
name|getPrivateDistributedCacheDir
argument_list|(
name|conf
operator|.
name|getUser
argument_list|()
argument_list|)
argument_list|,
name|TaskTracker
operator|.
name|getPublicDistributedCacheDir
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
argument_list|)
expr_stmt|;
comment|// Set up the child task's configuration. After this call, no localization
comment|// of files should happen in the TaskTracker's process space. Any changes to
comment|// the conf object after this will NOT be reflected to the child.
name|setupChildTaskConfiguration
argument_list|(
name|lDirAlloc
argument_list|)
expr_stmt|;
comment|// Build classpath
name|List
argument_list|<
name|String
argument_list|>
name|classPaths
init|=
name|getClassPaths
argument_list|(
name|conf
argument_list|,
name|workDir
argument_list|,
name|taskDistributedCacheManager
argument_list|)
decl_stmt|;
name|long
name|logSize
init|=
name|TaskLog
operator|.
name|getTaskLogLength
argument_list|(
name|conf
argument_list|)
decl_stmt|;
comment|//  Build exec child JVM args.
name|Vector
argument_list|<
name|String
argument_list|>
name|vargs
init|=
name|getVMArgs
argument_list|(
name|taskid
argument_list|,
name|workDir
argument_list|,
name|classPaths
argument_list|,
name|logSize
argument_list|)
decl_stmt|;
name|tracker
operator|.
name|addToMemoryManager
argument_list|(
name|t
operator|.
name|getTaskID
argument_list|()
argument_list|,
name|t
operator|.
name|isMapTask
argument_list|()
argument_list|,
name|conf
argument_list|)
expr_stmt|;
comment|// set memory limit using ulimit if feasible and necessary ...
name|List
argument_list|<
name|String
argument_list|>
name|setup
init|=
name|getVMSetupCmd
argument_list|()
decl_stmt|;
comment|// Set up the redirection of the task's stdout and stderr streams
name|File
index|[]
name|logFiles
init|=
name|prepareLogFiles
argument_list|(
name|taskid
argument_list|,
name|t
operator|.
name|isTaskCleanupTask
argument_list|()
argument_list|)
decl_stmt|;
name|File
name|stdout
init|=
name|logFiles
index|[
literal|0
index|]
decl_stmt|;
name|File
name|stderr
init|=
name|logFiles
index|[
literal|1
index|]
decl_stmt|;
name|tracker
operator|.
name|getTaskTrackerInstrumentation
argument_list|()
operator|.
name|reportTaskLaunch
argument_list|(
name|taskid
argument_list|,
name|stdout
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|env
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|errorInfo
operator|=
name|getVMEnvironment
argument_list|(
name|errorInfo
argument_list|,
name|workDir
argument_list|,
name|conf
argument_list|,
name|env
argument_list|,
name|taskid
argument_list|,
name|logSize
argument_list|)
expr_stmt|;
name|launchJvmAndWait
argument_list|(
name|setup
argument_list|,
name|vargs
argument_list|,
name|stdout
argument_list|,
name|stderr
argument_list|,
name|logSize
argument_list|,
name|workDir
argument_list|,
name|env
argument_list|)
expr_stmt|;
name|tracker
operator|.
name|getTaskTrackerInstrumentation
argument_list|()
operator|.
name|reportTaskEnd
argument_list|(
name|t
operator|.
name|getTaskID
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|exitCodeSet
condition|)
block|{
if|if
condition|(
operator|!
name|killed
operator|&&
name|exitCode
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|exitCode
operator|==
literal|65
condition|)
block|{
name|tracker
operator|.
name|getTaskTrackerInstrumentation
argument_list|()
operator|.
name|taskFailedPing
argument_list|(
name|t
operator|.
name|getTaskID
argument_list|()
argument_list|)
expr_stmt|;
block|}
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Task process exit with nonzero status of "
operator|+
name|exitCode
operator|+
literal|"."
argument_list|)
throw|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|FSError
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|fatal
argument_list|(
literal|"FSError"
argument_list|,
name|e
argument_list|)
expr_stmt|;
try|try
block|{
name|tracker
operator|.
name|internalFsError
argument_list|(
name|t
operator|.
name|getTaskID
argument_list|()
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ie
parameter_list|)
block|{
name|LOG
operator|.
name|fatal
argument_list|(
name|t
operator|.
name|getTaskID
argument_list|()
operator|+
literal|" reporting FSError"
argument_list|,
name|ie
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|throwable
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|t
operator|.
name|getTaskID
argument_list|()
operator|+
literal|" : "
operator|+
name|errorInfo
argument_list|,
name|throwable
argument_list|)
expr_stmt|;
name|Throwable
name|causeThrowable
init|=
operator|new
name|Throwable
argument_list|(
name|errorInfo
argument_list|,
name|throwable
argument_list|)
decl_stmt|;
name|ByteArrayOutputStream
name|baos
init|=
operator|new
name|ByteArrayOutputStream
argument_list|()
decl_stmt|;
name|causeThrowable
operator|.
name|printStackTrace
argument_list|(
operator|new
name|PrintStream
argument_list|(
name|baos
argument_list|)
argument_list|)
expr_stmt|;
try|try
block|{
name|tracker
operator|.
name|internalReportDiagnosticInfo
argument_list|(
name|t
operator|.
name|getTaskID
argument_list|()
argument_list|,
name|baos
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|t
operator|.
name|getTaskID
argument_list|()
operator|+
literal|" Reporting Diagnostics"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
try|try
block|{
if|if
condition|(
name|taskDistributedCacheManager
operator|!=
literal|null
condition|)
block|{
name|taskDistributedCacheManager
operator|.
name|release
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ie
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Error releasing caches : Cache files might not have been cleaned up"
argument_list|)
expr_stmt|;
block|}
comment|// It is safe to call TaskTracker.TaskInProgress.reportTaskFinished with
comment|// *false* since the task has either
comment|// a) SUCCEEDED - which means commit has been done
comment|// b) FAILED - which means we do not need to commit
name|tip
operator|.
name|reportTaskFinished
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|launchJvmAndWait (List<String> setup, Vector<String> vargs, File stdout, File stderr, long logSize, File workDir, Map<String, String> env)
name|void
name|launchJvmAndWait
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|setup
parameter_list|,
name|Vector
argument_list|<
name|String
argument_list|>
name|vargs
parameter_list|,
name|File
name|stdout
parameter_list|,
name|File
name|stderr
parameter_list|,
name|long
name|logSize
parameter_list|,
name|File
name|workDir
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|env
parameter_list|)
throws|throws
name|InterruptedException
block|{
name|jvmManager
operator|.
name|launchJvm
argument_list|(
name|this
argument_list|,
name|jvmManager
operator|.
name|constructJvmEnv
argument_list|(
name|setup
argument_list|,
name|vargs
argument_list|,
name|stdout
argument_list|,
name|stderr
argument_list|,
name|logSize
argument_list|,
name|workDir
argument_list|,
name|env
argument_list|,
name|conf
argument_list|)
argument_list|)
expr_stmt|;
synchronized|synchronized
init|(
name|lock
init|)
block|{
while|while
condition|(
operator|!
name|done
condition|)
block|{
name|lock
operator|.
name|wait
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Prepare the log files for the task    *     * @param taskid    * @param isCleanup    * @return an array of files. The first file is stdout, the second is stderr.    * @throws IOException     */
DECL|method|prepareLogFiles (TaskAttemptID taskid, boolean isCleanup)
name|File
index|[]
name|prepareLogFiles
parameter_list|(
name|TaskAttemptID
name|taskid
parameter_list|,
name|boolean
name|isCleanup
parameter_list|)
throws|throws
name|IOException
block|{
name|File
index|[]
name|logFiles
init|=
operator|new
name|File
index|[
literal|2
index|]
decl_stmt|;
name|logFiles
index|[
literal|0
index|]
operator|=
name|TaskLog
operator|.
name|getTaskLogFile
argument_list|(
name|taskid
argument_list|,
name|isCleanup
argument_list|,
name|TaskLog
operator|.
name|LogName
operator|.
name|STDOUT
argument_list|)
expr_stmt|;
name|logFiles
index|[
literal|1
index|]
operator|=
name|TaskLog
operator|.
name|getTaskLogFile
argument_list|(
name|taskid
argument_list|,
name|isCleanup
argument_list|,
name|TaskLog
operator|.
name|LogName
operator|.
name|STDERR
argument_list|)
expr_stmt|;
name|File
name|logDir
init|=
name|logFiles
index|[
literal|0
index|]
operator|.
name|getParentFile
argument_list|()
decl_stmt|;
name|boolean
name|b
init|=
name|logDir
operator|.
name|mkdirs
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|b
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"mkdirs failed. Ignoring"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|FileSystem
name|localFs
init|=
name|FileSystem
operator|.
name|getLocal
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|localFs
operator|.
name|setPermission
argument_list|(
operator|new
name|Path
argument_list|(
name|logDir
operator|.
name|getCanonicalPath
argument_list|()
argument_list|)
argument_list|,
operator|new
name|FsPermission
argument_list|(
operator|(
name|short
operator|)
literal|0700
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|logFiles
return|;
block|}
comment|/**    * Write the child's configuration to the disk and set it in configuration so    * that the child can pick it up from there.    *     * @param lDirAlloc    * @throws IOException    */
DECL|method|setupChildTaskConfiguration (LocalDirAllocator lDirAlloc)
name|void
name|setupChildTaskConfiguration
parameter_list|(
name|LocalDirAllocator
name|lDirAlloc
parameter_list|)
throws|throws
name|IOException
block|{
name|Path
name|localTaskFile
init|=
name|lDirAlloc
operator|.
name|getLocalPathForWrite
argument_list|(
name|TaskTracker
operator|.
name|getTaskConfFile
argument_list|(
name|t
operator|.
name|getUser
argument_list|()
argument_list|,
name|t
operator|.
name|getJobID
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|,
name|t
operator|.
name|getTaskID
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|,
name|t
operator|.
name|isTaskCleanupTask
argument_list|()
argument_list|)
argument_list|,
name|conf
argument_list|)
decl_stmt|;
comment|// write the child's task configuration file to the local disk
name|writeLocalTaskFile
argument_list|(
name|localTaskFile
operator|.
name|toString
argument_list|()
argument_list|,
name|conf
argument_list|)
expr_stmt|;
comment|// Set the final job file in the task. The child needs to know the correct
comment|// path to job.xml. So set this path accordingly.
name|t
operator|.
name|setJobFile
argument_list|(
name|localTaskFile
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * @return    */
DECL|method|getVMSetupCmd ()
specifier|private
name|List
argument_list|<
name|String
argument_list|>
name|getVMSetupCmd
parameter_list|()
block|{
name|int
name|ulimit
init|=
name|getChildUlimit
argument_list|(
name|conf
argument_list|)
decl_stmt|;
if|if
condition|(
name|ulimit
operator|<=
literal|0
condition|)
block|{
return|return
literal|null
return|;
block|}
name|List
argument_list|<
name|String
argument_list|>
name|setup
init|=
literal|null
decl_stmt|;
name|String
index|[]
name|ulimitCmd
init|=
name|Shell
operator|.
name|getUlimitMemoryCommand
argument_list|(
name|ulimit
argument_list|)
decl_stmt|;
if|if
condition|(
name|ulimitCmd
operator|!=
literal|null
condition|)
block|{
name|setup
operator|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
expr_stmt|;
for|for
control|(
name|String
name|arg
range|:
name|ulimitCmd
control|)
block|{
name|setup
operator|.
name|add
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|setup
return|;
block|}
comment|/**    * Parse the given string and return an array of individual java opts. Split    * on whitespace and replace the special string "@taskid@" with the task ID    * given.    *     * @param javaOpts The string to parse    * @param taskid The task ID to replace the special string with    * @return An array of individual java opts.    */
DECL|method|parseChildJavaOpts (String javaOpts, TaskAttemptID taskid)
specifier|static
name|String
index|[]
name|parseChildJavaOpts
parameter_list|(
name|String
name|javaOpts
parameter_list|,
name|TaskAttemptID
name|taskid
parameter_list|)
block|{
name|javaOpts
operator|=
name|javaOpts
operator|.
name|replace
argument_list|(
literal|"@taskid@"
argument_list|,
name|taskid
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|javaOpts
operator|.
name|trim
argument_list|()
operator|.
name|split
argument_list|(
literal|"\\s+"
argument_list|)
return|;
block|}
comment|/**    * @param taskid    * @param workDir    * @param classPaths    * @param logSize    * @return    * @throws IOException    */
DECL|method|getVMArgs (TaskAttemptID taskid, File workDir, List<String> classPaths, long logSize)
specifier|private
name|Vector
argument_list|<
name|String
argument_list|>
name|getVMArgs
parameter_list|(
name|TaskAttemptID
name|taskid
parameter_list|,
name|File
name|workDir
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|classPaths
parameter_list|,
name|long
name|logSize
parameter_list|)
throws|throws
name|IOException
block|{
name|Vector
argument_list|<
name|String
argument_list|>
name|vargs
init|=
operator|new
name|Vector
argument_list|<
name|String
argument_list|>
argument_list|(
literal|8
argument_list|)
decl_stmt|;
name|File
name|jvm
init|=
comment|// use same jvm as parent
operator|new
name|File
argument_list|(
operator|new
name|File
argument_list|(
name|System
operator|.
name|getProperty
argument_list|(
literal|"java.home"
argument_list|)
argument_list|,
literal|"bin"
argument_list|)
argument_list|,
literal|"java"
argument_list|)
decl_stmt|;
name|vargs
operator|.
name|add
argument_list|(
name|jvm
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
comment|// Add child (task) java-vm options.
comment|//
comment|// The following symbols if present in mapred.{map|reduce}.child.java.opts
comment|// value are replaced:
comment|// + @taskid@ is interpolated with value of TaskID.
comment|// Other occurrences of @ will not be altered.
comment|//
comment|// Example with multiple arguments and substitutions, showing
comment|// jvm GC logging, and start of a passwordless JVM JMX agent so can
comment|// connect with jconsole and the likes to watch child memory, threads
comment|// and get thread dumps.
comment|//
comment|//<property>
comment|//<name>mapred.child.java.opts</name>
comment|//<value>-Xmx512M -verbose:gc -Xloggc:/tmp/@taskid@.gc \
comment|//           -Dcom.sun.management.jmxremote.authenticate=false \
comment|//           -Dcom.sun.management.jmxremote.ssl=false \
comment|//</value>
comment|//</property>
comment|//
comment|//<property>
comment|//<name>mapred.child.java.opts</name>
comment|//<value>-Xmx1024M -verbose:gc -Xloggc:/tmp/@taskid@.gc \
comment|//           -Dcom.sun.management.jmxremote.authenticate=false \
comment|//           -Dcom.sun.management.jmxremote.ssl=false \
comment|//</value>
comment|//</property>
comment|//
name|String
index|[]
name|javaOptsSplit
init|=
name|parseChildJavaOpts
argument_list|(
name|getChildJavaOpts
argument_list|(
name|conf
argument_list|,
name|JobConf
operator|.
name|DEFAULT_MAPRED_TASK_JAVA_OPTS
argument_list|)
argument_list|,
name|taskid
argument_list|)
decl_stmt|;
comment|// Add java.library.path; necessary for loading native libraries.
comment|//
comment|// 1. To support native-hadoop library i.e. libhadoop.so, we add the
comment|//    parent processes' java.library.path to the child.
comment|// 2. We also add the 'cwd' of the task to it's java.library.path to help
comment|//    users distribute native libraries via the DistributedCache.
comment|// 3. The user can also specify extra paths to be added to the
comment|//    java.library.path via mapred.{map|reduce}.child.java.opts.
comment|//
name|String
name|libraryPath
init|=
name|System
operator|.
name|getProperty
argument_list|(
literal|"java.library.path"
argument_list|)
decl_stmt|;
if|if
condition|(
name|libraryPath
operator|==
literal|null
condition|)
block|{
name|libraryPath
operator|=
name|workDir
operator|.
name|getAbsolutePath
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|libraryPath
operator|+=
name|SYSTEM_PATH_SEPARATOR
operator|+
name|workDir
expr_stmt|;
block|}
name|boolean
name|hasUserLDPath
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|javaOptsSplit
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|javaOptsSplit
index|[
name|i
index|]
operator|.
name|startsWith
argument_list|(
literal|"-Djava.library.path="
argument_list|)
condition|)
block|{
name|javaOptsSplit
index|[
name|i
index|]
operator|+=
name|SYSTEM_PATH_SEPARATOR
operator|+
name|libraryPath
expr_stmt|;
name|hasUserLDPath
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|hasUserLDPath
condition|)
block|{
name|vargs
operator|.
name|add
argument_list|(
literal|"-Djava.library.path="
operator|+
name|libraryPath
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|javaOptsSplit
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|vargs
operator|.
name|add
argument_list|(
name|javaOptsSplit
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|Path
name|childTmpDir
init|=
name|createChildTmpDir
argument_list|(
name|workDir
argument_list|,
name|conf
argument_list|)
decl_stmt|;
name|vargs
operator|.
name|add
argument_list|(
literal|"-Djava.io.tmpdir="
operator|+
name|childTmpDir
argument_list|)
expr_stmt|;
comment|// Add classpath.
name|vargs
operator|.
name|add
argument_list|(
literal|"-classpath"
argument_list|)
expr_stmt|;
name|String
name|classPath
init|=
name|StringUtils
operator|.
name|join
argument_list|(
name|SYSTEM_PATH_SEPARATOR
argument_list|,
name|classPaths
argument_list|)
decl_stmt|;
name|vargs
operator|.
name|add
argument_list|(
name|classPath
argument_list|)
expr_stmt|;
comment|// Setup the log4j prop
name|setupLog4jProperties
argument_list|(
name|vargs
argument_list|,
name|taskid
argument_list|,
name|logSize
argument_list|)
expr_stmt|;
if|if
condition|(
name|conf
operator|.
name|getProfileEnabled
argument_list|()
condition|)
block|{
if|if
condition|(
name|conf
operator|.
name|getProfileTaskRange
argument_list|(
name|t
operator|.
name|isMapTask
argument_list|()
argument_list|)
operator|.
name|isIncluded
argument_list|(
name|t
operator|.
name|getPartition
argument_list|()
argument_list|)
condition|)
block|{
name|File
name|prof
init|=
name|TaskLog
operator|.
name|getTaskLogFile
argument_list|(
name|taskid
argument_list|,
name|t
operator|.
name|isTaskCleanupTask
argument_list|()
argument_list|,
name|TaskLog
operator|.
name|LogName
operator|.
name|PROFILE
argument_list|)
decl_stmt|;
name|vargs
operator|.
name|add
argument_list|(
name|String
operator|.
name|format
argument_list|(
name|conf
operator|.
name|getProfileParams
argument_list|()
argument_list|,
name|prof
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Add main class and its arguments
name|vargs
operator|.
name|add
argument_list|(
name|Child
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
comment|// main of Child
comment|// pass umbilical address
name|InetSocketAddress
name|address
init|=
name|tracker
operator|.
name|getTaskTrackerReportAddress
argument_list|()
decl_stmt|;
name|vargs
operator|.
name|add
argument_list|(
name|address
operator|.
name|getAddress
argument_list|()
operator|.
name|getHostAddress
argument_list|()
argument_list|)
expr_stmt|;
name|vargs
operator|.
name|add
argument_list|(
name|Integer
operator|.
name|toString
argument_list|(
name|address
operator|.
name|getPort
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|vargs
operator|.
name|add
argument_list|(
name|taskid
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
comment|// pass task identifier
comment|// pass task log location
name|vargs
operator|.
name|add
argument_list|(
name|TaskLog
operator|.
name|getAttemptDir
argument_list|(
name|taskid
argument_list|,
name|t
operator|.
name|isTaskCleanupTask
argument_list|()
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|vargs
return|;
block|}
DECL|method|setupLog4jProperties (Vector<String> vargs, TaskAttemptID taskid, long logSize)
specifier|private
name|void
name|setupLog4jProperties
parameter_list|(
name|Vector
argument_list|<
name|String
argument_list|>
name|vargs
parameter_list|,
name|TaskAttemptID
name|taskid
parameter_list|,
name|long
name|logSize
parameter_list|)
block|{
name|vargs
operator|.
name|add
argument_list|(
literal|"-Dhadoop.log.dir="
operator|+
operator|new
name|File
argument_list|(
name|System
operator|.
name|getProperty
argument_list|(
literal|"hadoop.log.dir"
argument_list|)
argument_list|)
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
name|vargs
operator|.
name|add
argument_list|(
literal|"-Dhadoop.root.logger="
operator|+
name|getLogLevel
argument_list|(
name|conf
argument_list|)
operator|.
name|toString
argument_list|()
operator|+
literal|",TLA"
argument_list|)
expr_stmt|;
name|vargs
operator|.
name|add
argument_list|(
literal|"-D"
operator|+
name|TaskLogAppender
operator|.
name|TASKID_PROPERTY
operator|+
literal|"="
operator|+
name|taskid
argument_list|)
expr_stmt|;
name|vargs
operator|.
name|add
argument_list|(
literal|"-D"
operator|+
name|TaskLogAppender
operator|.
name|ISCLEANUP_PROPERTY
operator|+
literal|"="
operator|+
name|t
operator|.
name|isTaskCleanupTask
argument_list|()
argument_list|)
expr_stmt|;
name|vargs
operator|.
name|add
argument_list|(
literal|"-D"
operator|+
name|TaskLogAppender
operator|.
name|LOGSIZE_PROPERTY
operator|+
literal|"="
operator|+
name|logSize
argument_list|)
expr_stmt|;
block|}
comment|/**    * @param taskid    * @param workDir    * @return    * @throws IOException    */
DECL|method|createChildTmpDir (File workDir, JobConf conf)
specifier|static
name|Path
name|createChildTmpDir
parameter_list|(
name|File
name|workDir
parameter_list|,
name|JobConf
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
comment|// add java.io.tmpdir given by mapreduce.task.tmp.dir
name|String
name|tmp
init|=
name|conf
operator|.
name|get
argument_list|(
name|MRJobConfig
operator|.
name|TASK_TEMP_DIR
argument_list|,
literal|"./tmp"
argument_list|)
decl_stmt|;
name|Path
name|tmpDir
init|=
operator|new
name|Path
argument_list|(
name|tmp
argument_list|)
decl_stmt|;
comment|// if temp directory path is not absolute, prepend it with workDir.
if|if
condition|(
operator|!
name|tmpDir
operator|.
name|isAbsolute
argument_list|()
condition|)
block|{
name|tmpDir
operator|=
operator|new
name|Path
argument_list|(
name|workDir
operator|.
name|toString
argument_list|()
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|FileSystem
name|localFs
init|=
name|FileSystem
operator|.
name|getLocal
argument_list|(
name|conf
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|localFs
operator|.
name|mkdirs
argument_list|(
name|tmpDir
argument_list|)
operator|&&
name|localFs
operator|.
name|getFileStatus
argument_list|(
name|tmpDir
argument_list|)
operator|.
name|isFile
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Mkdirs failed to create "
operator|+
name|tmpDir
operator|.
name|toString
argument_list|()
argument_list|)
throw|;
block|}
block|}
return|return
name|tmpDir
return|;
block|}
comment|/**    */
DECL|method|getClassPaths (JobConf conf, File workDir, TaskDistributedCacheManager taskDistributedCacheManager)
specifier|private
specifier|static
name|List
argument_list|<
name|String
argument_list|>
name|getClassPaths
parameter_list|(
name|JobConf
name|conf
parameter_list|,
name|File
name|workDir
parameter_list|,
name|TaskDistributedCacheManager
name|taskDistributedCacheManager
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Accumulates class paths for child.
name|List
argument_list|<
name|String
argument_list|>
name|classPaths
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
comment|// start with same classpath as parent process
name|appendSystemClasspaths
argument_list|(
name|classPaths
argument_list|)
expr_stmt|;
comment|// include the user specified classpath
name|appendJobJarClasspaths
argument_list|(
name|conf
operator|.
name|getJar
argument_list|()
argument_list|,
name|classPaths
argument_list|)
expr_stmt|;
comment|// Distributed cache paths
name|classPaths
operator|.
name|addAll
argument_list|(
name|taskDistributedCacheManager
operator|.
name|getClassPaths
argument_list|()
argument_list|)
expr_stmt|;
comment|// Include the working dir too
name|classPaths
operator|.
name|add
argument_list|(
name|workDir
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|classPaths
return|;
block|}
comment|/**    * sets the environment variables needed for task jvm and its children.    * @param errorInfo    * @param workDir    * @param env    * @return    * @throws Throwable    */
DECL|method|getVMEnvironment (String errorInfo, File workDir, JobConf conf, Map<String, String> env, TaskAttemptID taskid, long logSize)
specifier|private
name|String
name|getVMEnvironment
parameter_list|(
name|String
name|errorInfo
parameter_list|,
name|File
name|workDir
parameter_list|,
name|JobConf
name|conf
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|env
parameter_list|,
name|TaskAttemptID
name|taskid
parameter_list|,
name|long
name|logSize
parameter_list|)
throws|throws
name|Throwable
block|{
name|StringBuffer
name|ldLibraryPath
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
name|ldLibraryPath
operator|.
name|append
argument_list|(
name|workDir
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|String
name|oldLdLibraryPath
init|=
literal|null
decl_stmt|;
name|oldLdLibraryPath
operator|=
name|System
operator|.
name|getenv
argument_list|(
literal|"LD_LIBRARY_PATH"
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldLdLibraryPath
operator|!=
literal|null
condition|)
block|{
name|ldLibraryPath
operator|.
name|append
argument_list|(
name|SYSTEM_PATH_SEPARATOR
argument_list|)
expr_stmt|;
name|ldLibraryPath
operator|.
name|append
argument_list|(
name|oldLdLibraryPath
argument_list|)
expr_stmt|;
block|}
name|env
operator|.
name|put
argument_list|(
literal|"LD_LIBRARY_PATH"
argument_list|,
name|ldLibraryPath
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
comment|// put jobTokenFile name into env
name|String
name|jobTokenFile
init|=
name|conf
operator|.
name|get
argument_list|(
name|TokenCache
operator|.
name|JOB_TOKENS_FILENAME
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"putting jobToken file name into environment fn="
operator|+
name|jobTokenFile
argument_list|)
expr_stmt|;
name|env
operator|.
name|put
argument_list|(
name|UserGroupInformation
operator|.
name|HADOOP_TOKEN_FILE_LOCATION
argument_list|,
name|jobTokenFile
argument_list|)
expr_stmt|;
comment|// for the child of task jvm, set hadoop.root.logger
name|env
operator|.
name|put
argument_list|(
literal|"HADOOP_ROOT_LOGGER"
argument_list|,
literal|"INFO,TLA"
argument_list|)
expr_stmt|;
name|String
name|hadoopClientOpts
init|=
name|System
operator|.
name|getenv
argument_list|(
literal|"HADOOP_CLIENT_OPTS"
argument_list|)
decl_stmt|;
if|if
condition|(
name|hadoopClientOpts
operator|==
literal|null
condition|)
block|{
name|hadoopClientOpts
operator|=
literal|""
expr_stmt|;
block|}
else|else
block|{
name|hadoopClientOpts
operator|=
name|hadoopClientOpts
operator|+
literal|" "
expr_stmt|;
block|}
name|hadoopClientOpts
operator|=
name|hadoopClientOpts
operator|+
literal|"-Dhadoop.tasklog.taskid="
operator|+
name|taskid
operator|+
literal|" -Dhadoop.tasklog.iscleanup="
operator|+
name|t
operator|.
name|isTaskCleanupTask
argument_list|()
operator|+
literal|" -Dhadoop.tasklog.totalLogFileSize="
operator|+
name|logSize
expr_stmt|;
name|env
operator|.
name|put
argument_list|(
literal|"HADOOP_CLIENT_OPTS"
argument_list|,
name|hadoopClientOpts
argument_list|)
expr_stmt|;
comment|// add the env variables passed by the user
name|String
name|mapredChildEnv
init|=
name|getChildEnv
argument_list|(
name|conf
argument_list|)
decl_stmt|;
if|if
condition|(
name|mapredChildEnv
operator|!=
literal|null
operator|&&
name|mapredChildEnv
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|String
name|childEnvs
index|[]
init|=
name|mapredChildEnv
operator|.
name|split
argument_list|(
literal|","
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|cEnv
range|:
name|childEnvs
control|)
block|{
try|try
block|{
name|String
index|[]
name|parts
init|=
name|cEnv
operator|.
name|split
argument_list|(
literal|"="
argument_list|)
decl_stmt|;
comment|// split on '='
name|String
name|value
init|=
name|env
operator|.
name|get
argument_list|(
name|parts
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
comment|// replace $env with the child's env constructed by tt's
comment|// example LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/tmp
name|value
operator|=
name|parts
index|[
literal|1
index|]
operator|.
name|replace
argument_list|(
literal|"$"
operator|+
name|parts
index|[
literal|0
index|]
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// this key is not configured by the tt for the child .. get it
comment|// from the tt's env
comment|// example PATH=$PATH:/tmp
name|value
operator|=
name|System
operator|.
name|getenv
argument_list|(
name|parts
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
comment|// the env key is present in the tt's env
name|value
operator|=
name|parts
index|[
literal|1
index|]
operator|.
name|replace
argument_list|(
literal|"$"
operator|+
name|parts
index|[
literal|0
index|]
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// the env key is note present anywhere .. simply set it
comment|// example X=$X:/tmp or X=/tmp
name|value
operator|=
name|parts
index|[
literal|1
index|]
operator|.
name|replace
argument_list|(
literal|"$"
operator|+
name|parts
index|[
literal|0
index|]
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
block|}
name|env
operator|.
name|put
argument_list|(
name|parts
index|[
literal|0
index|]
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
comment|// set the error msg
name|errorInfo
operator|=
literal|"Invalid User environment settings : "
operator|+
name|mapredChildEnv
operator|+
literal|". Failed to parse user-passed environment param."
operator|+
literal|" Expecting : env1=value1,env2=value2..."
expr_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
name|errorInfo
argument_list|)
expr_stmt|;
throw|throw
name|t
throw|;
block|}
block|}
block|}
return|return
name|errorInfo
return|;
block|}
comment|/**    * Write the task specific job-configuration file.    *     * @param localFs    * @throws IOException    */
DECL|method|writeLocalTaskFile (String jobFile, JobConf conf)
specifier|private
specifier|static
name|void
name|writeLocalTaskFile
parameter_list|(
name|String
name|jobFile
parameter_list|,
name|JobConf
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|Path
name|localTaskFile
init|=
operator|new
name|Path
argument_list|(
name|jobFile
argument_list|)
decl_stmt|;
name|FileSystem
name|localFs
init|=
name|FileSystem
operator|.
name|getLocal
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|localFs
operator|.
name|delete
argument_list|(
name|localTaskFile
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|OutputStream
name|out
init|=
name|localFs
operator|.
name|create
argument_list|(
name|localTaskFile
argument_list|)
decl_stmt|;
try|try
block|{
name|conf
operator|.
name|writeXml
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|out
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Prepare the Configs.LOCAL_DIR for the child. The child is sand-boxed now.    * Whenever it uses LocalDirAllocator from now on inside the child, it will    * only see files inside the attempt-directory. This is done in the Child's    * process space.    */
DECL|method|setupChildMapredLocalDirs (Task t, JobConf conf)
specifier|static
name|void
name|setupChildMapredLocalDirs
parameter_list|(
name|Task
name|t
parameter_list|,
name|JobConf
name|conf
parameter_list|)
block|{
name|String
index|[]
name|localDirs
init|=
name|conf
operator|.
name|getTrimmedStrings
argument_list|(
name|MRConfig
operator|.
name|LOCAL_DIR
argument_list|)
decl_stmt|;
name|String
name|jobId
init|=
name|t
operator|.
name|getJobID
argument_list|()
operator|.
name|toString
argument_list|()
decl_stmt|;
name|String
name|taskId
init|=
name|t
operator|.
name|getTaskID
argument_list|()
operator|.
name|toString
argument_list|()
decl_stmt|;
name|boolean
name|isCleanup
init|=
name|t
operator|.
name|isTaskCleanupTask
argument_list|()
decl_stmt|;
name|String
name|user
init|=
name|t
operator|.
name|getUser
argument_list|()
decl_stmt|;
name|StringBuffer
name|childMapredLocalDir
init|=
operator|new
name|StringBuffer
argument_list|(
name|localDirs
index|[
literal|0
index|]
operator|+
name|Path
operator|.
name|SEPARATOR
operator|+
name|TaskTracker
operator|.
name|getLocalTaskDir
argument_list|(
name|user
argument_list|,
name|jobId
argument_list|,
name|taskId
argument_list|,
name|isCleanup
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|localDirs
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|childMapredLocalDir
operator|.
name|append
argument_list|(
literal|","
operator|+
name|localDirs
index|[
name|i
index|]
operator|+
name|Path
operator|.
name|SEPARATOR
operator|+
name|TaskTracker
operator|.
name|getLocalTaskDir
argument_list|(
name|user
argument_list|,
name|jobId
argument_list|,
name|taskId
argument_list|,
name|isCleanup
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
name|MRConfig
operator|.
name|LOCAL_DIR
operator|+
literal|" for child : "
operator|+
name|childMapredLocalDir
argument_list|)
expr_stmt|;
name|conf
operator|.
name|set
argument_list|(
name|MRConfig
operator|.
name|LOCAL_DIR
argument_list|,
name|childMapredLocalDir
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/** Creates the working directory pathname for a task attempt. */
DECL|method|formWorkDir (LocalDirAllocator lDirAlloc, TaskAttemptID task, boolean isCleanup, JobConf conf)
specifier|static
name|File
name|formWorkDir
parameter_list|(
name|LocalDirAllocator
name|lDirAlloc
parameter_list|,
name|TaskAttemptID
name|task
parameter_list|,
name|boolean
name|isCleanup
parameter_list|,
name|JobConf
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|Path
name|workDir
init|=
name|lDirAlloc
operator|.
name|getLocalPathToRead
argument_list|(
name|TaskTracker
operator|.
name|getTaskWorkDir
argument_list|(
name|conf
operator|.
name|getUser
argument_list|()
argument_list|,
name|task
operator|.
name|getJobID
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|,
name|task
operator|.
name|toString
argument_list|()
argument_list|,
name|isCleanup
argument_list|)
argument_list|,
name|conf
argument_list|)
decl_stmt|;
return|return
operator|new
name|File
argument_list|(
name|workDir
operator|.
name|toString
argument_list|()
argument_list|)
return|;
block|}
DECL|method|appendSystemClasspaths (List<String> classPaths)
specifier|private
specifier|static
name|void
name|appendSystemClasspaths
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|classPaths
parameter_list|)
block|{
for|for
control|(
name|String
name|c
range|:
name|System
operator|.
name|getProperty
argument_list|(
literal|"java.class.path"
argument_list|)
operator|.
name|split
argument_list|(
name|SYSTEM_PATH_SEPARATOR
argument_list|)
control|)
block|{
name|classPaths
operator|.
name|add
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Given a "jobJar" (typically retrieved via {@link JobConf#getJar()}),    * appends classpath entries for it, as well as its lib/ and classes/    * subdirectories.    *     * @param jobJar Job jar from configuration    * @param classPaths Accumulator for class paths    */
DECL|method|appendJobJarClasspaths (String jobJar, List<String> classPaths)
specifier|static
name|void
name|appendJobJarClasspaths
parameter_list|(
name|String
name|jobJar
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|classPaths
parameter_list|)
block|{
if|if
condition|(
name|jobJar
operator|==
literal|null
condition|)
block|{
return|return;
block|}
name|File
name|jobCacheDir
init|=
operator|new
name|File
argument_list|(
operator|new
name|Path
argument_list|(
name|jobJar
argument_list|)
operator|.
name|getParent
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
comment|// if jar exists, it into workDir
name|File
index|[]
name|libs
init|=
operator|new
name|File
argument_list|(
name|jobCacheDir
argument_list|,
literal|"lib"
argument_list|)
operator|.
name|listFiles
argument_list|()
decl_stmt|;
if|if
condition|(
name|libs
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|File
name|l
range|:
name|libs
control|)
block|{
name|classPaths
operator|.
name|add
argument_list|(
name|l
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|classPaths
operator|.
name|add
argument_list|(
operator|new
name|File
argument_list|(
name|jobCacheDir
argument_list|,
literal|"classes"
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|classPaths
operator|.
name|add
argument_list|(
operator|new
name|File
argument_list|(
name|jobCacheDir
argument_list|,
literal|"job.jar"
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Creates distributed cache symlinks and tmp directory, as appropriate.    * Note that when we setup the distributed    * cache, we didn't create the symlinks. This is done on a per task basis    * by the currently executing task.    *     * @param conf The job configuration.    * @param workDir Working directory, which is completely deleted.    */
DECL|method|setupWorkDir (JobConf conf, File workDir)
specifier|public
specifier|static
name|void
name|setupWorkDir
parameter_list|(
name|JobConf
name|conf
parameter_list|,
name|File
name|workDir
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Fully deleting contents of "
operator|+
name|workDir
argument_list|)
expr_stmt|;
block|}
comment|/** deletes only the contents of workDir leaving the directory empty. We      * can't delete the workDir as it is the current working directory.      */
name|FileUtil
operator|.
name|fullyDeleteContents
argument_list|(
name|workDir
argument_list|)
expr_stmt|;
if|if
condition|(
name|DistributedCache
operator|.
name|getSymlink
argument_list|(
name|conf
argument_list|)
condition|)
block|{
name|URI
index|[]
name|archives
init|=
name|DistributedCache
operator|.
name|getCacheArchives
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|URI
index|[]
name|files
init|=
name|DistributedCache
operator|.
name|getCacheFiles
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|Path
index|[]
name|localArchives
init|=
name|DistributedCache
operator|.
name|getLocalCacheArchives
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|Path
index|[]
name|localFiles
init|=
name|DistributedCache
operator|.
name|getLocalCacheFiles
argument_list|(
name|conf
argument_list|)
decl_stmt|;
if|if
condition|(
name|archives
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|archives
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|String
name|link
init|=
name|archives
index|[
name|i
index|]
operator|.
name|getFragment
argument_list|()
decl_stmt|;
name|String
name|target
init|=
name|localArchives
index|[
name|i
index|]
operator|.
name|toString
argument_list|()
decl_stmt|;
name|symlink
argument_list|(
name|workDir
argument_list|,
name|target
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|files
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|files
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|String
name|link
init|=
name|files
index|[
name|i
index|]
operator|.
name|getFragment
argument_list|()
decl_stmt|;
name|String
name|target
init|=
name|localFiles
index|[
name|i
index|]
operator|.
name|toString
argument_list|()
decl_stmt|;
name|symlink
argument_list|(
name|workDir
argument_list|,
name|target
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// For streaming, create extra symlinks (for all the files
comment|// in the job cache dir) in the current working directory.
comment|// Note that this is only executed if the configuration
comment|// points to a jar file.
if|if
condition|(
name|conf
operator|.
name|getJar
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|File
name|jobCacheDir
init|=
operator|new
name|File
argument_list|(
operator|new
name|Path
argument_list|(
name|conf
operator|.
name|getJar
argument_list|()
argument_list|)
operator|.
name|getParent
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
try|try
block|{
name|TrackerDistributedCacheManager
operator|.
name|createAllSymlink
argument_list|(
name|conf
argument_list|,
name|jobCacheDir
argument_list|,
name|workDir
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ie
parameter_list|)
block|{
comment|// Do not exit even if symlinks have not been created.
name|LOG
operator|.
name|warn
argument_list|(
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|ie
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|createChildTmpDir
argument_list|(
name|workDir
argument_list|,
name|conf
argument_list|)
expr_stmt|;
block|}
comment|/**    * Utility method for creating a symlink and warning on errors.    *     * If link is null, does nothing.    */
DECL|method|symlink (File workDir, String target, String link)
specifier|private
specifier|static
name|void
name|symlink
parameter_list|(
name|File
name|workDir
parameter_list|,
name|String
name|target
parameter_list|,
name|String
name|link
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|link
operator|!=
literal|null
condition|)
block|{
name|link
operator|=
name|workDir
operator|.
name|toString
argument_list|()
operator|+
name|Path
operator|.
name|SEPARATOR
operator|+
name|link
expr_stmt|;
name|File
name|flink
init|=
operator|new
name|File
argument_list|(
name|link
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|flink
operator|.
name|exists
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Creating symlink: %s<- %s"
argument_list|,
name|target
argument_list|,
name|link
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|!=
name|FileUtil
operator|.
name|symLink
argument_list|(
name|target
argument_list|,
name|link
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Failed to create symlink: %s<- %s"
argument_list|,
name|target
argument_list|,
name|link
argument_list|)
argument_list|)
throw|;
block|}
block|}
block|}
block|}
comment|/**    * Kill the child process    */
DECL|method|kill ()
specifier|public
name|void
name|kill
parameter_list|()
block|{
name|killed
operator|=
literal|true
expr_stmt|;
name|jvmManager
operator|.
name|taskKilled
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|signalDone
argument_list|()
expr_stmt|;
block|}
DECL|method|signalDone ()
specifier|public
name|void
name|signalDone
parameter_list|()
block|{
synchronized|synchronized
init|(
name|lock
init|)
block|{
name|done
operator|=
literal|true
expr_stmt|;
name|lock
operator|.
name|notify
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|setExitCode (int exitCode)
specifier|public
name|void
name|setExitCode
parameter_list|(
name|int
name|exitCode
parameter_list|)
block|{
name|this
operator|.
name|exitCodeSet
operator|=
literal|true
expr_stmt|;
name|this
operator|.
name|exitCode
operator|=
name|exitCode
expr_stmt|;
block|}
block|}
end_class

end_unit

