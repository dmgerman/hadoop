begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.mapred
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configurable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|permission
operator|.
name|FsPermission
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|CleanupQueue
operator|.
name|PathDeletionContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|JvmManager
operator|.
name|JvmEnv
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|MRConfig
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|DiskChecker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Shell
operator|.
name|ShellCommandExecutor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceStability
import|;
end_import

begin_comment
comment|/**  * Controls initialization, finalization and clean up of tasks, and  * also the launching and killing of task JVMs.  *   * This class defines the API for initializing, finalizing and cleaning  * up of tasks, as also the launching and killing task JVMs.  * Subclasses of this class will implement the logic required for  * performing the actual actions.  *   *<br/>  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
DECL|class|TaskController
specifier|public
specifier|abstract
class|class
name|TaskController
implements|implements
name|Configurable
block|{
DECL|field|conf
specifier|private
name|Configuration
name|conf
decl_stmt|;
DECL|field|LOG
specifier|public
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|TaskController
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|method|getConf ()
specifier|public
name|Configuration
name|getConf
parameter_list|()
block|{
return|return
name|conf
return|;
block|}
comment|// The list of directory paths specified in the variable Configs.LOCAL_DIR
comment|// This is used to determine which among the list of directories is picked up
comment|// for storing data for a particular task.
DECL|field|mapredLocalDirs
specifier|protected
name|String
index|[]
name|mapredLocalDirs
decl_stmt|;
DECL|method|setConf (Configuration conf)
specifier|public
name|void
name|setConf
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
name|this
operator|.
name|conf
operator|=
name|conf
expr_stmt|;
name|mapredLocalDirs
operator|=
name|conf
operator|.
name|getTrimmedStrings
argument_list|(
name|MRConfig
operator|.
name|LOCAL_DIR
argument_list|)
expr_stmt|;
block|}
comment|/**    * Sets up the permissions of the following directories on all the configured    * disks:    *<ul>    *<li>mapreduce.cluster.local.directories</li>    *<li>Hadoop log directories</li>    *</ul>    */
DECL|method|setup ()
specifier|public
name|void
name|setup
parameter_list|()
throws|throws
name|IOException
block|{
name|FileSystem
name|localFs
init|=
name|FileSystem
operator|.
name|getLocal
argument_list|(
name|conf
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|localDir
range|:
name|this
operator|.
name|mapredLocalDirs
control|)
block|{
comment|// Set up the mapreduce.cluster.local.directories.
name|File
name|mapredlocalDir
init|=
operator|new
name|File
argument_list|(
name|localDir
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|mapredlocalDir
operator|.
name|isDirectory
argument_list|()
operator|&&
operator|!
name|mapredlocalDir
operator|.
name|mkdirs
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Unable to create mapreduce.cluster.local.directory : "
operator|+
name|mapredlocalDir
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|localFs
operator|.
name|setPermission
argument_list|(
operator|new
name|Path
argument_list|(
name|mapredlocalDir
operator|.
name|getCanonicalPath
argument_list|()
argument_list|)
argument_list|,
operator|new
name|FsPermission
argument_list|(
operator|(
name|short
operator|)
literal|0755
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Set up the user log directory
name|File
name|taskLog
init|=
name|TaskLog
operator|.
name|getUserLogDir
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|taskLog
operator|.
name|isDirectory
argument_list|()
operator|&&
operator|!
name|taskLog
operator|.
name|mkdirs
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Unable to create taskLog directory : "
operator|+
name|taskLog
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|localFs
operator|.
name|setPermission
argument_list|(
operator|new
name|Path
argument_list|(
name|taskLog
operator|.
name|getCanonicalPath
argument_list|()
argument_list|)
argument_list|,
operator|new
name|FsPermission
argument_list|(
operator|(
name|short
operator|)
literal|0755
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|DiskChecker
operator|.
name|checkDir
argument_list|(
name|TaskLog
operator|.
name|getUserLogDir
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Take task-controller specific actions to initialize job. This involves    * setting appropriate permissions to job-files so as to secure the files to    * be accessible only by the user's tasks.    *     * @throws IOException    */
DECL|method|initializeJob (JobInitializationContext context)
specifier|abstract
name|void
name|initializeJob
parameter_list|(
name|JobInitializationContext
name|context
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/**    * Take task-controller specific actions to initialize the distributed cache    * file. This involves setting appropriate permissions for these files so as    * to secure them to be accessible only their owners.    *     * @param context    * @throws IOException    */
DECL|method|initializeDistributedCacheFile (DistributedCacheFileContext context)
specifier|public
specifier|abstract
name|void
name|initializeDistributedCacheFile
parameter_list|(
name|DistributedCacheFileContext
name|context
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/**    * Launch a task JVM    *     * This method defines how a JVM will be launched to run a task. Each    * task-controller should also do an    * {@link #initializeTask(TaskControllerContext)} inside this method so as to    * initialize the task before launching it. This is for reasons of    * task-controller specific optimizations w.r.t combining initialization and    * launching of tasks.    *     * @param context the context associated to the task    */
DECL|method|launchTaskJVM (TaskControllerContext context)
specifier|abstract
name|void
name|launchTaskJVM
parameter_list|(
name|TaskControllerContext
name|context
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/**    * Top level cleanup a task JVM method.    *<ol>    *<li>Sends a graceful termiante signal to task JVM to allow subprocesses    * to cleanup.</li>    *<li>Sends a forceful kill signal to task JVM, terminating all its    * sub-processes forcefully.</li>    *</ol>    *    * @param context the task for which kill signal has to be sent.    */
DECL|method|destroyTaskJVM (TaskControllerContext context)
specifier|final
name|void
name|destroyTaskJVM
parameter_list|(
name|TaskControllerContext
name|context
parameter_list|)
block|{
comment|// Send SIGTERM to try to ask for a polite exit.
name|terminateTask
argument_list|(
name|context
argument_list|)
expr_stmt|;
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|context
operator|.
name|sleeptimeBeforeSigkill
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Sleep interrupted : "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|killTask
argument_list|(
name|context
argument_list|)
expr_stmt|;
block|}
comment|/** Perform initializing actions required before a task can run.     *      * For instance, this method can be used to setup appropriate     * access permissions for files and directories that will be     * used by tasks. Tasks use the job cache, log, and distributed cache     * directories and files as part of their functioning. Typically,     * these files are shared between the daemon and the tasks     * themselves. So, a TaskController that is launching tasks     * as different users can implement this method to setup     * appropriate ownership and permissions for these directories     * and files.     */
DECL|method|initializeTask (TaskControllerContext context)
specifier|abstract
name|void
name|initializeTask
parameter_list|(
name|TaskControllerContext
name|context
parameter_list|)
throws|throws
name|IOException
function_decl|;
DECL|class|TaskExecContext
specifier|static
class|class
name|TaskExecContext
block|{
comment|// task being executed
DECL|field|task
name|Task
name|task
decl_stmt|;
block|}
comment|/**    * Contains task information required for the task controller.      */
DECL|class|TaskControllerContext
specifier|static
class|class
name|TaskControllerContext
extends|extends
name|TaskExecContext
block|{
DECL|field|shExec
name|ShellCommandExecutor
name|shExec
decl_stmt|;
comment|// the Shell executor executing the JVM for this task.
comment|// Information used only when this context is used for launching new tasks.
DECL|field|env
name|JvmEnv
name|env
decl_stmt|;
comment|// the JVM environment for the task.
comment|// Information used only when this context is used for destroying a task jvm.
DECL|field|pid
name|String
name|pid
decl_stmt|;
comment|// process handle of task JVM.
DECL|field|sleeptimeBeforeSigkill
name|long
name|sleeptimeBeforeSigkill
decl_stmt|;
comment|// waiting time before sending SIGKILL to task JVM after sending SIGTERM
block|}
comment|/**    * Contains info related to the path of the file/dir to be deleted. This info    * is needed by task-controller to build the full path of the file/dir    */
DECL|class|TaskControllerPathDeletionContext
specifier|static
specifier|abstract
class|class
name|TaskControllerPathDeletionContext
extends|extends
name|PathDeletionContext
block|{
DECL|field|taskController
name|TaskController
name|taskController
decl_stmt|;
DECL|field|user
name|String
name|user
decl_stmt|;
comment|/**      * mapredLocalDir is the base dir under which to-be-deleted jobLocalDir,       * taskWorkDir or taskAttemptDir exists. fullPath of jobLocalDir,       * taskAttemptDir or taskWorkDir is built using mapredLocalDir, jobId,       * taskId, etc.      */
DECL|field|mapredLocalDir
name|Path
name|mapredLocalDir
decl_stmt|;
DECL|method|TaskControllerPathDeletionContext (FileSystem fs, Path mapredLocalDir, TaskController taskController, String user)
specifier|public
name|TaskControllerPathDeletionContext
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Path
name|mapredLocalDir
parameter_list|,
name|TaskController
name|taskController
parameter_list|,
name|String
name|user
parameter_list|)
block|{
name|super
argument_list|(
name|fs
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|this
operator|.
name|taskController
operator|=
name|taskController
expr_stmt|;
name|this
operator|.
name|mapredLocalDir
operator|=
name|mapredLocalDir
expr_stmt|;
name|this
operator|.
name|user
operator|=
name|user
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getPathForCleanup ()
specifier|protected
name|String
name|getPathForCleanup
parameter_list|()
block|{
if|if
condition|(
name|fullPath
operator|==
literal|null
condition|)
block|{
name|fullPath
operator|=
name|buildPathForDeletion
argument_list|()
expr_stmt|;
block|}
return|return
name|fullPath
return|;
block|}
comment|/**      * Return the component of the path under the {@link #mapredLocalDir} to be       * cleaned up. Its the responsibility of the class that extends       * {@link TaskControllerPathDeletionContext} to provide the correct       * component. For example       *  - For task related cleanups, either the task-work-dir or task-local-dir      *    might be returned depending on jvm reuse.      *  - For job related cleanup, simply the job-local-dir might be returned.      */
DECL|method|getPath ()
specifier|abstract
specifier|protected
name|String
name|getPath
parameter_list|()
function_decl|;
comment|/**      * Builds the path of taskAttemptDir OR taskWorkDir based on      * mapredLocalDir, jobId, taskId, etc      */
DECL|method|buildPathForDeletion ()
name|String
name|buildPathForDeletion
parameter_list|()
block|{
return|return
name|mapredLocalDir
operator|.
name|toUri
argument_list|()
operator|.
name|getPath
argument_list|()
operator|+
name|Path
operator|.
name|SEPARATOR
operator|+
name|getPath
argument_list|()
return|;
block|}
block|}
comment|/** Contains info related to the path of the file/dir to be deleted. This info    * is needed by task-controller to build the full path of the task-work-dir or    * task-local-dir depending on whether the jvm is reused or not.    */
DECL|class|TaskControllerTaskPathDeletionContext
specifier|static
class|class
name|TaskControllerTaskPathDeletionContext
extends|extends
name|TaskControllerPathDeletionContext
block|{
DECL|field|task
specifier|final
name|Task
name|task
decl_stmt|;
DECL|field|isWorkDir
specifier|final
name|boolean
name|isWorkDir
decl_stmt|;
DECL|method|TaskControllerTaskPathDeletionContext (FileSystem fs, Path mapredLocalDir, Task task, boolean isWorkDir, TaskController taskController)
specifier|public
name|TaskControllerTaskPathDeletionContext
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Path
name|mapredLocalDir
parameter_list|,
name|Task
name|task
parameter_list|,
name|boolean
name|isWorkDir
parameter_list|,
name|TaskController
name|taskController
parameter_list|)
block|{
name|super
argument_list|(
name|fs
argument_list|,
name|mapredLocalDir
argument_list|,
name|taskController
argument_list|,
name|task
operator|.
name|getUser
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|task
operator|=
name|task
expr_stmt|;
name|this
operator|.
name|isWorkDir
operator|=
name|isWorkDir
expr_stmt|;
block|}
comment|/**      * Returns the taskWorkDir or taskLocalDir based on whether       * {@link TaskControllerTaskPathDeletionContext} is configured to delete      * the workDir.      */
annotation|@
name|Override
DECL|method|getPath ()
specifier|protected
name|String
name|getPath
parameter_list|()
block|{
name|String
name|subDir
init|=
operator|(
name|isWorkDir
operator|)
condition|?
name|TaskTracker
operator|.
name|getTaskWorkDir
argument_list|(
name|task
operator|.
name|getUser
argument_list|()
argument_list|,
name|task
operator|.
name|getJobID
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|,
name|task
operator|.
name|getTaskID
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|,
name|task
operator|.
name|isTaskCleanupTask
argument_list|()
argument_list|)
else|:
name|TaskTracker
operator|.
name|getLocalTaskDir
argument_list|(
name|task
operator|.
name|getUser
argument_list|()
argument_list|,
name|task
operator|.
name|getJobID
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|,
name|task
operator|.
name|getTaskID
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|,
name|task
operator|.
name|isTaskCleanupTask
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|subDir
return|;
block|}
comment|/**      * Makes the path(and its subdirectories recursively) fully deletable by      * setting proper permissions(770) by task-controller      */
annotation|@
name|Override
DECL|method|enablePathForCleanup ()
specifier|protected
name|void
name|enablePathForCleanup
parameter_list|()
throws|throws
name|IOException
block|{
name|getPathForCleanup
argument_list|()
expr_stmt|;
comment|// allow init of fullPath, if not inited already
if|if
condition|(
name|fs
operator|.
name|exists
argument_list|(
operator|new
name|Path
argument_list|(
name|fullPath
argument_list|)
argument_list|)
condition|)
block|{
name|taskController
operator|.
name|enableTaskForCleanup
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/** Contains info related to the path of the file/dir to be deleted. This info    * is needed by task-controller to build the full path of the job-local-dir.    */
DECL|class|TaskControllerJobPathDeletionContext
specifier|static
class|class
name|TaskControllerJobPathDeletionContext
extends|extends
name|TaskControllerPathDeletionContext
block|{
DECL|field|jobId
specifier|final
name|JobID
name|jobId
decl_stmt|;
DECL|method|TaskControllerJobPathDeletionContext (FileSystem fs, Path mapredLocalDir, JobID id, String user, TaskController taskController)
specifier|public
name|TaskControllerJobPathDeletionContext
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Path
name|mapredLocalDir
parameter_list|,
name|JobID
name|id
parameter_list|,
name|String
name|user
parameter_list|,
name|TaskController
name|taskController
parameter_list|)
block|{
name|super
argument_list|(
name|fs
argument_list|,
name|mapredLocalDir
argument_list|,
name|taskController
argument_list|,
name|user
argument_list|)
expr_stmt|;
name|this
operator|.
name|jobId
operator|=
name|id
expr_stmt|;
block|}
comment|/**      * Returns the jobLocalDir of the job to be cleaned up.      */
annotation|@
name|Override
DECL|method|getPath ()
specifier|protected
name|String
name|getPath
parameter_list|()
block|{
return|return
name|TaskTracker
operator|.
name|getLocalJobDir
argument_list|(
name|user
argument_list|,
name|jobId
operator|.
name|toString
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Makes the path(and its sub-directories recursively) fully deletable by      * setting proper permissions(770) by task-controller      */
annotation|@
name|Override
DECL|method|enablePathForCleanup ()
specifier|protected
name|void
name|enablePathForCleanup
parameter_list|()
throws|throws
name|IOException
block|{
name|getPathForCleanup
argument_list|()
expr_stmt|;
comment|// allow init of fullPath, if not inited already
if|if
condition|(
name|fs
operator|.
name|exists
argument_list|(
operator|new
name|Path
argument_list|(
name|fullPath
argument_list|)
argument_list|)
condition|)
block|{
name|taskController
operator|.
name|enableJobForCleanup
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|InterfaceAudience
operator|.
name|Private
annotation|@
name|InterfaceStability
operator|.
name|Unstable
DECL|class|InitializationContext
specifier|public
specifier|static
class|class
name|InitializationContext
block|{
DECL|field|workDir
specifier|public
name|File
name|workDir
decl_stmt|;
DECL|field|user
specifier|public
name|String
name|user
decl_stmt|;
DECL|method|InitializationContext ()
specifier|public
name|InitializationContext
parameter_list|()
block|{     }
DECL|method|InitializationContext (String user, File workDir)
specifier|public
name|InitializationContext
parameter_list|(
name|String
name|user
parameter_list|,
name|File
name|workDir
parameter_list|)
block|{
name|this
operator|.
name|user
operator|=
name|user
expr_stmt|;
name|this
operator|.
name|workDir
operator|=
name|workDir
expr_stmt|;
block|}
block|}
comment|/**    * This is used for initializing the private localized files in distributed    * cache. Initialization would involve changing permission, ownership and etc.    */
annotation|@
name|InterfaceAudience
operator|.
name|Private
annotation|@
name|InterfaceStability
operator|.
name|Unstable
DECL|class|DistributedCacheFileContext
specifier|public
specifier|static
class|class
name|DistributedCacheFileContext
extends|extends
name|InitializationContext
block|{
comment|// base directory under which file has been localized
DECL|field|localizedBaseDir
name|Path
name|localizedBaseDir
decl_stmt|;
comment|// the unique string used to construct the localized path
DECL|field|uniqueString
name|String
name|uniqueString
decl_stmt|;
DECL|method|DistributedCacheFileContext (String user, File workDir, Path localizedBaseDir, String uniqueString)
specifier|public
name|DistributedCacheFileContext
parameter_list|(
name|String
name|user
parameter_list|,
name|File
name|workDir
parameter_list|,
name|Path
name|localizedBaseDir
parameter_list|,
name|String
name|uniqueString
parameter_list|)
block|{
name|super
argument_list|(
name|user
argument_list|,
name|workDir
argument_list|)
expr_stmt|;
name|this
operator|.
name|localizedBaseDir
operator|=
name|localizedBaseDir
expr_stmt|;
name|this
operator|.
name|uniqueString
operator|=
name|uniqueString
expr_stmt|;
block|}
DECL|method|getLocalizedUniqueDir ()
specifier|public
name|Path
name|getLocalizedUniqueDir
parameter_list|()
block|{
return|return
operator|new
name|Path
argument_list|(
name|localizedBaseDir
argument_list|,
operator|new
name|Path
argument_list|(
name|TaskTracker
operator|.
name|getPrivateDistributedCacheDir
argument_list|(
name|user
argument_list|)
argument_list|,
name|uniqueString
argument_list|)
argument_list|)
return|;
block|}
block|}
DECL|class|JobInitializationContext
specifier|static
class|class
name|JobInitializationContext
extends|extends
name|InitializationContext
block|{
DECL|field|jobid
name|JobID
name|jobid
decl_stmt|;
block|}
DECL|class|DebugScriptContext
specifier|static
class|class
name|DebugScriptContext
extends|extends
name|TaskExecContext
block|{
DECL|field|args
name|List
argument_list|<
name|String
argument_list|>
name|args
decl_stmt|;
DECL|field|workDir
name|File
name|workDir
decl_stmt|;
DECL|field|stdout
name|File
name|stdout
decl_stmt|;
block|}
comment|/**    * Sends a graceful terminate signal to taskJVM and it sub-processes.     *       * @param context task context    */
DECL|method|terminateTask (TaskControllerContext context)
specifier|abstract
name|void
name|terminateTask
parameter_list|(
name|TaskControllerContext
name|context
parameter_list|)
function_decl|;
comment|/**    * Sends a KILL signal to forcefully terminate the taskJVM and its    * sub-processes.    *     * @param context task context    */
DECL|method|killTask (TaskControllerContext context)
specifier|abstract
name|void
name|killTask
parameter_list|(
name|TaskControllerContext
name|context
parameter_list|)
function_decl|;
comment|/**    * Sends a QUIT signal to direct the task JVM (and sub-processes) to    * dump their stack to stdout.    *    * @param context task context.    */
DECL|method|dumpTaskStack (TaskControllerContext context)
specifier|abstract
name|void
name|dumpTaskStack
parameter_list|(
name|TaskControllerContext
name|context
parameter_list|)
function_decl|;
comment|/**    * Initialize user on this TaskTracer in a TaskController specific manner.    *     * @param context    * @throws IOException    */
DECL|method|initializeUser (InitializationContext context)
specifier|public
specifier|abstract
name|void
name|initializeUser
parameter_list|(
name|InitializationContext
name|context
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/**    * Launch the task debug script    *     * @param context    * @throws IOException    */
DECL|method|runDebugScript (DebugScriptContext context)
specifier|abstract
name|void
name|runDebugScript
parameter_list|(
name|DebugScriptContext
name|context
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/**    * Enable the task for cleanup by changing permissions of the path    * @param context   path deletion context    * @throws IOException    */
DECL|method|enableTaskForCleanup (PathDeletionContext context)
specifier|abstract
name|void
name|enableTaskForCleanup
parameter_list|(
name|PathDeletionContext
name|context
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/**    * Enable the job for cleanup by changing permissions of the path    * @param context   path deletion context    * @throws IOException    */
DECL|method|enableJobForCleanup (PathDeletionContext context)
specifier|abstract
name|void
name|enableJobForCleanup
parameter_list|(
name|PathDeletionContext
name|context
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/**    * Returns the local unix user that a given job will run as.    */
DECL|method|getRunAsUser (JobConf conf)
name|String
name|getRunAsUser
parameter_list|(
name|JobConf
name|conf
parameter_list|)
block|{
return|return
name|System
operator|.
name|getProperty
argument_list|(
literal|"user.name"
argument_list|)
return|;
block|}
block|}
end_class

end_unit

