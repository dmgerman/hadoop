begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.mapred
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|JobConf
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|TaskTracker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|TaskTracker
operator|.
name|TaskInProgress
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|server
operator|.
name|tasktracker
operator|.
name|TTConfig
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|util
operator|.
name|ProcfsBasedProcessTree
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|util
operator|.
name|ProcessTree
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
import|;
end_import

begin_comment
comment|/**  * Manages memory usage of tasks running under this TT. Kills any task-trees  * that overflow and over-step memory limits.  */
end_comment

begin_class
DECL|class|TaskMemoryManagerThread
class|class
name|TaskMemoryManagerThread
extends|extends
name|Thread
block|{
DECL|field|LOG
specifier|private
specifier|static
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|TaskMemoryManagerThread
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|taskTracker
specifier|private
name|TaskTracker
name|taskTracker
decl_stmt|;
DECL|field|monitoringInterval
specifier|private
name|long
name|monitoringInterval
decl_stmt|;
DECL|field|maxMemoryAllowedForAllTasks
specifier|private
name|long
name|maxMemoryAllowedForAllTasks
decl_stmt|;
DECL|field|maxRssMemoryAllowedForAllTasks
specifier|private
name|long
name|maxRssMemoryAllowedForAllTasks
decl_stmt|;
DECL|field|processTreeInfoMap
specifier|private
name|Map
argument_list|<
name|TaskAttemptID
argument_list|,
name|ProcessTreeInfo
argument_list|>
name|processTreeInfoMap
decl_stmt|;
DECL|field|tasksToBeAdded
specifier|private
name|Map
argument_list|<
name|TaskAttemptID
argument_list|,
name|ProcessTreeInfo
argument_list|>
name|tasksToBeAdded
decl_stmt|;
DECL|field|tasksToBeRemoved
specifier|private
name|List
argument_list|<
name|TaskAttemptID
argument_list|>
name|tasksToBeRemoved
decl_stmt|;
DECL|field|MEMORY_USAGE_STRING
specifier|private
specifier|static
specifier|final
name|String
name|MEMORY_USAGE_STRING
init|=
literal|"Memory usage of ProcessTree %s for task-id %s : Virutal %d bytes, "
operator|+
literal|"limit : %d bytes; Physical %d bytes, limit %d bytes"
decl_stmt|;
DECL|method|TaskMemoryManagerThread (TaskTracker taskTracker)
specifier|public
name|TaskMemoryManagerThread
parameter_list|(
name|TaskTracker
name|taskTracker
parameter_list|)
block|{
name|this
argument_list|(
name|taskTracker
operator|.
name|getTotalMemoryAllottedForTasksOnTT
argument_list|()
operator|*
literal|1024
operator|*
literal|1024L
argument_list|,
name|taskTracker
operator|.
name|getJobConf
argument_list|()
operator|.
name|getLong
argument_list|(
name|TTConfig
operator|.
name|TT_MEMORY_MANAGER_MONITORING_INTERVAL
argument_list|,
literal|5000L
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|taskTracker
operator|=
name|taskTracker
expr_stmt|;
name|long
name|reservedRssMemory
init|=
name|taskTracker
operator|.
name|getReservedPhysicalMemoryOnTT
argument_list|()
decl_stmt|;
name|long
name|totalPhysicalMemoryOnTT
init|=
name|taskTracker
operator|.
name|getTotalPhysicalMemoryOnTT
argument_list|()
decl_stmt|;
if|if
condition|(
name|reservedRssMemory
operator|==
name|JobConf
operator|.
name|DISABLED_MEMORY_LIMIT
operator|||
name|totalPhysicalMemoryOnTT
operator|==
name|JobConf
operator|.
name|DISABLED_MEMORY_LIMIT
condition|)
block|{
name|maxRssMemoryAllowedForAllTasks
operator|=
name|JobConf
operator|.
name|DISABLED_MEMORY_LIMIT
expr_stmt|;
block|}
else|else
block|{
name|maxRssMemoryAllowedForAllTasks
operator|=
name|totalPhysicalMemoryOnTT
operator|-
name|reservedRssMemory
expr_stmt|;
block|}
block|}
comment|// mainly for test purposes. note that the tasktracker variable is
comment|// not set here.
DECL|method|TaskMemoryManagerThread (long maxMemoryAllowedForAllTasks, long monitoringInterval)
name|TaskMemoryManagerThread
parameter_list|(
name|long
name|maxMemoryAllowedForAllTasks
parameter_list|,
name|long
name|monitoringInterval
parameter_list|)
block|{
name|setName
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|processTreeInfoMap
operator|=
operator|new
name|HashMap
argument_list|<
name|TaskAttemptID
argument_list|,
name|ProcessTreeInfo
argument_list|>
argument_list|()
expr_stmt|;
name|tasksToBeAdded
operator|=
operator|new
name|HashMap
argument_list|<
name|TaskAttemptID
argument_list|,
name|ProcessTreeInfo
argument_list|>
argument_list|()
expr_stmt|;
name|tasksToBeRemoved
operator|=
operator|new
name|ArrayList
argument_list|<
name|TaskAttemptID
argument_list|>
argument_list|()
expr_stmt|;
name|this
operator|.
name|maxMemoryAllowedForAllTasks
operator|=
name|maxMemoryAllowedForAllTasks
operator|<
literal|0
condition|?
name|JobConf
operator|.
name|DISABLED_MEMORY_LIMIT
else|:
name|maxMemoryAllowedForAllTasks
expr_stmt|;
name|this
operator|.
name|monitoringInterval
operator|=
name|monitoringInterval
expr_stmt|;
block|}
DECL|method|addTask (TaskAttemptID tid, long memLimit, long memLimitPhysical)
specifier|public
name|void
name|addTask
parameter_list|(
name|TaskAttemptID
name|tid
parameter_list|,
name|long
name|memLimit
parameter_list|,
name|long
name|memLimitPhysical
parameter_list|)
block|{
synchronized|synchronized
init|(
name|tasksToBeAdded
init|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Tracking ProcessTree "
operator|+
name|tid
operator|+
literal|" for the first time"
argument_list|)
expr_stmt|;
name|ProcessTreeInfo
name|ptInfo
init|=
operator|new
name|ProcessTreeInfo
argument_list|(
name|tid
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|memLimit
argument_list|,
name|memLimitPhysical
argument_list|)
decl_stmt|;
name|tasksToBeAdded
operator|.
name|put
argument_list|(
name|tid
argument_list|,
name|ptInfo
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|removeTask (TaskAttemptID tid)
specifier|public
name|void
name|removeTask
parameter_list|(
name|TaskAttemptID
name|tid
parameter_list|)
block|{
synchronized|synchronized
init|(
name|tasksToBeRemoved
init|)
block|{
name|tasksToBeRemoved
operator|.
name|add
argument_list|(
name|tid
argument_list|)
expr_stmt|;
block|}
block|}
DECL|class|ProcessTreeInfo
specifier|private
specifier|static
class|class
name|ProcessTreeInfo
block|{
DECL|field|tid
specifier|private
name|TaskAttemptID
name|tid
decl_stmt|;
DECL|field|pid
specifier|private
name|String
name|pid
decl_stmt|;
DECL|field|pTree
specifier|private
name|ProcfsBasedProcessTree
name|pTree
decl_stmt|;
DECL|field|memLimit
specifier|private
name|long
name|memLimit
decl_stmt|;
DECL|field|memLimitPhysical
specifier|private
name|long
name|memLimitPhysical
decl_stmt|;
DECL|method|ProcessTreeInfo (TaskAttemptID tid, String pid, ProcfsBasedProcessTree pTree, long memLimit, long memLimitPhysical)
specifier|public
name|ProcessTreeInfo
parameter_list|(
name|TaskAttemptID
name|tid
parameter_list|,
name|String
name|pid
parameter_list|,
name|ProcfsBasedProcessTree
name|pTree
parameter_list|,
name|long
name|memLimit
parameter_list|,
name|long
name|memLimitPhysical
parameter_list|)
block|{
name|this
operator|.
name|tid
operator|=
name|tid
expr_stmt|;
name|this
operator|.
name|pid
operator|=
name|pid
expr_stmt|;
name|this
operator|.
name|pTree
operator|=
name|pTree
expr_stmt|;
name|this
operator|.
name|memLimit
operator|=
name|memLimit
expr_stmt|;
name|this
operator|.
name|memLimitPhysical
operator|=
name|memLimitPhysical
expr_stmt|;
block|}
DECL|method|getTID ()
specifier|public
name|TaskAttemptID
name|getTID
parameter_list|()
block|{
return|return
name|tid
return|;
block|}
DECL|method|getPID ()
specifier|public
name|String
name|getPID
parameter_list|()
block|{
return|return
name|pid
return|;
block|}
DECL|method|setPid (String pid)
specifier|public
name|void
name|setPid
parameter_list|(
name|String
name|pid
parameter_list|)
block|{
name|this
operator|.
name|pid
operator|=
name|pid
expr_stmt|;
block|}
DECL|method|getProcessTree ()
specifier|public
name|ProcfsBasedProcessTree
name|getProcessTree
parameter_list|()
block|{
return|return
name|pTree
return|;
block|}
DECL|method|setProcessTree (ProcfsBasedProcessTree pTree)
specifier|public
name|void
name|setProcessTree
parameter_list|(
name|ProcfsBasedProcessTree
name|pTree
parameter_list|)
block|{
name|this
operator|.
name|pTree
operator|=
name|pTree
expr_stmt|;
block|}
DECL|method|getMemLimit ()
specifier|public
name|long
name|getMemLimit
parameter_list|()
block|{
return|return
name|memLimit
return|;
block|}
comment|/**      * @return Physical memory limit for the process tree in bytes      */
DECL|method|getMemLimitPhysical ()
specifier|public
name|long
name|getMemLimitPhysical
parameter_list|()
block|{
return|return
name|memLimitPhysical
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Starting thread: "
operator|+
name|this
operator|.
name|getClass
argument_list|()
argument_list|)
expr_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
comment|// Print the processTrees for debugging.
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|StringBuffer
name|tmp
init|=
operator|new
name|StringBuffer
argument_list|(
literal|"[ "
argument_list|)
decl_stmt|;
for|for
control|(
name|ProcessTreeInfo
name|p
range|:
name|processTreeInfoMap
operator|.
name|values
argument_list|()
control|)
block|{
name|tmp
operator|.
name|append
argument_list|(
name|p
operator|.
name|getPID
argument_list|()
argument_list|)
expr_stmt|;
name|tmp
operator|.
name|append
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Current ProcessTree list : "
operator|+
name|tmp
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|tmp
operator|.
name|length
argument_list|()
argument_list|)
operator|+
literal|"]"
argument_list|)
expr_stmt|;
block|}
comment|//Add new Tasks
synchronized|synchronized
init|(
name|tasksToBeAdded
init|)
block|{
name|processTreeInfoMap
operator|.
name|putAll
argument_list|(
name|tasksToBeAdded
argument_list|)
expr_stmt|;
name|tasksToBeAdded
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
comment|//Remove finished Tasks
synchronized|synchronized
init|(
name|tasksToBeRemoved
init|)
block|{
for|for
control|(
name|TaskAttemptID
name|tid
range|:
name|tasksToBeRemoved
control|)
block|{
name|processTreeInfoMap
operator|.
name|remove
argument_list|(
name|tid
argument_list|)
expr_stmt|;
block|}
name|tasksToBeRemoved
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
name|long
name|memoryStillInUsage
init|=
literal|0
decl_stmt|;
name|long
name|rssMemoryStillInUsage
init|=
literal|0
decl_stmt|;
comment|// Now, check memory usage and kill any overflowing tasks
for|for
control|(
name|Iterator
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|TaskAttemptID
argument_list|,
name|ProcessTreeInfo
argument_list|>
argument_list|>
name|it
init|=
name|processTreeInfoMap
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Map
operator|.
name|Entry
argument_list|<
name|TaskAttemptID
argument_list|,
name|ProcessTreeInfo
argument_list|>
name|entry
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|TaskAttemptID
name|tid
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|ProcessTreeInfo
name|ptInfo
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
try|try
block|{
name|String
name|pId
init|=
name|ptInfo
operator|.
name|getPID
argument_list|()
decl_stmt|;
comment|// Initialize any uninitialized processTrees
if|if
condition|(
name|pId
operator|==
literal|null
condition|)
block|{
comment|// get pid from taskAttemptId
name|pId
operator|=
name|taskTracker
operator|.
name|getPid
argument_list|(
name|ptInfo
operator|.
name|getTID
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|pId
operator|!=
literal|null
condition|)
block|{
comment|// pId will be null, either if the JVM is not spawned yet or if
comment|// the JVM is removed from jvmIdToPid
name|long
name|sleeptimeBeforeSigkill
init|=
name|taskTracker
operator|.
name|getJobConf
argument_list|()
operator|.
name|getLong
argument_list|(
name|TTConfig
operator|.
name|TT_SLEEP_TIME_BEFORE_SIG_KILL
argument_list|,
name|ProcessTree
operator|.
name|DEFAULT_SLEEPTIME_BEFORE_SIGKILL
argument_list|)
decl_stmt|;
comment|// create process tree object
name|ProcfsBasedProcessTree
name|pt
init|=
operator|new
name|ProcfsBasedProcessTree
argument_list|(
name|pId
argument_list|,
name|ProcessTree
operator|.
name|isSetsidAvailable
argument_list|,
name|sleeptimeBeforeSigkill
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Tracking ProcessTree "
operator|+
name|pId
operator|+
literal|" for the first time"
argument_list|)
expr_stmt|;
name|ptInfo
operator|.
name|setPid
argument_list|(
name|pId
argument_list|)
expr_stmt|;
name|ptInfo
operator|.
name|setProcessTree
argument_list|(
name|pt
argument_list|)
expr_stmt|;
block|}
block|}
comment|// End of initializing any uninitialized processTrees
if|if
condition|(
name|pId
operator|==
literal|null
condition|)
block|{
continue|continue;
comment|// processTree cannot be tracked
block|}
name|TaskInProgress
name|tip
init|=
name|taskTracker
operator|.
name|getRunningTask
argument_list|(
name|tid
argument_list|)
decl_stmt|;
if|if
condition|(
name|tip
operator|==
literal|null
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|tip
operator|.
name|wasKilled
argument_list|()
condition|)
block|{
continue|continue;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Constructing ProcessTree for : PID = "
operator|+
name|pId
operator|+
literal|" TID = "
operator|+
name|tid
argument_list|)
expr_stmt|;
name|ProcfsBasedProcessTree
name|pTree
init|=
name|ptInfo
operator|.
name|getProcessTree
argument_list|()
decl_stmt|;
name|pTree
operator|=
name|pTree
operator|.
name|getProcessTree
argument_list|()
expr_stmt|;
comment|// get the updated process-tree
name|ptInfo
operator|.
name|setProcessTree
argument_list|(
name|pTree
argument_list|)
expr_stmt|;
comment|// update ptInfo with proces-tree of
comment|// updated state
name|long
name|currentMemUsage
init|=
name|pTree
operator|.
name|getCumulativeVmem
argument_list|()
decl_stmt|;
name|long
name|currentRssMemUsage
init|=
name|pTree
operator|.
name|getCumulativeRssmem
argument_list|()
decl_stmt|;
comment|// as processes begin with an age 1, we want to see if there
comment|// are processes more than 1 iteration old.
name|long
name|curMemUsageOfAgedProcesses
init|=
name|pTree
operator|.
name|getCumulativeVmem
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|long
name|curRssMemUsageOfAgedProcesses
init|=
name|pTree
operator|.
name|getCumulativeRssmem
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|long
name|limit
init|=
name|ptInfo
operator|.
name|getMemLimit
argument_list|()
decl_stmt|;
name|long
name|limitPhysical
init|=
name|ptInfo
operator|.
name|getMemLimitPhysical
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|String
operator|.
name|format
argument_list|(
name|MEMORY_USAGE_STRING
argument_list|,
name|pId
argument_list|,
name|tid
operator|.
name|toString
argument_list|()
argument_list|,
name|currentMemUsage
argument_list|,
name|limit
argument_list|,
name|currentRssMemUsage
argument_list|,
name|limitPhysical
argument_list|)
argument_list|)
expr_stmt|;
name|boolean
name|isMemoryOverLimit
init|=
literal|false
decl_stmt|;
name|String
name|msg
init|=
literal|""
decl_stmt|;
if|if
condition|(
name|doCheckVirtualMemory
argument_list|()
operator|&&
name|isProcessTreeOverLimit
argument_list|(
name|tid
operator|.
name|toString
argument_list|()
argument_list|,
name|currentMemUsage
argument_list|,
name|curMemUsageOfAgedProcesses
argument_list|,
name|limit
argument_list|)
condition|)
block|{
comment|// Task (the root process) is still alive and overflowing memory.
comment|// Dump the process-tree and then clean it up.
name|msg
operator|=
literal|"TaskTree [pid="
operator|+
name|pId
operator|+
literal|",tipID="
operator|+
name|tid
operator|+
literal|"] is running beyond memory-limits. Current usage : "
operator|+
name|currentMemUsage
operator|+
literal|"bytes. Limit : "
operator|+
name|limit
operator|+
literal|"bytes. Killing task. \nDump of the process-tree for "
operator|+
name|tid
operator|+
literal|" : \n"
operator|+
name|pTree
operator|.
name|getProcessTreeDump
argument_list|()
expr_stmt|;
name|isMemoryOverLimit
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|doCheckPhysicalMemory
argument_list|()
operator|&&
name|isProcessTreeOverLimit
argument_list|(
name|tid
operator|.
name|toString
argument_list|()
argument_list|,
name|currentRssMemUsage
argument_list|,
name|curRssMemUsageOfAgedProcesses
argument_list|,
name|limitPhysical
argument_list|)
condition|)
block|{
comment|// Task (the root process) is still alive and overflowing memory.
comment|// Dump the process-tree and then clean it up.
name|msg
operator|=
literal|"TaskTree [pid="
operator|+
name|pId
operator|+
literal|",tipID="
operator|+
name|tid
operator|+
literal|"] is running beyond physical memory-limits."
operator|+
literal|" Current usage : "
operator|+
name|currentRssMemUsage
operator|+
literal|"bytes. Limit : "
operator|+
name|limitPhysical
operator|+
literal|"bytes. Killing task. \nDump of the process-tree for "
operator|+
name|tid
operator|+
literal|" : \n"
operator|+
name|pTree
operator|.
name|getProcessTreeDump
argument_list|()
expr_stmt|;
name|isMemoryOverLimit
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|isMemoryOverLimit
condition|)
block|{
comment|// Virtual or physical memory over limit. Fail the task and remove
comment|// the corresponding process tree
name|LOG
operator|.
name|warn
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|taskTracker
operator|.
name|cleanUpOverMemoryTask
argument_list|(
name|tid
argument_list|,
literal|true
argument_list|,
name|msg
argument_list|)
expr_stmt|;
comment|// Now destroy the ProcessTree, remove it from monitoring map.
name|pTree
operator|.
name|destroy
argument_list|(
literal|true
comment|/*in the background*/
argument_list|)
expr_stmt|;
name|it
operator|.
name|remove
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Removed ProcessTree with root "
operator|+
name|pId
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Accounting the total memory in usage for all tasks that are still
comment|// alive and within limits.
name|memoryStillInUsage
operator|+=
name|currentMemUsage
expr_stmt|;
name|rssMemoryStillInUsage
operator|+=
name|currentRssMemUsage
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
comment|// Log the exception and proceed to the next task.
name|LOG
operator|.
name|warn
argument_list|(
literal|"Uncaught exception in TaskMemoryManager "
operator|+
literal|"while managing memory of "
operator|+
name|tid
operator|+
literal|" : "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|doCheckVirtualMemory
argument_list|()
operator|&&
name|memoryStillInUsage
operator|>
name|maxMemoryAllowedForAllTasks
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"The total memory in usage "
operator|+
name|memoryStillInUsage
operator|+
literal|" is still overflowing TTs limits "
operator|+
name|maxMemoryAllowedForAllTasks
operator|+
literal|". Trying to kill a few tasks with the least progress."
argument_list|)
expr_stmt|;
name|killTasksWithLeastProgress
argument_list|(
name|memoryStillInUsage
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|doCheckPhysicalMemory
argument_list|()
operator|&&
name|rssMemoryStillInUsage
operator|>
name|maxRssMemoryAllowedForAllTasks
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"The total physical memory in usage "
operator|+
name|rssMemoryStillInUsage
operator|+
literal|" is still overflowing TTs limits "
operator|+
name|maxRssMemoryAllowedForAllTasks
operator|+
literal|". Trying to kill a few tasks with the highest memory."
argument_list|)
expr_stmt|;
name|killTasksWithMaxRssMemory
argument_list|(
name|rssMemoryStillInUsage
argument_list|)
expr_stmt|;
block|}
comment|// Sleep for some time before beginning next cycle
try|try
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|+
literal|" : Sleeping for "
operator|+
name|monitoringInterval
operator|+
literal|" ms"
argument_list|)
expr_stmt|;
name|Thread
operator|.
name|sleep
argument_list|(
name|monitoringInterval
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|+
literal|" interrupted. Finishing the thread and returning."
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
comment|/**    * Is the total physical memory check enabled?    * @return true if total physical memory check is enabled.    */
DECL|method|doCheckPhysicalMemory ()
specifier|private
name|boolean
name|doCheckPhysicalMemory
parameter_list|()
block|{
return|return
operator|!
operator|(
name|maxRssMemoryAllowedForAllTasks
operator|==
name|JobConf
operator|.
name|DISABLED_MEMORY_LIMIT
operator|)
return|;
block|}
comment|/**    * Is the total virtual memory check enabled?    * @return true if total virtual memory check is enabled.    */
DECL|method|doCheckVirtualMemory ()
specifier|private
name|boolean
name|doCheckVirtualMemory
parameter_list|()
block|{
return|return
operator|!
operator|(
name|maxMemoryAllowedForAllTasks
operator|==
name|JobConf
operator|.
name|DISABLED_MEMORY_LIMIT
operator|)
return|;
block|}
comment|/**    * Check whether a task's process tree's current memory usage is over limit.    *     * When a java process exec's a program, it could momentarily account for    * double the size of it's memory, because the JVM does a fork()+exec()    * which at fork time creates a copy of the parent's memory. If the     * monitoring thread detects the memory used by the task tree at the same    * instance, it could assume it is over limit and kill the tree, for no    * fault of the process itself.    *     * We counter this problem by employing a heuristic check:    * - if a process tree exceeds the memory limit by more than twice,     * it is killed immediately    * - if a process tree has processes older than the monitoring interval    * exceeding the memory limit by even 1 time, it is killed. Else it is given    * the benefit of doubt to lie around for one more iteration.    *     * @param tId Task Id for the task tree    * @param currentMemUsage Memory usage of a task tree    * @param curMemUsageOfAgedProcesses Memory usage of processes older than    *                                    an iteration in a task tree    * @param limit The limit specified for the task    * @return true if the memory usage is more than twice the specified limit,    *              or if processes in the tree, older than this thread's     *              monitoring interval, exceed the memory limit. False,     *              otherwise.    */
DECL|method|isProcessTreeOverLimit (String tId, long currentMemUsage, long curMemUsageOfAgedProcesses, long limit)
name|boolean
name|isProcessTreeOverLimit
parameter_list|(
name|String
name|tId
parameter_list|,
name|long
name|currentMemUsage
parameter_list|,
name|long
name|curMemUsageOfAgedProcesses
parameter_list|,
name|long
name|limit
parameter_list|)
block|{
name|boolean
name|isOverLimit
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|currentMemUsage
operator|>
operator|(
literal|2
operator|*
name|limit
operator|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Process tree for task: "
operator|+
name|tId
operator|+
literal|" running over twice "
operator|+
literal|"the configured limit. Limit="
operator|+
name|limit
operator|+
literal|", current usage = "
operator|+
name|currentMemUsage
argument_list|)
expr_stmt|;
name|isOverLimit
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|curMemUsageOfAgedProcesses
operator|>
name|limit
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Process tree for task: "
operator|+
name|tId
operator|+
literal|" has processes older than 1 "
operator|+
literal|"iteration running over the configured limit. Limit="
operator|+
name|limit
operator|+
literal|", current usage = "
operator|+
name|curMemUsageOfAgedProcesses
argument_list|)
expr_stmt|;
name|isOverLimit
operator|=
literal|true
expr_stmt|;
block|}
return|return
name|isOverLimit
return|;
block|}
comment|// method provided just for easy testing purposes
DECL|method|isProcessTreeOverLimit (ProcfsBasedProcessTree pTree, String tId, long limit)
name|boolean
name|isProcessTreeOverLimit
parameter_list|(
name|ProcfsBasedProcessTree
name|pTree
parameter_list|,
name|String
name|tId
parameter_list|,
name|long
name|limit
parameter_list|)
block|{
name|long
name|currentMemUsage
init|=
name|pTree
operator|.
name|getCumulativeVmem
argument_list|()
decl_stmt|;
comment|// as processes begin with an age 1, we want to see if there are processes
comment|// more than 1 iteration old.
name|long
name|curMemUsageOfAgedProcesses
init|=
name|pTree
operator|.
name|getCumulativeVmem
argument_list|(
literal|1
argument_list|)
decl_stmt|;
return|return
name|isProcessTreeOverLimit
argument_list|(
name|tId
argument_list|,
name|currentMemUsage
argument_list|,
name|curMemUsageOfAgedProcesses
argument_list|,
name|limit
argument_list|)
return|;
block|}
DECL|method|killTasksWithLeastProgress (long memoryStillInUsage)
specifier|private
name|void
name|killTasksWithLeastProgress
parameter_list|(
name|long
name|memoryStillInUsage
parameter_list|)
block|{
name|List
argument_list|<
name|TaskAttemptID
argument_list|>
name|tasksToKill
init|=
operator|new
name|ArrayList
argument_list|<
name|TaskAttemptID
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|TaskAttemptID
argument_list|>
name|tasksToExclude
init|=
operator|new
name|ArrayList
argument_list|<
name|TaskAttemptID
argument_list|>
argument_list|()
decl_stmt|;
comment|// Find tasks to kill so as to get memory usage under limits.
while|while
condition|(
name|memoryStillInUsage
operator|>
name|maxMemoryAllowedForAllTasks
condition|)
block|{
comment|// Exclude tasks that are already marked for killing.
comment|// Note that we do not need to call isKillable() here because the logic
comment|// is contained in taskTracker.findTaskToKill()
name|TaskInProgress
name|task
init|=
name|taskTracker
operator|.
name|findTaskToKill
argument_list|(
name|tasksToExclude
argument_list|)
decl_stmt|;
if|if
condition|(
name|task
operator|==
literal|null
condition|)
block|{
break|break;
comment|// couldn't find any more tasks to kill.
block|}
name|TaskAttemptID
name|tid
init|=
name|task
operator|.
name|getTask
argument_list|()
operator|.
name|getTaskID
argument_list|()
decl_stmt|;
if|if
condition|(
name|processTreeInfoMap
operator|.
name|containsKey
argument_list|(
name|tid
argument_list|)
condition|)
block|{
name|ProcessTreeInfo
name|ptInfo
init|=
name|processTreeInfoMap
operator|.
name|get
argument_list|(
name|tid
argument_list|)
decl_stmt|;
name|ProcfsBasedProcessTree
name|pTree
init|=
name|ptInfo
operator|.
name|getProcessTree
argument_list|()
decl_stmt|;
name|memoryStillInUsage
operator|-=
name|pTree
operator|.
name|getCumulativeVmem
argument_list|()
expr_stmt|;
name|tasksToKill
operator|.
name|add
argument_list|(
name|tid
argument_list|)
expr_stmt|;
block|}
comment|// Exclude this task from next search because it is already
comment|// considered.
name|tasksToExclude
operator|.
name|add
argument_list|(
name|tid
argument_list|)
expr_stmt|;
block|}
comment|// Now kill the tasks.
if|if
condition|(
operator|!
name|tasksToKill
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|TaskAttemptID
name|tid
range|:
name|tasksToKill
control|)
block|{
name|String
name|msg
init|=
literal|"Killing one of the least progress tasks - "
operator|+
name|tid
operator|+
literal|", as the cumulative memory usage of all the tasks on "
operator|+
literal|"the TaskTracker exceeds virtual memory limit "
operator|+
name|maxMemoryAllowedForAllTasks
operator|+
literal|"."
decl_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|killTask
argument_list|(
name|tid
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"The total memory usage is overflowing TTs limits. "
operator|+
literal|"But found no alive task to kill for freeing memory."
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Return the cumulative rss memory used by a task    * @param tid the task attempt ID of the task    * @return rss memory usage in bytes. 0 if the process tree is not available    */
DECL|method|getTaskCumulativeRssmem (TaskAttemptID tid)
specifier|private
name|long
name|getTaskCumulativeRssmem
parameter_list|(
name|TaskAttemptID
name|tid
parameter_list|)
block|{
name|ProcessTreeInfo
name|ptInfo
init|=
name|processTreeInfoMap
operator|.
name|get
argument_list|(
name|tid
argument_list|)
decl_stmt|;
name|ProcfsBasedProcessTree
name|pTree
init|=
name|ptInfo
operator|.
name|getProcessTree
argument_list|()
decl_stmt|;
return|return
name|pTree
operator|==
literal|null
condition|?
literal|0
else|:
name|pTree
operator|.
name|getCumulativeVmem
argument_list|()
return|;
block|}
comment|/**    * Starting from the tasks use the highest amount of RSS memory,    * kill the tasks until the RSS memory meets the requirement    * @param rssMemoryInUsage    */
DECL|method|killTasksWithMaxRssMemory (long rssMemoryInUsage)
specifier|private
name|void
name|killTasksWithMaxRssMemory
parameter_list|(
name|long
name|rssMemoryInUsage
parameter_list|)
block|{
name|List
argument_list|<
name|TaskAttemptID
argument_list|>
name|tasksToKill
init|=
operator|new
name|ArrayList
argument_list|<
name|TaskAttemptID
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|TaskAttemptID
argument_list|>
name|allTasks
init|=
operator|new
name|ArrayList
argument_list|<
name|TaskAttemptID
argument_list|>
argument_list|()
decl_stmt|;
name|allTasks
operator|.
name|addAll
argument_list|(
name|processTreeInfoMap
operator|.
name|keySet
argument_list|()
argument_list|)
expr_stmt|;
comment|// Sort the tasks ascendingly according to RSS memory usage
name|Collections
operator|.
name|sort
argument_list|(
name|allTasks
argument_list|,
operator|new
name|Comparator
argument_list|<
name|TaskAttemptID
argument_list|>
argument_list|()
block|{
specifier|public
name|int
name|compare
parameter_list|(
name|TaskAttemptID
name|tid1
parameter_list|,
name|TaskAttemptID
name|tid2
parameter_list|)
block|{
return|return
name|getTaskCumulativeRssmem
argument_list|(
name|tid1
argument_list|)
operator|<
name|getTaskCumulativeRssmem
argument_list|(
name|tid2
argument_list|)
condition|?
operator|-
literal|1
else|:
literal|1
return|;
block|}
block|}
argument_list|)
expr_stmt|;
comment|// Kill the tasks one by one until the memory requirement is met
while|while
condition|(
name|rssMemoryInUsage
operator|>
name|maxRssMemoryAllowedForAllTasks
operator|&&
operator|!
name|allTasks
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|TaskAttemptID
name|tid
init|=
name|allTasks
operator|.
name|remove
argument_list|(
name|allTasks
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|isKillable
argument_list|(
name|tid
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|long
name|rssmem
init|=
name|getTaskCumulativeRssmem
argument_list|(
name|tid
argument_list|)
decl_stmt|;
if|if
condition|(
name|rssmem
operator|==
literal|0
condition|)
block|{
break|break;
comment|// Skip tasks without process tree information currently
block|}
name|tasksToKill
operator|.
name|add
argument_list|(
name|tid
argument_list|)
expr_stmt|;
name|rssMemoryInUsage
operator|-=
name|rssmem
expr_stmt|;
block|}
comment|// Now kill the tasks.
if|if
condition|(
operator|!
name|tasksToKill
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|TaskAttemptID
name|tid
range|:
name|tasksToKill
control|)
block|{
name|String
name|msg
init|=
literal|"Killing one of the memory-consuming tasks - "
operator|+
name|tid
operator|+
literal|", as the cumulative RSS memory usage of all the tasks on "
operator|+
literal|"the TaskTracker exceeds physical memory limit "
operator|+
name|maxRssMemoryAllowedForAllTasks
operator|+
literal|"."
decl_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|killTask
argument_list|(
name|tid
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"The total physical memory usage is overflowing TTs limits. "
operator|+
literal|"But found no alive task to kill for freeing memory."
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Kill the task and clean up ProcessTreeInfo    * @param tid task attempt ID of the task to be killed.    * @param msg diagnostics message    */
DECL|method|killTask (TaskAttemptID tid, String msg)
specifier|private
name|void
name|killTask
parameter_list|(
name|TaskAttemptID
name|tid
parameter_list|,
name|String
name|msg
parameter_list|)
block|{
name|TaskInProgress
name|tip
init|=
name|taskTracker
operator|.
name|getRunningTask
argument_list|(
name|tid
argument_list|)
decl_stmt|;
if|if
condition|(
name|tip
operator|!=
literal|null
condition|)
block|{
comment|//for the task identified to be killed update taskDiagnostic
name|TaskStatus
name|taskStatus
init|=
name|tip
operator|.
name|getStatus
argument_list|()
decl_stmt|;
name|taskStatus
operator|.
name|setDiagnosticInfo
argument_list|(
name|msg
argument_list|)
expr_stmt|;
block|}
comment|// Kill the task and mark it as killed.
name|taskTracker
operator|.
name|cleanUpOverMemoryTask
argument_list|(
name|tid
argument_list|,
literal|false
argument_list|,
name|msg
argument_list|)
expr_stmt|;
comment|// Now destroy the ProcessTree, remove it from monitoring map.
name|ProcessTreeInfo
name|ptInfo
init|=
name|processTreeInfoMap
operator|.
name|get
argument_list|(
name|tid
argument_list|)
decl_stmt|;
name|ProcfsBasedProcessTree
name|pTree
init|=
name|ptInfo
operator|.
name|getProcessTree
argument_list|()
decl_stmt|;
name|pTree
operator|.
name|destroy
argument_list|(
literal|true
comment|/*in the background*/
argument_list|)
expr_stmt|;
name|processTreeInfoMap
operator|.
name|remove
argument_list|(
name|tid
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Removed ProcessTree with root "
operator|+
name|ptInfo
operator|.
name|getPID
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Check if a task can be killed to increase free memory    * @param tid task attempt ID    * @return true if the task can be killed    */
DECL|method|isKillable (TaskAttemptID tid)
specifier|private
name|boolean
name|isKillable
parameter_list|(
name|TaskAttemptID
name|tid
parameter_list|)
block|{
name|TaskInProgress
name|tip
init|=
name|taskTracker
operator|.
name|getRunningTask
argument_list|(
name|tid
argument_list|)
decl_stmt|;
return|return
name|tip
operator|!=
literal|null
operator|&&
operator|!
name|tip
operator|.
name|wasKilled
argument_list|()
operator|&&
operator|(
name|tip
operator|.
name|getRunState
argument_list|()
operator|==
name|TaskStatus
operator|.
name|State
operator|.
name|RUNNING
operator|||
name|tip
operator|.
name|getRunState
argument_list|()
operator|==
name|TaskStatus
operator|.
name|State
operator|.
name|COMMIT_PENDING
operator|)
return|;
block|}
block|}
end_class

end_unit

