begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.mapred
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|JobInProgress
operator|.
name|DataStatistics
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|SortedRanges
operator|.
name|Range
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|TaskCounter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|TaskType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|jobhistory
operator|.
name|JobHistory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|jobhistory
operator|.
name|TaskUpdatedEvent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|split
operator|.
name|JobSplit
operator|.
name|TaskSplitMetaInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|server
operator|.
name|jobtracker
operator|.
name|JTConfig
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|net
operator|.
name|Node
import|;
end_import

begin_comment
comment|/*************************************************************  * TaskInProgress maintains all the info needed for a  * Task in the lifetime of its owning Job.  A given Task  * might be speculatively executed or reexecuted, so we  * need a level of indirection above the running-id itself.  *<br>  * A given TaskInProgress contains multiple task attempt ids,  * 0 or more of which might be executing at any one time.  * (That's what allows speculative execution.)  A task attempt id  * is now *never* recycled.  A TIP allocates enough task attempt ids  * to account for all the speculation and failures it will  * ever have to handle.  Once those are up, the TIP is dead.  * **************************************************************  */
end_comment

begin_class
DECL|class|TaskInProgress
class|class
name|TaskInProgress
block|{
DECL|field|MAX_TASK_EXECS
specifier|static
specifier|final
name|int
name|MAX_TASK_EXECS
init|=
literal|1
decl_stmt|;
comment|//max # nonspec tasks to run concurrently
DECL|field|maxTaskAttempts
name|int
name|maxTaskAttempts
init|=
literal|4
decl_stmt|;
DECL|field|SPECULATIVE_LAG
specifier|static
specifier|final
name|long
name|SPECULATIVE_LAG
init|=
literal|60
operator|*
literal|1000
decl_stmt|;
DECL|field|NUM_ATTEMPTS_PER_RESTART
specifier|private
specifier|static
specifier|final
name|int
name|NUM_ATTEMPTS_PER_RESTART
init|=
literal|1000
decl_stmt|;
DECL|field|MEMORY_SPLITS_RESOLUTION
specifier|private
specifier|static
specifier|final
name|long
name|MEMORY_SPLITS_RESOLUTION
init|=
literal|1024
decl_stmt|;
DECL|field|DEFAULT_STATISTICS_INTERVALS
specifier|static
specifier|final
name|int
name|DEFAULT_STATISTICS_INTERVALS
init|=
literal|12
decl_stmt|;
DECL|field|LOG
specifier|public
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|TaskInProgress
operator|.
name|class
argument_list|)
decl_stmt|;
comment|// Defines the TIP
DECL|field|jobFile
specifier|private
name|String
name|jobFile
init|=
literal|null
decl_stmt|;
DECL|field|splitInfo
specifier|private
name|TaskSplitMetaInfo
name|splitInfo
decl_stmt|;
DECL|field|numMaps
specifier|private
name|int
name|numMaps
decl_stmt|;
DECL|field|partition
specifier|private
name|int
name|partition
decl_stmt|;
DECL|field|jobtracker
specifier|private
name|JobTracker
name|jobtracker
decl_stmt|;
DECL|field|jobHistory
specifier|private
name|JobHistory
name|jobHistory
decl_stmt|;
DECL|field|id
specifier|private
name|TaskID
name|id
decl_stmt|;
DECL|field|job
specifier|private
name|JobInProgress
name|job
decl_stmt|;
DECL|field|numSlotsRequired
specifier|private
specifier|final
name|int
name|numSlotsRequired
decl_stmt|;
comment|// Status of the TIP
DECL|field|successEventNumber
specifier|private
name|int
name|successEventNumber
init|=
operator|-
literal|1
decl_stmt|;
DECL|field|numTaskFailures
specifier|private
name|int
name|numTaskFailures
init|=
literal|0
decl_stmt|;
DECL|field|numKilledTasks
specifier|private
name|int
name|numKilledTasks
init|=
literal|0
decl_stmt|;
DECL|field|progress
specifier|private
name|double
name|progress
init|=
literal|0
decl_stmt|;
DECL|field|oldProgressRate
specifier|private
name|double
name|oldProgressRate
decl_stmt|;
DECL|field|state
specifier|private
name|String
name|state
init|=
literal|""
decl_stmt|;
DECL|field|lastDispatchTime
specifier|private
name|long
name|lastDispatchTime
init|=
literal|0
decl_stmt|;
comment|// most recent time task attempt given to TT
DECL|field|execStartTime
specifier|private
name|long
name|execStartTime
init|=
literal|0
decl_stmt|;
comment|// when we started first task-attempt
DECL|field|execFinishTime
specifier|private
name|long
name|execFinishTime
init|=
literal|0
decl_stmt|;
DECL|field|completes
specifier|private
name|int
name|completes
init|=
literal|0
decl_stmt|;
DECL|field|failed
specifier|private
name|boolean
name|failed
init|=
literal|false
decl_stmt|;
DECL|field|killed
specifier|private
name|boolean
name|killed
init|=
literal|false
decl_stmt|;
DECL|field|maxSkipRecords
specifier|private
name|long
name|maxSkipRecords
init|=
literal|0
decl_stmt|;
DECL|field|failedRanges
specifier|private
name|FailedRanges
name|failedRanges
init|=
operator|new
name|FailedRanges
argument_list|()
decl_stmt|;
DECL|field|skipping
specifier|private
specifier|volatile
name|boolean
name|skipping
init|=
literal|false
decl_stmt|;
DECL|field|jobCleanup
specifier|private
name|boolean
name|jobCleanup
init|=
literal|false
decl_stmt|;
DECL|field|jobSetup
specifier|private
name|boolean
name|jobSetup
init|=
literal|false
decl_stmt|;
DECL|field|CPU_COUNTER_KEY
specifier|static
specifier|final
name|Enum
argument_list|<
name|?
argument_list|>
name|CPU_COUNTER_KEY
init|=
name|TaskCounter
operator|.
name|CPU_MILLISECONDS
decl_stmt|;
DECL|field|VM_BYTES_KEY
specifier|static
specifier|final
name|Enum
argument_list|<
name|?
argument_list|>
name|VM_BYTES_KEY
init|=
name|TaskCounter
operator|.
name|VIRTUAL_MEMORY_BYTES
decl_stmt|;
DECL|field|PHYSICAL_BYTES_KEY
specifier|static
specifier|final
name|Enum
argument_list|<
name|?
argument_list|>
name|PHYSICAL_BYTES_KEY
init|=
name|TaskCounter
operator|.
name|PHYSICAL_MEMORY_BYTES
decl_stmt|;
comment|// The 'next' usable taskid of this tip
DECL|field|nextTaskId
name|int
name|nextTaskId
init|=
literal|0
decl_stmt|;
comment|// The taskid that took this TIP to SUCCESS
DECL|field|successfulTaskId
specifier|private
name|TaskAttemptID
name|successfulTaskId
decl_stmt|;
comment|// The first taskid of this tip
DECL|field|firstTaskId
specifier|private
name|TaskAttemptID
name|firstTaskId
decl_stmt|;
comment|// Map from task Id -> TaskTracker Id, contains tasks that are
comment|// currently runnings
DECL|field|activeTasks
specifier|private
name|TreeMap
argument_list|<
name|TaskAttemptID
argument_list|,
name|String
argument_list|>
name|activeTasks
init|=
operator|new
name|TreeMap
argument_list|<
name|TaskAttemptID
argument_list|,
name|String
argument_list|>
argument_list|()
decl_stmt|;
comment|// All attempt Ids of this TIP
DECL|field|tasks
specifier|private
name|TreeSet
argument_list|<
name|TaskAttemptID
argument_list|>
name|tasks
init|=
operator|new
name|TreeSet
argument_list|<
name|TaskAttemptID
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|conf
specifier|private
name|JobConf
name|conf
decl_stmt|;
DECL|field|taskDiagnosticData
specifier|private
name|Map
argument_list|<
name|TaskAttemptID
argument_list|,
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|taskDiagnosticData
init|=
operator|new
name|TreeMap
argument_list|<
name|TaskAttemptID
argument_list|,
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
comment|/**    * Map from task attempt Id -> TaskStatus    */
DECL|field|taskStatuses
name|TreeMap
argument_list|<
name|TaskAttemptID
argument_list|,
name|TaskStatus
argument_list|>
name|taskStatuses
init|=
operator|new
name|TreeMap
argument_list|<
name|TaskAttemptID
argument_list|,
name|TaskStatus
argument_list|>
argument_list|()
decl_stmt|;
comment|/**    * Map from task attempt Id -> splits block    */
DECL|field|splitsBlocks
specifier|private
name|Map
argument_list|<
name|TaskAttemptID
argument_list|,
name|ProgressSplitsBlock
argument_list|>
name|splitsBlocks
init|=
operator|new
name|TreeMap
argument_list|<
name|TaskAttemptID
argument_list|,
name|ProgressSplitsBlock
argument_list|>
argument_list|()
decl_stmt|;
comment|// Map from taskId -> TaskTracker Id,
comment|// contains cleanup attempts and where they ran, if any
DECL|field|cleanupTasks
specifier|private
name|TreeMap
argument_list|<
name|TaskAttemptID
argument_list|,
name|String
argument_list|>
name|cleanupTasks
init|=
operator|new
name|TreeMap
argument_list|<
name|TaskAttemptID
argument_list|,
name|String
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|machinesWhereFailed
specifier|private
name|TreeSet
argument_list|<
name|String
argument_list|>
name|machinesWhereFailed
init|=
operator|new
name|TreeSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|tasksReportedClosed
specifier|private
name|TreeSet
argument_list|<
name|TaskAttemptID
argument_list|>
name|tasksReportedClosed
init|=
operator|new
name|TreeSet
argument_list|<
name|TaskAttemptID
argument_list|>
argument_list|()
decl_stmt|;
comment|//list of tasks to kill,<taskid> -><shouldFail>
DECL|field|tasksToKill
specifier|private
name|TreeMap
argument_list|<
name|TaskAttemptID
argument_list|,
name|Boolean
argument_list|>
name|tasksToKill
init|=
operator|new
name|TreeMap
argument_list|<
name|TaskAttemptID
argument_list|,
name|Boolean
argument_list|>
argument_list|()
decl_stmt|;
comment|//task to commit,<taskattemptid>
DECL|field|taskToCommit
specifier|private
name|TaskAttemptID
name|taskToCommit
decl_stmt|;
DECL|field|counters
specifier|private
specifier|volatile
name|Counters
name|counters
init|=
operator|new
name|Counters
argument_list|()
decl_stmt|;
DECL|field|dispatchTimeMap
specifier|private
name|HashMap
argument_list|<
name|TaskAttemptID
argument_list|,
name|Long
argument_list|>
name|dispatchTimeMap
init|=
operator|new
name|HashMap
argument_list|<
name|TaskAttemptID
argument_list|,
name|Long
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|user
specifier|private
name|String
name|user
decl_stmt|;
comment|/**    * Constructor for MapTask    */
DECL|method|TaskInProgress (JobID jobid, String jobFile, TaskSplitMetaInfo split, JobTracker jobtracker, JobConf conf, JobInProgress job, int partition, int numSlotsRequired)
specifier|public
name|TaskInProgress
parameter_list|(
name|JobID
name|jobid
parameter_list|,
name|String
name|jobFile
parameter_list|,
name|TaskSplitMetaInfo
name|split
parameter_list|,
name|JobTracker
name|jobtracker
parameter_list|,
name|JobConf
name|conf
parameter_list|,
name|JobInProgress
name|job
parameter_list|,
name|int
name|partition
parameter_list|,
name|int
name|numSlotsRequired
parameter_list|)
block|{
name|this
operator|.
name|jobFile
operator|=
name|jobFile
expr_stmt|;
name|this
operator|.
name|splitInfo
operator|=
name|split
expr_stmt|;
name|this
operator|.
name|jobtracker
operator|=
name|jobtracker
expr_stmt|;
name|this
operator|.
name|job
operator|=
name|job
expr_stmt|;
name|this
operator|.
name|conf
operator|=
name|conf
expr_stmt|;
name|this
operator|.
name|partition
operator|=
name|partition
expr_stmt|;
name|this
operator|.
name|maxSkipRecords
operator|=
name|SkipBadRecords
operator|.
name|getMapperMaxSkipRecords
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|numSlotsRequired
operator|=
name|numSlotsRequired
expr_stmt|;
name|setMaxTaskAttempts
argument_list|()
expr_stmt|;
name|init
argument_list|(
name|jobid
argument_list|)
expr_stmt|;
if|if
condition|(
name|jobtracker
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|jobHistory
operator|=
name|jobtracker
operator|.
name|getJobHistory
argument_list|()
expr_stmt|;
block|}
name|this
operator|.
name|user
operator|=
name|job
operator|.
name|getUser
argument_list|()
expr_stmt|;
block|}
comment|/**    * Constructor for ReduceTask    */
DECL|method|TaskInProgress (JobID jobid, String jobFile, int numMaps, int partition, JobTracker jobtracker, JobConf conf, JobInProgress job, int numSlotsRequired)
specifier|public
name|TaskInProgress
parameter_list|(
name|JobID
name|jobid
parameter_list|,
name|String
name|jobFile
parameter_list|,
name|int
name|numMaps
parameter_list|,
name|int
name|partition
parameter_list|,
name|JobTracker
name|jobtracker
parameter_list|,
name|JobConf
name|conf
parameter_list|,
name|JobInProgress
name|job
parameter_list|,
name|int
name|numSlotsRequired
parameter_list|)
block|{
name|this
operator|.
name|jobFile
operator|=
name|jobFile
expr_stmt|;
name|this
operator|.
name|numMaps
operator|=
name|numMaps
expr_stmt|;
name|this
operator|.
name|partition
operator|=
name|partition
expr_stmt|;
name|this
operator|.
name|jobtracker
operator|=
name|jobtracker
expr_stmt|;
name|this
operator|.
name|job
operator|=
name|job
expr_stmt|;
name|this
operator|.
name|conf
operator|=
name|conf
expr_stmt|;
name|this
operator|.
name|maxSkipRecords
operator|=
name|SkipBadRecords
operator|.
name|getReducerMaxSkipGroups
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|numSlotsRequired
operator|=
name|numSlotsRequired
expr_stmt|;
name|setMaxTaskAttempts
argument_list|()
expr_stmt|;
name|init
argument_list|(
name|jobid
argument_list|)
expr_stmt|;
if|if
condition|(
name|jobtracker
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|jobHistory
operator|=
name|jobtracker
operator|.
name|getJobHistory
argument_list|()
expr_stmt|;
block|}
name|this
operator|.
name|user
operator|=
name|job
operator|.
name|getUser
argument_list|()
expr_stmt|;
block|}
DECL|method|getSplits (TaskAttemptID statusAttemptID)
specifier|synchronized
name|ProgressSplitsBlock
name|getSplits
parameter_list|(
name|TaskAttemptID
name|statusAttemptID
parameter_list|)
block|{
name|ProgressSplitsBlock
name|result
init|=
name|splitsBlocks
operator|.
name|get
argument_list|(
name|statusAttemptID
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|==
literal|null
condition|)
block|{
name|result
operator|=
operator|new
name|ProgressSplitsBlock
argument_list|(
name|conf
operator|.
name|getInt
argument_list|(
name|JTConfig
operator|.
name|JT_JOBHISTORY_TASKPROGRESS_NUMBER_SPLITS
argument_list|,
name|ProgressSplitsBlock
operator|.
name|DEFAULT_NUMBER_PROGRESS_SPLITS
argument_list|)
argument_list|)
expr_stmt|;
name|splitsBlocks
operator|.
name|put
argument_list|(
name|statusAttemptID
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
DECL|method|updateProgressSplits (TaskStatus taskStatus)
specifier|private
name|void
name|updateProgressSplits
parameter_list|(
name|TaskStatus
name|taskStatus
parameter_list|)
block|{
name|double
name|newProgress
init|=
name|taskStatus
operator|.
name|getProgress
argument_list|()
decl_stmt|;
name|Counters
name|counters
init|=
name|taskStatus
operator|.
name|getCounters
argument_list|()
decl_stmt|;
if|if
condition|(
name|counters
operator|==
literal|null
condition|)
return|return;
name|TaskAttemptID
name|statusAttemptID
init|=
name|taskStatus
operator|.
name|getTaskID
argument_list|()
decl_stmt|;
name|ProgressSplitsBlock
name|splitsBlock
init|=
name|getSplits
argument_list|(
name|statusAttemptID
argument_list|)
decl_stmt|;
if|if
condition|(
name|splitsBlock
operator|!=
literal|null
condition|)
block|{
name|long
name|now
init|=
name|JobTracker
operator|.
name|getClock
argument_list|()
operator|.
name|getTime
argument_list|()
decl_stmt|;
name|Long
name|start
init|=
name|getDispatchTime
argument_list|(
name|statusAttemptID
argument_list|)
decl_stmt|;
if|if
condition|(
name|start
operator|!=
literal|null
operator|&&
name|now
operator|-
name|start
operator|<=
name|Integer
operator|.
name|MAX_VALUE
condition|)
block|{
name|splitsBlock
operator|.
name|progressWallclockTime
operator|.
name|extend
argument_list|(
name|newProgress
argument_list|,
call|(
name|int
call|)
argument_list|(
name|now
operator|-
name|start
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Counters
operator|.
name|Counter
name|cpuCounter
init|=
name|counters
operator|.
name|findCounter
argument_list|(
name|CPU_COUNTER_KEY
argument_list|)
decl_stmt|;
if|if
condition|(
name|cpuCounter
operator|!=
literal|null
operator|&&
name|cpuCounter
operator|.
name|getCounter
argument_list|()
operator|<=
name|Integer
operator|.
name|MAX_VALUE
condition|)
block|{
name|splitsBlock
operator|.
name|progressCPUTime
operator|.
name|extend
argument_list|(
name|newProgress
argument_list|,
call|(
name|int
call|)
argument_list|(
name|cpuCounter
operator|.
name|getCounter
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Counters
operator|.
name|Counter
name|virtualBytes
init|=
name|counters
operator|.
name|findCounter
argument_list|(
name|VM_BYTES_KEY
argument_list|)
decl_stmt|;
if|if
condition|(
name|virtualBytes
operator|!=
literal|null
condition|)
block|{
name|splitsBlock
operator|.
name|progressVirtualMemoryKbytes
operator|.
name|extend
argument_list|(
name|newProgress
argument_list|,
call|(
name|int
call|)
argument_list|(
name|virtualBytes
operator|.
name|getCounter
argument_list|()
operator|/
operator|(
name|MEMORY_SPLITS_RESOLUTION
operator|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Counters
operator|.
name|Counter
name|physicalBytes
init|=
name|counters
operator|.
name|findCounter
argument_list|(
name|PHYSICAL_BYTES_KEY
argument_list|)
decl_stmt|;
if|if
condition|(
name|physicalBytes
operator|!=
literal|null
condition|)
block|{
name|splitsBlock
operator|.
name|progressPhysicalMemoryKbytes
operator|.
name|extend
argument_list|(
name|newProgress
argument_list|,
call|(
name|int
call|)
argument_list|(
name|physicalBytes
operator|.
name|getCounter
argument_list|()
operator|/
operator|(
name|MEMORY_SPLITS_RESOLUTION
operator|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Set the max number of attempts before we declare a TIP as "failed"    */
DECL|method|setMaxTaskAttempts ()
specifier|private
name|void
name|setMaxTaskAttempts
parameter_list|()
block|{
if|if
condition|(
name|isMapTask
argument_list|()
condition|)
block|{
name|this
operator|.
name|maxTaskAttempts
operator|=
name|conf
operator|.
name|getMaxMapAttempts
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|maxTaskAttempts
operator|=
name|conf
operator|.
name|getMaxReduceAttempts
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Return the index of the tip within the job, so     * "task_200707121733_1313_0002_m_012345" would return 12345;    * @return int the tip index    */
DECL|method|idWithinJob ()
specifier|public
name|int
name|idWithinJob
parameter_list|()
block|{
return|return
name|partition
return|;
block|}
DECL|method|isJobCleanupTask ()
specifier|public
name|boolean
name|isJobCleanupTask
parameter_list|()
block|{
return|return
name|jobCleanup
return|;
block|}
DECL|method|setJobCleanupTask ()
specifier|public
name|void
name|setJobCleanupTask
parameter_list|()
block|{
name|jobCleanup
operator|=
literal|true
expr_stmt|;
block|}
DECL|method|isJobSetupTask ()
specifier|public
name|boolean
name|isJobSetupTask
parameter_list|()
block|{
return|return
name|jobSetup
return|;
block|}
DECL|method|setJobSetupTask ()
specifier|public
name|void
name|setJobSetupTask
parameter_list|()
block|{
name|jobSetup
operator|=
literal|true
expr_stmt|;
block|}
DECL|method|isOnlyCommitPending ()
specifier|public
name|boolean
name|isOnlyCommitPending
parameter_list|()
block|{
for|for
control|(
name|TaskStatus
name|t
range|:
name|taskStatuses
operator|.
name|values
argument_list|()
control|)
block|{
if|if
condition|(
name|t
operator|.
name|getRunState
argument_list|()
operator|==
name|TaskStatus
operator|.
name|State
operator|.
name|COMMIT_PENDING
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
DECL|method|isCommitPending (TaskAttemptID taskId)
specifier|public
name|boolean
name|isCommitPending
parameter_list|(
name|TaskAttemptID
name|taskId
parameter_list|)
block|{
name|TaskStatus
name|t
init|=
name|taskStatuses
operator|.
name|get
argument_list|(
name|taskId
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
name|t
operator|.
name|getRunState
argument_list|()
operator|==
name|TaskStatus
operator|.
name|State
operator|.
name|COMMIT_PENDING
return|;
block|}
comment|/**    * Initialization common to Map and Reduce    */
DECL|method|init (JobID jobId)
name|void
name|init
parameter_list|(
name|JobID
name|jobId
parameter_list|)
block|{
name|this
operator|.
name|id
operator|=
operator|new
name|TaskID
argument_list|(
name|jobId
argument_list|,
name|isMapTask
argument_list|()
condition|?
name|TaskType
operator|.
name|MAP
else|:
name|TaskType
operator|.
name|REDUCE
argument_list|,
name|partition
argument_list|)
expr_stmt|;
name|this
operator|.
name|skipping
operator|=
name|startSkipping
argument_list|()
expr_stmt|;
block|}
comment|////////////////////////////////////
comment|// Accessors, info, profiles, etc.
comment|////////////////////////////////////
comment|/**    * Return the dispatch time    */
DECL|method|getDispatchTime (TaskAttemptID taskid)
specifier|public
name|long
name|getDispatchTime
parameter_list|(
name|TaskAttemptID
name|taskid
parameter_list|)
block|{
name|Long
name|l
init|=
name|dispatchTimeMap
operator|.
name|get
argument_list|(
name|taskid
argument_list|)
decl_stmt|;
if|if
condition|(
name|l
operator|!=
literal|null
condition|)
block|{
return|return
name|l
operator|.
name|longValue
argument_list|()
return|;
block|}
return|return
literal|0
return|;
block|}
DECL|method|getLastDispatchTime ()
specifier|public
name|long
name|getLastDispatchTime
parameter_list|()
block|{
return|return
name|this
operator|.
name|lastDispatchTime
return|;
block|}
comment|/**    * Set the dispatch time    */
DECL|method|setDispatchTime (TaskAttemptID taskid, long disTime)
specifier|public
name|void
name|setDispatchTime
parameter_list|(
name|TaskAttemptID
name|taskid
parameter_list|,
name|long
name|disTime
parameter_list|)
block|{
name|dispatchTimeMap
operator|.
name|put
argument_list|(
name|taskid
argument_list|,
name|disTime
argument_list|)
expr_stmt|;
name|this
operator|.
name|lastDispatchTime
operator|=
name|disTime
expr_stmt|;
block|}
comment|/**    * Return the exec start time    */
DECL|method|getExecStartTime ()
specifier|public
name|long
name|getExecStartTime
parameter_list|()
block|{
return|return
name|execStartTime
return|;
block|}
comment|/**    * Set the exec start time    */
DECL|method|setExecStartTime (long startTime)
specifier|public
name|void
name|setExecStartTime
parameter_list|(
name|long
name|startTime
parameter_list|)
block|{
name|execStartTime
operator|=
name|startTime
expr_stmt|;
block|}
comment|/**    * Return the exec finish time    */
DECL|method|getExecFinishTime ()
specifier|public
name|long
name|getExecFinishTime
parameter_list|()
block|{
return|return
name|execFinishTime
return|;
block|}
comment|/**    * Set the exec finish time    */
DECL|method|setExecFinishTime (long finishTime)
specifier|public
name|void
name|setExecFinishTime
parameter_list|(
name|long
name|finishTime
parameter_list|)
block|{
name|execFinishTime
operator|=
name|finishTime
expr_stmt|;
name|TaskUpdatedEvent
name|tue
init|=
operator|new
name|TaskUpdatedEvent
argument_list|(
name|id
argument_list|,
name|execFinishTime
argument_list|)
decl_stmt|;
name|jobHistory
operator|.
name|logEvent
argument_list|(
name|tue
argument_list|,
name|id
operator|.
name|getJobID
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Return the parent job    */
DECL|method|getJob ()
specifier|public
name|JobInProgress
name|getJob
parameter_list|()
block|{
return|return
name|job
return|;
block|}
comment|/**    * Return an ID for this task, not its component taskid-threads    */
DECL|method|getTIPId ()
specifier|public
name|TaskID
name|getTIPId
parameter_list|()
block|{
return|return
name|this
operator|.
name|id
return|;
block|}
comment|/**    * Whether this is a map task    */
DECL|method|isMapTask ()
specifier|public
name|boolean
name|isMapTask
parameter_list|()
block|{
return|return
name|splitInfo
operator|!=
literal|null
return|;
block|}
comment|/**    * Returns the {@link TaskType} of the {@link TaskAttemptID} passed.     * The type of an attempt is determined by the nature of the task and not its     * id.     * For example,    * - Attempt 'attempt_123_01_m_01_0' might be a job-setup task even though it     *   has a _m_ in its id. Hence the task type of this attempt is JOB_SETUP     *   instead of MAP.    * - Similarly reduce attempt 'attempt_123_01_r_01_0' might have failed and is    *   now supposed to do the task-level cleanup. In such a case this attempt     *   will be of type TASK_CLEANUP instead of REDUCE.    */
DECL|method|getAttemptType (TaskAttemptID id)
name|TaskType
name|getAttemptType
parameter_list|(
name|TaskAttemptID
name|id
parameter_list|)
block|{
if|if
condition|(
name|isCleanupAttempt
argument_list|(
name|id
argument_list|)
condition|)
block|{
return|return
name|TaskType
operator|.
name|TASK_CLEANUP
return|;
block|}
elseif|else
if|if
condition|(
name|isJobSetupTask
argument_list|()
condition|)
block|{
return|return
name|TaskType
operator|.
name|JOB_SETUP
return|;
block|}
elseif|else
if|if
condition|(
name|isJobCleanupTask
argument_list|()
condition|)
block|{
return|return
name|TaskType
operator|.
name|JOB_CLEANUP
return|;
block|}
elseif|else
if|if
condition|(
name|isMapTask
argument_list|()
condition|)
block|{
return|return
name|TaskType
operator|.
name|MAP
return|;
block|}
else|else
block|{
return|return
name|TaskType
operator|.
name|REDUCE
return|;
block|}
block|}
comment|/**    * Is the Task associated with taskid is the first attempt of the tip?     * @param taskId    * @return Returns true if the Task is the first attempt of the tip    */
DECL|method|isFirstAttempt (TaskAttemptID taskId)
specifier|public
name|boolean
name|isFirstAttempt
parameter_list|(
name|TaskAttemptID
name|taskId
parameter_list|)
block|{
return|return
name|firstTaskId
operator|==
literal|null
condition|?
literal|false
else|:
name|firstTaskId
operator|.
name|equals
argument_list|(
name|taskId
argument_list|)
return|;
block|}
comment|/**    * Is this tip currently running any tasks?    * @return true if any tasks are running    */
DECL|method|isRunning ()
specifier|public
name|boolean
name|isRunning
parameter_list|()
block|{
return|return
operator|!
name|activeTasks
operator|.
name|isEmpty
argument_list|()
return|;
block|}
comment|/**    * Is this TaskAttemptid running    * @param taskId    * @return true if taskId attempt is running.    */
DECL|method|isAttemptRunning (TaskAttemptID taskId)
name|boolean
name|isAttemptRunning
parameter_list|(
name|TaskAttemptID
name|taskId
parameter_list|)
block|{
return|return
name|activeTasks
operator|.
name|containsKey
argument_list|(
name|taskId
argument_list|)
return|;
block|}
DECL|method|getSuccessfulTaskid ()
name|TaskAttemptID
name|getSuccessfulTaskid
parameter_list|()
block|{
return|return
name|successfulTaskId
return|;
block|}
DECL|method|setSuccessfulTaskid (TaskAttemptID successfulTaskId)
specifier|private
name|void
name|setSuccessfulTaskid
parameter_list|(
name|TaskAttemptID
name|successfulTaskId
parameter_list|)
block|{
name|this
operator|.
name|successfulTaskId
operator|=
name|successfulTaskId
expr_stmt|;
block|}
DECL|method|resetSuccessfulTaskid ()
specifier|private
name|void
name|resetSuccessfulTaskid
parameter_list|()
block|{
name|this
operator|.
name|successfulTaskId
operator|=
literal|null
expr_stmt|;
block|}
DECL|method|getUser ()
name|String
name|getUser
parameter_list|()
block|{
return|return
name|user
return|;
block|}
DECL|method|setUser (String user)
name|void
name|setUser
parameter_list|(
name|String
name|user
parameter_list|)
block|{
name|this
operator|.
name|user
operator|=
name|user
expr_stmt|;
block|}
comment|/**    * Is this tip complete?    *     * @return<code>true</code> if the tip is complete, else<code>false</code>    */
DECL|method|isComplete ()
specifier|public
specifier|synchronized
name|boolean
name|isComplete
parameter_list|()
block|{
return|return
operator|(
name|completes
operator|>
literal|0
operator|)
return|;
block|}
comment|/**    * Is the given taskid the one that took this tip to completion?    *     * @param taskid taskid of attempt to check for completion    * @return<code>true</code> if taskid is complete, else<code>false</code>    */
DECL|method|isComplete (TaskAttemptID taskid)
specifier|public
name|boolean
name|isComplete
parameter_list|(
name|TaskAttemptID
name|taskid
parameter_list|)
block|{
return|return
operator|(
operator|(
name|completes
operator|>
literal|0
operator|)
operator|&&
name|taskid
operator|.
name|equals
argument_list|(
name|getSuccessfulTaskid
argument_list|()
argument_list|)
operator|)
return|;
block|}
comment|/**    * Is the tip a failure?    *     * @return<code>true</code> if tip has failed, else<code>false</code>    */
DECL|method|isFailed ()
specifier|public
name|boolean
name|isFailed
parameter_list|()
block|{
return|return
name|failed
return|;
block|}
comment|/**    * Number of times the TaskInProgress has failed.    */
DECL|method|numTaskFailures ()
specifier|public
name|int
name|numTaskFailures
parameter_list|()
block|{
return|return
name|numTaskFailures
return|;
block|}
comment|/**    * Number of times the TaskInProgress has been killed by the framework.    */
DECL|method|numKilledTasks ()
specifier|public
name|int
name|numKilledTasks
parameter_list|()
block|{
return|return
name|numKilledTasks
return|;
block|}
comment|/**    * Get the overall progress (from 0 to 1.0) for this TIP    */
DECL|method|getProgress ()
specifier|public
name|double
name|getProgress
parameter_list|()
block|{
return|return
name|progress
return|;
block|}
comment|/**    * Get the task's counters    */
DECL|method|getCounters ()
specifier|public
name|Counters
name|getCounters
parameter_list|()
block|{
return|return
name|counters
return|;
block|}
comment|/**    * Returns whether a component task-thread should be     * closed because the containing JobInProgress has completed    * or the task is killed by the user    */
DECL|method|shouldClose (TaskAttemptID taskid)
specifier|public
name|boolean
name|shouldClose
parameter_list|(
name|TaskAttemptID
name|taskid
parameter_list|)
block|{
comment|/**      * If the task hasn't been closed yet, and it belongs to a completed      * TaskInProgress close it.      *       * However, for completed map tasks we do not close the task which      * actually was the one responsible for _completing_ the TaskInProgress.       */
name|boolean
name|close
init|=
literal|false
decl_stmt|;
name|TaskStatus
name|ts
init|=
name|taskStatuses
operator|.
name|get
argument_list|(
name|taskid
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|ts
operator|!=
literal|null
operator|)
operator|&&
operator|(
operator|!
name|tasksReportedClosed
operator|.
name|contains
argument_list|(
name|taskid
argument_list|)
operator|)
operator|&&
operator|(
operator|(
name|this
operator|.
name|failed
operator|)
operator|||
operator|(
operator|(
name|job
operator|.
name|getStatus
argument_list|()
operator|.
name|getRunState
argument_list|()
operator|!=
name|JobStatus
operator|.
name|RUNNING
operator|&&
operator|(
name|job
operator|.
name|getStatus
argument_list|()
operator|.
name|getRunState
argument_list|()
operator|!=
name|JobStatus
operator|.
name|PREP
operator|)
operator|)
operator|)
operator|)
condition|)
block|{
name|tasksReportedClosed
operator|.
name|add
argument_list|(
name|taskid
argument_list|)
expr_stmt|;
name|close
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isComplete
argument_list|()
operator|&&
operator|!
operator|(
name|isMapTask
argument_list|()
operator|&&
operator|!
name|jobSetup
operator|&&
operator|!
name|jobCleanup
operator|&&
name|isComplete
argument_list|(
name|taskid
argument_list|)
operator|)
operator|&&
operator|!
name|tasksReportedClosed
operator|.
name|contains
argument_list|(
name|taskid
argument_list|)
condition|)
block|{
name|tasksReportedClosed
operator|.
name|add
argument_list|(
name|taskid
argument_list|)
expr_stmt|;
name|close
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|isComplete
argument_list|()
operator|&&
operator|!
name|isComplete
argument_list|(
name|taskid
argument_list|)
condition|)
block|{
name|addDiagnosticInfo
argument_list|(
name|taskid
argument_list|,
literal|"Another (possibly speculative) attempt"
operator|+
literal|" already SUCCEEDED"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|isCommitPending
argument_list|(
name|taskid
argument_list|)
operator|&&
operator|!
name|shouldCommit
argument_list|(
name|taskid
argument_list|)
operator|&&
operator|!
name|tasksReportedClosed
operator|.
name|contains
argument_list|(
name|taskid
argument_list|)
condition|)
block|{
name|tasksReportedClosed
operator|.
name|add
argument_list|(
name|taskid
argument_list|)
expr_stmt|;
name|addDiagnosticInfo
argument_list|(
name|taskid
argument_list|,
literal|"Another (possibly speculative) attempt"
operator|+
literal|" went to COMMIT_PENDING state earlier"
argument_list|)
expr_stmt|;
name|close
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|close
operator|=
name|tasksToKill
operator|.
name|keySet
argument_list|()
operator|.
name|contains
argument_list|(
name|taskid
argument_list|)
expr_stmt|;
block|}
return|return
name|close
return|;
block|}
comment|/**    * Commit this task attempt for the tip.     * @param taskid    */
DECL|method|doCommit (TaskAttemptID taskid)
specifier|public
name|void
name|doCommit
parameter_list|(
name|TaskAttemptID
name|taskid
parameter_list|)
block|{
name|taskToCommit
operator|=
name|taskid
expr_stmt|;
block|}
comment|/**    * Returns whether the task attempt should be committed or not     */
DECL|method|shouldCommit (TaskAttemptID taskid)
specifier|public
name|boolean
name|shouldCommit
parameter_list|(
name|TaskAttemptID
name|taskid
parameter_list|)
block|{
return|return
operator|!
name|isComplete
argument_list|()
operator|&&
name|isCommitPending
argument_list|(
name|taskid
argument_list|)
operator|&&
name|taskToCommit
operator|.
name|equals
argument_list|(
name|taskid
argument_list|)
return|;
block|}
comment|/**    * Creates a "status report" for this task.  Includes the    * task ID and overall status, plus reports for all the    * component task-threads that have ever been started.    */
DECL|method|generateSingleReport ()
specifier|synchronized
name|TaskReport
name|generateSingleReport
parameter_list|()
block|{
name|ArrayList
argument_list|<
name|String
argument_list|>
name|diagnostics
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|List
argument_list|<
name|String
argument_list|>
name|l
range|:
name|taskDiagnosticData
operator|.
name|values
argument_list|()
control|)
block|{
name|diagnostics
operator|.
name|addAll
argument_list|(
name|l
argument_list|)
expr_stmt|;
block|}
name|TIPStatus
name|currentStatus
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|isRunning
argument_list|()
operator|&&
operator|!
name|isComplete
argument_list|()
condition|)
block|{
name|currentStatus
operator|=
name|TIPStatus
operator|.
name|RUNNING
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isComplete
argument_list|()
condition|)
block|{
name|currentStatus
operator|=
name|TIPStatus
operator|.
name|COMPLETE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|wasKilled
argument_list|()
condition|)
block|{
name|currentStatus
operator|=
name|TIPStatus
operator|.
name|KILLED
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isFailed
argument_list|()
condition|)
block|{
name|currentStatus
operator|=
name|TIPStatus
operator|.
name|FAILED
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|isComplete
argument_list|()
operator|||
name|isRunning
argument_list|()
operator|||
name|wasKilled
argument_list|()
operator|)
condition|)
block|{
name|currentStatus
operator|=
name|TIPStatus
operator|.
name|PENDING
expr_stmt|;
block|}
name|TaskReport
name|report
init|=
operator|new
name|TaskReport
argument_list|(
name|getTIPId
argument_list|()
argument_list|,
operator|(
name|float
operator|)
name|progress
argument_list|,
name|state
argument_list|,
name|diagnostics
operator|.
name|toArray
argument_list|(
operator|new
name|String
index|[
name|diagnostics
operator|.
name|size
argument_list|()
index|]
argument_list|)
argument_list|,
name|currentStatus
argument_list|,
name|execStartTime
argument_list|,
name|execFinishTime
argument_list|,
name|counters
argument_list|)
decl_stmt|;
if|if
condition|(
name|currentStatus
operator|==
name|TIPStatus
operator|.
name|RUNNING
condition|)
block|{
name|report
operator|.
name|setRunningTaskAttempts
argument_list|(
name|activeTasks
operator|.
name|keySet
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|currentStatus
operator|==
name|TIPStatus
operator|.
name|COMPLETE
condition|)
block|{
name|report
operator|.
name|setSuccessfulAttempt
argument_list|(
name|getSuccessfulTaskid
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|report
return|;
block|}
comment|/**    * Get the diagnostic messages for a given task within this tip.    *     * @param taskId the id of the required task    * @return the list of diagnostics for that task    */
DECL|method|getDiagnosticInfo (TaskAttemptID taskId)
specifier|synchronized
name|List
argument_list|<
name|String
argument_list|>
name|getDiagnosticInfo
parameter_list|(
name|TaskAttemptID
name|taskId
parameter_list|)
block|{
return|return
name|taskDiagnosticData
operator|.
name|get
argument_list|(
name|taskId
argument_list|)
return|;
block|}
comment|////////////////////////////////////////////////
comment|// Update methods, usually invoked by the owning
comment|// job.
comment|////////////////////////////////////////////////
comment|/**    * Save diagnostic information for a given task.    *     * @param taskId id of the task     * @param diagInfo diagnostic information for the task    */
DECL|method|addDiagnosticInfo (TaskAttemptID taskId, String diagInfo)
specifier|public
name|void
name|addDiagnosticInfo
parameter_list|(
name|TaskAttemptID
name|taskId
parameter_list|,
name|String
name|diagInfo
parameter_list|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|diagHistory
init|=
name|taskDiagnosticData
operator|.
name|get
argument_list|(
name|taskId
argument_list|)
decl_stmt|;
if|if
condition|(
name|diagHistory
operator|==
literal|null
condition|)
block|{
name|diagHistory
operator|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
expr_stmt|;
name|taskDiagnosticData
operator|.
name|put
argument_list|(
name|taskId
argument_list|,
name|diagHistory
argument_list|)
expr_stmt|;
block|}
name|diagHistory
operator|.
name|add
argument_list|(
name|diagInfo
argument_list|)
expr_stmt|;
block|}
comment|/**    * A status message from a client has arrived.    * It updates the status of a single component-thread-task,    * which might result in an overall TaskInProgress status update.    * @return has the task changed its state noticeably?    */
DECL|method|updateStatus (TaskStatus status)
specifier|synchronized
name|boolean
name|updateStatus
parameter_list|(
name|TaskStatus
name|status
parameter_list|)
block|{
try|try
block|{
name|TaskAttemptID
name|taskid
init|=
name|status
operator|.
name|getTaskID
argument_list|()
decl_stmt|;
name|String
name|tracker
init|=
name|status
operator|.
name|getTaskTracker
argument_list|()
decl_stmt|;
name|String
name|diagInfo
init|=
name|status
operator|.
name|getDiagnosticInfo
argument_list|()
decl_stmt|;
name|TaskStatus
name|oldStatus
init|=
name|taskStatuses
operator|.
name|get
argument_list|(
name|taskid
argument_list|)
decl_stmt|;
name|boolean
name|changed
init|=
literal|true
decl_stmt|;
if|if
condition|(
name|diagInfo
operator|!=
literal|null
operator|&&
name|diagInfo
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Error from "
operator|+
name|taskid
operator|+
literal|" on "
operator|+
name|tracker
operator|+
literal|": "
operator|+
name|diagInfo
argument_list|)
expr_stmt|;
name|addDiagnosticInfo
argument_list|(
name|taskid
argument_list|,
name|diagInfo
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|skipping
condition|)
block|{
name|failedRanges
operator|.
name|updateState
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|oldStatus
operator|!=
literal|null
condition|)
block|{
name|TaskStatus
operator|.
name|State
name|oldState
init|=
name|oldStatus
operator|.
name|getRunState
argument_list|()
decl_stmt|;
name|TaskStatus
operator|.
name|State
name|newState
init|=
name|status
operator|.
name|getRunState
argument_list|()
decl_stmt|;
comment|// We should never receive a duplicate success/failure/killed
comment|// status update for the same taskid! This is a safety check,
comment|// and is addressed better at the TaskTracker to ensure this.
comment|// @see {@link TaskTracker.transmitHeartbeat()}
if|if
condition|(
operator|(
name|newState
operator|!=
name|TaskStatus
operator|.
name|State
operator|.
name|RUNNING
operator|&&
name|newState
operator|!=
name|TaskStatus
operator|.
name|State
operator|.
name|COMMIT_PENDING
operator|&&
name|newState
operator|!=
name|TaskStatus
operator|.
name|State
operator|.
name|FAILED_UNCLEAN
operator|&&
name|newState
operator|!=
name|TaskStatus
operator|.
name|State
operator|.
name|KILLED_UNCLEAN
operator|&&
name|newState
operator|!=
name|TaskStatus
operator|.
name|State
operator|.
name|UNASSIGNED
operator|)
operator|&&
operator|(
name|oldState
operator|==
name|newState
operator|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Recieved duplicate status update of '"
operator|+
name|newState
operator|+
literal|"' for '"
operator|+
name|taskid
operator|+
literal|"' of TIP '"
operator|+
name|getTIPId
argument_list|()
operator|+
literal|"'"
operator|+
literal|"oldTT="
operator|+
name|oldStatus
operator|.
name|getTaskTracker
argument_list|()
operator|+
literal|" while newTT="
operator|+
name|status
operator|.
name|getTaskTracker
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// The task is not allowed to move from completed back to running.
comment|// We have seen out of order status messagesmoving tasks from complete
comment|// to running. This is a spot fix, but it should be addressed more
comment|// globally.
if|if
condition|(
operator|(
name|newState
operator|==
name|TaskStatus
operator|.
name|State
operator|.
name|RUNNING
operator|||
name|newState
operator|==
name|TaskStatus
operator|.
name|State
operator|.
name|UNASSIGNED
operator|)
operator|&&
operator|(
name|oldState
operator|==
name|TaskStatus
operator|.
name|State
operator|.
name|FAILED
operator|||
name|oldState
operator|==
name|TaskStatus
operator|.
name|State
operator|.
name|KILLED
operator|||
name|oldState
operator|==
name|TaskStatus
operator|.
name|State
operator|.
name|FAILED_UNCLEAN
operator|||
name|oldState
operator|==
name|TaskStatus
operator|.
name|State
operator|.
name|KILLED_UNCLEAN
operator|||
name|oldState
operator|==
name|TaskStatus
operator|.
name|State
operator|.
name|SUCCEEDED
operator|||
name|oldState
operator|==
name|TaskStatus
operator|.
name|State
operator|.
name|COMMIT_PENDING
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|//Do not accept any status once the task is marked FAILED/KILLED
comment|//This is to handle the case of the JobTracker timing out a task
comment|//due to launch delay, but the TT comes back with any state or
comment|//TT got expired
if|if
condition|(
name|oldState
operator|==
name|TaskStatus
operator|.
name|State
operator|.
name|FAILED
operator|||
name|oldState
operator|==
name|TaskStatus
operator|.
name|State
operator|.
name|KILLED
condition|)
block|{
name|tasksToKill
operator|.
name|put
argument_list|(
name|taskid
argument_list|,
literal|true
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|changed
operator|=
name|oldState
operator|!=
name|newState
expr_stmt|;
block|}
comment|// if task is a cleanup attempt, do not replace the complete status,
comment|// update only specific fields.
comment|// For example, startTime should not be updated,
comment|// but finishTime has to be updated.
if|if
condition|(
operator|!
name|isCleanupAttempt
argument_list|(
name|taskid
argument_list|)
condition|)
block|{
name|taskStatuses
operator|.
name|put
argument_list|(
name|taskid
argument_list|,
name|status
argument_list|)
expr_stmt|;
comment|//we don't want to include setup tasks in the task execution stats
if|if
condition|(
operator|!
name|isJobSetupTask
argument_list|()
operator|&&
operator|(
operator|(
name|isMapTask
argument_list|()
operator|&&
name|job
operator|.
name|hasSpeculativeMaps
argument_list|()
operator|)
operator|||
operator|(
operator|!
name|isMapTask
argument_list|()
operator|&&
name|job
operator|.
name|hasSpeculativeReduces
argument_list|()
operator|)
operator|)
condition|)
block|{
name|long
name|now
init|=
name|JobTracker
operator|.
name|getClock
argument_list|()
operator|.
name|getTime
argument_list|()
decl_stmt|;
name|double
name|oldProgRate
init|=
name|getOldProgressRate
argument_list|()
decl_stmt|;
name|double
name|currProgRate
init|=
name|getCurrentProgressRate
argument_list|(
name|now
argument_list|)
decl_stmt|;
name|job
operator|.
name|updateStatistics
argument_list|(
name|oldProgRate
argument_list|,
name|currProgRate
argument_list|,
name|isMapTask
argument_list|()
argument_list|)
expr_stmt|;
comment|//we need to store the current progress rate, so that we can
comment|//update statistics accurately the next time we invoke
comment|//updateStatistics
name|setProgressRate
argument_list|(
name|currProgRate
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|taskStatuses
operator|.
name|get
argument_list|(
name|taskid
argument_list|)
operator|.
name|statusUpdate
argument_list|(
name|status
operator|.
name|getRunState
argument_list|()
argument_list|,
name|status
operator|.
name|getProgress
argument_list|()
argument_list|,
name|status
operator|.
name|getStateString
argument_list|()
argument_list|,
name|status
operator|.
name|getPhase
argument_list|()
argument_list|,
name|status
operator|.
name|getFinishTime
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Recompute progress
name|recomputeProgress
argument_list|()
expr_stmt|;
return|return
name|changed
return|;
block|}
finally|finally
block|{
name|updateProgressSplits
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Indicate that one of the taskids in this TaskInProgress    * has failed.    */
DECL|method|incompleteSubTask (TaskAttemptID taskid, JobStatus jobStatus)
specifier|public
name|void
name|incompleteSubTask
parameter_list|(
name|TaskAttemptID
name|taskid
parameter_list|,
name|JobStatus
name|jobStatus
parameter_list|)
block|{
comment|//
comment|// Note the failure and its location
comment|//
name|TaskStatus
name|status
init|=
name|taskStatuses
operator|.
name|get
argument_list|(
name|taskid
argument_list|)
decl_stmt|;
name|String
name|trackerName
decl_stmt|;
name|String
name|trackerHostName
init|=
literal|null
decl_stmt|;
name|TaskStatus
operator|.
name|State
name|taskState
init|=
name|TaskStatus
operator|.
name|State
operator|.
name|FAILED
decl_stmt|;
if|if
condition|(
name|status
operator|!=
literal|null
condition|)
block|{
name|trackerName
operator|=
name|status
operator|.
name|getTaskTracker
argument_list|()
expr_stmt|;
name|trackerHostName
operator|=
name|JobInProgress
operator|.
name|convertTrackerNameToHostName
argument_list|(
name|trackerName
argument_list|)
expr_stmt|;
comment|// Check if the user manually KILLED/FAILED this task-attempt...
name|Boolean
name|shouldFail
init|=
name|tasksToKill
operator|.
name|remove
argument_list|(
name|taskid
argument_list|)
decl_stmt|;
if|if
condition|(
name|shouldFail
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|status
operator|.
name|getRunState
argument_list|()
operator|==
name|TaskStatus
operator|.
name|State
operator|.
name|FAILED
operator|||
name|status
operator|.
name|getRunState
argument_list|()
operator|==
name|TaskStatus
operator|.
name|State
operator|.
name|KILLED
condition|)
block|{
name|taskState
operator|=
operator|(
name|shouldFail
operator|)
condition|?
name|TaskStatus
operator|.
name|State
operator|.
name|FAILED
else|:
name|TaskStatus
operator|.
name|State
operator|.
name|KILLED
expr_stmt|;
block|}
else|else
block|{
name|taskState
operator|=
operator|(
name|shouldFail
operator|)
condition|?
name|TaskStatus
operator|.
name|State
operator|.
name|FAILED_UNCLEAN
else|:
name|TaskStatus
operator|.
name|State
operator|.
name|KILLED_UNCLEAN
expr_stmt|;
block|}
name|status
operator|.
name|setRunState
argument_list|(
name|taskState
argument_list|)
expr_stmt|;
name|addDiagnosticInfo
argument_list|(
name|taskid
argument_list|,
literal|"Task has been "
operator|+
name|taskState
operator|+
literal|" by the user"
argument_list|)
expr_stmt|;
block|}
name|taskState
operator|=
name|status
operator|.
name|getRunState
argument_list|()
expr_stmt|;
if|if
condition|(
name|taskState
operator|!=
name|TaskStatus
operator|.
name|State
operator|.
name|FAILED
operator|&&
name|taskState
operator|!=
name|TaskStatus
operator|.
name|State
operator|.
name|KILLED
operator|&&
name|taskState
operator|!=
name|TaskStatus
operator|.
name|State
operator|.
name|FAILED_UNCLEAN
operator|&&
name|taskState
operator|!=
name|TaskStatus
operator|.
name|State
operator|.
name|KILLED_UNCLEAN
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Task '"
operator|+
name|taskid
operator|+
literal|"' running on '"
operator|+
name|trackerName
operator|+
literal|"' in state: '"
operator|+
name|taskState
operator|+
literal|"' being failed!"
argument_list|)
expr_stmt|;
name|status
operator|.
name|setRunState
argument_list|(
name|TaskStatus
operator|.
name|State
operator|.
name|FAILED
argument_list|)
expr_stmt|;
name|taskState
operator|=
name|TaskStatus
operator|.
name|State
operator|.
name|FAILED
expr_stmt|;
block|}
comment|// tasktracker went down and failed time was not reported.
if|if
condition|(
literal|0
operator|==
name|status
operator|.
name|getFinishTime
argument_list|()
condition|)
block|{
name|status
operator|.
name|setFinishTime
argument_list|(
name|JobTracker
operator|.
name|getClock
argument_list|()
operator|.
name|getTime
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|this
operator|.
name|activeTasks
operator|.
name|remove
argument_list|(
name|taskid
argument_list|)
expr_stmt|;
comment|// Since we do not fail completed reduces (whose outputs go to hdfs), we
comment|// should note this failure only for completed maps, only if this taskid;
comment|// completed this map. however if the job is done, there is no need to
comment|// manipulate completed maps
if|if
condition|(
name|this
operator|.
name|isMapTask
argument_list|()
operator|&&
operator|!
name|jobSetup
operator|&&
operator|!
name|jobCleanup
operator|&&
name|isComplete
argument_list|(
name|taskid
argument_list|)
operator|&&
name|jobStatus
operator|.
name|getRunState
argument_list|()
operator|!=
name|JobStatus
operator|.
name|SUCCEEDED
condition|)
block|{
name|this
operator|.
name|completes
operator|--
expr_stmt|;
comment|// Reset the successfulTaskId since we don't have a SUCCESSFUL task now
name|resetSuccessfulTaskid
argument_list|()
expr_stmt|;
block|}
comment|// Note that there can be failures of tasks that are hosted on a machine
comment|// that has not yet registered with restarted jobtracker
comment|// recalculate the counts only if its a genuine failure
if|if
condition|(
name|tasks
operator|.
name|contains
argument_list|(
name|taskid
argument_list|)
condition|)
block|{
if|if
condition|(
name|taskState
operator|==
name|TaskStatus
operator|.
name|State
operator|.
name|FAILED
condition|)
block|{
name|numTaskFailures
operator|++
expr_stmt|;
if|if
condition|(
name|isMapTask
argument_list|()
condition|)
block|{
name|jobtracker
operator|.
name|getInstrumentation
argument_list|()
operator|.
name|failedMap
argument_list|(
name|taskid
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|jobtracker
operator|.
name|getInstrumentation
argument_list|()
operator|.
name|failedReduce
argument_list|(
name|taskid
argument_list|)
expr_stmt|;
block|}
name|machinesWhereFailed
operator|.
name|add
argument_list|(
name|trackerHostName
argument_list|)
expr_stmt|;
if|if
condition|(
name|maxSkipRecords
operator|>
literal|0
condition|)
block|{
comment|//skipping feature enabled
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"TaskInProgress adding"
operator|+
name|status
operator|.
name|getNextRecordRange
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|failedRanges
operator|.
name|add
argument_list|(
name|status
operator|.
name|getNextRecordRange
argument_list|()
argument_list|)
expr_stmt|;
name|skipping
operator|=
name|startSkipping
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|taskState
operator|==
name|TaskStatus
operator|.
name|State
operator|.
name|KILLED
condition|)
block|{
name|numKilledTasks
operator|++
expr_stmt|;
if|if
condition|(
name|isMapTask
argument_list|()
condition|)
block|{
name|jobtracker
operator|.
name|getInstrumentation
argument_list|()
operator|.
name|killedMap
argument_list|(
name|taskid
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|jobtracker
operator|.
name|getInstrumentation
argument_list|()
operator|.
name|killedReduce
argument_list|(
name|taskid
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|numTaskFailures
operator|>=
name|maxTaskAttempts
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"TaskInProgress "
operator|+
name|getTIPId
argument_list|()
operator|+
literal|" has failed "
operator|+
name|numTaskFailures
operator|+
literal|" times."
argument_list|)
expr_stmt|;
name|kill
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Get whether to start skipping mode.     */
DECL|method|startSkipping ()
specifier|private
name|boolean
name|startSkipping
parameter_list|()
block|{
if|if
condition|(
name|maxSkipRecords
operator|>
literal|0
operator|&&
name|numTaskFailures
operator|>=
name|SkipBadRecords
operator|.
name|getAttemptsToStartSkipping
argument_list|(
name|conf
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
comment|/**    * Finalize the<b>completed</b> task; note that this might not be the first     * task-attempt of the {@link TaskInProgress} and hence might be declared     * {@link TaskStatus.State.SUCCEEDED} or {@link TaskStatus.State.KILLED}    *     * @param taskId id of the completed task-attempt    * @param finalTaskState final {@link TaskStatus.State} of the task-attempt    */
DECL|method|completedTask (TaskAttemptID taskId, TaskStatus.State finalTaskState)
specifier|private
name|void
name|completedTask
parameter_list|(
name|TaskAttemptID
name|taskId
parameter_list|,
name|TaskStatus
operator|.
name|State
name|finalTaskState
parameter_list|)
block|{
name|TaskStatus
name|status
init|=
name|taskStatuses
operator|.
name|get
argument_list|(
name|taskId
argument_list|)
decl_stmt|;
name|status
operator|.
name|setRunState
argument_list|(
name|finalTaskState
argument_list|)
expr_stmt|;
name|activeTasks
operator|.
name|remove
argument_list|(
name|taskId
argument_list|)
expr_stmt|;
block|}
comment|/**    * Indicate that one of the taskids in this already-completed    * TaskInProgress has successfully completed; hence we mark this    * taskid as {@link TaskStatus.State.KILLED}.     */
DECL|method|alreadyCompletedTask (TaskAttemptID taskid)
name|void
name|alreadyCompletedTask
parameter_list|(
name|TaskAttemptID
name|taskid
parameter_list|)
block|{
comment|// 'KILL' the task
name|completedTask
argument_list|(
name|taskid
argument_list|,
name|TaskStatus
operator|.
name|State
operator|.
name|KILLED
argument_list|)
expr_stmt|;
comment|// Note the reason for the task being 'KILLED'
name|addDiagnosticInfo
argument_list|(
name|taskid
argument_list|,
literal|"Already completed TIP"
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Already complete TIP "
operator|+
name|getTIPId
argument_list|()
operator|+
literal|" has completed task "
operator|+
name|taskid
argument_list|)
expr_stmt|;
block|}
comment|/**    * Indicate that one of the taskids in this TaskInProgress    * has successfully completed!    */
DECL|method|completed (TaskAttemptID taskid)
specifier|public
name|void
name|completed
parameter_list|(
name|TaskAttemptID
name|taskid
parameter_list|)
block|{
comment|//
comment|// Record that this taskid is complete
comment|//
name|completedTask
argument_list|(
name|taskid
argument_list|,
name|TaskStatus
operator|.
name|State
operator|.
name|SUCCEEDED
argument_list|)
expr_stmt|;
comment|// Note the successful taskid
name|setSuccessfulTaskid
argument_list|(
name|taskid
argument_list|)
expr_stmt|;
comment|//
comment|// Now that the TIP is complete, the other speculative
comment|// subtasks will be closed when the owning tasktracker
comment|// reports in and calls shouldClose() on this object.
comment|//
name|this
operator|.
name|completes
operator|++
expr_stmt|;
name|this
operator|.
name|execFinishTime
operator|=
name|JobTracker
operator|.
name|getClock
argument_list|()
operator|.
name|getTime
argument_list|()
expr_stmt|;
name|recomputeProgress
argument_list|()
expr_stmt|;
block|}
comment|/**    * Get the split locations     */
DECL|method|getSplitLocations ()
specifier|public
name|String
index|[]
name|getSplitLocations
parameter_list|()
block|{
if|if
condition|(
name|isMapTask
argument_list|()
operator|&&
operator|!
name|jobSetup
operator|&&
operator|!
name|jobCleanup
condition|)
block|{
return|return
name|splitInfo
operator|.
name|getLocations
argument_list|()
return|;
block|}
return|return
operator|new
name|String
index|[
literal|0
index|]
return|;
block|}
comment|/**    * Get the Status of the tasks managed by this TIP    */
DECL|method|getTaskStatuses ()
specifier|public
name|TaskStatus
index|[]
name|getTaskStatuses
parameter_list|()
block|{
return|return
name|taskStatuses
operator|.
name|values
argument_list|()
operator|.
name|toArray
argument_list|(
operator|new
name|TaskStatus
index|[
name|taskStatuses
operator|.
name|size
argument_list|()
index|]
argument_list|)
return|;
block|}
comment|/**    * Get all the {@link TaskAttemptID}s in this {@link TaskInProgress}    */
DECL|method|getAllTaskAttemptIDs ()
name|TaskAttemptID
index|[]
name|getAllTaskAttemptIDs
parameter_list|()
block|{
return|return
name|tasks
operator|.
name|toArray
argument_list|(
operator|new
name|TaskAttemptID
index|[
name|tasks
operator|.
name|size
argument_list|()
index|]
argument_list|)
return|;
block|}
comment|/**    * Get the status of the specified task    * @param taskid    * @return    */
DECL|method|getTaskStatus (TaskAttemptID taskid)
specifier|public
name|TaskStatus
name|getTaskStatus
parameter_list|(
name|TaskAttemptID
name|taskid
parameter_list|)
block|{
return|return
name|taskStatuses
operator|.
name|get
argument_list|(
name|taskid
argument_list|)
return|;
block|}
comment|/**    * The TIP's been ordered kill()ed.    */
DECL|method|kill ()
specifier|public
name|void
name|kill
parameter_list|()
block|{
if|if
condition|(
name|isComplete
argument_list|()
operator|||
name|failed
condition|)
block|{
return|return;
block|}
name|this
operator|.
name|failed
operator|=
literal|true
expr_stmt|;
name|killed
operator|=
literal|true
expr_stmt|;
name|this
operator|.
name|execFinishTime
operator|=
name|JobTracker
operator|.
name|getClock
argument_list|()
operator|.
name|getTime
argument_list|()
expr_stmt|;
name|recomputeProgress
argument_list|()
expr_stmt|;
block|}
comment|/**    * Was the task killed?    * @return true if the task killed    */
DECL|method|wasKilled ()
specifier|public
name|boolean
name|wasKilled
parameter_list|()
block|{
return|return
name|killed
return|;
block|}
comment|/**    * Kill the given task    */
DECL|method|killTask (TaskAttemptID taskId, boolean shouldFail)
name|boolean
name|killTask
parameter_list|(
name|TaskAttemptID
name|taskId
parameter_list|,
name|boolean
name|shouldFail
parameter_list|)
block|{
name|TaskStatus
name|st
init|=
name|taskStatuses
operator|.
name|get
argument_list|(
name|taskId
argument_list|)
decl_stmt|;
if|if
condition|(
name|st
operator|!=
literal|null
operator|&&
operator|(
name|st
operator|.
name|getRunState
argument_list|()
operator|==
name|TaskStatus
operator|.
name|State
operator|.
name|RUNNING
operator|||
name|st
operator|.
name|getRunState
argument_list|()
operator|==
name|TaskStatus
operator|.
name|State
operator|.
name|COMMIT_PENDING
operator|||
name|st
operator|.
name|inTaskCleanupPhase
argument_list|()
operator|||
name|st
operator|.
name|getRunState
argument_list|()
operator|==
name|TaskStatus
operator|.
name|State
operator|.
name|UNASSIGNED
operator|)
operator|&&
name|tasksToKill
operator|.
name|put
argument_list|(
name|taskId
argument_list|,
name|shouldFail
argument_list|)
operator|==
literal|null
condition|)
block|{
name|String
name|logStr
init|=
literal|"Request received to "
operator|+
operator|(
name|shouldFail
condition|?
literal|"fail"
else|:
literal|"kill"
operator|)
operator|+
literal|" task '"
operator|+
name|taskId
operator|+
literal|"' by user"
decl_stmt|;
name|addDiagnosticInfo
argument_list|(
name|taskId
argument_list|,
name|logStr
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|logStr
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
comment|/**    * This method is called whenever there's a status change    * for one of the TIP's sub-tasks.  It recomputes the overall     * progress for the TIP.  We examine all sub-tasks and find     * the one that's most advanced (and non-failed).    */
DECL|method|recomputeProgress ()
name|void
name|recomputeProgress
parameter_list|()
block|{
if|if
condition|(
name|isComplete
argument_list|()
condition|)
block|{
name|this
operator|.
name|progress
operator|=
literal|1
expr_stmt|;
comment|// update the counters and the state
name|TaskStatus
name|completedStatus
init|=
name|taskStatuses
operator|.
name|get
argument_list|(
name|getSuccessfulTaskid
argument_list|()
argument_list|)
decl_stmt|;
name|this
operator|.
name|counters
operator|=
name|completedStatus
operator|.
name|getCounters
argument_list|()
expr_stmt|;
name|this
operator|.
name|state
operator|=
name|completedStatus
operator|.
name|getStateString
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|failed
condition|)
block|{
name|this
operator|.
name|progress
operator|=
literal|0
expr_stmt|;
comment|// reset the counters and the state
name|this
operator|.
name|state
operator|=
literal|""
expr_stmt|;
name|this
operator|.
name|counters
operator|=
operator|new
name|Counters
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|double
name|bestProgress
init|=
literal|0
decl_stmt|;
name|String
name|bestState
init|=
literal|""
decl_stmt|;
name|Counters
name|bestCounters
init|=
operator|new
name|Counters
argument_list|()
decl_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|TaskAttemptID
argument_list|>
name|it
init|=
name|taskStatuses
operator|.
name|keySet
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|TaskAttemptID
name|taskid
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|TaskStatus
name|status
init|=
name|taskStatuses
operator|.
name|get
argument_list|(
name|taskid
argument_list|)
decl_stmt|;
if|if
condition|(
name|status
operator|.
name|getRunState
argument_list|()
operator|==
name|TaskStatus
operator|.
name|State
operator|.
name|SUCCEEDED
condition|)
block|{
name|bestProgress
operator|=
literal|1
expr_stmt|;
name|bestState
operator|=
name|status
operator|.
name|getStateString
argument_list|()
expr_stmt|;
name|bestCounters
operator|=
name|status
operator|.
name|getCounters
argument_list|()
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|status
operator|.
name|getRunState
argument_list|()
operator|==
name|TaskStatus
operator|.
name|State
operator|.
name|COMMIT_PENDING
condition|)
block|{
comment|//for COMMIT_PENDING, we take the last state that we recorded
comment|//when the task was RUNNING
name|bestProgress
operator|=
name|this
operator|.
name|progress
expr_stmt|;
name|bestState
operator|=
name|this
operator|.
name|state
expr_stmt|;
name|bestCounters
operator|=
name|this
operator|.
name|counters
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|status
operator|.
name|getRunState
argument_list|()
operator|==
name|TaskStatus
operator|.
name|State
operator|.
name|RUNNING
condition|)
block|{
if|if
condition|(
name|status
operator|.
name|getProgress
argument_list|()
operator|>=
name|bestProgress
condition|)
block|{
name|bestProgress
operator|=
name|status
operator|.
name|getProgress
argument_list|()
expr_stmt|;
name|bestState
operator|=
name|status
operator|.
name|getStateString
argument_list|()
expr_stmt|;
if|if
condition|(
name|status
operator|.
name|getIncludeAllCounters
argument_list|()
condition|)
block|{
name|bestCounters
operator|=
name|status
operator|.
name|getCounters
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|bestCounters
operator|=
name|this
operator|.
name|counters
expr_stmt|;
block|}
block|}
block|}
block|}
name|this
operator|.
name|progress
operator|=
name|bestProgress
expr_stmt|;
name|this
operator|.
name|state
operator|=
name|bestState
expr_stmt|;
name|this
operator|.
name|counters
operator|=
name|bestCounters
expr_stmt|;
block|}
block|}
comment|/////////////////////////////////////////////////
comment|// "Action" methods that actually require the TIP
comment|// to do something.
comment|/////////////////////////////////////////////////
comment|/**    * Return whether this TIP still needs to run    */
DECL|method|isRunnable ()
name|boolean
name|isRunnable
parameter_list|()
block|{
return|return
operator|!
name|failed
operator|&&
operator|(
name|completes
operator|==
literal|0
operator|)
return|;
block|}
comment|/**    * Can this task be speculated? This requires that it isn't done or almost    * done and that it isn't already being speculatively executed.    *     * Added for use by queue scheduling algorithms.    * @param currentTime     */
DECL|method|canBeSpeculated (long currentTime)
name|boolean
name|canBeSpeculated
parameter_list|(
name|long
name|currentTime
parameter_list|)
block|{
name|DataStatistics
name|taskStats
init|=
name|job
operator|.
name|getRunningTaskStatistics
argument_list|(
name|isMapTask
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"activeTasks.size(): "
operator|+
name|activeTasks
operator|.
name|size
argument_list|()
operator|+
literal|" "
operator|+
name|activeTasks
operator|.
name|firstKey
argument_list|()
operator|+
literal|" task's progressrate: "
operator|+
name|getCurrentProgressRate
argument_list|(
name|currentTime
argument_list|)
operator|+
literal|" taskStats : "
operator|+
name|taskStats
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|!
name|skipping
operator|&&
name|isRunnable
argument_list|()
operator|&&
name|isRunning
argument_list|()
operator|&&
name|activeTasks
operator|.
name|size
argument_list|()
operator|<=
name|MAX_TASK_EXECS
operator|&&
name|currentTime
operator|-
name|lastDispatchTime
operator|>=
name|SPECULATIVE_LAG
operator|&&
name|completes
operator|==
literal|0
operator|&&
operator|!
name|isOnlyCommitPending
argument_list|()
operator|&&
operator|(
name|taskStats
operator|.
name|mean
argument_list|()
operator|-
name|getCurrentProgressRate
argument_list|(
name|currentTime
argument_list|)
operator|>
name|taskStats
operator|.
name|std
argument_list|()
operator|*
name|job
operator|.
name|getSlowTaskThreshold
argument_list|()
operator|)
operator|)
return|;
block|}
comment|/**    * Is the task currently speculating?    */
DECL|method|isSpeculating ()
name|boolean
name|isSpeculating
parameter_list|()
block|{
return|return
operator|(
name|activeTasks
operator|.
name|size
argument_list|()
operator|>
name|MAX_TASK_EXECS
operator|)
return|;
block|}
comment|/**    * Return a Task that can be sent to a TaskTracker for execution.    */
DECL|method|getTaskToRun (String taskTracker)
specifier|public
name|Task
name|getTaskToRun
parameter_list|(
name|String
name|taskTracker
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Create the 'taskid'; do not count the 'killed' tasks against the job!
name|TaskAttemptID
name|taskid
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|nextTaskId
operator|<
operator|(
name|MAX_TASK_EXECS
operator|+
name|maxTaskAttempts
operator|+
name|numKilledTasks
operator|)
condition|)
block|{
comment|// Make sure that the attempts are unqiue across restarts
name|int
name|attemptId
init|=
name|job
operator|.
name|getNumRestarts
argument_list|()
operator|*
name|NUM_ATTEMPTS_PER_RESTART
operator|+
name|nextTaskId
decl_stmt|;
name|taskid
operator|=
operator|new
name|TaskAttemptID
argument_list|(
name|id
argument_list|,
name|attemptId
argument_list|)
expr_stmt|;
operator|++
name|nextTaskId
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Exceeded limit of "
operator|+
operator|(
name|MAX_TASK_EXECS
operator|+
name|maxTaskAttempts
operator|)
operator|+
literal|" (plus "
operator|+
name|numKilledTasks
operator|+
literal|" killed)"
operator|+
literal|" attempts for the tip '"
operator|+
name|getTIPId
argument_list|()
operator|+
literal|"'"
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
comment|//keep track of the last time we started an attempt at this TIP
comment|//used to calculate the progress rate of this TIP
name|setDispatchTime
argument_list|(
name|taskid
argument_list|,
name|JobTracker
operator|.
name|getClock
argument_list|()
operator|.
name|getTime
argument_list|()
argument_list|)
expr_stmt|;
comment|//set this the first time we run a taskAttempt in this TIP
comment|//each Task attempt has its own TaskStatus, which tracks that
comment|//attempts execStartTime, thus this startTime is TIP wide.
if|if
condition|(
literal|0
operator|==
name|execStartTime
condition|)
block|{
name|setExecStartTime
argument_list|(
name|lastDispatchTime
argument_list|)
expr_stmt|;
block|}
return|return
name|addRunningTask
argument_list|(
name|taskid
argument_list|,
name|taskTracker
argument_list|)
return|;
block|}
DECL|method|addRunningTask (TaskAttemptID taskid, String taskTracker)
specifier|public
name|Task
name|addRunningTask
parameter_list|(
name|TaskAttemptID
name|taskid
parameter_list|,
name|String
name|taskTracker
parameter_list|)
block|{
return|return
name|addRunningTask
argument_list|(
name|taskid
argument_list|,
name|taskTracker
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**    * Adds a previously running task to this tip. This is used in case of     * jobtracker restarts.    */
DECL|method|addRunningTask (TaskAttemptID taskid, String taskTracker, boolean taskCleanup)
specifier|public
name|Task
name|addRunningTask
parameter_list|(
name|TaskAttemptID
name|taskid
parameter_list|,
name|String
name|taskTracker
parameter_list|,
name|boolean
name|taskCleanup
parameter_list|)
block|{
comment|// 1 slot is enough for taskCleanup task
name|int
name|numSlotsNeeded
init|=
name|taskCleanup
condition|?
literal|1
else|:
name|numSlotsRequired
decl_stmt|;
comment|// create the task
name|Task
name|t
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|isMapTask
argument_list|()
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"attempt "
operator|+
name|numTaskFailures
operator|+
literal|" sending skippedRecords "
operator|+
name|failedRanges
operator|.
name|getIndicesCount
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|t
operator|=
operator|new
name|MapTask
argument_list|(
name|jobFile
argument_list|,
name|taskid
argument_list|,
name|partition
argument_list|,
name|splitInfo
operator|.
name|getSplitIndex
argument_list|()
argument_list|,
name|numSlotsNeeded
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|t
operator|=
operator|new
name|ReduceTask
argument_list|(
name|jobFile
argument_list|,
name|taskid
argument_list|,
name|partition
argument_list|,
name|numMaps
argument_list|,
name|numSlotsNeeded
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|jobCleanup
condition|)
block|{
name|t
operator|.
name|setJobCleanupTask
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|jobSetup
condition|)
block|{
name|t
operator|.
name|setJobSetupTask
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|taskCleanup
condition|)
block|{
name|t
operator|.
name|setTaskCleanupTask
argument_list|()
expr_stmt|;
name|t
operator|.
name|setState
argument_list|(
name|taskStatuses
operator|.
name|get
argument_list|(
name|taskid
argument_list|)
operator|.
name|getRunState
argument_list|()
argument_list|)
expr_stmt|;
name|cleanupTasks
operator|.
name|put
argument_list|(
name|taskid
argument_list|,
name|taskTracker
argument_list|)
expr_stmt|;
block|}
name|t
operator|.
name|setConf
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|t
operator|.
name|setUser
argument_list|(
name|getUser
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Launching task with skipRanges:"
operator|+
name|failedRanges
operator|.
name|getSkipRanges
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|t
operator|.
name|setSkipRanges
argument_list|(
name|failedRanges
operator|.
name|getSkipRanges
argument_list|()
argument_list|)
expr_stmt|;
name|t
operator|.
name|setSkipping
argument_list|(
name|skipping
argument_list|)
expr_stmt|;
if|if
condition|(
name|failedRanges
operator|.
name|isTestAttempt
argument_list|()
condition|)
block|{
name|t
operator|.
name|setWriteSkipRecs
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
name|activeTasks
operator|.
name|put
argument_list|(
name|taskid
argument_list|,
name|taskTracker
argument_list|)
expr_stmt|;
name|tasks
operator|.
name|add
argument_list|(
name|taskid
argument_list|)
expr_stmt|;
comment|// Ask JobTracker to note that the task exists
name|jobtracker
operator|.
name|createTaskEntry
argument_list|(
name|taskid
argument_list|,
name|taskTracker
argument_list|,
name|this
argument_list|)
expr_stmt|;
comment|// check and set the first attempt
if|if
condition|(
name|firstTaskId
operator|==
literal|null
condition|)
block|{
name|firstTaskId
operator|=
name|taskid
expr_stmt|;
block|}
return|return
name|t
return|;
block|}
DECL|method|isRunningTask (TaskAttemptID taskid)
name|boolean
name|isRunningTask
parameter_list|(
name|TaskAttemptID
name|taskid
parameter_list|)
block|{
name|TaskStatus
name|status
init|=
name|taskStatuses
operator|.
name|get
argument_list|(
name|taskid
argument_list|)
decl_stmt|;
return|return
name|status
operator|!=
literal|null
operator|&&
name|status
operator|.
name|getRunState
argument_list|()
operator|==
name|TaskStatus
operator|.
name|State
operator|.
name|RUNNING
return|;
block|}
DECL|method|isCleanupAttempt (TaskAttemptID taskid)
name|boolean
name|isCleanupAttempt
parameter_list|(
name|TaskAttemptID
name|taskid
parameter_list|)
block|{
return|return
name|cleanupTasks
operator|.
name|containsKey
argument_list|(
name|taskid
argument_list|)
return|;
block|}
DECL|method|machineWhereCleanupRan (TaskAttemptID taskid)
name|String
name|machineWhereCleanupRan
parameter_list|(
name|TaskAttemptID
name|taskid
parameter_list|)
block|{
return|return
name|cleanupTasks
operator|.
name|get
argument_list|(
name|taskid
argument_list|)
return|;
block|}
DECL|method|machineWhereTaskRan (TaskAttemptID taskid)
name|String
name|machineWhereTaskRan
parameter_list|(
name|TaskAttemptID
name|taskid
parameter_list|)
block|{
return|return
name|taskStatuses
operator|.
name|get
argument_list|(
name|taskid
argument_list|)
operator|.
name|getTaskTracker
argument_list|()
return|;
block|}
DECL|method|wasKilled (TaskAttemptID taskid)
name|boolean
name|wasKilled
parameter_list|(
name|TaskAttemptID
name|taskid
parameter_list|)
block|{
return|return
name|tasksToKill
operator|.
name|containsKey
argument_list|(
name|taskid
argument_list|)
return|;
block|}
comment|/**    * Has this task already failed on this machine?    * @param trackerHost The task tracker hostname    * @return Has it failed?    */
DECL|method|hasFailedOnMachine (String trackerHost)
specifier|public
name|boolean
name|hasFailedOnMachine
parameter_list|(
name|String
name|trackerHost
parameter_list|)
block|{
return|return
name|machinesWhereFailed
operator|.
name|contains
argument_list|(
name|trackerHost
argument_list|)
return|;
block|}
comment|/**    * Was this task ever scheduled to run on this machine?    * @param trackerHost The task tracker hostname     * @param trackerName The tracker name    * @return Was task scheduled on the tracker?    */
DECL|method|hasRunOnMachine (String trackerHost, String trackerName)
specifier|public
name|boolean
name|hasRunOnMachine
parameter_list|(
name|String
name|trackerHost
parameter_list|,
name|String
name|trackerName
parameter_list|)
block|{
return|return
name|this
operator|.
name|activeTasks
operator|.
name|values
argument_list|()
operator|.
name|contains
argument_list|(
name|trackerName
argument_list|)
operator|||
name|hasFailedOnMachine
argument_list|(
name|trackerHost
argument_list|)
return|;
block|}
comment|/**    * Get the number of machines where this task has failed.    * @return the size of the failed machine set    */
DECL|method|getNumberOfFailedMachines ()
specifier|public
name|int
name|getNumberOfFailedMachines
parameter_list|()
block|{
return|return
name|machinesWhereFailed
operator|.
name|size
argument_list|()
return|;
block|}
comment|/**    * Get the id of this map or reduce task.    * @return The index of this tip in the maps/reduces lists.    */
DECL|method|getIdWithinJob ()
specifier|public
name|int
name|getIdWithinJob
parameter_list|()
block|{
return|return
name|partition
return|;
block|}
comment|/**    * Set the event number that was raised for this tip    */
DECL|method|setSuccessEventNumber (int eventNumber)
specifier|public
name|void
name|setSuccessEventNumber
parameter_list|(
name|int
name|eventNumber
parameter_list|)
block|{
name|successEventNumber
operator|=
name|eventNumber
expr_stmt|;
block|}
comment|/**    * Get the event number that was raised for this tip    */
DECL|method|getSuccessEventNumber ()
specifier|public
name|int
name|getSuccessEventNumber
parameter_list|()
block|{
return|return
name|successEventNumber
return|;
block|}
comment|/**     * Gets the Node list of input split locations sorted in rack order.    */
DECL|method|getSplitNodes ()
specifier|public
name|String
name|getSplitNodes
parameter_list|()
block|{
if|if
condition|(
operator|!
name|isMapTask
argument_list|()
operator|||
name|jobSetup
operator|||
name|jobCleanup
condition|)
block|{
return|return
literal|""
return|;
block|}
name|String
index|[]
name|splits
init|=
name|splitInfo
operator|.
name|getLocations
argument_list|()
decl_stmt|;
name|Node
index|[]
name|nodes
init|=
operator|new
name|Node
index|[
name|splits
operator|.
name|length
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|splits
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|nodes
index|[
name|i
index|]
operator|=
name|jobtracker
operator|.
name|getNode
argument_list|(
name|splits
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|// sort nodes on rack location
name|Arrays
operator|.
name|sort
argument_list|(
name|nodes
argument_list|,
operator|new
name|Comparator
argument_list|<
name|Node
argument_list|>
argument_list|()
block|{
specifier|public
name|int
name|compare
parameter_list|(
name|Node
name|a
parameter_list|,
name|Node
name|b
parameter_list|)
block|{
name|String
name|left
init|=
name|a
operator|.
name|getNetworkLocation
argument_list|()
decl_stmt|;
name|String
name|right
init|=
name|b
operator|.
name|getNetworkLocation
argument_list|()
decl_stmt|;
return|return
name|left
operator|.
name|compareTo
argument_list|(
name|right
argument_list|)
return|;
block|}
block|}
argument_list|)
expr_stmt|;
return|return
name|nodeToString
argument_list|(
name|nodes
argument_list|)
return|;
block|}
DECL|method|nodeToString (Node[] nodes)
specifier|private
specifier|static
name|String
name|nodeToString
parameter_list|(
name|Node
index|[]
name|nodes
parameter_list|)
block|{
if|if
condition|(
name|nodes
operator|==
literal|null
operator|||
name|nodes
operator|.
name|length
operator|==
literal|0
condition|)
block|{
return|return
literal|""
return|;
block|}
name|StringBuffer
name|ret
init|=
operator|new
name|StringBuffer
argument_list|(
name|nodes
index|[
literal|0
index|]
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|nodes
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|ret
operator|.
name|append
argument_list|(
literal|","
argument_list|)
expr_stmt|;
name|ret
operator|.
name|append
argument_list|(
name|nodes
index|[
name|i
index|]
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
operator|.
name|toString
argument_list|()
return|;
block|}
DECL|method|getMapInputSize ()
specifier|public
name|long
name|getMapInputSize
parameter_list|()
block|{
if|if
condition|(
name|isMapTask
argument_list|()
operator|&&
operator|!
name|jobSetup
operator|&&
operator|!
name|jobCleanup
condition|)
block|{
return|return
name|splitInfo
operator|.
name|getInputDataLength
argument_list|()
return|;
block|}
else|else
block|{
return|return
literal|0
return|;
block|}
block|}
comment|/**    * Compare most recent task attempts dispatch time to current system time so    * that task progress rate will slow down as time proceeds even if no progress    * is reported for the task. This allows speculative tasks to be launched for    * tasks on slow/dead TT's before we realize the TT is dead/slow. Skew isn't    * an issue since both times are from the JobTrackers perspective.    * @return the progress rate from the active task that is doing best    */
DECL|method|getCurrentProgressRate (long currentTime)
specifier|public
name|double
name|getCurrentProgressRate
parameter_list|(
name|long
name|currentTime
parameter_list|)
block|{
name|double
name|bestProgressRate
init|=
literal|0
decl_stmt|;
for|for
control|(
name|TaskStatus
name|ts
range|:
name|taskStatuses
operator|.
name|values
argument_list|()
control|)
block|{
if|if
condition|(
name|ts
operator|.
name|getRunState
argument_list|()
operator|==
name|TaskStatus
operator|.
name|State
operator|.
name|RUNNING
operator|||
name|ts
operator|.
name|getRunState
argument_list|()
operator|==
name|TaskStatus
operator|.
name|State
operator|.
name|SUCCEEDED
operator|||
name|ts
operator|.
name|getRunState
argument_list|()
operator|==
name|TaskStatus
operator|.
name|State
operator|.
name|COMMIT_PENDING
condition|)
block|{
name|double
name|progressRate
init|=
name|ts
operator|.
name|getProgress
argument_list|()
operator|/
name|Math
operator|.
name|max
argument_list|(
literal|1
argument_list|,
name|currentTime
operator|-
name|getDispatchTime
argument_list|(
name|ts
operator|.
name|getTaskID
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|progressRate
operator|>
name|bestProgressRate
condition|)
block|{
name|bestProgressRate
operator|=
name|progressRate
expr_stmt|;
block|}
block|}
block|}
return|return
name|bestProgressRate
return|;
block|}
DECL|method|setProgressRate (double rate)
specifier|private
name|void
name|setProgressRate
parameter_list|(
name|double
name|rate
parameter_list|)
block|{
name|oldProgressRate
operator|=
name|rate
expr_stmt|;
block|}
DECL|method|getOldProgressRate ()
specifier|private
name|double
name|getOldProgressRate
parameter_list|()
block|{
return|return
name|oldProgressRate
return|;
block|}
comment|/**    * This class keeps the records to be skipped during further executions     * based on failed records from all the previous attempts.    * It also narrow down the skip records if it is more than the     * acceptable value by dividing the failed range into half. In this case one     * half is executed in the next attempt (test attempt).     * In the test attempt, only the test range gets executed, others get skipped.     * Based on the success/failure of the test attempt, the range is divided     * further.    */
DECL|class|FailedRanges
specifier|private
class|class
name|FailedRanges
block|{
DECL|field|skipRanges
specifier|private
name|SortedRanges
name|skipRanges
init|=
operator|new
name|SortedRanges
argument_list|()
decl_stmt|;
DECL|field|divide
specifier|private
name|Divide
name|divide
decl_stmt|;
DECL|method|getSkipRanges ()
specifier|synchronized
name|SortedRanges
name|getSkipRanges
parameter_list|()
block|{
if|if
condition|(
name|divide
operator|!=
literal|null
condition|)
block|{
return|return
name|divide
operator|.
name|skipRange
return|;
block|}
return|return
name|skipRanges
return|;
block|}
DECL|method|isTestAttempt ()
specifier|synchronized
name|boolean
name|isTestAttempt
parameter_list|()
block|{
return|return
name|divide
operator|!=
literal|null
return|;
block|}
DECL|method|getIndicesCount ()
specifier|synchronized
name|long
name|getIndicesCount
parameter_list|()
block|{
if|if
condition|(
name|isTestAttempt
argument_list|()
condition|)
block|{
return|return
name|divide
operator|.
name|skipRange
operator|.
name|getIndicesCount
argument_list|()
return|;
block|}
return|return
name|skipRanges
operator|.
name|getIndicesCount
argument_list|()
return|;
block|}
DECL|method|updateState (TaskStatus status)
specifier|synchronized
name|void
name|updateState
parameter_list|(
name|TaskStatus
name|status
parameter_list|)
block|{
if|if
condition|(
name|isTestAttempt
argument_list|()
operator|&&
operator|(
name|status
operator|.
name|getRunState
argument_list|()
operator|==
name|TaskStatus
operator|.
name|State
operator|.
name|SUCCEEDED
operator|)
condition|)
block|{
name|divide
operator|.
name|testPassed
operator|=
literal|true
expr_stmt|;
comment|//since it was the test attempt we need to set it to failed
comment|//as it worked only on the test range
name|status
operator|.
name|setRunState
argument_list|(
name|TaskStatus
operator|.
name|State
operator|.
name|FAILED
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|add (Range failedRange)
specifier|synchronized
name|void
name|add
parameter_list|(
name|Range
name|failedRange
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"FailedRange:"
operator|+
name|failedRange
argument_list|)
expr_stmt|;
if|if
condition|(
name|divide
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"FailedRange:"
operator|+
name|failedRange
operator|+
literal|"  test:"
operator|+
name|divide
operator|.
name|test
operator|+
literal|"  pass:"
operator|+
name|divide
operator|.
name|testPassed
argument_list|)
expr_stmt|;
if|if
condition|(
name|divide
operator|.
name|testPassed
condition|)
block|{
comment|//test range passed
comment|//other range would be bad. test it
name|failedRange
operator|=
name|divide
operator|.
name|other
expr_stmt|;
block|}
else|else
block|{
comment|//test range failed
comment|//other range would be good.
name|failedRange
operator|=
name|divide
operator|.
name|test
expr_stmt|;
block|}
comment|//reset
name|divide
operator|=
literal|null
expr_stmt|;
block|}
if|if
condition|(
name|maxSkipRecords
operator|==
literal|0
operator|||
name|failedRange
operator|.
name|getLength
argument_list|()
operator|<=
name|maxSkipRecords
condition|)
block|{
name|skipRanges
operator|.
name|add
argument_list|(
name|failedRange
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|//start dividing the range to narrow down the skipped
comment|//records until maxSkipRecords are met OR all attempts
comment|//get exhausted
name|divide
operator|=
operator|new
name|Divide
argument_list|(
name|failedRange
argument_list|)
expr_stmt|;
block|}
block|}
DECL|class|Divide
class|class
name|Divide
block|{
DECL|field|skipRange
specifier|private
specifier|final
name|SortedRanges
name|skipRange
decl_stmt|;
DECL|field|test
specifier|private
specifier|final
name|Range
name|test
decl_stmt|;
DECL|field|other
specifier|private
specifier|final
name|Range
name|other
decl_stmt|;
DECL|field|testPassed
specifier|private
name|boolean
name|testPassed
decl_stmt|;
DECL|method|Divide (Range range)
name|Divide
parameter_list|(
name|Range
name|range
parameter_list|)
block|{
name|long
name|half
init|=
name|range
operator|.
name|getLength
argument_list|()
operator|/
literal|2
decl_stmt|;
name|test
operator|=
operator|new
name|Range
argument_list|(
name|range
operator|.
name|getStartIndex
argument_list|()
argument_list|,
name|half
argument_list|)
expr_stmt|;
name|other
operator|=
operator|new
name|Range
argument_list|(
name|test
operator|.
name|getEndIndex
argument_list|()
argument_list|,
name|range
operator|.
name|getLength
argument_list|()
operator|-
name|half
argument_list|)
expr_stmt|;
comment|//construct the skip range from the skipRanges
name|skipRange
operator|=
operator|new
name|SortedRanges
argument_list|()
expr_stmt|;
for|for
control|(
name|Range
name|r
range|:
name|skipRanges
operator|.
name|getRanges
argument_list|()
control|)
block|{
name|skipRange
operator|.
name|add
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
name|skipRange
operator|.
name|add
argument_list|(
operator|new
name|Range
argument_list|(
literal|0
argument_list|,
name|test
operator|.
name|getStartIndex
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|skipRange
operator|.
name|add
argument_list|(
operator|new
name|Range
argument_list|(
name|test
operator|.
name|getEndIndex
argument_list|()
argument_list|,
operator|(
name|Long
operator|.
name|MAX_VALUE
operator|-
name|test
operator|.
name|getEndIndex
argument_list|()
operator|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|getActiveTasks ()
name|TreeMap
argument_list|<
name|TaskAttemptID
argument_list|,
name|String
argument_list|>
name|getActiveTasks
parameter_list|()
block|{
return|return
name|activeTasks
return|;
block|}
DECL|method|getNumSlotsRequired ()
name|int
name|getNumSlotsRequired
parameter_list|()
block|{
return|return
name|numSlotsRequired
return|;
block|}
block|}
end_class

end_unit

