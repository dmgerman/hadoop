begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  *  with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *  Unless required by applicable law or agreed to in writing, software  *  distributed under the License is distributed on an "AS IS" BASIS,  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  *  See the License for the specific language governing permissions and  *  limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.ozone.container.common.impl
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ozone
operator|.
name|container
operator|.
name|common
operator|.
name|impl
package|;
end_package

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|primitives
operator|.
name|Longs
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|io
operator|.
name|FileUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdds
operator|.
name|scm
operator|.
name|ScmConfigKeys
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdds
operator|.
name|scm
operator|.
name|container
operator|.
name|common
operator|.
name|helpers
operator|.
name|StorageContainerException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|StorageLocation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdds
operator|.
name|protocol
operator|.
name|proto
operator|.
name|HddsProtos
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdds
operator|.
name|protocol
operator|.
name|proto
operator|.
name|HddsProtos
operator|.
name|LifeCycleState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdds
operator|.
name|protocol
operator|.
name|DatanodeDetails
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdds
operator|.
name|protocol
operator|.
name|datanode
operator|.
name|proto
operator|.
name|ContainerProtos
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdds
operator|.
name|protocol
operator|.
name|datanode
operator|.
name|proto
operator|.
name|ContainerProtos
operator|.
name|ContainerLifeCycleState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdds
operator|.
name|protocol
operator|.
name|proto
operator|.
name|StorageContainerDatanodeProtocolProtos
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdds
operator|.
name|protocol
operator|.
name|proto
operator|.
name|StorageContainerDatanodeProtocolProtos
operator|.
name|ContainerReportsProto
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdds
operator|.
name|protocol
operator|.
name|proto
operator|.
name|StorageContainerDatanodeProtocolProtos
operator|.
name|NodeReportProto
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdds
operator|.
name|protocol
operator|.
name|proto
operator|.
name|StorageContainerDatanodeProtocolProtos
operator|.
name|StorageReportProto
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ozone
operator|.
name|OzoneConfigKeys
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ozone
operator|.
name|OzoneConsts
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ozone
operator|.
name|container
operator|.
name|common
operator|.
name|helpers
operator|.
name|ContainerData
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ozone
operator|.
name|container
operator|.
name|common
operator|.
name|helpers
operator|.
name|ContainerUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ozone
operator|.
name|container
operator|.
name|common
operator|.
name|helpers
operator|.
name|KeyData
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ozone
operator|.
name|container
operator|.
name|common
operator|.
name|helpers
operator|.
name|KeyUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ozone
operator|.
name|container
operator|.
name|common
operator|.
name|interfaces
operator|.
name|ChunkManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ozone
operator|.
name|container
operator|.
name|common
operator|.
name|interfaces
operator|.
name|ContainerDeletionChoosingPolicy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ozone
operator|.
name|container
operator|.
name|common
operator|.
name|interfaces
operator|.
name|ContainerLocationManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ozone
operator|.
name|container
operator|.
name|common
operator|.
name|interfaces
operator|.
name|ContainerManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ozone
operator|.
name|container
operator|.
name|common
operator|.
name|interfaces
operator|.
name|KeyManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|ReflectionUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|utils
operator|.
name|MetadataKeyFilters
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|utils
operator|.
name|MetadataStore
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FilenameFilter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|Paths
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|DigestInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|DigestOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|MessageDigest
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|NoSuchAlgorithmException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentNavigableMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentSkipListMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|ReentrantReadWriteLock
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|stream
operator|.
name|Collectors
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_DATANODE_DATA_DIR_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdds
operator|.
name|protocol
operator|.
name|datanode
operator|.
name|proto
operator|.
name|ContainerProtos
operator|.
name|Result
operator|.
name|CONTAINER_EXISTS
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdds
operator|.
name|protocol
operator|.
name|datanode
operator|.
name|proto
operator|.
name|ContainerProtos
operator|.
name|Result
operator|.
name|CONTAINER_INTERNAL_ERROR
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdds
operator|.
name|protocol
operator|.
name|datanode
operator|.
name|proto
operator|.
name|ContainerProtos
operator|.
name|Result
operator|.
name|CONTAINER_NOT_FOUND
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdds
operator|.
name|protocol
operator|.
name|datanode
operator|.
name|proto
operator|.
name|ContainerProtos
operator|.
name|Result
operator|.
name|ERROR_IN_COMPACT_DB
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdds
operator|.
name|protocol
operator|.
name|datanode
operator|.
name|proto
operator|.
name|ContainerProtos
operator|.
name|Result
operator|.
name|INVALID_CONFIG
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdds
operator|.
name|protocol
operator|.
name|datanode
operator|.
name|proto
operator|.
name|ContainerProtos
operator|.
name|Result
operator|.
name|IO_EXCEPTION
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdds
operator|.
name|protocol
operator|.
name|datanode
operator|.
name|proto
operator|.
name|ContainerProtos
operator|.
name|Result
operator|.
name|NO_SUCH_ALGORITHM
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdds
operator|.
name|protocol
operator|.
name|datanode
operator|.
name|proto
operator|.
name|ContainerProtos
operator|.
name|Result
operator|.
name|UNABLE_TO_READ_METADATA_DB
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdds
operator|.
name|protocol
operator|.
name|datanode
operator|.
name|proto
operator|.
name|ContainerProtos
operator|.
name|Result
operator|.
name|UNCLOSED_CONTAINER_IO
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdds
operator|.
name|protocol
operator|.
name|datanode
operator|.
name|proto
operator|.
name|ContainerProtos
operator|.
name|Result
operator|.
name|UNSUPPORTED_REQUEST
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdds
operator|.
name|protocol
operator|.
name|datanode
operator|.
name|proto
operator|.
name|ContainerProtos
operator|.
name|Result
operator|.
name|INVALID_CONTAINER_STATE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ozone
operator|.
name|OzoneConsts
operator|.
name|CONTAINER_EXTENSION
import|;
end_import

begin_comment
comment|/**  * A Generic ContainerManagerImpl that will be called from Ozone  * ContainerManagerImpl. This allows us to support delta changes to ozone  * version without having to rewrite the containerManager.  */
end_comment

begin_class
DECL|class|ContainerManagerImpl
specifier|public
class|class
name|ContainerManagerImpl
implements|implements
name|ContainerManager
block|{
DECL|field|LOG
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|ContainerManagerImpl
operator|.
name|class
argument_list|)
decl_stmt|;
comment|// TODO: consider primitive collection like eclipse-collections
comment|// to avoid autoboxing overhead
specifier|private
specifier|final
name|ConcurrentSkipListMap
argument_list|<
name|Long
argument_list|,
name|ContainerData
argument_list|>
DECL|field|containerMap
name|containerMap
init|=
operator|new
name|ConcurrentSkipListMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|// Use a non-fair RW lock for better throughput, we may revisit this decision
comment|// if this causes fairness issues.
DECL|field|lock
specifier|private
specifier|final
name|ReentrantReadWriteLock
name|lock
init|=
operator|new
name|ReentrantReadWriteLock
argument_list|()
decl_stmt|;
DECL|field|locationManager
specifier|private
name|ContainerLocationManager
name|locationManager
decl_stmt|;
DECL|field|chunkManager
specifier|private
name|ChunkManager
name|chunkManager
decl_stmt|;
DECL|field|keyManager
specifier|private
name|KeyManager
name|keyManager
decl_stmt|;
DECL|field|conf
specifier|private
name|Configuration
name|conf
decl_stmt|;
DECL|field|containerDeletionChooser
specifier|private
name|ContainerDeletionChoosingPolicy
name|containerDeletionChooser
decl_stmt|;
comment|/**    * Init call that sets up a container Manager.    *    * @param config - Configuration.    * @param containerDirs - List of Metadata Container locations.    * @param dnDetails - DatanodeDetails.    * @throws IOException    */
annotation|@
name|Override
DECL|method|init ( Configuration config, List<StorageLocation> containerDirs, DatanodeDetails dnDetails)
specifier|public
name|void
name|init
parameter_list|(
name|Configuration
name|config
parameter_list|,
name|List
argument_list|<
name|StorageLocation
argument_list|>
name|containerDirs
parameter_list|,
name|DatanodeDetails
name|dnDetails
parameter_list|)
throws|throws
name|IOException
block|{
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|config
argument_list|,
literal|"Config must not be null"
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|containerDirs
argument_list|,
literal|"Container directories cannot "
operator|+
literal|"be null"
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|dnDetails
argument_list|,
literal|"Datanode Details cannot "
operator|+
literal|"be null"
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkState
argument_list|(
name|containerDirs
operator|.
name|size
argument_list|()
operator|>
literal|0
argument_list|,
literal|"Number of container"
operator|+
literal|" directories must be greater than zero."
argument_list|)
expr_stmt|;
name|this
operator|.
name|conf
operator|=
name|config
expr_stmt|;
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
name|containerDeletionChooser
operator|=
name|ReflectionUtils
operator|.
name|newInstance
argument_list|(
name|conf
operator|.
name|getClass
argument_list|(
name|ScmConfigKeys
operator|.
name|OZONE_SCM_CONTAINER_DELETION_CHOOSING_POLICY
argument_list|,
name|TopNOrderedContainerDeletionChoosingPolicy
operator|.
name|class
argument_list|,
name|ContainerDeletionChoosingPolicy
operator|.
name|class
argument_list|)
argument_list|,
name|conf
argument_list|)
expr_stmt|;
for|for
control|(
name|StorageLocation
name|path
range|:
name|containerDirs
control|)
block|{
name|File
name|directory
init|=
name|Paths
operator|.
name|get
argument_list|(
name|path
operator|.
name|getNormalizedUri
argument_list|()
argument_list|)
operator|.
name|toFile
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|directory
operator|.
name|exists
argument_list|()
operator|&&
operator|!
name|directory
operator|.
name|mkdirs
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Container metadata directory doesn't exist "
operator|+
literal|"and cannot be created. Path: {}"
argument_list|,
name|path
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|StorageContainerException
argument_list|(
literal|"Container metadata "
operator|+
literal|"directory doesn't exist and cannot be created "
operator|+
name|path
operator|.
name|toString
argument_list|()
argument_list|,
name|INVALID_CONFIG
argument_list|)
throw|;
block|}
comment|// TODO: This will fail if any directory is invalid.
comment|// We should fix this to handle invalid directories and continue.
comment|// Leaving it this way to fail fast for time being.
if|if
condition|(
operator|!
name|directory
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Invalid path to container metadata directory. path: {}"
argument_list|,
name|path
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|StorageContainerException
argument_list|(
literal|"Invalid path to container "
operator|+
literal|"metadata directory."
operator|+
name|path
argument_list|,
name|INVALID_CONFIG
argument_list|)
throw|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Loading containers under {}"
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|File
index|[]
name|files
init|=
name|directory
operator|.
name|listFiles
argument_list|(
operator|new
name|ContainerFilter
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|files
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|File
name|containerFile
range|:
name|files
control|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Loading container {}"
argument_list|,
name|containerFile
argument_list|)
expr_stmt|;
name|String
name|containerPath
init|=
name|ContainerUtils
operator|.
name|getContainerNameFromFile
argument_list|(
name|containerFile
argument_list|)
decl_stmt|;
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|containerPath
argument_list|,
literal|"Container path cannot"
operator|+
literal|" be null"
argument_list|)
expr_stmt|;
name|readContainerInfo
argument_list|(
name|containerPath
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|List
argument_list|<
name|StorageLocation
argument_list|>
name|dataDirs
init|=
operator|new
name|LinkedList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|dir
range|:
name|config
operator|.
name|getStrings
argument_list|(
name|DFS_DATANODE_DATA_DIR_KEY
argument_list|)
control|)
block|{
name|StorageLocation
name|location
init|=
name|StorageLocation
operator|.
name|parse
argument_list|(
name|dir
argument_list|)
decl_stmt|;
name|dataDirs
operator|.
name|add
argument_list|(
name|location
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|locationManager
operator|=
operator|new
name|ContainerLocationManagerImpl
argument_list|(
name|containerDirs
argument_list|,
name|dataDirs
argument_list|,
name|config
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Reads the Container Info from a file and verifies that checksum match. If    * the checksums match, then that file is added to containerMap.    *    * @param containerName - Name which points to the persisted container.    * @throws StorageContainerException    */
DECL|method|readContainerInfo (String containerName)
specifier|private
name|void
name|readContainerInfo
parameter_list|(
name|String
name|containerName
parameter_list|)
throws|throws
name|StorageContainerException
block|{
name|Preconditions
operator|.
name|checkState
argument_list|(
name|containerName
operator|.
name|length
argument_list|()
operator|>
literal|0
argument_list|,
literal|"Container name length cannot be zero."
argument_list|)
expr_stmt|;
name|FileInputStream
name|containerStream
init|=
literal|null
decl_stmt|;
name|DigestInputStream
name|dis
init|=
literal|null
decl_stmt|;
name|FileInputStream
name|metaStream
init|=
literal|null
decl_stmt|;
name|Path
name|cPath
init|=
name|Paths
operator|.
name|get
argument_list|(
name|containerName
argument_list|)
operator|.
name|getFileName
argument_list|()
decl_stmt|;
name|String
name|keyName
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|cPath
operator|!=
literal|null
condition|)
block|{
name|keyName
operator|=
name|cPath
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|keyName
argument_list|,
literal|"Container Name  to container key mapping is null"
argument_list|)
expr_stmt|;
name|long
name|containerID
init|=
name|Long
operator|.
name|parseLong
argument_list|(
name|keyName
argument_list|)
decl_stmt|;
try|try
block|{
name|String
name|containerFileName
init|=
name|containerName
operator|.
name|concat
argument_list|(
name|CONTAINER_EXTENSION
argument_list|)
decl_stmt|;
name|containerStream
operator|=
operator|new
name|FileInputStream
argument_list|(
name|containerFileName
argument_list|)
expr_stmt|;
name|ContainerProtos
operator|.
name|ContainerData
name|containerDataProto
init|=
name|ContainerProtos
operator|.
name|ContainerData
operator|.
name|parseDelimitedFrom
argument_list|(
name|containerStream
argument_list|)
decl_stmt|;
name|ContainerData
name|containerData
decl_stmt|;
if|if
condition|(
name|containerDataProto
operator|==
literal|null
condition|)
block|{
comment|// Sometimes container metadata might have been created but empty,
comment|// when loading the info we get a null, this often means last time
comment|// SCM was ending up at some middle phase causing that the metadata
comment|// was not populated. Such containers are marked as inactive.
name|ContainerData
name|cData
init|=
operator|new
name|ContainerData
argument_list|(
name|containerID
argument_list|,
name|conf
argument_list|,
name|ContainerLifeCycleState
operator|.
name|INVALID
argument_list|)
decl_stmt|;
name|containerMap
operator|.
name|put
argument_list|(
name|containerID
argument_list|,
name|cData
argument_list|)
expr_stmt|;
return|return;
block|}
name|containerData
operator|=
name|ContainerData
operator|.
name|getFromProtBuf
argument_list|(
name|containerDataProto
argument_list|,
name|conf
argument_list|)
expr_stmt|;
comment|// Initialize pending deletion blocks and deleted blocks count in
comment|// in-memory containerData.
name|MetadataStore
name|metadata
init|=
name|KeyUtils
operator|.
name|getDB
argument_list|(
name|containerData
argument_list|,
name|conf
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|byte
index|[]
argument_list|,
name|byte
index|[]
argument_list|>
argument_list|>
name|underDeletionBlocks
init|=
name|metadata
operator|.
name|getSequentialRangeKVs
argument_list|(
literal|null
argument_list|,
name|Integer
operator|.
name|MAX_VALUE
argument_list|,
name|MetadataKeyFilters
operator|.
name|getDeletingKeyFilter
argument_list|()
argument_list|)
decl_stmt|;
name|byte
index|[]
name|transactionID
init|=
name|metadata
operator|.
name|get
argument_list|(
name|DFSUtil
operator|.
name|string2Bytes
argument_list|(
name|OzoneConsts
operator|.
name|DELETE_TRANSACTION_KEY_PREFIX
operator|+
name|containerID
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|transactionID
operator|!=
literal|null
condition|)
block|{
name|containerData
operator|.
name|updateDeleteTransactionId
argument_list|(
name|Longs
operator|.
name|fromByteArray
argument_list|(
name|transactionID
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|containerData
operator|.
name|incrPendingDeletionBlocks
argument_list|(
name|underDeletionBlocks
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|byte
index|[]
argument_list|,
name|byte
index|[]
argument_list|>
argument_list|>
name|liveKeys
init|=
name|metadata
operator|.
name|getRangeKVs
argument_list|(
literal|null
argument_list|,
name|Integer
operator|.
name|MAX_VALUE
argument_list|,
name|MetadataKeyFilters
operator|.
name|getNormalKeyFilter
argument_list|()
argument_list|)
decl_stmt|;
comment|// Get container bytesUsed upon loading container
comment|// The in-memory state is updated upon key write or delete
comment|// TODO: update containerDataProto and persist it into container MetaFile
name|long
name|bytesUsed
init|=
literal|0
decl_stmt|;
name|bytesUsed
operator|=
name|liveKeys
operator|.
name|parallelStream
argument_list|()
operator|.
name|mapToLong
argument_list|(
name|e
lambda|->
block|{
name|KeyData
name|keyData
decl_stmt|;
try|try
block|{
name|keyData
operator|=
name|KeyUtils
operator|.
name|getKeyData
argument_list|(
name|e
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|keyData
operator|.
name|getSize
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
return|return
literal|0L
return|;
block|}
block|}
argument_list|)
operator|.
name|sum
argument_list|()
expr_stmt|;
name|containerData
operator|.
name|setBytesUsed
argument_list|(
name|bytesUsed
argument_list|)
expr_stmt|;
name|containerMap
operator|.
name|put
argument_list|(
name|containerID
argument_list|,
name|containerData
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"read failed for file: {} ex: {}"
argument_list|,
name|containerName
argument_list|,
name|ex
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
comment|// TODO : Add this file to a recovery Queue.
comment|// Remember that this container is busted and we cannot use it.
name|ContainerData
name|cData
init|=
operator|new
name|ContainerData
argument_list|(
name|containerID
argument_list|,
name|conf
argument_list|,
name|ContainerLifeCycleState
operator|.
name|INVALID
argument_list|)
decl_stmt|;
name|containerMap
operator|.
name|put
argument_list|(
name|containerID
argument_list|,
name|cData
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|StorageContainerException
argument_list|(
literal|"Unable to read container info"
argument_list|,
name|UNABLE_TO_READ_METADATA_DB
argument_list|)
throw|;
block|}
finally|finally
block|{
name|IOUtils
operator|.
name|closeStream
argument_list|(
name|dis
argument_list|)
expr_stmt|;
name|IOUtils
operator|.
name|closeStream
argument_list|(
name|containerStream
argument_list|)
expr_stmt|;
name|IOUtils
operator|.
name|closeStream
argument_list|(
name|metaStream
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Creates a container with the given name.    *    * @param containerData - Container Name and metadata.    * @throws StorageContainerException - Exception    */
annotation|@
name|Override
DECL|method|createContainer (ContainerData containerData)
specifier|public
name|void
name|createContainer
parameter_list|(
name|ContainerData
name|containerData
parameter_list|)
throws|throws
name|StorageContainerException
block|{
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|containerData
argument_list|,
literal|"Container data cannot be null"
argument_list|)
expr_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
name|containerMap
operator|.
name|containsKey
argument_list|(
name|containerData
operator|.
name|getContainerID
argument_list|()
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"container already exists. {}"
argument_list|,
name|containerData
operator|.
name|getContainerID
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|StorageContainerException
argument_list|(
literal|"container already exists."
argument_list|,
name|CONTAINER_EXISTS
argument_list|)
throw|;
block|}
comment|// This is by design. We first write and close the
comment|// container Info and metadata to a directory.
comment|// Then read back and put that info into the containerMap.
comment|// This allows us to make sure that our write is consistent.
name|writeContainerInfo
argument_list|(
name|containerData
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|File
name|cFile
init|=
operator|new
name|File
argument_list|(
name|containerData
operator|.
name|getContainerPath
argument_list|()
argument_list|)
decl_stmt|;
name|readContainerInfo
argument_list|(
name|ContainerUtils
operator|.
name|getContainerNameFromFile
argument_list|(
name|cFile
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NoSuchAlgorithmException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Internal error: We seem to be running a JVM without a "
operator|+
literal|"needed hash algorithm."
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|StorageContainerException
argument_list|(
literal|"failed to create container"
argument_list|,
name|NO_SUCH_ALGORITHM
argument_list|)
throw|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Writes a container to a chosen location and updates the container Map.    *    * The file formats of ContainerData and Container Meta is the following.    *    * message ContainerData {    * required string name = 1;    * repeated KeyValue metadata = 2;    * optional string dbPath = 3;    * optional string containerPath = 4;    * optional int64 bytesUsed = 5;    * optional int64 size = 6;    * }    *    * message ContainerMeta {    * required string fileName = 1;    * required string hash = 2;    * }    *    * @param containerData - container Data    * @param overwrite - Whether we are overwriting.    * @throws StorageContainerException, NoSuchAlgorithmException    */
DECL|method|writeContainerInfo (ContainerData containerData, boolean overwrite)
specifier|private
name|void
name|writeContainerInfo
parameter_list|(
name|ContainerData
name|containerData
parameter_list|,
name|boolean
name|overwrite
parameter_list|)
throws|throws
name|StorageContainerException
throws|,
name|NoSuchAlgorithmException
block|{
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|this
operator|.
name|locationManager
argument_list|,
literal|"Internal error: location manager cannot be null"
argument_list|)
expr_stmt|;
name|FileOutputStream
name|containerStream
init|=
literal|null
decl_stmt|;
name|DigestOutputStream
name|dos
init|=
literal|null
decl_stmt|;
name|FileOutputStream
name|metaStream
init|=
literal|null
decl_stmt|;
try|try
block|{
name|Path
name|metadataPath
init|=
literal|null
decl_stmt|;
name|Path
name|location
init|=
operator|(
operator|!
name|overwrite
operator|)
condition|?
name|locationManager
operator|.
name|getContainerPath
argument_list|()
else|:
name|Paths
operator|.
name|get
argument_list|(
name|containerData
operator|.
name|getContainerPath
argument_list|()
argument_list|)
operator|.
name|getParent
argument_list|()
decl_stmt|;
if|if
condition|(
name|location
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|StorageContainerException
argument_list|(
literal|"Failed to get container file path."
argument_list|,
name|CONTAINER_INTERNAL_ERROR
argument_list|)
throw|;
block|}
name|File
name|containerFile
init|=
name|ContainerUtils
operator|.
name|getContainerFile
argument_list|(
name|containerData
argument_list|,
name|location
argument_list|)
decl_stmt|;
name|String
name|containerName
init|=
name|Long
operator|.
name|toString
argument_list|(
name|containerData
operator|.
name|getContainerID
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|overwrite
condition|)
block|{
name|ContainerUtils
operator|.
name|verifyIsNewContainer
argument_list|(
name|containerFile
argument_list|)
expr_stmt|;
name|metadataPath
operator|=
name|this
operator|.
name|locationManager
operator|.
name|getDataPath
argument_list|(
name|containerName
argument_list|)
expr_stmt|;
name|metadataPath
operator|=
name|ContainerUtils
operator|.
name|createMetadata
argument_list|(
name|metadataPath
argument_list|,
name|containerName
argument_list|,
name|conf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|metadataPath
operator|=
name|ContainerUtils
operator|.
name|getMetadataDirectory
argument_list|(
name|containerData
argument_list|)
expr_stmt|;
block|}
name|containerStream
operator|=
operator|new
name|FileOutputStream
argument_list|(
name|containerFile
argument_list|)
expr_stmt|;
name|MessageDigest
name|sha
init|=
name|MessageDigest
operator|.
name|getInstance
argument_list|(
name|OzoneConsts
operator|.
name|FILE_HASH
argument_list|)
decl_stmt|;
name|dos
operator|=
operator|new
name|DigestOutputStream
argument_list|(
name|containerStream
argument_list|,
name|sha
argument_list|)
expr_stmt|;
name|containerData
operator|.
name|setDBPath
argument_list|(
name|metadataPath
operator|.
name|resolve
argument_list|(
name|ContainerUtils
operator|.
name|getContainerDbFileName
argument_list|(
name|containerName
argument_list|)
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|containerData
operator|.
name|setContainerPath
argument_list|(
name|containerFile
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|containerData
operator|.
name|getContainerDBType
argument_list|()
operator|==
literal|null
condition|)
block|{
name|String
name|impl
init|=
name|conf
operator|.
name|getTrimmed
argument_list|(
name|OzoneConfigKeys
operator|.
name|OZONE_METADATA_STORE_IMPL
argument_list|,
name|OzoneConfigKeys
operator|.
name|OZONE_METADATA_STORE_IMPL_DEFAULT
argument_list|)
decl_stmt|;
name|containerData
operator|.
name|setContainerDBType
argument_list|(
name|impl
argument_list|)
expr_stmt|;
block|}
name|ContainerProtos
operator|.
name|ContainerData
name|protoData
init|=
name|containerData
operator|.
name|getProtoBufMessage
argument_list|()
decl_stmt|;
name|protoData
operator|.
name|writeDelimitedTo
argument_list|(
name|dos
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
comment|// TODO : we need to clean up partially constructed files
comment|// The proper way to do would be for a thread
comment|// to read all these 3 artifacts and make sure they are
comment|// sane. That info needs to come from the replication
comment|// pipeline, and if not consistent delete these file.
comment|// In case of ozone this is *not* a deal breaker since
comment|// SCM is guaranteed to generate unique container names.
comment|// The saving grace is that we check if we have residue files
comment|// lying around when creating a new container. We need to queue
comment|// this information to a cleaner thread.
name|LOG
operator|.
name|error
argument_list|(
literal|"Creation of container failed. Name: {}, we might need to "
operator|+
literal|"cleanup partially created artifacts. "
argument_list|,
name|containerData
operator|.
name|getContainerID
argument_list|()
argument_list|,
name|ex
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|StorageContainerException
argument_list|(
literal|"Container creation failed. "
argument_list|,
name|ex
argument_list|,
name|CONTAINER_INTERNAL_ERROR
argument_list|)
throw|;
block|}
finally|finally
block|{
name|IOUtils
operator|.
name|closeStream
argument_list|(
name|dos
argument_list|)
expr_stmt|;
name|IOUtils
operator|.
name|closeStream
argument_list|(
name|containerStream
argument_list|)
expr_stmt|;
name|IOUtils
operator|.
name|closeStream
argument_list|(
name|metaStream
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Deletes an existing container.    *    * @param containerID - ID of the container.    * @param forceDelete - whether this container should be deleted forcibly.    * @throws StorageContainerException    */
annotation|@
name|Override
DECL|method|deleteContainer (long containerID, boolean forceDelete)
specifier|public
name|void
name|deleteContainer
parameter_list|(
name|long
name|containerID
parameter_list|,
name|boolean
name|forceDelete
parameter_list|)
throws|throws
name|StorageContainerException
block|{
name|Preconditions
operator|.
name|checkState
argument_list|(
name|containerID
operator|>=
literal|0
argument_list|,
literal|"Container ID cannot be negative."
argument_list|)
expr_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
name|isOpen
argument_list|(
name|containerID
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|StorageContainerException
argument_list|(
literal|"Deleting an open container is not allowed."
argument_list|,
name|UNCLOSED_CONTAINER_IO
argument_list|)
throw|;
block|}
name|ContainerData
name|containerData
init|=
name|containerMap
operator|.
name|get
argument_list|(
name|containerID
argument_list|)
decl_stmt|;
if|if
condition|(
name|containerData
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"No such container. ID: {}"
argument_list|,
name|containerID
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|StorageContainerException
argument_list|(
literal|"No such container. ID : "
operator|+
name|containerID
argument_list|,
name|CONTAINER_NOT_FOUND
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|containerData
operator|.
name|isValid
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Invalid container data. ID: {}"
argument_list|,
name|containerID
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|StorageContainerException
argument_list|(
literal|"Invalid container data. Name : "
operator|+
name|containerID
argument_list|,
name|CONTAINER_NOT_FOUND
argument_list|)
throw|;
block|}
name|ContainerUtils
operator|.
name|removeContainer
argument_list|(
name|containerData
argument_list|,
name|conf
argument_list|,
name|forceDelete
argument_list|)
expr_stmt|;
name|containerMap
operator|.
name|remove
argument_list|(
name|containerID
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|StorageContainerException
name|e
parameter_list|)
block|{
throw|throw
name|e
throw|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// TODO : An I/O error during delete can leave partial artifacts on the
comment|// disk. We will need the cleaner thread to cleanup this information.
name|String
name|errMsg
init|=
name|String
operator|.
name|format
argument_list|(
literal|"Failed to cleanup container. ID: %d"
argument_list|,
name|containerID
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|error
argument_list|(
name|errMsg
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|StorageContainerException
argument_list|(
name|errMsg
argument_list|,
name|e
argument_list|,
name|IO_EXCEPTION
argument_list|)
throw|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * A simple interface for container Iterations.    *<p/>    * This call make no guarantees about consistency of the data between    * different list calls. It just returns the best known data at that point of    * time. It is possible that using this iteration you can miss certain    * container from the listing.    *    * @param startContainerID -  Return containers with ID>= startContainerID.    * @param count - how many to return    * @param data - Actual containerData    * @throws StorageContainerException    */
annotation|@
name|Override
DECL|method|listContainer (long startContainerID, long count, List<ContainerData> data)
specifier|public
name|void
name|listContainer
parameter_list|(
name|long
name|startContainerID
parameter_list|,
name|long
name|count
parameter_list|,
name|List
argument_list|<
name|ContainerData
argument_list|>
name|data
parameter_list|)
throws|throws
name|StorageContainerException
block|{
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|data
argument_list|,
literal|"Internal assertion: data cannot be null"
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkState
argument_list|(
name|startContainerID
operator|>=
literal|0
argument_list|,
literal|"Start container ID cannot be negative"
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkState
argument_list|(
name|count
operator|>
literal|0
argument_list|,
literal|"max number of containers returned "
operator|+
literal|"must be positive"
argument_list|)
expr_stmt|;
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
name|ConcurrentNavigableMap
argument_list|<
name|Long
argument_list|,
name|ContainerData
argument_list|>
name|map
decl_stmt|;
if|if
condition|(
name|startContainerID
operator|==
literal|0
condition|)
block|{
name|map
operator|=
name|containerMap
operator|.
name|tailMap
argument_list|(
name|containerMap
operator|.
name|firstKey
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|map
operator|=
name|containerMap
operator|.
name|tailMap
argument_list|(
name|startContainerID
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
name|int
name|currentCount
init|=
literal|0
decl_stmt|;
for|for
control|(
name|ContainerData
name|entry
range|:
name|map
operator|.
name|values
argument_list|()
control|)
block|{
if|if
condition|(
name|currentCount
operator|<
name|count
condition|)
block|{
name|data
operator|.
name|add
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|currentCount
operator|++
expr_stmt|;
block|}
else|else
block|{
return|return;
block|}
block|}
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Get metadata about a specific container.    *    * @param containerID - ID of the container    * @return ContainerData - Container Data.    * @throws StorageContainerException    */
annotation|@
name|Override
DECL|method|readContainer (long containerID)
specifier|public
name|ContainerData
name|readContainer
parameter_list|(
name|long
name|containerID
parameter_list|)
throws|throws
name|StorageContainerException
block|{
name|Preconditions
operator|.
name|checkState
argument_list|(
name|containerID
operator|>=
literal|0
argument_list|,
literal|"Container ID cannot be negative."
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|containerMap
operator|.
name|containsKey
argument_list|(
name|containerID
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|StorageContainerException
argument_list|(
literal|"Unable to find the container. ID: "
operator|+
name|containerID
argument_list|,
name|CONTAINER_NOT_FOUND
argument_list|)
throw|;
block|}
name|ContainerData
name|cData
init|=
name|containerMap
operator|.
name|get
argument_list|(
name|containerID
argument_list|)
decl_stmt|;
if|if
condition|(
name|cData
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|StorageContainerException
argument_list|(
literal|"Invalid container data. ID: "
operator|+
name|containerID
argument_list|,
name|CONTAINER_INTERNAL_ERROR
argument_list|)
throw|;
block|}
return|return
name|cData
return|;
block|}
comment|/**    * Closes a open container, if it is already closed or does not exist a    * StorageContainerException is thrown.    *    * @param containerID - ID of the container.    * @throws StorageContainerException    */
annotation|@
name|Override
DECL|method|closeContainer (long containerID)
specifier|public
name|void
name|closeContainer
parameter_list|(
name|long
name|containerID
parameter_list|)
throws|throws
name|StorageContainerException
throws|,
name|NoSuchAlgorithmException
block|{
name|ContainerData
name|containerData
init|=
name|readContainer
argument_list|(
name|containerID
argument_list|)
decl_stmt|;
name|containerData
operator|.
name|closeContainer
argument_list|()
expr_stmt|;
name|writeContainerInfo
argument_list|(
name|containerData
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|MetadataStore
name|db
init|=
name|KeyUtils
operator|.
name|getDB
argument_list|(
name|containerData
argument_list|,
name|conf
argument_list|)
decl_stmt|;
comment|// It is ok if this operation takes a bit of time.
comment|// Close container is not expected to be instantaneous.
try|try
block|{
name|db
operator|.
name|compactDB
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Error in DB compaction while closing container"
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|StorageContainerException
argument_list|(
name|e
argument_list|,
name|ERROR_IN_COMPACT_DB
argument_list|)
throw|;
block|}
comment|// Active is different from closed. Closed means it is immutable, active
comment|// false means we have some internal error that is happening to this
comment|// container. This is a way to track damaged containers if we have an
comment|// I/O failure, this allows us to take quick action in case of container
comment|// issues.
name|containerMap
operator|.
name|put
argument_list|(
name|containerID
argument_list|,
name|containerData
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|updateContainer (long containerID, ContainerData data, boolean forceUpdate)
specifier|public
name|void
name|updateContainer
parameter_list|(
name|long
name|containerID
parameter_list|,
name|ContainerData
name|data
parameter_list|,
name|boolean
name|forceUpdate
parameter_list|)
throws|throws
name|StorageContainerException
block|{
name|Preconditions
operator|.
name|checkState
argument_list|(
name|containerID
operator|>=
literal|0
argument_list|,
literal|"Container ID cannot be negative."
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|data
argument_list|,
literal|"Container data cannot be null"
argument_list|)
expr_stmt|;
name|FileOutputStream
name|containerStream
init|=
literal|null
decl_stmt|;
name|DigestOutputStream
name|dos
init|=
literal|null
decl_stmt|;
name|MessageDigest
name|sha
init|=
literal|null
decl_stmt|;
name|File
name|containerFileBK
init|=
literal|null
decl_stmt|,
name|containerFile
init|=
literal|null
decl_stmt|;
name|boolean
name|deleted
init|=
literal|false
decl_stmt|;
if|if
condition|(
operator|!
name|containerMap
operator|.
name|containsKey
argument_list|(
name|containerID
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|StorageContainerException
argument_list|(
literal|"Container doesn't exist. Name :"
operator|+
name|containerID
argument_list|,
name|CONTAINER_NOT_FOUND
argument_list|)
throw|;
block|}
try|try
block|{
name|sha
operator|=
name|MessageDigest
operator|.
name|getInstance
argument_list|(
name|OzoneConsts
operator|.
name|FILE_HASH
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NoSuchAlgorithmException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|StorageContainerException
argument_list|(
literal|"Unable to create Message Digest,"
operator|+
literal|" usually this is a java configuration issue."
argument_list|,
name|NO_SUCH_ALGORITHM
argument_list|)
throw|;
block|}
try|try
block|{
name|Path
name|location
init|=
name|locationManager
operator|.
name|getContainerPath
argument_list|()
decl_stmt|;
name|ContainerData
name|orgData
init|=
name|containerMap
operator|.
name|get
argument_list|(
name|containerID
argument_list|)
decl_stmt|;
if|if
condition|(
name|orgData
operator|==
literal|null
condition|)
block|{
comment|// updating a invalid container
throw|throw
operator|new
name|StorageContainerException
argument_list|(
literal|"Update a container with invalid"
operator|+
literal|"container meta data"
argument_list|,
name|CONTAINER_INTERNAL_ERROR
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|forceUpdate
operator|&&
operator|!
name|orgData
operator|.
name|isOpen
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|StorageContainerException
argument_list|(
literal|"Update a closed container is not allowed. ID: "
operator|+
name|containerID
argument_list|,
name|UNSUPPORTED_REQUEST
argument_list|)
throw|;
block|}
name|containerFile
operator|=
name|ContainerUtils
operator|.
name|getContainerFile
argument_list|(
name|orgData
argument_list|,
name|location
argument_list|)
expr_stmt|;
comment|// If forceUpdate is true, there is no need to check
comment|// whether the container file exists.
if|if
condition|(
operator|!
name|forceUpdate
condition|)
block|{
if|if
condition|(
operator|!
name|containerFile
operator|.
name|exists
argument_list|()
operator|||
operator|!
name|containerFile
operator|.
name|canWrite
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|StorageContainerException
argument_list|(
literal|"Container file not exists or corrupted. ID: "
operator|+
name|containerID
argument_list|,
name|CONTAINER_INTERNAL_ERROR
argument_list|)
throw|;
block|}
comment|// Backup the container file
name|containerFileBK
operator|=
name|File
operator|.
name|createTempFile
argument_list|(
literal|"tmp_"
operator|+
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|+
literal|"_"
argument_list|,
name|containerFile
operator|.
name|getName
argument_list|()
argument_list|,
name|containerFile
operator|.
name|getParentFile
argument_list|()
argument_list|)
expr_stmt|;
name|FileUtils
operator|.
name|copyFile
argument_list|(
name|containerFile
argument_list|,
name|containerFileBK
argument_list|)
expr_stmt|;
name|deleted
operator|=
name|containerFile
operator|.
name|delete
argument_list|()
expr_stmt|;
name|containerStream
operator|=
operator|new
name|FileOutputStream
argument_list|(
name|containerFile
argument_list|)
expr_stmt|;
name|dos
operator|=
operator|new
name|DigestOutputStream
argument_list|(
name|containerStream
argument_list|,
name|sha
argument_list|)
expr_stmt|;
name|ContainerProtos
operator|.
name|ContainerData
name|protoData
init|=
name|data
operator|.
name|getProtoBufMessage
argument_list|()
decl_stmt|;
name|protoData
operator|.
name|writeDelimitedTo
argument_list|(
name|dos
argument_list|)
expr_stmt|;
block|}
comment|// Update the in-memory map
name|containerMap
operator|.
name|replace
argument_list|(
name|containerID
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// Restore the container file from backup
if|if
condition|(
name|containerFileBK
operator|!=
literal|null
operator|&&
name|containerFileBK
operator|.
name|exists
argument_list|()
operator|&&
name|deleted
condition|)
block|{
if|if
condition|(
name|containerFile
operator|.
name|delete
argument_list|()
operator|&&
name|containerFileBK
operator|.
name|renameTo
argument_list|(
name|containerFile
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|StorageContainerException
argument_list|(
literal|"Container update failed,"
operator|+
literal|" container data restored from the backup."
argument_list|,
name|CONTAINER_INTERNAL_ERROR
argument_list|)
throw|;
block|}
else|else
block|{
throw|throw
operator|new
name|StorageContainerException
argument_list|(
literal|"Failed to restore container data from the backup. ID: "
operator|+
name|containerID
argument_list|,
name|CONTAINER_INTERNAL_ERROR
argument_list|)
throw|;
block|}
block|}
else|else
block|{
throw|throw
operator|new
name|StorageContainerException
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|CONTAINER_INTERNAL_ERROR
argument_list|)
throw|;
block|}
block|}
finally|finally
block|{
if|if
condition|(
name|containerFileBK
operator|!=
literal|null
operator|&&
name|containerFileBK
operator|.
name|exists
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|containerFileBK
operator|.
name|delete
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Unable to delete container file backup : {}."
argument_list|,
name|containerFileBK
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|IOUtils
operator|.
name|closeStream
argument_list|(
name|dos
argument_list|)
expr_stmt|;
name|IOUtils
operator|.
name|closeStream
argument_list|(
name|containerStream
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|VisibleForTesting
DECL|method|getContainerFile (ContainerData data)
specifier|protected
name|File
name|getContainerFile
parameter_list|(
name|ContainerData
name|data
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|ContainerUtils
operator|.
name|getContainerFile
argument_list|(
name|data
argument_list|,
name|this
operator|.
name|locationManager
operator|.
name|getContainerPath
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Checks if a container exists.    *    * @param containerID - ID of the container.    * @return true if the container is open false otherwise.    * @throws StorageContainerException - Throws Exception if we are not able to    *                                   find the container.    */
annotation|@
name|Override
DECL|method|isOpen (long containerID)
specifier|public
name|boolean
name|isOpen
parameter_list|(
name|long
name|containerID
parameter_list|)
throws|throws
name|StorageContainerException
block|{
specifier|final
name|ContainerData
name|containerData
init|=
name|containerMap
operator|.
name|get
argument_list|(
name|containerID
argument_list|)
decl_stmt|;
if|if
condition|(
name|containerData
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|StorageContainerException
argument_list|(
literal|"Container not found: "
operator|+
name|containerID
argument_list|,
name|CONTAINER_NOT_FOUND
argument_list|)
throw|;
block|}
return|return
name|containerData
operator|.
name|isOpen
argument_list|()
return|;
block|}
comment|/**    * Returns LifeCycle State of the container.    * @param containerID - Id of the container    * @return LifeCycle State of the container    * @throws StorageContainerException    */
DECL|method|getState (long containerID)
specifier|private
name|HddsProtos
operator|.
name|LifeCycleState
name|getState
parameter_list|(
name|long
name|containerID
parameter_list|)
throws|throws
name|StorageContainerException
block|{
name|LifeCycleState
name|state
decl_stmt|;
specifier|final
name|ContainerData
name|data
init|=
name|containerMap
operator|.
name|get
argument_list|(
name|containerID
argument_list|)
decl_stmt|;
if|if
condition|(
name|data
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|StorageContainerException
argument_list|(
literal|"Container status not found: "
operator|+
name|containerID
argument_list|,
name|CONTAINER_NOT_FOUND
argument_list|)
throw|;
block|}
switch|switch
condition|(
name|data
operator|.
name|getState
argument_list|()
condition|)
block|{
case|case
name|OPEN
case|:
name|state
operator|=
name|LifeCycleState
operator|.
name|OPEN
expr_stmt|;
break|break;
case|case
name|CLOSING
case|:
name|state
operator|=
name|LifeCycleState
operator|.
name|CLOSING
expr_stmt|;
break|break;
case|case
name|CLOSED
case|:
name|state
operator|=
name|LifeCycleState
operator|.
name|CLOSED
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|StorageContainerException
argument_list|(
literal|"Invalid Container state found: "
operator|+
name|containerID
argument_list|,
name|INVALID_CONTAINER_STATE
argument_list|)
throw|;
block|}
return|return
name|state
return|;
block|}
comment|/**    * Supports clean shutdown of container.    *    * @throws IOException    */
annotation|@
name|Override
DECL|method|shutdown ()
specifier|public
name|void
name|shutdown
parameter_list|()
throws|throws
name|IOException
block|{
name|Preconditions
operator|.
name|checkState
argument_list|(
name|this
operator|.
name|hasWriteLock
argument_list|()
argument_list|,
literal|"Assumption that we are holding the lock violated."
argument_list|)
expr_stmt|;
name|this
operator|.
name|containerMap
operator|.
name|clear
argument_list|()
expr_stmt|;
name|this
operator|.
name|locationManager
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|getContainerMap ()
specifier|public
name|ConcurrentSkipListMap
argument_list|<
name|Long
argument_list|,
name|ContainerData
argument_list|>
name|getContainerMap
parameter_list|()
block|{
return|return
name|containerMap
return|;
block|}
comment|/**    * Acquire read lock.    */
annotation|@
name|Override
DECL|method|readLock ()
specifier|public
name|void
name|readLock
parameter_list|()
block|{
name|this
operator|.
name|lock
operator|.
name|readLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|readLockInterruptibly ()
specifier|public
name|void
name|readLockInterruptibly
parameter_list|()
throws|throws
name|InterruptedException
block|{
name|this
operator|.
name|lock
operator|.
name|readLock
argument_list|()
operator|.
name|lockInterruptibly
argument_list|()
expr_stmt|;
block|}
comment|/**    * Release read lock.    */
annotation|@
name|Override
DECL|method|readUnlock ()
specifier|public
name|void
name|readUnlock
parameter_list|()
block|{
name|this
operator|.
name|lock
operator|.
name|readLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
comment|/**    * Check if the current thread holds read lock.    */
annotation|@
name|Override
DECL|method|hasReadLock ()
specifier|public
name|boolean
name|hasReadLock
parameter_list|()
block|{
return|return
name|this
operator|.
name|lock
operator|.
name|readLock
argument_list|()
operator|.
name|tryLock
argument_list|()
return|;
block|}
comment|/**    * Acquire write lock.    */
annotation|@
name|Override
DECL|method|writeLock ()
specifier|public
name|void
name|writeLock
parameter_list|()
block|{
name|this
operator|.
name|lock
operator|.
name|writeLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
block|}
comment|/**    * Acquire write lock, unless interrupted while waiting.    */
annotation|@
name|Override
DECL|method|writeLockInterruptibly ()
specifier|public
name|void
name|writeLockInterruptibly
parameter_list|()
throws|throws
name|InterruptedException
block|{
name|this
operator|.
name|lock
operator|.
name|writeLock
argument_list|()
operator|.
name|lockInterruptibly
argument_list|()
expr_stmt|;
block|}
comment|/**    * Release write lock.    */
annotation|@
name|Override
DECL|method|writeUnlock ()
specifier|public
name|void
name|writeUnlock
parameter_list|()
block|{
name|this
operator|.
name|lock
operator|.
name|writeLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
comment|/**    * Check if the current thread holds write lock.    */
annotation|@
name|Override
DECL|method|hasWriteLock ()
specifier|public
name|boolean
name|hasWriteLock
parameter_list|()
block|{
return|return
name|this
operator|.
name|lock
operator|.
name|writeLock
argument_list|()
operator|.
name|isHeldByCurrentThread
argument_list|()
return|;
block|}
DECL|method|getChunkManager ()
specifier|public
name|ChunkManager
name|getChunkManager
parameter_list|()
block|{
return|return
name|this
operator|.
name|chunkManager
return|;
block|}
comment|/**    * Sets the chunk Manager.    *    * @param chunkManager - Chunk Manager    */
DECL|method|setChunkManager (ChunkManager chunkManager)
specifier|public
name|void
name|setChunkManager
parameter_list|(
name|ChunkManager
name|chunkManager
parameter_list|)
block|{
name|this
operator|.
name|chunkManager
operator|=
name|chunkManager
expr_stmt|;
block|}
comment|/**    * Gets the Key Manager.    *    * @return KeyManager.    */
annotation|@
name|Override
DECL|method|getKeyManager ()
specifier|public
name|KeyManager
name|getKeyManager
parameter_list|()
block|{
return|return
name|this
operator|.
name|keyManager
return|;
block|}
comment|/**    * Get the node report.    * @return node report.    */
annotation|@
name|Override
DECL|method|getNodeReport ()
specifier|public
name|NodeReportProto
name|getNodeReport
parameter_list|()
throws|throws
name|IOException
block|{
name|StorageLocationReport
index|[]
name|reports
init|=
name|locationManager
operator|.
name|getLocationReport
argument_list|()
decl_stmt|;
name|NodeReportProto
operator|.
name|Builder
name|nrb
init|=
name|NodeReportProto
operator|.
name|newBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|reports
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|StorageReportProto
operator|.
name|Builder
name|srb
init|=
name|StorageReportProto
operator|.
name|newBuilder
argument_list|()
decl_stmt|;
name|nrb
operator|.
name|addStorageReport
argument_list|(
name|reports
index|[
name|i
index|]
operator|.
name|getProtoBufMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|nrb
operator|.
name|build
argument_list|()
return|;
block|}
comment|/**    * Gets container reports.    *    * @return List of all closed containers.    * @throws IOException    */
annotation|@
name|Override
DECL|method|getClosedContainerReports ()
specifier|public
name|List
argument_list|<
name|ContainerData
argument_list|>
name|getClosedContainerReports
parameter_list|()
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Starting container report iteration."
argument_list|)
expr_stmt|;
comment|// No need for locking since containerMap is a ConcurrentSkipListMap
comment|// And we can never get the exact state since close might happen
comment|// after we iterate a point.
return|return
name|containerMap
operator|.
name|entrySet
argument_list|()
operator|.
name|stream
argument_list|()
operator|.
name|filter
argument_list|(
name|containerData
lambda|->
name|containerData
operator|.
name|getValue
argument_list|()
operator|.
name|isClosed
argument_list|()
argument_list|)
operator|.
name|map
argument_list|(
name|containerData
lambda|->
name|containerData
operator|.
name|getValue
argument_list|()
argument_list|)
operator|.
name|collect
argument_list|(
name|Collectors
operator|.
name|toList
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Get container report.    *    * @return The container report.    * @throws IOException    */
annotation|@
name|Override
DECL|method|getContainerReport ()
specifier|public
name|ContainerReportsProto
name|getContainerReport
parameter_list|()
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Starting container report iteration."
argument_list|)
expr_stmt|;
comment|// No need for locking since containerMap is a ConcurrentSkipListMap
comment|// And we can never get the exact state since close might happen
comment|// after we iterate a point.
name|List
argument_list|<
name|ContainerData
argument_list|>
name|containers
init|=
name|containerMap
operator|.
name|values
argument_list|()
operator|.
name|stream
argument_list|()
operator|.
name|collect
argument_list|(
name|Collectors
operator|.
name|toList
argument_list|()
argument_list|)
decl_stmt|;
name|ContainerReportsProto
operator|.
name|Builder
name|crBuilder
init|=
name|ContainerReportsProto
operator|.
name|newBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|ContainerData
name|container
range|:
name|containers
control|)
block|{
name|long
name|containerId
init|=
name|container
operator|.
name|getContainerID
argument_list|()
decl_stmt|;
name|StorageContainerDatanodeProtocolProtos
operator|.
name|ContainerInfo
operator|.
name|Builder
name|ciBuilder
init|=
name|StorageContainerDatanodeProtocolProtos
operator|.
name|ContainerInfo
operator|.
name|newBuilder
argument_list|()
decl_stmt|;
name|ciBuilder
operator|.
name|setContainerID
argument_list|(
name|container
operator|.
name|getContainerID
argument_list|()
argument_list|)
operator|.
name|setSize
argument_list|(
name|container
operator|.
name|getMaxSize
argument_list|()
argument_list|)
operator|.
name|setUsed
argument_list|(
name|container
operator|.
name|getBytesUsed
argument_list|()
argument_list|)
operator|.
name|setKeyCount
argument_list|(
name|container
operator|.
name|getKeyCount
argument_list|()
argument_list|)
operator|.
name|setReadCount
argument_list|(
name|container
operator|.
name|getReadCount
argument_list|()
argument_list|)
operator|.
name|setWriteCount
argument_list|(
name|container
operator|.
name|getWriteCount
argument_list|()
argument_list|)
operator|.
name|setReadBytes
argument_list|(
name|container
operator|.
name|getReadBytes
argument_list|()
argument_list|)
operator|.
name|setWriteBytes
argument_list|(
name|container
operator|.
name|getWriteBytes
argument_list|()
argument_list|)
operator|.
name|setState
argument_list|(
name|getState
argument_list|(
name|containerId
argument_list|)
argument_list|)
operator|.
name|setDeleteTransactionId
argument_list|(
name|container
operator|.
name|getDeleteTransactionId
argument_list|()
argument_list|)
expr_stmt|;
name|crBuilder
operator|.
name|addReports
argument_list|(
name|ciBuilder
operator|.
name|build
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|crBuilder
operator|.
name|build
argument_list|()
return|;
block|}
comment|/**    * Sets the Key Manager.    *    * @param keyManager - Key Manager.    */
annotation|@
name|Override
DECL|method|setKeyManager (KeyManager keyManager)
specifier|public
name|void
name|setKeyManager
parameter_list|(
name|KeyManager
name|keyManager
parameter_list|)
block|{
name|this
operator|.
name|keyManager
operator|=
name|keyManager
expr_stmt|;
block|}
comment|/**    * Filter out only container files from the container metadata dir.    */
DECL|class|ContainerFilter
specifier|private
specifier|static
class|class
name|ContainerFilter
implements|implements
name|FilenameFilter
block|{
comment|/**      * Tests if a specified file should be included in a file list.      *      * @param dir the directory in which the file was found.      * @param name the name of the file.      * @return<code>true</code> if and only if the name should be included in      * the file list;<code>false</code> otherwise.      */
annotation|@
name|Override
DECL|method|accept (File dir, String name)
specifier|public
name|boolean
name|accept
parameter_list|(
name|File
name|dir
parameter_list|,
name|String
name|name
parameter_list|)
block|{
return|return
name|name
operator|.
name|endsWith
argument_list|(
name|CONTAINER_EXTENSION
argument_list|)
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|chooseContainerForBlockDeletion ( int count)
specifier|public
name|List
argument_list|<
name|ContainerData
argument_list|>
name|chooseContainerForBlockDeletion
parameter_list|(
name|int
name|count
parameter_list|)
throws|throws
name|StorageContainerException
block|{
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
return|return
name|containerDeletionChooser
operator|.
name|chooseContainerForBlockDeletion
argument_list|(
name|count
argument_list|,
name|containerMap
argument_list|)
return|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|VisibleForTesting
DECL|method|getContainerDeletionChooser ()
specifier|public
name|ContainerDeletionChoosingPolicy
name|getContainerDeletionChooser
parameter_list|()
block|{
return|return
name|containerDeletionChooser
return|;
block|}
annotation|@
name|Override
DECL|method|incrPendingDeletionBlocks (int numBlocks, long containerId)
specifier|public
name|void
name|incrPendingDeletionBlocks
parameter_list|(
name|int
name|numBlocks
parameter_list|,
name|long
name|containerId
parameter_list|)
block|{
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|ContainerData
name|cData
init|=
name|containerMap
operator|.
name|get
argument_list|(
name|containerId
argument_list|)
decl_stmt|;
name|cData
operator|.
name|incrPendingDeletionBlocks
argument_list|(
name|numBlocks
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|decrPendingDeletionBlocks (int numBlocks, long containerId)
specifier|public
name|void
name|decrPendingDeletionBlocks
parameter_list|(
name|int
name|numBlocks
parameter_list|,
name|long
name|containerId
parameter_list|)
block|{
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|ContainerData
name|cData
init|=
name|containerMap
operator|.
name|get
argument_list|(
name|containerId
argument_list|)
decl_stmt|;
name|cData
operator|.
name|decrPendingDeletionBlocks
argument_list|(
name|numBlocks
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Increase the read count of the container.    *    * @param containerId - ID of the container.    */
annotation|@
name|Override
DECL|method|incrReadCount (long containerId)
specifier|public
name|void
name|incrReadCount
parameter_list|(
name|long
name|containerId
parameter_list|)
block|{
name|ContainerData
name|cData
init|=
name|containerMap
operator|.
name|get
argument_list|(
name|containerId
argument_list|)
decl_stmt|;
name|cData
operator|.
name|incrReadCount
argument_list|()
expr_stmt|;
block|}
DECL|method|getReadCount (long containerId)
specifier|public
name|long
name|getReadCount
parameter_list|(
name|long
name|containerId
parameter_list|)
block|{
name|ContainerData
name|cData
init|=
name|containerMap
operator|.
name|get
argument_list|(
name|containerId
argument_list|)
decl_stmt|;
return|return
name|cData
operator|.
name|getReadCount
argument_list|()
return|;
block|}
comment|/**    * Increase the read counter for bytes read from the container.    *    * @param containerId - ID of the container.    * @param readBytes     - bytes read from the container.    */
annotation|@
name|Override
DECL|method|incrReadBytes (long containerId, long readBytes)
specifier|public
name|void
name|incrReadBytes
parameter_list|(
name|long
name|containerId
parameter_list|,
name|long
name|readBytes
parameter_list|)
block|{
name|ContainerData
name|cData
init|=
name|containerMap
operator|.
name|get
argument_list|(
name|containerId
argument_list|)
decl_stmt|;
name|cData
operator|.
name|incrReadBytes
argument_list|(
name|readBytes
argument_list|)
expr_stmt|;
block|}
comment|/**    * Returns number of bytes read from the container.    * @param containerId    * @return    */
DECL|method|getReadBytes (long containerId)
specifier|public
name|long
name|getReadBytes
parameter_list|(
name|long
name|containerId
parameter_list|)
block|{
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
name|ContainerData
name|cData
init|=
name|containerMap
operator|.
name|get
argument_list|(
name|containerId
argument_list|)
decl_stmt|;
return|return
name|cData
operator|.
name|getReadBytes
argument_list|()
return|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Increase the write count of the container.    *    * @param containerId - Name of the container.    */
annotation|@
name|Override
DECL|method|incrWriteCount (long containerId)
specifier|public
name|void
name|incrWriteCount
parameter_list|(
name|long
name|containerId
parameter_list|)
block|{
name|ContainerData
name|cData
init|=
name|containerMap
operator|.
name|get
argument_list|(
name|containerId
argument_list|)
decl_stmt|;
name|cData
operator|.
name|incrWriteCount
argument_list|()
expr_stmt|;
block|}
DECL|method|getWriteCount (long containerId)
specifier|public
name|long
name|getWriteCount
parameter_list|(
name|long
name|containerId
parameter_list|)
block|{
name|ContainerData
name|cData
init|=
name|containerMap
operator|.
name|get
argument_list|(
name|containerId
argument_list|)
decl_stmt|;
return|return
name|cData
operator|.
name|getWriteCount
argument_list|()
return|;
block|}
comment|/**    * Increse the write counter for bytes write into the container.    *    * @param containerId   - ID of the container.    * @param writeBytes    - bytes write into the container.    */
annotation|@
name|Override
DECL|method|incrWriteBytes (long containerId, long writeBytes)
specifier|public
name|void
name|incrWriteBytes
parameter_list|(
name|long
name|containerId
parameter_list|,
name|long
name|writeBytes
parameter_list|)
block|{
name|ContainerData
name|cData
init|=
name|containerMap
operator|.
name|get
argument_list|(
name|containerId
argument_list|)
decl_stmt|;
name|cData
operator|.
name|incrWriteBytes
argument_list|(
name|writeBytes
argument_list|)
expr_stmt|;
block|}
DECL|method|getWriteBytes (long containerId)
specifier|public
name|long
name|getWriteBytes
parameter_list|(
name|long
name|containerId
parameter_list|)
block|{
name|ContainerData
name|cData
init|=
name|containerMap
operator|.
name|get
argument_list|(
name|containerId
argument_list|)
decl_stmt|;
return|return
name|cData
operator|.
name|getWriteBytes
argument_list|()
return|;
block|}
comment|/**    * Increase the bytes used by the container.    *    * @param containerId   - ID of the container.    * @param used          - additional bytes used by the container.    * @return the current bytes used.    */
annotation|@
name|Override
DECL|method|incrBytesUsed (long containerId, long used)
specifier|public
name|long
name|incrBytesUsed
parameter_list|(
name|long
name|containerId
parameter_list|,
name|long
name|used
parameter_list|)
block|{
name|ContainerData
name|cData
init|=
name|containerMap
operator|.
name|get
argument_list|(
name|containerId
argument_list|)
decl_stmt|;
return|return
name|cData
operator|.
name|incrBytesUsed
argument_list|(
name|used
argument_list|)
return|;
block|}
comment|/**    * Decrease the bytes used by the container.    *    * @param containerId   - ID of the container.    * @param used          - additional bytes reclaimed by the container.    * @return the current bytes used.    */
annotation|@
name|Override
DECL|method|decrBytesUsed (long containerId, long used)
specifier|public
name|long
name|decrBytesUsed
parameter_list|(
name|long
name|containerId
parameter_list|,
name|long
name|used
parameter_list|)
block|{
name|ContainerData
name|cData
init|=
name|containerMap
operator|.
name|get
argument_list|(
name|containerId
argument_list|)
decl_stmt|;
return|return
name|cData
operator|.
name|decrBytesUsed
argument_list|(
name|used
argument_list|)
return|;
block|}
DECL|method|getBytesUsed (long containerId)
specifier|public
name|long
name|getBytesUsed
parameter_list|(
name|long
name|containerId
parameter_list|)
block|{
name|ContainerData
name|cData
init|=
name|containerMap
operator|.
name|get
argument_list|(
name|containerId
argument_list|)
decl_stmt|;
return|return
name|cData
operator|.
name|getBytesUsed
argument_list|()
return|;
block|}
comment|/**    * Get the number of keys in the container.    *    * @param containerId - ID of the container.    * @return the current key count.    */
annotation|@
name|Override
DECL|method|getNumKeys (long containerId)
specifier|public
name|long
name|getNumKeys
parameter_list|(
name|long
name|containerId
parameter_list|)
block|{
name|ContainerData
name|cData
init|=
name|containerMap
operator|.
name|get
argument_list|(
name|containerId
argument_list|)
decl_stmt|;
return|return
name|cData
operator|.
name|getKeyCount
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|updateDeleteTransactionId (long containerId, long deleteTransactionId)
specifier|public
name|void
name|updateDeleteTransactionId
parameter_list|(
name|long
name|containerId
parameter_list|,
name|long
name|deleteTransactionId
parameter_list|)
block|{
name|containerMap
operator|.
name|get
argument_list|(
name|containerId
argument_list|)
operator|.
name|updateDeleteTransactionId
argument_list|(
name|deleteTransactionId
argument_list|)
expr_stmt|;
block|}
block|}
end_class

end_unit

