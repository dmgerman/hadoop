begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdds.scm.net
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdds
operator|.
name|scm
operator|.
name|net
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdds
operator|.
name|scm
operator|.
name|net
operator|.
name|NetConstants
operator|.
name|PATH_SEPARATOR_STR
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdds
operator|.
name|scm
operator|.
name|net
operator|.
name|NetConstants
operator|.
name|PATH_SEPARATOR
import|;
end_import

begin_comment
comment|/**  * A thread safe class that implements InnerNode interface.  */
end_comment

begin_class
DECL|class|InnerNodeImpl
specifier|public
class|class
name|InnerNodeImpl
extends|extends
name|NodeImpl
implements|implements
name|InnerNode
block|{
DECL|class|Factory
specifier|protected
specifier|static
class|class
name|Factory
implements|implements
name|InnerNode
operator|.
name|Factory
argument_list|<
name|InnerNodeImpl
argument_list|>
block|{
DECL|method|Factory ()
specifier|protected
name|Factory
parameter_list|()
block|{}
DECL|method|newInnerNode (String name, String location, InnerNode parent, int level, int cost)
specifier|public
name|InnerNodeImpl
name|newInnerNode
parameter_list|(
name|String
name|name
parameter_list|,
name|String
name|location
parameter_list|,
name|InnerNode
name|parent
parameter_list|,
name|int
name|level
parameter_list|,
name|int
name|cost
parameter_list|)
block|{
return|return
operator|new
name|InnerNodeImpl
argument_list|(
name|name
argument_list|,
name|location
argument_list|,
name|parent
argument_list|,
name|level
argument_list|,
name|cost
argument_list|)
return|;
block|}
block|}
DECL|field|FACTORY
specifier|static
specifier|final
name|Factory
name|FACTORY
init|=
operator|new
name|Factory
argument_list|()
decl_stmt|;
comment|// a map of node's network name to Node for quick search and keep
comment|// the insert order
DECL|field|childrenMap
specifier|private
specifier|final
name|HashMap
argument_list|<
name|String
argument_list|,
name|Node
argument_list|>
name|childrenMap
init|=
operator|new
name|LinkedHashMap
argument_list|<
name|String
argument_list|,
name|Node
argument_list|>
argument_list|()
decl_stmt|;
comment|// number of descendant leaves under this node
DECL|field|numOfLeaves
specifier|private
name|int
name|numOfLeaves
decl_stmt|;
comment|// LOGGER
DECL|field|LOG
specifier|public
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|InnerNodeImpl
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/**    * Construct an InnerNode from its name, network location, parent, level and    * its cost.    **/
DECL|method|InnerNodeImpl (String name, String location, InnerNode parent, int level, int cost)
specifier|protected
name|InnerNodeImpl
parameter_list|(
name|String
name|name
parameter_list|,
name|String
name|location
parameter_list|,
name|InnerNode
name|parent
parameter_list|,
name|int
name|level
parameter_list|,
name|int
name|cost
parameter_list|)
block|{
name|super
argument_list|(
name|name
argument_list|,
name|location
argument_list|,
name|parent
argument_list|,
name|level
argument_list|,
name|cost
argument_list|)
expr_stmt|;
block|}
comment|/** @return the number of children this node has */
DECL|method|getNumOfChildren ()
specifier|private
name|int
name|getNumOfChildren
parameter_list|()
block|{
return|return
name|childrenMap
operator|.
name|size
argument_list|()
return|;
block|}
comment|/** @return its leaf nodes number */
annotation|@
name|Override
DECL|method|getNumOfLeaves ()
specifier|public
name|int
name|getNumOfLeaves
parameter_list|()
block|{
return|return
name|numOfLeaves
return|;
block|}
comment|/**    * @return number of its all nodes at level<i>level</i>. Here level is a    * relative level. If level is 1, means node itself. If level is 2, means its    * direct children, and so on.    **/
DECL|method|getNumOfNodes (int level)
specifier|public
name|int
name|getNumOfNodes
parameter_list|(
name|int
name|level
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|level
operator|>
literal|0
argument_list|)
expr_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|level
operator|==
literal|1
condition|)
block|{
name|count
operator|+=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|level
operator|==
literal|2
condition|)
block|{
name|count
operator|+=
name|getNumOfChildren
argument_list|()
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|Node
name|node
range|:
name|childrenMap
operator|.
name|values
argument_list|()
control|)
block|{
if|if
condition|(
name|node
operator|instanceof
name|InnerNode
condition|)
block|{
name|count
operator|+=
operator|(
operator|(
name|InnerNode
operator|)
name|node
operator|)
operator|.
name|getNumOfNodes
argument_list|(
name|level
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Cannot support Level:"
operator|+
name|level
operator|+
literal|" on this node "
operator|+
name|this
operator|.
name|toString
argument_list|()
argument_list|)
throw|;
block|}
block|}
block|}
return|return
name|count
return|;
block|}
comment|/**    * Judge if this node is the parent of a leave node<i>n</i>.    * @return true if this node is the parent of<i>n</i>    */
DECL|method|isLeafParent ()
specifier|private
name|boolean
name|isLeafParent
parameter_list|()
block|{
if|if
condition|(
name|childrenMap
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
name|Node
name|child
init|=
name|childrenMap
operator|.
name|values
argument_list|()
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
decl_stmt|;
return|return
name|child
operator|instanceof
name|InnerNode
condition|?
literal|false
else|:
literal|true
return|;
block|}
comment|/**    * Judge if this node is the parent of node<i>node</i>.    * @param node a node    * @return true if this node is the parent of<i>n</i>    */
DECL|method|isParent (Node node)
specifier|private
name|boolean
name|isParent
parameter_list|(
name|Node
name|node
parameter_list|)
block|{
return|return
name|node
operator|.
name|getNetworkLocation
argument_list|()
operator|.
name|equals
argument_list|(
name|this
operator|.
name|getNetworkFullPath
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Add node<i>node</i> to the subtree of this node.    * @param node node to be added    * @return true if the node is added, false if is only updated    */
DECL|method|add (Node node)
specifier|public
name|boolean
name|add
parameter_list|(
name|Node
name|node
parameter_list|)
block|{
if|if
condition|(
operator|!
name|isAncestor
argument_list|(
name|node
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|node
operator|.
name|getNetworkName
argument_list|()
operator|+
literal|", which is located at "
operator|+
name|node
operator|.
name|getNetworkLocation
argument_list|()
operator|+
literal|", is not a descendant of "
operator|+
name|this
operator|.
name|getNetworkFullPath
argument_list|()
argument_list|)
throw|;
block|}
if|if
condition|(
name|isParent
argument_list|(
name|node
argument_list|)
condition|)
block|{
comment|// this node is the parent, then add it directly
name|node
operator|.
name|setParent
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|node
operator|.
name|setLevel
argument_list|(
name|this
operator|.
name|getLevel
argument_list|()
operator|+
literal|1
argument_list|)
expr_stmt|;
name|Node
name|current
init|=
name|childrenMap
operator|.
name|put
argument_list|(
name|node
operator|.
name|getNetworkName
argument_list|()
argument_list|,
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|current
operator|!=
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
else|else
block|{
comment|// find the next level ancestor node
name|String
name|ancestorName
init|=
name|getNextLevelAncestorName
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|InnerNode
name|childNode
init|=
operator|(
name|InnerNode
operator|)
name|childrenMap
operator|.
name|get
argument_list|(
name|ancestorName
argument_list|)
decl_stmt|;
if|if
condition|(
name|childNode
operator|==
literal|null
condition|)
block|{
comment|// create a new InnerNode for this ancestor node
name|childNode
operator|=
name|createChildNode
argument_list|(
name|ancestorName
argument_list|)
expr_stmt|;
name|childrenMap
operator|.
name|put
argument_list|(
name|childNode
operator|.
name|getNetworkName
argument_list|()
argument_list|,
name|childNode
argument_list|)
expr_stmt|;
block|}
comment|// add node to the subtree of the next ancestor node
if|if
condition|(
operator|!
name|childNode
operator|.
name|add
argument_list|(
name|node
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
name|numOfLeaves
operator|++
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|/**    * Remove node<i>node</i> from the subtree of this node.    * @param node node to be deleted    */
DECL|method|remove (Node node)
specifier|public
name|void
name|remove
parameter_list|(
name|Node
name|node
parameter_list|)
block|{
if|if
condition|(
operator|!
name|isAncestor
argument_list|(
name|node
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|node
operator|.
name|getNetworkName
argument_list|()
operator|+
literal|", which is located at "
operator|+
name|node
operator|.
name|getNetworkLocation
argument_list|()
operator|+
literal|", is not a descendant of "
operator|+
name|this
operator|.
name|getNetworkFullPath
argument_list|()
argument_list|)
throw|;
block|}
if|if
condition|(
name|isParent
argument_list|(
name|node
argument_list|)
condition|)
block|{
comment|// this node is the parent, remove it directly
if|if
condition|(
name|childrenMap
operator|.
name|containsKey
argument_list|(
name|node
operator|.
name|getNetworkName
argument_list|()
argument_list|)
condition|)
block|{
name|childrenMap
operator|.
name|remove
argument_list|(
name|node
operator|.
name|getNetworkName
argument_list|()
argument_list|)
expr_stmt|;
name|node
operator|.
name|setParent
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Should not come to here. Node:"
operator|+
name|node
operator|.
name|getNetworkFullPath
argument_list|()
operator|+
literal|", Parent:"
operator|+
name|this
operator|.
name|getNetworkFullPath
argument_list|()
argument_list|)
throw|;
block|}
block|}
else|else
block|{
comment|// find the next ancestor node
name|String
name|ancestorName
init|=
name|getNextLevelAncestorName
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|InnerNodeImpl
name|childNode
init|=
operator|(
name|InnerNodeImpl
operator|)
name|childrenMap
operator|.
name|get
argument_list|(
name|ancestorName
argument_list|)
decl_stmt|;
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|childNode
argument_list|,
literal|"InnerNode is deleted before leaf"
argument_list|)
expr_stmt|;
comment|// remove node from the parent node
name|childNode
operator|.
name|remove
argument_list|(
name|node
argument_list|)
expr_stmt|;
comment|// if the parent node has no children, remove the parent node too
if|if
condition|(
name|childNode
operator|.
name|getNumOfChildren
argument_list|()
operator|==
literal|0
condition|)
block|{
name|childrenMap
operator|.
name|remove
argument_list|(
name|ancestorName
argument_list|)
expr_stmt|;
block|}
block|}
name|numOfLeaves
operator|--
expr_stmt|;
block|}
comment|/**    * Given a node's string representation, return a reference to the node.    * Node can be leaf node or inner node.    *    * @param loc string location of a node. If loc starts with "/", it's a    *            absolute path, otherwise a relative path. Following examples    *            are all accepted,    *            1.  /dc1/rm1/rack1          -> an inner node    *            2.  /dc1/rm1/rack1/node1    -> a leaf node    *            3.  rack1/node1             -> a relative path to this node    *    * @return null if the node is not found    */
DECL|method|getNode (String loc)
specifier|public
name|Node
name|getNode
parameter_list|(
name|String
name|loc
parameter_list|)
block|{
if|if
condition|(
name|loc
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|String
name|fullPath
init|=
name|this
operator|.
name|getNetworkFullPath
argument_list|()
decl_stmt|;
if|if
condition|(
name|loc
operator|.
name|equalsIgnoreCase
argument_list|(
name|fullPath
argument_list|)
condition|)
block|{
return|return
name|this
return|;
block|}
comment|// remove current node's location from loc when it's a absolute path
if|if
condition|(
name|fullPath
operator|.
name|equals
argument_list|(
name|NetConstants
operator|.
name|PATH_SEPARATOR_STR
argument_list|)
condition|)
block|{
comment|// current node is ROOT
if|if
condition|(
name|loc
operator|.
name|startsWith
argument_list|(
name|PATH_SEPARATOR_STR
argument_list|)
condition|)
block|{
name|loc
operator|=
name|loc
operator|.
name|substring
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|loc
operator|.
name|startsWith
argument_list|(
name|fullPath
argument_list|)
condition|)
block|{
name|loc
operator|=
name|loc
operator|.
name|substring
argument_list|(
name|fullPath
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
comment|// skip the separator "/"
name|loc
operator|=
name|loc
operator|.
name|substring
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|String
index|[]
name|path
init|=
name|loc
operator|.
name|split
argument_list|(
name|PATH_SEPARATOR_STR
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|Node
name|child
init|=
name|childrenMap
operator|.
name|get
argument_list|(
name|path
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|child
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
name|path
operator|.
name|length
operator|==
literal|1
condition|)
block|{
return|return
name|child
return|;
block|}
if|if
condition|(
name|child
operator|instanceof
name|InnerNode
condition|)
block|{
return|return
operator|(
operator|(
name|InnerNode
operator|)
name|child
operator|)
operator|.
name|getNode
argument_list|(
name|path
index|[
literal|1
index|]
argument_list|)
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
comment|/**    * get<i>leafIndex</i> leaf of this subtree.    *    * @param leafIndex an indexed leaf of the node    * @return the leaf node corresponding to the given index.    */
DECL|method|getLeaf (int leafIndex)
specifier|public
name|Node
name|getLeaf
parameter_list|(
name|int
name|leafIndex
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|leafIndex
operator|>=
literal|0
argument_list|)
expr_stmt|;
comment|// children are leaves
if|if
condition|(
name|isLeafParent
argument_list|()
condition|)
block|{
comment|// range check
if|if
condition|(
name|leafIndex
operator|>=
name|getNumOfChildren
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|getChildNode
argument_list|(
name|leafIndex
argument_list|)
return|;
block|}
else|else
block|{
for|for
control|(
name|Node
name|node
range|:
name|childrenMap
operator|.
name|values
argument_list|()
control|)
block|{
name|InnerNodeImpl
name|child
init|=
operator|(
name|InnerNodeImpl
operator|)
name|node
decl_stmt|;
name|int
name|leafCount
init|=
name|child
operator|.
name|getNumOfLeaves
argument_list|()
decl_stmt|;
if|if
condition|(
name|leafIndex
operator|<
name|leafCount
condition|)
block|{
return|return
name|child
operator|.
name|getLeaf
argument_list|(
name|leafIndex
argument_list|)
return|;
block|}
else|else
block|{
name|leafIndex
operator|-=
name|leafCount
expr_stmt|;
block|}
block|}
return|return
literal|null
return|;
block|}
block|}
comment|/**    * Get<i>leafIndex</i> leaf of this subtree.    *    * @param leafIndex node's index, start from 0, skip the nodes in    *                 excludedScope and excludedNodes with ancestorGen    * @param excludedScopes the exclude scopes    * @param excludedNodes nodes to be excluded from. If ancestorGen is not 0,    *                      the chosen node will not share same ancestor with    *                      those in excluded nodes at the specified generation    * @param ancestorGen  apply to excludeNodes, when value is 0, then no same    *                    ancestor enforcement on excludedNodes    * @return the leaf node corresponding to the given index.    * Example:    *    *                                /  --- root    *                              /  \    *                             /    \    *                            /      \    *                           /        \    *                         dc1         dc2    *                        / \         / \    *                       /   \       /   \    *                      /     \     /     \    *                    rack1 rack2  rack1  rack2    *                   / \     / \  / \     / \    *                 n1  n2  n3 n4 n5  n6  n7 n8    *    *   Input:    *   leafIndex = 2    *   excludedScope = /dc2/rack2    *   excludedNodes = {/dc1/rack1/n1}    *   ancestorGen = 1    *    *   Output:    *   node /dc1/rack2/n5    *    *   Explanation:    *   Since excludedNodes is n1 and ancestorGen is 1, it means nodes under    *   /root/dc1/rack1 are excluded. Given leafIndex start from 0, LeafIndex 2    *   means picking the 3th available node, which is n5.    *    */
DECL|method|getLeaf (int leafIndex, List<String> excludedScopes, Collection<Node> excludedNodes, int ancestorGen)
specifier|public
name|Node
name|getLeaf
parameter_list|(
name|int
name|leafIndex
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|excludedScopes
parameter_list|,
name|Collection
argument_list|<
name|Node
argument_list|>
name|excludedNodes
parameter_list|,
name|int
name|ancestorGen
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|leafIndex
operator|>=
literal|0
operator|&&
name|ancestorGen
operator|>=
literal|0
argument_list|)
expr_stmt|;
comment|// come to leaf parent layer
if|if
condition|(
name|isLeafParent
argument_list|()
condition|)
block|{
return|return
name|getLeafOnLeafParent
argument_list|(
name|leafIndex
argument_list|,
name|excludedScopes
argument_list|,
name|excludedNodes
argument_list|)
return|;
block|}
name|int
name|maxLevel
init|=
name|NodeSchemaManager
operator|.
name|getInstance
argument_list|()
operator|.
name|getMaxLevel
argument_list|()
decl_stmt|;
comment|// this node's children, it's generation as the ancestor of the leaf node
name|int
name|currentGen
init|=
name|maxLevel
operator|-
name|this
operator|.
name|getLevel
argument_list|()
operator|-
literal|1
decl_stmt|;
comment|// build an ancestor(children) to exclude node count map
name|Map
argument_list|<
name|Node
argument_list|,
name|Integer
argument_list|>
name|countMap
init|=
name|getAncestorCountMap
argument_list|(
name|excludedNodes
argument_list|,
name|ancestorGen
argument_list|,
name|currentGen
argument_list|)
decl_stmt|;
comment|// nodes covered by excluded scope
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|excludedNodeCount
init|=
name|getExcludedScopeNodeCount
argument_list|(
name|excludedScopes
argument_list|)
decl_stmt|;
for|for
control|(
name|Node
name|child
range|:
name|childrenMap
operator|.
name|values
argument_list|()
control|)
block|{
name|int
name|leafCount
init|=
name|child
operator|.
name|getNumOfLeaves
argument_list|()
decl_stmt|;
comment|// skip nodes covered by excluded scopes
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|entry
range|:
name|excludedNodeCount
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
name|entry
operator|.
name|getKey
argument_list|()
operator|.
name|startsWith
argument_list|(
name|child
operator|.
name|getNetworkFullPath
argument_list|()
argument_list|)
condition|)
block|{
name|leafCount
operator|-=
name|entry
operator|.
name|getValue
argument_list|()
expr_stmt|;
block|}
block|}
comment|// skip nodes covered by excluded nodes and ancestorGen
name|Integer
name|count
init|=
name|countMap
operator|.
name|get
argument_list|(
name|child
argument_list|)
decl_stmt|;
if|if
condition|(
name|count
operator|!=
literal|null
condition|)
block|{
name|leafCount
operator|-=
name|count
expr_stmt|;
block|}
if|if
condition|(
name|leafIndex
operator|<
name|leafCount
condition|)
block|{
return|return
operator|(
operator|(
name|InnerNode
operator|)
name|child
operator|)
operator|.
name|getLeaf
argument_list|(
name|leafIndex
argument_list|,
name|excludedScopes
argument_list|,
name|excludedNodes
argument_list|,
name|ancestorGen
argument_list|)
return|;
block|}
else|else
block|{
name|leafIndex
operator|-=
name|leafCount
expr_stmt|;
block|}
block|}
return|return
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|equals (Object to)
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|to
parameter_list|)
block|{
if|if
condition|(
name|to
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|this
operator|==
name|to
condition|)
block|{
return|return
literal|true
return|;
block|}
return|return
name|this
operator|.
name|toString
argument_list|()
operator|.
name|equals
argument_list|(
name|to
operator|.
name|toString
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|hashCode ()
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|super
operator|.
name|hashCode
argument_list|()
return|;
block|}
comment|/**    * Get a ancestor to its excluded node count map.    *    * @param nodes a collection of leaf nodes to exclude    * @param genToExclude  the ancestor generation to exclude    * @param genToReturn  the ancestor generation to return the count map    * @return the map.    * example:    *    *                *  --- root    *              /    \    *             *      *   -- genToReturn =2    *            / \    / \    *          *   *   *   *  -- genToExclude = 1    *         /\  /\  /\  /\    *       *  * * * * * * *  -- nodes    */
DECL|method|getAncestorCountMap (Collection<Node> nodes, int genToExclude, int genToReturn)
specifier|private
name|Map
argument_list|<
name|Node
argument_list|,
name|Integer
argument_list|>
name|getAncestorCountMap
parameter_list|(
name|Collection
argument_list|<
name|Node
argument_list|>
name|nodes
parameter_list|,
name|int
name|genToExclude
parameter_list|,
name|int
name|genToReturn
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkState
argument_list|(
name|genToExclude
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkState
argument_list|(
name|genToReturn
operator|>=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|nodes
operator|==
literal|null
operator|||
name|nodes
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
name|Collections
operator|.
name|emptyMap
argument_list|()
return|;
block|}
comment|// with the recursive call, genToReturn can be smaller than genToExclude
if|if
condition|(
name|genToReturn
operator|<
name|genToExclude
condition|)
block|{
name|genToExclude
operator|=
name|genToReturn
expr_stmt|;
block|}
comment|// ancestorToExclude to ancestorToReturn map
name|HashMap
argument_list|<
name|Node
argument_list|,
name|Node
argument_list|>
name|ancestorMap
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|Node
name|node
range|:
name|nodes
control|)
block|{
name|Node
name|ancestorToExclude
init|=
name|node
operator|.
name|getAncestor
argument_list|(
name|genToExclude
argument_list|)
decl_stmt|;
name|Node
name|ancestorToReturn
init|=
name|node
operator|.
name|getAncestor
argument_list|(
name|genToReturn
argument_list|)
decl_stmt|;
if|if
condition|(
name|ancestorToExclude
operator|==
literal|null
operator|||
name|ancestorToReturn
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Ancestor not found, node: "
operator|+
name|node
operator|.
name|getNetworkFullPath
argument_list|()
operator|+
literal|", generation to exclude: "
operator|+
name|genToExclude
operator|+
literal|", generation to return:"
operator|+
name|genToReturn
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|ancestorMap
operator|.
name|put
argument_list|(
name|ancestorToExclude
argument_list|,
name|ancestorToReturn
argument_list|)
expr_stmt|;
block|}
comment|// ancestorToReturn to exclude node count map
name|HashMap
argument_list|<
name|Node
argument_list|,
name|Integer
argument_list|>
name|countMap
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|Node
argument_list|,
name|Node
argument_list|>
name|entry
range|:
name|ancestorMap
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|countMap
operator|.
name|compute
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
argument_list|,
parameter_list|(
name|key
parameter_list|,
name|n
parameter_list|)
lambda|->
operator|(
name|n
operator|==
literal|null
condition|?
literal|0
else|:
name|n
operator|)
operator|+
name|entry
operator|.
name|getKey
argument_list|()
operator|.
name|getNumOfLeaves
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|countMap
return|;
block|}
comment|/**    *  Get the node with leafIndex, considering skip nodes in excludedScope    *  and in excludeNodes list.    */
DECL|method|getLeafOnLeafParent (int leafIndex, List<String> excludedScopes, Collection<Node> excludedNodes)
specifier|private
name|Node
name|getLeafOnLeafParent
parameter_list|(
name|int
name|leafIndex
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|excludedScopes
parameter_list|,
name|Collection
argument_list|<
name|Node
argument_list|>
name|excludedNodes
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|isLeafParent
argument_list|()
operator|&&
name|leafIndex
operator|>=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|leafIndex
operator|>=
name|getNumOfChildren
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
for|for
control|(
name|Node
name|node
range|:
name|childrenMap
operator|.
name|values
argument_list|()
control|)
block|{
if|if
condition|(
name|excludedNodes
operator|!=
literal|null
operator|&&
name|excludedNodes
operator|.
name|contains
argument_list|(
name|node
argument_list|)
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|excludedScopes
operator|!=
literal|null
operator|&&
name|excludedScopes
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|excludedScopes
operator|.
name|stream
argument_list|()
operator|.
name|anyMatch
argument_list|(
name|scope
lambda|->
name|node
operator|.
name|getNetworkFullPath
argument_list|()
operator|.
name|startsWith
argument_list|(
name|scope
argument_list|)
argument_list|)
condition|)
block|{
continue|continue;
block|}
block|}
if|if
condition|(
name|leafIndex
operator|==
literal|0
condition|)
block|{
return|return
name|node
return|;
block|}
name|leafIndex
operator|--
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
comment|/**    *  Return child's name of this node which is an ancestor of node<i>n</i>.    */
DECL|method|getNextLevelAncestorName (Node n)
specifier|private
name|String
name|getNextLevelAncestorName
parameter_list|(
name|Node
name|n
parameter_list|)
block|{
name|int
name|parentPathLen
init|=
name|this
operator|.
name|getNetworkFullPath
argument_list|()
operator|.
name|length
argument_list|()
decl_stmt|;
name|String
name|name
init|=
name|n
operator|.
name|getNetworkLocation
argument_list|()
operator|.
name|substring
argument_list|(
name|parentPathLen
argument_list|)
decl_stmt|;
if|if
condition|(
name|name
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
operator|==
name|PATH_SEPARATOR
condition|)
block|{
name|name
operator|=
name|name
operator|.
name|substring
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|int
name|index
init|=
name|name
operator|.
name|indexOf
argument_list|(
name|PATH_SEPARATOR
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|!=
operator|-
literal|1
condition|)
block|{
name|name
operator|=
name|name
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
return|return
name|name
return|;
block|}
comment|/**    * Creates a child node to be added to the list of children.    * @param name The name of the child node    * @return A new inner node    * @see InnerNodeImpl(String, String, InnerNode, int)    */
DECL|method|createChildNode (String name)
specifier|private
name|InnerNodeImpl
name|createChildNode
parameter_list|(
name|String
name|name
parameter_list|)
block|{
name|int
name|childLevel
init|=
name|this
operator|.
name|getLevel
argument_list|()
operator|+
literal|1
decl_stmt|;
name|int
name|cost
init|=
name|NodeSchemaManager
operator|.
name|getInstance
argument_list|()
operator|.
name|getCost
argument_list|(
name|childLevel
argument_list|)
decl_stmt|;
return|return
operator|new
name|InnerNodeImpl
argument_list|(
name|name
argument_list|,
name|this
operator|.
name|getNetworkFullPath
argument_list|()
argument_list|,
name|this
argument_list|,
name|childLevel
argument_list|,
name|cost
argument_list|)
return|;
block|}
comment|/** Get node with index<i>index</i>. */
DECL|method|getChildNode (int index)
specifier|private
name|Node
name|getChildNode
parameter_list|(
name|int
name|index
parameter_list|)
block|{
name|Iterator
name|iterator
init|=
name|childrenMap
operator|.
name|values
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|Node
name|node
init|=
literal|null
decl_stmt|;
while|while
condition|(
name|index
operator|>=
literal|0
operator|&&
name|iterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|node
operator|=
operator|(
name|Node
operator|)
name|iterator
operator|.
name|next
argument_list|()
expr_stmt|;
name|index
operator|--
expr_stmt|;
block|}
return|return
name|node
return|;
block|}
comment|/** Get how many leaf nodes are covered by the excludedScopes(no overlap). */
DECL|method|getExcludedScopeNodeCount ( List<String> excludedScopes)
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|getExcludedScopeNodeCount
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|excludedScopes
parameter_list|)
block|{
name|HashMap
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|nodeCounts
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
if|if
condition|(
name|excludedScopes
operator|==
literal|null
operator|||
name|excludedScopes
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|nodeCounts
return|;
block|}
for|for
control|(
name|String
name|scope
range|:
name|excludedScopes
control|)
block|{
name|Node
name|excludedScopeNode
init|=
name|getNode
argument_list|(
name|scope
argument_list|)
decl_stmt|;
name|nodeCounts
operator|.
name|put
argument_list|(
name|scope
argument_list|,
name|excludedScopeNode
operator|==
literal|null
condition|?
literal|0
else|:
name|excludedScopeNode
operator|.
name|getNumOfLeaves
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|nodeCounts
return|;
block|}
block|}
end_class

end_unit

