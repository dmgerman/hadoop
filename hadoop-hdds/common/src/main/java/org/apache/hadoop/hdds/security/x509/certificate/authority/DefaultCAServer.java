begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  *  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdds.security.x509.certificate.authority
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdds
operator|.
name|security
operator|.
name|x509
operator|.
name|certificate
operator|.
name|authority
package|;
end_package

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdds
operator|.
name|security
operator|.
name|exception
operator|.
name|SCMSecurityException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdds
operator|.
name|security
operator|.
name|x509
operator|.
name|SecurityConfig
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdds
operator|.
name|security
operator|.
name|x509
operator|.
name|certificate
operator|.
name|authority
operator|.
name|PKIProfiles
operator|.
name|DefaultProfile
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdds
operator|.
name|security
operator|.
name|x509
operator|.
name|certificate
operator|.
name|authority
operator|.
name|PKIProfiles
operator|.
name|PKIProfile
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdds
operator|.
name|security
operator|.
name|x509
operator|.
name|certificate
operator|.
name|utils
operator|.
name|CertificateCodec
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdds
operator|.
name|security
operator|.
name|x509
operator|.
name|certificates
operator|.
name|utils
operator|.
name|SelfSignedCertificate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdds
operator|.
name|security
operator|.
name|x509
operator|.
name|keys
operator|.
name|HDDSKeyGenerator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdds
operator|.
name|security
operator|.
name|x509
operator|.
name|keys
operator|.
name|KeyCodec
import|;
end_import

begin_import
import|import
name|org
operator|.
name|bouncycastle
operator|.
name|cert
operator|.
name|X509CertificateHolder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|bouncycastle
operator|.
name|operator
operator|.
name|OperatorCreationException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|bouncycastle
operator|.
name|pkcs
operator|.
name|PKCS10CertificationRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|Files
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|Paths
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|KeyPair
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|NoSuchAlgorithmException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|NoSuchProviderException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|cert
operator|.
name|CertificateException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|cert
operator|.
name|X509Certificate
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|spec
operator|.
name|InvalidKeySpecException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|time
operator|.
name|LocalDate
import|;
end_import

begin_import
import|import
name|java
operator|.
name|time
operator|.
name|LocalDateTime
import|;
end_import

begin_import
import|import
name|java
operator|.
name|time
operator|.
name|LocalTime
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|CompletableFuture
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Future
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|Consumer
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdds
operator|.
name|security
operator|.
name|x509
operator|.
name|certificates
operator|.
name|utils
operator|.
name|CertificateSignRequest
operator|.
name|*
import|;
end_import

begin_comment
comment|/**  * The default CertificateServer used by SCM. This has no dependencies on any  * external system, this allows us to bootstrap a CertificateServer from  * Scratch.  *<p>  * Details =======  *<p>  * The Default CA server is one of the many possible implementations of an SCM  * Certificate Authority.  *<p>  * A certificate authority needs the Root Certificates and its private key to  * operate.  The init function of the DefaultCA Server detects four possible  * states the System can be in.  *<p>  * 1.  Success - This means that the expected Certificates and Keys are in  * place, and the CA was able to read those files into memory.  *<p>  * 2. Missing Keys - This means that private keys are missing. This is an error  * state which SCM CA cannot recover from. The cluster might have been  * initialized earlier and for some reason, we are not able to find the private  * keys for the CA. Eventually we will have 2 ways to recover from this state,  * first one is to copy the SCM CA private keys from a backup. Second one is to  * rekey the whole cluster. Both of these are improvements we will support in  * future.  *<p>  * 3. Missing Certificate - Similar to Missing Keys, but the root certificates  * are missing.  *<p>  * 4. Initialize - We don't have keys or certificates. DefaultCA assumes that  * this is a system bootup and will generate the keys and certificates  * automatically.  *<p>  * The init() follows the following logic,  *<p>  * 1. Compute the Verification Status -- Success, Missing Keys, Missing Certs or  * Initialize.  *<p>  * 2. ProcessVerificationStatus - Returns a Lambda, based on the Verification  * Status.  *<p>  * 3. Invoke the Lambda function.  *<p>  * At the end of the init function, we have functional CA. This function can be  * invoked as many times since we will regenerate the keys and certs only if  * both of them are missing.  */
end_comment

begin_class
DECL|class|DefaultCAServer
specifier|public
class|class
name|DefaultCAServer
implements|implements
name|CertificateServer
block|{
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|DefaultCAServer
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|subject
specifier|private
specifier|final
name|String
name|subject
decl_stmt|;
DECL|field|clusterID
specifier|private
specifier|final
name|String
name|clusterID
decl_stmt|;
DECL|field|scmID
specifier|private
specifier|final
name|String
name|scmID
decl_stmt|;
DECL|field|componentName
specifier|private
name|String
name|componentName
init|=
name|Paths
operator|.
name|get
argument_list|(
literal|"scm"
argument_list|,
literal|"ca"
argument_list|)
operator|.
name|toString
argument_list|()
decl_stmt|;
DECL|field|caKeysPath
specifier|private
name|Path
name|caKeysPath
decl_stmt|;
DECL|field|caRootX509Path
specifier|private
name|Path
name|caRootX509Path
decl_stmt|;
DECL|field|config
specifier|private
name|SecurityConfig
name|config
decl_stmt|;
comment|/**    * TODO: We will make these configurable in the future.    */
DECL|field|profile
specifier|private
name|PKIProfile
name|profile
decl_stmt|;
DECL|field|approver
specifier|private
name|CertificateApprover
name|approver
decl_stmt|;
comment|/**    * Create an Instance of DefaultCAServer.    *    * @param subject - String Subject    * @param clusterID - String ClusterID    * @param scmID - String SCMID.    */
DECL|method|DefaultCAServer (String subject, String clusterID, String scmID)
specifier|public
name|DefaultCAServer
parameter_list|(
name|String
name|subject
parameter_list|,
name|String
name|clusterID
parameter_list|,
name|String
name|scmID
parameter_list|)
block|{
name|this
operator|.
name|subject
operator|=
name|subject
expr_stmt|;
name|this
operator|.
name|clusterID
operator|=
name|clusterID
expr_stmt|;
name|this
operator|.
name|scmID
operator|=
name|scmID
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|init (SecurityConfig securityConfig, CAType type)
specifier|public
name|void
name|init
parameter_list|(
name|SecurityConfig
name|securityConfig
parameter_list|,
name|CAType
name|type
parameter_list|)
throws|throws
name|SCMSecurityException
block|{
name|caKeysPath
operator|=
name|securityConfig
operator|.
name|getKeyLocation
argument_list|(
name|componentName
argument_list|)
expr_stmt|;
name|caRootX509Path
operator|=
name|securityConfig
operator|.
name|getCertificateLocation
argument_list|(
name|componentName
argument_list|)
expr_stmt|;
name|this
operator|.
name|config
operator|=
name|securityConfig
expr_stmt|;
comment|// TODO: Make these configurable and load different profiles based on
comment|// config.
name|profile
operator|=
operator|new
name|DefaultProfile
argument_list|()
expr_stmt|;
name|this
operator|.
name|approver
operator|=
operator|new
name|DefaultApprover
argument_list|(
name|profile
argument_list|,
name|this
operator|.
name|config
argument_list|)
expr_stmt|;
comment|/* In future we will spilt this code to have different kind of CAs.      * Right now, we have only self-signed CertificateServer.      */
if|if
condition|(
name|type
operator|==
name|CAType
operator|.
name|SELF_SIGNED_CA
condition|)
block|{
name|VerificationStatus
name|status
init|=
name|verifySelfSignedCA
argument_list|(
name|securityConfig
argument_list|)
decl_stmt|;
name|Consumer
argument_list|<
name|SecurityConfig
argument_list|>
name|caInitializer
init|=
name|processVerificationStatus
argument_list|(
name|status
argument_list|)
decl_stmt|;
name|caInitializer
operator|.
name|accept
argument_list|(
name|securityConfig
argument_list|)
expr_stmt|;
return|return;
block|}
name|LOG
operator|.
name|error
argument_list|(
literal|"We support only Self-Signed CAs for now."
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Not implemented functionality requested."
argument_list|)
throw|;
block|}
annotation|@
name|Override
DECL|method|getCACertificate ()
specifier|public
name|X509CertificateHolder
name|getCACertificate
parameter_list|()
throws|throws
name|IOException
block|{
name|CertificateCodec
name|certificateCodec
init|=
operator|new
name|CertificateCodec
argument_list|(
name|config
argument_list|,
name|componentName
argument_list|)
decl_stmt|;
try|try
block|{
return|return
name|certificateCodec
operator|.
name|readCertificate
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|CertificateException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
DECL|method|getCAKeys ()
specifier|private
name|KeyPair
name|getCAKeys
parameter_list|()
throws|throws
name|IOException
block|{
name|KeyCodec
name|keyCodec
init|=
operator|new
name|KeyCodec
argument_list|(
name|config
argument_list|,
name|componentName
argument_list|)
decl_stmt|;
try|try
block|{
return|return
operator|new
name|KeyPair
argument_list|(
name|keyCodec
operator|.
name|readPublicKey
argument_list|()
argument_list|,
name|keyCodec
operator|.
name|readPrivateKey
argument_list|()
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|InvalidKeySpecException
decl||
name|NoSuchAlgorithmException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
DECL|method|requestCertificate ( PKCS10CertificationRequest csr, CertificateApprover.ApprovalType approverType)
specifier|public
name|Future
argument_list|<
name|X509CertificateHolder
argument_list|>
name|requestCertificate
parameter_list|(
name|PKCS10CertificationRequest
name|csr
parameter_list|,
name|CertificateApprover
operator|.
name|ApprovalType
name|approverType
parameter_list|)
block|{
name|LocalDate
name|beginDate
init|=
name|LocalDate
operator|.
name|now
argument_list|()
operator|.
name|atStartOfDay
argument_list|()
operator|.
name|toLocalDate
argument_list|()
decl_stmt|;
name|LocalDateTime
name|temp
init|=
name|LocalDateTime
operator|.
name|of
argument_list|(
name|beginDate
argument_list|,
name|LocalTime
operator|.
name|MIDNIGHT
argument_list|)
decl_stmt|;
name|LocalDate
name|endDate
init|=
name|temp
operator|.
name|plus
argument_list|(
name|config
operator|.
name|getDefaultCertDuration
argument_list|()
argument_list|)
operator|.
name|toLocalDate
argument_list|()
decl_stmt|;
name|CompletableFuture
argument_list|<
name|X509CertificateHolder
argument_list|>
name|xcertHolder
init|=
name|approver
operator|.
name|inspectCSR
argument_list|(
name|csr
argument_list|)
decl_stmt|;
if|if
condition|(
name|xcertHolder
operator|.
name|isCompletedExceptionally
argument_list|()
condition|)
block|{
comment|// This means that approver told us there are things which it disagrees
comment|// with in this Certificate Request. Since the first set of sanity
comment|// checks failed, we just return the future object right here.
return|return
name|xcertHolder
return|;
block|}
try|try
block|{
switch|switch
condition|(
name|approverType
condition|)
block|{
case|case
name|MANUAL
case|:
name|xcertHolder
operator|.
name|completeExceptionally
argument_list|(
operator|new
name|SCMSecurityException
argument_list|(
literal|"Manual "
operator|+
literal|"approval is not yet implemented."
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|KERBEROS_TRUSTED
case|:
case|case
name|TESTING_AUTOMATIC
case|:
name|X509CertificateHolder
name|xcert
init|=
name|approver
operator|.
name|sign
argument_list|(
name|config
argument_list|,
name|getCAKeys
argument_list|()
operator|.
name|getPrivate
argument_list|()
argument_list|,
name|getCACertificate
argument_list|()
argument_list|,
name|java
operator|.
name|sql
operator|.
name|Date
operator|.
name|valueOf
argument_list|(
name|beginDate
argument_list|)
argument_list|,
name|java
operator|.
name|sql
operator|.
name|Date
operator|.
name|valueOf
argument_list|(
name|endDate
argument_list|)
argument_list|,
name|csr
argument_list|)
decl_stmt|;
name|xcertHolder
operator|.
name|complete
argument_list|(
name|xcert
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
literal|null
return|;
comment|// cannot happen, keeping checkstyle happy.
block|}
block|}
catch|catch
parameter_list|(
name|IOException
decl||
name|OperatorCreationException
name|e
parameter_list|)
block|{
name|xcertHolder
operator|.
name|completeExceptionally
argument_list|(
operator|new
name|SCMSecurityException
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|xcertHolder
return|;
block|}
annotation|@
name|Override
DECL|method|requestCertificate (String csr, CertificateApprover.ApprovalType type)
specifier|public
name|Future
argument_list|<
name|X509CertificateHolder
argument_list|>
name|requestCertificate
parameter_list|(
name|String
name|csr
parameter_list|,
name|CertificateApprover
operator|.
name|ApprovalType
name|type
parameter_list|)
throws|throws
name|IOException
block|{
name|PKCS10CertificationRequest
name|request
init|=
name|getCertificationRequest
argument_list|(
name|csr
argument_list|)
decl_stmt|;
return|return
name|requestCertificate
argument_list|(
name|request
argument_list|,
name|type
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|revokeCertificate (X509Certificate certificate, CertificateApprover.ApprovalType approverType)
specifier|public
name|Future
argument_list|<
name|Boolean
argument_list|>
name|revokeCertificate
parameter_list|(
name|X509Certificate
name|certificate
parameter_list|,
name|CertificateApprover
operator|.
name|ApprovalType
name|approverType
parameter_list|)
throws|throws
name|SCMSecurityException
block|{
return|return
literal|null
return|;
block|}
comment|/**    * Generates a Self Signed CertificateServer. These are the steps in    * generating a Self-Signed CertificateServer.    *<p>    * 1. Generate a Private/Public Key Pair. 2. Persist to a protected location.    * 3. Generate a SelfSigned Root CertificateServer certificate.    *    * @param securityConfig - Config.    */
DECL|method|generateSelfSignedCA (SecurityConfig securityConfig)
specifier|private
name|void
name|generateSelfSignedCA
parameter_list|(
name|SecurityConfig
name|securityConfig
parameter_list|)
throws|throws
name|NoSuchAlgorithmException
throws|,
name|NoSuchProviderException
throws|,
name|IOException
block|{
name|KeyPair
name|keyPair
init|=
name|generateKeys
argument_list|(
name|securityConfig
argument_list|)
decl_stmt|;
name|generateRootCertificate
argument_list|(
name|securityConfig
argument_list|,
name|keyPair
argument_list|)
expr_stmt|;
block|}
comment|/**    * Verify Self-Signed CertificateServer. 1. Check if the Certificate exist. 2.    * Check if the key pair exists.    *    * @param securityConfig -- Config    * @return Verification Status    */
DECL|method|verifySelfSignedCA (SecurityConfig securityConfig)
specifier|private
name|VerificationStatus
name|verifySelfSignedCA
parameter_list|(
name|SecurityConfig
name|securityConfig
parameter_list|)
block|{
comment|/*     The following is the truth table for the States.     True means we have that file False means it is missing.     +--------------+--------+--------+--------------+     | Certificates |  Keys  | Result |   Function   |     +--------------+--------+--------+--------------+     | True         | True   | True   | Success      |     | False        | False  | True   | Initialize   |     | True         | False  | False  | Missing Key  |     | False        | True   | False  | Missing Cert |     +--------------+--------+--------+--------------+      This truth table maps to ~(certs xor keys) or certs == keys      */
name|boolean
name|keyStatus
init|=
name|checkIfKeysExist
argument_list|()
decl_stmt|;
name|boolean
name|certStatus
init|=
name|checkIfCertificatesExist
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|certStatus
operator|==
name|keyStatus
operator|)
operator|&&
operator|(
name|certStatus
operator|)
condition|)
block|{
return|return
name|VerificationStatus
operator|.
name|SUCCESS
return|;
block|}
if|if
condition|(
operator|(
name|certStatus
operator|==
name|keyStatus
operator|)
operator|&&
operator|(
operator|!
name|certStatus
operator|)
condition|)
block|{
return|return
name|VerificationStatus
operator|.
name|INITIALIZE
return|;
block|}
comment|// At this point certStatus is not equal to keyStatus.
if|if
condition|(
name|certStatus
condition|)
block|{
return|return
name|VerificationStatus
operator|.
name|MISSING_KEYS
return|;
block|}
return|return
name|VerificationStatus
operator|.
name|MISSING_CERTIFICATE
return|;
block|}
comment|/**    * Returns Keys status.    *    * @return True if the key files exist.    */
DECL|method|checkIfKeysExist ()
specifier|private
name|boolean
name|checkIfKeysExist
parameter_list|()
block|{
if|if
condition|(
operator|!
name|Files
operator|.
name|exists
argument_list|(
name|caKeysPath
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
name|Files
operator|.
name|exists
argument_list|(
name|Paths
operator|.
name|get
argument_list|(
name|caKeysPath
operator|.
name|toString
argument_list|()
argument_list|,
name|this
operator|.
name|config
operator|.
name|getPrivateKeyFileName
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Returns certificate Status.    *    * @return True if the Certificate files exist.    */
DECL|method|checkIfCertificatesExist ()
specifier|private
name|boolean
name|checkIfCertificatesExist
parameter_list|()
block|{
if|if
condition|(
operator|!
name|Files
operator|.
name|exists
argument_list|(
name|caRootX509Path
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
name|Files
operator|.
name|exists
argument_list|(
name|Paths
operator|.
name|get
argument_list|(
name|caRootX509Path
operator|.
name|toString
argument_list|()
argument_list|,
name|this
operator|.
name|config
operator|.
name|getCertificateFileName
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Based on the Status of the verification, we return a lambda that gets    * executed by the init function of the CA.    *    * @param status - Verification Status.    */
annotation|@
name|VisibleForTesting
DECL|method|processVerificationStatus ( VerificationStatus status)
name|Consumer
argument_list|<
name|SecurityConfig
argument_list|>
name|processVerificationStatus
parameter_list|(
name|VerificationStatus
name|status
parameter_list|)
block|{
name|Consumer
argument_list|<
name|SecurityConfig
argument_list|>
name|consumer
init|=
literal|null
decl_stmt|;
switch|switch
condition|(
name|status
condition|)
block|{
case|case
name|SUCCESS
case|:
name|consumer
operator|=
parameter_list|(
name|arg
parameter_list|)
lambda|->
name|LOG
operator|.
name|info
argument_list|(
literal|"CertificateServer validation is "
operator|+
literal|"successful"
argument_list|)
expr_stmt|;
break|break;
case|case
name|MISSING_KEYS
case|:
name|consumer
operator|=
parameter_list|(
name|arg
parameter_list|)
lambda|->
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"We have found the Certificate for this CertificateServer, "
operator|+
literal|"but keys used by this CertificateServer is missing. This is a "
operator|+
literal|"non-recoverable error. Please restart the system after locating "
operator|+
literal|"the Keys used by the CertificateServer."
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|error
argument_list|(
literal|"Exiting due to unrecoverable CertificateServer error."
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Missing Keys, cannot continue."
argument_list|)
throw|;
block|}
expr_stmt|;
break|break;
case|case
name|MISSING_CERTIFICATE
case|:
name|consumer
operator|=
parameter_list|(
name|arg
parameter_list|)
lambda|->
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"We found the keys, but the root certificate for this "
operator|+
literal|"CertificateServer is missing. Please restart SCM after locating "
operator|+
literal|"the "
operator|+
literal|"Certificates."
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|error
argument_list|(
literal|"Exiting due to unrecoverable CertificateServer error."
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Missing Root Certs, cannot continue."
argument_list|)
throw|;
block|}
expr_stmt|;
break|break;
case|case
name|INITIALIZE
case|:
name|consumer
operator|=
parameter_list|(
name|arg
parameter_list|)
lambda|->
block|{
try|try
block|{
name|generateSelfSignedCA
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NoSuchProviderException
decl||
name|NoSuchAlgorithmException
decl||
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to initialize CertificateServer."
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
name|VerificationStatus
name|newStatus
init|=
name|verifySelfSignedCA
argument_list|(
name|arg
argument_list|)
decl_stmt|;
if|if
condition|(
name|newStatus
operator|!=
name|VerificationStatus
operator|.
name|SUCCESS
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to initialize CertificateServer, failed in "
operator|+
literal|"verification."
argument_list|)
expr_stmt|;
block|}
block|}
expr_stmt|;
break|break;
default|default:
comment|/* Make CheckStyle happy */
break|break;
block|}
return|return
name|consumer
return|;
block|}
comment|/**    * Generates a KeyPair for the Certificate.    *    * @param securityConfig - SecurityConfig.    * @return Key Pair.    * @throws NoSuchProviderException  - on Error.    * @throws NoSuchAlgorithmException - on Error.    * @throws IOException              - on Error.    */
DECL|method|generateKeys (SecurityConfig securityConfig)
specifier|private
name|KeyPair
name|generateKeys
parameter_list|(
name|SecurityConfig
name|securityConfig
parameter_list|)
throws|throws
name|NoSuchProviderException
throws|,
name|NoSuchAlgorithmException
throws|,
name|IOException
block|{
name|HDDSKeyGenerator
name|keyGenerator
init|=
operator|new
name|HDDSKeyGenerator
argument_list|(
name|securityConfig
argument_list|)
decl_stmt|;
name|KeyPair
name|keys
init|=
name|keyGenerator
operator|.
name|generateKey
argument_list|()
decl_stmt|;
name|KeyCodec
name|keyPEMWriter
init|=
operator|new
name|KeyCodec
argument_list|(
name|securityConfig
argument_list|,
name|componentName
argument_list|)
decl_stmt|;
name|keyPEMWriter
operator|.
name|writeKey
argument_list|(
name|keys
argument_list|)
expr_stmt|;
return|return
name|keys
return|;
block|}
comment|/**    * Generates a self-signed Root Certificate for CA.    *    * @param securityConfig - SecurityConfig    * @param key - KeyPair.    * @throws IOException          - on Error.    * @throws SCMSecurityException - on Error.    */
DECL|method|generateRootCertificate (SecurityConfig securityConfig, KeyPair key)
specifier|private
name|void
name|generateRootCertificate
parameter_list|(
name|SecurityConfig
name|securityConfig
parameter_list|,
name|KeyPair
name|key
parameter_list|)
throws|throws
name|IOException
throws|,
name|SCMSecurityException
block|{
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|this
operator|.
name|config
argument_list|)
expr_stmt|;
name|LocalDate
name|beginDate
init|=
name|LocalDate
operator|.
name|now
argument_list|()
operator|.
name|atStartOfDay
argument_list|()
operator|.
name|toLocalDate
argument_list|()
decl_stmt|;
name|LocalDateTime
name|temp
init|=
name|LocalDateTime
operator|.
name|of
argument_list|(
name|beginDate
argument_list|,
name|LocalTime
operator|.
name|MIDNIGHT
argument_list|)
decl_stmt|;
name|LocalDate
name|endDate
init|=
name|temp
operator|.
name|plus
argument_list|(
name|securityConfig
operator|.
name|getMaxCertificateDuration
argument_list|()
argument_list|)
operator|.
name|toLocalDate
argument_list|()
decl_stmt|;
name|X509CertificateHolder
name|selfSignedCertificate
init|=
name|SelfSignedCertificate
operator|.
name|newBuilder
argument_list|()
operator|.
name|setSubject
argument_list|(
name|this
operator|.
name|subject
argument_list|)
operator|.
name|setScmID
argument_list|(
name|this
operator|.
name|scmID
argument_list|)
operator|.
name|setClusterID
argument_list|(
name|this
operator|.
name|clusterID
argument_list|)
operator|.
name|setBeginDate
argument_list|(
name|beginDate
argument_list|)
operator|.
name|setEndDate
argument_list|(
name|endDate
argument_list|)
operator|.
name|makeCA
argument_list|()
operator|.
name|setConfiguration
argument_list|(
name|securityConfig
operator|.
name|getConfiguration
argument_list|()
argument_list|)
operator|.
name|setKey
argument_list|(
name|key
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|CertificateCodec
name|certCodec
init|=
operator|new
name|CertificateCodec
argument_list|(
name|config
argument_list|,
name|componentName
argument_list|)
decl_stmt|;
name|certCodec
operator|.
name|writeCertificate
argument_list|(
name|selfSignedCertificate
argument_list|)
expr_stmt|;
block|}
comment|/**    * This represents the verification status of the CA. Based on this enum    * appropriate action is taken in the Init.    */
annotation|@
name|VisibleForTesting
DECL|enum|VerificationStatus
enum|enum
name|VerificationStatus
block|{
DECL|enumConstant|SUCCESS
name|SUCCESS
block|,
comment|/* All artifacts needed by CertificateServer is present */
DECL|enumConstant|MISSING_KEYS
name|MISSING_KEYS
block|,
comment|/* Private key is missing, certificate Exists.*/
DECL|enumConstant|MISSING_CERTIFICATE
name|MISSING_CERTIFICATE
block|,
comment|/* Keys exist, but root certificate missing.*/
DECL|enumConstant|INITIALIZE
name|INITIALIZE
comment|/* All artifacts are missing, we should init the system. */
block|}
block|}
end_class

end_unit

