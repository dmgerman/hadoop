begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  *  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdds.security.x509.certificate.client
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdds
operator|.
name|security
operator|.
name|x509
operator|.
name|certificate
operator|.
name|client
package|;
end_package

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang3
operator|.
name|RandomStringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|validator
operator|.
name|routines
operator|.
name|DomainValidator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdds
operator|.
name|security
operator|.
name|x509
operator|.
name|SecurityConfig
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdds
operator|.
name|security
operator|.
name|x509
operator|.
name|certificate
operator|.
name|utils
operator|.
name|CertificateCodec
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdds
operator|.
name|security
operator|.
name|x509
operator|.
name|certificates
operator|.
name|utils
operator|.
name|CertificateSignRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdds
operator|.
name|security
operator|.
name|x509
operator|.
name|exceptions
operator|.
name|CertificateException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdds
operator|.
name|security
operator|.
name|x509
operator|.
name|keys
operator|.
name|HDDSKeyGenerator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdds
operator|.
name|security
operator|.
name|x509
operator|.
name|keys
operator|.
name|KeyCodec
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdds
operator|.
name|HddsUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdds
operator|.
name|conf
operator|.
name|OzoneConfiguration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdds
operator|.
name|protocol
operator|.
name|SCMSecurityProtocol
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdds
operator|.
name|protocolPB
operator|.
name|SCMSecurityProtocolClientSideTranslatorPB
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdds
operator|.
name|protocolPB
operator|.
name|SCMSecurityProtocolPB
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdds
operator|.
name|scm
operator|.
name|protocolPB
operator|.
name|ScmBlockLocationProtocolPB
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|Client
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|ProtobufRpcEngine
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|RPC
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|net
operator|.
name|NetUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ozone
operator|.
name|OzoneSecurityUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|UserGroupInformation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|bouncycastle
operator|.
name|cert
operator|.
name|X509CertificateHolder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|InetSocketAddress
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|StandardCharsets
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|Files
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|InvalidKeyException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|KeyPair
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|NoSuchAlgorithmException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|NoSuchProviderException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|PrivateKey
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|PublicKey
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|Signature
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|SignatureException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|cert
operator|.
name|CertStore
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|cert
operator|.
name|X509Certificate
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|spec
operator|.
name|InvalidKeySpecException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Objects
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentHashMap
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdds
operator|.
name|security
operator|.
name|x509
operator|.
name|certificate
operator|.
name|client
operator|.
name|CertificateClient
operator|.
name|InitResponse
operator|.
name|FAILURE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdds
operator|.
name|security
operator|.
name|x509
operator|.
name|certificate
operator|.
name|client
operator|.
name|CertificateClient
operator|.
name|InitResponse
operator|.
name|GETCERT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdds
operator|.
name|security
operator|.
name|x509
operator|.
name|certificate
operator|.
name|client
operator|.
name|CertificateClient
operator|.
name|InitResponse
operator|.
name|SUCCESS
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdds
operator|.
name|security
operator|.
name|x509
operator|.
name|exceptions
operator|.
name|CertificateException
operator|.
name|ErrorCode
operator|.
name|*
import|;
end_import

begin_comment
comment|/**  * Default Certificate client implementation. It provides certificate  * operations that needs to be performed by certificate clients in the Ozone  * eco-system.  */
end_comment

begin_class
DECL|class|DefaultCertificateClient
specifier|public
specifier|abstract
class|class
name|DefaultCertificateClient
implements|implements
name|CertificateClient
block|{
DECL|field|CERT_FILE_NAME_FORMAT
specifier|private
specifier|static
specifier|final
name|String
name|CERT_FILE_NAME_FORMAT
init|=
literal|"%s.crt"
decl_stmt|;
DECL|field|CA_CERT_PREFIX
specifier|private
specifier|static
specifier|final
name|String
name|CA_CERT_PREFIX
init|=
literal|"CA-"
decl_stmt|;
DECL|field|logger
specifier|private
specifier|final
name|Logger
name|logger
decl_stmt|;
DECL|field|securityConfig
specifier|private
specifier|final
name|SecurityConfig
name|securityConfig
decl_stmt|;
DECL|field|keyCodec
specifier|private
specifier|final
name|KeyCodec
name|keyCodec
decl_stmt|;
DECL|field|privateKey
specifier|private
name|PrivateKey
name|privateKey
decl_stmt|;
DECL|field|publicKey
specifier|private
name|PublicKey
name|publicKey
decl_stmt|;
DECL|field|x509Certificate
specifier|private
name|X509Certificate
name|x509Certificate
decl_stmt|;
DECL|field|certificateMap
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|X509Certificate
argument_list|>
name|certificateMap
decl_stmt|;
DECL|field|certSerialId
specifier|private
name|String
name|certSerialId
decl_stmt|;
DECL|method|DefaultCertificateClient (SecurityConfig securityConfig, Logger log, String certSerialId)
name|DefaultCertificateClient
parameter_list|(
name|SecurityConfig
name|securityConfig
parameter_list|,
name|Logger
name|log
parameter_list|,
name|String
name|certSerialId
parameter_list|)
block|{
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|securityConfig
argument_list|)
expr_stmt|;
name|this
operator|.
name|securityConfig
operator|=
name|securityConfig
expr_stmt|;
name|keyCodec
operator|=
operator|new
name|KeyCodec
argument_list|(
name|securityConfig
argument_list|)
expr_stmt|;
name|this
operator|.
name|logger
operator|=
name|log
expr_stmt|;
name|this
operator|.
name|certificateMap
operator|=
operator|new
name|ConcurrentHashMap
argument_list|<>
argument_list|()
expr_stmt|;
name|this
operator|.
name|certSerialId
operator|=
name|certSerialId
expr_stmt|;
name|loadAllCertificates
argument_list|()
expr_stmt|;
block|}
comment|/**    * Load all certificates from configured location.    * */
DECL|method|loadAllCertificates ()
specifier|private
name|void
name|loadAllCertificates
parameter_list|()
block|{
comment|// See if certs directory exists in file system.
name|Path
name|certPath
init|=
name|securityConfig
operator|.
name|getCertificateLocation
argument_list|()
decl_stmt|;
if|if
condition|(
name|Files
operator|.
name|exists
argument_list|(
name|certPath
argument_list|)
operator|&&
name|Files
operator|.
name|isDirectory
argument_list|(
name|certPath
argument_list|)
condition|)
block|{
name|getLogger
argument_list|()
operator|.
name|info
argument_list|(
literal|"Loading certificate from location:{}."
argument_list|,
name|certPath
argument_list|)
expr_stmt|;
name|File
index|[]
name|certFiles
init|=
name|certPath
operator|.
name|toFile
argument_list|()
operator|.
name|listFiles
argument_list|()
decl_stmt|;
if|if
condition|(
name|certFiles
operator|!=
literal|null
condition|)
block|{
name|CertificateCodec
name|certificateCodec
init|=
operator|new
name|CertificateCodec
argument_list|(
name|securityConfig
argument_list|)
decl_stmt|;
for|for
control|(
name|File
name|file
range|:
name|certFiles
control|)
block|{
if|if
condition|(
name|file
operator|.
name|isFile
argument_list|()
condition|)
block|{
try|try
block|{
name|X509CertificateHolder
name|x509CertificateHolder
init|=
name|certificateCodec
operator|.
name|readCertificate
argument_list|(
name|certPath
argument_list|,
name|file
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
name|X509Certificate
name|cert
init|=
name|CertificateCodec
operator|.
name|getX509Certificate
argument_list|(
name|x509CertificateHolder
argument_list|)
decl_stmt|;
if|if
condition|(
name|cert
operator|!=
literal|null
operator|&&
name|cert
operator|.
name|getSerialNumber
argument_list|()
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|cert
operator|.
name|getSerialNumber
argument_list|()
operator|.
name|toString
argument_list|()
operator|.
name|equals
argument_list|(
name|certSerialId
argument_list|)
condition|)
block|{
name|x509Certificate
operator|=
name|cert
expr_stmt|;
block|}
name|certificateMap
operator|.
name|putIfAbsent
argument_list|(
name|cert
operator|.
name|getSerialNumber
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|,
name|cert
argument_list|)
expr_stmt|;
name|getLogger
argument_list|()
operator|.
name|info
argument_list|(
literal|"Added certificate from file:{}."
argument_list|,
name|file
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|getLogger
argument_list|()
operator|.
name|error
argument_list|(
literal|"Error reading certificate from file:{}"
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|java
operator|.
name|security
operator|.
name|cert
operator|.
name|CertificateException
decl||
name|IOException
name|e
parameter_list|)
block|{
name|getLogger
argument_list|()
operator|.
name|error
argument_list|(
literal|"Error reading certificate from file:{}."
argument_list|,
name|file
operator|.
name|getAbsolutePath
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
comment|/**    * Returns the private key of the specified  if it exists on the local    * system.    *    * @return private key or Null if there is no data.    */
annotation|@
name|Override
DECL|method|getPrivateKey ()
specifier|public
name|PrivateKey
name|getPrivateKey
parameter_list|()
block|{
if|if
condition|(
name|privateKey
operator|!=
literal|null
condition|)
block|{
return|return
name|privateKey
return|;
block|}
name|Path
name|keyPath
init|=
name|securityConfig
operator|.
name|getKeyLocation
argument_list|()
decl_stmt|;
if|if
condition|(
name|OzoneSecurityUtil
operator|.
name|checkIfFileExist
argument_list|(
name|keyPath
argument_list|,
name|securityConfig
operator|.
name|getPrivateKeyFileName
argument_list|()
argument_list|)
condition|)
block|{
try|try
block|{
name|privateKey
operator|=
name|keyCodec
operator|.
name|readPrivateKey
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InvalidKeySpecException
decl||
name|NoSuchAlgorithmException
decl||
name|IOException
name|e
parameter_list|)
block|{
name|getLogger
argument_list|()
operator|.
name|error
argument_list|(
literal|"Error while getting private key."
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|privateKey
return|;
block|}
comment|/**    * Returns the public key of the specified if it exists on the local system.    *    * @return public key or Null if there is no data.    */
annotation|@
name|Override
DECL|method|getPublicKey ()
specifier|public
name|PublicKey
name|getPublicKey
parameter_list|()
block|{
if|if
condition|(
name|publicKey
operator|!=
literal|null
condition|)
block|{
return|return
name|publicKey
return|;
block|}
name|Path
name|keyPath
init|=
name|securityConfig
operator|.
name|getKeyLocation
argument_list|()
decl_stmt|;
if|if
condition|(
name|OzoneSecurityUtil
operator|.
name|checkIfFileExist
argument_list|(
name|keyPath
argument_list|,
name|securityConfig
operator|.
name|getPublicKeyFileName
argument_list|()
argument_list|)
condition|)
block|{
try|try
block|{
name|publicKey
operator|=
name|keyCodec
operator|.
name|readPublicKey
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InvalidKeySpecException
decl||
name|NoSuchAlgorithmException
decl||
name|IOException
name|e
parameter_list|)
block|{
name|getLogger
argument_list|()
operator|.
name|error
argument_list|(
literal|"Error while getting public key."
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|publicKey
return|;
block|}
comment|/**    * Returns the default certificate of given client if it exists.    *    * @return certificate or Null if there is no data.    */
annotation|@
name|Override
DECL|method|getCertificate ()
specifier|public
name|X509Certificate
name|getCertificate
parameter_list|()
block|{
if|if
condition|(
name|x509Certificate
operator|!=
literal|null
condition|)
block|{
return|return
name|x509Certificate
return|;
block|}
if|if
condition|(
name|certSerialId
operator|==
literal|null
condition|)
block|{
name|getLogger
argument_list|()
operator|.
name|error
argument_list|(
literal|"Default certificate serial id is not set. Can't "
operator|+
literal|"locate the default certificate for this client."
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
comment|// Refresh the cache from file system.
name|loadAllCertificates
argument_list|()
expr_stmt|;
if|if
condition|(
name|certificateMap
operator|.
name|containsKey
argument_list|(
name|certSerialId
argument_list|)
condition|)
block|{
name|x509Certificate
operator|=
name|certificateMap
operator|.
name|get
argument_list|(
name|certSerialId
argument_list|)
expr_stmt|;
block|}
return|return
name|x509Certificate
return|;
block|}
comment|/**    * Returns the certificate  with the specified certificate serial id if it    * exists else try to get it from SCM.    * @param  certId    *    * @return certificate or Null if there is no data.    */
annotation|@
name|Override
DECL|method|getCertificate (String certId)
specifier|public
name|X509Certificate
name|getCertificate
parameter_list|(
name|String
name|certId
parameter_list|)
throws|throws
name|CertificateException
block|{
comment|// Check if it is in cache.
if|if
condition|(
name|certificateMap
operator|.
name|containsKey
argument_list|(
name|certId
argument_list|)
condition|)
block|{
return|return
name|certificateMap
operator|.
name|get
argument_list|(
name|certId
argument_list|)
return|;
block|}
comment|// Try to get it from SCM.
return|return
name|this
operator|.
name|getCertificateFromScm
argument_list|(
name|certId
argument_list|)
return|;
block|}
comment|/**    * Get certificate from SCM and store it in local file system.    * @param certId    * @return certificate    */
DECL|method|getCertificateFromScm (String certId)
specifier|private
name|X509Certificate
name|getCertificateFromScm
parameter_list|(
name|String
name|certId
parameter_list|)
throws|throws
name|CertificateException
block|{
name|getLogger
argument_list|()
operator|.
name|info
argument_list|(
literal|"Getting certificate with certSerialId:{}."
argument_list|,
name|certId
argument_list|)
expr_stmt|;
try|try
block|{
name|SCMSecurityProtocol
name|scmSecurityProtocolClient
init|=
name|getScmSecurityClient
argument_list|(
operator|(
name|OzoneConfiguration
operator|)
name|securityConfig
operator|.
name|getConfiguration
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|pemEncodedCert
init|=
name|scmSecurityProtocolClient
operator|.
name|getCertificate
argument_list|(
name|certId
argument_list|)
decl_stmt|;
name|this
operator|.
name|storeCertificate
argument_list|(
name|pemEncodedCert
argument_list|,
literal|true
argument_list|)
expr_stmt|;
return|return
name|CertificateCodec
operator|.
name|getX509Certificate
argument_list|(
name|pemEncodedCert
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|getLogger
argument_list|()
operator|.
name|error
argument_list|(
literal|"Error while getting Certificate with "
operator|+
literal|"certSerialId:{} from scm."
argument_list|,
name|certId
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|CertificateException
argument_list|(
literal|"Error while getting certificate for "
operator|+
literal|"certSerialId:"
operator|+
name|certId
argument_list|,
name|e
argument_list|,
name|CERTIFICATE_ERROR
argument_list|)
throw|;
block|}
block|}
comment|/**    * Verifies if this certificate is part of a trusted chain.    *    * @param certificate - certificate.    * @return true if it trusted, false otherwise.    */
annotation|@
name|Override
DECL|method|verifyCertificate (X509Certificate certificate)
specifier|public
name|boolean
name|verifyCertificate
parameter_list|(
name|X509Certificate
name|certificate
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"Operation not supported."
argument_list|)
throw|;
block|}
comment|/**    * Creates digital signature over the data stream using the s private key.    *    * @param stream - Data stream to sign.    * @throws CertificateException - on Error.    */
annotation|@
name|Override
DECL|method|signDataStream (InputStream stream)
specifier|public
name|byte
index|[]
name|signDataStream
parameter_list|(
name|InputStream
name|stream
parameter_list|)
throws|throws
name|CertificateException
block|{
try|try
block|{
name|Signature
name|sign
init|=
name|Signature
operator|.
name|getInstance
argument_list|(
name|securityConfig
operator|.
name|getSignatureAlgo
argument_list|()
argument_list|,
name|securityConfig
operator|.
name|getProvider
argument_list|()
argument_list|)
decl_stmt|;
name|sign
operator|.
name|initSign
argument_list|(
name|getPrivateKey
argument_list|()
argument_list|)
expr_stmt|;
name|byte
index|[]
name|buffer
init|=
operator|new
name|byte
index|[
literal|1024
operator|*
literal|4
index|]
decl_stmt|;
name|int
name|len
decl_stmt|;
while|while
condition|(
operator|-
literal|1
operator|!=
operator|(
name|len
operator|=
name|stream
operator|.
name|read
argument_list|(
name|buffer
argument_list|)
operator|)
condition|)
block|{
name|sign
operator|.
name|update
argument_list|(
name|buffer
argument_list|,
literal|0
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
return|return
name|sign
operator|.
name|sign
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|NoSuchAlgorithmException
decl||
name|NoSuchProviderException
decl||
name|InvalidKeyException
decl||
name|SignatureException
decl||
name|IOException
name|e
parameter_list|)
block|{
name|getLogger
argument_list|()
operator|.
name|error
argument_list|(
literal|"Error while signing the stream"
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|CertificateException
argument_list|(
literal|"Error while signing the stream"
argument_list|,
name|e
argument_list|,
name|CRYPTO_SIGN_ERROR
argument_list|)
throw|;
block|}
block|}
comment|/**    * Creates digital signature over the data stream using the s private key.    *    * @param data - Data to sign.    * @throws CertificateException - on Error.    */
annotation|@
name|Override
DECL|method|signData (byte[] data)
specifier|public
name|byte
index|[]
name|signData
parameter_list|(
name|byte
index|[]
name|data
parameter_list|)
throws|throws
name|CertificateException
block|{
try|try
block|{
name|Signature
name|sign
init|=
name|Signature
operator|.
name|getInstance
argument_list|(
name|securityConfig
operator|.
name|getSignatureAlgo
argument_list|()
argument_list|,
name|securityConfig
operator|.
name|getProvider
argument_list|()
argument_list|)
decl_stmt|;
name|sign
operator|.
name|initSign
argument_list|(
name|getPrivateKey
argument_list|()
argument_list|)
expr_stmt|;
name|sign
operator|.
name|update
argument_list|(
name|data
argument_list|)
expr_stmt|;
return|return
name|sign
operator|.
name|sign
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|NoSuchAlgorithmException
decl||
name|NoSuchProviderException
decl||
name|InvalidKeyException
decl||
name|SignatureException
name|e
parameter_list|)
block|{
name|getLogger
argument_list|()
operator|.
name|error
argument_list|(
literal|"Error while signing the stream"
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|CertificateException
argument_list|(
literal|"Error while signing the stream"
argument_list|,
name|e
argument_list|,
name|CRYPTO_SIGN_ERROR
argument_list|)
throw|;
block|}
block|}
comment|/**    * Verifies a digital Signature, given the signature and the certificate of    * the signer.    *    * @param stream - Data Stream.    * @param signature - Byte Array containing the signature.    * @param cert - Certificate of the Signer.    * @return true if verified, false if not.    */
annotation|@
name|Override
DECL|method|verifySignature (InputStream stream, byte[] signature, X509Certificate cert)
specifier|public
name|boolean
name|verifySignature
parameter_list|(
name|InputStream
name|stream
parameter_list|,
name|byte
index|[]
name|signature
parameter_list|,
name|X509Certificate
name|cert
parameter_list|)
throws|throws
name|CertificateException
block|{
try|try
block|{
name|Signature
name|sign
init|=
name|Signature
operator|.
name|getInstance
argument_list|(
name|securityConfig
operator|.
name|getSignatureAlgo
argument_list|()
argument_list|,
name|securityConfig
operator|.
name|getProvider
argument_list|()
argument_list|)
decl_stmt|;
name|sign
operator|.
name|initVerify
argument_list|(
name|cert
argument_list|)
expr_stmt|;
name|byte
index|[]
name|buffer
init|=
operator|new
name|byte
index|[
literal|1024
operator|*
literal|4
index|]
decl_stmt|;
name|int
name|len
decl_stmt|;
while|while
condition|(
operator|-
literal|1
operator|!=
operator|(
name|len
operator|=
name|stream
operator|.
name|read
argument_list|(
name|buffer
argument_list|)
operator|)
condition|)
block|{
name|sign
operator|.
name|update
argument_list|(
name|buffer
argument_list|,
literal|0
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
return|return
name|sign
operator|.
name|verify
argument_list|(
name|signature
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|NoSuchAlgorithmException
decl||
name|NoSuchProviderException
decl||
name|InvalidKeyException
decl||
name|SignatureException
decl||
name|IOException
name|e
parameter_list|)
block|{
name|getLogger
argument_list|()
operator|.
name|error
argument_list|(
literal|"Error while signing the stream"
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|CertificateException
argument_list|(
literal|"Error while signing the stream"
argument_list|,
name|e
argument_list|,
name|CRYPTO_SIGNATURE_VERIFICATION_ERROR
argument_list|)
throw|;
block|}
block|}
comment|/**    * Verifies a digital Signature, given the signature and the certificate of    * the signer.    *    * @param data - Data in byte array.    * @param signature - Byte Array containing the signature.    * @param cert - Certificate of the Signer.    * @return true if verified, false if not.    */
annotation|@
name|Override
DECL|method|verifySignature (byte[] data, byte[] signature, X509Certificate cert)
specifier|public
name|boolean
name|verifySignature
parameter_list|(
name|byte
index|[]
name|data
parameter_list|,
name|byte
index|[]
name|signature
parameter_list|,
name|X509Certificate
name|cert
parameter_list|)
throws|throws
name|CertificateException
block|{
try|try
block|{
name|Signature
name|sign
init|=
name|Signature
operator|.
name|getInstance
argument_list|(
name|securityConfig
operator|.
name|getSignatureAlgo
argument_list|()
argument_list|,
name|securityConfig
operator|.
name|getProvider
argument_list|()
argument_list|)
decl_stmt|;
name|sign
operator|.
name|initVerify
argument_list|(
name|cert
argument_list|)
expr_stmt|;
name|sign
operator|.
name|update
argument_list|(
name|data
argument_list|)
expr_stmt|;
return|return
name|sign
operator|.
name|verify
argument_list|(
name|signature
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|NoSuchAlgorithmException
decl||
name|NoSuchProviderException
decl||
name|InvalidKeyException
decl||
name|SignatureException
name|e
parameter_list|)
block|{
name|getLogger
argument_list|()
operator|.
name|error
argument_list|(
literal|"Error while signing the stream"
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|CertificateException
argument_list|(
literal|"Error while signing the stream"
argument_list|,
name|e
argument_list|,
name|CRYPTO_SIGNATURE_VERIFICATION_ERROR
argument_list|)
throw|;
block|}
block|}
comment|/**    * Verifies a digital Signature, given the signature and the certificate of    * the signer.    *    * @param data - Data in byte array.    * @param signature - Byte Array containing the signature.    * @param pubKey - Certificate of the Signer.    * @return true if verified, false if not.    */
DECL|method|verifySignature (byte[] data, byte[] signature, PublicKey pubKey)
specifier|private
name|boolean
name|verifySignature
parameter_list|(
name|byte
index|[]
name|data
parameter_list|,
name|byte
index|[]
name|signature
parameter_list|,
name|PublicKey
name|pubKey
parameter_list|)
throws|throws
name|CertificateException
block|{
try|try
block|{
name|Signature
name|sign
init|=
name|Signature
operator|.
name|getInstance
argument_list|(
name|securityConfig
operator|.
name|getSignatureAlgo
argument_list|()
argument_list|,
name|securityConfig
operator|.
name|getProvider
argument_list|()
argument_list|)
decl_stmt|;
name|sign
operator|.
name|initVerify
argument_list|(
name|pubKey
argument_list|)
expr_stmt|;
name|sign
operator|.
name|update
argument_list|(
name|data
argument_list|)
expr_stmt|;
return|return
name|sign
operator|.
name|verify
argument_list|(
name|signature
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|NoSuchAlgorithmException
decl||
name|NoSuchProviderException
decl||
name|InvalidKeyException
decl||
name|SignatureException
name|e
parameter_list|)
block|{
name|getLogger
argument_list|()
operator|.
name|error
argument_list|(
literal|"Error while signing the stream"
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|CertificateException
argument_list|(
literal|"Error while signing the stream"
argument_list|,
name|e
argument_list|,
name|CRYPTO_SIGNATURE_VERIFICATION_ERROR
argument_list|)
throw|;
block|}
block|}
comment|/**    * Returns a CSR builder that can be used to creates a Certificate signing    * request.    *    * @return CertificateSignRequest.Builder    */
annotation|@
name|Override
DECL|method|getCSRBuilder ()
specifier|public
name|CertificateSignRequest
operator|.
name|Builder
name|getCSRBuilder
parameter_list|()
throws|throws
name|CertificateException
block|{
name|CertificateSignRequest
operator|.
name|Builder
name|builder
init|=
operator|new
name|CertificateSignRequest
operator|.
name|Builder
argument_list|()
operator|.
name|setConfiguration
argument_list|(
name|securityConfig
operator|.
name|getConfiguration
argument_list|()
argument_list|)
decl_stmt|;
try|try
block|{
name|DomainValidator
name|validator
init|=
name|DomainValidator
operator|.
name|getInstance
argument_list|()
decl_stmt|;
comment|// Add all valid ips.
name|OzoneSecurityUtil
operator|.
name|getValidInetsForCurrentHost
argument_list|()
operator|.
name|forEach
argument_list|(
name|ip
lambda|->
block|{
name|builder
operator|.
name|addIpAddress
argument_list|(
name|ip
operator|.
name|getHostAddress
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|validator
operator|.
name|isValid
argument_list|(
name|ip
operator|.
name|getCanonicalHostName
argument_list|()
argument_list|)
condition|)
block|{
name|builder
operator|.
name|addDnsName
argument_list|(
name|ip
operator|.
name|getCanonicalHostName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|CertificateException
argument_list|(
literal|"Error while adding ip to CSR builder"
argument_list|,
name|e
argument_list|,
name|CSR_ERROR
argument_list|)
throw|;
block|}
return|return
name|builder
return|;
block|}
comment|/**    * Get the certificate of well-known entity from SCM.    *    * @param query - String Query, please see the implementation for the    * discussion on the query formats.    * @return X509Certificate or null if not found.    */
annotation|@
name|Override
DECL|method|queryCertificate (String query)
specifier|public
name|X509Certificate
name|queryCertificate
parameter_list|(
name|String
name|query
parameter_list|)
block|{
comment|// TODO:
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"Operation not supported"
argument_list|)
throw|;
block|}
comment|/**    * Stores the Certificate  for this client. Don't use this api to add trusted    * certificates of others.    *    * @param pemEncodedCert        - pem encoded X509 Certificate    * @param force                 - override any existing file    * @throws CertificateException - on Error.    *    */
annotation|@
name|Override
DECL|method|storeCertificate (String pemEncodedCert, boolean force)
specifier|public
name|void
name|storeCertificate
parameter_list|(
name|String
name|pemEncodedCert
parameter_list|,
name|boolean
name|force
parameter_list|)
throws|throws
name|CertificateException
block|{
name|this
operator|.
name|storeCertificate
argument_list|(
name|pemEncodedCert
argument_list|,
name|force
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/**    * Stores the Certificate  for this client. Don't use this api to add trusted    * certificates of others.    *    * @param pemEncodedCert        - pem encoded X509 Certificate    * @param force                 - override any existing file    * @param caCert                - Is CA certificate.    * @throws CertificateException - on Error.    *    */
annotation|@
name|Override
DECL|method|storeCertificate (String pemEncodedCert, boolean force, boolean caCert)
specifier|public
name|void
name|storeCertificate
parameter_list|(
name|String
name|pemEncodedCert
parameter_list|,
name|boolean
name|force
parameter_list|,
name|boolean
name|caCert
parameter_list|)
throws|throws
name|CertificateException
block|{
name|CertificateCodec
name|certificateCodec
init|=
operator|new
name|CertificateCodec
argument_list|(
name|securityConfig
argument_list|)
decl_stmt|;
try|try
block|{
name|Path
name|basePath
init|=
name|securityConfig
operator|.
name|getCertificateLocation
argument_list|()
decl_stmt|;
name|X509Certificate
name|cert
init|=
name|CertificateCodec
operator|.
name|getX509Certificate
argument_list|(
name|pemEncodedCert
argument_list|)
decl_stmt|;
name|String
name|certName
init|=
name|String
operator|.
name|format
argument_list|(
name|CERT_FILE_NAME_FORMAT
argument_list|,
name|cert
operator|.
name|getSerialNumber
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|caCert
condition|)
block|{
name|certName
operator|=
name|CA_CERT_PREFIX
operator|+
name|certName
expr_stmt|;
block|}
name|certificateCodec
operator|.
name|writeCertificate
argument_list|(
name|basePath
argument_list|,
name|certName
argument_list|,
name|pemEncodedCert
argument_list|,
name|force
argument_list|)
expr_stmt|;
name|certificateMap
operator|.
name|putIfAbsent
argument_list|(
name|cert
operator|.
name|getSerialNumber
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|,
name|cert
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
decl||
name|java
operator|.
name|security
operator|.
name|cert
operator|.
name|CertificateException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|CertificateException
argument_list|(
literal|"Error while storing certificate."
argument_list|,
name|e
argument_list|,
name|CERTIFICATE_ERROR
argument_list|)
throw|;
block|}
block|}
comment|/**    * Stores the trusted chain of certificates for a specific .    *    * @param ks - Key Store.    * @throws CertificateException - on Error.    */
annotation|@
name|Override
DECL|method|storeTrustChain (CertStore ks)
specifier|public
specifier|synchronized
name|void
name|storeTrustChain
parameter_list|(
name|CertStore
name|ks
parameter_list|)
throws|throws
name|CertificateException
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"Operation not supported."
argument_list|)
throw|;
block|}
comment|/**    * Stores the trusted chain of certificates for a specific .    *    * @param certificates - List of Certificates.    * @throws CertificateException - on Error.    */
annotation|@
name|Override
DECL|method|storeTrustChain (List<X509Certificate> certificates)
specifier|public
specifier|synchronized
name|void
name|storeTrustChain
parameter_list|(
name|List
argument_list|<
name|X509Certificate
argument_list|>
name|certificates
parameter_list|)
throws|throws
name|CertificateException
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"Operation not supported."
argument_list|)
throw|;
block|}
comment|/**    * Defines 8 cases of initialization.    * Each case specifies objects found.    * 0. NONE                  Keypair as well as certificate not found.    * 1. CERT                  Certificate found but keypair missing.    * 2. PUBLIC_KEY            Public key found but private key and    *                          certificate is missing.    * 3. PUBLICKEY_CERT        Only public key and certificate is present.    * 4. PRIVATE_KEY           Only private key is present.    * 5. PRIVATEKEY_CERT       Only private key and certificate is present.    * 6. PUBLICKEY_PRIVATEKEY  indicates private and public key were read    *                          successfully from configured location but    *                          Certificate.    * 7. All                   Keypair as well as certificate is present.    *    * */
DECL|enum|InitCase
specifier|protected
enum|enum
name|InitCase
block|{
DECL|enumConstant|NONE
name|NONE
block|,
DECL|enumConstant|CERT
name|CERT
block|,
DECL|enumConstant|PUBLIC_KEY
name|PUBLIC_KEY
block|,
DECL|enumConstant|PUBLICKEY_CERT
name|PUBLICKEY_CERT
block|,
DECL|enumConstant|PRIVATE_KEY
name|PRIVATE_KEY
block|,
DECL|enumConstant|PRIVATEKEY_CERT
name|PRIVATEKEY_CERT
block|,
DECL|enumConstant|PUBLICKEY_PRIVATEKEY
name|PUBLICKEY_PRIVATEKEY
block|,
DECL|enumConstant|ALL
name|ALL
block|}
comment|/**    *    * Initializes client by performing following actions.    * 1. Create key dir if not created already.    * 2. Generates and stores a keypair.    * 3. Try to recover public key if private key and certificate is present    *    but public key is missing.    *    * Truth table:    *  +--------------+-----------------+--------------+----------------+    *  | Private Key  | Public Keys     | Certificate  |   Result       |    *  +--------------+-----------------+--------------+----------------+    *  | False  (0)   | False   (0)     | False  (0)   |   GETCERT  000 |    *  | False  (0)   | False   (0)     | True   (1)   |   FAILURE  001 |    *  | False  (0)   | True    (1)     | False  (0)   |   FAILURE  010 |    *  | False  (0)   | True    (1)     | True   (1)   |   FAILURE  011 |    *  | True   (1)   | False   (0)     | False  (0)   |   FAILURE  100 |    *  | True   (1)   | False   (0)     | True   (1)   |   SUCCESS  101 |    *  | True   (1)   | True    (1)     | False  (0)   |   GETCERT  110 |    *  | True   (1)   | True    (1)     | True   (1)   |   SUCCESS  111 |    *  +--------------+-----------------+--------------+----------------+    *    * @return InitResponse    * Returns FAILURE in following cases:    * 1. If private key is missing but public key or certificate is available.    * 2. If public key and certificate is missing.    *    * Returns SUCCESS in following cases:    * 1. If keypair as well certificate is available.    * 2. If private key and certificate is available and public key is    *    recovered successfully.    *    * Returns GETCERT in following cases:    * 1. First time when keypair and certificate is not available, keypair    *    will be generated and stored at configured location.    * 2. When keypair (public/private key) is available but certificate is    *    missing.    *    */
annotation|@
name|Override
DECL|method|init ()
specifier|public
specifier|synchronized
name|InitResponse
name|init
parameter_list|()
throws|throws
name|CertificateException
block|{
name|int
name|initCase
init|=
literal|0
decl_stmt|;
name|PrivateKey
name|pvtKey
init|=
name|getPrivateKey
argument_list|()
decl_stmt|;
name|PublicKey
name|pubKey
init|=
name|getPublicKey
argument_list|()
decl_stmt|;
name|X509Certificate
name|certificate
init|=
name|getCertificate
argument_list|()
decl_stmt|;
if|if
condition|(
name|pvtKey
operator|!=
literal|null
condition|)
block|{
name|initCase
operator|=
name|initCase
operator||
literal|1
operator|<<
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|pubKey
operator|!=
literal|null
condition|)
block|{
name|initCase
operator|=
name|initCase
operator||
literal|1
operator|<<
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|certificate
operator|!=
literal|null
condition|)
block|{
name|initCase
operator|=
name|initCase
operator||
literal|1
expr_stmt|;
block|}
name|getLogger
argument_list|()
operator|.
name|info
argument_list|(
literal|"Certificate client init case: {}"
argument_list|,
name|initCase
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|initCase
operator|<
literal|8
argument_list|,
literal|"Not a "
operator|+
literal|"valid case."
argument_list|)
expr_stmt|;
name|InitCase
name|init
init|=
name|InitCase
operator|.
name|values
argument_list|()
index|[
name|initCase
index|]
decl_stmt|;
return|return
name|handleCase
argument_list|(
name|init
argument_list|)
return|;
block|}
comment|/**    * Default handling of each {@link InitCase}.    * */
DECL|method|handleCase (InitCase init)
specifier|protected
name|InitResponse
name|handleCase
parameter_list|(
name|InitCase
name|init
parameter_list|)
throws|throws
name|CertificateException
block|{
switch|switch
condition|(
name|init
condition|)
block|{
case|case
name|NONE
case|:
name|getLogger
argument_list|()
operator|.
name|info
argument_list|(
literal|"Creating keypair for client as keypair and "
operator|+
literal|"certificate not found."
argument_list|)
expr_stmt|;
name|bootstrapClientKeys
argument_list|()
expr_stmt|;
return|return
name|GETCERT
return|;
case|case
name|CERT
case|:
name|getLogger
argument_list|()
operator|.
name|error
argument_list|(
literal|"Private key not found, while certificate is still"
operator|+
literal|" present. Delete keypair and try again."
argument_list|)
expr_stmt|;
return|return
name|FAILURE
return|;
case|case
name|PUBLIC_KEY
case|:
name|getLogger
argument_list|()
operator|.
name|error
argument_list|(
literal|"Found public key but private key and certificate "
operator|+
literal|"missing."
argument_list|)
expr_stmt|;
return|return
name|FAILURE
return|;
case|case
name|PRIVATE_KEY
case|:
name|getLogger
argument_list|()
operator|.
name|info
argument_list|(
literal|"Found private key but public key and certificate "
operator|+
literal|"is missing."
argument_list|)
expr_stmt|;
comment|// TODO: Recovering public key from private might be possible in some
comment|//  cases.
return|return
name|FAILURE
return|;
case|case
name|PUBLICKEY_CERT
case|:
name|getLogger
argument_list|()
operator|.
name|error
argument_list|(
literal|"Found public key and certificate but private "
operator|+
literal|"key is missing."
argument_list|)
expr_stmt|;
return|return
name|FAILURE
return|;
case|case
name|PRIVATEKEY_CERT
case|:
name|getLogger
argument_list|()
operator|.
name|info
argument_list|(
literal|"Found private key and certificate but public key"
operator|+
literal|" missing."
argument_list|)
expr_stmt|;
if|if
condition|(
name|recoverPublicKey
argument_list|()
condition|)
block|{
return|return
name|SUCCESS
return|;
block|}
else|else
block|{
name|getLogger
argument_list|()
operator|.
name|error
argument_list|(
literal|"Public key recovery failed."
argument_list|)
expr_stmt|;
return|return
name|FAILURE
return|;
block|}
case|case
name|PUBLICKEY_PRIVATEKEY
case|:
name|getLogger
argument_list|()
operator|.
name|info
argument_list|(
literal|"Found private and public key but certificate is"
operator|+
literal|" missing."
argument_list|)
expr_stmt|;
if|if
condition|(
name|validateKeyPair
argument_list|(
name|getPublicKey
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|GETCERT
return|;
block|}
else|else
block|{
name|getLogger
argument_list|()
operator|.
name|info
argument_list|(
literal|"Keypair validation failed."
argument_list|)
expr_stmt|;
return|return
name|FAILURE
return|;
block|}
case|case
name|ALL
case|:
name|getLogger
argument_list|()
operator|.
name|info
argument_list|(
literal|"Found certificate file along with KeyPair."
argument_list|)
expr_stmt|;
if|if
condition|(
name|validateKeyPairAndCertificate
argument_list|()
condition|)
block|{
return|return
name|SUCCESS
return|;
block|}
else|else
block|{
return|return
name|FAILURE
return|;
block|}
default|default:
name|getLogger
argument_list|()
operator|.
name|error
argument_list|(
literal|"Unexpected case: {} (private/public/cert)"
argument_list|,
name|Integer
operator|.
name|toBinaryString
argument_list|(
name|init
operator|.
name|ordinal
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FAILURE
return|;
block|}
block|}
comment|/**    * Validate keypair and certificate.    * */
DECL|method|validateKeyPairAndCertificate ()
specifier|protected
name|boolean
name|validateKeyPairAndCertificate
parameter_list|()
throws|throws
name|CertificateException
block|{
if|if
condition|(
name|validateKeyPair
argument_list|(
name|getPublicKey
argument_list|()
argument_list|)
condition|)
block|{
name|getLogger
argument_list|()
operator|.
name|info
argument_list|(
literal|"Keypair validated."
argument_list|)
expr_stmt|;
comment|// TODO: Certificates cryptographic validity can be checked as well.
if|if
condition|(
name|validateKeyPair
argument_list|(
name|getCertificate
argument_list|()
operator|.
name|getPublicKey
argument_list|()
argument_list|)
condition|)
block|{
name|getLogger
argument_list|()
operator|.
name|info
argument_list|(
literal|"Keypair validated with certificate."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|getLogger
argument_list|()
operator|.
name|error
argument_list|(
literal|"Stored certificate is generated with different "
operator|+
literal|"private key."
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
else|else
block|{
name|getLogger
argument_list|()
operator|.
name|error
argument_list|(
literal|"Keypair validation failed."
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Tries to recover public key from certificate. Also validates recovered    * public key.    * */
DECL|method|recoverPublicKey ()
specifier|protected
name|boolean
name|recoverPublicKey
parameter_list|()
throws|throws
name|CertificateException
block|{
name|PublicKey
name|pubKey
init|=
name|getCertificate
argument_list|()
operator|.
name|getPublicKey
argument_list|()
decl_stmt|;
try|try
block|{
if|if
condition|(
name|validateKeyPair
argument_list|(
name|pubKey
argument_list|)
condition|)
block|{
name|keyCodec
operator|.
name|writePublicKey
argument_list|(
name|pubKey
argument_list|)
expr_stmt|;
name|publicKey
operator|=
name|pubKey
expr_stmt|;
block|}
else|else
block|{
name|getLogger
argument_list|()
operator|.
name|error
argument_list|(
literal|"Can't recover public key "
operator|+
literal|"corresponding to private key."
argument_list|,
name|BOOTSTRAP_ERROR
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|CertificateException
argument_list|(
literal|"Error while trying to recover "
operator|+
literal|"public key."
argument_list|,
name|e
argument_list|,
name|BOOTSTRAP_ERROR
argument_list|)
throw|;
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Validates public and private key of certificate client.    *    * @param pubKey    * */
DECL|method|validateKeyPair (PublicKey pubKey)
specifier|protected
name|boolean
name|validateKeyPair
parameter_list|(
name|PublicKey
name|pubKey
parameter_list|)
throws|throws
name|CertificateException
block|{
name|byte
index|[]
name|challenge
init|=
name|RandomStringUtils
operator|.
name|random
argument_list|(
literal|1000
argument_list|)
operator|.
name|getBytes
argument_list|(
name|StandardCharsets
operator|.
name|UTF_8
argument_list|)
decl_stmt|;
name|byte
index|[]
name|sign
init|=
name|signDataStream
argument_list|(
operator|new
name|ByteArrayInputStream
argument_list|(
name|challenge
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|verifySignature
argument_list|(
name|challenge
argument_list|,
name|sign
argument_list|,
name|pubKey
argument_list|)
return|;
block|}
comment|/**    * Bootstrap the client by creating keypair and storing it in configured    * location.    * */
DECL|method|bootstrapClientKeys ()
specifier|protected
name|void
name|bootstrapClientKeys
parameter_list|()
throws|throws
name|CertificateException
block|{
name|Path
name|keyPath
init|=
name|securityConfig
operator|.
name|getKeyLocation
argument_list|()
decl_stmt|;
if|if
condition|(
name|Files
operator|.
name|notExists
argument_list|(
name|keyPath
argument_list|)
condition|)
block|{
try|try
block|{
name|Files
operator|.
name|createDirectories
argument_list|(
name|keyPath
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|CertificateException
argument_list|(
literal|"Error while creating directories "
operator|+
literal|"for certificate storage."
argument_list|,
name|BOOTSTRAP_ERROR
argument_list|)
throw|;
block|}
block|}
name|KeyPair
name|keyPair
init|=
name|createKeyPair
argument_list|()
decl_stmt|;
name|privateKey
operator|=
name|keyPair
operator|.
name|getPrivate
argument_list|()
expr_stmt|;
name|publicKey
operator|=
name|keyPair
operator|.
name|getPublic
argument_list|()
expr_stmt|;
block|}
DECL|method|createKeyPair ()
specifier|protected
name|KeyPair
name|createKeyPair
parameter_list|()
throws|throws
name|CertificateException
block|{
name|HDDSKeyGenerator
name|keyGenerator
init|=
operator|new
name|HDDSKeyGenerator
argument_list|(
name|securityConfig
argument_list|)
decl_stmt|;
name|KeyPair
name|keyPair
init|=
literal|null
decl_stmt|;
try|try
block|{
name|keyPair
operator|=
name|keyGenerator
operator|.
name|generateKey
argument_list|()
expr_stmt|;
name|keyCodec
operator|.
name|writePublicKey
argument_list|(
name|keyPair
operator|.
name|getPublic
argument_list|()
argument_list|)
expr_stmt|;
name|keyCodec
operator|.
name|writePrivateKey
argument_list|(
name|keyPair
operator|.
name|getPrivate
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NoSuchProviderException
decl||
name|NoSuchAlgorithmException
decl||
name|IOException
name|e
parameter_list|)
block|{
name|getLogger
argument_list|()
operator|.
name|error
argument_list|(
literal|"Error while bootstrapping certificate client."
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|CertificateException
argument_list|(
literal|"Error while bootstrapping certificate."
argument_list|,
name|BOOTSTRAP_ERROR
argument_list|)
throw|;
block|}
return|return
name|keyPair
return|;
block|}
DECL|method|getLogger ()
specifier|public
name|Logger
name|getLogger
parameter_list|()
block|{
return|return
name|logger
return|;
block|}
comment|/**    * Create a scm security client, used to get SCM signed certificate.    *    * @return {@link SCMSecurityProtocol}    */
DECL|method|getScmSecurityClient ( OzoneConfiguration conf)
specifier|private
specifier|static
name|SCMSecurityProtocol
name|getScmSecurityClient
parameter_list|(
name|OzoneConfiguration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|RPC
operator|.
name|setProtocolEngine
argument_list|(
name|conf
argument_list|,
name|SCMSecurityProtocolPB
operator|.
name|class
argument_list|,
name|ProtobufRpcEngine
operator|.
name|class
argument_list|)
expr_stmt|;
name|long
name|scmVersion
init|=
name|RPC
operator|.
name|getProtocolVersion
argument_list|(
name|ScmBlockLocationProtocolPB
operator|.
name|class
argument_list|)
decl_stmt|;
name|InetSocketAddress
name|scmSecurityProtoAdd
init|=
name|HddsUtils
operator|.
name|getScmAddressForSecurityProtocol
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|SCMSecurityProtocolClientSideTranslatorPB
name|scmSecurityClient
init|=
operator|new
name|SCMSecurityProtocolClientSideTranslatorPB
argument_list|(
name|RPC
operator|.
name|getProxy
argument_list|(
name|SCMSecurityProtocolPB
operator|.
name|class
argument_list|,
name|scmVersion
argument_list|,
name|scmSecurityProtoAdd
argument_list|,
name|UserGroupInformation
operator|.
name|getCurrentUser
argument_list|()
argument_list|,
name|conf
argument_list|,
name|NetUtils
operator|.
name|getDefaultSocketFactory
argument_list|(
name|conf
argument_list|)
argument_list|,
name|Client
operator|.
name|getRpcTimeout
argument_list|(
name|conf
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|scmSecurityClient
return|;
block|}
block|}
end_class

end_unit

