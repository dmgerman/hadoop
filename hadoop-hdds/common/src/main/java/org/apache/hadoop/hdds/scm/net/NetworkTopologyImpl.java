begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdds.scm.net
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdds
operator|.
name|scm
operator|.
name|net
package|;
end_package

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|collections
operator|.
name|CollectionUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ThreadLocalRandom
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|ReadWriteLock
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|ReentrantReadWriteLock
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|stream
operator|.
name|Collectors
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdds
operator|.
name|scm
operator|.
name|net
operator|.
name|NetConstants
operator|.
name|ROOT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdds
operator|.
name|scm
operator|.
name|net
operator|.
name|NetConstants
operator|.
name|SCOPE_REVERSE_STR
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdds
operator|.
name|scm
operator|.
name|net
operator|.
name|NetConstants
operator|.
name|ANCESTOR_GENERATION_DEFAULT
import|;
end_import

begin_comment
comment|/**  * The class represents a cluster of computers with a tree hierarchical  * network topology. In the network topology, leaves represent data nodes  * (computers) and inner nodes represent datacenter/core-switches/routers that  * manages traffic in/out of data centers or racks.  */
end_comment

begin_class
DECL|class|NetworkTopologyImpl
specifier|public
class|class
name|NetworkTopologyImpl
implements|implements
name|NetworkTopology
block|{
DECL|field|LOG
specifier|public
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|NetworkTopology
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/** The Inner node crate factory. */
DECL|field|factory
specifier|private
specifier|final
name|InnerNode
operator|.
name|Factory
name|factory
decl_stmt|;
comment|/** The root cluster tree. */
DECL|field|clusterTree
specifier|private
specifier|final
name|InnerNode
name|clusterTree
decl_stmt|;
comment|/** Depth of all leaf nodes. */
DECL|field|maxLevel
specifier|private
specifier|final
name|int
name|maxLevel
decl_stmt|;
comment|/** Schema manager. */
DECL|field|schemaManager
specifier|private
specifier|final
name|NodeSchemaManager
name|schemaManager
decl_stmt|;
comment|/** Lock to coordinate cluster tree access. */
DECL|field|netlock
specifier|private
name|ReadWriteLock
name|netlock
init|=
operator|new
name|ReentrantReadWriteLock
argument_list|(
literal|true
argument_list|)
decl_stmt|;
DECL|method|NetworkTopologyImpl (Configuration conf)
specifier|public
name|NetworkTopologyImpl
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
name|schemaManager
operator|=
name|NodeSchemaManager
operator|.
name|getInstance
argument_list|()
expr_stmt|;
name|schemaManager
operator|.
name|init
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|maxLevel
operator|=
name|schemaManager
operator|.
name|getMaxLevel
argument_list|()
expr_stmt|;
name|factory
operator|=
name|InnerNodeImpl
operator|.
name|FACTORY
expr_stmt|;
name|clusterTree
operator|=
name|factory
operator|.
name|newInnerNode
argument_list|(
name|ROOT
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|NetConstants
operator|.
name|ROOT_LEVEL
argument_list|,
name|schemaManager
operator|.
name|getCost
argument_list|(
name|NetConstants
operator|.
name|ROOT_LEVEL
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|NetworkTopologyImpl (NodeSchemaManager manager)
specifier|public
name|NetworkTopologyImpl
parameter_list|(
name|NodeSchemaManager
name|manager
parameter_list|)
block|{
name|schemaManager
operator|=
name|manager
expr_stmt|;
name|maxLevel
operator|=
name|schemaManager
operator|.
name|getMaxLevel
argument_list|()
expr_stmt|;
name|factory
operator|=
name|InnerNodeImpl
operator|.
name|FACTORY
expr_stmt|;
name|clusterTree
operator|=
name|factory
operator|.
name|newInnerNode
argument_list|(
name|ROOT
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|NetConstants
operator|.
name|ROOT_LEVEL
argument_list|,
name|schemaManager
operator|.
name|getCost
argument_list|(
name|NetConstants
operator|.
name|ROOT_LEVEL
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Add a leaf node. This will be called when a new datanode is added.    * @param node node to be added; can be null    * @exception IllegalArgumentException if add a node to a leave or node to be    * added is not a leaf    */
DECL|method|add (Node node)
specifier|public
name|void
name|add
parameter_list|(
name|Node
name|node
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|node
operator|!=
literal|null
argument_list|,
literal|"node cannot be null"
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|instanceof
name|InnerNode
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Not allowed to add an inner node: "
operator|+
name|node
operator|.
name|getNetworkFullPath
argument_list|()
argument_list|)
throw|;
block|}
name|int
name|newDepth
init|=
name|NetUtils
operator|.
name|locationToDepth
argument_list|(
name|node
operator|.
name|getNetworkLocation
argument_list|()
argument_list|)
operator|+
literal|1
decl_stmt|;
comment|// Check depth
if|if
condition|(
name|maxLevel
operator|!=
name|newDepth
condition|)
block|{
throw|throw
operator|new
name|InvalidTopologyException
argument_list|(
literal|"Failed to add "
operator|+
name|node
operator|.
name|getNetworkFullPath
argument_list|()
operator|+
literal|": Its path depth is not "
operator|+
name|maxLevel
argument_list|)
throw|;
block|}
name|netlock
operator|.
name|writeLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
name|boolean
name|add
decl_stmt|;
try|try
block|{
name|add
operator|=
name|clusterTree
operator|.
name|add
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|netlock
operator|.
name|writeLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|add
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Added a new node: "
operator|+
name|node
operator|.
name|getNetworkFullPath
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"NetworkTopology became:\n{}"
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Remove a node from the network topology. This will be called when a    * existing datanode is removed from the system.    * @param node node to be removed; cannot be null    */
DECL|method|remove (Node node)
specifier|public
name|void
name|remove
parameter_list|(
name|Node
name|node
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|node
operator|!=
literal|null
argument_list|,
literal|"node cannot be null"
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|instanceof
name|InnerNode
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Not allowed to remove an inner node: "
operator|+
name|node
operator|.
name|getNetworkFullPath
argument_list|()
argument_list|)
throw|;
block|}
name|netlock
operator|.
name|writeLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|clusterTree
operator|.
name|remove
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|netlock
operator|.
name|writeLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Removed a node: "
operator|+
name|node
operator|.
name|getNetworkFullPath
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"NetworkTopology became:\n{}"
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
comment|/**    * Check if the tree already contains node<i>node</i>.    * @param node a node    * @return true if<i>node</i> is already in the tree; false otherwise    */
DECL|method|contains (Node node)
specifier|public
name|boolean
name|contains
parameter_list|(
name|Node
name|node
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|node
operator|!=
literal|null
argument_list|,
literal|"node cannot be null"
argument_list|)
expr_stmt|;
name|netlock
operator|.
name|readLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|Node
name|parent
init|=
name|node
operator|.
name|getParent
argument_list|()
decl_stmt|;
while|while
condition|(
name|parent
operator|!=
literal|null
operator|&&
name|parent
operator|!=
name|clusterTree
condition|)
block|{
name|parent
operator|=
name|parent
operator|.
name|getParent
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|parent
operator|==
name|clusterTree
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
finally|finally
block|{
name|netlock
operator|.
name|readLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
comment|/**    * Compare the specified ancestor generation of each node for equality.    * @return true if their specified generation ancestor are equal    */
DECL|method|isSameAncestor (Node node1, Node node2, int ancestorGen)
specifier|public
name|boolean
name|isSameAncestor
parameter_list|(
name|Node
name|node1
parameter_list|,
name|Node
name|node2
parameter_list|,
name|int
name|ancestorGen
parameter_list|)
block|{
if|if
condition|(
name|node1
operator|==
literal|null
operator|||
name|node2
operator|==
literal|null
operator|||
name|ancestorGen
operator|<=
literal|0
condition|)
block|{
return|return
literal|false
return|;
block|}
name|netlock
operator|.
name|readLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
return|return
name|node1
operator|.
name|getAncestor
argument_list|(
name|ancestorGen
argument_list|)
operator|==
name|node2
operator|.
name|getAncestor
argument_list|(
name|ancestorGen
argument_list|)
return|;
block|}
finally|finally
block|{
name|netlock
operator|.
name|readLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Compare the direct parent of each node for equality.    * @return true if their parent are the same    */
DECL|method|isSameParent (Node node1, Node node2)
specifier|public
name|boolean
name|isSameParent
parameter_list|(
name|Node
name|node1
parameter_list|,
name|Node
name|node2
parameter_list|)
block|{
if|if
condition|(
name|node1
operator|==
literal|null
operator|||
name|node2
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
name|netlock
operator|.
name|readLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|node1
operator|=
name|node1
operator|.
name|getParent
argument_list|()
expr_stmt|;
name|node2
operator|=
name|node2
operator|.
name|getParent
argument_list|()
expr_stmt|;
return|return
name|node1
operator|==
name|node2
return|;
block|}
finally|finally
block|{
name|netlock
operator|.
name|readLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Get the ancestor for node on generation<i>ancestorGen</i>.    *    * @param node the node to get ancestor    * @param ancestorGen  the ancestor generation    * @return the ancestor. If no ancestor is found, then null is returned.    */
DECL|method|getAncestor (Node node, int ancestorGen)
specifier|public
name|Node
name|getAncestor
parameter_list|(
name|Node
name|node
parameter_list|,
name|int
name|ancestorGen
parameter_list|)
block|{
if|if
condition|(
name|node
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|netlock
operator|.
name|readLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
return|return
name|node
operator|.
name|getAncestor
argument_list|(
name|ancestorGen
argument_list|)
return|;
block|}
finally|finally
block|{
name|netlock
operator|.
name|readLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Given a string representation of a node(leaf or inner), return its    * reference.    * @param loc a path string representing a node, can be leaf or inner node    * @return a reference to the node, null if the node is not in the tree    */
DECL|method|getNode (String loc)
specifier|public
name|Node
name|getNode
parameter_list|(
name|String
name|loc
parameter_list|)
block|{
name|loc
operator|=
name|NetUtils
operator|.
name|normalize
argument_list|(
name|loc
argument_list|)
expr_stmt|;
name|netlock
operator|.
name|readLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
operator|!
name|ROOT
operator|.
name|equals
argument_list|(
name|loc
argument_list|)
condition|)
block|{
return|return
name|clusterTree
operator|.
name|getNode
argument_list|(
name|loc
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|clusterTree
return|;
block|}
block|}
finally|finally
block|{
name|netlock
operator|.
name|readLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Given a string representation of Node, return its leaf nodes count.    * @param loc a path-like string representation of Node    * @return the number of leaf nodes for InnerNode, 1 for leaf node, 0 if node    * doesn't exist    */
DECL|method|getNumOfLeafNode (String loc)
specifier|public
name|int
name|getNumOfLeafNode
parameter_list|(
name|String
name|loc
parameter_list|)
block|{
name|netlock
operator|.
name|readLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|Node
name|node
init|=
name|getNode
argument_list|(
name|loc
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|!=
literal|null
condition|)
block|{
return|return
name|node
operator|.
name|getNumOfLeaves
argument_list|()
return|;
block|}
block|}
finally|finally
block|{
name|netlock
operator|.
name|readLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
comment|/**    * Return the max level of this tree, start from 1 for ROOT. For example,    * topology like "/rack/node" has the max level '3'.    */
DECL|method|getMaxLevel ()
specifier|public
name|int
name|getMaxLevel
parameter_list|()
block|{
return|return
name|maxLevel
return|;
block|}
comment|/**    * Return the node numbers at level<i>level</i>.    * @param level topology level, start from 1, which means ROOT    * @return the number of nodes on the level    */
DECL|method|getNumOfNodes (int level)
specifier|public
name|int
name|getNumOfNodes
parameter_list|(
name|int
name|level
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|level
operator|>
literal|0
operator|&&
name|level
operator|<=
name|maxLevel
argument_list|,
literal|"Invalid level"
argument_list|)
expr_stmt|;
name|netlock
operator|.
name|readLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
return|return
name|clusterTree
operator|.
name|getNumOfNodes
argument_list|(
name|level
argument_list|)
return|;
block|}
finally|finally
block|{
name|netlock
operator|.
name|readLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Randomly choose a node in the scope.    * @param scope range of nodes from which a node will be chosen. If scope    *              starts with ~, choose one from the all nodes except for the    *              ones in<i>scope</i>; otherwise, choose one from<i>scope</i>.    * @return the chosen node    */
DECL|method|chooseRandom (String scope)
specifier|public
name|Node
name|chooseRandom
parameter_list|(
name|String
name|scope
parameter_list|)
block|{
if|if
condition|(
name|scope
operator|==
literal|null
condition|)
block|{
name|scope
operator|=
name|ROOT
expr_stmt|;
block|}
if|if
condition|(
name|scope
operator|.
name|startsWith
argument_list|(
name|SCOPE_REVERSE_STR
argument_list|)
condition|)
block|{
name|ArrayList
argument_list|<
name|String
argument_list|>
name|excludedScopes
init|=
operator|new
name|ArrayList
argument_list|()
decl_stmt|;
name|excludedScopes
operator|.
name|add
argument_list|(
name|scope
operator|.
name|substring
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|chooseRandom
argument_list|(
name|ROOT
argument_list|,
name|excludedScopes
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|ANCESTOR_GENERATION_DEFAULT
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|chooseRandom
argument_list|(
name|scope
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|ANCESTOR_GENERATION_DEFAULT
argument_list|)
return|;
block|}
block|}
comment|/**    * Randomly choose a node in the scope, ano not in the exclude scope.    * @param scope range of nodes from which a node will be chosen. cannot start    *              with ~    * @param excludedScopes the chosen node cannot be in these ranges. cannot    *                      starts with ~    * @return the chosen node    */
DECL|method|chooseRandom (String scope, List<String> excludedScopes)
specifier|public
name|Node
name|chooseRandom
parameter_list|(
name|String
name|scope
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|excludedScopes
parameter_list|)
block|{
return|return
name|chooseRandom
argument_list|(
name|scope
argument_list|,
name|excludedScopes
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|ANCESTOR_GENERATION_DEFAULT
argument_list|)
return|;
block|}
comment|/**    * Randomly choose a leaf node from<i>scope</i>.    *    * If scope starts with ~, choose one from the all nodes except for the    * ones in<i>scope</i>; otherwise, choose nodes from<i>scope</i>.    * If excludedNodes is given, choose a node that's not in excludedNodes.    *    * @param scope range of nodes from which a node will be chosen    * @param excludedNodes nodes to be excluded    *    * @return the chosen node    */
DECL|method|chooseRandom (String scope, Collection<Node> excludedNodes)
specifier|public
name|Node
name|chooseRandom
parameter_list|(
name|String
name|scope
parameter_list|,
name|Collection
argument_list|<
name|Node
argument_list|>
name|excludedNodes
parameter_list|)
block|{
if|if
condition|(
name|scope
operator|==
literal|null
condition|)
block|{
name|scope
operator|=
name|ROOT
expr_stmt|;
block|}
if|if
condition|(
name|scope
operator|.
name|startsWith
argument_list|(
name|SCOPE_REVERSE_STR
argument_list|)
condition|)
block|{
name|ArrayList
argument_list|<
name|String
argument_list|>
name|excludedScopes
init|=
operator|new
name|ArrayList
argument_list|()
decl_stmt|;
name|excludedScopes
operator|.
name|add
argument_list|(
name|scope
operator|.
name|substring
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|chooseRandom
argument_list|(
name|ROOT
argument_list|,
name|excludedScopes
argument_list|,
name|excludedNodes
argument_list|,
literal|null
argument_list|,
name|ANCESTOR_GENERATION_DEFAULT
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|chooseRandom
argument_list|(
name|scope
argument_list|,
literal|null
argument_list|,
name|excludedNodes
argument_list|,
literal|null
argument_list|,
name|ANCESTOR_GENERATION_DEFAULT
argument_list|)
return|;
block|}
block|}
comment|/**    * Randomly choose a leaf node from<i>scope</i>.    *    * If scope starts with ~, choose one from the all nodes except for the    * ones in<i>scope</i>; otherwise, choose nodes from<i>scope</i>.    * If excludedNodes is given, choose a node that's not in excludedNodes.    *    * @param scope range of nodes from which a node will be chosen    * @param excludedNodes nodes to be excluded from.    * @param ancestorGen matters when excludeNodes is not null. It means the    * ancestor generation that's not allowed to share between chosen node and the    * excludedNodes. For example, if ancestorGen is 1, means chosen node    * cannot share the same parent with excludeNodes. If value is 2, cannot    * share the same grand parent, and so on. If ancestorGen is 0, then no    * effect.    *    * @return the chosen node    */
DECL|method|chooseRandom (String scope, Collection<Node> excludedNodes, int ancestorGen)
specifier|public
name|Node
name|chooseRandom
parameter_list|(
name|String
name|scope
parameter_list|,
name|Collection
argument_list|<
name|Node
argument_list|>
name|excludedNodes
parameter_list|,
name|int
name|ancestorGen
parameter_list|)
block|{
if|if
condition|(
name|scope
operator|==
literal|null
condition|)
block|{
name|scope
operator|=
name|ROOT
expr_stmt|;
block|}
if|if
condition|(
name|scope
operator|.
name|startsWith
argument_list|(
name|SCOPE_REVERSE_STR
argument_list|)
condition|)
block|{
name|ArrayList
argument_list|<
name|String
argument_list|>
name|excludedScopes
init|=
operator|new
name|ArrayList
argument_list|()
decl_stmt|;
name|excludedScopes
operator|.
name|add
argument_list|(
name|scope
operator|.
name|substring
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|chooseRandom
argument_list|(
name|ROOT
argument_list|,
name|excludedScopes
argument_list|,
name|excludedNodes
argument_list|,
literal|null
argument_list|,
name|ancestorGen
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|chooseRandom
argument_list|(
name|scope
argument_list|,
literal|null
argument_list|,
name|excludedNodes
argument_list|,
literal|null
argument_list|,
name|ancestorGen
argument_list|)
return|;
block|}
block|}
comment|/**    * Randomly choose one leaf node from<i>scope</i>, share the same generation    * ancestor with<i>affinityNode</i>, and exclude nodes in    *<i>excludeScope</i> and<i>excludeNodes</i>.    *    * @param scope range of nodes from which a node will be chosen, cannot start    *              with ~    * @param excludedScopes ranges of nodes to be excluded, cannot start with ~    * @param excludedNodes nodes to be excluded    * @param affinityNode  when not null, the chosen node should share the same    *                     ancestor with this node at generation ancestorGen.    *                      Ignored when value is null    * @param ancestorGen If 0, then no same generation ancestor enforcement on    *                     both excludedNodes and affinityNode. If greater than 0,    *                     then apply to affinityNode(if not null), or apply to    *                     excludedNodes if affinityNode is null    * @return the chosen node    */
DECL|method|chooseRandom (String scope, List<String> excludedScopes, Collection<Node> excludedNodes, Node affinityNode, int ancestorGen)
specifier|public
name|Node
name|chooseRandom
parameter_list|(
name|String
name|scope
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|excludedScopes
parameter_list|,
name|Collection
argument_list|<
name|Node
argument_list|>
name|excludedNodes
parameter_list|,
name|Node
name|affinityNode
parameter_list|,
name|int
name|ancestorGen
parameter_list|)
block|{
if|if
condition|(
name|scope
operator|==
literal|null
condition|)
block|{
name|scope
operator|=
name|ROOT
expr_stmt|;
block|}
name|checkScope
argument_list|(
name|scope
argument_list|)
expr_stmt|;
name|checkExcludedScopes
argument_list|(
name|excludedScopes
argument_list|)
expr_stmt|;
name|checkAffinityNode
argument_list|(
name|affinityNode
argument_list|)
expr_stmt|;
name|checkAncestorGen
argument_list|(
name|ancestorGen
argument_list|)
expr_stmt|;
name|netlock
operator|.
name|readLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
return|return
name|chooseNodeInternal
argument_list|(
name|scope
argument_list|,
operator|-
literal|1
argument_list|,
name|excludedScopes
argument_list|,
name|excludedNodes
argument_list|,
name|affinityNode
argument_list|,
name|ancestorGen
argument_list|)
return|;
block|}
finally|finally
block|{
name|netlock
operator|.
name|readLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Choose the leaf node at index<i>index</i> from<i>scope</i>, share the    * same generation ancestor with<i>affinityNode</i>, and exclude nodes in    *<i>excludeScope</i> and<i>excludeNodes</i>.    *    * @param leafIndex node index, exclude nodes in excludedScope and    *                  excludedNodes    * @param scope range of nodes from which a node will be chosen, cannot start    *              with ~    * @param excludedScopes ranges of nodes to be excluded, cannot start with ~    * @param excludedNodes nodes to be excluded    * @param affinityNode  when not null, the chosen node should share the same    *                     ancestor with this node at generation ancestorGen.    *                      Ignored when value is null    * @param ancestorGen If 0, then no same generation ancestor enforcement on    *                     both excludedNodes and affinityNode. If greater than 0,    *                     then apply to affinityNode(if not null), or apply to    *                     excludedNodes if affinityNode is null    * @return the chosen node    * Example:    *    *                                /  --- root    *                              /  \    *                             /    \    *                            /      \    *                           /        \    *                         dc1         dc2    *                        / \         / \    *                       /   \       /   \    *                      /     \     /     \    *                    rack1 rack2  rack1  rack2    *                   / \     / \  / \     / \    *                 n1  n2  n3 n4 n5  n6  n7 n8    *    *   Input:    *   leafIndex = 1    *   excludedScope = /dc2    *   excludedNodes = {/dc1/rack1/n1}    *   affinityNode = /dc1/rack2/n2    *   ancestorGen = 2    *    *   Output:    *   node /dc1/rack2/n4    *    *   Explanation:    *   With affinityNode n2 and ancestorGen 2, it means we can only pick node    *   from subtree /dc1. LeafIndex 1, so we pick the 2nd available node n4.    *    */
DECL|method|getNode (int leafIndex, String scope, List<String> excludedScopes, Collection<Node> excludedNodes, Node affinityNode, int ancestorGen)
specifier|public
name|Node
name|getNode
parameter_list|(
name|int
name|leafIndex
parameter_list|,
name|String
name|scope
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|excludedScopes
parameter_list|,
name|Collection
argument_list|<
name|Node
argument_list|>
name|excludedNodes
parameter_list|,
name|Node
name|affinityNode
parameter_list|,
name|int
name|ancestorGen
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|leafIndex
operator|>=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|scope
operator|==
literal|null
condition|)
block|{
name|scope
operator|=
name|ROOT
expr_stmt|;
block|}
name|checkScope
argument_list|(
name|scope
argument_list|)
expr_stmt|;
name|checkExcludedScopes
argument_list|(
name|excludedScopes
argument_list|)
expr_stmt|;
name|checkAffinityNode
argument_list|(
name|affinityNode
argument_list|)
expr_stmt|;
name|checkAncestorGen
argument_list|(
name|ancestorGen
argument_list|)
expr_stmt|;
name|netlock
operator|.
name|readLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
return|return
name|chooseNodeInternal
argument_list|(
name|scope
argument_list|,
name|leafIndex
argument_list|,
name|excludedScopes
argument_list|,
name|excludedNodes
argument_list|,
name|affinityNode
argument_list|,
name|ancestorGen
argument_list|)
return|;
block|}
finally|finally
block|{
name|netlock
operator|.
name|readLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|chooseNodeInternal (String scope, int leafIndex, List<String> excludedScopes, Collection<Node> excludedNodes, Node affinityNode, int ancestorGen)
specifier|private
name|Node
name|chooseNodeInternal
parameter_list|(
name|String
name|scope
parameter_list|,
name|int
name|leafIndex
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|excludedScopes
parameter_list|,
name|Collection
argument_list|<
name|Node
argument_list|>
name|excludedNodes
parameter_list|,
name|Node
name|affinityNode
parameter_list|,
name|int
name|ancestorGen
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|scope
operator|!=
literal|null
argument_list|)
expr_stmt|;
name|String
name|finalScope
init|=
name|scope
decl_stmt|;
if|if
condition|(
name|affinityNode
operator|!=
literal|null
operator|&&
name|ancestorGen
operator|>
literal|0
condition|)
block|{
name|Node
name|affinityAncestor
init|=
name|affinityNode
operator|.
name|getAncestor
argument_list|(
name|ancestorGen
argument_list|)
decl_stmt|;
if|if
condition|(
name|affinityAncestor
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"affinityNode "
operator|+
name|affinityNode
operator|.
name|getNetworkFullPath
argument_list|()
operator|+
literal|" doesn't have ancestor on"
operator|+
literal|" generation  "
operator|+
name|ancestorGen
argument_list|)
throw|;
block|}
comment|// affinity ancestor should has overlap with scope
if|if
condition|(
name|affinityAncestor
operator|.
name|getNetworkFullPath
argument_list|()
operator|.
name|startsWith
argument_list|(
name|scope
argument_list|)
condition|)
block|{
name|finalScope
operator|=
name|affinityAncestor
operator|.
name|getNetworkFullPath
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|scope
operator|.
name|startsWith
argument_list|(
name|affinityAncestor
operator|.
name|getNetworkFullPath
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
comment|// reset ancestor generation since the new scope is identified now
name|ancestorGen
operator|=
literal|0
expr_stmt|;
block|}
comment|// check overlap of excludedScopes and finalScope
name|List
argument_list|<
name|String
argument_list|>
name|mutableExcludedScopes
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|excludedScopes
operator|!=
literal|null
operator|&&
operator|!
name|excludedScopes
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|mutableExcludedScopes
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
expr_stmt|;
for|for
control|(
name|String
name|s
range|:
name|excludedScopes
control|)
block|{
comment|// excludeScope covers finalScope
if|if
condition|(
name|finalScope
operator|.
name|startsWith
argument_list|(
name|s
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
comment|// excludeScope and finalScope share nothing case
if|if
condition|(
name|s
operator|.
name|startsWith
argument_list|(
name|finalScope
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|mutableExcludedScopes
operator|.
name|stream
argument_list|()
operator|.
name|anyMatch
argument_list|(
name|e
lambda|->
name|s
operator|.
name|startsWith
argument_list|(
name|e
argument_list|)
argument_list|)
condition|)
block|{
name|mutableExcludedScopes
operator|.
name|add
argument_list|(
name|s
argument_list|)
block|;           }
block|}
block|}
block|}
comment|// clone excludedNodes before remove duplicate in it
name|Collection
argument_list|<
name|Node
argument_list|>
name|mutableExNodes
init|=
literal|null
decl_stmt|;
comment|// Remove duplicate in excludedNodes
if|if
condition|(
name|excludedNodes
operator|!=
literal|null
condition|)
block|{
name|mutableExNodes
operator|=
name|excludedNodes
operator|.
name|stream
argument_list|()
operator|.
name|distinct
argument_list|()
operator|.
name|collect
argument_list|(
name|Collectors
operator|.
name|toList
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// remove duplicate in mutableExNodes and mutableExcludedScopes
name|NetUtils
operator|.
name|removeDuplicate
argument_list|(
name|this
argument_list|,
name|mutableExNodes
argument_list|,
name|mutableExcludedScopes
argument_list|,
name|ancestorGen
argument_list|)
expr_stmt|;
comment|// calculate available node count
name|Node
name|scopeNode
init|=
name|getNode
argument_list|(
name|finalScope
argument_list|)
decl_stmt|;
name|int
name|availableNodes
init|=
name|getAvailableNodesCount
argument_list|(
name|scopeNode
operator|.
name|getNetworkFullPath
argument_list|()
argument_list|,
name|mutableExcludedScopes
argument_list|,
name|mutableExNodes
argument_list|,
name|ancestorGen
argument_list|)
decl_stmt|;
if|if
condition|(
name|availableNodes
operator|<=
literal|0
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"No available node in (scope=\"{}\" excludedScope=\"{}\" "
operator|+
literal|"excludedNodes=\"{}\"  ancestorGen=\"{}\")."
argument_list|,
name|scopeNode
operator|.
name|getNetworkFullPath
argument_list|()
argument_list|,
name|excludedScopes
argument_list|,
name|excludedNodes
argument_list|,
name|ancestorGen
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
comment|// scope is a Leaf node
if|if
condition|(
operator|!
operator|(
name|scopeNode
operator|instanceof
name|InnerNode
operator|)
condition|)
block|{
return|return
name|scopeNode
return|;
block|}
name|Node
name|ret
decl_stmt|;
name|int
name|nodeIndex
decl_stmt|;
if|if
condition|(
name|leafIndex
operator|>=
literal|0
condition|)
block|{
name|nodeIndex
operator|=
name|leafIndex
operator|%
name|availableNodes
expr_stmt|;
name|ret
operator|=
operator|(
operator|(
name|InnerNode
operator|)
name|scopeNode
operator|)
operator|.
name|getLeaf
argument_list|(
name|nodeIndex
argument_list|,
name|mutableExcludedScopes
argument_list|,
name|mutableExNodes
argument_list|,
name|ancestorGen
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nodeIndex
operator|=
name|ThreadLocalRandom
operator|.
name|current
argument_list|()
operator|.
name|nextInt
argument_list|(
name|availableNodes
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|(
operator|(
name|InnerNode
operator|)
name|scopeNode
operator|)
operator|.
name|getLeaf
argument_list|(
name|nodeIndex
argument_list|,
name|mutableExcludedScopes
argument_list|,
name|mutableExNodes
argument_list|,
name|ancestorGen
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Choosing node[index={},random={}] from \"{}\" available nodes"
operator|+
literal|" scope=\"{}\", excludedScope=\"{}\", excludeNodes=\"{}\"."
argument_list|,
name|nodeIndex
argument_list|,
operator|(
name|leafIndex
operator|==
operator|-
literal|1
condition|?
literal|"true"
else|:
literal|"false"
operator|)
argument_list|,
name|availableNodes
argument_list|,
name|scopeNode
operator|.
name|getNetworkFullPath
argument_list|()
argument_list|,
name|excludedScopes
argument_list|,
name|excludedNodes
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Chosen node = {}"
argument_list|,
operator|(
name|ret
operator|==
literal|null
condition|?
literal|"not found"
else|:
name|ret
operator|.
name|toString
argument_list|()
operator|)
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
comment|/** Return the distance cost between two nodes    * The distance cost from one node to its parent is it's parent's cost    * The distance cost between two nodes is calculated by summing up their    * distances cost to their closest common ancestor.    * @param node1 one node    * @param node2 another node    * @return the distance cost between node1 and node2 which is zero if they    * are the same or {@link Integer#MAX_VALUE} if node1 or node2 do not belong    * to the cluster    */
DECL|method|getDistanceCost (Node node1, Node node2)
specifier|public
name|int
name|getDistanceCost
parameter_list|(
name|Node
name|node1
parameter_list|,
name|Node
name|node2
parameter_list|)
block|{
if|if
condition|(
operator|(
name|node1
operator|!=
literal|null
operator|&&
name|node2
operator|!=
literal|null
operator|&&
name|node1
operator|.
name|equals
argument_list|(
name|node2
argument_list|)
operator|)
operator|||
operator|(
name|node1
operator|==
literal|null
operator|&&
name|node2
operator|==
literal|null
operator|)
condition|)
block|{
return|return
literal|0
return|;
block|}
if|if
condition|(
name|node1
operator|==
literal|null
operator|||
name|node2
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"One of the nodes is a null pointer"
argument_list|)
expr_stmt|;
return|return
name|Integer
operator|.
name|MAX_VALUE
return|;
block|}
name|int
name|cost
init|=
literal|0
decl_stmt|;
name|netlock
operator|.
name|readLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
operator|(
name|node1
operator|.
name|getAncestor
argument_list|(
name|maxLevel
operator|-
literal|1
argument_list|)
operator|!=
name|clusterTree
operator|)
operator|||
operator|(
name|node2
operator|.
name|getAncestor
argument_list|(
name|maxLevel
operator|-
literal|1
argument_list|)
operator|!=
name|clusterTree
operator|)
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"One of the nodes is outside of network topology"
argument_list|)
expr_stmt|;
return|return
name|Integer
operator|.
name|MAX_VALUE
return|;
block|}
name|int
name|level1
init|=
name|node1
operator|.
name|getLevel
argument_list|()
decl_stmt|;
name|int
name|level2
init|=
name|node2
operator|.
name|getLevel
argument_list|()
decl_stmt|;
if|if
condition|(
name|level1
operator|>
name|maxLevel
operator|||
name|level2
operator|>
name|maxLevel
condition|)
block|{
return|return
name|Integer
operator|.
name|MAX_VALUE
return|;
block|}
while|while
condition|(
name|level1
operator|>
name|level2
operator|&&
name|node1
operator|!=
literal|null
condition|)
block|{
name|node1
operator|=
name|node1
operator|.
name|getParent
argument_list|()
expr_stmt|;
name|level1
operator|--
expr_stmt|;
name|cost
operator|+=
name|node1
operator|==
literal|null
condition|?
literal|0
else|:
name|node1
operator|.
name|getCost
argument_list|()
expr_stmt|;
block|}
while|while
condition|(
name|level2
operator|>
name|level1
operator|&&
name|node2
operator|!=
literal|null
condition|)
block|{
name|node2
operator|=
name|node2
operator|.
name|getParent
argument_list|()
expr_stmt|;
name|level2
operator|--
expr_stmt|;
name|cost
operator|+=
name|node2
operator|==
literal|null
condition|?
literal|0
else|:
name|node2
operator|.
name|getCost
argument_list|()
expr_stmt|;
block|}
while|while
condition|(
name|node1
operator|!=
literal|null
operator|&&
name|node2
operator|!=
literal|null
operator|&&
name|node1
operator|!=
name|node2
condition|)
block|{
name|node1
operator|=
name|node1
operator|.
name|getParent
argument_list|()
expr_stmt|;
name|node2
operator|=
name|node2
operator|.
name|getParent
argument_list|()
expr_stmt|;
name|cost
operator|+=
name|node1
operator|==
literal|null
condition|?
literal|0
else|:
name|node1
operator|.
name|getCost
argument_list|()
expr_stmt|;
name|cost
operator|+=
name|node2
operator|==
literal|null
condition|?
literal|0
else|:
name|node2
operator|.
name|getCost
argument_list|()
expr_stmt|;
block|}
return|return
name|cost
return|;
block|}
finally|finally
block|{
name|netlock
operator|.
name|readLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Sort nodes array by network distance to<i>reader</i> to reduces network    * traffic and improves performance.    *    * As an additional twist, we also randomize the nodes at each network    * distance. This helps with load balancing when there is data skew.    *    * @param reader    Node where need the data    * @param nodes     Available replicas with the requested data    * @param activeLen Number of active nodes at the front of the array    */
DECL|method|sortByDistanceCost (Node reader, List<? extends Node> nodes, int activeLen)
specifier|public
name|List
argument_list|<
name|?
extends|extends
name|Node
argument_list|>
name|sortByDistanceCost
parameter_list|(
name|Node
name|reader
parameter_list|,
name|List
argument_list|<
name|?
extends|extends
name|Node
argument_list|>
name|nodes
parameter_list|,
name|int
name|activeLen
parameter_list|)
block|{
comment|/** Sort weights for the nodes array */
if|if
condition|(
name|reader
operator|==
literal|null
condition|)
block|{
return|return
name|nodes
return|;
block|}
name|int
index|[]
name|costs
init|=
operator|new
name|int
index|[
name|activeLen
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|activeLen
condition|;
name|i
operator|++
control|)
block|{
name|costs
index|[
name|i
index|]
operator|=
name|getDistanceCost
argument_list|(
name|reader
argument_list|,
name|nodes
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Add cost/node pairs to a TreeMap to sort
name|TreeMap
argument_list|<
name|Integer
argument_list|,
name|List
argument_list|<
name|Node
argument_list|>
argument_list|>
name|tree
init|=
operator|new
name|TreeMap
argument_list|<
name|Integer
argument_list|,
name|List
argument_list|<
name|Node
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|activeLen
condition|;
name|i
operator|++
control|)
block|{
name|int
name|cost
init|=
name|costs
index|[
name|i
index|]
decl_stmt|;
name|Node
name|node
init|=
name|nodes
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Node
argument_list|>
name|list
init|=
name|tree
operator|.
name|get
argument_list|(
name|cost
argument_list|)
decl_stmt|;
if|if
condition|(
name|list
operator|==
literal|null
condition|)
block|{
name|list
operator|=
name|Lists
operator|.
name|newArrayListWithExpectedSize
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|tree
operator|.
name|put
argument_list|(
name|cost
argument_list|,
name|list
argument_list|)
expr_stmt|;
block|}
name|list
operator|.
name|add
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|Node
argument_list|>
name|ret
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|List
argument_list|<
name|Node
argument_list|>
name|list
range|:
name|tree
operator|.
name|values
argument_list|()
control|)
block|{
if|if
condition|(
name|list
operator|!=
literal|null
condition|)
block|{
name|Collections
operator|.
name|shuffle
argument_list|(
name|list
argument_list|)
expr_stmt|;
for|for
control|(
name|Node
name|n
range|:
name|list
control|)
block|{
name|ret
operator|.
name|add
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|Preconditions
operator|.
name|checkState
argument_list|(
name|ret
operator|.
name|size
argument_list|()
operator|==
name|activeLen
argument_list|,
literal|"Wrong number of nodes sorted!"
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
comment|/**    * Return the number of leaves in<i>scope</i> but not in    *<i>excludedNodes</i> and<i>excludeScope</i>.    * @param scope the scope    * @param excludedScopes excluded scopes    * @param mutableExcludedNodes a list of excluded nodes, content might be    *                            changed after the call    * @param ancestorGen same generation ancestor prohibit on excludedNodes    * @return number of available nodes    */
DECL|method|getAvailableNodesCount (String scope, List<String> excludedScopes, Collection<Node> mutableExcludedNodes, int ancestorGen)
specifier|private
name|int
name|getAvailableNodesCount
parameter_list|(
name|String
name|scope
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|excludedScopes
parameter_list|,
name|Collection
argument_list|<
name|Node
argument_list|>
name|mutableExcludedNodes
parameter_list|,
name|int
name|ancestorGen
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|scope
operator|!=
literal|null
argument_list|)
expr_stmt|;
name|Node
name|scopeNode
init|=
name|getNode
argument_list|(
name|scope
argument_list|)
decl_stmt|;
if|if
condition|(
name|scopeNode
operator|==
literal|null
condition|)
block|{
return|return
literal|0
return|;
block|}
name|NetUtils
operator|.
name|removeOutscope
argument_list|(
name|mutableExcludedNodes
argument_list|,
name|scope
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|Node
argument_list|>
name|excludedAncestorList
init|=
name|NetUtils
operator|.
name|getAncestorList
argument_list|(
name|this
argument_list|,
name|mutableExcludedNodes
argument_list|,
name|ancestorGen
argument_list|)
decl_stmt|;
for|for
control|(
name|Node
name|ancestor
range|:
name|excludedAncestorList
control|)
block|{
if|if
condition|(
name|scope
operator|.
name|startsWith
argument_list|(
name|ancestor
operator|.
name|getNetworkFullPath
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|0
return|;
block|}
block|}
comment|// number of nodes to exclude
name|int
name|excludedCount
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|excludedScopes
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|String
name|excludedScope
range|:
name|excludedScopes
control|)
block|{
name|Node
name|excludedScopeNode
init|=
name|getNode
argument_list|(
name|excludedScope
argument_list|)
decl_stmt|;
if|if
condition|(
name|excludedScopeNode
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|excludedScope
operator|.
name|startsWith
argument_list|(
name|scope
argument_list|)
condition|)
block|{
name|excludedCount
operator|+=
name|excludedScopeNode
operator|.
name|getNumOfLeaves
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|scope
operator|.
name|startsWith
argument_list|(
name|excludedScope
argument_list|)
condition|)
block|{
return|return
literal|0
return|;
block|}
block|}
block|}
block|}
comment|// excludedNodes is not null case
if|if
condition|(
name|mutableExcludedNodes
operator|!=
literal|null
operator|&&
operator|(
operator|!
name|mutableExcludedNodes
operator|.
name|isEmpty
argument_list|()
operator|)
condition|)
block|{
if|if
condition|(
name|ancestorGen
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|Node
name|node
range|:
name|mutableExcludedNodes
control|)
block|{
if|if
condition|(
name|contains
argument_list|(
name|node
argument_list|)
condition|)
block|{
name|excludedCount
operator|++
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
for|for
control|(
name|Node
name|ancestor
range|:
name|excludedAncestorList
control|)
block|{
if|if
condition|(
name|ancestor
operator|.
name|getNetworkFullPath
argument_list|()
operator|.
name|startsWith
argument_list|(
name|scope
argument_list|)
condition|)
block|{
name|excludedCount
operator|+=
name|ancestor
operator|.
name|getNumOfLeaves
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
name|int
name|availableCount
init|=
name|scopeNode
operator|.
name|getNumOfLeaves
argument_list|()
operator|-
name|excludedCount
decl_stmt|;
name|Preconditions
operator|.
name|checkState
argument_list|(
name|availableCount
operator|>=
literal|0
argument_list|)
expr_stmt|;
return|return
name|availableCount
return|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
comment|// print max level
name|StringBuilder
name|tree
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|tree
operator|.
name|append
argument_list|(
literal|"Level: "
argument_list|)
expr_stmt|;
name|tree
operator|.
name|append
argument_list|(
name|maxLevel
argument_list|)
expr_stmt|;
name|tree
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|netlock
operator|.
name|readLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
comment|// print the number of leaves
name|int
name|numOfLeaves
init|=
name|clusterTree
operator|.
name|getNumOfLeaves
argument_list|()
decl_stmt|;
name|tree
operator|.
name|append
argument_list|(
literal|"Number of leaves:"
argument_list|)
expr_stmt|;
name|tree
operator|.
name|append
argument_list|(
name|numOfLeaves
argument_list|)
expr_stmt|;
name|tree
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
comment|// print all nodes
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numOfLeaves
condition|;
name|i
operator|++
control|)
block|{
name|tree
operator|.
name|append
argument_list|(
name|clusterTree
operator|.
name|getLeaf
argument_list|(
name|i
argument_list|)
operator|.
name|getNetworkFullPath
argument_list|()
argument_list|)
expr_stmt|;
name|tree
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|netlock
operator|.
name|readLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
return|return
name|tree
operator|.
name|toString
argument_list|()
return|;
block|}
DECL|method|checkScope (String scope)
specifier|private
name|void
name|checkScope
parameter_list|(
name|String
name|scope
parameter_list|)
block|{
if|if
condition|(
name|scope
operator|!=
literal|null
operator|&&
name|scope
operator|.
name|startsWith
argument_list|(
name|SCOPE_REVERSE_STR
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"scope "
operator|+
name|scope
operator|+
literal|" should not start with "
operator|+
name|SCOPE_REVERSE_STR
argument_list|)
throw|;
block|}
block|}
DECL|method|checkExcludedScopes (List<String> excludedScopes)
specifier|private
name|void
name|checkExcludedScopes
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|excludedScopes
parameter_list|)
block|{
if|if
condition|(
operator|!
name|CollectionUtils
operator|.
name|isEmpty
argument_list|(
name|excludedScopes
argument_list|)
condition|)
block|{
name|excludedScopes
operator|.
name|stream
argument_list|()
operator|.
name|forEach
argument_list|(
name|scope
lambda|->
block|{
if|if
condition|(
name|scope
operator|.
name|startsWith
argument_list|(
name|SCOPE_REVERSE_STR
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"excludedScope "
operator|+
name|scope
operator|+
literal|" cannot start with "
operator|+
name|SCOPE_REVERSE_STR
argument_list|)
throw|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|checkAffinityNode (Node affinityNode)
specifier|private
name|void
name|checkAffinityNode
parameter_list|(
name|Node
name|affinityNode
parameter_list|)
block|{
if|if
condition|(
name|affinityNode
operator|!=
literal|null
operator|&&
operator|(
operator|!
name|contains
argument_list|(
name|affinityNode
argument_list|)
operator|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Affinity node "
operator|+
name|affinityNode
operator|.
name|getNetworkFullPath
argument_list|()
operator|+
literal|" is not a member of topology"
argument_list|)
throw|;
block|}
block|}
DECL|method|checkAncestorGen (int ancestorGen)
specifier|private
name|void
name|checkAncestorGen
parameter_list|(
name|int
name|ancestorGen
parameter_list|)
block|{
if|if
condition|(
name|ancestorGen
operator|>
operator|(
name|maxLevel
operator|-
literal|1
operator|)
operator|||
name|ancestorGen
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"ancestorGen "
operator|+
name|ancestorGen
operator|+
literal|" exceeds this network topology acceptable level [0, "
operator|+
operator|(
name|maxLevel
operator|-
literal|1
operator|)
operator|+
literal|"]"
argument_list|)
throw|;
block|}
block|}
block|}
end_class

end_unit

