begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdds.scm.node.states
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdds
operator|.
name|scm
operator|.
name|node
operator|.
name|states
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdds
operator|.
name|protocol
operator|.
name|DatanodeDetails
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdds
operator|.
name|protocol
operator|.
name|proto
operator|.
name|HddsProtos
operator|.
name|NodeState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdds
operator|.
name|scm
operator|.
name|container
operator|.
name|ContainerID
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdds
operator|.
name|scm
operator|.
name|node
operator|.
name|DatanodeInfo
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|ReadWriteLock
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|ReentrantReadWriteLock
import|;
end_import

begin_comment
comment|/**  * Maintains the state of datanodes in SCM. This class should only be used by  * NodeStateManager to maintain the state. If anyone wants to change the  * state of a node they should call NodeStateManager, do not directly use  * this class.  */
end_comment

begin_class
DECL|class|NodeStateMap
specifier|public
class|class
name|NodeStateMap
block|{
comment|/**    * Node id to node info map.    */
DECL|field|nodeMap
specifier|private
specifier|final
name|ConcurrentHashMap
argument_list|<
name|UUID
argument_list|,
name|DatanodeInfo
argument_list|>
name|nodeMap
decl_stmt|;
comment|/**    * Represents the current state of node.    */
DECL|field|stateMap
specifier|private
specifier|final
name|ConcurrentHashMap
argument_list|<
name|NodeState
argument_list|,
name|Set
argument_list|<
name|UUID
argument_list|>
argument_list|>
name|stateMap
decl_stmt|;
comment|/**    * Node to set of containers on the node.    */
DECL|field|nodeToContainer
specifier|private
specifier|final
name|ConcurrentHashMap
argument_list|<
name|UUID
argument_list|,
name|Set
argument_list|<
name|ContainerID
argument_list|>
argument_list|>
name|nodeToContainer
decl_stmt|;
DECL|field|lock
specifier|private
specifier|final
name|ReadWriteLock
name|lock
decl_stmt|;
comment|/**    * Creates a new instance of NodeStateMap with no nodes.    */
DECL|method|NodeStateMap ()
specifier|public
name|NodeStateMap
parameter_list|()
block|{
name|lock
operator|=
operator|new
name|ReentrantReadWriteLock
argument_list|()
expr_stmt|;
name|nodeMap
operator|=
operator|new
name|ConcurrentHashMap
argument_list|<>
argument_list|()
expr_stmt|;
name|stateMap
operator|=
operator|new
name|ConcurrentHashMap
argument_list|<>
argument_list|()
expr_stmt|;
name|nodeToContainer
operator|=
operator|new
name|ConcurrentHashMap
argument_list|<>
argument_list|()
expr_stmt|;
name|initStateMap
argument_list|()
expr_stmt|;
block|}
comment|/**    * Initializes the state map with available states.    */
DECL|method|initStateMap ()
specifier|private
name|void
name|initStateMap
parameter_list|()
block|{
for|for
control|(
name|NodeState
name|state
range|:
name|NodeState
operator|.
name|values
argument_list|()
control|)
block|{
name|stateMap
operator|.
name|put
argument_list|(
name|state
argument_list|,
operator|new
name|HashSet
argument_list|<>
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Adds a node to NodeStateMap.    *    * @param datanodeDetails DatanodeDetails    * @param nodeState initial NodeState    *    * @throws NodeAlreadyExistsException if the node already exist    */
DECL|method|addNode (DatanodeDetails datanodeDetails, NodeState nodeState)
specifier|public
name|void
name|addNode
parameter_list|(
name|DatanodeDetails
name|datanodeDetails
parameter_list|,
name|NodeState
name|nodeState
parameter_list|)
throws|throws
name|NodeAlreadyExistsException
block|{
name|lock
operator|.
name|writeLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|UUID
name|id
init|=
name|datanodeDetails
operator|.
name|getUuid
argument_list|()
decl_stmt|;
if|if
condition|(
name|nodeMap
operator|.
name|containsKey
argument_list|(
name|id
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|NodeAlreadyExistsException
argument_list|(
literal|"Node UUID: "
operator|+
name|id
argument_list|)
throw|;
block|}
name|nodeMap
operator|.
name|put
argument_list|(
name|id
argument_list|,
operator|new
name|DatanodeInfo
argument_list|(
name|datanodeDetails
argument_list|)
argument_list|)
expr_stmt|;
name|nodeToContainer
operator|.
name|put
argument_list|(
name|id
argument_list|,
name|Collections
operator|.
name|emptySet
argument_list|()
argument_list|)
expr_stmt|;
name|stateMap
operator|.
name|get
argument_list|(
name|nodeState
argument_list|)
operator|.
name|add
argument_list|(
name|id
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|writeLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Updates the node state.    *    * @param nodeId Node Id    * @param currentState current state    * @param newState new state    *    * @throws NodeNotFoundException if the node is not present    */
DECL|method|updateNodeState (UUID nodeId, NodeState currentState, NodeState newState)
specifier|public
name|void
name|updateNodeState
parameter_list|(
name|UUID
name|nodeId
parameter_list|,
name|NodeState
name|currentState
parameter_list|,
name|NodeState
name|newState
parameter_list|)
throws|throws
name|NodeNotFoundException
block|{
name|lock
operator|.
name|writeLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkIfNodeExist
argument_list|(
name|nodeId
argument_list|)
expr_stmt|;
if|if
condition|(
name|stateMap
operator|.
name|get
argument_list|(
name|currentState
argument_list|)
operator|.
name|remove
argument_list|(
name|nodeId
argument_list|)
condition|)
block|{
name|stateMap
operator|.
name|get
argument_list|(
name|newState
argument_list|)
operator|.
name|add
argument_list|(
name|nodeId
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|NodeNotFoundException
argument_list|(
literal|"Node UUID: "
operator|+
name|nodeId
operator|+
literal|", not found in state: "
operator|+
name|currentState
argument_list|)
throw|;
block|}
block|}
finally|finally
block|{
name|lock
operator|.
name|writeLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Returns DatanodeInfo for the given node id.    *    * @param uuid Node Id    *    * @return DatanodeInfo of the node    *    * @throws NodeNotFoundException if the node is not present    */
DECL|method|getNodeInfo (UUID uuid)
specifier|public
name|DatanodeInfo
name|getNodeInfo
parameter_list|(
name|UUID
name|uuid
parameter_list|)
throws|throws
name|NodeNotFoundException
block|{
name|lock
operator|.
name|readLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkIfNodeExist
argument_list|(
name|uuid
argument_list|)
expr_stmt|;
return|return
name|nodeMap
operator|.
name|get
argument_list|(
name|uuid
argument_list|)
return|;
block|}
finally|finally
block|{
name|lock
operator|.
name|readLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Returns the list of node ids which are in the specified state.    *    * @param state NodeState    *    * @return list of node ids    */
DECL|method|getNodes (NodeState state)
specifier|public
name|List
argument_list|<
name|UUID
argument_list|>
name|getNodes
parameter_list|(
name|NodeState
name|state
parameter_list|)
block|{
name|lock
operator|.
name|readLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
return|return
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|stateMap
operator|.
name|get
argument_list|(
name|state
argument_list|)
argument_list|)
return|;
block|}
finally|finally
block|{
name|lock
operator|.
name|readLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Returns the list of all the node ids.    *    * @return list of all the node ids    */
DECL|method|getAllNodes ()
specifier|public
name|List
argument_list|<
name|UUID
argument_list|>
name|getAllNodes
parameter_list|()
block|{
name|lock
operator|.
name|readLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
return|return
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|nodeMap
operator|.
name|keySet
argument_list|()
argument_list|)
return|;
block|}
finally|finally
block|{
name|lock
operator|.
name|readLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Returns the count of nodes in the specified state.    *    * @param state NodeState    *    * @return Number of nodes in the specified state    */
DECL|method|getNodeCount (NodeState state)
specifier|public
name|int
name|getNodeCount
parameter_list|(
name|NodeState
name|state
parameter_list|)
block|{
name|lock
operator|.
name|readLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
return|return
name|stateMap
operator|.
name|get
argument_list|(
name|state
argument_list|)
operator|.
name|size
argument_list|()
return|;
block|}
finally|finally
block|{
name|lock
operator|.
name|readLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Returns the total node count.    *    * @return node count    */
DECL|method|getTotalNodeCount ()
specifier|public
name|int
name|getTotalNodeCount
parameter_list|()
block|{
name|lock
operator|.
name|readLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
return|return
name|nodeMap
operator|.
name|size
argument_list|()
return|;
block|}
finally|finally
block|{
name|lock
operator|.
name|readLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Returns the current state of the node.    *    * @param uuid node id    *    * @return NodeState    *    * @throws NodeNotFoundException if the node is not found    */
DECL|method|getNodeState (UUID uuid)
specifier|public
name|NodeState
name|getNodeState
parameter_list|(
name|UUID
name|uuid
parameter_list|)
throws|throws
name|NodeNotFoundException
block|{
name|lock
operator|.
name|readLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkIfNodeExist
argument_list|(
name|uuid
argument_list|)
expr_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|NodeState
argument_list|,
name|Set
argument_list|<
name|UUID
argument_list|>
argument_list|>
name|entry
range|:
name|stateMap
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
name|entry
operator|.
name|getValue
argument_list|()
operator|.
name|contains
argument_list|(
name|uuid
argument_list|)
condition|)
block|{
return|return
name|entry
operator|.
name|getKey
argument_list|()
return|;
block|}
block|}
throw|throw
operator|new
name|NodeNotFoundException
argument_list|(
literal|"Node not found in node state map."
operator|+
literal|" UUID: "
operator|+
name|uuid
argument_list|)
throw|;
block|}
finally|finally
block|{
name|lock
operator|.
name|readLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Adds the given container to the specified datanode.    *    * @param uuid - datanode uuid    * @param containerId - containerID    * @throws NodeNotFoundException - if datanode is not known. For new datanode    *                        use addDatanodeInContainerMap call.    */
DECL|method|addContainer (final UUID uuid, final ContainerID containerId)
specifier|public
name|void
name|addContainer
parameter_list|(
specifier|final
name|UUID
name|uuid
parameter_list|,
specifier|final
name|ContainerID
name|containerId
parameter_list|)
throws|throws
name|NodeNotFoundException
block|{
name|lock
operator|.
name|writeLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkIfNodeExist
argument_list|(
name|uuid
argument_list|)
expr_stmt|;
name|nodeToContainer
operator|.
name|get
argument_list|(
name|uuid
argument_list|)
operator|.
name|add
argument_list|(
name|containerId
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|writeLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|setContainers (UUID uuid, Set<ContainerID> containers)
specifier|public
name|void
name|setContainers
parameter_list|(
name|UUID
name|uuid
parameter_list|,
name|Set
argument_list|<
name|ContainerID
argument_list|>
name|containers
parameter_list|)
throws|throws
name|NodeNotFoundException
block|{
name|lock
operator|.
name|writeLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkIfNodeExist
argument_list|(
name|uuid
argument_list|)
expr_stmt|;
name|nodeToContainer
operator|.
name|put
argument_list|(
name|uuid
argument_list|,
name|containers
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|writeLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|getContainers (UUID uuid)
specifier|public
name|Set
argument_list|<
name|ContainerID
argument_list|>
name|getContainers
parameter_list|(
name|UUID
name|uuid
parameter_list|)
throws|throws
name|NodeNotFoundException
block|{
name|lock
operator|.
name|readLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkIfNodeExist
argument_list|(
name|uuid
argument_list|)
expr_stmt|;
return|return
name|Collections
operator|.
name|unmodifiableSet
argument_list|(
name|nodeToContainer
operator|.
name|get
argument_list|(
name|uuid
argument_list|)
argument_list|)
return|;
block|}
finally|finally
block|{
name|lock
operator|.
name|readLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|removeContainer (UUID uuid, ContainerID containerID)
specifier|public
name|void
name|removeContainer
parameter_list|(
name|UUID
name|uuid
parameter_list|,
name|ContainerID
name|containerID
parameter_list|)
throws|throws
name|NodeNotFoundException
block|{
name|lock
operator|.
name|writeLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkIfNodeExist
argument_list|(
name|uuid
argument_list|)
expr_stmt|;
name|nodeToContainer
operator|.
name|get
argument_list|(
name|uuid
argument_list|)
operator|.
name|remove
argument_list|(
name|containerID
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|writeLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Since we don't hold a global lock while constructing this string,    * the result might be inconsistent. If someone has changed the state of node    * while we are constructing the string, the result will be inconsistent.    * This should only be used for logging. We should not parse this string and    * use it for any critical calculations.    *    * @return current state of NodeStateMap    */
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|StringBuilder
name|builder
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|builder
operator|.
name|append
argument_list|(
literal|"Total number of nodes: "
argument_list|)
operator|.
name|append
argument_list|(
name|getTotalNodeCount
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|NodeState
name|state
range|:
name|NodeState
operator|.
name|values
argument_list|()
control|)
block|{
name|builder
operator|.
name|append
argument_list|(
literal|"Number of nodes in "
argument_list|)
operator|.
name|append
argument_list|(
name|state
argument_list|)
operator|.
name|append
argument_list|(
literal|" state: "
argument_list|)
operator|.
name|append
argument_list|(
name|getNodeCount
argument_list|(
name|state
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|builder
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * Throws NodeNotFoundException if the Node for given id doesn't exist.    *    * @param uuid Node UUID    * @throws NodeNotFoundException If the node is missing.    */
DECL|method|checkIfNodeExist (UUID uuid)
specifier|private
name|void
name|checkIfNodeExist
parameter_list|(
name|UUID
name|uuid
parameter_list|)
throws|throws
name|NodeNotFoundException
block|{
if|if
condition|(
operator|!
name|nodeToContainer
operator|.
name|containsKey
argument_list|(
name|uuid
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|NodeNotFoundException
argument_list|(
literal|"Node UUID: "
operator|+
name|uuid
argument_list|)
throw|;
block|}
block|}
block|}
end_class

end_unit

