begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdds.scm.container
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdds
operator|.
name|scm
operator|.
name|container
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdds
operator|.
name|protocol
operator|.
name|DatanodeDetails
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdds
operator|.
name|protocol
operator|.
name|proto
operator|.
name|HddsProtos
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdds
operator|.
name|protocol
operator|.
name|proto
operator|.
name|HddsProtos
operator|.
name|LifeCycleState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdds
operator|.
name|protocol
operator|.
name|proto
operator|.
name|StorageContainerDatanodeProtocolProtos
operator|.
name|ContainerReplicaProto
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdds
operator|.
name|protocol
operator|.
name|proto
operator|.
name|StorageContainerDatanodeProtocolProtos
operator|.
name|ContainerReplicaProto
operator|.
name|State
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdds
operator|.
name|server
operator|.
name|events
operator|.
name|EventPublisher
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ozone
operator|.
name|protocol
operator|.
name|commands
operator|.
name|CloseContainerCommand
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ozone
operator|.
name|protocol
operator|.
name|commands
operator|.
name|CommandForDatanode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Optional
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|UUID
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|stream
operator|.
name|Collectors
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdds
operator|.
name|scm
operator|.
name|events
operator|.
name|SCMEvents
operator|.
name|DATANODE_COMMAND
import|;
end_import

begin_comment
comment|/**  * Helper functions to handler container reports.  */
end_comment

begin_class
DECL|class|ReportHandlerHelper
specifier|public
specifier|final
class|class
name|ReportHandlerHelper
block|{
DECL|method|ReportHandlerHelper ()
specifier|private
name|ReportHandlerHelper
parameter_list|()
block|{}
comment|/**    * Processes the container replica and updates the container state in SCM.    * If needed, sends command to datanode to update the replica state.    *    * @param containerManager ContainerManager instance    * @param containerId Id of the container    * @param replicaProto replica of the container    * @param datanodeDetails datanode where the replica resides    * @param publisher event publisher    * @param logger for logging    * @throws IOException    */
DECL|method|processContainerReplica (final ContainerManager containerManager, final ContainerID containerId, final ContainerReplicaProto replicaProto, final DatanodeDetails datanodeDetails, final EventPublisher publisher, final Logger logger)
specifier|static
name|void
name|processContainerReplica
parameter_list|(
specifier|final
name|ContainerManager
name|containerManager
parameter_list|,
specifier|final
name|ContainerID
name|containerId
parameter_list|,
specifier|final
name|ContainerReplicaProto
name|replicaProto
parameter_list|,
specifier|final
name|DatanodeDetails
name|datanodeDetails
parameter_list|,
specifier|final
name|EventPublisher
name|publisher
parameter_list|,
specifier|final
name|Logger
name|logger
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|ContainerReplica
name|replica
init|=
name|ContainerReplica
operator|.
name|newBuilder
argument_list|()
operator|.
name|setContainerID
argument_list|(
name|containerId
argument_list|)
operator|.
name|setContainerState
argument_list|(
name|replicaProto
operator|.
name|getState
argument_list|()
argument_list|)
operator|.
name|setDatanodeDetails
argument_list|(
name|datanodeDetails
argument_list|)
operator|.
name|setOriginNodeId
argument_list|(
name|UUID
operator|.
name|fromString
argument_list|(
name|replicaProto
operator|.
name|getOriginNodeId
argument_list|()
argument_list|)
argument_list|)
operator|.
name|setSequenceId
argument_list|(
name|replicaProto
operator|.
name|getBlockCommitSequenceId
argument_list|()
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
comment|// This is an in-memory update.
name|containerManager
operator|.
name|updateContainerReplica
argument_list|(
name|containerId
argument_list|,
name|replica
argument_list|)
expr_stmt|;
name|ReportHandlerHelper
operator|.
name|reconcileContainerState
argument_list|(
name|containerManager
argument_list|,
name|containerId
argument_list|,
name|publisher
argument_list|,
name|logger
argument_list|)
expr_stmt|;
specifier|final
name|ContainerInfo
name|containerInfo
init|=
name|containerManager
operator|.
name|getContainer
argument_list|(
name|containerId
argument_list|)
decl_stmt|;
if|if
condition|(
name|containerInfo
operator|.
name|getUsedBytes
argument_list|()
operator|<
name|replicaProto
operator|.
name|getUsed
argument_list|()
condition|)
block|{
name|containerInfo
operator|.
name|setUsedBytes
argument_list|(
name|replicaProto
operator|.
name|getUsed
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|containerInfo
operator|.
name|getNumberOfKeys
argument_list|()
operator|<
name|replicaProto
operator|.
name|getKeyCount
argument_list|()
condition|)
block|{
name|containerInfo
operator|.
name|setNumberOfKeys
argument_list|(
name|replicaProto
operator|.
name|getKeyCount
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Now we have reconciled the container state. If the container state and
comment|// the replica state doesn't match, then take appropriate action.
name|ReportHandlerHelper
operator|.
name|sendReplicaCommands
argument_list|(
name|datanodeDetails
argument_list|,
name|containerInfo
argument_list|,
name|replica
argument_list|,
name|publisher
argument_list|,
name|logger
argument_list|)
expr_stmt|;
block|}
comment|/**    * Reconcile the container state based on the ContainerReplica states.    * ContainerState is updated after the reconciliation.    *    * @param manager ContainerManager    * @param containerId container id    * @throws ContainerNotFoundException    */
DECL|method|reconcileContainerState (final ContainerManager manager, final ContainerID containerId, final EventPublisher publisher, final Logger logger)
specifier|private
specifier|static
name|void
name|reconcileContainerState
parameter_list|(
specifier|final
name|ContainerManager
name|manager
parameter_list|,
specifier|final
name|ContainerID
name|containerId
parameter_list|,
specifier|final
name|EventPublisher
name|publisher
parameter_list|,
specifier|final
name|Logger
name|logger
parameter_list|)
throws|throws
name|IOException
block|{
comment|// TODO: handle unhealthy replica.
synchronized|synchronized
init|(
name|manager
operator|.
name|getContainer
argument_list|(
name|containerId
argument_list|)
init|)
block|{
specifier|final
name|ContainerInfo
name|container
init|=
name|manager
operator|.
name|getContainer
argument_list|(
name|containerId
argument_list|)
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|ContainerReplica
argument_list|>
name|replicas
init|=
name|manager
operator|.
name|getContainerReplicas
argument_list|(
name|containerId
argument_list|)
decl_stmt|;
specifier|final
name|LifeCycleState
name|containerState
init|=
name|container
operator|.
name|getState
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|containerState
condition|)
block|{
case|case
name|OPEN
case|:
comment|/*          * If the container state is OPEN.          * None of the replica should be in any other state.          *          */
name|List
argument_list|<
name|ContainerReplica
argument_list|>
name|invalidReplicas
init|=
name|replicas
operator|.
name|stream
argument_list|()
operator|.
name|filter
argument_list|(
name|replica
lambda|->
name|replica
operator|.
name|getState
argument_list|()
operator|!=
name|State
operator|.
name|OPEN
argument_list|)
operator|.
name|collect
argument_list|(
name|Collectors
operator|.
name|toList
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|invalidReplicas
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|logger
operator|.
name|warn
argument_list|(
literal|"Container {} has invalid replica state."
operator|+
literal|"Invalid Replicas: {}"
argument_list|,
name|containerId
argument_list|,
name|invalidReplicas
argument_list|)
expr_stmt|;
block|}
comment|// A container cannot be over replicated when in OPEN state.
break|break;
case|case
name|CLOSING
case|:
comment|/*          * SCM has asked DataNodes to close the container. Now the replicas          * can be in any of the following states.          *          * 1. OPEN          * 2. CLOSING          * 3. QUASI_CLOSED          * 4. CLOSED          *          * If all the replica are either in OPEN or CLOSING state, do nothing.          *          * If any one of the replica is in QUASI_CLOSED state, move the          * container to QUASI_CLOSED state.          *          * If any one of the replica is in CLOSED state, mark the container as          * CLOSED. The close has happened via Ratis.          *          */
name|Optional
argument_list|<
name|ContainerReplica
argument_list|>
name|closedReplica
init|=
name|replicas
operator|.
name|stream
argument_list|()
operator|.
name|filter
argument_list|(
name|replica
lambda|->
name|replica
operator|.
name|getState
argument_list|()
operator|==
name|State
operator|.
name|CLOSED
argument_list|)
operator|.
name|findFirst
argument_list|()
decl_stmt|;
if|if
condition|(
name|closedReplica
operator|.
name|isPresent
argument_list|()
condition|)
block|{
name|container
operator|.
name|updateSequenceId
argument_list|(
name|closedReplica
operator|.
name|get
argument_list|()
operator|.
name|getSequenceId
argument_list|()
argument_list|)
expr_stmt|;
name|manager
operator|.
name|updateContainerState
argument_list|(
name|containerId
argument_list|,
name|HddsProtos
operator|.
name|LifeCycleEvent
operator|.
name|CLOSE
argument_list|)
expr_stmt|;
comment|// TODO: remove container from OPEN pipeline, since the container is
comment|// closed we can go ahead and remove it from Ratis pipeline.
block|}
elseif|else
if|if
condition|(
name|replicas
operator|.
name|stream
argument_list|()
operator|.
name|anyMatch
argument_list|(
name|replica
lambda|->
name|replica
operator|.
name|getState
argument_list|()
operator|==
name|State
operator|.
name|QUASI_CLOSED
argument_list|)
condition|)
block|{
name|manager
operator|.
name|updateContainerState
argument_list|(
name|containerId
argument_list|,
name|HddsProtos
operator|.
name|LifeCycleEvent
operator|.
name|QUASI_CLOSE
argument_list|)
block|;         }
break|break;
case|case
name|QUASI_CLOSED
case|:
comment|/*          * The container is in QUASI_CLOSED state, this means that at least          * one of the replica is in QUASI_CLOSED/CLOSED state.          * Other replicas can be in any of the following state.          *          * 1. OPEN          * 2. CLOSING          * 3. QUASI_CLOSED          * 4. CLOSED          *          * If<50% of container replicas are in QUASI_CLOSED state and all          * the other replica are either in OPEN or CLOSING state, do nothing.          * We cannot identify the correct replica since we don't have quorum          * yet.          *          * If>50% (quorum) of replicas are in QUASI_CLOSED state and other          * replicas are either in OPEN or CLOSING state, try to identify          * the latest container replica using originNodeId and sequenceId.          * Force close those replica(s) which have the latest sequenceId.          *          * If at least one of the replica is in CLOSED state, mark the          * container as CLOSED. Force close the replicas which matches the          * sequenceId of the CLOSED replica.          *          */
if|if
condition|(
name|replicas
operator|.
name|stream
argument_list|()
operator|.
name|anyMatch
argument_list|(
name|replica
lambda|->
name|replica
operator|.
name|getState
argument_list|()
operator|==
name|State
operator|.
name|CLOSED
argument_list|)
condition|)
block|{
name|manager
operator|.
name|updateContainerState
argument_list|(
name|containerId
argument_list|,
name|HddsProtos
operator|.
name|LifeCycleEvent
operator|.
name|FORCE_CLOSE
argument_list|)
block|;
comment|// TODO: remove container from OPEN pipeline, since the container is
comment|// closed we can go ahead and remove it from Ratis pipeline.
block|}
else|else
block|{
specifier|final
name|int
name|replicationFactor
init|=
name|container
operator|.
name|getReplicationFactor
argument_list|()
operator|.
name|getNumber
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|ContainerReplica
argument_list|>
name|quasiClosedReplicas
init|=
name|replicas
operator|.
name|stream
argument_list|()
operator|.
name|filter
argument_list|(
name|replica
lambda|->
name|replica
operator|.
name|getState
argument_list|()
operator|==
name|State
operator|.
name|QUASI_CLOSED
argument_list|)
operator|.
name|collect
argument_list|(
name|Collectors
operator|.
name|toList
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|long
name|uniqueQuasiClosedReplicaCount
init|=
name|quasiClosedReplicas
operator|.
name|stream
argument_list|()
operator|.
name|map
argument_list|(
name|ContainerReplica
operator|::
name|getOriginDatanodeId
argument_list|)
operator|.
name|distinct
argument_list|()
operator|.
name|count
argument_list|()
decl_stmt|;
if|if
condition|(
name|uniqueQuasiClosedReplicaCount
operator|>
operator|(
name|replicationFactor
operator|/
literal|2
operator|)
condition|)
block|{
comment|// Quorum of unique replica has been QUASI_CLOSED
name|long
name|sequenceId
init|=
name|forceCloseContainerReplicaWithHighestSequenceId
argument_list|(
name|container
argument_list|,
name|quasiClosedReplicas
argument_list|,
name|publisher
argument_list|)
decl_stmt|;
if|if
condition|(
name|sequenceId
operator|!=
operator|-
literal|1L
condition|)
block|{
name|container
operator|.
name|updateSequenceId
argument_list|(
name|sequenceId
argument_list|)
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
name|CLOSED
case|:
comment|/*          * The container is already in closed state. do nothing.          */
break|break;
case|case
name|DELETING
case|:
comment|// Not handled.
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"Unsupported container state"
operator|+
literal|" 'DELETING'."
argument_list|)
throw|;
case|case
name|DELETED
case|:
comment|// Not handled.
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"Unsupported container state"
operator|+
literal|" 'DELETED'."
argument_list|)
throw|;
default|default:
break|break;
block|}
block|}
block|}
comment|/**    * Compares the QUASI_CLOSED replicas of a container and sends close command.    *    * @param quasiClosedReplicas list of quasi closed replicas    * @return the sequenceId of the closed replica.    */
DECL|method|forceCloseContainerReplicaWithHighestSequenceId ( final ContainerInfo container, final List<ContainerReplica> quasiClosedReplicas, final EventPublisher publisher)
specifier|private
specifier|static
name|long
name|forceCloseContainerReplicaWithHighestSequenceId
parameter_list|(
specifier|final
name|ContainerInfo
name|container
parameter_list|,
specifier|final
name|List
argument_list|<
name|ContainerReplica
argument_list|>
name|quasiClosedReplicas
parameter_list|,
specifier|final
name|EventPublisher
name|publisher
parameter_list|)
block|{
specifier|final
name|long
name|highestSequenceId
init|=
name|quasiClosedReplicas
operator|.
name|stream
argument_list|()
operator|.
name|map
argument_list|(
name|ContainerReplica
operator|::
name|getSequenceId
argument_list|)
operator|.
name|max
argument_list|(
name|Long
operator|::
name|compare
argument_list|)
operator|.
name|orElse
argument_list|(
operator|-
literal|1L
argument_list|)
decl_stmt|;
if|if
condition|(
name|highestSequenceId
operator|!=
operator|-
literal|1L
condition|)
block|{
name|quasiClosedReplicas
operator|.
name|stream
argument_list|()
operator|.
name|filter
argument_list|(
name|replica
lambda|->
name|replica
operator|.
name|getSequenceId
argument_list|()
operator|==
name|highestSequenceId
argument_list|)
operator|.
name|forEach
argument_list|(
name|replica
lambda|->
block|{
name|CloseContainerCommand
name|closeContainerCommand
operator|=
operator|new
name|CloseContainerCommand
argument_list|(
name|container
operator|.
name|getContainerID
argument_list|()
argument_list|,
name|container
operator|.
name|getPipelineID
argument_list|()
argument_list|,
literal|true
argument_list|)
argument_list|;
name|publisher
operator|.
name|fireEvent
argument_list|(
name|DATANODE_COMMAND
argument_list|,
operator|new
name|CommandForDatanode
argument_list|<>
argument_list|(
name|replica
operator|.
name|getDatanodeDetails
argument_list|()
operator|.
name|getUuid
argument_list|()
argument_list|,
name|closeContainerCommand
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|)
function|;
block|}
end_class

begin_return
return|return
name|highestSequenceId
return|;
end_return

begin_comment
unit|}
comment|/**    * Based on the container and replica state, send command to datanode if    * required.    *    * @param datanodeDetails datanode where the replica resides    * @param containerInfo container information    * @param replica replica information    * @param publisher queue to publish the datanode command event    * @param log for logging    */
end_comment

begin_function
DECL|method|sendReplicaCommands ( final DatanodeDetails datanodeDetails, final ContainerInfo containerInfo, final ContainerReplica replica, final EventPublisher publisher, final Logger log)
unit|static
name|void
name|sendReplicaCommands
parameter_list|(
specifier|final
name|DatanodeDetails
name|datanodeDetails
parameter_list|,
specifier|final
name|ContainerInfo
name|containerInfo
parameter_list|,
specifier|final
name|ContainerReplica
name|replica
parameter_list|,
specifier|final
name|EventPublisher
name|publisher
parameter_list|,
specifier|final
name|Logger
name|log
parameter_list|)
block|{
specifier|final
name|HddsProtos
operator|.
name|LifeCycleState
name|containerState
init|=
name|containerInfo
operator|.
name|getState
argument_list|()
decl_stmt|;
specifier|final
name|ContainerReplicaProto
operator|.
name|State
name|replicaState
init|=
name|replica
operator|.
name|getState
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|ReportHandlerHelper
operator|.
name|compareState
argument_list|(
name|containerState
argument_list|,
name|replicaState
argument_list|)
condition|)
block|{
if|if
condition|(
name|containerState
operator|==
name|HddsProtos
operator|.
name|LifeCycleState
operator|.
name|OPEN
condition|)
block|{
comment|// When a container state in SCM is OPEN, there is no way a datanode
comment|// can quasi close/close the container.
name|log
operator|.
name|warn
argument_list|(
literal|"Invalid container replica state for container {}"
operator|+
literal|" from datanode {}. Expected state is OPEN."
argument_list|,
name|containerInfo
operator|.
name|containerID
argument_list|()
argument_list|,
name|datanodeDetails
argument_list|)
expr_stmt|;
comment|// The replica can go CORRUPT, we have to handle it.
block|}
if|if
condition|(
name|containerState
operator|==
name|HddsProtos
operator|.
name|LifeCycleState
operator|.
name|CLOSING
operator|||
name|containerState
operator|==
name|HddsProtos
operator|.
name|LifeCycleState
operator|.
name|QUASI_CLOSED
condition|)
block|{
comment|// Resend close container event for this datanode if the container
comment|// replica state is OPEN/CLOSING.
if|if
condition|(
name|replicaState
operator|==
name|ContainerReplicaProto
operator|.
name|State
operator|.
name|OPEN
operator|||
name|replicaState
operator|==
name|ContainerReplicaProto
operator|.
name|State
operator|.
name|CLOSING
condition|)
block|{
name|CloseContainerCommand
name|closeContainerCommand
init|=
operator|new
name|CloseContainerCommand
argument_list|(
name|containerInfo
operator|.
name|getContainerID
argument_list|()
argument_list|,
name|containerInfo
operator|.
name|getPipelineID
argument_list|()
argument_list|)
decl_stmt|;
name|publisher
operator|.
name|fireEvent
argument_list|(
name|DATANODE_COMMAND
argument_list|,
operator|new
name|CommandForDatanode
argument_list|<>
argument_list|(
name|replica
operator|.
name|getDatanodeDetails
argument_list|()
operator|.
name|getUuid
argument_list|()
argument_list|,
name|closeContainerCommand
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|containerState
operator|==
name|HddsProtos
operator|.
name|LifeCycleState
operator|.
name|CLOSED
condition|)
block|{
if|if
condition|(
name|replicaState
operator|==
name|ContainerReplicaProto
operator|.
name|State
operator|.
name|OPEN
operator|||
name|replicaState
operator|==
name|ContainerReplicaProto
operator|.
name|State
operator|.
name|CLOSING
operator|||
name|replicaState
operator|==
name|ContainerReplicaProto
operator|.
name|State
operator|.
name|QUASI_CLOSED
condition|)
block|{
comment|// Send force close container event for this datanode if the container
comment|// replica state is OPEN/CLOSING/QUASI_CLOSED.
comment|// Close command will be send only if this replica matches the
comment|// sequence of the container.
if|if
condition|(
name|containerInfo
operator|.
name|getSequenceId
argument_list|()
operator|==
name|replica
operator|.
name|getSequenceId
argument_list|()
condition|)
block|{
name|CloseContainerCommand
name|closeContainerCommand
init|=
operator|new
name|CloseContainerCommand
argument_list|(
name|containerInfo
operator|.
name|getContainerID
argument_list|()
argument_list|,
name|containerInfo
operator|.
name|getPipelineID
argument_list|()
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|publisher
operator|.
name|fireEvent
argument_list|(
name|DATANODE_COMMAND
argument_list|,
operator|new
name|CommandForDatanode
argument_list|<>
argument_list|(
name|replica
operator|.
name|getDatanodeDetails
argument_list|()
operator|.
name|getUuid
argument_list|()
argument_list|,
name|closeContainerCommand
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// TODO: delete the replica if the BCSID doesn't match.
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/**    * Compares the container and replica state.    *    * @param containerState container state    * @param replicaState replica state    * @return true if the states are same, else false    */
end_comment

begin_function
DECL|method|compareState (final LifeCycleState containerState, final State replicaState)
specifier|private
specifier|static
name|boolean
name|compareState
parameter_list|(
specifier|final
name|LifeCycleState
name|containerState
parameter_list|,
specifier|final
name|State
name|replicaState
parameter_list|)
block|{
comment|// TODO: handle unhealthy replica.
switch|switch
condition|(
name|containerState
condition|)
block|{
case|case
name|OPEN
case|:
return|return
name|replicaState
operator|==
name|State
operator|.
name|OPEN
return|;
case|case
name|CLOSING
case|:
return|return
name|replicaState
operator|==
name|State
operator|.
name|CLOSING
return|;
case|case
name|QUASI_CLOSED
case|:
return|return
name|replicaState
operator|==
name|State
operator|.
name|QUASI_CLOSED
return|;
case|case
name|CLOSED
case|:
return|return
name|replicaState
operator|==
name|State
operator|.
name|CLOSED
return|;
case|case
name|DELETING
case|:
return|return
literal|false
return|;
case|case
name|DELETED
case|:
return|return
literal|false
return|;
default|default:
return|return
literal|false
return|;
block|}
block|}
end_function

unit|}
end_unit

