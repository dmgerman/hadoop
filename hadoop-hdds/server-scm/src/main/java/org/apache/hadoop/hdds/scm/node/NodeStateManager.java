begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdds.scm.node
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdds
operator|.
name|scm
operator|.
name|node
package|;
end_package

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ThreadFactoryBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdds
operator|.
name|protocol
operator|.
name|DatanodeDetails
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdds
operator|.
name|protocol
operator|.
name|proto
operator|.
name|HddsProtos
operator|.
name|NodeState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdds
operator|.
name|scm
operator|.
name|HddsServerUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdds
operator|.
name|scm
operator|.
name|container
operator|.
name|ContainerID
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdds
operator|.
name|scm
operator|.
name|pipeline
operator|.
name|Pipeline
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdds
operator|.
name|scm
operator|.
name|pipeline
operator|.
name|PipelineID
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdds
operator|.
name|scm
operator|.
name|container
operator|.
name|placement
operator|.
name|metrics
operator|.
name|SCMNodeStat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdds
operator|.
name|scm
operator|.
name|events
operator|.
name|SCMEvents
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdds
operator|.
name|scm
operator|.
name|node
operator|.
name|states
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdds
operator|.
name|scm
operator|.
name|node
operator|.
name|states
operator|.
name|Node2PipelineMap
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdds
operator|.
name|server
operator|.
name|events
operator|.
name|Event
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdds
operator|.
name|server
operator|.
name|events
operator|.
name|EventPublisher
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ozone
operator|.
name|common
operator|.
name|statemachine
operator|.
name|InvalidStateTransitionException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ozone
operator|.
name|common
operator|.
name|statemachine
operator|.
name|StateMachine
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Time
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|concurrent
operator|.
name|HadoopExecutors
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Closeable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ScheduledExecutorService
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|Predicate
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdds
operator|.
name|scm
operator|.
name|ScmConfigKeys
operator|.
name|OZONE_SCM_DEADNODE_INTERVAL
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdds
operator|.
name|scm
operator|.
name|ScmConfigKeys
operator|.
name|OZONE_SCM_HEARTBEAT_PROCESS_INTERVAL
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdds
operator|.
name|scm
operator|.
name|ScmConfigKeys
operator|.
name|OZONE_SCM_STALENODE_INTERVAL
import|;
end_import

begin_comment
comment|/**  * NodeStateManager maintains the state of all the datanodes in the cluster. All  * the node state change should happen only via NodeStateManager. It also  * runs a heartbeat thread which periodically updates the node state.  *<p>  * The getNode(byState) functions make copy of node maps and then creates a list  * based on that. It should be assumed that these get functions always report  * *stale* information. For example, getting the deadNodeCount followed by  * getNodes(DEAD) could very well produce totally different count. Also  * getNodeCount(HEALTHY) + getNodeCount(DEAD) + getNodeCode(STALE), is not  * guaranteed to add up to the total nodes that we know off. Please treat all  * get functions in this file as a snap-shot of information that is inconsistent  * as soon as you read it.  */
end_comment

begin_class
DECL|class|NodeStateManager
specifier|public
class|class
name|NodeStateManager
implements|implements
name|Runnable
implements|,
name|Closeable
block|{
comment|/**    * Node's life cycle events.    */
DECL|enum|NodeLifeCycleEvent
specifier|private
enum|enum
name|NodeLifeCycleEvent
block|{
DECL|enumConstant|TIMEOUT
DECL|enumConstant|RESTORE
DECL|enumConstant|RESURRECT
DECL|enumConstant|DECOMMISSION
DECL|enumConstant|DECOMMISSIONED
name|TIMEOUT
block|,
name|RESTORE
block|,
name|RESURRECT
block|,
name|DECOMMISSION
block|,
name|DECOMMISSIONED
block|}
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|NodeStateManager
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/**    * StateMachine for node lifecycle.    */
DECL|field|stateMachine
specifier|private
specifier|final
name|StateMachine
argument_list|<
name|NodeState
argument_list|,
name|NodeLifeCycleEvent
argument_list|>
name|stateMachine
decl_stmt|;
comment|/**    * This is the map which maintains the current state of all datanodes.    */
DECL|field|nodeStateMap
specifier|private
specifier|final
name|NodeStateMap
name|nodeStateMap
decl_stmt|;
comment|/**    * Maintains the mapping from node to pipelines a node is part of.    */
DECL|field|node2PipelineMap
specifier|private
specifier|final
name|Node2PipelineMap
name|node2PipelineMap
decl_stmt|;
comment|/**    * Used for publishing node state change events.    */
DECL|field|eventPublisher
specifier|private
specifier|final
name|EventPublisher
name|eventPublisher
decl_stmt|;
comment|/**    * Maps the event to be triggered when a node state us updated.    */
DECL|field|state2EventMap
specifier|private
specifier|final
name|Map
argument_list|<
name|NodeState
argument_list|,
name|Event
argument_list|<
name|DatanodeDetails
argument_list|>
argument_list|>
name|state2EventMap
decl_stmt|;
comment|/**    * ExecutorService used for scheduling heartbeat processing thread.    */
DECL|field|executorService
specifier|private
specifier|final
name|ScheduledExecutorService
name|executorService
decl_stmt|;
comment|/**    * The frequency in which we have run the heartbeat processing thread.    */
DECL|field|heartbeatCheckerIntervalMs
specifier|private
specifier|final
name|long
name|heartbeatCheckerIntervalMs
decl_stmt|;
comment|/**    * The timeout value which will be used for marking a datanode as stale.    */
DECL|field|staleNodeIntervalMs
specifier|private
specifier|final
name|long
name|staleNodeIntervalMs
decl_stmt|;
comment|/**    * The timeout value which will be used for marking a datanode as dead.    */
DECL|field|deadNodeIntervalMs
specifier|private
specifier|final
name|long
name|deadNodeIntervalMs
decl_stmt|;
comment|/**    * Constructs a NodeStateManager instance with the given configuration.    *    * @param conf Configuration    */
DECL|method|NodeStateManager (Configuration conf, EventPublisher eventPublisher)
specifier|public
name|NodeStateManager
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|EventPublisher
name|eventPublisher
parameter_list|)
block|{
name|this
operator|.
name|nodeStateMap
operator|=
operator|new
name|NodeStateMap
argument_list|()
expr_stmt|;
name|this
operator|.
name|node2PipelineMap
operator|=
operator|new
name|Node2PipelineMap
argument_list|()
expr_stmt|;
name|this
operator|.
name|eventPublisher
operator|=
name|eventPublisher
expr_stmt|;
name|this
operator|.
name|state2EventMap
operator|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
expr_stmt|;
name|initialiseState2EventMap
argument_list|()
expr_stmt|;
name|Set
argument_list|<
name|NodeState
argument_list|>
name|finalStates
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
name|finalStates
operator|.
name|add
argument_list|(
name|NodeState
operator|.
name|DECOMMISSIONED
argument_list|)
expr_stmt|;
name|this
operator|.
name|stateMachine
operator|=
operator|new
name|StateMachine
argument_list|<>
argument_list|(
name|NodeState
operator|.
name|HEALTHY
argument_list|,
name|finalStates
argument_list|)
expr_stmt|;
name|initializeStateMachine
argument_list|()
expr_stmt|;
name|heartbeatCheckerIntervalMs
operator|=
name|HddsServerUtil
operator|.
name|getScmheartbeatCheckerInterval
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|staleNodeIntervalMs
operator|=
name|HddsServerUtil
operator|.
name|getStaleNodeInterval
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|deadNodeIntervalMs
operator|=
name|HddsServerUtil
operator|.
name|getDeadNodeInterval
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkState
argument_list|(
name|heartbeatCheckerIntervalMs
operator|>
literal|0
argument_list|,
name|OZONE_SCM_HEARTBEAT_PROCESS_INTERVAL
operator|+
literal|" should be greater than 0."
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkState
argument_list|(
name|staleNodeIntervalMs
operator|<
name|deadNodeIntervalMs
argument_list|,
name|OZONE_SCM_STALENODE_INTERVAL
operator|+
literal|" should be less than"
operator|+
name|OZONE_SCM_DEADNODE_INTERVAL
argument_list|)
expr_stmt|;
name|executorService
operator|=
name|HadoopExecutors
operator|.
name|newScheduledThreadPool
argument_list|(
literal|1
argument_list|,
operator|new
name|ThreadFactoryBuilder
argument_list|()
operator|.
name|setDaemon
argument_list|(
literal|true
argument_list|)
operator|.
name|setNameFormat
argument_list|(
literal|"SCM Heartbeat Processing Thread - %d"
argument_list|)
operator|.
name|build
argument_list|()
argument_list|)
expr_stmt|;
name|executorService
operator|.
name|schedule
argument_list|(
name|this
argument_list|,
name|heartbeatCheckerIntervalMs
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
expr_stmt|;
block|}
comment|/**    * Populates state2event map.    */
DECL|method|initialiseState2EventMap ()
specifier|private
name|void
name|initialiseState2EventMap
parameter_list|()
block|{
name|state2EventMap
operator|.
name|put
argument_list|(
name|NodeState
operator|.
name|STALE
argument_list|,
name|SCMEvents
operator|.
name|STALE_NODE
argument_list|)
expr_stmt|;
name|state2EventMap
operator|.
name|put
argument_list|(
name|NodeState
operator|.
name|DEAD
argument_list|,
name|SCMEvents
operator|.
name|DEAD_NODE
argument_list|)
expr_stmt|;
block|}
comment|/*    *    * Node and State Transition Mapping:    *    * State: HEALTHY         -------------------> STALE    * Event:                       TIMEOUT    *    * State: STALE           -------------------> DEAD    * Event:                       TIMEOUT    *    * State: STALE           -------------------> HEALTHY    * Event:                       RESTORE    *    * State: DEAD            -------------------> HEALTHY    * Event:                       RESURRECT    *    * State: HEALTHY         -------------------> DECOMMISSIONING    * Event:                     DECOMMISSION    *    * State: STALE           -------------------> DECOMMISSIONING    * Event:                     DECOMMISSION    *    * State: DEAD            -------------------> DECOMMISSIONING    * Event:                     DECOMMISSION    *    * State: DECOMMISSIONING -------------------> DECOMMISSIONED    * Event:                     DECOMMISSIONED    *    *  Node State Flow    *    *  +--------------------------------------------------------+    *  |                                     (RESURRECT)        |    *  |   +--------------------------+                         |    *  |   |      (RESTORE)           |                         |    *  |   |                          |                         |    *  V   V                          |                         |    * [HEALTHY]------------------->[STALE]------------------->[DEAD]    *    |         (TIMEOUT)          |         (TIMEOUT)       |    *    |                            |                         |    *    |                            |                         |    *    |                            |                         |    *    |                            |                         |    *    | (DECOMMISSION)             | (DECOMMISSION)          | (DECOMMISSION)    *    |                            V                         |    *    +------------------->[DECOMMISSIONING]<----------------+    *                                 |    *                                 | (DECOMMISSIONED)    *                                 |    *                                 V    *                          [DECOMMISSIONED]    *    */
comment|/**    * Initializes the lifecycle of node state machine.    */
DECL|method|initializeStateMachine ()
specifier|private
name|void
name|initializeStateMachine
parameter_list|()
block|{
name|stateMachine
operator|.
name|addTransition
argument_list|(
name|NodeState
operator|.
name|HEALTHY
argument_list|,
name|NodeState
operator|.
name|STALE
argument_list|,
name|NodeLifeCycleEvent
operator|.
name|TIMEOUT
argument_list|)
expr_stmt|;
name|stateMachine
operator|.
name|addTransition
argument_list|(
name|NodeState
operator|.
name|STALE
argument_list|,
name|NodeState
operator|.
name|DEAD
argument_list|,
name|NodeLifeCycleEvent
operator|.
name|TIMEOUT
argument_list|)
expr_stmt|;
name|stateMachine
operator|.
name|addTransition
argument_list|(
name|NodeState
operator|.
name|STALE
argument_list|,
name|NodeState
operator|.
name|HEALTHY
argument_list|,
name|NodeLifeCycleEvent
operator|.
name|RESTORE
argument_list|)
expr_stmt|;
name|stateMachine
operator|.
name|addTransition
argument_list|(
name|NodeState
operator|.
name|DEAD
argument_list|,
name|NodeState
operator|.
name|HEALTHY
argument_list|,
name|NodeLifeCycleEvent
operator|.
name|RESURRECT
argument_list|)
expr_stmt|;
name|stateMachine
operator|.
name|addTransition
argument_list|(
name|NodeState
operator|.
name|HEALTHY
argument_list|,
name|NodeState
operator|.
name|DECOMMISSIONING
argument_list|,
name|NodeLifeCycleEvent
operator|.
name|DECOMMISSION
argument_list|)
expr_stmt|;
name|stateMachine
operator|.
name|addTransition
argument_list|(
name|NodeState
operator|.
name|STALE
argument_list|,
name|NodeState
operator|.
name|DECOMMISSIONING
argument_list|,
name|NodeLifeCycleEvent
operator|.
name|DECOMMISSION
argument_list|)
expr_stmt|;
name|stateMachine
operator|.
name|addTransition
argument_list|(
name|NodeState
operator|.
name|DEAD
argument_list|,
name|NodeState
operator|.
name|DECOMMISSIONING
argument_list|,
name|NodeLifeCycleEvent
operator|.
name|DECOMMISSION
argument_list|)
expr_stmt|;
name|stateMachine
operator|.
name|addTransition
argument_list|(
name|NodeState
operator|.
name|DECOMMISSIONING
argument_list|,
name|NodeState
operator|.
name|DECOMMISSIONED
argument_list|,
name|NodeLifeCycleEvent
operator|.
name|DECOMMISSIONED
argument_list|)
expr_stmt|;
block|}
comment|/**    * Adds a new node to the state manager.    *    * @param datanodeDetails DatanodeDetails    *    * @throws NodeAlreadyExistsException if the node is already present    */
DECL|method|addNode (DatanodeDetails datanodeDetails)
specifier|public
name|void
name|addNode
parameter_list|(
name|DatanodeDetails
name|datanodeDetails
parameter_list|)
throws|throws
name|NodeAlreadyExistsException
block|{
name|nodeStateMap
operator|.
name|addNode
argument_list|(
name|datanodeDetails
argument_list|,
name|stateMachine
operator|.
name|getInitialState
argument_list|()
argument_list|)
expr_stmt|;
name|eventPublisher
operator|.
name|fireEvent
argument_list|(
name|SCMEvents
operator|.
name|NEW_NODE
argument_list|,
name|datanodeDetails
argument_list|)
expr_stmt|;
block|}
comment|/**    * Adds a pipeline in the node2PipelineMap.    * @param pipeline - Pipeline to be added    */
DECL|method|addPipeline (Pipeline pipeline)
specifier|public
name|void
name|addPipeline
parameter_list|(
name|Pipeline
name|pipeline
parameter_list|)
block|{
name|node2PipelineMap
operator|.
name|addPipeline
argument_list|(
name|pipeline
argument_list|)
expr_stmt|;
block|}
comment|/**    * Get information about the node.    *    * @param datanodeDetails DatanodeDetails    *    * @return DatanodeInfo    *    * @throws NodeNotFoundException if the node is not present    */
DECL|method|getNode (DatanodeDetails datanodeDetails)
specifier|public
name|DatanodeInfo
name|getNode
parameter_list|(
name|DatanodeDetails
name|datanodeDetails
parameter_list|)
throws|throws
name|NodeNotFoundException
block|{
return|return
name|nodeStateMap
operator|.
name|getNodeInfo
argument_list|(
name|datanodeDetails
operator|.
name|getUuid
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Updates the last heartbeat time of the node.    *    * @throws NodeNotFoundException if the node is not present    */
DECL|method|updateLastHeartbeatTime (DatanodeDetails datanodeDetails)
specifier|public
name|void
name|updateLastHeartbeatTime
parameter_list|(
name|DatanodeDetails
name|datanodeDetails
parameter_list|)
throws|throws
name|NodeNotFoundException
block|{
name|nodeStateMap
operator|.
name|getNodeInfo
argument_list|(
name|datanodeDetails
operator|.
name|getUuid
argument_list|()
argument_list|)
operator|.
name|updateLastHeartbeatTime
argument_list|()
expr_stmt|;
block|}
comment|/**    * Returns the current state of the node.    *    * @param datanodeDetails DatanodeDetails    *    * @return NodeState    *    * @throws NodeNotFoundException if the node is not present    */
DECL|method|getNodeState (DatanodeDetails datanodeDetails)
specifier|public
name|NodeState
name|getNodeState
parameter_list|(
name|DatanodeDetails
name|datanodeDetails
parameter_list|)
throws|throws
name|NodeNotFoundException
block|{
return|return
name|nodeStateMap
operator|.
name|getNodeState
argument_list|(
name|datanodeDetails
operator|.
name|getUuid
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Returns all the node which are in healthy state.    *    * @return list of healthy nodes    */
DECL|method|getHealthyNodes ()
specifier|public
name|List
argument_list|<
name|DatanodeDetails
argument_list|>
name|getHealthyNodes
parameter_list|()
block|{
return|return
name|getNodes
argument_list|(
name|NodeState
operator|.
name|HEALTHY
argument_list|)
return|;
block|}
comment|/**    * Returns all the node which are in stale state.    *    * @return list of stale nodes    */
DECL|method|getStaleNodes ()
specifier|public
name|List
argument_list|<
name|DatanodeDetails
argument_list|>
name|getStaleNodes
parameter_list|()
block|{
return|return
name|getNodes
argument_list|(
name|NodeState
operator|.
name|STALE
argument_list|)
return|;
block|}
comment|/**    * Returns all the node which are in dead state.    *    * @return list of dead nodes    */
DECL|method|getDeadNodes ()
specifier|public
name|List
argument_list|<
name|DatanodeDetails
argument_list|>
name|getDeadNodes
parameter_list|()
block|{
return|return
name|getNodes
argument_list|(
name|NodeState
operator|.
name|DEAD
argument_list|)
return|;
block|}
comment|/**    * Returns all the node which are in the specified state.    *    * @param state NodeState    *    * @return list of nodes    */
DECL|method|getNodes (NodeState state)
specifier|public
name|List
argument_list|<
name|DatanodeDetails
argument_list|>
name|getNodes
parameter_list|(
name|NodeState
name|state
parameter_list|)
block|{
name|List
argument_list|<
name|DatanodeDetails
argument_list|>
name|nodes
init|=
operator|new
name|LinkedList
argument_list|<>
argument_list|()
decl_stmt|;
name|nodeStateMap
operator|.
name|getNodes
argument_list|(
name|state
argument_list|)
operator|.
name|forEach
argument_list|(
name|uuid
lambda|->
block|{
try|try
block|{
name|nodes
operator|.
name|add
argument_list|(
name|nodeStateMap
operator|.
name|getNodeDetails
argument_list|(
name|uuid
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NodeNotFoundException
name|e
parameter_list|)
block|{
comment|// This should not happen unless someone else other than
comment|// NodeStateManager is directly modifying NodeStateMap and removed
comment|// the node entry after we got the list of UUIDs.
name|LOG
operator|.
name|error
argument_list|(
literal|"Inconsistent NodeStateMap! "
operator|+
name|nodeStateMap
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
return|return
name|nodes
return|;
block|}
comment|/**    * Returns all the nodes which have registered to NodeStateManager.    *    * @return all the managed nodes    */
DECL|method|getAllNodes ()
specifier|public
name|List
argument_list|<
name|DatanodeDetails
argument_list|>
name|getAllNodes
parameter_list|()
block|{
name|List
argument_list|<
name|DatanodeDetails
argument_list|>
name|nodes
init|=
operator|new
name|LinkedList
argument_list|<>
argument_list|()
decl_stmt|;
name|nodeStateMap
operator|.
name|getAllNodes
argument_list|()
operator|.
name|forEach
argument_list|(
name|uuid
lambda|->
block|{
try|try
block|{
name|nodes
operator|.
name|add
argument_list|(
name|nodeStateMap
operator|.
name|getNodeDetails
argument_list|(
name|uuid
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NodeNotFoundException
name|e
parameter_list|)
block|{
comment|// This should not happen unless someone else other than
comment|// NodeStateManager is directly modifying NodeStateMap and removed
comment|// the node entry after we got the list of UUIDs.
name|LOG
operator|.
name|error
argument_list|(
literal|"Inconsistent NodeStateMap! "
operator|+
name|nodeStateMap
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
return|return
name|nodes
return|;
block|}
comment|/**    * Gets set of pipelineID a datanode belongs to.    * @param dnId - Datanode ID    * @return Set of PipelineID    */
DECL|method|getPipelineByDnID (UUID dnId)
specifier|public
name|Set
argument_list|<
name|PipelineID
argument_list|>
name|getPipelineByDnID
parameter_list|(
name|UUID
name|dnId
parameter_list|)
block|{
return|return
name|node2PipelineMap
operator|.
name|getPipelines
argument_list|(
name|dnId
argument_list|)
return|;
block|}
comment|/**    * Returns the count of healthy nodes.    *    * @return healthy node count    */
DECL|method|getHealthyNodeCount ()
specifier|public
name|int
name|getHealthyNodeCount
parameter_list|()
block|{
return|return
name|getNodeCount
argument_list|(
name|NodeState
operator|.
name|HEALTHY
argument_list|)
return|;
block|}
comment|/**    * Returns the count of stale nodes.    *    * @return stale node count    */
DECL|method|getStaleNodeCount ()
specifier|public
name|int
name|getStaleNodeCount
parameter_list|()
block|{
return|return
name|getNodeCount
argument_list|(
name|NodeState
operator|.
name|STALE
argument_list|)
return|;
block|}
comment|/**    * Returns the count of dead nodes.    *    * @return dead node count    */
DECL|method|getDeadNodeCount ()
specifier|public
name|int
name|getDeadNodeCount
parameter_list|()
block|{
return|return
name|getNodeCount
argument_list|(
name|NodeState
operator|.
name|DEAD
argument_list|)
return|;
block|}
comment|/**    * Returns the count of nodes in specified state.    *    * @param state NodeState    *    * @return node count    */
DECL|method|getNodeCount (NodeState state)
specifier|public
name|int
name|getNodeCount
parameter_list|(
name|NodeState
name|state
parameter_list|)
block|{
return|return
name|nodeStateMap
operator|.
name|getNodeCount
argument_list|(
name|state
argument_list|)
return|;
block|}
comment|/**    * Returns the count of all nodes managed by NodeStateManager.    *    * @return node count    */
DECL|method|getTotalNodeCount ()
specifier|public
name|int
name|getTotalNodeCount
parameter_list|()
block|{
return|return
name|nodeStateMap
operator|.
name|getTotalNodeCount
argument_list|()
return|;
block|}
comment|/**    * Returns the current stats of the node.    *    * @param uuid node id    *    * @return SCMNodeStat    *    * @throws NodeNotFoundException if the node is not present    */
DECL|method|getNodeStat (UUID uuid)
specifier|public
name|SCMNodeStat
name|getNodeStat
parameter_list|(
name|UUID
name|uuid
parameter_list|)
throws|throws
name|NodeNotFoundException
block|{
return|return
name|nodeStateMap
operator|.
name|getNodeStat
argument_list|(
name|uuid
argument_list|)
return|;
block|}
comment|/**    * Returns a unmodifiable copy of nodeStats.    * @return map with node stats.    */
DECL|method|getNodeStatsMap ()
specifier|public
name|Map
argument_list|<
name|UUID
argument_list|,
name|SCMNodeStat
argument_list|>
name|getNodeStatsMap
parameter_list|()
block|{
return|return
name|nodeStateMap
operator|.
name|getNodeStats
argument_list|()
return|;
block|}
comment|/**    * Set the stat for the node.    *    * @param uuid node id.    *    * @param newstat new stat that will set to the specify node.    */
DECL|method|setNodeStat (UUID uuid, SCMNodeStat newstat)
specifier|public
name|void
name|setNodeStat
parameter_list|(
name|UUID
name|uuid
parameter_list|,
name|SCMNodeStat
name|newstat
parameter_list|)
block|{
name|nodeStateMap
operator|.
name|setNodeStat
argument_list|(
name|uuid
argument_list|,
name|newstat
argument_list|)
expr_stmt|;
block|}
comment|/**    * Removes a pipeline from the node2PipelineMap.    * @param pipeline - Pipeline to be removed    */
DECL|method|removePipeline (Pipeline pipeline)
specifier|public
name|void
name|removePipeline
parameter_list|(
name|Pipeline
name|pipeline
parameter_list|)
block|{
name|node2PipelineMap
operator|.
name|removePipeline
argument_list|(
name|pipeline
argument_list|)
expr_stmt|;
block|}
comment|/**    * Update set of containers available on a datanode.    * @param uuid - DatanodeID    * @param containerIds - Set of containerIDs    * @throws NodeNotFoundException - if datanode is not known.    */
DECL|method|setContainers (UUID uuid, Set<ContainerID> containerIds)
specifier|public
name|void
name|setContainers
parameter_list|(
name|UUID
name|uuid
parameter_list|,
name|Set
argument_list|<
name|ContainerID
argument_list|>
name|containerIds
parameter_list|)
throws|throws
name|NodeNotFoundException
block|{
name|nodeStateMap
operator|.
name|setContainers
argument_list|(
name|uuid
argument_list|,
name|containerIds
argument_list|)
expr_stmt|;
block|}
comment|/**    * Return set of containerIDs available on a datanode.    * @param uuid - DatanodeID    * @return - set of containerIDs    */
DECL|method|getContainers (UUID uuid)
specifier|public
name|Set
argument_list|<
name|ContainerID
argument_list|>
name|getContainers
parameter_list|(
name|UUID
name|uuid
parameter_list|)
throws|throws
name|NodeNotFoundException
block|{
return|return
name|nodeStateMap
operator|.
name|getContainers
argument_list|(
name|uuid
argument_list|)
return|;
block|}
comment|/**    * Move Stale or Dead node to healthy if we got a heartbeat from them.    * Move healthy nodes to stale nodes if it is needed.    * Move Stales node to dead if needed.    *    * @see Thread#run()    */
annotation|@
name|Override
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
comment|/*      *      *          staleNodeDeadline                healthyNodeDeadline      *                 |                                  |      *      Dead       |             Stale                |     Healthy      *      Node       |             Node                 |     Node      *      Window     |             Window               |     Window      * ----------------+----------------------------------+------------------->      *>>-->> time-line>>-->>      *      * Here is the logic of computing the health of a node. âââââ* âââââ*â1. We get the current time and look back that the time âââââ*â   when we got a heartbeat from a node. âââââ*â âââââ*â2. If the last heartbeat was within the window of healthy node we mark âââââ*â   it as healthy. âââââ*â âââââ*â3. If the last HB Time stamp is longer and falls within the window of âââââ*â   Stale Node time, we will mark it as Stale. âââââ*â âââââ*â4. If the last HB time is older than the Stale Window, then the node is âââââ*    marked as dead.      *      * The Processing starts from current time and looks backwards in time.      */
name|long
name|processingStartTime
init|=
name|Time
operator|.
name|monotonicNow
argument_list|()
decl_stmt|;
comment|// After this time node is considered to be stale.
name|long
name|healthyNodeDeadline
init|=
name|processingStartTime
operator|-
name|staleNodeIntervalMs
decl_stmt|;
comment|// After this time node is considered to be dead.
name|long
name|staleNodeDeadline
init|=
name|processingStartTime
operator|-
name|deadNodeIntervalMs
decl_stmt|;
name|Predicate
argument_list|<
name|Long
argument_list|>
name|healthyNodeCondition
init|=
parameter_list|(
name|lastHbTime
parameter_list|)
lambda|->
name|lastHbTime
operator|>=
name|healthyNodeDeadline
decl_stmt|;
comment|// staleNodeCondition is superset of stale and dead node
name|Predicate
argument_list|<
name|Long
argument_list|>
name|staleNodeCondition
init|=
parameter_list|(
name|lastHbTime
parameter_list|)
lambda|->
name|lastHbTime
operator|<
name|healthyNodeDeadline
decl_stmt|;
name|Predicate
argument_list|<
name|Long
argument_list|>
name|deadNodeCondition
init|=
parameter_list|(
name|lastHbTime
parameter_list|)
lambda|->
name|lastHbTime
operator|<
name|staleNodeDeadline
decl_stmt|;
try|try
block|{
for|for
control|(
name|NodeState
name|state
range|:
name|NodeState
operator|.
name|values
argument_list|()
control|)
block|{
name|List
argument_list|<
name|UUID
argument_list|>
name|nodes
init|=
name|nodeStateMap
operator|.
name|getNodes
argument_list|(
name|state
argument_list|)
decl_stmt|;
for|for
control|(
name|UUID
name|id
range|:
name|nodes
control|)
block|{
name|DatanodeInfo
name|node
init|=
name|nodeStateMap
operator|.
name|getNodeInfo
argument_list|(
name|id
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|HEALTHY
case|:
comment|// Move the node to STALE if the last heartbeat time is less than
comment|// configured stale-node interval.
name|updateNodeState
argument_list|(
name|node
argument_list|,
name|staleNodeCondition
argument_list|,
name|state
argument_list|,
name|NodeLifeCycleEvent
operator|.
name|TIMEOUT
argument_list|)
expr_stmt|;
break|break;
case|case
name|STALE
case|:
comment|// Move the node to DEAD if the last heartbeat time is less than
comment|// configured dead-node interval.
name|updateNodeState
argument_list|(
name|node
argument_list|,
name|deadNodeCondition
argument_list|,
name|state
argument_list|,
name|NodeLifeCycleEvent
operator|.
name|TIMEOUT
argument_list|)
expr_stmt|;
comment|// Restore the node if we have received heartbeat before configured
comment|// stale-node interval.
name|updateNodeState
argument_list|(
name|node
argument_list|,
name|healthyNodeCondition
argument_list|,
name|state
argument_list|,
name|NodeLifeCycleEvent
operator|.
name|RESTORE
argument_list|)
expr_stmt|;
break|break;
case|case
name|DEAD
case|:
comment|// Resurrect the node if we have received heartbeat before
comment|// configured stale-node interval.
name|updateNodeState
argument_list|(
name|node
argument_list|,
name|healthyNodeCondition
argument_list|,
name|state
argument_list|,
name|NodeLifeCycleEvent
operator|.
name|RESURRECT
argument_list|)
expr_stmt|;
break|break;
comment|// We don't do anything for DECOMMISSIONING and DECOMMISSIONED in
comment|// heartbeat processing.
case|case
name|DECOMMISSIONING
case|:
case|case
name|DECOMMISSIONED
case|:
default|default:
block|}
block|}
block|}
block|}
catch|catch
parameter_list|(
name|NodeNotFoundException
name|e
parameter_list|)
block|{
comment|// This should not happen unless someone else other than
comment|// NodeStateManager is directly modifying NodeStateMap and removed
comment|// the node entry after we got the list of UUIDs.
name|LOG
operator|.
name|error
argument_list|(
literal|"Inconsistent NodeStateMap! "
operator|+
name|nodeStateMap
argument_list|)
expr_stmt|;
block|}
name|long
name|processingEndTime
init|=
name|Time
operator|.
name|monotonicNow
argument_list|()
decl_stmt|;
comment|//If we have taken too much time for HB processing, log that information.
if|if
condition|(
operator|(
name|processingEndTime
operator|-
name|processingStartTime
operator|)
operator|>
name|heartbeatCheckerIntervalMs
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Total time spend processing datanode HB's is greater than "
operator|+
literal|"configured values for datanode heartbeats. Please adjust the"
operator|+
literal|" heartbeat configs. Time Spend on HB processing: {} seconds "
operator|+
literal|"Datanode heartbeat Interval: {} seconds."
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
operator|.
name|toSeconds
argument_list|(
name|processingEndTime
operator|-
name|processingStartTime
argument_list|)
argument_list|,
name|heartbeatCheckerIntervalMs
argument_list|)
expr_stmt|;
block|}
comment|// we purposefully make this non-deterministic. Instead of using a
comment|// scheduleAtFixedFrequency  we will just go to sleep
comment|// and wake up at the next rendezvous point, which is currentTime +
comment|// heartbeatCheckerIntervalMs. This leads to the issue that we are now
comment|// heart beating not at a fixed cadence, but clock tick + time taken to
comment|// work.
comment|//
comment|// This time taken to work can skew the heartbeat processor thread.
comment|// The reason why we don't care is because of the following reasons.
comment|//
comment|// 1. checkerInterval is general many magnitudes faster than datanode HB
comment|// frequency.
comment|//
comment|// 2. if we have too much nodes, the SCM would be doing only HB
comment|// processing, this could lead to SCM's CPU starvation. With this
comment|// approach we always guarantee that  HB thread sleeps for a little while.
comment|//
comment|// 3. It is possible that we will never finish processing the HB's in the
comment|// thread. But that means we have a mis-configured system. We will warn
comment|// the users by logging that information.
comment|//
comment|// 4. And the most important reason, heartbeats are not blocked even if
comment|// this thread does not run, they will go into the processing queue.
if|if
condition|(
operator|!
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|isInterrupted
argument_list|()
operator|&&
operator|!
name|executorService
operator|.
name|isShutdown
argument_list|()
condition|)
block|{
name|executorService
operator|.
name|schedule
argument_list|(
name|this
argument_list|,
name|heartbeatCheckerIntervalMs
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Current Thread is interrupted, shutting down HB processing "
operator|+
literal|"thread for Node Manager."
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Updates the node state if the condition satisfies.    *    * @param node DatanodeInfo    * @param condition condition to check    * @param state current state of node    * @param lifeCycleEvent NodeLifeCycleEvent to be applied if condition    *                       matches    *    * @throws NodeNotFoundException if the node is not present    */
DECL|method|updateNodeState (DatanodeInfo node, Predicate<Long> condition, NodeState state, NodeLifeCycleEvent lifeCycleEvent)
specifier|private
name|void
name|updateNodeState
parameter_list|(
name|DatanodeInfo
name|node
parameter_list|,
name|Predicate
argument_list|<
name|Long
argument_list|>
name|condition
parameter_list|,
name|NodeState
name|state
parameter_list|,
name|NodeLifeCycleEvent
name|lifeCycleEvent
parameter_list|)
throws|throws
name|NodeNotFoundException
block|{
try|try
block|{
if|if
condition|(
name|condition
operator|.
name|test
argument_list|(
name|node
operator|.
name|getLastHeartbeatTime
argument_list|()
argument_list|)
condition|)
block|{
name|NodeState
name|newState
init|=
name|stateMachine
operator|.
name|getNextState
argument_list|(
name|state
argument_list|,
name|lifeCycleEvent
argument_list|)
decl_stmt|;
name|nodeStateMap
operator|.
name|updateNodeState
argument_list|(
name|node
operator|.
name|getUuid
argument_list|()
argument_list|,
name|state
argument_list|,
name|newState
argument_list|)
expr_stmt|;
if|if
condition|(
name|state2EventMap
operator|.
name|containsKey
argument_list|(
name|newState
argument_list|)
condition|)
block|{
name|eventPublisher
operator|.
name|fireEvent
argument_list|(
name|state2EventMap
operator|.
name|get
argument_list|(
name|newState
argument_list|)
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|InvalidStateTransitionException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Invalid state transition of node {}."
operator|+
literal|" Current state: {}, life cycle event: {}"
argument_list|,
name|node
argument_list|,
name|state
argument_list|,
name|lifeCycleEvent
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|close ()
specifier|public
name|void
name|close
parameter_list|()
block|{
name|executorService
operator|.
name|shutdown
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
operator|!
name|executorService
operator|.
name|awaitTermination
argument_list|(
literal|5
argument_list|,
name|TimeUnit
operator|.
name|SECONDS
argument_list|)
condition|)
block|{
name|executorService
operator|.
name|shutdownNow
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|executorService
operator|.
name|awaitTermination
argument_list|(
literal|5
argument_list|,
name|TimeUnit
operator|.
name|SECONDS
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to shutdown NodeStateManager properly."
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|executorService
operator|.
name|shutdownNow
argument_list|()
expr_stmt|;
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

