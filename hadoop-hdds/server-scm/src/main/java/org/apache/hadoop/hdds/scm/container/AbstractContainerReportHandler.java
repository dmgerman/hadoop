begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdds.scm.container
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdds
operator|.
name|scm
operator|.
name|container
package|;
end_package

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdds
operator|.
name|protocol
operator|.
name|DatanodeDetails
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdds
operator|.
name|protocol
operator|.
name|proto
operator|.
name|HddsProtos
operator|.
name|LifeCycleEvent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdds
operator|.
name|protocol
operator|.
name|proto
operator|.
name|StorageContainerDatanodeProtocolProtos
operator|.
name|ContainerReplicaProto
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdds
operator|.
name|protocol
operator|.
name|proto
operator|.
name|StorageContainerDatanodeProtocolProtos
operator|.
name|ContainerReplicaProto
operator|.
name|State
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|UUID
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|Supplier
import|;
end_import

begin_comment
comment|/**  * Base class for all the container report handlers.  */
end_comment

begin_class
DECL|class|AbstractContainerReportHandler
specifier|public
class|class
name|AbstractContainerReportHandler
block|{
DECL|field|containerManager
specifier|private
specifier|final
name|ContainerManager
name|containerManager
decl_stmt|;
DECL|field|logger
specifier|private
specifier|final
name|Logger
name|logger
decl_stmt|;
comment|/**    * Constructs AbstractContainerReportHandler instance with the    * given ContainerManager instance.    *    * @param containerManager ContainerManager    * @param logger Logger to be used for logging    */
DECL|method|AbstractContainerReportHandler (final ContainerManager containerManager, final Logger logger)
name|AbstractContainerReportHandler
parameter_list|(
specifier|final
name|ContainerManager
name|containerManager
parameter_list|,
specifier|final
name|Logger
name|logger
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|containerManager
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|logger
argument_list|)
expr_stmt|;
name|this
operator|.
name|containerManager
operator|=
name|containerManager
expr_stmt|;
name|this
operator|.
name|logger
operator|=
name|logger
expr_stmt|;
block|}
comment|/**    * Process the given ContainerReplica received from specified datanode.    *    * @param datanodeDetails DatanodeDetails of the node which reported    *                        this replica    * @param replicaProto ContainerReplica    *    * @throws IOException In case of any Exception while processing the report    */
DECL|method|processContainerReplica (final DatanodeDetails datanodeDetails, final ContainerReplicaProto replicaProto)
name|void
name|processContainerReplica
parameter_list|(
specifier|final
name|DatanodeDetails
name|datanodeDetails
parameter_list|,
specifier|final
name|ContainerReplicaProto
name|replicaProto
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|ContainerID
name|containerId
init|=
name|ContainerID
operator|.
name|valueof
argument_list|(
name|replicaProto
operator|.
name|getContainerID
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|ContainerReplica
name|replica
init|=
name|ContainerReplica
operator|.
name|newBuilder
argument_list|()
operator|.
name|setContainerID
argument_list|(
name|containerId
argument_list|)
operator|.
name|setContainerState
argument_list|(
name|replicaProto
operator|.
name|getState
argument_list|()
argument_list|)
operator|.
name|setDatanodeDetails
argument_list|(
name|datanodeDetails
argument_list|)
operator|.
name|setOriginNodeId
argument_list|(
name|UUID
operator|.
name|fromString
argument_list|(
name|replicaProto
operator|.
name|getOriginNodeId
argument_list|()
argument_list|)
argument_list|)
operator|.
name|setSequenceId
argument_list|(
name|replicaProto
operator|.
name|getBlockCommitSequenceId
argument_list|()
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
if|if
condition|(
name|logger
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"Processing replica of container {} from datanode {}"
argument_list|,
name|containerId
argument_list|,
name|datanodeDetails
argument_list|)
expr_stmt|;
block|}
comment|// Synchronized block should be replaced by container lock,
comment|// once we have introduced lock inside ContainerInfo.
synchronized|synchronized
init|(
name|containerManager
operator|.
name|getContainer
argument_list|(
name|containerId
argument_list|)
init|)
block|{
name|updateContainerStats
argument_list|(
name|containerId
argument_list|,
name|replicaProto
argument_list|)
expr_stmt|;
name|updateContainerState
argument_list|(
name|datanodeDetails
argument_list|,
name|containerId
argument_list|,
name|replica
argument_list|)
expr_stmt|;
name|containerManager
operator|.
name|updateContainerReplica
argument_list|(
name|containerId
argument_list|,
name|replica
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Update the container stats if it's lagging behind the stats in reported    * replica.    *    * @param containerId ID of the container    * @param replicaProto Container Replica information    * @throws ContainerNotFoundException If the container is not present    */
DECL|method|updateContainerStats (final ContainerID containerId, final ContainerReplicaProto replicaProto)
specifier|private
name|void
name|updateContainerStats
parameter_list|(
specifier|final
name|ContainerID
name|containerId
parameter_list|,
specifier|final
name|ContainerReplicaProto
name|replicaProto
parameter_list|)
throws|throws
name|ContainerNotFoundException
block|{
if|if
condition|(
operator|!
name|isUnhealthy
argument_list|(
name|replicaProto
operator|::
name|getState
argument_list|)
condition|)
block|{
specifier|final
name|ContainerInfo
name|containerInfo
init|=
name|containerManager
operator|.
name|getContainer
argument_list|(
name|containerId
argument_list|)
decl_stmt|;
if|if
condition|(
name|containerInfo
operator|.
name|getSequenceId
argument_list|()
operator|<
name|replicaProto
operator|.
name|getBlockCommitSequenceId
argument_list|()
condition|)
block|{
name|containerInfo
operator|.
name|updateSequenceId
argument_list|(
name|replicaProto
operator|.
name|getBlockCommitSequenceId
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|containerInfo
operator|.
name|getUsedBytes
argument_list|()
operator|<
name|replicaProto
operator|.
name|getUsed
argument_list|()
condition|)
block|{
name|containerInfo
operator|.
name|setUsedBytes
argument_list|(
name|replicaProto
operator|.
name|getUsed
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|containerInfo
operator|.
name|getNumberOfKeys
argument_list|()
operator|<
name|replicaProto
operator|.
name|getKeyCount
argument_list|()
condition|)
block|{
name|containerInfo
operator|.
name|setNumberOfKeys
argument_list|(
name|replicaProto
operator|.
name|getKeyCount
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Updates the container state based on the given replica state.    *    * @param datanode Datanode from which the report is received    * @param containerId ID of the container    * @param replica ContainerReplica    * @throws IOException In case of Exception    */
DECL|method|updateContainerState (final DatanodeDetails datanode, final ContainerID containerId, final ContainerReplica replica)
specifier|private
name|void
name|updateContainerState
parameter_list|(
specifier|final
name|DatanodeDetails
name|datanode
parameter_list|,
specifier|final
name|ContainerID
name|containerId
parameter_list|,
specifier|final
name|ContainerReplica
name|replica
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|ContainerInfo
name|container
init|=
name|containerManager
operator|.
name|getContainer
argument_list|(
name|containerId
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|container
operator|.
name|getState
argument_list|()
condition|)
block|{
case|case
name|OPEN
case|:
comment|/*        * If the state of a container is OPEN, datanodes cannot report        * any other state.        */
if|if
condition|(
name|replica
operator|.
name|getState
argument_list|()
operator|!=
name|State
operator|.
name|OPEN
condition|)
block|{
name|logger
operator|.
name|warn
argument_list|(
literal|"Container {} is in OPEN state, but the datanode {} "
operator|+
literal|"reports an {} replica."
argument_list|,
name|containerId
argument_list|,
name|datanode
argument_list|,
name|replica
operator|.
name|getState
argument_list|()
argument_list|)
expr_stmt|;
comment|// Should we take some action?
block|}
break|break;
case|case
name|CLOSING
case|:
comment|/*        * When the container is in CLOSING state the replicas can be in any        * of the following states:        *        * - OPEN        * - CLOSING        * - QUASI_CLOSED        * - CLOSED        *        * If all the replica are either in OPEN or CLOSING state, do nothing.        *        * If the replica is in QUASI_CLOSED state, move the container to        * QUASI_CLOSED state.        *        * If the replica is in CLOSED state, mark the container as CLOSED.        *        */
if|if
condition|(
name|replica
operator|.
name|getState
argument_list|()
operator|==
name|State
operator|.
name|QUASI_CLOSED
condition|)
block|{
name|logger
operator|.
name|info
argument_list|(
literal|"Moving container {} to QUASI_CLOSED state, datanode {} "
operator|+
literal|"reported QUASI_CLOSED replica."
argument_list|,
name|containerId
argument_list|,
name|datanode
argument_list|)
expr_stmt|;
name|containerManager
operator|.
name|updateContainerState
argument_list|(
name|containerId
argument_list|,
name|LifeCycleEvent
operator|.
name|QUASI_CLOSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|replica
operator|.
name|getState
argument_list|()
operator|==
name|State
operator|.
name|CLOSED
condition|)
block|{
name|logger
operator|.
name|info
argument_list|(
literal|"Moving container {} to CLOSED state, datanode {} "
operator|+
literal|"reported CLOSED replica."
argument_list|,
name|containerId
argument_list|,
name|datanode
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|replica
operator|.
name|getSequenceId
argument_list|()
operator|==
name|container
operator|.
name|getSequenceId
argument_list|()
argument_list|)
expr_stmt|;
name|containerManager
operator|.
name|updateContainerState
argument_list|(
name|containerId
argument_list|,
name|LifeCycleEvent
operator|.
name|CLOSE
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|QUASI_CLOSED
case|:
comment|/*        * The container is in QUASI_CLOSED state, this means that at least        * one of the replica was QUASI_CLOSED.        *        * Now replicas can be in any of the following state.        *        * 1. OPEN        * 2. CLOSING        * 3. QUASI_CLOSED        * 4. CLOSED        *        * If at least one of the replica is in CLOSED state, mark the        * container as CLOSED.        *        */
if|if
condition|(
name|replica
operator|.
name|getState
argument_list|()
operator|==
name|State
operator|.
name|CLOSED
condition|)
block|{
name|logger
operator|.
name|info
argument_list|(
literal|"Moving container {} to CLOSED state, datanode {} "
operator|+
literal|"reported CLOSED replica."
argument_list|,
name|containerId
argument_list|,
name|datanode
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|replica
operator|.
name|getSequenceId
argument_list|()
operator|==
name|container
operator|.
name|getSequenceId
argument_list|()
argument_list|)
expr_stmt|;
name|containerManager
operator|.
name|updateContainerState
argument_list|(
name|containerId
argument_list|,
name|LifeCycleEvent
operator|.
name|FORCE_CLOSE
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CLOSED
case|:
comment|/*        * The container is already in closed state. do nothing.        */
break|break;
case|case
name|DELETING
case|:
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"Unsupported container state 'DELETING'."
argument_list|)
throw|;
case|case
name|DELETED
case|:
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"Unsupported container state 'DELETED'."
argument_list|)
throw|;
default|default:
break|break;
block|}
block|}
comment|/**    * Returns true if the container replica is not marked as UNHEALTHY.    *    * @param replicaState State of the container replica.    * @return true if unhealthy, false otherwise    */
DECL|method|isUnhealthy (final Supplier<State> replicaState)
specifier|private
name|boolean
name|isUnhealthy
parameter_list|(
specifier|final
name|Supplier
argument_list|<
name|State
argument_list|>
name|replicaState
parameter_list|)
block|{
return|return
name|replicaState
operator|.
name|get
argument_list|()
operator|==
name|ContainerReplicaProto
operator|.
name|State
operator|.
name|UNHEALTHY
return|;
block|}
comment|/**    * Return ContainerManager.    * @return {@link ContainerManager}    */
DECL|method|getContainerManager ()
specifier|protected
name|ContainerManager
name|getContainerManager
parameter_list|()
block|{
return|return
name|containerManager
return|;
block|}
block|}
end_class

end_unit

