begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with this  * work for additional information regarding copyright ownership.  The ASF  * licenses this file to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the  * License for the specific language governing permissions and limitations under  * the License.  *  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdds.scm.container.states
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdds
operator|.
name|scm
operator|.
name|container
operator|.
name|states
package|;
end_package

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdds
operator|.
name|scm
operator|.
name|container
operator|.
name|ContainerID
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdds
operator|.
name|scm
operator|.
name|container
operator|.
name|common
operator|.
name|helpers
operator|.
name|ContainerInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdds
operator|.
name|scm
operator|.
name|exceptions
operator|.
name|SCMException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdds
operator|.
name|protocol
operator|.
name|proto
operator|.
name|HddsProtos
operator|.
name|LifeCycleState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdds
operator|.
name|protocol
operator|.
name|proto
operator|.
name|HddsProtos
operator|.
name|ReplicationFactor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdds
operator|.
name|protocol
operator|.
name|proto
operator|.
name|HddsProtos
operator|.
name|ReplicationType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|AutoCloseableLock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NavigableSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeSet
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdds
operator|.
name|scm
operator|.
name|exceptions
operator|.
name|SCMException
operator|.
name|ResultCodes
operator|.
name|CONTAINER_EXISTS
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdds
operator|.
name|scm
operator|.
name|exceptions
operator|.
name|SCMException
operator|.
name|ResultCodes
operator|.
name|FAILED_TO_CHANGE_CONTAINER_STATE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdds
operator|.
name|scm
operator|.
name|exceptions
operator|.
name|SCMException
operator|.
name|ResultCodes
operator|.
name|FAILED_TO_FIND_CONTAINER
import|;
end_import

begin_comment
comment|/**  * Container State Map acts like a unified map for various attributes that are  * used to select containers when we need allocated blocks.  *<p>  * This class provides the ability to query 4 classes of attributes. They are  *<p>  * 1. LifeCycleStates - LifeCycle States of container describe in which state  * a container is. For example, a container needs to be in Open State for a  * client to able to write to it.  *<p>  * 2. Owners - Each instance of Name service, for example, Namenode of HDFS or  * Key Space Manager (KSM) of Ozone or CBlockServer --  is an owner. It is  * possible to have many KSMs for a Ozone cluster and only one SCM. But SCM  * keeps the data from each KSM in separate bucket, never mixing them. To  * write data, often we have to find all open containers for a specific owner.  *<p>  * 3. ReplicationType - The clients are allowed to specify what kind of  * replication pipeline they want to use. Each Container exists on top of a  * pipeline, so we need to get ReplicationType that is specified by the user.  *<p>  * 4. ReplicationFactor - The replication factor represents how many copies  * of data should be made, right now we support 2 different types, ONE  * Replica and THREE Replica. User can specify how many copies should be made  * for a ozone key.  *<p>  * The most common access pattern of this class is to select a container based  * on all these parameters, for example, when allocating a block we will  * select a container that belongs to user1, with Ratis replication which can  * make 3 copies of data. The fact that we will look for open containers by  * default and if we cannot find them we will add new containers.  */
end_comment

begin_class
DECL|class|ContainerStateMap
specifier|public
class|class
name|ContainerStateMap
block|{
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|ContainerStateMap
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|lifeCycleStateMap
specifier|private
specifier|final
name|ContainerAttribute
argument_list|<
name|LifeCycleState
argument_list|>
name|lifeCycleStateMap
decl_stmt|;
DECL|field|ownerMap
specifier|private
specifier|final
name|ContainerAttribute
argument_list|<
name|String
argument_list|>
name|ownerMap
decl_stmt|;
DECL|field|factorMap
specifier|private
specifier|final
name|ContainerAttribute
argument_list|<
name|ReplicationFactor
argument_list|>
name|factorMap
decl_stmt|;
DECL|field|typeMap
specifier|private
specifier|final
name|ContainerAttribute
argument_list|<
name|ReplicationType
argument_list|>
name|typeMap
decl_stmt|;
DECL|field|containerMap
specifier|private
specifier|final
name|Map
argument_list|<
name|ContainerID
argument_list|,
name|ContainerInfo
argument_list|>
name|containerMap
decl_stmt|;
DECL|field|EMPTY_SET
specifier|private
specifier|final
specifier|static
name|NavigableSet
argument_list|<
name|ContainerID
argument_list|>
name|EMPTY_SET
init|=
name|Collections
operator|.
name|unmodifiableNavigableSet
argument_list|(
operator|new
name|TreeSet
argument_list|<>
argument_list|()
argument_list|)
decl_stmt|;
comment|// Container State Map lock should be held before calling into
comment|// Update ContainerAttributes. The consistency of ContainerAttributes is
comment|// protected by this lock.
DECL|field|autoLock
specifier|private
specifier|final
name|AutoCloseableLock
name|autoLock
decl_stmt|;
comment|/**    * Create a ContainerStateMap.    */
DECL|method|ContainerStateMap ()
specifier|public
name|ContainerStateMap
parameter_list|()
block|{
name|lifeCycleStateMap
operator|=
operator|new
name|ContainerAttribute
argument_list|<>
argument_list|()
expr_stmt|;
name|ownerMap
operator|=
operator|new
name|ContainerAttribute
argument_list|<>
argument_list|()
expr_stmt|;
name|factorMap
operator|=
operator|new
name|ContainerAttribute
argument_list|<>
argument_list|()
expr_stmt|;
name|typeMap
operator|=
operator|new
name|ContainerAttribute
argument_list|<>
argument_list|()
expr_stmt|;
name|containerMap
operator|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
expr_stmt|;
name|autoLock
operator|=
operator|new
name|AutoCloseableLock
argument_list|()
expr_stmt|;
comment|//        new InstrumentedLock(getClass().getName(), LOG,
comment|//            new ReentrantLock(),
comment|//            1000,
comment|//            300));
block|}
comment|/**    * Adds a ContainerInfo Entry in the ContainerStateMap.    *    * @param info - container info    * @throws SCMException - throws if create failed.    */
DECL|method|addContainer (ContainerInfo info)
specifier|public
name|void
name|addContainer
parameter_list|(
name|ContainerInfo
name|info
parameter_list|)
throws|throws
name|SCMException
block|{
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|info
argument_list|,
literal|"Container Info cannot be null"
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|info
operator|.
name|getReplicationFactor
argument_list|()
operator|.
name|getNumber
argument_list|()
operator|>
literal|0
argument_list|,
literal|"ExpectedReplicaCount should be greater than 0"
argument_list|)
expr_stmt|;
try|try
init|(
name|AutoCloseableLock
name|lock
init|=
name|autoLock
operator|.
name|acquire
argument_list|()
init|)
block|{
name|ContainerID
name|id
init|=
name|ContainerID
operator|.
name|valueof
argument_list|(
name|info
operator|.
name|getContainerID
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|containerMap
operator|.
name|putIfAbsent
argument_list|(
name|id
argument_list|,
name|info
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Duplicate container ID detected. {}"
argument_list|,
name|id
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|SCMException
argument_list|(
literal|"Duplicate container ID detected."
argument_list|,
name|CONTAINER_EXISTS
argument_list|)
throw|;
block|}
name|lifeCycleStateMap
operator|.
name|insert
argument_list|(
name|info
operator|.
name|getState
argument_list|()
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|ownerMap
operator|.
name|insert
argument_list|(
name|info
operator|.
name|getOwner
argument_list|()
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|factorMap
operator|.
name|insert
argument_list|(
name|info
operator|.
name|getReplicationFactor
argument_list|()
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|typeMap
operator|.
name|insert
argument_list|(
name|info
operator|.
name|getReplicationType
argument_list|()
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|trace
argument_list|(
literal|"Created container with {} successfully."
argument_list|,
name|id
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Returns the latest state of Container from SCM's Container State Map.    *    * @param info - ContainerInfo    * @return ContainerInfo    */
DECL|method|getContainerInfo (ContainerInfo info)
specifier|public
name|ContainerInfo
name|getContainerInfo
parameter_list|(
name|ContainerInfo
name|info
parameter_list|)
block|{
return|return
name|getContainerInfo
argument_list|(
name|info
operator|.
name|getContainerID
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Returns the latest state of Container from SCM's Container State Map.    *    * @param containerID - int    * @return container info, if found.    */
DECL|method|getContainerInfo (long containerID)
specifier|public
name|ContainerInfo
name|getContainerInfo
parameter_list|(
name|long
name|containerID
parameter_list|)
block|{
name|ContainerID
name|id
init|=
operator|new
name|ContainerID
argument_list|(
name|containerID
argument_list|)
decl_stmt|;
return|return
name|containerMap
operator|.
name|get
argument_list|(
name|id
argument_list|)
return|;
block|}
comment|/**    * Returns the full container Map.    *    * @return - Map    */
DECL|method|getContainerMap ()
specifier|public
name|Map
argument_list|<
name|ContainerID
argument_list|,
name|ContainerInfo
argument_list|>
name|getContainerMap
parameter_list|()
block|{
try|try
init|(
name|AutoCloseableLock
name|lock
init|=
name|autoLock
operator|.
name|acquire
argument_list|()
init|)
block|{
return|return
name|Collections
operator|.
name|unmodifiableMap
argument_list|(
name|containerMap
argument_list|)
return|;
block|}
block|}
comment|/**    * Just update the container State.    * @param info ContainerInfo.    */
DECL|method|updateContainerInfo (ContainerInfo info)
specifier|public
name|void
name|updateContainerInfo
parameter_list|(
name|ContainerInfo
name|info
parameter_list|)
throws|throws
name|SCMException
block|{
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|ContainerInfo
name|currentInfo
init|=
literal|null
decl_stmt|;
try|try
init|(
name|AutoCloseableLock
name|lock
init|=
name|autoLock
operator|.
name|acquire
argument_list|()
init|)
block|{
name|currentInfo
operator|=
name|containerMap
operator|.
name|get
argument_list|(
name|ContainerID
operator|.
name|valueof
argument_list|(
name|info
operator|.
name|getContainerID
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|currentInfo
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SCMException
argument_list|(
literal|"No such container."
argument_list|,
name|FAILED_TO_FIND_CONTAINER
argument_list|)
throw|;
block|}
name|containerMap
operator|.
name|put
argument_list|(
name|info
operator|.
name|containerID
argument_list|()
argument_list|,
name|info
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Update the State of a container.    *    * @param info - ContainerInfo    * @param currentState - CurrentState    * @param newState - NewState.    * @throws SCMException - in case of failure.    */
DECL|method|updateState (ContainerInfo info, LifeCycleState currentState, LifeCycleState newState)
specifier|public
name|void
name|updateState
parameter_list|(
name|ContainerInfo
name|info
parameter_list|,
name|LifeCycleState
name|currentState
parameter_list|,
name|LifeCycleState
name|newState
parameter_list|)
throws|throws
name|SCMException
block|{
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|currentState
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|newState
argument_list|)
expr_stmt|;
name|ContainerID
name|id
init|=
operator|new
name|ContainerID
argument_list|(
name|info
operator|.
name|getContainerID
argument_list|()
argument_list|)
decl_stmt|;
name|ContainerInfo
name|currentInfo
init|=
literal|null
decl_stmt|;
try|try
init|(
name|AutoCloseableLock
name|lock
init|=
name|autoLock
operator|.
name|acquire
argument_list|()
init|)
block|{
name|currentInfo
operator|=
name|containerMap
operator|.
name|get
argument_list|(
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|currentInfo
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SCMException
argument_list|(
literal|"No such container."
argument_list|,
name|FAILED_TO_FIND_CONTAINER
argument_list|)
throw|;
block|}
comment|// We are updating two places before this update is done, these can
comment|// fail independently, since the code needs to handle it.
comment|// We update the attribute map, if that fails it will throw an exception,
comment|// so no issues, if we are successful, we keep track of the fact that we
comment|// have updated the lifecycle state in the map, and update the container
comment|// state. If this second update fails, we will attempt to roll back the
comment|// earlier change we did. If the rollback fails, we can be in an
comment|// inconsistent state,
name|info
operator|.
name|setState
argument_list|(
name|newState
argument_list|)
expr_stmt|;
name|containerMap
operator|.
name|put
argument_list|(
name|id
argument_list|,
name|info
argument_list|)
expr_stmt|;
name|lifeCycleStateMap
operator|.
name|update
argument_list|(
name|currentState
argument_list|,
name|newState
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|trace
argument_list|(
literal|"Updated the container {} to new state. Old = {}, new = "
operator|+
literal|"{}"
argument_list|,
name|id
argument_list|,
name|currentState
argument_list|,
name|newState
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SCMException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to update the container state. {}"
argument_list|,
name|ex
argument_list|)
expr_stmt|;
comment|// we need to revert the change in this attribute since we are not
comment|// able to update the hash table.
name|LOG
operator|.
name|info
argument_list|(
literal|"Reverting the update to lifecycle state. Moving back to "
operator|+
literal|"old state. Old = {}, Attempted state = {}"
argument_list|,
name|currentState
argument_list|,
name|newState
argument_list|)
expr_stmt|;
name|containerMap
operator|.
name|put
argument_list|(
name|id
argument_list|,
name|currentInfo
argument_list|)
expr_stmt|;
comment|// if this line throws, the state map can be in an inconsistent
comment|// state, since we will have modified the attribute by the
comment|// container state will not in sync since we were not able to put
comment|// that into the hash table.
name|lifeCycleStateMap
operator|.
name|update
argument_list|(
name|newState
argument_list|,
name|currentState
argument_list|,
name|id
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|SCMException
argument_list|(
literal|"Updating the container map failed."
argument_list|,
name|ex
argument_list|,
name|FAILED_TO_CHANGE_CONTAINER_STATE
argument_list|)
throw|;
block|}
block|}
comment|/**    * Returns A list of containers owned by a name service.    *    * @param ownerName - Name of the NameService.    * @return - NavigableSet of ContainerIDs.    */
DECL|method|getContainerIDsByOwner (String ownerName)
name|NavigableSet
argument_list|<
name|ContainerID
argument_list|>
name|getContainerIDsByOwner
parameter_list|(
name|String
name|ownerName
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|ownerName
argument_list|)
expr_stmt|;
try|try
init|(
name|AutoCloseableLock
name|lock
init|=
name|autoLock
operator|.
name|acquire
argument_list|()
init|)
block|{
return|return
name|ownerMap
operator|.
name|getCollection
argument_list|(
name|ownerName
argument_list|)
return|;
block|}
block|}
comment|/**    * Returns Containers in the System by the Type.    *    * @param type - Replication type -- StandAlone, Ratis etc.    * @return NavigableSet    */
DECL|method|getContainerIDsByType (ReplicationType type)
name|NavigableSet
argument_list|<
name|ContainerID
argument_list|>
name|getContainerIDsByType
parameter_list|(
name|ReplicationType
name|type
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|type
argument_list|)
expr_stmt|;
try|try
init|(
name|AutoCloseableLock
name|lock
init|=
name|autoLock
operator|.
name|acquire
argument_list|()
init|)
block|{
return|return
name|typeMap
operator|.
name|getCollection
argument_list|(
name|type
argument_list|)
return|;
block|}
block|}
comment|/**    * Returns Containers by replication factor.    *    * @param factor - Replication Factor.    * @return NavigableSet.    */
DECL|method|getContainerIDsByFactor (ReplicationFactor factor)
name|NavigableSet
argument_list|<
name|ContainerID
argument_list|>
name|getContainerIDsByFactor
parameter_list|(
name|ReplicationFactor
name|factor
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|factor
argument_list|)
expr_stmt|;
try|try
init|(
name|AutoCloseableLock
name|lock
init|=
name|autoLock
operator|.
name|acquire
argument_list|()
init|)
block|{
return|return
name|factorMap
operator|.
name|getCollection
argument_list|(
name|factor
argument_list|)
return|;
block|}
block|}
comment|/**    * Returns Containers by State.    *    * @param state - State - Open, Closed etc.    * @return List of containers by state.    */
DECL|method|getContainerIDsByState (LifeCycleState state)
name|NavigableSet
argument_list|<
name|ContainerID
argument_list|>
name|getContainerIDsByState
parameter_list|(
name|LifeCycleState
name|state
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|state
argument_list|)
expr_stmt|;
try|try
init|(
name|AutoCloseableLock
name|lock
init|=
name|autoLock
operator|.
name|acquire
argument_list|()
init|)
block|{
return|return
name|lifeCycleStateMap
operator|.
name|getCollection
argument_list|(
name|state
argument_list|)
return|;
block|}
block|}
comment|/**    * Gets the containers that matches the  following filters.    *    * @param state - LifeCycleState    * @param owner - Owner    * @param factor - Replication Factor    * @param type - Replication Type    * @return ContainerInfo or Null if not container satisfies the criteria.    */
DECL|method|getMatchingContainerIDs ( LifeCycleState state, String owner, ReplicationFactor factor, ReplicationType type)
specifier|public
name|NavigableSet
argument_list|<
name|ContainerID
argument_list|>
name|getMatchingContainerIDs
parameter_list|(
name|LifeCycleState
name|state
parameter_list|,
name|String
name|owner
parameter_list|,
name|ReplicationFactor
name|factor
parameter_list|,
name|ReplicationType
name|type
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|state
argument_list|,
literal|"State cannot be null"
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|owner
argument_list|,
literal|"Owner cannot be null"
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|factor
argument_list|,
literal|"Factor cannot be null"
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|type
argument_list|,
literal|"Type cannot be null"
argument_list|)
expr_stmt|;
try|try
init|(
name|AutoCloseableLock
name|lock
init|=
name|autoLock
operator|.
name|acquire
argument_list|()
init|)
block|{
comment|// If we cannot meet any one condition we return EMPTY_SET immediately.
comment|// Since when we intersect these sets, the result will be empty if any
comment|// one is empty.
name|NavigableSet
argument_list|<
name|ContainerID
argument_list|>
name|stateSet
init|=
name|lifeCycleStateMap
operator|.
name|getCollection
argument_list|(
name|state
argument_list|)
decl_stmt|;
if|if
condition|(
name|stateSet
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
name|EMPTY_SET
return|;
block|}
name|NavigableSet
argument_list|<
name|ContainerID
argument_list|>
name|ownerSet
init|=
name|ownerMap
operator|.
name|getCollection
argument_list|(
name|owner
argument_list|)
decl_stmt|;
if|if
condition|(
name|ownerSet
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
name|EMPTY_SET
return|;
block|}
name|NavigableSet
argument_list|<
name|ContainerID
argument_list|>
name|factorSet
init|=
name|factorMap
operator|.
name|getCollection
argument_list|(
name|factor
argument_list|)
decl_stmt|;
if|if
condition|(
name|factorSet
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
name|EMPTY_SET
return|;
block|}
name|NavigableSet
argument_list|<
name|ContainerID
argument_list|>
name|typeSet
init|=
name|typeMap
operator|.
name|getCollection
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|typeSet
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
name|EMPTY_SET
return|;
block|}
comment|// if we add more constraints we will just add those sets here..
name|NavigableSet
argument_list|<
name|ContainerID
argument_list|>
index|[]
name|sets
init|=
name|sortBySize
argument_list|(
name|stateSet
argument_list|,
name|ownerSet
argument_list|,
name|factorSet
argument_list|,
name|typeSet
argument_list|)
decl_stmt|;
name|NavigableSet
argument_list|<
name|ContainerID
argument_list|>
name|currentSet
init|=
name|sets
index|[
literal|0
index|]
decl_stmt|;
comment|// We take the smallest set and intersect against the larger sets. This
comment|// allows us to reduce the lookups to the least possible number.
for|for
control|(
name|int
name|x
init|=
literal|1
init|;
name|x
operator|<
name|sets
operator|.
name|length
condition|;
name|x
operator|++
control|)
block|{
name|currentSet
operator|=
name|intersectSets
argument_list|(
name|currentSet
argument_list|,
name|sets
index|[
name|x
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|currentSet
return|;
block|}
block|}
comment|/**    * Calculates the intersection between sets and returns a new set.    *    * @param smaller - First Set    * @param bigger - Second Set    * @return resultSet which is the intersection of these two sets.    */
DECL|method|intersectSets ( NavigableSet<ContainerID> smaller, NavigableSet<ContainerID> bigger)
specifier|private
name|NavigableSet
argument_list|<
name|ContainerID
argument_list|>
name|intersectSets
parameter_list|(
name|NavigableSet
argument_list|<
name|ContainerID
argument_list|>
name|smaller
parameter_list|,
name|NavigableSet
argument_list|<
name|ContainerID
argument_list|>
name|bigger
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkState
argument_list|(
name|smaller
operator|.
name|size
argument_list|()
operator|<=
name|bigger
operator|.
name|size
argument_list|()
argument_list|,
literal|"This function assumes the first set is lesser or equal to second "
operator|+
literal|"set"
argument_list|)
expr_stmt|;
name|NavigableSet
argument_list|<
name|ContainerID
argument_list|>
name|resultSet
init|=
operator|new
name|TreeSet
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|ContainerID
name|id
range|:
name|smaller
control|)
block|{
if|if
condition|(
name|bigger
operator|.
name|contains
argument_list|(
name|id
argument_list|)
condition|)
block|{
name|resultSet
operator|.
name|add
argument_list|(
name|id
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|resultSet
return|;
block|}
comment|/**    * Sorts a list of Sets based on Size. This is useful when we are    * intersecting the sets.    *    * @param sets - varagrs of sets    * @return Returns a sorted array of sets based on the size of the set.    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|sortBySize ( NavigableSet<ContainerID>.... sets)
specifier|private
name|NavigableSet
argument_list|<
name|ContainerID
argument_list|>
index|[]
name|sortBySize
parameter_list|(
name|NavigableSet
argument_list|<
name|ContainerID
argument_list|>
modifier|...
name|sets
parameter_list|)
block|{
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|sets
operator|.
name|length
operator|-
literal|1
condition|;
name|x
operator|++
control|)
block|{
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|sets
operator|.
name|length
operator|-
name|x
operator|-
literal|1
condition|;
name|y
operator|++
control|)
block|{
if|if
condition|(
name|sets
index|[
name|y
index|]
operator|.
name|size
argument_list|()
operator|>
name|sets
index|[
name|y
operator|+
literal|1
index|]
operator|.
name|size
argument_list|()
condition|)
block|{
name|NavigableSet
name|temp
init|=
name|sets
index|[
name|y
index|]
decl_stmt|;
name|sets
index|[
name|y
index|]
operator|=
name|sets
index|[
name|y
operator|+
literal|1
index|]
expr_stmt|;
name|sets
index|[
name|y
operator|+
literal|1
index|]
operator|=
name|temp
expr_stmt|;
block|}
block|}
block|}
return|return
name|sets
return|;
block|}
block|}
end_class

end_unit

