begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with this  * work for additional information regarding copyright ownership.  The ASF  * licenses this file to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the  * License for the specific language governing permissions and limitations under  * the License.  *  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdds.scm.container.states
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdds
operator|.
name|scm
operator|.
name|container
operator|.
name|states
package|;
end_package

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdds
operator|.
name|scm
operator|.
name|container
operator|.
name|ContainerID
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdds
operator|.
name|scm
operator|.
name|container
operator|.
name|ContainerNotFoundException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdds
operator|.
name|scm
operator|.
name|container
operator|.
name|ContainerReplica
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdds
operator|.
name|scm
operator|.
name|container
operator|.
name|ContainerInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdds
operator|.
name|scm
operator|.
name|container
operator|.
name|ContainerReplicaNotFoundException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdds
operator|.
name|scm
operator|.
name|exceptions
operator|.
name|SCMException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdds
operator|.
name|protocol
operator|.
name|proto
operator|.
name|HddsProtos
operator|.
name|LifeCycleState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdds
operator|.
name|protocol
operator|.
name|proto
operator|.
name|HddsProtos
operator|.
name|ReplicationFactor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdds
operator|.
name|protocol
operator|.
name|proto
operator|.
name|HddsProtos
operator|.
name|ReplicationType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NavigableSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|ReadWriteLock
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|ReentrantReadWriteLock
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentHashMap
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdds
operator|.
name|scm
operator|.
name|exceptions
operator|.
name|SCMException
operator|.
name|ResultCodes
operator|.
name|CONTAINER_EXISTS
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdds
operator|.
name|scm
operator|.
name|exceptions
operator|.
name|SCMException
operator|.
name|ResultCodes
operator|.
name|FAILED_TO_CHANGE_CONTAINER_STATE
import|;
end_import

begin_comment
comment|/**  * Container State Map acts like a unified map for various attributes that are  * used to select containers when we need allocated blocks.  *<p>  * This class provides the ability to query 5 classes of attributes. They are  *<p>  * 1. LifeCycleStates - LifeCycle States of container describe in which state  * a container is. For example, a container needs to be in Open State for a  * client to able to write to it.  *<p>  * 2. Owners - Each instance of Name service, for example, Namenode of HDFS or  * Ozone Manager (OM) of Ozone or CBlockServer --  is an owner. It is  * possible to have many OMs for a Ozone cluster and only one SCM. But SCM  * keeps the data from each OM in separate bucket, never mixing them. To  * write data, often we have to find all open containers for a specific owner.  *<p>  * 3. ReplicationType - The clients are allowed to specify what kind of  * replication pipeline they want to use. Each Container exists on top of a  * pipeline, so we need to get ReplicationType that is specified by the user.  *<p>  * 4. ReplicationFactor - The replication factor represents how many copies  * of data should be made, right now we support 2 different types, ONE  * Replica and THREE Replica. User can specify how many copies should be made  * for a ozone key.  *<p>  * The most common access pattern of this class is to select a container based  * on all these parameters, for example, when allocating a block we will  * select a container that belongs to user1, with Ratis replication which can  * make 3 copies of data. The fact that we will look for open containers by  * default and if we cannot find them we will add new containers.  */
end_comment

begin_class
DECL|class|ContainerStateMap
specifier|public
class|class
name|ContainerStateMap
block|{
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|ContainerStateMap
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|EMPTY_SET
specifier|private
specifier|final
specifier|static
name|NavigableSet
argument_list|<
name|ContainerID
argument_list|>
name|EMPTY_SET
init|=
name|Collections
operator|.
name|unmodifiableNavigableSet
argument_list|(
operator|new
name|TreeSet
argument_list|<>
argument_list|()
argument_list|)
decl_stmt|;
DECL|field|lifeCycleStateMap
specifier|private
specifier|final
name|ContainerAttribute
argument_list|<
name|LifeCycleState
argument_list|>
name|lifeCycleStateMap
decl_stmt|;
DECL|field|ownerMap
specifier|private
specifier|final
name|ContainerAttribute
argument_list|<
name|String
argument_list|>
name|ownerMap
decl_stmt|;
DECL|field|factorMap
specifier|private
specifier|final
name|ContainerAttribute
argument_list|<
name|ReplicationFactor
argument_list|>
name|factorMap
decl_stmt|;
DECL|field|typeMap
specifier|private
specifier|final
name|ContainerAttribute
argument_list|<
name|ReplicationType
argument_list|>
name|typeMap
decl_stmt|;
DECL|field|containerMap
specifier|private
specifier|final
name|Map
argument_list|<
name|ContainerID
argument_list|,
name|ContainerInfo
argument_list|>
name|containerMap
decl_stmt|;
DECL|field|replicaMap
specifier|private
specifier|final
name|Map
argument_list|<
name|ContainerID
argument_list|,
name|Set
argument_list|<
name|ContainerReplica
argument_list|>
argument_list|>
name|replicaMap
decl_stmt|;
DECL|field|resultCache
specifier|private
specifier|final
name|Map
argument_list|<
name|ContainerQueryKey
argument_list|,
name|NavigableSet
argument_list|<
name|ContainerID
argument_list|>
argument_list|>
name|resultCache
decl_stmt|;
comment|// Container State Map lock should be held before calling into
comment|// Update ContainerAttributes. The consistency of ContainerAttributes is
comment|// protected by this lock.
DECL|field|lock
specifier|private
specifier|final
name|ReadWriteLock
name|lock
decl_stmt|;
comment|/**    * Create a ContainerStateMap.    */
DECL|method|ContainerStateMap ()
specifier|public
name|ContainerStateMap
parameter_list|()
block|{
name|this
operator|.
name|lifeCycleStateMap
operator|=
operator|new
name|ContainerAttribute
argument_list|<>
argument_list|()
expr_stmt|;
name|this
operator|.
name|ownerMap
operator|=
operator|new
name|ContainerAttribute
argument_list|<>
argument_list|()
expr_stmt|;
name|this
operator|.
name|factorMap
operator|=
operator|new
name|ContainerAttribute
argument_list|<>
argument_list|()
expr_stmt|;
name|this
operator|.
name|typeMap
operator|=
operator|new
name|ContainerAttribute
argument_list|<>
argument_list|()
expr_stmt|;
name|this
operator|.
name|containerMap
operator|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
expr_stmt|;
name|this
operator|.
name|lock
operator|=
operator|new
name|ReentrantReadWriteLock
argument_list|()
expr_stmt|;
name|this
operator|.
name|replicaMap
operator|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
expr_stmt|;
name|this
operator|.
name|resultCache
operator|=
operator|new
name|ConcurrentHashMap
argument_list|<>
argument_list|()
expr_stmt|;
block|}
comment|/**    * Adds a ContainerInfo Entry in the ContainerStateMap.    *    * @param info - container info    * @throws SCMException - throws if create failed.    */
DECL|method|addContainer (final ContainerInfo info)
specifier|public
name|void
name|addContainer
parameter_list|(
specifier|final
name|ContainerInfo
name|info
parameter_list|)
throws|throws
name|SCMException
block|{
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|info
argument_list|,
literal|"Container Info cannot be null"
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|info
operator|.
name|getReplicationFactor
argument_list|()
operator|.
name|getNumber
argument_list|()
operator|>
literal|0
argument_list|,
literal|"ExpectedReplicaCount should be greater than 0"
argument_list|)
expr_stmt|;
name|lock
operator|.
name|writeLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
specifier|final
name|ContainerID
name|id
init|=
name|info
operator|.
name|containerID
argument_list|()
decl_stmt|;
if|if
condition|(
name|containerMap
operator|.
name|putIfAbsent
argument_list|(
name|id
argument_list|,
name|info
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Duplicate container ID detected. {}"
argument_list|,
name|id
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|SCMException
argument_list|(
literal|"Duplicate container ID detected."
argument_list|,
name|CONTAINER_EXISTS
argument_list|)
throw|;
block|}
name|lifeCycleStateMap
operator|.
name|insert
argument_list|(
name|info
operator|.
name|getState
argument_list|()
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|ownerMap
operator|.
name|insert
argument_list|(
name|info
operator|.
name|getOwner
argument_list|()
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|factorMap
operator|.
name|insert
argument_list|(
name|info
operator|.
name|getReplicationFactor
argument_list|()
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|typeMap
operator|.
name|insert
argument_list|(
name|info
operator|.
name|getReplicationType
argument_list|()
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|replicaMap
operator|.
name|put
argument_list|(
name|id
argument_list|,
operator|new
name|HashSet
argument_list|<>
argument_list|()
argument_list|)
expr_stmt|;
comment|// Flush the cache of this container type, will be added later when
comment|// get container queries are executed.
name|flushCache
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|trace
argument_list|(
literal|"Created container with {} successfully."
argument_list|,
name|id
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|writeLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Removes a Container Entry from ContainerStateMap.    *    * @param containerID - ContainerID    * @throws SCMException - throws if create failed.    */
DECL|method|removeContainer (final ContainerID containerID)
specifier|public
name|void
name|removeContainer
parameter_list|(
specifier|final
name|ContainerID
name|containerID
parameter_list|)
throws|throws
name|ContainerNotFoundException
block|{
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|containerID
argument_list|,
literal|"ContainerID cannot be null"
argument_list|)
expr_stmt|;
name|lock
operator|.
name|writeLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkIfContainerExist
argument_list|(
name|containerID
argument_list|)
expr_stmt|;
comment|// Should we revert back to the original state if any of the below
comment|// remove operation fails?
specifier|final
name|ContainerInfo
name|info
init|=
name|containerMap
operator|.
name|remove
argument_list|(
name|containerID
argument_list|)
decl_stmt|;
name|lifeCycleStateMap
operator|.
name|remove
argument_list|(
name|info
operator|.
name|getState
argument_list|()
argument_list|,
name|containerID
argument_list|)
expr_stmt|;
name|ownerMap
operator|.
name|remove
argument_list|(
name|info
operator|.
name|getOwner
argument_list|()
argument_list|,
name|containerID
argument_list|)
expr_stmt|;
name|factorMap
operator|.
name|remove
argument_list|(
name|info
operator|.
name|getReplicationFactor
argument_list|()
argument_list|,
name|containerID
argument_list|)
expr_stmt|;
name|typeMap
operator|.
name|remove
argument_list|(
name|info
operator|.
name|getReplicationType
argument_list|()
argument_list|,
name|containerID
argument_list|)
expr_stmt|;
comment|// Flush the cache of this container type.
name|flushCache
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|trace
argument_list|(
literal|"Removed container with {} successfully."
argument_list|,
name|containerID
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|writeLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Returns the latest state of Container from SCM's Container State Map.    *    * @param containerID - ContainerID    * @return container info, if found.    */
DECL|method|getContainerInfo (final ContainerID containerID)
specifier|public
name|ContainerInfo
name|getContainerInfo
parameter_list|(
specifier|final
name|ContainerID
name|containerID
parameter_list|)
throws|throws
name|ContainerNotFoundException
block|{
name|lock
operator|.
name|readLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkIfContainerExist
argument_list|(
name|containerID
argument_list|)
expr_stmt|;
return|return
name|containerMap
operator|.
name|get
argument_list|(
name|containerID
argument_list|)
return|;
block|}
finally|finally
block|{
name|lock
operator|.
name|readLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Returns the latest list of DataNodes where replica for given containerId    * exist. Throws an SCMException if no entry is found for given containerId.    *    * @param containerID    * @return Set<DatanodeDetails>    */
DECL|method|getContainerReplicas ( final ContainerID containerID)
specifier|public
name|Set
argument_list|<
name|ContainerReplica
argument_list|>
name|getContainerReplicas
parameter_list|(
specifier|final
name|ContainerID
name|containerID
parameter_list|)
throws|throws
name|ContainerNotFoundException
block|{
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|containerID
argument_list|)
expr_stmt|;
name|lock
operator|.
name|readLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkIfContainerExist
argument_list|(
name|containerID
argument_list|)
expr_stmt|;
return|return
name|Collections
operator|.
name|unmodifiableSet
argument_list|(
operator|new
name|HashSet
argument_list|<>
argument_list|(
name|replicaMap
operator|.
name|get
argument_list|(
name|containerID
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
finally|finally
block|{
name|lock
operator|.
name|readLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Adds given datanodes as nodes where replica for given containerId exist.    * Logs a debug entry if a datanode is already added as replica for given    * ContainerId.    *    * @param containerID    * @param replica    */
DECL|method|updateContainerReplica (final ContainerID containerID, final ContainerReplica replica)
specifier|public
name|void
name|updateContainerReplica
parameter_list|(
specifier|final
name|ContainerID
name|containerID
parameter_list|,
specifier|final
name|ContainerReplica
name|replica
parameter_list|)
throws|throws
name|ContainerNotFoundException
block|{
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|containerID
argument_list|)
expr_stmt|;
name|lock
operator|.
name|writeLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkIfContainerExist
argument_list|(
name|containerID
argument_list|)
expr_stmt|;
name|Set
argument_list|<
name|ContainerReplica
argument_list|>
name|replicas
init|=
name|replicaMap
operator|.
name|get
argument_list|(
name|containerID
argument_list|)
decl_stmt|;
name|replicas
operator|.
name|remove
argument_list|(
name|replica
argument_list|)
expr_stmt|;
name|replicas
operator|.
name|add
argument_list|(
name|replica
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|writeLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Remove a container Replica for given DataNode.    *    * @param containerID    * @param replica    * @return True of dataNode is removed successfully else false.    */
DECL|method|removeContainerReplica (final ContainerID containerID, final ContainerReplica replica)
specifier|public
name|void
name|removeContainerReplica
parameter_list|(
specifier|final
name|ContainerID
name|containerID
parameter_list|,
specifier|final
name|ContainerReplica
name|replica
parameter_list|)
throws|throws
name|ContainerNotFoundException
throws|,
name|ContainerReplicaNotFoundException
block|{
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|containerID
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|replica
argument_list|)
expr_stmt|;
name|lock
operator|.
name|writeLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkIfContainerExist
argument_list|(
name|containerID
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|replicaMap
operator|.
name|get
argument_list|(
name|containerID
argument_list|)
operator|.
name|remove
argument_list|(
name|replica
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|ContainerReplicaNotFoundException
argument_list|(
literal|"Container #"
operator|+
name|containerID
operator|.
name|getId
argument_list|()
operator|+
literal|", replica: "
operator|+
name|replica
argument_list|)
throw|;
block|}
block|}
finally|finally
block|{
name|lock
operator|.
name|writeLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Just update the container State.    * @param info ContainerInfo.    */
DECL|method|updateContainerInfo (final ContainerInfo info)
specifier|public
name|void
name|updateContainerInfo
parameter_list|(
specifier|final
name|ContainerInfo
name|info
parameter_list|)
throws|throws
name|ContainerNotFoundException
block|{
name|lock
operator|.
name|writeLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|checkIfContainerExist
argument_list|(
name|info
operator|.
name|containerID
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|ContainerInfo
name|currentInfo
init|=
name|containerMap
operator|.
name|get
argument_list|(
name|info
operator|.
name|containerID
argument_list|()
argument_list|)
decl_stmt|;
name|flushCache
argument_list|(
name|info
argument_list|,
name|currentInfo
argument_list|)
expr_stmt|;
name|containerMap
operator|.
name|put
argument_list|(
name|info
operator|.
name|containerID
argument_list|()
argument_list|,
name|info
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|writeLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Update the State of a container.    *    * @param containerID - ContainerID    * @param currentState - CurrentState    * @param newState - NewState.    * @throws SCMException - in case of failure.    */
DECL|method|updateState (ContainerID containerID, LifeCycleState currentState, LifeCycleState newState)
specifier|public
name|void
name|updateState
parameter_list|(
name|ContainerID
name|containerID
parameter_list|,
name|LifeCycleState
name|currentState
parameter_list|,
name|LifeCycleState
name|newState
parameter_list|)
throws|throws
name|SCMException
throws|,
name|ContainerNotFoundException
block|{
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|currentState
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|newState
argument_list|)
expr_stmt|;
name|lock
operator|.
name|writeLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkIfContainerExist
argument_list|(
name|containerID
argument_list|)
expr_stmt|;
specifier|final
name|ContainerInfo
name|currentInfo
init|=
name|containerMap
operator|.
name|get
argument_list|(
name|containerID
argument_list|)
decl_stmt|;
try|try
block|{
specifier|final
name|ContainerInfo
name|newInfo
init|=
operator|new
name|ContainerInfo
argument_list|(
name|currentInfo
argument_list|)
decl_stmt|;
name|newInfo
operator|.
name|setState
argument_list|(
name|newState
argument_list|)
expr_stmt|;
comment|// We are updating two places before this update is done, these can
comment|// fail independently, since the code needs to handle it.
comment|// We update the attribute map, if that fails it will throw an
comment|// exception, so no issues, if we are successful, we keep track of the
comment|// fact that we have updated the lifecycle state in the map, and update
comment|// the container state. If this second update fails, we will attempt to
comment|// roll back the earlier change we did. If the rollback fails, we can
comment|// be in an inconsistent state,
name|containerMap
operator|.
name|put
argument_list|(
name|containerID
argument_list|,
name|newInfo
argument_list|)
expr_stmt|;
name|lifeCycleStateMap
operator|.
name|update
argument_list|(
name|currentState
argument_list|,
name|newState
argument_list|,
name|containerID
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|trace
argument_list|(
literal|"Updated the container {} to new state. Old = {}, new = "
operator|+
literal|"{}"
argument_list|,
name|containerID
argument_list|,
name|currentState
argument_list|,
name|newState
argument_list|)
expr_stmt|;
comment|// Just flush both old and new data sets from the result cache.
name|flushCache
argument_list|(
name|currentInfo
argument_list|,
name|newInfo
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SCMException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to update the container state. {}"
argument_list|,
name|ex
argument_list|)
expr_stmt|;
comment|// we need to revert the change in this attribute since we are not
comment|// able to update the hash table.
name|LOG
operator|.
name|info
argument_list|(
literal|"Reverting the update to lifecycle state. Moving back to "
operator|+
literal|"old state. Old = {}, Attempted state = {}"
argument_list|,
name|currentState
argument_list|,
name|newState
argument_list|)
expr_stmt|;
name|containerMap
operator|.
name|put
argument_list|(
name|containerID
argument_list|,
name|currentInfo
argument_list|)
expr_stmt|;
comment|// if this line throws, the state map can be in an inconsistent
comment|// state, since we will have modified the attribute by the
comment|// container state will not in sync since we were not able to put
comment|// that into the hash table.
name|lifeCycleStateMap
operator|.
name|update
argument_list|(
name|newState
argument_list|,
name|currentState
argument_list|,
name|containerID
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|SCMException
argument_list|(
literal|"Updating the container map failed."
argument_list|,
name|ex
argument_list|,
name|FAILED_TO_CHANGE_CONTAINER_STATE
argument_list|)
throw|;
block|}
block|}
finally|finally
block|{
name|lock
operator|.
name|writeLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|getAllContainerIDs ()
specifier|public
name|Set
argument_list|<
name|ContainerID
argument_list|>
name|getAllContainerIDs
parameter_list|()
block|{
return|return
name|containerMap
operator|.
name|keySet
argument_list|()
return|;
block|}
comment|/**    * Returns A list of containers owned by a name service.    *    * @param ownerName - Name of the NameService.    * @return - NavigableSet of ContainerIDs.    */
DECL|method|getContainerIDsByOwner (final String ownerName)
name|NavigableSet
argument_list|<
name|ContainerID
argument_list|>
name|getContainerIDsByOwner
parameter_list|(
specifier|final
name|String
name|ownerName
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|ownerName
argument_list|)
expr_stmt|;
name|lock
operator|.
name|readLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
return|return
name|ownerMap
operator|.
name|getCollection
argument_list|(
name|ownerName
argument_list|)
return|;
block|}
finally|finally
block|{
name|lock
operator|.
name|readLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Returns Containers in the System by the Type.    *    * @param type - Replication type -- StandAlone, Ratis etc.    * @return NavigableSet    */
DECL|method|getContainerIDsByType (final ReplicationType type)
name|NavigableSet
argument_list|<
name|ContainerID
argument_list|>
name|getContainerIDsByType
parameter_list|(
specifier|final
name|ReplicationType
name|type
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|lock
operator|.
name|readLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
return|return
name|typeMap
operator|.
name|getCollection
argument_list|(
name|type
argument_list|)
return|;
block|}
finally|finally
block|{
name|lock
operator|.
name|readLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Returns Containers by replication factor.    *    * @param factor - Replication Factor.    * @return NavigableSet.    */
DECL|method|getContainerIDsByFactor ( final ReplicationFactor factor)
name|NavigableSet
argument_list|<
name|ContainerID
argument_list|>
name|getContainerIDsByFactor
parameter_list|(
specifier|final
name|ReplicationFactor
name|factor
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|factor
argument_list|)
expr_stmt|;
name|lock
operator|.
name|readLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
return|return
name|factorMap
operator|.
name|getCollection
argument_list|(
name|factor
argument_list|)
return|;
block|}
finally|finally
block|{
name|lock
operator|.
name|readLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Returns Containers by State.    *    * @param state - State - Open, Closed etc.    * @return List of containers by state.    */
DECL|method|getContainerIDsByState ( final LifeCycleState state)
specifier|public
name|NavigableSet
argument_list|<
name|ContainerID
argument_list|>
name|getContainerIDsByState
parameter_list|(
specifier|final
name|LifeCycleState
name|state
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|lock
operator|.
name|readLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
return|return
name|lifeCycleStateMap
operator|.
name|getCollection
argument_list|(
name|state
argument_list|)
return|;
block|}
finally|finally
block|{
name|lock
operator|.
name|readLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Gets the containers that matches the  following filters.    *    * @param state - LifeCycleState    * @param owner - Owner    * @param factor - Replication Factor    * @param type - Replication Type    * @return ContainerInfo or Null if not container satisfies the criteria.    */
DECL|method|getMatchingContainerIDs ( final LifeCycleState state, final String owner, final ReplicationFactor factor, final ReplicationType type)
specifier|public
name|NavigableSet
argument_list|<
name|ContainerID
argument_list|>
name|getMatchingContainerIDs
parameter_list|(
specifier|final
name|LifeCycleState
name|state
parameter_list|,
specifier|final
name|String
name|owner
parameter_list|,
specifier|final
name|ReplicationFactor
name|factor
parameter_list|,
specifier|final
name|ReplicationType
name|type
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|state
argument_list|,
literal|"State cannot be null"
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|owner
argument_list|,
literal|"Owner cannot be null"
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|factor
argument_list|,
literal|"Factor cannot be null"
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|type
argument_list|,
literal|"Type cannot be null"
argument_list|)
expr_stmt|;
name|lock
operator|.
name|readLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
specifier|final
name|ContainerQueryKey
name|queryKey
init|=
operator|new
name|ContainerQueryKey
argument_list|(
name|state
argument_list|,
name|owner
argument_list|,
name|factor
argument_list|,
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|resultCache
operator|.
name|containsKey
argument_list|(
name|queryKey
argument_list|)
condition|)
block|{
return|return
name|resultCache
operator|.
name|get
argument_list|(
name|queryKey
argument_list|)
return|;
block|}
comment|// If we cannot meet any one condition we return EMPTY_SET immediately.
comment|// Since when we intersect these sets, the result will be empty if any
comment|// one is empty.
specifier|final
name|NavigableSet
argument_list|<
name|ContainerID
argument_list|>
name|stateSet
init|=
name|lifeCycleStateMap
operator|.
name|getCollection
argument_list|(
name|state
argument_list|)
decl_stmt|;
if|if
condition|(
name|stateSet
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
name|EMPTY_SET
return|;
block|}
specifier|final
name|NavigableSet
argument_list|<
name|ContainerID
argument_list|>
name|ownerSet
init|=
name|ownerMap
operator|.
name|getCollection
argument_list|(
name|owner
argument_list|)
decl_stmt|;
if|if
condition|(
name|ownerSet
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
name|EMPTY_SET
return|;
block|}
specifier|final
name|NavigableSet
argument_list|<
name|ContainerID
argument_list|>
name|factorSet
init|=
name|factorMap
operator|.
name|getCollection
argument_list|(
name|factor
argument_list|)
decl_stmt|;
if|if
condition|(
name|factorSet
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
name|EMPTY_SET
return|;
block|}
specifier|final
name|NavigableSet
argument_list|<
name|ContainerID
argument_list|>
name|typeSet
init|=
name|typeMap
operator|.
name|getCollection
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|typeSet
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
name|EMPTY_SET
return|;
block|}
comment|// if we add more constraints we will just add those sets here..
specifier|final
name|NavigableSet
argument_list|<
name|ContainerID
argument_list|>
index|[]
name|sets
init|=
name|sortBySize
argument_list|(
name|stateSet
argument_list|,
name|ownerSet
argument_list|,
name|factorSet
argument_list|,
name|typeSet
argument_list|)
decl_stmt|;
name|NavigableSet
argument_list|<
name|ContainerID
argument_list|>
name|currentSet
init|=
name|sets
index|[
literal|0
index|]
decl_stmt|;
comment|// We take the smallest set and intersect against the larger sets. This
comment|// allows us to reduce the lookups to the least possible number.
for|for
control|(
name|int
name|x
init|=
literal|1
init|;
name|x
operator|<
name|sets
operator|.
name|length
condition|;
name|x
operator|++
control|)
block|{
name|currentSet
operator|=
name|intersectSets
argument_list|(
name|currentSet
argument_list|,
name|sets
index|[
name|x
index|]
argument_list|)
expr_stmt|;
block|}
name|resultCache
operator|.
name|put
argument_list|(
name|queryKey
argument_list|,
name|currentSet
argument_list|)
expr_stmt|;
return|return
name|currentSet
return|;
block|}
finally|finally
block|{
name|lock
operator|.
name|readLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Calculates the intersection between sets and returns a new set.    *    * @param smaller - First Set    * @param bigger - Second Set    * @return resultSet which is the intersection of these two sets.    */
DECL|method|intersectSets ( final NavigableSet<ContainerID> smaller, final NavigableSet<ContainerID> bigger)
specifier|private
name|NavigableSet
argument_list|<
name|ContainerID
argument_list|>
name|intersectSets
parameter_list|(
specifier|final
name|NavigableSet
argument_list|<
name|ContainerID
argument_list|>
name|smaller
parameter_list|,
specifier|final
name|NavigableSet
argument_list|<
name|ContainerID
argument_list|>
name|bigger
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkState
argument_list|(
name|smaller
operator|.
name|size
argument_list|()
operator|<=
name|bigger
operator|.
name|size
argument_list|()
argument_list|,
literal|"This function assumes the first set is lesser or equal to second "
operator|+
literal|"set"
argument_list|)
expr_stmt|;
specifier|final
name|NavigableSet
argument_list|<
name|ContainerID
argument_list|>
name|resultSet
init|=
operator|new
name|TreeSet
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|ContainerID
name|id
range|:
name|smaller
control|)
block|{
if|if
condition|(
name|bigger
operator|.
name|contains
argument_list|(
name|id
argument_list|)
condition|)
block|{
name|resultSet
operator|.
name|add
argument_list|(
name|id
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|resultSet
return|;
block|}
comment|/**    * Sorts a list of Sets based on Size. This is useful when we are    * intersecting the sets.    *    * @param sets - varagrs of sets    * @return Returns a sorted array of sets based on the size of the set.    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|sortBySize ( final NavigableSet<ContainerID>... sets)
specifier|private
name|NavigableSet
argument_list|<
name|ContainerID
argument_list|>
index|[]
name|sortBySize
parameter_list|(
specifier|final
name|NavigableSet
argument_list|<
name|ContainerID
argument_list|>
modifier|...
name|sets
parameter_list|)
block|{
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|sets
operator|.
name|length
operator|-
literal|1
condition|;
name|x
operator|++
control|)
block|{
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|sets
operator|.
name|length
operator|-
name|x
operator|-
literal|1
condition|;
name|y
operator|++
control|)
block|{
if|if
condition|(
name|sets
index|[
name|y
index|]
operator|.
name|size
argument_list|()
operator|>
name|sets
index|[
name|y
operator|+
literal|1
index|]
operator|.
name|size
argument_list|()
condition|)
block|{
specifier|final
name|NavigableSet
name|temp
init|=
name|sets
index|[
name|y
index|]
decl_stmt|;
name|sets
index|[
name|y
index|]
operator|=
name|sets
index|[
name|y
operator|+
literal|1
index|]
expr_stmt|;
name|sets
index|[
name|y
operator|+
literal|1
index|]
operator|=
name|temp
expr_stmt|;
block|}
block|}
block|}
return|return
name|sets
return|;
block|}
DECL|method|flushCache (final ContainerInfo... containerInfos)
specifier|private
name|void
name|flushCache
parameter_list|(
specifier|final
name|ContainerInfo
modifier|...
name|containerInfos
parameter_list|)
block|{
for|for
control|(
name|ContainerInfo
name|containerInfo
range|:
name|containerInfos
control|)
block|{
specifier|final
name|ContainerQueryKey
name|key
init|=
operator|new
name|ContainerQueryKey
argument_list|(
name|containerInfo
operator|.
name|getState
argument_list|()
argument_list|,
name|containerInfo
operator|.
name|getOwner
argument_list|()
argument_list|,
name|containerInfo
operator|.
name|getReplicationFactor
argument_list|()
argument_list|,
name|containerInfo
operator|.
name|getReplicationType
argument_list|()
argument_list|)
decl_stmt|;
name|resultCache
operator|.
name|remove
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|checkIfContainerExist (ContainerID containerID)
specifier|private
name|void
name|checkIfContainerExist
parameter_list|(
name|ContainerID
name|containerID
parameter_list|)
throws|throws
name|ContainerNotFoundException
block|{
if|if
condition|(
operator|!
name|containerMap
operator|.
name|containsKey
argument_list|(
name|containerID
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|ContainerNotFoundException
argument_list|(
literal|"#"
operator|+
name|containerID
operator|.
name|getId
argument_list|()
argument_list|)
throw|;
block|}
block|}
block|}
end_class

end_unit

