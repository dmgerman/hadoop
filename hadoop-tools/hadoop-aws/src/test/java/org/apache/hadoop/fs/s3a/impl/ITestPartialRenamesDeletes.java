begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements. See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership. The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License. You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.fs.s3a.impl
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|impl
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|AccessDeniedException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|CompletableFuture
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|stream
operator|.
name|Collectors
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|stream
operator|.
name|Stream
import|;
end_import

begin_import
import|import
name|com
operator|.
name|amazonaws
operator|.
name|services
operator|.
name|s3
operator|.
name|model
operator|.
name|MultiObjectDeleteException
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Charsets
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ListeningExecutorService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|assertj
operator|.
name|core
operator|.
name|api
operator|.
name|Assertions
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Test
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|runner
operator|.
name|RunWith
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|runners
operator|.
name|Parameterized
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|contract
operator|.
name|ContractTestUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|AbstractS3ATestBase
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|S3AFileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|BlockingThreadPoolExecutorService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|DurationInfo
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|contract
operator|.
name|ContractTestUtils
operator|.
name|*
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|Constants
operator|.
name|*
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|S3ATestUtils
operator|.
name|MetricDiff
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|S3ATestUtils
operator|.
name|*
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|S3AUtils
operator|.
name|applyLocatedFiles
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|Statistic
operator|.
name|FILES_DELETE_REJECTED
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|Statistic
operator|.
name|OBJECT_DELETE_REQUESTS
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|auth
operator|.
name|RoleModel
operator|.
name|Effects
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|auth
operator|.
name|RoleModel
operator|.
name|Statement
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|auth
operator|.
name|RoleModel
operator|.
name|directory
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|auth
operator|.
name|RoleModel
operator|.
name|statement
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|auth
operator|.
name|RolePolicies
operator|.
name|*
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|auth
operator|.
name|RoleTestUtils
operator|.
name|bindRolePolicyStatements
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|auth
operator|.
name|RoleTestUtils
operator|.
name|forbidden
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|auth
operator|.
name|RoleTestUtils
operator|.
name|newAssumedRoleConfig
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|auth
operator|.
name|delegation
operator|.
name|DelegationConstants
operator|.
name|DELEGATION_TOKEN_BINDING
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|impl
operator|.
name|CallableSupplier
operator|.
name|submit
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|impl
operator|.
name|CallableSupplier
operator|.
name|waitForCompletion
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|impl
operator|.
name|MultiObjectDeleteSupport
operator|.
name|extractUndeletedPaths
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|impl
operator|.
name|MultiObjectDeleteSupport
operator|.
name|removeUndeletedPaths
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|test
operator|.
name|ExtraAssertions
operator|.
name|assertFileCount
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|test
operator|.
name|ExtraAssertions
operator|.
name|extractCause
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|IOUtils
operator|.
name|cleanupWithLogger
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|test
operator|.
name|LambdaTestUtils
operator|.
name|eval
import|;
end_import

begin_comment
comment|/**  * Test partial failures of delete and rename operations, especially  * that the S3Guard tables are consistent with the state of  * the filesystem.  *  * All these test have a unique path for each run, with a roleFS having  * full RW access to part of it, and R/O access to a restricted subdirectory  *  *<ol>  *<li>  *     The tests are parameterized to single/multi delete, which control which  *     of the two delete mechanisms are used.  *</li>  *<li>  *     In multi delete, in a scale test run, a significantly larger set of files  *     is created and then deleted.  *</li>  *<li>  *     This isn't done in the single delete as it is much slower and it is not  *     the situation we are trying to create.  *</li>  *</ol>  *  * This test manages to create lots of load on the s3guard prune command  * when that is tested in a separate test suite;  * too many tombstone files for the test to complete.  * An attempt is made in {@link #deleteTestDirInTeardown()} to prune these test  * files.  */
end_comment

begin_class
annotation|@
name|SuppressWarnings
argument_list|(
literal|"ThrowableNotThrown"
argument_list|)
annotation|@
name|RunWith
argument_list|(
name|Parameterized
operator|.
name|class
argument_list|)
DECL|class|ITestPartialRenamesDeletes
specifier|public
class|class
name|ITestPartialRenamesDeletes
extends|extends
name|AbstractS3ATestBase
block|{
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|ITestPartialRenamesDeletes
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|ROOT
specifier|private
specifier|static
specifier|final
name|Path
name|ROOT
init|=
operator|new
name|Path
argument_list|(
literal|"/"
argument_list|)
decl_stmt|;
DECL|field|STATEMENT_ALL_BUCKET_READ_ACCESS
specifier|private
specifier|static
specifier|final
name|Statement
name|STATEMENT_ALL_BUCKET_READ_ACCESS
init|=
name|statement
argument_list|(
literal|true
argument_list|,
name|S3_ALL_BUCKETS
argument_list|,
name|S3_BUCKET_READ_OPERATIONS
argument_list|)
decl_stmt|;
comment|/** Many threads for scale performance: {@value}. */
DECL|field|EXECUTOR_THREAD_COUNT
specifier|public
specifier|static
specifier|final
name|int
name|EXECUTOR_THREAD_COUNT
init|=
literal|64
decl_stmt|;
comment|/**    * For submitting work.    */
DECL|field|EXECUTOR
specifier|private
specifier|static
specifier|final
name|ListeningExecutorService
name|EXECUTOR
init|=
name|BlockingThreadPoolExecutorService
operator|.
name|newInstance
argument_list|(
name|EXECUTOR_THREAD_COUNT
argument_list|,
name|EXECUTOR_THREAD_COUNT
operator|*
literal|2
argument_list|,
literal|30
argument_list|,
name|TimeUnit
operator|.
name|SECONDS
argument_list|,
literal|"test-operations"
argument_list|)
decl_stmt|;
comment|/**    * The number of files in a non-scaled test.    *<p>    * Value: {@value}.    */
DECL|field|FILE_COUNT_NON_SCALED
specifier|public
specifier|static
specifier|final
name|int
name|FILE_COUNT_NON_SCALED
init|=
literal|2
decl_stmt|;
comment|/**    * The number of files for a scaled test. This is still    * less than half the amount which can be fitted into a delete    * request, so that even with this many R/W and R/O files,    * both can fit in the same request.    * Then, when a partial delete occurs, we can make assertions    * knowing that all R/W files should have been deleted and all    * R/O files rejected.    *<p>    * Value: {@value}.    */
DECL|field|FILE_COUNT_SCALED
specifier|public
specifier|static
specifier|final
name|int
name|FILE_COUNT_SCALED
init|=
literal|10
decl_stmt|;
DECL|field|DIR_COUNT
specifier|public
specifier|static
specifier|final
name|int
name|DIR_COUNT
init|=
literal|2
decl_stmt|;
DECL|field|DIR_COUNT_SCALED
specifier|public
specifier|static
specifier|final
name|int
name|DIR_COUNT_SCALED
init|=
literal|4
decl_stmt|;
DECL|field|DEPTH
specifier|public
specifier|static
specifier|final
name|int
name|DEPTH
init|=
literal|2
decl_stmt|;
DECL|field|DEPTH_SCALED
specifier|public
specifier|static
specifier|final
name|int
name|DEPTH_SCALED
init|=
literal|2
decl_stmt|;
DECL|field|PREFIX
specifier|public
specifier|static
specifier|final
name|String
name|PREFIX
init|=
literal|"file-"
decl_stmt|;
comment|/**    * A role FS; if non-null it is closed in teardown.    */
DECL|field|roleFS
specifier|private
name|S3AFileSystem
name|roleFS
decl_stmt|;
comment|/**    * Base path for this test run.    * This is generated uniquely for each test.    */
DECL|field|basePath
specifier|private
name|Path
name|basePath
decl_stmt|;
comment|/**    * A directory which restricted roles have full write access to.    */
DECL|field|writableDir
specifier|private
name|Path
name|writableDir
decl_stmt|;
comment|/**    * A directory to which restricted roles have only read access.    */
DECL|field|readOnlyDir
specifier|private
name|Path
name|readOnlyDir
decl_stmt|;
comment|/**    * A file under {@link #readOnlyDir} which cannot be written or deleted.    */
DECL|field|readOnlyChild
specifier|private
name|Path
name|readOnlyChild
decl_stmt|;
comment|/**    * A directory to which restricted roles have no read access.    */
DECL|field|noReadDir
specifier|private
name|Path
name|noReadDir
decl_stmt|;
comment|/** delete policy: single or multi? */
DECL|field|multiDelete
specifier|private
specifier|final
name|boolean
name|multiDelete
decl_stmt|;
comment|/**    * Configuration for the assume role FS.    */
DECL|field|assumedRoleConfig
specifier|private
name|Configuration
name|assumedRoleConfig
decl_stmt|;
DECL|field|fileCount
specifier|private
name|int
name|fileCount
decl_stmt|;
DECL|field|dirCount
specifier|private
name|int
name|dirCount
decl_stmt|;
DECL|field|dirDepth
specifier|private
name|int
name|dirDepth
decl_stmt|;
comment|/**    * Was the -Dscale switch passed in to the test run?    */
DECL|field|scaleTest
specifier|private
name|boolean
name|scaleTest
decl_stmt|;
comment|/**    * Test array for parameterized test runs.    *<ul>    *<li>Run 0: single deletes</li>    *<li>Run 1: multi deletes</li>    *</ul>    *    * @return a list of parameter tuples.    */
annotation|@
name|Parameterized
operator|.
name|Parameters
argument_list|(
name|name
operator|=
literal|"bulk-delete={0}"
argument_list|)
DECL|method|params ()
specifier|public
specifier|static
name|Collection
argument_list|<
name|Object
index|[]
argument_list|>
name|params
parameter_list|()
block|{
return|return
name|Arrays
operator|.
name|asList
argument_list|(
operator|new
name|Object
index|[]
index|[]
block|{
block|{
literal|false
block|}
block|,
block|{
literal|true
block|}
block|,     }
argument_list|)
return|;
block|}
comment|/**    * Constructor.    * @param multiDelete single vs multi delete in the role FS?    */
DECL|method|ITestPartialRenamesDeletes (final boolean multiDelete)
specifier|public
name|ITestPartialRenamesDeletes
parameter_list|(
specifier|final
name|boolean
name|multiDelete
parameter_list|)
block|{
name|this
operator|.
name|multiDelete
operator|=
name|multiDelete
expr_stmt|;
block|}
comment|/**    * This sets up a unique path for every test run, so as to guarantee isolation    * from previous runs.    * It creates a role policy which has read access to everything except    * the contents of {@link #noReadDir}, and with write access to    * {@link #writableDir}.    * @throws Exception failure    */
annotation|@
name|Override
DECL|method|setup ()
specifier|public
name|void
name|setup
parameter_list|()
throws|throws
name|Exception
block|{
name|super
operator|.
name|setup
argument_list|()
expr_stmt|;
name|assumeRoleTests
argument_list|()
expr_stmt|;
name|basePath
operator|=
name|uniquePath
argument_list|()
expr_stmt|;
name|readOnlyDir
operator|=
operator|new
name|Path
argument_list|(
name|basePath
argument_list|,
literal|"readonlyDir"
argument_list|)
expr_stmt|;
name|writableDir
operator|=
operator|new
name|Path
argument_list|(
name|basePath
argument_list|,
literal|"writableDir"
argument_list|)
expr_stmt|;
name|readOnlyChild
operator|=
operator|new
name|Path
argument_list|(
name|readOnlyDir
argument_list|,
literal|"child"
argument_list|)
expr_stmt|;
name|noReadDir
operator|=
operator|new
name|Path
argument_list|(
name|basePath
argument_list|,
literal|"noReadDir"
argument_list|)
expr_stmt|;
comment|// the full FS
name|S3AFileSystem
name|fs
init|=
name|getFileSystem
argument_list|()
decl_stmt|;
name|fs
operator|.
name|delete
argument_list|(
name|basePath
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|fs
operator|.
name|mkdirs
argument_list|(
name|writableDir
argument_list|)
expr_stmt|;
comment|// create the baseline assumed role
name|assumedRoleConfig
operator|=
name|createAssumedRoleConfig
argument_list|()
expr_stmt|;
name|bindRolePolicyStatements
argument_list|(
name|assumedRoleConfig
argument_list|,
name|STATEMENT_S3GUARD_CLIENT
argument_list|,
name|STATEMENT_ALLOW_SSE_KMS_RW
argument_list|,
name|STATEMENT_ALL_BUCKET_READ_ACCESS
argument_list|,
comment|// root:     r-x
operator|new
name|Statement
argument_list|(
name|Effects
operator|.
name|Allow
argument_list|)
comment|// dest:     rwx
operator|.
name|addActions
argument_list|(
name|S3_PATH_RW_OPERATIONS
argument_list|)
operator|.
name|addResources
argument_list|(
name|directory
argument_list|(
name|writableDir
argument_list|)
argument_list|)
argument_list|,
operator|new
name|Statement
argument_list|(
name|Effects
operator|.
name|Deny
argument_list|)
comment|// noReadDir: --x
operator|.
name|addActions
argument_list|(
name|S3_ALL_GET
argument_list|)
operator|.
name|addActions
argument_list|(
name|S3_ALL_PUT
argument_list|)
operator|.
name|addActions
argument_list|(
name|S3_ALL_DELETE
argument_list|)
operator|.
name|addResources
argument_list|(
name|directory
argument_list|(
name|noReadDir
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// the role configured to that set of restrictions
name|roleFS
operator|=
operator|(
name|S3AFileSystem
operator|)
name|readOnlyDir
operator|.
name|getFileSystem
argument_list|(
name|assumedRoleConfig
argument_list|)
expr_stmt|;
comment|// switch to the big set of files iff this is a multidelete run
comment|// with -Dscale set.
comment|// without that the DELETE calls become a key part of the bottleneck
name|scaleTest
operator|=
name|multiDelete
operator|&&
name|getTestPropertyBool
argument_list|(
name|getConfiguration
argument_list|()
argument_list|,
name|KEY_SCALE_TESTS_ENABLED
argument_list|,
name|DEFAULT_SCALE_TESTS_ENABLED
argument_list|)
expr_stmt|;
name|fileCount
operator|=
name|scaleTest
condition|?
name|FILE_COUNT_SCALED
else|:
name|FILE_COUNT_NON_SCALED
expr_stmt|;
name|dirCount
operator|=
name|scaleTest
condition|?
name|DIR_COUNT_SCALED
else|:
name|DIR_COUNT
expr_stmt|;
name|dirDepth
operator|=
name|scaleTest
condition|?
name|DEPTH_SCALED
else|:
name|DEPTH
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|teardown ()
specifier|public
name|void
name|teardown
parameter_list|()
throws|throws
name|Exception
block|{
name|cleanupWithLogger
argument_list|(
name|LOG
argument_list|,
name|roleFS
argument_list|)
expr_stmt|;
name|super
operator|.
name|teardown
argument_list|()
expr_stmt|;
block|}
DECL|method|assumeRoleTests ()
specifier|private
name|void
name|assumeRoleTests
parameter_list|()
block|{
name|assume
argument_list|(
literal|"No ARN for role tests"
argument_list|,
operator|!
name|getAssumedRoleARN
argument_list|()
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|getAssumedRoleARN ()
specifier|private
name|String
name|getAssumedRoleARN
parameter_list|()
block|{
return|return
name|getContract
argument_list|()
operator|.
name|getConf
argument_list|()
operator|.
name|getTrimmed
argument_list|(
name|ASSUMED_ROLE_ARN
argument_list|,
literal|""
argument_list|)
return|;
block|}
comment|/**    * Create the assumed role configuration.    * @return a config bonded to the ARN of the assumed role    */
DECL|method|createAssumedRoleConfig ()
specifier|public
name|Configuration
name|createAssumedRoleConfig
parameter_list|()
block|{
return|return
name|createAssumedRoleConfig
argument_list|(
name|getAssumedRoleARN
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Create a config for an assumed role; it also disables FS caching    * and sets the multi delete option to that of the current mode.    * @param roleARN ARN of role    * @return the new configuration    */
DECL|method|createAssumedRoleConfig (String roleARN)
specifier|private
name|Configuration
name|createAssumedRoleConfig
parameter_list|(
name|String
name|roleARN
parameter_list|)
block|{
name|Configuration
name|conf
init|=
name|newAssumedRoleConfig
argument_list|(
name|getContract
argument_list|()
operator|.
name|getConf
argument_list|()
argument_list|,
name|roleARN
argument_list|)
decl_stmt|;
name|removeBaseAndBucketOverrides
argument_list|(
name|conf
argument_list|,
name|DELEGATION_TOKEN_BINDING
argument_list|,
name|ENABLE_MULTI_DELETE
argument_list|)
expr_stmt|;
name|conf
operator|.
name|setBoolean
argument_list|(
name|ENABLE_MULTI_DELETE
argument_list|,
name|multiDelete
argument_list|)
expr_stmt|;
return|return
name|conf
return|;
block|}
annotation|@
name|Override
DECL|method|createConfiguration ()
specifier|protected
name|Configuration
name|createConfiguration
parameter_list|()
block|{
name|Configuration
name|conf
init|=
name|super
operator|.
name|createConfiguration
argument_list|()
decl_stmt|;
name|String
name|bucketName
init|=
name|getTestBucketName
argument_list|(
name|conf
argument_list|)
decl_stmt|;
comment|// ramp up the number of connections we can have for maximum PUT
comment|// performance
name|removeBucketOverrides
argument_list|(
name|bucketName
argument_list|,
name|conf
argument_list|,
name|MAX_THREADS
argument_list|,
name|MAXIMUM_CONNECTIONS
argument_list|,
name|S3GUARD_DDB_BACKGROUND_SLEEP_MSEC_KEY
argument_list|)
expr_stmt|;
name|conf
operator|.
name|setInt
argument_list|(
name|MAX_THREADS
argument_list|,
name|EXECUTOR_THREAD_COUNT
argument_list|)
expr_stmt|;
name|conf
operator|.
name|setInt
argument_list|(
name|MAXIMUM_CONNECTIONS
argument_list|,
name|EXECUTOR_THREAD_COUNT
operator|*
literal|2
argument_list|)
expr_stmt|;
comment|// turn off prune delays, so as to stop scale tests creating
comment|// so much cruft that future CLI prune commands take forever
name|conf
operator|.
name|setInt
argument_list|(
name|S3GUARD_DDB_BACKGROUND_SLEEP_MSEC_KEY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|conf
return|;
block|}
comment|/**    * Create a unique path, which includes method name,    * multidelete flag and a random UUID.    * @return a string to use for paths.    * @throws IOException path creation failure.    */
DECL|method|uniquePath ()
specifier|private
name|Path
name|uniquePath
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|path
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"%s-%s-%04d"
argument_list|,
name|getMethodName
argument_list|()
argument_list|,
name|multiDelete
condition|?
literal|"multi"
else|:
literal|"single"
argument_list|,
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|%
literal|10000
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * This is here to verify role and path setup.    */
annotation|@
name|Test
DECL|method|testCannotTouchUnderRODir ()
specifier|public
name|void
name|testCannotTouchUnderRODir
parameter_list|()
throws|throws
name|Throwable
block|{
name|forbidden
argument_list|(
literal|"touching the empty child "
operator|+
name|readOnlyChild
argument_list|,
literal|""
argument_list|,
parameter_list|()
lambda|->
block|{
name|touch
argument_list|(
name|roleFS
argument_list|,
name|readOnlyChild
argument_list|)
expr_stmt|;
return|return
name|readOnlyChild
return|;
block|}
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testCannotReadUnderNoReadDir ()
specifier|public
name|void
name|testCannotReadUnderNoReadDir
parameter_list|()
throws|throws
name|Throwable
block|{
name|Path
name|path
init|=
operator|new
name|Path
argument_list|(
name|noReadDir
argument_list|,
literal|"unreadable.txt"
argument_list|)
decl_stmt|;
name|createFile
argument_list|(
name|getFileSystem
argument_list|()
argument_list|,
name|path
argument_list|,
literal|true
argument_list|,
literal|"readonly"
operator|.
name|getBytes
argument_list|()
argument_list|)
expr_stmt|;
name|forbidden
argument_list|(
literal|"trying to read "
operator|+
name|path
argument_list|,
literal|""
argument_list|,
parameter_list|()
lambda|->
name|readUTF8
argument_list|(
name|roleFS
argument_list|,
name|path
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testMultiDeleteOptionPropagated ()
specifier|public
name|void
name|testMultiDeleteOptionPropagated
parameter_list|()
throws|throws
name|Throwable
block|{
name|describe
argument_list|(
literal|"Verify the test parameter propagates to the store context"
argument_list|)
expr_stmt|;
name|StoreContext
name|ctx
init|=
name|roleFS
operator|.
name|createStoreContext
argument_list|()
decl_stmt|;
name|Assertions
operator|.
name|assertThat
argument_list|(
name|ctx
operator|.
name|isMultiObjectDeleteEnabled
argument_list|()
argument_list|)
operator|.
name|as
argument_list|(
name|ctx
operator|.
name|toString
argument_list|()
argument_list|)
operator|.
name|isEqualTo
argument_list|(
name|multiDelete
argument_list|)
expr_stmt|;
block|}
comment|/**    * Execute a sequence of rename operations with access locked down.    */
annotation|@
name|Test
DECL|method|testRenameParentPathNotWriteable ()
specifier|public
name|void
name|testRenameParentPathNotWriteable
parameter_list|()
throws|throws
name|Throwable
block|{
name|describe
argument_list|(
literal|"rename with parent paths not writeable; multi=%s"
argument_list|,
name|multiDelete
argument_list|)
expr_stmt|;
specifier|final
name|Configuration
name|conf
init|=
name|createAssumedRoleConfig
argument_list|()
decl_stmt|;
name|bindRolePolicyStatements
argument_list|(
name|conf
argument_list|,
name|STATEMENT_S3GUARD_CLIENT
argument_list|,
name|STATEMENT_ALLOW_SSE_KMS_RW
argument_list|,
name|STATEMENT_ALL_BUCKET_READ_ACCESS
argument_list|,
operator|new
name|Statement
argument_list|(
name|Effects
operator|.
name|Allow
argument_list|)
operator|.
name|addActions
argument_list|(
name|S3_PATH_RW_OPERATIONS
argument_list|)
operator|.
name|addResources
argument_list|(
name|directory
argument_list|(
name|readOnlyDir
argument_list|)
argument_list|)
operator|.
name|addResources
argument_list|(
name|directory
argument_list|(
name|writableDir
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|roleFS
operator|=
operator|(
name|S3AFileSystem
operator|)
name|readOnlyDir
operator|.
name|getFileSystem
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|S3AFileSystem
name|fs
init|=
name|getFileSystem
argument_list|()
decl_stmt|;
name|roleFS
operator|.
name|getFileStatus
argument_list|(
name|ROOT
argument_list|)
expr_stmt|;
name|fs
operator|.
name|mkdirs
argument_list|(
name|readOnlyDir
argument_list|)
expr_stmt|;
comment|// you can create an adjacent child
name|touch
argument_list|(
name|fs
argument_list|,
name|readOnlyChild
argument_list|)
expr_stmt|;
name|fs
operator|.
name|delete
argument_list|(
name|writableDir
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|// as dest doesn't exist, this will map child -> dest
name|assertRenameOutcome
argument_list|(
name|roleFS
argument_list|,
name|readOnlyChild
argument_list|,
name|writableDir
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|assertIsFile
argument_list|(
name|writableDir
argument_list|)
expr_stmt|;
name|assertIsDirectory
argument_list|(
name|readOnlyDir
argument_list|)
expr_stmt|;
name|Path
name|renamedDestPath
init|=
operator|new
name|Path
argument_list|(
name|readOnlyDir
argument_list|,
name|writableDir
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
name|assertRenameOutcome
argument_list|(
name|roleFS
argument_list|,
name|writableDir
argument_list|,
name|readOnlyDir
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|assertIsFile
argument_list|(
name|renamedDestPath
argument_list|)
expr_stmt|;
name|roleFS
operator|.
name|delete
argument_list|(
name|readOnlyDir
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|roleFS
operator|.
name|delete
argument_list|(
name|writableDir
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testRenameSingleFileFailsInDelete ()
specifier|public
name|void
name|testRenameSingleFileFailsInDelete
parameter_list|()
throws|throws
name|Throwable
block|{
name|describe
argument_list|(
literal|"rename with source read only; multi=%s"
argument_list|,
name|multiDelete
argument_list|)
expr_stmt|;
name|Path
name|readOnlyFile
init|=
name|readOnlyChild
decl_stmt|;
comment|// the full FS
name|S3AFileSystem
name|fs
init|=
name|getFileSystem
argument_list|()
decl_stmt|;
name|fs
operator|.
name|delete
argument_list|(
name|basePath
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|// this file is readable by the roleFS, but cannot be deleted
name|touch
argument_list|(
name|fs
argument_list|,
name|readOnlyFile
argument_list|)
expr_stmt|;
name|roleFS
operator|.
name|delete
argument_list|(
name|writableDir
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|roleFS
operator|.
name|mkdirs
argument_list|(
name|writableDir
argument_list|)
expr_stmt|;
comment|// rename will fail in the delete phase
name|expectRenameForbidden
argument_list|(
name|readOnlyFile
argument_list|,
name|writableDir
argument_list|)
expr_stmt|;
comment|// and the source file is still there
name|assertIsFile
argument_list|(
name|readOnlyFile
argument_list|)
expr_stmt|;
comment|// and so is the copied version, because there's no attempt
comment|// at rollback, or preflight checking on the delete permissions
name|Path
name|renamedFile
init|=
operator|new
name|Path
argument_list|(
name|writableDir
argument_list|,
name|readOnlyFile
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
name|assertIsFile
argument_list|(
name|renamedFile
argument_list|)
expr_stmt|;
name|ContractTestUtils
operator|.
name|assertDeleted
argument_list|(
name|roleFS
argument_list|,
name|renamedFile
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|assertFileCount
argument_list|(
literal|"Empty Dest Dir"
argument_list|,
name|roleFS
argument_list|,
name|writableDir
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/**    * Execute a sequence of rename operations where the source    * data is read only to the client calling rename().    * This will cause the inner delete() operations to fail, whose outcomes    * are explored.    * Multiple files are created (in parallel) for some renames, so the test    * explores the outcome on bulk delete calls, including verifying that a    * MultiObjectDeleteException is translated to an AccessDeniedException.    *<ol>    *<li>The exception raised is AccessDeniedException,    *   from single and multi DELETE calls.</li>    *<li>It happens after the COPY. Not ideal, but, well, we can't pretend    *   it's a filesystem forever.</li>    *</ol>    */
annotation|@
name|Test
DECL|method|testRenameDirFailsInDelete ()
specifier|public
name|void
name|testRenameDirFailsInDelete
parameter_list|()
throws|throws
name|Throwable
block|{
name|describe
argument_list|(
literal|"rename with source read only; multi=%s"
argument_list|,
name|multiDelete
argument_list|)
expr_stmt|;
comment|// the full FS
name|S3AFileSystem
name|fs
init|=
name|getFileSystem
argument_list|()
decl_stmt|;
name|roleFS
operator|.
name|mkdirs
argument_list|(
name|writableDir
argument_list|)
expr_stmt|;
comment|// create a set of files
comment|// this is done in parallel as it is 10x faster on a long-haul test run.
name|List
argument_list|<
name|Path
argument_list|>
name|createdFiles
init|=
name|createFiles
argument_list|(
name|fs
argument_list|,
name|readOnlyDir
argument_list|,
name|dirDepth
argument_list|,
name|fileCount
argument_list|,
name|dirCount
argument_list|)
decl_stmt|;
comment|// are they all there?
name|int
name|expectedFileCount
init|=
name|createdFiles
operator|.
name|size
argument_list|()
decl_stmt|;
name|assertFileCount
argument_list|(
literal|"files ready to rename"
argument_list|,
name|roleFS
argument_list|,
name|readOnlyDir
argument_list|,
name|expectedFileCount
argument_list|)
expr_stmt|;
comment|// try to rename the directory
name|LOG
operator|.
name|info
argument_list|(
literal|"Renaming readonly files {} to {}"
argument_list|,
name|readOnlyDir
argument_list|,
name|writableDir
argument_list|)
expr_stmt|;
name|AccessDeniedException
name|deniedException
init|=
name|expectRenameForbidden
argument_list|(
name|readOnlyDir
argument_list|,
name|writableDir
argument_list|)
decl_stmt|;
if|if
condition|(
name|multiDelete
condition|)
block|{
comment|// look in that exception for a multidelete
name|MultiObjectDeleteException
name|mde
init|=
name|extractCause
argument_list|(
name|MultiObjectDeleteException
operator|.
name|class
argument_list|,
name|deniedException
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|Path
argument_list|>
name|undeleted
init|=
name|extractUndeletedPaths
argument_list|(
name|mde
argument_list|,
name|fs
operator|::
name|keyToQualifiedPath
argument_list|)
decl_stmt|;
name|Assertions
operator|.
name|assertThat
argument_list|(
name|undeleted
argument_list|)
operator|.
name|as
argument_list|(
literal|"files which could not be deleted"
argument_list|)
operator|.
name|hasSize
argument_list|(
name|expectedFileCount
argument_list|)
operator|.
name|containsAll
argument_list|(
name|createdFiles
argument_list|)
operator|.
name|containsExactlyInAnyOrderElementsOf
argument_list|(
name|createdFiles
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Result of renaming read-only files is as expected"
argument_list|,
name|deniedException
argument_list|)
expr_stmt|;
name|assertFileCount
argument_list|(
literal|"files in the source directory"
argument_list|,
name|roleFS
argument_list|,
name|readOnlyDir
argument_list|,
name|expectedFileCount
argument_list|)
expr_stmt|;
comment|// now lets look at the destination.
comment|// even with S3Guard on, we expect the destination to match that of our
comment|// the remote state.
comment|// the test will exist
name|describe
argument_list|(
literal|"Verify destination directory exists"
argument_list|)
expr_stmt|;
name|FileStatus
name|st
init|=
name|roleFS
operator|.
name|getFileStatus
argument_list|(
name|writableDir
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
literal|"Not a directory: "
operator|+
name|st
argument_list|,
name|st
operator|.
name|isDirectory
argument_list|()
argument_list|)
expr_stmt|;
name|assertFileCount
argument_list|(
literal|"files in the dest directory"
argument_list|,
name|roleFS
argument_list|,
name|writableDir
argument_list|,
name|expectedFileCount
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testRenameFileFailsNoWrite ()
specifier|public
name|void
name|testRenameFileFailsNoWrite
parameter_list|()
throws|throws
name|Throwable
block|{
name|describe
argument_list|(
literal|"Try to rename to a write-only destination fails with src"
operator|+
literal|"& dest unchanged."
argument_list|)
expr_stmt|;
name|roleFS
operator|.
name|mkdirs
argument_list|(
name|writableDir
argument_list|)
expr_stmt|;
name|S3AFileSystem
name|fs
init|=
name|getFileSystem
argument_list|()
decl_stmt|;
name|Path
name|source
init|=
operator|new
name|Path
argument_list|(
name|writableDir
argument_list|,
literal|"source"
argument_list|)
decl_stmt|;
name|touch
argument_list|(
name|fs
argument_list|,
name|source
argument_list|)
expr_stmt|;
name|fs
operator|.
name|mkdirs
argument_list|(
name|readOnlyDir
argument_list|)
expr_stmt|;
name|Path
name|dest
init|=
operator|new
name|Path
argument_list|(
name|readOnlyDir
argument_list|,
literal|"dest"
argument_list|)
decl_stmt|;
name|describe
argument_list|(
literal|"Renaming files {} to {}"
argument_list|,
name|writableDir
argument_list|,
name|dest
argument_list|)
expr_stmt|;
comment|// rename fails but doesn't raise an exception. Good or bad?
name|expectRenameForbidden
argument_list|(
name|source
argument_list|,
name|dest
argument_list|)
expr_stmt|;
name|assertIsFile
argument_list|(
name|source
argument_list|)
expr_stmt|;
name|assertPathDoesNotExist
argument_list|(
literal|"rename destination"
argument_list|,
name|dest
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testCopyDirFailsToReadOnlyDir ()
specifier|public
name|void
name|testCopyDirFailsToReadOnlyDir
parameter_list|()
throws|throws
name|Throwable
block|{
name|describe
argument_list|(
literal|"Try to copy to a read-only destination"
argument_list|)
expr_stmt|;
name|roleFS
operator|.
name|mkdirs
argument_list|(
name|writableDir
argument_list|)
expr_stmt|;
name|S3AFileSystem
name|fs
init|=
name|getFileSystem
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Path
argument_list|>
name|files
init|=
name|createFiles
argument_list|(
name|fs
argument_list|,
name|writableDir
argument_list|,
name|dirDepth
argument_list|,
name|fileCount
argument_list|,
name|dirCount
argument_list|)
decl_stmt|;
name|fs
operator|.
name|mkdirs
argument_list|(
name|readOnlyDir
argument_list|)
expr_stmt|;
name|Path
name|dest
init|=
operator|new
name|Path
argument_list|(
name|readOnlyDir
argument_list|,
literal|"dest"
argument_list|)
decl_stmt|;
name|expectRenameForbidden
argument_list|(
name|writableDir
argument_list|,
name|dest
argument_list|)
expr_stmt|;
name|assertPathDoesNotExist
argument_list|(
literal|"rename destination"
argument_list|,
name|dest
argument_list|)
expr_stmt|;
name|assertFileCount
argument_list|(
literal|"files in the source directory"
argument_list|,
name|roleFS
argument_list|,
name|writableDir
argument_list|,
name|files
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testCopyFileFailsOnSourceRead ()
specifier|public
name|void
name|testCopyFileFailsOnSourceRead
parameter_list|()
throws|throws
name|Throwable
block|{
name|describe
argument_list|(
literal|"The source file isn't readable, so the COPY fails"
argument_list|)
expr_stmt|;
name|Path
name|source
init|=
operator|new
name|Path
argument_list|(
name|noReadDir
argument_list|,
literal|"source"
argument_list|)
decl_stmt|;
name|S3AFileSystem
name|fs
init|=
name|getFileSystem
argument_list|()
decl_stmt|;
name|touch
argument_list|(
name|fs
argument_list|,
name|source
argument_list|)
expr_stmt|;
name|fs
operator|.
name|mkdirs
argument_list|(
name|writableDir
argument_list|)
expr_stmt|;
name|Path
name|dest
init|=
operator|new
name|Path
argument_list|(
name|writableDir
argument_list|,
literal|"dest"
argument_list|)
decl_stmt|;
name|expectRenameForbidden
argument_list|(
name|source
argument_list|,
name|dest
argument_list|)
expr_stmt|;
name|assertIsFile
argument_list|(
name|source
argument_list|)
expr_stmt|;
name|assertPathDoesNotExist
argument_list|(
literal|"rename destination"
argument_list|,
name|dest
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testCopyDirFailsOnSourceRead ()
specifier|public
name|void
name|testCopyDirFailsOnSourceRead
parameter_list|()
throws|throws
name|Throwable
block|{
name|describe
argument_list|(
literal|"The source file isn't readable, so the COPY fails"
argument_list|)
expr_stmt|;
name|S3AFileSystem
name|fs
init|=
name|getFileSystem
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Path
argument_list|>
name|files
init|=
name|createFiles
argument_list|(
name|fs
argument_list|,
name|noReadDir
argument_list|,
name|dirDepth
argument_list|,
name|fileCount
argument_list|,
name|dirCount
argument_list|)
decl_stmt|;
name|fs
operator|.
name|mkdirs
argument_list|(
name|writableDir
argument_list|)
expr_stmt|;
name|Path
name|dest
init|=
operator|new
name|Path
argument_list|(
name|writableDir
argument_list|,
literal|"dest"
argument_list|)
decl_stmt|;
name|expectRenameForbidden
argument_list|(
name|noReadDir
argument_list|,
name|dest
argument_list|)
expr_stmt|;
name|assertFileCount
argument_list|(
literal|"files in the source directory"
argument_list|,
name|fs
argument_list|,
name|noReadDir
argument_list|,
name|files
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Have a directory with full R/W permissions, but then remove    * write access underneath, and try to delete it.    * This verifies that failures in the delete fake dir stage.    * are not visible.    */
annotation|@
name|Test
DECL|method|testPartialEmptyDirDelete ()
specifier|public
name|void
name|testPartialEmptyDirDelete
parameter_list|()
throws|throws
name|Throwable
block|{
name|describe
argument_list|(
literal|"delete an empty directory with parent dir r/o"
operator|+
literal|" multidelete=%s"
argument_list|,
name|multiDelete
argument_list|)
expr_stmt|;
comment|// the full FS
specifier|final
name|Path
name|deletableChild
init|=
operator|new
name|Path
argument_list|(
name|writableDir
argument_list|,
literal|"deletableChild"
argument_list|)
decl_stmt|;
comment|// deletable child is created.
name|roleFS
operator|.
name|mkdirs
argument_list|(
name|deletableChild
argument_list|)
expr_stmt|;
name|assertPathExists
argument_list|(
literal|"parent dir after create"
argument_list|,
name|writableDir
argument_list|)
expr_stmt|;
name|assertPathExists
argument_list|(
literal|"grandparent dir after create"
argument_list|,
name|writableDir
operator|.
name|getParent
argument_list|()
argument_list|)
expr_stmt|;
comment|// now delete it.
name|roleFS
operator|.
name|delete
argument_list|(
name|deletableChild
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|assertPathExists
argument_list|(
literal|"parent dir after deletion"
argument_list|,
name|writableDir
argument_list|)
expr_stmt|;
name|assertPathExists
argument_list|(
literal|"grandparent dir after deletion"
argument_list|,
name|writableDir
operator|.
name|getParent
argument_list|()
argument_list|)
expr_stmt|;
name|assertPathDoesNotExist
argument_list|(
literal|"deletable dir after deletion"
argument_list|,
name|deletableChild
argument_list|)
expr_stmt|;
block|}
comment|/**    * Have a directory with full R/W permissions, but then remove    * write access underneath, and try to delete it.    */
annotation|@
name|Test
DECL|method|testPartialDirDelete ()
specifier|public
name|void
name|testPartialDirDelete
parameter_list|()
throws|throws
name|Throwable
block|{
name|describe
argument_list|(
literal|"delete with part of the child tree read only;"
operator|+
literal|" multidelete=%s"
argument_list|,
name|multiDelete
argument_list|)
expr_stmt|;
comment|// the full FS
name|S3AFileSystem
name|fs
init|=
name|getFileSystem
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Path
argument_list|>
name|readOnlyFiles
init|=
name|createFiles
argument_list|(
name|fs
argument_list|,
name|readOnlyDir
argument_list|,
name|dirDepth
argument_list|,
name|fileCount
argument_list|,
name|dirCount
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Path
argument_list|>
name|deletableFiles
init|=
name|createFiles
argument_list|(
name|fs
argument_list|,
name|writableDir
argument_list|,
name|dirDepth
argument_list|,
name|fileCount
argument_list|,
name|dirCount
argument_list|)
decl_stmt|;
comment|// as a safety check, verify that one of the deletable files can be deleted
name|Path
name|head
init|=
name|deletableFiles
operator|.
name|remove
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
literal|"delete "
operator|+
name|head
operator|+
literal|" failed"
argument_list|,
name|roleFS
operator|.
name|delete
argument_list|(
name|head
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|Path
argument_list|>
name|allFiles
init|=
name|Stream
operator|.
name|concat
argument_list|(
name|readOnlyFiles
operator|.
name|stream
argument_list|()
argument_list|,
name|deletableFiles
operator|.
name|stream
argument_list|()
argument_list|)
operator|.
name|collect
argument_list|(
name|Collectors
operator|.
name|toList
argument_list|()
argument_list|)
decl_stmt|;
comment|// this set can be deleted by the role FS
name|MetricDiff
name|rejectionCount
init|=
operator|new
name|MetricDiff
argument_list|(
name|roleFS
argument_list|,
name|FILES_DELETE_REJECTED
argument_list|)
decl_stmt|;
name|MetricDiff
name|deleteVerbCount
init|=
operator|new
name|MetricDiff
argument_list|(
name|roleFS
argument_list|,
name|OBJECT_DELETE_REQUESTS
argument_list|)
decl_stmt|;
name|describe
argument_list|(
literal|"Trying to delete read only directory"
argument_list|)
expr_stmt|;
name|AccessDeniedException
name|ex
init|=
name|expectDeleteForbidden
argument_list|(
name|readOnlyDir
argument_list|)
decl_stmt|;
if|if
condition|(
name|multiDelete
condition|)
block|{
comment|// multi-delete status checks
name|extractCause
argument_list|(
name|MultiObjectDeleteException
operator|.
name|class
argument_list|,
name|ex
argument_list|)
expr_stmt|;
name|rejectionCount
operator|.
name|assertDiffEquals
argument_list|(
literal|"Wrong rejection count"
argument_list|,
name|readOnlyFiles
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|deleteVerbCount
operator|.
name|assertDiffEquals
argument_list|(
literal|"Wrong delete count"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|reset
argument_list|(
name|rejectionCount
argument_list|,
name|deleteVerbCount
argument_list|)
expr_stmt|;
block|}
comment|// all the files are still there? (avoid in scale test due to cost)
if|if
condition|(
operator|!
name|scaleTest
condition|)
block|{
name|readOnlyFiles
operator|.
name|forEach
argument_list|(
name|this
operator|::
name|pathMustExist
argument_list|)
expr_stmt|;
block|}
name|describe
argument_list|(
literal|"Trying to delete upper-level directory"
argument_list|)
expr_stmt|;
name|ex
operator|=
name|expectDeleteForbidden
argument_list|(
name|basePath
argument_list|)
expr_stmt|;
if|if
condition|(
name|multiDelete
condition|)
block|{
comment|// multi-delete status checks
name|extractCause
argument_list|(
name|MultiObjectDeleteException
operator|.
name|class
argument_list|,
name|ex
argument_list|)
expr_stmt|;
name|deleteVerbCount
operator|.
name|assertDiffEquals
argument_list|(
literal|"Wrong delete count"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|MultiObjectDeleteException
name|mde
init|=
name|extractCause
argument_list|(
name|MultiObjectDeleteException
operator|.
name|class
argument_list|,
name|ex
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|Path
argument_list|>
name|undeleted
init|=
name|removeUndeletedPaths
argument_list|(
name|mde
argument_list|,
name|allFiles
argument_list|,
name|fs
operator|::
name|keyToQualifiedPath
argument_list|)
decl_stmt|;
name|Assertions
operator|.
name|assertThat
argument_list|(
name|undeleted
argument_list|)
operator|.
name|as
argument_list|(
literal|"files which could not be deleted"
argument_list|)
operator|.
name|containsExactlyInAnyOrderElementsOf
argument_list|(
name|readOnlyFiles
argument_list|)
expr_stmt|;
name|Assertions
operator|.
name|assertThat
argument_list|(
name|allFiles
argument_list|)
operator|.
name|as
argument_list|(
literal|"files which were deleted"
argument_list|)
operator|.
name|containsExactlyInAnyOrderElementsOf
argument_list|(
name|deletableFiles
argument_list|)
expr_stmt|;
name|rejectionCount
operator|.
name|assertDiffEquals
argument_list|(
literal|"Wrong rejection count"
argument_list|,
name|readOnlyFiles
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|reset
argument_list|(
name|rejectionCount
argument_list|,
name|deleteVerbCount
argument_list|)
expr_stmt|;
comment|// build the set of all paths under the directory tree through
comment|// a directory listing (i.e. not getFileStatus()).
comment|// small risk of observed inconsistency here on unguarded stores.
specifier|final
name|Set
argument_list|<
name|Path
argument_list|>
name|readOnlyListing
init|=
name|listFilesUnderPath
argument_list|(
name|readOnlyDir
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|String
name|directoryList
init|=
name|readOnlyListing
operator|.
name|stream
argument_list|()
operator|.
name|map
argument_list|(
name|Path
operator|::
name|toString
argument_list|)
operator|.
name|collect
argument_list|(
name|Collectors
operator|.
name|joining
argument_list|(
literal|", "
argument_list|,
literal|"["
argument_list|,
literal|"]"
argument_list|)
argument_list|)
decl_stmt|;
name|Assertions
operator|.
name|assertThat
argument_list|(
name|readOnlyListing
argument_list|)
operator|.
name|as
argument_list|(
literal|"ReadOnly directory "
operator|+
name|directoryList
argument_list|)
operator|.
name|containsAll
argument_list|(
name|readOnlyFiles
argument_list|)
expr_stmt|;
block|}
comment|/**    * Expect the delete() call to fail.    * @param path path to delete.    * @return the expected exception.    * @throws Exception any other failure.    */
DECL|method|expectDeleteForbidden (Path path)
specifier|private
name|AccessDeniedException
name|expectDeleteForbidden
parameter_list|(
name|Path
name|path
parameter_list|)
throws|throws
name|Exception
block|{
try|try
init|(
name|DurationInfo
name|ignored
init|=
operator|new
name|DurationInfo
argument_list|(
name|LOG
argument_list|,
literal|true
argument_list|,
literal|"delete %s"
argument_list|,
name|path
argument_list|)
init|)
block|{
return|return
name|forbidden
argument_list|(
literal|"Expected an error deleting "
operator|+
name|path
argument_list|,
literal|""
argument_list|,
parameter_list|()
lambda|->
block|{
name|boolean
name|r
init|=
name|roleFS
operator|.
name|delete
argument_list|(
name|path
argument_list|,
literal|true
argument_list|)
decl_stmt|;
return|return
literal|" delete="
operator|+
name|r
operator|+
literal|" "
operator|+
name|ls
argument_list|(
name|path
operator|.
name|getParent
argument_list|()
argument_list|)
return|;
block|}
argument_list|)
return|;
block|}
block|}
comment|/**    * Expect that a rename will fail with an exception using the roleFS.    * @param src source    * @param dest dest    * @return the exception raised.    * @throws Exception any other failure    */
DECL|method|expectRenameForbidden (Path src, Path dest)
specifier|private
name|AccessDeniedException
name|expectRenameForbidden
parameter_list|(
name|Path
name|src
parameter_list|,
name|Path
name|dest
parameter_list|)
throws|throws
name|Exception
block|{
try|try
init|(
name|DurationInfo
name|ignored
init|=
operator|new
name|DurationInfo
argument_list|(
name|LOG
argument_list|,
literal|true
argument_list|,
literal|"rename(%s, %s)"
argument_list|,
name|src
argument_list|,
name|dest
argument_list|)
init|)
block|{
return|return
name|forbidden
argument_list|(
literal|"Renaming "
operator|+
name|src
operator|+
literal|" to "
operator|+
name|dest
argument_list|,
literal|""
argument_list|,
parameter_list|()
lambda|->
block|{
name|boolean
name|result
init|=
name|roleFS
operator|.
name|rename
argument_list|(
name|src
argument_list|,
name|dest
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|error
argument_list|(
literal|"Rename should have been forbidden but returned {}"
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|error
argument_list|(
literal|"Source directory:\n{}"
argument_list|,
name|ContractTestUtils
operator|.
name|ls
argument_list|(
name|getFileSystem
argument_list|()
argument_list|,
name|src
operator|.
name|getParent
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|error
argument_list|(
literal|"Destination directory:\n{}"
argument_list|,
name|ContractTestUtils
operator|.
name|ls
argument_list|(
name|getFileSystem
argument_list|()
argument_list|,
name|src
operator|.
name|getParent
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|"Rename unexpectedly returned "
operator|+
name|result
return|;
block|}
argument_list|)
return|;
block|}
block|}
comment|/**    * Assert that a path must exist, map IOEs to RTEs for loops.    * @param p path.    */
DECL|method|pathMustExist (Path p)
specifier|private
name|void
name|pathMustExist
parameter_list|(
name|Path
name|p
parameter_list|)
block|{
name|eval
argument_list|(
parameter_list|()
lambda|->
name|assertPathExists
argument_list|(
literal|"Missing path"
argument_list|,
name|p
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * List all files under a path.    * @param path path to list    * @param recursive recursive listing?    * @return an unordered set of the paths.    * @throws IOException failure    */
DECL|method|listFilesUnderPath (Path path, boolean recursive)
specifier|private
name|Set
argument_list|<
name|Path
argument_list|>
name|listFilesUnderPath
parameter_list|(
name|Path
name|path
parameter_list|,
name|boolean
name|recursive
parameter_list|)
throws|throws
name|IOException
block|{
name|Set
argument_list|<
name|Path
argument_list|>
name|files
init|=
operator|new
name|TreeSet
argument_list|<>
argument_list|()
decl_stmt|;
try|try
init|(
name|DurationInfo
name|ignore
init|=
operator|new
name|DurationInfo
argument_list|(
name|LOG
argument_list|,
literal|"ls -R %s"
argument_list|,
name|path
argument_list|)
init|)
block|{
name|applyLocatedFiles
argument_list|(
name|getFileSystem
argument_list|()
operator|.
name|listFiles
argument_list|(
name|path
argument_list|,
name|recursive
argument_list|)
argument_list|,
parameter_list|(
name|status
parameter_list|)
lambda|->
name|files
operator|.
name|add
argument_list|(
name|status
operator|.
name|getPath
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|files
return|;
block|}
comment|/**    * Write the text to a file asynchronously. Logs the operation duration.    * @param fs filesystem    * @param path path    * @return future to the patch created.    */
DECL|method|put (FileSystem fs, Path path, String text)
specifier|private
specifier|static
name|CompletableFuture
argument_list|<
name|Path
argument_list|>
name|put
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Path
name|path
parameter_list|,
name|String
name|text
parameter_list|)
block|{
return|return
name|submit
argument_list|(
name|EXECUTOR
argument_list|,
parameter_list|()
lambda|->
block|{
try|try
init|(
name|DurationInfo
name|ignore
init|=
operator|new
name|DurationInfo
argument_list|(
name|LOG
argument_list|,
literal|false
argument_list|,
literal|"Creating %s"
argument_list|,
name|path
argument_list|)
init|)
block|{
name|createFile
argument_list|(
name|fs
argument_list|,
name|path
argument_list|,
literal|true
argument_list|,
name|text
operator|.
name|getBytes
argument_list|(
name|Charsets
operator|.
name|UTF_8
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|path
return|;
block|}
block|}
argument_list|)
return|;
block|}
comment|/**    * Parallel-touch a set of files in the destination directory.    * @param fs filesystem    * @param destDir destination    * @param depth file depth    * @param fileCount number of files to create.    * @param dirCount number of dirs to create at each level    * @return the list of files created.    */
DECL|method|createFiles (final FileSystem fs, final Path destDir, final int depth, final int fileCount, final int dirCount)
specifier|public
specifier|static
name|List
argument_list|<
name|Path
argument_list|>
name|createFiles
parameter_list|(
specifier|final
name|FileSystem
name|fs
parameter_list|,
specifier|final
name|Path
name|destDir
parameter_list|,
specifier|final
name|int
name|depth
parameter_list|,
specifier|final
name|int
name|fileCount
parameter_list|,
specifier|final
name|int
name|dirCount
parameter_list|)
throws|throws
name|IOException
block|{
name|List
argument_list|<
name|CompletableFuture
argument_list|<
name|Path
argument_list|>
argument_list|>
name|futures
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|fileCount
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Path
argument_list|>
name|paths
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|fileCount
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Path
argument_list|>
name|dirs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|fileCount
argument_list|)
decl_stmt|;
name|buildPaths
argument_list|(
name|paths
argument_list|,
name|dirs
argument_list|,
name|destDir
argument_list|,
name|depth
argument_list|,
name|fileCount
argument_list|,
name|dirCount
argument_list|)
expr_stmt|;
try|try
init|(
name|DurationInfo
name|ignore
init|=
operator|new
name|DurationInfo
argument_list|(
name|LOG
argument_list|,
literal|"Creating %d files"
argument_list|,
name|fileCount
argument_list|)
init|)
block|{
for|for
control|(
name|Path
name|path
range|:
name|paths
control|)
block|{
name|futures
operator|.
name|add
argument_list|(
name|put
argument_list|(
name|fs
argument_list|,
name|path
argument_list|,
name|path
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|waitForCompletion
argument_list|(
name|futures
argument_list|)
expr_stmt|;
return|return
name|paths
return|;
block|}
block|}
comment|/**    * Recursive method to build up lists of files and directories.    * @param filePaths list of file paths to add entries to.    * @param dirPaths list of directory paths to add entries to.    * @param destDir destination directory.    * @param depth depth of directories    * @param fileCount number of files.    * @param dirCount number of directories.    */
DECL|method|buildPaths ( final List<Path> filePaths, final List<Path> dirPaths, final Path destDir, final int depth, final int fileCount, final int dirCount)
specifier|private
specifier|static
name|void
name|buildPaths
parameter_list|(
specifier|final
name|List
argument_list|<
name|Path
argument_list|>
name|filePaths
parameter_list|,
specifier|final
name|List
argument_list|<
name|Path
argument_list|>
name|dirPaths
parameter_list|,
specifier|final
name|Path
name|destDir
parameter_list|,
specifier|final
name|int
name|depth
parameter_list|,
specifier|final
name|int
name|fileCount
parameter_list|,
specifier|final
name|int
name|dirCount
parameter_list|)
block|{
if|if
condition|(
name|depth
operator|<=
literal|0
condition|)
block|{
return|return;
block|}
comment|// create the file paths
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fileCount
condition|;
name|i
operator|++
control|)
block|{
name|String
name|name
init|=
name|PREFIX
operator|+
name|i
decl_stmt|;
name|Path
name|p
init|=
operator|new
name|Path
argument_list|(
name|destDir
argument_list|,
name|name
argument_list|)
decl_stmt|;
name|filePaths
operator|.
name|add
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|dirCount
condition|;
name|i
operator|++
control|)
block|{
name|String
name|name
init|=
literal|"dir-"
operator|+
name|i
decl_stmt|;
name|Path
name|p
init|=
operator|new
name|Path
argument_list|(
name|destDir
argument_list|,
name|name
argument_list|)
decl_stmt|;
name|dirPaths
operator|.
name|add
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|buildPaths
argument_list|(
name|filePaths
argument_list|,
name|dirPaths
argument_list|,
name|p
argument_list|,
name|depth
operator|-
literal|1
argument_list|,
name|fileCount
argument_list|,
name|dirCount
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

