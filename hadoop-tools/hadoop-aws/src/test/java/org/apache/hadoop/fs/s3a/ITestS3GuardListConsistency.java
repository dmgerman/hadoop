begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.fs.s3a
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
package|;
end_package

begin_import
import|import
name|com
operator|.
name|amazonaws
operator|.
name|services
operator|.
name|s3
operator|.
name|model
operator|.
name|ListObjectsV2Request
import|;
end_import

begin_import
import|import
name|com
operator|.
name|amazonaws
operator|.
name|services
operator|.
name|s3
operator|.
name|model
operator|.
name|ListObjectsV2Result
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FSDataOutputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|LocatedFileStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|RemoteIterator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|contract
operator|.
name|AbstractFSContract
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|contract
operator|.
name|s3a
operator|.
name|S3AContract
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Assume
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Test
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileNotFoundException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|stream
operator|.
name|Collectors
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|contract
operator|.
name|ContractTestUtils
operator|.
name|touch
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|contract
operator|.
name|ContractTestUtils
operator|.
name|writeTextFile
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|Constants
operator|.
name|*
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|FailureInjectionPolicy
operator|.
name|*
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|InconsistentAmazonS3Client
operator|.
name|*
import|;
end_import

begin_comment
comment|/**  * Test S3Guard list consistency feature by injecting delayed listObjects()  * visibility via {@link InconsistentAmazonS3Client}.  *  * Tests here generally:  * 1. Use the inconsistency injection mentioned above.  * 2. Only run when S3Guard is enabled.  */
end_comment

begin_class
DECL|class|ITestS3GuardListConsistency
specifier|public
class|class
name|ITestS3GuardListConsistency
extends|extends
name|AbstractS3ATestBase
block|{
DECL|field|invoker
specifier|private
name|Invoker
name|invoker
decl_stmt|;
annotation|@
name|Override
DECL|method|setup ()
specifier|public
name|void
name|setup
parameter_list|()
throws|throws
name|Exception
block|{
name|super
operator|.
name|setup
argument_list|()
expr_stmt|;
name|invoker
operator|=
operator|new
name|Invoker
argument_list|(
operator|new
name|S3ARetryPolicy
argument_list|(
name|getConfiguration
argument_list|()
argument_list|)
argument_list|,
name|Invoker
operator|.
name|NO_OP
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|createContract (Configuration conf)
specifier|protected
name|AbstractFSContract
name|createContract
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
name|conf
operator|.
name|setClass
argument_list|(
name|S3_CLIENT_FACTORY_IMPL
argument_list|,
name|InconsistentS3ClientFactory
operator|.
name|class
argument_list|,
name|S3ClientFactory
operator|.
name|class
argument_list|)
expr_stmt|;
comment|// Other configs would break test assumptions
name|conf
operator|.
name|set
argument_list|(
name|FAIL_INJECT_INCONSISTENCY_KEY
argument_list|,
name|DEFAULT_DELAY_KEY_SUBSTRING
argument_list|)
expr_stmt|;
name|conf
operator|.
name|setFloat
argument_list|(
name|FAIL_INJECT_INCONSISTENCY_PROBABILITY
argument_list|,
literal|1.0f
argument_list|)
expr_stmt|;
comment|// this is a long value to guarantee that the inconsistency holds
comment|// even over long-haul connections, and in the debugger too/
name|conf
operator|.
name|setLong
argument_list|(
name|FAIL_INJECT_INCONSISTENCY_MSEC
argument_list|,
call|(
name|long
call|)
argument_list|(
literal|60
operator|*
literal|1000
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|new
name|S3AContract
argument_list|(
name|conf
argument_list|)
return|;
block|}
comment|/**    * Helper function for other test cases: does a single rename operation and    * validates the aftermath.    * @param mkdirs Directories to create    * @param srcdirs Source paths for rename operation    * @param dstdirs Destination paths for rename operation    * @param yesdirs Files that must exist post-rename (e.g. srcdirs children)    * @param nodirs Files that must not exist post-rename (e.g. dstdirs children)    * @throws Exception    */
DECL|method|doTestRenameSequence (Path[] mkdirs, Path[] srcdirs, Path[] dstdirs, Path[] yesdirs, Path[] nodirs)
specifier|private
name|void
name|doTestRenameSequence
parameter_list|(
name|Path
index|[]
name|mkdirs
parameter_list|,
name|Path
index|[]
name|srcdirs
parameter_list|,
name|Path
index|[]
name|dstdirs
parameter_list|,
name|Path
index|[]
name|yesdirs
parameter_list|,
name|Path
index|[]
name|nodirs
parameter_list|)
throws|throws
name|Exception
block|{
name|S3AFileSystem
name|fs
init|=
name|getFileSystem
argument_list|()
decl_stmt|;
name|Assume
operator|.
name|assumeTrue
argument_list|(
name|fs
operator|.
name|hasMetadataStore
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|mkdirs
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|Path
name|mkdir
range|:
name|mkdirs
control|)
block|{
name|assertTrue
argument_list|(
name|fs
operator|.
name|mkdirs
argument_list|(
name|mkdir
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|clearInconsistency
argument_list|(
name|fs
argument_list|)
expr_stmt|;
block|}
name|assertTrue
argument_list|(
literal|"srcdirs and dstdirs must have equal length"
argument_list|,
name|srcdirs
operator|.
name|length
operator|==
name|dstdirs
operator|.
name|length
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|srcdirs
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|assertTrue
argument_list|(
literal|"Rename returned false: "
operator|+
name|srcdirs
index|[
name|i
index|]
operator|+
literal|" -> "
operator|+
name|dstdirs
index|[
name|i
index|]
argument_list|,
name|fs
operator|.
name|rename
argument_list|(
name|srcdirs
index|[
name|i
index|]
argument_list|,
name|dstdirs
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Path
name|yesdir
range|:
name|yesdirs
control|)
block|{
name|assertTrue
argument_list|(
literal|"Path was supposed to exist: "
operator|+
name|yesdir
argument_list|,
name|fs
operator|.
name|exists
argument_list|(
name|yesdir
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Path
name|nodir
range|:
name|nodirs
control|)
block|{
name|assertFalse
argument_list|(
literal|"Path is not supposed to exist: "
operator|+
name|nodir
argument_list|,
name|fs
operator|.
name|exists
argument_list|(
name|nodir
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Tests that after renaming a directory, the original directory and its    * contents are indeed missing and the corresponding new paths are visible.    * @throws Exception    */
annotation|@
name|Test
DECL|method|testConsistentListAfterRename ()
specifier|public
name|void
name|testConsistentListAfterRename
parameter_list|()
throws|throws
name|Exception
block|{
name|Path
index|[]
name|mkdirs
init|=
block|{
name|path
argument_list|(
literal|"d1/f"
argument_list|)
block|,
name|path
argument_list|(
literal|"d1/f"
operator|+
name|DEFAULT_DELAY_KEY_SUBSTRING
argument_list|)
block|}
decl_stmt|;
name|Path
index|[]
name|srcdirs
init|=
block|{
name|path
argument_list|(
literal|"d1"
argument_list|)
block|}
decl_stmt|;
name|Path
index|[]
name|dstdirs
init|=
block|{
name|path
argument_list|(
literal|"d2"
argument_list|)
block|}
decl_stmt|;
name|Path
index|[]
name|yesdirs
init|=
block|{
name|path
argument_list|(
literal|"d2"
argument_list|)
block|,
name|path
argument_list|(
literal|"d2/f"
argument_list|)
block|,
name|path
argument_list|(
literal|"d2/f"
operator|+
name|DEFAULT_DELAY_KEY_SUBSTRING
argument_list|)
block|}
decl_stmt|;
name|Path
index|[]
name|nodirs
init|=
block|{
name|path
argument_list|(
literal|"d1"
argument_list|)
block|,
name|path
argument_list|(
literal|"d1/f"
argument_list|)
block|,
name|path
argument_list|(
literal|"d1/f"
operator|+
name|DEFAULT_DELAY_KEY_SUBSTRING
argument_list|)
block|}
decl_stmt|;
name|doTestRenameSequence
argument_list|(
name|mkdirs
argument_list|,
name|srcdirs
argument_list|,
name|dstdirs
argument_list|,
name|yesdirs
argument_list|,
name|nodirs
argument_list|)
expr_stmt|;
name|getFileSystem
argument_list|()
operator|.
name|delete
argument_list|(
name|path
argument_list|(
literal|"d1"
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|getFileSystem
argument_list|()
operator|.
name|delete
argument_list|(
name|path
argument_list|(
literal|"d2"
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**    * Tests a circular sequence of renames to verify that overwriting recently    * deleted files and reading recently created files from rename operations    * works as expected.    * @throws Exception    */
annotation|@
name|Test
DECL|method|testRollingRenames ()
specifier|public
name|void
name|testRollingRenames
parameter_list|()
throws|throws
name|Exception
block|{
name|Path
index|[]
name|dir0
init|=
block|{
name|path
argument_list|(
literal|"rolling/1"
argument_list|)
block|}
decl_stmt|;
name|Path
index|[]
name|dir1
init|=
block|{
name|path
argument_list|(
literal|"rolling/2"
argument_list|)
block|}
decl_stmt|;
name|Path
index|[]
name|dir2
init|=
block|{
name|path
argument_list|(
literal|"rolling/3"
argument_list|)
block|}
decl_stmt|;
comment|// These sets have to be in reverse order compared to the movement
name|Path
index|[]
name|setA
init|=
block|{
name|dir1
index|[
literal|0
index|]
block|,
name|dir0
index|[
literal|0
index|]
block|}
decl_stmt|;
name|Path
index|[]
name|setB
init|=
block|{
name|dir2
index|[
literal|0
index|]
block|,
name|dir1
index|[
literal|0
index|]
block|}
decl_stmt|;
name|Path
index|[]
name|setC
init|=
block|{
name|dir0
index|[
literal|0
index|]
block|,
name|dir2
index|[
literal|0
index|]
block|}
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|Path
index|[]
name|firstSet
init|=
name|i
operator|==
literal|0
condition|?
name|setA
else|:
literal|null
decl_stmt|;
name|doTestRenameSequence
argument_list|(
name|firstSet
argument_list|,
name|setA
argument_list|,
name|setB
argument_list|,
name|setB
argument_list|,
name|dir0
argument_list|)
expr_stmt|;
name|doTestRenameSequence
argument_list|(
literal|null
argument_list|,
name|setB
argument_list|,
name|setC
argument_list|,
name|setC
argument_list|,
name|dir1
argument_list|)
expr_stmt|;
name|doTestRenameSequence
argument_list|(
literal|null
argument_list|,
name|setC
argument_list|,
name|setA
argument_list|,
name|setA
argument_list|,
name|dir2
argument_list|)
expr_stmt|;
block|}
name|S3AFileSystem
name|fs
init|=
name|getFileSystem
argument_list|()
decl_stmt|;
name|assertFalse
argument_list|(
literal|"Renaming deleted file should have failed"
argument_list|,
name|fs
operator|.
name|rename
argument_list|(
name|dir2
index|[
literal|0
index|]
argument_list|,
name|dir1
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"Renaming over existing file should have succeeded"
argument_list|,
name|fs
operator|.
name|rename
argument_list|(
name|dir1
index|[
literal|0
index|]
argument_list|,
name|dir0
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Tests that deleted files immediately stop manifesting in list operations    * even when the effect in S3 is delayed.    * @throws Exception    */
annotation|@
name|Test
DECL|method|testConsistentListAfterDelete ()
specifier|public
name|void
name|testConsistentListAfterDelete
parameter_list|()
throws|throws
name|Exception
block|{
name|S3AFileSystem
name|fs
init|=
name|getFileSystem
argument_list|()
decl_stmt|;
comment|// test will fail if NullMetadataStore (the default) is configured: skip it.
name|Assume
operator|.
name|assumeTrue
argument_list|(
literal|"FS needs to have a metadatastore."
argument_list|,
name|fs
operator|.
name|hasMetadataStore
argument_list|()
argument_list|)
expr_stmt|;
comment|// Any S3 keys that contain DELAY_KEY_SUBSTRING will be delayed
comment|// in listObjects() results via InconsistentS3Client
name|Path
name|inconsistentPath
init|=
name|path
argument_list|(
literal|"a/b/dir3-"
operator|+
name|DEFAULT_DELAY_KEY_SUBSTRING
argument_list|)
decl_stmt|;
name|Path
index|[]
name|testDirs
init|=
block|{
name|path
argument_list|(
literal|"a/b/dir1"
argument_list|)
block|,
name|path
argument_list|(
literal|"a/b/dir2"
argument_list|)
block|,
name|inconsistentPath
block|}
decl_stmt|;
for|for
control|(
name|Path
name|path
range|:
name|testDirs
control|)
block|{
name|assertTrue
argument_list|(
literal|"Can't create directory: "
operator|+
name|path
argument_list|,
name|fs
operator|.
name|mkdirs
argument_list|(
name|path
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|clearInconsistency
argument_list|(
name|fs
argument_list|)
expr_stmt|;
for|for
control|(
name|Path
name|path
range|:
name|testDirs
control|)
block|{
name|assertTrue
argument_list|(
literal|"Can't delete path: "
operator|+
name|path
argument_list|,
name|fs
operator|.
name|delete
argument_list|(
name|path
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|FileStatus
index|[]
name|paths
init|=
name|fs
operator|.
name|listStatus
argument_list|(
name|path
argument_list|(
literal|"a/b/"
argument_list|)
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Path
argument_list|>
name|list
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|FileStatus
name|fileState
range|:
name|paths
control|)
block|{
name|list
operator|.
name|add
argument_list|(
name|fileState
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|assertFalse
argument_list|(
literal|"This path should be deleted."
argument_list|,
name|list
operator|.
name|contains
argument_list|(
name|path
argument_list|(
literal|"a/b/dir1"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
literal|"This path should be deleted."
argument_list|,
name|list
operator|.
name|contains
argument_list|(
name|path
argument_list|(
literal|"a/b/dir2"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
literal|"This should fail without S3Guard, and succeed with it."
argument_list|,
name|list
operator|.
name|contains
argument_list|(
name|inconsistentPath
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Tests that rename immediately after files in the source directory are    * deleted results in exactly the correct set of destination files and none    * of the source files.    * @throws Exception    */
annotation|@
name|Test
DECL|method|testConsistentRenameAfterDelete ()
specifier|public
name|void
name|testConsistentRenameAfterDelete
parameter_list|()
throws|throws
name|Exception
block|{
name|S3AFileSystem
name|fs
init|=
name|getFileSystem
argument_list|()
decl_stmt|;
comment|// test will fail if NullMetadataStore (the default) is configured: skip it.
name|Assume
operator|.
name|assumeTrue
argument_list|(
name|fs
operator|.
name|hasMetadataStore
argument_list|()
argument_list|)
expr_stmt|;
comment|// Any S3 keys that contain DELAY_KEY_SUBSTRING will be delayed
comment|// in listObjects() results via InconsistentS3Client
name|Path
name|inconsistentPath
init|=
name|path
argument_list|(
literal|"a/b/dir3-"
operator|+
name|DEFAULT_DELAY_KEY_SUBSTRING
argument_list|)
decl_stmt|;
name|Path
index|[]
name|testDirs
init|=
block|{
name|path
argument_list|(
literal|"a/b/dir1"
argument_list|)
block|,
name|path
argument_list|(
literal|"a/b/dir2"
argument_list|)
block|,
name|inconsistentPath
block|}
decl_stmt|;
for|for
control|(
name|Path
name|path
range|:
name|testDirs
control|)
block|{
name|assertTrue
argument_list|(
name|fs
operator|.
name|mkdirs
argument_list|(
name|path
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|clearInconsistency
argument_list|(
name|fs
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|fs
operator|.
name|delete
argument_list|(
name|testDirs
index|[
literal|1
index|]
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|fs
operator|.
name|delete
argument_list|(
name|testDirs
index|[
literal|2
index|]
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|fs
operator|.
name|rename
argument_list|(
name|path
argument_list|(
literal|"a"
argument_list|)
argument_list|,
name|path
argument_list|(
literal|"a3"
argument_list|)
argument_list|)
expr_stmt|;
name|FileStatus
index|[]
name|paths
init|=
name|fs
operator|.
name|listStatus
argument_list|(
name|path
argument_list|(
literal|"a3/b"
argument_list|)
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Path
argument_list|>
name|list
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|FileStatus
name|fileState
range|:
name|paths
control|)
block|{
name|list
operator|.
name|add
argument_list|(
name|fileState
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|assertTrue
argument_list|(
name|list
operator|.
name|contains
argument_list|(
name|path
argument_list|(
literal|"a3/b/dir1"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|list
operator|.
name|contains
argument_list|(
name|path
argument_list|(
literal|"a3/b/dir2"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// This should fail without S3Guard, and succeed with it.
name|assertFalse
argument_list|(
name|list
operator|.
name|contains
argument_list|(
name|path
argument_list|(
literal|"a3/b/dir3-"
operator|+
name|DEFAULT_DELAY_KEY_SUBSTRING
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
try|try
block|{
name|RemoteIterator
argument_list|<
name|LocatedFileStatus
argument_list|>
name|old
init|=
name|fs
operator|.
name|listFilesAndEmptyDirectories
argument_list|(
name|path
argument_list|(
literal|"a"
argument_list|)
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|fail
argument_list|(
literal|"Recently renamed dir should not be visible"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|e
parameter_list|)
block|{
comment|// expected
block|}
block|}
annotation|@
name|Test
DECL|method|testConsistentListStatusAfterPut ()
specifier|public
name|void
name|testConsistentListStatusAfterPut
parameter_list|()
throws|throws
name|Exception
block|{
name|S3AFileSystem
name|fs
init|=
name|getFileSystem
argument_list|()
decl_stmt|;
comment|// This test will fail if NullMetadataStore (the default) is configured:
comment|// skip it.
name|Assume
operator|.
name|assumeTrue
argument_list|(
name|fs
operator|.
name|hasMetadataStore
argument_list|()
argument_list|)
expr_stmt|;
comment|// Any S3 keys that contain DELAY_KEY_SUBSTRING will be delayed
comment|// in listObjects() results via InconsistentS3Client
name|Path
name|inconsistentPath
init|=
name|path
argument_list|(
literal|"a/b/dir3-"
operator|+
name|DEFAULT_DELAY_KEY_SUBSTRING
argument_list|)
decl_stmt|;
name|Path
index|[]
name|testDirs
init|=
block|{
name|path
argument_list|(
literal|"a/b/dir1"
argument_list|)
block|,
name|path
argument_list|(
literal|"a/b/dir2"
argument_list|)
block|,
name|inconsistentPath
block|}
decl_stmt|;
for|for
control|(
name|Path
name|path
range|:
name|testDirs
control|)
block|{
name|assertTrue
argument_list|(
name|fs
operator|.
name|mkdirs
argument_list|(
name|path
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|FileStatus
index|[]
name|paths
init|=
name|fs
operator|.
name|listStatus
argument_list|(
name|path
argument_list|(
literal|"a/b/"
argument_list|)
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Path
argument_list|>
name|list
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|FileStatus
name|fileState
range|:
name|paths
control|)
block|{
name|list
operator|.
name|add
argument_list|(
name|fileState
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|assertTrue
argument_list|(
name|list
operator|.
name|contains
argument_list|(
name|path
argument_list|(
literal|"a/b/dir1"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|list
operator|.
name|contains
argument_list|(
name|path
argument_list|(
literal|"a/b/dir2"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// This should fail without S3Guard, and succeed with it.
name|assertTrue
argument_list|(
name|list
operator|.
name|contains
argument_list|(
name|inconsistentPath
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Similar to {@link #testConsistentListStatusAfterPut()}, this tests that the    * FS listLocatedStatus() call will return consistent list.    */
annotation|@
name|Test
DECL|method|testConsistentListLocatedStatusAfterPut ()
specifier|public
name|void
name|testConsistentListLocatedStatusAfterPut
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|S3AFileSystem
name|fs
init|=
name|getFileSystem
argument_list|()
decl_stmt|;
comment|// This test will fail if NullMetadataStore (the default) is configured:
comment|// skip it.
name|Assume
operator|.
name|assumeTrue
argument_list|(
name|fs
operator|.
name|hasMetadataStore
argument_list|()
argument_list|)
expr_stmt|;
name|String
name|rootDir
init|=
literal|"doTestConsistentListLocatedStatusAfterPut"
decl_stmt|;
name|fs
operator|.
name|mkdirs
argument_list|(
name|path
argument_list|(
name|rootDir
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|int
index|[]
name|numOfPaths
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|5
block|}
decl_stmt|;
for|for
control|(
name|int
name|normalPathNum
range|:
name|numOfPaths
control|)
block|{
for|for
control|(
name|int
name|delayedPathNum
range|:
operator|new
name|int
index|[]
block|{
literal|0
block|,
literal|2
block|}
control|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Testing with normalPathNum={}, delayedPathNum={}"
argument_list|,
name|normalPathNum
argument_list|,
name|delayedPathNum
argument_list|)
expr_stmt|;
name|doTestConsistentListLocatedStatusAfterPut
argument_list|(
name|fs
argument_list|,
name|rootDir
argument_list|,
name|normalPathNum
argument_list|,
name|delayedPathNum
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Helper method to implement the tests of consistent listLocatedStatus().    * @param fs The S3 file system from contract    * @param normalPathNum number paths listed directly from S3 without delaying    * @param delayedPathNum number paths listed with delaying    * @throws Exception    */
DECL|method|doTestConsistentListLocatedStatusAfterPut (S3AFileSystem fs, String rootDir, int normalPathNum, int delayedPathNum)
specifier|private
name|void
name|doTestConsistentListLocatedStatusAfterPut
parameter_list|(
name|S3AFileSystem
name|fs
parameter_list|,
name|String
name|rootDir
parameter_list|,
name|int
name|normalPathNum
parameter_list|,
name|int
name|delayedPathNum
parameter_list|)
throws|throws
name|Exception
block|{
specifier|final
name|List
argument_list|<
name|Path
argument_list|>
name|testDirs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|normalPathNum
operator|+
name|delayedPathNum
argument_list|)
decl_stmt|;
name|int
name|index
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
name|index
operator|<
name|normalPathNum
condition|;
name|index
operator|++
control|)
block|{
name|testDirs
operator|.
name|add
argument_list|(
name|path
argument_list|(
name|rootDir
operator|+
literal|"/dir-"
operator|+
name|index
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
name|index
operator|<
name|normalPathNum
operator|+
name|delayedPathNum
condition|;
name|index
operator|++
control|)
block|{
comment|// Any S3 keys that contain DELAY_KEY_SUBSTRING will be delayed
comment|// in listObjects() results via InconsistentS3Client
name|testDirs
operator|.
name|add
argument_list|(
name|path
argument_list|(
name|rootDir
operator|+
literal|"/dir-"
operator|+
name|index
operator|+
name|DEFAULT_DELAY_KEY_SUBSTRING
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Path
name|path
range|:
name|testDirs
control|)
block|{
comment|// delete the old test path (if any) so that when we call mkdirs() later,
comment|// the to delay directories will be tracked via putObject() request.
name|fs
operator|.
name|delete
argument_list|(
name|path
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|fs
operator|.
name|mkdirs
argument_list|(
name|path
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// this should return the union data from S3 and MetadataStore
specifier|final
name|RemoteIterator
argument_list|<
name|LocatedFileStatus
argument_list|>
name|statusIterator
init|=
name|fs
operator|.
name|listLocatedStatus
argument_list|(
name|path
argument_list|(
name|rootDir
operator|+
literal|"/"
argument_list|)
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Path
argument_list|>
name|list
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
init|;
name|statusIterator
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|list
operator|.
name|add
argument_list|(
name|statusIterator
operator|.
name|next
argument_list|()
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// This should fail without S3Guard, and succeed with it because part of the
comment|// children under test path are delaying visibility
for|for
control|(
name|Path
name|path
range|:
name|testDirs
control|)
block|{
name|assertTrue
argument_list|(
literal|"listLocatedStatus should list "
operator|+
name|path
argument_list|,
name|list
operator|.
name|contains
argument_list|(
name|path
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Tests that the S3AFS listFiles() call will return consistent file list.    */
annotation|@
name|Test
DECL|method|testConsistentListFiles ()
specifier|public
name|void
name|testConsistentListFiles
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|S3AFileSystem
name|fs
init|=
name|getFileSystem
argument_list|()
decl_stmt|;
comment|// This test will fail if NullMetadataStore (the default) is configured:
comment|// skip it.
name|Assume
operator|.
name|assumeTrue
argument_list|(
name|fs
operator|.
name|hasMetadataStore
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|int
index|[]
name|numOfPaths
init|=
block|{
literal|0
block|,
literal|2
block|}
decl_stmt|;
for|for
control|(
name|int
name|dirNum
range|:
name|numOfPaths
control|)
block|{
for|for
control|(
name|int
name|normalFile
range|:
name|numOfPaths
control|)
block|{
for|for
control|(
name|int
name|delayedFile
range|:
operator|new
name|int
index|[]
block|{
literal|0
block|,
literal|1
block|}
control|)
block|{
for|for
control|(
name|boolean
name|recursive
range|:
operator|new
name|boolean
index|[]
block|{
literal|true
block|,
literal|false
block|}
control|)
block|{
name|doTestListFiles
argument_list|(
name|fs
argument_list|,
name|dirNum
argument_list|,
name|normalFile
argument_list|,
name|delayedFile
argument_list|,
name|recursive
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
comment|/**    * Helper method to implement the tests of consistent listFiles().    *    * The file structure has dirNum subdirectories, and each directory (including    * the test base directory itself) has normalFileNum normal files and    * delayedFileNum delayed files.    *    * @param fs The S3 file system from contract    * @param dirNum number of subdirectories    * @param normalFileNum number files in each directory without delay to list    * @param delayedFileNum number files in each directory with delay to list    * @param recursive listFiles recursively if true    * @throws Exception if any unexpected error    */
DECL|method|doTestListFiles (S3AFileSystem fs, int dirNum, int normalFileNum, int delayedFileNum, boolean recursive)
specifier|private
name|void
name|doTestListFiles
parameter_list|(
name|S3AFileSystem
name|fs
parameter_list|,
name|int
name|dirNum
parameter_list|,
name|int
name|normalFileNum
parameter_list|,
name|int
name|delayedFileNum
parameter_list|,
name|boolean
name|recursive
parameter_list|)
throws|throws
name|Exception
block|{
name|describe
argument_list|(
literal|"Testing dirNum=%d, normalFile=%d, delayedFile=%d, "
operator|+
literal|"recursive=%s"
argument_list|,
name|dirNum
argument_list|,
name|normalFileNum
argument_list|,
name|delayedFileNum
argument_list|,
name|recursive
argument_list|)
expr_stmt|;
specifier|final
name|Path
name|baseTestDir
init|=
name|path
argument_list|(
literal|"doTestListFiles-"
operator|+
name|dirNum
operator|+
literal|"-"
operator|+
name|normalFileNum
operator|+
literal|"-"
operator|+
name|delayedFileNum
operator|+
literal|"-"
operator|+
name|recursive
argument_list|)
decl_stmt|;
comment|// delete the old test path (if any) so that when we call mkdirs() later,
comment|// the to delay sub directories will be tracked via putObject() request.
name|fs
operator|.
name|delete
argument_list|(
name|baseTestDir
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|// make subdirectories (if any)
specifier|final
name|List
argument_list|<
name|Path
argument_list|>
name|testDirs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|dirNum
operator|+
literal|1
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|fs
operator|.
name|mkdirs
argument_list|(
name|baseTestDir
argument_list|)
argument_list|)
expr_stmt|;
name|testDirs
operator|.
name|add
argument_list|(
name|baseTestDir
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|dirNum
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|Path
name|subdir
init|=
name|path
argument_list|(
name|baseTestDir
operator|+
literal|"/dir-"
operator|+
name|i
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|fs
operator|.
name|mkdirs
argument_list|(
name|subdir
argument_list|)
argument_list|)
expr_stmt|;
name|testDirs
operator|.
name|add
argument_list|(
name|subdir
argument_list|)
expr_stmt|;
block|}
specifier|final
name|Collection
argument_list|<
name|String
argument_list|>
name|fileNames
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|normalFileNum
operator|+
name|delayedFileNum
argument_list|)
decl_stmt|;
name|int
name|index
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
name|index
operator|<
name|normalFileNum
condition|;
name|index
operator|++
control|)
block|{
name|fileNames
operator|.
name|add
argument_list|(
literal|"file-"
operator|+
name|index
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
name|index
operator|<
name|normalFileNum
operator|+
name|delayedFileNum
condition|;
name|index
operator|++
control|)
block|{
comment|// Any S3 keys that contain DELAY_KEY_SUBSTRING will be delayed
comment|// in listObjects() results via InconsistentS3Client
name|fileNames
operator|.
name|add
argument_list|(
literal|"file-"
operator|+
name|index
operator|+
literal|"-"
operator|+
name|DEFAULT_DELAY_KEY_SUBSTRING
argument_list|)
expr_stmt|;
block|}
name|int
name|filesAndEmptyDirectories
init|=
literal|0
decl_stmt|;
comment|// create files under each test directory
for|for
control|(
name|Path
name|dir
range|:
name|testDirs
control|)
block|{
for|for
control|(
name|String
name|fileName
range|:
name|fileNames
control|)
block|{
name|writeTextFile
argument_list|(
name|fs
argument_list|,
operator|new
name|Path
argument_list|(
name|dir
argument_list|,
name|fileName
argument_list|)
argument_list|,
literal|"I, "
operator|+
name|fileName
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|filesAndEmptyDirectories
operator|++
expr_stmt|;
block|}
block|}
comment|// this should return the union data from S3 and MetadataStore
specifier|final
name|RemoteIterator
argument_list|<
name|LocatedFileStatus
argument_list|>
name|statusIterator
init|=
name|fs
operator|.
name|listFiles
argument_list|(
name|baseTestDir
argument_list|,
name|recursive
argument_list|)
decl_stmt|;
specifier|final
name|Collection
argument_list|<
name|Path
argument_list|>
name|listedFiles
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
init|;
name|statusIterator
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
specifier|final
name|FileStatus
name|status
init|=
name|statusIterator
operator|.
name|next
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
literal|"FileStatus "
operator|+
name|status
operator|+
literal|" is not a file!"
argument_list|,
name|status
operator|.
name|isFile
argument_list|()
argument_list|)
expr_stmt|;
name|listedFiles
operator|.
name|add
argument_list|(
name|status
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"S3AFileSystem::listFiles('{}', {}) -> {}"
argument_list|,
name|baseTestDir
argument_list|,
name|recursive
argument_list|,
name|listedFiles
argument_list|)
expr_stmt|;
comment|// This should fail without S3Guard, and succeed with it because part of the
comment|// files to list are delaying visibility
if|if
condition|(
operator|!
name|recursive
condition|)
block|{
comment|// in this case only the top level files are listed
name|verifyFileIsListed
argument_list|(
name|listedFiles
argument_list|,
name|baseTestDir
argument_list|,
name|fileNames
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Unexpected number of files returned by listFiles() call"
argument_list|,
name|normalFileNum
operator|+
name|delayedFileNum
argument_list|,
name|listedFiles
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|Path
name|dir
range|:
name|testDirs
control|)
block|{
name|verifyFileIsListed
argument_list|(
name|listedFiles
argument_list|,
name|dir
argument_list|,
name|fileNames
argument_list|)
expr_stmt|;
block|}
name|assertEquals
argument_list|(
literal|"Unexpected number of files returned by listFiles() call"
argument_list|,
name|filesAndEmptyDirectories
argument_list|,
name|listedFiles
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|verifyFileIsListed (Collection<Path> listedFiles, Path currentDir, Collection<String> fileNames)
specifier|private
specifier|static
name|void
name|verifyFileIsListed
parameter_list|(
name|Collection
argument_list|<
name|Path
argument_list|>
name|listedFiles
parameter_list|,
name|Path
name|currentDir
parameter_list|,
name|Collection
argument_list|<
name|String
argument_list|>
name|fileNames
parameter_list|)
block|{
for|for
control|(
name|String
name|fileName
range|:
name|fileNames
control|)
block|{
specifier|final
name|Path
name|file
init|=
operator|new
name|Path
argument_list|(
name|currentDir
argument_list|,
name|fileName
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|file
operator|+
literal|" should have been listed"
argument_list|,
name|listedFiles
operator|.
name|contains
argument_list|(
name|file
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Test
DECL|method|testCommitByRenameOperations ()
specifier|public
name|void
name|testCommitByRenameOperations
parameter_list|()
throws|throws
name|Throwable
block|{
name|S3AFileSystem
name|fs
init|=
name|getFileSystem
argument_list|()
decl_stmt|;
name|Assume
operator|.
name|assumeTrue
argument_list|(
name|fs
operator|.
name|hasMetadataStore
argument_list|()
argument_list|)
expr_stmt|;
name|Path
name|work
init|=
name|path
argument_list|(
literal|"test-commit-by-rename-"
operator|+
name|DEFAULT_DELAY_KEY_SUBSTRING
argument_list|)
decl_stmt|;
name|Path
name|task00
init|=
operator|new
name|Path
argument_list|(
name|work
argument_list|,
literal|"task00"
argument_list|)
decl_stmt|;
name|fs
operator|.
name|mkdirs
argument_list|(
name|task00
argument_list|)
expr_stmt|;
name|String
name|name
init|=
literal|"part-00"
decl_stmt|;
try|try
init|(
name|FSDataOutputStream
name|out
init|=
name|fs
operator|.
name|create
argument_list|(
operator|new
name|Path
argument_list|(
name|task00
argument_list|,
name|name
argument_list|)
argument_list|,
literal|false
argument_list|)
init|)
block|{
name|out
operator|.
name|writeChars
argument_list|(
literal|"hello"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|FileStatus
name|stat
range|:
name|fs
operator|.
name|listStatus
argument_list|(
name|task00
argument_list|)
control|)
block|{
name|fs
operator|.
name|rename
argument_list|(
name|stat
operator|.
name|getPath
argument_list|()
argument_list|,
name|work
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|FileStatus
argument_list|>
name|files
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
literal|2
argument_list|)
decl_stmt|;
for|for
control|(
name|FileStatus
name|stat
range|:
name|fs
operator|.
name|listStatus
argument_list|(
name|work
argument_list|)
control|)
block|{
if|if
condition|(
name|stat
operator|.
name|isFile
argument_list|()
condition|)
block|{
name|files
operator|.
name|add
argument_list|(
name|stat
argument_list|)
expr_stmt|;
block|}
block|}
name|assertFalse
argument_list|(
literal|"renamed file "
operator|+
name|name
operator|+
literal|" not found in "
operator|+
name|work
argument_list|,
name|files
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"more files found than expected in "
operator|+
name|work
operator|+
literal|" "
operator|+
name|ls
argument_list|(
name|work
argument_list|)
argument_list|,
literal|1
argument_list|,
name|files
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|FileStatus
name|status
init|=
name|files
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|"Wrong filename in "
operator|+
name|status
argument_list|,
name|name
argument_list|,
name|status
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testInconsistentS3ClientDeletes ()
specifier|public
name|void
name|testInconsistentS3ClientDeletes
parameter_list|()
throws|throws
name|Throwable
block|{
comment|// Test only implemented for v2 S3 list API
name|Assume
operator|.
name|assumeTrue
argument_list|(
name|getConfiguration
argument_list|()
operator|.
name|getInt
argument_list|(
name|LIST_VERSION
argument_list|,
name|DEFAULT_LIST_VERSION
argument_list|)
operator|==
literal|2
argument_list|)
expr_stmt|;
name|S3AFileSystem
name|fs
init|=
name|getFileSystem
argument_list|()
decl_stmt|;
name|Path
name|root
init|=
name|path
argument_list|(
literal|"testInconsistentClient"
operator|+
name|DEFAULT_DELAY_KEY_SUBSTRING
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
block|{
name|fs
operator|.
name|mkdirs
argument_list|(
operator|new
name|Path
argument_list|(
name|root
argument_list|,
literal|"dir"
operator|+
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|touch
argument_list|(
name|fs
argument_list|,
operator|new
name|Path
argument_list|(
name|root
argument_list|,
literal|"file"
operator|+
name|i
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
literal|3
condition|;
name|j
operator|++
control|)
block|{
name|touch
argument_list|(
name|fs
argument_list|,
operator|new
name|Path
argument_list|(
operator|new
name|Path
argument_list|(
name|root
argument_list|,
literal|"dir"
operator|+
name|i
argument_list|)
argument_list|,
literal|"file"
operator|+
name|i
operator|+
literal|"-"
operator|+
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|clearInconsistency
argument_list|(
name|fs
argument_list|)
expr_stmt|;
name|String
name|key
init|=
name|fs
operator|.
name|pathToKey
argument_list|(
name|root
argument_list|)
operator|+
literal|"/"
decl_stmt|;
name|ListObjectsV2Result
name|preDeleteDelimited
init|=
name|listObjectsV2
argument_list|(
name|fs
argument_list|,
name|key
argument_list|,
literal|"/"
argument_list|)
decl_stmt|;
name|ListObjectsV2Result
name|preDeleteUndelimited
init|=
name|listObjectsV2
argument_list|(
name|fs
argument_list|,
name|key
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|fs
operator|.
name|delete
argument_list|(
name|root
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|ListObjectsV2Result
name|postDeleteDelimited
init|=
name|listObjectsV2
argument_list|(
name|fs
argument_list|,
name|key
argument_list|,
literal|"/"
argument_list|)
decl_stmt|;
name|ListObjectsV2Result
name|postDeleteUndelimited
init|=
name|listObjectsV2
argument_list|(
name|fs
argument_list|,
name|key
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|assertListSizeEqual
argument_list|(
literal|"InconsistentAmazonS3Client added back objects incorrectly "
operator|+
literal|"in a non-recursive listing"
argument_list|,
name|preDeleteDelimited
operator|.
name|getObjectSummaries
argument_list|()
argument_list|,
name|postDeleteDelimited
operator|.
name|getObjectSummaries
argument_list|()
argument_list|)
expr_stmt|;
name|assertListSizeEqual
argument_list|(
literal|"InconsistentAmazonS3Client added back prefixes incorrectly "
operator|+
literal|"in a non-recursive listing"
argument_list|,
name|preDeleteDelimited
operator|.
name|getCommonPrefixes
argument_list|()
argument_list|,
name|postDeleteDelimited
operator|.
name|getCommonPrefixes
argument_list|()
argument_list|)
expr_stmt|;
name|assertListSizeEqual
argument_list|(
literal|"InconsistentAmazonS3Client added back objects incorrectly "
operator|+
literal|"in a recursive listing"
argument_list|,
name|preDeleteUndelimited
operator|.
name|getObjectSummaries
argument_list|()
argument_list|,
name|postDeleteUndelimited
operator|.
name|getObjectSummaries
argument_list|()
argument_list|)
expr_stmt|;
name|assertListSizeEqual
argument_list|(
literal|"InconsistentAmazonS3Client added back prefixes incorrectly "
operator|+
literal|"in a recursive listing"
argument_list|,
name|preDeleteUndelimited
operator|.
name|getCommonPrefixes
argument_list|()
argument_list|,
name|postDeleteUndelimited
operator|.
name|getCommonPrefixes
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Assert that the two list sizes match; failure message includes the lists.    * @param message text for the assertion    * @param expected expected list    * @param actual actual list    * @param<T> type of list    */
DECL|method|assertListSizeEqual (String message, List<T> expected, List<T> actual)
specifier|private
parameter_list|<
name|T
parameter_list|>
name|void
name|assertListSizeEqual
parameter_list|(
name|String
name|message
parameter_list|,
name|List
argument_list|<
name|T
argument_list|>
name|expected
parameter_list|,
name|List
argument_list|<
name|T
argument_list|>
name|actual
parameter_list|)
block|{
name|String
name|leftContents
init|=
name|expected
operator|.
name|stream
argument_list|()
operator|.
name|map
argument_list|(
name|n
lambda|->
name|n
operator|.
name|toString
argument_list|()
argument_list|)
operator|.
name|collect
argument_list|(
name|Collectors
operator|.
name|joining
argument_list|(
literal|"\n"
argument_list|)
argument_list|)
decl_stmt|;
name|String
name|rightContents
init|=
name|actual
operator|.
name|stream
argument_list|()
operator|.
name|map
argument_list|(
name|n
lambda|->
name|n
operator|.
name|toString
argument_list|()
argument_list|)
operator|.
name|collect
argument_list|(
name|Collectors
operator|.
name|joining
argument_list|(
literal|"\n"
argument_list|)
argument_list|)
decl_stmt|;
name|String
name|summary
init|=
literal|"\nExpected:"
operator|+
name|leftContents
operator|+
literal|"\n-----------\nActual:"
operator|+
name|rightContents
decl_stmt|;
name|assertEquals
argument_list|(
name|message
operator|+
name|summary
argument_list|,
name|expected
operator|.
name|size
argument_list|()
argument_list|,
name|actual
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Retrying v2 list directly through the s3 client.    * @param fs filesystem    * @param key key to list under    * @param delimiter any delimiter    * @return the listing    * @throws IOException on error    */
annotation|@
name|Retries
operator|.
name|RetryRaw
DECL|method|listObjectsV2 (S3AFileSystem fs, String key, String delimiter)
specifier|private
name|ListObjectsV2Result
name|listObjectsV2
parameter_list|(
name|S3AFileSystem
name|fs
parameter_list|,
name|String
name|key
parameter_list|,
name|String
name|delimiter
parameter_list|)
throws|throws
name|IOException
block|{
name|ListObjectsV2Request
name|k
init|=
name|fs
operator|.
name|createListObjectsRequest
argument_list|(
name|key
argument_list|,
name|delimiter
argument_list|)
operator|.
name|getV2
argument_list|()
decl_stmt|;
return|return
name|invoker
operator|.
name|retryUntranslated
argument_list|(
literal|"list"
argument_list|,
literal|true
argument_list|,
parameter_list|()
lambda|->
block|{
return|return
name|fs
operator|.
name|getAmazonS3ClientForTesting
argument_list|(
literal|"list"
argument_list|)
operator|.
name|listObjectsV2
argument_list|(
name|k
argument_list|)
return|;
block|}
argument_list|)
return|;
block|}
block|}
end_class

end_unit

