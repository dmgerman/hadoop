begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.fs.s3a.commit.terasort
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|commit
operator|.
name|terasort
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Optional
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|BiConsumer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|FixMethodOrder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Test
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|runners
operator|.
name|MethodSorters
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|examples
operator|.
name|terasort
operator|.
name|TeraGen
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|examples
operator|.
name|terasort
operator|.
name|TeraSort
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|examples
operator|.
name|terasort
operator|.
name|TeraSortConfigKeys
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|examples
operator|.
name|terasort
operator|.
name|TeraValidate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|contract
operator|.
name|ContractTestUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|commit
operator|.
name|AbstractYarnClusterITest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|JobConf
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|DurationInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Tool
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|ToolRunner
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|util
operator|.
name|Optional
operator|.
name|empty
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|commit
operator|.
name|CommitConstants
operator|.
name|CONFLICT_MODE_APPEND
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|commit
operator|.
name|CommitConstants
operator|.
name|FS_S3A_COMMITTER_STAGING_CONFLICT_MODE
import|;
end_import

begin_comment
comment|/**  * Runs Terasort against S3A.  *  * This is all done on a shared mini YARN and HDFS clusters, set up before  * any of the tests methods run.  *  * The tests run in sequence, so each operation is isolated.  * This also means that the test paths deleted in test  * teardown; shared variables must all be static.  */
end_comment

begin_class
annotation|@
name|FixMethodOrder
argument_list|(
name|MethodSorters
operator|.
name|NAME_ASCENDING
argument_list|)
annotation|@
name|SuppressWarnings
argument_list|(
literal|"StaticNonFinalField"
argument_list|)
DECL|class|AbstractCommitTerasortIT
specifier|public
specifier|abstract
class|class
name|AbstractCommitTerasortIT
extends|extends
name|AbstractYarnClusterITest
block|{
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|AbstractCommitTerasortIT
operator|.
name|class
argument_list|)
decl_stmt|;
comment|// all the durations are optional as they only get filled in when
comment|// a test run successfully completes. Failed tests don't have numbers.
DECL|field|terasortDuration
specifier|private
specifier|static
name|Optional
argument_list|<
name|DurationInfo
argument_list|>
name|terasortDuration
init|=
name|empty
argument_list|()
decl_stmt|;
DECL|field|teragenStageDuration
specifier|private
specifier|static
name|Optional
argument_list|<
name|DurationInfo
argument_list|>
name|teragenStageDuration
init|=
name|empty
argument_list|()
decl_stmt|;
DECL|field|terasortStageDuration
specifier|private
specifier|static
name|Optional
argument_list|<
name|DurationInfo
argument_list|>
name|terasortStageDuration
init|=
name|empty
argument_list|()
decl_stmt|;
DECL|field|teravalidateStageDuration
specifier|private
specifier|static
name|Optional
argument_list|<
name|DurationInfo
argument_list|>
name|teravalidateStageDuration
init|=
name|empty
argument_list|()
decl_stmt|;
DECL|field|terasortPath
specifier|private
name|Path
name|terasortPath
decl_stmt|;
DECL|field|sortInput
specifier|private
name|Path
name|sortInput
decl_stmt|;
DECL|field|sortOutput
specifier|private
name|Path
name|sortOutput
decl_stmt|;
DECL|field|sortValidate
specifier|private
name|Path
name|sortValidate
decl_stmt|;
comment|/**    * Not using special paths here.    * @return false    */
annotation|@
name|Override
DECL|method|useInconsistentClient ()
specifier|public
name|boolean
name|useInconsistentClient
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
annotation|@
name|Override
DECL|method|setup ()
specifier|public
name|void
name|setup
parameter_list|()
throws|throws
name|Exception
block|{
name|super
operator|.
name|setup
argument_list|()
expr_stmt|;
name|requireScaleTestsEnabled
argument_list|()
expr_stmt|;
name|prepareToTerasort
argument_list|()
expr_stmt|;
block|}
comment|/**    * Set up for terasorting by initializing paths.    * The paths used must be unique across parallel runs.    */
DECL|method|prepareToTerasort ()
specifier|private
name|void
name|prepareToTerasort
parameter_list|()
block|{
comment|// small sample size for faster runs
name|Configuration
name|yarnConfig
init|=
name|getYarn
argument_list|()
operator|.
name|getConfig
argument_list|()
decl_stmt|;
name|yarnConfig
operator|.
name|setInt
argument_list|(
name|TeraSortConfigKeys
operator|.
name|SAMPLE_SIZE
operator|.
name|key
argument_list|()
argument_list|,
literal|1000
argument_list|)
expr_stmt|;
name|yarnConfig
operator|.
name|setBoolean
argument_list|(
name|TeraSortConfigKeys
operator|.
name|USE_SIMPLE_PARTITIONER
operator|.
name|key
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|terasortPath
operator|=
operator|new
name|Path
argument_list|(
literal|"/terasort-"
operator|+
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
argument_list|)
operator|.
name|makeQualified
argument_list|(
name|getFileSystem
argument_list|()
argument_list|)
expr_stmt|;
name|sortInput
operator|=
operator|new
name|Path
argument_list|(
name|terasortPath
argument_list|,
literal|"sortin"
argument_list|)
expr_stmt|;
name|sortOutput
operator|=
operator|new
name|Path
argument_list|(
name|terasortPath
argument_list|,
literal|"sortout"
argument_list|)
expr_stmt|;
name|sortValidate
operator|=
operator|new
name|Path
argument_list|(
name|terasortPath
argument_list|,
literal|"validate"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|terasortDuration
operator|.
name|isPresent
argument_list|()
condition|)
block|{
name|terasortDuration
operator|=
name|Optional
operator|.
name|of
argument_list|(
operator|new
name|DurationInfo
argument_list|(
name|LOG
argument_list|,
literal|"Terasort"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Execute a single stage in the terasort,    * @param stage Stage name for messages/assertions.    * @param jobConf job conf    * @param dest destination directory -the _SUCCESS File will be expected here.    * @param tool tool to run.    * @param args args for the tool.    * @throws Exception any failure    */
DECL|method|executeStage ( final String stage, final JobConf jobConf, final Path dest, final Tool tool, final String[] args)
specifier|private
name|Optional
argument_list|<
name|DurationInfo
argument_list|>
name|executeStage
parameter_list|(
specifier|final
name|String
name|stage
parameter_list|,
specifier|final
name|JobConf
name|jobConf
parameter_list|,
specifier|final
name|Path
name|dest
parameter_list|,
specifier|final
name|Tool
name|tool
parameter_list|,
specifier|final
name|String
index|[]
name|args
parameter_list|)
throws|throws
name|Exception
block|{
name|int
name|result
decl_stmt|;
name|DurationInfo
name|d
init|=
operator|new
name|DurationInfo
argument_list|(
name|LOG
argument_list|,
name|stage
argument_list|)
decl_stmt|;
try|try
block|{
name|result
operator|=
name|ToolRunner
operator|.
name|run
argument_list|(
name|jobConf
argument_list|,
name|tool
argument_list|,
name|args
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|d
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
name|assertEquals
argument_list|(
name|stage
operator|+
literal|"("
operator|+
name|StringUtils
operator|.
name|join
argument_list|(
literal|", "
argument_list|,
name|args
argument_list|)
operator|+
literal|")"
operator|+
literal|" failed"
argument_list|,
literal|0
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|validateSuccessFile
argument_list|(
name|getFileSystem
argument_list|()
argument_list|,
name|dest
argument_list|,
name|committerName
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|Optional
operator|.
name|of
argument_list|(
name|d
argument_list|)
return|;
block|}
comment|/**    * Set up terasort by cleaning out the destination, and note the initial    * time before any of the jobs are executed.    */
annotation|@
name|Test
DECL|method|test_100_terasort_setup ()
specifier|public
name|void
name|test_100_terasort_setup
parameter_list|()
throws|throws
name|Throwable
block|{
name|describe
argument_list|(
literal|"Setting up for a terasort"
argument_list|)
expr_stmt|;
name|getFileSystem
argument_list|()
operator|.
name|delete
argument_list|(
name|terasortPath
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|test_110_teragen ()
specifier|public
name|void
name|test_110_teragen
parameter_list|()
throws|throws
name|Throwable
block|{
name|describe
argument_list|(
literal|"Teragen to %s"
argument_list|,
name|sortInput
argument_list|)
expr_stmt|;
name|JobConf
name|jobConf
init|=
name|newJobConf
argument_list|()
decl_stmt|;
name|patchConfigurationForCommitter
argument_list|(
name|jobConf
argument_list|)
expr_stmt|;
name|teragenStageDuration
operator|=
name|executeStage
argument_list|(
literal|"Teragen"
argument_list|,
name|jobConf
argument_list|,
name|sortInput
argument_list|,
operator|new
name|TeraGen
argument_list|()
argument_list|,
operator|new
name|String
index|[]
block|{
name|Integer
operator|.
name|toString
argument_list|(
name|SCALE_TEST_KEYS
argument_list|)
block|,
name|sortInput
operator|.
name|toString
argument_list|()
block|}
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|test_120_terasort ()
specifier|public
name|void
name|test_120_terasort
parameter_list|()
throws|throws
name|Throwable
block|{
name|describe
argument_list|(
literal|"Terasort from %s to %s"
argument_list|,
name|sortInput
argument_list|,
name|sortOutput
argument_list|)
expr_stmt|;
name|loadSuccessFile
argument_list|(
name|getFileSystem
argument_list|()
argument_list|,
name|sortInput
argument_list|)
expr_stmt|;
name|JobConf
name|jobConf
init|=
name|newJobConf
argument_list|()
decl_stmt|;
name|patchConfigurationForCommitter
argument_list|(
name|jobConf
argument_list|)
expr_stmt|;
comment|// this job adds some data, so skip it.
name|jobConf
operator|.
name|set
argument_list|(
name|FS_S3A_COMMITTER_STAGING_CONFLICT_MODE
argument_list|,
name|CONFLICT_MODE_APPEND
argument_list|)
expr_stmt|;
name|terasortStageDuration
operator|=
name|executeStage
argument_list|(
literal|"TeraSort"
argument_list|,
name|jobConf
argument_list|,
name|sortOutput
argument_list|,
operator|new
name|TeraSort
argument_list|()
argument_list|,
operator|new
name|String
index|[]
block|{
name|sortInput
operator|.
name|toString
argument_list|()
block|,
name|sortOutput
operator|.
name|toString
argument_list|()
block|}
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|test_130_teravalidate ()
specifier|public
name|void
name|test_130_teravalidate
parameter_list|()
throws|throws
name|Throwable
block|{
name|describe
argument_list|(
literal|"TeraValidate from %s to %s"
argument_list|,
name|sortOutput
argument_list|,
name|sortValidate
argument_list|)
expr_stmt|;
name|loadSuccessFile
argument_list|(
name|getFileSystem
argument_list|()
argument_list|,
name|sortOutput
argument_list|)
expr_stmt|;
name|JobConf
name|jobConf
init|=
name|newJobConf
argument_list|()
decl_stmt|;
name|patchConfigurationForCommitter
argument_list|(
name|jobConf
argument_list|)
expr_stmt|;
name|teravalidateStageDuration
operator|=
name|executeStage
argument_list|(
literal|"TeraValidate"
argument_list|,
name|jobConf
argument_list|,
name|sortValidate
argument_list|,
operator|new
name|TeraValidate
argument_list|()
argument_list|,
operator|new
name|String
index|[]
block|{
name|sortOutput
operator|.
name|toString
argument_list|()
block|,
name|sortValidate
operator|.
name|toString
argument_list|()
block|}
argument_list|)
expr_stmt|;
block|}
comment|/**    * Print the results, and save to the base dir as a CSV file.    * Why there? Makes it easy to list and compare.    */
annotation|@
name|Test
DECL|method|test_140_teracomplete ()
specifier|public
name|void
name|test_140_teracomplete
parameter_list|()
throws|throws
name|Throwable
block|{
name|terasortDuration
operator|.
name|get
argument_list|()
operator|.
name|close
argument_list|()
expr_stmt|;
specifier|final
name|StringBuilder
name|results
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|results
operator|.
name|append
argument_list|(
literal|"\"Operation\"\t\"Duration\"\n"
argument_list|)
expr_stmt|;
comment|// this is how you dynamically create a function in a method
comment|// for use afterwards.
comment|// Works because there's no IOEs being raised in this sequence.
name|BiConsumer
argument_list|<
name|String
argument_list|,
name|Optional
argument_list|<
name|DurationInfo
argument_list|>
argument_list|>
name|stage
init|=
parameter_list|(
name|s
parameter_list|,
name|od
parameter_list|)
lambda|->
name|results
operator|.
name|append
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"\"%s\"\t\"%s\"\n"
argument_list|,
name|s
argument_list|,
name|od
operator|.
name|map
argument_list|(
name|DurationInfo
operator|::
name|getDurationString
argument_list|)
operator|.
name|orElse
argument_list|(
literal|""
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|stage
operator|.
name|accept
argument_list|(
literal|"Generate"
argument_list|,
name|teragenStageDuration
argument_list|)
expr_stmt|;
name|stage
operator|.
name|accept
argument_list|(
literal|"Terasort"
argument_list|,
name|terasortStageDuration
argument_list|)
expr_stmt|;
name|stage
operator|.
name|accept
argument_list|(
literal|"Validate"
argument_list|,
name|teravalidateStageDuration
argument_list|)
expr_stmt|;
name|stage
operator|.
name|accept
argument_list|(
literal|"Completed"
argument_list|,
name|terasortDuration
argument_list|)
expr_stmt|;
name|String
name|text
init|=
name|results
operator|.
name|toString
argument_list|()
decl_stmt|;
name|Path
name|path
init|=
operator|new
name|Path
argument_list|(
name|terasortPath
argument_list|,
literal|"results.csv"
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Results are in {}\n{}"
argument_list|,
name|path
argument_list|,
name|text
argument_list|)
expr_stmt|;
name|ContractTestUtils
operator|.
name|writeTextFile
argument_list|(
name|getFileSystem
argument_list|()
argument_list|,
name|path
argument_list|,
name|text
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**    * Reset the duration so if two committer tests are run sequentially.    * Without this the total execution time is reported as from the start of    * the first test suite to the end of the second.    */
annotation|@
name|Test
DECL|method|test_150_teracleanup ()
specifier|public
name|void
name|test_150_teracleanup
parameter_list|()
throws|throws
name|Throwable
block|{
name|terasortDuration
operator|=
name|Optional
operator|.
name|empty
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|test_200_directory_deletion ()
specifier|public
name|void
name|test_200_directory_deletion
parameter_list|()
throws|throws
name|Throwable
block|{
name|getFileSystem
argument_list|()
operator|.
name|delete
argument_list|(
name|terasortPath
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
end_class

end_unit

