begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.fs.s3a.commit
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|commit
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|UUID
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|CommonConfigurationKeys
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|commit
operator|.
name|files
operator|.
name|SuccessData
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|JobConf
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|Job
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|v2
operator|.
name|MiniMRYarnCluster
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|v2
operator|.
name|jobhistory
operator|.
name|JHAdminConfig
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkNotNull
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|S3ATestUtils
operator|.
name|assume
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|S3ATestUtils
operator|.
name|deployService
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|S3ATestUtils
operator|.
name|getTestPropertyBool
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|S3ATestUtils
operator|.
name|terminateService
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|commit
operator|.
name|CommitConstants
operator|.
name|FS_S3A_COMMITTER_STAGING_UNIQUE_FILENAMES
import|;
end_import

begin_comment
comment|/**  * Full integration test MR jobs.  *  * This is all done on shared static mini YARN and HDFS clusters, set up before  * any of the tests methods run.  *  * To isolate tests properly for parallel test runs, that static state  * needs to be stored in the final classes implementing the tests, and  * exposed to the base class, with the setup clusters in the  * specific test suites creating the clusters with unique names.  *  * This is "hard" to do in Java, unlike, say, Scala.  *  * Note: this turns out not to be the root cause of ordering problems  * with the Terasort tests (that is hard coded use of a file in the local FS),  * but this design here does make it clear that the before and after class  * operations are explicitly called in the subclasses.  * If two subclasses of this class are instantiated in the same JVM, in order,  * they are guaranteed to be isolated.  *  * History: this is a superclass extracted from  * {@link AbstractITCommitMRJob} while adding support for testing terasorting.  *  */
end_comment

begin_class
DECL|class|AbstractYarnClusterITest
specifier|public
specifier|abstract
class|class
name|AbstractYarnClusterITest
extends|extends
name|AbstractCommitITest
block|{
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|AbstractYarnClusterITest
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|TEST_FILE_COUNT
specifier|private
specifier|static
specifier|final
name|int
name|TEST_FILE_COUNT
init|=
literal|2
decl_stmt|;
DECL|field|SCALE_TEST_FILE_COUNT
specifier|private
specifier|static
specifier|final
name|int
name|SCALE_TEST_FILE_COUNT
init|=
literal|50
decl_stmt|;
DECL|field|SCALE_TEST_KEYS
specifier|public
specifier|static
specifier|final
name|int
name|SCALE_TEST_KEYS
init|=
literal|1000
decl_stmt|;
DECL|field|BASE_TEST_KEYS
specifier|public
specifier|static
specifier|final
name|int
name|BASE_TEST_KEYS
init|=
literal|10
decl_stmt|;
DECL|field|scaleTest
specifier|private
name|boolean
name|scaleTest
decl_stmt|;
DECL|field|uniqueFilenames
specifier|private
name|boolean
name|uniqueFilenames
init|=
literal|false
decl_stmt|;
comment|/**    * This is the cluster binding which every subclass must create.    */
DECL|class|ClusterBinding
specifier|protected
specifier|static
specifier|final
class|class
name|ClusterBinding
block|{
DECL|field|hdfs
specifier|private
specifier|final
name|MiniDFSClusterService
name|hdfs
decl_stmt|;
DECL|field|yarn
specifier|private
specifier|final
name|MiniMRYarnCluster
name|yarn
decl_stmt|;
DECL|method|ClusterBinding ( final MiniDFSClusterService hdfs, final MiniMRYarnCluster yarn)
specifier|public
name|ClusterBinding
parameter_list|(
specifier|final
name|MiniDFSClusterService
name|hdfs
parameter_list|,
specifier|final
name|MiniMRYarnCluster
name|yarn
parameter_list|)
block|{
name|this
operator|.
name|hdfs
operator|=
name|checkNotNull
argument_list|(
name|hdfs
argument_list|)
expr_stmt|;
name|this
operator|.
name|yarn
operator|=
name|checkNotNull
argument_list|(
name|yarn
argument_list|)
expr_stmt|;
block|}
DECL|method|getHdfs ()
specifier|public
name|MiniDFSClusterService
name|getHdfs
parameter_list|()
block|{
return|return
name|hdfs
return|;
block|}
DECL|method|getYarn ()
specifier|public
name|MiniMRYarnCluster
name|getYarn
parameter_list|()
block|{
return|return
name|yarn
return|;
block|}
DECL|method|getConf ()
specifier|public
name|Configuration
name|getConf
parameter_list|()
block|{
return|return
name|getYarn
argument_list|()
operator|.
name|getConfig
argument_list|()
return|;
block|}
DECL|method|terminate ()
specifier|public
name|void
name|terminate
parameter_list|()
block|{
name|terminateService
argument_list|(
name|getYarn
argument_list|()
argument_list|)
expr_stmt|;
name|terminateService
argument_list|(
name|getHdfs
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Create the cluster binding. This must be done in    * class setup of the (final) subclass.    * The HDFS and YARN clusters share the same configuration, so    * the HDFS cluster binding is implicitly propagated to YARN.    * @param conf configuration to start with.    * @return the cluster binding.    * @throws IOException failure.    */
DECL|method|createCluster (JobConf conf)
specifier|protected
specifier|static
name|ClusterBinding
name|createCluster
parameter_list|(
name|JobConf
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|conf
operator|.
name|setBoolean
argument_list|(
name|JHAdminConfig
operator|.
name|MR_HISTORY_CLEANER_ENABLE
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|conf
operator|.
name|setLong
argument_list|(
name|CommonConfigurationKeys
operator|.
name|FS_DU_INTERVAL_KEY
argument_list|,
name|Long
operator|.
name|MAX_VALUE
argument_list|)
expr_stmt|;
comment|// create a unique cluster name.
name|String
name|clusterName
init|=
literal|"yarn-"
operator|+
name|UUID
operator|.
name|randomUUID
argument_list|()
decl_stmt|;
name|MiniDFSClusterService
name|miniDFSClusterService
init|=
name|deployService
argument_list|(
name|conf
argument_list|,
operator|new
name|MiniDFSClusterService
argument_list|()
argument_list|)
decl_stmt|;
name|MiniMRYarnCluster
name|yarnCluster
init|=
name|deployService
argument_list|(
name|conf
argument_list|,
operator|new
name|MiniMRYarnCluster
argument_list|(
name|clusterName
argument_list|,
literal|2
argument_list|)
argument_list|)
decl_stmt|;
return|return
operator|new
name|ClusterBinding
argument_list|(
name|miniDFSClusterService
argument_list|,
name|yarnCluster
argument_list|)
return|;
block|}
DECL|method|terminateCluster (ClusterBinding clusterBinding)
specifier|protected
specifier|static
name|void
name|terminateCluster
parameter_list|(
name|ClusterBinding
name|clusterBinding
parameter_list|)
block|{
if|if
condition|(
name|clusterBinding
operator|!=
literal|null
condition|)
block|{
name|clusterBinding
operator|.
name|terminate
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Get the cluster binding for this subclass    * @return    */
DECL|method|getClusterBinding ()
specifier|protected
specifier|abstract
name|ClusterBinding
name|getClusterBinding
parameter_list|()
function_decl|;
DECL|method|getHdfs ()
specifier|protected
name|MiniDFSClusterService
name|getHdfs
parameter_list|()
block|{
return|return
name|getClusterBinding
argument_list|()
operator|.
name|getHdfs
argument_list|()
return|;
block|}
DECL|method|getYarn ()
specifier|protected
name|MiniMRYarnCluster
name|getYarn
parameter_list|()
block|{
return|return
name|getClusterBinding
argument_list|()
operator|.
name|getYarn
argument_list|()
return|;
block|}
DECL|method|getLocalFS ()
specifier|public
name|FileSystem
name|getLocalFS
parameter_list|()
block|{
return|return
name|getHdfs
argument_list|()
operator|.
name|getLocalFS
argument_list|()
return|;
block|}
DECL|method|getDFS ()
specifier|protected
name|FileSystem
name|getDFS
parameter_list|()
block|{
return|return
name|getHdfs
argument_list|()
operator|.
name|getClusterFS
argument_list|()
return|;
block|}
comment|/**    * The name of the committer as returned by    * {@link AbstractS3ACommitter#getName()} and used for committer construction.    */
DECL|method|committerName ()
specifier|protected
specifier|abstract
name|String
name|committerName
parameter_list|()
function_decl|;
annotation|@
name|Override
DECL|method|setup ()
specifier|public
name|void
name|setup
parameter_list|()
throws|throws
name|Exception
block|{
name|super
operator|.
name|setup
argument_list|()
expr_stmt|;
name|assertNotNull
argument_list|(
literal|"cluster is not bound"
argument_list|,
name|getClusterBinding
argument_list|()
argument_list|)
expr_stmt|;
name|scaleTest
operator|=
name|getTestPropertyBool
argument_list|(
name|getConfiguration
argument_list|()
argument_list|,
name|KEY_SCALE_TESTS_ENABLED
argument_list|,
name|DEFAULT_SCALE_TESTS_ENABLED
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getTestTimeoutMillis ()
specifier|protected
name|int
name|getTestTimeoutMillis
parameter_list|()
block|{
return|return
name|SCALE_TEST_TIMEOUT_SECONDS
operator|*
literal|1000
return|;
block|}
DECL|method|newJobConf ()
specifier|protected
name|JobConf
name|newJobConf
parameter_list|()
block|{
return|return
operator|new
name|JobConf
argument_list|(
name|getYarn
argument_list|()
operator|.
name|getConfig
argument_list|()
argument_list|)
return|;
block|}
DECL|method|createJob ()
specifier|protected
name|Job
name|createJob
parameter_list|()
throws|throws
name|IOException
block|{
name|Configuration
name|jobConf
init|=
name|getClusterBinding
argument_list|()
operator|.
name|getConf
argument_list|()
decl_stmt|;
name|jobConf
operator|.
name|addResource
argument_list|(
name|getConfiguration
argument_list|()
argument_list|)
expr_stmt|;
name|Job
name|mrJob
init|=
name|Job
operator|.
name|getInstance
argument_list|(
name|jobConf
argument_list|,
name|getMethodName
argument_list|()
argument_list|)
decl_stmt|;
name|patchConfigurationForCommitter
argument_list|(
name|mrJob
operator|.
name|getConfiguration
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|mrJob
return|;
block|}
DECL|method|patchConfigurationForCommitter ( final Configuration jobConf)
specifier|protected
name|Configuration
name|patchConfigurationForCommitter
parameter_list|(
specifier|final
name|Configuration
name|jobConf
parameter_list|)
block|{
name|jobConf
operator|.
name|setBoolean
argument_list|(
name|FS_S3A_COMMITTER_STAGING_UNIQUE_FILENAMES
argument_list|,
name|uniqueFilenames
argument_list|)
expr_stmt|;
name|bindCommitter
argument_list|(
name|jobConf
argument_list|,
name|CommitConstants
operator|.
name|S3A_COMMITTER_FACTORY
argument_list|,
name|committerName
argument_list|()
argument_list|)
expr_stmt|;
comment|// pass down the scale test flag
name|jobConf
operator|.
name|setBoolean
argument_list|(
name|KEY_SCALE_TESTS_ENABLED
argument_list|,
name|scaleTest
argument_list|)
expr_stmt|;
return|return
name|jobConf
return|;
block|}
comment|/**    * Get the file count for the test.    * @return the number of mappers to create.    */
DECL|method|getTestFileCount ()
specifier|public
name|int
name|getTestFileCount
parameter_list|()
block|{
return|return
name|scaleTest
condition|?
name|SCALE_TEST_FILE_COUNT
else|:
name|TEST_FILE_COUNT
return|;
block|}
comment|/**    * Override point to let implementations tune the MR Job conf.    * @param jobConf configuration    */
DECL|method|applyCustomConfigOptions (JobConf jobConf)
specifier|protected
name|void
name|applyCustomConfigOptions
parameter_list|(
name|JobConf
name|jobConf
parameter_list|)
throws|throws
name|IOException
block|{    }
comment|/**    * Override point for any committer specific validation operations;    * called after the base assertions have all passed.    * @param destPath destination of work    * @param successData loaded success data    * @throws Exception failure    */
DECL|method|customPostExecutionValidation (Path destPath, SuccessData successData)
specifier|protected
name|void
name|customPostExecutionValidation
parameter_list|(
name|Path
name|destPath
parameter_list|,
name|SuccessData
name|successData
parameter_list|)
throws|throws
name|Exception
block|{    }
comment|/**    * Assume that scale tests are enabled.    */
DECL|method|requireScaleTestsEnabled ()
specifier|protected
name|void
name|requireScaleTestsEnabled
parameter_list|()
block|{
name|assume
argument_list|(
literal|"Scale test disabled: to enable set property "
operator|+
name|KEY_SCALE_TESTS_ENABLED
argument_list|,
name|isScaleTest
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|isScaleTest ()
specifier|public
name|boolean
name|isScaleTest
parameter_list|()
block|{
return|return
name|scaleTest
return|;
block|}
DECL|method|isUniqueFilenames ()
specifier|public
name|boolean
name|isUniqueFilenames
parameter_list|()
block|{
return|return
name|uniqueFilenames
return|;
block|}
block|}
end_class

end_unit

