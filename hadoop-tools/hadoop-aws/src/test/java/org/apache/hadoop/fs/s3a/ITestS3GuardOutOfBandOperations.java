begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.fs.s3a
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileNotFoundException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URI
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|UUID
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicLong
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|stream
operator|.
name|Collectors
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Assume
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Before
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Test
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|runner
operator|.
name|RunWith
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|runners
operator|.
name|Parameterized
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FSDataInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|s3guard
operator|.
name|NullMetadataStore
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FSDataOutputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|impl
operator|.
name|ChangeDetectionPolicy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|impl
operator|.
name|ChangeDetectionPolicy
operator|.
name|Source
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|s3guard
operator|.
name|DirListingMetadata
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|s3guard
operator|.
name|MetadataStore
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|s3guard
operator|.
name|PathMetadata
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|s3guard
operator|.
name|ITtlTimeProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|LocatedFileStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|RemoteIterator
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|contract
operator|.
name|ContractTestUtils
operator|.
name|touch
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|Constants
operator|.
name|DEFAULT_METADATASTORE_METADATA_TTL
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|Constants
operator|.
name|METADATASTORE_METADATA_TTL
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|S3ATestUtils
operator|.
name|removeBaseAndBucketOverrides
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|test
operator|.
name|LambdaTestUtils
operator|.
name|eventually
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assume
operator|.
name|assumeTrue
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|contract
operator|.
name|ContractTestUtils
operator|.
name|readBytesToString
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|contract
operator|.
name|ContractTestUtils
operator|.
name|writeTextFile
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|Constants
operator|.
name|METADATASTORE_AUTHORITATIVE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|Constants
operator|.
name|S3_METADATA_STORE_IMPL
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|S3ATestUtils
operator|.
name|metadataStorePersistsAuthoritativeBit
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|test
operator|.
name|LambdaTestUtils
operator|.
name|intercept
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|mockito
operator|.
name|Mockito
operator|.
name|mock
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|mockito
operator|.
name|Mockito
operator|.
name|when
import|;
end_import

begin_comment
comment|/**  *  * This integration test is for documenting and defining how S3Guard should  * behave in case of out-of-band (OOB) operations.  *<pre>  * The behavior is the following in case of S3AFileSystem.getFileStatus:  * A client with S3Guard  * B client without S3Guard (Directly to S3)  *  * * OOB OVERWRITE, authoritative mode:  * ** A client creates F1 file  * ** B client overwrites F1 file with F2 (Same, or different file size)  * ** A client's getFileStatus returns F1 metadata  *  * * OOB OVERWRITE, NOT authoritative mode:  * ** A client creates F1 file  * ** B client overwrites F1 file with F2 (Same, or different file size)  * ** A client's getFileStatus returns F2 metadata. In not authoritative  * mode we check S3 for the file. If the modification time of the file in S3  * is greater than in S3Guard, we can safely return the S3 file metadata and  * update the cache.  *  * * OOB DELETE, authoritative mode:  * ** A client creates F file  * ** B client deletes F file  * ** A client's getFileStatus returns that the file is still there  *  * * OOB DELETE, NOT authoritative mode:  * ** A client creates F file  * ** B client deletes F file  * ** A client's getFileStatus returns that the file is still there  *  * As you can see, authoritative and NOT authoritative mode behaves the same  * at OOB DELETE case.  *  * The behavior is the following in case of S3AFileSystem.listStatus:  * * File status in metadata store gets updated during the listing (in  * S3Guard.dirListingUnion) the same way as in getFileStatus.  *</pre>  */
end_comment

begin_class
annotation|@
name|RunWith
argument_list|(
name|Parameterized
operator|.
name|class
argument_list|)
DECL|class|ITestS3GuardOutOfBandOperations
specifier|public
class|class
name|ITestS3GuardOutOfBandOperations
extends|extends
name|AbstractS3ATestBase
block|{
DECL|field|TIMESTAMP_SLEEP
specifier|public
specifier|static
specifier|final
name|int
name|TIMESTAMP_SLEEP
init|=
literal|2000
decl_stmt|;
DECL|field|STABILIZATION_TIME
specifier|public
specifier|static
specifier|final
name|int
name|STABILIZATION_TIME
init|=
literal|20_000
decl_stmt|;
DECL|field|PROBE_INTERVAL_MILLIS
specifier|public
specifier|static
specifier|final
name|int
name|PROBE_INTERVAL_MILLIS
init|=
literal|500
decl_stmt|;
DECL|field|guardedFs
specifier|private
name|S3AFileSystem
name|guardedFs
decl_stmt|;
DECL|field|rawFS
specifier|private
name|S3AFileSystem
name|rawFS
decl_stmt|;
DECL|field|realMs
specifier|private
name|MetadataStore
name|realMs
decl_stmt|;
comment|/**    * Is the "real" FS Authoritative.    */
DECL|field|authoritative
specifier|private
specifier|final
name|boolean
name|authoritative
decl_stmt|;
comment|/**    * Test array for parameterized test runs.    * @return a list of parameter tuples.    */
annotation|@
name|Parameterized
operator|.
name|Parameters
argument_list|(
name|name
operator|=
literal|"auth={0}"
argument_list|)
DECL|method|params ()
specifier|public
specifier|static
name|Collection
argument_list|<
name|Object
index|[]
argument_list|>
name|params
parameter_list|()
block|{
return|return
name|Arrays
operator|.
name|asList
argument_list|(
operator|new
name|Object
index|[]
index|[]
block|{
block|{
literal|true
block|}
block|,
block|{
literal|false
block|}
block|}
argument_list|)
return|;
block|}
DECL|method|ITestS3GuardOutOfBandOperations (final boolean authoritative)
specifier|public
name|ITestS3GuardOutOfBandOperations
parameter_list|(
specifier|final
name|boolean
name|authoritative
parameter_list|)
block|{
name|this
operator|.
name|authoritative
operator|=
name|authoritative
expr_stmt|;
block|}
comment|/**    * By changing the method name, the thread name is changed and    * so you can see in the logs which mode is being tested.    * @return a string to use for the thread namer.    */
annotation|@
name|Override
DECL|method|getMethodName ()
specifier|protected
name|String
name|getMethodName
parameter_list|()
block|{
return|return
name|super
operator|.
name|getMethodName
argument_list|()
operator|+
operator|(
name|authoritative
condition|?
literal|"-auth"
else|:
literal|"-nonauth"
operator|)
return|;
block|}
annotation|@
name|Before
DECL|method|setup ()
specifier|public
name|void
name|setup
parameter_list|()
throws|throws
name|Exception
block|{
name|super
operator|.
name|setup
argument_list|()
expr_stmt|;
name|S3AFileSystem
name|fs
init|=
name|getFileSystem
argument_list|()
decl_stmt|;
comment|// These test will fail if no ms
name|assumeTrue
argument_list|(
literal|"FS needs to have a metadatastore."
argument_list|,
name|fs
operator|.
name|hasMetadataStore
argument_list|()
argument_list|)
expr_stmt|;
name|assumeTrue
argument_list|(
literal|"Metadatastore should persist authoritative bit"
argument_list|,
name|metadataStorePersistsAuthoritativeBit
argument_list|(
name|fs
operator|.
name|getMetadataStore
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|// This test setup shares a single metadata store across instances,
comment|// so that test runs with a local FS work.
comment|// but this needs to be addressed in teardown, where the guarded fs
comment|// needs to be detached from the metadata store before it is closed,
name|realMs
operator|=
name|fs
operator|.
name|getMetadataStore
argument_list|()
expr_stmt|;
comment|// now we create a new FS with the auth parameter
name|guardedFs
operator|=
name|createGuardedFS
argument_list|(
name|authoritative
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"No S3Guard store for "
operator|+
name|guardedFs
argument_list|,
name|guardedFs
operator|.
name|hasMetadataStore
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Authoritative status in "
operator|+
name|guardedFs
argument_list|,
name|authoritative
argument_list|,
name|guardedFs
operator|.
name|hasAuthoritativeMetadataStore
argument_list|()
argument_list|)
expr_stmt|;
comment|// create raw fs without s3guard
name|rawFS
operator|=
name|createUnguardedFS
argument_list|()
expr_stmt|;
name|assertFalse
argument_list|(
literal|"Raw FS still has S3Guard "
operator|+
name|rawFS
argument_list|,
name|rawFS
operator|.
name|hasMetadataStore
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|teardown ()
specifier|public
name|void
name|teardown
parameter_list|()
throws|throws
name|Exception
block|{
if|if
condition|(
name|guardedFs
operator|!=
literal|null
condition|)
block|{
comment|// detach from the (shared) metadata store.
name|guardedFs
operator|.
name|setMetadataStore
argument_list|(
operator|new
name|NullMetadataStore
argument_list|()
argument_list|)
expr_stmt|;
comment|// and only then close it.
name|IOUtils
operator|.
name|cleanupWithLogger
argument_list|(
name|LOG
argument_list|,
name|guardedFs
argument_list|)
expr_stmt|;
block|}
name|IOUtils
operator|.
name|cleanupWithLogger
argument_list|(
name|LOG
argument_list|,
name|rawFS
argument_list|)
expr_stmt|;
name|super
operator|.
name|teardown
argument_list|()
expr_stmt|;
block|}
comment|/**    * Create a new FS which is the same config as the test FS, except    * that it is guarded with the specific authoritative mode.    * @param authoritativeMode mode of the new FS's metastore    * @return the new FS    */
DECL|method|createGuardedFS (boolean authoritativeMode)
specifier|private
name|S3AFileSystem
name|createGuardedFS
parameter_list|(
name|boolean
name|authoritativeMode
parameter_list|)
throws|throws
name|Exception
block|{
name|S3AFileSystem
name|testFS
init|=
name|getFileSystem
argument_list|()
decl_stmt|;
name|Configuration
name|config
init|=
operator|new
name|Configuration
argument_list|(
name|testFS
operator|.
name|getConf
argument_list|()
argument_list|)
decl_stmt|;
name|URI
name|uri
init|=
name|testFS
operator|.
name|getUri
argument_list|()
decl_stmt|;
name|removeBaseAndBucketOverrides
argument_list|(
name|uri
operator|.
name|getHost
argument_list|()
argument_list|,
name|config
argument_list|,
name|METADATASTORE_AUTHORITATIVE
argument_list|,
name|METADATASTORE_METADATA_TTL
argument_list|)
expr_stmt|;
name|config
operator|.
name|setBoolean
argument_list|(
name|METADATASTORE_AUTHORITATIVE
argument_list|,
name|authoritativeMode
argument_list|)
expr_stmt|;
name|config
operator|.
name|setLong
argument_list|(
name|METADATASTORE_METADATA_TTL
argument_list|,
name|DEFAULT_METADATASTORE_METADATA_TTL
argument_list|)
expr_stmt|;
specifier|final
name|S3AFileSystem
name|gFs
init|=
name|createFS
argument_list|(
name|uri
argument_list|,
name|config
argument_list|)
decl_stmt|;
comment|// set back the same metadata store instance
name|gFs
operator|.
name|setMetadataStore
argument_list|(
name|realMs
argument_list|)
expr_stmt|;
return|return
name|gFs
return|;
block|}
comment|/**    * Create a test filesystem which is always unguarded.    * This filesystem MUST be closed in test teardown.    * @return the new FS    */
DECL|method|createUnguardedFS ()
specifier|private
name|S3AFileSystem
name|createUnguardedFS
parameter_list|()
throws|throws
name|Exception
block|{
name|S3AFileSystem
name|testFS
init|=
name|getFileSystem
argument_list|()
decl_stmt|;
name|Configuration
name|config
init|=
operator|new
name|Configuration
argument_list|(
name|testFS
operator|.
name|getConf
argument_list|()
argument_list|)
decl_stmt|;
name|URI
name|uri
init|=
name|testFS
operator|.
name|getUri
argument_list|()
decl_stmt|;
name|removeBaseAndBucketOverrides
argument_list|(
name|uri
operator|.
name|getHost
argument_list|()
argument_list|,
name|config
argument_list|,
name|S3_METADATA_STORE_IMPL
argument_list|)
expr_stmt|;
name|removeBaseAndBucketOverrides
argument_list|(
name|uri
operator|.
name|getHost
argument_list|()
argument_list|,
name|config
argument_list|,
name|METADATASTORE_AUTHORITATIVE
argument_list|)
expr_stmt|;
return|return
name|createFS
argument_list|(
name|uri
argument_list|,
name|config
argument_list|)
return|;
block|}
comment|/**    * Create and initialize a new filesystem.    * This filesystem MUST be closed in test teardown.    * @param uri FS URI    * @param config config.    * @return new instance    * @throws IOException failure    */
DECL|method|createFS (final URI uri, final Configuration config)
specifier|private
name|S3AFileSystem
name|createFS
parameter_list|(
specifier|final
name|URI
name|uri
parameter_list|,
specifier|final
name|Configuration
name|config
parameter_list|)
throws|throws
name|IOException
block|{
name|S3AFileSystem
name|fs2
init|=
operator|new
name|S3AFileSystem
argument_list|()
decl_stmt|;
name|fs2
operator|.
name|initialize
argument_list|(
name|uri
argument_list|,
name|config
argument_list|)
expr_stmt|;
return|return
name|fs2
return|;
block|}
annotation|@
name|Test
DECL|method|testSameLengthOverwrite ()
specifier|public
name|void
name|testSameLengthOverwrite
parameter_list|()
throws|throws
name|Exception
block|{
name|String
name|firstText
init|=
literal|"hello, world!"
decl_stmt|;
name|String
name|secondText
init|=
literal|"HELLO, WORLD!"
decl_stmt|;
name|overwriteFile
argument_list|(
name|firstText
argument_list|,
name|secondText
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testLongerLengthOverwrite ()
specifier|public
name|void
name|testLongerLengthOverwrite
parameter_list|()
throws|throws
name|Exception
block|{
name|String
name|firstText
init|=
literal|"Hello, World!"
decl_stmt|;
name|String
name|secondText
init|=
name|firstText
operator|+
literal|" "
operator|+
name|firstText
decl_stmt|;
name|overwriteFile
argument_list|(
name|firstText
argument_list|,
name|secondText
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testOutOfBandDeletes ()
specifier|public
name|void
name|testOutOfBandDeletes
parameter_list|()
throws|throws
name|Exception
block|{
name|ChangeDetectionPolicy
name|changeDetectionPolicy
init|=
operator|(
operator|(
name|S3AFileSystem
operator|)
name|getFileSystem
argument_list|()
operator|)
operator|.
name|getChangeDetectionPolicy
argument_list|()
decl_stmt|;
name|Assume
operator|.
name|assumeFalse
argument_list|(
literal|"FNF not expected when using a bucket with"
operator|+
literal|" object versioning"
argument_list|,
name|changeDetectionPolicy
operator|.
name|getSource
argument_list|()
operator|==
name|Source
operator|.
name|VersionId
argument_list|)
expr_stmt|;
name|Path
name|testFileName
init|=
name|path
argument_list|(
literal|"OutOfBandDelete-"
operator|+
name|UUID
operator|.
name|randomUUID
argument_list|()
argument_list|)
decl_stmt|;
name|outOfBandDeletes
argument_list|(
name|testFileName
argument_list|,
name|authoritative
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testListingSameLengthOverwrite ()
specifier|public
name|void
name|testListingSameLengthOverwrite
parameter_list|()
throws|throws
name|Exception
block|{
name|overwriteFileInListing
argument_list|(
literal|"THE TEXT"
argument_list|,
literal|"the text"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testListingLongerLengthOverwrite ()
specifier|public
name|void
name|testListingLongerLengthOverwrite
parameter_list|()
throws|throws
name|Exception
block|{
name|overwriteFileInListing
argument_list|(
literal|"THE TEXT"
argument_list|,
literal|"THE LONGER TEXT"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testListingDelete ()
specifier|public
name|void
name|testListingDelete
parameter_list|()
throws|throws
name|Exception
block|{
name|deleteFileInListing
argument_list|()
expr_stmt|;
block|}
comment|/**    * Tests that tombstone expiry is implemented, so if a file is created raw    * while the tombstone exist in ms for with the same name then S3Guard will    * check S3 for the file.    *    * Seq: create guarded; delete guarded; create raw (same path); read guarded;    * This will fail if no tombstone expiry is set    *    * @throws Exception    */
annotation|@
name|Test
DECL|method|testTombstoneExpiryGuardedDeleteRawCreate ()
specifier|public
name|void
name|testTombstoneExpiryGuardedDeleteRawCreate
parameter_list|()
throws|throws
name|Exception
block|{
name|boolean
name|allowAuthoritative
init|=
name|authoritative
decl_stmt|;
name|Path
name|testFilePath
init|=
name|path
argument_list|(
literal|"TEGDRC-"
operator|+
name|UUID
operator|.
name|randomUUID
argument_list|()
operator|+
literal|"/file"
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Allow authoritative param: {}"
argument_list|,
name|allowAuthoritative
argument_list|)
expr_stmt|;
name|String
name|originalText
init|=
literal|"some test"
decl_stmt|;
name|String
name|newText
init|=
literal|"the new originalText for test"
decl_stmt|;
specifier|final
name|ITtlTimeProvider
name|originalTimeProvider
init|=
name|guardedFs
operator|.
name|getTtlTimeProvider
argument_list|()
decl_stmt|;
try|try
block|{
specifier|final
name|AtomicLong
name|now
init|=
operator|new
name|AtomicLong
argument_list|(
literal|1
argument_list|)
decl_stmt|;
specifier|final
name|AtomicLong
name|metadataTtl
init|=
operator|new
name|AtomicLong
argument_list|(
literal|1
argument_list|)
decl_stmt|;
comment|// SET TTL TIME PROVIDER FOR TESTING
name|ITtlTimeProvider
name|testTimeProvider
init|=
operator|new
name|ITtlTimeProvider
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|long
name|getNow
parameter_list|()
block|{
return|return
name|now
operator|.
name|get
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|getMetadataTtl
parameter_list|()
block|{
return|return
name|metadataTtl
operator|.
name|get
argument_list|()
return|;
block|}
block|}
decl_stmt|;
name|guardedFs
operator|.
name|setTtlTimeProvider
argument_list|(
name|testTimeProvider
argument_list|)
expr_stmt|;
comment|// CREATE GUARDED
name|createAndAwaitFs
argument_list|(
name|guardedFs
argument_list|,
name|testFilePath
argument_list|,
name|originalText
argument_list|)
expr_stmt|;
comment|// DELETE GUARDED
name|deleteGuardedTombstoned
argument_list|(
name|guardedFs
argument_list|,
name|testFilePath
argument_list|,
name|now
argument_list|)
expr_stmt|;
comment|// CREATE RAW
name|createAndAwaitFs
argument_list|(
name|rawFS
argument_list|,
name|testFilePath
argument_list|,
name|newText
argument_list|)
expr_stmt|;
comment|// CHECK LISTING - THE FILE SHOULD NOT BE THERE, EVEN IF IT'S CREATED RAW
name|checkListingDoesNotContainPath
argument_list|(
name|guardedFs
argument_list|,
name|testFilePath
argument_list|)
expr_stmt|;
comment|// CHANGE TTL SO ENTRY (& TOMBSTONE METADATA) WILL EXPIRE
name|long
name|willExpire
init|=
name|now
operator|.
name|get
argument_list|()
operator|+
name|metadataTtl
operator|.
name|get
argument_list|()
operator|+
literal|1L
decl_stmt|;
name|now
operator|.
name|set
argument_list|(
name|willExpire
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"willExpire: {}, ttlNow: {}; ttlTTL: {}"
argument_list|,
name|willExpire
argument_list|,
name|testTimeProvider
operator|.
name|getNow
argument_list|()
argument_list|,
name|testTimeProvider
operator|.
name|getMetadataTtl
argument_list|()
argument_list|)
expr_stmt|;
comment|// READ GUARDED
name|String
name|newRead
init|=
name|readBytesToString
argument_list|(
name|guardedFs
argument_list|,
name|testFilePath
argument_list|,
name|newText
operator|.
name|length
argument_list|()
argument_list|)
decl_stmt|;
comment|// CHECK LISTING - THE FILE SHOULD BE THERE, TOMBSTONE EXPIRED
name|checkListingContainsPath
argument_list|(
name|guardedFs
argument_list|,
name|testFilePath
argument_list|)
expr_stmt|;
comment|// we can assert that the originalText is the new one, which created raw
name|LOG
operator|.
name|info
argument_list|(
literal|"Old: {}, New: {}, Read: {}"
argument_list|,
name|originalText
argument_list|,
name|newText
argument_list|,
name|newRead
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"The text should be modified with a new."
argument_list|,
name|newText
argument_list|,
name|newRead
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|guardedFs
operator|.
name|delete
argument_list|(
name|testFilePath
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|guardedFs
operator|.
name|setTtlTimeProvider
argument_list|(
name|originalTimeProvider
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|createAndAwaitFs (S3AFileSystem fs, Path testFilePath, String text)
specifier|private
name|void
name|createAndAwaitFs
parameter_list|(
name|S3AFileSystem
name|fs
parameter_list|,
name|Path
name|testFilePath
parameter_list|,
name|String
name|text
parameter_list|)
throws|throws
name|Exception
block|{
name|writeTextFile
argument_list|(
name|fs
argument_list|,
name|testFilePath
argument_list|,
name|text
argument_list|,
literal|true
argument_list|)
expr_stmt|;
specifier|final
name|FileStatus
name|newStatus
init|=
name|awaitFileStatus
argument_list|(
name|fs
argument_list|,
name|testFilePath
argument_list|)
decl_stmt|;
name|assertNotNull
argument_list|(
literal|"Newly created file status should not be null."
argument_list|,
name|newStatus
argument_list|)
expr_stmt|;
block|}
DECL|method|deleteGuardedTombstoned (S3AFileSystem guarded, Path testFilePath, AtomicLong now)
specifier|private
name|void
name|deleteGuardedTombstoned
parameter_list|(
name|S3AFileSystem
name|guarded
parameter_list|,
name|Path
name|testFilePath
parameter_list|,
name|AtomicLong
name|now
parameter_list|)
throws|throws
name|Exception
block|{
name|guarded
operator|.
name|delete
argument_list|(
name|testFilePath
argument_list|,
literal|true
argument_list|)
expr_stmt|;
specifier|final
name|PathMetadata
name|metadata
init|=
name|guarded
operator|.
name|getMetadataStore
argument_list|()
operator|.
name|get
argument_list|(
name|testFilePath
argument_list|)
decl_stmt|;
name|assertNotNull
argument_list|(
literal|"Created file metadata should not be null in ms"
argument_list|,
name|metadata
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Created file metadata last_updated should equal with "
operator|+
literal|"mocked now"
argument_list|,
name|now
operator|.
name|get
argument_list|()
argument_list|,
name|metadata
operator|.
name|getLastUpdated
argument_list|()
argument_list|)
expr_stmt|;
name|intercept
argument_list|(
name|FileNotFoundException
operator|.
name|class
argument_list|,
name|testFilePath
operator|.
name|toString
argument_list|()
argument_list|,
literal|"This file should throw FNFE when reading through "
operator|+
literal|"the guarded fs, and the metadatastore tombstoned the file."
argument_list|,
parameter_list|()
lambda|->
name|guarded
operator|.
name|getFileStatus
argument_list|(
name|testFilePath
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * createNonRecursive must fail if the parent directory has been deleted,    * and succeed if the tombstone has expired and the directory has been    * created out of band.    */
annotation|@
name|Test
DECL|method|testCreateNonRecursiveFailsIfParentDeleted ()
specifier|public
name|void
name|testCreateNonRecursiveFailsIfParentDeleted
parameter_list|()
throws|throws
name|Exception
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Authoritative mode: {}"
argument_list|,
name|authoritative
argument_list|)
expr_stmt|;
name|String
name|dirToDelete
init|=
name|methodName
operator|+
name|UUID
operator|.
name|randomUUID
argument_list|()
operator|.
name|toString
argument_list|()
decl_stmt|;
name|String
name|fileToTry
init|=
name|dirToDelete
operator|+
literal|"/theFileToTry"
decl_stmt|;
specifier|final
name|Path
name|dirPath
init|=
name|path
argument_list|(
name|dirToDelete
argument_list|)
decl_stmt|;
specifier|final
name|Path
name|filePath
init|=
name|path
argument_list|(
name|fileToTry
argument_list|)
decl_stmt|;
comment|// Create a directory with
name|ITtlTimeProvider
name|mockTimeProvider
init|=
name|mock
argument_list|(
name|ITtlTimeProvider
operator|.
name|class
argument_list|)
decl_stmt|;
name|ITtlTimeProvider
name|originalTimeProvider
init|=
name|guardedFs
operator|.
name|getTtlTimeProvider
argument_list|()
decl_stmt|;
try|try
block|{
name|guardedFs
operator|.
name|setTtlTimeProvider
argument_list|(
name|mockTimeProvider
argument_list|)
expr_stmt|;
name|when
argument_list|(
name|mockTimeProvider
operator|.
name|getNow
argument_list|()
argument_list|)
operator|.
name|thenReturn
argument_list|(
literal|100L
argument_list|)
expr_stmt|;
name|when
argument_list|(
name|mockTimeProvider
operator|.
name|getMetadataTtl
argument_list|()
argument_list|)
operator|.
name|thenReturn
argument_list|(
literal|5L
argument_list|)
expr_stmt|;
comment|// CREATE DIRECTORY
name|guardedFs
operator|.
name|mkdirs
argument_list|(
name|dirPath
argument_list|)
expr_stmt|;
comment|// DELETE DIRECTORY
name|guardedFs
operator|.
name|delete
argument_list|(
name|dirPath
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|// WRITE TO DELETED DIRECTORY - FAIL
name|intercept
argument_list|(
name|FileNotFoundException
operator|.
name|class
argument_list|,
name|dirToDelete
argument_list|,
literal|"createNonRecursive must fail if the parent directory has been deleted."
argument_list|,
parameter_list|()
lambda|->
name|createNonRecursive
argument_list|(
name|guardedFs
argument_list|,
name|filePath
argument_list|)
argument_list|)
expr_stmt|;
comment|// CREATE THE DIRECTORY RAW
name|rawFS
operator|.
name|mkdirs
argument_list|(
name|dirPath
argument_list|)
expr_stmt|;
name|awaitFileStatus
argument_list|(
name|rawFS
argument_list|,
name|dirPath
argument_list|)
expr_stmt|;
comment|// SET TIME SO METADATA EXPIRES
name|when
argument_list|(
name|mockTimeProvider
operator|.
name|getNow
argument_list|()
argument_list|)
operator|.
name|thenReturn
argument_list|(
literal|110L
argument_list|)
expr_stmt|;
comment|// WRITE TO DELETED DIRECTORY - SUCCESS
name|createNonRecursive
argument_list|(
name|guardedFs
argument_list|,
name|filePath
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|guardedFs
operator|.
name|delete
argument_list|(
name|filePath
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|guardedFs
operator|.
name|delete
argument_list|(
name|dirPath
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|guardedFs
operator|.
name|setTtlTimeProvider
argument_list|(
name|originalTimeProvider
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * When lastUpdated = 0 the entry should not expire. This is a special case    * eg. for old metadata entries    */
annotation|@
name|Test
DECL|method|testLastUpdatedZeroWontExpire ()
specifier|public
name|void
name|testLastUpdatedZeroWontExpire
parameter_list|()
throws|throws
name|Exception
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Authoritative mode: {}"
argument_list|,
name|authoritative
argument_list|)
expr_stmt|;
name|String
name|testFile
init|=
name|methodName
operator|+
name|UUID
operator|.
name|randomUUID
argument_list|()
operator|.
name|toString
argument_list|()
operator|+
literal|"/theFileToTry"
decl_stmt|;
name|long
name|ttl
init|=
literal|10L
decl_stmt|;
specifier|final
name|Path
name|filePath
init|=
name|path
argument_list|(
name|testFile
argument_list|)
decl_stmt|;
name|ITtlTimeProvider
name|mockTimeProvider
init|=
name|mock
argument_list|(
name|ITtlTimeProvider
operator|.
name|class
argument_list|)
decl_stmt|;
name|ITtlTimeProvider
name|originalTimeProvider
init|=
name|guardedFs
operator|.
name|getTtlTimeProvider
argument_list|()
decl_stmt|;
try|try
block|{
name|guardedFs
operator|.
name|setTtlTimeProvider
argument_list|(
name|mockTimeProvider
argument_list|)
expr_stmt|;
name|when
argument_list|(
name|mockTimeProvider
operator|.
name|getMetadataTtl
argument_list|()
argument_list|)
operator|.
name|thenReturn
argument_list|(
name|ttl
argument_list|)
expr_stmt|;
comment|// create a file while the NOW is 0, so it will set 0 as the last_updated
name|when
argument_list|(
name|mockTimeProvider
operator|.
name|getNow
argument_list|()
argument_list|)
operator|.
name|thenReturn
argument_list|(
literal|0L
argument_list|)
expr_stmt|;
name|touch
argument_list|(
name|guardedFs
argument_list|,
name|filePath
argument_list|)
expr_stmt|;
name|deleteFile
argument_list|(
name|guardedFs
argument_list|,
name|filePath
argument_list|)
expr_stmt|;
specifier|final
name|PathMetadata
name|pathMetadata
init|=
name|guardedFs
operator|.
name|getMetadataStore
argument_list|()
operator|.
name|get
argument_list|(
name|filePath
argument_list|)
decl_stmt|;
name|assertNotNull
argument_list|(
literal|"pathMetadata should not be null after deleting with "
operator|+
literal|"tombstones"
argument_list|,
name|pathMetadata
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"pathMetadata lastUpdated field should be 0"
argument_list|,
literal|0
argument_list|,
name|pathMetadata
operator|.
name|getLastUpdated
argument_list|()
argument_list|)
expr_stmt|;
comment|// set the time, so the metadata would expire
name|when
argument_list|(
name|mockTimeProvider
operator|.
name|getNow
argument_list|()
argument_list|)
operator|.
name|thenReturn
argument_list|(
literal|2
operator|*
name|ttl
argument_list|)
expr_stmt|;
name|intercept
argument_list|(
name|FileNotFoundException
operator|.
name|class
argument_list|,
name|filePath
operator|.
name|toString
argument_list|()
argument_list|,
literal|"This file should throw FNFE when reading through "
operator|+
literal|"the guarded fs, and the metadatastore tombstoned the file. "
operator|+
literal|"The tombstone won't expire if lastUpdated is set to 0."
argument_list|,
parameter_list|()
lambda|->
name|guardedFs
operator|.
name|getFileStatus
argument_list|(
name|filePath
argument_list|)
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|guardedFs
operator|.
name|delete
argument_list|(
name|filePath
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|guardedFs
operator|.
name|setTtlTimeProvider
argument_list|(
name|originalTimeProvider
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * 1. File is deleted in the guarded fs.    * 2. File is replaced in the raw fs.    * 3. File is deleted in the guarded FS after the expiry time.    * 4. File MUST NOT exist in raw FS.    */
annotation|@
name|Test
DECL|method|deleteAfterTombstoneExpiryOobCreate ()
specifier|public
name|void
name|deleteAfterTombstoneExpiryOobCreate
parameter_list|()
throws|throws
name|Exception
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Authoritative mode: {}"
argument_list|,
name|authoritative
argument_list|)
expr_stmt|;
name|String
name|testFile
init|=
name|methodName
operator|+
name|UUID
operator|.
name|randomUUID
argument_list|()
operator|.
name|toString
argument_list|()
operator|+
literal|"/theFileToTry"
decl_stmt|;
name|long
name|ttl
init|=
literal|10L
decl_stmt|;
specifier|final
name|Path
name|filePath
init|=
name|path
argument_list|(
name|testFile
argument_list|)
decl_stmt|;
name|ITtlTimeProvider
name|mockTimeProvider
init|=
name|mock
argument_list|(
name|ITtlTimeProvider
operator|.
name|class
argument_list|)
decl_stmt|;
name|ITtlTimeProvider
name|originalTimeProvider
init|=
name|guardedFs
operator|.
name|getTtlTimeProvider
argument_list|()
decl_stmt|;
try|try
block|{
name|guardedFs
operator|.
name|setTtlTimeProvider
argument_list|(
name|mockTimeProvider
argument_list|)
expr_stmt|;
name|when
argument_list|(
name|mockTimeProvider
operator|.
name|getMetadataTtl
argument_list|()
argument_list|)
operator|.
name|thenReturn
argument_list|(
name|ttl
argument_list|)
expr_stmt|;
comment|// CREATE AND DELETE WITH GUARDED FS
name|when
argument_list|(
name|mockTimeProvider
operator|.
name|getNow
argument_list|()
argument_list|)
operator|.
name|thenReturn
argument_list|(
literal|100L
argument_list|)
expr_stmt|;
name|touch
argument_list|(
name|guardedFs
argument_list|,
name|filePath
argument_list|)
expr_stmt|;
name|deleteFile
argument_list|(
name|guardedFs
argument_list|,
name|filePath
argument_list|)
expr_stmt|;
specifier|final
name|PathMetadata
name|pathMetadata
init|=
name|guardedFs
operator|.
name|getMetadataStore
argument_list|()
operator|.
name|get
argument_list|(
name|filePath
argument_list|)
decl_stmt|;
name|assertNotNull
argument_list|(
literal|"pathMetadata should not be null after deleting with "
operator|+
literal|"tombstones"
argument_list|,
name|pathMetadata
argument_list|)
expr_stmt|;
comment|// REPLACE WITH RAW FS
name|touch
argument_list|(
name|rawFS
argument_list|,
name|filePath
argument_list|)
expr_stmt|;
name|awaitFileStatus
argument_list|(
name|rawFS
argument_list|,
name|filePath
argument_list|)
expr_stmt|;
comment|// SET EXPIRY TIME, SO THE TOMBSTONE IS EXPIRED
name|when
argument_list|(
name|mockTimeProvider
operator|.
name|getNow
argument_list|()
argument_list|)
operator|.
name|thenReturn
argument_list|(
literal|100L
operator|+
literal|2
operator|*
name|ttl
argument_list|)
expr_stmt|;
comment|// DELETE IN GUARDED FS
name|guardedFs
operator|.
name|delete
argument_list|(
name|filePath
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|// FILE MUST NOT EXIST IN RAW
name|intercept
argument_list|(
name|FileNotFoundException
operator|.
name|class
argument_list|,
name|filePath
operator|.
name|toString
argument_list|()
argument_list|,
literal|"This file should throw FNFE when reading through "
operator|+
literal|"the raw fs, and the guarded fs deleted the file."
argument_list|,
parameter_list|()
lambda|->
name|rawFS
operator|.
name|getFileStatus
argument_list|(
name|filePath
argument_list|)
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|guardedFs
operator|.
name|delete
argument_list|(
name|filePath
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|guardedFs
operator|.
name|setTtlTimeProvider
argument_list|(
name|originalTimeProvider
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|checkListingDoesNotContainPath (S3AFileSystem fs, Path filePath)
specifier|private
name|void
name|checkListingDoesNotContainPath
parameter_list|(
name|S3AFileSystem
name|fs
parameter_list|,
name|Path
name|filePath
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|RemoteIterator
argument_list|<
name|LocatedFileStatus
argument_list|>
name|listIter
init|=
name|fs
operator|.
name|listFiles
argument_list|(
name|filePath
operator|.
name|getParent
argument_list|()
argument_list|,
literal|false
argument_list|)
decl_stmt|;
while|while
condition|(
name|listIter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
specifier|final
name|LocatedFileStatus
name|lfs
init|=
name|listIter
operator|.
name|next
argument_list|()
decl_stmt|;
name|assertNotEquals
argument_list|(
literal|"The tombstone has not been expired, so must not be"
operator|+
literal|" listed."
argument_list|,
name|filePath
argument_list|,
name|lfs
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"{}; file omitted from listFiles listing as expected."
argument_list|,
name|filePath
argument_list|)
expr_stmt|;
specifier|final
name|FileStatus
index|[]
name|fileStatuses
init|=
name|fs
operator|.
name|listStatus
argument_list|(
name|filePath
operator|.
name|getParent
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|FileStatus
name|fileStatus
range|:
name|fileStatuses
control|)
block|{
name|assertNotEquals
argument_list|(
literal|"The tombstone has not been expired, so must not be"
operator|+
literal|" listed."
argument_list|,
name|filePath
argument_list|,
name|fileStatus
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"{}; file omitted from listStatus as expected."
argument_list|,
name|filePath
argument_list|)
expr_stmt|;
block|}
DECL|method|checkListingContainsPath (S3AFileSystem fs, Path filePath)
specifier|private
name|void
name|checkListingContainsPath
parameter_list|(
name|S3AFileSystem
name|fs
parameter_list|,
name|Path
name|filePath
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|RemoteIterator
argument_list|<
name|LocatedFileStatus
argument_list|>
name|listIter
init|=
name|fs
operator|.
name|listFiles
argument_list|(
name|filePath
operator|.
name|getParent
argument_list|()
argument_list|,
literal|false
argument_list|)
decl_stmt|;
while|while
condition|(
name|listIter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
specifier|final
name|LocatedFileStatus
name|lfs
init|=
name|listIter
operator|.
name|next
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
name|filePath
argument_list|,
name|lfs
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|final
name|FileStatus
index|[]
name|fileStatuses
init|=
name|fs
operator|.
name|listStatus
argument_list|(
name|filePath
operator|.
name|getParent
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|FileStatus
name|fileStatus
range|:
name|fileStatuses
control|)
name|assertEquals
argument_list|(
literal|"The file should be listed in fs.listStatus"
argument_list|,
name|filePath
argument_list|,
name|fileStatus
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Perform an out-of-band delete.    * @param testFilePath filename    * @param allowAuthoritative  is the store authoritative    * @throws Exception failure    */
DECL|method|outOfBandDeletes ( final Path testFilePath, final boolean allowAuthoritative)
specifier|private
name|void
name|outOfBandDeletes
parameter_list|(
specifier|final
name|Path
name|testFilePath
parameter_list|,
specifier|final
name|boolean
name|allowAuthoritative
parameter_list|)
throws|throws
name|Exception
block|{
try|try
block|{
comment|// Create initial file
name|String
name|text
init|=
literal|"Hello, World!"
decl_stmt|;
name|writeTextFile
argument_list|(
name|guardedFs
argument_list|,
name|testFilePath
argument_list|,
name|text
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|awaitFileStatus
argument_list|(
name|rawFS
argument_list|,
name|testFilePath
argument_list|)
expr_stmt|;
comment|// Delete the file without S3Guard (raw)
name|deleteFile
argument_list|(
name|rawFS
argument_list|,
name|testFilePath
argument_list|)
expr_stmt|;
comment|// The check is the same if s3guard is authoritative and if it's not
comment|// it should be in the ms
name|FileStatus
name|status
init|=
name|guardedFs
operator|.
name|getFileStatus
argument_list|(
name|testFilePath
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Authoritative: {} status path: {}"
argument_list|,
name|allowAuthoritative
argument_list|,
name|status
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
name|expectExceptionWhenReading
argument_list|(
name|testFilePath
argument_list|,
name|text
argument_list|)
expr_stmt|;
name|expectExceptionWhenReadingOpenFileAPI
argument_list|(
name|testFilePath
argument_list|,
name|text
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|guardedFs
operator|.
name|delete
argument_list|(
name|testFilePath
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Overwrite a file out of band.    * @param firstText first text    * @param secondText second text    * @throws Exception failure    */
DECL|method|overwriteFile (String firstText, String secondText)
specifier|private
name|void
name|overwriteFile
parameter_list|(
name|String
name|firstText
parameter_list|,
name|String
name|secondText
parameter_list|)
throws|throws
name|Exception
block|{
name|boolean
name|allowAuthoritative
init|=
name|authoritative
decl_stmt|;
name|Path
name|testFilePath
init|=
name|path
argument_list|(
literal|"OverwriteFileTest-"
operator|+
name|UUID
operator|.
name|randomUUID
argument_list|()
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Allow authoritative param: {}"
argument_list|,
name|allowAuthoritative
argument_list|)
expr_stmt|;
try|try
block|{
comment|// Create initial file
name|writeTextFile
argument_list|(
name|guardedFs
argument_list|,
name|testFilePath
argument_list|,
name|firstText
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|// and cache the value for later
specifier|final
name|FileStatus
name|origStatus
init|=
name|awaitFileStatus
argument_list|(
name|rawFS
argument_list|,
name|testFilePath
argument_list|)
decl_stmt|;
name|waitForDifferentTimestamps
argument_list|()
expr_stmt|;
comment|// Overwrite the file without S3Guard
name|writeTextFile
argument_list|(
name|rawFS
argument_list|,
name|testFilePath
argument_list|,
name|secondText
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|// Read the file and verify the data
name|eventually
argument_list|(
name|STABILIZATION_TIME
argument_list|,
name|PROBE_INTERVAL_MILLIS
argument_list|,
parameter_list|()
lambda|->
block|{
name|FileStatus
name|rawFileStatus
init|=
name|rawFS
operator|.
name|getFileStatus
argument_list|(
name|testFilePath
argument_list|)
decl_stmt|;
specifier|final
name|FileStatus
name|guardedFileStatus
init|=
name|guardedFs
operator|.
name|getFileStatus
argument_list|(
name|testFilePath
argument_list|)
decl_stmt|;
name|verifyFileStatusAsExpected
argument_list|(
name|firstText
argument_list|,
name|secondText
argument_list|,
name|allowAuthoritative
argument_list|,
name|origStatus
argument_list|,
name|rawFileStatus
argument_list|,
name|guardedFileStatus
argument_list|)
expr_stmt|;
block|}
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|guardedFs
operator|.
name|delete
argument_list|(
name|testFilePath
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Assert that an array has a given size; in failure the full string values    * of the array will be included, one per line.    * @param message message for errors.    * @param expected expected length.    * @param array the array to probe    */
DECL|method|assertArraySize ( final String message, final int expected, final T[] array)
specifier|private
parameter_list|<
name|T
parameter_list|>
name|void
name|assertArraySize
parameter_list|(
specifier|final
name|String
name|message
parameter_list|,
specifier|final
name|int
name|expected
parameter_list|,
specifier|final
name|T
index|[]
name|array
parameter_list|)
block|{
if|if
condition|(
name|expected
operator|!=
name|array
operator|.
name|length
condition|)
block|{
comment|// condition is not met, build an error which includes all the entries
name|String
name|listing
init|=
name|Arrays
operator|.
name|stream
argument_list|(
name|array
argument_list|)
operator|.
name|map
argument_list|(
name|Object
operator|::
name|toString
argument_list|)
operator|.
name|collect
argument_list|(
name|Collectors
operator|.
name|joining
argument_list|(
literal|"\n"
argument_list|)
argument_list|)
decl_stmt|;
name|fail
argument_list|(
name|message
operator|+
literal|": expected "
operator|+
name|expected
operator|+
literal|" elements but found "
operator|+
name|array
operator|.
name|length
operator|+
literal|"\n"
operator|+
name|listing
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Overwrite a file, verify that the text is different as is the timestamp.    * There are some pauses in the test to ensure that timestamps are different.    * @param firstText first text to write    * @param secondText second text to write    */
DECL|method|overwriteFileInListing (String firstText, String secondText)
specifier|private
name|void
name|overwriteFileInListing
parameter_list|(
name|String
name|firstText
parameter_list|,
name|String
name|secondText
parameter_list|)
throws|throws
name|Exception
block|{
name|boolean
name|allowAuthoritative
init|=
name|authoritative
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Authoritative mode enabled: {}"
argument_list|,
name|allowAuthoritative
argument_list|)
expr_stmt|;
name|String
name|rUUID
init|=
name|UUID
operator|.
name|randomUUID
argument_list|()
operator|.
name|toString
argument_list|()
decl_stmt|;
name|String
name|testDir
init|=
literal|"dir-"
operator|+
name|rUUID
operator|+
literal|"/"
decl_stmt|;
name|String
name|testFile
init|=
name|testDir
operator|+
literal|"file-1-"
operator|+
name|rUUID
decl_stmt|;
name|Path
name|testDirPath
init|=
name|path
argument_list|(
name|testDir
argument_list|)
decl_stmt|;
name|Path
name|testFilePath
init|=
name|guardedFs
operator|.
name|qualify
argument_list|(
name|path
argument_list|(
name|testFile
argument_list|)
argument_list|)
decl_stmt|;
try|try
block|{
comment|// Create initial statusIterator with guarded ms
name|writeTextFile
argument_list|(
name|guardedFs
argument_list|,
name|testFilePath
argument_list|,
name|firstText
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|// and cache the value for later
specifier|final
name|S3AFileStatus
name|origStatus
init|=
name|awaitFileStatus
argument_list|(
name|rawFS
argument_list|,
name|testFilePath
argument_list|)
decl_stmt|;
name|assertNotNull
argument_list|(
literal|"No etag in raw status "
operator|+
name|origStatus
argument_list|,
name|origStatus
operator|.
name|getETag
argument_list|()
argument_list|)
expr_stmt|;
comment|// Do a listing to cache the lists. Should be authoritative if it's set.
specifier|final
name|S3AFileStatus
index|[]
name|origList
init|=
operator|(
name|S3AFileStatus
index|[]
operator|)
name|guardedFs
operator|.
name|listStatus
argument_list|(
name|testDirPath
argument_list|)
decl_stmt|;
name|assertArraySize
argument_list|(
literal|"Added one file to the new dir, so the number of "
operator|+
literal|"files in the dir should be one."
argument_list|,
literal|1
argument_list|,
name|origList
argument_list|)
expr_stmt|;
name|S3AFileStatus
name|origGuardedFileStatus
init|=
name|origList
index|[
literal|0
index|]
decl_stmt|;
name|assertNotNull
argument_list|(
literal|"No etag in origGuardedFileStatus"
operator|+
name|origGuardedFileStatus
argument_list|,
name|origGuardedFileStatus
operator|.
name|getETag
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|DirListingMetadata
name|dirListingMetadata
init|=
name|realMs
operator|.
name|listChildren
argument_list|(
name|guardedFs
operator|.
name|qualify
argument_list|(
name|testDirPath
argument_list|)
argument_list|)
decl_stmt|;
name|assertListingAuthority
argument_list|(
name|allowAuthoritative
argument_list|,
name|dirListingMetadata
argument_list|)
expr_stmt|;
comment|// a brief pause to guarantee timestamps are different.
name|waitForDifferentTimestamps
argument_list|()
expr_stmt|;
comment|// Update file with second text without S3Guard (raw)
name|deleteFile
argument_list|(
name|rawFS
argument_list|,
name|testFilePath
argument_list|)
expr_stmt|;
comment|// write to the test path with the second text
name|writeTextFile
argument_list|(
name|rawFS
argument_list|,
name|testFilePath
argument_list|,
name|secondText
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|// and await it becoming visible again.
specifier|final
name|FileStatus
name|rawFileStatus
init|=
name|awaitFileStatus
argument_list|(
name|rawFS
argument_list|,
name|testFilePath
argument_list|)
decl_stmt|;
comment|// check listing in guarded store.
specifier|final
name|S3AFileStatus
index|[]
name|modList
init|=
operator|(
name|S3AFileStatus
index|[]
operator|)
name|guardedFs
operator|.
name|listStatus
argument_list|(
name|testDirPath
argument_list|)
decl_stmt|;
name|assertArraySize
argument_list|(
literal|"Added one file to the new dir then modified it, "
operator|+
literal|"so the number of files in the dir should be one."
argument_list|,
literal|1
argument_list|,
name|modList
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"The only file path in the directory listing should be "
operator|+
literal|"equal to the testFilePath."
argument_list|,
name|testFilePath
argument_list|,
name|modList
index|[
literal|0
index|]
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
comment|// Read the file and verify the data
name|eventually
argument_list|(
name|STABILIZATION_TIME
argument_list|,
name|PROBE_INTERVAL_MILLIS
argument_list|,
parameter_list|()
lambda|->
block|{
specifier|final
name|FileStatus
name|guardedFileStatus
init|=
name|guardedFs
operator|.
name|getFileStatus
argument_list|(
name|testFilePath
argument_list|)
decl_stmt|;
name|verifyFileStatusAsExpected
argument_list|(
name|firstText
argument_list|,
name|secondText
argument_list|,
name|allowAuthoritative
argument_list|,
name|origStatus
argument_list|,
name|rawFileStatus
argument_list|,
name|guardedFileStatus
argument_list|)
expr_stmt|;
block|}
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|guardedFs
operator|.
name|delete
argument_list|(
name|testDirPath
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|deleteFile (final S3AFileSystem fs, final Path testFilePath)
specifier|private
name|void
name|deleteFile
parameter_list|(
specifier|final
name|S3AFileSystem
name|fs
parameter_list|,
specifier|final
name|Path
name|testFilePath
parameter_list|)
throws|throws
name|Exception
block|{
name|fs
operator|.
name|delete
argument_list|(
name|testFilePath
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|awaitDeletedFileDisappearance
argument_list|(
name|fs
argument_list|,
name|testFilePath
argument_list|)
expr_stmt|;
block|}
comment|/**    * Verify that the file status of a file which has been overwritten    * is as expected, throwing informative exceptions if not.    * @param firstText text of the first write    * @param secondText text of the second    * @param allowAuthoritative is S3Guard being authoritative    * @param origStatus filestatus of the first written file    * @param rawFileStatus status of the updated file from the raw FS    * @param guardedFileStatus status of the updated file from the guarded FS    */
DECL|method|verifyFileStatusAsExpected (final String firstText, final String secondText, final boolean allowAuthoritative, final FileStatus origStatus, final FileStatus rawFileStatus, final FileStatus guardedFileStatus)
specifier|private
name|void
name|verifyFileStatusAsExpected
parameter_list|(
specifier|final
name|String
name|firstText
parameter_list|,
specifier|final
name|String
name|secondText
parameter_list|,
specifier|final
name|boolean
name|allowAuthoritative
parameter_list|,
specifier|final
name|FileStatus
name|origStatus
parameter_list|,
specifier|final
name|FileStatus
name|rawFileStatus
parameter_list|,
specifier|final
name|FileStatus
name|guardedFileStatus
parameter_list|)
block|{
name|String
name|stats
init|=
literal|"\nRaw: "
operator|+
name|rawFileStatus
operator|.
name|toString
argument_list|()
operator|+
literal|"\nGuarded: "
operator|+
name|guardedFileStatus
operator|.
name|toString
argument_list|()
decl_stmt|;
if|if
condition|(
name|firstText
operator|.
name|length
argument_list|()
operator|!=
name|secondText
operator|.
name|length
argument_list|()
condition|)
block|{
comment|// the file lengths are different, so compare that first.
comment|// it's not going to be brittle to timestamps, and easy to understand
comment|// when there is an error.
comment|// check the file length in the raw FS To verify that status is actually
comment|// stabilized w.r.t the last write.
name|long
name|expectedLength
init|=
name|secondText
operator|.
name|length
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
literal|"Length of raw file status did not match the updated text "
operator|+
name|rawFileStatus
argument_list|,
name|expectedLength
argument_list|,
name|rawFileStatus
operator|.
name|getLen
argument_list|()
argument_list|)
expr_stmt|;
comment|// now compare the lengths of the the raw and guarded files
name|long
name|guardedLength
init|=
name|guardedFileStatus
operator|.
name|getLen
argument_list|()
decl_stmt|;
if|if
condition|(
name|allowAuthoritative
condition|)
block|{
comment|// expect the length to be out of sync
name|assertNotEquals
argument_list|(
literal|"File length in authoritative table with "
operator|+
name|stats
argument_list|,
name|expectedLength
argument_list|,
name|guardedLength
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|assertEquals
argument_list|(
literal|"File length in authoritative table with "
operator|+
name|stats
argument_list|,
name|expectedLength
argument_list|,
name|guardedLength
argument_list|)
expr_stmt|;
block|}
block|}
comment|// check etag. This relies on first and second text being different.
specifier|final
name|S3AFileStatus
name|rawS3AFileStatus
init|=
operator|(
name|S3AFileStatus
operator|)
name|rawFileStatus
decl_stmt|;
specifier|final
name|S3AFileStatus
name|guardedS3AFileStatus
init|=
operator|(
name|S3AFileStatus
operator|)
name|guardedFileStatus
decl_stmt|;
specifier|final
name|S3AFileStatus
name|origS3AFileStatus
init|=
operator|(
name|S3AFileStatus
operator|)
name|origStatus
decl_stmt|;
name|assertNotEquals
argument_list|(
literal|"raw status still no to date with changes"
operator|+
name|stats
argument_list|,
name|origS3AFileStatus
operator|.
name|getETag
argument_list|()
argument_list|,
name|rawS3AFileStatus
operator|.
name|getETag
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|allowAuthoritative
condition|)
block|{
comment|// expect the etag to be out of sync
name|assertNotEquals
argument_list|(
literal|"etag in authoritative table with "
operator|+
name|stats
argument_list|,
name|rawS3AFileStatus
operator|.
name|getETag
argument_list|()
argument_list|,
name|guardedS3AFileStatus
operator|.
name|getETag
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|assertEquals
argument_list|(
literal|"etag in non-authoritative table with "
operator|+
name|stats
argument_list|,
name|rawS3AFileStatus
operator|.
name|getETag
argument_list|()
argument_list|,
name|guardedS3AFileStatus
operator|.
name|getETag
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Next: modification time.
name|long
name|rawModTime
init|=
name|rawFileStatus
operator|.
name|getModificationTime
argument_list|()
decl_stmt|;
name|long
name|guardedModTime
init|=
name|guardedFileStatus
operator|.
name|getModificationTime
argument_list|()
decl_stmt|;
name|assertNotEquals
argument_list|(
literal|"Updated file still has original timestamp\n"
operator|+
literal|" original "
operator|+
name|origStatus
operator|+
name|stats
argument_list|,
name|origStatus
operator|.
name|getModificationTime
argument_list|()
argument_list|,
name|rawModTime
argument_list|)
expr_stmt|;
if|if
condition|(
name|allowAuthoritative
condition|)
block|{
comment|// If authoritative is allowed metadata is not updated, so mod_time
comment|// won't match
name|assertNotEquals
argument_list|(
literal|"Authoritative is enabled, so metadata is not "
operator|+
literal|"updated in ms, so mod_time won't match. Expecting "
operator|+
literal|"different values for raw and guarded filestatus."
operator|+
name|stats
argument_list|,
name|rawModTime
argument_list|,
name|guardedModTime
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// If authoritative is not enabled metadata is updated, mod_time
comment|// will match
name|assertEquals
argument_list|(
literal|"Authoritative is disabled, so metadata is"
operator|+
literal|" updated in ms, so mod_time must match. Expecting "
operator|+
literal|" same values for raw and guarded filestatus."
operator|+
name|stats
argument_list|,
name|rawModTime
argument_list|,
name|guardedModTime
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * A brief pause to guarantee timestamps are different.    * This doesn't have to be as long as a stabilization delay.    */
DECL|method|waitForDifferentTimestamps ()
specifier|private
name|void
name|waitForDifferentTimestamps
parameter_list|()
throws|throws
name|InterruptedException
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|TIMESTAMP_SLEEP
argument_list|)
expr_stmt|;
block|}
comment|/**    * Assert that a listing has the specific authority.    * @param expectAuthoritative expect authority bit of listing    * @param dirListingMetadata listing to check    */
DECL|method|assertListingAuthority (final boolean expectAuthoritative, final DirListingMetadata dirListingMetadata)
specifier|private
name|void
name|assertListingAuthority
parameter_list|(
specifier|final
name|boolean
name|expectAuthoritative
parameter_list|,
specifier|final
name|DirListingMetadata
name|dirListingMetadata
parameter_list|)
block|{
if|if
condition|(
name|expectAuthoritative
condition|)
block|{
name|assertTrue
argument_list|(
literal|"DirListingMeta should be authoritative if authoritative "
operator|+
literal|"mode is enabled."
argument_list|,
name|dirListingMetadata
operator|.
name|isAuthoritative
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|assertFalse
argument_list|(
literal|"DirListingMeta should not be authoritative if "
operator|+
literal|"authoritative mode is disabled."
argument_list|,
name|dirListingMetadata
operator|.
name|isAuthoritative
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Delete a file and use listStatus to build up the S3Guard cache.    */
DECL|method|deleteFileInListing ()
specifier|private
name|void
name|deleteFileInListing
parameter_list|()
throws|throws
name|Exception
block|{
name|boolean
name|allowAuthoritative
init|=
name|authoritative
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Authoritative mode enabled: {}"
argument_list|,
name|allowAuthoritative
argument_list|)
expr_stmt|;
name|String
name|rUUID
init|=
name|UUID
operator|.
name|randomUUID
argument_list|()
operator|.
name|toString
argument_list|()
decl_stmt|;
name|String
name|testDir
init|=
literal|"dir-"
operator|+
name|rUUID
operator|+
literal|"/"
decl_stmt|;
name|String
name|testFile
init|=
name|testDir
operator|+
literal|"file-1-"
operator|+
name|rUUID
decl_stmt|;
name|Path
name|testDirPath
init|=
name|path
argument_list|(
name|testDir
argument_list|)
decl_stmt|;
name|Path
name|testFilePath
init|=
name|guardedFs
operator|.
name|qualify
argument_list|(
name|path
argument_list|(
name|testFile
argument_list|)
argument_list|)
decl_stmt|;
name|String
name|text
init|=
literal|"Some random text"
decl_stmt|;
try|try
block|{
comment|// Create initial statusIterator with real ms
name|writeTextFile
argument_list|(
name|guardedFs
argument_list|,
name|testFilePath
argument_list|,
name|text
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|awaitFileStatus
argument_list|(
name|rawFS
argument_list|,
name|testFilePath
argument_list|)
expr_stmt|;
comment|// Do a listing to cache the lists. Should be authoritative if it's set.
specifier|final
name|FileStatus
index|[]
name|origList
init|=
name|guardedFs
operator|.
name|listStatus
argument_list|(
name|testDirPath
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|"Added one file to the new dir, so the number of "
operator|+
literal|"files in the dir should be one."
argument_list|,
literal|1
argument_list|,
name|origList
operator|.
name|length
argument_list|)
expr_stmt|;
specifier|final
name|DirListingMetadata
name|dirListingMetadata
init|=
name|realMs
operator|.
name|listChildren
argument_list|(
name|guardedFs
operator|.
name|qualify
argument_list|(
name|testDirPath
argument_list|)
argument_list|)
decl_stmt|;
name|assertListingAuthority
argument_list|(
name|allowAuthoritative
argument_list|,
name|dirListingMetadata
argument_list|)
expr_stmt|;
comment|// Delete the file without S3Guard (raw)
name|deleteFile
argument_list|(
name|rawFS
argument_list|,
name|testFilePath
argument_list|)
expr_stmt|;
comment|// File status will be still readable from s3guard
name|FileStatus
name|status
init|=
name|guardedFs
operator|.
name|getFileStatus
argument_list|(
name|testFilePath
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"authoritative: {} status: {}"
argument_list|,
name|allowAuthoritative
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|expectExceptionWhenReading
argument_list|(
name|testFilePath
argument_list|,
name|text
argument_list|)
expr_stmt|;
name|expectExceptionWhenReadingOpenFileAPI
argument_list|(
name|testFilePath
argument_list|,
name|text
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|guardedFs
operator|.
name|delete
argument_list|(
name|testDirPath
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * We expect the read to fail with an FNFE: open will be happy.    * @param testFilePath path of the test file    * @param text the context in the file.    * @throws Exception failure other than the FNFE    */
DECL|method|expectExceptionWhenReading (Path testFilePath, String text)
specifier|private
name|void
name|expectExceptionWhenReading
parameter_list|(
name|Path
name|testFilePath
parameter_list|,
name|String
name|text
parameter_list|)
throws|throws
name|Exception
block|{
try|try
init|(
name|FSDataInputStream
name|in
init|=
name|guardedFs
operator|.
name|open
argument_list|(
name|testFilePath
argument_list|)
init|)
block|{
name|intercept
argument_list|(
name|FileNotFoundException
operator|.
name|class
argument_list|,
parameter_list|()
lambda|->
block|{
name|byte
index|[]
name|bytes
init|=
operator|new
name|byte
index|[
name|text
operator|.
name|length
argument_list|()
index|]
decl_stmt|;
return|return
name|in
operator|.
name|read
argument_list|(
name|bytes
argument_list|,
literal|0
argument_list|,
name|bytes
operator|.
name|length
argument_list|)
return|;
block|}
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * We expect the read to fail with an FNFE: open will be happy.    * @param testFilePath path of the test file    * @param text the context in the file.    * @throws Exception failure other than the FNFE    */
DECL|method|expectExceptionWhenReadingOpenFileAPI ( Path testFilePath, String text)
specifier|private
name|void
name|expectExceptionWhenReadingOpenFileAPI
parameter_list|(
name|Path
name|testFilePath
parameter_list|,
name|String
name|text
parameter_list|)
throws|throws
name|Exception
block|{
try|try
init|(
name|FSDataInputStream
name|in
init|=
name|guardedFs
operator|.
name|openFile
argument_list|(
name|testFilePath
argument_list|)
operator|.
name|build
argument_list|()
operator|.
name|get
argument_list|()
init|)
block|{
name|intercept
argument_list|(
name|FileNotFoundException
operator|.
name|class
argument_list|,
parameter_list|()
lambda|->
block|{
name|byte
index|[]
name|bytes
init|=
operator|new
name|byte
index|[
name|text
operator|.
name|length
argument_list|()
index|]
decl_stmt|;
return|return
name|in
operator|.
name|read
argument_list|(
name|bytes
argument_list|,
literal|0
argument_list|,
name|bytes
operator|.
name|length
argument_list|)
return|;
block|}
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Wait for a deleted file to no longer be visible.    * @param fs filesystem    * @param testFilePath path to query    * @throws Exception failure    */
DECL|method|awaitDeletedFileDisappearance (final S3AFileSystem fs, final Path testFilePath)
specifier|private
name|void
name|awaitDeletedFileDisappearance
parameter_list|(
specifier|final
name|S3AFileSystem
name|fs
parameter_list|,
specifier|final
name|Path
name|testFilePath
parameter_list|)
throws|throws
name|Exception
block|{
name|eventually
argument_list|(
name|STABILIZATION_TIME
argument_list|,
name|PROBE_INTERVAL_MILLIS
argument_list|,
parameter_list|()
lambda|->
name|intercept
argument_list|(
name|FileNotFoundException
operator|.
name|class
argument_list|,
parameter_list|()
lambda|->
name|fs
operator|.
name|getFileStatus
argument_list|(
name|testFilePath
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Wait for a file to be visible.    * @param fs filesystem    * @param testFilePath path to query    * @return the file status.    * @throws Exception failure    */
DECL|method|awaitFileStatus (S3AFileSystem fs, final Path testFilePath)
specifier|private
name|S3AFileStatus
name|awaitFileStatus
parameter_list|(
name|S3AFileSystem
name|fs
parameter_list|,
specifier|final
name|Path
name|testFilePath
parameter_list|)
throws|throws
name|Exception
block|{
return|return
operator|(
name|S3AFileStatus
operator|)
name|eventually
argument_list|(
name|STABILIZATION_TIME
argument_list|,
name|PROBE_INTERVAL_MILLIS
argument_list|,
parameter_list|()
lambda|->
name|fs
operator|.
name|getFileStatus
argument_list|(
name|testFilePath
argument_list|)
argument_list|)
return|;
block|}
DECL|method|createNonRecursive (FileSystem fs, Path path)
specifier|private
name|FSDataOutputStream
name|createNonRecursive
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Path
name|path
parameter_list|)
throws|throws
name|Exception
block|{
return|return
name|fs
operator|.
name|createNonRecursive
argument_list|(
name|path
argument_list|,
literal|false
argument_list|,
literal|4096
argument_list|,
operator|(
name|short
operator|)
literal|3
argument_list|,
operator|(
name|short
operator|)
literal|4096
argument_list|,
literal|null
argument_list|)
return|;
block|}
block|}
end_class

end_unit

