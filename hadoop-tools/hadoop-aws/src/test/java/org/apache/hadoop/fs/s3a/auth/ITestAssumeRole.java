begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements. See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership. The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License. You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.fs.s3a.auth
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|auth
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URI
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|AccessDeniedException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|stream
operator|.
name|IntStream
import|;
end_import

begin_import
import|import
name|com
operator|.
name|amazonaws
operator|.
name|auth
operator|.
name|AWSCredentials
import|;
end_import

begin_import
import|import
name|com
operator|.
name|amazonaws
operator|.
name|services
operator|.
name|securitytoken
operator|.
name|model
operator|.
name|AWSSecurityTokenServiceException
import|;
end_import

begin_import
import|import
name|com
operator|.
name|fasterxml
operator|.
name|jackson
operator|.
name|core
operator|.
name|JsonProcessingException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|assertj
operator|.
name|core
operator|.
name|api
operator|.
name|Assertions
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Test
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang3
operator|.
name|tuple
operator|.
name|Pair
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|LocatedFileStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|contract
operator|.
name|ContractTestUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|AWSBadRequestException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|AbstractS3ATestBase
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|MultipartUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|S3AFileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|S3ATestConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|SimpleAWSCredentialsProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|commit
operator|.
name|CommitConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|commit
operator|.
name|CommitOperations
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|commit
operator|.
name|files
operator|.
name|PendingSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|commit
operator|.
name|files
operator|.
name|SinglePendingCommit
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|s3guard
operator|.
name|S3GuardTool
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|contract
operator|.
name|ContractTestUtils
operator|.
name|touch
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|Constants
operator|.
name|*
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|S3ATestUtils
operator|.
name|*
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|S3AUtils
operator|.
name|*
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|auth
operator|.
name|RoleTestUtils
operator|.
name|*
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|auth
operator|.
name|RoleModel
operator|.
name|*
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|auth
operator|.
name|RolePolicies
operator|.
name|*
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|auth
operator|.
name|RoleTestUtils
operator|.
name|forbidden
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|auth
operator|.
name|RoleTestUtils
operator|.
name|newAssumedRoleConfig
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|s3guard
operator|.
name|S3GuardToolTestHelper
operator|.
name|exec
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|IOUtils
operator|.
name|cleanupWithLogger
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|test
operator|.
name|GenericTestUtils
operator|.
name|assertExceptionContains
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|test
operator|.
name|LambdaTestUtils
operator|.
name|*
import|;
end_import

begin_comment
comment|/**  * Tests use of assumed roles.  * Only run if an assumed role is provided.  */
end_comment

begin_class
annotation|@
name|SuppressWarnings
argument_list|(
block|{
literal|"IOResourceOpenedButNotSafelyClosed"
block|,
literal|"ThrowableNotThrown"
block|}
argument_list|)
DECL|class|ITestAssumeRole
specifier|public
class|class
name|ITestAssumeRole
extends|extends
name|AbstractS3ATestBase
block|{
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|ITestAssumeRole
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|ROOT
specifier|private
specifier|static
specifier|final
name|Path
name|ROOT
init|=
operator|new
name|Path
argument_list|(
literal|"/"
argument_list|)
decl_stmt|;
DECL|field|STATEMENT_ALL_BUCKET_READ_ACCESS
specifier|private
specifier|static
specifier|final
name|Statement
name|STATEMENT_ALL_BUCKET_READ_ACCESS
init|=
name|statement
argument_list|(
literal|true
argument_list|,
name|S3_ALL_BUCKETS
argument_list|,
name|S3_BUCKET_READ_OPERATIONS
argument_list|)
decl_stmt|;
comment|/**    * test URI, built in setup.    */
DECL|field|uri
specifier|private
name|URI
name|uri
decl_stmt|;
comment|/**    * A role FS; if non-null it is closed in teardown.    */
DECL|field|roleFS
specifier|private
name|S3AFileSystem
name|roleFS
decl_stmt|;
comment|/**    * Error code from STS server.    */
DECL|field|VALIDATION_ERROR
specifier|protected
specifier|static
specifier|final
name|String
name|VALIDATION_ERROR
init|=
literal|"ValidationError"
decl_stmt|;
annotation|@
name|Override
DECL|method|setup ()
specifier|public
name|void
name|setup
parameter_list|()
throws|throws
name|Exception
block|{
name|super
operator|.
name|setup
argument_list|()
expr_stmt|;
name|assumeRoleTests
argument_list|()
expr_stmt|;
name|uri
operator|=
operator|new
name|URI
argument_list|(
name|S3ATestConstants
operator|.
name|DEFAULT_CSVTEST_FILE
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|teardown ()
specifier|public
name|void
name|teardown
parameter_list|()
throws|throws
name|Exception
block|{
name|cleanupWithLogger
argument_list|(
name|LOG
argument_list|,
name|roleFS
argument_list|)
expr_stmt|;
name|super
operator|.
name|teardown
argument_list|()
expr_stmt|;
block|}
DECL|method|assumeRoleTests ()
specifier|private
name|void
name|assumeRoleTests
parameter_list|()
block|{
name|assume
argument_list|(
literal|"No ARN for role tests"
argument_list|,
operator|!
name|getAssumedRoleARN
argument_list|()
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|getAssumedRoleARN ()
specifier|private
name|String
name|getAssumedRoleARN
parameter_list|()
block|{
return|return
name|getContract
argument_list|()
operator|.
name|getConf
argument_list|()
operator|.
name|getTrimmed
argument_list|(
name|ASSUMED_ROLE_ARN
argument_list|,
literal|""
argument_list|)
return|;
block|}
comment|/**    * Expect a filesystem to fail to instantiate.    * @param conf config to use    * @param clazz class of exception to expect    * @param text text in exception    * @param<E> type of exception as inferred from clazz    * @return the caught exception if it was of the expected type and contents    * @throws Exception if the exception was the wrong class    */
DECL|method|expectFileSystemCreateFailure ( Configuration conf, Class<E> clazz, String text)
specifier|private
parameter_list|<
name|E
extends|extends
name|Throwable
parameter_list|>
name|E
name|expectFileSystemCreateFailure
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|Class
argument_list|<
name|E
argument_list|>
name|clazz
parameter_list|,
name|String
name|text
parameter_list|)
throws|throws
name|Exception
block|{
return|return
name|interceptClosing
argument_list|(
name|clazz
argument_list|,
name|text
argument_list|,
parameter_list|()
lambda|->
operator|new
name|Path
argument_list|(
name|getFileSystem
argument_list|()
operator|.
name|getUri
argument_list|()
argument_list|)
operator|.
name|getFileSystem
argument_list|(
name|conf
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Test
DECL|method|testCreateCredentialProvider ()
specifier|public
name|void
name|testCreateCredentialProvider
parameter_list|()
throws|throws
name|IOException
block|{
name|describe
argument_list|(
literal|"Create the credential provider"
argument_list|)
expr_stmt|;
name|Configuration
name|conf
init|=
name|createValidRoleConf
argument_list|()
decl_stmt|;
try|try
init|(
name|AssumedRoleCredentialProvider
name|provider
init|=
operator|new
name|AssumedRoleCredentialProvider
argument_list|(
name|uri
argument_list|,
name|conf
argument_list|)
init|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Provider is {}"
argument_list|,
name|provider
argument_list|)
expr_stmt|;
name|AWSCredentials
name|credentials
init|=
name|provider
operator|.
name|getCredentials
argument_list|()
decl_stmt|;
name|assertNotNull
argument_list|(
literal|"Null credentials from "
operator|+
name|provider
argument_list|,
name|credentials
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Test
DECL|method|testCreateCredentialProviderNoURI ()
specifier|public
name|void
name|testCreateCredentialProviderNoURI
parameter_list|()
throws|throws
name|IOException
block|{
name|describe
argument_list|(
literal|"Create the credential provider"
argument_list|)
expr_stmt|;
name|Configuration
name|conf
init|=
name|createValidRoleConf
argument_list|()
decl_stmt|;
try|try
init|(
name|AssumedRoleCredentialProvider
name|provider
init|=
operator|new
name|AssumedRoleCredentialProvider
argument_list|(
literal|null
argument_list|,
name|conf
argument_list|)
init|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Provider is {}"
argument_list|,
name|provider
argument_list|)
expr_stmt|;
name|AWSCredentials
name|credentials
init|=
name|provider
operator|.
name|getCredentials
argument_list|()
decl_stmt|;
name|assertNotNull
argument_list|(
literal|"Null credentials from "
operator|+
name|provider
argument_list|,
name|credentials
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Create a valid role configuration.    * @return a configuration set to use to the role ARN.    * @throws JsonProcessingException problems working with JSON policies.    */
DECL|method|createValidRoleConf ()
specifier|protected
name|Configuration
name|createValidRoleConf
parameter_list|()
throws|throws
name|JsonProcessingException
block|{
name|String
name|roleARN
init|=
name|getAssumedRoleARN
argument_list|()
decl_stmt|;
name|Configuration
name|conf
init|=
operator|new
name|Configuration
argument_list|(
name|getContract
argument_list|()
operator|.
name|getConf
argument_list|()
argument_list|)
decl_stmt|;
name|conf
operator|.
name|set
argument_list|(
name|AWS_CREDENTIALS_PROVIDER
argument_list|,
name|AssumedRoleCredentialProvider
operator|.
name|NAME
argument_list|)
expr_stmt|;
name|conf
operator|.
name|set
argument_list|(
name|ASSUMED_ROLE_ARN
argument_list|,
name|roleARN
argument_list|)
expr_stmt|;
name|conf
operator|.
name|set
argument_list|(
name|ASSUMED_ROLE_SESSION_NAME
argument_list|,
literal|"valid"
argument_list|)
expr_stmt|;
name|conf
operator|.
name|set
argument_list|(
name|ASSUMED_ROLE_SESSION_DURATION
argument_list|,
literal|"45m"
argument_list|)
expr_stmt|;
name|bindRolePolicy
argument_list|(
name|conf
argument_list|,
name|RESTRICTED_POLICY
argument_list|)
expr_stmt|;
return|return
name|conf
return|;
block|}
annotation|@
name|Test
DECL|method|testAssumedInvalidRole ()
specifier|public
name|void
name|testAssumedInvalidRole
parameter_list|()
throws|throws
name|Throwable
block|{
name|Configuration
name|conf
init|=
operator|new
name|Configuration
argument_list|()
decl_stmt|;
name|conf
operator|.
name|set
argument_list|(
name|ASSUMED_ROLE_ARN
argument_list|,
name|ROLE_ARN_EXAMPLE
argument_list|)
expr_stmt|;
name|interceptClosing
argument_list|(
name|AWSSecurityTokenServiceException
operator|.
name|class
argument_list|,
literal|""
argument_list|,
parameter_list|()
lambda|->
operator|new
name|AssumedRoleCredentialProvider
argument_list|(
name|uri
argument_list|,
name|conf
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testAssumeRoleFSBadARN ()
specifier|public
name|void
name|testAssumeRoleFSBadARN
parameter_list|()
throws|throws
name|Exception
block|{
name|describe
argument_list|(
literal|"Attemnpt to create the FS with an invalid ARN"
argument_list|)
expr_stmt|;
name|Configuration
name|conf
init|=
name|createAssumedRoleConfig
argument_list|()
decl_stmt|;
name|conf
operator|.
name|set
argument_list|(
name|ASSUMED_ROLE_ARN
argument_list|,
name|ROLE_ARN_EXAMPLE
argument_list|)
expr_stmt|;
name|expectFileSystemCreateFailure
argument_list|(
name|conf
argument_list|,
name|AccessDeniedException
operator|.
name|class
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testAssumeRoleNoARN ()
specifier|public
name|void
name|testAssumeRoleNoARN
parameter_list|()
throws|throws
name|Exception
block|{
name|describe
argument_list|(
literal|"Attemnpt to create the FS with no ARN"
argument_list|)
expr_stmt|;
name|Configuration
name|conf
init|=
name|createAssumedRoleConfig
argument_list|()
decl_stmt|;
name|conf
operator|.
name|unset
argument_list|(
name|ASSUMED_ROLE_ARN
argument_list|)
expr_stmt|;
name|expectFileSystemCreateFailure
argument_list|(
name|conf
argument_list|,
name|IOException
operator|.
name|class
argument_list|,
name|AssumedRoleCredentialProvider
operator|.
name|E_NO_ROLE
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testAssumeRoleFSBadPolicy ()
specifier|public
name|void
name|testAssumeRoleFSBadPolicy
parameter_list|()
throws|throws
name|Exception
block|{
name|describe
argument_list|(
literal|"Attemnpt to create the FS with malformed JSON"
argument_list|)
expr_stmt|;
name|Configuration
name|conf
init|=
name|createAssumedRoleConfig
argument_list|()
decl_stmt|;
comment|// add some malformed JSON
name|conf
operator|.
name|set
argument_list|(
name|ASSUMED_ROLE_POLICY
argument_list|,
literal|"}"
argument_list|)
expr_stmt|;
name|expectFileSystemCreateFailure
argument_list|(
name|conf
argument_list|,
name|AWSBadRequestException
operator|.
name|class
argument_list|,
literal|"JSON"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testAssumeRoleFSBadPolicy2 ()
specifier|public
name|void
name|testAssumeRoleFSBadPolicy2
parameter_list|()
throws|throws
name|Exception
block|{
name|describe
argument_list|(
literal|"Attempt to create the FS with valid but non-compliant JSON"
argument_list|)
expr_stmt|;
name|Configuration
name|conf
init|=
name|createAssumedRoleConfig
argument_list|()
decl_stmt|;
comment|// add some invalid JSON
name|conf
operator|.
name|set
argument_list|(
name|ASSUMED_ROLE_POLICY
argument_list|,
literal|"{'json':'but not what AWS wants}"
argument_list|)
expr_stmt|;
name|expectFileSystemCreateFailure
argument_list|(
name|conf
argument_list|,
name|AWSBadRequestException
operator|.
name|class
argument_list|,
literal|"Syntax errors in policy"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testAssumeRoleCannotAuthAssumedRole ()
specifier|public
name|void
name|testAssumeRoleCannotAuthAssumedRole
parameter_list|()
throws|throws
name|Exception
block|{
name|describe
argument_list|(
literal|"Assert that you can't use assumed roles to auth assumed roles"
argument_list|)
expr_stmt|;
name|Configuration
name|conf
init|=
name|createAssumedRoleConfig
argument_list|()
decl_stmt|;
name|unsetHadoopCredentialProviders
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|conf
operator|.
name|set
argument_list|(
name|ASSUMED_ROLE_CREDENTIALS_PROVIDER
argument_list|,
name|AssumedRoleCredentialProvider
operator|.
name|NAME
argument_list|)
expr_stmt|;
name|expectFileSystemCreateFailure
argument_list|(
name|conf
argument_list|,
name|IOException
operator|.
name|class
argument_list|,
name|E_FORBIDDEN_AWS_PROVIDER
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testAssumeRoleBadInnerAuth ()
specifier|public
name|void
name|testAssumeRoleBadInnerAuth
parameter_list|()
throws|throws
name|Exception
block|{
name|describe
argument_list|(
literal|"Try to authenticate with a keypair with spaces"
argument_list|)
expr_stmt|;
name|Configuration
name|conf
init|=
name|createAssumedRoleConfig
argument_list|()
decl_stmt|;
name|unsetHadoopCredentialProviders
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|conf
operator|.
name|set
argument_list|(
name|ASSUMED_ROLE_CREDENTIALS_PROVIDER
argument_list|,
name|SimpleAWSCredentialsProvider
operator|.
name|NAME
argument_list|)
expr_stmt|;
name|conf
operator|.
name|set
argument_list|(
name|ACCESS_KEY
argument_list|,
literal|"not valid"
argument_list|)
expr_stmt|;
name|conf
operator|.
name|set
argument_list|(
name|SECRET_KEY
argument_list|,
literal|"not secret"
argument_list|)
expr_stmt|;
name|expectFileSystemCreateFailure
argument_list|(
name|conf
argument_list|,
name|AWSBadRequestException
operator|.
name|class
argument_list|,
literal|"not a valid "
operator|+
literal|"key=value pair (missing equal-sign) in Authorization header"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testAssumeRoleBadInnerAuth2 ()
specifier|public
name|void
name|testAssumeRoleBadInnerAuth2
parameter_list|()
throws|throws
name|Exception
block|{
name|describe
argument_list|(
literal|"Try to authenticate with an invalid keypair"
argument_list|)
expr_stmt|;
name|Configuration
name|conf
init|=
name|createAssumedRoleConfig
argument_list|()
decl_stmt|;
name|unsetHadoopCredentialProviders
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|conf
operator|.
name|set
argument_list|(
name|ASSUMED_ROLE_CREDENTIALS_PROVIDER
argument_list|,
name|SimpleAWSCredentialsProvider
operator|.
name|NAME
argument_list|)
expr_stmt|;
name|conf
operator|.
name|set
argument_list|(
name|ACCESS_KEY
argument_list|,
literal|"notvalid"
argument_list|)
expr_stmt|;
name|conf
operator|.
name|set
argument_list|(
name|SECRET_KEY
argument_list|,
literal|"notsecret"
argument_list|)
expr_stmt|;
name|expectFileSystemCreateFailure
argument_list|(
name|conf
argument_list|,
name|AccessDeniedException
operator|.
name|class
argument_list|,
literal|"The security token included in the request is invalid"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testAssumeRoleBadSession ()
specifier|public
name|void
name|testAssumeRoleBadSession
parameter_list|()
throws|throws
name|Exception
block|{
name|describe
argument_list|(
literal|"Try to authenticate with an invalid session"
argument_list|)
expr_stmt|;
name|Configuration
name|conf
init|=
name|createAssumedRoleConfig
argument_list|()
decl_stmt|;
name|conf
operator|.
name|set
argument_list|(
name|ASSUMED_ROLE_SESSION_NAME
argument_list|,
literal|"Session names cannot hava spaces!"
argument_list|)
expr_stmt|;
name|expectFileSystemCreateFailure
argument_list|(
name|conf
argument_list|,
name|AWSBadRequestException
operator|.
name|class
argument_list|,
literal|"Member must satisfy regular expression pattern"
argument_list|)
expr_stmt|;
block|}
comment|/**    * A duration>1h is forbidden client-side in AWS SDK 1.11.271;    * with the ability to extend durations deployed in March 2018,    * duration checks will need to go server-side, and, presumably,    * later SDKs will remove the client side checks.    * This code exists to see when this happens.    */
annotation|@
name|Test
DECL|method|testAssumeRoleThreeHourSessionDuration ()
specifier|public
name|void
name|testAssumeRoleThreeHourSessionDuration
parameter_list|()
throws|throws
name|Exception
block|{
name|describe
argument_list|(
literal|"Try to authenticate with a long session duration"
argument_list|)
expr_stmt|;
name|Configuration
name|conf
init|=
name|createAssumedRoleConfig
argument_list|()
decl_stmt|;
comment|// add a duration of three hours
name|conf
operator|.
name|setInt
argument_list|(
name|ASSUMED_ROLE_SESSION_DURATION
argument_list|,
literal|3
operator|*
literal|60
operator|*
literal|60
argument_list|)
expr_stmt|;
try|try
block|{
operator|new
name|Path
argument_list|(
name|getFileSystem
argument_list|()
operator|.
name|getUri
argument_list|()
argument_list|)
operator|.
name|getFileSystem
argument_list|(
name|conf
argument_list|)
operator|.
name|close
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Successfully created token of a duration>3h"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|assertExceptionContains
argument_list|(
name|VALIDATION_ERROR
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * A duration>1h is forbidden client-side in AWS SDK 1.11.271;    * with the ability to extend durations deployed in March 2018.    * with the later SDKs, the checks go server-side and    * later SDKs will remove the client side checks.    * This test doesn't look into the details of the exception    * to avoid being too brittle.    */
annotation|@
name|Test
DECL|method|testAssumeRoleThirtySixHourSessionDuration ()
specifier|public
name|void
name|testAssumeRoleThirtySixHourSessionDuration
parameter_list|()
throws|throws
name|Exception
block|{
name|describe
argument_list|(
literal|"Try to authenticate with a long session duration"
argument_list|)
expr_stmt|;
name|Configuration
name|conf
init|=
name|createAssumedRoleConfig
argument_list|()
decl_stmt|;
name|conf
operator|.
name|setInt
argument_list|(
name|ASSUMED_ROLE_SESSION_DURATION
argument_list|,
literal|36
operator|*
literal|60
operator|*
literal|60
argument_list|)
expr_stmt|;
name|IOException
name|ioe
init|=
name|expectFileSystemCreateFailure
argument_list|(
name|conf
argument_list|,
name|IOException
operator|.
name|class
argument_list|,
literal|null
argument_list|)
decl_stmt|;
block|}
comment|/**    * Create the assumed role configuration.    * @return a config bonded to the ARN of the assumed role    */
DECL|method|createAssumedRoleConfig ()
specifier|public
name|Configuration
name|createAssumedRoleConfig
parameter_list|()
block|{
return|return
name|createAssumedRoleConfig
argument_list|(
name|getAssumedRoleARN
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Create a config for an assumed role; it also disables FS caching.    * @param roleARN ARN of role    * @return the new configuration    */
DECL|method|createAssumedRoleConfig (String roleARN)
specifier|private
name|Configuration
name|createAssumedRoleConfig
parameter_list|(
name|String
name|roleARN
parameter_list|)
block|{
return|return
name|newAssumedRoleConfig
argument_list|(
name|getContract
argument_list|()
operator|.
name|getConf
argument_list|()
argument_list|,
name|roleARN
argument_list|)
return|;
block|}
annotation|@
name|Test
DECL|method|testAssumeRoleUndefined ()
specifier|public
name|void
name|testAssumeRoleUndefined
parameter_list|()
throws|throws
name|Throwable
block|{
name|describe
argument_list|(
literal|"Verify that you cannot instantiate the"
operator|+
literal|" AssumedRoleCredentialProvider without a role ARN"
argument_list|)
expr_stmt|;
name|Configuration
name|conf
init|=
operator|new
name|Configuration
argument_list|()
decl_stmt|;
name|conf
operator|.
name|set
argument_list|(
name|ASSUMED_ROLE_ARN
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|interceptClosing
argument_list|(
name|IOException
operator|.
name|class
argument_list|,
name|AssumedRoleCredentialProvider
operator|.
name|E_NO_ROLE
argument_list|,
parameter_list|()
lambda|->
operator|new
name|AssumedRoleCredentialProvider
argument_list|(
name|uri
argument_list|,
name|conf
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testAssumedIllegalDuration ()
specifier|public
name|void
name|testAssumedIllegalDuration
parameter_list|()
throws|throws
name|Throwable
block|{
name|describe
argument_list|(
literal|"Expect the constructor to fail if the session is to short"
argument_list|)
expr_stmt|;
name|Configuration
name|conf
init|=
operator|new
name|Configuration
argument_list|()
decl_stmt|;
name|conf
operator|.
name|set
argument_list|(
name|ASSUMED_ROLE_SESSION_DURATION
argument_list|,
literal|"30s"
argument_list|)
expr_stmt|;
name|interceptClosing
argument_list|(
name|AWSSecurityTokenServiceException
operator|.
name|class
argument_list|,
literal|""
argument_list|,
parameter_list|()
lambda|->
operator|new
name|AssumedRoleCredentialProvider
argument_list|(
name|uri
argument_list|,
name|conf
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testAssumeRoleCreateFS ()
specifier|public
name|void
name|testAssumeRoleCreateFS
parameter_list|()
throws|throws
name|IOException
block|{
name|describe
argument_list|(
literal|"Create an FS client with the role and do some basic IO"
argument_list|)
expr_stmt|;
name|String
name|roleARN
init|=
name|getAssumedRoleARN
argument_list|()
decl_stmt|;
name|Configuration
name|conf
init|=
name|createAssumedRoleConfig
argument_list|(
name|roleARN
argument_list|)
decl_stmt|;
name|Path
name|path
init|=
operator|new
name|Path
argument_list|(
name|getFileSystem
argument_list|()
operator|.
name|getUri
argument_list|()
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Creating test FS and user {} with assumed role {}"
argument_list|,
name|conf
operator|.
name|get
argument_list|(
name|ACCESS_KEY
argument_list|)
argument_list|,
name|roleARN
argument_list|)
expr_stmt|;
try|try
init|(
name|FileSystem
name|fs
init|=
name|path
operator|.
name|getFileSystem
argument_list|(
name|conf
argument_list|)
init|)
block|{
name|fs
operator|.
name|getFileStatus
argument_list|(
name|ROOT
argument_list|)
expr_stmt|;
name|fs
operator|.
name|mkdirs
argument_list|(
name|path
argument_list|(
literal|"testAssumeRoleFS"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Test
DECL|method|testAssumeRoleRestrictedPolicyFS ()
specifier|public
name|void
name|testAssumeRoleRestrictedPolicyFS
parameter_list|()
throws|throws
name|Exception
block|{
name|describe
argument_list|(
literal|"Restrict the policy for this session; verify that reads fail."
argument_list|)
expr_stmt|;
comment|// there's some special handling of S3Guard here as operations
comment|// which only go to DDB don't fail the way S3 would reject them.
name|Configuration
name|conf
init|=
name|createAssumedRoleConfig
argument_list|()
decl_stmt|;
name|bindRolePolicy
argument_list|(
name|conf
argument_list|,
name|RESTRICTED_POLICY
argument_list|)
expr_stmt|;
name|Path
name|path
init|=
operator|new
name|Path
argument_list|(
name|getFileSystem
argument_list|()
operator|.
name|getUri
argument_list|()
argument_list|)
decl_stmt|;
name|boolean
name|guarded
init|=
name|getFileSystem
argument_list|()
operator|.
name|hasMetadataStore
argument_list|()
decl_stmt|;
try|try
init|(
name|FileSystem
name|fs
init|=
name|path
operator|.
name|getFileSystem
argument_list|(
name|conf
argument_list|)
init|)
block|{
if|if
condition|(
operator|!
name|guarded
condition|)
block|{
comment|// when S3Guard is enabled, the restricted policy still
comment|// permits S3Guard record lookup, so getFileStatus calls
comment|// will work iff the record is in the database.
name|forbidden
argument_list|(
literal|"getFileStatus"
argument_list|,
parameter_list|()
lambda|->
name|fs
operator|.
name|getFileStatus
argument_list|(
name|ROOT
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|forbidden
argument_list|(
literal|""
argument_list|,
parameter_list|()
lambda|->
name|fs
operator|.
name|listStatus
argument_list|(
name|ROOT
argument_list|)
argument_list|)
expr_stmt|;
name|forbidden
argument_list|(
literal|""
argument_list|,
parameter_list|()
lambda|->
name|fs
operator|.
name|mkdirs
argument_list|(
name|path
argument_list|(
literal|"testAssumeRoleFS"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Tighten the extra policy on the assumed role call for torrent access,    * and verify that it blocks all other operations.    * That is: any non empty policy in the assumeRole API call overrides    * all of the policies attached to the role before.    * switches the role instance to only those policies in the    */
annotation|@
name|Test
DECL|method|testAssumeRolePoliciesOverrideRolePerms ()
specifier|public
name|void
name|testAssumeRolePoliciesOverrideRolePerms
parameter_list|()
throws|throws
name|Throwable
block|{
name|describe
argument_list|(
literal|"extra policies in assumed roles need;"
operator|+
literal|" all required policies stated"
argument_list|)
expr_stmt|;
name|Configuration
name|conf
init|=
name|createAssumedRoleConfig
argument_list|()
decl_stmt|;
name|bindRolePolicy
argument_list|(
name|conf
argument_list|,
name|policy
argument_list|(
name|statement
argument_list|(
literal|false
argument_list|,
name|S3_ALL_BUCKETS
argument_list|,
name|S3_GET_OBJECT_TORRENT
argument_list|)
argument_list|,
name|ALLOW_S3_GET_BUCKET_LOCATION
argument_list|,
name|STATEMENT_S3GUARD_CLIENT
argument_list|,
name|STATEMENT_ALLOW_SSE_KMS_RW
argument_list|)
argument_list|)
expr_stmt|;
name|Path
name|path
init|=
name|path
argument_list|(
literal|"testAssumeRoleStillIncludesRolePerms"
argument_list|)
decl_stmt|;
name|roleFS
operator|=
operator|(
name|S3AFileSystem
operator|)
name|path
operator|.
name|getFileSystem
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|assertTouchForbidden
argument_list|(
name|roleFS
argument_list|,
name|path
argument_list|)
expr_stmt|;
block|}
comment|/**    * After blocking all write verbs used by S3A, try to write data (fail)    * and read data (succeed).    * For S3Guard: full DDB RW access is retained.    * SSE-KMS key access is set to decrypt only.    */
annotation|@
name|Test
DECL|method|testReadOnlyOperations ()
specifier|public
name|void
name|testReadOnlyOperations
parameter_list|()
throws|throws
name|Throwable
block|{
name|describe
argument_list|(
literal|"Restrict role to read only"
argument_list|)
expr_stmt|;
name|Configuration
name|conf
init|=
name|createAssumedRoleConfig
argument_list|()
decl_stmt|;
name|bindRolePolicy
argument_list|(
name|conf
argument_list|,
name|policy
argument_list|(
name|statement
argument_list|(
literal|false
argument_list|,
name|S3_ALL_BUCKETS
argument_list|,
name|S3_PATH_WRITE_OPERATIONS
argument_list|)
argument_list|,
name|STATEMENT_ALL_S3
argument_list|,
name|STATEMENT_S3GUARD_CLIENT
argument_list|,
name|STATEMENT_ALLOW_SSE_KMS_READ
argument_list|)
argument_list|)
expr_stmt|;
name|Path
name|path
init|=
name|methodPath
argument_list|()
decl_stmt|;
name|roleFS
operator|=
operator|(
name|S3AFileSystem
operator|)
name|path
operator|.
name|getFileSystem
argument_list|(
name|conf
argument_list|)
expr_stmt|;
comment|// list the root path, expect happy
name|roleFS
operator|.
name|listStatus
argument_list|(
name|ROOT
argument_list|)
expr_stmt|;
comment|// touch will fail
name|assertTouchForbidden
argument_list|(
name|roleFS
argument_list|,
name|path
argument_list|)
expr_stmt|;
comment|// you can delete it, because it's not there and getFileStatus() is allowed
name|roleFS
operator|.
name|delete
argument_list|(
name|path
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|//create it with the full FS
name|getFileSystem
argument_list|()
operator|.
name|mkdirs
argument_list|(
name|path
argument_list|)
expr_stmt|;
comment|// and delete will not
name|assertDeleteForbidden
argument_list|(
name|this
operator|.
name|roleFS
argument_list|,
name|path
argument_list|)
expr_stmt|;
comment|// list multipart uploads.
comment|// This is part of the read policy.
name|int
name|counter
init|=
literal|0
decl_stmt|;
name|MultipartUtils
operator|.
name|UploadIterator
name|iterator
init|=
name|roleFS
operator|.
name|listUploads
argument_list|(
literal|"/"
argument_list|)
decl_stmt|;
while|while
condition|(
name|iterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|counter
operator|++
expr_stmt|;
name|iterator
operator|.
name|next
argument_list|()
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Found {} outstanding MPUs"
argument_list|,
name|counter
argument_list|)
expr_stmt|;
block|}
comment|/**    * Write successfully to the directory with full R/W access,    * fail to write or delete data elsewhere.    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"StringConcatenationMissingWhitespace"
argument_list|)
annotation|@
name|Test
DECL|method|testRestrictedWriteSubdir ()
specifier|public
name|void
name|testRestrictedWriteSubdir
parameter_list|()
throws|throws
name|Throwable
block|{
name|describe
argument_list|(
literal|"Attempt writing to paths where a role only has"
operator|+
literal|" write access to a subdir of the bucket"
argument_list|)
expr_stmt|;
name|Path
name|restrictedDir
init|=
name|methodPath
argument_list|()
decl_stmt|;
name|Path
name|child
init|=
operator|new
name|Path
argument_list|(
name|restrictedDir
argument_list|,
literal|"child"
argument_list|)
decl_stmt|;
comment|// the full FS
name|S3AFileSystem
name|fs
init|=
name|getFileSystem
argument_list|()
decl_stmt|;
name|fs
operator|.
name|delete
argument_list|(
name|restrictedDir
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|Configuration
name|conf
init|=
name|createAssumedRoleConfig
argument_list|()
decl_stmt|;
name|bindRolePolicyStatements
argument_list|(
name|conf
argument_list|,
name|STATEMENT_S3GUARD_CLIENT
argument_list|,
name|STATEMENT_ALL_BUCKET_READ_ACCESS
argument_list|,
name|STATEMENT_ALLOW_SSE_KMS_RW
argument_list|,
operator|new
name|Statement
argument_list|(
name|Effects
operator|.
name|Allow
argument_list|)
operator|.
name|addActions
argument_list|(
name|S3_ALL_OPERATIONS
argument_list|)
operator|.
name|addResources
argument_list|(
name|directory
argument_list|(
name|restrictedDir
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|roleFS
operator|=
operator|(
name|S3AFileSystem
operator|)
name|restrictedDir
operator|.
name|getFileSystem
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|roleFS
operator|.
name|getFileStatus
argument_list|(
name|ROOT
argument_list|)
expr_stmt|;
name|roleFS
operator|.
name|mkdirs
argument_list|(
name|restrictedDir
argument_list|)
expr_stmt|;
name|assertIsDirectory
argument_list|(
name|restrictedDir
argument_list|)
expr_stmt|;
comment|// you can create an adjacent child
name|touch
argument_list|(
name|roleFS
argument_list|,
name|child
argument_list|)
expr_stmt|;
name|assertIsFile
argument_list|(
name|child
argument_list|)
expr_stmt|;
comment|// child delete rights
name|ContractTestUtils
operator|.
name|assertDeleted
argument_list|(
name|roleFS
argument_list|,
name|child
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|// parent delete rights
name|ContractTestUtils
operator|.
name|assertDeleted
argument_list|(
name|roleFS
argument_list|,
name|restrictedDir
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|// delete will try to create an empty parent directory marker, and may fail
name|roleFS
operator|.
name|delete
argument_list|(
name|restrictedDir
argument_list|,
literal|false
argument_list|)
expr_stmt|;
comment|// this sibling path has the same prefix as restrictedDir, but is
comment|// adjacent. This verifies that a restrictedDir* pattern isn't matching
comment|// siblings, so granting broader rights
name|Path
name|sibling
init|=
operator|new
name|Path
argument_list|(
name|restrictedDir
operator|.
name|toUri
argument_list|()
operator|+
literal|"sibling"
argument_list|)
decl_stmt|;
name|touch
argument_list|(
name|fs
argument_list|,
name|sibling
argument_list|)
expr_stmt|;
name|assertTouchForbidden
argument_list|(
name|roleFS
argument_list|,
name|sibling
argument_list|)
expr_stmt|;
name|assertDeleteForbidden
argument_list|(
name|roleFS
argument_list|,
name|sibling
argument_list|)
expr_stmt|;
block|}
DECL|method|methodPath ()
specifier|public
name|Path
name|methodPath
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|path
argument_list|(
name|getMethodName
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Without simulation of STS failures, and with STS overload likely to    * be very rare, there'll be no implicit test coverage of    * {@link AssumedRoleCredentialProvider#operationRetried(String, Exception, int, boolean)}.    * This test simply invokes the callback for both the first and second retry event.    *    * If the handler ever adds more than logging, this test ensures that things    * don't break.    */
annotation|@
name|Test
DECL|method|testAssumedRoleRetryHandler ()
specifier|public
name|void
name|testAssumedRoleRetryHandler
parameter_list|()
throws|throws
name|Throwable
block|{
try|try
init|(
name|AssumedRoleCredentialProvider
name|provider
init|=
operator|new
name|AssumedRoleCredentialProvider
argument_list|(
name|getFileSystem
argument_list|()
operator|.
name|getUri
argument_list|()
argument_list|,
name|createAssumedRoleConfig
argument_list|()
argument_list|)
init|)
block|{
name|provider
operator|.
name|operationRetried
argument_list|(
literal|"retry"
argument_list|,
operator|new
name|IOException
argument_list|(
literal|"failure"
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|provider
operator|.
name|operationRetried
argument_list|(
literal|"retry"
argument_list|,
operator|new
name|IOException
argument_list|(
literal|"failure"
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Test
DECL|method|testRestrictedCommitActions ()
specifier|public
name|void
name|testRestrictedCommitActions
parameter_list|()
throws|throws
name|Throwable
block|{
name|describe
argument_list|(
literal|"Attempt commit operations against a path with restricted rights"
argument_list|)
expr_stmt|;
name|Configuration
name|conf
init|=
name|createAssumedRoleConfig
argument_list|()
decl_stmt|;
name|conf
operator|.
name|setBoolean
argument_list|(
name|CommitConstants
operator|.
name|MAGIC_COMMITTER_ENABLED
argument_list|,
literal|true
argument_list|)
expr_stmt|;
specifier|final
name|int
name|uploadPartSize
init|=
literal|5
operator|*
literal|1024
operator|*
literal|1024
decl_stmt|;
name|Path
name|basePath
init|=
name|methodPath
argument_list|()
decl_stmt|;
name|Path
name|readOnlyDir
init|=
operator|new
name|Path
argument_list|(
name|basePath
argument_list|,
literal|"readOnlyDir"
argument_list|)
decl_stmt|;
name|Path
name|writeableDir
init|=
operator|new
name|Path
argument_list|(
name|basePath
argument_list|,
literal|"writeableDir"
argument_list|)
decl_stmt|;
comment|// the full FS
name|S3AFileSystem
name|fs
init|=
name|getFileSystem
argument_list|()
decl_stmt|;
name|fs
operator|.
name|delete
argument_list|(
name|basePath
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|fs
operator|.
name|mkdirs
argument_list|(
name|readOnlyDir
argument_list|)
expr_stmt|;
name|bindRolePolicyStatements
argument_list|(
name|conf
argument_list|,
name|STATEMENT_S3GUARD_CLIENT
argument_list|,
name|STATEMENT_ALLOW_SSE_KMS_RW
argument_list|,
name|STATEMENT_ALL_BUCKET_READ_ACCESS
argument_list|,
operator|new
name|Statement
argument_list|(
name|Effects
operator|.
name|Allow
argument_list|)
operator|.
name|addActions
argument_list|(
name|S3_PATH_RW_OPERATIONS
argument_list|)
operator|.
name|addResources
argument_list|(
name|directory
argument_list|(
name|writeableDir
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|roleFS
operator|=
operator|(
name|S3AFileSystem
operator|)
name|writeableDir
operator|.
name|getFileSystem
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|CommitOperations
name|fullOperations
init|=
operator|new
name|CommitOperations
argument_list|(
name|fs
argument_list|)
decl_stmt|;
name|CommitOperations
name|operations
init|=
operator|new
name|CommitOperations
argument_list|(
name|roleFS
argument_list|)
decl_stmt|;
name|File
name|localSrc
init|=
name|File
operator|.
name|createTempFile
argument_list|(
literal|"source"
argument_list|,
literal|""
argument_list|)
decl_stmt|;
name|writeCSVData
argument_list|(
name|localSrc
argument_list|)
expr_stmt|;
name|Path
name|uploadDest
init|=
operator|new
name|Path
argument_list|(
name|readOnlyDir
argument_list|,
literal|"restricted.csv"
argument_list|)
decl_stmt|;
name|forbidden
argument_list|(
literal|"initiate MultiPartUpload"
argument_list|,
parameter_list|()
lambda|->
block|{
return|return
name|operations
operator|.
name|uploadFileToPendingCommit
argument_list|(
name|localSrc
argument_list|,
name|uploadDest
argument_list|,
literal|""
argument_list|,
name|uploadPartSize
argument_list|)
return|;
block|}
argument_list|)
expr_stmt|;
comment|// delete the file
name|localSrc
operator|.
name|delete
argument_list|()
expr_stmt|;
comment|// create a directory there
name|localSrc
operator|.
name|mkdirs
argument_list|()
expr_stmt|;
comment|// create some local files and upload them with permissions
name|int
name|range
init|=
literal|2
decl_stmt|;
name|IntStream
operator|.
name|rangeClosed
argument_list|(
literal|1
argument_list|,
name|range
argument_list|)
operator|.
name|parallel
argument_list|()
operator|.
name|forEach
argument_list|(
parameter_list|(
name|i
parameter_list|)
lambda|->
name|eval
argument_list|(
parameter_list|()
lambda|->
block|{
name|String
name|name
operator|=
literal|"part-000"
operator|+
name|i
argument_list|;
name|File
name|src
operator|=
operator|new
name|File
argument_list|(
name|localSrc
argument_list|,
name|name
argument_list|)
argument_list|;
name|Path
name|dest
operator|=
operator|new
name|Path
argument_list|(
name|readOnlyDir
argument_list|,
name|name
argument_list|)
argument_list|;
name|writeCSVData
argument_list|(
name|src
argument_list|)
argument_list|;
name|SinglePendingCommit
name|pending
operator|=
name|fullOperations
operator|.
name|uploadFileToPendingCommit
argument_list|(
name|src
argument_list|,
name|dest
argument_list|,
literal|""
argument_list|,
name|uploadPartSize
argument_list|)
argument_list|;
name|pending
operator|.
name|save
argument_list|(
name|fs
argument_list|,
operator|new
name|Path
argument_list|(
name|readOnlyDir
argument_list|,
name|name
operator|+
name|CommitConstants
operator|.
name|PENDING_SUFFIX
argument_list|)
argument_list|,
literal|true
argument_list|)
argument_list|;
name|assertTrue
argument_list|(
name|src
operator|.
name|delete
argument_list|()
argument_list|)
argument_list|;
block|}
block|)
end_class

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_try
try|try
block|{
comment|// we expect to be able to list all the files here
name|Pair
argument_list|<
name|PendingSet
argument_list|,
name|List
argument_list|<
name|Pair
argument_list|<
name|LocatedFileStatus
argument_list|,
name|IOException
argument_list|>
argument_list|>
argument_list|>
name|pendingCommits
init|=
name|operations
operator|.
name|loadSinglePendingCommits
argument_list|(
name|readOnlyDir
argument_list|,
literal|true
argument_list|)
decl_stmt|;
comment|// all those commits must fail
name|List
argument_list|<
name|SinglePendingCommit
argument_list|>
name|commits
init|=
name|pendingCommits
operator|.
name|getLeft
argument_list|()
operator|.
name|getCommits
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
name|range
argument_list|,
name|commits
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
try|try
init|(
name|CommitOperations
operator|.
name|CommitContext
name|commitContext
init|=
name|operations
operator|.
name|initiateCommitOperation
argument_list|(
name|uploadDest
argument_list|)
init|)
block|{
name|commits
operator|.
name|parallelStream
argument_list|()
operator|.
name|forEach
argument_list|(
parameter_list|(
name|c
parameter_list|)
lambda|->
block|{
name|CommitOperations
operator|.
name|MaybeIOE
name|maybeIOE
init|=
name|commitContext
operator|.
name|commit
argument_list|(
name|c
argument_list|,
literal|"origin"
argument_list|)
decl_stmt|;
name|Path
name|path
init|=
name|c
operator|.
name|destinationPath
argument_list|()
decl_stmt|;
name|assertCommitAccessDenied
argument_list|(
name|path
argument_list|,
name|maybeIOE
argument_list|)
expr_stmt|;
block|}
argument_list|)
expr_stmt|;
block|}
comment|// fail of all list and abort of .pending files.
name|LOG
operator|.
name|info
argument_list|(
literal|"abortAllSinglePendingCommits({})"
argument_list|,
name|readOnlyDir
argument_list|)
expr_stmt|;
name|assertCommitAccessDenied
argument_list|(
name|readOnlyDir
argument_list|,
name|operations
operator|.
name|abortAllSinglePendingCommits
argument_list|(
name|readOnlyDir
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
comment|// try writing a magic file
name|Path
name|magicDestPath
init|=
operator|new
name|Path
argument_list|(
name|readOnlyDir
argument_list|,
name|CommitConstants
operator|.
name|MAGIC
operator|+
literal|"/"
operator|+
literal|"magic.txt"
argument_list|)
decl_stmt|;
name|forbidden
argument_list|(
literal|""
argument_list|,
parameter_list|()
lambda|->
block|{
name|touch
argument_list|(
name|roleFS
argument_list|,
name|magicDestPath
argument_list|)
expr_stmt|;
comment|// shouldn't get here; if we do: return the existence of the 0-byte
comment|// dest file.
return|return
name|fs
operator|.
name|getFileStatus
argument_list|(
name|magicDestPath
argument_list|)
return|;
block|}
argument_list|)
expr_stmt|;
comment|// a recursive list and abort is blocked.
name|forbidden
argument_list|(
literal|""
argument_list|,
parameter_list|()
lambda|->
name|operations
operator|.
name|abortPendingUploadsUnderPath
argument_list|(
name|readOnlyDir
argument_list|)
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Cleanup"
argument_list|)
expr_stmt|;
name|fullOperations
operator|.
name|abortPendingUploadsUnderPath
argument_list|(
name|readOnlyDir
argument_list|)
expr_stmt|;
block|}
end_try

begin_comment
unit|}
comment|/**    * Verifies that an operation returning a "MaybeIOE" failed    * with an AccessDeniedException in the maybe instance.    * @param path path operated on    * @param maybeIOE result to inspect    */
end_comment

begin_function
DECL|method|assertCommitAccessDenied (final Path path, final CommitOperations.MaybeIOE maybeIOE)
unit|public
name|void
name|assertCommitAccessDenied
parameter_list|(
specifier|final
name|Path
name|path
parameter_list|,
specifier|final
name|CommitOperations
operator|.
name|MaybeIOE
name|maybeIOE
parameter_list|)
block|{
name|IOException
name|ex
init|=
name|maybeIOE
operator|.
name|getException
argument_list|()
decl_stmt|;
name|assertNotNull
argument_list|(
literal|"no IOE in "
operator|+
name|maybeIOE
operator|+
literal|" for "
operator|+
name|path
argument_list|,
name|ex
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ex
operator|instanceof
name|AccessDeniedException
operator|)
condition|)
block|{
name|ContractTestUtils
operator|.
name|fail
argument_list|(
literal|"Wrong exception class for commit to "
operator|+
name|path
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**    * Write some CSV data to a local file.    * @param localSrc local file    * @throws IOException failure    */
end_comment

begin_function
DECL|method|writeCSVData (final File localSrc)
specifier|public
name|void
name|writeCSVData
parameter_list|(
specifier|final
name|File
name|localSrc
parameter_list|)
throws|throws
name|IOException
block|{
try|try
init|(
name|FileOutputStream
name|fo
init|=
operator|new
name|FileOutputStream
argument_list|(
name|localSrc
argument_list|)
init|)
block|{
name|fo
operator|.
name|write
argument_list|(
literal|"1, true"
operator|.
name|getBytes
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
annotation|@
name|Test
DECL|method|testPartialDelete ()
specifier|public
name|void
name|testPartialDelete
parameter_list|()
throws|throws
name|Throwable
block|{
name|describe
argument_list|(
literal|"delete with part of the child tree read only; multidelete"
argument_list|)
expr_stmt|;
name|executePartialDelete
argument_list|(
name|createAssumedRoleConfig
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
DECL|method|testPartialDeleteSingleDelete ()
specifier|public
name|void
name|testPartialDeleteSingleDelete
parameter_list|()
throws|throws
name|Throwable
block|{
name|describe
argument_list|(
literal|"delete with part of the child tree read only"
argument_list|)
expr_stmt|;
name|executePartialDelete
argument_list|(
name|createAssumedRoleConfig
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**    * Have a directory with full R/W permissions, but then remove    * write access underneath, and try to delete it.    * @param conf FS configuration    * @param singleDelete flag to indicate this is a single delete operation    */
end_comment

begin_function
DECL|method|executePartialDelete (final Configuration conf, final boolean singleDelete)
specifier|public
name|void
name|executePartialDelete
parameter_list|(
specifier|final
name|Configuration
name|conf
parameter_list|,
specifier|final
name|boolean
name|singleDelete
parameter_list|)
throws|throws
name|Exception
block|{
name|conf
operator|.
name|setBoolean
argument_list|(
name|ENABLE_MULTI_DELETE
argument_list|,
operator|!
name|singleDelete
argument_list|)
expr_stmt|;
name|Path
name|destDir
init|=
name|methodPath
argument_list|()
decl_stmt|;
name|Path
name|readOnlyDir
init|=
operator|new
name|Path
argument_list|(
name|destDir
argument_list|,
literal|"readonlyDir"
argument_list|)
decl_stmt|;
comment|// the full FS
name|S3AFileSystem
name|fs
init|=
name|getFileSystem
argument_list|()
decl_stmt|;
name|fs
operator|.
name|delete
argument_list|(
name|destDir
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|bindRolePolicyStatements
argument_list|(
name|conf
argument_list|,
name|STATEMENT_S3GUARD_CLIENT
argument_list|,
name|STATEMENT_ALLOW_SSE_KMS_RW
argument_list|,
name|statement
argument_list|(
literal|true
argument_list|,
name|S3_ALL_BUCKETS
argument_list|,
name|S3_ALL_OPERATIONS
argument_list|)
argument_list|,
operator|new
name|Statement
argument_list|(
name|Effects
operator|.
name|Deny
argument_list|)
operator|.
name|addActions
argument_list|(
name|S3_PATH_WRITE_OPERATIONS
argument_list|)
operator|.
name|addResources
argument_list|(
name|directory
argument_list|(
name|readOnlyDir
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|roleFS
operator|=
operator|(
name|S3AFileSystem
operator|)
name|destDir
operator|.
name|getFileSystem
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|int
name|range
init|=
literal|10
decl_stmt|;
name|touchFiles
argument_list|(
name|fs
argument_list|,
name|readOnlyDir
argument_list|,
name|range
argument_list|)
expr_stmt|;
name|touchFiles
argument_list|(
name|roleFS
argument_list|,
name|destDir
argument_list|,
name|range
argument_list|)
expr_stmt|;
name|forbidden
argument_list|(
literal|""
argument_list|,
parameter_list|()
lambda|->
name|roleFS
operator|.
name|delete
argument_list|(
name|readOnlyDir
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|forbidden
argument_list|(
literal|""
argument_list|,
parameter_list|()
lambda|->
name|roleFS
operator|.
name|delete
argument_list|(
name|destDir
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
comment|// and although you can't delete under the path, if the file doesn't
comment|// exist, the delete call fails fast.
name|Path
name|pathWhichDoesntExist
init|=
operator|new
name|Path
argument_list|(
name|readOnlyDir
argument_list|,
literal|"no-such-path"
argument_list|)
decl_stmt|;
name|assertFalse
argument_list|(
literal|"deleting "
operator|+
name|pathWhichDoesntExist
argument_list|,
name|roleFS
operator|.
name|delete
argument_list|(
name|pathWhichDoesntExist
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**    * Block access to bucket locations and verify that {@code getBucketLocation}    * fails -but that the bucket-info command recovers from this.    */
end_comment

begin_function
annotation|@
name|Test
DECL|method|testBucketLocationForbidden ()
specifier|public
name|void
name|testBucketLocationForbidden
parameter_list|()
throws|throws
name|Throwable
block|{
name|describe
argument_list|(
literal|"Restrict role to read only"
argument_list|)
expr_stmt|;
name|Configuration
name|conf
init|=
name|createAssumedRoleConfig
argument_list|()
decl_stmt|;
comment|// S3Guard is turned off so that it isn't trying to work out
comment|// where any table is.
name|removeBaseAndBucketOverrides
argument_list|(
name|getTestBucketName
argument_list|(
name|conf
argument_list|)
argument_list|,
name|conf
argument_list|,
name|S3_METADATA_STORE_IMPL
argument_list|)
expr_stmt|;
name|bindRolePolicyStatements
argument_list|(
name|conf
argument_list|,
name|STATEMENT_S3GUARD_CLIENT
argument_list|,
name|STATEMENT_ALLOW_SSE_KMS_RW
argument_list|,
name|statement
argument_list|(
literal|true
argument_list|,
name|S3_ALL_BUCKETS
argument_list|,
name|S3_ALL_OPERATIONS
argument_list|)
argument_list|,
name|statement
argument_list|(
literal|false
argument_list|,
name|S3_ALL_BUCKETS
argument_list|,
name|S3_GET_BUCKET_LOCATION
argument_list|)
argument_list|)
expr_stmt|;
name|Path
name|path
init|=
name|methodPath
argument_list|()
decl_stmt|;
name|roleFS
operator|=
operator|(
name|S3AFileSystem
operator|)
name|path
operator|.
name|getFileSystem
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|forbidden
argument_list|(
literal|""
argument_list|,
parameter_list|()
lambda|->
name|roleFS
operator|.
name|getBucketLocation
argument_list|()
argument_list|)
expr_stmt|;
name|S3GuardTool
operator|.
name|BucketInfo
name|infocmd
init|=
operator|new
name|S3GuardTool
operator|.
name|BucketInfo
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|URI
name|fsUri
init|=
name|getFileSystem
argument_list|()
operator|.
name|getUri
argument_list|()
decl_stmt|;
name|String
name|info
init|=
name|exec
argument_list|(
name|infocmd
argument_list|,
name|S3GuardTool
operator|.
name|BucketInfo
operator|.
name|NAME
argument_list|,
name|fsUri
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
name|Assertions
operator|.
name|assertThat
argument_list|(
name|info
argument_list|)
operator|.
name|contains
argument_list|(
name|S3GuardTool
operator|.
name|BucketInfo
operator|.
name|LOCATION_UNKNOWN
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**    * Turn off access to dynamo DB Tags and see how DDB table init copes.    * There's no testing of the codepath other than checking the logs    * - this test does make sure that no regression stops the tag permission    * failures from halting the client    */
end_comment

begin_function
annotation|@
name|Test
DECL|method|testRestrictDDBTagAccess ()
specifier|public
name|void
name|testRestrictDDBTagAccess
parameter_list|()
throws|throws
name|Throwable
block|{
name|describe
argument_list|(
literal|"extra policies in assumed roles need;"
operator|+
literal|" all required policies stated"
argument_list|)
expr_stmt|;
name|Configuration
name|conf
init|=
name|createAssumedRoleConfig
argument_list|()
decl_stmt|;
name|bindRolePolicyStatements
argument_list|(
name|conf
argument_list|,
name|STATEMENT_S3GUARD_CLIENT
argument_list|,
name|STATEMENT_ALLOW_SSE_KMS_RW
argument_list|,
name|STATEMENT_ALL_S3
argument_list|,
operator|new
name|Statement
argument_list|(
name|Effects
operator|.
name|Deny
argument_list|)
operator|.
name|addActions
argument_list|(
name|S3_PATH_RW_OPERATIONS
argument_list|)
operator|.
name|addResources
argument_list|(
name|ALL_DDB_TABLES
argument_list|)
argument_list|)
expr_stmt|;
name|Path
name|path
init|=
name|path
argument_list|(
literal|"testRestrictDDBTagAccess"
argument_list|)
decl_stmt|;
name|roleFS
operator|=
operator|(
name|S3AFileSystem
operator|)
name|path
operator|.
name|getFileSystem
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
end_function

unit|}
end_unit

