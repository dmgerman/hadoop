begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements. See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership. The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License. You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.fs.s3a.auth
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|auth
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URI
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|AccessDeniedException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|stream
operator|.
name|Collectors
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|stream
operator|.
name|IntStream
import|;
end_import

begin_import
import|import
name|com
operator|.
name|amazonaws
operator|.
name|auth
operator|.
name|AWSCredentials
import|;
end_import

begin_import
import|import
name|com
operator|.
name|amazonaws
operator|.
name|services
operator|.
name|securitytoken
operator|.
name|model
operator|.
name|AWSSecurityTokenServiceException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Test
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang3
operator|.
name|tuple
operator|.
name|Pair
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|LocatedFileStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|contract
operator|.
name|ContractTestUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|AWSBadRequestException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|AbstractS3ATestBase
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|MultipartUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|S3AFileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|S3ATestConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|S3AUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|SimpleAWSCredentialsProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|commit
operator|.
name|CommitConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|commit
operator|.
name|CommitOperations
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|commit
operator|.
name|files
operator|.
name|PendingSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|commit
operator|.
name|files
operator|.
name|SinglePendingCommit
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|contract
operator|.
name|ContractTestUtils
operator|.
name|assertRenameOutcome
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|contract
operator|.
name|ContractTestUtils
operator|.
name|touch
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|Constants
operator|.
name|*
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|S3ATestUtils
operator|.
name|*
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|S3AUtils
operator|.
name|*
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|auth
operator|.
name|RoleTestUtils
operator|.
name|*
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|auth
operator|.
name|RoleModel
operator|.
name|*
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|auth
operator|.
name|RolePolicies
operator|.
name|*
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|auth
operator|.
name|RoleTestUtils
operator|.
name|forbidden
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|test
operator|.
name|LambdaTestUtils
operator|.
name|*
import|;
end_import

begin_comment
comment|/**  * Tests use of assumed roles.  * Only run if an assumed role is provided.  */
end_comment

begin_class
annotation|@
name|SuppressWarnings
argument_list|(
block|{
literal|"IOResourceOpenedButNotSafelyClosed"
block|,
literal|"ThrowableNotThrown"
block|}
argument_list|)
DECL|class|ITestAssumeRole
specifier|public
class|class
name|ITestAssumeRole
extends|extends
name|AbstractS3ATestBase
block|{
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|ITestAssumeRole
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|ROOT
specifier|private
specifier|static
specifier|final
name|Path
name|ROOT
init|=
operator|new
name|Path
argument_list|(
literal|"/"
argument_list|)
decl_stmt|;
comment|/**    * test URI, built in setup.    */
DECL|field|uri
specifier|private
name|URI
name|uri
decl_stmt|;
comment|/**    * A role FS; if non-null it is closed in teardown.    */
DECL|field|roleFS
specifier|private
name|S3AFileSystem
name|roleFS
decl_stmt|;
annotation|@
name|Override
DECL|method|setup ()
specifier|public
name|void
name|setup
parameter_list|()
throws|throws
name|Exception
block|{
name|super
operator|.
name|setup
argument_list|()
expr_stmt|;
name|assumeRoleTests
argument_list|()
expr_stmt|;
name|uri
operator|=
operator|new
name|URI
argument_list|(
name|S3ATestConstants
operator|.
name|DEFAULT_CSVTEST_FILE
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|teardown ()
specifier|public
name|void
name|teardown
parameter_list|()
throws|throws
name|Exception
block|{
name|S3AUtils
operator|.
name|closeAll
argument_list|(
name|LOG
argument_list|,
name|roleFS
argument_list|)
expr_stmt|;
name|super
operator|.
name|teardown
argument_list|()
expr_stmt|;
block|}
DECL|method|assumeRoleTests ()
specifier|private
name|void
name|assumeRoleTests
parameter_list|()
block|{
name|assume
argument_list|(
literal|"No ARN for role tests"
argument_list|,
operator|!
name|getAssumedRoleARN
argument_list|()
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|getAssumedRoleARN ()
specifier|private
name|String
name|getAssumedRoleARN
parameter_list|()
block|{
return|return
name|getContract
argument_list|()
operator|.
name|getConf
argument_list|()
operator|.
name|getTrimmed
argument_list|(
name|ASSUMED_ROLE_ARN
argument_list|,
literal|""
argument_list|)
return|;
block|}
comment|/**    * Expect a filesystem to fail to instantiate.    * @param conf config to use    * @param clazz class of exception to expect    * @param text text in exception    * @param<E> type of exception as inferred from clazz    * @throws Exception if the exception was the wrong class    */
DECL|method|expectFileSystemCreateFailure ( Configuration conf, Class<E> clazz, String text)
specifier|private
parameter_list|<
name|E
extends|extends
name|Throwable
parameter_list|>
name|void
name|expectFileSystemCreateFailure
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|Class
argument_list|<
name|E
argument_list|>
name|clazz
parameter_list|,
name|String
name|text
parameter_list|)
throws|throws
name|Exception
block|{
name|interceptClosing
argument_list|(
name|clazz
argument_list|,
name|text
argument_list|,
parameter_list|()
lambda|->
operator|new
name|Path
argument_list|(
name|getFileSystem
argument_list|()
operator|.
name|getUri
argument_list|()
argument_list|)
operator|.
name|getFileSystem
argument_list|(
name|conf
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testCreateCredentialProvider ()
specifier|public
name|void
name|testCreateCredentialProvider
parameter_list|()
throws|throws
name|IOException
block|{
name|describe
argument_list|(
literal|"Create the credential provider"
argument_list|)
expr_stmt|;
name|String
name|roleARN
init|=
name|getAssumedRoleARN
argument_list|()
decl_stmt|;
name|Configuration
name|conf
init|=
operator|new
name|Configuration
argument_list|(
name|getContract
argument_list|()
operator|.
name|getConf
argument_list|()
argument_list|)
decl_stmt|;
name|conf
operator|.
name|set
argument_list|(
name|AWS_CREDENTIALS_PROVIDER
argument_list|,
name|AssumedRoleCredentialProvider
operator|.
name|NAME
argument_list|)
expr_stmt|;
name|conf
operator|.
name|set
argument_list|(
name|ASSUMED_ROLE_ARN
argument_list|,
name|roleARN
argument_list|)
expr_stmt|;
name|conf
operator|.
name|set
argument_list|(
name|ASSUMED_ROLE_SESSION_NAME
argument_list|,
literal|"valid"
argument_list|)
expr_stmt|;
name|conf
operator|.
name|set
argument_list|(
name|ASSUMED_ROLE_SESSION_DURATION
argument_list|,
literal|"45m"
argument_list|)
expr_stmt|;
name|bindRolePolicy
argument_list|(
name|conf
argument_list|,
name|RESTRICTED_POLICY
argument_list|)
expr_stmt|;
try|try
init|(
name|AssumedRoleCredentialProvider
name|provider
init|=
operator|new
name|AssumedRoleCredentialProvider
argument_list|(
name|uri
argument_list|,
name|conf
argument_list|)
init|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Provider is {}"
argument_list|,
name|provider
argument_list|)
expr_stmt|;
name|AWSCredentials
name|credentials
init|=
name|provider
operator|.
name|getCredentials
argument_list|()
decl_stmt|;
name|assertNotNull
argument_list|(
literal|"Null credentials from "
operator|+
name|provider
argument_list|,
name|credentials
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Test
DECL|method|testAssumedInvalidRole ()
specifier|public
name|void
name|testAssumedInvalidRole
parameter_list|()
throws|throws
name|Throwable
block|{
name|Configuration
name|conf
init|=
operator|new
name|Configuration
argument_list|()
decl_stmt|;
name|conf
operator|.
name|set
argument_list|(
name|ASSUMED_ROLE_ARN
argument_list|,
name|ROLE_ARN_EXAMPLE
argument_list|)
expr_stmt|;
name|interceptClosing
argument_list|(
name|AWSSecurityTokenServiceException
operator|.
name|class
argument_list|,
name|E_BAD_ROLE
argument_list|,
parameter_list|()
lambda|->
operator|new
name|AssumedRoleCredentialProvider
argument_list|(
name|uri
argument_list|,
name|conf
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testAssumeRoleFSBadARN ()
specifier|public
name|void
name|testAssumeRoleFSBadARN
parameter_list|()
throws|throws
name|Exception
block|{
name|describe
argument_list|(
literal|"Attemnpt to create the FS with an invalid ARN"
argument_list|)
expr_stmt|;
name|Configuration
name|conf
init|=
name|createAssumedRoleConfig
argument_list|()
decl_stmt|;
name|conf
operator|.
name|set
argument_list|(
name|ASSUMED_ROLE_ARN
argument_list|,
name|ROLE_ARN_EXAMPLE
argument_list|)
expr_stmt|;
name|expectFileSystemCreateFailure
argument_list|(
name|conf
argument_list|,
name|AccessDeniedException
operator|.
name|class
argument_list|,
name|E_BAD_ROLE
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testAssumeRoleNoARN ()
specifier|public
name|void
name|testAssumeRoleNoARN
parameter_list|()
throws|throws
name|Exception
block|{
name|describe
argument_list|(
literal|"Attemnpt to create the FS with no ARN"
argument_list|)
expr_stmt|;
name|Configuration
name|conf
init|=
name|createAssumedRoleConfig
argument_list|()
decl_stmt|;
name|conf
operator|.
name|unset
argument_list|(
name|ASSUMED_ROLE_ARN
argument_list|)
expr_stmt|;
name|expectFileSystemCreateFailure
argument_list|(
name|conf
argument_list|,
name|IOException
operator|.
name|class
argument_list|,
name|AssumedRoleCredentialProvider
operator|.
name|E_NO_ROLE
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testAssumeRoleFSBadPolicy ()
specifier|public
name|void
name|testAssumeRoleFSBadPolicy
parameter_list|()
throws|throws
name|Exception
block|{
name|describe
argument_list|(
literal|"Attemnpt to create the FS with malformed JSON"
argument_list|)
expr_stmt|;
name|Configuration
name|conf
init|=
name|createAssumedRoleConfig
argument_list|()
decl_stmt|;
comment|// add some malformed JSON
name|conf
operator|.
name|set
argument_list|(
name|ASSUMED_ROLE_POLICY
argument_list|,
literal|"}"
argument_list|)
expr_stmt|;
name|expectFileSystemCreateFailure
argument_list|(
name|conf
argument_list|,
name|AWSBadRequestException
operator|.
name|class
argument_list|,
literal|"JSON"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testAssumeRoleFSBadPolicy2 ()
specifier|public
name|void
name|testAssumeRoleFSBadPolicy2
parameter_list|()
throws|throws
name|Exception
block|{
name|describe
argument_list|(
literal|"Attempt to create the FS with valid but non-compliant JSON"
argument_list|)
expr_stmt|;
name|Configuration
name|conf
init|=
name|createAssumedRoleConfig
argument_list|()
decl_stmt|;
comment|// add some invalid JSON
name|conf
operator|.
name|set
argument_list|(
name|ASSUMED_ROLE_POLICY
argument_list|,
literal|"{'json':'but not what AWS wants}"
argument_list|)
expr_stmt|;
name|expectFileSystemCreateFailure
argument_list|(
name|conf
argument_list|,
name|AWSBadRequestException
operator|.
name|class
argument_list|,
literal|"Syntax errors in policy"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testAssumeRoleCannotAuthAssumedRole ()
specifier|public
name|void
name|testAssumeRoleCannotAuthAssumedRole
parameter_list|()
throws|throws
name|Exception
block|{
name|describe
argument_list|(
literal|"Assert that you can't use assumed roles to auth assumed roles"
argument_list|)
expr_stmt|;
name|Configuration
name|conf
init|=
name|createAssumedRoleConfig
argument_list|()
decl_stmt|;
name|conf
operator|.
name|set
argument_list|(
name|ASSUMED_ROLE_CREDENTIALS_PROVIDER
argument_list|,
name|AssumedRoleCredentialProvider
operator|.
name|NAME
argument_list|)
expr_stmt|;
name|expectFileSystemCreateFailure
argument_list|(
name|conf
argument_list|,
name|IOException
operator|.
name|class
argument_list|,
name|AssumedRoleCredentialProvider
operator|.
name|E_FORBIDDEN_PROVIDER
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testAssumeRoleBadInnerAuth ()
specifier|public
name|void
name|testAssumeRoleBadInnerAuth
parameter_list|()
throws|throws
name|Exception
block|{
name|describe
argument_list|(
literal|"Try to authenticate with a keypair with spaces"
argument_list|)
expr_stmt|;
name|Configuration
name|conf
init|=
name|createAssumedRoleConfig
argument_list|()
decl_stmt|;
name|conf
operator|.
name|set
argument_list|(
name|ASSUMED_ROLE_CREDENTIALS_PROVIDER
argument_list|,
name|SimpleAWSCredentialsProvider
operator|.
name|NAME
argument_list|)
expr_stmt|;
name|conf
operator|.
name|set
argument_list|(
name|ACCESS_KEY
argument_list|,
literal|"not valid"
argument_list|)
expr_stmt|;
name|conf
operator|.
name|set
argument_list|(
name|SECRET_KEY
argument_list|,
literal|"not secret"
argument_list|)
expr_stmt|;
name|expectFileSystemCreateFailure
argument_list|(
name|conf
argument_list|,
name|AWSBadRequestException
operator|.
name|class
argument_list|,
literal|"not a valid "
operator|+
literal|"key=value pair (missing equal-sign) in Authorization header"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testAssumeRoleBadInnerAuth2 ()
specifier|public
name|void
name|testAssumeRoleBadInnerAuth2
parameter_list|()
throws|throws
name|Exception
block|{
name|describe
argument_list|(
literal|"Try to authenticate with an invalid keypair"
argument_list|)
expr_stmt|;
name|Configuration
name|conf
init|=
name|createAssumedRoleConfig
argument_list|()
decl_stmt|;
name|conf
operator|.
name|set
argument_list|(
name|ASSUMED_ROLE_CREDENTIALS_PROVIDER
argument_list|,
name|SimpleAWSCredentialsProvider
operator|.
name|NAME
argument_list|)
expr_stmt|;
name|conf
operator|.
name|set
argument_list|(
name|ACCESS_KEY
argument_list|,
literal|"notvalid"
argument_list|)
expr_stmt|;
name|conf
operator|.
name|set
argument_list|(
name|SECRET_KEY
argument_list|,
literal|"notsecret"
argument_list|)
expr_stmt|;
name|expectFileSystemCreateFailure
argument_list|(
name|conf
argument_list|,
name|AccessDeniedException
operator|.
name|class
argument_list|,
literal|"The security token included in the request is invalid"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testAssumeRoleBadSession ()
specifier|public
name|void
name|testAssumeRoleBadSession
parameter_list|()
throws|throws
name|Exception
block|{
name|describe
argument_list|(
literal|"Try to authenticate with an invalid session"
argument_list|)
expr_stmt|;
name|Configuration
name|conf
init|=
name|createAssumedRoleConfig
argument_list|()
decl_stmt|;
name|conf
operator|.
name|set
argument_list|(
name|ASSUMED_ROLE_SESSION_NAME
argument_list|,
literal|"Session names cannot hava spaces!"
argument_list|)
expr_stmt|;
name|expectFileSystemCreateFailure
argument_list|(
name|conf
argument_list|,
name|AWSBadRequestException
operator|.
name|class
argument_list|,
literal|"Member must satisfy regular expression pattern"
argument_list|)
expr_stmt|;
block|}
comment|/**    * Create the assumed role configuration.    * @return a config bonded to the ARN of the assumed role    */
DECL|method|createAssumedRoleConfig ()
specifier|public
name|Configuration
name|createAssumedRoleConfig
parameter_list|()
block|{
return|return
name|createAssumedRoleConfig
argument_list|(
name|getAssumedRoleARN
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Create a config for an assumed role; it also disables FS caching.    * @param roleARN ARN of role    * @return the new configuration    */
DECL|method|createAssumedRoleConfig (String roleARN)
specifier|private
name|Configuration
name|createAssumedRoleConfig
parameter_list|(
name|String
name|roleARN
parameter_list|)
block|{
return|return
name|newAssumedRoleConfig
argument_list|(
name|getContract
argument_list|()
operator|.
name|getConf
argument_list|()
argument_list|,
name|roleARN
argument_list|)
return|;
block|}
annotation|@
name|Test
DECL|method|testAssumeRoleUndefined ()
specifier|public
name|void
name|testAssumeRoleUndefined
parameter_list|()
throws|throws
name|Throwable
block|{
name|describe
argument_list|(
literal|"Verify that you cannot instantiate the"
operator|+
literal|" AssumedRoleCredentialProvider without a role ARN"
argument_list|)
expr_stmt|;
name|Configuration
name|conf
init|=
operator|new
name|Configuration
argument_list|()
decl_stmt|;
name|conf
operator|.
name|set
argument_list|(
name|ASSUMED_ROLE_ARN
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|interceptClosing
argument_list|(
name|IOException
operator|.
name|class
argument_list|,
name|AssumedRoleCredentialProvider
operator|.
name|E_NO_ROLE
argument_list|,
parameter_list|()
lambda|->
operator|new
name|AssumedRoleCredentialProvider
argument_list|(
name|uri
argument_list|,
name|conf
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testAssumedIllegalDuration ()
specifier|public
name|void
name|testAssumedIllegalDuration
parameter_list|()
throws|throws
name|Throwable
block|{
name|describe
argument_list|(
literal|"Expect the constructor to fail if the session is to short"
argument_list|)
expr_stmt|;
name|Configuration
name|conf
init|=
operator|new
name|Configuration
argument_list|()
decl_stmt|;
name|conf
operator|.
name|set
argument_list|(
name|ASSUMED_ROLE_SESSION_DURATION
argument_list|,
literal|"30s"
argument_list|)
expr_stmt|;
name|interceptClosing
argument_list|(
name|IllegalArgumentException
operator|.
name|class
argument_list|,
literal|""
argument_list|,
parameter_list|()
lambda|->
operator|new
name|AssumedRoleCredentialProvider
argument_list|(
name|uri
argument_list|,
name|conf
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testAssumeRoleCreateFS ()
specifier|public
name|void
name|testAssumeRoleCreateFS
parameter_list|()
throws|throws
name|IOException
block|{
name|describe
argument_list|(
literal|"Create an FS client with the role and do some basic IO"
argument_list|)
expr_stmt|;
name|String
name|roleARN
init|=
name|getAssumedRoleARN
argument_list|()
decl_stmt|;
name|Configuration
name|conf
init|=
name|createAssumedRoleConfig
argument_list|(
name|roleARN
argument_list|)
decl_stmt|;
name|Path
name|path
init|=
operator|new
name|Path
argument_list|(
name|getFileSystem
argument_list|()
operator|.
name|getUri
argument_list|()
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Creating test FS and user {} with assumed role {}"
argument_list|,
name|conf
operator|.
name|get
argument_list|(
name|ACCESS_KEY
argument_list|)
argument_list|,
name|roleARN
argument_list|)
expr_stmt|;
try|try
init|(
name|FileSystem
name|fs
init|=
name|path
operator|.
name|getFileSystem
argument_list|(
name|conf
argument_list|)
init|)
block|{
name|fs
operator|.
name|getFileStatus
argument_list|(
operator|new
name|Path
argument_list|(
literal|"/"
argument_list|)
argument_list|)
expr_stmt|;
name|fs
operator|.
name|mkdirs
argument_list|(
name|path
argument_list|(
literal|"testAssumeRoleFS"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Test
DECL|method|testAssumeRoleRestrictedPolicyFS ()
specifier|public
name|void
name|testAssumeRoleRestrictedPolicyFS
parameter_list|()
throws|throws
name|Exception
block|{
name|describe
argument_list|(
literal|"Restrict the policy for this session; verify that reads fail"
argument_list|)
expr_stmt|;
name|Configuration
name|conf
init|=
name|createAssumedRoleConfig
argument_list|()
decl_stmt|;
name|bindRolePolicy
argument_list|(
name|conf
argument_list|,
name|RESTRICTED_POLICY
argument_list|)
expr_stmt|;
name|Path
name|path
init|=
operator|new
name|Path
argument_list|(
name|getFileSystem
argument_list|()
operator|.
name|getUri
argument_list|()
argument_list|)
decl_stmt|;
try|try
init|(
name|FileSystem
name|fs
init|=
name|path
operator|.
name|getFileSystem
argument_list|(
name|conf
argument_list|)
init|)
block|{
name|forbidden
argument_list|(
literal|"getFileStatus"
argument_list|,
parameter_list|()
lambda|->
name|fs
operator|.
name|getFileStatus
argument_list|(
operator|new
name|Path
argument_list|(
literal|"/"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|forbidden
argument_list|(
literal|"getFileStatus"
argument_list|,
parameter_list|()
lambda|->
name|fs
operator|.
name|listStatus
argument_list|(
operator|new
name|Path
argument_list|(
literal|"/"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|forbidden
argument_list|(
literal|"getFileStatus"
argument_list|,
parameter_list|()
lambda|->
name|fs
operator|.
name|mkdirs
argument_list|(
name|path
argument_list|(
literal|"testAssumeRoleFS"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Tighten the extra policy on the assumed role call for torrent access,    * and verify that it blocks all other operations.    * That is: any non empty policy in the assumeRole API call overrides    * all of the policies attached to the role before.    * switches the role instance to only those policies in the    */
annotation|@
name|Test
DECL|method|testAssumeRolePoliciesOverrideRolePerms ()
specifier|public
name|void
name|testAssumeRolePoliciesOverrideRolePerms
parameter_list|()
throws|throws
name|Throwable
block|{
name|describe
argument_list|(
literal|"extra policies in assumed roles need;"
operator|+
literal|" all required policies stated"
argument_list|)
expr_stmt|;
name|Configuration
name|conf
init|=
name|createAssumedRoleConfig
argument_list|()
decl_stmt|;
name|bindRolePolicy
argument_list|(
name|conf
argument_list|,
name|policy
argument_list|(
name|statement
argument_list|(
literal|false
argument_list|,
name|S3_ALL_BUCKETS
argument_list|,
name|S3_GET_OBJECT_TORRENT
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|Path
name|path
init|=
name|path
argument_list|(
literal|"testAssumeRoleStillIncludesRolePerms"
argument_list|)
decl_stmt|;
name|roleFS
operator|=
operator|(
name|S3AFileSystem
operator|)
name|path
operator|.
name|getFileSystem
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|assertTouchForbidden
argument_list|(
name|roleFS
argument_list|,
name|path
argument_list|)
expr_stmt|;
block|}
comment|/**    * After blocking all write verbs used by S3A, try to write data (fail)    * and read data (succeed).    */
annotation|@
name|Test
DECL|method|testReadOnlyOperations ()
specifier|public
name|void
name|testReadOnlyOperations
parameter_list|()
throws|throws
name|Throwable
block|{
name|describe
argument_list|(
literal|"Restrict role to read only"
argument_list|)
expr_stmt|;
name|Configuration
name|conf
init|=
name|createAssumedRoleConfig
argument_list|()
decl_stmt|;
name|bindRolePolicy
argument_list|(
name|conf
argument_list|,
name|policy
argument_list|(
name|statement
argument_list|(
literal|false
argument_list|,
name|S3_ALL_BUCKETS
argument_list|,
name|S3_PATH_WRITE_OPERATIONS
argument_list|)
argument_list|,
name|STATEMENT_ALL_S3
argument_list|,
name|STATEMENT_ALL_DDB
argument_list|)
argument_list|)
expr_stmt|;
name|Path
name|path
init|=
name|methodPath
argument_list|()
decl_stmt|;
name|roleFS
operator|=
operator|(
name|S3AFileSystem
operator|)
name|path
operator|.
name|getFileSystem
argument_list|(
name|conf
argument_list|)
expr_stmt|;
comment|// list the root path, expect happy
name|roleFS
operator|.
name|listStatus
argument_list|(
name|ROOT
argument_list|)
expr_stmt|;
comment|// touch will fail
name|assertTouchForbidden
argument_list|(
name|roleFS
argument_list|,
name|path
argument_list|)
expr_stmt|;
comment|// you can delete it, because it's not there and getFileStatus() is allowed
name|roleFS
operator|.
name|delete
argument_list|(
name|path
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|//create it with the full FS
name|getFileSystem
argument_list|()
operator|.
name|mkdirs
argument_list|(
name|path
argument_list|)
expr_stmt|;
comment|// and delete will not
name|assertDeleteForbidden
argument_list|(
name|this
operator|.
name|roleFS
argument_list|,
name|path
argument_list|)
expr_stmt|;
comment|// list multipart uploads.
comment|// This is part of the read policy.
name|int
name|counter
init|=
literal|0
decl_stmt|;
name|MultipartUtils
operator|.
name|UploadIterator
name|iterator
init|=
name|roleFS
operator|.
name|listUploads
argument_list|(
literal|"/"
argument_list|)
decl_stmt|;
while|while
condition|(
name|iterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|counter
operator|++
expr_stmt|;
name|iterator
operator|.
name|next
argument_list|()
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Found {} outstanding MPUs"
argument_list|,
name|counter
argument_list|)
expr_stmt|;
block|}
comment|/**    * Write successfully to the directory with full R/W access,    * fail to write or delete data elsewhere.    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"StringConcatenationMissingWhitespace"
argument_list|)
annotation|@
name|Test
DECL|method|testRestrictedWriteSubdir ()
specifier|public
name|void
name|testRestrictedWriteSubdir
parameter_list|()
throws|throws
name|Throwable
block|{
name|describe
argument_list|(
literal|"Attempt writing to paths where a role only has"
operator|+
literal|" write access to a subdir of the bucket"
argument_list|)
expr_stmt|;
name|Path
name|restrictedDir
init|=
name|methodPath
argument_list|()
decl_stmt|;
name|Path
name|child
init|=
operator|new
name|Path
argument_list|(
name|restrictedDir
argument_list|,
literal|"child"
argument_list|)
decl_stmt|;
comment|// the full FS
name|S3AFileSystem
name|fs
init|=
name|getFileSystem
argument_list|()
decl_stmt|;
name|fs
operator|.
name|delete
argument_list|(
name|restrictedDir
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|Configuration
name|conf
init|=
name|createAssumedRoleConfig
argument_list|()
decl_stmt|;
name|bindRolePolicyStatements
argument_list|(
name|conf
argument_list|,
name|STATEMENT_ALL_DDB
argument_list|,
name|statement
argument_list|(
literal|true
argument_list|,
name|S3_ALL_BUCKETS
argument_list|,
name|S3_ROOT_READ_OPERATIONS
argument_list|)
argument_list|,
operator|new
name|Statement
argument_list|(
name|Effects
operator|.
name|Allow
argument_list|)
operator|.
name|addActions
argument_list|(
name|S3_ALL_OPERATIONS
argument_list|)
operator|.
name|addResources
argument_list|(
name|directory
argument_list|(
name|restrictedDir
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|roleFS
operator|=
operator|(
name|S3AFileSystem
operator|)
name|restrictedDir
operator|.
name|getFileSystem
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|roleFS
operator|.
name|getFileStatus
argument_list|(
name|ROOT
argument_list|)
expr_stmt|;
name|roleFS
operator|.
name|mkdirs
argument_list|(
name|restrictedDir
argument_list|)
expr_stmt|;
name|assertIsDirectory
argument_list|(
name|restrictedDir
argument_list|)
expr_stmt|;
comment|// you can create an adjacent child
name|touch
argument_list|(
name|roleFS
argument_list|,
name|child
argument_list|)
expr_stmt|;
name|assertIsFile
argument_list|(
name|child
argument_list|)
expr_stmt|;
comment|// child delete rights
name|ContractTestUtils
operator|.
name|assertDeleted
argument_list|(
name|roleFS
argument_list|,
name|child
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|// parent delete rights
name|ContractTestUtils
operator|.
name|assertDeleted
argument_list|(
name|roleFS
argument_list|,
name|restrictedDir
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|// delete will try to create an empty parent directory marker, and may fail
name|roleFS
operator|.
name|delete
argument_list|(
name|restrictedDir
argument_list|,
literal|false
argument_list|)
expr_stmt|;
comment|// this sibling path has the same prefix as restrictedDir, but is
comment|// adjacent. This verifies that a restrictedDir* pattern isn't matching
comment|// siblings, so granting broader rights
name|Path
name|sibling
init|=
operator|new
name|Path
argument_list|(
name|restrictedDir
operator|.
name|toUri
argument_list|()
operator|+
literal|"sibling"
argument_list|)
decl_stmt|;
name|touch
argument_list|(
name|fs
argument_list|,
name|sibling
argument_list|)
expr_stmt|;
name|assertTouchForbidden
argument_list|(
name|roleFS
argument_list|,
name|sibling
argument_list|)
expr_stmt|;
name|assertDeleteForbidden
argument_list|(
name|roleFS
argument_list|,
name|sibling
argument_list|)
expr_stmt|;
block|}
DECL|method|methodPath ()
specifier|public
name|Path
name|methodPath
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|path
argument_list|(
name|getMethodName
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Test
DECL|method|testRestrictedRename ()
specifier|public
name|void
name|testRestrictedRename
parameter_list|()
throws|throws
name|Throwable
block|{
name|describe
argument_list|(
literal|"rename with parent paths not writeable"
argument_list|)
expr_stmt|;
name|executeRestrictedRename
argument_list|(
name|createAssumedRoleConfig
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testRestrictedSingleDeleteRename ()
specifier|public
name|void
name|testRestrictedSingleDeleteRename
parameter_list|()
throws|throws
name|Throwable
block|{
name|describe
argument_list|(
literal|"rename with parent paths not writeable"
operator|+
literal|" and multi-object delete disabled"
argument_list|)
expr_stmt|;
name|Configuration
name|conf
init|=
name|createAssumedRoleConfig
argument_list|()
decl_stmt|;
name|conf
operator|.
name|setBoolean
argument_list|(
name|ENABLE_MULTI_DELETE
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|executeRestrictedRename
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
comment|/**    * Execute a sequence of rename operations.    * @param conf FS configuration    */
DECL|method|executeRestrictedRename (final Configuration conf)
specifier|public
name|void
name|executeRestrictedRename
parameter_list|(
specifier|final
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|Path
name|basePath
init|=
name|methodPath
argument_list|()
decl_stmt|;
name|Path
name|restrictedDir
init|=
operator|new
name|Path
argument_list|(
name|basePath
argument_list|,
literal|"renameSrc"
argument_list|)
decl_stmt|;
name|Path
name|destPath
init|=
operator|new
name|Path
argument_list|(
name|basePath
argument_list|,
literal|"renameDest"
argument_list|)
decl_stmt|;
name|Path
name|child
init|=
operator|new
name|Path
argument_list|(
name|restrictedDir
argument_list|,
literal|"child"
argument_list|)
decl_stmt|;
comment|// the full FS
name|S3AFileSystem
name|fs
init|=
name|getFileSystem
argument_list|()
decl_stmt|;
name|fs
operator|.
name|delete
argument_list|(
name|basePath
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|bindRolePolicyStatements
argument_list|(
name|conf
argument_list|,
name|STATEMENT_ALL_DDB
argument_list|,
name|statement
argument_list|(
literal|true
argument_list|,
name|S3_ALL_BUCKETS
argument_list|,
name|S3_ROOT_READ_OPERATIONS
argument_list|)
argument_list|,
operator|new
name|Statement
argument_list|(
name|Effects
operator|.
name|Allow
argument_list|)
operator|.
name|addActions
argument_list|(
name|S3_PATH_RW_OPERATIONS
argument_list|)
operator|.
name|addResources
argument_list|(
name|directory
argument_list|(
name|restrictedDir
argument_list|)
argument_list|)
operator|.
name|addResources
argument_list|(
name|directory
argument_list|(
name|destPath
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|roleFS
operator|=
operator|(
name|S3AFileSystem
operator|)
name|restrictedDir
operator|.
name|getFileSystem
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|roleFS
operator|.
name|getFileStatus
argument_list|(
name|ROOT
argument_list|)
expr_stmt|;
name|roleFS
operator|.
name|mkdirs
argument_list|(
name|restrictedDir
argument_list|)
expr_stmt|;
comment|// you can create an adjacent child
name|touch
argument_list|(
name|roleFS
argument_list|,
name|child
argument_list|)
expr_stmt|;
name|roleFS
operator|.
name|delete
argument_list|(
name|destPath
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|// as dest doesn't exist, this will map child -> dest
name|assertRenameOutcome
argument_list|(
name|roleFS
argument_list|,
name|child
argument_list|,
name|destPath
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|assertIsFile
argument_list|(
name|destPath
argument_list|)
expr_stmt|;
name|assertIsDirectory
argument_list|(
name|restrictedDir
argument_list|)
expr_stmt|;
name|Path
name|renamedDestPath
init|=
operator|new
name|Path
argument_list|(
name|restrictedDir
argument_list|,
name|destPath
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
name|assertRenameOutcome
argument_list|(
name|roleFS
argument_list|,
name|destPath
argument_list|,
name|restrictedDir
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|assertIsFile
argument_list|(
name|renamedDestPath
argument_list|)
expr_stmt|;
name|roleFS
operator|.
name|delete
argument_list|(
name|restrictedDir
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|roleFS
operator|.
name|delete
argument_list|(
name|destPath
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testRestrictedRenameReadOnlyData ()
specifier|public
name|void
name|testRestrictedRenameReadOnlyData
parameter_list|()
throws|throws
name|Throwable
block|{
name|describe
argument_list|(
literal|"rename with source read only, multidelete"
argument_list|)
expr_stmt|;
name|executeRenameReadOnlyData
argument_list|(
name|createAssumedRoleConfig
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testRestrictedRenameReadOnlySingleDelete ()
specifier|public
name|void
name|testRestrictedRenameReadOnlySingleDelete
parameter_list|()
throws|throws
name|Throwable
block|{
name|describe
argument_list|(
literal|"rename with source read only single delete"
argument_list|)
expr_stmt|;
name|Configuration
name|conf
init|=
name|createAssumedRoleConfig
argument_list|()
decl_stmt|;
name|conf
operator|.
name|setBoolean
argument_list|(
name|ENABLE_MULTI_DELETE
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|executeRenameReadOnlyData
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
comment|/**    * Execute a sequence of rename operations where the source    * data is read only to the client calling rename().    * This will cause the inner delete() operations to fail, whose outcomes    * are explored.    * Multiple files are created (in parallel) for some renames, so exploring    * the outcome on bulk delete calls, including verifying that a    * MultiObjectDeleteException is translated to an AccessDeniedException.    *<ol>    *<li>The exception raised is AccessDeniedException,    *   from single and multi DELETE calls.</li>    *<li>It happens after the COPY. Not ideal, but, well, we can't pretend    *   it's a filesystem forever.</li>    *</ol>    * @param conf FS configuration    */
DECL|method|executeRenameReadOnlyData (final Configuration conf)
specifier|public
name|void
name|executeRenameReadOnlyData
parameter_list|(
specifier|final
name|Configuration
name|conf
parameter_list|)
throws|throws
name|Exception
block|{
name|assume
argument_list|(
literal|"Does not work with S3Guard"
argument_list|,
operator|!
name|getFileSystem
argument_list|()
operator|.
name|hasMetadataStore
argument_list|()
argument_list|)
expr_stmt|;
name|Path
name|basePath
init|=
name|methodPath
argument_list|()
decl_stmt|;
name|Path
name|destDir
init|=
operator|new
name|Path
argument_list|(
name|basePath
argument_list|,
literal|"renameDest"
argument_list|)
decl_stmt|;
name|Path
name|readOnlyDir
init|=
operator|new
name|Path
argument_list|(
name|basePath
argument_list|,
literal|"readonlyDir"
argument_list|)
decl_stmt|;
name|Path
name|readOnlyFile
init|=
operator|new
name|Path
argument_list|(
name|readOnlyDir
argument_list|,
literal|"readonlyChild"
argument_list|)
decl_stmt|;
comment|// the full FS
name|S3AFileSystem
name|fs
init|=
name|getFileSystem
argument_list|()
decl_stmt|;
name|fs
operator|.
name|delete
argument_list|(
name|basePath
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|// this file is readable by the roleFS, but cannot be deleted
name|touch
argument_list|(
name|fs
argument_list|,
name|readOnlyFile
argument_list|)
expr_stmt|;
name|bindRolePolicyStatements
argument_list|(
name|conf
argument_list|,
name|STATEMENT_ALL_DDB
argument_list|,
name|statement
argument_list|(
literal|true
argument_list|,
name|S3_ALL_BUCKETS
argument_list|,
name|S3_ROOT_READ_OPERATIONS
argument_list|)
argument_list|,
operator|new
name|Statement
argument_list|(
name|Effects
operator|.
name|Allow
argument_list|)
operator|.
name|addActions
argument_list|(
name|S3_PATH_RW_OPERATIONS
argument_list|)
operator|.
name|addResources
argument_list|(
name|directory
argument_list|(
name|destDir
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|roleFS
operator|=
operator|(
name|S3AFileSystem
operator|)
name|destDir
operator|.
name|getFileSystem
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|roleFS
operator|.
name|delete
argument_list|(
name|destDir
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|roleFS
operator|.
name|mkdirs
argument_list|(
name|destDir
argument_list|)
expr_stmt|;
comment|// rename will fail in the delete phase
name|forbidden
argument_list|(
name|readOnlyFile
operator|.
name|toString
argument_list|()
argument_list|,
parameter_list|()
lambda|->
name|roleFS
operator|.
name|rename
argument_list|(
name|readOnlyFile
argument_list|,
name|destDir
argument_list|)
argument_list|)
expr_stmt|;
comment|// and the source file is still there
name|assertIsFile
argument_list|(
name|readOnlyFile
argument_list|)
expr_stmt|;
comment|// but so is the copied version, because there's no attempt
comment|// at rollback, or preflight checking on the delete permissions
name|Path
name|renamedFile
init|=
operator|new
name|Path
argument_list|(
name|destDir
argument_list|,
name|readOnlyFile
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
name|assertIsFile
argument_list|(
name|renamedFile
argument_list|)
expr_stmt|;
name|ContractTestUtils
operator|.
name|assertDeleted
argument_list|(
name|roleFS
argument_list|,
name|renamedFile
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|assertFileCount
argument_list|(
literal|"Empty Dest Dir"
argument_list|,
name|roleFS
argument_list|,
name|destDir
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|// create a set of files
comment|// this is done in parallel as it is 10x faster on a long-haul test run.
name|int
name|range
init|=
literal|10
decl_stmt|;
name|touchFiles
argument_list|(
name|fs
argument_list|,
name|readOnlyDir
argument_list|,
name|range
argument_list|)
expr_stmt|;
comment|// don't forget about that original file!
specifier|final
name|long
name|createdFiles
init|=
name|range
operator|+
literal|1
decl_stmt|;
comment|// are they all there?
name|assertFileCount
argument_list|(
literal|"files ready to rename"
argument_list|,
name|roleFS
argument_list|,
name|readOnlyDir
argument_list|,
name|createdFiles
argument_list|)
expr_stmt|;
comment|// try to rename the directory
name|LOG
operator|.
name|info
argument_list|(
literal|"Renaming readonly files {} to {}"
argument_list|,
name|readOnlyDir
argument_list|,
name|destDir
argument_list|)
expr_stmt|;
name|AccessDeniedException
name|ex
init|=
name|forbidden
argument_list|(
literal|""
argument_list|,
parameter_list|()
lambda|->
name|roleFS
operator|.
name|rename
argument_list|(
name|readOnlyDir
argument_list|,
name|destDir
argument_list|)
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Result of renaming read-only files is AccessDeniedException"
argument_list|,
name|ex
argument_list|)
expr_stmt|;
name|assertFileCount
argument_list|(
literal|"files copied to the destination"
argument_list|,
name|roleFS
argument_list|,
name|destDir
argument_list|,
name|createdFiles
argument_list|)
expr_stmt|;
name|assertFileCount
argument_list|(
literal|"files in the source directory"
argument_list|,
name|roleFS
argument_list|,
name|readOnlyDir
argument_list|,
name|createdFiles
argument_list|)
expr_stmt|;
comment|// and finally (so as to avoid the delay of POSTing some more objects,
comment|// delete that r/o source
name|forbidden
argument_list|(
literal|""
argument_list|,
parameter_list|()
lambda|->
name|roleFS
operator|.
name|delete
argument_list|(
name|readOnlyDir
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Parallel-touch a set of files in the destination directory.    * @param fs filesystem    * @param destDir destination    * @param range range 1..range inclusive of files to create.    */
DECL|method|touchFiles (final S3AFileSystem fs, final Path destDir, final int range)
specifier|public
name|void
name|touchFiles
parameter_list|(
specifier|final
name|S3AFileSystem
name|fs
parameter_list|,
specifier|final
name|Path
name|destDir
parameter_list|,
specifier|final
name|int
name|range
parameter_list|)
block|{
name|IntStream
operator|.
name|rangeClosed
argument_list|(
literal|1
argument_list|,
name|range
argument_list|)
operator|.
name|parallel
argument_list|()
operator|.
name|forEach
argument_list|(
parameter_list|(
name|i
parameter_list|)
lambda|->
name|eval
argument_list|(
parameter_list|()
lambda|->
name|touch
argument_list|(
name|fs
argument_list|,
operator|new
name|Path
argument_list|(
name|destDir
argument_list|,
literal|"file-"
operator|+
name|i
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testRestrictedCommitActions ()
specifier|public
name|void
name|testRestrictedCommitActions
parameter_list|()
throws|throws
name|Throwable
block|{
name|describe
argument_list|(
literal|"Attempt commit operations against a path with restricted rights"
argument_list|)
expr_stmt|;
name|Configuration
name|conf
init|=
name|createAssumedRoleConfig
argument_list|()
decl_stmt|;
name|conf
operator|.
name|setBoolean
argument_list|(
name|CommitConstants
operator|.
name|MAGIC_COMMITTER_ENABLED
argument_list|,
literal|true
argument_list|)
expr_stmt|;
specifier|final
name|int
name|uploadPartSize
init|=
literal|5
operator|*
literal|1024
operator|*
literal|1024
decl_stmt|;
name|Path
name|basePath
init|=
name|methodPath
argument_list|()
decl_stmt|;
name|Path
name|readOnlyDir
init|=
operator|new
name|Path
argument_list|(
name|basePath
argument_list|,
literal|"readOnlyDir"
argument_list|)
decl_stmt|;
name|Path
name|writeableDir
init|=
operator|new
name|Path
argument_list|(
name|basePath
argument_list|,
literal|"writeableDir"
argument_list|)
decl_stmt|;
comment|// the full FS
name|S3AFileSystem
name|fs
init|=
name|getFileSystem
argument_list|()
decl_stmt|;
name|fs
operator|.
name|delete
argument_list|(
name|basePath
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|fs
operator|.
name|mkdirs
argument_list|(
name|readOnlyDir
argument_list|)
expr_stmt|;
name|bindRolePolicyStatements
argument_list|(
name|conf
argument_list|,
name|STATEMENT_ALL_DDB
argument_list|,
name|statement
argument_list|(
literal|true
argument_list|,
name|S3_ALL_BUCKETS
argument_list|,
name|S3_ROOT_READ_OPERATIONS
argument_list|)
argument_list|,
operator|new
name|Statement
argument_list|(
name|Effects
operator|.
name|Allow
argument_list|)
operator|.
name|addActions
argument_list|(
name|S3_PATH_RW_OPERATIONS
argument_list|)
operator|.
name|addResources
argument_list|(
name|directory
argument_list|(
name|writeableDir
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|roleFS
operator|=
operator|(
name|S3AFileSystem
operator|)
name|writeableDir
operator|.
name|getFileSystem
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|CommitOperations
name|fullOperations
init|=
operator|new
name|CommitOperations
argument_list|(
name|fs
argument_list|)
decl_stmt|;
name|CommitOperations
name|operations
init|=
operator|new
name|CommitOperations
argument_list|(
name|roleFS
argument_list|)
decl_stmt|;
name|File
name|localSrc
init|=
name|File
operator|.
name|createTempFile
argument_list|(
literal|"source"
argument_list|,
literal|""
argument_list|)
decl_stmt|;
name|writeCSVData
argument_list|(
name|localSrc
argument_list|)
expr_stmt|;
name|Path
name|uploadDest
init|=
operator|new
name|Path
argument_list|(
name|readOnlyDir
argument_list|,
literal|"restricted.csv"
argument_list|)
decl_stmt|;
name|forbidden
argument_list|(
literal|"initiate MultiPartUpload"
argument_list|,
parameter_list|()
lambda|->
block|{
return|return
name|operations
operator|.
name|uploadFileToPendingCommit
argument_list|(
name|localSrc
argument_list|,
name|uploadDest
argument_list|,
literal|""
argument_list|,
name|uploadPartSize
argument_list|)
return|;
block|}
argument_list|)
expr_stmt|;
comment|// delete the file
name|localSrc
operator|.
name|delete
argument_list|()
expr_stmt|;
comment|// create a directory there
name|localSrc
operator|.
name|mkdirs
argument_list|()
expr_stmt|;
comment|// create some local files and upload them with permissions
name|int
name|range
init|=
literal|2
decl_stmt|;
name|IntStream
operator|.
name|rangeClosed
argument_list|(
literal|1
argument_list|,
name|range
argument_list|)
operator|.
name|parallel
argument_list|()
operator|.
name|forEach
argument_list|(
parameter_list|(
name|i
parameter_list|)
lambda|->
name|eval
argument_list|(
parameter_list|()
lambda|->
block|{
name|String
name|name
operator|=
literal|"part-000"
operator|+
name|i
argument_list|;
name|File
name|src
operator|=
operator|new
name|File
argument_list|(
name|localSrc
argument_list|,
name|name
argument_list|)
argument_list|;
name|Path
name|dest
operator|=
operator|new
name|Path
argument_list|(
name|readOnlyDir
argument_list|,
name|name
argument_list|)
argument_list|;
name|writeCSVData
argument_list|(
name|src
argument_list|)
argument_list|;
name|SinglePendingCommit
name|pending
operator|=
name|fullOperations
operator|.
name|uploadFileToPendingCommit
argument_list|(
name|src
argument_list|,
name|dest
argument_list|,
literal|""
argument_list|,
name|uploadPartSize
argument_list|)
argument_list|;
name|pending
operator|.
name|save
argument_list|(
name|fs
argument_list|,
operator|new
name|Path
argument_list|(
name|readOnlyDir
argument_list|,
name|name
operator|+
name|CommitConstants
operator|.
name|PENDING_SUFFIX
argument_list|)
argument_list|,
literal|true
argument_list|)
argument_list|;
name|assertTrue
argument_list|(
name|src
operator|.
name|delete
argument_list|()
argument_list|)
argument_list|;
block|}
block|)
end_class

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_try
try|try
block|{
comment|// we expect to be able to list all the files here
name|Pair
argument_list|<
name|PendingSet
argument_list|,
name|List
argument_list|<
name|Pair
argument_list|<
name|LocatedFileStatus
argument_list|,
name|IOException
argument_list|>
argument_list|>
argument_list|>
name|pendingCommits
init|=
name|operations
operator|.
name|loadSinglePendingCommits
argument_list|(
name|readOnlyDir
argument_list|,
literal|true
argument_list|)
decl_stmt|;
comment|// all those commits must fail
name|List
argument_list|<
name|SinglePendingCommit
argument_list|>
name|commits
init|=
name|pendingCommits
operator|.
name|getLeft
argument_list|()
operator|.
name|getCommits
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
name|range
argument_list|,
name|commits
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|commits
operator|.
name|parallelStream
argument_list|()
operator|.
name|forEach
argument_list|(
parameter_list|(
name|c
parameter_list|)
lambda|->
block|{
name|CommitOperations
operator|.
name|MaybeIOE
name|maybeIOE
init|=
name|operations
operator|.
name|commit
argument_list|(
name|c
argument_list|,
literal|"origin"
argument_list|)
decl_stmt|;
name|Path
name|path
init|=
name|c
operator|.
name|destinationPath
argument_list|()
decl_stmt|;
name|assertCommitAccessDenied
argument_list|(
name|path
argument_list|,
name|maybeIOE
argument_list|)
expr_stmt|;
block|}
argument_list|)
expr_stmt|;
comment|// fail of all list and abort of .pending files.
name|LOG
operator|.
name|info
argument_list|(
literal|"abortAllSinglePendingCommits({})"
argument_list|,
name|readOnlyDir
argument_list|)
expr_stmt|;
name|assertCommitAccessDenied
argument_list|(
name|readOnlyDir
argument_list|,
name|operations
operator|.
name|abortAllSinglePendingCommits
argument_list|(
name|readOnlyDir
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
comment|// try writing a magic file
name|Path
name|magicDestPath
init|=
operator|new
name|Path
argument_list|(
name|readOnlyDir
argument_list|,
name|CommitConstants
operator|.
name|MAGIC
operator|+
literal|"/"
operator|+
literal|"magic.txt"
argument_list|)
decl_stmt|;
name|forbidden
argument_list|(
literal|""
argument_list|,
parameter_list|()
lambda|->
block|{
name|touch
argument_list|(
name|roleFS
argument_list|,
name|magicDestPath
argument_list|)
expr_stmt|;
comment|// shouldn't get here; if we do: return the existence of the 0-byte
comment|// dest file.
return|return
name|fs
operator|.
name|getFileStatus
argument_list|(
name|magicDestPath
argument_list|)
return|;
block|}
argument_list|)
expr_stmt|;
comment|// a recursive list and abort is blocked.
name|forbidden
argument_list|(
literal|""
argument_list|,
parameter_list|()
lambda|->
name|operations
operator|.
name|abortPendingUploadsUnderPath
argument_list|(
name|readOnlyDir
argument_list|)
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Cleanup"
argument_list|)
expr_stmt|;
name|fullOperations
operator|.
name|abortPendingUploadsUnderPath
argument_list|(
name|readOnlyDir
argument_list|)
expr_stmt|;
block|}
end_try

begin_comment
unit|}
comment|/**    * Verifies that an operation returning a "MaybeIOE" failed    * with an AccessDeniedException in the maybe instance.    * @param path path operated on    * @param maybeIOE result to inspect    */
end_comment

begin_function
DECL|method|assertCommitAccessDenied (final Path path, final CommitOperations.MaybeIOE maybeIOE)
unit|public
name|void
name|assertCommitAccessDenied
parameter_list|(
specifier|final
name|Path
name|path
parameter_list|,
specifier|final
name|CommitOperations
operator|.
name|MaybeIOE
name|maybeIOE
parameter_list|)
block|{
name|IOException
name|ex
init|=
name|maybeIOE
operator|.
name|getException
argument_list|()
decl_stmt|;
name|assertNotNull
argument_list|(
literal|"no IOE in "
operator|+
name|maybeIOE
operator|+
literal|" for "
operator|+
name|path
argument_list|,
name|ex
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ex
operator|instanceof
name|AccessDeniedException
operator|)
condition|)
block|{
name|ContractTestUtils
operator|.
name|fail
argument_list|(
literal|"Wrong exception class for commit to "
operator|+
name|path
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**    * Write some CSV data to a local file.    * @param localSrc local file    * @throws IOException failure    */
end_comment

begin_function
DECL|method|writeCSVData (final File localSrc)
specifier|public
name|void
name|writeCSVData
parameter_list|(
specifier|final
name|File
name|localSrc
parameter_list|)
throws|throws
name|IOException
block|{
try|try
init|(
name|FileOutputStream
name|fo
init|=
operator|new
name|FileOutputStream
argument_list|(
name|localSrc
argument_list|)
init|)
block|{
name|fo
operator|.
name|write
argument_list|(
literal|"1, true"
operator|.
name|getBytes
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
annotation|@
name|Test
DECL|method|testPartialDelete ()
specifier|public
name|void
name|testPartialDelete
parameter_list|()
throws|throws
name|Throwable
block|{
name|describe
argument_list|(
literal|"delete with part of the child tree read only; multidelete"
argument_list|)
expr_stmt|;
name|executePartialDelete
argument_list|(
name|createAssumedRoleConfig
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
DECL|method|testPartialDeleteSingleDelete ()
specifier|public
name|void
name|testPartialDeleteSingleDelete
parameter_list|()
throws|throws
name|Throwable
block|{
name|describe
argument_list|(
literal|"delete with part of the child tree read only"
argument_list|)
expr_stmt|;
name|Configuration
name|conf
init|=
name|createAssumedRoleConfig
argument_list|()
decl_stmt|;
name|conf
operator|.
name|setBoolean
argument_list|(
name|ENABLE_MULTI_DELETE
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|executePartialDelete
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**    * Have a directory with full R/W permissions, but then remove    * write access underneath, and try to delete it.    * @param conf FS configuration    */
end_comment

begin_function
DECL|method|executePartialDelete (final Configuration conf)
specifier|public
name|void
name|executePartialDelete
parameter_list|(
specifier|final
name|Configuration
name|conf
parameter_list|)
throws|throws
name|Exception
block|{
name|Path
name|destDir
init|=
name|methodPath
argument_list|()
decl_stmt|;
name|Path
name|readOnlyDir
init|=
operator|new
name|Path
argument_list|(
name|destDir
argument_list|,
literal|"readonlyDir"
argument_list|)
decl_stmt|;
comment|// the full FS
name|S3AFileSystem
name|fs
init|=
name|getFileSystem
argument_list|()
decl_stmt|;
name|fs
operator|.
name|delete
argument_list|(
name|destDir
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|bindRolePolicyStatements
argument_list|(
name|conf
argument_list|,
name|STATEMENT_ALL_DDB
argument_list|,
name|statement
argument_list|(
literal|true
argument_list|,
name|S3_ALL_BUCKETS
argument_list|,
name|S3_ALL_OPERATIONS
argument_list|)
argument_list|,
operator|new
name|Statement
argument_list|(
name|Effects
operator|.
name|Deny
argument_list|)
operator|.
name|addActions
argument_list|(
name|S3_PATH_WRITE_OPERATIONS
argument_list|)
operator|.
name|addResources
argument_list|(
name|directory
argument_list|(
name|readOnlyDir
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|roleFS
operator|=
operator|(
name|S3AFileSystem
operator|)
name|destDir
operator|.
name|getFileSystem
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|int
name|range
init|=
literal|10
decl_stmt|;
name|touchFiles
argument_list|(
name|fs
argument_list|,
name|readOnlyDir
argument_list|,
name|range
argument_list|)
expr_stmt|;
name|touchFiles
argument_list|(
name|roleFS
argument_list|,
name|destDir
argument_list|,
name|range
argument_list|)
expr_stmt|;
name|forbidden
argument_list|(
literal|""
argument_list|,
parameter_list|()
lambda|->
name|roleFS
operator|.
name|delete
argument_list|(
name|readOnlyDir
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|forbidden
argument_list|(
literal|""
argument_list|,
parameter_list|()
lambda|->
name|roleFS
operator|.
name|delete
argument_list|(
name|destDir
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
comment|// and although you can't delete under the path, if the file doesn't
comment|// exist, the delete call fails fast.
name|Path
name|pathWhichDoesntExist
init|=
operator|new
name|Path
argument_list|(
name|readOnlyDir
argument_list|,
literal|"no-such-path"
argument_list|)
decl_stmt|;
name|assertFalse
argument_list|(
literal|"deleting "
operator|+
name|pathWhichDoesntExist
argument_list|,
name|roleFS
operator|.
name|delete
argument_list|(
name|pathWhichDoesntExist
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**    * Assert that the number of files in a destination matches that expected.    * @param text text to use in the message    * @param fs filesystem    * @param path path to list (recursively)    * @param expected expected count    * @throws IOException IO problem    */
end_comment

begin_function
DECL|method|assertFileCount (String text, FileSystem fs, Path path, long expected)
specifier|private
specifier|static
name|void
name|assertFileCount
parameter_list|(
name|String
name|text
parameter_list|,
name|FileSystem
name|fs
parameter_list|,
name|Path
name|path
parameter_list|,
name|long
name|expected
parameter_list|)
throws|throws
name|IOException
block|{
name|List
argument_list|<
name|String
argument_list|>
name|files
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|applyLocatedFiles
argument_list|(
name|fs
operator|.
name|listFiles
argument_list|(
name|path
argument_list|,
literal|true
argument_list|)
argument_list|,
parameter_list|(
name|status
parameter_list|)
lambda|->
name|files
operator|.
name|add
argument_list|(
name|status
operator|.
name|getPath
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|long
name|actual
init|=
name|files
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|actual
operator|!=
name|expected
condition|)
block|{
name|String
name|ls
init|=
name|files
operator|.
name|stream
argument_list|()
operator|.
name|collect
argument_list|(
name|Collectors
operator|.
name|joining
argument_list|(
literal|"\n"
argument_list|)
argument_list|)
decl_stmt|;
name|fail
argument_list|(
name|text
operator|+
literal|": expected "
operator|+
name|expected
operator|+
literal|" files in "
operator|+
name|path
operator|+
literal|" but got "
operator|+
name|actual
operator|+
literal|"\n"
operator|+
name|ls
argument_list|)
expr_stmt|;
block|}
block|}
end_function

unit|}
end_unit

