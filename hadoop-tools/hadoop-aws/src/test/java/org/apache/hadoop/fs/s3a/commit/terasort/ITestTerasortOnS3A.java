begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.fs.s3a.commit.terasort
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|commit
operator|.
name|terasort
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileNotFoundException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|StandardCharsets
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Optional
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|Consumer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Assume
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|FixMethodOrder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Test
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|runner
operator|.
name|RunWith
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|runners
operator|.
name|MethodSorters
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|runners
operator|.
name|Parameterized
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|io
operator|.
name|FileUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|examples
operator|.
name|terasort
operator|.
name|TeraGen
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|examples
operator|.
name|terasort
operator|.
name|TeraSort
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|examples
operator|.
name|terasort
operator|.
name|TeraSortConfigKeys
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|examples
operator|.
name|terasort
operator|.
name|TeraValidate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|commit
operator|.
name|AbstractYarnClusterITest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|commit
operator|.
name|magic
operator|.
name|MagicS3GuardCommitter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|commit
operator|.
name|staging
operator|.
name|DirectoryStagingCommitter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|JobConf
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|DurationInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Tool
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|ToolRunner
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|util
operator|.
name|Optional
operator|.
name|empty
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|S3ATestUtils
operator|.
name|lsR
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|commit
operator|.
name|CommitConstants
operator|.
name|MAGIC_COMMITTER_ENABLED
import|;
end_import

begin_comment
comment|/**  * Runs Terasort against S3A.  *  * Parameterized by committer name, using a YARN cluster  * shared across all test runs.  * The tests run in sequence, so each operation is isolated.  * This also means that the test paths are deleted in test  * teardown; shared variables must all be static.  *  * The test is a scale test; for each parameter it takes a few minutes to  * run the full suite.  * Before anyone calls that out as slow: try running the test with the file  * committer.  */
end_comment

begin_class
annotation|@
name|FixMethodOrder
argument_list|(
name|MethodSorters
operator|.
name|NAME_ASCENDING
argument_list|)
annotation|@
name|RunWith
argument_list|(
name|Parameterized
operator|.
name|class
argument_list|)
annotation|@
name|SuppressWarnings
argument_list|(
literal|"StaticNonFinalField"
argument_list|)
DECL|class|ITestTerasortOnS3A
specifier|public
class|class
name|ITestTerasortOnS3A
extends|extends
name|AbstractYarnClusterITest
block|{
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|ITestTerasortOnS3A
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|EXPECTED_PARTITION_COUNT
specifier|public
specifier|static
specifier|final
name|int
name|EXPECTED_PARTITION_COUNT
init|=
literal|10
decl_stmt|;
DECL|field|PARTITION_SAMPLE_SIZE
specifier|public
specifier|static
specifier|final
name|int
name|PARTITION_SAMPLE_SIZE
init|=
literal|1000
decl_stmt|;
DECL|field|ROW_COUNT
specifier|public
specifier|static
specifier|final
name|int
name|ROW_COUNT
init|=
literal|1000
decl_stmt|;
comment|/**    * Duration tracker created in the first of the test cases and closed    * in {@link #test_140_teracomplete()}.    */
DECL|field|terasortDuration
specifier|private
specifier|static
name|Optional
argument_list|<
name|DurationInfo
argument_list|>
name|terasortDuration
init|=
name|empty
argument_list|()
decl_stmt|;
comment|/**    * Tracker of which stages are completed and how long they took.    */
DECL|field|completedStages
specifier|private
specifier|static
name|Map
argument_list|<
name|String
argument_list|,
name|DurationInfo
argument_list|>
name|completedStages
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|/** Name of the committer for this run. */
DECL|field|committerName
specifier|private
specifier|final
name|String
name|committerName
decl_stmt|;
comment|/** Base path for all the terasort input and output paths. */
DECL|field|terasortPath
specifier|private
name|Path
name|terasortPath
decl_stmt|;
comment|/** Input (teragen) path. */
DECL|field|sortInput
specifier|private
name|Path
name|sortInput
decl_stmt|;
comment|/** Path where sorted data goes. */
DECL|field|sortOutput
specifier|private
name|Path
name|sortOutput
decl_stmt|;
comment|/** Path for validated job's output. */
DECL|field|sortValidate
specifier|private
name|Path
name|sortValidate
decl_stmt|;
comment|/**    * Test array for parameterized test runs.    *    * @return the committer binding for this run.    */
annotation|@
name|Parameterized
operator|.
name|Parameters
argument_list|(
name|name
operator|=
literal|"{0}"
argument_list|)
DECL|method|params ()
specifier|public
specifier|static
name|Collection
argument_list|<
name|Object
index|[]
argument_list|>
name|params
parameter_list|()
block|{
return|return
name|Arrays
operator|.
name|asList
argument_list|(
operator|new
name|Object
index|[]
index|[]
block|{
block|{
name|DirectoryStagingCommitter
operator|.
name|NAME
block|}
block|,
block|{
name|MagicS3GuardCommitter
operator|.
name|NAME
block|}
block|}
argument_list|)
return|;
block|}
DECL|method|ITestTerasortOnS3A (final String committerName)
specifier|public
name|ITestTerasortOnS3A
parameter_list|(
specifier|final
name|String
name|committerName
parameter_list|)
block|{
name|this
operator|.
name|committerName
operator|=
name|committerName
expr_stmt|;
block|}
comment|/**    * Not using special paths here.    * @return false    */
annotation|@
name|Override
DECL|method|useInconsistentClient ()
specifier|public
name|boolean
name|useInconsistentClient
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
annotation|@
name|Override
DECL|method|committerName ()
specifier|protected
name|String
name|committerName
parameter_list|()
block|{
return|return
name|committerName
return|;
block|}
annotation|@
name|Override
DECL|method|setup ()
specifier|public
name|void
name|setup
parameter_list|()
throws|throws
name|Exception
block|{
name|super
operator|.
name|setup
argument_list|()
expr_stmt|;
name|requireScaleTestsEnabled
argument_list|()
expr_stmt|;
name|prepareToTerasort
argument_list|()
expr_stmt|;
block|}
comment|/**    * Set up the job conf with the options for terasort chosen by the scale    * options.    * @param conf configuration    */
annotation|@
name|Override
DECL|method|applyCustomConfigOptions (JobConf conf)
specifier|protected
name|void
name|applyCustomConfigOptions
parameter_list|(
name|JobConf
name|conf
parameter_list|)
block|{
comment|// small sample size for faster runs
name|conf
operator|.
name|setBoolean
argument_list|(
name|MAGIC_COMMITTER_ENABLED
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|conf
operator|.
name|setInt
argument_list|(
name|TeraSortConfigKeys
operator|.
name|SAMPLE_SIZE
operator|.
name|key
argument_list|()
argument_list|,
name|getSampleSizeForEachPartition
argument_list|()
argument_list|)
expr_stmt|;
name|conf
operator|.
name|setInt
argument_list|(
name|TeraSortConfigKeys
operator|.
name|NUM_PARTITIONS
operator|.
name|key
argument_list|()
argument_list|,
name|getExpectedPartitionCount
argument_list|()
argument_list|)
expr_stmt|;
name|conf
operator|.
name|setBoolean
argument_list|(
name|TeraSortConfigKeys
operator|.
name|USE_SIMPLE_PARTITIONER
operator|.
name|key
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
DECL|method|getExpectedPartitionCount ()
specifier|private
name|int
name|getExpectedPartitionCount
parameter_list|()
block|{
return|return
name|EXPECTED_PARTITION_COUNT
return|;
block|}
DECL|method|getSampleSizeForEachPartition ()
specifier|private
name|int
name|getSampleSizeForEachPartition
parameter_list|()
block|{
return|return
name|PARTITION_SAMPLE_SIZE
return|;
block|}
DECL|method|getRowCount ()
specifier|protected
name|int
name|getRowCount
parameter_list|()
block|{
return|return
name|ROW_COUNT
return|;
block|}
comment|/**    * Set up the terasort by initializing paths variables    * The paths used must be unique across parameterized runs but    * common across all test cases in a single parameterized run.    */
DECL|method|prepareToTerasort ()
specifier|private
name|void
name|prepareToTerasort
parameter_list|()
block|{
comment|// small sample size for faster runs
name|terasortPath
operator|=
operator|new
name|Path
argument_list|(
literal|"/terasort-"
operator|+
name|committerName
argument_list|)
operator|.
name|makeQualified
argument_list|(
name|getFileSystem
argument_list|()
argument_list|)
expr_stmt|;
name|sortInput
operator|=
operator|new
name|Path
argument_list|(
name|terasortPath
argument_list|,
literal|"sortin"
argument_list|)
expr_stmt|;
name|sortOutput
operator|=
operator|new
name|Path
argument_list|(
name|terasortPath
argument_list|,
literal|"sortout"
argument_list|)
expr_stmt|;
name|sortValidate
operator|=
operator|new
name|Path
argument_list|(
name|terasortPath
argument_list|,
literal|"validate"
argument_list|)
expr_stmt|;
block|}
comment|/**    * Declare that a stage has completed.    * @param stage stage name/key in the map    * @param d duration.    */
DECL|method|completedStage (final String stage, final DurationInfo d)
specifier|private
specifier|static
name|void
name|completedStage
parameter_list|(
specifier|final
name|String
name|stage
parameter_list|,
specifier|final
name|DurationInfo
name|d
parameter_list|)
block|{
name|completedStages
operator|.
name|put
argument_list|(
name|stage
argument_list|,
name|d
argument_list|)
expr_stmt|;
block|}
comment|/**    * Declare a stage which is required for this test case.    * @param stage stage name    */
DECL|method|requireStage (final String stage)
specifier|private
specifier|static
name|void
name|requireStage
parameter_list|(
specifier|final
name|String
name|stage
parameter_list|)
block|{
name|Assume
operator|.
name|assumeTrue
argument_list|(
literal|"Required stage was not completed: "
operator|+
name|stage
argument_list|,
name|completedStages
operator|.
name|get
argument_list|(
name|stage
argument_list|)
operator|!=
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**    * Execute a single stage in the terasort.    * Updates the completed stages map with the stage duration -if successful.    * @param stage Stage name for the stages map.    * @param jobConf job conf    * @param dest destination directory -the _SUCCESS file will be expected here.    * @param tool tool to run.    * @param args args for the tool.    * @param minimumFileCount minimum number of files to have been created    * @throws Exception any failure    */
DECL|method|executeStage ( final String stage, final JobConf jobConf, final Path dest, final Tool tool, final String[] args, final int minimumFileCount)
specifier|private
name|void
name|executeStage
parameter_list|(
specifier|final
name|String
name|stage
parameter_list|,
specifier|final
name|JobConf
name|jobConf
parameter_list|,
specifier|final
name|Path
name|dest
parameter_list|,
specifier|final
name|Tool
name|tool
parameter_list|,
specifier|final
name|String
index|[]
name|args
parameter_list|,
specifier|final
name|int
name|minimumFileCount
parameter_list|)
throws|throws
name|Exception
block|{
name|int
name|result
decl_stmt|;
name|DurationInfo
name|d
init|=
operator|new
name|DurationInfo
argument_list|(
name|LOG
argument_list|,
name|stage
argument_list|)
decl_stmt|;
try|try
block|{
name|result
operator|=
name|ToolRunner
operator|.
name|run
argument_list|(
name|jobConf
argument_list|,
name|tool
argument_list|,
name|args
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|d
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
name|dumpOutputTree
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|stage
operator|+
literal|"("
operator|+
name|StringUtils
operator|.
name|join
argument_list|(
literal|", "
argument_list|,
name|args
argument_list|)
operator|+
literal|")"
operator|+
literal|" failed"
argument_list|,
literal|0
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|validateSuccessFile
argument_list|(
name|dest
argument_list|,
name|committerName
argument_list|()
argument_list|,
name|getFileSystem
argument_list|()
argument_list|,
name|stage
argument_list|,
name|minimumFileCount
argument_list|)
expr_stmt|;
name|completedStage
argument_list|(
name|stage
argument_list|,
name|d
argument_list|)
expr_stmt|;
block|}
comment|/**    * Set up terasort by cleaning out the destination, and note the initial    * time before any of the jobs are executed.    *    * This is executed first<i>for each parameterized run</i>.    * It is where all variables which need to be reset for each run need    * to be reset.    */
annotation|@
name|Test
DECL|method|test_100_terasort_setup ()
specifier|public
name|void
name|test_100_terasort_setup
parameter_list|()
throws|throws
name|Throwable
block|{
name|describe
argument_list|(
literal|"Setting up for a terasort"
argument_list|)
expr_stmt|;
name|getFileSystem
argument_list|()
operator|.
name|delete
argument_list|(
name|terasortPath
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|completedStages
operator|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
expr_stmt|;
name|terasortDuration
operator|=
name|Optional
operator|.
name|of
argument_list|(
operator|new
name|DurationInfo
argument_list|(
name|LOG
argument_list|,
literal|false
argument_list|,
literal|"Terasort"
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|test_110_teragen ()
specifier|public
name|void
name|test_110_teragen
parameter_list|()
throws|throws
name|Throwable
block|{
name|describe
argument_list|(
literal|"Teragen to %s"
argument_list|,
name|sortInput
argument_list|)
expr_stmt|;
name|getFileSystem
argument_list|()
operator|.
name|delete
argument_list|(
name|sortInput
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|JobConf
name|jobConf
init|=
name|newJobConf
argument_list|()
decl_stmt|;
name|patchConfigurationForCommitter
argument_list|(
name|jobConf
argument_list|)
expr_stmt|;
name|executeStage
argument_list|(
literal|"teragen"
argument_list|,
name|jobConf
argument_list|,
name|sortInput
argument_list|,
operator|new
name|TeraGen
argument_list|()
argument_list|,
operator|new
name|String
index|[]
block|{
name|Integer
operator|.
name|toString
argument_list|(
name|getRowCount
argument_list|()
argument_list|)
block|,
name|sortInput
operator|.
name|toString
argument_list|()
block|}
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|test_120_terasort ()
specifier|public
name|void
name|test_120_terasort
parameter_list|()
throws|throws
name|Throwable
block|{
name|describe
argument_list|(
literal|"Terasort from %s to %s"
argument_list|,
name|sortInput
argument_list|,
name|sortOutput
argument_list|)
expr_stmt|;
name|requireStage
argument_list|(
literal|"teragen"
argument_list|)
expr_stmt|;
name|getFileSystem
argument_list|()
operator|.
name|delete
argument_list|(
name|sortOutput
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|loadSuccessFile
argument_list|(
name|getFileSystem
argument_list|()
argument_list|,
name|sortInput
argument_list|,
literal|"previous teragen stage"
argument_list|)
expr_stmt|;
name|JobConf
name|jobConf
init|=
name|newJobConf
argument_list|()
decl_stmt|;
name|patchConfigurationForCommitter
argument_list|(
name|jobConf
argument_list|)
expr_stmt|;
name|executeStage
argument_list|(
literal|"terasort"
argument_list|,
name|jobConf
argument_list|,
name|sortOutput
argument_list|,
operator|new
name|TeraSort
argument_list|()
argument_list|,
operator|new
name|String
index|[]
block|{
name|sortInput
operator|.
name|toString
argument_list|()
block|,
name|sortOutput
operator|.
name|toString
argument_list|()
block|}
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|test_130_teravalidate ()
specifier|public
name|void
name|test_130_teravalidate
parameter_list|()
throws|throws
name|Throwable
block|{
name|describe
argument_list|(
literal|"TeraValidate from %s to %s"
argument_list|,
name|sortOutput
argument_list|,
name|sortValidate
argument_list|)
expr_stmt|;
name|requireStage
argument_list|(
literal|"terasort"
argument_list|)
expr_stmt|;
name|getFileSystem
argument_list|()
operator|.
name|delete
argument_list|(
name|sortValidate
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|loadSuccessFile
argument_list|(
name|getFileSystem
argument_list|()
argument_list|,
name|sortOutput
argument_list|,
literal|"previous terasort stage"
argument_list|)
expr_stmt|;
name|JobConf
name|jobConf
init|=
name|newJobConf
argument_list|()
decl_stmt|;
name|patchConfigurationForCommitter
argument_list|(
name|jobConf
argument_list|)
expr_stmt|;
name|executeStage
argument_list|(
literal|"teravalidate"
argument_list|,
name|jobConf
argument_list|,
name|sortValidate
argument_list|,
operator|new
name|TeraValidate
argument_list|()
argument_list|,
operator|new
name|String
index|[]
block|{
name|sortOutput
operator|.
name|toString
argument_list|()
block|,
name|sortValidate
operator|.
name|toString
argument_list|()
block|}
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/**    * Print the results, and save to the base dir as a CSV file.    * Why there? Makes it easy to list and compare.    */
annotation|@
name|Test
DECL|method|test_140_teracomplete ()
specifier|public
name|void
name|test_140_teracomplete
parameter_list|()
throws|throws
name|Throwable
block|{
name|terasortDuration
operator|.
name|ifPresent
argument_list|(
name|d
lambda|->
block|{
name|d
operator|.
name|close
argument_list|()
expr_stmt|;
name|completedStage
argument_list|(
literal|"overall"
argument_list|,
name|d
argument_list|)
expr_stmt|;
block|}
argument_list|)
expr_stmt|;
specifier|final
name|StringBuilder
name|results
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|results
operator|.
name|append
argument_list|(
literal|"\"Operation\"\t\"Duration\"\n"
argument_list|)
expr_stmt|;
comment|// this is how you dynamically create a function in a method
comment|// for use afterwards.
comment|// Works because there's no IOEs being raised in this sequence.
name|Consumer
argument_list|<
name|String
argument_list|>
name|stage
init|=
parameter_list|(
name|s
parameter_list|)
lambda|->
block|{
name|DurationInfo
name|duration
init|=
name|completedStages
operator|.
name|get
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|results
operator|.
name|append
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"\"%s\"\t\"%s\"\n"
argument_list|,
name|s
argument_list|,
name|duration
operator|==
literal|null
condition|?
literal|""
else|:
name|duration
argument_list|)
argument_list|)
expr_stmt|;
block|}
decl_stmt|;
name|stage
operator|.
name|accept
argument_list|(
literal|"teragen"
argument_list|)
expr_stmt|;
name|stage
operator|.
name|accept
argument_list|(
literal|"terasort"
argument_list|)
expr_stmt|;
name|stage
operator|.
name|accept
argument_list|(
literal|"teravalidate"
argument_list|)
expr_stmt|;
name|stage
operator|.
name|accept
argument_list|(
literal|"overall"
argument_list|)
expr_stmt|;
name|String
name|text
init|=
name|results
operator|.
name|toString
argument_list|()
decl_stmt|;
name|File
name|resultsFile
init|=
name|File
operator|.
name|createTempFile
argument_list|(
literal|"results"
argument_list|,
literal|".csv"
argument_list|)
decl_stmt|;
name|FileUtils
operator|.
name|write
argument_list|(
name|resultsFile
argument_list|,
name|text
argument_list|,
name|StandardCharsets
operator|.
name|UTF_8
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Results are in {}\n{}"
argument_list|,
name|resultsFile
argument_list|,
name|text
argument_list|)
expr_stmt|;
block|}
comment|/**    * Reset the duration so if two committer tests are run sequentially.    * Without this the total execution time is reported as from the start of    * the first test suite to the end of the second.    */
annotation|@
name|Test
DECL|method|test_150_teracleanup ()
specifier|public
name|void
name|test_150_teracleanup
parameter_list|()
throws|throws
name|Throwable
block|{
name|terasortDuration
operator|=
name|Optional
operator|.
name|empty
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|test_200_directory_deletion ()
specifier|public
name|void
name|test_200_directory_deletion
parameter_list|()
throws|throws
name|Throwable
block|{
name|getFileSystem
argument_list|()
operator|.
name|delete
argument_list|(
name|terasortPath
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**    * Dump the files under a path -but not fail if the path is not present.,    * @param path path to dump    * @throws Exception any failure.    */
DECL|method|dumpOutputTree (Path path)
specifier|protected
name|void
name|dumpOutputTree
parameter_list|(
name|Path
name|path
parameter_list|)
throws|throws
name|Exception
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Files under output directory {}"
argument_list|,
name|path
argument_list|)
expr_stmt|;
try|try
block|{
name|lsR
argument_list|(
name|getFileSystem
argument_list|()
argument_list|,
name|path
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Output directory {} not found"
argument_list|,
name|path
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

