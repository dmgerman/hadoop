begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.fs.s3a.select
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|select
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|BufferedReader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileNotFoundException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStreamReader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|CompletableFuture
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Assume
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Test
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|io
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FSDataInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FSExceptionMessages
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FutureDataInputStreamBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|PathIOException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Seekable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|contract
operator|.
name|ContractTestUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|impl
operator|.
name|AbstractFSBuilderImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|AWSBadRequestException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|AWSServiceIOException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|Constants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|S3AFileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|S3AInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|S3AInstrumentation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|S3ATestUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|Statistic
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|LongWritable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|Text
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|JobConf
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|InputSplit
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|Job
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|JobContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|lib
operator|.
name|input
operator|.
name|FileInputFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|lib
operator|.
name|input
operator|.
name|LineRecordReader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|lib
operator|.
name|input
operator|.
name|TextInputFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|lib
operator|.
name|output
operator|.
name|FileOutputFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|task
operator|.
name|JobContextImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|DurationInfo
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|Constants
operator|.
name|INPUT_FADVISE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|Constants
operator|.
name|INPUT_FADV_NORMAL
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|Constants
operator|.
name|READAHEAD_RANGE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|select
operator|.
name|CsvFile
operator|.
name|ALL_QUOTES
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|select
operator|.
name|SelectBinding
operator|.
name|expandBackslashChars
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|select
operator|.
name|SelectConstants
operator|.
name|*
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|test
operator|.
name|LambdaTestUtils
operator|.
name|intercept
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|test
operator|.
name|LambdaTestUtils
operator|.
name|interceptFuture
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|hamcrest
operator|.
name|CoreMatchers
operator|.
name|hasItem
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|hamcrest
operator|.
name|CoreMatchers
operator|.
name|not
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|hamcrest
operator|.
name|collection
operator|.
name|IsCollectionWithSize
operator|.
name|hasSize
import|;
end_import

begin_comment
comment|/**  * Test the S3 Select feature with some basic SQL Commands.  * Executed if the destination store declares its support for the feature.  */
end_comment

begin_class
DECL|class|ITestS3Select
specifier|public
class|class
name|ITestS3Select
extends|extends
name|AbstractS3SelectTest
block|{
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|ITestS3Select
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|E_CAST_FAILED
specifier|public
specifier|static
specifier|final
name|String
name|E_CAST_FAILED
init|=
literal|"CastFailed"
decl_stmt|;
DECL|field|E_PARSE_INVALID_PATH_COMPONENT
specifier|public
specifier|static
specifier|final
name|String
name|E_PARSE_INVALID_PATH_COMPONENT
init|=
literal|"ParseInvalidPathComponent"
decl_stmt|;
DECL|field|E_INVALID_TABLE_ALIAS
specifier|public
specifier|static
specifier|final
name|String
name|E_INVALID_TABLE_ALIAS
init|=
literal|"InvalidTableAlias"
decl_stmt|;
DECL|field|selectConf
specifier|private
name|Configuration
name|selectConf
decl_stmt|;
comment|/** well formed CSV. */
DECL|field|csvPath
specifier|private
name|Path
name|csvPath
decl_stmt|;
comment|/** CSV file with fewer columns than expected, all fields parse badly. */
DECL|field|brokenCSV
specifier|private
name|Path
name|brokenCSV
decl_stmt|;
annotation|@
name|Override
DECL|method|setup ()
specifier|public
name|void
name|setup
parameter_list|()
throws|throws
name|Exception
block|{
name|super
operator|.
name|setup
argument_list|()
expr_stmt|;
name|csvPath
operator|=
name|path
argument_list|(
name|getMethodName
argument_list|()
operator|+
literal|".csv"
argument_list|)
expr_stmt|;
name|Assume
operator|.
name|assumeTrue
argument_list|(
literal|"S3 Select is not enabled"
argument_list|,
name|getFileSystem
argument_list|()
operator|.
name|hasPathCapability
argument_list|(
name|csvPath
argument_list|,
name|S3_SELECT_CAPABILITY
argument_list|)
argument_list|)
expr_stmt|;
name|selectConf
operator|=
operator|new
name|Configuration
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|selectConf
operator|.
name|setBoolean
argument_list|(
name|SELECT_ERRORS_INCLUDE_SQL
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|createStandardCsvFile
argument_list|(
name|getFileSystem
argument_list|()
argument_list|,
name|csvPath
argument_list|,
name|ALL_QUOTES
argument_list|)
expr_stmt|;
comment|// create the broken CSV file.
name|brokenCSV
operator|=
name|path
argument_list|(
literal|"testParseBrokenCSVFile"
argument_list|)
expr_stmt|;
name|createStandardCsvFile
argument_list|(
name|getFileSystem
argument_list|()
argument_list|,
name|brokenCSV
argument_list|,
literal|true
argument_list|,
name|ALL_QUOTES
argument_list|,
name|ALL_ROWS_COUNT
argument_list|,
name|ALL_ROWS_COUNT
argument_list|,
literal|","
argument_list|,
literal|"\n"
argument_list|,
literal|"\""
argument_list|,
name|csv
lambda|->
name|csv
operator|.
name|line
argument_list|(
literal|"# comment"
argument_list|)
operator|.
name|row
argument_list|(
name|ALL_QUOTES
argument_list|,
literal|"bad"
argument_list|,
literal|"Tuesday"
argument_list|,
literal|0
argument_list|,
literal|"entry-bad"
argument_list|,
literal|"yes"
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|teardown ()
specifier|public
name|void
name|teardown
parameter_list|()
throws|throws
name|Exception
block|{
name|describe
argument_list|(
literal|"teardown"
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
name|csvPath
operator|!=
literal|null
condition|)
block|{
name|getFileSystem
argument_list|()
operator|.
name|delete
argument_list|(
name|csvPath
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|brokenCSV
operator|!=
literal|null
condition|)
block|{
name|getFileSystem
argument_list|()
operator|.
name|delete
argument_list|(
name|brokenCSV
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|super
operator|.
name|teardown
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Test
DECL|method|testCapabilityProbe ()
specifier|public
name|void
name|testCapabilityProbe
parameter_list|()
throws|throws
name|Throwable
block|{
comment|// this should always hold true if we get past test setup
name|assertTrue
argument_list|(
literal|"Select is not available on "
operator|+
name|getFileSystem
argument_list|()
argument_list|,
name|isSelectAvailable
argument_list|(
name|getFileSystem
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"NestedAssignment"
argument_list|)
annotation|@
name|Test
DECL|method|testReadWholeFileClassicAPI ()
specifier|public
name|void
name|testReadWholeFileClassicAPI
parameter_list|()
throws|throws
name|Throwable
block|{
name|describe
argument_list|(
literal|"create and read the whole file. Verifies setup working"
argument_list|)
expr_stmt|;
name|int
name|lines
decl_stmt|;
try|try
init|(
name|BufferedReader
name|reader
init|=
operator|new
name|BufferedReader
argument_list|(
operator|new
name|InputStreamReader
argument_list|(
name|getFileSystem
argument_list|()
operator|.
name|open
argument_list|(
name|csvPath
argument_list|)
argument_list|)
argument_list|)
init|)
block|{
name|lines
operator|=
literal|0
expr_stmt|;
comment|// seek to 0, which is what some input formats do
name|String
name|line
decl_stmt|;
while|while
condition|(
operator|(
name|line
operator|=
name|reader
operator|.
name|readLine
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
name|lines
operator|++
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"{}"
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
block|}
name|assertEquals
argument_list|(
literal|"line count"
argument_list|,
name|ALL_ROWS_COUNT_WITH_HEADER
argument_list|,
name|lines
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testSelectWholeFileNoHeader ()
specifier|public
name|void
name|testSelectWholeFileNoHeader
parameter_list|()
throws|throws
name|Throwable
block|{
name|describe
argument_list|(
literal|"Select the entire file, expect all rows but the header"
argument_list|)
expr_stmt|;
name|expectSelected
argument_list|(
name|ALL_ROWS_COUNT
argument_list|,
name|selectConf
argument_list|,
name|CSV_HEADER_OPT_USE
argument_list|,
literal|"SELECT * FROM S3OBJECT"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testSelectFirstColumnNoHeader ()
specifier|public
name|void
name|testSelectFirstColumnNoHeader
parameter_list|()
throws|throws
name|Throwable
block|{
name|describe
argument_list|(
literal|"Select the entire file, expect all rows but the header"
argument_list|)
expr_stmt|;
name|expectSelected
argument_list|(
name|ALL_ROWS_COUNT_WITH_HEADER
argument_list|,
name|selectConf
argument_list|,
name|CSV_HEADER_OPT_NONE
argument_list|,
literal|"SELECT s._1 FROM S3OBJECT s"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testSelectSelfNoHeader ()
specifier|public
name|void
name|testSelectSelfNoHeader
parameter_list|()
throws|throws
name|Throwable
block|{
name|describe
argument_list|(
literal|"Select the entire file, expect all rows but the header"
argument_list|)
expr_stmt|;
name|expectSelected
argument_list|(
name|ALL_ROWS_COUNT_WITH_HEADER
argument_list|,
name|selectConf
argument_list|,
name|CSV_HEADER_OPT_NONE
argument_list|,
literal|"SELECT s._1 FROM S3OBJECT s WHERE s._1 = s._1"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testSelectSelfUseHeader ()
specifier|public
name|void
name|testSelectSelfUseHeader
parameter_list|()
throws|throws
name|Throwable
block|{
name|describe
argument_list|(
literal|"Select the entire file, expect all rows including the header"
argument_list|)
expr_stmt|;
name|expectSelected
argument_list|(
name|ALL_ROWS_COUNT
argument_list|,
name|selectConf
argument_list|,
name|CSV_HEADER_OPT_USE
argument_list|,
literal|"SELECT s.id FROM S3OBJECT s WHERE s.id = s.id"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testSelectID2UseHeader ()
specifier|public
name|void
name|testSelectID2UseHeader
parameter_list|()
throws|throws
name|Throwable
block|{
name|describe
argument_list|(
literal|"Select where ID=2; use the header"
argument_list|)
expr_stmt|;
name|expectSelected
argument_list|(
literal|1
argument_list|,
name|selectConf
argument_list|,
name|CSV_HEADER_OPT_USE
argument_list|,
literal|"SELECT s.id FROM S3OBJECT s WHERE s.id = '2'"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testSelectNoMatchingID ()
specifier|public
name|void
name|testSelectNoMatchingID
parameter_list|()
throws|throws
name|Throwable
block|{
name|describe
argument_list|(
literal|"Select where there is no match; expect nothing back"
argument_list|)
expr_stmt|;
name|expectSelected
argument_list|(
literal|0
argument_list|,
name|selectConf
argument_list|,
name|CSV_HEADER_OPT_USE
argument_list|,
literal|"SELECT s.id FROM S3OBJECT s WHERE s.id = '0x8000'"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testSelectId1 ()
specifier|public
name|void
name|testSelectId1
parameter_list|()
throws|throws
name|Throwable
block|{
name|describe
argument_list|(
literal|"Select the first element in the file"
argument_list|)
expr_stmt|;
name|expectSelected
argument_list|(
literal|1
argument_list|,
name|selectConf
argument_list|,
name|CSV_HEADER_OPT_NONE
argument_list|,
literal|"SELECT * FROM S3OBJECT s WHERE s._1 = '1'"
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testSelectEmptySQL ()
specifier|public
name|void
name|testSelectEmptySQL
parameter_list|()
throws|throws
name|Throwable
block|{
name|describe
argument_list|(
literal|"An empty SQL statement fails fast"
argument_list|)
expr_stmt|;
name|FutureDataInputStreamBuilder
name|builder
init|=
name|getFileSystem
argument_list|()
operator|.
name|openFile
argument_list|(
name|csvPath
argument_list|)
operator|.
name|must
argument_list|(
name|SELECT_SQL
argument_list|,
literal|""
argument_list|)
decl_stmt|;
name|interceptFuture
argument_list|(
name|IllegalArgumentException
operator|.
name|class
argument_list|,
name|SELECT_SQL
argument_list|,
name|builder
operator|.
name|build
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testSelectEmptyFile ()
specifier|public
name|void
name|testSelectEmptyFile
parameter_list|()
throws|throws
name|Throwable
block|{
name|describe
argument_list|(
literal|"Select everything from an empty file"
argument_list|)
expr_stmt|;
name|Path
name|path
init|=
name|path
argument_list|(
literal|"testSelectEmptyFile"
argument_list|)
decl_stmt|;
name|S3AFileSystem
name|fs
init|=
name|getFileSystem
argument_list|()
decl_stmt|;
name|ContractTestUtils
operator|.
name|touch
argument_list|(
name|fs
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|parseToLines
argument_list|(
name|fs
operator|.
name|openFile
argument_list|(
name|path
argument_list|)
operator|.
name|must
argument_list|(
name|SELECT_SQL
argument_list|,
name|SELECT_EVERYTHING
argument_list|)
operator|.
name|build
argument_list|()
operator|.
name|get
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testSelectEmptyFileWithConditions ()
specifier|public
name|void
name|testSelectEmptyFileWithConditions
parameter_list|()
throws|throws
name|Throwable
block|{
name|describe
argument_list|(
literal|"Select everything from an empty file with a more complex SQL"
argument_list|)
expr_stmt|;
name|Path
name|path
init|=
name|path
argument_list|(
literal|"testSelectEmptyFileWithConditions"
argument_list|)
decl_stmt|;
name|S3AFileSystem
name|fs
init|=
name|getFileSystem
argument_list|()
decl_stmt|;
name|ContractTestUtils
operator|.
name|touch
argument_list|(
name|fs
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|String
name|sql
init|=
literal|"SELECT * FROM S3OBJECT s WHERE s._1 = `TRUE`"
decl_stmt|;
name|CompletableFuture
argument_list|<
name|FSDataInputStream
argument_list|>
name|future
init|=
name|fs
operator|.
name|openFile
argument_list|(
name|path
argument_list|)
operator|.
name|must
argument_list|(
name|SELECT_SQL
argument_list|,
name|sql
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
literal|"Not at the end of the file"
argument_list|,
operator|-
literal|1
argument_list|,
name|future
operator|.
name|get
argument_list|()
operator|.
name|read
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testSelectSeek ()
specifier|public
name|void
name|testSelectSeek
parameter_list|()
throws|throws
name|Throwable
block|{
name|describe
argument_list|(
literal|"Verify forward seeks work, not others"
argument_list|)
expr_stmt|;
comment|// start: read in the full data through the initial select
comment|// this makes asserting that contents match possible
name|Path
name|path
init|=
name|csvPath
decl_stmt|;
name|S3AFileSystem
name|fs
init|=
name|getFileSystem
argument_list|()
decl_stmt|;
name|int
name|len
init|=
operator|(
name|int
operator|)
name|fs
operator|.
name|getFileStatus
argument_list|(
name|path
argument_list|)
operator|.
name|getLen
argument_list|()
decl_stmt|;
name|byte
index|[]
name|fullData
init|=
operator|new
name|byte
index|[
name|len
index|]
decl_stmt|;
name|int
name|actualLen
decl_stmt|;
try|try
init|(
name|DurationInfo
name|ignored
init|=
operator|new
name|DurationInfo
argument_list|(
name|LOG
argument_list|,
literal|"Initial read of %s"
argument_list|,
name|path
argument_list|)
init|;
name|FSDataInputStream
name|sourceStream
operator|=
name|select
argument_list|(
name|fs
argument_list|,
name|path
argument_list|,
name|selectConf
argument_list|,
name|SELECT_EVERYTHING
argument_list|)
init|)
block|{
comment|// read it in
name|actualLen
operator|=
name|IOUtils
operator|.
name|read
argument_list|(
name|sourceStream
argument_list|,
name|fullData
argument_list|)
expr_stmt|;
block|}
name|int
name|seekRange
init|=
literal|20
decl_stmt|;
try|try
init|(
name|FSDataInputStream
name|seekStream
init|=
name|select
argument_list|(
name|fs
argument_list|,
name|path
argument_list|,
name|selectConf
argument_list|,
name|SELECT_EVERYTHING
argument_list|)
init|)
block|{
name|SelectInputStream
name|sis
init|=
operator|(
name|SelectInputStream
operator|)
name|seekStream
operator|.
name|getWrappedStream
argument_list|()
decl_stmt|;
name|S3AInstrumentation
operator|.
name|InputStreamStatistics
name|streamStats
init|=
name|sis
operator|.
name|getS3AStreamStatistics
argument_list|()
decl_stmt|;
comment|// lazy seek doesn't raise a problem here
name|seekStream
operator|.
name|seek
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"first byte read"
argument_list|,
name|fullData
index|[
literal|0
index|]
argument_list|,
name|seekStream
operator|.
name|read
argument_list|()
argument_list|)
expr_stmt|;
comment|// and now the pos has moved, again, seek will be OK
name|seekStream
operator|.
name|seek
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|seekStream
operator|.
name|seek
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|// but trying to seek elsewhere now fails
name|PathIOException
name|ex
init|=
name|intercept
argument_list|(
name|PathIOException
operator|.
name|class
argument_list|,
name|SelectInputStream
operator|.
name|SEEK_UNSUPPORTED
argument_list|,
parameter_list|()
lambda|->
name|seekStream
operator|.
name|seek
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Seek error is as expected"
argument_list|,
name|ex
argument_list|)
expr_stmt|;
comment|// positioned reads from the current location work.
name|byte
index|[]
name|buffer
init|=
operator|new
name|byte
index|[
literal|1
index|]
decl_stmt|;
name|long
name|pos
init|=
name|seekStream
operator|.
name|getPos
argument_list|()
decl_stmt|;
name|seekStream
operator|.
name|readFully
argument_list|(
name|pos
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
comment|// but positioned backwards fail.
name|intercept
argument_list|(
name|PathIOException
operator|.
name|class
argument_list|,
name|SelectInputStream
operator|.
name|SEEK_UNSUPPORTED
argument_list|,
parameter_list|()
lambda|->
name|seekStream
operator|.
name|readFully
argument_list|(
literal|0
argument_list|,
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
comment|// the position has now moved on.
name|assertPosition
argument_list|(
name|seekStream
argument_list|,
name|pos
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|// so a seek to the old pos will fail
name|intercept
argument_list|(
name|PathIOException
operator|.
name|class
argument_list|,
name|SelectInputStream
operator|.
name|SEEK_UNSUPPORTED
argument_list|,
parameter_list|()
lambda|->
name|seekStream
operator|.
name|readFully
argument_list|(
name|pos
argument_list|,
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
comment|// set the readahead to the default.
comment|// This verifies it reverts to the default.
name|seekStream
operator|.
name|setReadahead
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Readahead in "
argument_list|,
name|Constants
operator|.
name|DEFAULT_READAHEAD_RANGE
argument_list|,
name|sis
operator|.
name|getReadahead
argument_list|()
argument_list|)
expr_stmt|;
comment|// forward seeks are implemented as 1+ skip
name|long
name|target
init|=
name|seekStream
operator|.
name|getPos
argument_list|()
operator|+
name|seekRange
decl_stmt|;
name|seek
argument_list|(
name|seekStream
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|assertPosition
argument_list|(
name|seekStream
argument_list|,
name|target
argument_list|)
expr_stmt|;
comment|// now do a read and compare values
name|assertEquals
argument_list|(
literal|"byte at seek position"
argument_list|,
name|fullData
index|[
operator|(
name|int
operator|)
name|seekStream
operator|.
name|getPos
argument_list|()
index|]
argument_list|,
name|seekStream
operator|.
name|read
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Seek bytes skipped in "
operator|+
name|streamStats
argument_list|,
name|seekRange
argument_list|,
name|streamStats
operator|.
name|bytesSkippedOnSeek
argument_list|)
expr_stmt|;
comment|// try an invalid readahead range
name|intercept
argument_list|(
name|IllegalArgumentException
operator|.
name|class
argument_list|,
name|S3AInputStream
operator|.
name|E_NEGATIVE_READAHEAD_VALUE
argument_list|,
parameter_list|()
lambda|->
name|seekStream
operator|.
name|setReadahead
argument_list|(
operator|-
literal|1L
argument_list|)
argument_list|)
expr_stmt|;
comment|// do a slightly forward offset read
name|int
name|read
init|=
name|seekStream
operator|.
name|read
argument_list|(
name|seekStream
operator|.
name|getPos
argument_list|()
operator|+
literal|2
argument_list|,
name|buffer
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|read
argument_list|)
expr_stmt|;
comment|// final fun: seek way past the EOF
name|logIntercepted
argument_list|(
name|expectSeekEOF
argument_list|(
name|seekStream
argument_list|,
name|actualLen
operator|*
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|assertPosition
argument_list|(
name|seekStream
argument_list|,
name|actualLen
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
operator|-
literal|1
argument_list|,
name|seekStream
operator|.
name|read
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Seek statistics {}"
argument_list|,
name|streamStats
argument_list|)
expr_stmt|;
comment|// this will return no, but not fail
name|assertFalse
argument_list|(
literal|"Failed to seek to new source in "
operator|+
name|seekStream
argument_list|,
name|seekStream
operator|.
name|seekToNewSource
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|// and set the readahead to 0 to see that close path works
name|seekStream
operator|.
name|setReadahead
argument_list|(
literal|0L
argument_list|)
expr_stmt|;
comment|// then do a manual close even though there's one in the try resource.
comment|// which will verify that a double close is harmless
name|seekStream
operator|.
name|close
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Final stream state {}"
argument_list|,
name|sis
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Assert that a stream is in a specific position.    * @param stream stream or other seekable.    * @param pos expected position.    * @throws IOException failure of the getPos() call.    * @throws AssertionError mismatch between expected and actual.    */
DECL|method|assertPosition (Seekable stream, long pos)
specifier|private
name|void
name|assertPosition
parameter_list|(
name|Seekable
name|stream
parameter_list|,
name|long
name|pos
parameter_list|)
throws|throws
name|IOException
block|{
name|assertEquals
argument_list|(
literal|"Wrong stream position in "
operator|+
name|stream
argument_list|,
name|pos
argument_list|,
name|stream
operator|.
name|getPos
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testSelectOddLinesNoHeader ()
specifier|public
name|void
name|testSelectOddLinesNoHeader
parameter_list|()
throws|throws
name|Throwable
block|{
name|describe
argument_list|(
literal|"Select odd lines, ignoring the header"
argument_list|)
expr_stmt|;
name|expectSelected
argument_list|(
name|ODD_ROWS_COUNT
argument_list|,
name|selectConf
argument_list|,
name|CSV_HEADER_OPT_IGNORE
argument_list|,
literal|"SELECT * FROM S3OBJECT s WHERE s._5 = `TRUE`"
argument_list|)
expr_stmt|;
comment|// and do a quick check on the instrumentation
name|long
name|bytesRead
init|=
name|getFileSystem
argument_list|()
operator|.
name|getInstrumentation
argument_list|()
operator|.
name|getCounterValue
argument_list|(
name|Statistic
operator|.
name|STREAM_SEEK_BYTES_READ
argument_list|)
decl_stmt|;
name|assertNotEquals
argument_list|(
literal|"No bytes read count"
argument_list|,
literal|0
argument_list|,
name|bytesRead
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testSelectOddLinesHeader ()
specifier|public
name|void
name|testSelectOddLinesHeader
parameter_list|()
throws|throws
name|Throwable
block|{
name|describe
argument_list|(
literal|"Select the odd values"
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|selected
init|=
name|expectSelected
argument_list|(
name|ODD_ROWS_COUNT
argument_list|,
name|selectConf
argument_list|,
name|CSV_HEADER_OPT_USE
argument_list|,
name|SELECT_ODD_ROWS
argument_list|)
decl_stmt|;
comment|// the list includes odd values
name|assertThat
argument_list|(
name|selected
argument_list|,
name|hasItem
argument_list|(
name|ENTRY_0001
argument_list|)
argument_list|)
expr_stmt|;
comment|// but not the evens
name|assertThat
argument_list|(
name|selected
argument_list|,
name|not
argument_list|(
name|hasItem
argument_list|(
name|ENTRY_0002
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testSelectOddLinesHeaderTSVOutput ()
specifier|public
name|void
name|testSelectOddLinesHeaderTSVOutput
parameter_list|()
throws|throws
name|Throwable
block|{
name|describe
argument_list|(
literal|"Select the odd values with tab spaced output"
argument_list|)
expr_stmt|;
name|selectConf
operator|.
name|set
argument_list|(
name|CSV_OUTPUT_FIELD_DELIMITER
argument_list|,
literal|"\t"
argument_list|)
expr_stmt|;
name|selectConf
operator|.
name|set
argument_list|(
name|CSV_OUTPUT_QUOTE_CHARACTER
argument_list|,
literal|"'"
argument_list|)
expr_stmt|;
name|selectConf
operator|.
name|set
argument_list|(
name|CSV_OUTPUT_QUOTE_FIELDS
argument_list|,
name|CSV_OUTPUT_QUOTE_FIELDS_AS_NEEEDED
argument_list|)
expr_stmt|;
name|selectConf
operator|.
name|set
argument_list|(
name|CSV_OUTPUT_RECORD_DELIMITER
argument_list|,
literal|"\r"
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|selected
init|=
name|expectSelected
argument_list|(
name|ODD_ROWS_COUNT
argument_list|,
name|selectConf
argument_list|,
name|CSV_HEADER_OPT_USE
argument_list|,
name|SELECT_ODD_ENTRIES_BOOL
argument_list|)
decl_stmt|;
comment|// the list includes odd values
name|String
name|row1
init|=
name|selected
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
comment|// split that first line into columns: This is why TSV is better for code
comment|// to work with than CSV
name|String
index|[]
name|columns
init|=
name|row1
operator|.
name|split
argument_list|(
literal|"\t"
argument_list|,
operator|-
literal|1
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|"Wrong column count from tab split line<"
operator|+
name|row1
operator|+
literal|">"
argument_list|,
name|CSV_COLUMN_COUNT
argument_list|,
name|columns
operator|.
name|length
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Wrong column value from tab split line<"
operator|+
name|row1
operator|+
literal|">"
argument_list|,
literal|"entry-0001"
argument_list|,
name|columns
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testSelectNotOperationHeader ()
specifier|public
name|void
name|testSelectNotOperationHeader
parameter_list|()
throws|throws
name|Throwable
block|{
name|describe
argument_list|(
literal|"Select the even values with a NOT call; quote the header name"
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|selected
init|=
name|expectSelected
argument_list|(
name|EVEN_ROWS_COUNT
argument_list|,
name|selectConf
argument_list|,
name|CSV_HEADER_OPT_USE
argument_list|,
literal|"SELECT s.name FROM S3OBJECT s WHERE NOT s.\"odd\" = %s"
argument_list|,
name|TRUE
argument_list|)
decl_stmt|;
comment|// the list includes no odd values
name|assertThat
argument_list|(
name|selected
argument_list|,
name|not
argument_list|(
name|hasItem
argument_list|(
name|ENTRY_0001
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// but has the evens
name|assertThat
argument_list|(
name|selected
argument_list|,
name|hasItem
argument_list|(
name|ENTRY_0002
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testBackslashExpansion ()
specifier|public
name|void
name|testBackslashExpansion
parameter_list|()
throws|throws
name|Throwable
block|{
name|assertEquals
argument_list|(
literal|"\t\r\n"
argument_list|,
name|expandBackslashChars
argument_list|(
literal|"\t\r\n"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"\t"
argument_list|,
name|expandBackslashChars
argument_list|(
literal|"\\t"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"\r"
argument_list|,
name|expandBackslashChars
argument_list|(
literal|"\\r"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"\r \n"
argument_list|,
name|expandBackslashChars
argument_list|(
literal|"\\r \\n"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"\\"
argument_list|,
name|expandBackslashChars
argument_list|(
literal|"\\\\"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * This is an expanded example for the documentation.    * Also helps catch out unplanned changes to the configuration strings.    */
annotation|@
name|Test
DECL|method|testSelectFileExample ()
specifier|public
name|void
name|testSelectFileExample
parameter_list|()
throws|throws
name|Throwable
block|{
name|describe
argument_list|(
literal|"Select the entire file, expect all rows but the header"
argument_list|)
expr_stmt|;
name|int
name|len
init|=
operator|(
name|int
operator|)
name|getFileSystem
argument_list|()
operator|.
name|getFileStatus
argument_list|(
name|csvPath
argument_list|)
operator|.
name|getLen
argument_list|()
decl_stmt|;
name|FutureDataInputStreamBuilder
name|builder
init|=
name|getFileSystem
argument_list|()
operator|.
name|openFile
argument_list|(
name|csvPath
argument_list|)
operator|.
name|must
argument_list|(
literal|"fs.s3a.select.sql"
argument_list|,
name|SELECT_ODD_ENTRIES
argument_list|)
operator|.
name|must
argument_list|(
literal|"fs.s3a.select.input.format"
argument_list|,
literal|"CSV"
argument_list|)
operator|.
name|must
argument_list|(
literal|"fs.s3a.select.input.compression"
argument_list|,
literal|"NONE"
argument_list|)
operator|.
name|must
argument_list|(
literal|"fs.s3a.select.input.csv.header"
argument_list|,
literal|"use"
argument_list|)
operator|.
name|must
argument_list|(
literal|"fs.s3a.select.output.format"
argument_list|,
literal|"CSV"
argument_list|)
decl_stmt|;
name|CompletableFuture
argument_list|<
name|FSDataInputStream
argument_list|>
name|future
init|=
name|builder
operator|.
name|build
argument_list|()
decl_stmt|;
try|try
init|(
name|FSDataInputStream
name|select
init|=
name|future
operator|.
name|get
argument_list|()
init|)
block|{
comment|// process the output
name|byte
index|[]
name|bytes
init|=
operator|new
name|byte
index|[
name|len
index|]
decl_stmt|;
name|int
name|actual
init|=
name|select
operator|.
name|read
argument_list|(
name|bytes
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"file length is {}; length of selected data is {}"
argument_list|,
name|len
argument_list|,
name|actual
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * This is an expanded example for the documentation.    * Also helps catch out unplanned changes to the configuration strings.    */
annotation|@
name|Test
DECL|method|testSelectUnsupportedInputFormat ()
specifier|public
name|void
name|testSelectUnsupportedInputFormat
parameter_list|()
throws|throws
name|Throwable
block|{
name|describe
argument_list|(
literal|"Request an unsupported input format"
argument_list|)
expr_stmt|;
name|FutureDataInputStreamBuilder
name|builder
init|=
name|getFileSystem
argument_list|()
operator|.
name|openFile
argument_list|(
name|csvPath
argument_list|)
operator|.
name|must
argument_list|(
name|SELECT_SQL
argument_list|,
name|SELECT_ODD_ENTRIES
argument_list|)
operator|.
name|must
argument_list|(
name|SELECT_INPUT_FORMAT
argument_list|,
literal|"pptx"
argument_list|)
decl_stmt|;
name|interceptFuture
argument_list|(
name|IllegalArgumentException
operator|.
name|class
argument_list|,
literal|"pptx"
argument_list|,
name|builder
operator|.
name|build
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Ask for an invalid output format.    */
annotation|@
name|Test
DECL|method|testSelectUnsupportedOutputFormat ()
specifier|public
name|void
name|testSelectUnsupportedOutputFormat
parameter_list|()
throws|throws
name|Throwable
block|{
name|describe
argument_list|(
literal|"Request a (currently) unsupported output format"
argument_list|)
expr_stmt|;
name|FutureDataInputStreamBuilder
name|builder
init|=
name|getFileSystem
argument_list|()
operator|.
name|openFile
argument_list|(
name|csvPath
argument_list|)
operator|.
name|must
argument_list|(
name|SELECT_SQL
argument_list|,
name|SELECT_ODD_ENTRIES
argument_list|)
operator|.
name|must
argument_list|(
name|SELECT_INPUT_FORMAT
argument_list|,
literal|"csv"
argument_list|)
operator|.
name|must
argument_list|(
name|SELECT_OUTPUT_FORMAT
argument_list|,
literal|"json"
argument_list|)
decl_stmt|;
name|interceptFuture
argument_list|(
name|IllegalArgumentException
operator|.
name|class
argument_list|,
literal|"json"
argument_list|,
name|builder
operator|.
name|build
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    *  Missing files fail lazy.    */
annotation|@
name|Test
DECL|method|testSelectMissingFile ()
specifier|public
name|void
name|testSelectMissingFile
parameter_list|()
throws|throws
name|Throwable
block|{
name|describe
argument_list|(
literal|"Select a missing file, expect it to surface in the future"
argument_list|)
expr_stmt|;
name|Path
name|missing
init|=
name|path
argument_list|(
literal|"missing"
argument_list|)
decl_stmt|;
name|FutureDataInputStreamBuilder
name|builder
init|=
name|getFileSystem
argument_list|()
operator|.
name|openFile
argument_list|(
name|missing
argument_list|)
operator|.
name|must
argument_list|(
name|SELECT_SQL
argument_list|,
name|SELECT_ODD_ENTRIES
argument_list|)
decl_stmt|;
name|interceptFuture
argument_list|(
name|FileNotFoundException
operator|.
name|class
argument_list|,
literal|""
argument_list|,
name|builder
operator|.
name|build
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testSelectDirectoryFails ()
specifier|public
name|void
name|testSelectDirectoryFails
parameter_list|()
throws|throws
name|Throwable
block|{
name|describe
argument_list|(
literal|"Verify that secondary select options are only valid on select"
operator|+
literal|" queries"
argument_list|)
expr_stmt|;
name|S3AFileSystem
name|fs
init|=
name|getFileSystem
argument_list|()
decl_stmt|;
name|Path
name|dir
init|=
name|path
argument_list|(
literal|"dir"
argument_list|)
decl_stmt|;
comment|// this will be an empty dir marker
name|fs
operator|.
name|mkdirs
argument_list|(
name|dir
argument_list|)
expr_stmt|;
name|FutureDataInputStreamBuilder
name|builder
init|=
name|getFileSystem
argument_list|()
operator|.
name|openFile
argument_list|(
name|dir
argument_list|)
operator|.
name|must
argument_list|(
name|SELECT_SQL
argument_list|,
name|SELECT_ODD_ENTRIES
argument_list|)
decl_stmt|;
name|interceptFuture
argument_list|(
name|PathIOException
operator|.
name|class
argument_list|,
literal|""
argument_list|,
name|builder
operator|.
name|build
argument_list|()
argument_list|)
expr_stmt|;
comment|// try the parent
name|builder
operator|=
name|getFileSystem
argument_list|()
operator|.
name|openFile
argument_list|(
name|dir
operator|.
name|getParent
argument_list|()
argument_list|)
operator|.
name|must
argument_list|(
name|SELECT_SQL
argument_list|,
name|SELECT_ODD_ENTRIES
argument_list|)
expr_stmt|;
name|interceptFuture
argument_list|(
name|PathIOException
operator|.
name|class
argument_list|,
literal|""
argument_list|,
name|builder
operator|.
name|build
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testSelectRootFails ()
specifier|public
name|void
name|testSelectRootFails
parameter_list|()
throws|throws
name|Throwable
block|{
name|describe
argument_list|(
literal|"verify root dir selection is rejected"
argument_list|)
expr_stmt|;
name|FutureDataInputStreamBuilder
name|builder
init|=
name|getFileSystem
argument_list|()
operator|.
name|openFile
argument_list|(
name|path
argument_list|(
literal|"/"
argument_list|)
argument_list|)
operator|.
name|must
argument_list|(
name|SELECT_SQL
argument_list|,
name|SELECT_ODD_ENTRIES
argument_list|)
decl_stmt|;
name|interceptFuture
argument_list|(
name|PathIOException
operator|.
name|class
argument_list|,
literal|""
argument_list|,
name|builder
operator|.
name|build
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Validate the abort logic.    */
annotation|@
name|Test
DECL|method|testCloseWithAbort ()
specifier|public
name|void
name|testCloseWithAbort
parameter_list|()
throws|throws
name|Throwable
block|{
name|describe
argument_list|(
literal|"Close the stream with the readahead outstanding"
argument_list|)
expr_stmt|;
name|S3ATestUtils
operator|.
name|MetricDiff
name|readOps
init|=
operator|new
name|S3ATestUtils
operator|.
name|MetricDiff
argument_list|(
name|getFileSystem
argument_list|()
argument_list|,
name|Statistic
operator|.
name|STREAM_READ_OPERATIONS_INCOMPLETE
argument_list|)
decl_stmt|;
name|selectConf
operator|.
name|setInt
argument_list|(
name|READAHEAD_RANGE
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|FSDataInputStream
name|stream
init|=
name|select
argument_list|(
name|getFileSystem
argument_list|()
argument_list|,
name|csvPath
argument_list|,
name|selectConf
argument_list|,
literal|"SELECT * FROM S3OBJECT s"
argument_list|)
decl_stmt|;
name|SelectInputStream
name|sis
init|=
operator|(
name|SelectInputStream
operator|)
name|stream
operator|.
name|getWrappedStream
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
literal|"Readahead on "
operator|+
name|sis
argument_list|,
literal|2
argument_list|,
name|sis
operator|.
name|getReadahead
argument_list|()
argument_list|)
expr_stmt|;
name|stream
operator|.
name|setReadahead
argument_list|(
literal|1L
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Readahead on "
operator|+
name|sis
argument_list|,
literal|1
argument_list|,
name|sis
operator|.
name|getReadahead
argument_list|()
argument_list|)
expr_stmt|;
name|stream
operator|.
name|read
argument_list|()
expr_stmt|;
name|S3AInstrumentation
operator|.
name|InputStreamStatistics
name|stats
init|=
name|sis
operator|.
name|getS3AStreamStatistics
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
literal|"Read count in "
operator|+
name|sis
argument_list|,
literal|1
argument_list|,
name|stats
operator|.
name|bytesRead
argument_list|)
expr_stmt|;
name|stream
operator|.
name|close
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Abort count in "
operator|+
name|sis
argument_list|,
literal|1
argument_list|,
name|stats
operator|.
name|aborted
argument_list|)
expr_stmt|;
name|readOps
operator|.
name|assertDiffEquals
argument_list|(
literal|"Read operations are still considered active"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|intercept
argument_list|(
name|PathIOException
operator|.
name|class
argument_list|,
name|FSExceptionMessages
operator|.
name|STREAM_IS_CLOSED
argument_list|,
parameter_list|()
lambda|->
name|stream
operator|.
name|read
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testCloseWithNoAbort ()
specifier|public
name|void
name|testCloseWithNoAbort
parameter_list|()
throws|throws
name|Throwable
block|{
name|describe
argument_list|(
literal|"Close the stream with the readahead outstandingV"
argument_list|)
expr_stmt|;
name|FSDataInputStream
name|stream
init|=
name|select
argument_list|(
name|getFileSystem
argument_list|()
argument_list|,
name|csvPath
argument_list|,
name|selectConf
argument_list|,
literal|"SELECT * FROM S3OBJECT s"
argument_list|)
decl_stmt|;
name|stream
operator|.
name|setReadahead
argument_list|(
literal|0x1000L
argument_list|)
expr_stmt|;
name|SelectInputStream
name|sis
init|=
operator|(
name|SelectInputStream
operator|)
name|stream
operator|.
name|getWrappedStream
argument_list|()
decl_stmt|;
name|S3AInstrumentation
operator|.
name|InputStreamStatistics
name|stats
init|=
name|sis
operator|.
name|getS3AStreamStatistics
argument_list|()
decl_stmt|;
name|stream
operator|.
name|close
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Close count in "
operator|+
name|sis
argument_list|,
literal|1
argument_list|,
name|stats
operator|.
name|closed
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Abort count in "
operator|+
name|sis
argument_list|,
literal|0
argument_list|,
name|stats
operator|.
name|aborted
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"No bytes read in close of "
operator|+
name|sis
argument_list|,
name|stats
operator|.
name|bytesReadInClose
operator|>
literal|0
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testFileContextIntegration ()
specifier|public
name|void
name|testFileContextIntegration
parameter_list|()
throws|throws
name|Throwable
block|{
name|describe
argument_list|(
literal|"Test that select works through FileContext"
argument_list|)
expr_stmt|;
name|FileContext
name|fc
init|=
name|S3ATestUtils
operator|.
name|createTestFileContext
argument_list|(
name|getConfiguration
argument_list|()
argument_list|)
decl_stmt|;
name|selectConf
operator|.
name|set
argument_list|(
name|CSV_INPUT_HEADER
argument_list|,
name|CSV_HEADER_OPT_USE
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|selected
init|=
name|verifySelectionCount
argument_list|(
name|ODD_ROWS_COUNT
argument_list|,
name|SELECT_ODD_ENTRIES_INT
argument_list|,
name|parseToLines
argument_list|(
name|select
argument_list|(
name|fc
argument_list|,
name|csvPath
argument_list|,
name|selectConf
argument_list|,
name|SELECT_ODD_ROWS
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
comment|// the list includes odd values
name|assertThat
argument_list|(
name|selected
argument_list|,
name|hasItem
argument_list|(
name|ENTRY_0001
argument_list|)
argument_list|)
expr_stmt|;
comment|// but not the evens
name|assertThat
argument_list|(
name|selected
argument_list|,
name|not
argument_list|(
name|hasItem
argument_list|(
name|ENTRY_0002
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testSelectOptionsOnlyOnSelectCalls ()
specifier|public
name|void
name|testSelectOptionsOnlyOnSelectCalls
parameter_list|()
throws|throws
name|Throwable
block|{
name|describe
argument_list|(
literal|"Secondary select options are only valid on select"
operator|+
literal|" queries"
argument_list|)
expr_stmt|;
name|String
name|key
init|=
name|CSV_INPUT_HEADER
decl_stmt|;
name|intercept
argument_list|(
name|IllegalArgumentException
operator|.
name|class
argument_list|,
name|key
argument_list|,
parameter_list|()
lambda|->
name|getFileSystem
argument_list|()
operator|.
name|openFile
argument_list|(
name|csvPath
argument_list|)
operator|.
name|must
argument_list|(
name|key
argument_list|,
name|CSV_HEADER_OPT_USE
argument_list|)
operator|.
name|build
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testSelectMustBeEnabled ()
specifier|public
name|void
name|testSelectMustBeEnabled
parameter_list|()
throws|throws
name|Throwable
block|{
name|describe
argument_list|(
literal|"Verify that the FS must have S3 select enabled."
argument_list|)
expr_stmt|;
name|Configuration
name|conf
init|=
operator|new
name|Configuration
argument_list|(
name|getFileSystem
argument_list|()
operator|.
name|getConf
argument_list|()
argument_list|)
decl_stmt|;
name|conf
operator|.
name|setBoolean
argument_list|(
name|FS_S3A_SELECT_ENABLED
argument_list|,
literal|false
argument_list|)
expr_stmt|;
try|try
init|(
name|FileSystem
name|fs2
init|=
name|FileSystem
operator|.
name|newInstance
argument_list|(
name|csvPath
operator|.
name|toUri
argument_list|()
argument_list|,
name|conf
argument_list|)
init|)
block|{
name|intercept
argument_list|(
name|UnsupportedOperationException
operator|.
name|class
argument_list|,
name|SELECT_UNSUPPORTED
argument_list|,
parameter_list|()
lambda|->
block|{
name|assertFalse
argument_list|(
literal|"S3 Select Capability must be disabled on "
operator|+
name|fs2
argument_list|,
name|isSelectAvailable
argument_list|(
name|fs2
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|fs2
operator|.
name|openFile
argument_list|(
name|csvPath
argument_list|)
operator|.
name|must
argument_list|(
name|SELECT_SQL
argument_list|,
name|SELECT_ODD_ROWS
argument_list|)
operator|.
name|build
argument_list|()
return|;
block|}
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Test
DECL|method|testSelectOptionsRejectedOnNormalOpen ()
specifier|public
name|void
name|testSelectOptionsRejectedOnNormalOpen
parameter_list|()
throws|throws
name|Throwable
block|{
name|describe
argument_list|(
literal|"Verify that a normal open fails on select must() options"
argument_list|)
expr_stmt|;
name|intercept
argument_list|(
name|IllegalArgumentException
operator|.
name|class
argument_list|,
name|AbstractFSBuilderImpl
operator|.
name|UNKNOWN_MANDATORY_KEY
argument_list|,
parameter_list|()
lambda|->
name|getFileSystem
argument_list|()
operator|.
name|openFile
argument_list|(
name|csvPath
argument_list|)
operator|.
name|must
argument_list|(
name|CSV_INPUT_HEADER
argument_list|,
name|CSV_HEADER_OPT_USE
argument_list|)
operator|.
name|build
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testSelectOddRecordsWithHeader ()
specifier|public
name|void
name|testSelectOddRecordsWithHeader
parameter_list|()
throws|throws
name|Throwable
block|{
name|describe
argument_list|(
literal|"work through a record reader"
argument_list|)
expr_stmt|;
name|JobConf
name|conf
init|=
name|createJobConf
argument_list|()
decl_stmt|;
name|inputMust
argument_list|(
name|conf
argument_list|,
name|CSV_INPUT_HEADER
argument_list|,
name|CSV_HEADER_OPT_USE
argument_list|)
expr_stmt|;
name|expectRecordsRead
argument_list|(
name|ODD_ROWS_COUNT
argument_list|,
name|conf
argument_list|,
name|SELECT_ODD_ENTRIES_DECIMAL
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testSelectDatestampsConverted ()
specifier|public
name|void
name|testSelectDatestampsConverted
parameter_list|()
throws|throws
name|Throwable
block|{
name|describe
argument_list|(
literal|"timestamp conversion in record IIO"
argument_list|)
expr_stmt|;
name|JobConf
name|conf
init|=
name|createJobConf
argument_list|()
decl_stmt|;
name|inputMust
argument_list|(
name|conf
argument_list|,
name|CSV_INPUT_HEADER
argument_list|,
name|CSV_HEADER_OPT_USE
argument_list|)
expr_stmt|;
name|inputMust
argument_list|(
name|conf
argument_list|,
name|CSV_OUTPUT_QUOTE_FIELDS
argument_list|,
name|CSV_OUTPUT_QUOTE_FIELDS_AS_NEEEDED
argument_list|)
expr_stmt|;
name|String
name|sql
init|=
name|SELECT_TO_DATE
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|records
init|=
name|expectRecordsRead
argument_list|(
name|ALL_ROWS_COUNT
argument_list|,
name|conf
argument_list|,
name|sql
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Result of {}\n{}"
argument_list|,
name|sql
argument_list|,
name|prepareToPrint
argument_list|(
name|records
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testSelectNoMatch ()
specifier|public
name|void
name|testSelectNoMatch
parameter_list|()
throws|throws
name|Throwable
block|{
name|describe
argument_list|(
literal|"when there's no match to a query, 0 records are returned,"
argument_list|)
expr_stmt|;
name|JobConf
name|conf
init|=
name|createJobConf
argument_list|()
decl_stmt|;
name|inputMust
argument_list|(
name|conf
argument_list|,
name|CSV_INPUT_HEADER
argument_list|,
name|CSV_HEADER_OPT_USE
argument_list|)
expr_stmt|;
name|expectRecordsRead
argument_list|(
literal|0
argument_list|,
name|conf
argument_list|,
literal|"SELECT * FROM S3OBJECT s WHERE s.odd = "
operator|+
name|q
argument_list|(
literal|"maybe"
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testSelectOddRecordsIgnoreHeader ()
specifier|public
name|void
name|testSelectOddRecordsIgnoreHeader
parameter_list|()
throws|throws
name|Throwable
block|{
name|describe
argument_list|(
literal|"work through a record reader"
argument_list|)
expr_stmt|;
name|JobConf
name|conf
init|=
name|createJobConf
argument_list|()
decl_stmt|;
name|inputOpt
argument_list|(
name|conf
argument_list|,
name|CSV_INPUT_HEADER
argument_list|,
name|CSV_HEADER_OPT_NONE
argument_list|)
expr_stmt|;
name|inputMust
argument_list|(
name|conf
argument_list|,
name|CSV_INPUT_HEADER
argument_list|,
name|CSV_HEADER_OPT_IGNORE
argument_list|)
expr_stmt|;
name|expectRecordsRead
argument_list|(
name|EVEN_ROWS_COUNT
argument_list|,
name|conf
argument_list|,
name|SELECT_EVEN_ROWS_NO_HEADER
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testSelectRecordsUnknownMustOpt ()
specifier|public
name|void
name|testSelectRecordsUnknownMustOpt
parameter_list|()
throws|throws
name|Throwable
block|{
name|describe
argument_list|(
literal|"verify reader key validation is remapped"
argument_list|)
expr_stmt|;
name|JobConf
name|conf
init|=
name|createJobConf
argument_list|()
decl_stmt|;
name|inputOpt
argument_list|(
name|conf
argument_list|,
name|CSV_INPUT_HEADER
argument_list|,
name|CSV_HEADER_OPT_NONE
argument_list|)
expr_stmt|;
name|inputMust
argument_list|(
name|conf
argument_list|,
name|CSV_INPUT_HEADER
operator|+
literal|".something"
argument_list|,
name|CSV_HEADER_OPT_IGNORE
argument_list|)
expr_stmt|;
name|intercept
argument_list|(
name|IllegalArgumentException
operator|.
name|class
argument_list|,
name|AbstractFSBuilderImpl
operator|.
name|UNKNOWN_MANDATORY_KEY
argument_list|,
parameter_list|()
lambda|->
name|readRecords
argument_list|(
name|conf
argument_list|,
name|SELECT_EVEN_ROWS_NO_HEADER
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testSelectOddRecordsWithHeaderV1 ()
specifier|public
name|void
name|testSelectOddRecordsWithHeaderV1
parameter_list|()
throws|throws
name|Throwable
block|{
name|describe
argument_list|(
literal|"work through a V1 record reader"
argument_list|)
expr_stmt|;
name|JobConf
name|conf
init|=
name|createJobConf
argument_list|()
decl_stmt|;
name|inputMust
argument_list|(
name|conf
argument_list|,
name|CSV_INPUT_HEADER
argument_list|,
name|CSV_HEADER_OPT_USE
argument_list|)
expr_stmt|;
comment|// using a double backslash here makes the string "\t" which will then
comment|// be parsed in the SelectBinding code as it if had come in on from an XML
comment|// entry
name|inputMust
argument_list|(
name|conf
argument_list|,
name|CSV_OUTPUT_FIELD_DELIMITER
argument_list|,
literal|"\\t"
argument_list|)
expr_stmt|;
name|inputMust
argument_list|(
name|conf
argument_list|,
name|CSV_OUTPUT_QUOTE_CHARACTER
argument_list|,
literal|"'"
argument_list|)
expr_stmt|;
name|inputMust
argument_list|(
name|conf
argument_list|,
name|CSV_OUTPUT_QUOTE_FIELDS
argument_list|,
name|CSV_OUTPUT_QUOTE_FIELDS_AS_NEEEDED
argument_list|)
expr_stmt|;
name|inputMust
argument_list|(
name|conf
argument_list|,
name|CSV_OUTPUT_RECORD_DELIMITER
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|verifySelectionCount
argument_list|(
name|ODD_ROWS_COUNT
argument_list|,
name|SELECT_ODD_ROWS
argument_list|,
name|readRecordsV1
argument_list|(
name|conf
argument_list|,
name|SELECT_ODD_ROWS
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Create a job conf for line reader tests.    * This patches the job with the passthrough codec for    * CSV files.    * @return a job configuration    */
DECL|method|createJobConf ()
specifier|private
name|JobConf
name|createJobConf
parameter_list|()
block|{
name|JobConf
name|conf
init|=
operator|new
name|JobConf
argument_list|(
name|getConfiguration
argument_list|()
argument_list|)
decl_stmt|;
name|enablePassthroughCodec
argument_list|(
name|conf
argument_list|,
literal|".csv"
argument_list|)
expr_stmt|;
return|return
name|conf
return|;
block|}
annotation|@
name|Test
DECL|method|testSelectOddRecordsIgnoreHeaderV1 ()
specifier|public
name|void
name|testSelectOddRecordsIgnoreHeaderV1
parameter_list|()
throws|throws
name|Throwable
block|{
name|describe
argument_list|(
literal|"work through a V1 record reader"
argument_list|)
expr_stmt|;
name|JobConf
name|conf
init|=
name|createJobConf
argument_list|()
decl_stmt|;
name|inputOpt
argument_list|(
name|conf
argument_list|,
name|CSV_INPUT_HEADER
argument_list|,
name|CSV_HEADER_OPT_NONE
argument_list|)
expr_stmt|;
name|inputMust
argument_list|(
name|conf
argument_list|,
name|CSV_INPUT_HEADER
argument_list|,
name|CSV_HEADER_OPT_IGNORE
argument_list|)
expr_stmt|;
name|inputMust
argument_list|(
name|conf
argument_list|,
name|INPUT_FADVISE
argument_list|,
name|INPUT_FADV_NORMAL
argument_list|)
expr_stmt|;
name|inputMust
argument_list|(
name|conf
argument_list|,
name|SELECT_ERRORS_INCLUDE_SQL
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|verifySelectionCount
argument_list|(
name|EVEN_ROWS_COUNT
argument_list|,
name|SELECT_EVEN_ROWS_NO_HEADER
argument_list|,
name|readRecordsV1
argument_list|(
name|conf
argument_list|,
name|SELECT_EVEN_ROWS_NO_HEADER
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|expectRecordsRead (final int expected, final JobConf conf, final String sql)
specifier|protected
name|List
argument_list|<
name|String
argument_list|>
name|expectRecordsRead
parameter_list|(
specifier|final
name|int
name|expected
parameter_list|,
specifier|final
name|JobConf
name|conf
parameter_list|,
specifier|final
name|String
name|sql
parameter_list|)
throws|throws
name|Exception
block|{
return|return
name|verifySelectionCount
argument_list|(
name|expected
argument_list|,
name|sql
argument_list|,
name|readRecords
argument_list|(
name|conf
argument_list|,
name|sql
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Reads lines through {@link LineRecordReader}, as if it were an MR    * job.    * @param conf jpb conf    * @param sql sql to add to the configuration.    * @return the selected lines.    * @throws Exception failure    */
DECL|method|readRecords (JobConf conf, String sql)
specifier|private
name|List
argument_list|<
name|String
argument_list|>
name|readRecords
parameter_list|(
name|JobConf
name|conf
parameter_list|,
name|String
name|sql
parameter_list|)
throws|throws
name|Exception
block|{
return|return
name|readRecords
argument_list|(
name|conf
argument_list|,
name|csvPath
argument_list|,
name|sql
argument_list|,
name|createLineRecordReader
argument_list|()
argument_list|,
name|ALL_ROWS_COUNT_WITH_HEADER
argument_list|)
return|;
block|}
comment|/**    * Reads lines through a v1 LineRecordReader}.    * @param conf jpb conf    * @param sql sql to add to the configuration.    * @return the selected lines.    * @throws Exception failure    */
DECL|method|readRecordsV1 (JobConf conf, String sql)
specifier|private
name|List
argument_list|<
name|String
argument_list|>
name|readRecordsV1
parameter_list|(
name|JobConf
name|conf
parameter_list|,
name|String
name|sql
parameter_list|)
throws|throws
name|Exception
block|{
name|inputMust
argument_list|(
name|conf
argument_list|,
name|SELECT_SQL
argument_list|,
name|sql
argument_list|)
expr_stmt|;
return|return
name|super
operator|.
name|readRecordsV1
argument_list|(
name|conf
argument_list|,
name|createLineRecordReaderV1
argument_list|(
name|conf
argument_list|,
name|csvPath
argument_list|)
argument_list|,
operator|new
name|LongWritable
argument_list|()
argument_list|,
operator|new
name|Text
argument_list|()
argument_list|,
name|ALL_ROWS_COUNT_WITH_HEADER
argument_list|)
return|;
block|}
comment|/**    * Issue a select call, expect the specific number of rows back.    * Error text will include the SQL.    * @param expected expected row count.    * @param conf config for the select call.    * @param header header option    * @param sql template for a formatted SQL request.    * @param args arguments for the formatted request.    * @return the lines selected    * @throws IOException failure    */
DECL|method|expectSelected ( final int expected, final Configuration conf, final String header, final String sql, final Object...args)
specifier|private
name|List
argument_list|<
name|String
argument_list|>
name|expectSelected
parameter_list|(
specifier|final
name|int
name|expected
parameter_list|,
specifier|final
name|Configuration
name|conf
parameter_list|,
specifier|final
name|String
name|header
parameter_list|,
specifier|final
name|String
name|sql
parameter_list|,
specifier|final
name|Object
modifier|...
name|args
parameter_list|)
throws|throws
name|Exception
block|{
name|conf
operator|.
name|set
argument_list|(
name|CSV_INPUT_HEADER
argument_list|,
name|header
argument_list|)
expr_stmt|;
return|return
name|verifySelectionCount
argument_list|(
name|expected
argument_list|,
name|sql
argument_list|(
name|sql
argument_list|,
name|args
argument_list|)
argument_list|,
name|selectCsvFile
argument_list|(
name|conf
argument_list|,
name|sql
argument_list|,
name|args
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Select from the CSV file.    * @param conf config for the select call.    * @param sql template for a formatted SQL request.    * @param args arguments for the formatted request.    * @return the lines selected    * @throws IOException failure    */
DECL|method|selectCsvFile ( final Configuration conf, final String sql, final Object...args)
specifier|private
name|List
argument_list|<
name|String
argument_list|>
name|selectCsvFile
parameter_list|(
specifier|final
name|Configuration
name|conf
parameter_list|,
specifier|final
name|String
name|sql
parameter_list|,
specifier|final
name|Object
modifier|...
name|args
parameter_list|)
throws|throws
name|Exception
block|{
return|return
name|parseToLines
argument_list|(
name|select
argument_list|(
name|getFileSystem
argument_list|()
argument_list|,
name|csvPath
argument_list|,
name|conf
argument_list|,
name|sql
argument_list|,
name|args
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Test
DECL|method|testCommentsSkipped ()
specifier|public
name|void
name|testCommentsSkipped
parameter_list|()
throws|throws
name|Throwable
block|{
name|describe
argument_list|(
literal|"Verify that comments are skipped"
argument_list|)
expr_stmt|;
name|selectConf
operator|.
name|set
argument_list|(
name|CSV_INPUT_HEADER
argument_list|,
name|CSV_HEADER_OPT_USE
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|lines
init|=
name|verifySelectionCount
argument_list|(
name|ALL_ROWS_COUNT_WITH_HEADER
argument_list|,
literal|"select s.id"
argument_list|,
name|parseToLines
argument_list|(
name|select
argument_list|(
name|getFileSystem
argument_list|()
argument_list|,
name|brokenCSV
argument_list|,
name|selectConf
argument_list|,
literal|"SELECT * FROM S3OBJECT s"
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"\n{}"
argument_list|,
name|prepareToPrint
argument_list|(
name|lines
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testEmptyColumnsRegenerated ()
specifier|public
name|void
name|testEmptyColumnsRegenerated
parameter_list|()
throws|throws
name|Throwable
block|{
name|describe
argument_list|(
literal|"if you ask for a column but your row doesn't have it,"
operator|+
literal|" an empty column is inserted"
argument_list|)
expr_stmt|;
name|selectConf
operator|.
name|set
argument_list|(
name|CSV_INPUT_HEADER
argument_list|,
name|CSV_HEADER_OPT_USE
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|lines
init|=
name|verifySelectionCount
argument_list|(
name|ALL_ROWS_COUNT_WITH_HEADER
argument_list|,
literal|"select s.oddrange"
argument_list|,
name|parseToLines
argument_list|(
name|select
argument_list|(
name|getFileSystem
argument_list|()
argument_list|,
name|brokenCSV
argument_list|,
name|selectConf
argument_list|,
literal|"SELECT s.oddrange FROM S3OBJECT s"
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"\n{}"
argument_list|,
name|prepareToPrint
argument_list|(
name|lines
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Final oddrange column is not regenerated empty"
argument_list|,
literal|"\"\""
argument_list|,
name|lines
operator|.
name|get
argument_list|(
name|lines
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testIntCastFailure ()
specifier|public
name|void
name|testIntCastFailure
parameter_list|()
throws|throws
name|Throwable
block|{
name|describe
argument_list|(
literal|"Verify that int casts fail"
argument_list|)
expr_stmt|;
name|expectSelectFailure
argument_list|(
name|E_CAST_FAILED
argument_list|,
name|SELECT_ODD_ENTRIES_INT
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testSelectToDateParseFailure ()
specifier|public
name|void
name|testSelectToDateParseFailure
parameter_list|()
throws|throws
name|Throwable
block|{
name|describe
argument_list|(
literal|"Verify date parsing failure"
argument_list|)
expr_stmt|;
name|expectSelectFailure
argument_list|(
name|E_CAST_FAILED
argument_list|,
name|SELECT_TO_DATE
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testParseInvalidPathComponent ()
specifier|public
name|void
name|testParseInvalidPathComponent
parameter_list|()
throws|throws
name|Throwable
block|{
name|describe
argument_list|(
literal|"Verify bad SQL parseing"
argument_list|)
expr_stmt|;
name|expectSelectFailure
argument_list|(
name|E_PARSE_INVALID_PATH_COMPONENT
argument_list|,
literal|"SELECT * FROM S3OBJECT WHERE s.'oddf' = true"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testSelectInvalidTableAlias ()
specifier|public
name|void
name|testSelectInvalidTableAlias
parameter_list|()
throws|throws
name|Throwable
block|{
name|describe
argument_list|(
literal|"select with unknown column name"
argument_list|)
expr_stmt|;
name|expectSelectFailure
argument_list|(
name|E_INVALID_TABLE_ALIAS
argument_list|,
literal|"SELECT * FROM S3OBJECT WHERE s.\"oddf\" = 'true'"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testSelectGeneratedAliases ()
specifier|public
name|void
name|testSelectGeneratedAliases
parameter_list|()
throws|throws
name|Throwable
block|{
name|describe
argument_list|(
literal|"select with a ._2 column when headers are enabled"
argument_list|)
expr_stmt|;
name|expectSelectFailure
argument_list|(
name|E_INVALID_TABLE_ALIAS
argument_list|,
literal|"SELECT * FROM S3OBJECT WHERE s._2 = 'true'"
argument_list|)
expr_stmt|;
block|}
comment|/**    * Expect select against the broken CSV file to fail with a specific    * AWS exception error code.    * If the is no failure, the results are included in the assertion raised.    * @param expectedErrorCode error code in getErrorCode()    * @param sql SQL to invoke    * @return the exception, if it is as expected.    * @throws Exception any other failure    * @throws AssertionError when an exception is raised, but its error code    * is different, or when no exception was raised.    */
DECL|method|expectSelectFailure ( String expectedErrorCode, String sql)
specifier|protected
name|AWSServiceIOException
name|expectSelectFailure
parameter_list|(
name|String
name|expectedErrorCode
parameter_list|,
name|String
name|sql
parameter_list|)
throws|throws
name|Exception
block|{
name|selectConf
operator|.
name|set
argument_list|(
name|CSV_INPUT_HEADER
argument_list|,
name|CSV_HEADER_OPT_USE
argument_list|)
expr_stmt|;
return|return
name|verifyErrorCode
argument_list|(
name|expectedErrorCode
argument_list|,
name|intercept
argument_list|(
name|AWSBadRequestException
operator|.
name|class
argument_list|,
parameter_list|()
lambda|->
name|prepareToPrint
argument_list|(
name|parseToLines
argument_list|(
name|select
argument_list|(
name|getFileSystem
argument_list|()
argument_list|,
name|brokenCSV
argument_list|,
name|selectConf
argument_list|,
name|sql
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Test
DECL|method|testInputSplit ()
specifier|public
name|void
name|testInputSplit
parameter_list|()
throws|throws
name|Throwable
block|{
name|describe
argument_list|(
literal|"Verify that only a single file is used for splits"
argument_list|)
expr_stmt|;
name|JobConf
name|conf
init|=
operator|new
name|JobConf
argument_list|(
name|getConfiguration
argument_list|()
argument_list|)
decl_stmt|;
name|inputMust
argument_list|(
name|conf
argument_list|,
name|CSV_INPUT_HEADER
argument_list|,
name|CSV_HEADER_OPT_USE
argument_list|)
expr_stmt|;
specifier|final
name|Path
name|input
init|=
name|csvPath
decl_stmt|;
name|S3AFileSystem
name|fs
init|=
name|getFileSystem
argument_list|()
decl_stmt|;
specifier|final
name|Path
name|output
init|=
name|path
argument_list|(
literal|"testLandsatSelect"
argument_list|)
operator|.
name|makeQualified
argument_list|(
name|fs
operator|.
name|getUri
argument_list|()
argument_list|,
name|fs
operator|.
name|getWorkingDirectory
argument_list|()
argument_list|)
decl_stmt|;
name|conf
operator|.
name|set
argument_list|(
name|FileInputFormat
operator|.
name|INPUT_DIR
argument_list|,
name|input
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|conf
operator|.
name|set
argument_list|(
name|FileOutputFormat
operator|.
name|OUTDIR
argument_list|,
name|output
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|Job
name|job
init|=
name|Job
operator|.
name|getInstance
argument_list|(
name|conf
argument_list|,
literal|"testInputSplit"
argument_list|)
decl_stmt|;
name|JobContext
name|jobCtx
init|=
operator|new
name|JobContextImpl
argument_list|(
name|job
operator|.
name|getConfiguration
argument_list|()
argument_list|,
name|getTaskAttempt0
argument_list|()
operator|.
name|getJobID
argument_list|()
argument_list|)
decl_stmt|;
name|TextInputFormat
name|tif
init|=
operator|new
name|TextInputFormat
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|InputSplit
argument_list|>
name|splits
init|=
name|tif
operator|.
name|getSplits
argument_list|(
name|jobCtx
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
literal|"split count wrong"
argument_list|,
name|splits
argument_list|,
name|hasSize
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_class

end_unit

