begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  *  or more contributor license agreements.  See the NOTICE file  *  distributed with this work for additional information  *  regarding copyright ownership.  The ASF licenses this file  *  to you under the Apache License, Version 2.0 (the  *  "License"); you may not use this file except in compliance  *  with the License.  You may obtain a copy of the License at  *  *       http://www.apache.org/licenses/LICENSE-2.0  *  *  Unless required by applicable law or agreed to in writing, software  *  distributed under the License is distributed on an "AS IS" BASIS,  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  *  See the License for the specific language governing permissions and  *  limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.fs.s3a
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileNotFoundException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|Charset
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Optional
import|;
end_import

begin_import
import|import
name|com
operator|.
name|amazonaws
operator|.
name|AmazonClientException
import|;
end_import

begin_import
import|import
name|com
operator|.
name|amazonaws
operator|.
name|services
operator|.
name|s3
operator|.
name|AmazonS3
import|;
end_import

begin_import
import|import
name|com
operator|.
name|amazonaws
operator|.
name|services
operator|.
name|s3
operator|.
name|model
operator|.
name|CopyObjectRequest
import|;
end_import

begin_import
import|import
name|com
operator|.
name|amazonaws
operator|.
name|services
operator|.
name|s3
operator|.
name|model
operator|.
name|CopyObjectResult
import|;
end_import

begin_import
import|import
name|com
operator|.
name|amazonaws
operator|.
name|services
operator|.
name|s3
operator|.
name|model
operator|.
name|GetObjectMetadataRequest
import|;
end_import

begin_import
import|import
name|com
operator|.
name|amazonaws
operator|.
name|services
operator|.
name|s3
operator|.
name|model
operator|.
name|GetObjectRequest
import|;
end_import

begin_import
import|import
name|com
operator|.
name|amazonaws
operator|.
name|services
operator|.
name|s3
operator|.
name|model
operator|.
name|ObjectMetadata
import|;
end_import

begin_import
import|import
name|com
operator|.
name|amazonaws
operator|.
name|services
operator|.
name|s3
operator|.
name|model
operator|.
name|S3Object
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Charsets
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Assume
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Test
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|runner
operator|.
name|RunWith
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|runners
operator|.
name|Parameterized
import|;
end_import

begin_import
import|import
name|org
operator|.
name|mockito
operator|.
name|ArgumentMatchers
import|;
end_import

begin_import
import|import
name|org
operator|.
name|mockito
operator|.
name|Mockito
import|;
end_import

begin_import
import|import
name|org
operator|.
name|mockito
operator|.
name|invocation
operator|.
name|InvocationOnMock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|mockito
operator|.
name|stubbing
operator|.
name|Answer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|io
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang3
operator|.
name|tuple
operator|.
name|Pair
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FSDataInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|impl
operator|.
name|ChangeDetectionPolicy
operator|.
name|Mode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|impl
operator|.
name|ChangeDetectionPolicy
operator|.
name|Source
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|s3guard
operator|.
name|LocalMetadataStore
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|s3guard
operator|.
name|MetadataStore
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|s3guard
operator|.
name|NullMetadataStore
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|s3guard
operator|.
name|PathMetadata
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|contract
operator|.
name|ContractTestUtils
operator|.
name|dataset
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|contract
operator|.
name|ContractTestUtils
operator|.
name|readUTF8
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|contract
operator|.
name|ContractTestUtils
operator|.
name|writeDataset
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|Constants
operator|.
name|*
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|S3ATestUtils
operator|.
name|removeBaseAndBucketOverrides
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|impl
operator|.
name|ChangeDetectionPolicy
operator|.
name|CHANGE_DETECTED
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|select
operator|.
name|SelectConstants
operator|.
name|S3_SELECT_CAPABILITY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|select
operator|.
name|SelectConstants
operator|.
name|SELECT_SQL
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|test
operator|.
name|LambdaTestUtils
operator|.
name|eventually
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|test
operator|.
name|LambdaTestUtils
operator|.
name|intercept
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|test
operator|.
name|LambdaTestUtils
operator|.
name|interceptFuture
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|mockito
operator|.
name|Mockito
operator|.
name|doAnswer
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|mockito
operator|.
name|Mockito
operator|.
name|when
import|;
end_import

begin_comment
comment|/**  * Test S3A remote file change detection.  * This is a very parameterized test; the first three parameters  * define configuration options for the tests, while the final one  * declares the expected outcomes given those options.  *  * This test uses mocking to insert transient failures into the S3 client,  * underneath the S3A Filesystem instance.  *  * This is used to simulate eventual consistency, so force the change policy  * failure modes to be encountered.  *  * If changes are made to the filesystem such that the number of calls to  * operations such as {@link S3AFileSystem#getObjectMetadata(Path)} are  * changed, the number of failures which the mock layer must generate may  * change.  *  * As the S3Guard auth mode flag does control whether or not a HEAD is issued  * in a call to {@code getFileStatus()}; the test parameter {@link #authMode}  * is used to help predict this count.  *  *<i>Important:</i> if you are seeing failures in this test after changing  * one of the rename/copy/open operations, it may be that an increase,  * decrease or change in the number of low-level S3 HEAD/GET operations is  * triggering the failures.  * Please review the changes to see that you haven't unintentionally done this.  * If it is intentional, please update the parameters here.  *  * If you are seeing failures without such a change, and nobody else is,  * it is likely that you have a different bucket configuration option which  * is somehow triggering a regression. If you can work out which option  * this is, then extend {@link #createConfiguration()} to reset that parameter  * too.  *  * Note: to help debug these issues, set the log for this to DEBUG:  *<pre>  *   log4j.logger.org.apache.hadoop.fs.s3a.ITestS3ARemoteFileChanged=DEBUG  *</pre>  * The debug information printed will include a trace of where operations  * are being called from, to help understand why the test is failing.  */
end_comment

begin_class
annotation|@
name|RunWith
argument_list|(
name|Parameterized
operator|.
name|class
argument_list|)
DECL|class|ITestS3ARemoteFileChanged
specifier|public
class|class
name|ITestS3ARemoteFileChanged
extends|extends
name|AbstractS3ATestBase
block|{
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|ITestS3ARemoteFileChanged
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|TEST_DATA
specifier|private
specifier|static
specifier|final
name|String
name|TEST_DATA
init|=
literal|"Some test data"
decl_stmt|;
DECL|field|TEST_DATA_BYTES
specifier|private
specifier|static
specifier|final
name|byte
index|[]
name|TEST_DATA_BYTES
init|=
name|TEST_DATA
operator|.
name|getBytes
argument_list|(
name|Charsets
operator|.
name|UTF_8
argument_list|)
decl_stmt|;
DECL|field|TEST_MAX_RETRIES
specifier|private
specifier|static
specifier|final
name|int
name|TEST_MAX_RETRIES
init|=
literal|4
decl_stmt|;
DECL|field|TEST_RETRY_INTERVAL
specifier|private
specifier|static
specifier|final
name|String
name|TEST_RETRY_INTERVAL
init|=
literal|"1ms"
decl_stmt|;
DECL|field|QUOTED_TEST_DATA
specifier|private
specifier|static
specifier|final
name|String
name|QUOTED_TEST_DATA
init|=
literal|"\""
operator|+
name|TEST_DATA
operator|+
literal|"\""
decl_stmt|;
DECL|field|originalS3Client
specifier|private
name|Optional
argument_list|<
name|AmazonS3
argument_list|>
name|originalS3Client
init|=
name|Optional
operator|.
name|empty
argument_list|()
decl_stmt|;
DECL|enum|InteractionType
specifier|private
enum|enum
name|InteractionType
block|{
DECL|enumConstant|READ
name|READ
block|,
DECL|enumConstant|READ_AFTER_DELETE
name|READ_AFTER_DELETE
block|,
DECL|enumConstant|EVENTUALLY_CONSISTENT_READ
name|EVENTUALLY_CONSISTENT_READ
block|,
DECL|enumConstant|COPY
name|COPY
block|,
DECL|enumConstant|EVENTUALLY_CONSISTENT_COPY
name|EVENTUALLY_CONSISTENT_COPY
block|,
DECL|enumConstant|EVENTUALLY_CONSISTENT_METADATA
name|EVENTUALLY_CONSISTENT_METADATA
block|,
DECL|enumConstant|SELECT
name|SELECT
block|,
DECL|enumConstant|EVENTUALLY_CONSISTENT_SELECT
name|EVENTUALLY_CONSISTENT_SELECT
block|}
DECL|field|changeDetectionSource
specifier|private
specifier|final
name|String
name|changeDetectionSource
decl_stmt|;
DECL|field|changeDetectionMode
specifier|private
specifier|final
name|String
name|changeDetectionMode
decl_stmt|;
DECL|field|authMode
specifier|private
specifier|final
name|boolean
name|authMode
decl_stmt|;
DECL|field|expectedExceptionInteractions
specifier|private
specifier|final
name|Collection
argument_list|<
name|InteractionType
argument_list|>
name|expectedExceptionInteractions
decl_stmt|;
DECL|field|fs
specifier|private
name|S3AFileSystem
name|fs
decl_stmt|;
comment|/**    * Test parameters.    *<ol>    *<li>Change detection source: etag or version.</li>    *<li>Change detection policy: server, client, client+warn, none</li>    *<li>Whether to enable auth mode on the filesystem.</li>    *<li>Expected outcomes.</li>    *</ol>    * @return the test configuration.    */
annotation|@
name|Parameterized
operator|.
name|Parameters
argument_list|(
name|name
operator|=
literal|"{0}-{1}-auth-{2}"
argument_list|)
DECL|method|params ()
specifier|public
specifier|static
name|Collection
argument_list|<
name|Object
index|[]
argument_list|>
name|params
parameter_list|()
block|{
return|return
name|Arrays
operator|.
name|asList
argument_list|(
operator|new
name|Object
index|[]
index|[]
block|{
comment|// make sure it works with invalid config
block|{
literal|"bogus"
block|,
literal|"bogus"
block|,
literal|true
block|,
name|Arrays
operator|.
name|asList
argument_list|(
name|InteractionType
operator|.
name|READ
argument_list|,
name|InteractionType
operator|.
name|READ_AFTER_DELETE
argument_list|,
name|InteractionType
operator|.
name|EVENTUALLY_CONSISTENT_READ
argument_list|,
name|InteractionType
operator|.
name|COPY
argument_list|,
name|InteractionType
operator|.
name|EVENTUALLY_CONSISTENT_COPY
argument_list|,
name|InteractionType
operator|.
name|EVENTUALLY_CONSISTENT_METADATA
argument_list|,
name|InteractionType
operator|.
name|SELECT
argument_list|,
name|InteractionType
operator|.
name|EVENTUALLY_CONSISTENT_SELECT
argument_list|)
block|}
block|,
comment|// test with etag
block|{
name|CHANGE_DETECT_SOURCE_ETAG
block|,
name|CHANGE_DETECT_MODE_SERVER
block|,
literal|true
block|,
name|Arrays
operator|.
name|asList
argument_list|(
name|InteractionType
operator|.
name|READ
argument_list|,
name|InteractionType
operator|.
name|READ_AFTER_DELETE
argument_list|,
name|InteractionType
operator|.
name|EVENTUALLY_CONSISTENT_READ
argument_list|,
name|InteractionType
operator|.
name|COPY
argument_list|,
name|InteractionType
operator|.
name|EVENTUALLY_CONSISTENT_COPY
argument_list|,
name|InteractionType
operator|.
name|EVENTUALLY_CONSISTENT_METADATA
argument_list|,
name|InteractionType
operator|.
name|SELECT
argument_list|,
name|InteractionType
operator|.
name|EVENTUALLY_CONSISTENT_SELECT
argument_list|)
block|}
block|,
block|{
name|CHANGE_DETECT_SOURCE_ETAG
block|,
name|CHANGE_DETECT_MODE_CLIENT
block|,
literal|false
block|,
name|Arrays
operator|.
name|asList
argument_list|(
name|InteractionType
operator|.
name|READ
argument_list|,
name|InteractionType
operator|.
name|EVENTUALLY_CONSISTENT_READ
argument_list|,
name|InteractionType
operator|.
name|READ_AFTER_DELETE
argument_list|,
name|InteractionType
operator|.
name|COPY
argument_list|,
comment|// not InteractionType.EVENTUALLY_CONSISTENT_COPY as copy change
comment|// detection can't really occur client-side.  The eTag of
comment|// the new object can't be expected to match.
name|InteractionType
operator|.
name|EVENTUALLY_CONSISTENT_METADATA
argument_list|,
name|InteractionType
operator|.
name|SELECT
argument_list|,
name|InteractionType
operator|.
name|EVENTUALLY_CONSISTENT_SELECT
argument_list|)
block|}
block|,
block|{
name|CHANGE_DETECT_SOURCE_ETAG
block|,
name|CHANGE_DETECT_MODE_WARN
block|,
literal|false
block|,
name|Arrays
operator|.
name|asList
argument_list|(
name|InteractionType
operator|.
name|READ_AFTER_DELETE
argument_list|)
block|}
block|,
block|{
name|CHANGE_DETECT_SOURCE_ETAG
block|,
name|CHANGE_DETECT_MODE_NONE
block|,
literal|false
block|,
name|Arrays
operator|.
name|asList
argument_list|(
name|InteractionType
operator|.
name|READ_AFTER_DELETE
argument_list|)
block|}
block|,
comment|// test with versionId
comment|// when using server-side versionId, the exceptions
comment|// shouldn't happen since the previous version will still be available
block|{
name|CHANGE_DETECT_SOURCE_VERSION_ID
block|,
name|CHANGE_DETECT_MODE_SERVER
block|,
literal|true
block|,
name|Arrays
operator|.
name|asList
argument_list|(
name|InteractionType
operator|.
name|EVENTUALLY_CONSISTENT_READ
argument_list|,
name|InteractionType
operator|.
name|EVENTUALLY_CONSISTENT_COPY
argument_list|,
name|InteractionType
operator|.
name|EVENTUALLY_CONSISTENT_METADATA
argument_list|,
name|InteractionType
operator|.
name|EVENTUALLY_CONSISTENT_SELECT
argument_list|)
block|}
block|,
comment|// with client-side versionId it will behave similar to client-side eTag
block|{
name|CHANGE_DETECT_SOURCE_VERSION_ID
block|,
name|CHANGE_DETECT_MODE_CLIENT
block|,
literal|false
block|,
name|Arrays
operator|.
name|asList
argument_list|(
name|InteractionType
operator|.
name|READ
argument_list|,
name|InteractionType
operator|.
name|READ_AFTER_DELETE
argument_list|,
name|InteractionType
operator|.
name|EVENTUALLY_CONSISTENT_READ
argument_list|,
name|InteractionType
operator|.
name|COPY
argument_list|,
comment|// not InteractionType.EVENTUALLY_CONSISTENT_COPY as copy change
comment|// detection can't really occur client-side.  The versionId of
comment|// the new object can't be expected to match.
name|InteractionType
operator|.
name|EVENTUALLY_CONSISTENT_METADATA
argument_list|,
name|InteractionType
operator|.
name|SELECT
argument_list|,
name|InteractionType
operator|.
name|EVENTUALLY_CONSISTENT_SELECT
argument_list|)
block|}
block|,
block|{
name|CHANGE_DETECT_SOURCE_VERSION_ID
block|,
name|CHANGE_DETECT_MODE_WARN
block|,
literal|true
block|,
name|Arrays
operator|.
name|asList
argument_list|(
name|InteractionType
operator|.
name|READ_AFTER_DELETE
argument_list|)
block|}
block|,
block|{
name|CHANGE_DETECT_SOURCE_VERSION_ID
block|,
name|CHANGE_DETECT_MODE_NONE
block|,
literal|false
block|,
name|Arrays
operator|.
name|asList
argument_list|(
name|InteractionType
operator|.
name|READ_AFTER_DELETE
argument_list|)
block|}
block|}
argument_list|)
return|;
block|}
DECL|method|ITestS3ARemoteFileChanged (String changeDetectionSource, String changeDetectionMode, boolean authMode, Collection<InteractionType> expectedExceptionInteractions)
specifier|public
name|ITestS3ARemoteFileChanged
parameter_list|(
name|String
name|changeDetectionSource
parameter_list|,
name|String
name|changeDetectionMode
parameter_list|,
name|boolean
name|authMode
parameter_list|,
name|Collection
argument_list|<
name|InteractionType
argument_list|>
name|expectedExceptionInteractions
parameter_list|)
block|{
name|this
operator|.
name|changeDetectionSource
operator|=
name|changeDetectionSource
expr_stmt|;
name|this
operator|.
name|changeDetectionMode
operator|=
name|changeDetectionMode
expr_stmt|;
name|this
operator|.
name|authMode
operator|=
name|authMode
expr_stmt|;
name|this
operator|.
name|expectedExceptionInteractions
operator|=
name|expectedExceptionInteractions
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|setup ()
specifier|public
name|void
name|setup
parameter_list|()
throws|throws
name|Exception
block|{
name|super
operator|.
name|setup
argument_list|()
expr_stmt|;
comment|// skip all versioned checks if the remote FS doesn't do
comment|// versions.
name|fs
operator|=
name|getFileSystem
argument_list|()
expr_stmt|;
name|skipIfVersionPolicyAndNoVersionId
argument_list|()
expr_stmt|;
comment|// cache the original S3 client for teardown.
name|originalS3Client
operator|=
name|Optional
operator|.
name|of
argument_list|(
name|fs
operator|.
name|getAmazonS3ClientForTesting
argument_list|(
literal|"caching"
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|teardown ()
specifier|public
name|void
name|teardown
parameter_list|()
throws|throws
name|Exception
block|{
comment|// restore the s3 client so there's no mocking interfering with the teardown
name|originalS3Client
operator|.
name|ifPresent
argument_list|(
name|fs
operator|::
name|setAmazonS3Client
argument_list|)
expr_stmt|;
name|super
operator|.
name|teardown
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|createConfiguration ()
specifier|protected
name|Configuration
name|createConfiguration
parameter_list|()
block|{
name|Configuration
name|conf
init|=
name|super
operator|.
name|createConfiguration
argument_list|()
decl_stmt|;
name|removeBaseAndBucketOverrides
argument_list|(
name|conf
argument_list|,
name|CHANGE_DETECT_SOURCE
argument_list|,
name|CHANGE_DETECT_MODE
argument_list|,
name|RETRY_LIMIT
argument_list|,
name|RETRY_INTERVAL
argument_list|,
name|METADATASTORE_AUTHORITATIVE
argument_list|)
expr_stmt|;
name|conf
operator|.
name|set
argument_list|(
name|CHANGE_DETECT_SOURCE
argument_list|,
name|changeDetectionSource
argument_list|)
expr_stmt|;
name|conf
operator|.
name|set
argument_list|(
name|CHANGE_DETECT_MODE
argument_list|,
name|changeDetectionMode
argument_list|)
expr_stmt|;
name|conf
operator|.
name|setBoolean
argument_list|(
name|METADATASTORE_AUTHORITATIVE
argument_list|,
name|authMode
argument_list|)
expr_stmt|;
comment|// reduce retry limit so FileNotFoundException cases timeout faster,
comment|// speeding up the tests
name|conf
operator|.
name|setInt
argument_list|(
name|RETRY_LIMIT
argument_list|,
name|TEST_MAX_RETRIES
argument_list|)
expr_stmt|;
name|conf
operator|.
name|set
argument_list|(
name|RETRY_INTERVAL
argument_list|,
name|TEST_RETRY_INTERVAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|conf
operator|.
name|getClass
argument_list|(
name|S3_METADATA_STORE_IMPL
argument_list|,
name|MetadataStore
operator|.
name|class
argument_list|)
operator|==
name|NullMetadataStore
operator|.
name|class
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Enabling local S3Guard metadata store"
argument_list|)
expr_stmt|;
comment|// favor LocalMetadataStore over NullMetadataStore
name|conf
operator|.
name|setClass
argument_list|(
name|S3_METADATA_STORE_IMPL
argument_list|,
name|LocalMetadataStore
operator|.
name|class
argument_list|,
name|MetadataStore
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
name|S3ATestUtils
operator|.
name|disableFilesystemCaching
argument_list|(
name|conf
argument_list|)
expr_stmt|;
return|return
name|conf
return|;
block|}
comment|/**    * Get the path of this method, including parameterized values.    * @return a path unique to this method and parameters    * @throws IOException failure.    */
DECL|method|path ()
specifier|protected
name|Path
name|path
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|super
operator|.
name|path
argument_list|(
name|getMethodName
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * How many HEAD requests are made in a call to    * {@link S3AFileSystem#getFileStatus(Path)}?    * @return a number>= 0.    */
DECL|method|getFileStatusHeadCount ()
specifier|private
name|int
name|getFileStatusHeadCount
parameter_list|()
block|{
return|return
name|authMode
condition|?
literal|0
else|:
literal|1
return|;
block|}
comment|/**    * Tests reading a file that is changed while the reader's InputStream is    * open.    */
annotation|@
name|Test
DECL|method|testReadFileChangedStreamOpen ()
specifier|public
name|void
name|testReadFileChangedStreamOpen
parameter_list|()
throws|throws
name|Throwable
block|{
name|describe
argument_list|(
literal|"Tests reading a file that is changed while the reader's "
operator|+
literal|"InputStream is open."
argument_list|)
expr_stmt|;
specifier|final
name|int
name|originalLength
init|=
literal|8192
decl_stmt|;
specifier|final
name|byte
index|[]
name|originalDataset
init|=
name|dataset
argument_list|(
name|originalLength
argument_list|,
literal|'a'
argument_list|,
literal|32
argument_list|)
decl_stmt|;
specifier|final
name|int
name|newLength
init|=
name|originalLength
operator|+
literal|1
decl_stmt|;
specifier|final
name|byte
index|[]
name|newDataset
init|=
name|dataset
argument_list|(
name|newLength
argument_list|,
literal|'A'
argument_list|,
literal|32
argument_list|)
decl_stmt|;
specifier|final
name|Path
name|testpath
init|=
name|path
argument_list|(
literal|"readFileToChange.txt"
argument_list|)
decl_stmt|;
comment|// initial write
name|writeDataset
argument_list|(
name|fs
argument_list|,
name|testpath
argument_list|,
name|originalDataset
argument_list|,
name|originalDataset
operator|.
name|length
argument_list|,
literal|1024
argument_list|,
literal|false
argument_list|)
expr_stmt|;
try|try
init|(
name|FSDataInputStream
name|instream
init|=
name|fs
operator|.
name|open
argument_list|(
name|testpath
argument_list|)
init|)
block|{
comment|// seek forward and read successfully
name|instream
operator|.
name|seek
argument_list|(
literal|1024
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"no data to read"
argument_list|,
name|instream
operator|.
name|read
argument_list|()
operator|>=
literal|0
argument_list|)
expr_stmt|;
comment|// overwrite
name|writeDataset
argument_list|(
name|fs
argument_list|,
name|testpath
argument_list|,
name|newDataset
argument_list|,
name|newDataset
operator|.
name|length
argument_list|,
literal|1024
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|// here the new file length is larger. Probe the file to see if this is
comment|// true, with a spin and wait
name|eventually
argument_list|(
literal|30
operator|*
literal|1000
argument_list|,
literal|1000
argument_list|,
parameter_list|()
lambda|->
block|{
name|assertEquals
argument_list|(
name|newLength
argument_list|,
name|fs
operator|.
name|getFileStatus
argument_list|(
name|testpath
argument_list|)
operator|.
name|getLen
argument_list|()
argument_list|)
expr_stmt|;
block|}
argument_list|)
expr_stmt|;
comment|// With the new file version in place, any subsequent S3 read by
comment|// eTag/versionId will fail.  A new read by eTag/versionId will occur in
comment|// reopen() on read after a seek() backwards.  We verify seek backwards
comment|// results in the expected exception and seek() forward works without
comment|// issue.
comment|// first check seek forward
name|instream
operator|.
name|seek
argument_list|(
literal|2048
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"no data to read"
argument_list|,
name|instream
operator|.
name|read
argument_list|()
operator|>=
literal|0
argument_list|)
expr_stmt|;
comment|// now check seek backward
name|instream
operator|.
name|seek
argument_list|(
name|instream
operator|.
name|getPos
argument_list|()
operator|-
literal|100
argument_list|)
expr_stmt|;
if|if
condition|(
name|expectedExceptionInteractions
operator|.
name|contains
argument_list|(
name|InteractionType
operator|.
name|READ
argument_list|)
condition|)
block|{
name|expectReadFailure
argument_list|(
name|instream
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|instream
operator|.
name|read
argument_list|()
expr_stmt|;
block|}
name|byte
index|[]
name|buf
init|=
operator|new
name|byte
index|[
literal|256
index|]
decl_stmt|;
comment|// seek backward
name|instream
operator|.
name|seek
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|expectedExceptionInteractions
operator|.
name|contains
argument_list|(
name|InteractionType
operator|.
name|READ
argument_list|)
condition|)
block|{
name|expectReadFailure
argument_list|(
name|instream
argument_list|)
expr_stmt|;
name|intercept
argument_list|(
name|RemoteFileChangedException
operator|.
name|class
argument_list|,
literal|""
argument_list|,
literal|"read"
argument_list|,
parameter_list|()
lambda|->
name|instream
operator|.
name|read
argument_list|(
literal|0
argument_list|,
name|buf
argument_list|,
literal|0
argument_list|,
name|buf
operator|.
name|length
argument_list|)
argument_list|)
expr_stmt|;
name|intercept
argument_list|(
name|RemoteFileChangedException
operator|.
name|class
argument_list|,
literal|""
argument_list|,
literal|"readfully"
argument_list|,
parameter_list|()
lambda|->
name|instream
operator|.
name|readFully
argument_list|(
literal|0
argument_list|,
name|buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|instream
operator|.
name|read
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|instream
operator|.
name|read
argument_list|(
literal|0
argument_list|,
name|buf
argument_list|,
literal|0
argument_list|,
name|buf
operator|.
name|length
argument_list|)
expr_stmt|;
name|instream
operator|.
name|readFully
argument_list|(
literal|0
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
comment|// delete the file. Reads must fail
name|fs
operator|.
name|delete
argument_list|(
name|testpath
argument_list|,
literal|false
argument_list|)
expr_stmt|;
comment|// seek backward
name|instream
operator|.
name|seek
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|expectedExceptionInteractions
operator|.
name|contains
argument_list|(
name|InteractionType
operator|.
name|READ_AFTER_DELETE
argument_list|)
condition|)
block|{
name|intercept
argument_list|(
name|FileNotFoundException
operator|.
name|class
argument_list|,
literal|""
argument_list|,
literal|"read()"
argument_list|,
parameter_list|()
lambda|->
name|instream
operator|.
name|read
argument_list|()
argument_list|)
expr_stmt|;
name|intercept
argument_list|(
name|FileNotFoundException
operator|.
name|class
argument_list|,
literal|""
argument_list|,
literal|"readfully"
argument_list|,
parameter_list|()
lambda|->
name|instream
operator|.
name|readFully
argument_list|(
literal|2048
argument_list|,
name|buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|instream
operator|.
name|read
argument_list|()
expr_stmt|;
name|instream
operator|.
name|readFully
argument_list|(
literal|2048
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Tests reading a file where the version visible in S3 does not match the    * version tracked in the metadata store.    */
annotation|@
name|Test
DECL|method|testReadFileChangedOutOfSyncMetadata ()
specifier|public
name|void
name|testReadFileChangedOutOfSyncMetadata
parameter_list|()
throws|throws
name|Throwable
block|{
specifier|final
name|Path
name|testpath
init|=
name|writeOutOfSyncFileVersion
argument_list|(
literal|"fileChangedOutOfSync.dat"
argument_list|)
decl_stmt|;
try|try
init|(
name|FSDataInputStream
name|instream
init|=
name|fs
operator|.
name|open
argument_list|(
name|testpath
argument_list|)
init|)
block|{
if|if
condition|(
name|expectedExceptionInteractions
operator|.
name|contains
argument_list|(
name|InteractionType
operator|.
name|READ
argument_list|)
condition|)
block|{
name|expectReadFailure
argument_list|(
name|instream
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|instream
operator|.
name|read
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Ensures a file can be read when there is no version metadata    * (ETag, versionId).    */
annotation|@
name|Test
DECL|method|testReadWithNoVersionMetadata ()
specifier|public
name|void
name|testReadWithNoVersionMetadata
parameter_list|()
throws|throws
name|Throwable
block|{
specifier|final
name|Path
name|testpath
init|=
name|writeFileWithNoVersionMetadata
argument_list|(
literal|"readnoversion.dat"
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|"Contents of "
operator|+
name|testpath
argument_list|,
name|TEST_DATA
argument_list|,
name|readUTF8
argument_list|(
name|fs
argument_list|,
name|testpath
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Tests using S3 Select on a file where the version visible in S3 does not    * match the version tracked in the metadata store.    */
annotation|@
name|Test
DECL|method|testSelectChangedFile ()
specifier|public
name|void
name|testSelectChangedFile
parameter_list|()
throws|throws
name|Throwable
block|{
name|requireS3Select
argument_list|()
expr_stmt|;
specifier|final
name|Path
name|testpath
init|=
name|writeOutOfSyncFileVersion
argument_list|(
literal|"select.dat"
argument_list|)
decl_stmt|;
if|if
condition|(
name|expectedExceptionInteractions
operator|.
name|contains
argument_list|(
name|InteractionType
operator|.
name|SELECT
argument_list|)
condition|)
block|{
name|interceptFuture
argument_list|(
name|RemoteFileChangedException
operator|.
name|class
argument_list|,
literal|"select"
argument_list|,
name|fs
operator|.
name|openFile
argument_list|(
name|testpath
argument_list|)
operator|.
name|must
argument_list|(
name|SELECT_SQL
argument_list|,
literal|"SELECT * FROM S3OBJECT"
argument_list|)
operator|.
name|build
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fs
operator|.
name|openFile
argument_list|(
name|testpath
argument_list|)
operator|.
name|must
argument_list|(
name|SELECT_SQL
argument_list|,
literal|"SELECT * FROM S3OBJECT"
argument_list|)
operator|.
name|build
argument_list|()
operator|.
name|get
argument_list|()
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Tests using S3 Select on a file where the version visible in S3 does not    * initially match the version tracked in the metadata store, but eventually    * (after retries) does.    */
annotation|@
name|Test
DECL|method|testSelectEventuallyConsistentFile ()
specifier|public
name|void
name|testSelectEventuallyConsistentFile
parameter_list|()
throws|throws
name|Throwable
block|{
name|describe
argument_list|(
literal|"Eventually Consistent S3 Select"
argument_list|)
expr_stmt|;
name|requireS3Guard
argument_list|()
expr_stmt|;
name|requireS3Select
argument_list|()
expr_stmt|;
name|AmazonS3
name|s3ClientSpy
init|=
name|spyOnFilesystem
argument_list|()
decl_stmt|;
specifier|final
name|Path
name|testpath1
init|=
name|writeEventuallyConsistentFileVersion
argument_list|(
literal|"select1.dat"
argument_list|,
name|s3ClientSpy
argument_list|,
literal|0
argument_list|,
name|TEST_MAX_RETRIES
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|// should succeed since the inconsistency doesn't last longer than the
comment|// configured retry limit
name|fs
operator|.
name|openFile
argument_list|(
name|testpath1
argument_list|)
operator|.
name|must
argument_list|(
name|SELECT_SQL
argument_list|,
literal|"SELECT * FROM S3OBJECT"
argument_list|)
operator|.
name|build
argument_list|()
operator|.
name|get
argument_list|()
operator|.
name|close
argument_list|()
expr_stmt|;
comment|// select() makes a getFileStatus() call before the consistency checking
comment|// that will match the stub. As such, we need an extra inconsistency here
comment|// to cross the threshold
name|int
name|getMetadataInconsistencyCount
init|=
name|TEST_MAX_RETRIES
operator|+
literal|2
decl_stmt|;
specifier|final
name|Path
name|testpath2
init|=
name|writeEventuallyConsistentFileVersion
argument_list|(
literal|"select2.dat"
argument_list|,
name|s3ClientSpy
argument_list|,
literal|0
argument_list|,
name|getMetadataInconsistencyCount
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|expectedExceptionInteractions
operator|.
name|contains
argument_list|(
name|InteractionType
operator|.
name|EVENTUALLY_CONSISTENT_SELECT
argument_list|)
condition|)
block|{
comment|// should fail since the inconsistency lasts longer than the configured
comment|// retry limit
name|interceptFuture
argument_list|(
name|RemoteFileChangedException
operator|.
name|class
argument_list|,
literal|"select"
argument_list|,
name|fs
operator|.
name|openFile
argument_list|(
name|testpath2
argument_list|)
operator|.
name|must
argument_list|(
name|SELECT_SQL
argument_list|,
literal|"SELECT * FROM S3OBJECT"
argument_list|)
operator|.
name|build
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fs
operator|.
name|openFile
argument_list|(
name|testpath2
argument_list|)
operator|.
name|must
argument_list|(
name|SELECT_SQL
argument_list|,
literal|"SELECT * FROM S3OBJECT"
argument_list|)
operator|.
name|build
argument_list|()
operator|.
name|get
argument_list|()
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Ensures a file can be read via S3 Select when there is no version metadata    * (ETag, versionId).    */
annotation|@
name|Test
DECL|method|testSelectWithNoVersionMetadata ()
specifier|public
name|void
name|testSelectWithNoVersionMetadata
parameter_list|()
throws|throws
name|Throwable
block|{
name|requireS3Select
argument_list|()
expr_stmt|;
specifier|final
name|Path
name|testpath
init|=
name|writeFileWithNoVersionMetadata
argument_list|(
literal|"selectnoversion.dat"
argument_list|)
decl_stmt|;
try|try
init|(
name|FSDataInputStream
name|instream
init|=
name|fs
operator|.
name|openFile
argument_list|(
name|testpath
argument_list|)
operator|.
name|must
argument_list|(
name|SELECT_SQL
argument_list|,
literal|"SELECT * FROM S3OBJECT"
argument_list|)
operator|.
name|build
argument_list|()
operator|.
name|get
argument_list|()
init|)
block|{
name|assertEquals
argument_list|(
name|QUOTED_TEST_DATA
argument_list|,
name|IOUtils
operator|.
name|toString
argument_list|(
name|instream
argument_list|,
name|Charset
operator|.
name|forName
argument_list|(
literal|"UTF-8"
argument_list|)
argument_list|)
operator|.
name|trim
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Tests doing a rename() on a file where the version visible in S3 does not    * match the version tracked in the metadata store.    * @throws Throwable failure    */
annotation|@
name|Test
DECL|method|testRenameChangedFile ()
specifier|public
name|void
name|testRenameChangedFile
parameter_list|()
throws|throws
name|Throwable
block|{
specifier|final
name|Path
name|testpath
init|=
name|writeOutOfSyncFileVersion
argument_list|(
literal|"rename.dat"
argument_list|)
decl_stmt|;
specifier|final
name|Path
name|dest
init|=
name|path
argument_list|(
literal|"dest.dat"
argument_list|)
decl_stmt|;
if|if
condition|(
name|expectedExceptionInteractions
operator|.
name|contains
argument_list|(
name|InteractionType
operator|.
name|COPY
argument_list|)
condition|)
block|{
name|intercept
argument_list|(
name|RemoteFileChangedException
operator|.
name|class
argument_list|,
literal|""
argument_list|,
literal|"expected copy() failure"
argument_list|,
parameter_list|()
lambda|->
name|fs
operator|.
name|rename
argument_list|(
name|testpath
argument_list|,
name|dest
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fs
operator|.
name|rename
argument_list|(
name|testpath
argument_list|,
name|dest
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Inconsistent response counts for getObjectMetadata() and    * copyObject() for a rename.    * @param metadataCallsExpectedBeforeRetryLoop number of getObjectMetadata    * calls expected before the consistency checking retry loop    * @return the inconsistencies for (metadata, copy)    */
DECL|method|renameInconsistencyCounts ( int metadataCallsExpectedBeforeRetryLoop)
specifier|private
name|Pair
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|renameInconsistencyCounts
parameter_list|(
name|int
name|metadataCallsExpectedBeforeRetryLoop
parameter_list|)
block|{
name|int
name|metadataInconsistencyCount
init|=
name|TEST_MAX_RETRIES
operator|+
name|metadataCallsExpectedBeforeRetryLoop
decl_stmt|;
name|int
name|copyInconsistencyCount
init|=
name|versionCheckingIsOnServer
argument_list|()
condition|?
name|TEST_MAX_RETRIES
else|:
literal|0
decl_stmt|;
return|return
name|Pair
operator|.
name|of
argument_list|(
name|metadataInconsistencyCount
argument_list|,
name|copyInconsistencyCount
argument_list|)
return|;
block|}
comment|/**    * Tests doing a rename() on a file where the version visible in S3 does not    * match the version in the metadata store until a certain number of retries    * has been met.    */
annotation|@
name|Test
DECL|method|testRenameEventuallyConsistentFile ()
specifier|public
name|void
name|testRenameEventuallyConsistentFile
parameter_list|()
throws|throws
name|Throwable
block|{
name|requireS3Guard
argument_list|()
expr_stmt|;
name|AmazonS3
name|s3ClientSpy
init|=
name|spyOnFilesystem
argument_list|()
decl_stmt|;
comment|// Total inconsistent response count across getObjectMetadata() and
comment|// copyObject().
comment|// The split of inconsistent responses between getObjectMetadata() and
comment|// copyObject() is arbitrary.
name|Pair
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|counts
init|=
name|renameInconsistencyCounts
argument_list|(
name|getFileStatusHeadCount
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|metadataInconsistencyCount
init|=
name|counts
operator|.
name|getLeft
argument_list|()
decl_stmt|;
name|int
name|copyInconsistencyCount
init|=
name|counts
operator|.
name|getRight
argument_list|()
decl_stmt|;
specifier|final
name|Path
name|testpath1
init|=
name|writeEventuallyConsistentFileVersion
argument_list|(
literal|"rename-eventually1.dat"
argument_list|,
name|s3ClientSpy
argument_list|,
literal|0
argument_list|,
name|metadataInconsistencyCount
argument_list|,
name|copyInconsistencyCount
argument_list|)
decl_stmt|;
specifier|final
name|Path
name|dest1
init|=
name|path
argument_list|(
literal|"dest1.dat"
argument_list|)
decl_stmt|;
comment|// shouldn't fail since the inconsistency doesn't last through the
comment|// configured retry limit
name|fs
operator|.
name|rename
argument_list|(
name|testpath1
argument_list|,
name|dest1
argument_list|)
expr_stmt|;
block|}
comment|/**    * Tests doing a rename() on a file where the version visible in S3 does not    * match the version in the metadata store until a certain number of retries    * has been met.    * The test expects failure by AWSClientIOException caused by NPE due to    * https://github.com/aws/aws-sdk-java/issues/1644    */
annotation|@
name|Test
DECL|method|testRenameEventuallyConsistentFileNPE ()
specifier|public
name|void
name|testRenameEventuallyConsistentFileNPE
parameter_list|()
throws|throws
name|Throwable
block|{
name|requireS3Guard
argument_list|()
expr_stmt|;
name|skipIfVersionPolicyAndNoVersionId
argument_list|()
expr_stmt|;
name|AmazonS3
name|s3ClientSpy
init|=
name|spyOnFilesystem
argument_list|()
decl_stmt|;
name|Pair
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|counts
init|=
name|renameInconsistencyCounts
argument_list|(
name|getFileStatusHeadCount
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|metadataInconsistencyCount
init|=
name|counts
operator|.
name|getLeft
argument_list|()
decl_stmt|;
name|int
name|copyInconsistencyCount
init|=
name|counts
operator|.
name|getRight
argument_list|()
decl_stmt|;
comment|// giving copyInconsistencyCount + 1 here should trigger the failure,
comment|// exceeding the retry limit
specifier|final
name|Path
name|testpath2
init|=
name|writeEventuallyConsistentFileVersion
argument_list|(
literal|"rename-eventuallyNPE.dat"
argument_list|,
name|s3ClientSpy
argument_list|,
literal|0
argument_list|,
name|metadataInconsistencyCount
argument_list|,
name|copyInconsistencyCount
operator|+
literal|1
argument_list|)
decl_stmt|;
specifier|final
name|Path
name|dest2
init|=
name|path
argument_list|(
literal|"destNPE.dat"
argument_list|)
decl_stmt|;
if|if
condition|(
name|expectedExceptionInteractions
operator|.
name|contains
argument_list|(
name|InteractionType
operator|.
name|EVENTUALLY_CONSISTENT_COPY
argument_list|)
condition|)
block|{
comment|// should fail since the inconsistency is set up to persist longer than
comment|// the configured retry limit
comment|// the expected exception is not RemoteFileChangedException due to
comment|// https://github.com/aws/aws-sdk-java/issues/1644
comment|// If this test is failing after an AWS SDK update,
comment|// then it means the SDK bug is fixed.
comment|// Please update this test to match the new behavior.
name|AWSClientIOException
name|exception
init|=
name|intercept
argument_list|(
name|AWSClientIOException
operator|.
name|class
argument_list|,
literal|"Unable to complete transfer: null"
argument_list|,
literal|"expected copy() failure"
argument_list|,
parameter_list|()
lambda|->
name|fs
operator|.
name|rename
argument_list|(
name|testpath2
argument_list|,
name|dest2
argument_list|)
argument_list|)
decl_stmt|;
name|AmazonClientException
name|cause
init|=
name|exception
operator|.
name|getCause
argument_list|()
decl_stmt|;
if|if
condition|(
name|cause
operator|==
literal|null
condition|)
block|{
comment|// no cause; something else went wrong: throw.
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"No inner cause"
argument_list|,
name|exception
argument_list|)
throw|;
block|}
name|Throwable
name|causeCause
init|=
name|cause
operator|.
name|getCause
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|causeCause
operator|instanceof
name|NullPointerException
operator|)
condition|)
block|{
comment|// null causeCause or it is the wrong type: throw
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"Innermost cause is not NPE"
argument_list|,
name|exception
argument_list|)
throw|;
block|}
block|}
else|else
block|{
name|fs
operator|.
name|rename
argument_list|(
name|testpath2
argument_list|,
name|dest2
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Tests doing a rename() on a file where the version visible in S3 does not    * match the version in the metadata store until a certain number of retries    * has been met.    * The test expects failure by RemoteFileChangedException.    */
annotation|@
name|Test
DECL|method|testRenameEventuallyConsistentFileRFCE ()
specifier|public
name|void
name|testRenameEventuallyConsistentFileRFCE
parameter_list|()
throws|throws
name|Throwable
block|{
name|requireS3Guard
argument_list|()
expr_stmt|;
name|skipIfVersionPolicyAndNoVersionId
argument_list|()
expr_stmt|;
name|AmazonS3
name|s3ClientSpy
init|=
name|spyOnFilesystem
argument_list|()
decl_stmt|;
name|Pair
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|counts
init|=
name|renameInconsistencyCounts
argument_list|(
name|getFileStatusHeadCount
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|metadataInconsistencyCount
init|=
name|counts
operator|.
name|getLeft
argument_list|()
decl_stmt|;
name|int
name|copyInconsistencyCount
init|=
name|counts
operator|.
name|getRight
argument_list|()
decl_stmt|;
comment|// giving metadataInconsistencyCount + 1 here should trigger the failure,
comment|// exceeding the retry limit
specifier|final
name|Path
name|testpath2
init|=
name|writeEventuallyConsistentFileVersion
argument_list|(
literal|"rename-eventuallyRFCE.dat"
argument_list|,
name|s3ClientSpy
argument_list|,
literal|0
argument_list|,
name|metadataInconsistencyCount
operator|+
literal|1
argument_list|,
name|copyInconsistencyCount
argument_list|)
decl_stmt|;
specifier|final
name|Path
name|dest2
init|=
name|path
argument_list|(
literal|"destRFCE.dat"
argument_list|)
decl_stmt|;
if|if
condition|(
name|expectedExceptionInteractions
operator|.
name|contains
argument_list|(
name|InteractionType
operator|.
name|EVENTUALLY_CONSISTENT_METADATA
argument_list|)
condition|)
block|{
comment|// should fail since the inconsistency is set up to persist longer than
comment|// the configured retry limit
name|intercept
argument_list|(
name|RemoteFileChangedException
operator|.
name|class
argument_list|,
name|CHANGE_DETECTED
argument_list|,
literal|"expected copy() failure"
argument_list|,
parameter_list|()
lambda|->
name|fs
operator|.
name|rename
argument_list|(
name|testpath2
argument_list|,
name|dest2
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fs
operator|.
name|rename
argument_list|(
name|testpath2
argument_list|,
name|dest2
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Tests doing a rename() on a directory containing    * an file which is eventually consistent.    * There is no call to getFileStatus on the source file whose    * inconsistency is simulated; the state of S3Guard auth mode is not    * relevant.    */
annotation|@
name|Test
DECL|method|testRenameEventuallyConsistentDirectory ()
specifier|public
name|void
name|testRenameEventuallyConsistentDirectory
parameter_list|()
throws|throws
name|Throwable
block|{
name|requireS3Guard
argument_list|()
expr_stmt|;
name|AmazonS3
name|s3ClientSpy
init|=
name|spyOnFilesystem
argument_list|()
decl_stmt|;
name|Path
name|basedir
init|=
name|path
argument_list|()
decl_stmt|;
name|Path
name|sourcedir
init|=
operator|new
name|Path
argument_list|(
name|basedir
argument_list|,
literal|"sourcedir"
argument_list|)
decl_stmt|;
name|fs
operator|.
name|mkdirs
argument_list|(
name|sourcedir
argument_list|)
expr_stmt|;
name|Path
name|destdir
init|=
operator|new
name|Path
argument_list|(
name|basedir
argument_list|,
literal|"destdir"
argument_list|)
decl_stmt|;
name|String
name|inconsistent
init|=
literal|"inconsistent"
decl_stmt|;
name|String
name|consistent
init|=
literal|"consistent"
decl_stmt|;
name|Path
name|inconsistentFile
init|=
operator|new
name|Path
argument_list|(
name|sourcedir
argument_list|,
name|inconsistent
argument_list|)
decl_stmt|;
name|Path
name|consistentFile
init|=
operator|new
name|Path
argument_list|(
name|sourcedir
argument_list|,
name|consistent
argument_list|)
decl_stmt|;
comment|// write the consistent data
name|writeDataset
argument_list|(
name|fs
argument_list|,
name|consistentFile
argument_list|,
name|TEST_DATA_BYTES
argument_list|,
name|TEST_DATA_BYTES
operator|.
name|length
argument_list|,
literal|1024
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|Pair
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|counts
init|=
name|renameInconsistencyCounts
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|int
name|metadataInconsistencyCount
init|=
name|counts
operator|.
name|getLeft
argument_list|()
decl_stmt|;
name|int
name|copyInconsistencyCount
init|=
name|counts
operator|.
name|getRight
argument_list|()
decl_stmt|;
name|writeEventuallyConsistentData
argument_list|(
name|s3ClientSpy
argument_list|,
name|inconsistentFile
argument_list|,
name|TEST_DATA_BYTES
argument_list|,
literal|0
argument_list|,
name|metadataInconsistencyCount
argument_list|,
name|copyInconsistencyCount
argument_list|)
expr_stmt|;
comment|// must not fail since the inconsistency doesn't last through the
comment|// configured retry limit
name|fs
operator|.
name|rename
argument_list|(
name|sourcedir
argument_list|,
name|destdir
argument_list|)
expr_stmt|;
block|}
comment|/**    * Ensures a file can be renamed when there is no version metadata    * (ETag, versionId).    */
annotation|@
name|Test
DECL|method|testRenameWithNoVersionMetadata ()
specifier|public
name|void
name|testRenameWithNoVersionMetadata
parameter_list|()
throws|throws
name|Throwable
block|{
specifier|final
name|Path
name|testpath
init|=
name|writeFileWithNoVersionMetadata
argument_list|(
literal|"renamenoversion.dat"
argument_list|)
decl_stmt|;
specifier|final
name|Path
name|dest
init|=
name|path
argument_list|(
literal|"noversiondest.dat"
argument_list|)
decl_stmt|;
name|fs
operator|.
name|rename
argument_list|(
name|testpath
argument_list|,
name|dest
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Contents of "
operator|+
name|dest
argument_list|,
name|TEST_DATA
argument_list|,
name|readUTF8
argument_list|(
name|fs
argument_list|,
name|dest
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Ensures S3Guard and retries allow an eventually consistent read.    */
annotation|@
name|Test
DECL|method|testReadAfterEventuallyConsistentWrite ()
specifier|public
name|void
name|testReadAfterEventuallyConsistentWrite
parameter_list|()
throws|throws
name|Throwable
block|{
name|requireS3Guard
argument_list|()
expr_stmt|;
name|AmazonS3
name|s3ClientSpy
init|=
name|spyOnFilesystem
argument_list|()
decl_stmt|;
specifier|final
name|Path
name|testpath1
init|=
name|writeEventuallyConsistentFileVersion
argument_list|(
literal|"eventually1.dat"
argument_list|,
name|s3ClientSpy
argument_list|,
name|TEST_MAX_RETRIES
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
try|try
init|(
name|FSDataInputStream
name|instream1
init|=
name|fs
operator|.
name|open
argument_list|(
name|testpath1
argument_list|)
init|)
block|{
comment|// succeeds on the last retry
name|instream1
operator|.
name|read
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Ensures S3Guard and retries allow an eventually consistent read.    */
annotation|@
name|Test
DECL|method|testReadAfterEventuallyConsistentWrite2 ()
specifier|public
name|void
name|testReadAfterEventuallyConsistentWrite2
parameter_list|()
throws|throws
name|Throwable
block|{
name|requireS3Guard
argument_list|()
expr_stmt|;
name|AmazonS3
name|s3ClientSpy
init|=
name|spyOnFilesystem
argument_list|()
decl_stmt|;
specifier|final
name|Path
name|testpath2
init|=
name|writeEventuallyConsistentFileVersion
argument_list|(
literal|"eventually2.dat"
argument_list|,
name|s3ClientSpy
argument_list|,
name|TEST_MAX_RETRIES
operator|+
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
try|try
init|(
name|FSDataInputStream
name|instream2
init|=
name|fs
operator|.
name|open
argument_list|(
name|testpath2
argument_list|)
init|)
block|{
if|if
condition|(
name|expectedExceptionInteractions
operator|.
name|contains
argument_list|(
name|InteractionType
operator|.
name|EVENTUALLY_CONSISTENT_READ
argument_list|)
condition|)
block|{
comment|// keeps retrying and eventually gives up with RemoteFileChangedException
name|expectReadFailure
argument_list|(
name|instream2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|instream2
operator|.
name|read
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Ensures read on re-open (after seek backwards) when S3 does not return the    * version of the file tracked in the metadata store fails immediately.  No    * retries should happen since a retry is not expected to recover.    */
annotation|@
name|Test
DECL|method|testEventuallyConsistentReadOnReopen ()
specifier|public
name|void
name|testEventuallyConsistentReadOnReopen
parameter_list|()
throws|throws
name|Throwable
block|{
name|requireS3Guard
argument_list|()
expr_stmt|;
name|AmazonS3
name|s3ClientSpy
init|=
name|spyOnFilesystem
argument_list|()
decl_stmt|;
name|String
name|filename
init|=
literal|"eventually-reopen.dat"
decl_stmt|;
specifier|final
name|Path
name|testpath
init|=
name|writeEventuallyConsistentFileVersion
argument_list|(
name|filename
argument_list|,
name|s3ClientSpy
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
try|try
init|(
name|FSDataInputStream
name|instream
init|=
name|fs
operator|.
name|open
argument_list|(
name|testpath
argument_list|)
init|)
block|{
name|instream
operator|.
name|read
argument_list|()
expr_stmt|;
comment|// overwrite the file, returning inconsistent version for
comment|// (effectively) infinite retries
name|writeEventuallyConsistentFileVersion
argument_list|(
name|filename
argument_list|,
name|s3ClientSpy
argument_list|,
name|Integer
operator|.
name|MAX_VALUE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|instream
operator|.
name|seek
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|expectedExceptionInteractions
operator|.
name|contains
argument_list|(
name|InteractionType
operator|.
name|READ
argument_list|)
condition|)
block|{
comment|// if it retries at all, it will retry forever, which should fail
comment|// the test.  The expected behavior is immediate
comment|// RemoteFileChangedException.
name|expectReadFailure
argument_list|(
name|instream
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|instream
operator|.
name|read
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Writes a file with old ETag and versionId in the metadata store such    * that the metadata is out of sync with S3.  Attempts to read such a file    * should result in {@link RemoteFileChangedException}.    */
DECL|method|writeOutOfSyncFileVersion (String filename)
specifier|private
name|Path
name|writeOutOfSyncFileVersion
parameter_list|(
name|String
name|filename
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|Path
name|testpath
init|=
name|path
argument_list|(
name|filename
argument_list|)
decl_stmt|;
specifier|final
name|byte
index|[]
name|dataset
init|=
name|TEST_DATA_BYTES
decl_stmt|;
name|writeDataset
argument_list|(
name|fs
argument_list|,
name|testpath
argument_list|,
name|dataset
argument_list|,
name|dataset
operator|.
name|length
argument_list|,
literal|1024
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|S3AFileStatus
name|originalStatus
init|=
operator|(
name|S3AFileStatus
operator|)
name|fs
operator|.
name|getFileStatus
argument_list|(
name|testpath
argument_list|)
decl_stmt|;
comment|// overwrite with half the content
name|writeDataset
argument_list|(
name|fs
argument_list|,
name|testpath
argument_list|,
name|dataset
argument_list|,
name|dataset
operator|.
name|length
operator|/
literal|2
argument_list|,
literal|1024
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|S3AFileStatus
name|newStatus
init|=
operator|(
name|S3AFileStatus
operator|)
name|fs
operator|.
name|getFileStatus
argument_list|(
name|testpath
argument_list|)
decl_stmt|;
comment|// put back the original etag, versionId
name|S3AFileStatus
name|forgedStatus
init|=
name|S3AFileStatus
operator|.
name|fromFileStatus
argument_list|(
name|newStatus
argument_list|,
name|Tristate
operator|.
name|FALSE
argument_list|,
name|originalStatus
operator|.
name|getETag
argument_list|()
argument_list|,
name|originalStatus
operator|.
name|getVersionId
argument_list|()
argument_list|)
decl_stmt|;
name|fs
operator|.
name|getMetadataStore
argument_list|()
operator|.
name|put
argument_list|(
operator|new
name|PathMetadata
argument_list|(
name|forgedStatus
argument_list|,
name|Tristate
operator|.
name|FALSE
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|testpath
return|;
block|}
comment|/**    * Writes {@link #TEST_DATA} to a file where the file will be inconsistent    * in S3 for a set of operations.    * The duration of the inconsistency is controlled by the    * getObjectInconsistencyCount, getMetadataInconsistencyCount, and    * copyInconsistentCallCount parameters.    * The inconsistency manifests in AmazonS3#getObject,    * AmazonS3#getObjectMetadata, and AmazonS3#copyObject.    * This method sets up the provided s3ClientSpy to return a response to each    * of these methods indicating an inconsistency where the requested object    * version (eTag or versionId) is not available until a certain retry    * threshold is met.    * Providing inconsistent call count values above or    * below the overall retry limit allows a test to simulate a condition that    * either should or should not result in an overall failure from retry    * exhaustion.    * @param filename name of file (will be under test path)    * @param s3ClientSpy s3 client to patch    * @param getObjectInconsistencyCount number of GET inconsistencies    * @param getMetadataInconsistencyCount number of HEAD inconsistencies    * @param copyInconsistencyCount number of COPY inconsistencies.    * @return the path written    * @throws IOException failure to write the test data.    */
DECL|method|writeEventuallyConsistentFileVersion (String filename, AmazonS3 s3ClientSpy, int getObjectInconsistencyCount, int getMetadataInconsistencyCount, int copyInconsistencyCount)
specifier|private
name|Path
name|writeEventuallyConsistentFileVersion
parameter_list|(
name|String
name|filename
parameter_list|,
name|AmazonS3
name|s3ClientSpy
parameter_list|,
name|int
name|getObjectInconsistencyCount
parameter_list|,
name|int
name|getMetadataInconsistencyCount
parameter_list|,
name|int
name|copyInconsistencyCount
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|writeEventuallyConsistentData
argument_list|(
name|s3ClientSpy
argument_list|,
name|path
argument_list|(
name|filename
argument_list|)
argument_list|,
name|TEST_DATA_BYTES
argument_list|,
name|getObjectInconsistencyCount
argument_list|,
name|getMetadataInconsistencyCount
argument_list|,
name|copyInconsistencyCount
argument_list|)
return|;
block|}
comment|/**    * Writes data to a path and configures the S3 client for inconsistent    * HEAD, GET or COPY operations.    * @param testpath absolute path of file    * @param s3ClientSpy s3 client to patch    * @param dataset bytes to write.    * @param getObjectInconsistencyCount number of GET inconsistencies    * @param getMetadataInconsistencyCount number of HEAD inconsistencies    * @param copyInconsistencyCount number of COPY inconsistencies.    * @return the path written    * @throws IOException failure to write the test data.    */
DECL|method|writeEventuallyConsistentData (final AmazonS3 s3ClientSpy, final Path testpath, final byte[] dataset, final int getObjectInconsistencyCount, final int getMetadataInconsistencyCount, final int copyInconsistencyCount)
specifier|private
name|Path
name|writeEventuallyConsistentData
parameter_list|(
specifier|final
name|AmazonS3
name|s3ClientSpy
parameter_list|,
specifier|final
name|Path
name|testpath
parameter_list|,
specifier|final
name|byte
index|[]
name|dataset
parameter_list|,
specifier|final
name|int
name|getObjectInconsistencyCount
parameter_list|,
specifier|final
name|int
name|getMetadataInconsistencyCount
parameter_list|,
specifier|final
name|int
name|copyInconsistencyCount
parameter_list|)
throws|throws
name|IOException
block|{
name|writeDataset
argument_list|(
name|fs
argument_list|,
name|testpath
argument_list|,
name|dataset
argument_list|,
name|dataset
operator|.
name|length
argument_list|,
literal|1024
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|S3AFileStatus
name|originalStatus
init|=
operator|(
name|S3AFileStatus
operator|)
name|fs
operator|.
name|getFileStatus
argument_list|(
name|testpath
argument_list|)
decl_stmt|;
comment|// overwrite with half the content
name|writeDataset
argument_list|(
name|fs
argument_list|,
name|testpath
argument_list|,
name|dataset
argument_list|,
name|dataset
operator|.
name|length
operator|/
literal|2
argument_list|,
literal|1024
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Original file info: {}: version={}, etag={}"
argument_list|,
name|testpath
argument_list|,
name|originalStatus
operator|.
name|getVersionId
argument_list|()
argument_list|,
name|originalStatus
operator|.
name|getETag
argument_list|()
argument_list|)
expr_stmt|;
name|S3AFileStatus
name|newStatus
init|=
operator|(
name|S3AFileStatus
operator|)
name|fs
operator|.
name|getFileStatus
argument_list|(
name|testpath
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Updated file info: {}: version={}, etag={}"
argument_list|,
name|testpath
argument_list|,
name|newStatus
operator|.
name|getVersionId
argument_list|()
argument_list|,
name|newStatus
operator|.
name|getETag
argument_list|()
argument_list|)
expr_stmt|;
name|stubTemporaryUnavailable
argument_list|(
name|s3ClientSpy
argument_list|,
name|getObjectInconsistencyCount
argument_list|,
name|testpath
argument_list|,
name|newStatus
argument_list|)
expr_stmt|;
name|stubTemporaryWrongVersion
argument_list|(
name|s3ClientSpy
argument_list|,
name|getObjectInconsistencyCount
argument_list|,
name|testpath
argument_list|,
name|originalStatus
argument_list|)
expr_stmt|;
if|if
condition|(
name|versionCheckingIsOnServer
argument_list|()
condition|)
block|{
comment|// only stub inconsistency when mode is server since no constraints that
comment|// should trigger inconsistency are passed in any other mode
name|stubTemporaryCopyInconsistency
argument_list|(
name|s3ClientSpy
argument_list|,
name|testpath
argument_list|,
name|newStatus
argument_list|,
name|copyInconsistencyCount
argument_list|)
expr_stmt|;
block|}
name|stubTemporaryMetadataInconsistency
argument_list|(
name|s3ClientSpy
argument_list|,
name|testpath
argument_list|,
name|originalStatus
argument_list|,
name|newStatus
argument_list|,
name|getMetadataInconsistencyCount
argument_list|)
expr_stmt|;
return|return
name|testpath
return|;
block|}
comment|/**    * Log the call hierarchy at debug level, helps track down    * where calls to operations are coming from.    */
DECL|method|logLocationAtDebug ()
specifier|private
name|void
name|logLocationAtDebug
parameter_list|()
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Call hierarchy"
argument_list|,
operator|new
name|Exception
argument_list|(
literal|"here"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Stubs {@link AmazonS3#getObject(GetObjectRequest)}    * within s3ClientSpy to return null until inconsistentCallCount calls have    * been made.  The null response simulates what occurs when an object    * matching the specified ETag or versionId is not available.    * @param s3ClientSpy the spy to stub    * @param inconsistentCallCount the number of calls that should return the    * null response    * @param testpath the path of the object the stub should apply to    */
DECL|method|stubTemporaryUnavailable (AmazonS3 s3ClientSpy, int inconsistentCallCount, Path testpath, S3AFileStatus newStatus)
specifier|private
name|void
name|stubTemporaryUnavailable
parameter_list|(
name|AmazonS3
name|s3ClientSpy
parameter_list|,
name|int
name|inconsistentCallCount
parameter_list|,
name|Path
name|testpath
parameter_list|,
name|S3AFileStatus
name|newStatus
parameter_list|)
block|{
name|Answer
argument_list|<
name|S3Object
argument_list|>
name|temporarilyUnavailableAnswer
init|=
operator|new
name|Answer
argument_list|<
name|S3Object
argument_list|>
argument_list|()
block|{
specifier|private
name|int
name|callCount
init|=
literal|0
decl_stmt|;
annotation|@
name|Override
specifier|public
name|S3Object
name|answer
parameter_list|(
name|InvocationOnMock
name|invocation
parameter_list|)
throws|throws
name|Throwable
block|{
comment|// simulates ETag or versionId constraint not met until
comment|// inconsistentCallCount surpassed
name|callCount
operator|++
expr_stmt|;
if|if
condition|(
name|callCount
operator|<=
name|inconsistentCallCount
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Temporarily unavailable {} count {} of {}"
argument_list|,
name|testpath
argument_list|,
name|callCount
argument_list|,
name|inconsistentCallCount
argument_list|)
expr_stmt|;
name|logLocationAtDebug
argument_list|()
expr_stmt|;
return|return
literal|null
return|;
block|}
return|return
operator|(
name|S3Object
operator|)
name|invocation
operator|.
name|callRealMethod
argument_list|()
return|;
block|}
block|}
decl_stmt|;
comment|// match the requests that would be made in either server-side change
comment|// detection mode
name|doAnswer
argument_list|(
name|temporarilyUnavailableAnswer
argument_list|)
operator|.
name|when
argument_list|(
name|s3ClientSpy
argument_list|)
operator|.
name|getObject
argument_list|(
name|matchingGetObjectRequest
argument_list|(
name|testpath
argument_list|,
name|newStatus
operator|.
name|getETag
argument_list|()
argument_list|,
literal|null
argument_list|)
argument_list|)
expr_stmt|;
name|doAnswer
argument_list|(
name|temporarilyUnavailableAnswer
argument_list|)
operator|.
name|when
argument_list|(
name|s3ClientSpy
argument_list|)
operator|.
name|getObject
argument_list|(
name|matchingGetObjectRequest
argument_list|(
name|testpath
argument_list|,
literal|null
argument_list|,
name|newStatus
operator|.
name|getVersionId
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Stubs {@link AmazonS3#getObject(GetObjectRequest)}    * within s3ClientSpy to return an object modified to contain metadata    * from originalStatus until inconsistentCallCount calls have been made.    * @param s3ClientSpy the spy to stub    * @param testpath the path of the object the stub should apply to    * @param inconsistentCallCount the number of calls that should return the    * null response    * @param originalStatus the status metadata to inject into the    * inconsistentCallCount responses    */
DECL|method|stubTemporaryWrongVersion (AmazonS3 s3ClientSpy, int inconsistentCallCount, Path testpath, S3AFileStatus originalStatus)
specifier|private
name|void
name|stubTemporaryWrongVersion
parameter_list|(
name|AmazonS3
name|s3ClientSpy
parameter_list|,
name|int
name|inconsistentCallCount
parameter_list|,
name|Path
name|testpath
parameter_list|,
name|S3AFileStatus
name|originalStatus
parameter_list|)
block|{
name|Answer
argument_list|<
name|S3Object
argument_list|>
name|temporarilyWrongVersionAnswer
init|=
operator|new
name|Answer
argument_list|<
name|S3Object
argument_list|>
argument_list|()
block|{
specifier|private
name|int
name|callCount
init|=
literal|0
decl_stmt|;
annotation|@
name|Override
specifier|public
name|S3Object
name|answer
parameter_list|(
name|InvocationOnMock
name|invocation
parameter_list|)
throws|throws
name|Throwable
block|{
comment|// simulates old ETag or versionId until inconsistentCallCount surpassed
name|callCount
operator|++
expr_stmt|;
name|S3Object
name|s3Object
init|=
operator|(
name|S3Object
operator|)
name|invocation
operator|.
name|callRealMethod
argument_list|()
decl_stmt|;
if|if
condition|(
name|callCount
operator|<=
name|inconsistentCallCount
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Temporary Wrong Version {} count {} of {}"
argument_list|,
name|testpath
argument_list|,
name|callCount
argument_list|,
name|inconsistentCallCount
argument_list|)
expr_stmt|;
name|logLocationAtDebug
argument_list|()
expr_stmt|;
name|S3Object
name|objectSpy
init|=
name|Mockito
operator|.
name|spy
argument_list|(
name|s3Object
argument_list|)
decl_stmt|;
name|ObjectMetadata
name|metadataSpy
init|=
name|Mockito
operator|.
name|spy
argument_list|(
name|s3Object
operator|.
name|getObjectMetadata
argument_list|()
argument_list|)
decl_stmt|;
name|when
argument_list|(
name|objectSpy
operator|.
name|getObjectMetadata
argument_list|()
argument_list|)
operator|.
name|thenReturn
argument_list|(
name|metadataSpy
argument_list|)
expr_stmt|;
name|when
argument_list|(
name|metadataSpy
operator|.
name|getETag
argument_list|()
argument_list|)
operator|.
name|thenReturn
argument_list|(
name|originalStatus
operator|.
name|getETag
argument_list|()
argument_list|)
expr_stmt|;
name|when
argument_list|(
name|metadataSpy
operator|.
name|getVersionId
argument_list|()
argument_list|)
operator|.
name|thenReturn
argument_list|(
name|originalStatus
operator|.
name|getVersionId
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|objectSpy
return|;
block|}
return|return
name|s3Object
return|;
block|}
block|}
decl_stmt|;
comment|// match requests that would be made in client-side change detection
name|doAnswer
argument_list|(
name|temporarilyWrongVersionAnswer
argument_list|)
operator|.
name|when
argument_list|(
name|s3ClientSpy
argument_list|)
operator|.
name|getObject
argument_list|(
name|matchingGetObjectRequest
argument_list|(
name|testpath
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Stubs {@link AmazonS3#copyObject(CopyObjectRequest)}    * within s3ClientSpy to return null (indicating preconditions not met) until    * copyInconsistentCallCount calls have been made.    * @param s3ClientSpy the spy to stub    * @param testpath the path of the object the stub should apply to    * @param newStatus the status metadata containing the ETag and versionId    * that should be matched in order for the stub to apply    * @param copyInconsistentCallCount how many times to return the    * precondition failed error    */
DECL|method|stubTemporaryCopyInconsistency (AmazonS3 s3ClientSpy, Path testpath, S3AFileStatus newStatus, int copyInconsistentCallCount)
specifier|private
name|void
name|stubTemporaryCopyInconsistency
parameter_list|(
name|AmazonS3
name|s3ClientSpy
parameter_list|,
name|Path
name|testpath
parameter_list|,
name|S3AFileStatus
name|newStatus
parameter_list|,
name|int
name|copyInconsistentCallCount
parameter_list|)
block|{
name|Answer
argument_list|<
name|CopyObjectResult
argument_list|>
name|temporarilyPreconditionsNotMetAnswer
init|=
operator|new
name|Answer
argument_list|<
name|CopyObjectResult
argument_list|>
argument_list|()
block|{
specifier|private
name|int
name|callCount
init|=
literal|0
decl_stmt|;
annotation|@
name|Override
specifier|public
name|CopyObjectResult
name|answer
parameter_list|(
name|InvocationOnMock
name|invocation
parameter_list|)
throws|throws
name|Throwable
block|{
name|callCount
operator|++
expr_stmt|;
if|if
condition|(
name|callCount
operator|<=
name|copyInconsistentCallCount
condition|)
block|{
name|String
name|message
init|=
literal|"preconditions not met on call "
operator|+
name|callCount
operator|+
literal|" of "
operator|+
name|copyInconsistentCallCount
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Copying {}: {}"
argument_list|,
name|testpath
argument_list|,
name|message
argument_list|)
expr_stmt|;
name|logLocationAtDebug
argument_list|()
expr_stmt|;
return|return
literal|null
return|;
block|}
return|return
operator|(
name|CopyObjectResult
operator|)
name|invocation
operator|.
name|callRealMethod
argument_list|()
return|;
block|}
block|}
decl_stmt|;
comment|// match requests made during copy
name|doAnswer
argument_list|(
name|temporarilyPreconditionsNotMetAnswer
argument_list|)
operator|.
name|when
argument_list|(
name|s3ClientSpy
argument_list|)
operator|.
name|copyObject
argument_list|(
name|matchingCopyObjectRequest
argument_list|(
name|testpath
argument_list|,
name|newStatus
operator|.
name|getETag
argument_list|()
argument_list|,
literal|null
argument_list|)
argument_list|)
expr_stmt|;
name|doAnswer
argument_list|(
name|temporarilyPreconditionsNotMetAnswer
argument_list|)
operator|.
name|when
argument_list|(
name|s3ClientSpy
argument_list|)
operator|.
name|copyObject
argument_list|(
name|matchingCopyObjectRequest
argument_list|(
name|testpath
argument_list|,
literal|null
argument_list|,
name|newStatus
operator|.
name|getVersionId
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Stubs {@link AmazonS3#getObjectMetadata(GetObjectMetadataRequest)}    * within s3ClientSpy to return metadata from originalStatus until    * metadataInconsistentCallCount calls have been made.    * @param s3ClientSpy the spy to stub    * @param testpath the path of the object the stub should apply to    * @param originalStatus the inconsistent status metadata to return    * @param newStatus the status metadata to return after    * metadataInconsistentCallCount is met    * @param metadataInconsistentCallCount how many times to return the    * inconsistent metadata    */
DECL|method|stubTemporaryMetadataInconsistency (AmazonS3 s3ClientSpy, Path testpath, S3AFileStatus originalStatus, S3AFileStatus newStatus, int metadataInconsistentCallCount)
specifier|private
name|void
name|stubTemporaryMetadataInconsistency
parameter_list|(
name|AmazonS3
name|s3ClientSpy
parameter_list|,
name|Path
name|testpath
parameter_list|,
name|S3AFileStatus
name|originalStatus
parameter_list|,
name|S3AFileStatus
name|newStatus
parameter_list|,
name|int
name|metadataInconsistentCallCount
parameter_list|)
block|{
name|Answer
argument_list|<
name|ObjectMetadata
argument_list|>
name|temporarilyOldMetadataAnswer
init|=
operator|new
name|Answer
argument_list|<
name|ObjectMetadata
argument_list|>
argument_list|()
block|{
specifier|private
name|int
name|callCount
init|=
literal|0
decl_stmt|;
annotation|@
name|Override
specifier|public
name|ObjectMetadata
name|answer
parameter_list|(
name|InvocationOnMock
name|invocation
parameter_list|)
throws|throws
name|Throwable
block|{
name|ObjectMetadata
name|objectMetadata
init|=
operator|(
name|ObjectMetadata
operator|)
name|invocation
operator|.
name|callRealMethod
argument_list|()
decl_stmt|;
name|callCount
operator|++
expr_stmt|;
if|if
condition|(
name|callCount
operator|<=
name|metadataInconsistentCallCount
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Inconsistent metadata {} count {} of {}"
argument_list|,
name|testpath
argument_list|,
name|callCount
argument_list|,
name|metadataInconsistentCallCount
argument_list|)
expr_stmt|;
name|logLocationAtDebug
argument_list|()
expr_stmt|;
name|ObjectMetadata
name|metadataSpy
init|=
name|Mockito
operator|.
name|spy
argument_list|(
name|objectMetadata
argument_list|)
decl_stmt|;
name|when
argument_list|(
name|metadataSpy
operator|.
name|getETag
argument_list|()
argument_list|)
operator|.
name|thenReturn
argument_list|(
name|originalStatus
operator|.
name|getETag
argument_list|()
argument_list|)
expr_stmt|;
name|when
argument_list|(
name|metadataSpy
operator|.
name|getVersionId
argument_list|()
argument_list|)
operator|.
name|thenReturn
argument_list|(
name|originalStatus
operator|.
name|getVersionId
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|metadataSpy
return|;
block|}
return|return
name|objectMetadata
return|;
block|}
block|}
decl_stmt|;
comment|// match requests made during select
name|doAnswer
argument_list|(
name|temporarilyOldMetadataAnswer
argument_list|)
operator|.
name|when
argument_list|(
name|s3ClientSpy
argument_list|)
operator|.
name|getObjectMetadata
argument_list|(
name|matchingMetadataRequest
argument_list|(
name|testpath
argument_list|,
literal|null
argument_list|)
argument_list|)
expr_stmt|;
name|doAnswer
argument_list|(
name|temporarilyOldMetadataAnswer
argument_list|)
operator|.
name|when
argument_list|(
name|s3ClientSpy
argument_list|)
operator|.
name|getObjectMetadata
argument_list|(
name|matchingMetadataRequest
argument_list|(
name|testpath
argument_list|,
name|newStatus
operator|.
name|getVersionId
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Writes a file with null ETag and versionId in the metadata store.    */
DECL|method|writeFileWithNoVersionMetadata (String filename)
specifier|private
name|Path
name|writeFileWithNoVersionMetadata
parameter_list|(
name|String
name|filename
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|Path
name|testpath
init|=
name|path
argument_list|(
name|filename
argument_list|)
decl_stmt|;
name|writeDataset
argument_list|(
name|fs
argument_list|,
name|testpath
argument_list|,
name|TEST_DATA_BYTES
argument_list|,
name|TEST_DATA_BYTES
operator|.
name|length
argument_list|,
literal|1024
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|S3AFileStatus
name|originalStatus
init|=
operator|(
name|S3AFileStatus
operator|)
name|fs
operator|.
name|getFileStatus
argument_list|(
name|testpath
argument_list|)
decl_stmt|;
comment|// remove ETag and versionId
name|S3AFileStatus
name|newStatus
init|=
name|S3AFileStatus
operator|.
name|fromFileStatus
argument_list|(
name|originalStatus
argument_list|,
name|Tristate
operator|.
name|FALSE
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|fs
operator|.
name|getMetadataStore
argument_list|()
operator|.
name|put
argument_list|(
operator|new
name|PathMetadata
argument_list|(
name|newStatus
argument_list|,
name|Tristate
operator|.
name|FALSE
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|testpath
return|;
block|}
comment|/**    * The test is invalid if the policy uses versionId but the bucket doesn't    * have versioning enabled.    *    * Tests the given file for a versionId to detect whether bucket versioning    * is enabled.    */
DECL|method|skipIfVersionPolicyAndNoVersionId (Path testpath)
specifier|private
name|void
name|skipIfVersionPolicyAndNoVersionId
parameter_list|(
name|Path
name|testpath
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|fs
operator|.
name|getChangeDetectionPolicy
argument_list|()
operator|.
name|getSource
argument_list|()
operator|==
name|Source
operator|.
name|VersionId
condition|)
block|{
comment|// skip versionId tests if the bucket doesn't have object versioning
comment|// enabled
name|Assume
operator|.
name|assumeTrue
argument_list|(
literal|"Target filesystem does not support versioning"
argument_list|,
name|fs
operator|.
name|getObjectMetadata
argument_list|(
name|fs
operator|.
name|pathToKey
argument_list|(
name|testpath
argument_list|)
argument_list|)
operator|.
name|getVersionId
argument_list|()
operator|!=
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Like {@link #skipIfVersionPolicyAndNoVersionId(Path)} but generates a new    * file to test versionId against.    */
DECL|method|skipIfVersionPolicyAndNoVersionId ()
specifier|private
name|void
name|skipIfVersionPolicyAndNoVersionId
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|fs
operator|.
name|getChangeDetectionPolicy
argument_list|()
operator|.
name|getSource
argument_list|()
operator|==
name|Source
operator|.
name|VersionId
condition|)
block|{
name|Path
name|versionIdFeatureTestFile
init|=
name|path
argument_list|(
literal|"versionIdTest"
argument_list|)
decl_stmt|;
name|writeDataset
argument_list|(
name|fs
argument_list|,
name|versionIdFeatureTestFile
argument_list|,
name|TEST_DATA_BYTES
argument_list|,
name|TEST_DATA_BYTES
operator|.
name|length
argument_list|,
literal|1024
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|skipIfVersionPolicyAndNoVersionId
argument_list|(
name|versionIdFeatureTestFile
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|matchingGetObjectRequest (Path path, String eTag, String versionId)
specifier|private
name|GetObjectRequest
name|matchingGetObjectRequest
parameter_list|(
name|Path
name|path
parameter_list|,
name|String
name|eTag
parameter_list|,
name|String
name|versionId
parameter_list|)
block|{
return|return
name|ArgumentMatchers
operator|.
name|argThat
argument_list|(
name|request
lambda|->
block|{
if|if
condition|(
name|request
operator|.
name|getBucketName
argument_list|()
operator|.
name|equals
argument_list|(
name|fs
operator|.
name|getBucket
argument_list|()
argument_list|)
operator|&&
name|request
operator|.
name|getKey
argument_list|()
operator|.
name|equals
argument_list|(
name|fs
operator|.
name|pathToKey
argument_list|(
name|path
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|eTag
operator|==
literal|null
operator|&&
operator|!
name|request
operator|.
name|getMatchingETagConstraints
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|eTag
operator|!=
literal|null
operator|&&
operator|!
name|request
operator|.
name|getMatchingETagConstraints
argument_list|()
operator|.
name|contains
argument_list|(
name|eTag
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|versionId
operator|==
literal|null
operator|&&
name|request
operator|.
name|getVersionId
argument_list|()
operator|!=
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|versionId
operator|!=
literal|null
operator|&&
operator|!
name|versionId
operator|.
name|equals
argument_list|(
name|request
operator|.
name|getVersionId
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
argument_list|)
return|;
block|}
DECL|method|matchingCopyObjectRequest (Path path, String eTag, String versionId)
specifier|private
name|CopyObjectRequest
name|matchingCopyObjectRequest
parameter_list|(
name|Path
name|path
parameter_list|,
name|String
name|eTag
parameter_list|,
name|String
name|versionId
parameter_list|)
block|{
return|return
name|ArgumentMatchers
operator|.
name|argThat
argument_list|(
name|request
lambda|->
block|{
if|if
condition|(
name|request
operator|.
name|getSourceBucketName
argument_list|()
operator|.
name|equals
argument_list|(
name|fs
operator|.
name|getBucket
argument_list|()
argument_list|)
operator|&&
name|request
operator|.
name|getSourceKey
argument_list|()
operator|.
name|equals
argument_list|(
name|fs
operator|.
name|pathToKey
argument_list|(
name|path
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|eTag
operator|==
literal|null
operator|&&
operator|!
name|request
operator|.
name|getMatchingETagConstraints
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|eTag
operator|!=
literal|null
operator|&&
operator|!
name|request
operator|.
name|getMatchingETagConstraints
argument_list|()
operator|.
name|contains
argument_list|(
name|eTag
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|versionId
operator|==
literal|null
operator|&&
name|request
operator|.
name|getSourceVersionId
argument_list|()
operator|!=
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|versionId
operator|!=
literal|null
operator|&&
operator|!
name|versionId
operator|.
name|equals
argument_list|(
name|request
operator|.
name|getSourceVersionId
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
argument_list|)
return|;
block|}
DECL|method|matchingMetadataRequest (Path path, String versionId)
specifier|private
name|GetObjectMetadataRequest
name|matchingMetadataRequest
parameter_list|(
name|Path
name|path
parameter_list|,
name|String
name|versionId
parameter_list|)
block|{
return|return
name|ArgumentMatchers
operator|.
name|argThat
argument_list|(
name|request
lambda|->
block|{
if|if
condition|(
name|request
operator|.
name|getBucketName
argument_list|()
operator|.
name|equals
argument_list|(
name|fs
operator|.
name|getBucket
argument_list|()
argument_list|)
operator|&&
name|request
operator|.
name|getKey
argument_list|()
operator|.
name|equals
argument_list|(
name|fs
operator|.
name|pathToKey
argument_list|(
name|path
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|versionId
operator|==
literal|null
operator|&&
name|request
operator|.
name|getVersionId
argument_list|()
operator|!=
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|versionId
operator|!=
literal|null
operator|&&
operator|!
name|versionId
operator|.
name|equals
argument_list|(
name|request
operator|.
name|getVersionId
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
argument_list|)
return|;
block|}
comment|/**    * Skip a test case if it needs S3Guard and the filesystem does    * not have it.    */
DECL|method|requireS3Guard ()
specifier|private
name|void
name|requireS3Guard
parameter_list|()
block|{
name|Assume
operator|.
name|assumeTrue
argument_list|(
literal|"S3Guard must be enabled"
argument_list|,
name|fs
operator|.
name|hasMetadataStore
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Skip a test case if S3 Select is not supported on this store.    */
DECL|method|requireS3Select ()
specifier|private
name|void
name|requireS3Select
parameter_list|()
block|{
name|Assume
operator|.
name|assumeTrue
argument_list|(
literal|"S3 Select is not enabled"
argument_list|,
name|getFileSystem
argument_list|()
operator|.
name|hasCapability
argument_list|(
name|S3_SELECT_CAPABILITY
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Spy on the filesystem at the S3 client level.    * @return a mocked S3 client to which the test FS is bonded.    */
DECL|method|spyOnFilesystem ()
specifier|private
name|AmazonS3
name|spyOnFilesystem
parameter_list|()
block|{
name|AmazonS3
name|s3ClientSpy
init|=
name|Mockito
operator|.
name|spy
argument_list|(
name|fs
operator|.
name|getAmazonS3ClientForTesting
argument_list|(
literal|"mocking"
argument_list|)
argument_list|)
decl_stmt|;
name|fs
operator|.
name|setAmazonS3Client
argument_list|(
name|s3ClientSpy
argument_list|)
expr_stmt|;
return|return
name|s3ClientSpy
return|;
block|}
comment|/**    * Expect reading this stream to fail.    * @param instream input stream.    * @return the caught exception.    * @throws Exception an other exception    */
DECL|method|expectReadFailure ( final FSDataInputStream instream)
specifier|private
name|RemoteFileChangedException
name|expectReadFailure
parameter_list|(
specifier|final
name|FSDataInputStream
name|instream
parameter_list|)
throws|throws
name|Exception
block|{
return|return
name|intercept
argument_list|(
name|RemoteFileChangedException
operator|.
name|class
argument_list|,
literal|""
argument_list|,
literal|"read() returned"
argument_list|,
parameter_list|()
lambda|->
name|readToText
argument_list|(
name|instream
operator|.
name|read
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Convert the result of a read to a text string for errors.    * @param r result of the read() call.    * @return a string for exception text.    */
DECL|method|readToText (int r)
specifier|private
name|String
name|readToText
parameter_list|(
name|int
name|r
parameter_list|)
block|{
return|return
name|r
operator|<
literal|32
condition|?
operator|(
name|String
operator|.
name|format
argument_list|(
literal|"%02d"
argument_list|,
name|r
argument_list|)
operator|)
else|:
operator|(
name|String
operator|.
name|format
argument_list|(
literal|"%c"
argument_list|,
operator|(
name|char
operator|)
name|r
argument_list|)
operator|)
return|;
block|}
comment|/**    * Is the version checking on the server?    * @return true if the server returns 412 errors.    */
DECL|method|versionCheckingIsOnServer ()
specifier|private
name|boolean
name|versionCheckingIsOnServer
parameter_list|()
block|{
return|return
name|fs
operator|.
name|getChangeDetectionPolicy
argument_list|()
operator|.
name|getMode
argument_list|()
operator|==
name|Mode
operator|.
name|Server
return|;
block|}
block|}
end_class

end_unit

