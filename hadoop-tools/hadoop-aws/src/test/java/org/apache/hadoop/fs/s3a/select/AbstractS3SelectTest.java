begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.fs.s3a.select
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|select
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|BufferedReader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|EOFException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStreamReader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|time
operator|.
name|Duration
import|;
end_import

begin_import
import|import
name|java
operator|.
name|time
operator|.
name|ZonedDateTime
import|;
end_import

begin_import
import|import
name|java
operator|.
name|time
operator|.
name|format
operator|.
name|DateTimeFormatter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NoSuchElementException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Optional
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Scanner
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|Consumer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Assume
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|CommonConfigurationKeys
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FSDataInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FutureDataInputStreamBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|StreamCapabilities
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|AWSServiceIOException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|AbstractS3ATestBase
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|S3AFileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|commit
operator|.
name|AbstractCommitITest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|commit
operator|.
name|DurationInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|LongWritable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|Text
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|compress
operator|.
name|PassthroughCodec
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|JobConf
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|MRJobConfig
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|RecordReader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|TaskAttemptContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|TaskAttemptID
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|lib
operator|.
name|input
operator|.
name|FileSplit
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|lib
operator|.
name|input
operator|.
name|LineRecordReader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|task
operator|.
name|TaskAttemptContextImpl
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|impl
operator|.
name|FutureIOSupport
operator|.
name|awaitFuture
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|S3ATestUtils
operator|.
name|getLandsatCSVPath
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|select
operator|.
name|CsvFile
operator|.
name|ALL_QUOTES
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|select
operator|.
name|SelectConstants
operator|.
name|*
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|test
operator|.
name|LambdaTestUtils
operator|.
name|intercept
import|;
end_import

begin_comment
comment|/**  * Superclass for S3 Select tests.  * A lot of the work here goes into creating and querying a simple CSV test  * format, with various datatypes which can be used in type-casting queries.  *<pre>  * 1  "ID": index of the row  * 2  "date": date as ISO 8601  * 3  "timestamp": timestamp in seconds of epoch  * 4  "name", entry-$row  * 5  "odd", odd/even as boolean. True means odd,  * 6  "oddint", odd/even as int : 1 for odd, 0 for even  * 7  "oddrange": odd/even as 1 for odd, -1 for even  *</pre>  */
end_comment

begin_class
DECL|class|AbstractS3SelectTest
specifier|public
specifier|abstract
class|class
name|AbstractS3SelectTest
extends|extends
name|AbstractS3ATestBase
block|{
comment|/**    * Number of columns in the CSV file: {@value}.    */
DECL|field|CSV_COLUMN_COUNT
specifier|public
specifier|static
specifier|final
name|int
name|CSV_COLUMN_COUNT
init|=
literal|7
decl_stmt|;
DECL|field|TRUE
specifier|protected
specifier|static
specifier|final
name|String
name|TRUE
init|=
name|q
argument_list|(
literal|"TRUE"
argument_list|)
decl_stmt|;
DECL|field|FALSE
specifier|protected
specifier|static
specifier|final
name|String
name|FALSE
init|=
name|q
argument_list|(
literal|"FALSE"
argument_list|)
decl_stmt|;
DECL|field|SELECT_EVERYTHING
specifier|public
specifier|static
specifier|final
name|String
name|SELECT_EVERYTHING
init|=
literal|"SELECT * FROM S3OBJECT s"
decl_stmt|;
DECL|field|SELECT_EVEN_ROWS_NO_HEADER
specifier|public
specifier|static
specifier|final
name|String
name|SELECT_EVEN_ROWS_NO_HEADER
init|=
literal|"SELECT * FROM S3OBJECT s WHERE s._5 = "
operator|+
name|TRUE
decl_stmt|;
DECL|field|SELECT_ODD_ROWS
specifier|public
specifier|static
specifier|final
name|String
name|SELECT_ODD_ROWS
init|=
literal|"SELECT s.name FROM S3OBJECT s WHERE s.odd = "
operator|+
name|TRUE
decl_stmt|;
DECL|field|SELECT_ODD_ENTRIES
specifier|public
specifier|static
specifier|final
name|String
name|SELECT_ODD_ENTRIES
init|=
literal|"SELECT * FROM S3OBJECT s WHERE s.odd = `TRUE`"
decl_stmt|;
DECL|field|SELECT_ODD_ENTRIES_BOOL
specifier|public
specifier|static
specifier|final
name|String
name|SELECT_ODD_ENTRIES_BOOL
init|=
literal|"SELECT * FROM S3OBJECT s WHERE CAST(s.odd AS BOOL) = TRUE"
decl_stmt|;
DECL|field|SELECT_ODD_ENTRIES_INT
specifier|public
specifier|static
specifier|final
name|String
name|SELECT_ODD_ENTRIES_INT
init|=
literal|"SELECT * FROM S3OBJECT s WHERE CAST(s.\"oddint\" AS INT) = 1"
decl_stmt|;
DECL|field|SELECT_ODD_ENTRIES_DECIMAL
specifier|public
specifier|static
specifier|final
name|String
name|SELECT_ODD_ENTRIES_DECIMAL
init|=
literal|"SELECT * FROM S3OBJECT s WHERE CAST(s.\"oddint\" AS DECIMAL) = 1"
decl_stmt|;
comment|/**    * Playing with timestamps: {@value}.    */
DECL|field|SELECT_TO_DATE
specifier|public
specifier|static
specifier|final
name|String
name|SELECT_TO_DATE
init|=
literal|"SELECT\n"
operator|+
literal|"CAST(s.\"date\" AS TIMESTAMP)\n"
operator|+
literal|"FROM S3OBJECT s"
decl_stmt|;
comment|/**    * How many rows are being generated.    */
DECL|field|ALL_ROWS_COUNT
specifier|protected
specifier|static
specifier|final
name|int
name|ALL_ROWS_COUNT
init|=
literal|10
decl_stmt|;
comment|/**    * Row count of all rows + header.    */
DECL|field|ALL_ROWS_COUNT_WITH_HEADER
specifier|protected
specifier|static
specifier|final
name|int
name|ALL_ROWS_COUNT_WITH_HEADER
init|=
name|ALL_ROWS_COUNT
operator|+
literal|1
decl_stmt|;
comment|/**    * Number of odd rows expected: {@value}.    */
DECL|field|ODD_ROWS_COUNT
specifier|protected
specifier|static
specifier|final
name|int
name|ODD_ROWS_COUNT
init|=
name|ALL_ROWS_COUNT
operator|/
literal|2
decl_stmt|;
comment|/**    * Number of even rows expected: {@value}.    * This is the same as the odd row count; it's separate just to    * be consistent on tests which select even results.    */
DECL|field|EVEN_ROWS_COUNT
specifier|protected
specifier|static
specifier|final
name|int
name|EVEN_ROWS_COUNT
init|=
name|ODD_ROWS_COUNT
decl_stmt|;
DECL|field|ENTRY_0001
specifier|protected
specifier|static
specifier|final
name|String
name|ENTRY_0001
init|=
literal|"\"entry-0001\""
decl_stmt|;
DECL|field|ENTRY_0002
specifier|protected
specifier|static
specifier|final
name|String
name|ENTRY_0002
init|=
literal|"\"entry-0002\""
decl_stmt|;
comment|/**    * Path to the landsat csv.gz file.    */
DECL|field|landsatGZ
specifier|private
name|Path
name|landsatGZ
decl_stmt|;
comment|/**    * The filesystem with the landsat data.    */
DECL|field|landsatFS
specifier|private
name|S3AFileSystem
name|landsatFS
decl_stmt|;
comment|// A random task attempt id for testing.
DECL|field|attempt0
specifier|private
name|String
name|attempt0
decl_stmt|;
DECL|field|taskAttempt0
specifier|private
name|TaskAttemptID
name|taskAttempt0
decl_stmt|;
DECL|field|jobId
specifier|private
name|String
name|jobId
decl_stmt|;
comment|/**    * Base CSV file is headers.    *<pre>    * 1  "ID": index of the row    * 2  "date": date as Date.toString    * 3  "timestamp": timestamp in seconds of epoch    * 4  "name", entry-$row    * 5  "odd", odd/even as boolean    * 6  "oddint", odd/even as int : 1 for odd, 0 for even    * 7  "oddrange": odd/even as 1 for odd, -1 for even    *</pre>    * @param fs filesystem    * @param path path to write    * @param header should the standard header be printed?    * @param quoteHeaderPolicy what the header quote policy is.    * @param quoteRowPolicy what the row quote policy is.    * @param rows number of rows    * @param separator column separator    * @param eol end of line characters    * @param quote quote char    * @param footer callback to run after the main CSV file is written    * @throws IOException IO failure.    */
DECL|method|createStandardCsvFile ( final FileSystem fs, final Path path, final boolean header, final long quoteHeaderPolicy, final long quoteRowPolicy, final int rows, final String separator, final String eol, final String quote, final Consumer<CsvFile> footer)
specifier|public
specifier|static
name|void
name|createStandardCsvFile
parameter_list|(
specifier|final
name|FileSystem
name|fs
parameter_list|,
specifier|final
name|Path
name|path
parameter_list|,
specifier|final
name|boolean
name|header
parameter_list|,
specifier|final
name|long
name|quoteHeaderPolicy
parameter_list|,
specifier|final
name|long
name|quoteRowPolicy
parameter_list|,
specifier|final
name|int
name|rows
parameter_list|,
specifier|final
name|String
name|separator
parameter_list|,
specifier|final
name|String
name|eol
parameter_list|,
specifier|final
name|String
name|quote
parameter_list|,
specifier|final
name|Consumer
argument_list|<
name|CsvFile
argument_list|>
name|footer
parameter_list|)
throws|throws
name|IOException
block|{
try|try
init|(
name|CsvFile
name|csv
init|=
operator|new
name|CsvFile
argument_list|(
name|fs
argument_list|,
name|path
argument_list|,
literal|true
argument_list|,
name|separator
argument_list|,
name|eol
argument_list|,
name|quote
argument_list|)
init|)
block|{
if|if
condition|(
name|header
condition|)
block|{
name|writeStandardHeader
argument_list|(
name|csv
argument_list|,
name|quoteHeaderPolicy
argument_list|)
expr_stmt|;
block|}
name|DateTimeFormatter
name|formatter
init|=
name|DateTimeFormatter
operator|.
name|ISO_OFFSET_DATE_TIME
decl_stmt|;
name|ZonedDateTime
name|timestamp
init|=
name|ZonedDateTime
operator|.
name|now
argument_list|()
decl_stmt|;
name|Duration
name|duration
init|=
name|Duration
operator|.
name|ofHours
argument_list|(
literal|20
argument_list|)
decl_stmt|;
comment|// loop is at 1 for use in counters and flags
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<=
name|rows
condition|;
name|i
operator|++
control|)
block|{
comment|// flip the odd flags
name|boolean
name|odd
init|=
operator|(
name|i
operator|&
literal|1
operator|)
operator|==
literal|1
decl_stmt|;
comment|// and move the timestamp back
name|timestamp
operator|=
name|timestamp
operator|.
name|minus
argument_list|(
name|duration
argument_list|)
expr_stmt|;
name|csv
operator|.
name|row
argument_list|(
name|quoteRowPolicy
argument_list|,
name|i
argument_list|,
name|timestamp
operator|.
name|format
argument_list|(
name|formatter
argument_list|)
argument_list|,
name|timestamp
operator|.
name|toEpochSecond
argument_list|()
argument_list|,
name|String
operator|.
name|format
argument_list|(
literal|"entry-%04d"
argument_list|,
name|i
argument_list|)
argument_list|,
name|odd
condition|?
literal|"TRUE"
else|:
literal|"FALSE"
argument_list|,
name|odd
condition|?
literal|1
else|:
literal|0
argument_list|,
name|odd
condition|?
literal|1
else|:
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|// write the footer
name|footer
operator|.
name|accept
argument_list|(
name|csv
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Write out the standard header to a CSV file.    * @param csv CSV file to use.    * @param quoteHeaderPolicy quote policy.    * @return the input file.    * @throws IOException failure to write.    */
DECL|method|writeStandardHeader (final CsvFile csv, final long quoteHeaderPolicy)
specifier|private
specifier|static
name|CsvFile
name|writeStandardHeader
parameter_list|(
specifier|final
name|CsvFile
name|csv
parameter_list|,
specifier|final
name|long
name|quoteHeaderPolicy
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|csv
operator|.
name|row
argument_list|(
name|quoteHeaderPolicy
argument_list|,
literal|"id"
argument_list|,
literal|"date"
argument_list|,
literal|"timestamp"
argument_list|,
literal|"name"
argument_list|,
literal|"odd"
argument_list|,
literal|"oddint"
argument_list|,
literal|"oddrange"
argument_list|)
return|;
block|}
comment|/**    * Verify that an exception has a specific error code.    * if not: an assertion is raised containing the original value.    * @param code expected code.    * @param ex exception caught    * @throws AssertionError on a mismatch    */
DECL|method|verifyErrorCode (final String code, final AWSServiceIOException ex)
specifier|protected
specifier|static
name|AWSServiceIOException
name|verifyErrorCode
parameter_list|(
specifier|final
name|String
name|code
parameter_list|,
specifier|final
name|AWSServiceIOException
name|ex
parameter_list|)
block|{
name|logIntercepted
argument_list|(
name|ex
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|code
operator|.
name|equals
argument_list|(
name|ex
operator|.
name|getErrorCode
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"Expected Error code"
operator|+
name|code
operator|+
literal|" actual "
operator|+
name|ex
operator|.
name|getErrorCode
argument_list|()
argument_list|,
name|ex
argument_list|)
throw|;
block|}
return|return
name|ex
return|;
block|}
comment|/**    * Probe for a filesystem instance supporting S3 Select.    * @param filesystem filesystem    * @return true iff the filesystem supports S3 Select.    */
DECL|method|isSelectAvailable (final FileSystem filesystem)
name|boolean
name|isSelectAvailable
parameter_list|(
specifier|final
name|FileSystem
name|filesystem
parameter_list|)
block|{
return|return
name|filesystem
operator|instanceof
name|StreamCapabilities
operator|&&
operator|(
operator|(
name|StreamCapabilities
operator|)
name|filesystem
operator|)
operator|.
name|hasCapability
argument_list|(
name|S3_SELECT_CAPABILITY
argument_list|)
return|;
block|}
comment|/**    * Setup: requires select to be available.    */
annotation|@
name|Override
DECL|method|setup ()
specifier|public
name|void
name|setup
parameter_list|()
throws|throws
name|Exception
block|{
name|super
operator|.
name|setup
argument_list|()
expr_stmt|;
name|Assume
operator|.
name|assumeTrue
argument_list|(
literal|"S3 Select is not enabled on "
operator|+
name|getFileSystem
argument_list|()
operator|.
name|getUri
argument_list|()
argument_list|,
name|isSelectAvailable
argument_list|(
name|getFileSystem
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|Configuration
name|conf
init|=
name|getConfiguration
argument_list|()
decl_stmt|;
name|landsatGZ
operator|=
name|getLandsatCSVPath
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|landsatFS
operator|=
operator|(
name|S3AFileSystem
operator|)
name|landsatGZ
operator|.
name|getFileSystem
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|Assume
operator|.
name|assumeTrue
argument_list|(
literal|"S3 Select is not enabled on "
operator|+
name|landsatFS
operator|.
name|getUri
argument_list|()
argument_list|,
name|isSelectAvailable
argument_list|(
name|landsatFS
argument_list|)
argument_list|)
expr_stmt|;
comment|// create some job info
name|jobId
operator|=
name|AbstractCommitITest
operator|.
name|randomJobId
argument_list|()
expr_stmt|;
name|attempt0
operator|=
literal|"attempt_"
operator|+
name|jobId
operator|+
literal|"_m_000000_0"
expr_stmt|;
name|taskAttempt0
operator|=
name|TaskAttemptID
operator|.
name|forName
argument_list|(
name|attempt0
argument_list|)
expr_stmt|;
block|}
comment|/**    * Build the SQL statement, using String.Format rules.    * @param template template    * @param args arguments for the template    * @return the template to use    */
DECL|method|sql ( final String template, final Object... args)
specifier|protected
specifier|static
name|String
name|sql
parameter_list|(
specifier|final
name|String
name|template
parameter_list|,
specifier|final
name|Object
modifier|...
name|args
parameter_list|)
block|{
return|return
name|args
operator|.
name|length
operator|>
literal|0
condition|?
name|String
operator|.
name|format
argument_list|(
name|template
argument_list|,
name|args
argument_list|)
else|:
name|template
return|;
block|}
comment|/**    * Quote a constant with the SQL quote logic.    * @param c constant    * @return quoted constant    */
DECL|method|q (String c)
specifier|protected
specifier|static
name|String
name|q
parameter_list|(
name|String
name|c
parameter_list|)
block|{
return|return
literal|'\''
operator|+
name|c
operator|+
literal|'\''
return|;
block|}
comment|/**    * Select from a source file.    * @param fileSystem FS.    * @param source source file.    * @param conf config for the select call.    * @param sql template for a formatted SQL request.    * @param args arguments for the formatted request.    * @return the input stream.    * @throws IOException failure    */
DECL|method|select ( final FileSystem fileSystem, final Path source, final Configuration conf, final String sql, final Object... args)
specifier|protected
name|FSDataInputStream
name|select
parameter_list|(
specifier|final
name|FileSystem
name|fileSystem
parameter_list|,
specifier|final
name|Path
name|source
parameter_list|,
specifier|final
name|Configuration
name|conf
parameter_list|,
specifier|final
name|String
name|sql
parameter_list|,
specifier|final
name|Object
modifier|...
name|args
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|expression
init|=
name|sql
argument_list|(
name|sql
argument_list|,
name|args
argument_list|)
decl_stmt|;
name|describe
argument_list|(
literal|"Execution Select call: %s"
argument_list|,
name|expression
argument_list|)
expr_stmt|;
name|FutureDataInputStreamBuilder
name|builder
init|=
name|fileSystem
operator|.
name|openFile
argument_list|(
name|source
argument_list|)
operator|.
name|must
argument_list|(
name|SELECT_SQL
argument_list|,
name|expression
argument_list|)
decl_stmt|;
comment|// propagate all known options
for|for
control|(
name|String
name|key
range|:
name|InternalSelectConstants
operator|.
name|SELECT_OPTIONS
control|)
block|{
name|String
name|value
init|=
name|conf
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
name|builder
operator|.
name|must
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|awaitFuture
argument_list|(
name|builder
operator|.
name|build
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Select from a source file via the file context API.    * @param fc file context    * @param source source file.    * @param conf config for the select call.    * @param sql template for a formatted SQL request.    * @param args arguments for the formatted request.    * @return the input stream.    * @throws IOException failure    */
DECL|method|select ( final FileContext fc, final Path source, final Configuration conf, final String sql, final Object... args)
specifier|protected
name|FSDataInputStream
name|select
parameter_list|(
specifier|final
name|FileContext
name|fc
parameter_list|,
specifier|final
name|Path
name|source
parameter_list|,
specifier|final
name|Configuration
name|conf
parameter_list|,
specifier|final
name|String
name|sql
parameter_list|,
specifier|final
name|Object
modifier|...
name|args
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|expression
init|=
name|sql
argument_list|(
name|sql
argument_list|,
name|args
argument_list|)
decl_stmt|;
name|describe
argument_list|(
literal|"Execution Select call: %s"
argument_list|,
name|expression
argument_list|)
expr_stmt|;
name|FutureDataInputStreamBuilder
name|builder
init|=
name|fc
operator|.
name|openFile
argument_list|(
name|source
argument_list|)
operator|.
name|must
argument_list|(
name|SELECT_SQL
argument_list|,
name|expression
argument_list|)
decl_stmt|;
comment|// propagate all known options
name|InternalSelectConstants
operator|.
name|SELECT_OPTIONS
operator|.
name|forEach
argument_list|(
parameter_list|(
name|key
parameter_list|)
lambda|->
name|Optional
operator|.
name|ofNullable
argument_list|(
name|conf
operator|.
name|get
argument_list|(
name|key
argument_list|)
argument_list|)
operator|.
name|map
argument_list|(
parameter_list|(
name|v
parameter_list|)
lambda|->
name|builder
operator|.
name|must
argument_list|(
name|key
argument_list|,
name|v
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|awaitFuture
argument_list|(
name|builder
operator|.
name|build
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Parse a selection to lines; log at info.    * @param selection selection input    * @return a list of lines.    * @throws IOException if raised during the read.    */
DECL|method|parseToLines (final FSDataInputStream selection)
specifier|protected
name|List
argument_list|<
name|String
argument_list|>
name|parseToLines
parameter_list|(
specifier|final
name|FSDataInputStream
name|selection
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|parseToLines
argument_list|(
name|selection
argument_list|,
name|getMaxLines
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Enable the passthrough codec for a job, with the given extension.    * @param conf configuration to update    * @param extension extension to use    */
DECL|method|enablePassthroughCodec (final Configuration conf, final String extension)
specifier|protected
name|void
name|enablePassthroughCodec
parameter_list|(
specifier|final
name|Configuration
name|conf
parameter_list|,
specifier|final
name|String
name|extension
parameter_list|)
block|{
name|conf
operator|.
name|set
argument_list|(
name|CommonConfigurationKeys
operator|.
name|IO_COMPRESSION_CODECS_KEY
argument_list|,
name|PassthroughCodec
operator|.
name|CLASSNAME
argument_list|)
expr_stmt|;
name|conf
operator|.
name|set
argument_list|(
name|PassthroughCodec
operator|.
name|OPT_EXTENSION
argument_list|,
name|extension
argument_list|)
expr_stmt|;
block|}
comment|/**    * Override if a test suite is likely to ever return more lines.    * @return the max number for parseToLines/1    */
DECL|method|getMaxLines ()
specifier|protected
name|int
name|getMaxLines
parameter_list|()
block|{
return|return
literal|100
return|;
block|}
comment|/**    * Parse a selection to lines; log at info.    * @param selection selection input    * @param maxLines maximum number of lines.    * @return a list of lines.    * @throws IOException if raised during the read.    */
DECL|method|parseToLines (final FSDataInputStream selection, int maxLines)
specifier|protected
name|List
argument_list|<
name|String
argument_list|>
name|parseToLines
parameter_list|(
specifier|final
name|FSDataInputStream
name|selection
parameter_list|,
name|int
name|maxLines
parameter_list|)
throws|throws
name|IOException
block|{
name|List
argument_list|<
name|String
argument_list|>
name|result
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|String
name|stats
decl_stmt|;
comment|// the scanner assumes that any IOE => EOF; we don't want
comment|// that and so will check afterwards.
try|try
init|(
name|Scanner
name|scanner
init|=
operator|new
name|Scanner
argument_list|(
operator|new
name|BufferedReader
argument_list|(
operator|new
name|InputStreamReader
argument_list|(
name|selection
argument_list|)
argument_list|)
argument_list|)
init|)
block|{
name|scanner
operator|.
name|useDelimiter
argument_list|(
name|CSV_INPUT_RECORD_DELIMITER_DEFAULT
argument_list|)
expr_stmt|;
while|while
condition|(
name|maxLines
operator|>
literal|0
condition|)
block|{
try|try
block|{
name|String
name|l
init|=
name|scanner
operator|.
name|nextLine
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"{}"
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|result
operator|.
name|add
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|maxLines
operator|--
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NoSuchElementException
name|e
parameter_list|)
block|{
comment|// EOL or an error
break|break;
block|}
block|}
name|stats
operator|=
name|selection
operator|.
name|toString
argument_list|()
expr_stmt|;
name|describe
argument_list|(
literal|"Result line count: %s\nStatistics\n%s"
argument_list|,
name|result
operator|.
name|size
argument_list|()
argument_list|,
name|stats
argument_list|)
expr_stmt|;
comment|// look for any raised error.
name|IOException
name|ioe
init|=
name|scanner
operator|.
name|ioException
argument_list|()
decl_stmt|;
if|if
condition|(
name|ioe
operator|!=
literal|null
operator|&&
operator|!
operator|(
name|ioe
operator|instanceof
name|EOFException
operator|)
condition|)
block|{
throw|throw
name|ioe
throw|;
block|}
block|}
return|return
name|result
return|;
block|}
comment|/**    * Verify the selection count; return the original list.    * If there's a mismatch, the whole list is logged at error, then    * an assertion raised.    * @param expected expected value.    * @param expression expression -for error messages.    * @param selection selected result.    * @return the input list.    */
DECL|method|verifySelectionCount ( final int expected, final String expression, final List<String> selection)
specifier|protected
name|List
argument_list|<
name|String
argument_list|>
name|verifySelectionCount
parameter_list|(
specifier|final
name|int
name|expected
parameter_list|,
specifier|final
name|String
name|expression
parameter_list|,
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|selection
parameter_list|)
block|{
return|return
name|verifySelectionCount
argument_list|(
name|expected
argument_list|,
name|expected
argument_list|,
name|expression
argument_list|,
name|selection
argument_list|)
return|;
block|}
comment|/**    * Verify the selection count is within a given range;    * return the original list.    * If there's a mismatch, the whole list is logged at error, then    * an assertion raised.    * @param min min value (exclusive).    * @param max max value (exclusive). If -1: no maximum.    * @param expression expression -for error messages.    * @param selection selected result.    * @return the input list.    */
DECL|method|verifySelectionCount ( final int min, final int max, final String expression, final List<String> selection)
specifier|protected
name|List
argument_list|<
name|String
argument_list|>
name|verifySelectionCount
parameter_list|(
specifier|final
name|int
name|min
parameter_list|,
specifier|final
name|int
name|max
parameter_list|,
specifier|final
name|String
name|expression
parameter_list|,
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|selection
parameter_list|)
block|{
name|int
name|size
init|=
name|selection
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|size
operator|<
name|min
operator|||
operator|(
name|max
operator|>
operator|-
literal|1
operator|&&
name|size
operator|>
name|max
operator|)
condition|)
block|{
comment|// mismatch: log and then fail
name|String
name|listing
init|=
name|prepareToPrint
argument_list|(
name|selection
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|error
argument_list|(
literal|"\n{} => \n{}"
argument_list|,
name|expression
argument_list|,
name|listing
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"row count from select call "
operator|+
name|expression
operator|+
literal|" is out of range "
operator|+
name|min
operator|+
literal|" to "
operator|+
name|max
operator|+
literal|": "
operator|+
name|size
operator|+
literal|" \n"
operator|+
name|listing
argument_list|)
expr_stmt|;
block|}
return|return
name|selection
return|;
block|}
comment|/**    * Do whatever is needed to prepare a string for logging.    * @param selection selection    * @return something printable.    */
DECL|method|prepareToPrint (final List<String> selection)
specifier|protected
name|String
name|prepareToPrint
parameter_list|(
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|selection
parameter_list|)
block|{
return|return
name|String
operator|.
name|join
argument_list|(
literal|"\n"
argument_list|,
name|selection
argument_list|)
return|;
block|}
comment|/**    * Create "the standard" CSV file with the default row count.    * @param fs filesystem    * @param path path to write    * @param quoteRowPolicy what the row quote policy is.    * @throws IOException IO failure.    */
DECL|method|createStandardCsvFile ( final FileSystem fs, final Path path, final long quoteRowPolicy)
specifier|protected
name|void
name|createStandardCsvFile
parameter_list|(
specifier|final
name|FileSystem
name|fs
parameter_list|,
specifier|final
name|Path
name|path
parameter_list|,
specifier|final
name|long
name|quoteRowPolicy
parameter_list|)
throws|throws
name|IOException
block|{
name|createStandardCsvFile
argument_list|(
name|fs
argument_list|,
name|path
argument_list|,
literal|true
argument_list|,
name|ALL_QUOTES
argument_list|,
name|quoteRowPolicy
argument_list|,
name|ALL_ROWS_COUNT
argument_list|,
literal|","
argument_list|,
literal|"\n"
argument_list|,
literal|"\""
argument_list|,
name|c
lambda|->
block|{}
argument_list|)
expr_stmt|;
block|}
comment|/**    * Set an MR Job input option.    * @param conf configuration    * @param key key to set    * @param val value    */
DECL|method|inputOpt (Configuration conf, String key, String val)
name|void
name|inputOpt
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|String
name|key
parameter_list|,
name|String
name|val
parameter_list|)
block|{
name|conf
operator|.
name|set
argument_list|(
name|MRJobConfig
operator|.
name|INPUT_FILE_OPTION_PREFIX
operator|+
name|key
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
comment|/**    * Set a mandatory MR Job input option.    * @param conf configuration    * @param key key to set    * @param val value    */
DECL|method|inputMust (Configuration conf, String key, String val)
name|void
name|inputMust
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|String
name|key
parameter_list|,
name|String
name|val
parameter_list|)
block|{
name|conf
operator|.
name|set
argument_list|(
name|MRJobConfig
operator|.
name|INPUT_FILE_MANDATORY_PREFIX
operator|+
name|key
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
comment|/**    * Reads lines through a v2 RecordReader, as if it were part of a    * MRv2 job.    * @param conf job conf    * @param path path to query    * @param sql sql to add to the configuration.    * @param initialCapacity capacity of the read    * @param reader reader: this is closed after the read    * @return the selected lines.    * @throws Exception failure    */
DECL|method|readRecords (JobConf conf, Path path, String sql, RecordReader<?, ?> reader, int initialCapacity)
specifier|protected
name|List
argument_list|<
name|String
argument_list|>
name|readRecords
parameter_list|(
name|JobConf
name|conf
parameter_list|,
name|Path
name|path
parameter_list|,
name|String
name|sql
parameter_list|,
name|RecordReader
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|reader
parameter_list|,
name|int
name|initialCapacity
parameter_list|)
throws|throws
name|Exception
block|{
name|inputMust
argument_list|(
name|conf
argument_list|,
name|SELECT_SQL
argument_list|,
name|sql
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|lines
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|initialCapacity
argument_list|)
decl_stmt|;
try|try
block|{
name|reader
operator|.
name|initialize
argument_list|(
name|createSplit
argument_list|(
name|conf
argument_list|,
name|path
argument_list|)
argument_list|,
name|createTaskAttemptContext
argument_list|(
name|conf
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|reader
operator|.
name|nextKeyValue
argument_list|()
condition|)
block|{
name|lines
operator|.
name|add
argument_list|(
name|reader
operator|.
name|getCurrentValue
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|reader
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
return|return
name|lines
return|;
block|}
comment|/**    * Reads lines through a v1 RecordReader, as if it were part of a    * MRv1 job.    * @param conf job conf    * @param reader reader: this is closed after the read    * @param initialCapacity capacity of the read    * @return the selected lines.    * @throws Exception failure    */
DECL|method|readRecordsV1 (JobConf conf, org.apache.hadoop.mapred.RecordReader<K, V> reader, K key, V value, int initialCapacity)
specifier|protected
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|List
argument_list|<
name|String
argument_list|>
name|readRecordsV1
parameter_list|(
name|JobConf
name|conf
parameter_list|,
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|RecordReader
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|reader
parameter_list|,
name|K
name|key
parameter_list|,
name|V
name|value
parameter_list|,
name|int
name|initialCapacity
parameter_list|)
throws|throws
name|Exception
block|{
name|List
argument_list|<
name|String
argument_list|>
name|lines
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|initialCapacity
argument_list|)
decl_stmt|;
try|try
block|{
while|while
condition|(
name|reader
operator|.
name|next
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
condition|)
block|{
name|lines
operator|.
name|add
argument_list|(
name|value
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|reader
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
return|return
name|lines
return|;
block|}
comment|/**    * Create a task attempt context for a job, creating a random JobID to    * do this.    * @param conf job configuration.    * @return a new task attempt context containing the job conf    * @throws Exception failure.    */
DECL|method|createTaskAttemptContext (final JobConf conf)
specifier|protected
name|TaskAttemptContext
name|createTaskAttemptContext
parameter_list|(
specifier|final
name|JobConf
name|conf
parameter_list|)
throws|throws
name|Exception
block|{
name|String
name|id
init|=
name|AbstractCommitITest
operator|.
name|randomJobId
argument_list|()
decl_stmt|;
return|return
operator|new
name|TaskAttemptContextImpl
argument_list|(
name|conf
argument_list|,
name|TaskAttemptID
operator|.
name|forName
argument_list|(
literal|"attempt_"
operator|+
name|id
operator|+
literal|"_m_000000_0"
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Create an MRv2 file input split.    * @param conf job configuration    * @param path path to file    * @return the split    * @throws IOException problems reading the file.    */
DECL|method|createSplit (final JobConf conf, final Path path)
specifier|protected
name|FileSplit
name|createSplit
parameter_list|(
specifier|final
name|JobConf
name|conf
parameter_list|,
specifier|final
name|Path
name|path
parameter_list|)
throws|throws
name|IOException
block|{
name|FileSystem
name|fs
init|=
name|path
operator|.
name|getFileSystem
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|FileStatus
name|status
init|=
name|fs
operator|.
name|getFileStatus
argument_list|(
name|path
argument_list|)
decl_stmt|;
return|return
operator|new
name|FileSplit
argument_list|(
name|path
argument_list|,
literal|0
argument_list|,
name|status
operator|.
name|getLen
argument_list|()
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"localhost"
block|}
argument_list|)
return|;
block|}
comment|/**    * Create an MRv1 file input split.    * @param conf job configuration    * @param path path to file    * @return the split    * @throws IOException problems reading the file.    */
specifier|protected
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|FileSplit
DECL|method|createSplitV1 (final JobConf conf, final Path path)
name|createSplitV1
parameter_list|(
specifier|final
name|JobConf
name|conf
parameter_list|,
specifier|final
name|Path
name|path
parameter_list|)
throws|throws
name|IOException
block|{
name|FileSystem
name|fs
init|=
name|path
operator|.
name|getFileSystem
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|FileStatus
name|status
init|=
name|fs
operator|.
name|getFileStatus
argument_list|(
name|path
argument_list|)
decl_stmt|;
return|return
operator|new
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|FileSplit
argument_list|(
name|path
argument_list|,
literal|0
argument_list|,
name|status
operator|.
name|getLen
argument_list|()
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"localhost"
block|}
argument_list|)
return|;
block|}
comment|/**    * Create a v2 line record reader expecting newlines as the EOL marker.    * @return a reader    */
DECL|method|createLineRecordReader ()
specifier|protected
name|RecordReader
argument_list|<
name|LongWritable
argument_list|,
name|Text
argument_list|>
name|createLineRecordReader
parameter_list|()
block|{
return|return
operator|new
name|LineRecordReader
argument_list|(
operator|new
name|byte
index|[]
block|{
literal|'\n'
block|}
argument_list|)
return|;
block|}
comment|/**    * Create a v1 line record reader.    * @return a reader    */
specifier|protected
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|RecordReader
argument_list|<
name|LongWritable
argument_list|,
name|Text
argument_list|>
DECL|method|createLineRecordReaderV1 ( final JobConf conf, final Path path)
name|createLineRecordReaderV1
parameter_list|(
specifier|final
name|JobConf
name|conf
parameter_list|,
specifier|final
name|Path
name|path
parameter_list|)
throws|throws
name|IOException
block|{
return|return
operator|new
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|LineRecordReader
argument_list|(
name|conf
argument_list|,
name|createSplitV1
argument_list|(
name|conf
argument_list|,
name|path
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Get the path to the landsat file.    * @return the landsat CSV.GZ path.    */
DECL|method|getLandsatGZ ()
specifier|protected
name|Path
name|getLandsatGZ
parameter_list|()
block|{
return|return
name|landsatGZ
return|;
block|}
comment|/**    * Get the filesystem for the landsat file.    * @return the landsat FS.    */
DECL|method|getLandsatFS ()
specifier|protected
name|S3AFileSystem
name|getLandsatFS
parameter_list|()
block|{
return|return
name|landsatFS
return|;
block|}
comment|/**    * Perform a seek: log duration of the operation.    * @param stream stream to seek.    * @param target target position.    * @throws IOException on an error    */
DECL|method|seek (final FSDataInputStream stream, final long target)
specifier|protected
name|void
name|seek
parameter_list|(
specifier|final
name|FSDataInputStream
name|stream
parameter_list|,
specifier|final
name|long
name|target
parameter_list|)
throws|throws
name|IOException
block|{
try|try
init|(
name|DurationInfo
name|ignored
init|=
operator|new
name|DurationInfo
argument_list|(
name|LOG
argument_list|,
literal|"Seek to %d"
argument_list|,
name|target
argument_list|)
init|)
block|{
name|stream
operator|.
name|seek
argument_list|(
name|target
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Execute a seek so far past the EOF that it will be rejected.    * If the seek did not fail, the exception raised includes the toString()    * value of the stream.    * @param seekStream stream to seek in.    * @param newpos new position    * @return the EOF Exception raised.    * @throws Exception any other exception.    */
DECL|method|expectSeekEOF (final FSDataInputStream seekStream, final int newpos)
specifier|protected
name|EOFException
name|expectSeekEOF
parameter_list|(
specifier|final
name|FSDataInputStream
name|seekStream
parameter_list|,
specifier|final
name|int
name|newpos
parameter_list|)
throws|throws
name|Exception
block|{
return|return
name|intercept
argument_list|(
name|EOFException
operator|.
name|class
argument_list|,
parameter_list|()
lambda|->
block|{
name|seek
argument_list|(
name|seekStream
argument_list|,
name|newpos
argument_list|)
expr_stmt|;
comment|// return this for the test failure reports.
return|return
literal|"Stream after seek to "
operator|+
name|newpos
operator|+
literal|": "
operator|+
name|seekStream
return|;
block|}
argument_list|)
return|;
block|}
DECL|method|getAttempt0 ()
specifier|public
name|String
name|getAttempt0
parameter_list|()
block|{
return|return
name|attempt0
return|;
block|}
DECL|method|getTaskAttempt0 ()
specifier|public
name|TaskAttemptID
name|getTaskAttempt0
parameter_list|()
block|{
return|return
name|taskAttempt0
return|;
block|}
DECL|method|getJobId ()
specifier|public
name|String
name|getJobId
parameter_list|()
block|{
return|return
name|jobId
return|;
block|}
comment|/**    * Logs intercepted exceptions.    * This generates the stack traces for the documentation.    * @param ex exception    * @return the exception passed in (for chaining)    */
DECL|method|logIntercepted (T ex)
specifier|protected
specifier|static
parameter_list|<
name|T
extends|extends
name|Exception
parameter_list|>
name|T
name|logIntercepted
parameter_list|(
name|T
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Intercepted Exception is "
argument_list|,
name|ex
argument_list|)
expr_stmt|;
return|return
name|ex
return|;
block|}
block|}
end_class

end_unit

