begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  *  or more contributor license agreements.  See the NOTICE file  *  distributed with this work for additional information  *  regarding copyright ownership.  The ASF licenses this file  *  to you under the Apache License, Version 2.0 (the  *  "License"); you may not use this file except in compliance  *  with the License.  You may obtain a copy of the License at  *  *       http://www.apache.org/licenses/LICENSE-2.0  *  *  Unless required by applicable law or agreed to in writing, software  *  distributed under the License is distributed on an "AS IS" BASIS,  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  *  See the License for the specific language governing permissions and  *  limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.fs.contract.s3a
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|contract
operator|.
name|s3a
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URI
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URISyntaxException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Test
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|runner
operator|.
name|RunWith
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|runners
operator|.
name|Parameterized
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FSDataInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|contract
operator|.
name|AbstractContractSeekTest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|contract
operator|.
name|AbstractFSContract
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|contract
operator|.
name|ContractTestUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|S3AFileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|S3AInputPolicy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|S3ATestUtils
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkNotNull
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|Constants
operator|.
name|INPUT_FADVISE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|Constants
operator|.
name|INPUT_FADV_NORMAL
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|Constants
operator|.
name|INPUT_FADV_RANDOM
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|Constants
operator|.
name|INPUT_FADV_SEQUENTIAL
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|Constants
operator|.
name|READAHEAD_RANGE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|S3ATestConstants
operator|.
name|FS_S3A_IMPL_DISABLE_CACHE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|S3ATestUtils
operator|.
name|maybeEnableS3Guard
import|;
end_import

begin_comment
comment|/**  * S3A contract tests covering file seek.  */
end_comment

begin_class
annotation|@
name|RunWith
argument_list|(
name|Parameterized
operator|.
name|class
argument_list|)
DECL|class|ITestS3AContractSeek
specifier|public
class|class
name|ITestS3AContractSeek
extends|extends
name|AbstractContractSeekTest
block|{
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|ITestS3AContractSeek
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|READAHEAD
specifier|protected
specifier|static
specifier|final
name|int
name|READAHEAD
init|=
literal|1024
decl_stmt|;
DECL|field|seekPolicy
specifier|private
specifier|final
name|String
name|seekPolicy
decl_stmt|;
DECL|field|DATASET_LEN
specifier|public
specifier|static
specifier|final
name|int
name|DATASET_LEN
init|=
name|READAHEAD
operator|*
literal|2
decl_stmt|;
DECL|field|DATASET
specifier|public
specifier|static
specifier|final
name|byte
index|[]
name|DATASET
init|=
name|ContractTestUtils
operator|.
name|dataset
argument_list|(
name|DATASET_LEN
argument_list|,
literal|'a'
argument_list|,
literal|32
argument_list|)
decl_stmt|;
comment|/**    * This test suite is parameterized for the different seek policies    * which S3A Supports.    * @return a list of seek policies to test.    */
annotation|@
name|Parameterized
operator|.
name|Parameters
DECL|method|params ()
specifier|public
specifier|static
name|Collection
argument_list|<
name|Object
index|[]
argument_list|>
name|params
parameter_list|()
block|{
return|return
name|Arrays
operator|.
name|asList
argument_list|(
operator|new
name|Object
index|[]
index|[]
block|{
block|{
name|INPUT_FADV_RANDOM
block|}
block|,
block|{
name|INPUT_FADV_NORMAL
block|}
block|,
block|{
name|INPUT_FADV_SEQUENTIAL
block|}
block|,     }
argument_list|)
return|;
block|}
comment|/**    * Run the test with a chosen seek policy.    * @param seekPolicy fadvise policy to use.    */
DECL|method|ITestS3AContractSeek (final String seekPolicy)
specifier|public
name|ITestS3AContractSeek
parameter_list|(
specifier|final
name|String
name|seekPolicy
parameter_list|)
block|{
name|this
operator|.
name|seekPolicy
operator|=
name|seekPolicy
expr_stmt|;
block|}
comment|/**    * Create a configuration, possibly patching in S3Guard options.    * The FS is set to be uncached and the readahead and seek policies    * of the bucket itself are removed, so as to guarantee that the    * parameterized and test settings are    * @return a configuration    */
annotation|@
name|Override
DECL|method|createConfiguration ()
specifier|protected
name|Configuration
name|createConfiguration
parameter_list|()
block|{
name|Configuration
name|conf
init|=
name|super
operator|.
name|createConfiguration
argument_list|()
decl_stmt|;
comment|// patch in S3Guard options
name|maybeEnableS3Guard
argument_list|(
name|conf
argument_list|)
expr_stmt|;
comment|// purge any per-bucket overrides.
try|try
block|{
name|URI
name|bucketURI
init|=
operator|new
name|URI
argument_list|(
name|checkNotNull
argument_list|(
name|conf
operator|.
name|get
argument_list|(
literal|"fs.contract.test.fs.s3a"
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|S3ATestUtils
operator|.
name|removeBucketOverrides
argument_list|(
name|bucketURI
operator|.
name|getHost
argument_list|()
argument_list|,
name|conf
argument_list|,
name|READAHEAD_RANGE
argument_list|,
name|INPUT_FADVISE
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|URISyntaxException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
comment|// the FS is uncached, so will need clearing in test teardowns.
name|S3ATestUtils
operator|.
name|disableFilesystemCaching
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|conf
operator|.
name|setInt
argument_list|(
name|READAHEAD_RANGE
argument_list|,
name|READAHEAD
argument_list|)
expr_stmt|;
name|conf
operator|.
name|set
argument_list|(
name|INPUT_FADVISE
argument_list|,
name|seekPolicy
argument_list|)
expr_stmt|;
return|return
name|conf
return|;
block|}
annotation|@
name|Override
DECL|method|createContract (Configuration conf)
specifier|protected
name|AbstractFSContract
name|createContract
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
return|return
operator|new
name|S3AContract
argument_list|(
name|conf
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|teardown ()
specifier|public
name|void
name|teardown
parameter_list|()
throws|throws
name|Exception
block|{
name|S3AFileSystem
name|fs
init|=
name|getFileSystem
argument_list|()
decl_stmt|;
if|if
condition|(
name|fs
operator|.
name|getConf
argument_list|()
operator|.
name|getBoolean
argument_list|(
name|FS_S3A_IMPL_DISABLE_CACHE
argument_list|,
literal|false
argument_list|)
condition|)
block|{
name|fs
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
name|super
operator|.
name|teardown
argument_list|()
expr_stmt|;
block|}
comment|/**    * This subclass of the {@code path(path)} operation adds the seek policy    * to the end to guarantee uniqueness across different calls of the same    * method.    *    * {@inheritDoc}    */
annotation|@
name|Override
DECL|method|path (final String filepath)
specifier|protected
name|Path
name|path
parameter_list|(
specifier|final
name|String
name|filepath
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|super
operator|.
name|path
argument_list|(
name|filepath
operator|+
literal|"-"
operator|+
name|seekPolicy
argument_list|)
return|;
block|}
comment|/**    * Go to end, read then seek back to the previous position to force normal    * seek policy to switch to random IO.    * This will call readByte to trigger the second GET    * @param in input stream    * @return the byte read    * @throws IOException failure.    */
DECL|method|readAtEndAndReturn (final FSDataInputStream in)
specifier|private
name|byte
name|readAtEndAndReturn
parameter_list|(
specifier|final
name|FSDataInputStream
name|in
parameter_list|)
throws|throws
name|IOException
block|{
name|long
name|pos
init|=
name|in
operator|.
name|getPos
argument_list|()
decl_stmt|;
name|in
operator|.
name|seek
argument_list|(
name|DATASET_LEN
operator|-
literal|1
argument_list|)
expr_stmt|;
name|in
operator|.
name|readByte
argument_list|()
expr_stmt|;
comment|// go back to start and force a new GET
name|in
operator|.
name|seek
argument_list|(
name|pos
argument_list|)
expr_stmt|;
return|return
name|in
operator|.
name|readByte
argument_list|()
return|;
block|}
comment|/**    * Assert that the data read matches the dataset at the given offset.    * This helps verify that the seek process is moving the read pointer    * to the correct location in the file.    * @param readOffset the offset in the file where the read began.    * @param operation operation name for the assertion.    * @param data data read in.    * @param length length of data to check.    */
DECL|method|assertDatasetEquals ( final int readOffset, final String operation, final byte[] data, int length)
specifier|private
name|void
name|assertDatasetEquals
parameter_list|(
specifier|final
name|int
name|readOffset
parameter_list|,
specifier|final
name|String
name|operation
parameter_list|,
specifier|final
name|byte
index|[]
name|data
parameter_list|,
name|int
name|length
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
block|{
name|int
name|o
init|=
name|readOffset
operator|+
name|i
decl_stmt|;
name|assertEquals
argument_list|(
name|operation
operator|+
literal|" with seek policy "
operator|+
name|seekPolicy
operator|+
literal|"and read offset "
operator|+
name|readOffset
operator|+
literal|": data["
operator|+
name|i
operator|+
literal|"] != DATASET["
operator|+
name|o
operator|+
literal|"]"
argument_list|,
name|DATASET
index|[
name|o
index|]
argument_list|,
name|data
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|getFileSystem ()
specifier|public
name|S3AFileSystem
name|getFileSystem
parameter_list|()
block|{
return|return
operator|(
name|S3AFileSystem
operator|)
name|super
operator|.
name|getFileSystem
argument_list|()
return|;
block|}
annotation|@
name|Test
DECL|method|testReadPolicyInFS ()
specifier|public
name|void
name|testReadPolicyInFS
parameter_list|()
throws|throws
name|Throwable
block|{
name|describe
argument_list|(
literal|"Verify the read policy is being consistently set"
argument_list|)
expr_stmt|;
name|S3AFileSystem
name|fs
init|=
name|getFileSystem
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
name|S3AInputPolicy
operator|.
name|getPolicy
argument_list|(
name|seekPolicy
argument_list|)
argument_list|,
name|fs
operator|.
name|getInputPolicy
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Test for HADOOP-16109: Parquet reading S3AFileSystem causes EOF.    * This sets up a read which will span the active readahead and,    * in random IO mode, a subsequent GET.    */
annotation|@
name|Test
DECL|method|testReadAcrossReadahead ()
specifier|public
name|void
name|testReadAcrossReadahead
parameter_list|()
throws|throws
name|Throwable
block|{
name|describe
argument_list|(
literal|"Sets up a read which will span the active readahead"
operator|+
literal|" and the rest of the file."
argument_list|)
expr_stmt|;
name|Path
name|path
init|=
name|path
argument_list|(
literal|"testReadAcrossReadahead"
argument_list|)
decl_stmt|;
name|writeTestDataset
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|FileSystem
name|fs
init|=
name|getFileSystem
argument_list|()
decl_stmt|;
comment|// forward seek reading across readahead boundary
try|try
init|(
name|FSDataInputStream
name|in
init|=
name|fs
operator|.
name|open
argument_list|(
name|path
argument_list|)
init|)
block|{
specifier|final
name|byte
index|[]
name|temp
init|=
operator|new
name|byte
index|[
literal|5
index|]
decl_stmt|;
name|in
operator|.
name|readByte
argument_list|()
expr_stmt|;
name|int
name|offset
init|=
name|READAHEAD
operator|-
literal|1
decl_stmt|;
name|in
operator|.
name|readFully
argument_list|(
name|offset
argument_list|,
name|temp
argument_list|)
expr_stmt|;
comment|//<-- works
name|assertDatasetEquals
argument_list|(
name|offset
argument_list|,
literal|"read spanning boundary"
argument_list|,
name|temp
argument_list|,
name|temp
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
comment|// Read exactly on the the boundary
try|try
init|(
name|FSDataInputStream
name|in
init|=
name|fs
operator|.
name|open
argument_list|(
name|path
argument_list|)
init|)
block|{
specifier|final
name|byte
index|[]
name|temp
init|=
operator|new
name|byte
index|[
literal|5
index|]
decl_stmt|;
name|readAtEndAndReturn
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"current position"
argument_list|,
literal|1
argument_list|,
call|(
name|int
call|)
argument_list|(
name|in
operator|.
name|getPos
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|in
operator|.
name|readFully
argument_list|(
name|READAHEAD
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|assertDatasetEquals
argument_list|(
name|READAHEAD
argument_list|,
literal|"read exactly on boundary"
argument_list|,
name|temp
argument_list|,
name|temp
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Read across the end of the read buffer using the readByte call,    * which will read a single byte only.    */
annotation|@
name|Test
DECL|method|testReadSingleByteAcrossReadahead ()
specifier|public
name|void
name|testReadSingleByteAcrossReadahead
parameter_list|()
throws|throws
name|Throwable
block|{
name|describe
argument_list|(
literal|"Read over boundary using read()/readByte() calls."
argument_list|)
expr_stmt|;
name|Path
name|path
init|=
name|path
argument_list|(
literal|"testReadSingleByteAcrossReadahead"
argument_list|)
decl_stmt|;
name|writeTestDataset
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|FileSystem
name|fs
init|=
name|getFileSystem
argument_list|()
decl_stmt|;
try|try
init|(
name|FSDataInputStream
name|in
init|=
name|fs
operator|.
name|open
argument_list|(
name|path
argument_list|)
init|)
block|{
specifier|final
name|byte
index|[]
name|b0
init|=
operator|new
name|byte
index|[
literal|1
index|]
decl_stmt|;
name|readAtEndAndReturn
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|in
operator|.
name|seek
argument_list|(
name|READAHEAD
operator|-
literal|1
argument_list|)
expr_stmt|;
name|b0
index|[
literal|0
index|]
operator|=
name|in
operator|.
name|readByte
argument_list|()
expr_stmt|;
name|assertDatasetEquals
argument_list|(
name|READAHEAD
operator|-
literal|1
argument_list|,
literal|"read before end of boundary"
argument_list|,
name|b0
argument_list|,
name|b0
operator|.
name|length
argument_list|)
expr_stmt|;
name|b0
index|[
literal|0
index|]
operator|=
name|in
operator|.
name|readByte
argument_list|()
expr_stmt|;
name|assertDatasetEquals
argument_list|(
name|READAHEAD
argument_list|,
literal|"read at end of boundary"
argument_list|,
name|b0
argument_list|,
name|b0
operator|.
name|length
argument_list|)
expr_stmt|;
name|b0
index|[
literal|0
index|]
operator|=
name|in
operator|.
name|readByte
argument_list|()
expr_stmt|;
name|assertDatasetEquals
argument_list|(
name|READAHEAD
operator|+
literal|1
argument_list|,
literal|"read after end of boundary"
argument_list|,
name|b0
argument_list|,
name|b0
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Test
DECL|method|testSeekToReadaheadAndRead ()
specifier|public
name|void
name|testSeekToReadaheadAndRead
parameter_list|()
throws|throws
name|Throwable
block|{
name|describe
argument_list|(
literal|"Seek to just before readahead limit and call"
operator|+
literal|" InputStream.read(byte[])"
argument_list|)
expr_stmt|;
name|Path
name|path
init|=
name|path
argument_list|(
literal|"testSeekToReadaheadAndRead"
argument_list|)
decl_stmt|;
name|FileSystem
name|fs
init|=
name|getFileSystem
argument_list|()
decl_stmt|;
name|writeTestDataset
argument_list|(
name|path
argument_list|)
expr_stmt|;
try|try
init|(
name|FSDataInputStream
name|in
init|=
name|fs
operator|.
name|open
argument_list|(
name|path
argument_list|)
init|)
block|{
name|readAtEndAndReturn
argument_list|(
name|in
argument_list|)
expr_stmt|;
specifier|final
name|byte
index|[]
name|temp
init|=
operator|new
name|byte
index|[
literal|5
index|]
decl_stmt|;
name|int
name|offset
init|=
name|READAHEAD
operator|-
literal|1
decl_stmt|;
name|in
operator|.
name|seek
argument_list|(
name|offset
argument_list|)
expr_stmt|;
comment|// expect to read at least one byte.
name|int
name|l
init|=
name|in
operator|.
name|read
argument_list|(
name|temp
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
literal|"Reading in temp data"
argument_list|,
name|l
operator|>
literal|0
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Read of byte array at offset {} returned {} bytes"
argument_list|,
name|offset
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|assertDatasetEquals
argument_list|(
name|offset
argument_list|,
literal|"read at end of boundary"
argument_list|,
name|temp
argument_list|,
name|l
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Test
DECL|method|testSeekToReadaheadExactlyAndRead ()
specifier|public
name|void
name|testSeekToReadaheadExactlyAndRead
parameter_list|()
throws|throws
name|Throwable
block|{
name|describe
argument_list|(
literal|"Seek to exactly the readahead limit and call"
operator|+
literal|" InputStream.read(byte[])"
argument_list|)
expr_stmt|;
name|Path
name|path
init|=
name|path
argument_list|(
literal|"testSeekToReadaheadExactlyAndRead"
argument_list|)
decl_stmt|;
name|FileSystem
name|fs
init|=
name|getFileSystem
argument_list|()
decl_stmt|;
name|writeTestDataset
argument_list|(
name|path
argument_list|)
expr_stmt|;
try|try
init|(
name|FSDataInputStream
name|in
init|=
name|fs
operator|.
name|open
argument_list|(
name|path
argument_list|)
init|)
block|{
name|readAtEndAndReturn
argument_list|(
name|in
argument_list|)
expr_stmt|;
specifier|final
name|byte
index|[]
name|temp
init|=
operator|new
name|byte
index|[
literal|5
index|]
decl_stmt|;
name|int
name|offset
init|=
name|READAHEAD
decl_stmt|;
name|in
operator|.
name|seek
argument_list|(
name|offset
argument_list|)
expr_stmt|;
comment|// expect to read at least one byte.
name|int
name|l
init|=
name|in
operator|.
name|read
argument_list|(
name|temp
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Read of byte array at offset {} returned {} bytes"
argument_list|,
name|offset
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"Reading in temp data"
argument_list|,
name|l
operator|>
literal|0
argument_list|)
expr_stmt|;
name|assertDatasetEquals
argument_list|(
name|offset
argument_list|,
literal|"read at end of boundary"
argument_list|,
name|temp
argument_list|,
name|l
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Test
DECL|method|testSeekToReadaheadExactlyAndReadByte ()
specifier|public
name|void
name|testSeekToReadaheadExactlyAndReadByte
parameter_list|()
throws|throws
name|Throwable
block|{
name|describe
argument_list|(
literal|"Seek to exactly the readahead limit and call"
operator|+
literal|" readByte()"
argument_list|)
expr_stmt|;
name|Path
name|path
init|=
name|path
argument_list|(
literal|"testSeekToReadaheadExactlyAndReadByte"
argument_list|)
decl_stmt|;
name|FileSystem
name|fs
init|=
name|getFileSystem
argument_list|()
decl_stmt|;
name|writeTestDataset
argument_list|(
name|path
argument_list|)
expr_stmt|;
try|try
init|(
name|FSDataInputStream
name|in
init|=
name|fs
operator|.
name|open
argument_list|(
name|path
argument_list|)
init|)
block|{
name|readAtEndAndReturn
argument_list|(
name|in
argument_list|)
expr_stmt|;
specifier|final
name|byte
index|[]
name|temp
init|=
operator|new
name|byte
index|[
literal|1
index|]
decl_stmt|;
name|int
name|offset
init|=
name|READAHEAD
decl_stmt|;
name|in
operator|.
name|seek
argument_list|(
name|offset
argument_list|)
expr_stmt|;
comment|// expect to read a byte successfully.
name|temp
index|[
literal|0
index|]
operator|=
name|in
operator|.
name|readByte
argument_list|()
expr_stmt|;
name|assertDatasetEquals
argument_list|(
name|READAHEAD
argument_list|,
literal|"read at end of boundary"
argument_list|,
name|temp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Read of byte at offset {} returned expected value"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Write the standard {@link #DATASET} dataset to the given path.    * @param path path to write to.    * @throws IOException failure    */
DECL|method|writeTestDataset (final Path path)
specifier|private
name|void
name|writeTestDataset
parameter_list|(
specifier|final
name|Path
name|path
parameter_list|)
throws|throws
name|IOException
block|{
name|ContractTestUtils
operator|.
name|writeDataset
argument_list|(
name|getFileSystem
argument_list|()
argument_list|,
name|path
argument_list|,
name|DATASET
argument_list|,
name|DATASET_LEN
argument_list|,
name|READAHEAD
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
end_class

end_unit

