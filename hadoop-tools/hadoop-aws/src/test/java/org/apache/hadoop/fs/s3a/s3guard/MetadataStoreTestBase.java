begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.fs.s3a.s3guard
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|s3guard
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Sets
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|After
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Assert
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Assume
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Before
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Test
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|RemoteIterator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|permission
operator|.
name|FsPermission
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|S3ATestUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|Tristate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|IOUtils
import|;
end_import

begin_comment
comment|/**  * Main test class for MetadataStore implementations.  * Implementations should each create a test by subclassing this and  * overriding {@link #createContract()}.  * If your implementation may return missing results for recently set paths,  * override {@link MetadataStoreTestBase#allowMissing()}.  */
end_comment

begin_class
DECL|class|MetadataStoreTestBase
specifier|public
specifier|abstract
class|class
name|MetadataStoreTestBase
extends|extends
name|Assert
block|{
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|MetadataStoreTestBase
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/** Some dummy values for sanity-checking FileStatus contents. */
DECL|field|BLOCK_SIZE
specifier|static
specifier|final
name|long
name|BLOCK_SIZE
init|=
literal|32
operator|*
literal|1024
operator|*
literal|1024
decl_stmt|;
DECL|field|REPLICATION
specifier|static
specifier|final
name|int
name|REPLICATION
init|=
literal|1
decl_stmt|;
DECL|field|PERMISSION
specifier|static
specifier|final
name|FsPermission
name|PERMISSION
init|=
operator|new
name|FsPermission
argument_list|(
operator|(
name|short
operator|)
literal|0755
argument_list|)
decl_stmt|;
DECL|field|OWNER
specifier|static
specifier|final
name|String
name|OWNER
init|=
literal|"bob"
decl_stmt|;
DECL|field|GROUP
specifier|static
specifier|final
name|String
name|GROUP
init|=
literal|"uncles"
decl_stmt|;
DECL|field|accessTime
specifier|private
specifier|final
name|long
name|accessTime
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
DECL|field|modTime
specifier|private
specifier|final
name|long
name|modTime
init|=
name|accessTime
operator|-
literal|5000
decl_stmt|;
comment|/**    * Each test should override this.  Will use a new Configuration instance.    * @return Contract which specifies the MetadataStore under test plus config.    */
DECL|method|createContract ()
specifier|public
specifier|abstract
name|AbstractMSContract
name|createContract
parameter_list|()
throws|throws
name|IOException
function_decl|;
comment|/**    * Each test should override this.    * @param conf Base configuration instance to use.    * @return Contract which specifies the MetadataStore under test plus config.    */
DECL|method|createContract (Configuration conf)
specifier|public
specifier|abstract
name|AbstractMSContract
name|createContract
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/**    * Tests assume that implementations will return recently set results.  If    * your implementation does not always hold onto metadata (e.g. LRU or    * time-based expiry) you can override this to return false.    * @return true if the test should succeed when null results are returned    *  from the MetadataStore under test.    */
DECL|method|allowMissing ()
specifier|public
name|boolean
name|allowMissing
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
comment|/**    * Pruning is an optional feature for metadata store implementations.    * Tests will only check that functionality if it is expected to work.    * @return true if the test should expect pruning to work.    */
DECL|method|supportsPruning ()
specifier|public
name|boolean
name|supportsPruning
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
comment|/** The MetadataStore contract used to test against. */
DECL|field|contract
specifier|private
name|AbstractMSContract
name|contract
decl_stmt|;
DECL|field|ms
specifier|private
name|MetadataStore
name|ms
decl_stmt|;
comment|/**    * @return reference to the test contract.    */
DECL|method|getContract ()
specifier|protected
name|AbstractMSContract
name|getContract
parameter_list|()
block|{
return|return
name|contract
return|;
block|}
annotation|@
name|Before
DECL|method|setUp ()
specifier|public
name|void
name|setUp
parameter_list|()
throws|throws
name|Exception
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"== Setup. =="
argument_list|)
expr_stmt|;
name|contract
operator|=
name|createContract
argument_list|()
expr_stmt|;
name|ms
operator|=
name|contract
operator|.
name|getMetadataStore
argument_list|()
expr_stmt|;
name|assertNotNull
argument_list|(
literal|"null MetadataStore"
argument_list|,
name|ms
argument_list|)
expr_stmt|;
name|assertNotNull
argument_list|(
literal|"null FileSystem"
argument_list|,
name|contract
operator|.
name|getFileSystem
argument_list|()
argument_list|)
expr_stmt|;
name|ms
operator|.
name|initialize
argument_list|(
name|contract
operator|.
name|getFileSystem
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|After
DECL|method|tearDown ()
specifier|public
name|void
name|tearDown
parameter_list|()
throws|throws
name|Exception
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"== Tear down. =="
argument_list|)
expr_stmt|;
if|if
condition|(
name|ms
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|ms
operator|.
name|destroy
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to destroy tables in teardown"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
name|IOUtils
operator|.
name|closeStream
argument_list|(
name|ms
argument_list|)
expr_stmt|;
name|ms
operator|=
literal|null
expr_stmt|;
block|}
block|}
comment|/**    * Helper function for verifying DescendantsIterator and    * MetadataStoreListFilesIterator behavior.    * @param createNodes List of paths to create    * @param checkNodes List of paths that the iterator should return    */
DECL|method|doTestDescendantsIterator ( Class implementation, String[] createNodes, String[] checkNodes)
specifier|private
name|void
name|doTestDescendantsIterator
parameter_list|(
name|Class
name|implementation
parameter_list|,
name|String
index|[]
name|createNodes
parameter_list|,
name|String
index|[]
name|checkNodes
parameter_list|)
throws|throws
name|Exception
block|{
comment|// we set up the example file system tree in metadata store
for|for
control|(
name|String
name|pathStr
range|:
name|createNodes
control|)
block|{
specifier|final
name|FileStatus
name|status
init|=
name|pathStr
operator|.
name|contains
argument_list|(
literal|"file"
argument_list|)
condition|?
name|basicFileStatus
argument_list|(
name|strToPath
argument_list|(
name|pathStr
argument_list|)
argument_list|,
literal|100
argument_list|,
literal|false
argument_list|)
else|:
name|basicFileStatus
argument_list|(
name|strToPath
argument_list|(
name|pathStr
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|ms
operator|.
name|put
argument_list|(
operator|new
name|PathMetadata
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|final
name|PathMetadata
name|rootMeta
init|=
operator|new
name|PathMetadata
argument_list|(
name|makeDirStatus
argument_list|(
literal|"/"
argument_list|)
argument_list|)
decl_stmt|;
name|RemoteIterator
argument_list|<
name|FileStatus
argument_list|>
name|iterator
decl_stmt|;
if|if
condition|(
name|implementation
operator|==
name|DescendantsIterator
operator|.
name|class
condition|)
block|{
name|iterator
operator|=
operator|new
name|DescendantsIterator
argument_list|(
name|ms
argument_list|,
name|rootMeta
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|implementation
operator|==
name|MetadataStoreListFilesIterator
operator|.
name|class
condition|)
block|{
name|iterator
operator|=
operator|new
name|MetadataStoreListFilesIterator
argument_list|(
name|ms
argument_list|,
name|rootMeta
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"Unrecognized class"
argument_list|)
throw|;
block|}
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|actual
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
while|while
condition|(
name|iterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
specifier|final
name|Path
name|p
init|=
name|iterator
operator|.
name|next
argument_list|()
operator|.
name|getPath
argument_list|()
decl_stmt|;
name|actual
operator|.
name|add
argument_list|(
name|Path
operator|.
name|getPathWithoutSchemeAndAuthority
argument_list|(
name|p
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"We got {} by iterating DescendantsIterator"
argument_list|,
name|actual
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|allowMissing
argument_list|()
condition|)
block|{
name|assertEquals
argument_list|(
name|Sets
operator|.
name|newHashSet
argument_list|(
name|checkNodes
argument_list|)
argument_list|,
name|actual
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Test that we can get the whole sub-tree by iterating DescendantsIterator.    *    * The tree is similar to or same as the example in code comment.    */
annotation|@
name|Test
DECL|method|testDescendantsIterator ()
specifier|public
name|void
name|testDescendantsIterator
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|String
index|[]
name|tree
init|=
operator|new
name|String
index|[]
block|{
literal|"/dir1"
block|,
literal|"/dir1/dir2"
block|,
literal|"/dir1/dir3"
block|,
literal|"/dir1/dir2/file1"
block|,
literal|"/dir1/dir2/file2"
block|,
literal|"/dir1/dir3/dir4"
block|,
literal|"/dir1/dir3/dir5"
block|,
literal|"/dir1/dir3/dir4/file3"
block|,
literal|"/dir1/dir3/dir5/file4"
block|,
literal|"/dir1/dir3/dir6"
block|}
decl_stmt|;
name|doTestDescendantsIterator
argument_list|(
name|DescendantsIterator
operator|.
name|class
argument_list|,
name|tree
argument_list|,
name|tree
argument_list|)
expr_stmt|;
block|}
comment|/**    * Test that we can get the correct subset of the tree with    * MetadataStoreListFilesIterator.    *    * The tree is similar to or same as the example in code comment.    */
annotation|@
name|Test
DECL|method|testMetadataStoreListFilesIterator ()
specifier|public
name|void
name|testMetadataStoreListFilesIterator
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|String
index|[]
name|wholeTree
init|=
operator|new
name|String
index|[]
block|{
literal|"/dir1"
block|,
literal|"/dir1/dir2"
block|,
literal|"/dir1/dir3"
block|,
literal|"/dir1/dir2/file1"
block|,
literal|"/dir1/dir2/file2"
block|,
literal|"/dir1/dir3/dir4"
block|,
literal|"/dir1/dir3/dir5"
block|,
literal|"/dir1/dir3/dir4/file3"
block|,
literal|"/dir1/dir3/dir5/file4"
block|,
literal|"/dir1/dir3/dir6"
block|}
decl_stmt|;
specifier|final
name|String
index|[]
name|leafNodes
init|=
operator|new
name|String
index|[]
block|{
literal|"/dir1/dir2/file1"
block|,
literal|"/dir1/dir2/file2"
block|,
literal|"/dir1/dir3/dir4/file3"
block|,
literal|"/dir1/dir3/dir5/file4"
block|}
decl_stmt|;
name|doTestDescendantsIterator
argument_list|(
name|MetadataStoreListFilesIterator
operator|.
name|class
argument_list|,
name|wholeTree
argument_list|,
name|leafNodes
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testPutNew ()
specifier|public
name|void
name|testPutNew
parameter_list|()
throws|throws
name|Exception
block|{
comment|/* create three dirs /da1, /da2, /da3 */
name|createNewDirs
argument_list|(
literal|"/da1"
argument_list|,
literal|"/da2"
argument_list|,
literal|"/da3"
argument_list|)
expr_stmt|;
comment|/* It is caller's responsibility to set up ancestor entries beyond the      * containing directory.  We only track direct children of the directory.      * Thus this will not affect entry for /da1.      */
name|ms
operator|.
name|put
argument_list|(
operator|new
name|PathMetadata
argument_list|(
name|makeFileStatus
argument_list|(
literal|"/da1/db1/fc1"
argument_list|,
literal|100
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertEmptyDirs
argument_list|(
literal|"/da2"
argument_list|,
literal|"/da3"
argument_list|)
expr_stmt|;
name|assertDirectorySize
argument_list|(
literal|"/da1/db1"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Check contents of dir status. */
name|PathMetadata
name|dirMeta
init|=
name|ms
operator|.
name|get
argument_list|(
name|strToPath
argument_list|(
literal|"/da1"
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|allowMissing
argument_list|()
operator|||
name|dirMeta
operator|!=
literal|null
condition|)
block|{
name|verifyDirStatus
argument_list|(
name|dirMeta
operator|.
name|getFileStatus
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/* This already exists, and should silently replace it. */
name|ms
operator|.
name|put
argument_list|(
operator|new
name|PathMetadata
argument_list|(
name|makeDirStatus
argument_list|(
literal|"/da1/db1"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we had putNew(), and used it above, this would be empty again. */
name|assertDirectorySize
argument_list|(
literal|"/da1"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|assertEmptyDirs
argument_list|(
literal|"/da2"
argument_list|,
literal|"/da3"
argument_list|)
expr_stmt|;
comment|/* Ensure new files update correct parent dirs. */
name|ms
operator|.
name|put
argument_list|(
operator|new
name|PathMetadata
argument_list|(
name|makeFileStatus
argument_list|(
literal|"/da1/db1/fc1"
argument_list|,
literal|100
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ms
operator|.
name|put
argument_list|(
operator|new
name|PathMetadata
argument_list|(
name|makeFileStatus
argument_list|(
literal|"/da1/db1/fc2"
argument_list|,
literal|200
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertDirectorySize
argument_list|(
literal|"/da1"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|assertDirectorySize
argument_list|(
literal|"/da1/db1"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|assertEmptyDirs
argument_list|(
literal|"/da2"
argument_list|,
literal|"/da3"
argument_list|)
expr_stmt|;
name|PathMetadata
name|meta
init|=
name|ms
operator|.
name|get
argument_list|(
name|strToPath
argument_list|(
literal|"/da1/db1/fc2"
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|allowMissing
argument_list|()
operator|||
name|meta
operator|!=
literal|null
condition|)
block|{
name|assertNotNull
argument_list|(
literal|"Get file after put new."
argument_list|,
name|meta
argument_list|)
expr_stmt|;
name|verifyFileStatus
argument_list|(
name|meta
operator|.
name|getFileStatus
argument_list|()
argument_list|,
literal|200
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Test
DECL|method|testPutOverwrite ()
specifier|public
name|void
name|testPutOverwrite
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|String
name|filePath
init|=
literal|"/a1/b1/c1/some_file"
decl_stmt|;
specifier|final
name|String
name|dirPath
init|=
literal|"/a1/b1/c1/d1"
decl_stmt|;
name|ms
operator|.
name|put
argument_list|(
operator|new
name|PathMetadata
argument_list|(
name|makeFileStatus
argument_list|(
name|filePath
argument_list|,
literal|100
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ms
operator|.
name|put
argument_list|(
operator|new
name|PathMetadata
argument_list|(
name|makeDirStatus
argument_list|(
name|dirPath
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|PathMetadata
name|meta
init|=
name|ms
operator|.
name|get
argument_list|(
name|strToPath
argument_list|(
name|filePath
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|allowMissing
argument_list|()
operator|||
name|meta
operator|!=
literal|null
condition|)
block|{
name|verifyFileStatus
argument_list|(
name|meta
operator|.
name|getFileStatus
argument_list|()
argument_list|,
literal|100
argument_list|)
expr_stmt|;
block|}
name|ms
operator|.
name|put
argument_list|(
operator|new
name|PathMetadata
argument_list|(
name|basicFileStatus
argument_list|(
name|strToPath
argument_list|(
name|filePath
argument_list|)
argument_list|,
literal|9999
argument_list|,
literal|false
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|meta
operator|=
name|ms
operator|.
name|get
argument_list|(
name|strToPath
argument_list|(
name|filePath
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|allowMissing
argument_list|()
operator|||
name|meta
operator|!=
literal|null
condition|)
block|{
name|verifyFileStatus
argument_list|(
name|meta
operator|.
name|getFileStatus
argument_list|()
argument_list|,
literal|9999
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Test
DECL|method|testRootDirPutNew ()
specifier|public
name|void
name|testRootDirPutNew
parameter_list|()
throws|throws
name|Exception
block|{
name|Path
name|rootPath
init|=
name|strToPath
argument_list|(
literal|"/"
argument_list|)
decl_stmt|;
name|ms
operator|.
name|put
argument_list|(
operator|new
name|PathMetadata
argument_list|(
name|makeFileStatus
argument_list|(
literal|"/file1"
argument_list|,
literal|100
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|DirListingMetadata
name|dir
init|=
name|ms
operator|.
name|listChildren
argument_list|(
name|rootPath
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|allowMissing
argument_list|()
operator|||
name|dir
operator|!=
literal|null
condition|)
block|{
name|assertNotNull
argument_list|(
literal|"Root dir cached"
argument_list|,
name|dir
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
literal|"Root not fully cached"
argument_list|,
name|dir
operator|.
name|isAuthoritative
argument_list|()
argument_list|)
expr_stmt|;
name|assertNotNull
argument_list|(
literal|"have root dir file listing"
argument_list|,
name|dir
operator|.
name|getListing
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"One file in root dir"
argument_list|,
literal|1
argument_list|,
name|dir
operator|.
name|getListing
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"file1 in root dir"
argument_list|,
name|strToPath
argument_list|(
literal|"/file1"
argument_list|)
argument_list|,
name|dir
operator|.
name|getListing
argument_list|()
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
operator|.
name|getFileStatus
argument_list|()
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Test
DECL|method|testDelete ()
specifier|public
name|void
name|testDelete
parameter_list|()
throws|throws
name|Exception
block|{
name|setUpDeleteTest
argument_list|()
expr_stmt|;
name|ms
operator|.
name|delete
argument_list|(
name|strToPath
argument_list|(
literal|"/ADirectory1/db1/file2"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Ensure delete happened. */
name|assertDirectorySize
argument_list|(
literal|"/ADirectory1/db1"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|PathMetadata
name|meta
init|=
name|ms
operator|.
name|get
argument_list|(
name|strToPath
argument_list|(
literal|"/ADirectory1/db1/file2"
argument_list|)
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
literal|"File deleted"
argument_list|,
name|meta
operator|==
literal|null
operator|||
name|meta
operator|.
name|isDeleted
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testDeleteSubtree ()
specifier|public
name|void
name|testDeleteSubtree
parameter_list|()
throws|throws
name|Exception
block|{
name|deleteSubtreeHelper
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testDeleteSubtreeHostPath ()
specifier|public
name|void
name|testDeleteSubtreeHostPath
parameter_list|()
throws|throws
name|Exception
block|{
name|deleteSubtreeHelper
argument_list|(
name|contract
operator|.
name|getFileSystem
argument_list|()
operator|.
name|getUri
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|deleteSubtreeHelper (String pathPrefix)
specifier|private
name|void
name|deleteSubtreeHelper
parameter_list|(
name|String
name|pathPrefix
parameter_list|)
throws|throws
name|Exception
block|{
name|String
name|p
init|=
name|pathPrefix
decl_stmt|;
name|setUpDeleteTest
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|createNewDirs
argument_list|(
name|p
operator|+
literal|"/ADirectory1/db1/dc1"
argument_list|,
name|p
operator|+
literal|"/ADirectory1/db1/dc1/dd1"
argument_list|)
expr_stmt|;
name|ms
operator|.
name|put
argument_list|(
operator|new
name|PathMetadata
argument_list|(
name|makeFileStatus
argument_list|(
name|p
operator|+
literal|"/ADirectory1/db1/dc1/dd1/deepFile"
argument_list|,
literal|100
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|allowMissing
argument_list|()
condition|)
block|{
name|assertCached
argument_list|(
name|p
operator|+
literal|"/ADirectory1/db1"
argument_list|)
expr_stmt|;
block|}
name|ms
operator|.
name|deleteSubtree
argument_list|(
name|strToPath
argument_list|(
name|p
operator|+
literal|"/ADirectory1/db1/"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEmptyDirectory
argument_list|(
name|p
operator|+
literal|"/ADirectory1"
argument_list|)
expr_stmt|;
name|assertDeleted
argument_list|(
name|p
operator|+
literal|"/ADirectory1/db1"
argument_list|)
expr_stmt|;
name|assertDeleted
argument_list|(
name|p
operator|+
literal|"/ADirectory1/file1"
argument_list|)
expr_stmt|;
name|assertDeleted
argument_list|(
name|p
operator|+
literal|"/ADirectory1/file2"
argument_list|)
expr_stmt|;
name|assertDeleted
argument_list|(
name|p
operator|+
literal|"/ADirectory1/db1/dc1/dd1/deepFile"
argument_list|)
expr_stmt|;
name|assertEmptyDirectory
argument_list|(
name|p
operator|+
literal|"/ADirectory2"
argument_list|)
expr_stmt|;
block|}
comment|/*    * Some implementations might not support this.  It was useful to test    * correctness of the LocalMetadataStore implementation, but feel free to    * override this to be a no-op.    */
annotation|@
name|Test
DECL|method|testDeleteRecursiveRoot ()
specifier|public
name|void
name|testDeleteRecursiveRoot
parameter_list|()
throws|throws
name|Exception
block|{
name|setUpDeleteTest
argument_list|()
expr_stmt|;
name|ms
operator|.
name|deleteSubtree
argument_list|(
name|strToPath
argument_list|(
literal|"/"
argument_list|)
argument_list|)
expr_stmt|;
name|assertDeleted
argument_list|(
literal|"/ADirectory1"
argument_list|)
expr_stmt|;
name|assertDeleted
argument_list|(
literal|"/ADirectory2"
argument_list|)
expr_stmt|;
name|assertDeleted
argument_list|(
literal|"/ADirectory2/db1"
argument_list|)
expr_stmt|;
name|assertDeleted
argument_list|(
literal|"/ADirectory2/db1/file1"
argument_list|)
expr_stmt|;
name|assertDeleted
argument_list|(
literal|"/ADirectory2/db1/file2"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testDeleteNonExisting ()
specifier|public
name|void
name|testDeleteNonExisting
parameter_list|()
throws|throws
name|Exception
block|{
comment|// Path doesn't exist, but should silently succeed
name|ms
operator|.
name|delete
argument_list|(
name|strToPath
argument_list|(
literal|"/bobs/your/uncle"
argument_list|)
argument_list|)
expr_stmt|;
comment|// Ditto.
name|ms
operator|.
name|deleteSubtree
argument_list|(
name|strToPath
argument_list|(
literal|"/internets"
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|setUpDeleteTest ()
specifier|private
name|void
name|setUpDeleteTest
parameter_list|()
throws|throws
name|IOException
block|{
name|setUpDeleteTest
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
DECL|method|setUpDeleteTest (String prefix)
specifier|private
name|void
name|setUpDeleteTest
parameter_list|(
name|String
name|prefix
parameter_list|)
throws|throws
name|IOException
block|{
name|createNewDirs
argument_list|(
name|prefix
operator|+
literal|"/ADirectory1"
argument_list|,
name|prefix
operator|+
literal|"/ADirectory2"
argument_list|,
name|prefix
operator|+
literal|"/ADirectory1/db1"
argument_list|)
expr_stmt|;
name|ms
operator|.
name|put
argument_list|(
operator|new
name|PathMetadata
argument_list|(
name|makeFileStatus
argument_list|(
name|prefix
operator|+
literal|"/ADirectory1/db1/file1"
argument_list|,
literal|100
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ms
operator|.
name|put
argument_list|(
operator|new
name|PathMetadata
argument_list|(
name|makeFileStatus
argument_list|(
name|prefix
operator|+
literal|"/ADirectory1/db1/file2"
argument_list|,
literal|100
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|PathMetadata
name|meta
init|=
name|ms
operator|.
name|get
argument_list|(
name|strToPath
argument_list|(
name|prefix
operator|+
literal|"/ADirectory1/db1/file2"
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|allowMissing
argument_list|()
operator|||
name|meta
operator|!=
literal|null
condition|)
block|{
name|assertNotNull
argument_list|(
literal|"Found test file"
argument_list|,
name|meta
argument_list|)
expr_stmt|;
name|assertDirectorySize
argument_list|(
name|prefix
operator|+
literal|"/ADirectory1/db1"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Test
DECL|method|testGet ()
specifier|public
name|void
name|testGet
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|String
name|filePath
init|=
literal|"/a1/b1/c1/some_file"
decl_stmt|;
specifier|final
name|String
name|dirPath
init|=
literal|"/a1/b1/c1/d1"
decl_stmt|;
name|ms
operator|.
name|put
argument_list|(
operator|new
name|PathMetadata
argument_list|(
name|makeFileStatus
argument_list|(
name|filePath
argument_list|,
literal|100
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ms
operator|.
name|put
argument_list|(
operator|new
name|PathMetadata
argument_list|(
name|makeDirStatus
argument_list|(
name|dirPath
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|PathMetadata
name|meta
init|=
name|ms
operator|.
name|get
argument_list|(
name|strToPath
argument_list|(
name|filePath
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|allowMissing
argument_list|()
operator|||
name|meta
operator|!=
literal|null
condition|)
block|{
name|assertNotNull
argument_list|(
literal|"Get found file"
argument_list|,
name|meta
argument_list|)
expr_stmt|;
name|verifyFileStatus
argument_list|(
name|meta
operator|.
name|getFileStatus
argument_list|()
argument_list|,
literal|100
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|ms
operator|instanceof
name|NullMetadataStore
operator|)
condition|)
block|{
name|ms
operator|.
name|delete
argument_list|(
name|strToPath
argument_list|(
name|filePath
argument_list|)
argument_list|)
expr_stmt|;
name|meta
operator|=
name|ms
operator|.
name|get
argument_list|(
name|strToPath
argument_list|(
name|filePath
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"Tombstone not left for deleted file"
argument_list|,
name|meta
operator|.
name|isDeleted
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|meta
operator|=
name|ms
operator|.
name|get
argument_list|(
name|strToPath
argument_list|(
name|dirPath
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|allowMissing
argument_list|()
operator|||
name|meta
operator|!=
literal|null
condition|)
block|{
name|assertNotNull
argument_list|(
literal|"Get found file (dir)"
argument_list|,
name|meta
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"Found dir"
argument_list|,
name|meta
operator|.
name|getFileStatus
argument_list|()
operator|.
name|isDirectory
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|meta
operator|=
name|ms
operator|.
name|get
argument_list|(
name|strToPath
argument_list|(
literal|"/bollocks"
argument_list|)
argument_list|)
expr_stmt|;
name|assertNull
argument_list|(
literal|"Don't get non-existent file"
argument_list|,
name|meta
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testGetEmptyDir ()
specifier|public
name|void
name|testGetEmptyDir
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|String
name|dirPath
init|=
literal|"/a1/b1/c1/d1"
decl_stmt|;
comment|// Creates /a1/b1/c1/d1 as an empty dir
name|setupListStatus
argument_list|()
expr_stmt|;
comment|// 1. Tell MetadataStore (MS) that there are zero children
name|putListStatusFiles
argument_list|(
name|dirPath
argument_list|,
literal|true
comment|/* authoritative */
comment|/* zero children */
argument_list|)
expr_stmt|;
comment|// 2. Request a file status for dir, including whether or not the dir
comment|// is empty.
name|PathMetadata
name|meta
init|=
name|ms
operator|.
name|get
argument_list|(
name|strToPath
argument_list|(
name|dirPath
argument_list|)
argument_list|,
literal|true
argument_list|)
decl_stmt|;
comment|// 3. Check that either (a) the MS doesn't track whether or not it is
comment|// empty (which is allowed), or (b) the MS knows the dir is empty.
if|if
condition|(
operator|!
name|allowMissing
argument_list|()
operator|||
name|meta
operator|!=
literal|null
condition|)
block|{
name|assertNotNull
argument_list|(
literal|"Get should find meta for dir"
argument_list|,
name|meta
argument_list|)
expr_stmt|;
name|assertNotEquals
argument_list|(
literal|"Dir is empty or unknown"
argument_list|,
name|Tristate
operator|.
name|FALSE
argument_list|,
name|meta
operator|.
name|isEmptyDirectory
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Test
DECL|method|testGetNonEmptyDir ()
specifier|public
name|void
name|testGetNonEmptyDir
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|String
name|dirPath
init|=
literal|"/a1/b1/c1"
decl_stmt|;
comment|// Creates /a1/b1/c1 as an non-empty dir
name|setupListStatus
argument_list|()
expr_stmt|;
comment|// Request a file status for dir, including whether or not the dir
comment|// is empty.
name|PathMetadata
name|meta
init|=
name|ms
operator|.
name|get
argument_list|(
name|strToPath
argument_list|(
name|dirPath
argument_list|)
argument_list|,
literal|true
argument_list|)
decl_stmt|;
comment|// MetadataStore knows /a1/b1/c1 has at least one child.  It is valid
comment|// for it to answer either (a) UNKNOWN: the MS doesn't track whether
comment|// or not the dir is empty, or (b) the MS knows the dir is non-empty.
if|if
condition|(
operator|!
name|allowMissing
argument_list|()
operator|||
name|meta
operator|!=
literal|null
condition|)
block|{
name|assertNotNull
argument_list|(
literal|"Get should find meta for dir"
argument_list|,
name|meta
argument_list|)
expr_stmt|;
name|assertNotEquals
argument_list|(
literal|"Dir is non-empty or unknown"
argument_list|,
name|Tristate
operator|.
name|TRUE
argument_list|,
name|meta
operator|.
name|isEmptyDirectory
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Test
DECL|method|testGetDirUnknownIfEmpty ()
specifier|public
name|void
name|testGetDirUnknownIfEmpty
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|String
name|dirPath
init|=
literal|"/a1/b1/c1/d1"
decl_stmt|;
comment|// 1. Create /a1/b1/c1/d1 as an empty dir, but do not tell MetadataStore
comment|// (MS) whether or not it has any children.
name|setupListStatus
argument_list|()
expr_stmt|;
comment|// 2. Request a file status for dir, including whether or not the dir
comment|// is empty.
name|PathMetadata
name|meta
init|=
name|ms
operator|.
name|get
argument_list|(
name|strToPath
argument_list|(
name|dirPath
argument_list|)
argument_list|,
literal|true
argument_list|)
decl_stmt|;
comment|// 3. Assert MS reports isEmptyDir as UNKONWN: We haven't told MS
comment|// whether or not the directory has any children.
if|if
condition|(
operator|!
name|allowMissing
argument_list|()
operator|||
name|meta
operator|!=
literal|null
condition|)
block|{
name|assertNotNull
argument_list|(
literal|"Get should find meta for dir"
argument_list|,
name|meta
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Dir empty is unknown"
argument_list|,
name|Tristate
operator|.
name|UNKNOWN
argument_list|,
name|meta
operator|.
name|isEmptyDirectory
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Test
DECL|method|testListChildren ()
specifier|public
name|void
name|testListChildren
parameter_list|()
throws|throws
name|Exception
block|{
name|setupListStatus
argument_list|()
expr_stmt|;
name|DirListingMetadata
name|dirMeta
decl_stmt|;
name|dirMeta
operator|=
name|ms
operator|.
name|listChildren
argument_list|(
name|strToPath
argument_list|(
literal|"/"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|allowMissing
argument_list|()
condition|)
block|{
name|assertNotNull
argument_list|(
name|dirMeta
argument_list|)
expr_stmt|;
comment|/* Cache has no way of knowing it has all entries for root unless we          * specifically tell it via put() with          * DirListingMetadata.isAuthoritative = true */
name|assertFalse
argument_list|(
literal|"Root dir is not cached, or partially cached"
argument_list|,
name|dirMeta
operator|.
name|isAuthoritative
argument_list|()
argument_list|)
expr_stmt|;
name|assertListingsEqual
argument_list|(
name|dirMeta
operator|.
name|getListing
argument_list|()
argument_list|,
literal|"/a1"
argument_list|,
literal|"/a2"
argument_list|)
expr_stmt|;
block|}
name|dirMeta
operator|=
name|ms
operator|.
name|listChildren
argument_list|(
name|strToPath
argument_list|(
literal|"/a1"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|allowMissing
argument_list|()
operator|||
name|dirMeta
operator|!=
literal|null
condition|)
block|{
name|dirMeta
operator|=
name|dirMeta
operator|.
name|withoutTombstones
argument_list|()
expr_stmt|;
name|assertListingsEqual
argument_list|(
name|dirMeta
operator|.
name|getListing
argument_list|()
argument_list|,
literal|"/a1/b1"
argument_list|,
literal|"/a1/b2"
argument_list|)
expr_stmt|;
block|}
name|dirMeta
operator|=
name|ms
operator|.
name|listChildren
argument_list|(
name|strToPath
argument_list|(
literal|"/a1/b1"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|allowMissing
argument_list|()
operator|||
name|dirMeta
operator|!=
literal|null
condition|)
block|{
name|assertListingsEqual
argument_list|(
name|dirMeta
operator|.
name|getListing
argument_list|()
argument_list|,
literal|"/a1/b1/file1"
argument_list|,
literal|"/a1/b1/file2"
argument_list|,
literal|"/a1/b1/c1"
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|isMetadataStoreAuthoritative ()
specifier|private
name|boolean
name|isMetadataStoreAuthoritative
parameter_list|()
throws|throws
name|IOException
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|diags
init|=
name|ms
operator|.
name|getDiagnostics
argument_list|()
decl_stmt|;
name|String
name|isAuth
init|=
name|diags
operator|.
name|get
argument_list|(
name|MetadataStoreCapabilities
operator|.
name|PERSISTS_AUTHORITATIVE_BIT
argument_list|)
decl_stmt|;
if|if
condition|(
name|isAuth
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
name|Boolean
operator|.
name|valueOf
argument_list|(
name|isAuth
argument_list|)
return|;
block|}
annotation|@
name|Test
DECL|method|testListChildrenAuthoritative ()
specifier|public
name|void
name|testListChildrenAuthoritative
parameter_list|()
throws|throws
name|IOException
block|{
name|Assume
operator|.
name|assumeTrue
argument_list|(
literal|"MetadataStore should be capable for authoritative "
operator|+
literal|"storage of directories to run this test."
argument_list|,
name|isMetadataStoreAuthoritative
argument_list|()
argument_list|)
expr_stmt|;
name|setupListStatus
argument_list|()
expr_stmt|;
name|DirListingMetadata
name|dirMeta
init|=
name|ms
operator|.
name|listChildren
argument_list|(
name|strToPath
argument_list|(
literal|"/a1/b1"
argument_list|)
argument_list|)
decl_stmt|;
name|dirMeta
operator|.
name|setAuthoritative
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|dirMeta
operator|.
name|put
argument_list|(
name|makeFileStatus
argument_list|(
literal|"/a1/b1/file_new"
argument_list|,
literal|100
argument_list|)
argument_list|)
expr_stmt|;
name|ms
operator|.
name|put
argument_list|(
name|dirMeta
argument_list|)
expr_stmt|;
name|dirMeta
operator|=
name|ms
operator|.
name|listChildren
argument_list|(
name|strToPath
argument_list|(
literal|"/a1/b1"
argument_list|)
argument_list|)
expr_stmt|;
name|assertListingsEqual
argument_list|(
name|dirMeta
operator|.
name|getListing
argument_list|()
argument_list|,
literal|"/a1/b1/file1"
argument_list|,
literal|"/a1/b1/file2"
argument_list|,
literal|"/a1/b1/c1"
argument_list|,
literal|"/a1/b1/file_new"
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|dirMeta
operator|.
name|isAuthoritative
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testDirListingRoot ()
specifier|public
name|void
name|testDirListingRoot
parameter_list|()
throws|throws
name|Exception
block|{
name|commonTestPutListStatus
argument_list|(
literal|"/"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testPutDirListing ()
specifier|public
name|void
name|testPutDirListing
parameter_list|()
throws|throws
name|Exception
block|{
name|commonTestPutListStatus
argument_list|(
literal|"/a"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testInvalidListChildren ()
specifier|public
name|void
name|testInvalidListChildren
parameter_list|()
throws|throws
name|Exception
block|{
name|setupListStatus
argument_list|()
expr_stmt|;
name|assertNull
argument_list|(
literal|"missing path returns null"
argument_list|,
name|ms
operator|.
name|listChildren
argument_list|(
name|strToPath
argument_list|(
literal|"/a1/b1x"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testMove ()
specifier|public
name|void
name|testMove
parameter_list|()
throws|throws
name|Exception
block|{
comment|// Create test dir structure
name|createNewDirs
argument_list|(
literal|"/a1"
argument_list|,
literal|"/a2"
argument_list|,
literal|"/a3"
argument_list|)
expr_stmt|;
name|createNewDirs
argument_list|(
literal|"/a1/b1"
argument_list|,
literal|"/a1/b2"
argument_list|)
expr_stmt|;
name|putListStatusFiles
argument_list|(
literal|"/a1/b1"
argument_list|,
literal|false
argument_list|,
literal|"/a1/b1/file1"
argument_list|,
literal|"/a1/b1/file2"
argument_list|)
expr_stmt|;
comment|// Assert root listing as expected
name|Collection
argument_list|<
name|PathMetadata
argument_list|>
name|entries
decl_stmt|;
name|DirListingMetadata
name|dirMeta
init|=
name|ms
operator|.
name|listChildren
argument_list|(
name|strToPath
argument_list|(
literal|"/"
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|allowMissing
argument_list|()
operator|||
name|dirMeta
operator|!=
literal|null
condition|)
block|{
name|dirMeta
operator|=
name|dirMeta
operator|.
name|withoutTombstones
argument_list|()
expr_stmt|;
name|assertNotNull
argument_list|(
literal|"Listing root"
argument_list|,
name|dirMeta
argument_list|)
expr_stmt|;
name|entries
operator|=
name|dirMeta
operator|.
name|getListing
argument_list|()
expr_stmt|;
name|assertListingsEqual
argument_list|(
name|entries
argument_list|,
literal|"/a1"
argument_list|,
literal|"/a2"
argument_list|,
literal|"/a3"
argument_list|)
expr_stmt|;
block|}
comment|// Assert src listing as expected
name|dirMeta
operator|=
name|ms
operator|.
name|listChildren
argument_list|(
name|strToPath
argument_list|(
literal|"/a1/b1"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|allowMissing
argument_list|()
operator|||
name|dirMeta
operator|!=
literal|null
condition|)
block|{
name|assertNotNull
argument_list|(
literal|"Listing /a1/b1"
argument_list|,
name|dirMeta
argument_list|)
expr_stmt|;
name|entries
operator|=
name|dirMeta
operator|.
name|getListing
argument_list|()
expr_stmt|;
name|assertListingsEqual
argument_list|(
name|entries
argument_list|,
literal|"/a1/b1/file1"
argument_list|,
literal|"/a1/b1/file2"
argument_list|)
expr_stmt|;
block|}
comment|// Do the move(): rename(/a1/b1, /b1)
name|Collection
argument_list|<
name|Path
argument_list|>
name|srcPaths
init|=
name|Arrays
operator|.
name|asList
argument_list|(
name|strToPath
argument_list|(
literal|"/a1/b1"
argument_list|)
argument_list|,
name|strToPath
argument_list|(
literal|"/a1/b1/file1"
argument_list|)
argument_list|,
name|strToPath
argument_list|(
literal|"/a1/b1/file2"
argument_list|)
argument_list|)
decl_stmt|;
name|ArrayList
argument_list|<
name|PathMetadata
argument_list|>
name|destMetas
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|destMetas
operator|.
name|add
argument_list|(
operator|new
name|PathMetadata
argument_list|(
name|makeDirStatus
argument_list|(
literal|"/b1"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|destMetas
operator|.
name|add
argument_list|(
operator|new
name|PathMetadata
argument_list|(
name|makeFileStatus
argument_list|(
literal|"/b1/file1"
argument_list|,
literal|100
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|destMetas
operator|.
name|add
argument_list|(
operator|new
name|PathMetadata
argument_list|(
name|makeFileStatus
argument_list|(
literal|"/b1/file2"
argument_list|,
literal|100
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ms
operator|.
name|move
argument_list|(
name|srcPaths
argument_list|,
name|destMetas
argument_list|)
expr_stmt|;
comment|// Assert src is no longer there
name|dirMeta
operator|=
name|ms
operator|.
name|listChildren
argument_list|(
name|strToPath
argument_list|(
literal|"/a1"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|allowMissing
argument_list|()
operator|||
name|dirMeta
operator|!=
literal|null
condition|)
block|{
name|assertNotNull
argument_list|(
literal|"Listing /a1"
argument_list|,
name|dirMeta
argument_list|)
expr_stmt|;
name|entries
operator|=
name|dirMeta
operator|.
name|withoutTombstones
argument_list|()
operator|.
name|getListing
argument_list|()
expr_stmt|;
name|assertListingsEqual
argument_list|(
name|entries
argument_list|,
literal|"/a1/b2"
argument_list|)
expr_stmt|;
block|}
name|PathMetadata
name|meta
init|=
name|ms
operator|.
name|get
argument_list|(
name|strToPath
argument_list|(
literal|"/a1/b1/file1"
argument_list|)
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
literal|"Src path deleted"
argument_list|,
name|meta
operator|==
literal|null
operator|||
name|meta
operator|.
name|isDeleted
argument_list|()
argument_list|)
expr_stmt|;
comment|// Assert dest looks right
name|meta
operator|=
name|ms
operator|.
name|get
argument_list|(
name|strToPath
argument_list|(
literal|"/b1/file1"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|allowMissing
argument_list|()
operator|||
name|meta
operator|!=
literal|null
condition|)
block|{
name|assertNotNull
argument_list|(
literal|"dest file not null"
argument_list|,
name|meta
argument_list|)
expr_stmt|;
name|verifyFileStatus
argument_list|(
name|meta
operator|.
name|getFileStatus
argument_list|()
argument_list|,
literal|100
argument_list|)
expr_stmt|;
block|}
name|dirMeta
operator|=
name|ms
operator|.
name|listChildren
argument_list|(
name|strToPath
argument_list|(
literal|"/b1"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|allowMissing
argument_list|()
operator|||
name|dirMeta
operator|!=
literal|null
condition|)
block|{
name|assertNotNull
argument_list|(
literal|"dest listing not null"
argument_list|,
name|dirMeta
argument_list|)
expr_stmt|;
name|entries
operator|=
name|dirMeta
operator|.
name|getListing
argument_list|()
expr_stmt|;
name|assertListingsEqual
argument_list|(
name|entries
argument_list|,
literal|"/b1/file1"
argument_list|,
literal|"/b1/file2"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Test that the MetadataStore differentiates between the same path in two    * different buckets.    */
annotation|@
name|Test
DECL|method|testMultiBucketPaths ()
specifier|public
name|void
name|testMultiBucketPaths
parameter_list|()
throws|throws
name|Exception
block|{
name|String
name|p1
init|=
literal|"s3a://bucket-a/path1"
decl_stmt|;
name|String
name|p2
init|=
literal|"s3a://bucket-b/path2"
decl_stmt|;
comment|// Make sure we start out empty
name|PathMetadata
name|meta
init|=
name|ms
operator|.
name|get
argument_list|(
operator|new
name|Path
argument_list|(
name|p1
argument_list|)
argument_list|)
decl_stmt|;
name|assertNull
argument_list|(
literal|"Path should not be present yet."
argument_list|,
name|meta
argument_list|)
expr_stmt|;
name|meta
operator|=
name|ms
operator|.
name|get
argument_list|(
operator|new
name|Path
argument_list|(
name|p2
argument_list|)
argument_list|)
expr_stmt|;
name|assertNull
argument_list|(
literal|"Path2 should not be present yet."
argument_list|,
name|meta
argument_list|)
expr_stmt|;
comment|// Put p1, assert p2 doesn't match
name|ms
operator|.
name|put
argument_list|(
operator|new
name|PathMetadata
argument_list|(
name|makeFileStatus
argument_list|(
name|p1
argument_list|,
literal|100
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|meta
operator|=
name|ms
operator|.
name|get
argument_list|(
operator|new
name|Path
argument_list|(
name|p2
argument_list|)
argument_list|)
expr_stmt|;
name|assertNull
argument_list|(
literal|"Path 2 should not match path 1."
argument_list|,
name|meta
argument_list|)
expr_stmt|;
comment|// Make sure delete is correct as well
if|if
condition|(
operator|!
name|allowMissing
argument_list|()
condition|)
block|{
name|ms
operator|.
name|delete
argument_list|(
operator|new
name|Path
argument_list|(
name|p2
argument_list|)
argument_list|)
expr_stmt|;
name|meta
operator|=
name|ms
operator|.
name|get
argument_list|(
operator|new
name|Path
argument_list|(
name|p1
argument_list|)
argument_list|)
expr_stmt|;
name|assertNotNull
argument_list|(
literal|"Path should not have been deleted"
argument_list|,
name|meta
argument_list|)
expr_stmt|;
block|}
name|ms
operator|.
name|delete
argument_list|(
operator|new
name|Path
argument_list|(
name|p1
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testPruneFiles ()
specifier|public
name|void
name|testPruneFiles
parameter_list|()
throws|throws
name|Exception
block|{
name|Assume
operator|.
name|assumeTrue
argument_list|(
name|supportsPruning
argument_list|()
argument_list|)
expr_stmt|;
name|createNewDirs
argument_list|(
literal|"/pruneFiles"
argument_list|)
expr_stmt|;
name|long
name|oldTime
init|=
name|getTime
argument_list|()
decl_stmt|;
name|ms
operator|.
name|put
argument_list|(
operator|new
name|PathMetadata
argument_list|(
name|makeFileStatus
argument_list|(
literal|"/pruneFiles/old"
argument_list|,
literal|1
argument_list|,
name|oldTime
argument_list|,
name|oldTime
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|DirListingMetadata
name|ls2
init|=
name|ms
operator|.
name|listChildren
argument_list|(
name|strToPath
argument_list|(
literal|"/pruneFiles"
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|allowMissing
argument_list|()
condition|)
block|{
name|assertListingsEqual
argument_list|(
name|ls2
operator|.
name|getListing
argument_list|()
argument_list|,
literal|"/pruneFiles/old"
argument_list|)
expr_stmt|;
block|}
comment|// It's possible for the Local implementation to get from /pruneFiles/old's
comment|// modification time to here in under 1ms, causing it to not get pruned
name|Thread
operator|.
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|long
name|cutoff
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|long
name|newTime
init|=
name|getTime
argument_list|()
decl_stmt|;
name|ms
operator|.
name|put
argument_list|(
operator|new
name|PathMetadata
argument_list|(
name|makeFileStatus
argument_list|(
literal|"/pruneFiles/new"
argument_list|,
literal|1
argument_list|,
name|newTime
argument_list|,
name|newTime
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|DirListingMetadata
name|ls
decl_stmt|;
name|ls
operator|=
name|ms
operator|.
name|listChildren
argument_list|(
name|strToPath
argument_list|(
literal|"/pruneFiles"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|allowMissing
argument_list|()
condition|)
block|{
name|assertListingsEqual
argument_list|(
name|ls
operator|.
name|getListing
argument_list|()
argument_list|,
literal|"/pruneFiles/new"
argument_list|,
literal|"/pruneFiles/old"
argument_list|)
expr_stmt|;
block|}
name|ms
operator|.
name|prune
argument_list|(
name|cutoff
argument_list|)
expr_stmt|;
name|ls
operator|=
name|ms
operator|.
name|listChildren
argument_list|(
name|strToPath
argument_list|(
literal|"/pruneFiles"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|allowMissing
argument_list|()
condition|)
block|{
name|assertDeleted
argument_list|(
literal|"/pruneFiles/old"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|assertListingsEqual
argument_list|(
name|ls
operator|.
name|getListing
argument_list|()
argument_list|,
literal|"/pruneFiles/new"
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Test
DECL|method|testPruneDirs ()
specifier|public
name|void
name|testPruneDirs
parameter_list|()
throws|throws
name|Exception
block|{
name|Assume
operator|.
name|assumeTrue
argument_list|(
name|supportsPruning
argument_list|()
argument_list|)
expr_stmt|;
comment|// We only test that files, not dirs, are removed during prune.
comment|// We specifically allow directories to remain, as it is more robust
comment|// for DynamoDBMetadataStore's prune() implementation: If a
comment|// file was created in a directory while it was being pruned, it would
comment|// violate the invariant that all ancestors of a file exist in the table.
name|createNewDirs
argument_list|(
literal|"/pruneDirs/dir"
argument_list|)
expr_stmt|;
name|long
name|oldTime
init|=
name|getTime
argument_list|()
decl_stmt|;
name|ms
operator|.
name|put
argument_list|(
operator|new
name|PathMetadata
argument_list|(
name|makeFileStatus
argument_list|(
literal|"/pruneDirs/dir/file"
argument_list|,
literal|1
argument_list|,
name|oldTime
argument_list|,
name|oldTime
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// It's possible for the Local implementation to get from the old
comment|// modification time to here in under 1ms, causing it to not get pruned
name|Thread
operator|.
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|long
name|cutoff
init|=
name|getTime
argument_list|()
decl_stmt|;
name|ms
operator|.
name|prune
argument_list|(
name|cutoff
argument_list|)
expr_stmt|;
name|assertDeleted
argument_list|(
literal|"/pruneDirs/dir/file"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testPruneUnsetsAuthoritative ()
specifier|public
name|void
name|testPruneUnsetsAuthoritative
parameter_list|()
throws|throws
name|Exception
block|{
name|String
name|rootDir
init|=
literal|"/unpruned-root-dir"
decl_stmt|;
name|String
name|grandparentDir
init|=
name|rootDir
operator|+
literal|"/pruned-grandparent-dir"
decl_stmt|;
name|String
name|parentDir
init|=
name|grandparentDir
operator|+
literal|"/pruned-parent-dir"
decl_stmt|;
name|String
name|staleFile
init|=
name|parentDir
operator|+
literal|"/stale-file"
decl_stmt|;
name|String
name|freshFile
init|=
name|rootDir
operator|+
literal|"/fresh-file"
decl_stmt|;
name|String
index|[]
name|directories
init|=
block|{
name|rootDir
block|,
name|grandparentDir
block|,
name|parentDir
block|}
decl_stmt|;
name|createNewDirs
argument_list|(
name|rootDir
argument_list|,
name|grandparentDir
argument_list|,
name|parentDir
argument_list|)
expr_stmt|;
name|long
name|time
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|ms
operator|.
name|put
argument_list|(
operator|new
name|PathMetadata
argument_list|(
operator|new
name|FileStatus
argument_list|(
literal|0
argument_list|,
literal|false
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|time
operator|-
literal|1
argument_list|,
name|strToPath
argument_list|(
name|staleFile
argument_list|)
argument_list|)
argument_list|,
name|Tristate
operator|.
name|FALSE
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|ms
operator|.
name|put
argument_list|(
operator|new
name|PathMetadata
argument_list|(
operator|new
name|FileStatus
argument_list|(
literal|0
argument_list|,
literal|false
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|time
operator|+
literal|1
argument_list|,
name|strToPath
argument_list|(
name|freshFile
argument_list|)
argument_list|)
argument_list|,
name|Tristate
operator|.
name|FALSE
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|ms
operator|.
name|prune
argument_list|(
name|time
argument_list|)
expr_stmt|;
name|DirListingMetadata
name|listing
decl_stmt|;
for|for
control|(
name|String
name|directory
range|:
name|directories
control|)
block|{
name|Path
name|path
init|=
name|strToPath
argument_list|(
name|directory
argument_list|)
decl_stmt|;
if|if
condition|(
name|ms
operator|.
name|get
argument_list|(
name|path
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|listing
operator|=
name|ms
operator|.
name|listChildren
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|listing
operator|.
name|isAuthoritative
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/*    * Helper functions.    */
comment|/** Modifies paths input array and returns it. */
DECL|method|buildPathStrings (String parent, String... paths)
specifier|private
name|String
index|[]
name|buildPathStrings
parameter_list|(
name|String
name|parent
parameter_list|,
name|String
modifier|...
name|paths
parameter_list|)
throws|throws
name|IOException
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|paths
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|Path
name|p
init|=
operator|new
name|Path
argument_list|(
name|strToPath
argument_list|(
name|parent
argument_list|)
argument_list|,
name|paths
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|paths
index|[
name|i
index|]
operator|=
name|p
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
return|return
name|paths
return|;
block|}
DECL|method|commonTestPutListStatus (final String parent)
specifier|private
name|void
name|commonTestPutListStatus
parameter_list|(
specifier|final
name|String
name|parent
parameter_list|)
throws|throws
name|IOException
block|{
name|putListStatusFiles
argument_list|(
name|parent
argument_list|,
literal|true
argument_list|,
name|buildPathStrings
argument_list|(
name|parent
argument_list|,
literal|"file1"
argument_list|,
literal|"file2"
argument_list|,
literal|"file3"
argument_list|)
argument_list|)
expr_stmt|;
name|DirListingMetadata
name|dirMeta
init|=
name|ms
operator|.
name|listChildren
argument_list|(
name|strToPath
argument_list|(
name|parent
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|allowMissing
argument_list|()
operator|||
name|dirMeta
operator|!=
literal|null
condition|)
block|{
name|dirMeta
operator|=
name|dirMeta
operator|.
name|withoutTombstones
argument_list|()
expr_stmt|;
name|assertNotNull
argument_list|(
literal|"list after putListStatus"
argument_list|,
name|dirMeta
argument_list|)
expr_stmt|;
name|Collection
argument_list|<
name|PathMetadata
argument_list|>
name|entries
init|=
name|dirMeta
operator|.
name|getListing
argument_list|()
decl_stmt|;
name|assertNotNull
argument_list|(
literal|"listStatus has entries"
argument_list|,
name|entries
argument_list|)
expr_stmt|;
name|assertListingsEqual
argument_list|(
name|entries
argument_list|,
name|buildPathStrings
argument_list|(
name|parent
argument_list|,
literal|"file1"
argument_list|,
literal|"file2"
argument_list|,
literal|"file3"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|setupListStatus ()
specifier|private
name|void
name|setupListStatus
parameter_list|()
throws|throws
name|IOException
block|{
name|createNewDirs
argument_list|(
literal|"/a1"
argument_list|,
literal|"/a2"
argument_list|,
literal|"/a1/b1"
argument_list|,
literal|"/a1/b2"
argument_list|,
literal|"/a1/b1/c1"
argument_list|,
literal|"/a1/b1/c1/d1"
argument_list|)
expr_stmt|;
name|ms
operator|.
name|put
argument_list|(
operator|new
name|PathMetadata
argument_list|(
name|makeFileStatus
argument_list|(
literal|"/a1/b1/file1"
argument_list|,
literal|100
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ms
operator|.
name|put
argument_list|(
operator|new
name|PathMetadata
argument_list|(
name|makeFileStatus
argument_list|(
literal|"/a1/b1/file2"
argument_list|,
literal|100
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|assertListingsEqual (Collection<PathMetadata> listing, String ...pathStrs)
specifier|private
name|void
name|assertListingsEqual
parameter_list|(
name|Collection
argument_list|<
name|PathMetadata
argument_list|>
name|listing
parameter_list|,
name|String
modifier|...
name|pathStrs
parameter_list|)
throws|throws
name|IOException
block|{
name|Set
argument_list|<
name|Path
argument_list|>
name|a
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|PathMetadata
name|meta
range|:
name|listing
control|)
block|{
name|a
operator|.
name|add
argument_list|(
name|meta
operator|.
name|getFileStatus
argument_list|()
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|Set
argument_list|<
name|Path
argument_list|>
name|b
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|ps
range|:
name|pathStrs
control|)
block|{
name|b
operator|.
name|add
argument_list|(
name|strToPath
argument_list|(
name|ps
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|assertEquals
argument_list|(
literal|"Same set of files"
argument_list|,
name|b
argument_list|,
name|a
argument_list|)
expr_stmt|;
block|}
DECL|method|putListStatusFiles (String dirPath, boolean authoritative, String... filenames)
specifier|private
name|void
name|putListStatusFiles
parameter_list|(
name|String
name|dirPath
parameter_list|,
name|boolean
name|authoritative
parameter_list|,
name|String
modifier|...
name|filenames
parameter_list|)
throws|throws
name|IOException
block|{
name|ArrayList
argument_list|<
name|PathMetadata
argument_list|>
name|metas
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|filenames
operator|.
name|length
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|filename
range|:
name|filenames
control|)
block|{
name|metas
operator|.
name|add
argument_list|(
operator|new
name|PathMetadata
argument_list|(
name|makeFileStatus
argument_list|(
name|filename
argument_list|,
literal|100
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|DirListingMetadata
name|dirMeta
init|=
operator|new
name|DirListingMetadata
argument_list|(
name|strToPath
argument_list|(
name|dirPath
argument_list|)
argument_list|,
name|metas
argument_list|,
name|authoritative
argument_list|)
decl_stmt|;
name|ms
operator|.
name|put
argument_list|(
name|dirMeta
argument_list|)
expr_stmt|;
block|}
DECL|method|createNewDirs (String... dirs)
specifier|private
name|void
name|createNewDirs
parameter_list|(
name|String
modifier|...
name|dirs
parameter_list|)
throws|throws
name|IOException
block|{
for|for
control|(
name|String
name|pathStr
range|:
name|dirs
control|)
block|{
name|ms
operator|.
name|put
argument_list|(
operator|new
name|PathMetadata
argument_list|(
name|makeDirStatus
argument_list|(
name|pathStr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|assertDirectorySize (String pathStr, int size)
specifier|private
name|void
name|assertDirectorySize
parameter_list|(
name|String
name|pathStr
parameter_list|,
name|int
name|size
parameter_list|)
throws|throws
name|IOException
block|{
name|DirListingMetadata
name|dirMeta
init|=
name|ms
operator|.
name|listChildren
argument_list|(
name|strToPath
argument_list|(
name|pathStr
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|allowMissing
argument_list|()
condition|)
block|{
name|assertNotNull
argument_list|(
literal|"Directory "
operator|+
name|pathStr
operator|+
literal|" in cache"
argument_list|,
name|dirMeta
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|allowMissing
argument_list|()
operator|||
name|dirMeta
operator|!=
literal|null
condition|)
block|{
name|dirMeta
operator|=
name|dirMeta
operator|.
name|withoutTombstones
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Number of entries in dir "
operator|+
name|pathStr
argument_list|,
name|size
argument_list|,
name|nonDeleted
argument_list|(
name|dirMeta
operator|.
name|getListing
argument_list|()
argument_list|)
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** @return only file statuses which are *not* marked deleted. */
DECL|method|nonDeleted ( Collection<PathMetadata> statuses)
specifier|private
name|Collection
argument_list|<
name|PathMetadata
argument_list|>
name|nonDeleted
parameter_list|(
name|Collection
argument_list|<
name|PathMetadata
argument_list|>
name|statuses
parameter_list|)
block|{
name|Collection
argument_list|<
name|PathMetadata
argument_list|>
name|currentStatuses
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|PathMetadata
name|status
range|:
name|statuses
control|)
block|{
if|if
condition|(
operator|!
name|status
operator|.
name|isDeleted
argument_list|()
condition|)
block|{
name|currentStatuses
operator|.
name|add
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|currentStatuses
return|;
block|}
DECL|method|assertDeleted (String pathStr)
specifier|private
name|void
name|assertDeleted
parameter_list|(
name|String
name|pathStr
parameter_list|)
throws|throws
name|IOException
block|{
name|Path
name|path
init|=
name|strToPath
argument_list|(
name|pathStr
argument_list|)
decl_stmt|;
name|PathMetadata
name|meta
init|=
name|ms
operator|.
name|get
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|boolean
name|cached
init|=
name|meta
operator|!=
literal|null
operator|&&
operator|!
name|meta
operator|.
name|isDeleted
argument_list|()
decl_stmt|;
name|assertFalse
argument_list|(
name|pathStr
operator|+
literal|" should not be cached."
argument_list|,
name|cached
argument_list|)
expr_stmt|;
block|}
DECL|method|assertCached (String pathStr)
specifier|protected
name|void
name|assertCached
parameter_list|(
name|String
name|pathStr
parameter_list|)
throws|throws
name|IOException
block|{
name|Path
name|path
init|=
name|strToPath
argument_list|(
name|pathStr
argument_list|)
decl_stmt|;
name|PathMetadata
name|meta
init|=
name|ms
operator|.
name|get
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|boolean
name|cached
init|=
name|meta
operator|!=
literal|null
operator|&&
operator|!
name|meta
operator|.
name|isDeleted
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
name|pathStr
operator|+
literal|" should be cached."
argument_list|,
name|cached
argument_list|)
expr_stmt|;
block|}
comment|/**    * Convenience to create a fully qualified Path from string.    */
DECL|method|strToPath (String p)
name|Path
name|strToPath
parameter_list|(
name|String
name|p
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|Path
name|path
init|=
operator|new
name|Path
argument_list|(
name|p
argument_list|)
decl_stmt|;
assert|assert
name|path
operator|.
name|isAbsolute
argument_list|()
assert|;
return|return
name|path
operator|.
name|makeQualified
argument_list|(
name|contract
operator|.
name|getFileSystem
argument_list|()
operator|.
name|getUri
argument_list|()
argument_list|,
literal|null
argument_list|)
return|;
block|}
DECL|method|assertEmptyDirectory (String pathStr)
specifier|private
name|void
name|assertEmptyDirectory
parameter_list|(
name|String
name|pathStr
parameter_list|)
throws|throws
name|IOException
block|{
name|assertDirectorySize
argument_list|(
name|pathStr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
DECL|method|assertEmptyDirs (String ....dirs)
specifier|private
name|void
name|assertEmptyDirs
parameter_list|(
name|String
modifier|...
name|dirs
parameter_list|)
throws|throws
name|IOException
block|{
for|for
control|(
name|String
name|pathStr
range|:
name|dirs
control|)
block|{
name|assertEmptyDirectory
argument_list|(
name|pathStr
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|basicFileStatus (Path path, int size, boolean isDir)
name|FileStatus
name|basicFileStatus
parameter_list|(
name|Path
name|path
parameter_list|,
name|int
name|size
parameter_list|,
name|boolean
name|isDir
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|basicFileStatus
argument_list|(
name|path
argument_list|,
name|size
argument_list|,
name|isDir
argument_list|,
name|modTime
argument_list|,
name|accessTime
argument_list|)
return|;
block|}
DECL|method|basicFileStatus (Path path, int size, boolean isDir, long newModTime, long newAccessTime)
specifier|public
specifier|static
name|FileStatus
name|basicFileStatus
parameter_list|(
name|Path
name|path
parameter_list|,
name|int
name|size
parameter_list|,
name|boolean
name|isDir
parameter_list|,
name|long
name|newModTime
parameter_list|,
name|long
name|newAccessTime
parameter_list|)
throws|throws
name|IOException
block|{
return|return
operator|new
name|FileStatus
argument_list|(
name|size
argument_list|,
name|isDir
argument_list|,
name|REPLICATION
argument_list|,
name|BLOCK_SIZE
argument_list|,
name|newModTime
argument_list|,
name|newAccessTime
argument_list|,
name|PERMISSION
argument_list|,
name|OWNER
argument_list|,
name|GROUP
argument_list|,
name|path
argument_list|)
return|;
block|}
DECL|method|makeFileStatus (String pathStr, int size)
specifier|private
name|FileStatus
name|makeFileStatus
parameter_list|(
name|String
name|pathStr
parameter_list|,
name|int
name|size
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|makeFileStatus
argument_list|(
name|pathStr
argument_list|,
name|size
argument_list|,
name|modTime
argument_list|,
name|accessTime
argument_list|)
return|;
block|}
DECL|method|makeFileStatus (String pathStr, int size, long newModTime, long newAccessTime)
specifier|private
name|FileStatus
name|makeFileStatus
parameter_list|(
name|String
name|pathStr
parameter_list|,
name|int
name|size
parameter_list|,
name|long
name|newModTime
parameter_list|,
name|long
name|newAccessTime
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|basicFileStatus
argument_list|(
name|strToPath
argument_list|(
name|pathStr
argument_list|)
argument_list|,
name|size
argument_list|,
literal|false
argument_list|,
name|newModTime
argument_list|,
name|newAccessTime
argument_list|)
return|;
block|}
DECL|method|verifyFileStatus (FileStatus status, long size)
name|void
name|verifyFileStatus
parameter_list|(
name|FileStatus
name|status
parameter_list|,
name|long
name|size
parameter_list|)
block|{
name|S3ATestUtils
operator|.
name|verifyFileStatus
argument_list|(
name|status
argument_list|,
name|size
argument_list|,
name|BLOCK_SIZE
argument_list|,
name|modTime
argument_list|)
expr_stmt|;
block|}
DECL|method|makeDirStatus (String pathStr)
specifier|private
name|FileStatus
name|makeDirStatus
parameter_list|(
name|String
name|pathStr
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|basicFileStatus
argument_list|(
name|strToPath
argument_list|(
name|pathStr
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|true
argument_list|,
name|modTime
argument_list|,
name|accessTime
argument_list|)
return|;
block|}
comment|/**    * Verify the directory file status. Subclass may verify additional fields.    */
DECL|method|verifyDirStatus (FileStatus status)
name|void
name|verifyDirStatus
parameter_list|(
name|FileStatus
name|status
parameter_list|)
block|{
name|assertTrue
argument_list|(
literal|"Is a dir"
argument_list|,
name|status
operator|.
name|isDirectory
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"zero length"
argument_list|,
literal|0
argument_list|,
name|status
operator|.
name|getLen
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|getModTime ()
name|long
name|getModTime
parameter_list|()
block|{
return|return
name|modTime
return|;
block|}
DECL|method|getAccessTime ()
name|long
name|getAccessTime
parameter_list|()
block|{
return|return
name|accessTime
return|;
block|}
DECL|method|getTime ()
specifier|protected
specifier|static
name|long
name|getTime
parameter_list|()
block|{
return|return
name|System
operator|.
name|currentTimeMillis
argument_list|()
return|;
block|}
block|}
end_class

end_unit

