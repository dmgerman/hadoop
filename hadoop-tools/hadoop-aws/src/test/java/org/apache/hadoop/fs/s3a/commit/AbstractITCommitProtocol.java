begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.fs.s3a.commit
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|commit
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileNotFoundException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutorService
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|stream
operator|.
name|Collectors
import|;
end_import

begin_import
import|import
name|org
operator|.
name|assertj
operator|.
name|core
operator|.
name|api
operator|.
name|Assertions
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|AfterClass
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Test
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|contract
operator|.
name|ContractTestUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|S3AFileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|IntWritable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|LongWritable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|MapFile
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|NullWritable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|Text
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|JobConf
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|Job
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|JobContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|JobStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|MRJobConfig
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|OutputCommitter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|OutputFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|RecordWriter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|TaskAttemptContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|TaskAttemptID
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|lib
operator|.
name|output
operator|.
name|FileOutputFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|lib
operator|.
name|output
operator|.
name|MapFileOutputFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|lib
operator|.
name|output
operator|.
name|TextOutputFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|task
operator|.
name|JobContextImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|task
operator|.
name|TaskAttemptContextImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|v2
operator|.
name|util
operator|.
name|MRBuilderUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|DurationInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|ReflectionUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|concurrent
operator|.
name|HadoopExecutors
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|contract
operator|.
name|ContractTestUtils
operator|.
name|*
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|S3AUtils
operator|.
name|*
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|S3ATestUtils
operator|.
name|*
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|commit
operator|.
name|CommitConstants
operator|.
name|*
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|test
operator|.
name|LambdaTestUtils
operator|.
name|*
import|;
end_import

begin_comment
comment|/**  * Test the job/task commit actions of an S3A Committer, including trying to  * simulate some failure and retry conditions.  * Derived from  * {@code org.apache.hadoop.mapreduce.lib.output.TestFileOutputCommitter}.  *  * This is a complex test suite as it tries to explore the full lifecycle  * of committers, and is designed for subclassing.  */
end_comment

begin_class
annotation|@
name|SuppressWarnings
argument_list|(
block|{
literal|"unchecked"
block|,
literal|"ThrowableNotThrown"
block|,
literal|"unused"
block|}
argument_list|)
DECL|class|AbstractITCommitProtocol
specifier|public
specifier|abstract
class|class
name|AbstractITCommitProtocol
extends|extends
name|AbstractCommitITest
block|{
DECL|field|outDir
specifier|private
name|Path
name|outDir
decl_stmt|;
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|AbstractITCommitProtocol
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|SUB_DIR
specifier|private
specifier|static
specifier|final
name|String
name|SUB_DIR
init|=
literal|"SUB_DIR"
decl_stmt|;
DECL|field|PART_00000
specifier|protected
specifier|static
specifier|final
name|String
name|PART_00000
init|=
literal|"part-m-00000"
decl_stmt|;
comment|/**    * Counter to guarantee that even in parallel test runs, no job has the same    * ID.    */
DECL|field|jobId
specifier|private
name|String
name|jobId
decl_stmt|;
comment|// A random task attempt id for testing.
DECL|field|attempt0
specifier|private
name|String
name|attempt0
decl_stmt|;
DECL|field|taskAttempt0
specifier|private
name|TaskAttemptID
name|taskAttempt0
decl_stmt|;
DECL|field|attempt1
specifier|private
name|String
name|attempt1
decl_stmt|;
DECL|field|taskAttempt1
specifier|private
name|TaskAttemptID
name|taskAttempt1
decl_stmt|;
DECL|field|KEY_1
specifier|private
specifier|static
specifier|final
name|Text
name|KEY_1
init|=
operator|new
name|Text
argument_list|(
literal|"key1"
argument_list|)
decl_stmt|;
DECL|field|KEY_2
specifier|private
specifier|static
specifier|final
name|Text
name|KEY_2
init|=
operator|new
name|Text
argument_list|(
literal|"key2"
argument_list|)
decl_stmt|;
DECL|field|VAL_1
specifier|private
specifier|static
specifier|final
name|Text
name|VAL_1
init|=
operator|new
name|Text
argument_list|(
literal|"val1"
argument_list|)
decl_stmt|;
DECL|field|VAL_2
specifier|private
specifier|static
specifier|final
name|Text
name|VAL_2
init|=
operator|new
name|Text
argument_list|(
literal|"val2"
argument_list|)
decl_stmt|;
comment|/** A job to abort in test case teardown. */
DECL|field|abortInTeardown
specifier|private
name|List
argument_list|<
name|JobData
argument_list|>
name|abortInTeardown
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
literal|1
argument_list|)
decl_stmt|;
specifier|private
specifier|final
name|StandardCommitterFactory
DECL|field|standardCommitterFactory
name|standardCommitterFactory
init|=
operator|new
name|StandardCommitterFactory
argument_list|()
decl_stmt|;
DECL|method|cleanupDestDir ()
specifier|private
name|void
name|cleanupDestDir
parameter_list|()
throws|throws
name|IOException
block|{
name|rmdir
argument_list|(
name|this
operator|.
name|outDir
argument_list|,
name|getConfiguration
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * This must return the name of a suite which is unique to the non-abstract    * test.    * @return a string which must be unique and a valid path.    */
DECL|method|suitename ()
specifier|protected
specifier|abstract
name|String
name|suitename
parameter_list|()
function_decl|;
comment|/**    * Get the log; can be overridden for test case log.    * @return a log.    */
DECL|method|log ()
specifier|public
name|Logger
name|log
parameter_list|()
block|{
return|return
name|LOG
return|;
block|}
comment|/**    * Overridden method returns the suitename as well as the method name,    * so if more than one committer test is run in parallel, paths are    * isolated.    * @return a name for a method, unique across the suites and test cases.    */
annotation|@
name|Override
DECL|method|getMethodName ()
specifier|protected
name|String
name|getMethodName
parameter_list|()
block|{
return|return
name|suitename
argument_list|()
operator|+
literal|"-"
operator|+
name|super
operator|.
name|getMethodName
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|setup ()
specifier|public
name|void
name|setup
parameter_list|()
throws|throws
name|Exception
block|{
name|super
operator|.
name|setup
argument_list|()
expr_stmt|;
name|jobId
operator|=
name|randomJobId
argument_list|()
expr_stmt|;
name|attempt0
operator|=
literal|"attempt_"
operator|+
name|jobId
operator|+
literal|"_m_000000_0"
expr_stmt|;
name|taskAttempt0
operator|=
name|TaskAttemptID
operator|.
name|forName
argument_list|(
name|attempt0
argument_list|)
expr_stmt|;
name|attempt1
operator|=
literal|"attempt_"
operator|+
name|jobId
operator|+
literal|"_m_000001_0"
expr_stmt|;
name|taskAttempt1
operator|=
name|TaskAttemptID
operator|.
name|forName
argument_list|(
name|attempt1
argument_list|)
expr_stmt|;
name|outDir
operator|=
name|path
argument_list|(
name|getMethodName
argument_list|()
argument_list|)
expr_stmt|;
name|abortMultipartUploadsUnderPath
argument_list|(
name|outDir
argument_list|)
expr_stmt|;
name|cleanupDestDir
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|teardown ()
specifier|public
name|void
name|teardown
parameter_list|()
throws|throws
name|Exception
block|{
name|describe
argument_list|(
literal|"teardown"
argument_list|)
expr_stmt|;
name|abortInTeardown
operator|.
name|forEach
argument_list|(
name|this
operator|::
name|abortJobQuietly
argument_list|)
expr_stmt|;
if|if
condition|(
name|outDir
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|abortMultipartUploadsUnderPath
argument_list|(
name|outDir
argument_list|)
expr_stmt|;
name|cleanupDestDir
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|log
argument_list|()
operator|.
name|info
argument_list|(
literal|"Exception during cleanup"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
name|S3AFileSystem
name|fileSystem
init|=
name|getFileSystem
argument_list|()
decl_stmt|;
if|if
condition|(
name|fileSystem
operator|!=
literal|null
condition|)
block|{
name|log
argument_list|()
operator|.
name|info
argument_list|(
literal|"Statistics for {}:\n{}"
argument_list|,
name|fileSystem
operator|.
name|getUri
argument_list|()
argument_list|,
name|fileSystem
operator|.
name|getInstrumentation
argument_list|()
operator|.
name|dump
argument_list|(
literal|"  "
argument_list|,
literal|" =  "
argument_list|,
literal|"\n"
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|super
operator|.
name|teardown
argument_list|()
expr_stmt|;
block|}
comment|/**    * This only looks for leakage of committer thread pools,    * and not any other leaked threads, such as those from S3A FS instances.    */
annotation|@
name|AfterClass
DECL|method|checkForThreadLeakage ()
specifier|public
specifier|static
name|void
name|checkForThreadLeakage
parameter_list|()
block|{
name|List
argument_list|<
name|String
argument_list|>
name|committerThreads
init|=
name|getCurrentThreadNames
argument_list|()
operator|.
name|stream
argument_list|()
operator|.
name|filter
argument_list|(
name|n
lambda|->
name|n
operator|.
name|startsWith
argument_list|(
name|AbstractS3ACommitter
operator|.
name|THREAD_PREFIX
argument_list|)
argument_list|)
operator|.
name|collect
argument_list|(
name|Collectors
operator|.
name|toList
argument_list|()
argument_list|)
decl_stmt|;
name|Assertions
operator|.
name|assertThat
argument_list|(
name|committerThreads
argument_list|)
operator|.
name|describedAs
argument_list|(
literal|"Outstanding committer threads"
argument_list|)
operator|.
name|isEmpty
argument_list|()
expr_stmt|;
block|}
comment|/**    * Add the specified job to the current list of jobs to abort in teardown.    * @param jobData job data.    */
DECL|method|abortInTeardown (JobData jobData)
specifier|protected
name|void
name|abortInTeardown
parameter_list|(
name|JobData
name|jobData
parameter_list|)
block|{
name|abortInTeardown
operator|.
name|add
argument_list|(
name|jobData
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|createConfiguration ()
specifier|protected
name|Configuration
name|createConfiguration
parameter_list|()
block|{
name|Configuration
name|conf
init|=
name|super
operator|.
name|createConfiguration
argument_list|()
decl_stmt|;
name|disableFilesystemCaching
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|bindCommitter
argument_list|(
name|conf
argument_list|)
expr_stmt|;
return|return
name|conf
return|;
block|}
comment|/***    * Bind to the committer from the methods of    * {@link #getCommitterFactoryName()} and {@link #getCommitterName()}.    * @param conf configuration to set up    */
DECL|method|bindCommitter (Configuration conf)
specifier|protected
name|void
name|bindCommitter
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
name|super
operator|.
name|bindCommitter
argument_list|(
name|conf
argument_list|,
name|getCommitterFactoryName
argument_list|()
argument_list|,
name|getCommitterName
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Create a committer for a task.    * @param context task context    * @return new committer    * @throws IOException failure    */
DECL|method|createCommitter ( TaskAttemptContext context)
specifier|protected
name|AbstractS3ACommitter
name|createCommitter
parameter_list|(
name|TaskAttemptContext
name|context
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|createCommitter
argument_list|(
name|getOutDir
argument_list|()
argument_list|,
name|context
argument_list|)
return|;
block|}
comment|/**    * Create a committer for a task and a given output path.    * @param outputPath path    * @param context task context    * @return new committer    * @throws IOException failure    */
DECL|method|createCommitter ( Path outputPath, TaskAttemptContext context)
specifier|protected
specifier|abstract
name|AbstractS3ACommitter
name|createCommitter
parameter_list|(
name|Path
name|outputPath
parameter_list|,
name|TaskAttemptContext
name|context
parameter_list|)
throws|throws
name|IOException
function_decl|;
DECL|method|getCommitterFactoryName ()
specifier|protected
name|String
name|getCommitterFactoryName
parameter_list|()
block|{
return|return
name|CommitConstants
operator|.
name|S3A_COMMITTER_FACTORY
return|;
block|}
DECL|method|getCommitterName ()
specifier|protected
specifier|abstract
name|String
name|getCommitterName
parameter_list|()
function_decl|;
DECL|method|getOutDir ()
specifier|protected
name|Path
name|getOutDir
parameter_list|()
block|{
return|return
name|outDir
return|;
block|}
DECL|method|getJobId ()
specifier|protected
name|String
name|getJobId
parameter_list|()
block|{
return|return
name|jobId
return|;
block|}
DECL|method|getAttempt0 ()
specifier|protected
name|String
name|getAttempt0
parameter_list|()
block|{
return|return
name|attempt0
return|;
block|}
DECL|method|getTaskAttempt0 ()
specifier|protected
name|TaskAttemptID
name|getTaskAttempt0
parameter_list|()
block|{
return|return
name|taskAttempt0
return|;
block|}
DECL|method|getAttempt1 ()
specifier|protected
name|String
name|getAttempt1
parameter_list|()
block|{
return|return
name|attempt1
return|;
block|}
DECL|method|getTaskAttempt1 ()
specifier|protected
name|TaskAttemptID
name|getTaskAttempt1
parameter_list|()
block|{
return|return
name|taskAttempt1
return|;
block|}
comment|/**    * Functional interface for creating committers, designed to allow    * different factories to be used to create different failure modes.    */
annotation|@
name|FunctionalInterface
DECL|interface|CommitterFactory
specifier|public
interface|interface
name|CommitterFactory
block|{
comment|/**      * Create a committer for a task.      * @param context task context      * @return new committer      * @throws IOException failure      */
DECL|method|createCommitter ( TaskAttemptContext context)
name|AbstractS3ACommitter
name|createCommitter
parameter_list|(
name|TaskAttemptContext
name|context
parameter_list|)
throws|throws
name|IOException
function_decl|;
block|}
comment|/**    * The normal committer creation factory, uses the abstract methods    * in the class.    */
DECL|class|StandardCommitterFactory
specifier|public
class|class
name|StandardCommitterFactory
implements|implements
name|CommitterFactory
block|{
annotation|@
name|Override
DECL|method|createCommitter (TaskAttemptContext context)
specifier|public
name|AbstractS3ACommitter
name|createCommitter
parameter_list|(
name|TaskAttemptContext
name|context
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|AbstractITCommitProtocol
operator|.
name|this
operator|.
name|createCommitter
argument_list|(
name|context
argument_list|)
return|;
block|}
block|}
comment|/**    * Write some text out.    * @param context task    * @throws IOException IO failure    * @throws InterruptedException write interrupted    */
DECL|method|writeTextOutput (TaskAttemptContext context)
specifier|protected
name|void
name|writeTextOutput
parameter_list|(
name|TaskAttemptContext
name|context
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|describe
argument_list|(
literal|"write output"
argument_list|)
expr_stmt|;
try|try
init|(
name|DurationInfo
name|d
init|=
operator|new
name|DurationInfo
argument_list|(
name|LOG
argument_list|,
literal|"Writing Text output for task %s"
argument_list|,
name|context
operator|.
name|getTaskAttemptID
argument_list|()
argument_list|)
init|)
block|{
name|writeOutput
argument_list|(
operator|new
name|LoggingTextOutputFormat
argument_list|()
operator|.
name|getRecordWriter
argument_list|(
name|context
argument_list|)
argument_list|,
name|context
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Write the standard output.    * @param writer record writer    * @param context task context    * @throws IOException IO failure    * @throws InterruptedException write interrupted    */
DECL|method|writeOutput (RecordWriter writer, TaskAttemptContext context)
specifier|private
name|void
name|writeOutput
parameter_list|(
name|RecordWriter
name|writer
parameter_list|,
name|TaskAttemptContext
name|context
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|NullWritable
name|nullWritable
init|=
name|NullWritable
operator|.
name|get
argument_list|()
decl_stmt|;
try|try
init|(
name|CloseWriter
name|cw
init|=
operator|new
name|CloseWriter
argument_list|(
name|writer
argument_list|,
name|context
argument_list|)
init|)
block|{
name|writer
operator|.
name|write
argument_list|(
name|KEY_1
argument_list|,
name|VAL_1
argument_list|)
expr_stmt|;
name|writer
operator|.
name|write
argument_list|(
literal|null
argument_list|,
name|nullWritable
argument_list|)
expr_stmt|;
name|writer
operator|.
name|write
argument_list|(
literal|null
argument_list|,
name|VAL_1
argument_list|)
expr_stmt|;
name|writer
operator|.
name|write
argument_list|(
name|nullWritable
argument_list|,
name|VAL_2
argument_list|)
expr_stmt|;
name|writer
operator|.
name|write
argument_list|(
name|KEY_2
argument_list|,
name|nullWritable
argument_list|)
expr_stmt|;
name|writer
operator|.
name|write
argument_list|(
name|KEY_1
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|writer
operator|.
name|write
argument_list|(
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|writer
operator|.
name|write
argument_list|(
name|KEY_2
argument_list|,
name|VAL_2
argument_list|)
expr_stmt|;
name|writer
operator|.
name|close
argument_list|(
name|context
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Write the output of a map.    * @param writer record writer    * @param context task context    * @throws IOException IO failure    * @throws InterruptedException write interrupted    */
DECL|method|writeMapFileOutput (RecordWriter writer, TaskAttemptContext context)
specifier|private
name|void
name|writeMapFileOutput
parameter_list|(
name|RecordWriter
name|writer
parameter_list|,
name|TaskAttemptContext
name|context
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|describe
argument_list|(
literal|"\nWrite map output"
argument_list|)
expr_stmt|;
try|try
init|(
name|DurationInfo
name|d
init|=
operator|new
name|DurationInfo
argument_list|(
name|LOG
argument_list|,
literal|"Writing Text output for task %s"
argument_list|,
name|context
operator|.
name|getTaskAttemptID
argument_list|()
argument_list|)
init|;
name|CloseWriter
name|cw
operator|=
operator|new
name|CloseWriter
argument_list|(
name|writer
argument_list|,
name|context
argument_list|)
init|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
operator|++
name|i
control|)
block|{
name|Text
name|val
init|=
operator|(
operator|(
name|i
operator|&
literal|1
operator|)
operator|==
literal|1
operator|)
condition|?
name|VAL_1
else|:
name|VAL_2
decl_stmt|;
name|writer
operator|.
name|write
argument_list|(
operator|new
name|LongWritable
argument_list|(
name|i
argument_list|)
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
name|writer
operator|.
name|close
argument_list|(
name|context
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Details on a job for use in {@code startJob} and elsewhere.    */
DECL|class|JobData
specifier|public
specifier|static
class|class
name|JobData
block|{
DECL|field|job
specifier|private
specifier|final
name|Job
name|job
decl_stmt|;
DECL|field|jContext
specifier|private
specifier|final
name|JobContext
name|jContext
decl_stmt|;
DECL|field|tContext
specifier|private
specifier|final
name|TaskAttemptContext
name|tContext
decl_stmt|;
DECL|field|committer
specifier|private
specifier|final
name|AbstractS3ACommitter
name|committer
decl_stmt|;
DECL|field|conf
specifier|private
specifier|final
name|Configuration
name|conf
decl_stmt|;
DECL|method|JobData (Job job, JobContext jContext, TaskAttemptContext tContext, AbstractS3ACommitter committer)
specifier|public
name|JobData
parameter_list|(
name|Job
name|job
parameter_list|,
name|JobContext
name|jContext
parameter_list|,
name|TaskAttemptContext
name|tContext
parameter_list|,
name|AbstractS3ACommitter
name|committer
parameter_list|)
block|{
name|this
operator|.
name|job
operator|=
name|job
expr_stmt|;
name|this
operator|.
name|jContext
operator|=
name|jContext
expr_stmt|;
name|this
operator|.
name|tContext
operator|=
name|tContext
expr_stmt|;
name|this
operator|.
name|committer
operator|=
name|committer
expr_stmt|;
name|conf
operator|=
name|job
operator|.
name|getConfiguration
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Create a new job. Sets the task attempt ID,    * and output dir; asks for a success marker.    * @return the new job    * @throws IOException failure    */
DECL|method|newJob ()
specifier|public
name|Job
name|newJob
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|newJob
argument_list|(
name|outDir
argument_list|,
name|getConfiguration
argument_list|()
argument_list|,
name|attempt0
argument_list|)
return|;
block|}
comment|/**    * Create a new job. Sets the task attempt ID,    * and output dir; asks for a success marker.    * @param dir dest dir    * @param configuration config to get the job from    * @param taskAttemptId task attempt    * @return the new job    * @throws IOException failure    */
DECL|method|newJob (Path dir, Configuration configuration, String taskAttemptId)
specifier|private
name|Job
name|newJob
parameter_list|(
name|Path
name|dir
parameter_list|,
name|Configuration
name|configuration
parameter_list|,
name|String
name|taskAttemptId
parameter_list|)
throws|throws
name|IOException
block|{
name|Job
name|job
init|=
name|Job
operator|.
name|getInstance
argument_list|(
name|configuration
argument_list|)
decl_stmt|;
name|Configuration
name|conf
init|=
name|job
operator|.
name|getConfiguration
argument_list|()
decl_stmt|;
name|conf
operator|.
name|set
argument_list|(
name|MRJobConfig
operator|.
name|TASK_ATTEMPT_ID
argument_list|,
name|taskAttemptId
argument_list|)
expr_stmt|;
name|conf
operator|.
name|setBoolean
argument_list|(
name|CREATE_SUCCESSFUL_JOB_OUTPUT_DIR_MARKER
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|FileOutputFormat
operator|.
name|setOutputPath
argument_list|(
name|job
argument_list|,
name|dir
argument_list|)
expr_stmt|;
return|return
name|job
return|;
block|}
comment|/**    * Start a job with a committer; optionally write the test data.    * Always register the job to be aborted (quietly) in teardown.    * This is, from an "OO-purity perspective" the wrong kind of method to    * do: it's setting things up, mixing functionality, registering for teardown.    * Its aim is simple though: a common body of code for starting work    * in test cases.    * @param writeText should the text be written?    * @return the job data 4-tuple    * @throws IOException IO problems    * @throws InterruptedException interruption during write    */
DECL|method|startJob (boolean writeText)
specifier|protected
name|JobData
name|startJob
parameter_list|(
name|boolean
name|writeText
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
return|return
name|startJob
argument_list|(
name|standardCommitterFactory
argument_list|,
name|writeText
argument_list|)
return|;
block|}
comment|/**    * Start a job with a committer; optionally write the test data.    * Always register the job to be aborted (quietly) in teardown.    * This is, from an "OO-purity perspective" the wrong kind of method to    * do: it's setting things up, mixing functionality, registering for teardown.    * Its aim is simple though: a common body of code for starting work    * in test cases.    * @param factory the committer factory to use    * @param writeText should the text be written?    * @return the job data 4-tuple    * @throws IOException IO problems    * @throws InterruptedException interruption during write    */
DECL|method|startJob (CommitterFactory factory, boolean writeText)
specifier|protected
name|JobData
name|startJob
parameter_list|(
name|CommitterFactory
name|factory
parameter_list|,
name|boolean
name|writeText
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|Job
name|job
init|=
name|newJob
argument_list|()
decl_stmt|;
name|Configuration
name|conf
init|=
name|job
operator|.
name|getConfiguration
argument_list|()
decl_stmt|;
name|conf
operator|.
name|set
argument_list|(
name|MRJobConfig
operator|.
name|TASK_ATTEMPT_ID
argument_list|,
name|attempt0
argument_list|)
expr_stmt|;
name|conf
operator|.
name|setInt
argument_list|(
name|MRJobConfig
operator|.
name|APPLICATION_ATTEMPT_ID
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|JobContext
name|jContext
init|=
operator|new
name|JobContextImpl
argument_list|(
name|conf
argument_list|,
name|taskAttempt0
operator|.
name|getJobID
argument_list|()
argument_list|)
decl_stmt|;
name|TaskAttemptContext
name|tContext
init|=
operator|new
name|TaskAttemptContextImpl
argument_list|(
name|conf
argument_list|,
name|taskAttempt0
argument_list|)
decl_stmt|;
name|AbstractS3ACommitter
name|committer
init|=
name|factory
operator|.
name|createCommitter
argument_list|(
name|tContext
argument_list|)
decl_stmt|;
comment|// setup
name|JobData
name|jobData
init|=
operator|new
name|JobData
argument_list|(
name|job
argument_list|,
name|jContext
argument_list|,
name|tContext
argument_list|,
name|committer
argument_list|)
decl_stmt|;
name|setup
argument_list|(
name|jobData
argument_list|)
expr_stmt|;
name|abortInTeardown
argument_list|(
name|jobData
argument_list|)
expr_stmt|;
if|if
condition|(
name|writeText
condition|)
block|{
comment|// write output
name|writeTextOutput
argument_list|(
name|tContext
argument_list|)
expr_stmt|;
block|}
return|return
name|jobData
return|;
block|}
comment|/**    * Set up the job and task.    * @param jobData job data    * @throws IOException problems    */
DECL|method|setup (JobData jobData)
specifier|protected
name|void
name|setup
parameter_list|(
name|JobData
name|jobData
parameter_list|)
throws|throws
name|IOException
block|{
name|AbstractS3ACommitter
name|committer
init|=
name|jobData
operator|.
name|committer
decl_stmt|;
name|JobContext
name|jContext
init|=
name|jobData
operator|.
name|jContext
decl_stmt|;
name|TaskAttemptContext
name|tContext
init|=
name|jobData
operator|.
name|tContext
decl_stmt|;
name|describe
argument_list|(
literal|"\nsetup job"
argument_list|)
expr_stmt|;
try|try
init|(
name|DurationInfo
name|d
init|=
operator|new
name|DurationInfo
argument_list|(
name|LOG
argument_list|,
literal|"setup job %s"
argument_list|,
name|jContext
operator|.
name|getJobID
argument_list|()
argument_list|)
init|)
block|{
name|committer
operator|.
name|setupJob
argument_list|(
name|jContext
argument_list|)
expr_stmt|;
block|}
try|try
init|(
name|DurationInfo
name|d
init|=
operator|new
name|DurationInfo
argument_list|(
name|LOG
argument_list|,
literal|"setup task %s"
argument_list|,
name|tContext
operator|.
name|getTaskAttemptID
argument_list|()
argument_list|)
init|)
block|{
name|committer
operator|.
name|setupTask
argument_list|(
name|tContext
argument_list|)
expr_stmt|;
block|}
name|describe
argument_list|(
literal|"setup complete\n"
argument_list|)
expr_stmt|;
block|}
comment|/**    * Abort a job quietly.    * @param jobData job info    */
DECL|method|abortJobQuietly (JobData jobData)
specifier|protected
name|void
name|abortJobQuietly
parameter_list|(
name|JobData
name|jobData
parameter_list|)
block|{
name|abortJobQuietly
argument_list|(
name|jobData
operator|.
name|committer
argument_list|,
name|jobData
operator|.
name|jContext
argument_list|,
name|jobData
operator|.
name|tContext
argument_list|)
expr_stmt|;
block|}
comment|/**    * Abort a job quietly: first task, then job.    * @param committer committer    * @param jContext job context    * @param tContext task context    */
DECL|method|abortJobQuietly (AbstractS3ACommitter committer, JobContext jContext, TaskAttemptContext tContext)
specifier|protected
name|void
name|abortJobQuietly
parameter_list|(
name|AbstractS3ACommitter
name|committer
parameter_list|,
name|JobContext
name|jContext
parameter_list|,
name|TaskAttemptContext
name|tContext
parameter_list|)
block|{
name|describe
argument_list|(
literal|"\naborting task"
argument_list|)
expr_stmt|;
try|try
block|{
name|committer
operator|.
name|abortTask
argument_list|(
name|tContext
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|log
argument_list|()
operator|.
name|warn
argument_list|(
literal|"Exception aborting task:"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
name|describe
argument_list|(
literal|"\naborting job"
argument_list|)
expr_stmt|;
try|try
block|{
name|committer
operator|.
name|abortJob
argument_list|(
name|jContext
argument_list|,
name|JobStatus
operator|.
name|State
operator|.
name|KILLED
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|log
argument_list|()
operator|.
name|warn
argument_list|(
literal|"Exception aborting job"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Commit up the task and then the job.    * @param committer committer    * @param jContext job context    * @param tContext task context    * @throws IOException problems    */
DECL|method|commit (AbstractS3ACommitter committer, JobContext jContext, TaskAttemptContext tContext)
specifier|protected
name|void
name|commit
parameter_list|(
name|AbstractS3ACommitter
name|committer
parameter_list|,
name|JobContext
name|jContext
parameter_list|,
name|TaskAttemptContext
name|tContext
parameter_list|)
throws|throws
name|IOException
block|{
try|try
init|(
name|DurationInfo
name|d
init|=
operator|new
name|DurationInfo
argument_list|(
name|LOG
argument_list|,
literal|"committing work"
argument_list|,
name|jContext
operator|.
name|getJobID
argument_list|()
argument_list|)
init|)
block|{
name|describe
argument_list|(
literal|"\ncommitting task"
argument_list|)
expr_stmt|;
name|committer
operator|.
name|commitTask
argument_list|(
name|tContext
argument_list|)
expr_stmt|;
name|describe
argument_list|(
literal|"\ncommitting job"
argument_list|)
expr_stmt|;
name|committer
operator|.
name|commitJob
argument_list|(
name|jContext
argument_list|)
expr_stmt|;
name|describe
argument_list|(
literal|"commit complete\n"
argument_list|)
expr_stmt|;
name|verifyCommitterHasNoThreads
argument_list|(
name|committer
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Execute work as part of a test, after creating the job.    * After the execution, {@link #abortJobQuietly(JobData)} is    * called for abort/cleanup.    * @param name name of work (for logging)    * @param action action to execute    * @throws Exception failure    */
DECL|method|executeWork (String name, ActionToTest action)
specifier|protected
name|void
name|executeWork
parameter_list|(
name|String
name|name
parameter_list|,
name|ActionToTest
name|action
parameter_list|)
throws|throws
name|Exception
block|{
name|executeWork
argument_list|(
name|name
argument_list|,
name|startJob
argument_list|(
literal|false
argument_list|)
argument_list|,
name|action
argument_list|)
expr_stmt|;
block|}
comment|/**    * Execute work as part of a test, against the created job.    * After the execution, {@link #abortJobQuietly(JobData)} is    * called for abort/cleanup.    * @param name name of work (for logging)    * @param jobData job info    * @param action action to execute    * @throws Exception failure    */
DECL|method|executeWork (String name, JobData jobData, ActionToTest action)
specifier|public
name|void
name|executeWork
parameter_list|(
name|String
name|name
parameter_list|,
name|JobData
name|jobData
parameter_list|,
name|ActionToTest
name|action
parameter_list|)
throws|throws
name|Exception
block|{
try|try
init|(
name|DurationInfo
name|d
init|=
operator|new
name|DurationInfo
argument_list|(
name|LOG
argument_list|,
literal|"Executing %s"
argument_list|,
name|name
argument_list|)
init|)
block|{
name|action
operator|.
name|exec
argument_list|(
name|jobData
operator|.
name|job
argument_list|,
name|jobData
operator|.
name|jContext
argument_list|,
name|jobData
operator|.
name|tContext
argument_list|,
name|jobData
operator|.
name|committer
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|abortJobQuietly
argument_list|(
name|jobData
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Verify that recovery doesn't work for these committers.    */
annotation|@
name|Test
annotation|@
name|SuppressWarnings
argument_list|(
literal|"deprecation"
argument_list|)
DECL|method|testRecoveryAndCleanup ()
specifier|public
name|void
name|testRecoveryAndCleanup
parameter_list|()
throws|throws
name|Exception
block|{
name|describe
argument_list|(
literal|"Test (unsupported) task recovery."
argument_list|)
expr_stmt|;
name|JobData
name|jobData
init|=
name|startJob
argument_list|(
literal|true
argument_list|)
decl_stmt|;
name|TaskAttemptContext
name|tContext
init|=
name|jobData
operator|.
name|tContext
decl_stmt|;
name|AbstractS3ACommitter
name|committer
init|=
name|jobData
operator|.
name|committer
decl_stmt|;
name|assertNotNull
argument_list|(
literal|"null workPath in committer "
operator|+
name|committer
argument_list|,
name|committer
operator|.
name|getWorkPath
argument_list|()
argument_list|)
expr_stmt|;
name|assertNotNull
argument_list|(
literal|"null outputPath in committer "
operator|+
name|committer
argument_list|,
name|committer
operator|.
name|getOutputPath
argument_list|()
argument_list|)
expr_stmt|;
comment|// Commit the task. This will promote data and metadata to where
comment|// job commits will pick it up on commit or abort.
name|commitTask
argument_list|(
name|committer
argument_list|,
name|tContext
argument_list|)
expr_stmt|;
name|assertTaskAttemptPathDoesNotExist
argument_list|(
name|committer
argument_list|,
name|tContext
argument_list|)
expr_stmt|;
name|Configuration
name|conf2
init|=
name|jobData
operator|.
name|job
operator|.
name|getConfiguration
argument_list|()
decl_stmt|;
name|conf2
operator|.
name|set
argument_list|(
name|MRJobConfig
operator|.
name|TASK_ATTEMPT_ID
argument_list|,
name|attempt0
argument_list|)
expr_stmt|;
name|conf2
operator|.
name|setInt
argument_list|(
name|MRJobConfig
operator|.
name|APPLICATION_ATTEMPT_ID
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|JobContext
name|jContext2
init|=
operator|new
name|JobContextImpl
argument_list|(
name|conf2
argument_list|,
name|taskAttempt0
operator|.
name|getJobID
argument_list|()
argument_list|)
decl_stmt|;
name|TaskAttemptContext
name|tContext2
init|=
operator|new
name|TaskAttemptContextImpl
argument_list|(
name|conf2
argument_list|,
name|taskAttempt0
argument_list|)
decl_stmt|;
name|AbstractS3ACommitter
name|committer2
init|=
name|createCommitter
argument_list|(
name|tContext2
argument_list|)
decl_stmt|;
name|committer2
operator|.
name|setupJob
argument_list|(
name|tContext2
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
literal|"recoverySupported in "
operator|+
name|committer2
argument_list|,
name|committer2
operator|.
name|isRecoverySupported
argument_list|()
argument_list|)
expr_stmt|;
name|intercept
argument_list|(
name|PathCommitException
operator|.
name|class
argument_list|,
literal|"recover"
argument_list|,
parameter_list|()
lambda|->
name|committer2
operator|.
name|recoverTask
argument_list|(
name|tContext2
argument_list|)
argument_list|)
expr_stmt|;
comment|// at this point, task attempt 0 has failed to recover
comment|// it should be abortable though. This will be a no-op as it already
comment|// committed
name|describe
argument_list|(
literal|"aborting task attempt 2; expect nothing to clean up"
argument_list|)
expr_stmt|;
name|committer2
operator|.
name|abortTask
argument_list|(
name|tContext2
argument_list|)
expr_stmt|;
name|describe
argument_list|(
literal|"Aborting job 2; expect pending commits to be aborted"
argument_list|)
expr_stmt|;
name|committer2
operator|.
name|abortJob
argument_list|(
name|jContext2
argument_list|,
name|JobStatus
operator|.
name|State
operator|.
name|KILLED
argument_list|)
expr_stmt|;
comment|// now, state of system may still have pending data
name|assertNoMultipartUploadsPending
argument_list|(
name|outDir
argument_list|)
expr_stmt|;
name|verifyCommitterHasNoThreads
argument_list|(
name|committer2
argument_list|)
expr_stmt|;
block|}
DECL|method|assertTaskAttemptPathDoesNotExist ( AbstractS3ACommitter committer, TaskAttemptContext context)
specifier|protected
name|void
name|assertTaskAttemptPathDoesNotExist
parameter_list|(
name|AbstractS3ACommitter
name|committer
parameter_list|,
name|TaskAttemptContext
name|context
parameter_list|)
throws|throws
name|IOException
block|{
name|Path
name|attemptPath
init|=
name|committer
operator|.
name|getTaskAttemptPath
argument_list|(
name|context
argument_list|)
decl_stmt|;
name|ContractTestUtils
operator|.
name|assertPathDoesNotExist
argument_list|(
name|attemptPath
operator|.
name|getFileSystem
argument_list|(
name|context
operator|.
name|getConfiguration
argument_list|()
argument_list|)
argument_list|,
literal|"task attempt dir"
argument_list|,
name|attemptPath
argument_list|)
expr_stmt|;
block|}
DECL|method|assertJobAttemptPathDoesNotExist ( AbstractS3ACommitter committer, JobContext context)
specifier|protected
name|void
name|assertJobAttemptPathDoesNotExist
parameter_list|(
name|AbstractS3ACommitter
name|committer
parameter_list|,
name|JobContext
name|context
parameter_list|)
throws|throws
name|IOException
block|{
name|Path
name|attemptPath
init|=
name|committer
operator|.
name|getJobAttemptPath
argument_list|(
name|context
argument_list|)
decl_stmt|;
name|ContractTestUtils
operator|.
name|assertPathDoesNotExist
argument_list|(
name|attemptPath
operator|.
name|getFileSystem
argument_list|(
name|context
operator|.
name|getConfiguration
argument_list|()
argument_list|)
argument_list|,
literal|"job attempt dir"
argument_list|,
name|attemptPath
argument_list|)
expr_stmt|;
block|}
comment|/**    * Verify the output of the directory.    * That includes the {@code part-m-00000-*}    * file existence and contents, as well as optionally, the success marker.    * @param dir directory to scan.    * @param expectSuccessMarker check the success marker?    * @throws Exception failure.    */
DECL|method|validateContent (Path dir, boolean expectSuccessMarker)
specifier|private
name|void
name|validateContent
parameter_list|(
name|Path
name|dir
parameter_list|,
name|boolean
name|expectSuccessMarker
parameter_list|)
throws|throws
name|Exception
block|{
if|if
condition|(
name|expectSuccessMarker
condition|)
block|{
name|verifySuccessMarker
argument_list|(
name|dir
argument_list|)
expr_stmt|;
block|}
name|Path
name|expectedFile
init|=
name|getPart0000
argument_list|(
name|dir
argument_list|)
decl_stmt|;
name|log
argument_list|()
operator|.
name|debug
argument_list|(
literal|"Validating content in {}"
argument_list|,
name|expectedFile
argument_list|)
expr_stmt|;
name|StringBuffer
name|expectedOutput
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
name|expectedOutput
operator|.
name|append
argument_list|(
name|KEY_1
argument_list|)
operator|.
name|append
argument_list|(
literal|'\t'
argument_list|)
operator|.
name|append
argument_list|(
name|VAL_1
argument_list|)
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|expectedOutput
operator|.
name|append
argument_list|(
name|VAL_1
argument_list|)
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|expectedOutput
operator|.
name|append
argument_list|(
name|VAL_2
argument_list|)
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|expectedOutput
operator|.
name|append
argument_list|(
name|KEY_2
argument_list|)
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|expectedOutput
operator|.
name|append
argument_list|(
name|KEY_1
argument_list|)
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|expectedOutput
operator|.
name|append
argument_list|(
name|KEY_2
argument_list|)
operator|.
name|append
argument_list|(
literal|'\t'
argument_list|)
operator|.
name|append
argument_list|(
name|VAL_2
argument_list|)
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|String
name|output
init|=
name|readFile
argument_list|(
name|expectedFile
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|"Content of "
operator|+
name|expectedFile
argument_list|,
name|expectedOutput
operator|.
name|toString
argument_list|()
argument_list|,
name|output
argument_list|)
expr_stmt|;
block|}
comment|/**    * Identify any path under the directory which begins with the    * {@code "part-m-00000"} sequence. There's some compensation for    * eventual consistency here.    * @param dir directory to scan    * @return the full path    * @throws FileNotFoundException the path is missing.    * @throws Exception failure.    */
DECL|method|getPart0000 (final Path dir)
specifier|protected
name|Path
name|getPart0000
parameter_list|(
specifier|final
name|Path
name|dir
parameter_list|)
throws|throws
name|Exception
block|{
specifier|final
name|FileSystem
name|fs
init|=
name|dir
operator|.
name|getFileSystem
argument_list|(
name|getConfiguration
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|eventually
argument_list|(
name|CONSISTENCY_WAIT
argument_list|,
name|CONSISTENCY_PROBE_INTERVAL
argument_list|,
parameter_list|()
lambda|->
name|getPart0000Immediately
argument_list|(
name|fs
argument_list|,
name|dir
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Identify any path under the directory which begins with the    * {@code "part-m-00000"} sequence. There's some compensation for    * eventual consistency here.    * @param fs FS to probe    * @param dir directory to scan    * @return the full path    * @throws FileNotFoundException the path is missing.    * @throws IOException failure.    */
DECL|method|getPart0000Immediately (FileSystem fs, Path dir)
specifier|private
name|Path
name|getPart0000Immediately
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Path
name|dir
parameter_list|)
throws|throws
name|IOException
block|{
name|FileStatus
index|[]
name|statuses
init|=
name|fs
operator|.
name|listStatus
argument_list|(
name|dir
argument_list|,
name|path
lambda|->
name|path
operator|.
name|getName
argument_list|()
operator|.
name|startsWith
argument_list|(
name|PART_00000
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|statuses
operator|.
name|length
operator|!=
literal|1
condition|)
block|{
comment|// fail, with a listing of the parent dir
name|ContractTestUtils
operator|.
name|assertPathExists
argument_list|(
name|fs
argument_list|,
literal|"Output file"
argument_list|,
operator|new
name|Path
argument_list|(
name|dir
argument_list|,
name|PART_00000
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|statuses
index|[
literal|0
index|]
operator|.
name|getPath
argument_list|()
return|;
block|}
comment|/**    * Look for the partFile subdir of the output dir.    * @param fs filesystem    * @param dir output dir    * @throws Exception failure.    */
DECL|method|validateMapFileOutputContent ( FileSystem fs, Path dir)
specifier|private
name|void
name|validateMapFileOutputContent
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Path
name|dir
parameter_list|)
throws|throws
name|Exception
block|{
comment|// map output is a directory with index and data files
name|assertPathExists
argument_list|(
literal|"Map output"
argument_list|,
name|dir
argument_list|)
expr_stmt|;
name|Path
name|expectedMapDir
init|=
name|getPart0000
argument_list|(
name|dir
argument_list|)
decl_stmt|;
name|assertPathExists
argument_list|(
literal|"Map output"
argument_list|,
name|expectedMapDir
argument_list|)
expr_stmt|;
name|assertIsDirectory
argument_list|(
name|expectedMapDir
argument_list|)
expr_stmt|;
name|FileStatus
index|[]
name|files
init|=
name|fs
operator|.
name|listStatus
argument_list|(
name|expectedMapDir
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
literal|"No files found in "
operator|+
name|expectedMapDir
argument_list|,
name|files
operator|.
name|length
operator|>
literal|0
argument_list|)
expr_stmt|;
name|assertPathExists
argument_list|(
literal|"index file in "
operator|+
name|expectedMapDir
argument_list|,
operator|new
name|Path
argument_list|(
name|expectedMapDir
argument_list|,
name|MapFile
operator|.
name|INDEX_FILE_NAME
argument_list|)
argument_list|)
expr_stmt|;
name|assertPathExists
argument_list|(
literal|"data file in "
operator|+
name|expectedMapDir
argument_list|,
operator|new
name|Path
argument_list|(
name|expectedMapDir
argument_list|,
name|MapFile
operator|.
name|DATA_FILE_NAME
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Dump all MPUs in the filesystem.    * @throws IOException IO failure    */
DECL|method|dumpMultipartUploads ()
specifier|protected
name|void
name|dumpMultipartUploads
parameter_list|()
throws|throws
name|IOException
block|{
name|countMultipartUploads
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
comment|/**    * Full test of the expected lifecycle: start job, task, write, commit task,    * commit job.    * @throws Exception on a failure    */
annotation|@
name|Test
DECL|method|testCommitLifecycle ()
specifier|public
name|void
name|testCommitLifecycle
parameter_list|()
throws|throws
name|Exception
block|{
name|describe
argument_list|(
literal|"Full test of the expected lifecycle:\n"
operator|+
literal|" start job, task, write, commit task, commit job.\n"
operator|+
literal|"Verify:\n"
operator|+
literal|"* no files are visible after task commit\n"
operator|+
literal|"* the expected file is visible after job commit\n"
operator|+
literal|"* no outstanding MPUs after job commit"
argument_list|)
expr_stmt|;
name|JobData
name|jobData
init|=
name|startJob
argument_list|(
literal|false
argument_list|)
decl_stmt|;
name|JobContext
name|jContext
init|=
name|jobData
operator|.
name|jContext
decl_stmt|;
name|TaskAttemptContext
name|tContext
init|=
name|jobData
operator|.
name|tContext
decl_stmt|;
name|AbstractS3ACommitter
name|committer
init|=
name|jobData
operator|.
name|committer
decl_stmt|;
name|validateTaskAttemptWorkingDirectory
argument_list|(
name|committer
argument_list|,
name|tContext
argument_list|)
expr_stmt|;
comment|// write output
name|describe
argument_list|(
literal|"1. Writing output"
argument_list|)
expr_stmt|;
name|writeTextOutput
argument_list|(
name|tContext
argument_list|)
expr_stmt|;
name|dumpMultipartUploads
argument_list|()
expr_stmt|;
name|describe
argument_list|(
literal|"2. Committing task"
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"No files to commit were found by "
operator|+
name|committer
argument_list|,
name|committer
operator|.
name|needsTaskCommit
argument_list|(
name|tContext
argument_list|)
argument_list|)
expr_stmt|;
name|commitTask
argument_list|(
name|committer
argument_list|,
name|tContext
argument_list|)
expr_stmt|;
comment|// this is only task commit; there MUST be no part- files in the dest dir
name|waitForConsistency
argument_list|()
expr_stmt|;
try|try
block|{
name|applyLocatedFiles
argument_list|(
name|getFileSystem
argument_list|()
operator|.
name|listFiles
argument_list|(
name|outDir
argument_list|,
literal|false
argument_list|)
argument_list|,
parameter_list|(
name|status
parameter_list|)
lambda|->
name|assertFalse
argument_list|(
literal|"task committed file to dest :"
operator|+
name|status
argument_list|,
name|status
operator|.
name|getPath
argument_list|()
operator|.
name|toString
argument_list|()
operator|.
name|contains
argument_list|(
literal|"part"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|ignored
parameter_list|)
block|{
name|log
argument_list|()
operator|.
name|info
argument_list|(
literal|"Outdir {} is not created by task commit phase "
argument_list|,
name|outDir
argument_list|)
expr_stmt|;
block|}
name|describe
argument_list|(
literal|"3. Committing job"
argument_list|)
expr_stmt|;
name|assertMultipartUploadsPending
argument_list|(
name|outDir
argument_list|)
expr_stmt|;
name|commitJob
argument_list|(
name|committer
argument_list|,
name|jContext
argument_list|)
expr_stmt|;
comment|// validate output
name|describe
argument_list|(
literal|"4. Validating content"
argument_list|)
expr_stmt|;
name|validateContent
argument_list|(
name|outDir
argument_list|,
name|shouldExpectSuccessMarker
argument_list|()
argument_list|)
expr_stmt|;
name|assertNoMultipartUploadsPending
argument_list|(
name|outDir
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testCommitterWithDuplicatedCommit ()
specifier|public
name|void
name|testCommitterWithDuplicatedCommit
parameter_list|()
throws|throws
name|Exception
block|{
name|describe
argument_list|(
literal|"Call a task then job commit twice;"
operator|+
literal|"expect the second task commit to fail."
argument_list|)
expr_stmt|;
name|JobData
name|jobData
init|=
name|startJob
argument_list|(
literal|true
argument_list|)
decl_stmt|;
name|JobContext
name|jContext
init|=
name|jobData
operator|.
name|jContext
decl_stmt|;
name|TaskAttemptContext
name|tContext
init|=
name|jobData
operator|.
name|tContext
decl_stmt|;
name|AbstractS3ACommitter
name|committer
init|=
name|jobData
operator|.
name|committer
decl_stmt|;
comment|// do commit
name|commit
argument_list|(
name|committer
argument_list|,
name|jContext
argument_list|,
name|tContext
argument_list|)
expr_stmt|;
comment|// validate output
name|validateContent
argument_list|(
name|outDir
argument_list|,
name|shouldExpectSuccessMarker
argument_list|()
argument_list|)
expr_stmt|;
name|assertNoMultipartUploadsPending
argument_list|(
name|outDir
argument_list|)
expr_stmt|;
comment|// commit task to fail on retry
name|expectFNFEonTaskCommit
argument_list|(
name|committer
argument_list|,
name|tContext
argument_list|)
expr_stmt|;
block|}
DECL|method|shouldExpectSuccessMarker ()
specifier|protected
name|boolean
name|shouldExpectSuccessMarker
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
comment|/**    * Simulate a failure on the first job commit; expect the    * second to succeed.    */
annotation|@
name|Test
DECL|method|testCommitterWithFailure ()
specifier|public
name|void
name|testCommitterWithFailure
parameter_list|()
throws|throws
name|Exception
block|{
name|describe
argument_list|(
literal|"Fail the first job commit then retry"
argument_list|)
expr_stmt|;
name|JobData
name|jobData
init|=
name|startJob
argument_list|(
operator|new
name|FailingCommitterFactory
argument_list|()
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|JobContext
name|jContext
init|=
name|jobData
operator|.
name|jContext
decl_stmt|;
name|TaskAttemptContext
name|tContext
init|=
name|jobData
operator|.
name|tContext
decl_stmt|;
name|AbstractS3ACommitter
name|committer
init|=
name|jobData
operator|.
name|committer
decl_stmt|;
comment|// do commit
name|committer
operator|.
name|commitTask
argument_list|(
name|tContext
argument_list|)
expr_stmt|;
comment|// now fail job
name|expectSimulatedFailureOnJobCommit
argument_list|(
name|jContext
argument_list|,
name|committer
argument_list|)
expr_stmt|;
name|commitJob
argument_list|(
name|committer
argument_list|,
name|jContext
argument_list|)
expr_stmt|;
comment|// but the data got there, due to the order of operations.
name|validateContent
argument_list|(
name|outDir
argument_list|,
name|shouldExpectSuccessMarker
argument_list|()
argument_list|)
expr_stmt|;
name|expectJobCommitToFail
argument_list|(
name|jContext
argument_list|,
name|committer
argument_list|)
expr_stmt|;
block|}
comment|/**    * Override point: the failure expected on the attempt to commit a failed    * job.    * @param jContext job context    * @param committer committer    * @throws Exception any unexpected failure.    */
DECL|method|expectJobCommitToFail (JobContext jContext, AbstractS3ACommitter committer)
specifier|protected
name|void
name|expectJobCommitToFail
parameter_list|(
name|JobContext
name|jContext
parameter_list|,
name|AbstractS3ACommitter
name|committer
parameter_list|)
throws|throws
name|Exception
block|{
comment|// next attempt will fail as there is no longer a directory to commit
name|expectJobCommitFailure
argument_list|(
name|jContext
argument_list|,
name|committer
argument_list|,
name|FileNotFoundException
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
comment|/**    * Expect a job commit operation to fail with a specific exception.    * @param jContext job context    * @param committer committer    * @param clazz class of exception    * @return the caught exception    * @throws Exception any unexpected failure.    */
DECL|method|expectJobCommitFailure ( JobContext jContext, AbstractS3ACommitter committer, Class<E> clazz)
specifier|protected
specifier|static
parameter_list|<
name|E
extends|extends
name|IOException
parameter_list|>
name|E
name|expectJobCommitFailure
parameter_list|(
name|JobContext
name|jContext
parameter_list|,
name|AbstractS3ACommitter
name|committer
parameter_list|,
name|Class
argument_list|<
name|E
argument_list|>
name|clazz
parameter_list|)
throws|throws
name|Exception
block|{
return|return
name|intercept
argument_list|(
name|clazz
argument_list|,
parameter_list|()
lambda|->
block|{
name|committer
operator|.
name|commitJob
argument_list|(
name|jContext
argument_list|)
expr_stmt|;
return|return
name|committer
operator|.
name|toString
argument_list|()
return|;
block|}
argument_list|)
return|;
block|}
DECL|method|expectFNFEonTaskCommit ( AbstractS3ACommitter committer, TaskAttemptContext tContext)
specifier|protected
specifier|static
name|void
name|expectFNFEonTaskCommit
parameter_list|(
name|AbstractS3ACommitter
name|committer
parameter_list|,
name|TaskAttemptContext
name|tContext
parameter_list|)
throws|throws
name|Exception
block|{
name|intercept
argument_list|(
name|FileNotFoundException
operator|.
name|class
argument_list|,
parameter_list|()
lambda|->
block|{
name|committer
operator|.
name|commitTask
argument_list|(
name|tContext
argument_list|)
expr_stmt|;
return|return
name|committer
operator|.
name|toString
argument_list|()
return|;
block|}
argument_list|)
expr_stmt|;
block|}
comment|/**    * Simulate a failure on the first job commit; expect the    * second to succeed.    */
annotation|@
name|Test
DECL|method|testCommitterWithNoOutputs ()
specifier|public
name|void
name|testCommitterWithNoOutputs
parameter_list|()
throws|throws
name|Exception
block|{
name|describe
argument_list|(
literal|"Have a task and job with no outputs: expect success"
argument_list|)
expr_stmt|;
name|JobData
name|jobData
init|=
name|startJob
argument_list|(
operator|new
name|FailingCommitterFactory
argument_list|()
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|TaskAttemptContext
name|tContext
init|=
name|jobData
operator|.
name|tContext
decl_stmt|;
name|AbstractS3ACommitter
name|committer
init|=
name|jobData
operator|.
name|committer
decl_stmt|;
comment|// do commit
name|committer
operator|.
name|commitTask
argument_list|(
name|tContext
argument_list|)
expr_stmt|;
name|assertTaskAttemptPathDoesNotExist
argument_list|(
name|committer
argument_list|,
name|tContext
argument_list|)
expr_stmt|;
block|}
DECL|method|expectSimulatedFailureOnJobCommit (JobContext jContext, AbstractS3ACommitter committer)
specifier|protected
specifier|static
name|void
name|expectSimulatedFailureOnJobCommit
parameter_list|(
name|JobContext
name|jContext
parameter_list|,
name|AbstractS3ACommitter
name|committer
parameter_list|)
throws|throws
name|Exception
block|{
operator|(
operator|(
name|CommitterFaultInjection
operator|)
name|committer
operator|)
operator|.
name|setFaults
argument_list|(
name|CommitterFaultInjection
operator|.
name|Faults
operator|.
name|commitJob
argument_list|)
expr_stmt|;
name|expectJobCommitFailure
argument_list|(
name|jContext
argument_list|,
name|committer
argument_list|,
name|CommitterFaultInjectionImpl
operator|.
name|Failure
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testMapFileOutputCommitter ()
specifier|public
name|void
name|testMapFileOutputCommitter
parameter_list|()
throws|throws
name|Exception
block|{
name|describe
argument_list|(
literal|"Test that the committer generates map output into a directory\n"
operator|+
literal|"starting with the prefix part-"
argument_list|)
expr_stmt|;
name|JobData
name|jobData
init|=
name|startJob
argument_list|(
literal|false
argument_list|)
decl_stmt|;
name|JobContext
name|jContext
init|=
name|jobData
operator|.
name|jContext
decl_stmt|;
name|TaskAttemptContext
name|tContext
init|=
name|jobData
operator|.
name|tContext
decl_stmt|;
name|AbstractS3ACommitter
name|committer
init|=
name|jobData
operator|.
name|committer
decl_stmt|;
name|Configuration
name|conf
init|=
name|jobData
operator|.
name|conf
decl_stmt|;
comment|// write output
name|writeMapFileOutput
argument_list|(
operator|new
name|MapFileOutputFormat
argument_list|()
operator|.
name|getRecordWriter
argument_list|(
name|tContext
argument_list|)
argument_list|,
name|tContext
argument_list|)
expr_stmt|;
comment|// do commit
name|commit
argument_list|(
name|committer
argument_list|,
name|jContext
argument_list|,
name|tContext
argument_list|)
expr_stmt|;
name|S3AFileSystem
name|fs
init|=
name|getFileSystem
argument_list|()
decl_stmt|;
name|waitForConsistency
argument_list|()
expr_stmt|;
name|lsR
argument_list|(
name|fs
argument_list|,
name|outDir
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|String
name|ls
init|=
name|ls
argument_list|(
name|outDir
argument_list|)
decl_stmt|;
name|describe
argument_list|(
literal|"\nvalidating"
argument_list|)
expr_stmt|;
comment|// validate output
name|verifySuccessMarker
argument_list|(
name|outDir
argument_list|)
expr_stmt|;
name|describe
argument_list|(
literal|"validate output of %s"
argument_list|,
name|outDir
argument_list|)
expr_stmt|;
name|validateMapFileOutputContent
argument_list|(
name|fs
argument_list|,
name|outDir
argument_list|)
expr_stmt|;
comment|// Ensure getReaders call works and also ignores
comment|// hidden filenames (_ or . prefixes)
name|describe
argument_list|(
literal|"listing"
argument_list|)
expr_stmt|;
name|FileStatus
index|[]
name|filtered
init|=
name|fs
operator|.
name|listStatus
argument_list|(
name|outDir
argument_list|,
name|HIDDEN_FILE_FILTER
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|"listed children under "
operator|+
name|ls
argument_list|,
literal|1
argument_list|,
name|filtered
operator|.
name|length
argument_list|)
expr_stmt|;
name|FileStatus
name|fileStatus
init|=
name|filtered
index|[
literal|0
index|]
decl_stmt|;
name|assertTrue
argument_list|(
literal|"Not the part file: "
operator|+
name|fileStatus
argument_list|,
name|fileStatus
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|startsWith
argument_list|(
name|PART_00000
argument_list|)
argument_list|)
expr_stmt|;
name|describe
argument_list|(
literal|"getReaders()"
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Number of MapFile.Reader entries with shared FS "
operator|+
name|outDir
operator|+
literal|" : "
operator|+
name|ls
argument_list|,
literal|1
argument_list|,
name|getReaders
argument_list|(
name|fs
argument_list|,
name|outDir
argument_list|,
name|conf
argument_list|)
operator|.
name|length
argument_list|)
expr_stmt|;
name|describe
argument_list|(
literal|"getReaders(new FS)"
argument_list|)
expr_stmt|;
name|FileSystem
name|fs2
init|=
name|FileSystem
operator|.
name|get
argument_list|(
name|outDir
operator|.
name|toUri
argument_list|()
argument_list|,
name|conf
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|"Number of MapFile.Reader entries with shared FS2 "
operator|+
name|outDir
operator|+
literal|" : "
operator|+
name|ls
argument_list|,
literal|1
argument_list|,
name|getReaders
argument_list|(
name|fs2
argument_list|,
name|outDir
argument_list|,
name|conf
argument_list|)
operator|.
name|length
argument_list|)
expr_stmt|;
name|describe
argument_list|(
literal|"MapFileOutputFormat.getReaders"
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Number of MapFile.Reader entries with new FS in "
operator|+
name|outDir
operator|+
literal|" : "
operator|+
name|ls
argument_list|,
literal|1
argument_list|,
name|MapFileOutputFormat
operator|.
name|getReaders
argument_list|(
name|outDir
argument_list|,
name|conf
argument_list|)
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
comment|/** Open the output generated by this format. */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"IOResourceOpenedButNotSafelyClosed"
argument_list|)
DECL|method|getReaders (FileSystem fs, Path dir, Configuration conf)
specifier|private
specifier|static
name|MapFile
operator|.
name|Reader
index|[]
name|getReaders
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Path
name|dir
parameter_list|,
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|Path
index|[]
name|names
init|=
name|FileUtil
operator|.
name|stat2Paths
argument_list|(
name|fs
operator|.
name|listStatus
argument_list|(
name|dir
argument_list|,
name|HIDDEN_FILE_FILTER
argument_list|)
argument_list|)
decl_stmt|;
comment|// sort names, so that hash partitioning works
name|Arrays
operator|.
name|sort
argument_list|(
name|names
argument_list|)
expr_stmt|;
name|MapFile
operator|.
name|Reader
index|[]
name|parts
init|=
operator|new
name|MapFile
operator|.
name|Reader
index|[
name|names
operator|.
name|length
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|names
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|parts
index|[
name|i
index|]
operator|=
operator|new
name|MapFile
operator|.
name|Reader
argument_list|(
name|names
index|[
name|i
index|]
argument_list|,
name|conf
argument_list|)
expr_stmt|;
block|}
return|return
name|parts
return|;
block|}
comment|/**    * A functional interface which an action to test must implement.    */
annotation|@
name|FunctionalInterface
DECL|interface|ActionToTest
specifier|public
interface|interface
name|ActionToTest
block|{
DECL|method|exec (Job job, JobContext jContext, TaskAttemptContext tContext, AbstractS3ACommitter committer)
name|void
name|exec
parameter_list|(
name|Job
name|job
parameter_list|,
name|JobContext
name|jContext
parameter_list|,
name|TaskAttemptContext
name|tContext
parameter_list|,
name|AbstractS3ACommitter
name|committer
parameter_list|)
throws|throws
name|Exception
function_decl|;
block|}
annotation|@
name|Test
DECL|method|testAbortTaskNoWorkDone ()
specifier|public
name|void
name|testAbortTaskNoWorkDone
parameter_list|()
throws|throws
name|Exception
block|{
name|executeWork
argument_list|(
literal|"abort task no work"
argument_list|,
parameter_list|(
name|job
parameter_list|,
name|jContext
parameter_list|,
name|tContext
parameter_list|,
name|committer
parameter_list|)
lambda|->
name|committer
operator|.
name|abortTask
argument_list|(
name|tContext
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testAbortJobNoWorkDone ()
specifier|public
name|void
name|testAbortJobNoWorkDone
parameter_list|()
throws|throws
name|Exception
block|{
name|executeWork
argument_list|(
literal|"abort task no work"
argument_list|,
parameter_list|(
name|job
parameter_list|,
name|jContext
parameter_list|,
name|tContext
parameter_list|,
name|committer
parameter_list|)
lambda|->
name|committer
operator|.
name|abortJob
argument_list|(
name|jContext
argument_list|,
name|JobStatus
operator|.
name|State
operator|.
name|RUNNING
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testCommitJobButNotTask ()
specifier|public
name|void
name|testCommitJobButNotTask
parameter_list|()
throws|throws
name|Exception
block|{
name|executeWork
argument_list|(
literal|"commit a job while a task's work is pending, "
operator|+
literal|"expect task writes to be cancelled."
argument_list|,
parameter_list|(
name|job
parameter_list|,
name|jContext
parameter_list|,
name|tContext
parameter_list|,
name|committer
parameter_list|)
lambda|->
block|{
comment|// step 1: write the text
name|writeTextOutput
argument_list|(
name|tContext
argument_list|)
expr_stmt|;
comment|// step 2: commit the job
name|createCommitter
argument_list|(
name|tContext
argument_list|)
operator|.
name|commitJob
argument_list|(
name|tContext
argument_list|)
expr_stmt|;
comment|// verify that no output can be observed
name|assertPart0000DoesNotExist
argument_list|(
name|outDir
argument_list|)
expr_stmt|;
comment|// that includes, no pending MPUs; commitJob is expected to
comment|// cancel any.
name|assertNoMultipartUploadsPending
argument_list|(
name|outDir
argument_list|)
expr_stmt|;
block|}
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testAbortTaskThenJob ()
specifier|public
name|void
name|testAbortTaskThenJob
parameter_list|()
throws|throws
name|Exception
block|{
name|JobData
name|jobData
init|=
name|startJob
argument_list|(
literal|true
argument_list|)
decl_stmt|;
name|AbstractS3ACommitter
name|committer
init|=
name|jobData
operator|.
name|committer
decl_stmt|;
comment|// do abort
name|committer
operator|.
name|abortTask
argument_list|(
name|jobData
operator|.
name|tContext
argument_list|)
expr_stmt|;
name|intercept
argument_list|(
name|FileNotFoundException
operator|.
name|class
argument_list|,
literal|""
argument_list|,
parameter_list|()
lambda|->
name|getPart0000
argument_list|(
name|committer
operator|.
name|getWorkPath
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|committer
operator|.
name|abortJob
argument_list|(
name|jobData
operator|.
name|jContext
argument_list|,
name|JobStatus
operator|.
name|State
operator|.
name|FAILED
argument_list|)
expr_stmt|;
name|assertJobAbortCleanedUp
argument_list|(
name|jobData
argument_list|)
expr_stmt|;
name|verifyCommitterHasNoThreads
argument_list|(
name|committer
argument_list|)
expr_stmt|;
block|}
comment|/**    * Extension point: assert that the job was all cleaned up after an abort.    * Base assertions    *<ul>    *<li>Output dir is absent or, if present, empty</li>    *<li>No pending MPUs to/under the output dir</li>    *</ul>    * @param jobData job data    * @throws Exception failure    */
DECL|method|assertJobAbortCleanedUp (JobData jobData)
specifier|public
name|void
name|assertJobAbortCleanedUp
parameter_list|(
name|JobData
name|jobData
parameter_list|)
throws|throws
name|Exception
block|{
comment|// special handling of magic directory; harmless in staging
name|S3AFileSystem
name|fs
init|=
name|getFileSystem
argument_list|()
decl_stmt|;
try|try
block|{
name|FileStatus
index|[]
name|children
init|=
name|listChildren
argument_list|(
name|fs
argument_list|,
name|outDir
argument_list|)
decl_stmt|;
if|if
condition|(
name|children
operator|.
name|length
operator|!=
literal|0
condition|)
block|{
name|lsR
argument_list|(
name|fs
argument_list|,
name|outDir
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
name|assertArrayEquals
argument_list|(
literal|"Output directory not empty "
operator|+
name|ls
argument_list|(
name|outDir
argument_list|)
argument_list|,
operator|new
name|FileStatus
index|[
literal|0
index|]
argument_list|,
name|children
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|e
parameter_list|)
block|{
comment|// this is a valid failure mode; it means the dest dir doesn't exist yet.
block|}
name|assertNoMultipartUploadsPending
argument_list|(
name|outDir
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testFailAbort ()
specifier|public
name|void
name|testFailAbort
parameter_list|()
throws|throws
name|Exception
block|{
name|describe
argument_list|(
literal|"Abort the task, then job (failed), abort the job again"
argument_list|)
expr_stmt|;
name|JobData
name|jobData
init|=
name|startJob
argument_list|(
literal|true
argument_list|)
decl_stmt|;
name|JobContext
name|jContext
init|=
name|jobData
operator|.
name|jContext
decl_stmt|;
name|TaskAttemptContext
name|tContext
init|=
name|jobData
operator|.
name|tContext
decl_stmt|;
name|AbstractS3ACommitter
name|committer
init|=
name|jobData
operator|.
name|committer
decl_stmt|;
comment|// do abort
name|committer
operator|.
name|abortTask
argument_list|(
name|tContext
argument_list|)
expr_stmt|;
name|committer
operator|.
name|getJobAttemptPath
argument_list|(
name|jContext
argument_list|)
expr_stmt|;
name|committer
operator|.
name|getTaskAttemptPath
argument_list|(
name|tContext
argument_list|)
expr_stmt|;
name|assertPart0000DoesNotExist
argument_list|(
name|outDir
argument_list|)
expr_stmt|;
name|assertSuccessMarkerDoesNotExist
argument_list|(
name|outDir
argument_list|)
expr_stmt|;
name|describe
argument_list|(
literal|"Aborting job into %s"
argument_list|,
name|outDir
argument_list|)
expr_stmt|;
name|committer
operator|.
name|abortJob
argument_list|(
name|jContext
argument_list|,
name|JobStatus
operator|.
name|State
operator|.
name|FAILED
argument_list|)
expr_stmt|;
name|assertTaskAttemptPathDoesNotExist
argument_list|(
name|committer
argument_list|,
name|tContext
argument_list|)
expr_stmt|;
name|assertJobAttemptPathDoesNotExist
argument_list|(
name|committer
argument_list|,
name|jContext
argument_list|)
expr_stmt|;
comment|// try again; expect abort to be idempotent.
name|committer
operator|.
name|abortJob
argument_list|(
name|jContext
argument_list|,
name|JobStatus
operator|.
name|State
operator|.
name|FAILED
argument_list|)
expr_stmt|;
name|assertNoMultipartUploadsPending
argument_list|(
name|outDir
argument_list|)
expr_stmt|;
name|verifyCommitterHasNoThreads
argument_list|(
name|committer
argument_list|)
expr_stmt|;
block|}
DECL|method|assertPart0000DoesNotExist (Path dir)
specifier|public
name|void
name|assertPart0000DoesNotExist
parameter_list|(
name|Path
name|dir
parameter_list|)
throws|throws
name|Exception
block|{
name|intercept
argument_list|(
name|FileNotFoundException
operator|.
name|class
argument_list|,
parameter_list|()
lambda|->
name|getPart0000
argument_list|(
name|dir
argument_list|)
argument_list|)
expr_stmt|;
name|assertPathDoesNotExist
argument_list|(
literal|"expected output file"
argument_list|,
operator|new
name|Path
argument_list|(
name|dir
argument_list|,
name|PART_00000
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testAbortJobNotTask ()
specifier|public
name|void
name|testAbortJobNotTask
parameter_list|()
throws|throws
name|Exception
block|{
name|executeWork
argument_list|(
literal|"abort task no work"
argument_list|,
parameter_list|(
name|job
parameter_list|,
name|jContext
parameter_list|,
name|tContext
parameter_list|,
name|committer
parameter_list|)
lambda|->
block|{
comment|// write output
name|writeTextOutput
argument_list|(
name|tContext
argument_list|)
expr_stmt|;
name|committer
operator|.
name|abortJob
argument_list|(
name|jContext
argument_list|,
name|JobStatus
operator|.
name|State
operator|.
name|RUNNING
argument_list|)
expr_stmt|;
name|assertTaskAttemptPathDoesNotExist
argument_list|(
name|committer
argument_list|,
name|tContext
argument_list|)
expr_stmt|;
name|assertJobAttemptPathDoesNotExist
argument_list|(
name|committer
argument_list|,
name|jContext
argument_list|)
expr_stmt|;
name|assertNoMultipartUploadsPending
argument_list|(
name|outDir
argument_list|)
expr_stmt|;
block|}
argument_list|)
expr_stmt|;
block|}
comment|/**    * This looks at what happens with concurrent commits.    * However, the failure condition it looks for (subdir under subdir)    * is the kind of failure you see on a rename-based commit.    *    * What it will not detect is the fact that both tasks will each commit    * to the destination directory. That is: whichever commits last wins.    *    * There's no way to stop this. Instead it is a requirement that the task    * commit operation is only executed when the committer is happy to    * commit only those tasks which it knows have succeeded, and abort those    * which have not.    * @throws Exception failure    */
annotation|@
name|Test
DECL|method|testConcurrentCommitTaskWithSubDir ()
specifier|public
name|void
name|testConcurrentCommitTaskWithSubDir
parameter_list|()
throws|throws
name|Exception
block|{
name|Job
name|job
init|=
name|newJob
argument_list|()
decl_stmt|;
name|FileOutputFormat
operator|.
name|setOutputPath
argument_list|(
name|job
argument_list|,
name|outDir
argument_list|)
expr_stmt|;
specifier|final
name|Configuration
name|conf
init|=
name|job
operator|.
name|getConfiguration
argument_list|()
decl_stmt|;
specifier|final
name|JobContext
name|jContext
init|=
operator|new
name|JobContextImpl
argument_list|(
name|conf
argument_list|,
name|taskAttempt0
operator|.
name|getJobID
argument_list|()
argument_list|)
decl_stmt|;
name|AbstractS3ACommitter
name|amCommitter
init|=
name|createCommitter
argument_list|(
operator|new
name|TaskAttemptContextImpl
argument_list|(
name|conf
argument_list|,
name|taskAttempt0
argument_list|)
argument_list|)
decl_stmt|;
name|amCommitter
operator|.
name|setupJob
argument_list|(
name|jContext
argument_list|)
expr_stmt|;
specifier|final
name|TaskAttemptContext
index|[]
name|taCtx
init|=
operator|new
name|TaskAttemptContextImpl
index|[
literal|2
index|]
decl_stmt|;
name|taCtx
index|[
literal|0
index|]
operator|=
operator|new
name|TaskAttemptContextImpl
argument_list|(
name|conf
argument_list|,
name|taskAttempt0
argument_list|)
expr_stmt|;
name|taCtx
index|[
literal|1
index|]
operator|=
operator|new
name|TaskAttemptContextImpl
argument_list|(
name|conf
argument_list|,
name|taskAttempt1
argument_list|)
expr_stmt|;
specifier|final
name|TextOutputFormat
index|[]
name|tof
init|=
operator|new
name|LoggingTextOutputFormat
index|[
literal|2
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|tof
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|tof
index|[
name|i
index|]
operator|=
operator|new
name|LoggingTextOutputFormat
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Path
name|getDefaultWorkFile
parameter_list|(
name|TaskAttemptContext
name|context
parameter_list|,
name|String
name|extension
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|AbstractS3ACommitter
name|foc
init|=
operator|(
name|AbstractS3ACommitter
operator|)
name|getOutputCommitter
argument_list|(
name|context
argument_list|)
decl_stmt|;
return|return
operator|new
name|Path
argument_list|(
operator|new
name|Path
argument_list|(
name|foc
operator|.
name|getWorkPath
argument_list|()
argument_list|,
name|SUB_DIR
argument_list|)
argument_list|,
name|getUniqueFile
argument_list|(
name|context
argument_list|,
name|getOutputName
argument_list|(
name|context
argument_list|)
argument_list|,
name|extension
argument_list|)
argument_list|)
return|;
block|}
block|}
expr_stmt|;
block|}
specifier|final
name|ExecutorService
name|executor
init|=
name|HadoopExecutors
operator|.
name|newFixedThreadPool
argument_list|(
literal|2
argument_list|)
decl_stmt|;
try|try
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|taCtx
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|int
name|taskIdx
init|=
name|i
decl_stmt|;
name|executor
operator|.
name|submit
argument_list|(
parameter_list|()
lambda|->
block|{
specifier|final
name|OutputCommitter
name|outputCommitter
init|=
name|tof
index|[
name|taskIdx
index|]
operator|.
name|getOutputCommitter
argument_list|(
name|taCtx
index|[
name|taskIdx
index|]
argument_list|)
decl_stmt|;
name|outputCommitter
operator|.
name|setupTask
argument_list|(
name|taCtx
index|[
name|taskIdx
index|]
argument_list|)
expr_stmt|;
specifier|final
name|RecordWriter
name|rw
init|=
name|tof
index|[
name|taskIdx
index|]
operator|.
name|getRecordWriter
argument_list|(
name|taCtx
index|[
name|taskIdx
index|]
argument_list|)
decl_stmt|;
name|writeOutput
argument_list|(
name|rw
argument_list|,
name|taCtx
index|[
name|taskIdx
index|]
argument_list|)
expr_stmt|;
name|describe
argument_list|(
literal|"Committing Task %d"
argument_list|,
name|taskIdx
argument_list|)
expr_stmt|;
name|outputCommitter
operator|.
name|commitTask
argument_list|(
name|taCtx
index|[
name|taskIdx
index|]
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|executor
operator|.
name|shutdown
argument_list|()
expr_stmt|;
while|while
condition|(
operator|!
name|executor
operator|.
name|awaitTermination
argument_list|(
literal|1
argument_list|,
name|TimeUnit
operator|.
name|SECONDS
argument_list|)
condition|)
block|{
name|log
argument_list|()
operator|.
name|info
argument_list|(
literal|"Awaiting thread termination!"
argument_list|)
expr_stmt|;
block|}
block|}
comment|// if we commit here then all tasks will be committed, so there will
comment|// be contention for that final directory: both parts will go in.
name|describe
argument_list|(
literal|"\nCommitting Job"
argument_list|)
expr_stmt|;
name|amCommitter
operator|.
name|commitJob
argument_list|(
name|jContext
argument_list|)
expr_stmt|;
name|assertPathExists
argument_list|(
literal|"base output directory"
argument_list|,
name|outDir
argument_list|)
expr_stmt|;
name|assertPart0000DoesNotExist
argument_list|(
name|outDir
argument_list|)
expr_stmt|;
name|Path
name|outSubDir
init|=
operator|new
name|Path
argument_list|(
name|outDir
argument_list|,
name|SUB_DIR
argument_list|)
decl_stmt|;
name|assertPathDoesNotExist
argument_list|(
literal|"Must not end up with sub_dir/sub_dir"
argument_list|,
operator|new
name|Path
argument_list|(
name|outSubDir
argument_list|,
name|SUB_DIR
argument_list|)
argument_list|)
expr_stmt|;
comment|// validate output
comment|// There's no success marker in the subdirectory
name|validateContent
argument_list|(
name|outSubDir
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/**    * Create a committer which fails; the class    * {@link CommitterFaultInjectionImpl} implements the logic.    * @param tContext task context    * @return committer instance    * @throws IOException failure to instantiate    */
DECL|method|createFailingCommitter ( TaskAttemptContext tContext)
specifier|protected
specifier|abstract
name|AbstractS3ACommitter
name|createFailingCommitter
parameter_list|(
name|TaskAttemptContext
name|tContext
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/**    * Factory for failing committers.    */
DECL|class|FailingCommitterFactory
specifier|public
class|class
name|FailingCommitterFactory
implements|implements
name|CommitterFactory
block|{
annotation|@
name|Override
DECL|method|createCommitter (TaskAttemptContext context)
specifier|public
name|AbstractS3ACommitter
name|createCommitter
parameter_list|(
name|TaskAttemptContext
name|context
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|createFailingCommitter
argument_list|(
name|context
argument_list|)
return|;
block|}
block|}
annotation|@
name|Test
DECL|method|testOutputFormatIntegration ()
specifier|public
name|void
name|testOutputFormatIntegration
parameter_list|()
throws|throws
name|Throwable
block|{
name|Configuration
name|conf
init|=
name|getConfiguration
argument_list|()
decl_stmt|;
name|Job
name|job
init|=
name|newJob
argument_list|()
decl_stmt|;
name|job
operator|.
name|setOutputFormatClass
argument_list|(
name|LoggingTextOutputFormat
operator|.
name|class
argument_list|)
expr_stmt|;
name|conf
operator|=
name|job
operator|.
name|getConfiguration
argument_list|()
expr_stmt|;
name|conf
operator|.
name|set
argument_list|(
name|MRJobConfig
operator|.
name|TASK_ATTEMPT_ID
argument_list|,
name|attempt0
argument_list|)
expr_stmt|;
name|conf
operator|.
name|setInt
argument_list|(
name|MRJobConfig
operator|.
name|APPLICATION_ATTEMPT_ID
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|JobContext
name|jContext
init|=
operator|new
name|JobContextImpl
argument_list|(
name|conf
argument_list|,
name|taskAttempt0
operator|.
name|getJobID
argument_list|()
argument_list|)
decl_stmt|;
name|TaskAttemptContext
name|tContext
init|=
operator|new
name|TaskAttemptContextImpl
argument_list|(
name|conf
argument_list|,
name|taskAttempt0
argument_list|)
decl_stmt|;
name|LoggingTextOutputFormat
name|outputFormat
init|=
operator|(
name|LoggingTextOutputFormat
operator|)
name|ReflectionUtils
operator|.
name|newInstance
argument_list|(
name|tContext
operator|.
name|getOutputFormatClass
argument_list|()
argument_list|,
name|conf
argument_list|)
decl_stmt|;
name|AbstractS3ACommitter
name|committer
init|=
operator|(
name|AbstractS3ACommitter
operator|)
name|outputFormat
operator|.
name|getOutputCommitter
argument_list|(
name|tContext
argument_list|)
decl_stmt|;
comment|// setup
name|JobData
name|jobData
init|=
operator|new
name|JobData
argument_list|(
name|job
argument_list|,
name|jContext
argument_list|,
name|tContext
argument_list|,
name|committer
argument_list|)
decl_stmt|;
name|setup
argument_list|(
name|jobData
argument_list|)
expr_stmt|;
name|abortInTeardown
argument_list|(
name|jobData
argument_list|)
expr_stmt|;
name|LoggingTextOutputFormat
operator|.
name|LoggingLineRecordWriter
name|recordWriter
init|=
name|outputFormat
operator|.
name|getRecordWriter
argument_list|(
name|tContext
argument_list|)
decl_stmt|;
name|IntWritable
name|iw
init|=
operator|new
name|IntWritable
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|recordWriter
operator|.
name|write
argument_list|(
name|iw
argument_list|,
name|iw
argument_list|)
expr_stmt|;
name|Path
name|dest
init|=
name|recordWriter
operator|.
name|getDest
argument_list|()
decl_stmt|;
name|validateTaskAttemptPathDuringWrite
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|recordWriter
operator|.
name|close
argument_list|(
name|tContext
argument_list|)
expr_stmt|;
comment|// at this point
name|validateTaskAttemptPathAfterWrite
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"Committer does not have data to commit "
operator|+
name|committer
argument_list|,
name|committer
operator|.
name|needsTaskCommit
argument_list|(
name|tContext
argument_list|)
argument_list|)
expr_stmt|;
name|commitTask
argument_list|(
name|committer
argument_list|,
name|tContext
argument_list|)
expr_stmt|;
name|commitJob
argument_list|(
name|committer
argument_list|,
name|jContext
argument_list|)
expr_stmt|;
comment|// validate output
name|verifySuccessMarker
argument_list|(
name|outDir
argument_list|)
expr_stmt|;
block|}
comment|/**    * Create a committer through reflection then use it to abort    * a task. This mimics the action of an AM when a container fails and    * the AM wants to abort the task attempt.    */
annotation|@
name|Test
DECL|method|testAMWorkflow ()
specifier|public
name|void
name|testAMWorkflow
parameter_list|()
throws|throws
name|Throwable
block|{
name|describe
argument_list|(
literal|"Create a committer with a null output path& use as an AM"
argument_list|)
expr_stmt|;
name|JobData
name|jobData
init|=
name|startJob
argument_list|(
literal|true
argument_list|)
decl_stmt|;
name|JobContext
name|jContext
init|=
name|jobData
operator|.
name|jContext
decl_stmt|;
name|TaskAttemptContext
name|tContext
init|=
name|jobData
operator|.
name|tContext
decl_stmt|;
name|TaskAttemptContext
name|newAttempt
init|=
name|taskAttemptForJob
argument_list|(
name|MRBuilderUtils
operator|.
name|newJobId
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
argument_list|,
name|jContext
argument_list|)
decl_stmt|;
name|Configuration
name|conf
init|=
name|jContext
operator|.
name|getConfiguration
argument_list|()
decl_stmt|;
comment|// bind
name|LoggingTextOutputFormat
operator|.
name|bind
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|OutputFormat
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|outputFormat
init|=
name|ReflectionUtils
operator|.
name|newInstance
argument_list|(
name|newAttempt
operator|.
name|getOutputFormatClass
argument_list|()
argument_list|,
name|conf
argument_list|)
decl_stmt|;
name|Path
name|outputPath
init|=
name|FileOutputFormat
operator|.
name|getOutputPath
argument_list|(
name|newAttempt
argument_list|)
decl_stmt|;
name|assertNotNull
argument_list|(
literal|"null output path in new task attempt"
argument_list|,
name|outputPath
argument_list|)
expr_stmt|;
name|AbstractS3ACommitter
name|committer2
init|=
operator|(
name|AbstractS3ACommitter
operator|)
name|outputFormat
operator|.
name|getOutputCommitter
argument_list|(
name|newAttempt
argument_list|)
decl_stmt|;
name|committer2
operator|.
name|abortTask
argument_list|(
name|tContext
argument_list|)
expr_stmt|;
name|verifyCommitterHasNoThreads
argument_list|(
name|committer2
argument_list|)
expr_stmt|;
name|assertNoMultipartUploadsPending
argument_list|(
name|getOutDir
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testParallelJobsToAdjacentPaths ()
specifier|public
name|void
name|testParallelJobsToAdjacentPaths
parameter_list|()
throws|throws
name|Throwable
block|{
name|describe
argument_list|(
literal|"Run two jobs in parallel, assert they both complete"
argument_list|)
expr_stmt|;
name|JobData
name|jobData
init|=
name|startJob
argument_list|(
literal|true
argument_list|)
decl_stmt|;
name|Job
name|job1
init|=
name|jobData
operator|.
name|job
decl_stmt|;
name|AbstractS3ACommitter
name|committer1
init|=
name|jobData
operator|.
name|committer
decl_stmt|;
name|JobContext
name|jContext1
init|=
name|jobData
operator|.
name|jContext
decl_stmt|;
name|TaskAttemptContext
name|tContext1
init|=
name|jobData
operator|.
name|tContext
decl_stmt|;
comment|// now build up a second job
name|String
name|jobId2
init|=
name|randomJobId
argument_list|()
decl_stmt|;
name|String
name|attempt20
init|=
literal|"attempt_"
operator|+
name|jobId2
operator|+
literal|"_m_000000_0"
decl_stmt|;
name|TaskAttemptID
name|taskAttempt20
init|=
name|TaskAttemptID
operator|.
name|forName
argument_list|(
name|attempt20
argument_list|)
decl_stmt|;
name|String
name|attempt21
init|=
literal|"attempt_"
operator|+
name|jobId2
operator|+
literal|"_m_000001_0"
decl_stmt|;
name|TaskAttemptID
name|taskAttempt21
init|=
name|TaskAttemptID
operator|.
name|forName
argument_list|(
name|attempt21
argument_list|)
decl_stmt|;
name|Path
name|job1Dest
init|=
name|outDir
decl_stmt|;
name|Path
name|job2Dest
init|=
operator|new
name|Path
argument_list|(
name|getOutDir
argument_list|()
operator|.
name|getParent
argument_list|()
argument_list|,
name|getMethodName
argument_list|()
operator|+
literal|"job2Dest"
argument_list|)
decl_stmt|;
comment|// little safety check
name|assertNotEquals
argument_list|(
name|job1Dest
argument_list|,
name|job2Dest
argument_list|)
expr_stmt|;
comment|// create the second job
name|Job
name|job2
init|=
name|newJob
argument_list|(
name|job2Dest
argument_list|,
operator|new
name|JobConf
argument_list|(
name|getConfiguration
argument_list|()
argument_list|)
argument_list|,
name|attempt20
argument_list|)
decl_stmt|;
name|Configuration
name|conf2
init|=
name|job2
operator|.
name|getConfiguration
argument_list|()
decl_stmt|;
name|conf2
operator|.
name|setInt
argument_list|(
name|MRJobConfig
operator|.
name|APPLICATION_ATTEMPT_ID
argument_list|,
literal|1
argument_list|)
expr_stmt|;
try|try
block|{
name|JobContext
name|jContext2
init|=
operator|new
name|JobContextImpl
argument_list|(
name|conf2
argument_list|,
name|taskAttempt20
operator|.
name|getJobID
argument_list|()
argument_list|)
decl_stmt|;
name|TaskAttemptContext
name|tContext2
init|=
operator|new
name|TaskAttemptContextImpl
argument_list|(
name|conf2
argument_list|,
name|taskAttempt20
argument_list|)
decl_stmt|;
name|AbstractS3ACommitter
name|committer2
init|=
name|createCommitter
argument_list|(
name|job2Dest
argument_list|,
name|tContext2
argument_list|)
decl_stmt|;
name|JobData
name|jobData2
init|=
operator|new
name|JobData
argument_list|(
name|job2
argument_list|,
name|jContext2
argument_list|,
name|tContext2
argument_list|,
name|committer2
argument_list|)
decl_stmt|;
name|setup
argument_list|(
name|jobData2
argument_list|)
expr_stmt|;
name|abortInTeardown
argument_list|(
name|jobData2
argument_list|)
expr_stmt|;
comment|// make sure the directories are different
name|assertEquals
argument_list|(
name|job2Dest
argument_list|,
name|committer2
operator|.
name|getOutputPath
argument_list|()
argument_list|)
expr_stmt|;
comment|// job2 setup, write some data there
name|writeTextOutput
argument_list|(
name|tContext2
argument_list|)
expr_stmt|;
comment|// at this point, job1 and job2 both have uncommitted tasks
comment|// commit tasks in order task 2, task 1.
name|commitTask
argument_list|(
name|committer2
argument_list|,
name|tContext2
argument_list|)
expr_stmt|;
name|commitTask
argument_list|(
name|committer1
argument_list|,
name|tContext1
argument_list|)
expr_stmt|;
name|assertMultipartUploadsPending
argument_list|(
name|job1Dest
argument_list|)
expr_stmt|;
name|assertMultipartUploadsPending
argument_list|(
name|job2Dest
argument_list|)
expr_stmt|;
comment|// commit jobs in order job 1, job 2
name|commitJob
argument_list|(
name|committer1
argument_list|,
name|jContext1
argument_list|)
expr_stmt|;
name|assertNoMultipartUploadsPending
argument_list|(
name|job1Dest
argument_list|)
expr_stmt|;
name|getPart0000
argument_list|(
name|job1Dest
argument_list|)
expr_stmt|;
name|assertMultipartUploadsPending
argument_list|(
name|job2Dest
argument_list|)
expr_stmt|;
name|commitJob
argument_list|(
name|committer2
argument_list|,
name|jContext2
argument_list|)
expr_stmt|;
name|getPart0000
argument_list|(
name|job2Dest
argument_list|)
expr_stmt|;
name|assertNoMultipartUploadsPending
argument_list|(
name|job2Dest
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
comment|// uncommitted files to this path need to be deleted in tests which fail
name|abortMultipartUploadsUnderPath
argument_list|(
name|job2Dest
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Test
DECL|method|testS3ACommitterFactoryBinding ()
specifier|public
name|void
name|testS3ACommitterFactoryBinding
parameter_list|()
throws|throws
name|Throwable
block|{
name|describe
argument_list|(
literal|"Verify that the committer factory returns this "
operator|+
literal|"committer when configured to do so"
argument_list|)
expr_stmt|;
name|Job
name|job
init|=
name|newJob
argument_list|()
decl_stmt|;
name|FileOutputFormat
operator|.
name|setOutputPath
argument_list|(
name|job
argument_list|,
name|outDir
argument_list|)
expr_stmt|;
name|Configuration
name|conf
init|=
name|job
operator|.
name|getConfiguration
argument_list|()
decl_stmt|;
name|conf
operator|.
name|set
argument_list|(
name|MRJobConfig
operator|.
name|TASK_ATTEMPT_ID
argument_list|,
name|attempt0
argument_list|)
expr_stmt|;
name|conf
operator|.
name|setInt
argument_list|(
name|MRJobConfig
operator|.
name|APPLICATION_ATTEMPT_ID
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|TaskAttemptContext
name|tContext
init|=
operator|new
name|TaskAttemptContextImpl
argument_list|(
name|conf
argument_list|,
name|taskAttempt0
argument_list|)
decl_stmt|;
name|String
name|name
init|=
name|getCommitterName
argument_list|()
decl_stmt|;
name|S3ACommitterFactory
name|factory
init|=
operator|new
name|S3ACommitterFactory
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
literal|"Wrong committer from factory"
argument_list|,
name|createCommitter
argument_list|(
name|outDir
argument_list|,
name|tContext
argument_list|)
operator|.
name|getClass
argument_list|()
argument_list|,
name|factory
operator|.
name|createOutputCommitter
argument_list|(
name|outDir
argument_list|,
name|tContext
argument_list|)
operator|.
name|getClass
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Validate the path of a file being written to during the write    * itself.    * @param p path    * @throws IOException IO failure    */
DECL|method|validateTaskAttemptPathDuringWrite (Path p)
specifier|protected
name|void
name|validateTaskAttemptPathDuringWrite
parameter_list|(
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{    }
comment|/**    * Validate the path of a file being written to after the write    * operation has completed.    * @param p path    * @throws IOException IO failure    */
DECL|method|validateTaskAttemptPathAfterWrite (Path p)
specifier|protected
name|void
name|validateTaskAttemptPathAfterWrite
parameter_list|(
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{    }
comment|/**    * Perform any actions needed to validate the working directory of    * a committer.    * For example: filesystem, path attributes    * @param committer committer instance    * @param context task attempt context    * @throws IOException IO failure    */
DECL|method|validateTaskAttemptWorkingDirectory ( AbstractS3ACommitter committer, TaskAttemptContext context)
specifier|protected
name|void
name|validateTaskAttemptWorkingDirectory
parameter_list|(
name|AbstractS3ACommitter
name|committer
parameter_list|,
name|TaskAttemptContext
name|context
parameter_list|)
throws|throws
name|IOException
block|{   }
comment|/**    * Commit a task then validate the state of the committer afterwards.    * @param committer committer    * @param tContext task context    * @throws IOException IO failure    */
DECL|method|commitTask (final AbstractS3ACommitter committer, final TaskAttemptContext tContext)
specifier|protected
name|void
name|commitTask
parameter_list|(
specifier|final
name|AbstractS3ACommitter
name|committer
parameter_list|,
specifier|final
name|TaskAttemptContext
name|tContext
parameter_list|)
throws|throws
name|IOException
block|{
name|committer
operator|.
name|commitTask
argument_list|(
name|tContext
argument_list|)
expr_stmt|;
name|verifyCommitterHasNoThreads
argument_list|(
name|committer
argument_list|)
expr_stmt|;
block|}
comment|/**    * Commit a job then validate the state of the committer afterwards.    * @param committer committer    * @param jContext job context    * @throws IOException IO failure    */
DECL|method|commitJob (final AbstractS3ACommitter committer, final JobContext jContext)
specifier|protected
name|void
name|commitJob
parameter_list|(
specifier|final
name|AbstractS3ACommitter
name|committer
parameter_list|,
specifier|final
name|JobContext
name|jContext
parameter_list|)
throws|throws
name|IOException
block|{
name|committer
operator|.
name|commitJob
argument_list|(
name|jContext
argument_list|)
expr_stmt|;
name|verifyCommitterHasNoThreads
argument_list|(
name|committer
argument_list|)
expr_stmt|;
block|}
comment|/**    * Verify that the committer does not have a thread pool.    * @param committer committer to validate.    */
DECL|method|verifyCommitterHasNoThreads (AbstractS3ACommitter committer)
specifier|protected
name|void
name|verifyCommitterHasNoThreads
parameter_list|(
name|AbstractS3ACommitter
name|committer
parameter_list|)
block|{
name|assertFalse
argument_list|(
literal|"Committer has an active thread pool"
argument_list|,
name|committer
operator|.
name|hasThreadPool
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
end_class

end_unit

