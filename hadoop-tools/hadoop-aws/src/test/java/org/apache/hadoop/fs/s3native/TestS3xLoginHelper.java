begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.fs.s3native
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3native
package|;
end_package

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URI
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URISyntaxException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Assert
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Test
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|test
operator|.
name|LambdaTestUtils
operator|.
name|intercept
import|;
end_import

begin_comment
comment|/**  * Test how URIs and login details are extracted from URIs.  */
end_comment

begin_class
DECL|class|TestS3xLoginHelper
specifier|public
class|class
name|TestS3xLoginHelper
extends|extends
name|Assert
block|{
DECL|field|BUCKET
specifier|public
specifier|static
specifier|final
name|String
name|BUCKET
init|=
literal|"s3a://bucket"
decl_stmt|;
DECL|field|ENDPOINT
specifier|private
specifier|static
specifier|final
name|URI
name|ENDPOINT
init|=
name|uri
argument_list|(
name|BUCKET
argument_list|)
decl_stmt|;
DECL|field|S
specifier|public
specifier|static
specifier|final
name|String
name|S
init|=
literal|"%2f"
decl_stmt|;
DECL|field|P
specifier|public
specifier|static
specifier|final
name|String
name|P
init|=
literal|"%2b"
decl_stmt|;
DECL|field|P_RAW
specifier|public
specifier|static
specifier|final
name|String
name|P_RAW
init|=
literal|"+"
decl_stmt|;
DECL|field|USER
specifier|public
specifier|static
specifier|final
name|String
name|USER
init|=
literal|"user"
decl_stmt|;
DECL|field|PASLASHSLASH
specifier|public
specifier|static
specifier|final
name|String
name|PASLASHSLASH
init|=
literal|"pa"
operator|+
name|S
operator|+
name|S
decl_stmt|;
DECL|field|PAPLUS
specifier|public
specifier|static
specifier|final
name|String
name|PAPLUS
init|=
literal|"pa"
operator|+
name|P
decl_stmt|;
DECL|field|PAPLUS_RAW
specifier|public
specifier|static
specifier|final
name|String
name|PAPLUS_RAW
init|=
literal|"pa"
operator|+
name|P_RAW
decl_stmt|;
DECL|field|WITH_USER_AND_PASS
specifier|public
specifier|static
specifier|final
name|URI
name|WITH_USER_AND_PASS
init|=
name|uri
argument_list|(
literal|"s3a://user:pass@bucket"
argument_list|)
decl_stmt|;
DECL|field|WITH_SLASH_IN_PASS
specifier|public
specifier|static
specifier|final
name|URI
name|WITH_SLASH_IN_PASS
init|=
name|uri
argument_list|(
literal|"s3a://user:"
operator|+
name|PASLASHSLASH
operator|+
literal|"@bucket"
argument_list|)
decl_stmt|;
DECL|field|WITH_PLUS_IN_PASS
specifier|public
specifier|static
specifier|final
name|URI
name|WITH_PLUS_IN_PASS
init|=
name|uri
argument_list|(
literal|"s3a://user:"
operator|+
name|PAPLUS
operator|+
literal|"@bucket"
argument_list|)
decl_stmt|;
DECL|field|WITH_PLUS_RAW_IN_PASS
specifier|public
specifier|static
specifier|final
name|URI
name|WITH_PLUS_RAW_IN_PASS
init|=
name|uri
argument_list|(
literal|"s3a://user:"
operator|+
name|PAPLUS_RAW
operator|+
literal|"@bucket"
argument_list|)
decl_stmt|;
DECL|field|USER_NO_PASS
specifier|public
specifier|static
specifier|final
name|URI
name|USER_NO_PASS
init|=
name|uri
argument_list|(
literal|"s3a://user@bucket"
argument_list|)
decl_stmt|;
DECL|field|WITH_USER_AND_COLON
specifier|public
specifier|static
specifier|final
name|URI
name|WITH_USER_AND_COLON
init|=
name|uri
argument_list|(
literal|"s3a://user:@bucket"
argument_list|)
decl_stmt|;
DECL|field|NO_USER
specifier|public
specifier|static
specifier|final
name|URI
name|NO_USER
init|=
name|uri
argument_list|(
literal|"s3a://:pass@bucket"
argument_list|)
decl_stmt|;
DECL|field|NO_USER_NO_PASS
specifier|public
specifier|static
specifier|final
name|URI
name|NO_USER_NO_PASS
init|=
name|uri
argument_list|(
literal|"s3a://:@bucket"
argument_list|)
decl_stmt|;
DECL|field|NO_USER_NO_PASS_TWO_COLON
specifier|public
specifier|static
specifier|final
name|URI
name|NO_USER_NO_PASS_TWO_COLON
init|=
name|uri
argument_list|(
literal|"s3a://::@bucket"
argument_list|)
decl_stmt|;
comment|/**    * Construct a URI; raises an RTE if it won't parse.    * This allows it to be used in static constructors.    * @param s URI string    * @return the URI    * @throws RuntimeException on a URI syntax problem    */
DECL|method|uri (String s)
specifier|private
specifier|static
name|URI
name|uri
parameter_list|(
name|String
name|s
parameter_list|)
block|{
try|try
block|{
return|return
operator|new
name|URI
argument_list|(
name|s
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|URISyntaxException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
operator|.
name|toString
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**    * Assert that a built up FS URI matches the endpoint.    * @param uri URI to build the FS URI from    */
DECL|method|assertMatchesEndpoint (URI uri)
specifier|private
name|void
name|assertMatchesEndpoint
parameter_list|(
name|URI
name|uri
parameter_list|)
block|{
name|assertEquals
argument_list|(
literal|"Source "
operator|+
name|uri
argument_list|,
name|ENDPOINT
argument_list|,
name|S3xLoginHelper
operator|.
name|buildFSURI
argument_list|(
name|uri
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Assert that the supplied FS URI is invalid as it contains    * username:password secrets.    * @param uri URI to build the FS URI from    */
DECL|method|assertInvalid (URI uri)
specifier|private
name|void
name|assertInvalid
parameter_list|(
name|URI
name|uri
parameter_list|)
throws|throws
name|Exception
block|{
name|intercept
argument_list|(
name|IllegalArgumentException
operator|.
name|class
argument_list|,
name|S3xLoginHelper
operator|.
name|LOGIN_WARNING
argument_list|,
parameter_list|()
lambda|->
name|S3xLoginHelper
operator|.
name|buildFSURI
argument_list|(
name|uri
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Assert that the login/pass details from a URI match that expected.    * @param user username    * @param pass password    * @param uri URI to build login details from    * @return the login tuple    */
DECL|method|assertMatchesLogin (String user, String pass, URI uri)
specifier|private
name|S3xLoginHelper
operator|.
name|Login
name|assertMatchesLogin
parameter_list|(
name|String
name|user
parameter_list|,
name|String
name|pass
parameter_list|,
name|URI
name|uri
parameter_list|)
block|{
name|S3xLoginHelper
operator|.
name|Login
name|expected
init|=
operator|new
name|S3xLoginHelper
operator|.
name|Login
argument_list|(
name|user
argument_list|,
name|pass
argument_list|)
decl_stmt|;
name|S3xLoginHelper
operator|.
name|Login
name|actual
init|=
name|S3xLoginHelper
operator|.
name|extractLoginDetails
argument_list|(
name|uri
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|expected
operator|.
name|equals
argument_list|(
name|actual
argument_list|)
condition|)
block|{
name|Assert
operator|.
name|fail
argument_list|(
literal|"Source "
operator|+
name|uri
operator|+
literal|" login expected=:"
operator|+
name|toString
argument_list|(
name|expected
argument_list|)
operator|+
literal|" actual="
operator|+
name|toString
argument_list|(
name|actual
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|actual
return|;
block|}
annotation|@
name|Test
DECL|method|testSimpleFSURI ()
specifier|public
name|void
name|testSimpleFSURI
parameter_list|()
throws|throws
name|Throwable
block|{
name|assertMatchesEndpoint
argument_list|(
name|ENDPOINT
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testLoginSimple ()
specifier|public
name|void
name|testLoginSimple
parameter_list|()
throws|throws
name|Throwable
block|{
name|S3xLoginHelper
operator|.
name|Login
name|login
init|=
name|assertMatchesLogin
argument_list|(
literal|""
argument_list|,
literal|""
argument_list|,
name|ENDPOINT
argument_list|)
decl_stmt|;
name|assertFalse
argument_list|(
literal|"Login of "
operator|+
name|login
argument_list|,
name|login
operator|.
name|hasLogin
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testLoginWithUser ()
specifier|public
name|void
name|testLoginWithUser
parameter_list|()
throws|throws
name|Throwable
block|{
name|assertMatchesLogin
argument_list|(
name|USER
argument_list|,
literal|""
argument_list|,
name|USER_NO_PASS
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testLoginWithUserAndColon ()
specifier|public
name|void
name|testLoginWithUserAndColon
parameter_list|()
throws|throws
name|Throwable
block|{
name|assertMatchesLogin
argument_list|(
name|USER
argument_list|,
literal|""
argument_list|,
name|WITH_USER_AND_COLON
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testLoginNoUser ()
specifier|public
name|void
name|testLoginNoUser
parameter_list|()
throws|throws
name|Throwable
block|{
name|assertMatchesLogin
argument_list|(
literal|""
argument_list|,
literal|""
argument_list|,
name|NO_USER
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testLoginNoUserNoPass ()
specifier|public
name|void
name|testLoginNoUserNoPass
parameter_list|()
throws|throws
name|Throwable
block|{
name|assertMatchesLogin
argument_list|(
literal|""
argument_list|,
literal|""
argument_list|,
name|NO_USER_NO_PASS
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testLoginNoUserNoPassTwoColon ()
specifier|public
name|void
name|testLoginNoUserNoPassTwoColon
parameter_list|()
throws|throws
name|Throwable
block|{
name|assertMatchesLogin
argument_list|(
literal|""
argument_list|,
literal|""
argument_list|,
name|NO_USER_NO_PASS_TWO_COLON
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testFsUriWithUserAndPass ()
specifier|public
name|void
name|testFsUriWithUserAndPass
parameter_list|()
throws|throws
name|Throwable
block|{
name|assertInvalid
argument_list|(
name|WITH_USER_AND_PASS
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testFsUriWithSlashInPass ()
specifier|public
name|void
name|testFsUriWithSlashInPass
parameter_list|()
throws|throws
name|Throwable
block|{
name|assertInvalid
argument_list|(
name|WITH_SLASH_IN_PASS
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testFsUriWithPlusInPass ()
specifier|public
name|void
name|testFsUriWithPlusInPass
parameter_list|()
throws|throws
name|Throwable
block|{
name|assertInvalid
argument_list|(
name|WITH_PLUS_IN_PASS
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testFsUriWithPlusRawInPass ()
specifier|public
name|void
name|testFsUriWithPlusRawInPass
parameter_list|()
throws|throws
name|Throwable
block|{
name|assertInvalid
argument_list|(
name|WITH_PLUS_RAW_IN_PASS
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testFsUriWithUser ()
specifier|public
name|void
name|testFsUriWithUser
parameter_list|()
throws|throws
name|Throwable
block|{
name|assertInvalid
argument_list|(
name|USER_NO_PASS
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testFsUriWithUserAndColon ()
specifier|public
name|void
name|testFsUriWithUserAndColon
parameter_list|()
throws|throws
name|Throwable
block|{
name|assertInvalid
argument_list|(
name|WITH_USER_AND_COLON
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testFsiNoUser ()
specifier|public
name|void
name|testFsiNoUser
parameter_list|()
throws|throws
name|Throwable
block|{
name|assertMatchesEndpoint
argument_list|(
name|NO_USER
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testFsUriNoUserNoPass ()
specifier|public
name|void
name|testFsUriNoUserNoPass
parameter_list|()
throws|throws
name|Throwable
block|{
name|assertMatchesEndpoint
argument_list|(
name|NO_USER_NO_PASS
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testFsUriNoUserNoPassTwoColon ()
specifier|public
name|void
name|testFsUriNoUserNoPassTwoColon
parameter_list|()
throws|throws
name|Throwable
block|{
name|assertMatchesEndpoint
argument_list|(
name|NO_USER_NO_PASS_TWO_COLON
argument_list|)
expr_stmt|;
block|}
comment|/**    * Stringifier. Kept in the code to avoid accidental logging in production    * code.    * @return login details for assertions.    */
DECL|method|toString (S3xLoginHelper.Login login)
specifier|public
name|String
name|toString
parameter_list|(
name|S3xLoginHelper
operator|.
name|Login
name|login
parameter_list|)
block|{
specifier|final
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|(
literal|"LoginTuple{"
argument_list|)
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"<'"
argument_list|)
operator|.
name|append
argument_list|(
name|login
operator|.
name|getUser
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|'\''
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|", '"
argument_list|)
operator|.
name|append
argument_list|(
name|login
operator|.
name|getPassword
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|'\''
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|'>'
argument_list|)
expr_stmt|;
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
end_class

end_unit

