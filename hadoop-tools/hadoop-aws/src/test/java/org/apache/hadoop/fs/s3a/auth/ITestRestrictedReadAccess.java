begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements. See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership. The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License. You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.fs.s3a.auth
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|auth
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileNotFoundException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|StandardCharsets
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|AccessDeniedException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Optional
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Callable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|assertj
operator|.
name|core
operator|.
name|api
operator|.
name|Assertions
import|;
end_import

begin_import
import|import
name|org
operator|.
name|assertj
operator|.
name|core
operator|.
name|api
operator|.
name|Assumptions
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Test
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|runner
operator|.
name|RunWith
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|runners
operator|.
name|Parameterized
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang3
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FSDataInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|PathFilter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|contract
operator|.
name|ContractTestUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|AbstractS3ATestBase
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|S3AFileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|S3ATestUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|Statistic
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|s3guard
operator|.
name|DynamoDBMetadataStore
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|LocatedFileStatusFetcher
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|lib
operator|.
name|input
operator|.
name|InvalidInputException
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|contract
operator|.
name|ContractTestUtils
operator|.
name|createFile
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|contract
operator|.
name|ContractTestUtils
operator|.
name|touch
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|Constants
operator|.
name|ASSUMED_ROLE_ARN
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|Constants
operator|.
name|METADATASTORE_AUTHORITATIVE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|Constants
operator|.
name|S3_METADATA_STORE_IMPL
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|S3ATestUtils
operator|.
name|assume
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|S3ATestUtils
operator|.
name|assumeS3GuardState
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|S3ATestUtils
operator|.
name|disableFilesystemCaching
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|S3ATestUtils
operator|.
name|getTestBucketName
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|S3ATestUtils
operator|.
name|isS3GuardTestPropertySet
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|S3ATestUtils
operator|.
name|lsR
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|S3ATestUtils
operator|.
name|removeBaseAndBucketOverrides
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|S3ATestUtils
operator|.
name|removeBucketOverrides
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|auth
operator|.
name|RoleModel
operator|.
name|Effects
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|auth
operator|.
name|RoleModel
operator|.
name|Statement
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|auth
operator|.
name|RoleModel
operator|.
name|directory
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|auth
operator|.
name|RoleModel
operator|.
name|statement
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|auth
operator|.
name|RolePolicies
operator|.
name|*
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|auth
operator|.
name|RoleTestUtils
operator|.
name|bindRolePolicyStatements
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|auth
operator|.
name|RoleTestUtils
operator|.
name|newAssumedRoleConfig
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|IOUtils
operator|.
name|cleanupWithLogger
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|lib
operator|.
name|input
operator|.
name|FileInputFormat
operator|.
name|LIST_STATUS_NUM_THREADS
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|test
operator|.
name|GenericTestUtils
operator|.
name|assertExceptionContains
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|test
operator|.
name|GenericTestUtils
operator|.
name|failif
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|test
operator|.
name|LambdaTestUtils
operator|.
name|intercept
import|;
end_import

begin_comment
comment|/**  * This test creates a client with no read access to the underlying  * filesystem and then tries to perform various read operations on it.  * S3Guard in non-auth mode always goes to the FS, so we parameterize the  * test for S3Guard + Auth to see how failures move around.  *<ol>  *<li>Tests only run if an assumed role is provided.</li>  *<li>And the S3Guard tests require DynamoDB.</li>  *</ol>  * The tests are all bundled into one big test case.  * From a purist unit test perspective, this is utterly wrong as it goes  * against the  *<i>"Each test case tests exactly one thing"</i>  * philosophy of JUnit.  *<p>  * However is significantly reduces setup costs on the parameterized test runs,  * as it means that the filesystems and directories only need to be  * created and destroyed once per parameterized suite, rather than  * once per individual test.  *<p>  * All the test probes have informative messages so when a test failure  * does occur, its cause should be discoverable. It main weaknesses are  * therefore:  *<ol>  *<li>A failure of an assertion blocks all subsequent assertions from  *   being checked.</li>  *<li>Maintenance is potentially harder.</li>  *</ol>  * To simplify maintenance, the operations tested are broken up into  * their own methods, with fields used to share the restricted role and  * created paths.  *  */
end_comment

begin_class
annotation|@
name|SuppressWarnings
argument_list|(
literal|"ThrowableNotThrown"
argument_list|)
annotation|@
name|RunWith
argument_list|(
name|Parameterized
operator|.
name|class
argument_list|)
DECL|class|ITestRestrictedReadAccess
specifier|public
class|class
name|ITestRestrictedReadAccess
extends|extends
name|AbstractS3ATestBase
block|{
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|ITestRestrictedReadAccess
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/** Filter to select everything. */
DECL|field|EVERYTHING
specifier|private
specifier|static
specifier|final
name|PathFilter
name|EVERYTHING
init|=
name|t
lambda|->
literal|true
decl_stmt|;
comment|/** Filter to select .txt files. */
DECL|field|TEXT_FILE
specifier|private
specifier|static
specifier|final
name|PathFilter
name|TEXT_FILE
init|=
name|path
lambda|->
name|path
operator|.
name|toUri
argument_list|()
operator|.
name|toString
argument_list|()
operator|.
name|endsWith
argument_list|(
literal|".txt"
argument_list|)
decl_stmt|;
comment|/** The same path filter used in FileInputFormat. */
DECL|field|HIDDEN_FILE_FILTER
specifier|private
specifier|static
specifier|final
name|PathFilter
name|HIDDEN_FILE_FILTER
init|=
parameter_list|(
name|p
parameter_list|)
lambda|->
block|{
name|String
name|n
init|=
name|p
operator|.
name|getName
argument_list|()
decl_stmt|;
return|return
operator|!
name|n
operator|.
name|startsWith
argument_list|(
literal|"_"
argument_list|)
operator|&&
operator|!
name|n
operator|.
name|startsWith
argument_list|(
literal|"."
argument_list|)
return|;
block|}
decl_stmt|;
comment|/**    * Text found in LocatedFileStatusFetcher exception when the glob    * returned "null".    */
DECL|field|DOES_NOT_EXIST
specifier|private
specifier|static
specifier|final
name|String
name|DOES_NOT_EXIST
init|=
literal|"does not exist"
decl_stmt|;
comment|/**    * Text found in LocatedFileStatusFetcher exception when    * the glob returned an empty list.    */
DECL|field|MATCHES_0_FILES
specifier|private
specifier|static
specifier|final
name|String
name|MATCHES_0_FILES
init|=
literal|"matches 0 files"
decl_stmt|;
comment|/**    * Text used in files.    */
DECL|field|HELLO
specifier|public
specifier|static
specifier|final
name|byte
index|[]
name|HELLO
init|=
literal|"hello"
operator|.
name|getBytes
argument_list|(
name|StandardCharsets
operator|.
name|UTF_8
argument_list|)
decl_stmt|;
DECL|field|guardedInAuthMode
specifier|private
specifier|final
name|boolean
name|guardedInAuthMode
decl_stmt|;
comment|/**    * Wildcard scan to find *.txt in the no-read directory.    * When a scan/glob is done with S3Guard in auth mode, the scan will    * succeed but the file open will fail for any non-empty file.    * In non-auth mode, the read restrictions will fail the actual scan.    */
DECL|field|noReadWildcard
specifier|private
name|Path
name|noReadWildcard
decl_stmt|;
comment|/**    * Parameterization.    */
annotation|@
name|Parameterized
operator|.
name|Parameters
argument_list|(
name|name
operator|=
literal|"{0}"
argument_list|)
DECL|method|params ()
specifier|public
specifier|static
name|Collection
argument_list|<
name|Object
index|[]
argument_list|>
name|params
parameter_list|()
block|{
return|return
name|Arrays
operator|.
name|asList
argument_list|(
operator|new
name|Object
index|[]
index|[]
block|{
block|{
literal|"raw"
block|,
literal|false
block|,
literal|false
block|}
block|,
block|{
literal|"nonauth"
block|,
literal|true
block|,
literal|false
block|}
block|,
block|{
literal|"auth"
block|,
literal|true
block|,
literal|true
block|}
block|}
argument_list|)
return|;
block|}
DECL|field|name
specifier|private
specifier|final
name|String
name|name
decl_stmt|;
DECL|field|s3guard
specifier|private
specifier|final
name|boolean
name|s3guard
decl_stmt|;
DECL|field|authMode
specifier|private
specifier|final
name|boolean
name|authMode
decl_stmt|;
DECL|field|basePath
specifier|private
name|Path
name|basePath
decl_stmt|;
DECL|field|noReadDir
specifier|private
name|Path
name|noReadDir
decl_stmt|;
DECL|field|emptyDir
specifier|private
name|Path
name|emptyDir
decl_stmt|;
DECL|field|emptyFile
specifier|private
name|Path
name|emptyFile
decl_stmt|;
DECL|field|subDir
specifier|private
name|Path
name|subDir
decl_stmt|;
DECL|field|subdirFile
specifier|private
name|Path
name|subdirFile
decl_stmt|;
DECL|field|subDir2
specifier|private
name|Path
name|subDir2
decl_stmt|;
DECL|field|subdir2File1
specifier|private
name|Path
name|subdir2File1
decl_stmt|;
DECL|field|subdir2File2
specifier|private
name|Path
name|subdir2File2
decl_stmt|;
DECL|field|roleConfig
specifier|private
name|Configuration
name|roleConfig
decl_stmt|;
comment|/**    * A read-only FS; if non-null it is closed in teardown.    */
DECL|field|readonlyFS
specifier|private
name|S3AFileSystem
name|readonlyFS
decl_stmt|;
comment|/**    * Test suite setup.    * @param name name for logs/paths.    * @param s3guard is S3Guard enabled?    * @param authMode is S3Guard in auth mode?    */
DECL|method|ITestRestrictedReadAccess ( final String name, final boolean s3guard, final boolean authMode)
specifier|public
name|ITestRestrictedReadAccess
parameter_list|(
specifier|final
name|String
name|name
parameter_list|,
specifier|final
name|boolean
name|s3guard
parameter_list|,
specifier|final
name|boolean
name|authMode
parameter_list|)
block|{
name|this
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|this
operator|.
name|s3guard
operator|=
name|s3guard
expr_stmt|;
name|this
operator|.
name|authMode
operator|=
name|authMode
expr_stmt|;
name|this
operator|.
name|guardedInAuthMode
operator|=
name|s3guard
operator|&&
name|authMode
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|createConfiguration ()
specifier|public
name|Configuration
name|createConfiguration
parameter_list|()
block|{
name|Configuration
name|conf
init|=
name|super
operator|.
name|createConfiguration
argument_list|()
decl_stmt|;
name|String
name|bucketName
init|=
name|getTestBucketName
argument_list|(
name|conf
argument_list|)
decl_stmt|;
comment|// is s3guard enabled?
name|boolean
name|guardedTestRun
init|=
name|isS3GuardTestPropertySet
argument_list|(
name|conf
argument_list|)
decl_stmt|;
comment|// in a guarded test run, except for the special case of raw,
comment|// all DDB settings are left alone.
name|removeBaseAndBucketOverrides
argument_list|(
name|bucketName
argument_list|,
name|conf
argument_list|,
name|METADATASTORE_AUTHORITATIVE
argument_list|)
expr_stmt|;
name|removeBucketOverrides
argument_list|(
name|bucketName
argument_list|,
name|conf
argument_list|,
name|S3_METADATA_STORE_IMPL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s3guard
condition|)
block|{
name|removeBaseAndBucketOverrides
argument_list|(
name|bucketName
argument_list|,
name|conf
argument_list|,
name|S3_METADATA_STORE_IMPL
argument_list|)
expr_stmt|;
block|}
name|conf
operator|.
name|setBoolean
argument_list|(
name|METADATASTORE_AUTHORITATIVE
argument_list|,
name|authMode
argument_list|)
expr_stmt|;
name|disableFilesystemCaching
argument_list|(
name|conf
argument_list|)
expr_stmt|;
return|return
name|conf
return|;
block|}
annotation|@
name|Override
DECL|method|setup ()
specifier|public
name|void
name|setup
parameter_list|()
throws|throws
name|Exception
block|{
name|super
operator|.
name|setup
argument_list|()
expr_stmt|;
if|if
condition|(
name|s3guard
condition|)
block|{
comment|// s3guard is required for those test runs where any of the
comment|// guard options are set
name|assumeS3GuardState
argument_list|(
literal|true
argument_list|,
name|getConfiguration
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|assumeRoleTests
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|teardown ()
specifier|public
name|void
name|teardown
parameter_list|()
throws|throws
name|Exception
block|{
try|try
block|{
name|super
operator|.
name|teardown
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|cleanupWithLogger
argument_list|(
name|LOG
argument_list|,
name|readonlyFS
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|assumeRoleTests ()
specifier|private
name|void
name|assumeRoleTests
parameter_list|()
block|{
name|assume
argument_list|(
literal|"No ARN for role tests"
argument_list|,
operator|!
name|getAssumedRoleARN
argument_list|()
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|getAssumedRoleARN ()
specifier|private
name|String
name|getAssumedRoleARN
parameter_list|()
block|{
return|return
name|getContract
argument_list|()
operator|.
name|getConf
argument_list|()
operator|.
name|getTrimmed
argument_list|(
name|ASSUMED_ROLE_ARN
argument_list|,
literal|""
argument_list|)
return|;
block|}
comment|/**    * Create the assumed role configuration.    * @return a config bonded to the ARN of the assumed role    */
DECL|method|createAssumedRoleConfig ()
specifier|public
name|Configuration
name|createAssumedRoleConfig
parameter_list|()
block|{
return|return
name|createAssumedRoleConfig
argument_list|(
name|getAssumedRoleARN
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Create a config for an assumed role; it also disables FS caching.    * @param roleARN ARN of role    * @return the new configuration    */
DECL|method|createAssumedRoleConfig (String roleARN)
specifier|private
name|Configuration
name|createAssumedRoleConfig
parameter_list|(
name|String
name|roleARN
parameter_list|)
block|{
return|return
name|newAssumedRoleConfig
argument_list|(
name|getContract
argument_list|()
operator|.
name|getConf
argument_list|()
argument_list|,
name|roleARN
argument_list|)
return|;
block|}
comment|/**    * This is a single test case which invokes the individual test cases    * in sequence.    */
annotation|@
name|Test
DECL|method|testNoReadAccess ()
specifier|public
name|void
name|testNoReadAccess
parameter_list|()
throws|throws
name|Throwable
block|{
name|describe
argument_list|(
literal|"Test failure handling if the client doesn't"
operator|+
literal|" have read access under a path"
argument_list|)
expr_stmt|;
name|initNoReadAccess
argument_list|()
expr_stmt|;
comment|// now move up the API Chain, from the calls made by globStatus,
comment|// to globStatus itself, and then to LocatedFileStatusFetcher,
comment|// which invokes globStatus
name|checkBasicFileOperations
argument_list|()
expr_stmt|;
name|checkGlobOperations
argument_list|()
expr_stmt|;
name|checkSingleThreadedLocatedFileStatus
argument_list|()
expr_stmt|;
name|checkLocatedFileStatusFourThreads
argument_list|()
expr_stmt|;
name|checkLocatedFileStatusScanFile
argument_list|()
expr_stmt|;
name|checkLocatedFileStatusNonexistentPath
argument_list|()
expr_stmt|;
name|checkDeleteOperations
argument_list|()
expr_stmt|;
block|}
comment|/**    * Initialize the directory tree and the role filesystem.    */
DECL|method|initNoReadAccess ()
specifier|public
name|void
name|initNoReadAccess
parameter_list|()
throws|throws
name|Throwable
block|{
name|describe
argument_list|(
literal|"Setting up filesystem"
argument_list|)
expr_stmt|;
name|S3AFileSystem
name|realFS
init|=
name|getFileSystem
argument_list|()
decl_stmt|;
name|verifyS3GuardSettings
argument_list|(
name|realFS
argument_list|,
literal|"real filesystem"
argument_list|)
expr_stmt|;
comment|// avoiding the parameterization to steer clear of accidentally creating
comment|// patterns
name|basePath
operator|=
name|path
argument_list|(
literal|"testNoReadAccess-"
operator|+
name|name
argument_list|)
expr_stmt|;
comment|// define the paths and create them.
name|describe
argument_list|(
literal|"Creating test directories and files"
argument_list|)
expr_stmt|;
comment|// this is the directory to which the restricted role has no read
comment|// access.
name|noReadDir
operator|=
operator|new
name|Path
argument_list|(
name|basePath
argument_list|,
literal|"noReadDir"
argument_list|)
expr_stmt|;
comment|// wildcard scan to find *.txt
name|noReadWildcard
operator|=
operator|new
name|Path
argument_list|(
name|noReadDir
argument_list|,
literal|"*/*.txt"
argument_list|)
expr_stmt|;
comment|// an empty directory directory under the noReadDir
name|emptyDir
operator|=
operator|new
name|Path
argument_list|(
name|noReadDir
argument_list|,
literal|"emptyDir"
argument_list|)
expr_stmt|;
name|realFS
operator|.
name|mkdirs
argument_list|(
name|emptyDir
argument_list|)
expr_stmt|;
comment|// an empty file directory under the noReadDir
name|emptyFile
operator|=
operator|new
name|Path
argument_list|(
name|noReadDir
argument_list|,
literal|"emptyFile.txt"
argument_list|)
expr_stmt|;
name|touch
argument_list|(
name|realFS
argument_list|,
name|emptyFile
argument_list|)
expr_stmt|;
comment|// a subdirectory
name|subDir
operator|=
operator|new
name|Path
argument_list|(
name|noReadDir
argument_list|,
literal|"subDir"
argument_list|)
expr_stmt|;
comment|// and a file in that subdirectory
name|subdirFile
operator|=
operator|new
name|Path
argument_list|(
name|subDir
argument_list|,
literal|"subdirFile.txt"
argument_list|)
expr_stmt|;
name|createFile
argument_list|(
name|realFS
argument_list|,
name|subdirFile
argument_list|,
literal|true
argument_list|,
name|HELLO
argument_list|)
expr_stmt|;
name|subDir2
operator|=
operator|new
name|Path
argument_list|(
name|noReadDir
argument_list|,
literal|"subDir2"
argument_list|)
expr_stmt|;
name|subdir2File1
operator|=
operator|new
name|Path
argument_list|(
name|subDir2
argument_list|,
literal|"subdir2File1.txt"
argument_list|)
expr_stmt|;
name|subdir2File2
operator|=
operator|new
name|Path
argument_list|(
name|subDir2
argument_list|,
literal|"subdir2File2.docx"
argument_list|)
expr_stmt|;
name|createFile
argument_list|(
name|realFS
argument_list|,
name|subdir2File1
argument_list|,
literal|true
argument_list|,
name|HELLO
argument_list|)
expr_stmt|;
name|createFile
argument_list|(
name|realFS
argument_list|,
name|subdir2File2
argument_list|,
literal|true
argument_list|,
name|HELLO
argument_list|)
expr_stmt|;
comment|// execute a recursive list to make sure that S3Guard tables are always
comment|// up to date
name|lsR
argument_list|(
name|realFS
argument_list|,
name|noReadDir
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|// create a role filesystem which does not have read access under a path
comment|// it still has write access, which can be explored in the final
comment|// step to delete files and directories.
name|roleConfig
operator|=
name|createAssumedRoleConfig
argument_list|()
expr_stmt|;
name|bindRolePolicyStatements
argument_list|(
name|roleConfig
argument_list|,
name|STATEMENT_S3GUARD_CLIENT
argument_list|,
name|STATEMENT_ALLOW_SSE_KMS_RW
argument_list|,
name|statement
argument_list|(
literal|true
argument_list|,
name|S3_ALL_BUCKETS
argument_list|,
name|S3_ALL_OPERATIONS
argument_list|)
argument_list|,
operator|new
name|Statement
argument_list|(
name|Effects
operator|.
name|Deny
argument_list|)
operator|.
name|addActions
argument_list|(
name|S3_ALL_GET
argument_list|)
operator|.
name|addResources
argument_list|(
name|directory
argument_list|(
name|noReadDir
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|readonlyFS
operator|=
operator|(
name|S3AFileSystem
operator|)
name|basePath
operator|.
name|getFileSystem
argument_list|(
name|roleConfig
argument_list|)
expr_stmt|;
name|verifyS3GuardSettings
argument_list|(
name|readonlyFS
argument_list|,
literal|"readonly"
argument_list|)
expr_stmt|;
block|}
comment|/**    * Verify that the FS (real or restricted) meets the    * requirement of the test.    * S3Guard tests are skipped if the (default) store is not    * a DDB store consistent across all FS instances.    * The raw tests fail if somehow the FS does still have a S3Guard metastore.    * @param fs filesystem    * @param storeType store role for error messages.    */
DECL|method|verifyS3GuardSettings (final S3AFileSystem fs, final String storeType)
specifier|protected
name|void
name|verifyS3GuardSettings
parameter_list|(
specifier|final
name|S3AFileSystem
name|fs
parameter_list|,
specifier|final
name|String
name|storeType
parameter_list|)
block|{
if|if
condition|(
name|s3guard
condition|)
block|{
name|Assumptions
operator|.
name|assumeThat
argument_list|(
name|fs
operator|.
name|getMetadataStore
argument_list|()
argument_list|)
operator|.
name|describedAs
argument_list|(
literal|"Metadata store in "
operator|+
name|storeType
operator|+
literal|" fs: %s"
argument_list|,
name|fs
operator|.
name|getMetadataStore
argument_list|()
argument_list|)
operator|.
name|isInstanceOf
argument_list|(
name|DynamoDBMetadataStore
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Assertions
operator|.
name|assertThat
argument_list|(
name|fs
operator|.
name|hasMetadataStore
argument_list|()
argument_list|)
operator|.
name|describedAs
argument_list|(
literal|"Metadata store in "
operator|+
name|storeType
operator|+
literal|" fs: %s"
argument_list|,
name|fs
operator|.
name|getMetadataStore
argument_list|()
argument_list|)
operator|.
name|isFalse
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Validate basic IO operations.    */
DECL|method|checkBasicFileOperations ()
specifier|public
name|void
name|checkBasicFileOperations
parameter_list|()
throws|throws
name|Throwable
block|{
comment|// this is a LIST call; there's no marker.
comment|// so the sequence is
comment|//   - HEAD path -> FNFE
comment|//   - HEAD path + / -> FNFE
comment|//   - LIST path -> list results
comment|// Because the client has list access, this succeeds
name|readonlyFS
operator|.
name|listStatus
argument_list|(
name|basePath
argument_list|)
expr_stmt|;
name|lsR
argument_list|(
name|readonlyFS
argument_list|,
name|basePath
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|// this is HEAD + "/" on S3; get on S3Guard auth when the path exists,
name|accessDeniedIf
argument_list|(
operator|!
name|s3guard
argument_list|,
parameter_list|()
lambda|->
name|readonlyFS
operator|.
name|listStatus
argument_list|(
name|emptyDir
argument_list|)
argument_list|)
expr_stmt|;
comment|// a recursive list of the no-read-directory works because
comment|// there is no directory marker, it becomes a LIST call.
name|lsR
argument_list|(
name|readonlyFS
argument_list|,
name|noReadDir
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|// similarly, a getFileStatus ends up being a list of the path
comment|// and so working.
name|readonlyFS
operator|.
name|getFileStatus
argument_list|(
name|noReadDir
argument_list|)
expr_stmt|;
comment|// empty dir checks work when guarded because even in non-auth mode
comment|// there are no checks for directories being out of date
comment|// without S3, the HEAD path + "/" is blocked
name|accessDeniedIf
argument_list|(
operator|!
name|s3guard
argument_list|,
parameter_list|()
lambda|->
name|readonlyFS
operator|.
name|getFileStatus
argument_list|(
name|emptyDir
argument_list|)
argument_list|)
expr_stmt|;
comment|// now look at a file; the outcome depends on the mode.
name|accessDeniedIf
argument_list|(
operator|!
name|guardedInAuthMode
argument_list|,
parameter_list|()
lambda|->
name|readonlyFS
operator|.
name|getFileStatus
argument_list|(
name|subdirFile
argument_list|)
argument_list|)
expr_stmt|;
comment|// irrespective of mode, the attempt to read the data will fail.
comment|// the only variable is where the failure occurs
name|accessDenied
argument_list|(
parameter_list|()
lambda|->
name|ContractTestUtils
operator|.
name|readUTF8
argument_list|(
name|readonlyFS
argument_list|,
name|subdirFile
argument_list|,
name|HELLO
operator|.
name|length
argument_list|)
argument_list|)
expr_stmt|;
comment|// the empty file is interesting.
comment|// auth mode doesn't check the store.
comment|// Furthermore, because it knows the file length is zero,
comment|// it returns -1 without even opening the file.
comment|// This means that permissions on the file do not get checked.
comment|// See: HADOOP-16464.
name|Optional
argument_list|<
name|FSDataInputStream
argument_list|>
name|optIn
init|=
name|accessDeniedIf
argument_list|(
operator|!
name|guardedInAuthMode
argument_list|,
parameter_list|()
lambda|->
name|readonlyFS
operator|.
name|open
argument_list|(
name|emptyFile
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|optIn
operator|.
name|isPresent
argument_list|()
condition|)
block|{
try|try
init|(
name|FSDataInputStream
name|is
init|=
name|optIn
operator|.
name|get
argument_list|()
init|)
block|{
name|Assertions
operator|.
name|assertThat
argument_list|(
name|is
operator|.
name|read
argument_list|()
argument_list|)
operator|.
name|describedAs
argument_list|(
literal|"read of empty file"
argument_list|)
operator|.
name|isEqualTo
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Explore Glob's recursive scan.    */
DECL|method|checkGlobOperations ()
specifier|public
name|void
name|checkGlobOperations
parameter_list|()
throws|throws
name|Throwable
block|{
name|describe
argument_list|(
literal|"Glob Status operations"
argument_list|)
expr_stmt|;
comment|// baseline: the real filesystem on a subdir
name|globFS
argument_list|(
name|getFileSystem
argument_list|()
argument_list|,
name|subdirFile
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|// a file fails if not in auth mode
name|globFS
argument_list|(
name|readonlyFS
argument_list|,
name|subdirFile
argument_list|,
literal|null
argument_list|,
operator|!
name|guardedInAuthMode
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|// empty directories don't fail.
name|FileStatus
index|[]
name|st
init|=
name|globFS
argument_list|(
name|readonlyFS
argument_list|,
name|emptyDir
argument_list|,
literal|null
argument_list|,
operator|!
name|s3guard
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|s3guard
condition|)
block|{
name|assertStatusPathEquals
argument_list|(
name|emptyDir
argument_list|,
name|st
argument_list|)
expr_stmt|;
block|}
name|st
operator|=
name|globFS
argument_list|(
name|readonlyFS
argument_list|,
name|noReadWildcard
argument_list|,
literal|null
argument_list|,
operator|!
name|s3guard
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|s3guard
condition|)
block|{
name|Assertions
operator|.
name|assertThat
argument_list|(
name|st
argument_list|)
operator|.
name|extracting
argument_list|(
name|FileStatus
operator|::
name|getPath
argument_list|)
operator|.
name|containsExactlyInAnyOrder
argument_list|(
name|subdirFile
argument_list|,
name|subdir2File1
argument_list|)
expr_stmt|;
block|}
comment|// there is precisely one .docx file (subdir2File2.docx)
name|globFS
argument_list|(
name|readonlyFS
argument_list|,
operator|new
name|Path
argument_list|(
name|noReadDir
argument_list|,
literal|"*/*.docx"
argument_list|)
argument_list|,
literal|null
argument_list|,
operator|!
name|s3guard
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|// there are no .doc files.
name|globFS
argument_list|(
name|readonlyFS
argument_list|,
operator|new
name|Path
argument_list|(
name|noReadDir
argument_list|,
literal|"*/*.doc"
argument_list|)
argument_list|,
literal|null
argument_list|,
operator|!
name|s3guard
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|globFS
argument_list|(
name|readonlyFS
argument_list|,
name|noReadDir
argument_list|,
name|EVERYTHING
argument_list|,
literal|false
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|// and a filter without any wildcarded pattern only finds
comment|// the role dir itself.
name|FileStatus
index|[]
name|st2
init|=
name|globFS
argument_list|(
name|readonlyFS
argument_list|,
name|noReadDir
argument_list|,
name|EVERYTHING
argument_list|,
literal|false
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|Assertions
operator|.
name|assertThat
argument_list|(
name|st2
argument_list|)
operator|.
name|extracting
argument_list|(
name|FileStatus
operator|::
name|getPath
argument_list|)
operator|.
name|containsExactly
argument_list|(
name|noReadDir
argument_list|)
expr_stmt|;
block|}
comment|/**    * Run a located file status fetcher against the directory tree.    */
DECL|method|checkSingleThreadedLocatedFileStatus ()
specifier|public
name|void
name|checkSingleThreadedLocatedFileStatus
parameter_list|()
throws|throws
name|Throwable
block|{
name|describe
argument_list|(
literal|"LocatedFileStatusFetcher operations"
argument_list|)
expr_stmt|;
comment|// use the same filter as FileInputFormat; single thread.
name|roleConfig
operator|.
name|setInt
argument_list|(
name|LIST_STATUS_NUM_THREADS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|LocatedFileStatusFetcher
name|fetcher
init|=
operator|new
name|LocatedFileStatusFetcher
argument_list|(
name|roleConfig
argument_list|,
operator|new
name|Path
index|[]
block|{
name|basePath
block|}
argument_list|,
literal|true
argument_list|,
name|HIDDEN_FILE_FILTER
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|accessDeniedIf
argument_list|(
operator|!
name|s3guard
argument_list|,
parameter_list|()
lambda|->
name|fetcher
operator|.
name|getFileStatuses
argument_list|()
argument_list|)
operator|.
name|ifPresent
argument_list|(
name|stats
lambda|->
block|{
name|Assertions
operator|.
name|assertThat
argument_list|(
name|stats
argument_list|)
operator|.
name|describedAs
argument_list|(
literal|"result of located scan"
argument_list|)
operator|.
name|flatExtracting
argument_list|(
name|FileStatus
operator|::
name|getPath
argument_list|)
operator|.
name|containsExactlyInAnyOrder
argument_list|(
name|emptyFile
argument_list|,
name|subdirFile
argument_list|,
name|subdir2File1
argument_list|,
name|subdir2File2
argument_list|)
argument_list|;
block|}
block|)
class|;
end_class

begin_comment
unit|}
comment|/**    * Run a located file status fetcher against the directory tree.    */
end_comment

begin_function
DECL|method|checkLocatedFileStatusFourThreads ()
unit|public
name|void
name|checkLocatedFileStatusFourThreads
parameter_list|()
throws|throws
name|Throwable
block|{
comment|// four threads and the text filter.
name|int
name|threads
init|=
literal|4
decl_stmt|;
name|describe
argument_list|(
literal|"LocatedFileStatusFetcher with %d"
argument_list|,
name|threads
argument_list|)
expr_stmt|;
name|roleConfig
operator|.
name|setInt
argument_list|(
name|LIST_STATUS_NUM_THREADS
argument_list|,
name|threads
argument_list|)
expr_stmt|;
name|LocatedFileStatusFetcher
name|fetcher
init|=
operator|new
name|LocatedFileStatusFetcher
argument_list|(
name|roleConfig
argument_list|,
operator|new
name|Path
index|[]
block|{
name|noReadWildcard
block|}
argument_list|,
literal|true
argument_list|,
name|EVERYTHING
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|accessDeniedIf
argument_list|(
operator|!
name|s3guard
argument_list|,
parameter_list|()
lambda|->
name|fetcher
operator|.
name|getFileStatuses
argument_list|()
argument_list|)
operator|.
name|ifPresent
argument_list|(
name|stats
lambda|->
block|{
name|Assertions
operator|.
name|assertThat
argument_list|(
name|stats
argument_list|)
operator|.
name|describedAs
argument_list|(
literal|"result of located scan"
argument_list|)
operator|.
name|isNotNull
argument_list|()
operator|.
name|flatExtracting
argument_list|(
name|FileStatus
operator|::
name|getPath
argument_list|)
operator|.
name|containsExactlyInAnyOrder
argument_list|(
name|subdirFile
argument_list|,
name|subdir2File1
argument_list|)
argument_list|;
block|}
end_function

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_comment
unit|}
comment|/**    * Run a located file status fetcher against the directory tree.    */
end_comment

begin_function
DECL|method|checkLocatedFileStatusScanFile ()
unit|public
name|void
name|checkLocatedFileStatusScanFile
parameter_list|()
throws|throws
name|Throwable
block|{
comment|// pass in a file as the base of the scan.
name|describe
argument_list|(
literal|"LocatedFileStatusFetcher with file %s"
argument_list|,
name|subdirFile
argument_list|)
expr_stmt|;
name|roleConfig
operator|.
name|setInt
argument_list|(
name|LIST_STATUS_NUM_THREADS
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|LocatedFileStatusFetcher
name|fetcher
init|=
operator|new
name|LocatedFileStatusFetcher
argument_list|(
name|roleConfig
argument_list|,
operator|new
name|Path
index|[]
block|{
name|subdirFile
block|}
argument_list|,
literal|true
argument_list|,
name|TEXT_FILE
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|accessDeniedIf
argument_list|(
operator|!
name|guardedInAuthMode
argument_list|,
parameter_list|()
lambda|->
name|fetcher
operator|.
name|getFileStatuses
argument_list|()
argument_list|)
operator|.
name|ifPresent
argument_list|(
name|stats
lambda|->
block|{
name|Assertions
operator|.
name|assertThat
argument_list|(
name|stats
argument_list|)
operator|.
name|describedAs
argument_list|(
literal|"result of located scan"
argument_list|)
operator|.
name|isNotNull
argument_list|()
operator|.
name|flatExtracting
argument_list|(
name|FileStatus
operator|::
name|getPath
argument_list|)
operator|.
name|containsExactly
argument_list|(
name|subdirFile
argument_list|)
argument_list|;
block|}
end_function

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_comment
unit|}
comment|/**    * Explore what happens with a path that does not exist.    */
end_comment

begin_function
DECL|method|checkLocatedFileStatusNonexistentPath ()
unit|public
name|void
name|checkLocatedFileStatusNonexistentPath
parameter_list|()
throws|throws
name|Throwable
block|{
comment|// scan a path that doesn't exist
name|Path
name|nonexistent
init|=
operator|new
name|Path
argument_list|(
name|noReadDir
argument_list|,
literal|"nonexistent"
argument_list|)
decl_stmt|;
name|InvalidInputException
name|ex
init|=
name|intercept
argument_list|(
name|InvalidInputException
operator|.
name|class
argument_list|,
name|DOES_NOT_EXIST
argument_list|,
parameter_list|()
lambda|->
operator|new
name|LocatedFileStatusFetcher
argument_list|(
name|roleConfig
argument_list|,
operator|new
name|Path
index|[]
block|{
name|nonexistent
block|}
argument_list|,
literal|true
argument_list|,
name|EVERYTHING
argument_list|,
literal|true
argument_list|)
operator|.
name|getFileStatuses
argument_list|()
argument_list|)
decl_stmt|;
comment|// validate nested exception
name|assertExceptionContains
argument_list|(
name|DOES_NOT_EXIST
argument_list|,
name|ex
operator|.
name|getCause
argument_list|()
argument_list|)
expr_stmt|;
comment|// a file which exists but which doesn't match the pattern
comment|// is downgraded to not existing.
name|intercept
argument_list|(
name|InvalidInputException
operator|.
name|class
argument_list|,
name|DOES_NOT_EXIST
argument_list|,
parameter_list|()
lambda|->
operator|new
name|LocatedFileStatusFetcher
argument_list|(
name|roleConfig
argument_list|,
operator|new
name|Path
index|[]
block|{
name|noReadDir
block|}
argument_list|,
literal|true
argument_list|,
name|TEXT_FILE
argument_list|,
literal|true
argument_list|)
operator|.
name|getFileStatuses
argument_list|()
argument_list|)
expr_stmt|;
comment|// a pattern under a nonexistent path is considered to not be a match.
name|ex
operator|=
name|intercept
argument_list|(
name|InvalidInputException
operator|.
name|class
argument_list|,
name|MATCHES_0_FILES
argument_list|,
parameter_list|()
lambda|->
operator|new
name|LocatedFileStatusFetcher
argument_list|(
name|roleConfig
argument_list|,
operator|new
name|Path
index|[]
block|{
operator|new
name|Path
argument_list|(
name|nonexistent
argument_list|,
literal|"*.txt)"
argument_list|)
block|}
argument_list|,
literal|true
argument_list|,
name|TEXT_FILE
argument_list|,
literal|true
argument_list|)
operator|.
name|getFileStatuses
argument_list|()
argument_list|)
expr_stmt|;
comment|// validate nested exception
name|assertExceptionContains
argument_list|(
name|MATCHES_0_FILES
argument_list|,
name|ex
operator|.
name|getCause
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**    * Do some cleanup to see what happens with delete calls.    * Cleanup happens in test teardown anyway; doing it here    * just makes use of the delete calls to see how delete failures    * change with permissions and S3Guard stettings.    */
end_comment

begin_function
DECL|method|checkDeleteOperations ()
specifier|public
name|void
name|checkDeleteOperations
parameter_list|()
throws|throws
name|Throwable
block|{
name|describe
argument_list|(
literal|"Testing delete operations"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|authMode
condition|)
block|{
comment|// unguarded or non-auth S3Guard to fail on HEAD + /
name|accessDenied
argument_list|(
parameter_list|()
lambda|->
name|readonlyFS
operator|.
name|delete
argument_list|(
name|emptyDir
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
comment|// to fail on HEAD
name|accessDenied
argument_list|(
parameter_list|()
lambda|->
name|readonlyFS
operator|.
name|delete
argument_list|(
name|emptyFile
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// auth mode checks DDB for status and then issues the DELETE
name|readonlyFS
operator|.
name|delete
argument_list|(
name|emptyDir
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|readonlyFS
operator|.
name|delete
argument_list|(
name|emptyFile
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|// this will succeed for both as there is no subdir marker.
name|readonlyFS
operator|.
name|delete
argument_list|(
name|subDir
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|// after which  it is not there
name|fileNotFound
argument_list|(
parameter_list|()
lambda|->
name|readonlyFS
operator|.
name|getFileStatus
argument_list|(
name|subDir
argument_list|)
argument_list|)
expr_stmt|;
comment|// and nor is its child.
name|fileNotFound
argument_list|(
parameter_list|()
lambda|->
name|readonlyFS
operator|.
name|getFileStatus
argument_list|(
name|subdirFile
argument_list|)
argument_list|)
expr_stmt|;
comment|// now delete the base path
name|readonlyFS
operator|.
name|delete
argument_list|(
name|basePath
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|// and expect an FNFE
name|fileNotFound
argument_list|(
parameter_list|()
lambda|->
name|readonlyFS
operator|.
name|getFileStatus
argument_list|(
name|subDir
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**    * Require an operation to fail with a FileNotFoundException.    * @param eval closure to evaluate.    * @param<T> type of callable    * @return the exception.    * @throws Exception any other exception    */
end_comment

begin_function
DECL|method|fileNotFound (final Callable<T> eval)
specifier|protected
parameter_list|<
name|T
parameter_list|>
name|FileNotFoundException
name|fileNotFound
parameter_list|(
specifier|final
name|Callable
argument_list|<
name|T
argument_list|>
name|eval
parameter_list|)
throws|throws
name|Exception
block|{
return|return
name|intercept
argument_list|(
name|FileNotFoundException
operator|.
name|class
argument_list|,
name|eval
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Require an operation to fail with an AccessDeniedException.    * @param eval closure to evaluate.    * @param<T> type of callable    * @return the exception.    * @throws Exception any other exception    */
end_comment

begin_function
DECL|method|accessDenied (final Callable<T> eval)
specifier|protected
parameter_list|<
name|T
parameter_list|>
name|AccessDeniedException
name|accessDenied
parameter_list|(
specifier|final
name|Callable
argument_list|<
name|T
argument_list|>
name|eval
parameter_list|)
throws|throws
name|Exception
block|{
return|return
name|intercept
argument_list|(
name|AccessDeniedException
operator|.
name|class
argument_list|,
name|eval
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Conditionally expect an operation to fail with an AccessDeniedException.    * @param condition the condition which must be true for access to be denied    * @param eval closure to evaluate.    * @param<T> type of callable    * @return the return value if the call succeeded    * and did not return null.    * @throws Exception any unexpected exception    */
end_comment

begin_function
DECL|method|accessDeniedIf ( final boolean condition, final Callable<T> eval)
specifier|protected
parameter_list|<
name|T
parameter_list|>
name|Optional
argument_list|<
name|T
argument_list|>
name|accessDeniedIf
parameter_list|(
specifier|final
name|boolean
name|condition
parameter_list|,
specifier|final
name|Callable
argument_list|<
name|T
argument_list|>
name|eval
parameter_list|)
throws|throws
name|Exception
block|{
if|if
condition|(
name|condition
condition|)
block|{
name|intercept
argument_list|(
name|AccessDeniedException
operator|.
name|class
argument_list|,
name|eval
argument_list|)
expr_stmt|;
return|return
name|Optional
operator|.
name|empty
argument_list|()
return|;
block|}
else|else
block|{
return|return
name|Optional
operator|.
name|ofNullable
argument_list|(
name|eval
operator|.
name|call
argument_list|()
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/**    * Assert that a status array has exactly one element and its    * value is as expected.    * @param expected expected path    * @param statuses list of statuses    */
end_comment

begin_function
DECL|method|assertStatusPathEquals (final Path expected, final FileStatus[] statuses)
specifier|protected
name|void
name|assertStatusPathEquals
parameter_list|(
specifier|final
name|Path
name|expected
parameter_list|,
specifier|final
name|FileStatus
index|[]
name|statuses
parameter_list|)
block|{
name|Assertions
operator|.
name|assertThat
argument_list|(
name|statuses
argument_list|)
operator|.
name|describedAs
argument_list|(
literal|"List of status entries"
argument_list|)
operator|.
name|isNotNull
argument_list|()
operator|.
name|hasSize
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|Assertions
operator|.
name|assertThat
argument_list|(
name|statuses
index|[
literal|0
index|]
operator|.
name|getPath
argument_list|()
argument_list|)
operator|.
name|describedAs
argument_list|(
literal|"Status entry %s"
argument_list|,
name|statuses
index|[
literal|0
index|]
argument_list|)
operator|.
name|isEqualTo
argument_list|(
name|expected
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**    * Glob under a path with expected outcomes.    * @param fs filesystem to use    * @param path path (which can include patterns)    * @param filter optional filter    * @param expectAuthFailure is auth failure expected?    * @param expectedCount expected count of results; -1 means null response    * @return the result of a successful glob or null if an expected auth    *          failure was caught.    * @throws IOException failure.    */
end_comment

begin_function
DECL|method|globFS ( final S3AFileSystem fs, final Path path, final PathFilter filter, boolean expectAuthFailure, final int expectedCount)
specifier|protected
name|FileStatus
index|[]
name|globFS
parameter_list|(
specifier|final
name|S3AFileSystem
name|fs
parameter_list|,
specifier|final
name|Path
name|path
parameter_list|,
specifier|final
name|PathFilter
name|filter
parameter_list|,
name|boolean
name|expectAuthFailure
parameter_list|,
specifier|final
name|int
name|expectedCount
parameter_list|)
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Glob {}"
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|S3ATestUtils
operator|.
name|MetricDiff
name|getMetric
init|=
operator|new
name|S3ATestUtils
operator|.
name|MetricDiff
argument_list|(
name|fs
argument_list|,
name|Statistic
operator|.
name|OBJECT_METADATA_REQUESTS
argument_list|)
decl_stmt|;
name|S3ATestUtils
operator|.
name|MetricDiff
name|listMetric
init|=
operator|new
name|S3ATestUtils
operator|.
name|MetricDiff
argument_list|(
name|fs
argument_list|,
name|Statistic
operator|.
name|OBJECT_LIST_REQUESTS
argument_list|)
decl_stmt|;
name|FileStatus
index|[]
name|st
decl_stmt|;
try|try
block|{
name|st
operator|=
name|filter
operator|==
literal|null
condition|?
name|fs
operator|.
name|globStatus
argument_list|(
name|path
argument_list|)
else|:
name|fs
operator|.
name|globStatus
argument_list|(
name|path
argument_list|,
name|filter
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Metrics:\n {},\n {}"
argument_list|,
name|getMetric
argument_list|,
name|listMetric
argument_list|)
expr_stmt|;
if|if
condition|(
name|expectAuthFailure
condition|)
block|{
comment|// should have failed here
name|String
name|resultStr
decl_stmt|;
if|if
condition|(
name|st
operator|==
literal|null
condition|)
block|{
name|resultStr
operator|=
literal|"A null array"
expr_stmt|;
block|}
else|else
block|{
name|resultStr
operator|=
name|StringUtils
operator|.
name|join
argument_list|(
name|st
argument_list|,
literal|","
argument_list|)
expr_stmt|;
block|}
name|fail
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"globStatus(%s) should have raised"
operator|+
literal|" an exception, but returned %s"
argument_list|,
name|path
argument_list|,
name|resultStr
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|AccessDeniedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Metrics:\n {},\n {}"
argument_list|,
name|getMetric
argument_list|,
name|listMetric
argument_list|)
expr_stmt|;
name|failif
argument_list|(
operator|!
name|expectAuthFailure
argument_list|,
literal|"Access denied in glob of "
operator|+
name|path
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
catch|catch
parameter_list|(
name|IOException
decl||
name|RuntimeException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"Other exception raised in glob:"
operator|+
name|e
argument_list|,
name|e
argument_list|)
throw|;
block|}
if|if
condition|(
name|expectedCount
operator|<
literal|0
condition|)
block|{
name|Assertions
operator|.
name|assertThat
argument_list|(
name|st
argument_list|)
operator|.
name|describedAs
argument_list|(
literal|"Glob of %s"
argument_list|,
name|path
argument_list|)
operator|.
name|isNull
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|Assertions
operator|.
name|assertThat
argument_list|(
name|st
argument_list|)
operator|.
name|describedAs
argument_list|(
literal|"Glob of %s"
argument_list|,
name|path
argument_list|)
operator|.
name|isNotNull
argument_list|()
operator|.
name|hasSize
argument_list|(
name|expectedCount
argument_list|)
expr_stmt|;
block|}
return|return
name|st
return|;
block|}
end_function

unit|}
end_unit

