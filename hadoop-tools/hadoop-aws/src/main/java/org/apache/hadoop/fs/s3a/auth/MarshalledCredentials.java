begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.fs.s3a.auth
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|auth
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataInput
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataOutput
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Serializable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|time
operator|.
name|OffsetDateTime
import|;
end_import

begin_import
import|import
name|java
operator|.
name|time
operator|.
name|ZoneOffset
import|;
end_import

begin_import
import|import
name|java
operator|.
name|time
operator|.
name|format
operator|.
name|DateTimeFormatter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Date
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Objects
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Optional
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|S3AUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|auth
operator|.
name|delegation
operator|.
name|DelegationTokenIOException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|Text
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|Writable
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|util
operator|.
name|Objects
operator|.
name|requireNonNull
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang3
operator|.
name|StringUtils
operator|.
name|isNotEmpty
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|Constants
operator|.
name|ACCESS_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|Constants
operator|.
name|SECRET_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|Constants
operator|.
name|SESSION_TOKEN
import|;
end_import

begin_comment
comment|/**  * Stores the credentials for a session or for a full login.  * This structure is {@link Writable}, so can be marshalled inside a  * delegation token.  *  * The class is designed so that keys inside are kept non-null; to be  * unset just set them to the empty string. This is to simplify marshalling.  *  *<i>Important: Add no references to any AWS SDK class, to  * ensure it can be safely deserialized whenever the relevant token  * identifier of a token type declared in this JAR is examined.</i>  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
DECL|class|MarshalledCredentials
specifier|public
specifier|final
class|class
name|MarshalledCredentials
implements|implements
name|Writable
implements|,
name|Serializable
block|{
comment|/**    * Error text on invalid non-empty credentials: {@value}.    */
annotation|@
name|VisibleForTesting
DECL|field|INVALID_CREDENTIALS
specifier|public
specifier|static
specifier|final
name|String
name|INVALID_CREDENTIALS
init|=
literal|"Invalid AWS credentials"
decl_stmt|;
comment|/**    * How long can any of the secrets be: {@value}.    * This is much longer than the current tokens, but leaves space for    * future enhancements.    */
DECL|field|MAX_SECRET_LENGTH
specifier|private
specifier|static
specifier|final
name|int
name|MAX_SECRET_LENGTH
init|=
literal|8192
decl_stmt|;
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|8444610385533920692L
decl_stmt|;
comment|/**    * Access key of IAM account.    */
DECL|field|accessKey
specifier|private
name|String
name|accessKey
init|=
literal|""
decl_stmt|;
comment|/**    * Secret key of IAM account.    */
DECL|field|secretKey
specifier|private
name|String
name|secretKey
init|=
literal|""
decl_stmt|;
comment|/**    * Optional session token.    * If non-empty: the credentials can be converted into    * session credentials.    */
DECL|field|sessionToken
specifier|private
name|String
name|sessionToken
init|=
literal|""
decl_stmt|;
comment|/**    * ARN of a role. Purely for diagnostics.    */
DECL|field|roleARN
specifier|private
name|String
name|roleARN
init|=
literal|""
decl_stmt|;
comment|/**    * Expiry time milliseconds in UTC; the {@code Java.Util.Date} value.    * 0 means "does not expire/unknown".    */
DECL|field|expiration
specifier|private
name|long
name|expiration
decl_stmt|;
comment|/**    * Constructor.    */
DECL|method|MarshalledCredentials ()
specifier|public
name|MarshalledCredentials
parameter_list|()
block|{   }
comment|/**    * Create from a set of properties.    * No expiry time is expected/known here.    * @param accessKey access key    * @param secretKey secret key    * @param sessionToken session token    */
DECL|method|MarshalledCredentials ( final String accessKey, final String secretKey, final String sessionToken)
specifier|public
name|MarshalledCredentials
parameter_list|(
specifier|final
name|String
name|accessKey
parameter_list|,
specifier|final
name|String
name|secretKey
parameter_list|,
specifier|final
name|String
name|sessionToken
parameter_list|)
block|{
name|this
argument_list|()
expr_stmt|;
name|this
operator|.
name|accessKey
operator|=
name|requireNonNull
argument_list|(
name|accessKey
argument_list|)
expr_stmt|;
name|this
operator|.
name|secretKey
operator|=
name|requireNonNull
argument_list|(
name|secretKey
argument_list|)
expr_stmt|;
name|this
operator|.
name|sessionToken
operator|=
name|sessionToken
operator|==
literal|null
condition|?
literal|""
else|:
name|sessionToken
expr_stmt|;
block|}
DECL|method|getAccessKey ()
specifier|public
name|String
name|getAccessKey
parameter_list|()
block|{
return|return
name|accessKey
return|;
block|}
DECL|method|getSecretKey ()
specifier|public
name|String
name|getSecretKey
parameter_list|()
block|{
return|return
name|secretKey
return|;
block|}
DECL|method|getSessionToken ()
specifier|public
name|String
name|getSessionToken
parameter_list|()
block|{
return|return
name|sessionToken
return|;
block|}
comment|/**    * Expiration; will be 0 for none known.    * @return any expiration timestamp    */
DECL|method|getExpiration ()
specifier|public
name|long
name|getExpiration
parameter_list|()
block|{
return|return
name|expiration
return|;
block|}
DECL|method|setExpiration (final long expiration)
specifier|public
name|void
name|setExpiration
parameter_list|(
specifier|final
name|long
name|expiration
parameter_list|)
block|{
name|this
operator|.
name|expiration
operator|=
name|expiration
expr_stmt|;
block|}
comment|/**    * Get a temporal representing the time of expiration, if there    * is one.    * This is here to wrap up expectations about timestamps and zones.    * @return the expiration time.    */
DECL|method|getExpirationDateTime ()
specifier|public
name|Optional
argument_list|<
name|OffsetDateTime
argument_list|>
name|getExpirationDateTime
parameter_list|()
block|{
return|return
name|expiration
operator|==
literal|0
condition|?
name|Optional
operator|.
name|empty
argument_list|()
else|:
name|Optional
operator|.
name|of
argument_list|(
name|OffsetDateTime
operator|.
name|ofInstant
argument_list|(
operator|new
name|Date
argument_list|(
name|expiration
argument_list|)
operator|.
name|toInstant
argument_list|()
argument_list|,
name|ZoneOffset
operator|.
name|UTC
argument_list|)
argument_list|)
return|;
block|}
DECL|method|getRoleARN ()
specifier|public
name|String
name|getRoleARN
parameter_list|()
block|{
return|return
name|roleARN
return|;
block|}
DECL|method|setRoleARN (String roleARN)
specifier|public
name|void
name|setRoleARN
parameter_list|(
name|String
name|roleARN
parameter_list|)
block|{
name|this
operator|.
name|roleARN
operator|=
name|requireNonNull
argument_list|(
name|roleARN
argument_list|)
expr_stmt|;
block|}
DECL|method|setAccessKey (final String accessKey)
specifier|public
name|void
name|setAccessKey
parameter_list|(
specifier|final
name|String
name|accessKey
parameter_list|)
block|{
name|this
operator|.
name|accessKey
operator|=
name|requireNonNull
argument_list|(
name|accessKey
argument_list|,
literal|"access key"
argument_list|)
expr_stmt|;
block|}
DECL|method|setSecretKey (final String secretKey)
specifier|public
name|void
name|setSecretKey
parameter_list|(
specifier|final
name|String
name|secretKey
parameter_list|)
block|{
name|this
operator|.
name|secretKey
operator|=
name|requireNonNull
argument_list|(
name|secretKey
argument_list|,
literal|"secret key"
argument_list|)
expr_stmt|;
block|}
DECL|method|setSessionToken (final String sessionToken)
specifier|public
name|void
name|setSessionToken
parameter_list|(
specifier|final
name|String
name|sessionToken
parameter_list|)
block|{
name|this
operator|.
name|sessionToken
operator|=
name|requireNonNull
argument_list|(
name|sessionToken
argument_list|,
literal|"session token"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|equals (Object o)
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
name|this
operator|==
name|o
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
name|o
operator|==
literal|null
operator|||
name|getClass
argument_list|()
operator|!=
name|o
operator|.
name|getClass
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
name|MarshalledCredentials
name|that
init|=
operator|(
name|MarshalledCredentials
operator|)
name|o
decl_stmt|;
return|return
name|expiration
operator|==
name|that
operator|.
name|expiration
operator|&&
name|Objects
operator|.
name|equals
argument_list|(
name|accessKey
argument_list|,
name|that
operator|.
name|accessKey
argument_list|)
operator|&&
name|Objects
operator|.
name|equals
argument_list|(
name|secretKey
argument_list|,
name|that
operator|.
name|secretKey
argument_list|)
operator|&&
name|Objects
operator|.
name|equals
argument_list|(
name|sessionToken
argument_list|,
name|that
operator|.
name|sessionToken
argument_list|)
operator|&&
name|Objects
operator|.
name|equals
argument_list|(
name|roleARN
argument_list|,
name|that
operator|.
name|roleARN
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|hashCode ()
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|Objects
operator|.
name|hash
argument_list|(
name|accessKey
argument_list|,
name|secretKey
argument_list|,
name|sessionToken
argument_list|,
name|roleARN
argument_list|,
name|expiration
argument_list|)
return|;
block|}
comment|/**    * String value MUST NOT include any secrets.    * @return a string value for logging.    */
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
if|if
condition|(
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|"Empty credentials"
return|;
block|}
name|String
name|validity
init|=
name|isValid
argument_list|(
name|CredentialTypeRequired
operator|.
name|AnyNonEmpty
argument_list|)
condition|?
literal|"valid"
else|:
literal|"invalid"
decl_stmt|;
if|if
condition|(
operator|!
name|hasSessionToken
argument_list|()
condition|)
block|{
comment|// full credentials have the simplest string value.
return|return
literal|"full credentials ("
operator|+
name|validity
operator|+
literal|")"
return|;
block|}
else|else
block|{
comment|// session/role credentials may have an expiry and role ARN.
return|return
name|String
operator|.
name|format
argument_list|(
literal|"session credentials, expiry %s; %s(%s)"
argument_list|,
name|getExpirationDateTime
argument_list|()
operator|.
name|map
argument_list|(
name|x
lambda|->
name|x
operator|.
name|format
argument_list|(
name|DateTimeFormatter
operator|.
name|ISO_DATE
argument_list|)
argument_list|)
operator|.
name|orElse
argument_list|(
literal|"unknown"
argument_list|)
argument_list|,
operator|(
name|isNotEmpty
argument_list|(
name|roleARN
argument_list|)
condition|?
operator|(
literal|"role \""
operator|+
name|roleARN
operator|+
literal|"\" "
operator|)
else|:
literal|""
operator|)
argument_list|,
name|validity
argument_list|)
return|;
block|}
block|}
comment|/**    * Is this empty: does it contain any credentials at all?    * This test returns true if either the access key or secret key is empty.    * @return true if there are no credentials.    */
DECL|method|isEmpty ()
specifier|public
name|boolean
name|isEmpty
parameter_list|()
block|{
return|return
operator|!
operator|(
name|isNotEmpty
argument_list|(
name|accessKey
argument_list|)
operator|&&
name|isNotEmpty
argument_list|(
name|secretKey
argument_list|)
operator|)
return|;
block|}
comment|/**    * Is this a valid set of credentials tokens?    * @param required credential type required.    * @return true if the requirements are met.    */
DECL|method|isValid (final CredentialTypeRequired required)
specifier|public
name|boolean
name|isValid
parameter_list|(
specifier|final
name|CredentialTypeRequired
name|required
parameter_list|)
block|{
if|if
condition|(
name|accessKey
operator|==
literal|null
operator|||
name|secretKey
operator|==
literal|null
operator|||
name|sessionToken
operator|==
literal|null
condition|)
block|{
comment|// null fields are not permitted, empty is OK for marshalling around.
return|return
literal|false
return|;
block|}
comment|// now look at whether values are set/unset.
name|boolean
name|hasAccessAndSecretKeys
init|=
name|isNotEmpty
argument_list|(
name|accessKey
argument_list|)
operator|&&
name|isNotEmpty
argument_list|(
name|secretKey
argument_list|)
decl_stmt|;
name|boolean
name|hasSessionToken
init|=
name|hasSessionToken
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|required
condition|)
block|{
case|case
name|AnyIncludingEmpty
case|:
comment|// this is simplest.
return|return
literal|true
return|;
case|case
name|Empty
case|:
comment|// empty. ignore session value if the other keys are unset.
return|return
operator|!
name|hasAccessAndSecretKeys
return|;
case|case
name|AnyNonEmpty
case|:
comment|// just look for the access key and secret key being non-empty
return|return
name|hasAccessAndSecretKeys
return|;
case|case
name|FullOnly
case|:
return|return
name|hasAccessAndSecretKeys
operator|&&
operator|!
name|hasSessionToken
return|;
case|case
name|SessionOnly
case|:
return|return
name|hasAccessAndSecretKeys
operator|&&
name|hasSessionToken
argument_list|()
return|;
comment|// this is here to keep the IDE quiet
default|default:
return|return
literal|false
return|;
block|}
block|}
comment|/**    * Does this set of credentials have a session token.    * @return true if there's a session token.    */
DECL|method|hasSessionToken ()
specifier|public
name|boolean
name|hasSessionToken
parameter_list|()
block|{
return|return
name|isNotEmpty
argument_list|(
name|sessionToken
argument_list|)
return|;
block|}
comment|/**    * Write the token.    * Only works if valid.    * @param out stream to serialize to.    * @throws IOException if the serialization failed.    */
annotation|@
name|Override
DECL|method|write (DataOutput out)
specifier|public
name|void
name|write
parameter_list|(
name|DataOutput
name|out
parameter_list|)
throws|throws
name|IOException
block|{
name|validate
argument_list|(
literal|"Writing "
operator|+
name|this
operator|+
literal|": "
argument_list|,
name|CredentialTypeRequired
operator|.
name|AnyIncludingEmpty
argument_list|)
expr_stmt|;
name|Text
operator|.
name|writeString
argument_list|(
name|out
argument_list|,
name|accessKey
argument_list|)
expr_stmt|;
name|Text
operator|.
name|writeString
argument_list|(
name|out
argument_list|,
name|secretKey
argument_list|)
expr_stmt|;
name|Text
operator|.
name|writeString
argument_list|(
name|out
argument_list|,
name|sessionToken
argument_list|)
expr_stmt|;
name|Text
operator|.
name|writeString
argument_list|(
name|out
argument_list|,
name|roleARN
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeLong
argument_list|(
name|expiration
argument_list|)
expr_stmt|;
block|}
comment|/**    * Read in the fields.    * @throws IOException IO problem    */
annotation|@
name|Override
DECL|method|readFields (DataInput in)
specifier|public
name|void
name|readFields
parameter_list|(
name|DataInput
name|in
parameter_list|)
throws|throws
name|IOException
block|{
name|accessKey
operator|=
name|Text
operator|.
name|readString
argument_list|(
name|in
argument_list|,
name|MAX_SECRET_LENGTH
argument_list|)
expr_stmt|;
name|secretKey
operator|=
name|Text
operator|.
name|readString
argument_list|(
name|in
argument_list|,
name|MAX_SECRET_LENGTH
argument_list|)
expr_stmt|;
name|sessionToken
operator|=
name|Text
operator|.
name|readString
argument_list|(
name|in
argument_list|,
name|MAX_SECRET_LENGTH
argument_list|)
expr_stmt|;
name|roleARN
operator|=
name|Text
operator|.
name|readString
argument_list|(
name|in
argument_list|,
name|MAX_SECRET_LENGTH
argument_list|)
expr_stmt|;
name|expiration
operator|=
name|in
operator|.
name|readLong
argument_list|()
expr_stmt|;
block|}
comment|/**    * Verify that a set of credentials is valid.    * @throws DelegationTokenIOException if they aren't    * @param message message to prefix errors;    * @param typeRequired credential type required.    */
DECL|method|validate (final String message, final CredentialTypeRequired typeRequired)
specifier|public
name|void
name|validate
parameter_list|(
specifier|final
name|String
name|message
parameter_list|,
specifier|final
name|CredentialTypeRequired
name|typeRequired
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|isValid
argument_list|(
name|typeRequired
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|DelegationTokenIOException
argument_list|(
name|message
operator|+
name|buildInvalidCredentialsError
argument_list|(
name|typeRequired
argument_list|)
argument_list|)
throw|;
block|}
block|}
comment|/**    * Build an error string for when the credentials do not match    * those required.    * @param typeRequired credential type required.    * @return an error string.    */
DECL|method|buildInvalidCredentialsError ( final CredentialTypeRequired typeRequired)
specifier|public
name|String
name|buildInvalidCredentialsError
parameter_list|(
specifier|final
name|CredentialTypeRequired
name|typeRequired
parameter_list|)
block|{
if|if
condition|(
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|" "
operator|+
name|MarshalledCredentialBinding
operator|.
name|NO_AWS_CREDENTIALS
return|;
block|}
else|else
block|{
return|return
literal|" "
operator|+
name|INVALID_CREDENTIALS
operator|+
literal|" in "
operator|+
name|toString
argument_list|()
operator|+
literal|" required: "
operator|+
name|typeRequired
return|;
block|}
block|}
comment|/**    * Patch a configuration with the secrets.    * This does not set any per-bucket options (it doesn't know the bucket...).    *<i>Warning: once done the configuration must be considered sensitive.</i>    * @param config configuration to patch    */
DECL|method|setSecretsInConfiguration (Configuration config)
specifier|public
name|void
name|setSecretsInConfiguration
parameter_list|(
name|Configuration
name|config
parameter_list|)
block|{
name|config
operator|.
name|set
argument_list|(
name|ACCESS_KEY
argument_list|,
name|accessKey
argument_list|)
expr_stmt|;
name|config
operator|.
name|set
argument_list|(
name|SECRET_KEY
argument_list|,
name|secretKey
argument_list|)
expr_stmt|;
name|S3AUtils
operator|.
name|setIfDefined
argument_list|(
name|config
argument_list|,
name|SESSION_TOKEN
argument_list|,
name|sessionToken
argument_list|,
literal|"session credentials"
argument_list|)
expr_stmt|;
block|}
comment|/**    * Return a set of empty credentials.    * These can be marshalled, but not used for login.    * @return a new set of credentials.    */
DECL|method|empty ()
specifier|public
specifier|static
name|MarshalledCredentials
name|empty
parameter_list|()
block|{
return|return
operator|new
name|MarshalledCredentials
argument_list|(
literal|""
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
return|;
block|}
comment|/**    * Enumeration of credential types for use in validation methods.    */
DECL|enum|CredentialTypeRequired
specifier|public
enum|enum
name|CredentialTypeRequired
block|{
comment|/** No entry at all. */
DECL|enumConstant|Empty
name|Empty
argument_list|(
literal|"None"
argument_list|)
block|,
comment|/** Any credential type including "unset". */
DECL|enumConstant|AnyIncludingEmpty
name|AnyIncludingEmpty
argument_list|(
literal|"Full, Session or None"
argument_list|)
block|,
comment|/** Any credential type is OK. */
DECL|enumConstant|AnyNonEmpty
name|AnyNonEmpty
argument_list|(
literal|"Full or Session"
argument_list|)
block|,
comment|/** The credentials must be session or role credentials. */
DECL|enumConstant|SessionOnly
name|SessionOnly
argument_list|(
literal|"Session"
argument_list|)
block|,
comment|/** Full credentials are required. */
DECL|enumConstant|FullOnly
name|FullOnly
argument_list|(
literal|"Full"
argument_list|)
block|;
DECL|field|text
specifier|private
specifier|final
name|String
name|text
decl_stmt|;
DECL|method|CredentialTypeRequired (final String text)
name|CredentialTypeRequired
parameter_list|(
specifier|final
name|String
name|text
parameter_list|)
block|{
name|this
operator|.
name|text
operator|=
name|text
expr_stmt|;
block|}
DECL|method|getText ()
specifier|public
name|String
name|getText
parameter_list|()
block|{
return|return
name|text
return|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|getText
argument_list|()
return|;
block|}
block|}
block|}
end_class

end_unit

