begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.fs.s3a.s3guard
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|s3guard
package|;
end_package

begin_import
import|import
name|javax
operator|.
name|annotation
operator|.
name|Nullable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Closeable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileNotFoundException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|PrintWriter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URI
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayDeque
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Date
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Deque
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|com
operator|.
name|amazonaws
operator|.
name|services
operator|.
name|dynamodbv2
operator|.
name|xspec
operator|.
name|ExpressionSpecBuilder
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang3
operator|.
name|tuple
operator|.
name|Pair
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceStability
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|PathIOException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|RemoteIterator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|Listing
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|S3AFileStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|S3AFileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|S3ALocatedFileStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|S3ListRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|service
operator|.
name|Service
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|service
operator|.
name|launcher
operator|.
name|LauncherExitCodes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|service
operator|.
name|launcher
operator|.
name|ServiceLaunchException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|service
operator|.
name|launcher
operator|.
name|ServiceLauncher
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|DurationInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|ExitUtil
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkNotNull
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|S3AUtils
operator|.
name|ACCEPT_ALL
import|;
end_import

begin_comment
comment|/**  * This is a low-level diagnostics entry point which does a CVE/TSV dump of  * the DDB state.  * As it also lists the filesystem, it actually changes the state of the store  * during the operation.  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
annotation|@
name|InterfaceStability
operator|.
name|Unstable
DECL|class|DumpS3GuardDynamoTable
specifier|public
class|class
name|DumpS3GuardDynamoTable
extends|extends
name|AbstractS3GuardDynamoDBDiagnostic
block|{
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|DumpS3GuardDynamoTable
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/**    * Application name.    */
DECL|field|NAME
specifier|public
specifier|static
specifier|final
name|String
name|NAME
init|=
literal|"DumpS3GuardDynamoTable"
decl_stmt|;
comment|/**    * Usage.    */
DECL|field|USAGE_MESSAGE
specifier|private
specifier|static
specifier|final
name|String
name|USAGE_MESSAGE
init|=
name|NAME
operator|+
literal|"<filesystem><dest-file>"
decl_stmt|;
comment|/**    * Suffix for the flat list: {@value}.    */
DECL|field|FLAT_CSV
specifier|public
specifier|static
specifier|final
name|String
name|FLAT_CSV
init|=
literal|"-flat.csv"
decl_stmt|;
comment|/**    * Suffix for the raw S3 dump: {@value}.    */
DECL|field|RAW_CSV
specifier|public
specifier|static
specifier|final
name|String
name|RAW_CSV
init|=
literal|"-s3.csv"
decl_stmt|;
comment|/**    * Suffix for the DDB scan: {@value}.    */
DECL|field|SCAN_CSV
specifier|public
specifier|static
specifier|final
name|String
name|SCAN_CSV
init|=
literal|"-scan.csv"
decl_stmt|;
comment|/**    * Suffix for the second DDB scan: : {@value}.    */
DECL|field|SCAN2_CSV
specifier|public
specifier|static
specifier|final
name|String
name|SCAN2_CSV
init|=
literal|"-scan-2.csv"
decl_stmt|;
comment|/**    * Suffix for the treewalk scan of the S3A Filesystem: {@value}.    */
DECL|field|TREE_CSV
specifier|public
specifier|static
specifier|final
name|String
name|TREE_CSV
init|=
literal|"-tree.csv"
decl_stmt|;
comment|/**    * Suffix for a recursive treewalk through the metastore: {@value}.    */
DECL|field|STORE_CSV
specifier|public
specifier|static
specifier|final
name|String
name|STORE_CSV
init|=
literal|"-store.csv"
decl_stmt|;
comment|/**    * Path in the local filesystem to save the data.    */
DECL|field|destPath
specifier|private
name|String
name|destPath
decl_stmt|;
DECL|field|scanEntryResult
specifier|private
name|Pair
argument_list|<
name|Long
argument_list|,
name|Long
argument_list|>
name|scanEntryResult
decl_stmt|;
DECL|field|secondScanResult
specifier|private
name|Pair
argument_list|<
name|Long
argument_list|,
name|Long
argument_list|>
name|secondScanResult
decl_stmt|;
DECL|field|rawObjectStoreCount
specifier|private
name|long
name|rawObjectStoreCount
decl_stmt|;
DECL|field|listStatusCount
specifier|private
name|long
name|listStatusCount
decl_stmt|;
DECL|field|treewalkCount
specifier|private
name|long
name|treewalkCount
decl_stmt|;
comment|/**    * Instantiate.    * @param name application name.    */
DECL|method|DumpS3GuardDynamoTable (final String name)
specifier|public
name|DumpS3GuardDynamoTable
parameter_list|(
specifier|final
name|String
name|name
parameter_list|)
block|{
name|super
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
comment|/**    * Instantiate with default name.    */
DECL|method|DumpS3GuardDynamoTable ()
specifier|public
name|DumpS3GuardDynamoTable
parameter_list|()
block|{
name|this
argument_list|(
name|NAME
argument_list|)
expr_stmt|;
block|}
comment|/**    * Bind to a specific FS + store.    * @param fs filesystem    * @param store metastore to use    * @param destFile the base filename for output    * @param uri URI of store -only needed if FS is null.    */
DECL|method|DumpS3GuardDynamoTable ( final S3AFileSystem fs, final DynamoDBMetadataStore store, final File destFile, final URI uri)
specifier|public
name|DumpS3GuardDynamoTable
parameter_list|(
specifier|final
name|S3AFileSystem
name|fs
parameter_list|,
specifier|final
name|DynamoDBMetadataStore
name|store
parameter_list|,
specifier|final
name|File
name|destFile
parameter_list|,
specifier|final
name|URI
name|uri
parameter_list|)
block|{
name|super
argument_list|(
name|NAME
argument_list|,
name|fs
argument_list|,
name|store
argument_list|,
name|uri
argument_list|)
expr_stmt|;
name|this
operator|.
name|destPath
operator|=
name|destFile
operator|.
name|getAbsolutePath
argument_list|()
expr_stmt|;
block|}
comment|/**    * Bind to the argument list, including validating the CLI.    * @throws Exception failure.    */
annotation|@
name|Override
DECL|method|serviceStart ()
specifier|protected
name|void
name|serviceStart
parameter_list|()
throws|throws
name|Exception
block|{
if|if
condition|(
name|getStore
argument_list|()
operator|==
literal|null
condition|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|arg
init|=
name|getArgumentList
argument_list|(
literal|2
argument_list|,
literal|2
argument_list|,
name|USAGE_MESSAGE
argument_list|)
decl_stmt|;
name|bindFromCLI
argument_list|(
name|arg
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|destPath
operator|=
name|arg
operator|.
name|get
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Dump the filesystem and the metastore.    * @return the exit code.    * @throws ServiceLaunchException on failure.    * @throws IOException IO failure.    */
annotation|@
name|Override
DECL|method|execute ()
specifier|public
name|int
name|execute
parameter_list|()
throws|throws
name|ServiceLaunchException
throws|,
name|IOException
block|{
try|try
block|{
specifier|final
name|File
name|scanFile
init|=
operator|new
name|File
argument_list|(
name|destPath
operator|+
name|SCAN_CSV
argument_list|)
operator|.
name|getCanonicalFile
argument_list|()
decl_stmt|;
name|File
name|parentDir
init|=
name|scanFile
operator|.
name|getParentFile
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|parentDir
operator|.
name|mkdirs
argument_list|()
operator|&&
operator|!
name|parentDir
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|PathIOException
argument_list|(
name|parentDir
operator|.
name|toString
argument_list|()
argument_list|,
literal|"Could not create destination directory"
argument_list|)
throw|;
block|}
try|try
init|(
name|CsvFile
name|csv
init|=
operator|new
name|CsvFile
argument_list|(
name|scanFile
argument_list|)
init|;
name|DurationInfo
name|ignored
operator|=
operator|new
name|DurationInfo
argument_list|(
name|LOG
argument_list|,
literal|"scanFile dump to %s"
argument_list|,
name|scanFile
argument_list|)
init|)
block|{
name|scanEntryResult
operator|=
name|scanMetastore
argument_list|(
name|csv
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|getFilesystem
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|Path
name|basePath
init|=
name|getFilesystem
argument_list|()
operator|.
name|qualify
argument_list|(
operator|new
name|Path
argument_list|(
name|getUri
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|File
name|destFile
init|=
operator|new
name|File
argument_list|(
name|destPath
operator|+
name|STORE_CSV
argument_list|)
operator|.
name|getCanonicalFile
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Writing Store details to {}"
argument_list|,
name|destFile
argument_list|)
expr_stmt|;
try|try
init|(
name|CsvFile
name|csv
init|=
operator|new
name|CsvFile
argument_list|(
name|destFile
argument_list|)
init|;              DurationInfo ignored = new DurationInfo(LOG
operator|,
init|"List metastore")
block|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Base path: {}"
argument_list|,
name|basePath
argument_list|)
expr_stmt|;
name|dumpMetastore
argument_list|(
name|csv
argument_list|,
name|basePath
argument_list|)
expr_stmt|;
block|}
comment|// these operations all update the metastore as they list,
comment|// that is: they are side-effecting.
specifier|final
name|File
name|treewalkFile
init|=
operator|new
name|File
argument_list|(
name|destPath
operator|+
name|TREE_CSV
argument_list|)
operator|.
name|getCanonicalFile
argument_list|()
decl_stmt|;
try|try
init|(
name|CsvFile
name|csv
init|=
operator|new
name|CsvFile
argument_list|(
name|treewalkFile
argument_list|)
init|;
name|DurationInfo
name|ignored
operator|=
operator|new
name|DurationInfo
argument_list|(
name|LOG
argument_list|,
literal|"Treewalk to %s"
argument_list|,
name|treewalkFile
argument_list|)
init|)
block|{
name|treewalkCount
operator|=
name|treewalkFilesystem
argument_list|(
name|csv
argument_list|,
name|basePath
argument_list|)
expr_stmt|;
block|}
specifier|final
name|File
name|flatlistFile
init|=
operator|new
name|File
argument_list|(
name|destPath
operator|+
name|FLAT_CSV
argument_list|)
operator|.
name|getCanonicalFile
argument_list|()
decl_stmt|;
try|try
init|(
name|CsvFile
name|csv
init|=
operator|new
name|CsvFile
argument_list|(
name|flatlistFile
argument_list|)
init|;
name|DurationInfo
name|ignored
operator|=
operator|new
name|DurationInfo
argument_list|(
name|LOG
argument_list|,
literal|"Flat list to %s"
argument_list|,
name|flatlistFile
argument_list|)
init|)
block|{
name|listStatusCount
operator|=
name|listStatusFilesystem
argument_list|(
name|csv
argument_list|,
name|basePath
argument_list|)
expr_stmt|;
block|}
specifier|final
name|File
name|rawFile
init|=
operator|new
name|File
argument_list|(
name|destPath
operator|+
name|RAW_CSV
argument_list|)
operator|.
name|getCanonicalFile
argument_list|()
decl_stmt|;
try|try
init|(
name|CsvFile
name|csv
init|=
operator|new
name|CsvFile
argument_list|(
name|rawFile
argument_list|)
init|;
name|DurationInfo
name|ignored
operator|=
operator|new
name|DurationInfo
argument_list|(
name|LOG
argument_list|,
literal|"Raw dump to %s"
argument_list|,
name|rawFile
argument_list|)
init|)
block|{
name|rawObjectStoreCount
operator|=
name|dumpRawS3ObjectStore
argument_list|(
name|csv
argument_list|)
expr_stmt|;
block|}
specifier|final
name|File
name|scanFile2
init|=
operator|new
name|File
argument_list|(
name|destPath
operator|+
name|SCAN2_CSV
argument_list|)
operator|.
name|getCanonicalFile
argument_list|()
decl_stmt|;
try|try
init|(
name|CsvFile
name|csv
init|=
operator|new
name|CsvFile
argument_list|(
name|scanFile
argument_list|)
init|;
name|DurationInfo
name|ignored
operator|=
operator|new
name|DurationInfo
argument_list|(
name|LOG
argument_list|,
literal|"scanFile dump to %s"
argument_list|,
name|scanFile2
argument_list|)
init|)
block|{
name|secondScanResult
operator|=
name|scanMetastore
argument_list|(
name|csv
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|LauncherExitCodes
operator|.
name|EXIT_SUCCESS
return|;
block|}
catch|catch
parameter_list|(
name|IOException
decl||
name|RuntimeException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"failure"
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
end_class

begin_comment
comment|/**    * Push all elements of a list to a queue, such that the first entry    * on the list becomes the head of the queue.    * @param queue queue to update    * @param entries list of entries to add.    * @param<T> type of queue    */
end_comment

begin_function
DECL|method|pushAll (Deque<T> queue, List<T> entries)
specifier|private
parameter_list|<
name|T
parameter_list|>
name|void
name|pushAll
parameter_list|(
name|Deque
argument_list|<
name|T
argument_list|>
name|queue
parameter_list|,
name|List
argument_list|<
name|T
argument_list|>
name|entries
parameter_list|)
block|{
name|List
argument_list|<
name|T
argument_list|>
name|reversed
init|=
name|Lists
operator|.
name|reverse
argument_list|(
name|entries
argument_list|)
decl_stmt|;
for|for
control|(
name|T
name|t
range|:
name|reversed
control|)
block|{
name|queue
operator|.
name|push
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**    * Dump the filesystem via a treewalk.    * If metastore entries mark directories as deleted, this    * walk will not explore them.    * @param csv destination.    * @param base base path.    * @return number of entries found.    * @throws IOException IO failure.    */
end_comment

begin_function
DECL|method|treewalkFilesystem ( final CsvFile csv, final Path base)
specifier|protected
name|long
name|treewalkFilesystem
parameter_list|(
specifier|final
name|CsvFile
name|csv
parameter_list|,
specifier|final
name|Path
name|base
parameter_list|)
throws|throws
name|IOException
block|{
name|ArrayDeque
argument_list|<
name|Path
argument_list|>
name|queue
init|=
operator|new
name|ArrayDeque
argument_list|<>
argument_list|()
decl_stmt|;
name|queue
operator|.
name|add
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|long
name|count
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|!
name|queue
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|Path
name|path
init|=
name|queue
operator|.
name|pop
argument_list|()
decl_stmt|;
name|count
operator|++
expr_stmt|;
name|FileStatus
index|[]
name|fileStatuses
decl_stmt|;
try|try
block|{
name|fileStatuses
operator|=
name|getFilesystem
argument_list|()
operator|.
name|listStatus
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"File {} was not found"
argument_list|,
name|path
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|// entries
for|for
control|(
name|FileStatus
name|fileStatus
range|:
name|fileStatuses
control|)
block|{
name|csv
operator|.
name|entry
argument_list|(
operator|(
name|S3AFileStatus
operator|)
name|fileStatus
argument_list|)
expr_stmt|;
block|}
comment|// scan through the list, building up a reverse list of all directories
comment|// found.
name|List
argument_list|<
name|Path
argument_list|>
name|dirs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|fileStatuses
operator|.
name|length
argument_list|)
decl_stmt|;
for|for
control|(
name|FileStatus
name|fileStatus
range|:
name|fileStatuses
control|)
block|{
if|if
condition|(
name|fileStatus
operator|.
name|isDirectory
argument_list|()
operator|&&
operator|!
operator|(
name|fileStatus
operator|.
name|getPath
argument_list|()
operator|.
name|equals
argument_list|(
name|path
argument_list|)
operator|)
condition|)
block|{
comment|// directory: add to the end of the queue.
name|dirs
operator|.
name|add
argument_list|(
name|fileStatus
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// file: just increment the count
name|count
operator|++
expr_stmt|;
block|}
comment|// now push the dirs list in reverse
comment|// so that they have been added in the sort order as returned.
name|pushAll
argument_list|(
name|queue
argument_list|,
name|dirs
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|count
return|;
block|}
end_function

begin_comment
comment|/**    * Dump the filesystem via a recursive listStatus call.    * @param csv destination.    * @return number of entries found.    * @throws IOException IO failure.    */
end_comment

begin_function
DECL|method|listStatusFilesystem ( final CsvFile csv, final Path path)
specifier|protected
name|long
name|listStatusFilesystem
parameter_list|(
specifier|final
name|CsvFile
name|csv
parameter_list|,
specifier|final
name|Path
name|path
parameter_list|)
throws|throws
name|IOException
block|{
name|long
name|count
init|=
literal|0
decl_stmt|;
name|RemoteIterator
argument_list|<
name|S3ALocatedFileStatus
argument_list|>
name|iterator
init|=
name|getFilesystem
argument_list|()
operator|.
name|listFilesAndEmptyDirectories
argument_list|(
name|path
argument_list|,
literal|true
argument_list|)
decl_stmt|;
while|while
condition|(
name|iterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|S3ALocatedFileStatus
name|status
init|=
name|iterator
operator|.
name|next
argument_list|()
decl_stmt|;
name|csv
operator|.
name|entry
argument_list|(
name|status
operator|.
name|toS3AFileStatus
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|count
return|;
block|}
end_function

begin_comment
comment|/**    * Dump the raw S3 Object Store.    * @param csv destination.    * @return number of entries found.    * @throws IOException IO failure.    */
end_comment

begin_function
DECL|method|dumpRawS3ObjectStore ( final CsvFile csv)
specifier|protected
name|long
name|dumpRawS3ObjectStore
parameter_list|(
specifier|final
name|CsvFile
name|csv
parameter_list|)
throws|throws
name|IOException
block|{
name|S3AFileSystem
name|fs
init|=
name|getFilesystem
argument_list|()
decl_stmt|;
name|Path
name|rootPath
init|=
name|fs
operator|.
name|qualify
argument_list|(
operator|new
name|Path
argument_list|(
literal|"/"
argument_list|)
argument_list|)
decl_stmt|;
name|Listing
name|listing
init|=
operator|new
name|Listing
argument_list|(
name|fs
argument_list|)
decl_stmt|;
name|S3ListRequest
name|request
init|=
name|fs
operator|.
name|createListObjectsRequest
argument_list|(
literal|""
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|long
name|count
init|=
literal|0
decl_stmt|;
name|RemoteIterator
argument_list|<
name|S3AFileStatus
argument_list|>
name|st
init|=
name|listing
operator|.
name|createFileStatusListingIterator
argument_list|(
name|rootPath
argument_list|,
name|request
argument_list|,
name|ACCEPT_ALL
argument_list|,
operator|new
name|Listing
operator|.
name|AcceptAllButSelfAndS3nDirs
argument_list|(
name|rootPath
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
name|st
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|count
operator|++
expr_stmt|;
name|S3AFileStatus
name|next
init|=
name|st
operator|.
name|next
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"[{}] {}"
argument_list|,
name|count
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|csv
operator|.
name|entry
argument_list|(
name|next
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"entry count: {}"
argument_list|,
name|count
argument_list|)
expr_stmt|;
return|return
name|count
return|;
block|}
end_function

begin_comment
comment|/**    * list children under the metastore from a base path, through    * a recursive query + walk strategy.    * @param csv dest    * @param basePath base path    * @throws IOException failure.    */
end_comment

begin_function
DECL|method|dumpMetastore (final CsvFile csv, final Path basePath)
specifier|protected
name|void
name|dumpMetastore
parameter_list|(
specifier|final
name|CsvFile
name|csv
parameter_list|,
specifier|final
name|Path
name|basePath
parameter_list|)
throws|throws
name|IOException
block|{
name|dumpStoreEntries
argument_list|(
name|csv
argument_list|,
name|getStore
argument_list|()
operator|.
name|listChildren
argument_list|(
name|basePath
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**    * Recursive Store Dump.    * @param csv open CSV file.    * @param dir directory listing    * @return (directories, files)    * @throws IOException failure    */
end_comment

begin_function
DECL|method|dumpStoreEntries ( CsvFile csv, DirListingMetadata dir)
specifier|private
name|Pair
argument_list|<
name|Long
argument_list|,
name|Long
argument_list|>
name|dumpStoreEntries
parameter_list|(
name|CsvFile
name|csv
parameter_list|,
name|DirListingMetadata
name|dir
parameter_list|)
throws|throws
name|IOException
block|{
name|ArrayDeque
argument_list|<
name|DirListingMetadata
argument_list|>
name|queue
init|=
operator|new
name|ArrayDeque
argument_list|<>
argument_list|()
decl_stmt|;
name|queue
operator|.
name|add
argument_list|(
name|dir
argument_list|)
expr_stmt|;
name|long
name|files
init|=
literal|0
decl_stmt|,
name|dirs
init|=
literal|1
decl_stmt|;
while|while
condition|(
operator|!
name|queue
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|DirListingMetadata
name|next
init|=
name|queue
operator|.
name|pop
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|DDBPathMetadata
argument_list|>
name|childDirs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|Collection
argument_list|<
name|PathMetadata
argument_list|>
name|listing
init|=
name|next
operator|.
name|getListing
argument_list|()
decl_stmt|;
comment|// sort by name
name|List
argument_list|<
name|PathMetadata
argument_list|>
name|sorted
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|listing
argument_list|)
decl_stmt|;
name|sorted
operator|.
name|sort
argument_list|(
operator|new
name|PathOrderComparators
operator|.
name|PathMetadataComparator
argument_list|(
parameter_list|(
name|l
parameter_list|,
name|r
parameter_list|)
lambda|->
name|l
operator|.
name|compareTo
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|PathMetadata
name|pmd
range|:
name|sorted
control|)
block|{
name|DDBPathMetadata
name|ddbMd
init|=
operator|(
name|DDBPathMetadata
operator|)
name|pmd
decl_stmt|;
name|dumpEntry
argument_list|(
name|csv
argument_list|,
name|ddbMd
argument_list|)
expr_stmt|;
if|if
condition|(
name|ddbMd
operator|.
name|getFileStatus
argument_list|()
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
name|childDirs
operator|.
name|add
argument_list|(
name|ddbMd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|files
operator|++
expr_stmt|;
block|}
block|}
name|List
argument_list|<
name|DirListingMetadata
argument_list|>
name|childMD
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|childDirs
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|DDBPathMetadata
name|childDir
range|:
name|childDirs
control|)
block|{
name|childMD
operator|.
name|add
argument_list|(
name|getStore
argument_list|()
operator|.
name|listChildren
argument_list|(
name|childDir
operator|.
name|getFileStatus
argument_list|()
operator|.
name|getPath
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|pushAll
argument_list|(
name|queue
argument_list|,
name|childMD
argument_list|)
expr_stmt|;
block|}
return|return
name|Pair
operator|.
name|of
argument_list|(
name|dirs
argument_list|,
name|files
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Dump a single entry, and log it.    * @param csv CSV output file.    * @param md metadata to log.    */
end_comment

begin_function
DECL|method|dumpEntry (CsvFile csv, DDBPathMetadata md)
specifier|private
name|void
name|dumpEntry
parameter_list|(
name|CsvFile
name|csv
parameter_list|,
name|DDBPathMetadata
name|md
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"{}"
argument_list|,
name|md
operator|.
name|prettyPrint
argument_list|()
argument_list|)
expr_stmt|;
name|csv
operator|.
name|entry
argument_list|(
name|md
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**    * Scan the metastore for all entries and dump them.    * There's no attempt to sort the output.    * @param csv file    * @return tuple of (live entries, tombstones).    */
end_comment

begin_function
DECL|method|scanMetastore (CsvFile csv)
specifier|private
name|Pair
argument_list|<
name|Long
argument_list|,
name|Long
argument_list|>
name|scanMetastore
parameter_list|(
name|CsvFile
name|csv
parameter_list|)
block|{
name|S3GuardTableAccess
name|tableAccess
init|=
operator|new
name|S3GuardTableAccess
argument_list|(
name|getStore
argument_list|()
argument_list|)
decl_stmt|;
name|ExpressionSpecBuilder
name|builder
init|=
operator|new
name|ExpressionSpecBuilder
argument_list|()
decl_stmt|;
name|Iterable
argument_list|<
name|DDBPathMetadata
argument_list|>
name|results
init|=
name|tableAccess
operator|.
name|scanMetadata
argument_list|(
name|builder
argument_list|)
decl_stmt|;
name|long
name|live
init|=
literal|0
decl_stmt|;
name|long
name|tombstone
init|=
literal|0
decl_stmt|;
for|for
control|(
name|DDBPathMetadata
name|md
range|:
name|results
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|md
operator|instanceof
name|S3GuardTableAccess
operator|.
name|VersionMarker
operator|)
condition|)
block|{
comment|// print it
name|csv
operator|.
name|entry
argument_list|(
name|md
argument_list|)
expr_stmt|;
if|if
condition|(
name|md
operator|.
name|isDeleted
argument_list|()
condition|)
block|{
name|tombstone
operator|++
expr_stmt|;
block|}
else|else
block|{
name|live
operator|++
expr_stmt|;
block|}
block|}
block|}
return|return
name|Pair
operator|.
name|of
argument_list|(
name|live
argument_list|,
name|tombstone
argument_list|)
return|;
block|}
end_function

begin_function
DECL|method|getScanEntryResult ()
specifier|public
name|Pair
argument_list|<
name|Long
argument_list|,
name|Long
argument_list|>
name|getScanEntryResult
parameter_list|()
block|{
return|return
name|scanEntryResult
return|;
block|}
end_function

begin_function
DECL|method|getSecondScanResult ()
specifier|public
name|Pair
argument_list|<
name|Long
argument_list|,
name|Long
argument_list|>
name|getSecondScanResult
parameter_list|()
block|{
return|return
name|secondScanResult
return|;
block|}
end_function

begin_function
DECL|method|getRawObjectStoreCount ()
specifier|public
name|long
name|getRawObjectStoreCount
parameter_list|()
block|{
return|return
name|rawObjectStoreCount
return|;
block|}
end_function

begin_function
DECL|method|getListStatusCount ()
specifier|public
name|long
name|getListStatusCount
parameter_list|()
block|{
return|return
name|listStatusCount
return|;
block|}
end_function

begin_function
DECL|method|getTreewalkCount ()
specifier|public
name|long
name|getTreewalkCount
parameter_list|()
block|{
return|return
name|treewalkCount
return|;
block|}
end_function

begin_comment
comment|/**    * Convert a timestamp in milliseconds to a human string.    * @param millis epoch time in millis    * @return a string for the CSV file.    */
end_comment

begin_function
DECL|method|stringify (long millis)
specifier|private
specifier|static
name|String
name|stringify
parameter_list|(
name|long
name|millis
parameter_list|)
block|{
return|return
operator|new
name|Date
argument_list|(
name|millis
argument_list|)
operator|.
name|toString
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/**    * This is the JVM entry point for the service launcher.    *    * Converts the arguments to a list, then invokes    * {@link #serviceMain(List, AbstractS3GuardDynamoDBDiagnostic)}.    * @param args command line arguments.    */
end_comment

begin_function
DECL|method|main (String[] args)
specifier|public
specifier|static
name|void
name|main
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
block|{
try|try
block|{
name|serviceMain
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|args
argument_list|)
argument_list|,
operator|new
name|DumpS3GuardDynamoTable
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ExitUtil
operator|.
name|ExitException
name|e
parameter_list|)
block|{
name|ExitUtil
operator|.
name|terminate
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**    * The real main function, which takes the arguments as a list.    * Argument 0 MUST be the service classname    * @param argsList the list of arguments    * @param service service to launch.    */
end_comment

begin_function
DECL|method|serviceMain ( final List<String> argsList, final AbstractS3GuardDynamoDBDiagnostic service)
specifier|static
name|void
name|serviceMain
parameter_list|(
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|argsList
parameter_list|,
specifier|final
name|AbstractS3GuardDynamoDBDiagnostic
name|service
parameter_list|)
block|{
name|ServiceLauncher
argument_list|<
name|Service
argument_list|>
name|serviceLauncher
init|=
operator|new
name|ServiceLauncher
argument_list|<>
argument_list|(
name|service
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
name|ExitUtil
operator|.
name|ExitException
name|ex
init|=
name|serviceLauncher
operator|.
name|launchService
argument_list|(
operator|new
name|Configuration
argument_list|()
argument_list|,
name|service
argument_list|,
name|argsList
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|ex
operator|!=
literal|null
condition|)
block|{
throw|throw
name|ex
throw|;
block|}
block|}
end_function

begin_comment
comment|/**    * Entry point to dump the metastore and s3 store world views    *<p>    * Both the FS and the store will be dumped: the store is scanned    * before and after the sequence to show what changes were made to    * the store during the list operation.    * @param fs fs to dump. If null a store must be provided.    * @param store store to dump (fallback to FS)    * @param conf configuration to use (fallback to fs)    * @param destFile base name of the output files.    * @param uri URI of store -only needed if FS is null.    * @throws ExitUtil.ExitException failure.    * @return the store    */
end_comment

begin_function
DECL|method|dumpStore ( @ullable final S3AFileSystem fs, @Nullable DynamoDBMetadataStore store, @Nullable Configuration conf, final File destFile, @Nullable URI uri)
specifier|public
specifier|static
name|DumpS3GuardDynamoTable
name|dumpStore
parameter_list|(
annotation|@
name|Nullable
specifier|final
name|S3AFileSystem
name|fs
parameter_list|,
annotation|@
name|Nullable
name|DynamoDBMetadataStore
name|store
parameter_list|,
annotation|@
name|Nullable
name|Configuration
name|conf
parameter_list|,
specifier|final
name|File
name|destFile
parameter_list|,
annotation|@
name|Nullable
name|URI
name|uri
parameter_list|)
throws|throws
name|ExitUtil
operator|.
name|ExitException
block|{
name|ServiceLauncher
argument_list|<
name|Service
argument_list|>
name|serviceLauncher
init|=
operator|new
name|ServiceLauncher
argument_list|<>
argument_list|(
name|NAME
argument_list|)
decl_stmt|;
if|if
condition|(
name|conf
operator|==
literal|null
condition|)
block|{
name|conf
operator|=
name|checkNotNull
argument_list|(
name|fs
argument_list|,
literal|"No filesystem"
argument_list|)
operator|.
name|getConf
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|store
operator|==
literal|null
condition|)
block|{
name|store
operator|=
operator|(
name|DynamoDBMetadataStore
operator|)
name|checkNotNull
argument_list|(
name|fs
argument_list|,
literal|"No filesystem"
argument_list|)
operator|.
name|getMetadataStore
argument_list|()
expr_stmt|;
block|}
name|DumpS3GuardDynamoTable
name|dump
init|=
operator|new
name|DumpS3GuardDynamoTable
argument_list|(
name|fs
argument_list|,
name|store
argument_list|,
name|destFile
argument_list|,
name|uri
argument_list|)
decl_stmt|;
name|ExitUtil
operator|.
name|ExitException
name|ex
init|=
name|serviceLauncher
operator|.
name|launchService
argument_list|(
name|conf
argument_list|,
name|dump
argument_list|,
name|Collections
operator|.
name|emptyList
argument_list|()
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|ex
operator|!=
literal|null
operator|&&
name|ex
operator|.
name|getExitCode
argument_list|()
operator|!=
literal|0
condition|)
block|{
throw|throw
name|ex
throw|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Results:"
argument_list|)
expr_stmt|;
name|Pair
argument_list|<
name|Long
argument_list|,
name|Long
argument_list|>
name|r
init|=
name|dump
operator|.
name|getScanEntryResult
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Metastore entries: {}"
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Metastore scan total {}, entries {}, tombstones {}"
argument_list|,
name|r
operator|.
name|getLeft
argument_list|()
operator|+
name|r
operator|.
name|getRight
argument_list|()
argument_list|,
name|r
operator|.
name|getLeft
argument_list|()
argument_list|,
name|r
operator|.
name|getRight
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"S3 count {}"
argument_list|,
name|dump
operator|.
name|getRawObjectStoreCount
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Treewalk Count {}"
argument_list|,
name|dump
operator|.
name|getTreewalkCount
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"List Status Count {}"
argument_list|,
name|dump
operator|.
name|getListStatusCount
argument_list|()
argument_list|)
expr_stmt|;
name|r
operator|=
name|dump
operator|.
name|getSecondScanResult
argument_list|()
expr_stmt|;
if|if
condition|(
name|r
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Second metastore scan total {}, entries {}, tombstones {}"
argument_list|,
name|r
operator|.
name|getLeft
argument_list|()
operator|+
name|r
operator|.
name|getRight
argument_list|()
argument_list|,
name|r
operator|.
name|getLeft
argument_list|()
argument_list|,
name|r
operator|.
name|getRight
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|dump
return|;
block|}
end_function

begin_comment
comment|/**    * Writer for generating test CSV files.    *    * Quotes are manged by passing in a long whose specific bits control    * whether or not a row is quoted, bit 0 for column 0, etc.    *    * There is no escaping of values here.    */
end_comment

begin_class
DECL|class|CsvFile
specifier|private
specifier|static
specifier|final
class|class
name|CsvFile
implements|implements
name|Closeable
block|{
comment|/** constant to quote all columns. */
DECL|field|ALL_QUOTES
specifier|public
specifier|static
specifier|final
name|long
name|ALL_QUOTES
init|=
literal|0x7fffffff
decl_stmt|;
comment|/** least significant bit is used for first column; 1  mean 'quote'. */
DECL|field|ROW_QUOTE_MAP
specifier|public
specifier|static
specifier|final
name|int
name|ROW_QUOTE_MAP
init|=
literal|0b1110_1001_1111
decl_stmt|;
comment|/** quote nothing: {@value}. */
DECL|field|NO_QUOTES
specifier|public
specifier|static
specifier|final
name|long
name|NO_QUOTES
init|=
literal|0
decl_stmt|;
DECL|field|path
specifier|private
specifier|final
name|Path
name|path
decl_stmt|;
DECL|field|out
specifier|private
specifier|final
name|PrintWriter
name|out
decl_stmt|;
DECL|field|separator
specifier|private
specifier|final
name|String
name|separator
decl_stmt|;
DECL|field|eol
specifier|private
specifier|final
name|String
name|eol
decl_stmt|;
DECL|field|quote
specifier|private
specifier|final
name|String
name|quote
decl_stmt|;
comment|/**      * Create.      * @param path filesystem path.      * @param out output write.      * @param separator separator of entries.      * @param eol EOL marker.      * @param quote quote marker.      * @throws IOException failure.      */
DECL|method|CsvFile ( final Path path, final PrintWriter out, final String separator, final String eol, final String quote)
specifier|private
name|CsvFile
parameter_list|(
specifier|final
name|Path
name|path
parameter_list|,
specifier|final
name|PrintWriter
name|out
parameter_list|,
specifier|final
name|String
name|separator
parameter_list|,
specifier|final
name|String
name|eol
parameter_list|,
specifier|final
name|String
name|quote
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|separator
operator|=
name|checkNotNull
argument_list|(
name|separator
argument_list|)
expr_stmt|;
name|this
operator|.
name|eol
operator|=
name|checkNotNull
argument_list|(
name|eol
argument_list|)
expr_stmt|;
name|this
operator|.
name|quote
operator|=
name|checkNotNull
argument_list|(
name|quote
argument_list|)
expr_stmt|;
name|this
operator|.
name|path
operator|=
name|path
expr_stmt|;
name|this
operator|.
name|out
operator|=
name|checkNotNull
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|header
argument_list|()
expr_stmt|;
block|}
comment|/**      * Create to a file, with UTF-8 output and the standard      * options of the TSV file.      * @param file destination file.      * @throws IOException failure.      */
DECL|method|CsvFile (File file)
specifier|private
name|CsvFile
parameter_list|(
name|File
name|file
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|(
literal|null
argument_list|,
operator|new
name|PrintWriter
argument_list|(
name|file
argument_list|,
literal|"UTF-8"
argument_list|)
argument_list|,
literal|"\t"
argument_list|,
literal|"\n"
argument_list|,
literal|"\""
argument_list|)
expr_stmt|;
block|}
comment|/**      * Close the file, if not already done.      * @throws IOException on a failure.      */
annotation|@
name|Override
DECL|method|close ()
specifier|public
specifier|synchronized
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|out
operator|!=
literal|null
condition|)
block|{
name|out
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|getPath ()
specifier|public
name|Path
name|getPath
parameter_list|()
block|{
return|return
name|path
return|;
block|}
DECL|method|getSeparator ()
specifier|public
name|String
name|getSeparator
parameter_list|()
block|{
return|return
name|separator
return|;
block|}
DECL|method|getEol ()
specifier|public
name|String
name|getEol
parameter_list|()
block|{
return|return
name|eol
return|;
block|}
comment|/**      * Write a row.      * Entries are quoted if the bit for that column is true.      * @param quotes quote policy: every bit defines the rule for that element      * @param columns columns to write      * @return self for ease of chaining.      */
DECL|method|row (long quotes, Object... columns)
specifier|public
name|CsvFile
name|row
parameter_list|(
name|long
name|quotes
parameter_list|,
name|Object
modifier|...
name|columns
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|out
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|columns
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
block|{
name|out
operator|.
name|write
argument_list|(
name|separator
argument_list|)
expr_stmt|;
block|}
name|boolean
name|toQuote
init|=
operator|(
name|quotes
operator|&
literal|1
operator|)
operator|==
literal|1
decl_stmt|;
comment|// unsigned right shift to make next column flag @ position 0
name|quotes
operator|=
name|quotes
operator|>>>
literal|1
expr_stmt|;
if|if
condition|(
name|toQuote
condition|)
block|{
name|out
operator|.
name|write
argument_list|(
name|quote
argument_list|)
expr_stmt|;
block|}
name|Object
name|column
init|=
name|columns
index|[
name|i
index|]
decl_stmt|;
name|out
operator|.
name|write
argument_list|(
name|column
operator|!=
literal|null
condition|?
name|column
operator|.
name|toString
argument_list|()
else|:
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|toQuote
condition|)
block|{
name|out
operator|.
name|write
argument_list|(
name|quote
argument_list|)
expr_stmt|;
block|}
block|}
name|out
operator|.
name|write
argument_list|(
name|eol
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Write a line.      * @param line line to print      * @return self for ease of chaining.      */
DECL|method|line (String line)
specifier|public
name|CsvFile
name|line
parameter_list|(
name|String
name|line
parameter_list|)
block|{
name|out
operator|.
name|write
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|out
operator|.
name|write
argument_list|(
name|eol
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Get the output stream.      * @return the stream.      */
DECL|method|getOut ()
specifier|public
name|PrintWriter
name|getOut
parameter_list|()
block|{
return|return
name|out
return|;
block|}
comment|/**      * Print the header.      */
DECL|method|header ()
name|void
name|header
parameter_list|()
block|{
name|row
argument_list|(
name|CsvFile
operator|.
name|ALL_QUOTES
argument_list|,
literal|"type"
argument_list|,
literal|"deleted"
argument_list|,
literal|"path"
argument_list|,
literal|"is_auth_dir"
argument_list|,
literal|"is_empty_dir"
argument_list|,
literal|"len"
argument_list|,
literal|"updated"
argument_list|,
literal|"updated_s"
argument_list|,
literal|"last_modified"
argument_list|,
literal|"last_modified_s"
argument_list|,
literal|"etag"
argument_list|,
literal|"version"
argument_list|)
expr_stmt|;
block|}
comment|/**      * Add a metadata entry.      * @param md metadata.      */
DECL|method|entry (DDBPathMetadata md)
name|void
name|entry
parameter_list|(
name|DDBPathMetadata
name|md
parameter_list|)
block|{
name|S3AFileStatus
name|fileStatus
init|=
name|md
operator|.
name|getFileStatus
argument_list|()
decl_stmt|;
name|row
argument_list|(
name|ROW_QUOTE_MAP
argument_list|,
name|fileStatus
operator|.
name|isDirectory
argument_list|()
condition|?
literal|"dir"
else|:
literal|"file"
argument_list|,
name|md
operator|.
name|isDeleted
argument_list|()
argument_list|,
name|fileStatus
operator|.
name|getPath
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|,
name|md
operator|.
name|isAuthoritativeDir
argument_list|()
argument_list|,
name|md
operator|.
name|isEmptyDirectory
argument_list|()
operator|.
name|name
argument_list|()
argument_list|,
name|fileStatus
operator|.
name|getLen
argument_list|()
argument_list|,
name|md
operator|.
name|getLastUpdated
argument_list|()
argument_list|,
name|stringify
argument_list|(
name|md
operator|.
name|getLastUpdated
argument_list|()
argument_list|)
argument_list|,
name|fileStatus
operator|.
name|getModificationTime
argument_list|()
argument_list|,
name|stringify
argument_list|(
name|fileStatus
operator|.
name|getModificationTime
argument_list|()
argument_list|)
argument_list|,
name|fileStatus
operator|.
name|getETag
argument_list|()
argument_list|,
name|fileStatus
operator|.
name|getVersionId
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**      * filesystem entry: no metadata.      * @param fileStatus file status      */
DECL|method|entry (S3AFileStatus fileStatus)
name|void
name|entry
parameter_list|(
name|S3AFileStatus
name|fileStatus
parameter_list|)
block|{
name|row
argument_list|(
name|ROW_QUOTE_MAP
argument_list|,
name|fileStatus
operator|.
name|isDirectory
argument_list|()
condition|?
literal|"dir"
else|:
literal|"file"
argument_list|,
literal|"false"
argument_list|,
name|fileStatus
operator|.
name|getPath
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|,
literal|""
argument_list|,
name|fileStatus
operator|.
name|isEmptyDirectory
argument_list|()
operator|.
name|name
argument_list|()
argument_list|,
name|fileStatus
operator|.
name|getLen
argument_list|()
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
name|fileStatus
operator|.
name|getModificationTime
argument_list|()
argument_list|,
name|stringify
argument_list|(
name|fileStatus
operator|.
name|getModificationTime
argument_list|()
argument_list|)
argument_list|,
name|fileStatus
operator|.
name|getETag
argument_list|()
argument_list|,
name|fileStatus
operator|.
name|getVersionId
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
end_class

unit|}
end_unit

