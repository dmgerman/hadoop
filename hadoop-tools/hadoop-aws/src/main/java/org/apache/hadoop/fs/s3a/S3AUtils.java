begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.fs.s3a
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
package|;
end_package

begin_import
import|import
name|com
operator|.
name|amazonaws
operator|.
name|AbortedException
import|;
end_import

begin_import
import|import
name|com
operator|.
name|amazonaws
operator|.
name|AmazonClientException
import|;
end_import

begin_import
import|import
name|com
operator|.
name|amazonaws
operator|.
name|AmazonServiceException
import|;
end_import

begin_import
import|import
name|com
operator|.
name|amazonaws
operator|.
name|ClientConfiguration
import|;
end_import

begin_import
import|import
name|com
operator|.
name|amazonaws
operator|.
name|Protocol
import|;
end_import

begin_import
import|import
name|com
operator|.
name|amazonaws
operator|.
name|SdkBaseException
import|;
end_import

begin_import
import|import
name|com
operator|.
name|amazonaws
operator|.
name|auth
operator|.
name|AWSCredentialsProvider
import|;
end_import

begin_import
import|import
name|com
operator|.
name|amazonaws
operator|.
name|auth
operator|.
name|EnvironmentVariableCredentialsProvider
import|;
end_import

begin_import
import|import
name|com
operator|.
name|amazonaws
operator|.
name|retry
operator|.
name|RetryUtils
import|;
end_import

begin_import
import|import
name|com
operator|.
name|amazonaws
operator|.
name|services
operator|.
name|dynamodbv2
operator|.
name|model
operator|.
name|AmazonDynamoDBException
import|;
end_import

begin_import
import|import
name|com
operator|.
name|amazonaws
operator|.
name|services
operator|.
name|dynamodbv2
operator|.
name|model
operator|.
name|LimitExceededException
import|;
end_import

begin_import
import|import
name|com
operator|.
name|amazonaws
operator|.
name|services
operator|.
name|dynamodbv2
operator|.
name|model
operator|.
name|ProvisionedThroughputExceededException
import|;
end_import

begin_import
import|import
name|com
operator|.
name|amazonaws
operator|.
name|services
operator|.
name|dynamodbv2
operator|.
name|model
operator|.
name|ResourceNotFoundException
import|;
end_import

begin_import
import|import
name|com
operator|.
name|amazonaws
operator|.
name|services
operator|.
name|s3
operator|.
name|model
operator|.
name|AmazonS3Exception
import|;
end_import

begin_import
import|import
name|com
operator|.
name|amazonaws
operator|.
name|services
operator|.
name|s3
operator|.
name|model
operator|.
name|MultiObjectDeleteException
import|;
end_import

begin_import
import|import
name|com
operator|.
name|amazonaws
operator|.
name|services
operator|.
name|s3
operator|.
name|model
operator|.
name|S3ObjectSummary
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang3
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceStability
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|LocatedFileStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|PathFilter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|RemoteIterator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|auth
operator|.
name|IAMInstanceCredentialsProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3native
operator|.
name|S3xLoginHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|net
operator|.
name|ConnectTimeoutException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|ProviderUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|VersionInfo
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|annotation
operator|.
name|Nullable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Closeable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|EOFException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileNotFoundException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InterruptedIOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Constructor
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|InvocationTargetException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Method
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Modifier
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|SocketTimeoutException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URI
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|AccessDeniedException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Date
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Optional
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutionException
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang3
operator|.
name|StringUtils
operator|.
name|isEmpty
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|Constants
operator|.
name|*
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|impl
operator|.
name|MultiObjectDeleteSupport
operator|.
name|translateDeleteException
import|;
end_import

begin_comment
comment|/**  * Utility methods for S3A code.  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
annotation|@
name|InterfaceStability
operator|.
name|Evolving
DECL|class|S3AUtils
specifier|public
specifier|final
class|class
name|S3AUtils
block|{
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|S3AUtils
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|CONSTRUCTOR_EXCEPTION
specifier|static
specifier|final
name|String
name|CONSTRUCTOR_EXCEPTION
init|=
literal|"constructor exception"
decl_stmt|;
DECL|field|INSTANTIATION_EXCEPTION
specifier|static
specifier|final
name|String
name|INSTANTIATION_EXCEPTION
init|=
literal|"instantiation exception"
decl_stmt|;
DECL|field|NOT_AWS_PROVIDER
specifier|static
specifier|final
name|String
name|NOT_AWS_PROVIDER
init|=
literal|"does not implement AWSCredentialsProvider"
decl_stmt|;
DECL|field|ABSTRACT_PROVIDER
specifier|static
specifier|final
name|String
name|ABSTRACT_PROVIDER
init|=
literal|"is abstract and therefore cannot be created"
decl_stmt|;
DECL|field|ENDPOINT_KEY
specifier|static
specifier|final
name|String
name|ENDPOINT_KEY
init|=
literal|"Endpoint"
decl_stmt|;
comment|/** Filesystem is closed; kept here to keep the errors close. */
DECL|field|E_FS_CLOSED
specifier|static
specifier|final
name|String
name|E_FS_CLOSED
init|=
literal|"FileSystem is closed!"
decl_stmt|;
comment|/**    * Core property for provider path. Duplicated here for consistent    * code across Hadoop version: {@value}.    */
DECL|field|CREDENTIAL_PROVIDER_PATH
specifier|static
specifier|final
name|String
name|CREDENTIAL_PROVIDER_PATH
init|=
literal|"hadoop.security.credential.provider.path"
decl_stmt|;
comment|/**    * Encryption SSE-C used but the config lacks an encryption key.    */
DECL|field|SSE_C_NO_KEY_ERROR
specifier|public
specifier|static
specifier|final
name|String
name|SSE_C_NO_KEY_ERROR
init|=
name|S3AEncryptionMethods
operator|.
name|SSE_C
operator|.
name|getMethod
argument_list|()
operator|+
literal|" is enabled but no encryption key was declared in "
operator|+
name|SERVER_SIDE_ENCRYPTION_KEY
decl_stmt|;
comment|/**    * Encryption SSE-S3 is used but the caller also set an encryption key.    */
DECL|field|SSE_S3_WITH_KEY_ERROR
specifier|public
specifier|static
specifier|final
name|String
name|SSE_S3_WITH_KEY_ERROR
init|=
name|S3AEncryptionMethods
operator|.
name|SSE_S3
operator|.
name|getMethod
argument_list|()
operator|+
literal|" is enabled but an encryption key was set in "
operator|+
name|SERVER_SIDE_ENCRYPTION_KEY
decl_stmt|;
DECL|field|EOF_MESSAGE_IN_XML_PARSER
specifier|private
specifier|static
specifier|final
name|String
name|EOF_MESSAGE_IN_XML_PARSER
init|=
literal|"Failed to sanitize XML document destined for handler class"
decl_stmt|;
DECL|field|BUCKET_PATTERN
specifier|private
specifier|static
specifier|final
name|String
name|BUCKET_PATTERN
init|=
name|FS_S3A_BUCKET_PREFIX
operator|+
literal|"%s.%s"
decl_stmt|;
comment|/**    * Error message when the AWS provider list built up contains a forbidden    * entry.    */
annotation|@
name|VisibleForTesting
DECL|field|E_FORBIDDEN_AWS_PROVIDER
specifier|public
specifier|static
specifier|final
name|String
name|E_FORBIDDEN_AWS_PROVIDER
init|=
literal|"AWS provider class cannot be used"
decl_stmt|;
DECL|method|S3AUtils ()
specifier|private
name|S3AUtils
parameter_list|()
block|{   }
comment|/**    * Translate an exception raised in an operation into an IOException.    * The specific type of IOException depends on the class of    * {@link AmazonClientException} passed in, and any status codes included    * in the operation. That is: HTTP error codes are examined and can be    * used to build a more specific response.    *    * @see<a href="http://docs.aws.amazon.com/AmazonS3/latest/API/ErrorResponses.html">S3 Error responses</a>    * @see<a href="http://docs.aws.amazon.com/AmazonS3/latest/dev/ErrorBestPractices.html">Amazon S3 Error Best Practices</a>    * @see<a href="http://docs.aws.amazon.com/amazondynamodb/latest/APIReference/CommonErrors.html">Dynamo DB Commmon errors</a>    * @param operation operation    * @param path path operated on (must not be null)    * @param exception amazon exception raised    * @return an IOE which wraps the caught exception.    */
DECL|method|translateException (String operation, Path path, AmazonClientException exception)
specifier|public
specifier|static
name|IOException
name|translateException
parameter_list|(
name|String
name|operation
parameter_list|,
name|Path
name|path
parameter_list|,
name|AmazonClientException
name|exception
parameter_list|)
block|{
return|return
name|translateException
argument_list|(
name|operation
argument_list|,
name|path
operator|.
name|toString
argument_list|()
argument_list|,
name|exception
argument_list|)
return|;
block|}
comment|/**    * Translate an exception raised in an operation into an IOException.    * The specific type of IOException depends on the class of    * {@link AmazonClientException} passed in, and any status codes included    * in the operation. That is: HTTP error codes are examined and can be    * used to build a more specific response.    * @param operation operation    * @param path path operated on (may be null)    * @param exception amazon exception raised    * @return an IOE which wraps the caught exception.    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"ThrowableInstanceNeverThrown"
argument_list|)
DECL|method|translateException (@ullable String operation, String path, SdkBaseException exception)
specifier|public
specifier|static
name|IOException
name|translateException
parameter_list|(
annotation|@
name|Nullable
name|String
name|operation
parameter_list|,
name|String
name|path
parameter_list|,
name|SdkBaseException
name|exception
parameter_list|)
block|{
name|String
name|message
init|=
name|String
operator|.
name|format
argument_list|(
literal|"%s%s: %s"
argument_list|,
name|operation
argument_list|,
name|StringUtils
operator|.
name|isNotEmpty
argument_list|(
name|path
argument_list|)
condition|?
operator|(
literal|" on "
operator|+
name|path
operator|)
else|:
literal|""
argument_list|,
name|exception
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|exception
operator|instanceof
name|AmazonServiceException
operator|)
condition|)
block|{
name|Exception
name|innerCause
init|=
name|containsInterruptedException
argument_list|(
name|exception
argument_list|)
decl_stmt|;
if|if
condition|(
name|innerCause
operator|!=
literal|null
condition|)
block|{
comment|// interrupted IO, or a socket exception underneath that class
return|return
name|translateInterruptedException
argument_list|(
name|exception
argument_list|,
name|innerCause
argument_list|,
name|message
argument_list|)
return|;
block|}
if|if
condition|(
name|signifiesConnectionBroken
argument_list|(
name|exception
argument_list|)
condition|)
block|{
comment|// call considered an sign of connectivity failure
return|return
operator|(
name|EOFException
operator|)
operator|new
name|EOFException
argument_list|(
name|message
argument_list|)
operator|.
name|initCause
argument_list|(
name|exception
argument_list|)
return|;
block|}
if|if
condition|(
name|exception
operator|instanceof
name|CredentialInitializationException
condition|)
block|{
comment|// the exception raised by AWSCredentialProvider list if the
comment|// credentials were not accepted.
return|return
operator|(
name|AccessDeniedException
operator|)
operator|new
name|AccessDeniedException
argument_list|(
name|path
argument_list|,
literal|null
argument_list|,
name|exception
operator|.
name|toString
argument_list|()
argument_list|)
operator|.
name|initCause
argument_list|(
name|exception
argument_list|)
return|;
block|}
return|return
operator|new
name|AWSClientIOException
argument_list|(
name|message
argument_list|,
name|exception
argument_list|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|exception
operator|instanceof
name|AmazonDynamoDBException
condition|)
block|{
comment|// special handling for dynamo DB exceptions
return|return
name|translateDynamoDBException
argument_list|(
name|path
argument_list|,
name|message
argument_list|,
operator|(
name|AmazonDynamoDBException
operator|)
name|exception
argument_list|)
return|;
block|}
name|IOException
name|ioe
decl_stmt|;
name|AmazonServiceException
name|ase
init|=
operator|(
name|AmazonServiceException
operator|)
name|exception
decl_stmt|;
comment|// this exception is non-null if the service exception is an s3 one
name|AmazonS3Exception
name|s3Exception
init|=
name|ase
operator|instanceof
name|AmazonS3Exception
condition|?
operator|(
name|AmazonS3Exception
operator|)
name|ase
else|:
literal|null
decl_stmt|;
name|int
name|status
init|=
name|ase
operator|.
name|getStatusCode
argument_list|()
decl_stmt|;
name|message
operator|=
name|message
operator|+
literal|":"
operator|+
name|ase
operator|.
name|getErrorCode
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|status
condition|)
block|{
case|case
literal|301
case|:
case|case
literal|307
case|:
if|if
condition|(
name|s3Exception
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|s3Exception
operator|.
name|getAdditionalDetails
argument_list|()
operator|!=
literal|null
operator|&&
name|s3Exception
operator|.
name|getAdditionalDetails
argument_list|()
operator|.
name|containsKey
argument_list|(
name|ENDPOINT_KEY
argument_list|)
condition|)
block|{
name|message
operator|=
name|String
operator|.
name|format
argument_list|(
literal|"Received permanent redirect response to "
operator|+
literal|"endpoint %s.  This likely indicates that the S3 endpoint "
operator|+
literal|"configured in %s does not match the AWS region containing "
operator|+
literal|"the bucket."
argument_list|,
name|s3Exception
operator|.
name|getAdditionalDetails
argument_list|()
operator|.
name|get
argument_list|(
name|ENDPOINT_KEY
argument_list|)
argument_list|,
name|ENDPOINT
argument_list|)
expr_stmt|;
block|}
name|ioe
operator|=
operator|new
name|AWSRedirectException
argument_list|(
name|message
argument_list|,
name|s3Exception
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ioe
operator|=
operator|new
name|AWSRedirectException
argument_list|(
name|message
argument_list|,
name|ase
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|400
case|:
name|ioe
operator|=
operator|new
name|AWSBadRequestException
argument_list|(
name|message
argument_list|,
name|ase
argument_list|)
expr_stmt|;
break|break;
comment|// permissions
case|case
literal|401
case|:
case|case
literal|403
case|:
name|ioe
operator|=
operator|new
name|AccessDeniedException
argument_list|(
name|path
argument_list|,
literal|null
argument_list|,
name|message
argument_list|)
expr_stmt|;
name|ioe
operator|.
name|initCause
argument_list|(
name|ase
argument_list|)
expr_stmt|;
break|break;
comment|// the object isn't there
case|case
literal|404
case|:
case|case
literal|410
case|:
name|ioe
operator|=
operator|new
name|FileNotFoundException
argument_list|(
name|message
argument_list|)
expr_stmt|;
name|ioe
operator|.
name|initCause
argument_list|(
name|ase
argument_list|)
expr_stmt|;
break|break;
comment|// method not allowed; seen on S3 Select.
comment|// treated as a bad request
case|case
literal|405
case|:
name|ioe
operator|=
operator|new
name|AWSBadRequestException
argument_list|(
name|message
argument_list|,
name|s3Exception
argument_list|)
expr_stmt|;
break|break;
comment|// out of range. This may happen if an object is overwritten with
comment|// a shorter one while it is being read.
case|case
literal|416
case|:
name|ioe
operator|=
operator|new
name|EOFException
argument_list|(
name|message
argument_list|)
expr_stmt|;
name|ioe
operator|.
name|initCause
argument_list|(
name|ase
argument_list|)
expr_stmt|;
break|break;
comment|// this has surfaced as a "no response from server" message.
comment|// so rare we haven't replicated it.
comment|// Treating as an idempotent proxy error.
case|case
literal|443
case|:
case|case
literal|444
case|:
name|ioe
operator|=
operator|new
name|AWSNoResponseException
argument_list|(
name|message
argument_list|,
name|ase
argument_list|)
expr_stmt|;
break|break;
comment|// throttling
case|case
literal|503
case|:
name|ioe
operator|=
operator|new
name|AWSServiceThrottledException
argument_list|(
name|message
argument_list|,
name|ase
argument_list|)
expr_stmt|;
break|break;
comment|// internal error
case|case
literal|500
case|:
name|ioe
operator|=
operator|new
name|AWSStatus500Exception
argument_list|(
name|message
argument_list|,
name|ase
argument_list|)
expr_stmt|;
break|break;
case|case
literal|200
case|:
if|if
condition|(
name|exception
operator|instanceof
name|MultiObjectDeleteException
condition|)
block|{
comment|// failure during a bulk delete
return|return
name|translateDeleteException
argument_list|(
name|message
argument_list|,
operator|(
name|MultiObjectDeleteException
operator|)
name|exception
argument_list|)
return|;
block|}
comment|// other 200: FALL THROUGH
default|default:
comment|// no specific exit code. Choose an IOE subclass based on the class
comment|// of the caught exception
name|ioe
operator|=
name|s3Exception
operator|!=
literal|null
condition|?
operator|new
name|AWSS3IOException
argument_list|(
name|message
argument_list|,
name|s3Exception
argument_list|)
else|:
operator|new
name|AWSServiceIOException
argument_list|(
name|message
argument_list|,
name|ase
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|ioe
return|;
block|}
block|}
comment|/**    * Extract an exception from a failed future, and convert to an IOE.    * @param operation operation which failed    * @param path path operated on (may be null)    * @param ee execution exception    * @return an IOE which can be thrown    */
DECL|method|extractException (String operation, String path, ExecutionException ee)
specifier|public
specifier|static
name|IOException
name|extractException
parameter_list|(
name|String
name|operation
parameter_list|,
name|String
name|path
parameter_list|,
name|ExecutionException
name|ee
parameter_list|)
block|{
name|IOException
name|ioe
decl_stmt|;
name|Throwable
name|cause
init|=
name|ee
operator|.
name|getCause
argument_list|()
decl_stmt|;
if|if
condition|(
name|cause
operator|instanceof
name|AmazonClientException
condition|)
block|{
name|ioe
operator|=
name|translateException
argument_list|(
name|operation
argument_list|,
name|path
argument_list|,
operator|(
name|AmazonClientException
operator|)
name|cause
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cause
operator|instanceof
name|IOException
condition|)
block|{
name|ioe
operator|=
operator|(
name|IOException
operator|)
name|cause
expr_stmt|;
block|}
else|else
block|{
name|ioe
operator|=
operator|new
name|IOException
argument_list|(
name|operation
operator|+
literal|" failed: "
operator|+
name|cause
argument_list|,
name|cause
argument_list|)
expr_stmt|;
block|}
return|return
name|ioe
return|;
block|}
comment|/**    * Recurse down the exception loop looking for any inner details about    * an interrupted exception.    * @param thrown exception thrown    * @return the actual exception if the operation was an interrupt    */
DECL|method|containsInterruptedException (Throwable thrown)
specifier|static
name|Exception
name|containsInterruptedException
parameter_list|(
name|Throwable
name|thrown
parameter_list|)
block|{
if|if
condition|(
name|thrown
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
name|thrown
operator|instanceof
name|InterruptedException
operator|||
name|thrown
operator|instanceof
name|InterruptedIOException
operator|||
name|thrown
operator|instanceof
name|AbortedException
condition|)
block|{
return|return
operator|(
name|Exception
operator|)
name|thrown
return|;
block|}
comment|// tail recurse
return|return
name|containsInterruptedException
argument_list|(
name|thrown
operator|.
name|getCause
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Handles translation of interrupted exception. This includes    * preserving the class of the fault for better retry logic    * @param exception outer exception    * @param innerCause inner cause (which is guaranteed to be some form    * of interrupted exception    * @param message message for the new exception.    * @return an IOE which can be rethrown    */
DECL|method|translateInterruptedException ( SdkBaseException exception, final Exception innerCause, String message)
specifier|private
specifier|static
name|InterruptedIOException
name|translateInterruptedException
parameter_list|(
name|SdkBaseException
name|exception
parameter_list|,
specifier|final
name|Exception
name|innerCause
parameter_list|,
name|String
name|message
parameter_list|)
block|{
name|InterruptedIOException
name|ioe
decl_stmt|;
if|if
condition|(
name|innerCause
operator|instanceof
name|SocketTimeoutException
condition|)
block|{
name|ioe
operator|=
operator|new
name|SocketTimeoutException
argument_list|(
name|message
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|String
name|name
init|=
name|innerCause
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
decl_stmt|;
if|if
condition|(
name|name
operator|.
name|endsWith
argument_list|(
literal|".ConnectTimeoutException"
argument_list|)
operator|||
name|name
operator|.
name|endsWith
argument_list|(
literal|"$ConnectTimeoutException"
argument_list|)
condition|)
block|{
comment|// TCP connection http timeout from the shaded or unshaded filenames
comment|// com.amazonaws.thirdparty.apache.http.conn.ConnectTimeoutException
name|ioe
operator|=
operator|new
name|ConnectTimeoutException
argument_list|(
name|message
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// any other exception
name|ioe
operator|=
operator|new
name|InterruptedIOException
argument_list|(
name|message
argument_list|)
expr_stmt|;
block|}
block|}
name|ioe
operator|.
name|initCause
argument_list|(
name|exception
argument_list|)
expr_stmt|;
return|return
name|ioe
return|;
block|}
comment|/**    * Is the exception an instance of a throttling exception. That    * is an AmazonServiceException with a 503 response, any    * exception from DynamoDB for limits exceeded, an    * {@link AWSServiceThrottledException},    * or anything which the AWS SDK's RetryUtils considers to be    * a throttling exception.    * @param ex exception to examine    * @return true if it is considered a throttling exception    */
DECL|method|isThrottleException (Exception ex)
specifier|public
specifier|static
name|boolean
name|isThrottleException
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
return|return
name|ex
operator|instanceof
name|AWSServiceThrottledException
operator|||
name|ex
operator|instanceof
name|ProvisionedThroughputExceededException
operator|||
name|ex
operator|instanceof
name|LimitExceededException
operator|||
operator|(
name|ex
operator|instanceof
name|AmazonServiceException
operator|&&
literal|503
operator|==
operator|(
operator|(
name|AmazonServiceException
operator|)
name|ex
operator|)
operator|.
name|getStatusCode
argument_list|()
operator|)
operator|||
operator|(
name|ex
operator|instanceof
name|SdkBaseException
operator|&&
name|RetryUtils
operator|.
name|isThrottlingException
argument_list|(
operator|(
name|SdkBaseException
operator|)
name|ex
argument_list|)
operator|)
return|;
block|}
comment|/**    * Cue that an AWS exception is likely to be an EOF Exception based    * on the message coming back from an XML/JSON parser. This is likely    * to be brittle, so only a hint.    * @param ex exception    * @return true if this is believed to be a sign the connection was broken.    */
DECL|method|signifiesConnectionBroken (SdkBaseException ex)
specifier|public
specifier|static
name|boolean
name|signifiesConnectionBroken
parameter_list|(
name|SdkBaseException
name|ex
parameter_list|)
block|{
return|return
name|ex
operator|.
name|toString
argument_list|()
operator|.
name|contains
argument_list|(
name|EOF_MESSAGE_IN_XML_PARSER
argument_list|)
return|;
block|}
comment|/**    * Translate a DynamoDB exception into an IOException.    *    * @param path path in the DDB    * @param message preformatted message for the exception    * @param ddbException exception    * @return an exception to throw.    */
DECL|method|translateDynamoDBException (final String path, final String message, final AmazonDynamoDBException ddbException)
specifier|public
specifier|static
name|IOException
name|translateDynamoDBException
parameter_list|(
specifier|final
name|String
name|path
parameter_list|,
specifier|final
name|String
name|message
parameter_list|,
specifier|final
name|AmazonDynamoDBException
name|ddbException
parameter_list|)
block|{
if|if
condition|(
name|isThrottleException
argument_list|(
name|ddbException
argument_list|)
condition|)
block|{
return|return
operator|new
name|AWSServiceThrottledException
argument_list|(
name|message
argument_list|,
name|ddbException
argument_list|)
return|;
block|}
if|if
condition|(
name|ddbException
operator|instanceof
name|ResourceNotFoundException
condition|)
block|{
return|return
operator|(
name|FileNotFoundException
operator|)
operator|new
name|FileNotFoundException
argument_list|(
name|message
argument_list|)
operator|.
name|initCause
argument_list|(
name|ddbException
argument_list|)
return|;
block|}
specifier|final
name|int
name|statusCode
init|=
name|ddbException
operator|.
name|getStatusCode
argument_list|()
decl_stmt|;
specifier|final
name|String
name|errorCode
init|=
name|ddbException
operator|.
name|getErrorCode
argument_list|()
decl_stmt|;
name|IOException
name|result
init|=
literal|null
decl_stmt|;
comment|// 400 gets used a lot by DDB
if|if
condition|(
name|statusCode
operator|==
literal|400
condition|)
block|{
switch|switch
condition|(
name|errorCode
condition|)
block|{
case|case
literal|"AccessDeniedException"
case|:
name|result
operator|=
operator|(
name|IOException
operator|)
operator|new
name|AccessDeniedException
argument_list|(
name|path
argument_list|,
literal|null
argument_list|,
name|ddbException
operator|.
name|toString
argument_list|()
argument_list|)
operator|.
name|initCause
argument_list|(
name|ddbException
argument_list|)
expr_stmt|;
break|break;
default|default:
name|result
operator|=
operator|new
name|AWSBadRequestException
argument_list|(
name|message
argument_list|,
name|ddbException
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|result
operator|==
literal|null
condition|)
block|{
name|result
operator|=
operator|new
name|AWSServiceIOException
argument_list|(
name|message
argument_list|,
name|ddbException
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
comment|/**    * Get low level details of an amazon exception for logging; multi-line.    * @param e exception    * @return string details    */
DECL|method|stringify (AmazonServiceException e)
specifier|public
specifier|static
name|String
name|stringify
parameter_list|(
name|AmazonServiceException
name|e
parameter_list|)
block|{
name|StringBuilder
name|builder
init|=
operator|new
name|StringBuilder
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"%s: %s error %d: %s; %s%s%n"
argument_list|,
name|e
operator|.
name|getErrorType
argument_list|()
argument_list|,
name|e
operator|.
name|getServiceName
argument_list|()
argument_list|,
name|e
operator|.
name|getStatusCode
argument_list|()
argument_list|,
name|e
operator|.
name|getErrorCode
argument_list|()
argument_list|,
name|e
operator|.
name|getErrorMessage
argument_list|()
argument_list|,
operator|(
name|e
operator|.
name|isRetryable
argument_list|()
condition|?
literal|" (retryable)"
else|:
literal|""
operator|)
argument_list|)
argument_list|)
decl_stmt|;
name|String
name|rawResponseContent
init|=
name|e
operator|.
name|getRawResponseContent
argument_list|()
decl_stmt|;
if|if
condition|(
name|rawResponseContent
operator|!=
literal|null
condition|)
block|{
name|builder
operator|.
name|append
argument_list|(
name|rawResponseContent
argument_list|)
expr_stmt|;
block|}
return|return
name|builder
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * Get low level details of an amazon exception for logging; multi-line.    * @param e exception    * @return string details    */
DECL|method|stringify (AmazonS3Exception e)
specifier|public
specifier|static
name|String
name|stringify
parameter_list|(
name|AmazonS3Exception
name|e
parameter_list|)
block|{
comment|// get the low level details of an exception,
name|StringBuilder
name|builder
init|=
operator|new
name|StringBuilder
argument_list|(
name|stringify
argument_list|(
operator|(
name|AmazonServiceException
operator|)
name|e
argument_list|)
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|details
init|=
name|e
operator|.
name|getAdditionalDetails
argument_list|()
decl_stmt|;
if|if
condition|(
name|details
operator|!=
literal|null
condition|)
block|{
name|builder
operator|.
name|append
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|d
range|:
name|details
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|builder
operator|.
name|append
argument_list|(
name|d
operator|.
name|getKey
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|'='
argument_list|)
operator|.
name|append
argument_list|(
name|d
operator|.
name|getValue
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|builder
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * Create a files status instance from a listing.    * @param keyPath path to entry    * @param summary summary from AWS    * @param blockSize block size to declare.    * @param owner owner of the file    * @param eTag S3 object eTag or null if unavailable    * @param versionId S3 object versionId or null if unavailable    * @return a status entry    */
DECL|method|createFileStatus (Path keyPath, S3ObjectSummary summary, long blockSize, String owner, String eTag, String versionId)
specifier|public
specifier|static
name|S3AFileStatus
name|createFileStatus
parameter_list|(
name|Path
name|keyPath
parameter_list|,
name|S3ObjectSummary
name|summary
parameter_list|,
name|long
name|blockSize
parameter_list|,
name|String
name|owner
parameter_list|,
name|String
name|eTag
parameter_list|,
name|String
name|versionId
parameter_list|)
block|{
name|long
name|size
init|=
name|summary
operator|.
name|getSize
argument_list|()
decl_stmt|;
return|return
name|createFileStatus
argument_list|(
name|keyPath
argument_list|,
name|objectRepresentsDirectory
argument_list|(
name|summary
operator|.
name|getKey
argument_list|()
argument_list|,
name|size
argument_list|)
argument_list|,
name|size
argument_list|,
name|summary
operator|.
name|getLastModified
argument_list|()
argument_list|,
name|blockSize
argument_list|,
name|owner
argument_list|,
name|eTag
argument_list|,
name|versionId
argument_list|)
return|;
block|}
comment|/**    * Create a file status for object we just uploaded.  For files, we use    * current time as modification time, since s3a uses S3's service-based    * modification time, which will not be available until we do a    * getFileStatus() later on.    * @param keyPath path for created object    * @param isDir true iff directory    * @param size file length    * @param blockSize block size for file status    * @param owner Hadoop username    * @param eTag S3 object eTag or null if unavailable    * @param versionId S3 object versionId or null if unavailable    * @return a status entry    */
DECL|method|createUploadFileStatus (Path keyPath, boolean isDir, long size, long blockSize, String owner, String eTag, String versionId)
specifier|public
specifier|static
name|S3AFileStatus
name|createUploadFileStatus
parameter_list|(
name|Path
name|keyPath
parameter_list|,
name|boolean
name|isDir
parameter_list|,
name|long
name|size
parameter_list|,
name|long
name|blockSize
parameter_list|,
name|String
name|owner
parameter_list|,
name|String
name|eTag
parameter_list|,
name|String
name|versionId
parameter_list|)
block|{
name|Date
name|date
init|=
name|isDir
condition|?
literal|null
else|:
operator|new
name|Date
argument_list|()
decl_stmt|;
return|return
name|createFileStatus
argument_list|(
name|keyPath
argument_list|,
name|isDir
argument_list|,
name|size
argument_list|,
name|date
argument_list|,
name|blockSize
argument_list|,
name|owner
argument_list|,
name|eTag
argument_list|,
name|versionId
argument_list|)
return|;
block|}
comment|/* Date 'modified' is ignored when isDir is true. */
DECL|method|createFileStatus (Path keyPath, boolean isDir, long size, Date modified, long blockSize, String owner, String eTag, String versionId)
specifier|private
specifier|static
name|S3AFileStatus
name|createFileStatus
parameter_list|(
name|Path
name|keyPath
parameter_list|,
name|boolean
name|isDir
parameter_list|,
name|long
name|size
parameter_list|,
name|Date
name|modified
parameter_list|,
name|long
name|blockSize
parameter_list|,
name|String
name|owner
parameter_list|,
name|String
name|eTag
parameter_list|,
name|String
name|versionId
parameter_list|)
block|{
if|if
condition|(
name|isDir
condition|)
block|{
return|return
operator|new
name|S3AFileStatus
argument_list|(
name|Tristate
operator|.
name|UNKNOWN
argument_list|,
name|keyPath
argument_list|,
name|owner
argument_list|)
return|;
block|}
else|else
block|{
return|return
operator|new
name|S3AFileStatus
argument_list|(
name|size
argument_list|,
name|dateToLong
argument_list|(
name|modified
argument_list|)
argument_list|,
name|keyPath
argument_list|,
name|blockSize
argument_list|,
name|owner
argument_list|,
name|eTag
argument_list|,
name|versionId
argument_list|)
return|;
block|}
block|}
comment|/**    * Predicate: does the object represent a directory?.    * @param name object name    * @param size object size    * @return true if it meets the criteria for being an object    */
DECL|method|objectRepresentsDirectory (final String name, final long size)
specifier|public
specifier|static
name|boolean
name|objectRepresentsDirectory
parameter_list|(
specifier|final
name|String
name|name
parameter_list|,
specifier|final
name|long
name|size
parameter_list|)
block|{
return|return
operator|!
name|name
operator|.
name|isEmpty
argument_list|()
operator|&&
name|name
operator|.
name|charAt
argument_list|(
name|name
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
operator|==
literal|'/'
operator|&&
name|size
operator|==
literal|0L
return|;
block|}
comment|/**    * Date to long conversion.    * Handles null Dates that can be returned by AWS by returning 0    * @param date date from AWS query    * @return timestamp of the object    */
DECL|method|dateToLong (final Date date)
specifier|public
specifier|static
name|long
name|dateToLong
parameter_list|(
specifier|final
name|Date
name|date
parameter_list|)
block|{
if|if
condition|(
name|date
operator|==
literal|null
condition|)
block|{
return|return
literal|0L
return|;
block|}
return|return
name|date
operator|.
name|getTime
argument_list|()
return|;
block|}
comment|/**    * The standard AWS provider list for AWS connections.    */
specifier|public
specifier|static
specifier|final
name|List
argument_list|<
name|Class
argument_list|<
name|?
argument_list|>
argument_list|>
DECL|field|STANDARD_AWS_PROVIDERS
name|STANDARD_AWS_PROVIDERS
init|=
name|Collections
operator|.
name|unmodifiableList
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|TemporaryAWSCredentialsProvider
operator|.
name|class
argument_list|,
name|SimpleAWSCredentialsProvider
operator|.
name|class
argument_list|,
name|EnvironmentVariableCredentialsProvider
operator|.
name|class
argument_list|,
name|IAMInstanceCredentialsProvider
operator|.
name|class
argument_list|)
argument_list|)
decl_stmt|;
comment|/**    * Create the AWS credentials from the providers, the URI and    * the key {@link Constants#AWS_CREDENTIALS_PROVIDER} in the configuration.    * @param binding Binding URI -may be null    * @param conf filesystem configuration    * @return a credentials provider list    * @throws IOException Problems loading the providers (including reading    * secrets from credential files).    */
DECL|method|createAWSCredentialProviderSet ( @ullable URI binding, Configuration conf)
specifier|public
specifier|static
name|AWSCredentialProviderList
name|createAWSCredentialProviderSet
parameter_list|(
annotation|@
name|Nullable
name|URI
name|binding
parameter_list|,
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
comment|// this will reject any user:secret entries in the URI
name|S3xLoginHelper
operator|.
name|rejectSecretsInURIs
argument_list|(
name|binding
argument_list|)
expr_stmt|;
name|AWSCredentialProviderList
name|credentials
init|=
name|buildAWSProviderList
argument_list|(
name|binding
argument_list|,
name|conf
argument_list|,
name|AWS_CREDENTIALS_PROVIDER
argument_list|,
name|STANDARD_AWS_PROVIDERS
argument_list|,
operator|new
name|HashSet
argument_list|<>
argument_list|()
argument_list|)
decl_stmt|;
comment|// make sure the logging message strips out any auth details
name|LOG
operator|.
name|debug
argument_list|(
literal|"For URI {}, using credentials {}"
argument_list|,
name|binding
argument_list|,
name|credentials
argument_list|)
expr_stmt|;
return|return
name|credentials
return|;
block|}
comment|/**    * Load list of AWS credential provider/credential provider factory classes.    * @param conf configuration    * @param key key    * @param defaultValue list of default values    * @return the list of classes, possibly empty    * @throws IOException on a failure to load the list.    */
DECL|method|loadAWSProviderClasses (Configuration conf, String key, Class<?>... defaultValue)
specifier|public
specifier|static
name|List
argument_list|<
name|Class
argument_list|<
name|?
argument_list|>
argument_list|>
name|loadAWSProviderClasses
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|String
name|key
parameter_list|,
name|Class
argument_list|<
name|?
argument_list|>
modifier|...
name|defaultValue
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
return|return
name|Arrays
operator|.
name|asList
argument_list|(
name|conf
operator|.
name|getClasses
argument_list|(
name|key
argument_list|,
name|defaultValue
argument_list|)
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|RuntimeException
name|e
parameter_list|)
block|{
name|Throwable
name|c
init|=
name|e
operator|.
name|getCause
argument_list|()
operator|!=
literal|null
condition|?
name|e
operator|.
name|getCause
argument_list|()
else|:
name|e
decl_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
literal|"From option "
operator|+
name|key
operator|+
literal|' '
operator|+
name|c
argument_list|,
name|c
argument_list|)
throw|;
block|}
block|}
comment|/**    * Load list of AWS credential provider/credential provider factory classes;    * support a forbidden list to prevent loops, mandate full secrets, etc.    * @param binding Binding URI -may be null    * @param conf configuration    * @param key key    * @param forbidden a possibly empty set of forbidden classes.    * @param defaultValues list of default providers.    * @return the list of classes, possibly empty    * @throws IOException on a failure to load the list.    */
DECL|method|buildAWSProviderList ( @ullable final URI binding, final Configuration conf, final String key, final List<Class<?>> defaultValues, final Set<Class<?>> forbidden)
specifier|public
specifier|static
name|AWSCredentialProviderList
name|buildAWSProviderList
parameter_list|(
annotation|@
name|Nullable
specifier|final
name|URI
name|binding
parameter_list|,
specifier|final
name|Configuration
name|conf
parameter_list|,
specifier|final
name|String
name|key
parameter_list|,
specifier|final
name|List
argument_list|<
name|Class
argument_list|<
name|?
argument_list|>
argument_list|>
name|defaultValues
parameter_list|,
specifier|final
name|Set
argument_list|<
name|Class
argument_list|<
name|?
argument_list|>
argument_list|>
name|forbidden
parameter_list|)
throws|throws
name|IOException
block|{
comment|// build up the base provider
name|List
argument_list|<
name|Class
argument_list|<
name|?
argument_list|>
argument_list|>
name|awsClasses
init|=
name|loadAWSProviderClasses
argument_list|(
name|conf
argument_list|,
name|key
argument_list|,
name|defaultValues
operator|.
name|toArray
argument_list|(
operator|new
name|Class
index|[
name|defaultValues
operator|.
name|size
argument_list|()
index|]
argument_list|)
argument_list|)
decl_stmt|;
comment|// and if the list is empty, switch back to the defaults.
comment|// this is to address the issue that configuration.getClasses()
comment|// doesn't return the default if the config value is just whitespace.
if|if
condition|(
name|awsClasses
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|awsClasses
operator|=
name|defaultValues
expr_stmt|;
block|}
comment|// iterate through, checking for blacklists and then instantiating
comment|// each provider
name|AWSCredentialProviderList
name|providers
init|=
operator|new
name|AWSCredentialProviderList
argument_list|()
decl_stmt|;
for|for
control|(
name|Class
argument_list|<
name|?
argument_list|>
name|aClass
range|:
name|awsClasses
control|)
block|{
if|if
condition|(
name|forbidden
operator|.
name|contains
argument_list|(
name|aClass
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|E_FORBIDDEN_AWS_PROVIDER
operator|+
literal|" in option "
operator|+
name|key
operator|+
literal|": "
operator|+
name|aClass
argument_list|)
throw|;
block|}
name|providers
operator|.
name|add
argument_list|(
name|createAWSCredentialProvider
argument_list|(
name|conf
argument_list|,
name|aClass
argument_list|,
name|binding
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|providers
return|;
block|}
comment|/**    * Create an AWS credential provider from its class by using reflection.  The    * class must implement one of the following means of construction, which are    * attempted in order:    *    *<ol>    *<li>a public constructor accepting java.net.URI and    *     org.apache.hadoop.conf.Configuration</li>    *<li>a public constructor accepting    *    org.apache.hadoop.conf.Configuration</li>    *<li>a public static method named getInstance that accepts no    *    arguments and returns an instance of    *    com.amazonaws.auth.AWSCredentialsProvider, or</li>    *<li>a public default constructor.</li>    *</ol>    *    * @param conf configuration    * @param credClass credential class    * @param uri URI of the FS    * @return the instantiated class    * @throws IOException on any instantiation failure.    */
DECL|method|createAWSCredentialProvider ( Configuration conf, Class<?> credClass, @Nullable URI uri)
specifier|private
specifier|static
name|AWSCredentialsProvider
name|createAWSCredentialProvider
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|Class
argument_list|<
name|?
argument_list|>
name|credClass
parameter_list|,
annotation|@
name|Nullable
name|URI
name|uri
parameter_list|)
throws|throws
name|IOException
block|{
name|AWSCredentialsProvider
name|credentials
init|=
literal|null
decl_stmt|;
name|String
name|className
init|=
name|credClass
operator|.
name|getName
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|AWSCredentialsProvider
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|credClass
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Class "
operator|+
name|credClass
operator|+
literal|" "
operator|+
name|NOT_AWS_PROVIDER
argument_list|)
throw|;
block|}
if|if
condition|(
name|Modifier
operator|.
name|isAbstract
argument_list|(
name|credClass
operator|.
name|getModifiers
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Class "
operator|+
name|credClass
operator|+
literal|" "
operator|+
name|ABSTRACT_PROVIDER
argument_list|)
throw|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Credential provider class is {}"
argument_list|,
name|className
argument_list|)
expr_stmt|;
try|try
block|{
comment|// new X(uri, conf)
name|Constructor
name|cons
init|=
name|getConstructor
argument_list|(
name|credClass
argument_list|,
name|URI
operator|.
name|class
argument_list|,
name|Configuration
operator|.
name|class
argument_list|)
decl_stmt|;
if|if
condition|(
name|cons
operator|!=
literal|null
condition|)
block|{
name|credentials
operator|=
operator|(
name|AWSCredentialsProvider
operator|)
name|cons
operator|.
name|newInstance
argument_list|(
name|uri
argument_list|,
name|conf
argument_list|)
expr_stmt|;
return|return
name|credentials
return|;
block|}
comment|// new X(conf)
name|cons
operator|=
name|getConstructor
argument_list|(
name|credClass
argument_list|,
name|Configuration
operator|.
name|class
argument_list|)
expr_stmt|;
if|if
condition|(
name|cons
operator|!=
literal|null
condition|)
block|{
name|credentials
operator|=
operator|(
name|AWSCredentialsProvider
operator|)
name|cons
operator|.
name|newInstance
argument_list|(
name|conf
argument_list|)
expr_stmt|;
return|return
name|credentials
return|;
block|}
comment|// X.getInstance()
name|Method
name|factory
init|=
name|getFactoryMethod
argument_list|(
name|credClass
argument_list|,
name|AWSCredentialsProvider
operator|.
name|class
argument_list|,
literal|"getInstance"
argument_list|)
decl_stmt|;
if|if
condition|(
name|factory
operator|!=
literal|null
condition|)
block|{
name|credentials
operator|=
operator|(
name|AWSCredentialsProvider
operator|)
name|factory
operator|.
name|invoke
argument_list|(
literal|null
argument_list|)
expr_stmt|;
return|return
name|credentials
return|;
block|}
comment|// new X()
name|cons
operator|=
name|getConstructor
argument_list|(
name|credClass
argument_list|)
expr_stmt|;
if|if
condition|(
name|cons
operator|!=
literal|null
condition|)
block|{
name|credentials
operator|=
operator|(
name|AWSCredentialsProvider
operator|)
name|cons
operator|.
name|newInstance
argument_list|()
expr_stmt|;
return|return
name|credentials
return|;
block|}
comment|// no supported constructor or factory method found
throw|throw
operator|new
name|IOException
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"%s "
operator|+
name|CONSTRUCTOR_EXCEPTION
operator|+
literal|".  A class specified in %s must provide a public constructor "
operator|+
literal|"of a supported signature, or a public factory method named "
operator|+
literal|"getInstance that accepts no arguments."
argument_list|,
name|className
argument_list|,
name|AWS_CREDENTIALS_PROVIDER
argument_list|)
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|InvocationTargetException
name|e
parameter_list|)
block|{
name|Throwable
name|targetException
init|=
name|e
operator|.
name|getTargetException
argument_list|()
decl_stmt|;
if|if
condition|(
name|targetException
operator|==
literal|null
condition|)
block|{
name|targetException
operator|=
name|e
expr_stmt|;
block|}
if|if
condition|(
name|targetException
operator|instanceof
name|IOException
condition|)
block|{
throw|throw
operator|(
name|IOException
operator|)
name|targetException
throw|;
block|}
elseif|else
if|if
condition|(
name|targetException
operator|instanceof
name|SdkBaseException
condition|)
block|{
throw|throw
name|translateException
argument_list|(
literal|"Instantiate "
operator|+
name|className
argument_list|,
literal|""
argument_list|,
operator|(
name|SdkBaseException
operator|)
name|targetException
argument_list|)
throw|;
block|}
else|else
block|{
comment|// supported constructor or factory method found, but the call failed
throw|throw
operator|new
name|IOException
argument_list|(
name|className
operator|+
literal|" "
operator|+
name|INSTANTIATION_EXCEPTION
operator|+
literal|": "
operator|+
name|targetException
argument_list|,
name|targetException
argument_list|)
throw|;
block|}
block|}
catch|catch
parameter_list|(
name|ReflectiveOperationException
decl||
name|IllegalArgumentException
name|e
parameter_list|)
block|{
comment|// supported constructor or factory method found, but the call failed
throw|throw
operator|new
name|IOException
argument_list|(
name|className
operator|+
literal|" "
operator|+
name|INSTANTIATION_EXCEPTION
operator|+
literal|": "
operator|+
name|e
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**    * Set a key if the value is non-empty.    * @param config config to patch    * @param key key to set    * @param val value to probe and set    * @param origin origin    * @return true if the property was set    */
DECL|method|setIfDefined (Configuration config, String key, String val, String origin)
specifier|public
specifier|static
name|boolean
name|setIfDefined
parameter_list|(
name|Configuration
name|config
parameter_list|,
name|String
name|key
parameter_list|,
name|String
name|val
parameter_list|,
name|String
name|origin
parameter_list|)
block|{
if|if
condition|(
name|StringUtils
operator|.
name|isNotEmpty
argument_list|(
name|val
argument_list|)
condition|)
block|{
name|config
operator|.
name|set
argument_list|(
name|key
argument_list|,
name|val
argument_list|,
name|origin
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
comment|/**    * Return the access key and secret for S3 API use.    * or indicated in the UserInfo of the name URI param.    * @param name the URI for which we need the access keys; may be null    * @param conf the Configuration object to interrogate for keys.    * @return AWSAccessKeys    * @throws IOException problems retrieving passwords from KMS.    */
DECL|method|getAWSAccessKeys (URI name, Configuration conf)
specifier|public
specifier|static
name|S3xLoginHelper
operator|.
name|Login
name|getAWSAccessKeys
parameter_list|(
name|URI
name|name
parameter_list|,
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|S3xLoginHelper
operator|.
name|rejectSecretsInURIs
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|Configuration
name|c
init|=
name|ProviderUtils
operator|.
name|excludeIncompatibleCredentialProviders
argument_list|(
name|conf
argument_list|,
name|S3AFileSystem
operator|.
name|class
argument_list|)
decl_stmt|;
name|String
name|bucket
init|=
name|name
operator|!=
literal|null
condition|?
name|name
operator|.
name|getHost
argument_list|()
else|:
literal|""
decl_stmt|;
comment|// get the secrets from the configuration
comment|// get the access key
name|String
name|accessKey
init|=
name|lookupPassword
argument_list|(
name|bucket
argument_list|,
name|c
argument_list|,
name|ACCESS_KEY
argument_list|)
decl_stmt|;
comment|// and the secret
name|String
name|secretKey
init|=
name|lookupPassword
argument_list|(
name|bucket
argument_list|,
name|c
argument_list|,
name|SECRET_KEY
argument_list|)
decl_stmt|;
return|return
operator|new
name|S3xLoginHelper
operator|.
name|Login
argument_list|(
name|accessKey
argument_list|,
name|secretKey
argument_list|)
return|;
block|}
comment|/**    * Get a password from a configuration, including JCEKS files, handling both    * the absolute key and bucket override.    * @param bucket bucket or "" if none known    * @param conf configuration    * @param baseKey base key to look up, e.g "fs.s3a.secret.key"    * @param overrideVal override value: if non empty this is used instead of    * querying the configuration.    * @return a password or "".    * @throws IOException on any IO problem    * @throws IllegalArgumentException bad arguments    */
annotation|@
name|Deprecated
DECL|method|lookupPassword ( String bucket, Configuration conf, String baseKey, String overrideVal)
specifier|public
specifier|static
name|String
name|lookupPassword
parameter_list|(
name|String
name|bucket
parameter_list|,
name|Configuration
name|conf
parameter_list|,
name|String
name|baseKey
parameter_list|,
name|String
name|overrideVal
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|lookupPassword
argument_list|(
name|bucket
argument_list|,
name|conf
argument_list|,
name|baseKey
argument_list|,
name|overrideVal
argument_list|,
literal|""
argument_list|)
return|;
block|}
comment|/**    * Get a password from a configuration, including JCEKS files, handling both    * the absolute key and bucket override.    * @param bucket bucket or "" if none known    * @param conf configuration    * @param baseKey base key to look up, e.g "fs.s3a.secret.key"    * @return a password or "".    * @throws IOException on any IO problem    * @throws IllegalArgumentException bad arguments    */
DECL|method|lookupPassword ( String bucket, Configuration conf, String baseKey)
specifier|public
specifier|static
name|String
name|lookupPassword
parameter_list|(
name|String
name|bucket
parameter_list|,
name|Configuration
name|conf
parameter_list|,
name|String
name|baseKey
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|lookupPassword
argument_list|(
name|bucket
argument_list|,
name|conf
argument_list|,
name|baseKey
argument_list|,
literal|null
argument_list|,
literal|""
argument_list|)
return|;
block|}
comment|/**    * Get a password from a configuration, including JCEKS files, handling both    * the absolute key and bucket override.    * @param bucket bucket or "" if none known    * @param conf configuration    * @param baseKey base key to look up, e.g "fs.s3a.secret.key"    * @param overrideVal override value: if non empty this is used instead of    * querying the configuration.    * @param defVal value to return if there is no password    * @return a password or the value of defVal.    * @throws IOException on any IO problem    * @throws IllegalArgumentException bad arguments    */
DECL|method|lookupPassword ( String bucket, Configuration conf, String baseKey, String overrideVal, String defVal)
specifier|public
specifier|static
name|String
name|lookupPassword
parameter_list|(
name|String
name|bucket
parameter_list|,
name|Configuration
name|conf
parameter_list|,
name|String
name|baseKey
parameter_list|,
name|String
name|overrideVal
parameter_list|,
name|String
name|defVal
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|initialVal
decl_stmt|;
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|baseKey
operator|.
name|startsWith
argument_list|(
name|FS_S3A_PREFIX
argument_list|)
argument_list|,
literal|"%s does not start with $%s"
argument_list|,
name|baseKey
argument_list|,
name|FS_S3A_PREFIX
argument_list|)
expr_stmt|;
comment|// if there's a bucket, work with it
if|if
condition|(
name|StringUtils
operator|.
name|isNotEmpty
argument_list|(
name|bucket
argument_list|)
condition|)
block|{
name|String
name|subkey
init|=
name|baseKey
operator|.
name|substring
argument_list|(
name|FS_S3A_PREFIX
operator|.
name|length
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|shortBucketKey
init|=
name|String
operator|.
name|format
argument_list|(
name|BUCKET_PATTERN
argument_list|,
name|bucket
argument_list|,
name|subkey
argument_list|)
decl_stmt|;
name|String
name|longBucketKey
init|=
name|String
operator|.
name|format
argument_list|(
name|BUCKET_PATTERN
argument_list|,
name|bucket
argument_list|,
name|baseKey
argument_list|)
decl_stmt|;
comment|// set from the long key unless overidden.
name|initialVal
operator|=
name|getPassword
argument_list|(
name|conf
argument_list|,
name|longBucketKey
argument_list|,
name|overrideVal
argument_list|)
expr_stmt|;
comment|// then override from the short one if it is set
name|initialVal
operator|=
name|getPassword
argument_list|(
name|conf
argument_list|,
name|shortBucketKey
argument_list|,
name|initialVal
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// no bucket, make the initial value the override value
name|initialVal
operator|=
name|overrideVal
expr_stmt|;
block|}
return|return
name|getPassword
argument_list|(
name|conf
argument_list|,
name|baseKey
argument_list|,
name|initialVal
argument_list|,
name|defVal
argument_list|)
return|;
block|}
comment|/**    * Get a password from a configuration, or, if a value is passed in,    * pick that up instead.    * @param conf configuration    * @param key key to look up    * @param val current value: if non empty this is used instead of    * querying the configuration.    * @return a password or "".    * @throws IOException on any problem    */
DECL|method|getPassword (Configuration conf, String key, String val)
specifier|private
specifier|static
name|String
name|getPassword
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|String
name|key
parameter_list|,
name|String
name|val
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|getPassword
argument_list|(
name|conf
argument_list|,
name|key
argument_list|,
name|val
argument_list|,
literal|""
argument_list|)
return|;
block|}
comment|/**    * Get a password from a configuration, or, if a value is passed in,    * pick that up instead.    * @param conf configuration    * @param key key to look up    * @param val current value: if non empty this is used instead of    * querying the configuration.    * @param defVal default value if nothing is set    * @return a password or "".    * @throws IOException on any problem    */
DECL|method|getPassword (Configuration conf, String key, String val, String defVal)
specifier|private
specifier|static
name|String
name|getPassword
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|String
name|key
parameter_list|,
name|String
name|val
parameter_list|,
name|String
name|defVal
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|isEmpty
argument_list|(
name|val
argument_list|)
condition|?
name|lookupPassword
argument_list|(
name|conf
argument_list|,
name|key
argument_list|,
name|defVal
argument_list|)
else|:
name|val
return|;
block|}
comment|/**    * Get a password from a configuration/configured credential providers.    * @param conf configuration    * @param key key to look up    * @param defVal value to return if there is no password    * @return a password or the value in {@code defVal}    * @throws IOException on any problem    */
DECL|method|lookupPassword (Configuration conf, String key, String defVal)
specifier|static
name|String
name|lookupPassword
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|String
name|key
parameter_list|,
name|String
name|defVal
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
specifier|final
name|char
index|[]
name|pass
init|=
name|conf
operator|.
name|getPassword
argument_list|(
name|key
argument_list|)
decl_stmt|;
return|return
name|pass
operator|!=
literal|null
condition|?
operator|new
name|String
argument_list|(
name|pass
argument_list|)
operator|.
name|trim
argument_list|()
else|:
name|defVal
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Cannot find password option "
operator|+
name|key
argument_list|,
name|ioe
argument_list|)
throw|;
block|}
block|}
comment|/**    * String information about a summary entry for debug messages.    * @param summary summary object    * @return string value    */
DECL|method|stringify (S3ObjectSummary summary)
specifier|public
specifier|static
name|String
name|stringify
parameter_list|(
name|S3ObjectSummary
name|summary
parameter_list|)
block|{
name|StringBuilder
name|builder
init|=
operator|new
name|StringBuilder
argument_list|(
name|summary
operator|.
name|getKey
argument_list|()
operator|.
name|length
argument_list|()
operator|+
literal|100
argument_list|)
decl_stmt|;
name|builder
operator|.
name|append
argument_list|(
name|summary
operator|.
name|getKey
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|builder
operator|.
name|append
argument_list|(
literal|"size="
argument_list|)
operator|.
name|append
argument_list|(
name|summary
operator|.
name|getSize
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|builder
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * Get a integer option>= the minimum allowed value.    * @param conf configuration    * @param key key to look up    * @param defVal default value    * @param min minimum value    * @return the value    * @throws IllegalArgumentException if the value is below the minimum    */
DECL|method|intOption (Configuration conf, String key, int defVal, int min)
specifier|public
specifier|static
name|int
name|intOption
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|String
name|key
parameter_list|,
name|int
name|defVal
parameter_list|,
name|int
name|min
parameter_list|)
block|{
name|int
name|v
init|=
name|conf
operator|.
name|getInt
argument_list|(
name|key
argument_list|,
name|defVal
argument_list|)
decl_stmt|;
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|v
operator|>=
name|min
argument_list|,
name|String
operator|.
name|format
argument_list|(
literal|"Value of %s: %d is below the minimum value %d"
argument_list|,
name|key
argument_list|,
name|v
argument_list|,
name|min
argument_list|)
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Value of {} is {}"
argument_list|,
name|key
argument_list|,
name|v
argument_list|)
expr_stmt|;
return|return
name|v
return|;
block|}
comment|/**    * Get a long option>= the minimum allowed value.    * @param conf configuration    * @param key key to look up    * @param defVal default value    * @param min minimum value    * @return the value    * @throws IllegalArgumentException if the value is below the minimum    */
DECL|method|longOption (Configuration conf, String key, long defVal, long min)
specifier|public
specifier|static
name|long
name|longOption
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|String
name|key
parameter_list|,
name|long
name|defVal
parameter_list|,
name|long
name|min
parameter_list|)
block|{
name|long
name|v
init|=
name|conf
operator|.
name|getLong
argument_list|(
name|key
argument_list|,
name|defVal
argument_list|)
decl_stmt|;
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|v
operator|>=
name|min
argument_list|,
name|String
operator|.
name|format
argument_list|(
literal|"Value of %s: %d is below the minimum value %d"
argument_list|,
name|key
argument_list|,
name|v
argument_list|,
name|min
argument_list|)
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Value of {} is {}"
argument_list|,
name|key
argument_list|,
name|v
argument_list|)
expr_stmt|;
return|return
name|v
return|;
block|}
comment|/**    * Get a long option&gt;= the minimum allowed value, supporting memory    * prefixes K,M,G,T,P.    * @param conf configuration    * @param key key to look up    * @param defVal default value    * @param min minimum value    * @return the value    * @throws IllegalArgumentException if the value is below the minimum    */
DECL|method|longBytesOption (Configuration conf, String key, long defVal, long min)
specifier|public
specifier|static
name|long
name|longBytesOption
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|String
name|key
parameter_list|,
name|long
name|defVal
parameter_list|,
name|long
name|min
parameter_list|)
block|{
name|long
name|v
init|=
name|conf
operator|.
name|getLongBytes
argument_list|(
name|key
argument_list|,
name|defVal
argument_list|)
decl_stmt|;
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|v
operator|>=
name|min
argument_list|,
name|String
operator|.
name|format
argument_list|(
literal|"Value of %s: %d is below the minimum value %d"
argument_list|,
name|key
argument_list|,
name|v
argument_list|,
name|min
argument_list|)
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Value of {} is {}"
argument_list|,
name|key
argument_list|,
name|v
argument_list|)
expr_stmt|;
return|return
name|v
return|;
block|}
comment|/**    * Get a size property from the configuration: this property must    * be at least equal to {@link Constants#MULTIPART_MIN_SIZE}.    * If it is too small, it is rounded up to that minimum, and a warning    * printed.    * @param conf configuration    * @param property property name    * @param defVal default value    * @return the value, guaranteed to be above the minimum size    */
DECL|method|getMultipartSizeProperty (Configuration conf, String property, long defVal)
specifier|public
specifier|static
name|long
name|getMultipartSizeProperty
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|String
name|property
parameter_list|,
name|long
name|defVal
parameter_list|)
block|{
name|long
name|partSize
init|=
name|conf
operator|.
name|getLongBytes
argument_list|(
name|property
argument_list|,
name|defVal
argument_list|)
decl_stmt|;
if|if
condition|(
name|partSize
operator|<
name|MULTIPART_MIN_SIZE
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"{} must be at least 5 MB; configured value is {}"
argument_list|,
name|property
argument_list|,
name|partSize
argument_list|)
expr_stmt|;
name|partSize
operator|=
name|MULTIPART_MIN_SIZE
expr_stmt|;
block|}
return|return
name|partSize
return|;
block|}
comment|/**    * Ensure that the long value is in the range of an integer.    * @param name property name for error messages    * @param size original size    * @return the size, guaranteed to be less than or equal to the max    * value of an integer.    */
DECL|method|ensureOutputParameterInRange (String name, long size)
specifier|public
specifier|static
name|int
name|ensureOutputParameterInRange
parameter_list|(
name|String
name|name
parameter_list|,
name|long
name|size
parameter_list|)
block|{
if|if
condition|(
name|size
operator|>
name|Integer
operator|.
name|MAX_VALUE
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"s3a: {} capped to ~2.14GB"
operator|+
literal|" (maximum allowed size with current output mechanism)"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|Integer
operator|.
name|MAX_VALUE
return|;
block|}
else|else
block|{
return|return
operator|(
name|int
operator|)
name|size
return|;
block|}
block|}
comment|/**    * Returns the public constructor of {@code cl} specified by the list of    * {@code args} or {@code null} if {@code cl} has no public constructor that    * matches that specification.    * @param cl class    * @param args constructor argument types    * @return constructor or null    */
DECL|method|getConstructor (Class<?> cl, Class<?>... args)
specifier|private
specifier|static
name|Constructor
argument_list|<
name|?
argument_list|>
name|getConstructor
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|cl
parameter_list|,
name|Class
argument_list|<
name|?
argument_list|>
modifier|...
name|args
parameter_list|)
block|{
try|try
block|{
name|Constructor
name|cons
init|=
name|cl
operator|.
name|getDeclaredConstructor
argument_list|(
name|args
argument_list|)
decl_stmt|;
return|return
name|Modifier
operator|.
name|isPublic
argument_list|(
name|cons
operator|.
name|getModifiers
argument_list|()
argument_list|)
condition|?
name|cons
else|:
literal|null
return|;
block|}
catch|catch
parameter_list|(
name|NoSuchMethodException
decl||
name|SecurityException
name|e
parameter_list|)
block|{
return|return
literal|null
return|;
block|}
block|}
comment|/**    * Returns the public static method of {@code cl} that accepts no arguments    * and returns {@code returnType} specified by {@code methodName} or    * {@code null} if {@code cl} has no public static method that matches that    * specification.    * @param cl class    * @param returnType return type    * @param methodName method name    * @return method or null    */
DECL|method|getFactoryMethod (Class<?> cl, Class<?> returnType, String methodName)
specifier|private
specifier|static
name|Method
name|getFactoryMethod
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|cl
parameter_list|,
name|Class
argument_list|<
name|?
argument_list|>
name|returnType
parameter_list|,
name|String
name|methodName
parameter_list|)
block|{
try|try
block|{
name|Method
name|m
init|=
name|cl
operator|.
name|getDeclaredMethod
argument_list|(
name|methodName
argument_list|)
decl_stmt|;
if|if
condition|(
name|Modifier
operator|.
name|isPublic
argument_list|(
name|m
operator|.
name|getModifiers
argument_list|()
argument_list|)
operator|&&
name|Modifier
operator|.
name|isStatic
argument_list|(
name|m
operator|.
name|getModifiers
argument_list|()
argument_list|)
operator|&&
name|returnType
operator|.
name|isAssignableFrom
argument_list|(
name|m
operator|.
name|getReturnType
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|m
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
catch|catch
parameter_list|(
name|NoSuchMethodException
decl||
name|SecurityException
name|e
parameter_list|)
block|{
return|return
literal|null
return|;
block|}
block|}
comment|/**    * Propagates bucket-specific settings into generic S3A configuration keys.    * This is done by propagating the values of the form    * {@code fs.s3a.bucket.${bucket}.key} to    * {@code fs.s3a.key}, for all values of "key" other than a small set    * of unmodifiable values.    *    * The source of the updated property is set to the key name of the bucket    * property, to aid in diagnostics of where things came from.    *    * Returns a new configuration. Why the clone?    * You can use the same conf for different filesystems, and the original    * values are not updated.    *    * The {@code fs.s3a.impl} property cannot be set, nor can    * any with the prefix {@code fs.s3a.bucket}.    *    * This method does not propagate security provider path information from    * the S3A property into the Hadoop common provider: callers must call    * {@link #patchSecurityCredentialProviders(Configuration)} explicitly.    * @param source Source Configuration object.    * @param bucket bucket name. Must not be empty.    * @return a (potentially) patched clone of the original.    */
DECL|method|propagateBucketOptions (Configuration source, String bucket)
specifier|public
specifier|static
name|Configuration
name|propagateBucketOptions
parameter_list|(
name|Configuration
name|source
parameter_list|,
name|String
name|bucket
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|StringUtils
operator|.
name|isNotEmpty
argument_list|(
name|bucket
argument_list|)
argument_list|,
literal|"bucket"
argument_list|)
expr_stmt|;
specifier|final
name|String
name|bucketPrefix
init|=
name|FS_S3A_BUCKET_PREFIX
operator|+
name|bucket
operator|+
literal|'.'
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Propagating entries under {}"
argument_list|,
name|bucketPrefix
argument_list|)
expr_stmt|;
specifier|final
name|Configuration
name|dest
init|=
operator|new
name|Configuration
argument_list|(
name|source
argument_list|)
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|entry
range|:
name|source
control|)
block|{
specifier|final
name|String
name|key
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
comment|// get the (unexpanded) value.
specifier|final
name|String
name|value
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|key
operator|.
name|startsWith
argument_list|(
name|bucketPrefix
argument_list|)
operator|||
name|bucketPrefix
operator|.
name|equals
argument_list|(
name|key
argument_list|)
condition|)
block|{
continue|continue;
block|}
comment|// there's a bucket prefix, so strip it
specifier|final
name|String
name|stripped
init|=
name|key
operator|.
name|substring
argument_list|(
name|bucketPrefix
operator|.
name|length
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|stripped
operator|.
name|startsWith
argument_list|(
literal|"bucket."
argument_list|)
operator|||
literal|"impl"
operator|.
name|equals
argument_list|(
name|stripped
argument_list|)
condition|)
block|{
comment|//tell user off
name|LOG
operator|.
name|debug
argument_list|(
literal|"Ignoring bucket option {}"
argument_list|,
name|key
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// propagate the value, building a new origin field.
comment|// to track overwrites, the generic key is overwritten even if
comment|// already matches the new one.
name|String
name|origin
init|=
literal|"["
operator|+
name|StringUtils
operator|.
name|join
argument_list|(
name|source
operator|.
name|getPropertySources
argument_list|(
name|key
argument_list|)
argument_list|,
literal|", "
argument_list|)
operator|+
literal|"]"
decl_stmt|;
specifier|final
name|String
name|generic
init|=
name|FS_S3A_PREFIX
operator|+
name|stripped
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Updating {} from {}"
argument_list|,
name|generic
argument_list|,
name|origin
argument_list|)
expr_stmt|;
name|dest
operator|.
name|set
argument_list|(
name|generic
argument_list|,
name|value
argument_list|,
name|key
operator|+
literal|" via "
operator|+
name|origin
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|dest
return|;
block|}
comment|/**    * Delete a path quietly: failures are logged at DEBUG.    * @param fs filesystem    * @param path path    * @param recursive recursive?    */
DECL|method|deleteQuietly (FileSystem fs, Path path, boolean recursive)
specifier|public
specifier|static
name|void
name|deleteQuietly
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Path
name|path
parameter_list|,
name|boolean
name|recursive
parameter_list|)
block|{
try|try
block|{
name|fs
operator|.
name|delete
argument_list|(
name|path
argument_list|,
name|recursive
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Failed to delete {}"
argument_list|,
name|path
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Delete a path: failures are logged at WARN.    * @param fs filesystem    * @param path path    * @param recursive recursive?    */
DECL|method|deleteWithWarning (FileSystem fs, Path path, boolean recursive)
specifier|public
specifier|static
name|void
name|deleteWithWarning
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Path
name|path
parameter_list|,
name|boolean
name|recursive
parameter_list|)
block|{
try|try
block|{
name|fs
operator|.
name|delete
argument_list|(
name|path
argument_list|,
name|recursive
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to delete {}"
argument_list|,
name|path
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Create a new AWS {@code ClientConfiguration}.    * All clients to AWS services<i>MUST</i> use this for consistent setup    * of connectivity, UA, proxy settings.    * @param conf The Hadoop configuration    * @param bucket Optional bucket to use to look up per-bucket proxy secrets    * @return new AWS client configuration    * @throws IOException problem creating AWS client configuration    */
DECL|method|createAwsConf (Configuration conf, String bucket)
specifier|public
specifier|static
name|ClientConfiguration
name|createAwsConf
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|String
name|bucket
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|ClientConfiguration
name|awsConf
init|=
operator|new
name|ClientConfiguration
argument_list|()
decl_stmt|;
name|initConnectionSettings
argument_list|(
name|conf
argument_list|,
name|awsConf
argument_list|)
expr_stmt|;
name|initProxySupport
argument_list|(
name|conf
argument_list|,
name|bucket
argument_list|,
name|awsConf
argument_list|)
expr_stmt|;
name|initUserAgent
argument_list|(
name|conf
argument_list|,
name|awsConf
argument_list|)
expr_stmt|;
return|return
name|awsConf
return|;
block|}
comment|/**    * Initializes all AWS SDK settings related to connection management.    *    * @param conf Hadoop configuration    * @param awsConf AWS SDK configuration    */
DECL|method|initConnectionSettings (Configuration conf, ClientConfiguration awsConf)
specifier|public
specifier|static
name|void
name|initConnectionSettings
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|ClientConfiguration
name|awsConf
parameter_list|)
block|{
name|awsConf
operator|.
name|setMaxConnections
argument_list|(
name|intOption
argument_list|(
name|conf
argument_list|,
name|MAXIMUM_CONNECTIONS
argument_list|,
name|DEFAULT_MAXIMUM_CONNECTIONS
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|boolean
name|secureConnections
init|=
name|conf
operator|.
name|getBoolean
argument_list|(
name|SECURE_CONNECTIONS
argument_list|,
name|DEFAULT_SECURE_CONNECTIONS
argument_list|)
decl_stmt|;
name|awsConf
operator|.
name|setProtocol
argument_list|(
name|secureConnections
condition|?
name|Protocol
operator|.
name|HTTPS
else|:
name|Protocol
operator|.
name|HTTP
argument_list|)
expr_stmt|;
name|awsConf
operator|.
name|setMaxErrorRetry
argument_list|(
name|intOption
argument_list|(
name|conf
argument_list|,
name|MAX_ERROR_RETRIES
argument_list|,
name|DEFAULT_MAX_ERROR_RETRIES
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|awsConf
operator|.
name|setConnectionTimeout
argument_list|(
name|intOption
argument_list|(
name|conf
argument_list|,
name|ESTABLISH_TIMEOUT
argument_list|,
name|DEFAULT_ESTABLISH_TIMEOUT
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|awsConf
operator|.
name|setSocketTimeout
argument_list|(
name|intOption
argument_list|(
name|conf
argument_list|,
name|SOCKET_TIMEOUT
argument_list|,
name|DEFAULT_SOCKET_TIMEOUT
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|int
name|sockSendBuffer
init|=
name|intOption
argument_list|(
name|conf
argument_list|,
name|SOCKET_SEND_BUFFER
argument_list|,
name|DEFAULT_SOCKET_SEND_BUFFER
argument_list|,
literal|2048
argument_list|)
decl_stmt|;
name|int
name|sockRecvBuffer
init|=
name|intOption
argument_list|(
name|conf
argument_list|,
name|SOCKET_RECV_BUFFER
argument_list|,
name|DEFAULT_SOCKET_RECV_BUFFER
argument_list|,
literal|2048
argument_list|)
decl_stmt|;
name|awsConf
operator|.
name|setSocketBufferSizeHints
argument_list|(
name|sockSendBuffer
argument_list|,
name|sockRecvBuffer
argument_list|)
expr_stmt|;
name|String
name|signerOverride
init|=
name|conf
operator|.
name|getTrimmed
argument_list|(
name|SIGNING_ALGORITHM
argument_list|,
literal|""
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|signerOverride
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Signer override = {}"
argument_list|,
name|signerOverride
argument_list|)
expr_stmt|;
name|awsConf
operator|.
name|setSignerOverride
argument_list|(
name|signerOverride
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Initializes AWS SDK proxy support in the AWS client configuration    * if the S3A settings enable it.    *    * @param conf Hadoop configuration    * @param bucket Optional bucket to use to look up per-bucket proxy secrets    * @param awsConf AWS SDK configuration to update    * @throws IllegalArgumentException if misconfigured    * @throws IOException problem getting username/secret from password source.    */
DECL|method|initProxySupport (Configuration conf, String bucket, ClientConfiguration awsConf)
specifier|public
specifier|static
name|void
name|initProxySupport
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|String
name|bucket
parameter_list|,
name|ClientConfiguration
name|awsConf
parameter_list|)
throws|throws
name|IllegalArgumentException
throws|,
name|IOException
block|{
name|String
name|proxyHost
init|=
name|conf
operator|.
name|getTrimmed
argument_list|(
name|PROXY_HOST
argument_list|,
literal|""
argument_list|)
decl_stmt|;
name|int
name|proxyPort
init|=
name|conf
operator|.
name|getInt
argument_list|(
name|PROXY_PORT
argument_list|,
operator|-
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|proxyHost
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|awsConf
operator|.
name|setProxyHost
argument_list|(
name|proxyHost
argument_list|)
expr_stmt|;
if|if
condition|(
name|proxyPort
operator|>=
literal|0
condition|)
block|{
name|awsConf
operator|.
name|setProxyPort
argument_list|(
name|proxyPort
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|conf
operator|.
name|getBoolean
argument_list|(
name|SECURE_CONNECTIONS
argument_list|,
name|DEFAULT_SECURE_CONNECTIONS
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Proxy host set without port. Using HTTPS default 443"
argument_list|)
expr_stmt|;
name|awsConf
operator|.
name|setProxyPort
argument_list|(
literal|443
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Proxy host set without port. Using HTTP default 80"
argument_list|)
expr_stmt|;
name|awsConf
operator|.
name|setProxyPort
argument_list|(
literal|80
argument_list|)
expr_stmt|;
block|}
block|}
specifier|final
name|String
name|proxyUsername
init|=
name|lookupPassword
argument_list|(
name|bucket
argument_list|,
name|conf
argument_list|,
name|PROXY_USERNAME
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
decl_stmt|;
specifier|final
name|String
name|proxyPassword
init|=
name|lookupPassword
argument_list|(
name|bucket
argument_list|,
name|conf
argument_list|,
name|PROXY_PASSWORD
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|proxyUsername
operator|==
literal|null
operator|)
operator|!=
operator|(
name|proxyPassword
operator|==
literal|null
operator|)
condition|)
block|{
name|String
name|msg
init|=
literal|"Proxy error: "
operator|+
name|PROXY_USERNAME
operator|+
literal|" or "
operator|+
name|PROXY_PASSWORD
operator|+
literal|" set without the other."
decl_stmt|;
name|LOG
operator|.
name|error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|msg
argument_list|)
throw|;
block|}
name|awsConf
operator|.
name|setProxyUsername
argument_list|(
name|proxyUsername
argument_list|)
expr_stmt|;
name|awsConf
operator|.
name|setProxyPassword
argument_list|(
name|proxyPassword
argument_list|)
expr_stmt|;
name|awsConf
operator|.
name|setProxyDomain
argument_list|(
name|conf
operator|.
name|getTrimmed
argument_list|(
name|PROXY_DOMAIN
argument_list|)
argument_list|)
expr_stmt|;
name|awsConf
operator|.
name|setProxyWorkstation
argument_list|(
name|conf
operator|.
name|getTrimmed
argument_list|(
name|PROXY_WORKSTATION
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Using proxy server {}:{} as user {} with password {} on "
operator|+
literal|"domain {} as workstation {}"
argument_list|,
name|awsConf
operator|.
name|getProxyHost
argument_list|()
argument_list|,
name|awsConf
operator|.
name|getProxyPort
argument_list|()
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
name|awsConf
operator|.
name|getProxyUsername
argument_list|()
argument_list|)
argument_list|,
name|awsConf
operator|.
name|getProxyPassword
argument_list|()
argument_list|,
name|awsConf
operator|.
name|getProxyDomain
argument_list|()
argument_list|,
name|awsConf
operator|.
name|getProxyWorkstation
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|proxyPort
operator|>=
literal|0
condition|)
block|{
name|String
name|msg
init|=
literal|"Proxy error: "
operator|+
name|PROXY_PORT
operator|+
literal|" set without "
operator|+
name|PROXY_HOST
decl_stmt|;
name|LOG
operator|.
name|error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|msg
argument_list|)
throw|;
block|}
block|}
comment|/**    * Initializes the User-Agent header to send in HTTP requests to AWS    * services.  We always include the Hadoop version number.  The user also    * may set an optional custom prefix to put in front of the Hadoop version    * number.  The AWS SDK internally appends its own information, which seems    * to include the AWS SDK version, OS and JVM version.    *    * @param conf Hadoop configuration    * @param awsConf AWS SDK configuration to update    */
DECL|method|initUserAgent (Configuration conf, ClientConfiguration awsConf)
specifier|private
specifier|static
name|void
name|initUserAgent
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|ClientConfiguration
name|awsConf
parameter_list|)
block|{
name|String
name|userAgent
init|=
literal|"Hadoop "
operator|+
name|VersionInfo
operator|.
name|getVersion
argument_list|()
decl_stmt|;
name|String
name|userAgentPrefix
init|=
name|conf
operator|.
name|getTrimmed
argument_list|(
name|USER_AGENT_PREFIX
argument_list|,
literal|""
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|userAgentPrefix
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|userAgent
operator|=
name|userAgentPrefix
operator|+
literal|", "
operator|+
name|userAgent
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Using User-Agent: {}"
argument_list|,
name|userAgent
argument_list|)
expr_stmt|;
name|awsConf
operator|.
name|setUserAgentPrefix
argument_list|(
name|userAgent
argument_list|)
expr_stmt|;
block|}
comment|/**    * An interface for use in lambda-expressions working with    * directory tree listings.    */
annotation|@
name|FunctionalInterface
DECL|interface|CallOnLocatedFileStatus
specifier|public
interface|interface
name|CallOnLocatedFileStatus
block|{
DECL|method|call (LocatedFileStatus status)
name|void
name|call
parameter_list|(
name|LocatedFileStatus
name|status
parameter_list|)
throws|throws
name|IOException
function_decl|;
block|}
comment|/**    * An interface for use in lambda-expressions working with    * directory tree listings.    */
annotation|@
name|FunctionalInterface
DECL|interface|LocatedFileStatusMap
specifier|public
interface|interface
name|LocatedFileStatusMap
parameter_list|<
name|T
parameter_list|>
block|{
DECL|method|call (LocatedFileStatus status)
name|T
name|call
parameter_list|(
name|LocatedFileStatus
name|status
parameter_list|)
throws|throws
name|IOException
function_decl|;
block|}
comment|/**    * Apply an operation to every {@link LocatedFileStatus} in a remote    * iterator.    * @param iterator iterator from a list    * @param eval closure to evaluate    * @return the number of files processed    * @throws IOException anything in the closure, or iteration logic.    */
DECL|method|applyLocatedFiles ( RemoteIterator<? extends LocatedFileStatus> iterator, CallOnLocatedFileStatus eval)
specifier|public
specifier|static
name|long
name|applyLocatedFiles
parameter_list|(
name|RemoteIterator
argument_list|<
name|?
extends|extends
name|LocatedFileStatus
argument_list|>
name|iterator
parameter_list|,
name|CallOnLocatedFileStatus
name|eval
parameter_list|)
throws|throws
name|IOException
block|{
name|long
name|count
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|iterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|count
operator|++
expr_stmt|;
name|eval
operator|.
name|call
argument_list|(
name|iterator
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|count
return|;
block|}
comment|/**    * Map an operation to every {@link LocatedFileStatus} in a remote    * iterator, returning a list of the results.    * @param<T> return type of map    * @param iterator iterator from a list    * @param eval closure to evaluate    * @return the list of mapped results.    * @throws IOException anything in the closure, or iteration logic.    */
DECL|method|mapLocatedFiles ( RemoteIterator<? extends LocatedFileStatus> iterator, LocatedFileStatusMap<T> eval)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|List
argument_list|<
name|T
argument_list|>
name|mapLocatedFiles
parameter_list|(
name|RemoteIterator
argument_list|<
name|?
extends|extends
name|LocatedFileStatus
argument_list|>
name|iterator
parameter_list|,
name|LocatedFileStatusMap
argument_list|<
name|T
argument_list|>
name|eval
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|List
argument_list|<
name|T
argument_list|>
name|results
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|applyLocatedFiles
argument_list|(
name|iterator
argument_list|,
parameter_list|(
name|s
parameter_list|)
lambda|->
name|results
operator|.
name|add
argument_list|(
name|eval
operator|.
name|call
argument_list|(
name|s
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|results
return|;
block|}
comment|/**    * Map an operation to every {@link LocatedFileStatus} in a remote    * iterator, returning a list of the all results which were not empty.    * @param<T> return type of map    * @param iterator iterator from a list    * @param eval closure to evaluate    * @return the flattened list of mapped results.    * @throws IOException anything in the closure, or iteration logic.    */
DECL|method|flatmapLocatedFiles ( RemoteIterator<LocatedFileStatus> iterator, LocatedFileStatusMap<Optional<T>> eval)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|List
argument_list|<
name|T
argument_list|>
name|flatmapLocatedFiles
parameter_list|(
name|RemoteIterator
argument_list|<
name|LocatedFileStatus
argument_list|>
name|iterator
parameter_list|,
name|LocatedFileStatusMap
argument_list|<
name|Optional
argument_list|<
name|T
argument_list|>
argument_list|>
name|eval
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|List
argument_list|<
name|T
argument_list|>
name|results
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|applyLocatedFiles
argument_list|(
name|iterator
argument_list|,
parameter_list|(
name|s
parameter_list|)
lambda|->
name|eval
operator|.
name|call
argument_list|(
name|s
argument_list|)
operator|.
name|map
argument_list|(
name|r
lambda|->
name|results
operator|.
name|add
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|results
return|;
block|}
comment|/**    * List located files and filter them as a classic listFiles(path, filter)    * would do.    * @param fileSystem filesystem    * @param path path to list    * @param recursive recursive listing?    * @param filter filter for the filename    * @return the filtered list of entries    * @throws IOException IO failure.    */
DECL|method|listAndFilter (FileSystem fileSystem, Path path, boolean recursive, PathFilter filter)
specifier|public
specifier|static
name|List
argument_list|<
name|LocatedFileStatus
argument_list|>
name|listAndFilter
parameter_list|(
name|FileSystem
name|fileSystem
parameter_list|,
name|Path
name|path
parameter_list|,
name|boolean
name|recursive
parameter_list|,
name|PathFilter
name|filter
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|flatmapLocatedFiles
argument_list|(
name|fileSystem
operator|.
name|listFiles
argument_list|(
name|path
argument_list|,
name|recursive
argument_list|)
argument_list|,
name|status
lambda|->
name|maybe
argument_list|(
name|filter
operator|.
name|accept
argument_list|(
name|status
operator|.
name|getPath
argument_list|()
argument_list|)
argument_list|,
name|status
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Convert a value into a non-empty Optional instance if    * the value of {@code include} is true.    * @param include flag to indicate the value is to be included.    * @param value value to return    * @param<T> type of option.    * @return if include is false, Optional.empty. Otherwise, the value.    */
DECL|method|maybe (boolean include, T value)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|Optional
argument_list|<
name|T
argument_list|>
name|maybe
parameter_list|(
name|boolean
name|include
parameter_list|,
name|T
name|value
parameter_list|)
block|{
return|return
name|include
condition|?
name|Optional
operator|.
name|of
argument_list|(
name|value
argument_list|)
else|:
name|Optional
operator|.
name|empty
argument_list|()
return|;
block|}
comment|/**    * Patch the security credential provider information in    * {@link #CREDENTIAL_PROVIDER_PATH}    * with the providers listed in    * {@link Constants#S3A_SECURITY_CREDENTIAL_PROVIDER_PATH}.    *    * This allows different buckets to use different credential files.    * @param conf configuration to patch    */
DECL|method|patchSecurityCredentialProviders (Configuration conf)
specifier|static
name|void
name|patchSecurityCredentialProviders
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
name|Collection
argument_list|<
name|String
argument_list|>
name|customCredentials
init|=
name|conf
operator|.
name|getStringCollection
argument_list|(
name|S3A_SECURITY_CREDENTIAL_PROVIDER_PATH
argument_list|)
decl_stmt|;
name|Collection
argument_list|<
name|String
argument_list|>
name|hadoopCredentials
init|=
name|conf
operator|.
name|getStringCollection
argument_list|(
name|CREDENTIAL_PROVIDER_PATH
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|customCredentials
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|all
init|=
name|Lists
operator|.
name|newArrayList
argument_list|(
name|customCredentials
argument_list|)
decl_stmt|;
name|all
operator|.
name|addAll
argument_list|(
name|hadoopCredentials
argument_list|)
expr_stmt|;
name|String
name|joined
init|=
name|StringUtils
operator|.
name|join
argument_list|(
name|all
argument_list|,
literal|','
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Setting {} to {}"
argument_list|,
name|CREDENTIAL_PROVIDER_PATH
argument_list|,
name|joined
argument_list|)
expr_stmt|;
name|conf
operator|.
name|set
argument_list|(
name|CREDENTIAL_PROVIDER_PATH
argument_list|,
name|joined
argument_list|,
literal|"patch of "
operator|+
name|S3A_SECURITY_CREDENTIAL_PROVIDER_PATH
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Get any SSE key from a configuration/credential provider.    * This operation handles the case where the option has been    * set in the provider or configuration to the option    * {@code OLD_S3A_SERVER_SIDE_ENCRYPTION_KEY}.    * IOExceptions raised during retrieval are swallowed.    * @param bucket bucket to query for    * @param conf configuration to examine    * @return the encryption key or ""    * @throws IllegalArgumentException bad arguments.    */
DECL|method|getServerSideEncryptionKey (String bucket, Configuration conf)
specifier|public
specifier|static
name|String
name|getServerSideEncryptionKey
parameter_list|(
name|String
name|bucket
parameter_list|,
name|Configuration
name|conf
parameter_list|)
block|{
try|try
block|{
return|return
name|lookupPassword
argument_list|(
name|bucket
argument_list|,
name|conf
argument_list|,
name|SERVER_SIDE_ENCRYPTION_KEY
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Cannot retrieve "
operator|+
name|SERVER_SIDE_ENCRYPTION_KEY
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
literal|""
return|;
block|}
block|}
comment|/**    * Get the server-side encryption algorithm.    * This includes validation of the configuration, checking the state of    * the encryption key given the chosen algorithm.    *    * @param bucket bucket to query for    * @param conf configuration to scan    * @return the encryption mechanism (which will be {@code NONE} unless    * one is set.    * @throws IOException on any validation problem.    */
DECL|method|getEncryptionAlgorithm (String bucket, Configuration conf)
specifier|public
specifier|static
name|S3AEncryptionMethods
name|getEncryptionAlgorithm
parameter_list|(
name|String
name|bucket
parameter_list|,
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|S3AEncryptionMethods
name|sse
init|=
name|S3AEncryptionMethods
operator|.
name|getMethod
argument_list|(
name|lookupPassword
argument_list|(
name|bucket
argument_list|,
name|conf
argument_list|,
name|SERVER_SIDE_ENCRYPTION_ALGORITHM
argument_list|)
argument_list|)
decl_stmt|;
name|String
name|sseKey
init|=
name|getServerSideEncryptionKey
argument_list|(
name|bucket
argument_list|,
name|conf
argument_list|)
decl_stmt|;
name|int
name|sseKeyLen
init|=
name|StringUtils
operator|.
name|isBlank
argument_list|(
name|sseKey
argument_list|)
condition|?
literal|0
else|:
name|sseKey
operator|.
name|length
argument_list|()
decl_stmt|;
name|String
name|diagnostics
init|=
name|passwordDiagnostics
argument_list|(
name|sseKey
argument_list|,
literal|"key"
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|sse
condition|)
block|{
case|case
name|SSE_C
case|:
name|LOG
operator|.
name|debug
argument_list|(
literal|"Using SSE-C with {}"
argument_list|,
name|diagnostics
argument_list|)
expr_stmt|;
if|if
condition|(
name|sseKeyLen
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|SSE_C_NO_KEY_ERROR
argument_list|)
throw|;
block|}
break|break;
case|case
name|SSE_S3
case|:
if|if
condition|(
name|sseKeyLen
operator|!=
literal|0
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|SSE_S3_WITH_KEY_ERROR
operator|+
literal|" ("
operator|+
name|diagnostics
operator|+
literal|")"
argument_list|)
throw|;
block|}
break|break;
case|case
name|SSE_KMS
case|:
name|LOG
operator|.
name|debug
argument_list|(
literal|"Using SSE-KMS with {}"
argument_list|,
name|diagnostics
argument_list|)
expr_stmt|;
break|break;
case|case
name|NONE
case|:
default|default:
name|LOG
operator|.
name|debug
argument_list|(
literal|"Data is unencrypted"
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|sse
return|;
block|}
comment|/**    * Provide a password diagnostics string.    * This aims to help diagnostics without revealing significant password details    * @param pass password    * @param description description for text, e.g "key" or "password"    * @return text for use in messages.    */
DECL|method|passwordDiagnostics (String pass, String description)
specifier|private
specifier|static
name|String
name|passwordDiagnostics
parameter_list|(
name|String
name|pass
parameter_list|,
name|String
name|description
parameter_list|)
block|{
if|if
condition|(
name|pass
operator|==
literal|null
condition|)
block|{
return|return
literal|"null "
operator|+
name|description
return|;
block|}
name|int
name|len
init|=
name|pass
operator|.
name|length
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|len
condition|)
block|{
case|case
literal|0
case|:
return|return
literal|"empty "
operator|+
name|description
return|;
case|case
literal|1
case|:
return|return
name|description
operator|+
literal|" of length 1"
return|;
default|default:
return|return
name|description
operator|+
literal|" of length "
operator|+
name|len
operator|+
literal|" ending with "
operator|+
name|pass
operator|.
name|charAt
argument_list|(
name|len
operator|-
literal|1
argument_list|)
return|;
block|}
block|}
comment|/**    * Close the Closeable objects and<b>ignore</b> any Exception or    * null pointers.    * (This is the SLF4J equivalent of that in {@code IOUtils}).    * @param log the log to log at debug level. Can be null.    * @param closeables the objects to close    */
DECL|method|closeAll (Logger log, Closeable... closeables)
specifier|public
specifier|static
name|void
name|closeAll
parameter_list|(
name|Logger
name|log
parameter_list|,
name|Closeable
modifier|...
name|closeables
parameter_list|)
block|{
if|if
condition|(
name|log
operator|==
literal|null
condition|)
block|{
name|log
operator|=
name|LOG
expr_stmt|;
block|}
for|for
control|(
name|Closeable
name|c
range|:
name|closeables
control|)
block|{
if|if
condition|(
name|c
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"Closing {}"
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|c
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"Exception in closing {}"
argument_list|,
name|c
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**    * Close the Closeable objects and<b>ignore</b> any Exception or    * null pointers.    * (This is the SLF4J equivalent of that in {@code IOUtils}).    * @param log the log to log at debug level. Can be null.    * @param closeables the objects to close    */
DECL|method|closeAutocloseables (Logger log, AutoCloseable... closeables)
specifier|public
specifier|static
name|void
name|closeAutocloseables
parameter_list|(
name|Logger
name|log
parameter_list|,
name|AutoCloseable
modifier|...
name|closeables
parameter_list|)
block|{
if|if
condition|(
name|log
operator|==
literal|null
condition|)
block|{
name|log
operator|=
name|LOG
expr_stmt|;
block|}
for|for
control|(
name|AutoCloseable
name|c
range|:
name|closeables
control|)
block|{
if|if
condition|(
name|c
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"Closing {}"
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|c
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"Exception in closing {}"
argument_list|,
name|c
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**    * Set a bucket-specific property to a particular value.    * If the generic key passed in has an {@code fs.s3a. prefix},    * that's stripped off, so that when the the bucket properties are propagated    * down to the generic values, that value gets copied down.    * @param conf configuration to set    * @param bucket bucket name    * @param genericKey key; can start with "fs.s3a."    * @param value value to set    */
DECL|method|setBucketOption (Configuration conf, String bucket, String genericKey, String value)
specifier|public
specifier|static
name|void
name|setBucketOption
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|String
name|bucket
parameter_list|,
name|String
name|genericKey
parameter_list|,
name|String
name|value
parameter_list|)
block|{
specifier|final
name|String
name|baseKey
init|=
name|genericKey
operator|.
name|startsWith
argument_list|(
name|FS_S3A_PREFIX
argument_list|)
condition|?
name|genericKey
operator|.
name|substring
argument_list|(
name|FS_S3A_PREFIX
operator|.
name|length
argument_list|()
argument_list|)
else|:
name|genericKey
decl_stmt|;
name|conf
operator|.
name|set
argument_list|(
name|FS_S3A_BUCKET_PREFIX
operator|+
name|bucket
operator|+
literal|'.'
operator|+
name|baseKey
argument_list|,
name|value
argument_list|,
literal|"S3AUtils"
argument_list|)
expr_stmt|;
block|}
comment|/**    * Clear a bucket-specific property.    * If the generic key passed in has an {@code fs.s3a. prefix},    * that's stripped off, so that when the the bucket properties are propagated    * down to the generic values, that value gets copied down.    * @param conf configuration to set    * @param bucket bucket name    * @param genericKey key; can start with "fs.s3a."    */
DECL|method|clearBucketOption (Configuration conf, String bucket, String genericKey)
specifier|public
specifier|static
name|void
name|clearBucketOption
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|String
name|bucket
parameter_list|,
name|String
name|genericKey
parameter_list|)
block|{
specifier|final
name|String
name|baseKey
init|=
name|genericKey
operator|.
name|startsWith
argument_list|(
name|FS_S3A_PREFIX
argument_list|)
condition|?
name|genericKey
operator|.
name|substring
argument_list|(
name|FS_S3A_PREFIX
operator|.
name|length
argument_list|()
argument_list|)
else|:
name|genericKey
decl_stmt|;
name|String
name|k
init|=
name|FS_S3A_BUCKET_PREFIX
operator|+
name|bucket
operator|+
literal|'.'
operator|+
name|baseKey
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Unset {}"
argument_list|,
name|k
argument_list|)
expr_stmt|;
name|conf
operator|.
name|unset
argument_list|(
name|k
argument_list|)
expr_stmt|;
block|}
comment|/**    * Get a bucket-specific property.    * If the generic key passed in has an {@code fs.s3a. prefix},    * that's stripped off.    * @param conf configuration to set    * @param bucket bucket name    * @param genericKey key; can start with "fs.s3a."    * @return the bucket option, null if there is none    */
DECL|method|getBucketOption (Configuration conf, String bucket, String genericKey)
specifier|public
specifier|static
name|String
name|getBucketOption
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|String
name|bucket
parameter_list|,
name|String
name|genericKey
parameter_list|)
block|{
specifier|final
name|String
name|baseKey
init|=
name|genericKey
operator|.
name|startsWith
argument_list|(
name|FS_S3A_PREFIX
argument_list|)
condition|?
name|genericKey
operator|.
name|substring
argument_list|(
name|FS_S3A_PREFIX
operator|.
name|length
argument_list|()
argument_list|)
else|:
name|genericKey
decl_stmt|;
return|return
name|conf
operator|.
name|get
argument_list|(
name|FS_S3A_BUCKET_PREFIX
operator|+
name|bucket
operator|+
literal|'.'
operator|+
name|baseKey
argument_list|)
return|;
block|}
comment|/**    * Path filter which ignores any file which starts with . or _.    */
DECL|field|HIDDEN_FILE_FILTER
specifier|public
specifier|static
specifier|final
name|PathFilter
name|HIDDEN_FILE_FILTER
init|=
operator|new
name|PathFilter
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|accept
parameter_list|(
name|Path
name|path
parameter_list|)
block|{
name|String
name|name
init|=
name|path
operator|.
name|getName
argument_list|()
decl_stmt|;
return|return
operator|!
name|name
operator|.
name|startsWith
argument_list|(
literal|"_"
argument_list|)
operator|&&
operator|!
name|name
operator|.
name|startsWith
argument_list|(
literal|"."
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"HIDDEN_FILE_FILTER"
return|;
block|}
block|}
decl_stmt|;
comment|/**    * A Path filter which accepts all filenames.    */
DECL|field|ACCEPT_ALL
specifier|public
specifier|static
specifier|final
name|PathFilter
name|ACCEPT_ALL
init|=
operator|new
name|PathFilter
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|accept
parameter_list|(
name|Path
name|file
parameter_list|)
block|{
return|return
literal|true
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"ACCEPT_ALL"
return|;
block|}
block|}
decl_stmt|;
block|}
end_class

end_unit

