begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.fs.s3a
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InterruptedIOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Optional
import|;
end_import

begin_import
import|import
name|com
operator|.
name|amazonaws
operator|.
name|AmazonClientException
import|;
end_import

begin_import
import|import
name|com
operator|.
name|amazonaws
operator|.
name|SdkBaseException
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang3
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|retry
operator|.
name|RetryPolicy
import|;
end_import

begin_comment
comment|/**  * Class to provide lambda expression invocation of AWS operations.  *  * The core retry logic is in  * {@link #retryUntranslated(String, boolean, Retried, Operation)};  * the other {@code retry() and retryUntranslated()} calls are wrappers.  *  * The static {@link #once(String, String, Operation)} and  * {@link #once(String, String, VoidOperation)} calls take an operation and  * return it with AWS exceptions translated to IOEs of some form.  *  * The retry logic on a failure is defined by the retry policy passed in  * the constructor; the standard retry policy is {@link S3ARetryPolicy},  * though others may be used.  *  * The constructor also takes two {@link Retried} callbacks.  * The {@code caughtCallback} is called whenever an exception (IOE or AWS)  * is caught, before the retry processing looks at it.  * The {@code retryCallback} is invoked after a retry is scheduled  * but before the sleep.  * These callbacks can be used for reporting and incrementing statistics.  *  * The static {@link #quietly(String, String, VoidOperation)} and  * {@link #quietlyEval(String, String, Operation)} calls exist to take any  * operation and quietly catch and log at debug. The return value of  * {@link #quietlyEval(String, String, Operation)} is a java 8 optional,  * which can then be used in java8-expressions.  */
end_comment

begin_class
DECL|class|Invoker
specifier|public
class|class
name|Invoker
block|{
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|Invoker
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/**    * Retry policy to use.    */
DECL|field|retryPolicy
specifier|private
specifier|final
name|RetryPolicy
name|retryPolicy
decl_stmt|;
comment|/**    * Default retry handler.    */
DECL|field|retryCallback
specifier|private
specifier|final
name|Retried
name|retryCallback
decl_stmt|;
comment|/**    * Instantiate.    * @param retryPolicy retry policy for all operations.    * @param retryCallback standard retry policy    */
DECL|method|Invoker ( RetryPolicy retryPolicy, Retried retryCallback)
specifier|public
name|Invoker
parameter_list|(
name|RetryPolicy
name|retryPolicy
parameter_list|,
name|Retried
name|retryCallback
parameter_list|)
block|{
name|this
operator|.
name|retryPolicy
operator|=
name|retryPolicy
expr_stmt|;
name|this
operator|.
name|retryCallback
operator|=
name|retryCallback
expr_stmt|;
block|}
DECL|method|getRetryPolicy ()
specifier|public
name|RetryPolicy
name|getRetryPolicy
parameter_list|()
block|{
return|return
name|retryPolicy
return|;
block|}
DECL|method|getRetryCallback ()
specifier|public
name|Retried
name|getRetryCallback
parameter_list|()
block|{
return|return
name|retryCallback
return|;
block|}
comment|/**    * Execute a function, translating any exception into an IOException.    * @param action action to execute (used in error messages)    * @param path path of work (used in error messages)    * @param operation operation to execute    * @param<T> type of return value    * @return the result of the function call    * @throws IOException any IOE raised, or translated exception    */
annotation|@
name|Retries
operator|.
name|OnceTranslated
DECL|method|once (String action, String path, Operation<T> operation)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|T
name|once
parameter_list|(
name|String
name|action
parameter_list|,
name|String
name|path
parameter_list|,
name|Operation
argument_list|<
name|T
argument_list|>
name|operation
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
return|return
name|operation
operator|.
name|execute
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|AmazonClientException
name|e
parameter_list|)
block|{
throw|throw
name|S3AUtils
operator|.
name|translateException
argument_list|(
name|action
argument_list|,
name|path
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**    * Execute an operation with no result.    * @param action action to execute (used in error messages)    * @param path path of work (used in error messages)    * @param operation operation to execute    * @throws IOException any IOE raised, or translated exception    */
annotation|@
name|Retries
operator|.
name|OnceTranslated
DECL|method|once (String action, String path, VoidOperation operation)
specifier|public
specifier|static
name|void
name|once
parameter_list|(
name|String
name|action
parameter_list|,
name|String
name|path
parameter_list|,
name|VoidOperation
name|operation
parameter_list|)
throws|throws
name|IOException
block|{
name|once
argument_list|(
name|action
argument_list|,
name|path
argument_list|,
parameter_list|()
lambda|->
block|{
name|operation
operator|.
name|execute
argument_list|()
expr_stmt|;
return|return
literal|null
return|;
block|}
argument_list|)
expr_stmt|;
block|}
comment|/**    * Execute an operation and ignore all raised IOExceptions; log at INFO.    * @param log log to log at info.    * @param action action to include in log    * @param path optional path to include in log    * @param operation operation to execute    * @param<T> type of operation    */
DECL|method|ignoreIOExceptions ( Logger log, String action, String path, Operation<T> operation)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|void
name|ignoreIOExceptions
parameter_list|(
name|Logger
name|log
parameter_list|,
name|String
name|action
parameter_list|,
name|String
name|path
parameter_list|,
name|Operation
argument_list|<
name|T
argument_list|>
name|operation
parameter_list|)
block|{
try|try
block|{
name|once
argument_list|(
name|action
argument_list|,
name|path
argument_list|,
name|operation
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"{}: {}"
argument_list|,
name|toDescription
argument_list|(
name|action
argument_list|,
name|path
argument_list|)
argument_list|,
name|e
operator|.
name|toString
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Execute an operation and ignore all raised IOExceptions; log at INFO.    * @param log log to log at info.    * @param action action to include in log    * @param path optional path to include in log    * @param operation operation to execute    */
DECL|method|ignoreIOExceptions ( Logger log, String action, String path, VoidOperation operation)
specifier|public
specifier|static
name|void
name|ignoreIOExceptions
parameter_list|(
name|Logger
name|log
parameter_list|,
name|String
name|action
parameter_list|,
name|String
name|path
parameter_list|,
name|VoidOperation
name|operation
parameter_list|)
block|{
name|ignoreIOExceptions
argument_list|(
name|log
argument_list|,
name|action
argument_list|,
name|path
argument_list|,
parameter_list|()
lambda|->
block|{
name|operation
operator|.
name|execute
argument_list|()
expr_stmt|;
return|return
literal|null
return|;
block|}
argument_list|)
expr_stmt|;
block|}
comment|/**    * Execute a void operation with retry processing.    * @param action action to execute (used in error messages)    * @param path path of work (used in error messages)    * @param idempotent does the operation have semantics    * which mean that it can be retried even if was already executed?    * @param retrying callback on retries    * @param operation operation to execute    * @throws IOException any IOE raised, or translated exception    */
annotation|@
name|Retries
operator|.
name|RetryTranslated
DECL|method|retry (String action, String path, boolean idempotent, Retried retrying, VoidOperation operation)
specifier|public
name|void
name|retry
parameter_list|(
name|String
name|action
parameter_list|,
name|String
name|path
parameter_list|,
name|boolean
name|idempotent
parameter_list|,
name|Retried
name|retrying
parameter_list|,
name|VoidOperation
name|operation
parameter_list|)
throws|throws
name|IOException
block|{
name|retry
argument_list|(
name|action
argument_list|,
name|path
argument_list|,
name|idempotent
argument_list|,
name|retrying
argument_list|,
parameter_list|()
lambda|->
block|{
name|operation
operator|.
name|execute
argument_list|()
expr_stmt|;
return|return
literal|null
return|;
block|}
argument_list|)
expr_stmt|;
block|}
comment|/**    * Execute a void operation with  the default retry callback invoked.    * @param action action to execute (used in error messages)    * @param path path of work (used in error messages)    * @param idempotent does the operation have semantics    * which mean that it can be retried even if was already executed?    * @param operation operation to execute    * @throws IOException any IOE raised, or translated exception    */
annotation|@
name|Retries
operator|.
name|RetryTranslated
DECL|method|retry (String action, String path, boolean idempotent, VoidOperation operation)
specifier|public
name|void
name|retry
parameter_list|(
name|String
name|action
parameter_list|,
name|String
name|path
parameter_list|,
name|boolean
name|idempotent
parameter_list|,
name|VoidOperation
name|operation
parameter_list|)
throws|throws
name|IOException
block|{
name|retry
argument_list|(
name|action
argument_list|,
name|path
argument_list|,
name|idempotent
argument_list|,
name|retryCallback
argument_list|,
name|operation
argument_list|)
expr_stmt|;
block|}
comment|/**    * Execute a function with the default retry callback invoked.    * @param action action to execute (used in error messages)    * @param path path of work (used in error messages)    * @param idempotent does the operation have semantics    * which mean that it can be retried even if was already executed?    * @param operation operation to execute    * @param<T> type of return value    * @return the result of the call    * @throws IOException any IOE raised, or translated exception    */
annotation|@
name|Retries
operator|.
name|RetryTranslated
DECL|method|retry (String action, String path, boolean idempotent, Operation<T> operation)
specifier|public
parameter_list|<
name|T
parameter_list|>
name|T
name|retry
parameter_list|(
name|String
name|action
parameter_list|,
name|String
name|path
parameter_list|,
name|boolean
name|idempotent
parameter_list|,
name|Operation
argument_list|<
name|T
argument_list|>
name|operation
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|retry
argument_list|(
name|action
argument_list|,
name|path
argument_list|,
name|idempotent
argument_list|,
name|retryCallback
argument_list|,
name|operation
argument_list|)
return|;
block|}
comment|/**    * Execute a function with retry processing.    * Uses {@link #once(String, String, Operation)} as the inner    * invocation mechanism before retry logic is performed.    * @param<T> type of return value    * @param action action to execute (used in error messages)    * @param path path of work (used in error messages)    * @param idempotent does the operation have semantics    * which mean that it can be retried even if was already executed?    * @param retrying callback on retries    * @param operation operation to execute    * @return the result of the call    * @throws IOException any IOE raised, or translated exception    */
annotation|@
name|Retries
operator|.
name|RetryTranslated
DECL|method|retry ( String action, String path, boolean idempotent, Retried retrying, Operation<T> operation)
specifier|public
parameter_list|<
name|T
parameter_list|>
name|T
name|retry
parameter_list|(
name|String
name|action
parameter_list|,
name|String
name|path
parameter_list|,
name|boolean
name|idempotent
parameter_list|,
name|Retried
name|retrying
parameter_list|,
name|Operation
argument_list|<
name|T
argument_list|>
name|operation
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|retryUntranslated
argument_list|(
name|toDescription
argument_list|(
name|action
argument_list|,
name|path
argument_list|)
argument_list|,
name|idempotent
argument_list|,
name|retrying
argument_list|,
parameter_list|()
lambda|->
name|once
argument_list|(
name|action
argument_list|,
name|path
argument_list|,
name|operation
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Execute a function with retry processing and no translation.    * and the default retry callback.    * @param text description for the catching callback    * @param idempotent does the operation have semantics    * which mean that it can be retried even if was already executed?    * @param operation operation to execute    * @param<T> type of return value    * @return the result of the call    * @throws IOException any IOE raised    * @throws RuntimeException any Runtime exception raised    */
annotation|@
name|Retries
operator|.
name|RetryRaw
DECL|method|retryUntranslated ( String text, boolean idempotent, Operation<T> operation)
specifier|public
parameter_list|<
name|T
parameter_list|>
name|T
name|retryUntranslated
parameter_list|(
name|String
name|text
parameter_list|,
name|boolean
name|idempotent
parameter_list|,
name|Operation
argument_list|<
name|T
argument_list|>
name|operation
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|retryUntranslated
argument_list|(
name|text
argument_list|,
name|idempotent
argument_list|,
name|retryCallback
argument_list|,
name|operation
argument_list|)
return|;
block|}
comment|/**    * Execute a function with retry processing: AWS SDK Exceptions    * are<i>not</i> translated.    * This is method which the others eventually invoke.    * @param<T> type of return value    * @param text text to include in messages    * @param idempotent does the operation have semantics    * which mean that it can be retried even if was already executed?    * @param retrying callback on retries    * @param operation operation to execute    * @return the result of the call    * @throws IOException any IOE raised    * @throws SdkBaseException any AWS exception raised    * @throws RuntimeException : these are never caught and retries.    */
annotation|@
name|Retries
operator|.
name|RetryRaw
DECL|method|retryUntranslated ( String text, boolean idempotent, Retried retrying, Operation<T> operation)
specifier|public
parameter_list|<
name|T
parameter_list|>
name|T
name|retryUntranslated
parameter_list|(
name|String
name|text
parameter_list|,
name|boolean
name|idempotent
parameter_list|,
name|Retried
name|retrying
parameter_list|,
name|Operation
argument_list|<
name|T
argument_list|>
name|operation
parameter_list|)
throws|throws
name|IOException
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|retrying
operator|!=
literal|null
argument_list|,
literal|"null retrying argument"
argument_list|)
expr_stmt|;
name|int
name|retryCount
init|=
literal|0
decl_stmt|;
name|Exception
name|caught
decl_stmt|;
name|RetryPolicy
operator|.
name|RetryAction
name|retryAction
decl_stmt|;
name|boolean
name|shouldRetry
decl_stmt|;
do|do
block|{
try|try
block|{
comment|// execute the operation, returning if successful
return|return
name|operation
operator|.
name|execute
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|IOException
decl||
name|SdkBaseException
name|e
parameter_list|)
block|{
name|caught
operator|=
name|e
expr_stmt|;
block|}
comment|// you only get here if the operation didn't complete
comment|// normally, hence caught != null
comment|// translate the exception into an IOE for the retry logic
name|IOException
name|translated
decl_stmt|;
if|if
condition|(
name|caught
operator|instanceof
name|IOException
condition|)
block|{
name|translated
operator|=
operator|(
name|IOException
operator|)
name|caught
expr_stmt|;
block|}
else|else
block|{
name|translated
operator|=
name|S3AUtils
operator|.
name|translateException
argument_list|(
name|text
argument_list|,
literal|""
argument_list|,
operator|(
name|SdkBaseException
operator|)
name|caught
argument_list|)
expr_stmt|;
block|}
name|int
name|attempts
init|=
name|retryCount
operator|+
literal|1
decl_stmt|;
try|try
block|{
comment|// decide action base on operation, invocation count, etc
name|retryAction
operator|=
name|retryPolicy
operator|.
name|shouldRetry
argument_list|(
name|translated
argument_list|,
name|retryCount
argument_list|,
literal|0
argument_list|,
name|idempotent
argument_list|)
expr_stmt|;
comment|// is it a retry operation?
name|shouldRetry
operator|=
name|retryAction
operator|.
name|action
operator|.
name|equals
argument_list|(
name|RetryPolicy
operator|.
name|RetryAction
operator|.
name|RETRY
operator|.
name|action
argument_list|)
expr_stmt|;
if|if
condition|(
name|shouldRetry
condition|)
block|{
comment|// notify the callback
name|retrying
operator|.
name|onFailure
argument_list|(
name|text
argument_list|,
name|translated
argument_list|,
name|retryCount
argument_list|,
name|idempotent
argument_list|)
expr_stmt|;
comment|// then sleep for the policy delay
name|Thread
operator|.
name|sleep
argument_list|(
name|retryAction
operator|.
name|delayMillis
argument_list|)
expr_stmt|;
block|}
comment|// increment the retry count
name|retryCount
operator|++
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
comment|// sleep was interrupted
comment|// change the exception
name|caught
operator|=
operator|new
name|InterruptedIOException
argument_list|(
literal|"Interrupted"
argument_list|)
expr_stmt|;
name|caught
operator|.
name|initCause
argument_list|(
name|e
argument_list|)
expr_stmt|;
comment|// no retry
name|shouldRetry
operator|=
literal|false
expr_stmt|;
comment|// and re-interrupt the thread
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
comment|// The retry policy raised an exception
comment|// log that something happened
name|LOG
operator|.
name|warn
argument_list|(
literal|"{}: exception in retry processing"
argument_list|,
name|text
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|// and fail the execution with the last execution exception.
name|shouldRetry
operator|=
literal|false
expr_stmt|;
block|}
block|}
do|while
condition|(
name|shouldRetry
condition|)
do|;
if|if
condition|(
name|caught
operator|instanceof
name|IOException
condition|)
block|{
throw|throw
operator|(
name|IOException
operator|)
name|caught
throw|;
block|}
else|else
block|{
throw|throw
operator|(
name|SdkBaseException
operator|)
name|caught
throw|;
block|}
block|}
comment|/**    * Execute an operation; any exception raised is simply caught and    * logged at debug.    * @param action action to execute    * @param path path (for exception construction)    * @param operation operation    */
DECL|method|quietly (String action, String path, VoidOperation operation)
specifier|public
specifier|static
name|void
name|quietly
parameter_list|(
name|String
name|action
parameter_list|,
name|String
name|path
parameter_list|,
name|VoidOperation
name|operation
parameter_list|)
block|{
try|try
block|{
name|once
argument_list|(
name|action
argument_list|,
name|path
argument_list|,
name|operation
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Action {} failed"
argument_list|,
name|action
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Execute an operation; any exception raised is caught and    * logged at debug.    * The result is only non-empty if the operation succeeded    * @param<T> type to return    * @param action action to execute    * @param path path (for exception construction)    * @param operation operation    * @return the result of a successful operation    */
DECL|method|quietlyEval (String action, String path, Operation<T> operation)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|Optional
argument_list|<
name|T
argument_list|>
name|quietlyEval
parameter_list|(
name|String
name|action
parameter_list|,
name|String
name|path
parameter_list|,
name|Operation
argument_list|<
name|T
argument_list|>
name|operation
parameter_list|)
block|{
try|try
block|{
return|return
name|Optional
operator|.
name|of
argument_list|(
name|once
argument_list|(
name|action
argument_list|,
name|path
argument_list|,
name|operation
argument_list|)
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Action {} failed"
argument_list|,
name|action
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
name|Optional
operator|.
name|empty
argument_list|()
return|;
block|}
block|}
comment|/**    * Take an action and path and produce a string for logging.    * @param action action    * @param path path (may be null or empty)    * @return string for logs    */
DECL|method|toDescription (String action, String path)
specifier|private
specifier|static
name|String
name|toDescription
parameter_list|(
name|String
name|action
parameter_list|,
name|String
name|path
parameter_list|)
block|{
return|return
name|action
operator|+
operator|(
name|StringUtils
operator|.
name|isNotEmpty
argument_list|(
name|path
argument_list|)
condition|?
operator|(
literal|" on "
operator|+
name|path
operator|)
else|:
literal|""
operator|)
return|;
block|}
comment|/**    * Arbitrary operation throwing an IOException.    * @param<T> return type    */
annotation|@
name|FunctionalInterface
DECL|interface|Operation
specifier|public
interface|interface
name|Operation
parameter_list|<
name|T
parameter_list|>
block|{
DECL|method|execute ()
name|T
name|execute
parameter_list|()
throws|throws
name|IOException
function_decl|;
block|}
comment|/**    * Void operation which may raise an IOException.    */
annotation|@
name|FunctionalInterface
DECL|interface|VoidOperation
specifier|public
interface|interface
name|VoidOperation
block|{
DECL|method|execute ()
name|void
name|execute
parameter_list|()
throws|throws
name|IOException
function_decl|;
block|}
comment|/**    * Callback for retry and notification operations.    * Even if the interface is throwing up "raw" exceptions, this handler    * gets the translated one.    */
annotation|@
name|FunctionalInterface
DECL|interface|Retried
specifier|public
interface|interface
name|Retried
block|{
comment|/**      * Retry event in progress (before any sleep).      * @param text text passed in to the retry() Call.      * @param exception the caught (and possibly translated) exception.      * @param retries number of retries so far      * @param idempotent is the request idempotent.      */
DECL|method|onFailure ( String text, IOException exception, int retries, boolean idempotent)
name|void
name|onFailure
parameter_list|(
name|String
name|text
parameter_list|,
name|IOException
name|exception
parameter_list|,
name|int
name|retries
parameter_list|,
name|boolean
name|idempotent
parameter_list|)
function_decl|;
block|}
comment|/**    * No op for a retrying callback.    */
DECL|field|NO_OP
specifier|public
specifier|static
specifier|final
name|Retried
name|NO_OP
init|=
operator|new
name|Retried
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|onFailure
parameter_list|(
name|String
name|text
parameter_list|,
name|IOException
name|exception
parameter_list|,
name|int
name|retries
parameter_list|,
name|boolean
name|idempotent
parameter_list|)
block|{     }
block|}
decl_stmt|;
comment|/**    * Log summary at info, full stack at debug.    */
DECL|field|LOG_EVENT
specifier|public
specifier|static
specifier|final
name|Retried
name|LOG_EVENT
init|=
operator|new
name|Retried
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|onFailure
parameter_list|(
name|String
name|text
parameter_list|,
name|IOException
name|exception
parameter_list|,
name|int
name|retries
parameter_list|,
name|boolean
name|idempotent
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"{}: "
operator|+
name|exception
argument_list|,
name|text
argument_list|)
expr_stmt|;
if|if
condition|(
name|retries
operator|==
literal|1
condition|)
block|{
comment|// stack on first attempt, to keep noise down
name|LOG
operator|.
name|debug
argument_list|(
literal|"{}: "
operator|+
name|exception
argument_list|,
name|text
argument_list|,
name|exception
argument_list|)
expr_stmt|;
block|}
block|}
block|}
decl_stmt|;
block|}
end_class

end_unit

