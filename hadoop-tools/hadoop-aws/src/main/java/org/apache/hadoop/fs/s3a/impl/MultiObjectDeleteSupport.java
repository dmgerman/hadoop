begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.fs.s3a.impl
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|impl
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|AccessDeniedException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|Function
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|stream
operator|.
name|Collectors
import|;
end_import

begin_import
import|import
name|com
operator|.
name|amazonaws
operator|.
name|services
operator|.
name|s3
operator|.
name|model
operator|.
name|DeleteObjectsRequest
import|;
end_import

begin_import
import|import
name|com
operator|.
name|amazonaws
operator|.
name|services
operator|.
name|s3
operator|.
name|model
operator|.
name|MultiObjectDeleteException
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang3
operator|.
name|tuple
operator|.
name|Pair
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang3
operator|.
name|tuple
operator|.
name|Triple
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|AWSS3IOException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|S3AFileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|s3guard
operator|.
name|MetadataStore
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkNotNull
import|;
end_import

begin_comment
comment|/**  * Support for Multi Object Deletion.  */
end_comment

begin_class
DECL|class|MultiObjectDeleteSupport
specifier|public
specifier|final
class|class
name|MultiObjectDeleteSupport
extends|extends
name|AbstractStoreOperation
block|{
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|MultiObjectDeleteSupport
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/**    * Initiate with a store context.    * @param context store context.    */
DECL|method|MultiObjectDeleteSupport (final StoreContext context)
specifier|public
name|MultiObjectDeleteSupport
parameter_list|(
specifier|final
name|StoreContext
name|context
parameter_list|)
block|{
name|super
argument_list|(
name|context
argument_list|)
expr_stmt|;
block|}
comment|/**    * This is the exception exit code if access was denied on a delete.    * {@value}.    */
DECL|field|ACCESS_DENIED
specifier|public
specifier|static
specifier|final
name|String
name|ACCESS_DENIED
init|=
literal|"AccessDenied"
decl_stmt|;
comment|/**    * A {@code MultiObjectDeleteException} is raised if one or more    * paths listed in a bulk DELETE operation failed.    * The top-level exception is therefore just "something wasn't deleted",    * but doesn't include the what or the why.    * This translation will extract an AccessDeniedException if that's one of    * the causes, otherwise grabs the status code and uses it in the    * returned exception.    * @param message text for the exception    * @param deleteException the delete exception. to translate    * @return an IOE with more detail.    */
DECL|method|translateDeleteException ( final String message, final MultiObjectDeleteException deleteException)
specifier|public
specifier|static
name|IOException
name|translateDeleteException
parameter_list|(
specifier|final
name|String
name|message
parameter_list|,
specifier|final
name|MultiObjectDeleteException
name|deleteException
parameter_list|)
block|{
specifier|final
name|StringBuilder
name|result
init|=
operator|new
name|StringBuilder
argument_list|(
name|deleteException
operator|.
name|getErrors
argument_list|()
operator|.
name|size
argument_list|()
operator|*
literal|256
argument_list|)
decl_stmt|;
name|result
operator|.
name|append
argument_list|(
name|message
argument_list|)
operator|.
name|append
argument_list|(
literal|": "
argument_list|)
expr_stmt|;
name|String
name|exitCode
init|=
literal|""
decl_stmt|;
for|for
control|(
name|MultiObjectDeleteException
operator|.
name|DeleteError
name|error
range|:
name|deleteException
operator|.
name|getErrors
argument_list|()
control|)
block|{
name|String
name|code
init|=
name|error
operator|.
name|getCode
argument_list|()
decl_stmt|;
name|result
operator|.
name|append
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"%s: %s: %s%n"
argument_list|,
name|code
argument_list|,
name|error
operator|.
name|getKey
argument_list|()
argument_list|,
name|error
operator|.
name|getMessage
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|exitCode
operator|.
name|isEmpty
argument_list|()
operator|||
name|ACCESS_DENIED
operator|.
name|equals
argument_list|(
name|code
argument_list|)
condition|)
block|{
name|exitCode
operator|=
name|code
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ACCESS_DENIED
operator|.
name|equals
argument_list|(
name|exitCode
argument_list|)
condition|)
block|{
return|return
operator|(
name|IOException
operator|)
operator|new
name|AccessDeniedException
argument_list|(
name|result
operator|.
name|toString
argument_list|()
argument_list|)
operator|.
name|initCause
argument_list|(
name|deleteException
argument_list|)
return|;
block|}
else|else
block|{
return|return
operator|new
name|AWSS3IOException
argument_list|(
name|result
operator|.
name|toString
argument_list|()
argument_list|,
name|deleteException
argument_list|)
return|;
block|}
block|}
comment|/**    * Process a multi object delete exception by building two paths from    * the delete request: one of all deleted files, one of all undeleted values.    * The latter are those rejected in the delete call.    * @param deleteException the delete exception.    * @param keysToDelete the keys in the delete request    * @return tuple of (undeleted, deleted) paths.    */
DECL|method|splitUndeletedKeys ( final MultiObjectDeleteException deleteException, final Collection<DeleteObjectsRequest.KeyVersion> keysToDelete)
specifier|public
name|Pair
argument_list|<
name|List
argument_list|<
name|Path
argument_list|>
argument_list|,
name|List
argument_list|<
name|Path
argument_list|>
argument_list|>
name|splitUndeletedKeys
parameter_list|(
specifier|final
name|MultiObjectDeleteException
name|deleteException
parameter_list|,
specifier|final
name|Collection
argument_list|<
name|DeleteObjectsRequest
operator|.
name|KeyVersion
argument_list|>
name|keysToDelete
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Processing delete failure; keys to delete count = {};"
operator|+
literal|" errors in exception {}; successful deletions = {}"
argument_list|,
name|keysToDelete
operator|.
name|size
argument_list|()
argument_list|,
name|deleteException
operator|.
name|getErrors
argument_list|()
operator|.
name|size
argument_list|()
argument_list|,
name|deleteException
operator|.
name|getDeletedObjects
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
comment|// convert the collection of keys being deleted into paths
specifier|final
name|List
argument_list|<
name|Path
argument_list|>
name|pathsBeingDeleted
init|=
name|keysToPaths
argument_list|(
name|keysToDelete
argument_list|)
decl_stmt|;
comment|// Take this is list of paths
comment|// extract all undeleted entries contained in the exception and
comment|// then removes them from the original list.
name|List
argument_list|<
name|Path
argument_list|>
name|undeleted
init|=
name|removeUndeletedPaths
argument_list|(
name|deleteException
argument_list|,
name|pathsBeingDeleted
argument_list|,
name|getStoreContext
argument_list|()
operator|::
name|keyToPath
argument_list|)
decl_stmt|;
return|return
name|Pair
operator|.
name|of
argument_list|(
name|undeleted
argument_list|,
name|pathsBeingDeleted
argument_list|)
return|;
block|}
comment|/**    * Given a list of delete requests, convert them all to paths.    * @param keysToDelete list of keys for the delete operation.    * @return the paths.    */
DECL|method|keysToPaths ( final Collection<DeleteObjectsRequest.KeyVersion> keysToDelete)
specifier|public
name|List
argument_list|<
name|Path
argument_list|>
name|keysToPaths
parameter_list|(
specifier|final
name|Collection
argument_list|<
name|DeleteObjectsRequest
operator|.
name|KeyVersion
argument_list|>
name|keysToDelete
parameter_list|)
block|{
return|return
name|convertToPaths
argument_list|(
name|keysToDelete
argument_list|,
name|getStoreContext
argument_list|()
operator|::
name|keyToPath
argument_list|)
return|;
block|}
comment|/**    * Given a list of delete requests, convert them all to paths.    * @param keysToDelete list of keys for the delete operation.    * @param qualifier path qualifier    * @return the paths.    */
DECL|method|convertToPaths ( final Collection<DeleteObjectsRequest.KeyVersion> keysToDelete, final Function<String, Path> qualifier)
specifier|public
specifier|static
name|List
argument_list|<
name|Path
argument_list|>
name|convertToPaths
parameter_list|(
specifier|final
name|Collection
argument_list|<
name|DeleteObjectsRequest
operator|.
name|KeyVersion
argument_list|>
name|keysToDelete
parameter_list|,
specifier|final
name|Function
argument_list|<
name|String
argument_list|,
name|Path
argument_list|>
name|qualifier
parameter_list|)
block|{
return|return
name|keysToDelete
operator|.
name|stream
argument_list|()
operator|.
name|map
argument_list|(
parameter_list|(
name|keyVersion
parameter_list|)
lambda|->
name|qualifier
operator|.
name|apply
argument_list|(
name|keyVersion
operator|.
name|getKey
argument_list|()
argument_list|)
argument_list|)
operator|.
name|collect
argument_list|(
name|Collectors
operator|.
name|toList
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Process a delete failure by removing from the metastore all entries    * which where deleted, as inferred from the delete failures exception    * and the original list of files to delete declares to have been deleted.    * @param deleteException the delete exception.    * @param keysToDelete collection of keys which had been requested.    * @return a tuple of (undeleted, deleted, failures)    */
specifier|public
name|Triple
argument_list|<
name|List
argument_list|<
name|Path
argument_list|>
argument_list|,
name|List
argument_list|<
name|Path
argument_list|>
argument_list|,
name|List
argument_list|<
name|Pair
argument_list|<
name|Path
argument_list|,
name|IOException
argument_list|>
argument_list|>
argument_list|>
DECL|method|processDeleteFailure ( final MultiObjectDeleteException deleteException, final List<DeleteObjectsRequest.KeyVersion> keysToDelete)
name|processDeleteFailure
parameter_list|(
specifier|final
name|MultiObjectDeleteException
name|deleteException
parameter_list|,
specifier|final
name|List
argument_list|<
name|DeleteObjectsRequest
operator|.
name|KeyVersion
argument_list|>
name|keysToDelete
parameter_list|)
block|{
specifier|final
name|MetadataStore
name|metadataStore
init|=
name|checkNotNull
argument_list|(
name|getStoreContext
argument_list|()
operator|.
name|getMetadataStore
argument_list|()
argument_list|,
literal|"context metadatastore"
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|Pair
argument_list|<
name|Path
argument_list|,
name|IOException
argument_list|>
argument_list|>
name|failures
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|Pair
argument_list|<
name|List
argument_list|<
name|Path
argument_list|>
argument_list|,
name|List
argument_list|<
name|Path
argument_list|>
argument_list|>
name|outcome
init|=
name|splitUndeletedKeys
argument_list|(
name|deleteException
argument_list|,
name|keysToDelete
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Path
argument_list|>
name|deleted
init|=
name|outcome
operator|.
name|getRight
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Path
argument_list|>
name|undeleted
init|=
name|outcome
operator|.
name|getLeft
argument_list|()
decl_stmt|;
comment|// delete the paths but recover
comment|// TODO: handle the case where a parent path is deleted but not a child.
comment|// TODO: in a fake object delete, we don't actually want to delete
comment|//  metastore entries
name|deleted
operator|.
name|forEach
argument_list|(
name|path
lambda|->
block|{
try|try
block|{
name|metadataStore
operator|.
name|delete
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// trouble: we failed to delete the far end entry
comment|// try with the next one.
comment|// if this is a big network failure, this is going to be noisy.
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to update S3Guard store with deletion of {}"
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|failures
operator|.
name|add
argument_list|(
name|Pair
operator|.
name|of
argument_list|(
name|path
argument_list|,
name|e
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|undeleted
operator|.
name|forEach
argument_list|(
name|p
lambda|->
name|LOG
operator|.
name|debug
argument_list|(
literal|"Deleted {}"
argument_list|,
name|p
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|Triple
operator|.
name|of
argument_list|(
name|undeleted
argument_list|,
name|deleted
argument_list|,
name|failures
argument_list|)
return|;
block|}
comment|/**    * Build a list of undeleted paths from a {@code MultiObjectDeleteException}.    * Outside of unit tests, the qualifier function should be    * {@link S3AFileSystem#keyToQualifiedPath(String)}.    * @param deleteException the delete exception.    * @param qualifierFn function to qualify paths    * @return the possibly empty list of paths.    */
annotation|@
name|VisibleForTesting
DECL|method|extractUndeletedPaths ( final MultiObjectDeleteException deleteException, final Function<String, Path> qualifierFn)
specifier|public
specifier|static
name|List
argument_list|<
name|Path
argument_list|>
name|extractUndeletedPaths
parameter_list|(
specifier|final
name|MultiObjectDeleteException
name|deleteException
parameter_list|,
specifier|final
name|Function
argument_list|<
name|String
argument_list|,
name|Path
argument_list|>
name|qualifierFn
parameter_list|)
block|{
return|return
name|deleteException
operator|.
name|getErrors
argument_list|()
operator|.
name|stream
argument_list|()
operator|.
name|map
argument_list|(
parameter_list|(
name|e
parameter_list|)
lambda|->
name|qualifierFn
operator|.
name|apply
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|)
argument_list|)
operator|.
name|collect
argument_list|(
name|Collectors
operator|.
name|toList
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Process a {@code MultiObjectDeleteException} by    * removing all undeleted paths from the list of paths being deleted.    * The original list is updated, and so becomes the list of successfully    * deleted paths.    * @param deleteException the delete exception.    * @param pathsBeingDeleted list of paths which were being deleted.    * This has all undeleted paths removed, leaving only those deleted.    * @return the list of undeleted entries    */
annotation|@
name|VisibleForTesting
DECL|method|removeUndeletedPaths ( final MultiObjectDeleteException deleteException, final Collection<Path> pathsBeingDeleted, final Function<String, Path> qualifier)
specifier|static
name|List
argument_list|<
name|Path
argument_list|>
name|removeUndeletedPaths
parameter_list|(
specifier|final
name|MultiObjectDeleteException
name|deleteException
parameter_list|,
specifier|final
name|Collection
argument_list|<
name|Path
argument_list|>
name|pathsBeingDeleted
parameter_list|,
specifier|final
name|Function
argument_list|<
name|String
argument_list|,
name|Path
argument_list|>
name|qualifier
parameter_list|)
block|{
name|List
argument_list|<
name|Path
argument_list|>
name|undeleted
init|=
name|extractUndeletedPaths
argument_list|(
name|deleteException
argument_list|,
name|qualifier
argument_list|)
decl_stmt|;
name|pathsBeingDeleted
operator|.
name|removeAll
argument_list|(
name|undeleted
argument_list|)
expr_stmt|;
return|return
name|undeleted
return|;
block|}
comment|/**    * A delete operation failed.    * Currently just returns the list of all paths.    * @param ex exception.    * @param keysToDelete the keys which were being deleted.    * @return all paths which were not deleted.    */
DECL|method|processDeleteFailureGenericException (Exception ex, final List<DeleteObjectsRequest.KeyVersion> keysToDelete)
specifier|public
name|List
argument_list|<
name|Path
argument_list|>
name|processDeleteFailureGenericException
parameter_list|(
name|Exception
name|ex
parameter_list|,
specifier|final
name|List
argument_list|<
name|DeleteObjectsRequest
operator|.
name|KeyVersion
argument_list|>
name|keysToDelete
parameter_list|)
block|{
return|return
name|keysToPaths
argument_list|(
name|keysToDelete
argument_list|)
return|;
block|}
block|}
end_class

end_unit

