begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.fs.s3a.commit
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|commit
package|;
end_package

begin_import
import|import
name|javax
operator|.
name|annotation
operator|.
name|Nullable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Closeable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileNotFoundException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|stream
operator|.
name|Collectors
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|stream
operator|.
name|IntStream
import|;
end_import

begin_import
import|import
name|com
operator|.
name|amazonaws
operator|.
name|services
operator|.
name|s3
operator|.
name|model
operator|.
name|MultipartUpload
import|;
end_import

begin_import
import|import
name|com
operator|.
name|amazonaws
operator|.
name|services
operator|.
name|s3
operator|.
name|model
operator|.
name|PartETag
import|;
end_import

begin_import
import|import
name|com
operator|.
name|amazonaws
operator|.
name|services
operator|.
name|s3
operator|.
name|model
operator|.
name|UploadPartRequest
import|;
end_import

begin_import
import|import
name|com
operator|.
name|amazonaws
operator|.
name|services
operator|.
name|s3
operator|.
name|model
operator|.
name|UploadPartResult
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang3
operator|.
name|tuple
operator|.
name|Pair
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|LocatedFileStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|PathFilter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|RemoteIterator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|S3AFileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|S3AInstrumentation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|S3AUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|WriteOperationHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|commit
operator|.
name|files
operator|.
name|PendingSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|commit
operator|.
name|files
operator|.
name|SinglePendingCommit
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|commit
operator|.
name|files
operator|.
name|SuccessData
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|s3guard
operator|.
name|BulkOperationState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|DurationInfo
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|S3AUtils
operator|.
name|*
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|commit
operator|.
name|CommitConstants
operator|.
name|*
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|Constants
operator|.
name|*
import|;
end_import

begin_comment
comment|/**  * The implementation of the various actions a committer needs.  * This doesn't implement the protocol/binding to a specific execution engine,  * just the operations needed to to build one.  *  * When invoking FS operations, it assumes that the underlying FS is  * handling retries and exception translation: it does not attempt to  * duplicate that work.  *  */
end_comment

begin_class
DECL|class|CommitOperations
specifier|public
class|class
name|CommitOperations
block|{
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|CommitOperations
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/**    * Destination filesystem.    */
DECL|field|fs
specifier|private
specifier|final
name|S3AFileSystem
name|fs
decl_stmt|;
comment|/** Statistics. */
DECL|field|statistics
specifier|private
specifier|final
name|S3AInstrumentation
operator|.
name|CommitterStatistics
name|statistics
decl_stmt|;
comment|/**    * Write operations for the destination fs.    */
DECL|field|writeOperations
specifier|private
specifier|final
name|WriteOperationHelper
name|writeOperations
decl_stmt|;
comment|/**    * Filter to find all {code .pendingset} files.    */
DECL|field|PENDINGSET_FILTER
specifier|public
specifier|static
specifier|final
name|PathFilter
name|PENDINGSET_FILTER
init|=
name|path
lambda|->
name|path
operator|.
name|toString
argument_list|()
operator|.
name|endsWith
argument_list|(
name|CommitConstants
operator|.
name|PENDINGSET_SUFFIX
argument_list|)
decl_stmt|;
comment|/**    * Filter to find all {code .pending} files.    */
DECL|field|PENDING_FILTER
specifier|public
specifier|static
specifier|final
name|PathFilter
name|PENDING_FILTER
init|=
name|path
lambda|->
name|path
operator|.
name|toString
argument_list|()
operator|.
name|endsWith
argument_list|(
name|CommitConstants
operator|.
name|PENDING_SUFFIX
argument_list|)
decl_stmt|;
comment|/**    * Instantiate.    * @param fs FS to bind to    */
DECL|method|CommitOperations (S3AFileSystem fs)
specifier|public
name|CommitOperations
parameter_list|(
name|S3AFileSystem
name|fs
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|fs
operator|!=
literal|null
argument_list|,
literal|"null fs"
argument_list|)
expr_stmt|;
name|this
operator|.
name|fs
operator|=
name|fs
expr_stmt|;
name|statistics
operator|=
name|fs
operator|.
name|newCommitterStatistics
argument_list|()
expr_stmt|;
name|writeOperations
operator|=
name|fs
operator|.
name|getWriteOperationHelper
argument_list|()
expr_stmt|;
block|}
comment|/**    * Convert an ordered list of strings to a list of index etag parts.    * @param tagIds list of tags    * @return same list, now in numbered tuples    */
DECL|method|toPartEtags (List<String> tagIds)
specifier|public
specifier|static
name|List
argument_list|<
name|PartETag
argument_list|>
name|toPartEtags
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|tagIds
parameter_list|)
block|{
return|return
name|IntStream
operator|.
name|range
argument_list|(
literal|0
argument_list|,
name|tagIds
operator|.
name|size
argument_list|()
argument_list|)
operator|.
name|mapToObj
argument_list|(
name|i
lambda|->
operator|new
name|PartETag
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|tagIds
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
operator|.
name|collect
argument_list|(
name|Collectors
operator|.
name|toList
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"CommitOperations{"
operator|+
name|fs
operator|.
name|getUri
argument_list|()
operator|+
literal|'}'
return|;
block|}
comment|/** @return statistics. */
DECL|method|getStatistics ()
specifier|protected
name|S3AInstrumentation
operator|.
name|CommitterStatistics
name|getStatistics
parameter_list|()
block|{
return|return
name|statistics
return|;
block|}
comment|/**    * Commit the operation, throwing an exception on any failure.    * @param commit commit to execute    * @param operationState S3Guard state of ongoing operation.    * @throws IOException on a failure    */
DECL|method|commitOrFail ( final SinglePendingCommit commit, final BulkOperationState operationState)
specifier|private
name|void
name|commitOrFail
parameter_list|(
specifier|final
name|SinglePendingCommit
name|commit
parameter_list|,
specifier|final
name|BulkOperationState
name|operationState
parameter_list|)
throws|throws
name|IOException
block|{
name|commit
argument_list|(
name|commit
argument_list|,
name|commit
operator|.
name|getFilename
argument_list|()
argument_list|,
name|operationState
argument_list|)
operator|.
name|maybeRethrow
argument_list|()
expr_stmt|;
block|}
comment|/**    * Commit a single pending commit; exceptions are caught    * and converted to an outcome.    * @param commit entry to commit    * @param origin origin path/string for outcome text    * @param operationState S3Guard state of ongoing operation.    * @return the outcome    */
DECL|method|commit ( final SinglePendingCommit commit, final String origin, final BulkOperationState operationState)
specifier|private
name|MaybeIOE
name|commit
parameter_list|(
specifier|final
name|SinglePendingCommit
name|commit
parameter_list|,
specifier|final
name|String
name|origin
parameter_list|,
specifier|final
name|BulkOperationState
name|operationState
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Committing single commit {}"
argument_list|,
name|commit
argument_list|)
expr_stmt|;
name|MaybeIOE
name|outcome
decl_stmt|;
name|String
name|destKey
init|=
literal|"unknown destination"
decl_stmt|;
try|try
block|{
name|commit
operator|.
name|validate
argument_list|()
expr_stmt|;
name|destKey
operator|=
name|commit
operator|.
name|getDestinationKey
argument_list|()
expr_stmt|;
name|long
name|l
init|=
name|innerCommit
argument_list|(
name|commit
argument_list|,
name|operationState
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Successful commit of file length {}"
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|outcome
operator|=
name|MaybeIOE
operator|.
name|NONE
expr_stmt|;
name|statistics
operator|.
name|commitCompleted
argument_list|(
name|commit
operator|.
name|getLength
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|String
name|msg
init|=
name|String
operator|.
name|format
argument_list|(
literal|"Failed to commit upload against %s: %s"
argument_list|,
name|destKey
argument_list|,
name|e
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
name|msg
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|outcome
operator|=
operator|new
name|MaybeIOE
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|statistics
operator|.
name|commitFailed
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|String
name|msg
init|=
name|String
operator|.
name|format
argument_list|(
literal|"Failed to commit upload against %s,"
operator|+
literal|" described in %s: %s"
argument_list|,
name|destKey
argument_list|,
name|origin
argument_list|,
name|e
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
name|msg
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|outcome
operator|=
operator|new
name|MaybeIOE
argument_list|(
operator|new
name|PathCommitException
argument_list|(
name|origin
argument_list|,
name|msg
argument_list|,
name|e
argument_list|)
argument_list|)
expr_stmt|;
name|statistics
operator|.
name|commitFailed
argument_list|()
expr_stmt|;
block|}
return|return
name|outcome
return|;
block|}
comment|/**    * Inner commit operation.    * @param commit entry to commit    * @param operationState S3Guard state of ongoing operation.    * @return bytes committed.    * @throws IOException failure    */
DECL|method|innerCommit ( final SinglePendingCommit commit, final BulkOperationState operationState)
specifier|private
name|long
name|innerCommit
parameter_list|(
specifier|final
name|SinglePendingCommit
name|commit
parameter_list|,
specifier|final
name|BulkOperationState
name|operationState
parameter_list|)
throws|throws
name|IOException
block|{
comment|// finalize the commit
name|writeOperations
operator|.
name|commitUpload
argument_list|(
name|commit
operator|.
name|getDestinationKey
argument_list|()
argument_list|,
name|commit
operator|.
name|getUploadId
argument_list|()
argument_list|,
name|toPartEtags
argument_list|(
name|commit
operator|.
name|getEtags
argument_list|()
argument_list|)
argument_list|,
name|commit
operator|.
name|getLength
argument_list|()
argument_list|,
name|operationState
argument_list|)
expr_stmt|;
return|return
name|commit
operator|.
name|getLength
argument_list|()
return|;
block|}
comment|/**    * Locate all files with the pending suffix under a directory.    * @param pendingDir directory    * @param recursive recursive listing?    * @return the list of all located entries    * @throws IOException if there is a problem listing the path.    */
DECL|method|locateAllSinglePendingCommits ( Path pendingDir, boolean recursive)
specifier|public
name|List
argument_list|<
name|LocatedFileStatus
argument_list|>
name|locateAllSinglePendingCommits
parameter_list|(
name|Path
name|pendingDir
parameter_list|,
name|boolean
name|recursive
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|listAndFilter
argument_list|(
name|fs
argument_list|,
name|pendingDir
argument_list|,
name|recursive
argument_list|,
name|PENDING_FILTER
argument_list|)
return|;
block|}
comment|/**    * Load all single pending commits in the directory.    * All load failures are logged and then added to list of files which would    * not load.    * @param pendingDir directory containing commits    * @param recursive do a recursive scan?    * @return tuple of loaded entries and those pending files which would    * not load/validate.    * @throws IOException on a failure to list the files.    */
specifier|public
name|Pair
argument_list|<
name|PendingSet
argument_list|,
name|List
argument_list|<
name|Pair
argument_list|<
name|LocatedFileStatus
argument_list|,
name|IOException
argument_list|>
argument_list|>
argument_list|>
DECL|method|loadSinglePendingCommits (Path pendingDir, boolean recursive)
name|loadSinglePendingCommits
parameter_list|(
name|Path
name|pendingDir
parameter_list|,
name|boolean
name|recursive
parameter_list|)
throws|throws
name|IOException
block|{
name|List
argument_list|<
name|LocatedFileStatus
argument_list|>
name|statusList
init|=
name|locateAllSinglePendingCommits
argument_list|(
name|pendingDir
argument_list|,
name|recursive
argument_list|)
decl_stmt|;
name|PendingSet
name|commits
init|=
operator|new
name|PendingSet
argument_list|(
name|statusList
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Pair
argument_list|<
name|LocatedFileStatus
argument_list|,
name|IOException
argument_list|>
argument_list|>
name|failures
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
literal|1
argument_list|)
decl_stmt|;
for|for
control|(
name|LocatedFileStatus
name|status
range|:
name|statusList
control|)
block|{
try|try
block|{
name|commits
operator|.
name|add
argument_list|(
name|SinglePendingCommit
operator|.
name|load
argument_list|(
name|fs
argument_list|,
name|status
operator|.
name|getPath
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to load commit file {}"
argument_list|,
name|status
operator|.
name|getPath
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|failures
operator|.
name|add
argument_list|(
name|Pair
operator|.
name|of
argument_list|(
name|status
argument_list|,
name|e
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|Pair
operator|.
name|of
argument_list|(
name|commits
argument_list|,
name|failures
argument_list|)
return|;
block|}
comment|/**    * Convert any exception to an IOE, if needed.    * @param key key to use in a path exception    * @param ex exception    * @return an IOE, either the passed in value or a new one wrapping the other    * exception.    */
DECL|method|makeIOE (String key, Exception ex)
specifier|public
name|IOException
name|makeIOE
parameter_list|(
name|String
name|key
parameter_list|,
name|Exception
name|ex
parameter_list|)
block|{
return|return
name|ex
operator|instanceof
name|IOException
condition|?
operator|(
name|IOException
operator|)
name|ex
else|:
operator|new
name|PathCommitException
argument_list|(
name|key
argument_list|,
name|ex
operator|.
name|toString
argument_list|()
argument_list|,
name|ex
argument_list|)
return|;
block|}
comment|/**    * Abort the multipart commit supplied. This is the lower level operation    * which doesn't generate an outcome, instead raising an exception.    * @param commit pending commit to abort    * @throws FileNotFoundException if the abort ID is unknown    * @throws IOException on any failure    */
DECL|method|abortSingleCommit (SinglePendingCommit commit)
specifier|private
name|void
name|abortSingleCommit
parameter_list|(
name|SinglePendingCommit
name|commit
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|destKey
init|=
name|commit
operator|.
name|getDestinationKey
argument_list|()
decl_stmt|;
name|String
name|origin
init|=
name|commit
operator|.
name|getFilename
argument_list|()
operator|!=
literal|null
condition|?
operator|(
literal|" defined in "
operator|+
name|commit
operator|.
name|getFilename
argument_list|()
operator|)
else|:
literal|""
decl_stmt|;
name|String
name|uploadId
init|=
name|commit
operator|.
name|getUploadId
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Aborting commit to object {}{}"
argument_list|,
name|destKey
argument_list|,
name|origin
argument_list|)
expr_stmt|;
name|abortMultipartCommit
argument_list|(
name|destKey
argument_list|,
name|uploadId
argument_list|)
expr_stmt|;
block|}
comment|/**    * Create an {@code AbortMultipartUpload} request and POST it to S3,    * incrementing statistics afterwards.    * @param destKey destination key    * @param uploadId upload to cancel    * @throws FileNotFoundException if the abort ID is unknown    * @throws IOException on any failure    */
DECL|method|abortMultipartCommit (String destKey, String uploadId)
specifier|private
name|void
name|abortMultipartCommit
parameter_list|(
name|String
name|destKey
parameter_list|,
name|String
name|uploadId
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
name|writeOperations
operator|.
name|abortMultipartCommit
argument_list|(
name|destKey
argument_list|,
name|uploadId
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|statistics
operator|.
name|commitAborted
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Enumerate all pending files in a dir/tree, abort.    * @param pendingDir directory of pending operations    * @param recursive recurse?    * @return the outcome of all the abort operations    * @throws IOException if there is a problem listing the path.    */
DECL|method|abortAllSinglePendingCommits (Path pendingDir, boolean recursive)
specifier|public
name|MaybeIOE
name|abortAllSinglePendingCommits
parameter_list|(
name|Path
name|pendingDir
parameter_list|,
name|boolean
name|recursive
parameter_list|)
throws|throws
name|IOException
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|pendingDir
operator|!=
literal|null
argument_list|,
literal|"null pendingDir"
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Aborting all pending commit filess under {}"
operator|+
literal|" (recursive={}"
argument_list|,
name|pendingDir
argument_list|,
name|recursive
argument_list|)
expr_stmt|;
name|RemoteIterator
argument_list|<
name|LocatedFileStatus
argument_list|>
name|pendingFiles
decl_stmt|;
try|try
block|{
name|pendingFiles
operator|=
name|ls
argument_list|(
name|pendingDir
argument_list|,
name|recursive
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|fnfe
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"No directory to abort {}"
argument_list|,
name|pendingDir
argument_list|)
expr_stmt|;
return|return
name|MaybeIOE
operator|.
name|NONE
return|;
block|}
name|MaybeIOE
name|outcome
init|=
name|MaybeIOE
operator|.
name|NONE
decl_stmt|;
if|if
condition|(
operator|!
name|pendingFiles
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"No files to abort under {}"
argument_list|,
name|pendingDir
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|pendingFiles
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Path
name|pendingFile
init|=
name|pendingFiles
operator|.
name|next
argument_list|()
operator|.
name|getPath
argument_list|()
decl_stmt|;
if|if
condition|(
name|pendingFile
operator|.
name|getName
argument_list|()
operator|.
name|endsWith
argument_list|(
name|CommitConstants
operator|.
name|PENDING_SUFFIX
argument_list|)
condition|)
block|{
try|try
block|{
name|abortSingleCommit
argument_list|(
name|SinglePendingCommit
operator|.
name|load
argument_list|(
name|fs
argument_list|,
name|pendingFile
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"listed file already deleted: {}"
argument_list|,
name|pendingFile
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
decl||
name|IllegalArgumentException
name|e
parameter_list|)
block|{
if|if
condition|(
name|MaybeIOE
operator|.
name|NONE
operator|.
name|equals
argument_list|(
name|outcome
argument_list|)
condition|)
block|{
name|outcome
operator|=
operator|new
name|MaybeIOE
argument_list|(
name|makeIOE
argument_list|(
name|pendingFile
operator|.
name|toString
argument_list|()
argument_list|,
name|e
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
comment|// quietly try to delete the pending file
name|S3AUtils
operator|.
name|deleteQuietly
argument_list|(
name|fs
argument_list|,
name|pendingFile
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|outcome
return|;
block|}
comment|/**    * List files.    * @param path path    * @param recursive recursive listing?    * @return iterator    * @throws IOException failure    */
DECL|method|ls (Path path, boolean recursive)
specifier|protected
name|RemoteIterator
argument_list|<
name|LocatedFileStatus
argument_list|>
name|ls
parameter_list|(
name|Path
name|path
parameter_list|,
name|boolean
name|recursive
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|fs
operator|.
name|listFiles
argument_list|(
name|path
argument_list|,
name|recursive
argument_list|)
return|;
block|}
comment|/**    * List all pending uploads to the destination FS under a path.    * @param dest destination path    * @return A list of the pending uploads to any directory under that path.    * @throws IOException IO failure    */
DECL|method|listPendingUploadsUnderPath (Path dest)
specifier|public
name|List
argument_list|<
name|MultipartUpload
argument_list|>
name|listPendingUploadsUnderPath
parameter_list|(
name|Path
name|dest
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|fs
operator|.
name|listMultipartUploads
argument_list|(
name|fs
operator|.
name|pathToKey
argument_list|(
name|dest
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Abort all pending uploads to the destination FS under a path.    * @param dest destination path    * @return a count of the number of uploads aborted.    * @throws IOException IO failure    */
DECL|method|abortPendingUploadsUnderPath (Path dest)
specifier|public
name|int
name|abortPendingUploadsUnderPath
parameter_list|(
name|Path
name|dest
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|writeOperations
operator|.
name|abortMultipartUploadsUnderPath
argument_list|(
name|fs
operator|.
name|pathToKey
argument_list|(
name|dest
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Delete any existing {@code _SUCCESS} file.    * @param outputPath output directory    * @throws IOException IO problem    */
DECL|method|deleteSuccessMarker (Path outputPath)
specifier|public
name|void
name|deleteSuccessMarker
parameter_list|(
name|Path
name|outputPath
parameter_list|)
throws|throws
name|IOException
block|{
name|fs
operator|.
name|delete
argument_list|(
operator|new
name|Path
argument_list|(
name|outputPath
argument_list|,
name|_SUCCESS
argument_list|)
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/**    * Save the success data to the {@code _SUCCESS} file.    * @param outputPath output directory    * @param successData success data to save.    * @param addMetrics should the FS metrics be added?    * @throws IOException IO problem    */
DECL|method|createSuccessMarker (Path outputPath, SuccessData successData, boolean addMetrics)
specifier|public
name|void
name|createSuccessMarker
parameter_list|(
name|Path
name|outputPath
parameter_list|,
name|SuccessData
name|successData
parameter_list|,
name|boolean
name|addMetrics
parameter_list|)
throws|throws
name|IOException
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|outputPath
operator|!=
literal|null
argument_list|,
literal|"null outputPath"
argument_list|)
expr_stmt|;
if|if
condition|(
name|addMetrics
condition|)
block|{
name|addFileSystemStatistics
argument_list|(
name|successData
operator|.
name|getMetrics
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// add any diagnostics
name|Configuration
name|conf
init|=
name|fs
operator|.
name|getConf
argument_list|()
decl_stmt|;
name|successData
operator|.
name|addDiagnostic
argument_list|(
name|S3_METADATA_STORE_IMPL
argument_list|,
name|conf
operator|.
name|getTrimmed
argument_list|(
name|S3_METADATA_STORE_IMPL
argument_list|,
literal|""
argument_list|)
argument_list|)
expr_stmt|;
name|successData
operator|.
name|addDiagnostic
argument_list|(
name|METADATASTORE_AUTHORITATIVE
argument_list|,
name|conf
operator|.
name|getTrimmed
argument_list|(
name|METADATASTORE_AUTHORITATIVE
argument_list|,
literal|"false"
argument_list|)
argument_list|)
expr_stmt|;
name|successData
operator|.
name|addDiagnostic
argument_list|(
name|AUTHORITATIVE_PATH
argument_list|,
name|conf
operator|.
name|getTrimmed
argument_list|(
name|AUTHORITATIVE_PATH
argument_list|,
literal|""
argument_list|)
argument_list|)
expr_stmt|;
name|successData
operator|.
name|addDiagnostic
argument_list|(
name|MAGIC_COMMITTER_ENABLED
argument_list|,
name|conf
operator|.
name|getTrimmed
argument_list|(
name|MAGIC_COMMITTER_ENABLED
argument_list|,
literal|"false"
argument_list|)
argument_list|)
expr_stmt|;
comment|// now write
name|Path
name|markerPath
init|=
operator|new
name|Path
argument_list|(
name|outputPath
argument_list|,
name|_SUCCESS
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Touching success marker for job {}: {}"
argument_list|,
name|markerPath
argument_list|,
name|successData
argument_list|)
expr_stmt|;
try|try
init|(
name|DurationInfo
name|ignored
init|=
operator|new
name|DurationInfo
argument_list|(
name|LOG
argument_list|,
literal|"Writing success file %s"
argument_list|,
name|markerPath
argument_list|)
init|)
block|{
name|successData
operator|.
name|save
argument_list|(
name|fs
argument_list|,
name|markerPath
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Revert a pending commit by deleting the destination.    * @param commit pending commit    * @param operationState nullable operational state for a bulk update    * @throws IOException failure    */
DECL|method|revertCommit (SinglePendingCommit commit, BulkOperationState operationState)
specifier|public
name|void
name|revertCommit
parameter_list|(
name|SinglePendingCommit
name|commit
parameter_list|,
name|BulkOperationState
name|operationState
parameter_list|)
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Revert {}"
argument_list|,
name|commit
argument_list|)
expr_stmt|;
try|try
block|{
name|writeOperations
operator|.
name|revertCommit
argument_list|(
name|commit
operator|.
name|getDestinationKey
argument_list|()
argument_list|,
name|operationState
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|statistics
operator|.
name|commitReverted
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Upload all the data in the local file, returning the information    * needed to commit the work.    * @param localFile local file (be  a file)    * @param destPath destination path    * @param partition partition/subdir. Not used    * @param uploadPartSize size of upload    * @return a pending upload entry    * @throws IOException failure    */
DECL|method|uploadFileToPendingCommit (File localFile, Path destPath, String partition, long uploadPartSize)
specifier|public
name|SinglePendingCommit
name|uploadFileToPendingCommit
parameter_list|(
name|File
name|localFile
parameter_list|,
name|Path
name|destPath
parameter_list|,
name|String
name|partition
parameter_list|,
name|long
name|uploadPartSize
parameter_list|)
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Initiating multipart upload from {} to {}"
argument_list|,
name|localFile
argument_list|,
name|destPath
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|destPath
operator|!=
literal|null
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|localFile
operator|.
name|isFile
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|FileNotFoundException
argument_list|(
literal|"Not a file: "
operator|+
name|localFile
argument_list|)
throw|;
block|}
name|String
name|destURI
init|=
name|destPath
operator|.
name|toString
argument_list|()
decl_stmt|;
name|String
name|destKey
init|=
name|fs
operator|.
name|pathToKey
argument_list|(
name|destPath
argument_list|)
decl_stmt|;
name|String
name|uploadId
init|=
literal|null
decl_stmt|;
name|boolean
name|threw
init|=
literal|true
decl_stmt|;
try|try
block|{
name|statistics
operator|.
name|commitCreated
argument_list|()
expr_stmt|;
name|uploadId
operator|=
name|writeOperations
operator|.
name|initiateMultiPartUpload
argument_list|(
name|destKey
argument_list|)
expr_stmt|;
name|long
name|length
init|=
name|localFile
operator|.
name|length
argument_list|()
decl_stmt|;
name|SinglePendingCommit
name|commitData
init|=
operator|new
name|SinglePendingCommit
argument_list|()
decl_stmt|;
name|commitData
operator|.
name|setDestinationKey
argument_list|(
name|destKey
argument_list|)
expr_stmt|;
name|commitData
operator|.
name|setBucket
argument_list|(
name|fs
operator|.
name|getBucket
argument_list|()
argument_list|)
expr_stmt|;
name|commitData
operator|.
name|touch
argument_list|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
argument_list|)
expr_stmt|;
name|commitData
operator|.
name|setUploadId
argument_list|(
name|uploadId
argument_list|)
expr_stmt|;
name|commitData
operator|.
name|setUri
argument_list|(
name|destURI
argument_list|)
expr_stmt|;
name|commitData
operator|.
name|setText
argument_list|(
name|partition
operator|!=
literal|null
condition|?
literal|"partition: "
operator|+
name|partition
else|:
literal|""
argument_list|)
expr_stmt|;
name|commitData
operator|.
name|setLength
argument_list|(
name|length
argument_list|)
expr_stmt|;
name|long
name|offset
init|=
literal|0
decl_stmt|;
name|long
name|numParts
init|=
operator|(
name|length
operator|/
name|uploadPartSize
operator|+
operator|(
operator|(
name|length
operator|%
name|uploadPartSize
operator|)
operator|>
literal|0
condition|?
literal|1
else|:
literal|0
operator|)
operator|)
decl_stmt|;
comment|// always write one part, even if it is just an empty one
if|if
condition|(
name|numParts
operator|==
literal|0
condition|)
block|{
name|numParts
operator|=
literal|1
expr_stmt|;
block|}
name|List
argument_list|<
name|PartETag
argument_list|>
name|parts
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
operator|(
name|int
operator|)
name|numParts
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"File size is {}, number of parts to upload = {}"
argument_list|,
name|length
argument_list|,
name|numParts
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|partNumber
init|=
literal|1
init|;
name|partNumber
operator|<=
name|numParts
condition|;
name|partNumber
operator|+=
literal|1
control|)
block|{
name|long
name|size
init|=
name|Math
operator|.
name|min
argument_list|(
name|length
operator|-
name|offset
argument_list|,
name|uploadPartSize
argument_list|)
decl_stmt|;
name|UploadPartRequest
name|part
decl_stmt|;
name|part
operator|=
name|writeOperations
operator|.
name|newUploadPartRequest
argument_list|(
name|destKey
argument_list|,
name|uploadId
argument_list|,
name|partNumber
argument_list|,
operator|(
name|int
operator|)
name|size
argument_list|,
literal|null
argument_list|,
name|localFile
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|part
operator|.
name|setLastPart
argument_list|(
name|partNumber
operator|==
name|numParts
argument_list|)
expr_stmt|;
name|UploadPartResult
name|partResult
init|=
name|writeOperations
operator|.
name|uploadPart
argument_list|(
name|part
argument_list|)
decl_stmt|;
name|offset
operator|+=
name|uploadPartSize
expr_stmt|;
name|parts
operator|.
name|add
argument_list|(
name|partResult
operator|.
name|getPartETag
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|commitData
operator|.
name|bindCommitData
argument_list|(
name|parts
argument_list|)
expr_stmt|;
name|statistics
operator|.
name|commitUploaded
argument_list|(
name|length
argument_list|)
expr_stmt|;
name|threw
operator|=
literal|false
expr_stmt|;
return|return
name|commitData
return|;
block|}
finally|finally
block|{
if|if
condition|(
name|threw
operator|&&
name|uploadId
operator|!=
literal|null
condition|)
block|{
name|statistics
operator|.
name|commitAborted
argument_list|()
expr_stmt|;
try|try
block|{
name|abortMultipartCommit
argument_list|(
name|destKey
argument_list|,
name|uploadId
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Failed to abort upload {} to {}"
argument_list|,
name|uploadId
argument_list|,
name|destKey
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**    * Add the filesystem statistics to the map; overwriting anything    * with the same name.    * @param dest destination map    */
DECL|method|addFileSystemStatistics (Map<String, Long> dest)
specifier|public
name|void
name|addFileSystemStatistics
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|Long
argument_list|>
name|dest
parameter_list|)
block|{
name|dest
operator|.
name|putAll
argument_list|(
name|fs
operator|.
name|getInstrumentation
argument_list|()
operator|.
name|toMap
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Note that a task has completed.    * @param success success flag    */
DECL|method|taskCompleted (boolean success)
specifier|public
name|void
name|taskCompleted
parameter_list|(
name|boolean
name|success
parameter_list|)
block|{
name|statistics
operator|.
name|taskCompleted
argument_list|(
name|success
argument_list|)
expr_stmt|;
block|}
comment|/**    * Note that a job has completed.    * @param success success flag    */
DECL|method|jobCompleted (boolean success)
specifier|public
name|void
name|jobCompleted
parameter_list|(
name|boolean
name|success
parameter_list|)
block|{
name|statistics
operator|.
name|jobCompleted
argument_list|(
name|success
argument_list|)
expr_stmt|;
block|}
comment|/**    * Begin the final commit.    * @param path path for all work.    * @return the commit context to pass in.    * @throws IOException failure.    */
DECL|method|initiateCommitOperation (Path path)
specifier|public
name|CommitContext
name|initiateCommitOperation
parameter_list|(
name|Path
name|path
parameter_list|)
throws|throws
name|IOException
block|{
return|return
operator|new
name|CommitContext
argument_list|(
name|writeOperations
operator|.
name|initiateCommitOperation
argument_list|(
name|path
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Commit context.    *    * It is used to manage the final commit sequence where files become    * visible. It contains a {@link BulkOperationState} field, which, if    * there is a metastore, will be requested from the store so that it    * can track multiple creation operations within the same overall operation.    * This will be null if there is no metastore, or the store chooses not    * to provide one.    *    * This can only be created through {@link #initiateCommitOperation(Path)}.    *    * Once the commit operation has completed, it must be closed.    * It must not be reused.    */
DECL|class|CommitContext
specifier|public
specifier|final
class|class
name|CommitContext
implements|implements
name|Closeable
block|{
comment|/**      * State of any metastore.      */
DECL|field|operationState
specifier|private
specifier|final
name|BulkOperationState
name|operationState
decl_stmt|;
comment|/**      * Create.      * @param operationState any S3Guard bulk state.      */
DECL|method|CommitContext (@ullable final BulkOperationState operationState)
specifier|private
name|CommitContext
parameter_list|(
annotation|@
name|Nullable
specifier|final
name|BulkOperationState
name|operationState
parameter_list|)
block|{
name|this
operator|.
name|operationState
operator|=
name|operationState
expr_stmt|;
block|}
comment|/**      * Commit the operation, throwing an exception on any failure.      * See {@link CommitOperations#commitOrFail(SinglePendingCommit, BulkOperationState)}.      * @param commit commit to execute      * @throws IOException on a failure      */
DECL|method|commitOrFail (SinglePendingCommit commit)
specifier|public
name|void
name|commitOrFail
parameter_list|(
name|SinglePendingCommit
name|commit
parameter_list|)
throws|throws
name|IOException
block|{
name|CommitOperations
operator|.
name|this
operator|.
name|commitOrFail
argument_list|(
name|commit
argument_list|,
name|operationState
argument_list|)
expr_stmt|;
block|}
comment|/**      * Commit a single pending commit; exceptions are caught      * and converted to an outcome.      * See {@link CommitOperations#commit(SinglePendingCommit, String, BulkOperationState)}.      * @param commit entry to commit      * @param origin origin path/string for outcome text      * @return the outcome      */
DECL|method|commit (SinglePendingCommit commit, String origin)
specifier|public
name|MaybeIOE
name|commit
parameter_list|(
name|SinglePendingCommit
name|commit
parameter_list|,
name|String
name|origin
parameter_list|)
block|{
return|return
name|CommitOperations
operator|.
name|this
operator|.
name|commit
argument_list|(
name|commit
argument_list|,
name|origin
argument_list|,
name|operationState
argument_list|)
return|;
block|}
comment|/**      * See {@link CommitOperations#abortSingleCommit(SinglePendingCommit)}.      * @param commit pending commit to abort      * @throws FileNotFoundException if the abort ID is unknown      * @throws IOException on any failure      */
DECL|method|abortSingleCommit (final SinglePendingCommit commit)
specifier|public
name|void
name|abortSingleCommit
parameter_list|(
specifier|final
name|SinglePendingCommit
name|commit
parameter_list|)
throws|throws
name|IOException
block|{
name|CommitOperations
operator|.
name|this
operator|.
name|abortSingleCommit
argument_list|(
name|commit
argument_list|)
expr_stmt|;
block|}
comment|/**      * See {@link CommitOperations#revertCommit(SinglePendingCommit, BulkOperationState)}.      * @param commit pending commit      * @throws IOException failure      */
DECL|method|revertCommit (final SinglePendingCommit commit)
specifier|public
name|void
name|revertCommit
parameter_list|(
specifier|final
name|SinglePendingCommit
name|commit
parameter_list|)
throws|throws
name|IOException
block|{
name|CommitOperations
operator|.
name|this
operator|.
name|revertCommit
argument_list|(
name|commit
argument_list|,
name|operationState
argument_list|)
expr_stmt|;
block|}
comment|/**      * See {@link CommitOperations#abortMultipartCommit(String, String)}..      * @param destKey destination key      * @param uploadId upload to cancel      * @throws FileNotFoundException if the abort ID is unknown      * @throws IOException on any failure      */
DECL|method|abortMultipartCommit ( final String destKey, final String uploadId)
specifier|public
name|void
name|abortMultipartCommit
parameter_list|(
specifier|final
name|String
name|destKey
parameter_list|,
specifier|final
name|String
name|uploadId
parameter_list|)
throws|throws
name|IOException
block|{
name|CommitOperations
operator|.
name|this
operator|.
name|abortMultipartCommit
argument_list|(
name|destKey
argument_list|,
name|uploadId
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|close ()
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
name|IOUtils
operator|.
name|cleanupWithLogger
argument_list|(
name|LOG
argument_list|,
name|operationState
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
specifier|final
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|(
literal|"CommitContext{"
argument_list|)
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"operationState="
argument_list|)
operator|.
name|append
argument_list|(
name|operationState
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|'}'
argument_list|)
expr_stmt|;
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
comment|/**    * A holder for a possible IOException; the call {@link #maybeRethrow()}    * will throw any exception passed into the constructor, and be a no-op    * if none was.    *    * Why isn't a Java 8 optional used here? The main benefit would be that    * {@link #maybeRethrow()} could be done as a map(), but because Java doesn't    * allow checked exceptions in a map, the following code is invalid    *<pre>    *   exception.map((e) -&gt; {throw e;}    *</pre>    * As a result, the code to work with exceptions would be almost as convoluted    * as the original.    */
DECL|class|MaybeIOE
specifier|public
specifier|static
class|class
name|MaybeIOE
block|{
DECL|field|exception
specifier|private
specifier|final
name|IOException
name|exception
decl_stmt|;
DECL|field|NONE
specifier|public
specifier|static
specifier|final
name|MaybeIOE
name|NONE
init|=
operator|new
name|MaybeIOE
argument_list|(
literal|null
argument_list|)
decl_stmt|;
comment|/**      * Construct with an exception.      * @param exception exception      */
DECL|method|MaybeIOE (IOException exception)
specifier|public
name|MaybeIOE
parameter_list|(
name|IOException
name|exception
parameter_list|)
block|{
name|this
operator|.
name|exception
operator|=
name|exception
expr_stmt|;
block|}
comment|/**      * Get any exception.      * @return the exception.      */
DECL|method|getException ()
specifier|public
name|IOException
name|getException
parameter_list|()
block|{
return|return
name|exception
return|;
block|}
comment|/**      * Is there an exception in this class?      * @return true if there is an exception      */
DECL|method|hasException ()
specifier|public
name|boolean
name|hasException
parameter_list|()
block|{
return|return
name|exception
operator|!=
literal|null
return|;
block|}
comment|/**      * Rethrow any exception.      * @throws IOException the exception field, if non-null.      */
DECL|method|maybeRethrow ()
specifier|public
name|void
name|maybeRethrow
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|exception
operator|!=
literal|null
condition|)
block|{
throw|throw
name|exception
throw|;
block|}
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
specifier|final
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|(
literal|"MaybeIOE{"
argument_list|)
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|hasException
argument_list|()
condition|?
name|exception
else|:
literal|""
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|'}'
argument_list|)
expr_stmt|;
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * Get an instance based on the exception: either a value      * or a reference to {@link #NONE}.      * @param ex exception      * @return an instance.      */
DECL|method|of (IOException ex)
specifier|public
specifier|static
name|MaybeIOE
name|of
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
return|return
name|ex
operator|!=
literal|null
condition|?
operator|new
name|MaybeIOE
argument_list|(
name|ex
argument_list|)
else|:
name|NONE
return|;
block|}
block|}
block|}
end_class

end_unit

