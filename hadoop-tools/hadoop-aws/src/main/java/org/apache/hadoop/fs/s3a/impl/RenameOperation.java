begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.fs.s3a.impl
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|impl
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|CompletableFuture
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicLong
import|;
end_import

begin_import
import|import
name|com
operator|.
name|amazonaws
operator|.
name|AmazonClientException
import|;
end_import

begin_import
import|import
name|com
operator|.
name|amazonaws
operator|.
name|services
operator|.
name|s3
operator|.
name|model
operator|.
name|DeleteObjectsRequest
import|;
end_import

begin_import
import|import
name|com
operator|.
name|amazonaws
operator|.
name|services
operator|.
name|s3
operator|.
name|transfer
operator|.
name|model
operator|.
name|CopyResult
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|RemoteIterator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|RenameFailedException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|Retries
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|S3AFileStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|S3ALocatedFileStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|S3AReadOpContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|S3ObjectAttributes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|Tristate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|s3guard
operator|.
name|MetadataStore
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|s3guard
operator|.
name|RenameTracker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|DurationInfo
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkNotNull
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|Constants
operator|.
name|FS_S3A_BLOCK_SIZE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|S3AUtils
operator|.
name|objectRepresentsDirectory
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|impl
operator|.
name|CallableSupplier
operator|.
name|submit
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|impl
operator|.
name|CallableSupplier
operator|.
name|waitForCompletion
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|impl
operator|.
name|InternalConstants
operator|.
name|DEFAULT_BLOCKSIZE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|impl
operator|.
name|InternalConstants
operator|.
name|MAX_ENTRIES_TO_DELETE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|impl
operator|.
name|InternalConstants
operator|.
name|RENAME_PARALLEL_LIMIT
import|;
end_import

begin_comment
comment|/**  * A parallelized rename operation which updates the metastore in the  * process, through whichever {@link RenameTracker} the store provides.  * The parallel execution is in groups of size  * {@link InternalConstants#RENAME_PARALLEL_LIMIT}; it is only  * after one group completes that the next group is initiated.  * Once enough files have been copied that they meet the  * {@link InternalConstants#MAX_ENTRIES_TO_DELETE} threshold, a delete  * is initiated.  * If it succeeds, the rename continues with the next group of files.  *  * The RenameTracker has the task of keeping the metastore up to date  * as the rename proceeds.  *  * The rename operation implements the classic HDFS rename policy of  * rename(file, dir) renames the file under the directory.  *  * There is<i>no</i> validation of input and output paths.  * Callers are required to themselves verify that destination is not under  * the source, above the source, the source itself, etc, etc.  */
end_comment

begin_class
DECL|class|RenameOperation
specifier|public
class|class
name|RenameOperation
extends|extends
name|ExecutingStoreOperation
argument_list|<
name|Long
argument_list|>
block|{
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|RenameOperation
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|sourcePath
specifier|private
specifier|final
name|Path
name|sourcePath
decl_stmt|;
DECL|field|sourceKey
specifier|private
specifier|final
name|String
name|sourceKey
decl_stmt|;
DECL|field|sourceStatus
specifier|private
specifier|final
name|S3AFileStatus
name|sourceStatus
decl_stmt|;
DECL|field|destPath
specifier|private
specifier|final
name|Path
name|destPath
decl_stmt|;
DECL|field|destKey
specifier|private
specifier|final
name|String
name|destKey
decl_stmt|;
DECL|field|destStatus
specifier|private
specifier|final
name|S3AFileStatus
name|destStatus
decl_stmt|;
comment|/**    * Callbacks into the filesystem.    */
DECL|field|callbacks
specifier|private
specifier|final
name|OperationCallbacks
name|callbacks
decl_stmt|;
comment|/**    * Counter of bytes copied.    */
DECL|field|bytesCopied
specifier|private
specifier|final
name|AtomicLong
name|bytesCopied
init|=
operator|new
name|AtomicLong
argument_list|()
decl_stmt|;
comment|/**    * Rename tracker.    */
DECL|field|renameTracker
specifier|private
name|RenameTracker
name|renameTracker
decl_stmt|;
comment|/**    * List of active copies.    */
DECL|field|activeCopies
specifier|private
specifier|final
name|List
argument_list|<
name|CompletableFuture
argument_list|<
name|Path
argument_list|>
argument_list|>
name|activeCopies
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|RENAME_PARALLEL_LIMIT
argument_list|)
decl_stmt|;
comment|/**    * list of keys to delete on the next (bulk) delete call.    */
DECL|field|keysToDelete
specifier|private
specifier|final
name|List
argument_list|<
name|DeleteObjectsRequest
operator|.
name|KeyVersion
argument_list|>
name|keysToDelete
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
comment|/**    * List of paths to delete, which will be passed to the rename    * tracker after the deletion succeeds.    */
DECL|field|pathsToDelete
specifier|private
specifier|final
name|List
argument_list|<
name|Path
argument_list|>
name|pathsToDelete
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|blocksize
specifier|private
specifier|final
name|long
name|blocksize
decl_stmt|;
comment|/**    * Initiate the rename.    *    * @param storeContext store context    * @param sourcePath source path    * @param sourceKey key of source    * @param sourceStatus pre-fetched source status    * @param destPath destination path.    * @param destKey destination key    * @param destStatus destination status.    * @param callbacks callback provider    */
DECL|method|RenameOperation ( final StoreContext storeContext, final Path sourcePath, final String sourceKey, final S3AFileStatus sourceStatus, final Path destPath, final String destKey, final S3AFileStatus destStatus, final OperationCallbacks callbacks)
specifier|public
name|RenameOperation
parameter_list|(
specifier|final
name|StoreContext
name|storeContext
parameter_list|,
specifier|final
name|Path
name|sourcePath
parameter_list|,
specifier|final
name|String
name|sourceKey
parameter_list|,
specifier|final
name|S3AFileStatus
name|sourceStatus
parameter_list|,
specifier|final
name|Path
name|destPath
parameter_list|,
specifier|final
name|String
name|destKey
parameter_list|,
specifier|final
name|S3AFileStatus
name|destStatus
parameter_list|,
specifier|final
name|OperationCallbacks
name|callbacks
parameter_list|)
block|{
name|super
argument_list|(
name|storeContext
argument_list|)
expr_stmt|;
name|this
operator|.
name|sourcePath
operator|=
name|sourcePath
expr_stmt|;
name|this
operator|.
name|sourceKey
operator|=
name|sourceKey
expr_stmt|;
name|this
operator|.
name|sourceStatus
operator|=
name|sourceStatus
expr_stmt|;
name|this
operator|.
name|destPath
operator|=
name|destPath
expr_stmt|;
name|this
operator|.
name|destKey
operator|=
name|destKey
expr_stmt|;
name|this
operator|.
name|destStatus
operator|=
name|destStatus
expr_stmt|;
name|this
operator|.
name|callbacks
operator|=
name|callbacks
expr_stmt|;
name|blocksize
operator|=
name|storeContext
operator|.
name|getConfiguration
argument_list|()
operator|.
name|getLongBytes
argument_list|(
name|FS_S3A_BLOCK_SIZE
argument_list|,
name|DEFAULT_BLOCKSIZE
argument_list|)
expr_stmt|;
block|}
comment|/**    * Wait for the active copies to complete then reset the list.    * @param reason for messages    * @throws IOException if one of the called futures raised an IOE.    * @throws RuntimeException if one of the futures raised one.    */
annotation|@
name|Retries
operator|.
name|OnceTranslated
DECL|method|completeActiveCopies (String reason)
specifier|private
name|void
name|completeActiveCopies
parameter_list|(
name|String
name|reason
parameter_list|)
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Waiting for {} active copies to complete: {}"
argument_list|,
name|activeCopies
operator|.
name|size
argument_list|()
argument_list|,
name|reason
argument_list|)
expr_stmt|;
name|waitForCompletion
argument_list|(
name|activeCopies
argument_list|)
expr_stmt|;
name|activeCopies
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
comment|/**    * Queue an object for deletion.    * @param path path to the object    * @param key key of the object.    */
DECL|method|queueToDelete (Path path, String key)
specifier|private
name|void
name|queueToDelete
parameter_list|(
name|Path
name|path
parameter_list|,
name|String
name|key
parameter_list|)
block|{
name|pathsToDelete
operator|.
name|add
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|keysToDelete
operator|.
name|add
argument_list|(
operator|new
name|DeleteObjectsRequest
operator|.
name|KeyVersion
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Block waiting for ay active copies to finish    * then delete all queued keys + paths to delete.    * @param reason reason for logs    * @throws IOException failure.    */
annotation|@
name|Retries
operator|.
name|RetryTranslated
DECL|method|completeActiveCopiesAndDeleteSources (String reason)
specifier|private
name|void
name|completeActiveCopiesAndDeleteSources
parameter_list|(
name|String
name|reason
parameter_list|)
throws|throws
name|IOException
block|{
name|completeActiveCopies
argument_list|(
name|reason
argument_list|)
expr_stmt|;
name|removeSourceObjects
argument_list|(
name|keysToDelete
argument_list|,
name|pathsToDelete
argument_list|)
expr_stmt|;
comment|// now reset the lists.
name|keysToDelete
operator|.
name|clear
argument_list|()
expr_stmt|;
name|pathsToDelete
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Retries
operator|.
name|RetryMixed
DECL|method|execute ()
specifier|public
name|Long
name|execute
parameter_list|()
throws|throws
name|IOException
block|{
name|executeOnlyOnce
argument_list|()
expr_stmt|;
specifier|final
name|StoreContext
name|storeContext
init|=
name|getStoreContext
argument_list|()
decl_stmt|;
specifier|final
name|MetadataStore
name|metadataStore
init|=
name|checkNotNull
argument_list|(
name|storeContext
operator|.
name|getMetadataStore
argument_list|()
argument_list|,
literal|"No metadata store in context"
argument_list|)
decl_stmt|;
comment|// Validation completed: time to begin the operation.
comment|// The store-specific rename tracker is used to keep the store
comment|// to date with the in-progress operation.
comment|// for the null store, these are all no-ops.
name|renameTracker
operator|=
name|metadataStore
operator|.
name|initiateRenameOperation
argument_list|(
name|storeContext
argument_list|,
name|sourcePath
argument_list|,
name|sourceStatus
argument_list|,
name|destPath
argument_list|)
expr_stmt|;
comment|// Ok! Time to start
try|try
block|{
if|if
condition|(
name|sourceStatus
operator|.
name|isFile
argument_list|()
condition|)
block|{
name|renameFileToDest
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|recursiveDirectoryRename
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|AmazonClientException
decl||
name|IOException
name|ex
parameter_list|)
block|{
comment|// rename failed.
comment|// block for all ongoing copies to complete, successfully or not
try|try
block|{
name|completeActiveCopies
argument_list|(
literal|"failure handling"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// a failure to update the metastore after a rename failure is what
comment|// we'd see on a network problem, expired credentials and other
comment|// unrecoverable errors.
comment|// Downgrading to warn because an exception is already
comment|// about to be thrown.
name|LOG
operator|.
name|warn
argument_list|(
literal|"While completing all active copies"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
comment|// notify the rename tracker of the failure
throw|throw
name|renameTracker
operator|.
name|renameFailed
argument_list|(
name|ex
argument_list|)
throw|;
block|}
comment|// At this point the rename has completed successfully in the S3 store.
comment|// Tell the metastore this fact and let it complete its changes
name|renameTracker
operator|.
name|completeRename
argument_list|()
expr_stmt|;
name|callbacks
operator|.
name|finishRename
argument_list|(
name|sourcePath
argument_list|,
name|destPath
argument_list|)
expr_stmt|;
return|return
name|bytesCopied
operator|.
name|get
argument_list|()
return|;
block|}
comment|/**    * The source is a file: rename it to the destination.    * @throws IOException failure    */
DECL|method|renameFileToDest ()
specifier|protected
name|void
name|renameFileToDest
parameter_list|()
throws|throws
name|IOException
block|{
specifier|final
name|StoreContext
name|storeContext
init|=
name|getStoreContext
argument_list|()
decl_stmt|;
comment|// the source is a file.
name|Path
name|copyDestinationPath
init|=
name|destPath
decl_stmt|;
name|String
name|copyDestinationKey
init|=
name|destKey
decl_stmt|;
name|S3ObjectAttributes
name|sourceAttributes
init|=
name|callbacks
operator|.
name|createObjectAttributes
argument_list|(
name|sourceStatus
argument_list|)
decl_stmt|;
name|S3AReadOpContext
name|readContext
init|=
name|callbacks
operator|.
name|createReadContext
argument_list|(
name|sourceStatus
argument_list|)
decl_stmt|;
if|if
condition|(
name|destStatus
operator|!=
literal|null
operator|&&
name|destStatus
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
comment|// destination is a directory: build the final destination underneath
name|String
name|newDestKey
init|=
name|maybeAddTrailingSlash
argument_list|(
name|destKey
argument_list|)
decl_stmt|;
name|String
name|filename
init|=
name|sourceKey
operator|.
name|substring
argument_list|(
name|storeContext
operator|.
name|pathToKey
argument_list|(
name|sourcePath
operator|.
name|getParent
argument_list|()
argument_list|)
operator|.
name|length
argument_list|()
operator|+
literal|1
argument_list|)
decl_stmt|;
name|newDestKey
operator|=
name|newDestKey
operator|+
name|filename
expr_stmt|;
name|copyDestinationKey
operator|=
name|newDestKey
expr_stmt|;
name|copyDestinationPath
operator|=
name|storeContext
operator|.
name|keyToPath
argument_list|(
name|newDestKey
argument_list|)
expr_stmt|;
block|}
comment|// destination either does not exist or is a file to overwrite.
name|LOG
operator|.
name|debug
argument_list|(
literal|"rename: renaming file {} to {}"
argument_list|,
name|sourcePath
argument_list|,
name|copyDestinationPath
argument_list|)
expr_stmt|;
name|copySourceAndUpdateTracker
argument_list|(
name|sourcePath
argument_list|,
name|sourceKey
argument_list|,
name|sourceAttributes
argument_list|,
name|readContext
argument_list|,
name|copyDestinationPath
argument_list|,
name|copyDestinationKey
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|bytesCopied
operator|.
name|addAndGet
argument_list|(
name|sourceStatus
operator|.
name|getLen
argument_list|()
argument_list|)
expr_stmt|;
comment|// delete the source
name|callbacks
operator|.
name|deleteObjectAtPath
argument_list|(
name|sourcePath
argument_list|,
name|sourceKey
argument_list|,
literal|true
argument_list|,
literal|null
argument_list|)
expr_stmt|;
comment|// and update the tracker
name|renameTracker
operator|.
name|sourceObjectsDeleted
argument_list|(
name|Lists
operator|.
name|newArrayList
argument_list|(
name|sourcePath
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Execute a full recursive rename.    * The source is a file: rename it to the destination.    * @throws IOException failure    */
DECL|method|recursiveDirectoryRename ()
specifier|protected
name|void
name|recursiveDirectoryRename
parameter_list|()
throws|throws
name|IOException
block|{
specifier|final
name|StoreContext
name|storeContext
init|=
name|getStoreContext
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"rename: renaming directory {} to {}"
argument_list|,
name|sourcePath
argument_list|,
name|destPath
argument_list|)
expr_stmt|;
comment|// This is a directory-to-directory copy
name|String
name|dstKey
init|=
name|maybeAddTrailingSlash
argument_list|(
name|destKey
argument_list|)
decl_stmt|;
name|String
name|srcKey
init|=
name|maybeAddTrailingSlash
argument_list|(
name|sourceKey
argument_list|)
decl_stmt|;
comment|// Verify dest is not a child of the source directory
if|if
condition|(
name|dstKey
operator|.
name|startsWith
argument_list|(
name|srcKey
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|RenameFailedException
argument_list|(
name|srcKey
argument_list|,
name|dstKey
argument_list|,
literal|"cannot rename a directory to a subdirectory of itself "
argument_list|)
throw|;
block|}
if|if
condition|(
name|destStatus
operator|!=
literal|null
operator|&&
name|destStatus
operator|.
name|isEmptyDirectory
argument_list|()
operator|==
name|Tristate
operator|.
name|TRUE
condition|)
block|{
comment|// delete unnecessary fake directory at the destination.
comment|// this MUST be done before anything else so that
comment|// rollback code doesn't get confused and insert a tombstone
comment|// marker.
name|LOG
operator|.
name|debug
argument_list|(
literal|"Deleting fake directory marker at destination {}"
argument_list|,
name|destStatus
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
name|callbacks
operator|.
name|deleteObjectAtPath
argument_list|(
name|destStatus
operator|.
name|getPath
argument_list|()
argument_list|,
name|dstKey
argument_list|,
literal|false
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
name|Path
name|parentPath
init|=
name|storeContext
operator|.
name|keyToPath
argument_list|(
name|srcKey
argument_list|)
decl_stmt|;
specifier|final
name|RemoteIterator
argument_list|<
name|S3ALocatedFileStatus
argument_list|>
name|iterator
init|=
name|callbacks
operator|.
name|listFilesAndEmptyDirectories
argument_list|(
name|parentPath
argument_list|,
name|sourceStatus
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|)
decl_stmt|;
while|while
condition|(
name|iterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
comment|// get the next entry in the listing.
name|S3ALocatedFileStatus
name|child
init|=
name|iterator
operator|.
name|next
argument_list|()
decl_stmt|;
comment|// convert it to an S3 key.
name|String
name|k
init|=
name|storeContext
operator|.
name|pathToKey
argument_list|(
name|child
operator|.
name|getPath
argument_list|()
argument_list|)
decl_stmt|;
comment|// possibly adding a "/" if it represents directory and it does
comment|// not have a trailing slash already.
name|String
name|key
init|=
operator|(
name|child
operator|.
name|isDirectory
argument_list|()
operator|&&
operator|!
name|k
operator|.
name|endsWith
argument_list|(
literal|"/"
argument_list|)
operator|)
condition|?
name|k
operator|+
literal|"/"
else|:
name|k
decl_stmt|;
comment|// the source object to copy as a path.
name|Path
name|childSourcePath
init|=
name|storeContext
operator|.
name|keyToPath
argument_list|(
name|key
argument_list|)
decl_stmt|;
comment|// mark for deletion on a successful copy.
name|queueToDelete
argument_list|(
name|childSourcePath
argument_list|,
name|key
argument_list|)
expr_stmt|;
comment|// the destination key is that of the key under the source tree,
comment|// remapped under the new destination path.
name|String
name|newDestKey
init|=
name|dstKey
operator|+
name|key
operator|.
name|substring
argument_list|(
name|srcKey
operator|.
name|length
argument_list|()
argument_list|)
decl_stmt|;
name|Path
name|childDestPath
init|=
name|storeContext
operator|.
name|keyToPath
argument_list|(
name|newDestKey
argument_list|)
decl_stmt|;
comment|// now begin the single copy
name|CompletableFuture
argument_list|<
name|Path
argument_list|>
name|copy
init|=
name|initiateCopy
argument_list|(
name|child
argument_list|,
name|key
argument_list|,
name|childSourcePath
argument_list|,
name|newDestKey
argument_list|,
name|childDestPath
argument_list|)
decl_stmt|;
name|activeCopies
operator|.
name|add
argument_list|(
name|copy
argument_list|)
expr_stmt|;
name|bytesCopied
operator|.
name|addAndGet
argument_list|(
name|sourceStatus
operator|.
name|getLen
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|activeCopies
operator|.
name|size
argument_list|()
operator|==
name|RENAME_PARALLEL_LIMIT
condition|)
block|{
comment|// the limit of active copies has been reached;
comment|// wait for completion or errors to surface.
name|LOG
operator|.
name|debug
argument_list|(
literal|"Waiting for active copies to complete"
argument_list|)
expr_stmt|;
name|completeActiveCopies
argument_list|(
literal|"batch threshold reached"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|keysToDelete
operator|.
name|size
argument_list|()
operator|==
name|MAX_ENTRIES_TO_DELETE
condition|)
block|{
comment|// finish ongoing copies then delete all queued keys.
comment|// provided the parallel limit is a factor of the max entry
comment|// constant, this will not need to block for the copy, and
comment|// simply jump straight to the delete.
name|completeActiveCopiesAndDeleteSources
argument_list|(
literal|"paged delete"
argument_list|)
expr_stmt|;
block|}
block|}
comment|// end of iteration through the list
comment|// await the final set of copies and their deletion
comment|// This will notify the renameTracker that these objects
comment|// have been deleted.
name|completeActiveCopiesAndDeleteSources
argument_list|(
literal|"final copy and delete"
argument_list|)
expr_stmt|;
comment|// We moved all the children, now move the top-level dir
comment|// Empty directory should have been added as the object summary
name|renameTracker
operator|.
name|moveSourceDirectory
argument_list|()
expr_stmt|;
block|}
comment|/**    * Initiate a copy operation in the executor.    * @param source status of the source object.    * @param key source key    * @param childSourcePath source as a path.    * @param newDestKey destination key    * @param childDestPath destination path.    * @return the future.    */
DECL|method|initiateCopy ( final S3ALocatedFileStatus source, final String key, final Path childSourcePath, final String newDestKey, final Path childDestPath)
specifier|protected
name|CompletableFuture
argument_list|<
name|Path
argument_list|>
name|initiateCopy
parameter_list|(
specifier|final
name|S3ALocatedFileStatus
name|source
parameter_list|,
specifier|final
name|String
name|key
parameter_list|,
specifier|final
name|Path
name|childSourcePath
parameter_list|,
specifier|final
name|String
name|newDestKey
parameter_list|,
specifier|final
name|Path
name|childDestPath
parameter_list|)
block|{
name|S3ObjectAttributes
name|sourceAttributes
init|=
name|callbacks
operator|.
name|createObjectAttributes
argument_list|(
name|source
operator|.
name|getPath
argument_list|()
argument_list|,
name|source
operator|.
name|getETag
argument_list|()
argument_list|,
name|source
operator|.
name|getVersionId
argument_list|()
argument_list|,
name|source
operator|.
name|getLen
argument_list|()
argument_list|)
decl_stmt|;
comment|// queue the copy operation for execution in the thread pool
return|return
name|submit
argument_list|(
name|getStoreContext
argument_list|()
operator|.
name|getExecutor
argument_list|()
argument_list|,
parameter_list|()
lambda|->
name|copySourceAndUpdateTracker
argument_list|(
name|childSourcePath
argument_list|,
name|key
argument_list|,
name|sourceAttributes
argument_list|,
name|callbacks
operator|.
name|createReadContext
argument_list|(
name|source
argument_list|)
argument_list|,
name|childDestPath
argument_list|,
name|newDestKey
argument_list|,
literal|true
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * This invoked to copy a file or directory marker then update the    * rename operation on success.    * It may be called in its own thread.    * @param sourceFile source path of the copy; may have a trailing / on it.    * @param srcKey source key    * @param srcAttributes status of the source object    * @param destination destination as a qualified path.    * @param destinationKey destination key    * @param addAncestors should ancestors be added to the metastore?    * @return the destination path.    * @throws IOException failure    */
annotation|@
name|Retries
operator|.
name|RetryTranslated
DECL|method|copySourceAndUpdateTracker ( final Path sourceFile, final String srcKey, final S3ObjectAttributes srcAttributes, final S3AReadOpContext readContext, final Path destination, final String destinationKey, final boolean addAncestors)
specifier|private
name|Path
name|copySourceAndUpdateTracker
parameter_list|(
specifier|final
name|Path
name|sourceFile
parameter_list|,
specifier|final
name|String
name|srcKey
parameter_list|,
specifier|final
name|S3ObjectAttributes
name|srcAttributes
parameter_list|,
specifier|final
name|S3AReadOpContext
name|readContext
parameter_list|,
specifier|final
name|Path
name|destination
parameter_list|,
specifier|final
name|String
name|destinationKey
parameter_list|,
specifier|final
name|boolean
name|addAncestors
parameter_list|)
throws|throws
name|IOException
block|{
name|long
name|len
init|=
name|srcAttributes
operator|.
name|getLen
argument_list|()
decl_stmt|;
name|CopyResult
name|copyResult
decl_stmt|;
try|try
init|(
name|DurationInfo
name|ignored
init|=
operator|new
name|DurationInfo
argument_list|(
name|LOG
argument_list|,
literal|false
argument_list|,
literal|"Copy file from %s to %s (length=%d)"
argument_list|,
name|srcKey
argument_list|,
name|destinationKey
argument_list|,
name|len
argument_list|)
init|)
block|{
name|copyResult
operator|=
name|callbacks
operator|.
name|copyFile
argument_list|(
name|srcKey
argument_list|,
name|destinationKey
argument_list|,
name|srcAttributes
argument_list|,
name|readContext
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|objectRepresentsDirectory
argument_list|(
name|srcKey
argument_list|,
name|len
argument_list|)
condition|)
block|{
name|renameTracker
operator|.
name|directoryMarkerCopied
argument_list|(
name|sourceFile
argument_list|,
name|destination
argument_list|,
name|addAncestors
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|S3ObjectAttributes
name|destAttributes
init|=
operator|new
name|S3ObjectAttributes
argument_list|(
name|destination
argument_list|,
name|copyResult
argument_list|,
name|srcAttributes
operator|.
name|getServerSideEncryptionAlgorithm
argument_list|()
argument_list|,
name|srcAttributes
operator|.
name|getServerSideEncryptionKey
argument_list|()
argument_list|,
name|len
argument_list|)
decl_stmt|;
name|renameTracker
operator|.
name|fileCopied
argument_list|(
name|sourceFile
argument_list|,
name|srcAttributes
argument_list|,
name|destAttributes
argument_list|,
name|destination
argument_list|,
name|blocksize
argument_list|,
name|addAncestors
argument_list|)
expr_stmt|;
block|}
return|return
name|destination
return|;
block|}
comment|/**    * Remove source objects and update the metastore by way of    * the rename tracker.    * @param keys list of keys to delete    * @param paths list of paths matching the keys to delete 1:1.    * @throws IOException failure    */
annotation|@
name|Retries
operator|.
name|RetryTranslated
DECL|method|removeSourceObjects ( final List<DeleteObjectsRequest.KeyVersion> keys, final List<Path> paths)
specifier|private
name|void
name|removeSourceObjects
parameter_list|(
specifier|final
name|List
argument_list|<
name|DeleteObjectsRequest
operator|.
name|KeyVersion
argument_list|>
name|keys
parameter_list|,
specifier|final
name|List
argument_list|<
name|Path
argument_list|>
name|paths
parameter_list|)
throws|throws
name|IOException
block|{
name|List
argument_list|<
name|Path
argument_list|>
name|undeletedObjects
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
try|try
block|{
comment|// remove the keys
comment|// this will update the metastore on a failure, but on
comment|// a successful operation leaves the store as is.
name|callbacks
operator|.
name|removeKeys
argument_list|(
name|keys
argument_list|,
literal|false
argument_list|,
name|undeletedObjects
argument_list|,
name|renameTracker
operator|.
name|getOperationState
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|// and clear the list.
block|}
catch|catch
parameter_list|(
name|AmazonClientException
decl||
name|IOException
name|e
parameter_list|)
block|{
comment|// Failed.
comment|// Notify the rename operation.
comment|// removeKeys will have already purged the metastore of
comment|// all keys it has known to delete; this is just a final
comment|// bit of housekeeping and a chance to tune exception
comment|// reporting.
comment|// The returned IOE is rethrown.
throw|throw
name|renameTracker
operator|.
name|deleteFailed
argument_list|(
name|e
argument_list|,
name|paths
argument_list|,
name|undeletedObjects
argument_list|)
throw|;
block|}
name|renameTracker
operator|.
name|sourceObjectsDeleted
argument_list|(
name|paths
argument_list|)
expr_stmt|;
block|}
comment|/**    * Turns a path (relative or otherwise) into an S3 key, adding a trailing    * "/" if the path is not the root<i>and</i> does not already have a "/"    * at the end.    *    * @param key s3 key or ""    * @return the with a trailing "/", or, if it is the root key, "",    */
DECL|method|maybeAddTrailingSlash (String key)
specifier|private
name|String
name|maybeAddTrailingSlash
parameter_list|(
name|String
name|key
parameter_list|)
block|{
if|if
condition|(
operator|!
name|key
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|key
operator|.
name|endsWith
argument_list|(
literal|"/"
argument_list|)
condition|)
block|{
return|return
name|key
operator|+
literal|'/'
return|;
block|}
else|else
block|{
return|return
name|key
return|;
block|}
block|}
block|}
end_class

end_unit

