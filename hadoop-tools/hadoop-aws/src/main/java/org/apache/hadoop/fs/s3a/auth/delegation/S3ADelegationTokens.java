begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.fs.s3a.auth.delegation
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|auth
operator|.
name|delegation
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URI
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|EnumSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Objects
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Optional
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang3
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|AWSCredentialProviderList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|S3AFileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|S3AInstrumentation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|auth
operator|.
name|RoleModel
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|Text
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|Credentials
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|UserGroupInformation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|token
operator|.
name|Token
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|service
operator|.
name|ServiceOperations
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|DurationInfo
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkArgument
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkState
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|auth
operator|.
name|delegation
operator|.
name|DelegationConstants
operator|.
name|DEFAULT_DELEGATION_TOKEN_BINDING
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|auth
operator|.
name|delegation
operator|.
name|DelegationConstants
operator|.
name|DELEGATION_TOKEN_BINDING
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|auth
operator|.
name|delegation
operator|.
name|DelegationConstants
operator|.
name|DURATION_LOG_AT_INFO
import|;
end_import

begin_comment
comment|/**  * Support for creating a DT from a filesystem.  *  * Isolated from S3A for control and testability.  *  * The S3A Delegation Tokens are special in that the tokens are not directly  * used to authenticate with the AWS services.  * Instead they can session/role  credentials requested off AWS on demand.  *  * The design is extensible in that different back-end bindings can be used  * to switch to different session creation mechanisms, or indeed, to any  * other authentication mechanism supported by an S3 service, provided it  * ultimately accepts some form of AWS credentials for authentication through  * the AWS SDK. That is, if someone wants to wire this up to Kerberos, or  * OAuth2, this design should support them.  *  * URIs processed must be the canonical URIs for the service.  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
DECL|class|S3ADelegationTokens
specifier|public
class|class
name|S3ADelegationTokens
extends|extends
name|AbstractDTService
block|{
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|S3ADelegationTokens
operator|.
name|class
argument_list|)
decl_stmt|;
annotation|@
name|VisibleForTesting
DECL|field|E_ALREADY_DEPLOYED
specifier|static
specifier|final
name|String
name|E_ALREADY_DEPLOYED
init|=
literal|"S3A Delegation tokens has already been bound/deployed"
decl_stmt|;
DECL|field|E_DELEGATION_TOKENS_DISABLED
specifier|public
specifier|static
specifier|final
name|String
name|E_DELEGATION_TOKENS_DISABLED
init|=
literal|"Delegation tokens are not enabled"
decl_stmt|;
comment|/**    * User who owns this FS; fixed at instantiation time, so that    * in calls to getDelegationToken() and similar, this user is the one whose    * credentials are involved.    */
DECL|field|user
specifier|private
specifier|final
name|UserGroupInformation
name|user
decl_stmt|;
comment|/**    * Count of number of created tokens.    * For testing and diagnostics.    */
DECL|field|creationCount
specifier|private
specifier|final
name|AtomicInteger
name|creationCount
init|=
operator|new
name|AtomicInteger
argument_list|(
literal|0
argument_list|)
decl_stmt|;
comment|/**    * Text value of this token service.    */
DECL|field|service
specifier|private
name|Text
name|service
decl_stmt|;
comment|/**    * Active Delegation token.    */
DECL|field|boundDT
specifier|private
name|Optional
argument_list|<
name|Token
argument_list|<
name|AbstractS3ATokenIdentifier
argument_list|>
argument_list|>
name|boundDT
init|=
name|Optional
operator|.
name|empty
argument_list|()
decl_stmt|;
comment|/**    * The DT decoded when this instance is created by bonding    * to an existing DT.    */
DECL|field|decodedIdentifier
specifier|private
name|Optional
argument_list|<
name|AbstractS3ATokenIdentifier
argument_list|>
name|decodedIdentifier
init|=
name|Optional
operator|.
name|empty
argument_list|()
decl_stmt|;
comment|/**    * Dynamically loaded token binding; lifecycle matches this object.    */
DECL|field|tokenBinding
specifier|private
name|AbstractDelegationTokenBinding
name|tokenBinding
decl_stmt|;
comment|/**    * List of cred providers; unset until {@link #bindToDelegationToken(Token)}.    */
DECL|field|credentialProviders
specifier|private
name|Optional
argument_list|<
name|AWSCredentialProviderList
argument_list|>
name|credentialProviders
init|=
name|Optional
operator|.
name|empty
argument_list|()
decl_stmt|;
comment|/**    * The access policies we want for operations.    * There's no attempt to ask for "admin" permissions here, e.g.    * those to manipulate S3Guard tables.    */
DECL|field|ACCESS_POLICY
specifier|protected
specifier|static
specifier|final
name|EnumSet
argument_list|<
name|AWSPolicyProvider
operator|.
name|AccessLevel
argument_list|>
name|ACCESS_POLICY
init|=
name|EnumSet
operator|.
name|of
argument_list|(
name|AWSPolicyProvider
operator|.
name|AccessLevel
operator|.
name|READ
argument_list|,
name|AWSPolicyProvider
operator|.
name|AccessLevel
operator|.
name|WRITE
argument_list|)
decl_stmt|;
comment|/**    * Statistics for the owner FS.    */
DECL|field|stats
specifier|private
name|S3AInstrumentation
operator|.
name|DelegationTokenStatistics
name|stats
decl_stmt|;
comment|/**    * Name of the token binding as extracted from token kind; used for    * logging.    */
DECL|field|tokenBindingName
specifier|private
name|String
name|tokenBindingName
init|=
literal|""
decl_stmt|;
comment|/**    * Instantiate.    * @throws IOException if login fails.    */
DECL|method|S3ADelegationTokens ()
specifier|public
name|S3ADelegationTokens
parameter_list|()
throws|throws
name|IOException
block|{
name|super
argument_list|(
literal|"S3ADelegationTokens"
argument_list|)
expr_stmt|;
name|user
operator|=
name|UserGroupInformation
operator|.
name|getCurrentUser
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|bindToFileSystem (final URI uri, final S3AFileSystem fs)
specifier|public
name|void
name|bindToFileSystem
parameter_list|(
specifier|final
name|URI
name|uri
parameter_list|,
specifier|final
name|S3AFileSystem
name|fs
parameter_list|)
throws|throws
name|IOException
block|{
name|super
operator|.
name|bindToFileSystem
argument_list|(
name|uri
argument_list|,
name|fs
argument_list|)
expr_stmt|;
name|service
operator|=
name|getTokenService
argument_list|(
name|getCanonicalUri
argument_list|()
argument_list|)
expr_stmt|;
name|stats
operator|=
name|fs
operator|.
name|getInstrumentation
argument_list|()
operator|.
name|newDelegationTokenStatistics
argument_list|()
expr_stmt|;
block|}
comment|/**    * Init the service.    * This identifies the token binding class to use and creates, initializes    * and starts it.    * Will raise an exception if delegation tokens are not enabled.    * @param conf configuration    * @throws Exception any failure to start up    */
annotation|@
name|Override
DECL|method|serviceInit (final Configuration conf)
specifier|protected
name|void
name|serviceInit
parameter_list|(
specifier|final
name|Configuration
name|conf
parameter_list|)
throws|throws
name|Exception
block|{
name|super
operator|.
name|serviceInit
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|checkState
argument_list|(
name|hasDelegationTokenBinding
argument_list|(
name|conf
argument_list|)
argument_list|,
name|E_DELEGATION_TOKENS_DISABLED
argument_list|)
expr_stmt|;
name|Class
argument_list|<
name|?
extends|extends
name|AbstractDelegationTokenBinding
argument_list|>
name|binding
init|=
name|conf
operator|.
name|getClass
argument_list|(
name|DelegationConstants
operator|.
name|DELEGATION_TOKEN_BINDING
argument_list|,
name|SessionTokenBinding
operator|.
name|class
argument_list|,
name|AbstractDelegationTokenBinding
operator|.
name|class
argument_list|)
decl_stmt|;
name|tokenBinding
operator|=
name|binding
operator|.
name|newInstance
argument_list|()
expr_stmt|;
name|tokenBinding
operator|.
name|bindToFileSystem
argument_list|(
name|getCanonicalUri
argument_list|()
argument_list|,
name|getFileSystem
argument_list|()
argument_list|)
expr_stmt|;
name|tokenBinding
operator|.
name|init
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|tokenBindingName
operator|=
name|tokenBinding
operator|.
name|getKind
argument_list|()
operator|.
name|toString
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Filesystem {} is using delegation tokens of kind {}"
argument_list|,
name|getCanonicalUri
argument_list|()
argument_list|,
name|tokenBindingName
argument_list|)
expr_stmt|;
block|}
comment|/**    * Service startup includes binding to any delegation token, and    * deploying unbounded if there is none.    * It is after this that token operations can be used.    * @throws Exception any failure    */
annotation|@
name|Override
DECL|method|serviceStart ()
specifier|protected
name|void
name|serviceStart
parameter_list|()
throws|throws
name|Exception
block|{
name|super
operator|.
name|serviceStart
argument_list|()
expr_stmt|;
name|tokenBinding
operator|.
name|start
argument_list|()
expr_stmt|;
name|bindToAnyDelegationToken
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"S3A Delegation support token {} with {}"
argument_list|,
name|identifierToString
argument_list|()
argument_list|,
name|tokenBinding
operator|.
name|getDescription
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Get the identifier as a string, or "(none)".    * @return a string value for logs etc.    */
DECL|method|identifierToString ()
specifier|private
name|String
name|identifierToString
parameter_list|()
block|{
return|return
name|decodedIdentifier
operator|.
name|map
argument_list|(
name|Objects
operator|::
name|toString
argument_list|)
operator|.
name|orElse
argument_list|(
literal|"(none)"
argument_list|)
return|;
block|}
comment|/**    * Stop the token binding.    * @throws Exception on any failure    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"ThrowableNotThrown"
argument_list|)
annotation|@
name|Override
DECL|method|serviceStop ()
specifier|protected
name|void
name|serviceStop
parameter_list|()
throws|throws
name|Exception
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Stopping delegation tokens"
argument_list|)
expr_stmt|;
try|try
block|{
name|super
operator|.
name|serviceStop
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|ServiceOperations
operator|.
name|stopQuietly
argument_list|(
name|LOG
argument_list|,
name|tokenBinding
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Perform the unbonded deployment operations.    * Create the AWS credential provider chain to use    * when talking to AWS when there is no delegation token to work with.    * authenticating this client with AWS services, and saves it    * to {@link #credentialProviders}    *    * @throws IOException any failure.    */
DECL|method|deployUnbonded ()
specifier|private
name|void
name|deployUnbonded
parameter_list|()
throws|throws
name|IOException
block|{
name|requireServiceStarted
argument_list|()
expr_stmt|;
name|checkState
argument_list|(
operator|!
name|isBoundToDT
argument_list|()
argument_list|,
literal|"Already Bound to a delegation token"
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"No delegation tokens present: using direct authentication"
argument_list|)
expr_stmt|;
name|credentialProviders
operator|=
name|Optional
operator|.
name|of
argument_list|(
name|tokenBinding
operator|.
name|deployUnbonded
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Attempt to bind to any existing DT, including unmarshalling its contents    * and creating the AWS credential provider used to authenticate    * the client.    *    * If successful:    *<ol>    *<li>{@link #boundDT} is set to the retrieved token.</li>    *<li>{@link #decodedIdentifier} is set to the extracted identifier.</li>    *<li>{@link #credentialProviders} is set to the credential    *   provider(s) returned by the token binding.</li>    *</ol>    * If unsuccessful, {@link #deployUnbonded()} is called for the    * unbonded codepath instead, which will set    * {@link #credentialProviders} to its value.    *    * This means after this call (and only after) the token operations    * can be invoked.    *    * This method is called from {@link #serviceStart()}, so a check on    * the service state can be used to check things; the state model    * prevents re-entrant calls.    * @throws IOException selection/extraction/validation failure.    */
DECL|method|bindToAnyDelegationToken ()
specifier|private
name|void
name|bindToAnyDelegationToken
parameter_list|()
throws|throws
name|IOException
block|{
name|checkState
argument_list|(
operator|!
name|credentialProviders
operator|.
name|isPresent
argument_list|()
argument_list|,
name|E_ALREADY_DEPLOYED
argument_list|)
expr_stmt|;
name|Token
argument_list|<
name|AbstractS3ATokenIdentifier
argument_list|>
name|token
init|=
name|selectTokenFromFSOwner
argument_list|()
decl_stmt|;
if|if
condition|(
name|token
operator|!=
literal|null
condition|)
block|{
name|bindToDelegationToken
argument_list|(
name|token
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|deployUnbonded
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|credentialProviders
operator|.
name|get
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|DelegationTokenIOException
argument_list|(
literal|"No AWS credential providers"
operator|+
literal|" created by Delegation Token Binding "
operator|+
name|tokenBinding
operator|.
name|getName
argument_list|()
argument_list|)
throw|;
block|}
block|}
comment|/**    * This is a test-only back door which resets the state and binds to    * a token again.    * This allows an instance of this class to be bonded to a DT after being    * started, so avoids the need to have the token in the current user    * credentials. It is package scoped so as to only be usable in tests    * in the same package.    *    * Yes, this is ugly, but there is no obvious/easy way to test token    * binding without Kerberos getting involved.    * @param token token to decode and bind to.    * @throws IOException selection/extraction/validation failure.    */
annotation|@
name|VisibleForTesting
DECL|method|resetTokenBindingToDT (final Token<AbstractS3ATokenIdentifier> token)
name|void
name|resetTokenBindingToDT
parameter_list|(
specifier|final
name|Token
argument_list|<
name|AbstractS3ATokenIdentifier
argument_list|>
name|token
parameter_list|)
throws|throws
name|IOException
block|{
name|credentialProviders
operator|=
name|Optional
operator|.
name|empty
argument_list|()
expr_stmt|;
name|bindToDelegationToken
argument_list|(
name|token
argument_list|)
expr_stmt|;
block|}
comment|/**    * Bind to a delegation token retrieved for this filesystem.    * Extract the secrets from the token and set internal fields    * to the values.    *<ol>    *<li>{@link #boundDT} is set to {@code token}.</li>    *<li>{@link #decodedIdentifier} is set to the extracted identifier.</li>    *<li>{@link #credentialProviders} is set to the credential    *   provider(s) returned by the token binding.</li>    *</ol>    * @param token token to decode and bind to.    * @throws IOException selection/extraction/validation failure.    */
annotation|@
name|VisibleForTesting
DECL|method|bindToDelegationToken ( final Token<AbstractS3ATokenIdentifier> token)
specifier|public
name|void
name|bindToDelegationToken
parameter_list|(
specifier|final
name|Token
argument_list|<
name|AbstractS3ATokenIdentifier
argument_list|>
name|token
parameter_list|)
throws|throws
name|IOException
block|{
name|checkState
argument_list|(
operator|!
name|credentialProviders
operator|.
name|isPresent
argument_list|()
argument_list|,
name|E_ALREADY_DEPLOYED
argument_list|)
expr_stmt|;
name|boundDT
operator|=
name|Optional
operator|.
name|of
argument_list|(
name|token
argument_list|)
expr_stmt|;
name|AbstractS3ATokenIdentifier
name|dti
init|=
name|extractIdentifier
argument_list|(
name|token
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Using delegation token {}"
argument_list|,
name|dti
argument_list|)
expr_stmt|;
name|decodedIdentifier
operator|=
name|Optional
operator|.
name|of
argument_list|(
name|dti
argument_list|)
expr_stmt|;
try|try
init|(
name|DurationInfo
name|ignored
init|=
operator|new
name|DurationInfo
argument_list|(
name|LOG
argument_list|,
name|DURATION_LOG_AT_INFO
argument_list|,
literal|"Creating Delegation Token"
argument_list|)
init|)
block|{
comment|// extract the credential providers.
name|credentialProviders
operator|=
name|Optional
operator|.
name|of
argument_list|(
name|tokenBinding
operator|.
name|bindToTokenIdentifier
argument_list|(
name|dti
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Predicate: is there a bound DT?    * @return true if there's a value in {@link #boundDT}.    */
DECL|method|isBoundToDT ()
specifier|public
name|boolean
name|isBoundToDT
parameter_list|()
block|{
return|return
name|boundDT
operator|.
name|isPresent
argument_list|()
return|;
block|}
comment|/**    * Get any bound DT.    * @return a delegation token if this instance was bound to it.    */
DECL|method|getBoundDT ()
specifier|public
name|Optional
argument_list|<
name|Token
argument_list|<
name|AbstractS3ATokenIdentifier
argument_list|>
argument_list|>
name|getBoundDT
parameter_list|()
block|{
return|return
name|boundDT
return|;
block|}
comment|/**    * Predicate: will this binding issue a DT if requested    * in a call to {@link #getBoundOrNewDT(EncryptionSecrets)}?    * That is: should the filesystem declare that it is issuing    * delegation tokens?    * @return a declaration of what will happen when asked for a token.    */
DECL|method|getTokenIssuingPolicy ()
specifier|public
name|TokenIssuingPolicy
name|getTokenIssuingPolicy
parameter_list|()
block|{
return|return
name|isBoundToDT
argument_list|()
condition|?
name|TokenIssuingPolicy
operator|.
name|ReturnExistingToken
else|:
name|tokenBinding
operator|.
name|getTokenIssuingPolicy
argument_list|()
return|;
block|}
comment|/**    * Get any bound DT or create a new one.    * @return a delegation token.    * @throws IOException if one cannot be created    * @param encryptionSecrets encryption secrets for any new token.    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"OptionalGetWithoutIsPresent"
argument_list|)
DECL|method|getBoundOrNewDT ( final EncryptionSecrets encryptionSecrets)
specifier|public
name|Token
argument_list|<
name|AbstractS3ATokenIdentifier
argument_list|>
name|getBoundOrNewDT
parameter_list|(
specifier|final
name|EncryptionSecrets
name|encryptionSecrets
parameter_list|)
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Delegation token requested"
argument_list|)
expr_stmt|;
if|if
condition|(
name|isBoundToDT
argument_list|()
condition|)
block|{
comment|// the FS was created on startup with a token, so return it.
name|LOG
operator|.
name|debug
argument_list|(
literal|"Returning current token"
argument_list|)
expr_stmt|;
return|return
name|getBoundDT
argument_list|()
operator|.
name|get
argument_list|()
return|;
block|}
else|else
block|{
comment|// not bound to a token, so create a new one.
comment|// issued DTs are not cached so that long-lived filesystems can
comment|// reliably issue session/role tokens.
return|return
name|createDelegationToken
argument_list|(
name|encryptionSecrets
argument_list|)
return|;
block|}
block|}
comment|/**    * How many delegation tokens have been issued?    * @return the number times {@link #createDelegationToken(EncryptionSecrets)}    * returned a token.    */
DECL|method|getCreationCount ()
specifier|public
name|int
name|getCreationCount
parameter_list|()
block|{
return|return
name|creationCount
operator|.
name|get
argument_list|()
return|;
block|}
comment|/**    * Create a delegation token for the user.    * This will only be called if a new DT is needed, that is: the    * filesystem has been deployed unbonded.    * @param encryptionSecrets encryption secrets for the token.    * @return the token    * @throws IOException if one cannot be created    */
annotation|@
name|VisibleForTesting
DECL|method|createDelegationToken ( final EncryptionSecrets encryptionSecrets)
specifier|public
name|Token
argument_list|<
name|AbstractS3ATokenIdentifier
argument_list|>
name|createDelegationToken
parameter_list|(
specifier|final
name|EncryptionSecrets
name|encryptionSecrets
parameter_list|)
throws|throws
name|IOException
block|{
name|requireServiceStarted
argument_list|()
expr_stmt|;
name|checkArgument
argument_list|(
name|encryptionSecrets
operator|!=
literal|null
argument_list|,
literal|"Null encryption secrets"
argument_list|)
expr_stmt|;
comment|// this isn't done in in advance as it needs S3Guard initialized in the
comment|// filesystem before it can generate complete policies.
name|List
argument_list|<
name|RoleModel
operator|.
name|Statement
argument_list|>
name|statements
init|=
name|getFileSystem
argument_list|()
operator|.
name|listAWSPolicyRules
argument_list|(
name|ACCESS_POLICY
argument_list|)
decl_stmt|;
name|Optional
argument_list|<
name|RoleModel
operator|.
name|Policy
argument_list|>
name|rolePolicy
init|=
name|statements
operator|.
name|isEmpty
argument_list|()
condition|?
name|Optional
operator|.
name|empty
argument_list|()
else|:
name|Optional
operator|.
name|of
argument_list|(
operator|new
name|RoleModel
operator|.
name|Policy
argument_list|(
name|statements
argument_list|)
argument_list|)
decl_stmt|;
try|try
init|(
name|DurationInfo
name|ignored
init|=
operator|new
name|DurationInfo
argument_list|(
name|LOG
argument_list|,
name|DURATION_LOG_AT_INFO
argument_list|,
literal|"Creating New Delegation Token"
argument_list|,
name|tokenBinding
operator|.
name|getKind
argument_list|()
argument_list|)
init|)
block|{
name|Token
argument_list|<
name|AbstractS3ATokenIdentifier
argument_list|>
name|token
init|=
name|tokenBinding
operator|.
name|createDelegationToken
argument_list|(
name|rolePolicy
argument_list|,
name|encryptionSecrets
argument_list|)
decl_stmt|;
if|if
condition|(
name|token
operator|!=
literal|null
condition|)
block|{
name|token
operator|.
name|setService
argument_list|(
name|service
argument_list|)
expr_stmt|;
name|noteTokenCreated
argument_list|(
name|token
argument_list|)
expr_stmt|;
block|}
return|return
name|token
return|;
block|}
block|}
comment|/**    * Note that a token has been created; increment counters and statistics.    * @param token token created    */
DECL|method|noteTokenCreated (final Token<AbstractS3ATokenIdentifier> token)
specifier|private
name|void
name|noteTokenCreated
parameter_list|(
specifier|final
name|Token
argument_list|<
name|AbstractS3ATokenIdentifier
argument_list|>
name|token
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Created S3A Delegation Token: {}"
argument_list|,
name|token
argument_list|)
expr_stmt|;
name|creationCount
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
name|stats
operator|.
name|tokenIssued
argument_list|()
expr_stmt|;
block|}
comment|/**    * Get the AWS credential provider.    * @return the DT credential provider    * @throws IOException failure to parse the DT    * @throws IllegalStateException if this instance is not bound to a DT    */
DECL|method|getCredentialProviders ()
specifier|public
name|AWSCredentialProviderList
name|getCredentialProviders
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|credentialProviders
operator|.
name|orElseThrow
argument_list|(
parameter_list|()
lambda|->
operator|new
name|DelegationTokenIOException
argument_list|(
literal|"Not yet bonded"
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Get the encryption secrets of the DT.    * non-empty iff service is started and was bound to a DT.    * @return any encryption settings propagated with the DT.    */
DECL|method|getEncryptionSecrets ()
specifier|public
name|Optional
argument_list|<
name|EncryptionSecrets
argument_list|>
name|getEncryptionSecrets
parameter_list|()
block|{
return|return
name|decodedIdentifier
operator|.
name|map
argument_list|(
name|AbstractS3ATokenIdentifier
operator|::
name|getEncryptionSecrets
argument_list|)
return|;
block|}
comment|/**    * Get any decoded identifier from the bound DT; empty if not bound.    * @return the decoded identifier.    */
DECL|method|getDecodedIdentifier ()
specifier|public
name|Optional
argument_list|<
name|AbstractS3ATokenIdentifier
argument_list|>
name|getDecodedIdentifier
parameter_list|()
block|{
return|return
name|decodedIdentifier
return|;
block|}
comment|/**    * Get the service identifier of the owning FS.    * @return a service identifier to use when registering tokens    */
DECL|method|getService ()
specifier|public
name|Text
name|getService
parameter_list|()
block|{
return|return
name|service
return|;
block|}
comment|/**    * The canonical name of the service.    * This can be used as the canonical service name for the FS.    * @return the canonicalized FS URI.    */
DECL|method|getCanonicalServiceName ()
specifier|public
name|String
name|getCanonicalServiceName
parameter_list|()
block|{
return|return
name|getCanonicalUri
argument_list|()
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * Find a token for the FS user and canonical filesystem URI.    * @return the token, or null if one cannot be found.    * @throws IOException on a failure to unmarshall the token.    */
annotation|@
name|VisibleForTesting
DECL|method|selectTokenFromFSOwner ()
specifier|public
name|Token
argument_list|<
name|AbstractS3ATokenIdentifier
argument_list|>
name|selectTokenFromFSOwner
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|lookupToken
argument_list|(
name|user
operator|.
name|getCredentials
argument_list|()
argument_list|,
name|service
argument_list|,
name|tokenBinding
operator|.
name|getKind
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Get the service identifier of a filesystem.    * This must be unique for (S3A, the FS URI)    * @param fsURI filesystem URI    * @return identifier to use.    */
DECL|method|getTokenService (final URI fsURI)
specifier|private
specifier|static
name|Text
name|getTokenService
parameter_list|(
specifier|final
name|URI
name|fsURI
parameter_list|)
block|{
return|return
name|getTokenService
argument_list|(
name|fsURI
operator|.
name|toString
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
specifier|final
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|(
literal|"S3ADelegationTokens{"
argument_list|)
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"canonicalServiceURI="
argument_list|)
operator|.
name|append
argument_list|(
name|getCanonicalUri
argument_list|()
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"; owner="
argument_list|)
operator|.
name|append
argument_list|(
name|user
operator|.
name|getShortUserName
argument_list|()
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"; isBoundToDT="
argument_list|)
operator|.
name|append
argument_list|(
name|isBoundToDT
argument_list|()
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"; token creation count="
argument_list|)
operator|.
name|append
argument_list|(
name|getCreationCount
argument_list|()
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"; tokenManager="
argument_list|)
operator|.
name|append
argument_list|(
name|tokenBinding
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"; token="
argument_list|)
operator|.
name|append
argument_list|(
name|identifierToString
argument_list|()
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|'}'
argument_list|)
expr_stmt|;
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * Get the kind of the issued tokens.    * @return token kind.    */
DECL|method|getTokenKind ()
specifier|public
name|Text
name|getTokenKind
parameter_list|()
block|{
return|return
name|tokenBinding
operator|.
name|getKind
argument_list|()
return|;
block|}
comment|/**    * Get the service identifier of a filesystem URI.    * This must be unique for (S3a, the FS URI)    * @param fsURI filesystem URI as a string    * @return identifier to use.    */
annotation|@
name|VisibleForTesting
DECL|method|getTokenService (final String fsURI)
specifier|static
name|Text
name|getTokenService
parameter_list|(
specifier|final
name|String
name|fsURI
parameter_list|)
block|{
return|return
operator|new
name|Text
argument_list|(
name|fsURI
argument_list|)
return|;
block|}
comment|/**    * From a token, get the session token identifier.    * @param token token to process    * @return the session token identifier    * @throws IOException failure to validate/read data encoded in identifier.    * @throws IllegalArgumentException if the token isn't an S3A session token    */
DECL|method|extractIdentifier ( final Token<? extends AbstractS3ATokenIdentifier> token)
specifier|public
name|AbstractS3ATokenIdentifier
name|extractIdentifier
parameter_list|(
specifier|final
name|Token
argument_list|<
name|?
extends|extends
name|AbstractS3ATokenIdentifier
argument_list|>
name|token
parameter_list|)
throws|throws
name|IOException
block|{
name|checkArgument
argument_list|(
name|token
operator|!=
literal|null
argument_list|,
literal|"null token"
argument_list|)
expr_stmt|;
name|AbstractS3ATokenIdentifier
name|identifier
decl_stmt|;
comment|// harden up decode beyond that Token does itself
try|try
block|{
name|identifier
operator|=
name|token
operator|.
name|decodeIdentifier
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RuntimeException
name|e
parameter_list|)
block|{
name|Throwable
name|cause
init|=
name|e
operator|.
name|getCause
argument_list|()
decl_stmt|;
if|if
condition|(
name|cause
operator|!=
literal|null
condition|)
block|{
comment|// its a wrapping around class instantiation.
throw|throw
operator|new
name|DelegationTokenIOException
argument_list|(
literal|"Decoding S3A token "
operator|+
name|cause
argument_list|,
name|cause
argument_list|)
throw|;
block|}
else|else
block|{
throw|throw
name|e
throw|;
block|}
block|}
if|if
condition|(
name|identifier
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|DelegationTokenIOException
argument_list|(
literal|"Failed to unmarshall token for "
operator|+
name|getCanonicalUri
argument_list|()
argument_list|)
throw|;
block|}
name|identifier
operator|.
name|validate
argument_list|()
expr_stmt|;
return|return
name|identifier
return|;
block|}
comment|/**    * Return a string for use in building up the User-Agent field, so    * get into the S3 access logs. Useful for diagnostics.    * Delegates to {{@link AbstractDelegationTokenBinding#getUserAgentField()}}    * for the current binding.    * @return a string for the S3 logs or "" for "nothing to add"    */
DECL|method|getUserAgentField ()
specifier|public
name|String
name|getUserAgentField
parameter_list|()
block|{
return|return
name|tokenBinding
operator|.
name|getUserAgentField
argument_list|()
return|;
block|}
comment|/**    * Look up a token from the credentials, verify it is of the correct    * kind.    * @param credentials credentials to look up.    * @param service service name    * @param kind token kind to look for    * @return the token or null if no suitable token was found    * @throws DelegationTokenIOException wrong token kind found    */
annotation|@
name|VisibleForTesting
DECL|method|lookupToken ( final Credentials credentials, final Text service, final Text kind)
specifier|public
specifier|static
name|Token
argument_list|<
name|AbstractS3ATokenIdentifier
argument_list|>
name|lookupToken
parameter_list|(
specifier|final
name|Credentials
name|credentials
parameter_list|,
specifier|final
name|Text
name|service
parameter_list|,
specifier|final
name|Text
name|kind
parameter_list|)
throws|throws
name|DelegationTokenIOException
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Looking for token for service {} in credentials"
argument_list|,
name|service
argument_list|)
expr_stmt|;
name|Token
argument_list|<
name|?
argument_list|>
name|token
init|=
name|credentials
operator|.
name|getToken
argument_list|(
name|service
argument_list|)
decl_stmt|;
if|if
condition|(
name|token
operator|!=
literal|null
condition|)
block|{
name|Text
name|tokenKind
init|=
name|token
operator|.
name|getKind
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Found token of kind {}"
argument_list|,
name|tokenKind
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|.
name|equals
argument_list|(
name|tokenKind
argument_list|)
condition|)
block|{
comment|// the Oauth implementation catches and logs here; this one
comment|// throws the failure up.
return|return
operator|(
name|Token
argument_list|<
name|AbstractS3ATokenIdentifier
argument_list|>
operator|)
name|token
return|;
block|}
else|else
block|{
comment|// there's a token for this URI, but its not the right DT kind
throw|throw
operator|new
name|DelegationTokenIOException
argument_list|(
name|DelegationTokenIOException
operator|.
name|TOKEN_MISMATCH
operator|+
literal|": expected token"
operator|+
literal|" for "
operator|+
name|service
operator|+
literal|" of type "
operator|+
name|kind
operator|+
literal|" but got a token of type "
operator|+
name|tokenKind
argument_list|)
throw|;
block|}
block|}
comment|// A token for the service was not found
name|LOG
operator|.
name|debug
argument_list|(
literal|"No token for {} found"
argument_list|,
name|service
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
comment|/**    * Look up any token from the service; cast it to one of ours.    * @param credentials credentials    * @param service service to look up    * @return any token found or null if none was    * @throws ClassCastException if the token is of a wrong type.    */
DECL|method|lookupToken ( final Credentials credentials, final Text service)
specifier|public
specifier|static
name|Token
argument_list|<
name|AbstractS3ATokenIdentifier
argument_list|>
name|lookupToken
parameter_list|(
specifier|final
name|Credentials
name|credentials
parameter_list|,
specifier|final
name|Text
name|service
parameter_list|)
block|{
return|return
operator|(
name|Token
argument_list|<
name|AbstractS3ATokenIdentifier
argument_list|>
operator|)
name|credentials
operator|.
name|getToken
argument_list|(
name|service
argument_list|)
return|;
block|}
comment|/**    * Look for any S3A token for the given FS service.    * @param credentials credentials to scan.    * @param uri the URI of the FS to look for    * @return the token or null if none was found    */
DECL|method|lookupS3ADelegationToken ( final Credentials credentials, final URI uri)
specifier|public
specifier|static
name|Token
argument_list|<
name|AbstractS3ATokenIdentifier
argument_list|>
name|lookupS3ADelegationToken
parameter_list|(
specifier|final
name|Credentials
name|credentials
parameter_list|,
specifier|final
name|URI
name|uri
parameter_list|)
block|{
return|return
name|lookupToken
argument_list|(
name|credentials
argument_list|,
name|getTokenService
argument_list|(
name|uri
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Predicate: does this configuration enable delegation tokens?    * That is: is there any text in the option    * {@link DelegationConstants#DELEGATION_TOKEN_BINDING} ?    * @param conf configuration to examine    * @return true iff the trimmed configuration option is not empty.    */
DECL|method|hasDelegationTokenBinding (Configuration conf)
specifier|public
specifier|static
name|boolean
name|hasDelegationTokenBinding
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
return|return
name|StringUtils
operator|.
name|isNotEmpty
argument_list|(
name|conf
operator|.
name|getTrimmed
argument_list|(
name|DELEGATION_TOKEN_BINDING
argument_list|,
name|DEFAULT_DELEGATION_TOKEN_BINDING
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * How will tokens be issued on request?    *    * The {@link #RequestNewToken} policy does not guarantee that a tokens    * can be created, only that an attempt will be made to request one.    * It may fail (wrong credential types, wrong role, etc).    */
DECL|enum|TokenIssuingPolicy
specifier|public
enum|enum
name|TokenIssuingPolicy
block|{
comment|/** The existing token will be returned. */
DECL|enumConstant|ReturnExistingToken
name|ReturnExistingToken
block|,
comment|/** No tokens will be issued. */
DECL|enumConstant|NoTokensAvailable
name|NoTokensAvailable
block|,
comment|/** An attempt will be made to request a new DT. */
DECL|enumConstant|RequestNewToken
name|RequestNewToken
block|}
block|}
end_class

end_unit

