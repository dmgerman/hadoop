begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.fs.s3a.select
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|select
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|EOFException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicBoolean
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicLong
import|;
end_import

begin_import
import|import
name|com
operator|.
name|amazonaws
operator|.
name|AbortedException
import|;
end_import

begin_import
import|import
name|com
operator|.
name|amazonaws
operator|.
name|services
operator|.
name|s3
operator|.
name|model
operator|.
name|SelectObjectContentEvent
import|;
end_import

begin_import
import|import
name|com
operator|.
name|amazonaws
operator|.
name|services
operator|.
name|s3
operator|.
name|model
operator|.
name|SelectObjectContentEventVisitor
import|;
end_import

begin_import
import|import
name|com
operator|.
name|amazonaws
operator|.
name|services
operator|.
name|s3
operator|.
name|model
operator|.
name|SelectObjectContentResult
import|;
end_import

begin_import
import|import
name|com
operator|.
name|amazonaws
operator|.
name|services
operator|.
name|s3
operator|.
name|model
operator|.
name|SelectRecordsInputStream
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceStability
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|CanSetReadahead
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FSExceptionMessages
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FSInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|PathIOException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|Retries
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|S3AInstrumentation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|S3AReadOpContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|S3ObjectAttributes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkNotNull
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang3
operator|.
name|StringUtils
operator|.
name|isNotEmpty
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|Invoker
operator|.
name|once
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|S3AInputStream
operator|.
name|validateReadahead
import|;
end_import

begin_comment
comment|/**  * An input stream for S3 Select return values.  * This is simply an end-to-end GET request, without any  * form of seek or recovery from connectivity failures.  *  * Currently only seek and positioned read operations on the current  * location are supported.  *  * The normal S3 input counters are updated by this stream.  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
annotation|@
name|InterfaceStability
operator|.
name|Unstable
DECL|class|SelectInputStream
specifier|public
class|class
name|SelectInputStream
extends|extends
name|FSInputStream
implements|implements
name|CanSetReadahead
block|{
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|SelectInputStream
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|SEEK_UNSUPPORTED
specifier|public
specifier|static
specifier|final
name|String
name|SEEK_UNSUPPORTED
init|=
literal|"seek()"
decl_stmt|;
comment|/**    * Same set of arguments as for an S3AInputStream.    */
DECL|field|objectAttributes
specifier|private
specifier|final
name|S3ObjectAttributes
name|objectAttributes
decl_stmt|;
comment|/**    * Tracks the current position.    */
DECL|field|pos
specifier|private
name|AtomicLong
name|pos
init|=
operator|new
name|AtomicLong
argument_list|(
literal|0
argument_list|)
decl_stmt|;
comment|/**    * Closed flag.    */
DECL|field|closed
specifier|private
specifier|final
name|AtomicBoolean
name|closed
init|=
operator|new
name|AtomicBoolean
argument_list|(
literal|false
argument_list|)
decl_stmt|;
comment|/**    * Did the read complete successfully?    */
DECL|field|completedSuccessfully
specifier|private
specifier|final
name|AtomicBoolean
name|completedSuccessfully
init|=
operator|new
name|AtomicBoolean
argument_list|(
literal|false
argument_list|)
decl_stmt|;
comment|/**    * Abortable response stream.    * This is guaranteed to never be null.    */
DECL|field|wrappedStream
specifier|private
specifier|final
name|SelectRecordsInputStream
name|wrappedStream
decl_stmt|;
DECL|field|bucket
specifier|private
specifier|final
name|String
name|bucket
decl_stmt|;
DECL|field|key
specifier|private
specifier|final
name|String
name|key
decl_stmt|;
DECL|field|uri
specifier|private
specifier|final
name|String
name|uri
decl_stmt|;
DECL|field|readContext
specifier|private
specifier|final
name|S3AReadOpContext
name|readContext
decl_stmt|;
DECL|field|streamStatistics
specifier|private
specifier|final
name|S3AInstrumentation
operator|.
name|InputStreamStatistics
name|streamStatistics
decl_stmt|;
DECL|field|readahead
specifier|private
name|long
name|readahead
decl_stmt|;
comment|/**    * Create the stream.    * The read attempt is initiated immediately.    * @param readContext read context    * @param objectAttributes object attributes from a HEAD request    * @param selectResponse response from the already executed call    * @throws IOException failure    */
annotation|@
name|Retries
operator|.
name|OnceTranslated
DECL|method|SelectInputStream ( final S3AReadOpContext readContext, final S3ObjectAttributes objectAttributes, final SelectObjectContentResult selectResponse)
specifier|public
name|SelectInputStream
parameter_list|(
specifier|final
name|S3AReadOpContext
name|readContext
parameter_list|,
specifier|final
name|S3ObjectAttributes
name|objectAttributes
parameter_list|,
specifier|final
name|SelectObjectContentResult
name|selectResponse
parameter_list|)
throws|throws
name|IOException
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|isNotEmpty
argument_list|(
name|objectAttributes
operator|.
name|getBucket
argument_list|()
argument_list|)
argument_list|,
literal|"No Bucket"
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|isNotEmpty
argument_list|(
name|objectAttributes
operator|.
name|getKey
argument_list|()
argument_list|)
argument_list|,
literal|"No Key"
argument_list|)
expr_stmt|;
name|this
operator|.
name|objectAttributes
operator|=
name|objectAttributes
expr_stmt|;
name|this
operator|.
name|bucket
operator|=
name|objectAttributes
operator|.
name|getBucket
argument_list|()
expr_stmt|;
name|this
operator|.
name|key
operator|=
name|objectAttributes
operator|.
name|getKey
argument_list|()
expr_stmt|;
name|this
operator|.
name|uri
operator|=
literal|"s3a://"
operator|+
name|this
operator|.
name|bucket
operator|+
literal|"/"
operator|+
name|this
operator|.
name|key
expr_stmt|;
name|this
operator|.
name|readContext
operator|=
name|readContext
expr_stmt|;
name|this
operator|.
name|readahead
operator|=
name|readContext
operator|.
name|getReadahead
argument_list|()
expr_stmt|;
name|this
operator|.
name|streamStatistics
operator|=
name|readContext
operator|.
name|getInstrumentation
argument_list|()
operator|.
name|newInputStreamStatistics
argument_list|()
expr_stmt|;
name|SelectRecordsInputStream
name|stream
init|=
name|once
argument_list|(
literal|"S3 Select"
argument_list|,
name|uri
argument_list|,
parameter_list|()
lambda|->
name|selectResponse
operator|.
name|getPayload
argument_list|()
operator|.
name|getRecordsInputStream
argument_list|(
operator|new
name|SelectObjectContentEventVisitor
argument_list|()
block|{
block|@Override               public void visit(final SelectObjectContentEvent.EndEvent event
argument_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Completed successful S3 select read from {}"
argument_list|,
name|uri
argument_list|)
block|;
name|completedSuccessfully
operator|.
name|set
argument_list|(
literal|true
argument_list|)
block|;               }
block|}
block|)
end_class

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|this
operator|.
name|wrappedStream
operator|=
name|checkNotNull
argument_list|(
name|stream
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|// this stream is already opened, so mark as such in the statistics.
end_comment

begin_expr_stmt
name|streamStatistics
operator|.
name|streamOpened
argument_list|()
expr_stmt|;
end_expr_stmt

begin_function
unit|}    @
name|Override
DECL|method|close ()
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
name|long
name|skipped
init|=
literal|0
decl_stmt|;
name|boolean
name|aborted
init|=
literal|false
decl_stmt|;
if|if
condition|(
operator|!
name|closed
operator|.
name|getAndSet
argument_list|(
literal|true
argument_list|)
condition|)
block|{
try|try
block|{
comment|// set up for aborts.
comment|// if we know the available amount> readahead. Abort.
comment|//
name|boolean
name|shouldAbort
init|=
name|wrappedStream
operator|.
name|available
argument_list|()
operator|>
name|readahead
decl_stmt|;
if|if
condition|(
operator|!
name|shouldAbort
condition|)
block|{
comment|// read our readahead range worth of data
name|skipped
operator|=
name|wrappedStream
operator|.
name|skip
argument_list|(
name|readahead
argument_list|)
expr_stmt|;
name|shouldAbort
operator|=
name|wrappedStream
operator|.
name|read
argument_list|()
operator|>=
literal|0
expr_stmt|;
block|}
comment|// now, either there is data left or not.
if|if
condition|(
name|shouldAbort
condition|)
block|{
comment|// yes, more data. Abort and add this fact to the stream stats
name|aborted
operator|=
literal|true
expr_stmt|;
name|wrappedStream
operator|.
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
decl||
name|AbortedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"While closing stream"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|IOUtils
operator|.
name|cleanupWithLogger
argument_list|(
name|LOG
argument_list|,
name|wrappedStream
argument_list|)
expr_stmt|;
name|streamStatistics
operator|.
name|streamClose
argument_list|(
name|aborted
argument_list|,
name|skipped
argument_list|)
expr_stmt|;
name|streamStatistics
operator|.
name|close
argument_list|()
expr_stmt|;
name|super
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/**    * Verify that the input stream is open. Non blocking; this gives    * the last state of the atomic {@link #closed} field.    * @throws PathIOException if the connection is closed.    */
end_comment

begin_function
DECL|method|checkNotClosed ()
specifier|private
name|void
name|checkNotClosed
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|closed
operator|.
name|get
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|PathIOException
argument_list|(
name|uri
argument_list|,
name|FSExceptionMessages
operator|.
name|STREAM_IS_CLOSED
argument_list|)
throw|;
block|}
block|}
end_function

begin_function
annotation|@
name|Override
DECL|method|available ()
specifier|public
name|int
name|available
parameter_list|()
throws|throws
name|IOException
block|{
name|checkNotClosed
argument_list|()
expr_stmt|;
return|return
name|wrappedStream
operator|.
name|available
argument_list|()
return|;
block|}
end_function

begin_function
annotation|@
name|Override
annotation|@
name|Retries
operator|.
name|OnceTranslated
DECL|method|skip (final long n)
specifier|public
specifier|synchronized
name|long
name|skip
parameter_list|(
specifier|final
name|long
name|n
parameter_list|)
throws|throws
name|IOException
block|{
name|checkNotClosed
argument_list|()
expr_stmt|;
name|long
name|skipped
init|=
name|once
argument_list|(
literal|"skip"
argument_list|,
name|uri
argument_list|,
parameter_list|()
lambda|->
name|wrappedStream
operator|.
name|skip
argument_list|(
name|n
argument_list|)
argument_list|)
decl_stmt|;
name|pos
operator|.
name|addAndGet
argument_list|(
name|skipped
argument_list|)
expr_stmt|;
comment|// treat as a forward skip for stats
name|streamStatistics
operator|.
name|seekForwards
argument_list|(
name|skipped
argument_list|)
expr_stmt|;
return|return
name|skipped
return|;
block|}
end_function

begin_function
annotation|@
name|Override
DECL|method|getPos ()
specifier|public
name|long
name|getPos
parameter_list|()
block|{
return|return
name|pos
operator|.
name|get
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/**    * Set the readahead.    * @param readahead The readahead to use.  null means to use the default.    */
end_comment

begin_function
annotation|@
name|Override
DECL|method|setReadahead (Long readahead)
specifier|public
name|void
name|setReadahead
parameter_list|(
name|Long
name|readahead
parameter_list|)
block|{
name|this
operator|.
name|readahead
operator|=
name|validateReadahead
argument_list|(
name|readahead
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**    * Get the current readahead value.    * @return the readahead    */
end_comment

begin_function
DECL|method|getReadahead ()
specifier|public
name|long
name|getReadahead
parameter_list|()
block|{
return|return
name|readahead
return|;
block|}
end_function

begin_comment
comment|/**    * Read a byte. There's no attempt to recover, but AWS-SDK exceptions    * such as {@code SelectObjectContentEventException} are translated into    * IOExceptions.    * @return a byte read or -1 for an end of file.    * @throws IOException failure.    */
end_comment

begin_function
annotation|@
name|Override
annotation|@
name|Retries
operator|.
name|OnceTranslated
DECL|method|read ()
specifier|public
specifier|synchronized
name|int
name|read
parameter_list|()
throws|throws
name|IOException
block|{
name|checkNotClosed
argument_list|()
expr_stmt|;
name|int
name|byteRead
decl_stmt|;
try|try
block|{
name|byteRead
operator|=
name|once
argument_list|(
literal|"read()"
argument_list|,
name|uri
argument_list|,
parameter_list|()
lambda|->
name|wrappedStream
operator|.
name|read
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|EOFException
name|e
parameter_list|)
block|{
comment|// this could be one of: end of file, some IO failure
if|if
condition|(
name|completedSuccessfully
operator|.
name|get
argument_list|()
condition|)
block|{
comment|// read was successful
return|return
operator|-
literal|1
return|;
block|}
else|else
block|{
comment|// the stream closed prematurely
name|LOG
operator|.
name|info
argument_list|(
literal|"Reading of S3 Select data from {} failed before all results "
operator|+
literal|" were generated."
argument_list|,
name|uri
argument_list|)
expr_stmt|;
name|streamStatistics
operator|.
name|readException
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|PathIOException
argument_list|(
name|uri
argument_list|,
literal|"Read of S3 Select data did not complete"
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
name|byteRead
operator|>=
literal|0
condition|)
block|{
name|incrementBytesRead
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|byteRead
return|;
block|}
end_function

begin_function
annotation|@
name|SuppressWarnings
argument_list|(
literal|"NullableProblems"
argument_list|)
annotation|@
name|Override
annotation|@
name|Retries
operator|.
name|OnceTranslated
DECL|method|read (final byte[] buf, final int off, final int len)
specifier|public
specifier|synchronized
name|int
name|read
parameter_list|(
specifier|final
name|byte
index|[]
name|buf
parameter_list|,
specifier|final
name|int
name|off
parameter_list|,
specifier|final
name|int
name|len
parameter_list|)
throws|throws
name|IOException
block|{
name|checkNotClosed
argument_list|()
expr_stmt|;
name|validatePositionedReadArgs
argument_list|(
name|pos
operator|.
name|get
argument_list|()
argument_list|,
name|buf
argument_list|,
name|off
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
name|int
name|bytesRead
decl_stmt|;
try|try
block|{
name|streamStatistics
operator|.
name|readOperationStarted
argument_list|(
name|pos
operator|.
name|get
argument_list|()
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|bytesRead
operator|=
name|wrappedStream
operator|.
name|read
argument_list|(
name|buf
argument_list|,
name|off
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|EOFException
name|e
parameter_list|)
block|{
name|streamStatistics
operator|.
name|readException
argument_list|()
expr_stmt|;
comment|// the base implementation swallows EOFs.
return|return
operator|-
literal|1
return|;
block|}
name|incrementBytesRead
argument_list|(
name|bytesRead
argument_list|)
expr_stmt|;
name|streamStatistics
operator|.
name|readOperationCompleted
argument_list|(
name|len
argument_list|,
name|bytesRead
argument_list|)
expr_stmt|;
return|return
name|bytesRead
return|;
block|}
end_function

begin_comment
comment|/**    * Forward seeks are supported, but not backwards ones.    * Forward seeks are implemented using read, so    * means that long-distance seeks will be (literally) expensive.    *    * @param newPos new seek position.    * @throws PathIOException Backwards seek attempted.    * @throws EOFException attempt to seek past the end of the stream.    * @throws IOException IO failure while skipping bytes    */
end_comment

begin_function
annotation|@
name|Override
annotation|@
name|Retries
operator|.
name|OnceTranslated
DECL|method|seek (long newPos)
specifier|public
specifier|synchronized
name|void
name|seek
parameter_list|(
name|long
name|newPos
parameter_list|)
throws|throws
name|IOException
block|{
name|long
name|current
init|=
name|getPos
argument_list|()
decl_stmt|;
name|long
name|distance
init|=
name|newPos
operator|-
name|current
decl_stmt|;
if|if
condition|(
name|distance
operator|<
literal|0
condition|)
block|{
throw|throw
name|unsupported
argument_list|(
name|SEEK_UNSUPPORTED
operator|+
literal|" backwards from "
operator|+
name|current
operator|+
literal|" to "
operator|+
name|newPos
argument_list|)
throw|;
block|}
if|if
condition|(
name|distance
operator|==
literal|0
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"ignoring seek to current position."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// the complicated one: Forward seeking. Useful for split files.
name|LOG
operator|.
name|debug
argument_list|(
literal|"Forward seek by reading {} bytes"
argument_list|,
name|distance
argument_list|)
expr_stmt|;
name|long
name|bytesSkipped
init|=
literal|0
decl_stmt|;
comment|// read byte-by-byte, hoping that buffering will compensate for this.
comment|// doing it this way ensures that the seek stops at exactly the right
comment|// place. skip(len) can return a smaller value, at which point
comment|// it's not clear what to do.
while|while
condition|(
name|distance
operator|>
literal|0
condition|)
block|{
name|int
name|r
init|=
name|read
argument_list|()
decl_stmt|;
if|if
condition|(
name|r
operator|==
operator|-
literal|1
condition|)
block|{
comment|// reached an EOF too early
throw|throw
operator|new
name|EOFException
argument_list|(
literal|"Seek to "
operator|+
name|newPos
operator|+
literal|" reached End of File at offset "
operator|+
name|getPos
argument_list|()
argument_list|)
throw|;
block|}
name|distance
operator|--
expr_stmt|;
name|bytesSkipped
operator|++
expr_stmt|;
block|}
comment|// read has finished.
name|streamStatistics
operator|.
name|seekForwards
argument_list|(
name|bytesSkipped
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**    * Build an exception to raise when an operation is not supported here.    * @param action action which is unsupported.    * @return an exception to throw.    */
end_comment

begin_function
DECL|method|unsupported (final String action)
specifier|protected
name|PathIOException
name|unsupported
parameter_list|(
specifier|final
name|String
name|action
parameter_list|)
block|{
return|return
operator|new
name|PathIOException
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"s3a://%s/%s"
argument_list|,
name|bucket
argument_list|,
name|key
argument_list|)
argument_list|,
name|action
operator|+
literal|" not supported"
argument_list|)
return|;
block|}
end_function

begin_function
annotation|@
name|Override
DECL|method|seekToNewSource (long targetPos)
specifier|public
name|boolean
name|seekToNewSource
parameter_list|(
name|long
name|targetPos
parameter_list|)
throws|throws
name|IOException
block|{
return|return
literal|false
return|;
block|}
end_function

begin_comment
comment|// Not supported.
end_comment

begin_function
annotation|@
name|Override
DECL|method|markSupported ()
specifier|public
name|boolean
name|markSupported
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
end_function

begin_function
annotation|@
name|SuppressWarnings
argument_list|(
literal|"NonSynchronizedMethodOverridesSynchronizedMethod"
argument_list|)
annotation|@
name|Override
DECL|method|mark (int readLimit)
specifier|public
name|void
name|mark
parameter_list|(
name|int
name|readLimit
parameter_list|)
block|{
comment|// Do nothing
block|}
end_function

begin_function
annotation|@
name|SuppressWarnings
argument_list|(
literal|"NonSynchronizedMethodOverridesSynchronizedMethod"
argument_list|)
annotation|@
name|Override
DECL|method|reset ()
specifier|public
name|void
name|reset
parameter_list|()
throws|throws
name|IOException
block|{
throw|throw
name|unsupported
argument_list|(
literal|"Mark"
argument_list|)
throw|;
block|}
end_function

begin_comment
comment|/**    * Aborts the IO.    */
end_comment

begin_function
DECL|method|abort ()
specifier|public
name|void
name|abort
parameter_list|()
block|{
if|if
condition|(
operator|!
name|closed
operator|.
name|get
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Aborting"
argument_list|)
expr_stmt|;
name|wrappedStream
operator|.
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**    * Read at a specific position.    * Reads at a position earlier than the current {@link #getPos()} position    * will fail with a {@link PathIOException}. See {@link #seek(long)}.    * Unlike the base implementation<i>And the requirements of the filesystem    * specification, this updates the stream position as returned in    * {@link #getPos()}.</i>    * @param position offset in the stream.    * @param buffer buffer to read in to.    * @param offset offset within the buffer    * @param length amount of data to read.    * @return the result.    * @throws PathIOException Backwards seek attempted.    * @throws EOFException attempt to seek past the end of the stream.    * @throws IOException IO failure while seeking in the stream or reading data.    */
end_comment

begin_function
annotation|@
name|Override
DECL|method|read (final long position, final byte[] buffer, final int offset, final int length)
specifier|public
name|int
name|read
parameter_list|(
specifier|final
name|long
name|position
parameter_list|,
specifier|final
name|byte
index|[]
name|buffer
parameter_list|,
specifier|final
name|int
name|offset
parameter_list|,
specifier|final
name|int
name|length
parameter_list|)
throws|throws
name|IOException
block|{
comment|// maybe seek forwards to the position.
name|seek
argument_list|(
name|position
argument_list|)
expr_stmt|;
return|return
name|read
argument_list|(
name|buffer
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Increment the bytes read counter if there is a stats instance    * and the number of bytes read is more than zero.    * This also updates the {@link #pos} marker by the same value.    * @param bytesRead number of bytes read    */
end_comment

begin_function
DECL|method|incrementBytesRead (long bytesRead)
specifier|private
name|void
name|incrementBytesRead
parameter_list|(
name|long
name|bytesRead
parameter_list|)
block|{
if|if
condition|(
name|bytesRead
operator|>
literal|0
condition|)
block|{
name|pos
operator|.
name|addAndGet
argument_list|(
name|bytesRead
argument_list|)
expr_stmt|;
block|}
name|streamStatistics
operator|.
name|bytesRead
argument_list|(
name|bytesRead
argument_list|)
expr_stmt|;
if|if
condition|(
name|readContext
operator|.
name|getStats
argument_list|()
operator|!=
literal|null
operator|&&
name|bytesRead
operator|>
literal|0
condition|)
block|{
name|readContext
operator|.
name|getStats
argument_list|()
operator|.
name|incrementBytesRead
argument_list|(
name|bytesRead
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**    * Get the Stream statistics.    * @return the statistics for this stream.    */
end_comment

begin_function
annotation|@
name|InterfaceAudience
operator|.
name|Private
annotation|@
name|InterfaceStability
operator|.
name|Unstable
DECL|method|getS3AStreamStatistics ()
specifier|public
name|S3AInstrumentation
operator|.
name|InputStreamStatistics
name|getS3AStreamStatistics
parameter_list|()
block|{
return|return
name|streamStatistics
return|;
block|}
end_function

begin_comment
comment|/**    * String value includes statistics as well as stream state.    *<b>Important: there are no guarantees as to the stability    * of this value.</b>    * @return a string value for printing in logs/diagnostics    */
end_comment

begin_function
annotation|@
name|Override
annotation|@
name|InterfaceStability
operator|.
name|Unstable
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|String
name|s
init|=
name|streamStatistics
operator|.
name|toString
argument_list|()
decl_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
specifier|final
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|(
literal|"SelectInputStream{"
argument_list|)
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|uri
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"; state "
argument_list|)
operator|.
name|append
argument_list|(
operator|!
name|closed
operator|.
name|get
argument_list|()
condition|?
literal|"open"
else|:
literal|"closed"
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"; pos="
argument_list|)
operator|.
name|append
argument_list|(
name|getPos
argument_list|()
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"; readahead="
argument_list|)
operator|.
name|append
argument_list|(
name|readahead
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|'\n'
argument_list|)
operator|.
name|append
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|'}'
argument_list|)
expr_stmt|;
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
end_function

unit|}
end_unit

