begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.fs.s3a.commit.staging
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|commit
operator|.
name|staging
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileNotFoundException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Locale
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Queue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentLinkedQueue
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|LocatedFileStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|PathExistsException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|RemoteIterator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|S3AFileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|commit
operator|.
name|AbstractS3ACommitter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|commit
operator|.
name|CommitConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|commit
operator|.
name|CommitOperations
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|commit
operator|.
name|InternalCommitterConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|commit
operator|.
name|Tasks
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|commit
operator|.
name|files
operator|.
name|PendingSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|commit
operator|.
name|files
operator|.
name|SinglePendingCommit
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|JobContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|JobID
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|TaskAttemptContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|lib
operator|.
name|output
operator|.
name|FileOutputCommitter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|DurationInfo
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|*
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|Constants
operator|.
name|*
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|S3AUtils
operator|.
name|*
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|Invoker
operator|.
name|*
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|commit
operator|.
name|staging
operator|.
name|StagingCommitterConstants
operator|.
name|*
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|commit
operator|.
name|CommitConstants
operator|.
name|*
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|commit
operator|.
name|CommitUtils
operator|.
name|*
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|commit
operator|.
name|CommitUtilsWithMR
operator|.
name|*
import|;
end_import

begin_comment
comment|/**  * Committer based on the contributed work of the  *<a href="https://github.com/rdblue/s3committer">Netflix multipart committers.</a>  *<ol>  *<li>  *   The working directory of each task is actually under a temporary  *   path in the local filesystem; jobs write directly into it.  *</li>  *<li>  *     Task Commit: list all files under the task working dir, upload  *     each of them but do not commit the final operation.  *     Persist the information for each pending commit into the cluster  *     for enumeration and commit by the job committer.  *</li>  *<li>Task Abort: recursive delete of task working dir.</li>  *<li>Job Commit: list all pending PUTs to commit; commit them.</li>  *<li>  *     Job Abort: list all pending PUTs to commit; abort them.  *     Delete all task attempt directories.  *</li>  *</ol>  *  * This is the base class of the Partitioned and Directory committers.  * It does not do any conflict resolution, and is made non-abstract  * primarily for test purposes. It is not expected to be used in production.  */
end_comment

begin_class
DECL|class|StagingCommitter
specifier|public
class|class
name|StagingCommitter
extends|extends
name|AbstractS3ACommitter
block|{
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|StagingCommitter
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/** Name: {@value}. */
DECL|field|NAME
specifier|public
specifier|static
specifier|final
name|String
name|NAME
init|=
literal|"staging"
decl_stmt|;
DECL|field|constructorOutputPath
specifier|private
specifier|final
name|Path
name|constructorOutputPath
decl_stmt|;
DECL|field|uploadPartSize
specifier|private
specifier|final
name|long
name|uploadPartSize
decl_stmt|;
DECL|field|uuid
specifier|private
specifier|final
name|String
name|uuid
decl_stmt|;
DECL|field|uniqueFilenames
specifier|private
specifier|final
name|boolean
name|uniqueFilenames
decl_stmt|;
DECL|field|wrappedCommitter
specifier|private
specifier|final
name|FileOutputCommitter
name|wrappedCommitter
decl_stmt|;
DECL|field|conflictResolution
specifier|private
name|ConflictResolution
name|conflictResolution
decl_stmt|;
DECL|field|s3KeyPrefix
specifier|private
name|String
name|s3KeyPrefix
decl_stmt|;
comment|/** The directory in the cluster FS for commits to go to. */
DECL|field|commitsDirectory
specifier|private
name|Path
name|commitsDirectory
decl_stmt|;
comment|/**    * Committer for a single task attempt.    * @param outputPath final output path    * @param context task context    * @throws IOException on a failure    */
DECL|method|StagingCommitter (Path outputPath, TaskAttemptContext context)
specifier|public
name|StagingCommitter
parameter_list|(
name|Path
name|outputPath
parameter_list|,
name|TaskAttemptContext
name|context
parameter_list|)
throws|throws
name|IOException
block|{
name|super
argument_list|(
name|outputPath
argument_list|,
name|context
argument_list|)
expr_stmt|;
name|this
operator|.
name|constructorOutputPath
operator|=
name|checkNotNull
argument_list|(
name|getOutputPath
argument_list|()
argument_list|,
literal|"output path"
argument_list|)
expr_stmt|;
name|Configuration
name|conf
init|=
name|getConf
argument_list|()
decl_stmt|;
name|this
operator|.
name|uploadPartSize
operator|=
name|conf
operator|.
name|getLongBytes
argument_list|(
name|MULTIPART_SIZE
argument_list|,
name|DEFAULT_MULTIPART_SIZE
argument_list|)
expr_stmt|;
name|this
operator|.
name|uuid
operator|=
name|getUploadUUID
argument_list|(
name|conf
argument_list|,
name|context
operator|.
name|getJobID
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|uniqueFilenames
operator|=
name|conf
operator|.
name|getBoolean
argument_list|(
name|FS_S3A_COMMITTER_STAGING_UNIQUE_FILENAMES
argument_list|,
name|DEFAULT_STAGING_COMMITTER_UNIQUE_FILENAMES
argument_list|)
expr_stmt|;
name|setWorkPath
argument_list|(
name|buildWorkPath
argument_list|(
name|context
argument_list|,
name|uuid
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|wrappedCommitter
operator|=
name|createWrappedCommitter
argument_list|(
name|context
argument_list|,
name|conf
argument_list|)
expr_stmt|;
name|setOutputPath
argument_list|(
name|constructorOutputPath
argument_list|)
expr_stmt|;
name|Path
name|finalOutputPath
init|=
name|getOutputPath
argument_list|()
decl_stmt|;
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|finalOutputPath
argument_list|,
literal|"Output path cannot be null"
argument_list|)
expr_stmt|;
name|S3AFileSystem
name|fs
init|=
name|getS3AFileSystem
argument_list|(
name|finalOutputPath
argument_list|,
name|context
operator|.
name|getConfiguration
argument_list|()
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|s3KeyPrefix
operator|=
name|fs
operator|.
name|pathToKey
argument_list|(
name|finalOutputPath
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"{}: final output path is {}"
argument_list|,
name|getRole
argument_list|()
argument_list|,
name|finalOutputPath
argument_list|)
expr_stmt|;
comment|// forces evaluation and caching of the resolution mode.
name|ConflictResolution
name|mode
init|=
name|getConflictResolutionMode
argument_list|(
name|getJobContext
argument_list|()
argument_list|,
name|fs
operator|.
name|getConf
argument_list|()
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Conflict resolution mode: {}"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getName ()
specifier|public
name|String
name|getName
parameter_list|()
block|{
return|return
name|NAME
return|;
block|}
comment|/**    * Create the wrapped committer.    * This includes customizing its options, and setting up the destination    * directory.    * @param context job/task context.    * @param conf config    * @return the inner committer    * @throws IOException on a failure    */
DECL|method|createWrappedCommitter (JobContext context, Configuration conf)
specifier|protected
name|FileOutputCommitter
name|createWrappedCommitter
parameter_list|(
name|JobContext
name|context
parameter_list|,
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
comment|// explicitly choose commit algorithm
name|initFileOutputCommitterOptions
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|commitsDirectory
operator|=
name|Paths
operator|.
name|getMultipartUploadCommitsDirectory
argument_list|(
name|conf
argument_list|,
name|uuid
argument_list|)
expr_stmt|;
return|return
operator|new
name|FileOutputCommitter
argument_list|(
name|commitsDirectory
argument_list|,
name|context
argument_list|)
return|;
block|}
comment|/**    * Init the context config with everything needed for the file output    * committer. In particular, this code currently only works with    * commit algorithm 1.    * @param context context to configure.    */
DECL|method|initFileOutputCommitterOptions (JobContext context)
specifier|protected
name|void
name|initFileOutputCommitterOptions
parameter_list|(
name|JobContext
name|context
parameter_list|)
block|{
name|context
operator|.
name|getConfiguration
argument_list|()
operator|.
name|setInt
argument_list|(
name|FileOutputCommitter
operator|.
name|FILEOUTPUTCOMMITTER_ALGORITHM_VERSION
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
specifier|final
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|(
literal|"StagingCommitter{"
argument_list|)
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|super
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|", conflictResolution="
argument_list|)
operator|.
name|append
argument_list|(
name|conflictResolution
argument_list|)
expr_stmt|;
if|if
condition|(
name|wrappedCommitter
operator|!=
literal|null
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|", wrappedCommitter="
argument_list|)
operator|.
name|append
argument_list|(
name|wrappedCommitter
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
literal|'}'
argument_list|)
expr_stmt|;
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * Get the UUID of an upload; may be the job ID.    * Spark will use a fake app ID based on the current minute and job ID 0.    * To avoid collisions, the key policy is:    *<ol>    *<li>Value of {@link InternalCommitterConstants#FS_S3A_COMMITTER_STAGING_UUID}.</li>    *<li>Value of {@code "spark.sql.sources.writeJobUUID"}.</li>    *<li>Value of {@code "spark.app.id"}.</li>    *<li>JobId passed in.</li>    *</ol>    * The staging UUID is set in in {@link #setupJob(JobContext)} and so will    * be valid in all sequences where the job has been set up for the    * configuration passed in.    * @param conf job/task configuration    * @param jobId Job ID    * @return an ID for use in paths.    */
DECL|method|getUploadUUID (Configuration conf, String jobId)
specifier|public
specifier|static
name|String
name|getUploadUUID
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|String
name|jobId
parameter_list|)
block|{
return|return
name|conf
operator|.
name|getTrimmed
argument_list|(
name|InternalCommitterConstants
operator|.
name|FS_S3A_COMMITTER_STAGING_UUID
argument_list|,
name|conf
operator|.
name|getTrimmed
argument_list|(
name|SPARK_WRITE_UUID
argument_list|,
name|conf
operator|.
name|getTrimmed
argument_list|(
name|SPARK_APP_ID
argument_list|,
name|jobId
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Get the UUID of a Job.    * @param conf job/task configuration    * @param jobId Job ID    * @return an ID for use in paths.    */
DECL|method|getUploadUUID (Configuration conf, JobID jobId)
specifier|public
specifier|static
name|String
name|getUploadUUID
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|JobID
name|jobId
parameter_list|)
block|{
return|return
name|getUploadUUID
argument_list|(
name|conf
argument_list|,
name|jobId
operator|.
name|toString
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Get the work path for a task.    * @param context job/task complex    * @param uuid UUID    * @return a path or null if the context is not of a task    * @throws IOException failure to build the path    */
DECL|method|buildWorkPath (JobContext context, String uuid)
specifier|private
specifier|static
name|Path
name|buildWorkPath
parameter_list|(
name|JobContext
name|context
parameter_list|,
name|String
name|uuid
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|context
operator|instanceof
name|TaskAttemptContext
condition|)
block|{
return|return
name|taskAttemptWorkingPath
argument_list|(
operator|(
name|TaskAttemptContext
operator|)
name|context
argument_list|,
name|uuid
argument_list|)
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
comment|/**    * Is this committer using unique filenames?    * @return true if unique filenames are used.    */
DECL|method|useUniqueFilenames ()
specifier|public
name|Boolean
name|useUniqueFilenames
parameter_list|()
block|{
return|return
name|uniqueFilenames
return|;
block|}
comment|/**    * Get the filesystem for the job attempt.    * @param context the context of the job.  This is used to get the    * application attempt ID.    * @return the FS to store job attempt data.    * @throws IOException failure to create the FS.    */
DECL|method|getJobAttemptFileSystem (JobContext context)
specifier|public
name|FileSystem
name|getJobAttemptFileSystem
parameter_list|(
name|JobContext
name|context
parameter_list|)
throws|throws
name|IOException
block|{
name|Path
name|p
init|=
name|getJobAttemptPath
argument_list|(
name|context
argument_list|)
decl_stmt|;
return|return
name|p
operator|.
name|getFileSystem
argument_list|(
name|context
operator|.
name|getConfiguration
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Compute the path where the output of a given job attempt will be placed.    * @param context the context of the job.  This is used to get the    * application attempt ID.    * @param out the output path to place these in.    * @return the path to store job attempt data.    */
DECL|method|getJobAttemptPath (JobContext context, Path out)
specifier|public
specifier|static
name|Path
name|getJobAttemptPath
parameter_list|(
name|JobContext
name|context
parameter_list|,
name|Path
name|out
parameter_list|)
block|{
return|return
name|getJobAttemptPath
argument_list|(
name|getAppAttemptId
argument_list|(
name|context
argument_list|)
argument_list|,
name|out
argument_list|)
return|;
block|}
comment|/**    * Compute the path where the output of a given job attempt will be placed.    * @param appAttemptId the ID of the application attempt for this job.    * @return the path to store job attempt data.    */
DECL|method|getJobAttemptPath (int appAttemptId, Path out)
specifier|private
specifier|static
name|Path
name|getJobAttemptPath
parameter_list|(
name|int
name|appAttemptId
parameter_list|,
name|Path
name|out
parameter_list|)
block|{
return|return
operator|new
name|Path
argument_list|(
name|getPendingJobAttemptsPath
argument_list|(
name|out
argument_list|)
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
name|appAttemptId
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|getJobAttemptPath (int appAttemptId)
specifier|protected
name|Path
name|getJobAttemptPath
parameter_list|(
name|int
name|appAttemptId
parameter_list|)
block|{
return|return
operator|new
name|Path
argument_list|(
name|getPendingJobAttemptsPath
argument_list|(
name|commitsDirectory
argument_list|)
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
name|appAttemptId
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Compute the path where the output of pending task attempts are stored.    * @param context the context of the job with pending tasks.    * @return the path where the output of pending task attempts are stored.    */
DECL|method|getPendingTaskAttemptsPath (JobContext context, Path out)
specifier|private
specifier|static
name|Path
name|getPendingTaskAttemptsPath
parameter_list|(
name|JobContext
name|context
parameter_list|,
name|Path
name|out
parameter_list|)
block|{
return|return
operator|new
name|Path
argument_list|(
name|getJobAttemptPath
argument_list|(
name|context
argument_list|,
name|out
argument_list|)
argument_list|,
name|TEMPORARY
argument_list|)
return|;
block|}
comment|/**    * Compute the path where the output of a task attempt is stored until    * that task is committed.    *    * @param context the context of the task attempt.    * @param out The output path to put things in.    * @return the path where a task attempt should be stored.    */
DECL|method|getTaskAttemptPath (TaskAttemptContext context, Path out)
specifier|public
specifier|static
name|Path
name|getTaskAttemptPath
parameter_list|(
name|TaskAttemptContext
name|context
parameter_list|,
name|Path
name|out
parameter_list|)
block|{
return|return
operator|new
name|Path
argument_list|(
name|getPendingTaskAttemptsPath
argument_list|(
name|context
argument_list|,
name|out
argument_list|)
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
name|context
operator|.
name|getTaskAttemptID
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Get the location of pending job attempts.    * @param out the base output directory.    * @return the location of pending job attempts.    */
DECL|method|getPendingJobAttemptsPath (Path out)
specifier|private
specifier|static
name|Path
name|getPendingJobAttemptsPath
parameter_list|(
name|Path
name|out
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|out
argument_list|,
literal|"Null 'out' path"
argument_list|)
expr_stmt|;
return|return
operator|new
name|Path
argument_list|(
name|out
argument_list|,
name|TEMPORARY
argument_list|)
return|;
block|}
comment|/**    * Compute the path where the output of a committed task is stored until    * the entire job is committed.    * @param context the context of the task attempt    * @return the path where the output of a committed task is stored until    * the entire job is committed.    */
DECL|method|getCommittedTaskPath (TaskAttemptContext context)
specifier|public
name|Path
name|getCommittedTaskPath
parameter_list|(
name|TaskAttemptContext
name|context
parameter_list|)
block|{
return|return
name|getCommittedTaskPath
argument_list|(
name|getAppAttemptId
argument_list|(
name|context
argument_list|)
argument_list|,
name|context
argument_list|)
return|;
block|}
comment|/**    * Validate the task attempt context; makes sure    * that the task attempt ID data is valid.    * @param context task context    */
DECL|method|validateContext (TaskAttemptContext context)
specifier|private
specifier|static
name|void
name|validateContext
parameter_list|(
name|TaskAttemptContext
name|context
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|context
argument_list|,
literal|"null context"
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|context
operator|.
name|getTaskAttemptID
argument_list|()
argument_list|,
literal|"null task attempt ID"
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|context
operator|.
name|getTaskAttemptID
argument_list|()
operator|.
name|getTaskID
argument_list|()
argument_list|,
literal|"null task ID"
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|context
operator|.
name|getTaskAttemptID
argument_list|()
operator|.
name|getJobID
argument_list|()
argument_list|,
literal|"null job ID"
argument_list|)
expr_stmt|;
block|}
comment|/**    * Compute the path where the output of a committed task is stored until the    * entire job is committed for a specific application attempt.    * @param appAttemptId the ID of the application attempt to use    * @param context the context of any task.    * @return the path where the output of a committed task is stored.    */
DECL|method|getCommittedTaskPath (int appAttemptId, TaskAttemptContext context)
specifier|protected
name|Path
name|getCommittedTaskPath
parameter_list|(
name|int
name|appAttemptId
parameter_list|,
name|TaskAttemptContext
name|context
parameter_list|)
block|{
name|validateContext
argument_list|(
name|context
argument_list|)
expr_stmt|;
return|return
operator|new
name|Path
argument_list|(
name|getJobAttemptPath
argument_list|(
name|appAttemptId
argument_list|)
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
name|context
operator|.
name|getTaskAttemptID
argument_list|()
operator|.
name|getTaskID
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|getTempTaskAttemptPath (TaskAttemptContext context)
specifier|public
name|Path
name|getTempTaskAttemptPath
parameter_list|(
name|TaskAttemptContext
name|context
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"Unimplemented"
argument_list|)
throw|;
block|}
comment|/**    * Lists the output of a task under the task attempt path. Subclasses can    * override this method to change how output files are identified.    *<p>    * This implementation lists the files that are direct children of the output    * path and filters hidden files (file names starting with '.' or '_').    *<p>    * The task attempt path is provided by    * {@link #getTaskAttemptPath(TaskAttemptContext)}    *    * @param context this task's {@link TaskAttemptContext}    * @return the output files produced by this task in the task attempt path    * @throws IOException on a failure    */
DECL|method|getTaskOutput (TaskAttemptContext context)
specifier|protected
name|List
argument_list|<
name|LocatedFileStatus
argument_list|>
name|getTaskOutput
parameter_list|(
name|TaskAttemptContext
name|context
parameter_list|)
throws|throws
name|IOException
block|{
comment|// get files on the local FS in the attempt path
name|Path
name|attemptPath
init|=
name|getTaskAttemptPath
argument_list|(
name|context
argument_list|)
decl_stmt|;
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|attemptPath
argument_list|,
literal|"No attemptPath path in {}"
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Scanning {} for files to commit"
argument_list|,
name|attemptPath
argument_list|)
expr_stmt|;
return|return
name|listAndFilter
argument_list|(
name|getTaskAttemptFilesystem
argument_list|(
name|context
argument_list|)
argument_list|,
name|attemptPath
argument_list|,
literal|true
argument_list|,
name|HIDDEN_FILE_FILTER
argument_list|)
return|;
block|}
comment|/**    * Returns the final S3 key for a relative path. Subclasses can override this    * method to upload files to a different S3 location.    *<p>    * This implementation concatenates the relative path with the key prefix    * from the output path.    * If {@link CommitConstants#FS_S3A_COMMITTER_STAGING_UNIQUE_FILENAMES} is    * set, then the task UUID is also included in the calculation    *    * @param relative the path of a file relative to the task attempt path    * @param context the JobContext or TaskAttemptContext for this job    * @return the S3 key where the file will be uploaded    */
DECL|method|getFinalKey (String relative, JobContext context)
specifier|protected
name|String
name|getFinalKey
parameter_list|(
name|String
name|relative
parameter_list|,
name|JobContext
name|context
parameter_list|)
block|{
if|if
condition|(
name|uniqueFilenames
condition|)
block|{
return|return
name|getS3KeyPrefix
argument_list|(
name|context
argument_list|)
operator|+
literal|"/"
operator|+
name|Paths
operator|.
name|addUUID
argument_list|(
name|relative
argument_list|,
name|uuid
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|getS3KeyPrefix
argument_list|(
name|context
argument_list|)
operator|+
literal|"/"
operator|+
name|relative
return|;
block|}
block|}
comment|/**    * Returns the final S3 location for a relative path as a Hadoop {@link Path}.    * This is a final method that calls {@link #getFinalKey(String, JobContext)}    * to determine the final location.    *    * @param relative the path of a file relative to the task attempt path    * @param context the JobContext or TaskAttemptContext for this job    * @return the S3 Path where the file will be uploaded    * @throws IOException IO problem    */
DECL|method|getFinalPath (String relative, JobContext context)
specifier|protected
specifier|final
name|Path
name|getFinalPath
parameter_list|(
name|String
name|relative
parameter_list|,
name|JobContext
name|context
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|getDestS3AFS
argument_list|()
operator|.
name|keyToQualifiedPath
argument_list|(
name|getFinalKey
argument_list|(
name|relative
argument_list|,
name|context
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Return the local work path as the destination for writing work.    * @param context the context of the task attempt.    * @return a path in the local filesystem.    */
annotation|@
name|Override
DECL|method|getBaseTaskAttemptPath (TaskAttemptContext context)
specifier|public
name|Path
name|getBaseTaskAttemptPath
parameter_list|(
name|TaskAttemptContext
name|context
parameter_list|)
block|{
comment|// a path on the local FS for files that will be uploaded
return|return
name|getWorkPath
argument_list|()
return|;
block|}
comment|/**    * For a job attempt path, the staging committer returns that of the    * wrapped committer.    * @param context the context of the job.    * @return a path in HDFS.    */
annotation|@
name|Override
DECL|method|getJobAttemptPath (JobContext context)
specifier|public
name|Path
name|getJobAttemptPath
parameter_list|(
name|JobContext
name|context
parameter_list|)
block|{
return|return
name|wrappedCommitter
operator|.
name|getJobAttemptPath
argument_list|(
name|context
argument_list|)
return|;
block|}
comment|/**    * Set up the job, including calling the same method on the    * wrapped committer.    * @param context job context    * @throws IOException IO failure.    */
annotation|@
name|Override
DECL|method|setupJob (JobContext context)
specifier|public
name|void
name|setupJob
parameter_list|(
name|JobContext
name|context
parameter_list|)
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"{}, Setting up job {}"
argument_list|,
name|getRole
argument_list|()
argument_list|,
name|jobIdString
argument_list|(
name|context
argument_list|)
argument_list|)
expr_stmt|;
name|context
operator|.
name|getConfiguration
argument_list|()
operator|.
name|set
argument_list|(
name|InternalCommitterConstants
operator|.
name|FS_S3A_COMMITTER_STAGING_UUID
argument_list|,
name|uuid
argument_list|)
expr_stmt|;
name|wrappedCommitter
operator|.
name|setupJob
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|super
operator|.
name|setupJob
argument_list|(
name|context
argument_list|)
expr_stmt|;
block|}
comment|/**    * Get the list of pending uploads for this job attempt.    * @param context job context    * @return a list of pending uploads.    * @throws IOException Any IO failure    */
annotation|@
name|Override
DECL|method|listPendingUploadsToCommit ( JobContext context)
specifier|protected
name|ActiveCommit
name|listPendingUploadsToCommit
parameter_list|(
name|JobContext
name|context
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|listPendingUploads
argument_list|(
name|context
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**    * Get the list of pending uploads for this job attempt, swallowing    * exceptions.    * @param context job context    * @return a list of pending uploads. If an exception was swallowed,    * then this may not match the actual set of pending operations    * @throws IOException shouldn't be raised, but retained for the compiler    */
DECL|method|listPendingUploadsToAbort ( JobContext context)
specifier|protected
name|ActiveCommit
name|listPendingUploadsToAbort
parameter_list|(
name|JobContext
name|context
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|listPendingUploads
argument_list|(
name|context
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|/**    * Get the list of pending uploads for this job attempt.    * @param context job context    * @param suppressExceptions should exceptions be swallowed?    * @return a list of pending uploads. If exceptions are being swallowed,    * then this may not match the actual set of pending operations    * @throws IOException Any IO failure which wasn't swallowed.    */
DECL|method|listPendingUploads ( JobContext context, boolean suppressExceptions)
specifier|protected
name|ActiveCommit
name|listPendingUploads
parameter_list|(
name|JobContext
name|context
parameter_list|,
name|boolean
name|suppressExceptions
parameter_list|)
throws|throws
name|IOException
block|{
try|try
init|(
name|DurationInfo
name|ignored
init|=
operator|new
name|DurationInfo
argument_list|(
name|LOG
argument_list|,
literal|"Listing pending uploads"
argument_list|)
init|)
block|{
name|Path
name|wrappedJobAttemptPath
init|=
name|getJobAttemptPath
argument_list|(
name|context
argument_list|)
decl_stmt|;
specifier|final
name|FileSystem
name|attemptFS
init|=
name|wrappedJobAttemptPath
operator|.
name|getFileSystem
argument_list|(
name|context
operator|.
name|getConfiguration
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|ActiveCommit
operator|.
name|fromStatusList
argument_list|(
name|attemptFS
argument_list|,
name|listAndFilter
argument_list|(
name|attemptFS
argument_list|,
name|wrappedJobAttemptPath
argument_list|,
literal|false
argument_list|,
name|HIDDEN_FILE_FILTER
argument_list|)
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|e
parameter_list|)
block|{
comment|// this can mean the job was aborted early on, so don't confuse people
comment|// with long stack traces that aren't the underlying problem.
name|maybeIgnore
argument_list|(
name|suppressExceptions
argument_list|,
literal|"Pending upload directory not found"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// unable to work with endpoint, if suppressing errors decide our actions
name|maybeIgnore
argument_list|(
name|suppressExceptions
argument_list|,
literal|"Listing pending uploads"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
comment|// reached iff an IOE was caught and swallowed
return|return
name|ActiveCommit
operator|.
name|empty
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|cleanupStagingDirs ()
specifier|public
name|void
name|cleanupStagingDirs
parameter_list|()
block|{
name|Path
name|workPath
init|=
name|getWorkPath
argument_list|()
decl_stmt|;
if|if
condition|(
name|workPath
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Cleaning up work path {}"
argument_list|,
name|workPath
argument_list|)
expr_stmt|;
name|ignoreIOExceptions
argument_list|(
name|LOG
argument_list|,
literal|"cleaning up"
argument_list|,
name|workPath
operator|.
name|toString
argument_list|()
argument_list|,
parameter_list|()
lambda|->
name|deleteQuietly
argument_list|(
name|workPath
operator|.
name|getFileSystem
argument_list|(
name|getConf
argument_list|()
argument_list|)
argument_list|,
name|workPath
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
annotation|@
name|SuppressWarnings
argument_list|(
literal|"deprecation"
argument_list|)
DECL|method|cleanup (JobContext context, boolean suppressExceptions)
specifier|protected
name|void
name|cleanup
parameter_list|(
name|JobContext
name|context
parameter_list|,
name|boolean
name|suppressExceptions
parameter_list|)
throws|throws
name|IOException
block|{
name|maybeIgnore
argument_list|(
name|suppressExceptions
argument_list|,
literal|"Cleanup wrapped committer"
argument_list|,
parameter_list|()
lambda|->
name|wrappedCommitter
operator|.
name|cleanupJob
argument_list|(
name|context
argument_list|)
argument_list|)
expr_stmt|;
name|maybeIgnore
argument_list|(
name|suppressExceptions
argument_list|,
literal|"Delete destination paths"
argument_list|,
parameter_list|()
lambda|->
name|deleteDestinationPaths
argument_list|(
name|context
argument_list|)
argument_list|)
expr_stmt|;
name|super
operator|.
name|cleanup
argument_list|(
name|context
argument_list|,
name|suppressExceptions
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|abortPendingUploadsInCleanup (boolean suppressExceptions)
specifier|protected
name|void
name|abortPendingUploadsInCleanup
parameter_list|(
name|boolean
name|suppressExceptions
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|getConf
argument_list|()
operator|.
name|getBoolean
argument_list|(
name|FS_S3A_COMMITTER_STAGING_ABORT_PENDING_UPLOADS
argument_list|,
literal|true
argument_list|)
condition|)
block|{
name|super
operator|.
name|abortPendingUploadsInCleanup
argument_list|(
name|suppressExceptions
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Not cleanup up pending uploads to {} as {} is false "
argument_list|,
name|getOutputPath
argument_list|()
argument_list|,
name|FS_S3A_COMMITTER_STAGING_ABORT_PENDING_UPLOADS
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|abortJobInternal (JobContext context, boolean suppressExceptions)
specifier|protected
name|void
name|abortJobInternal
parameter_list|(
name|JobContext
name|context
parameter_list|,
name|boolean
name|suppressExceptions
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|r
init|=
name|getRole
argument_list|()
decl_stmt|;
name|boolean
name|failed
init|=
literal|false
decl_stmt|;
try|try
init|(
name|DurationInfo
name|d
init|=
operator|new
name|DurationInfo
argument_list|(
name|LOG
argument_list|,
literal|"%s: aborting job in state %s "
argument_list|,
name|r
argument_list|,
name|jobIdString
argument_list|(
name|context
argument_list|)
argument_list|)
init|)
block|{
name|ActiveCommit
name|pending
init|=
name|listPendingUploadsToAbort
argument_list|(
name|context
argument_list|)
decl_stmt|;
name|abortPendingUploads
argument_list|(
name|context
argument_list|,
name|pending
argument_list|,
name|suppressExceptions
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|e
parameter_list|)
block|{
comment|// nothing to list
name|LOG
operator|.
name|debug
argument_list|(
literal|"No job directory to read uploads from"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|failed
operator|=
literal|true
expr_stmt|;
name|maybeIgnore
argument_list|(
name|suppressExceptions
argument_list|,
literal|"aborting job"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|super
operator|.
name|abortJobInternal
argument_list|(
name|context
argument_list|,
name|failed
operator|||
name|suppressExceptions
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Delete the working paths of a job.    *<ol>    *<li>The job attempt path</li>    *<li>{@code $dest/__temporary}</li>    *<li>the local working directory for staged files</li>    *</ol>    * Does not attempt to clean up the work of the wrapped committer.    * @param context job context    * @throws IOException IO failure    */
DECL|method|deleteDestinationPaths (JobContext context)
specifier|protected
name|void
name|deleteDestinationPaths
parameter_list|(
name|JobContext
name|context
parameter_list|)
throws|throws
name|IOException
block|{
name|Path
name|attemptPath
init|=
name|getJobAttemptPath
argument_list|(
name|context
argument_list|)
decl_stmt|;
name|ignoreIOExceptions
argument_list|(
name|LOG
argument_list|,
literal|"Deleting Job attempt Path"
argument_list|,
name|attemptPath
operator|.
name|toString
argument_list|()
argument_list|,
parameter_list|()
lambda|->
name|deleteWithWarning
argument_list|(
name|getJobAttemptFileSystem
argument_list|(
name|context
argument_list|)
argument_list|,
name|attemptPath
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
comment|// delete the __temporary directory. This will cause problems
comment|// if there is>1 task targeting the same dest dir
name|deleteWithWarning
argument_list|(
name|getDestFS
argument_list|()
argument_list|,
operator|new
name|Path
argument_list|(
name|getOutputPath
argument_list|()
argument_list|,
name|TEMPORARY
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|// and the working path
name|deleteTaskWorkingPathQuietly
argument_list|(
name|context
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|setupTask (TaskAttemptContext context)
specifier|public
name|void
name|setupTask
parameter_list|(
name|TaskAttemptContext
name|context
parameter_list|)
throws|throws
name|IOException
block|{
name|Path
name|taskAttemptPath
init|=
name|getTaskAttemptPath
argument_list|(
name|context
argument_list|)
decl_stmt|;
try|try
init|(
name|DurationInfo
name|d
init|=
operator|new
name|DurationInfo
argument_list|(
name|LOG
argument_list|,
literal|"%s: setup task attempt path %s "
argument_list|,
name|getRole
argument_list|()
argument_list|,
name|taskAttemptPath
argument_list|)
init|)
block|{
comment|// create the local FS
name|taskAttemptPath
operator|.
name|getFileSystem
argument_list|(
name|getConf
argument_list|()
argument_list|)
operator|.
name|mkdirs
argument_list|(
name|taskAttemptPath
argument_list|)
expr_stmt|;
name|wrappedCommitter
operator|.
name|setupTask
argument_list|(
name|context
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|needsTaskCommit (TaskAttemptContext context)
specifier|public
name|boolean
name|needsTaskCommit
parameter_list|(
name|TaskAttemptContext
name|context
parameter_list|)
throws|throws
name|IOException
block|{
try|try
init|(
name|DurationInfo
name|d
init|=
operator|new
name|DurationInfo
argument_list|(
name|LOG
argument_list|,
literal|"%s: needsTaskCommit() Task %s"
argument_list|,
name|getRole
argument_list|()
argument_list|,
name|context
operator|.
name|getTaskAttemptID
argument_list|()
argument_list|)
init|)
block|{
comment|// check for files on the local FS in the attempt path
name|Path
name|attemptPath
init|=
name|getTaskAttemptPath
argument_list|(
name|context
argument_list|)
decl_stmt|;
name|FileSystem
name|fs
init|=
name|getTaskAttemptFilesystem
argument_list|(
name|context
argument_list|)
decl_stmt|;
comment|// This could be made more efficient with a probe "hasChildren(Path)"
comment|// which returns true if there is>1 entry under a given path.
name|FileStatus
index|[]
name|stats
init|=
name|fs
operator|.
name|listStatus
argument_list|(
name|attemptPath
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"{} files to commit under {}"
argument_list|,
name|stats
operator|.
name|length
argument_list|,
name|attemptPath
argument_list|)
expr_stmt|;
return|return
name|stats
operator|.
name|length
operator|>
literal|0
return|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|e
parameter_list|)
block|{
comment|// list didn't find a directory, so nothing to commit
comment|// TODO: throw this up as an error?
name|LOG
operator|.
name|info
argument_list|(
literal|"No files to commit"
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
annotation|@
name|Override
DECL|method|commitTask (TaskAttemptContext context)
specifier|public
name|void
name|commitTask
parameter_list|(
name|TaskAttemptContext
name|context
parameter_list|)
throws|throws
name|IOException
block|{
try|try
init|(
name|DurationInfo
name|d
init|=
operator|new
name|DurationInfo
argument_list|(
name|LOG
argument_list|,
literal|"%s: commit task %s"
argument_list|,
name|getRole
argument_list|()
argument_list|,
name|context
operator|.
name|getTaskAttemptID
argument_list|()
argument_list|)
init|)
block|{
name|int
name|count
init|=
name|commitTaskInternal
argument_list|(
name|context
argument_list|,
name|getTaskOutput
argument_list|(
name|context
argument_list|)
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"{}: upload file count: {}"
argument_list|,
name|getRole
argument_list|()
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"{}: commit of task {} failed"
argument_list|,
name|getRole
argument_list|()
argument_list|,
name|context
operator|.
name|getTaskAttemptID
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|getCommitOperations
argument_list|()
operator|.
name|taskCompleted
argument_list|(
literal|false
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
finally|finally
block|{
name|destroyThreadPool
argument_list|()
expr_stmt|;
block|}
name|getCommitOperations
argument_list|()
operator|.
name|taskCompleted
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**    * Commit the task by uploading all created files and then    * writing a pending entry for them.    * @param context task context    * @param taskOutput list of files from the output    * @return number of uploads committed.    * @throws IOException IO Failures.    */
DECL|method|commitTaskInternal (final TaskAttemptContext context, List<? extends FileStatus> taskOutput)
specifier|protected
name|int
name|commitTaskInternal
parameter_list|(
specifier|final
name|TaskAttemptContext
name|context
parameter_list|,
name|List
argument_list|<
name|?
extends|extends
name|FileStatus
argument_list|>
name|taskOutput
parameter_list|)
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"{}: commitTaskInternal"
argument_list|,
name|getRole
argument_list|()
argument_list|)
expr_stmt|;
name|Configuration
name|conf
init|=
name|context
operator|.
name|getConfiguration
argument_list|()
decl_stmt|;
specifier|final
name|Path
name|attemptPath
init|=
name|getTaskAttemptPath
argument_list|(
name|context
argument_list|)
decl_stmt|;
name|FileSystem
name|attemptFS
init|=
name|getTaskAttemptFilesystem
argument_list|(
name|context
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"{}: attempt path is {}"
argument_list|,
name|getRole
argument_list|()
argument_list|,
name|attemptPath
argument_list|)
expr_stmt|;
comment|// add the commits file to the wrapped committer's task attempt location.
comment|// of this method.
name|Path
name|commitsAttemptPath
init|=
name|wrappedCommitter
operator|.
name|getTaskAttemptPath
argument_list|(
name|context
argument_list|)
decl_stmt|;
name|FileSystem
name|commitsFS
init|=
name|commitsAttemptPath
operator|.
name|getFileSystem
argument_list|(
name|conf
argument_list|)
decl_stmt|;
comment|// keep track of unfinished commits in case one fails. if something fails,
comment|// we will try to abort the ones that had already succeeded.
name|int
name|commitCount
init|=
name|taskOutput
operator|.
name|size
argument_list|()
decl_stmt|;
specifier|final
name|Queue
argument_list|<
name|SinglePendingCommit
argument_list|>
name|commits
init|=
operator|new
name|ConcurrentLinkedQueue
argument_list|<>
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"{}: uploading from staging directory to S3 {}"
argument_list|,
name|getRole
argument_list|()
argument_list|,
name|attemptPath
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"{}: Saving pending data information to {}"
argument_list|,
name|getRole
argument_list|()
argument_list|,
name|commitsAttemptPath
argument_list|)
expr_stmt|;
if|if
condition|(
name|taskOutput
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// there is nothing to write. needsTaskCommit() should have caught
comment|// this, so warn that there is some kind of problem in the protocol.
name|LOG
operator|.
name|warn
argument_list|(
literal|"{}: No files to commit"
argument_list|,
name|getRole
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|boolean
name|threw
init|=
literal|true
decl_stmt|;
comment|// before the uploads, report some progress
name|context
operator|.
name|progress
argument_list|()
expr_stmt|;
name|PendingSet
name|pendingCommits
init|=
operator|new
name|PendingSet
argument_list|(
name|commitCount
argument_list|)
decl_stmt|;
try|try
block|{
name|Tasks
operator|.
name|foreach
argument_list|(
name|taskOutput
argument_list|)
operator|.
name|stopOnFailure
argument_list|()
operator|.
name|suppressExceptions
argument_list|(
literal|false
argument_list|)
operator|.
name|executeWith
argument_list|(
name|buildThreadPool
argument_list|(
name|context
argument_list|)
argument_list|)
operator|.
name|run
argument_list|(
name|stat
lambda|->
block|{
name|Path
name|path
init|=
name|stat
operator|.
name|getPath
argument_list|()
decl_stmt|;
name|File
name|localFile
init|=
operator|new
name|File
argument_list|(
name|path
operator|.
name|toUri
argument_list|()
operator|.
name|getPath
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|relative
init|=
name|Paths
operator|.
name|getRelativePath
argument_list|(
name|attemptPath
argument_list|,
name|path
argument_list|)
decl_stmt|;
name|String
name|partition
init|=
name|Paths
operator|.
name|getPartition
argument_list|(
name|relative
argument_list|)
decl_stmt|;
name|String
name|key
init|=
name|getFinalKey
argument_list|(
name|relative
argument_list|,
name|context
argument_list|)
decl_stmt|;
name|Path
name|destPath
init|=
name|getDestS3AFS
argument_list|()
operator|.
name|keyToQualifiedPath
argument_list|(
name|key
argument_list|)
decl_stmt|;
name|SinglePendingCommit
name|commit
init|=
name|getCommitOperations
argument_list|()
operator|.
name|uploadFileToPendingCommit
argument_list|(
name|localFile
argument_list|,
name|destPath
argument_list|,
name|partition
argument_list|,
name|uploadPartSize
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"{}: adding pending commit {}"
argument_list|,
name|getRole
argument_list|()
argument_list|,
name|commit
argument_list|)
expr_stmt|;
name|commits
operator|.
name|add
argument_list|(
name|commit
argument_list|)
expr_stmt|;
block|}
argument_list|)
expr_stmt|;
for|for
control|(
name|SinglePendingCommit
name|commit
range|:
name|commits
control|)
block|{
name|pendingCommits
operator|.
name|add
argument_list|(
name|commit
argument_list|)
expr_stmt|;
block|}
comment|// save the data
comment|// although overwrite=false, there's still a risk of> 1 entry being
comment|// committed if the FS doesn't have create-no-overwrite consistency.
name|LOG
operator|.
name|debug
argument_list|(
literal|"Saving {} pending commit(s)) to file {}"
argument_list|,
name|pendingCommits
operator|.
name|size
argument_list|()
argument_list|,
name|commitsAttemptPath
argument_list|)
expr_stmt|;
name|pendingCommits
operator|.
name|save
argument_list|(
name|commitsFS
argument_list|,
name|commitsAttemptPath
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|threw
operator|=
literal|false
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|threw
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"{}: Exception during commit process, aborting {} commit(s)"
argument_list|,
name|getRole
argument_list|()
argument_list|,
name|commits
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
try|try
init|(
name|CommitOperations
operator|.
name|CommitContext
name|commitContext
init|=
name|initiateCommitOperation
argument_list|()
init|;               DurationInfo ignored = new DurationInfo(LOG
operator|,
init|"Aborting %s uploads"
operator|,
init|commits.size()
block|)
block|)
block|{
name|Tasks
operator|.
name|foreach
argument_list|(
name|commits
argument_list|)
operator|.
name|suppressExceptions
argument_list|()
operator|.
name|run
argument_list|(
name|commitContext
operator|::
name|abortSingleCommit
argument_list|)
expr_stmt|;
block|}
name|deleteTaskAttemptPathQuietly
argument_list|(
name|context
argument_list|)
expr_stmt|;
block|}
block|}
comment|// always purge attempt information at this point.
name|Paths
operator|.
name|clearTempFolderInfo
argument_list|(
name|context
operator|.
name|getTaskAttemptID
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_class

begin_expr_stmt
name|LOG
operator|.
name|debug
argument_list|(
literal|"Committing wrapped task"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|wrappedCommitter
operator|.
name|commitTask
argument_list|(
name|context
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|LOG
operator|.
name|debug
argument_list|(
literal|"Cleaning up attempt dir {}"
argument_list|,
name|attemptPath
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|attemptFS
operator|.
name|delete
argument_list|(
name|attemptPath
argument_list|,
literal|true
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|commits
operator|.
name|size
argument_list|()
return|;
end_return

begin_comment
unit|}
comment|/**    * Abort the task.    * The API specifies that the task has not yet been committed, so there are    * no uploads that need to be cancelled.    * Accordingly just delete files on the local FS, and call abortTask in    * the wrapped committer.    *<b>Important: this may be called in the AM after a container failure.</b>    * When that occurs and the failed container was on a different host in the    * cluster, the local files will not be deleted.    * @param context task context    * @throws IOException any failure    */
end_comment

begin_function
unit|@
name|Override
DECL|method|abortTask (TaskAttemptContext context)
specifier|public
name|void
name|abortTask
parameter_list|(
name|TaskAttemptContext
name|context
parameter_list|)
throws|throws
name|IOException
block|{
comment|// the API specifies that the task has not yet been committed, so there are
comment|// no uploads that need to be cancelled. just delete files on the local FS.
try|try
init|(
name|DurationInfo
name|d
init|=
operator|new
name|DurationInfo
argument_list|(
name|LOG
argument_list|,
literal|"Abort task %s"
argument_list|,
name|context
operator|.
name|getTaskAttemptID
argument_list|()
argument_list|)
init|)
block|{
name|deleteTaskAttemptPathQuietly
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|deleteTaskWorkingPathQuietly
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|wrappedCommitter
operator|.
name|abortTask
argument_list|(
name|context
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"{}: exception when aborting task {}"
argument_list|,
name|getRole
argument_list|()
argument_list|,
name|context
operator|.
name|getTaskAttemptID
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
finally|finally
block|{
name|destroyThreadPool
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**    * Get the work path for a task.    * @param context job/task complex    * @param uuid UUID    * @return a path    * @throws IOException failure to build the path    */
end_comment

begin_function
DECL|method|taskAttemptWorkingPath (TaskAttemptContext context, String uuid)
specifier|private
specifier|static
name|Path
name|taskAttemptWorkingPath
parameter_list|(
name|TaskAttemptContext
name|context
parameter_list|,
name|String
name|uuid
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|getTaskAttemptPath
argument_list|(
name|context
argument_list|,
name|Paths
operator|.
name|getLocalTaskAttemptTempDir
argument_list|(
name|context
operator|.
name|getConfiguration
argument_list|()
argument_list|,
name|uuid
argument_list|,
name|context
operator|.
name|getTaskAttemptID
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Delete the working path of a task; no-op if there is none, that    * is: this is a job.    * @param context job/task context    */
end_comment

begin_function
DECL|method|deleteTaskWorkingPathQuietly (JobContext context)
specifier|protected
name|void
name|deleteTaskWorkingPathQuietly
parameter_list|(
name|JobContext
name|context
parameter_list|)
block|{
name|ignoreIOExceptions
argument_list|(
name|LOG
argument_list|,
literal|"Delete working path"
argument_list|,
literal|""
argument_list|,
parameter_list|()
lambda|->
block|{
name|Path
name|path
init|=
name|buildWorkPath
argument_list|(
name|context
argument_list|,
name|getUUID
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|path
operator|!=
literal|null
condition|)
block|{
name|deleteQuietly
argument_list|(
name|path
operator|.
name|getFileSystem
argument_list|(
name|getConf
argument_list|()
argument_list|)
argument_list|,
name|path
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**    * Get the key of the destination "directory" of the job/task.    * @param context job context    * @return key to write to    */
end_comment

begin_function
DECL|method|getS3KeyPrefix (JobContext context)
specifier|private
name|String
name|getS3KeyPrefix
parameter_list|(
name|JobContext
name|context
parameter_list|)
block|{
return|return
name|s3KeyPrefix
return|;
block|}
end_function

begin_comment
comment|/**    * A UUID for this upload, as calculated with.    * {@link #getUploadUUID(Configuration, String)}    * @return the UUID for files    */
end_comment

begin_function
DECL|method|getUUID ()
specifier|protected
name|String
name|getUUID
parameter_list|()
block|{
return|return
name|uuid
return|;
block|}
end_function

begin_comment
comment|/**    * Returns the {@link ConflictResolution} mode for this commit.    *    * @param context the JobContext for this commit    * @param fsConf filesystem config    * @return the ConflictResolution mode    */
end_comment

begin_function
DECL|method|getConflictResolutionMode ( JobContext context, Configuration fsConf)
specifier|public
specifier|final
name|ConflictResolution
name|getConflictResolutionMode
parameter_list|(
name|JobContext
name|context
parameter_list|,
name|Configuration
name|fsConf
parameter_list|)
block|{
if|if
condition|(
name|conflictResolution
operator|==
literal|null
condition|)
block|{
name|this
operator|.
name|conflictResolution
operator|=
name|ConflictResolution
operator|.
name|valueOf
argument_list|(
name|getConfictModeOption
argument_list|(
name|context
argument_list|,
name|fsConf
argument_list|,
name|DEFAULT_CONFLICT_MODE
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|conflictResolution
return|;
block|}
end_function

begin_comment
comment|/**    * Generate a {@link PathExistsException} because the destination exists.    * Lists some of the child entries first, to help diagnose the problem.    * @param path path which exists    * @param description description (usually task/job ID)    * @return an exception to throw    */
end_comment

begin_function
DECL|method|failDestinationExists (final Path path, final String description)
specifier|protected
name|PathExistsException
name|failDestinationExists
parameter_list|(
specifier|final
name|Path
name|path
parameter_list|,
specifier|final
name|String
name|description
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"{}: Failing commit by job {} to write"
operator|+
literal|" to existing output path {}."
argument_list|,
name|description
argument_list|,
name|getJobContext
argument_list|()
operator|.
name|getJobID
argument_list|()
argument_list|,
name|path
argument_list|)
expr_stmt|;
comment|// List the first 10 descendants, to give some details
comment|// on what is wrong but not overload things if there are many files.
try|try
block|{
name|int
name|limit
init|=
literal|10
decl_stmt|;
name|RemoteIterator
argument_list|<
name|LocatedFileStatus
argument_list|>
name|lf
init|=
name|getDestFS
argument_list|()
operator|.
name|listFiles
argument_list|(
name|path
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Partial Directory listing"
argument_list|)
expr_stmt|;
while|while
condition|(
name|limit
operator|>
literal|0
operator|&&
name|lf
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|limit
operator|--
expr_stmt|;
name|LocatedFileStatus
name|status
init|=
name|lf
operator|.
name|next
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"{}: {}"
argument_list|,
name|status
operator|.
name|getPath
argument_list|()
argument_list|,
name|status
operator|.
name|isDirectory
argument_list|()
condition|?
literal|" dir"
else|:
operator|(
literal|"file size "
operator|+
name|status
operator|.
name|getLen
argument_list|()
operator|+
literal|" bytes"
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Discarding exception raised when listing {}: "
operator|+
name|e
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"stack trace "
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|PathExistsException
argument_list|(
name|path
operator|.
name|toString
argument_list|()
argument_list|,
name|description
operator|+
literal|": "
operator|+
name|InternalCommitterConstants
operator|.
name|E_DEST_EXISTS
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Get the conflict mode option string.    * @param context context with the config    * @param fsConf filesystem config    * @param defVal default value.    * @return the trimmed configuration option, upper case.    */
end_comment

begin_function
DECL|method|getConfictModeOption (JobContext context, Configuration fsConf, String defVal)
specifier|public
specifier|static
name|String
name|getConfictModeOption
parameter_list|(
name|JobContext
name|context
parameter_list|,
name|Configuration
name|fsConf
parameter_list|,
name|String
name|defVal
parameter_list|)
block|{
return|return
name|getConfigurationOption
argument_list|(
name|context
argument_list|,
name|fsConf
argument_list|,
name|FS_S3A_COMMITTER_STAGING_CONFLICT_MODE
argument_list|,
name|defVal
argument_list|)
operator|.
name|toUpperCase
argument_list|(
name|Locale
operator|.
name|ENGLISH
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Pre-commit actions for a job.    * Loads all the pending files to verify they can be loaded    * and parsed.    * @param context job context    * @param pending pending commits    * @throws IOException any failure    */
end_comment

begin_function
annotation|@
name|Override
DECL|method|preCommitJob ( final JobContext context, final ActiveCommit pending)
specifier|public
name|void
name|preCommitJob
parameter_list|(
specifier|final
name|JobContext
name|context
parameter_list|,
specifier|final
name|ActiveCommit
name|pending
parameter_list|)
throws|throws
name|IOException
block|{
comment|// see if the files can be loaded.
name|precommitCheckPendingFiles
argument_list|(
name|context
argument_list|,
name|pending
argument_list|)
expr_stmt|;
block|}
end_function

unit|}
end_unit

