begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.fs.s3a.s3guard
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|s3guard
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileNotFoundException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URI
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Objects
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|stream
operator|.
name|Collectors
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|annotation
operator|.
name|Nullable
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceStability
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|Retries
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|Retries
operator|.
name|RetryTranslated
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|S3AFileStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|S3AInstrumentation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|ReflectionUtils
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|Constants
operator|.
name|DEFAULT_METADATASTORE_METADATA_TTL
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|Constants
operator|.
name|METADATASTORE_METADATA_TTL
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|Constants
operator|.
name|S3_METADATA_STORE_IMPL
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|Statistic
operator|.
name|S3GUARD_METADATASTORE_PUT_PATH_LATENCY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|Statistic
operator|.
name|S3GUARD_METADATASTORE_PUT_PATH_REQUEST
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|S3AUtils
operator|.
name|createUploadFileStatus
import|;
end_import

begin_comment
comment|/**  * Logic for integrating MetadataStore with S3A.  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
annotation|@
name|InterfaceStability
operator|.
name|Unstable
DECL|class|S3Guard
specifier|public
specifier|final
class|class
name|S3Guard
block|{
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|S3Guard
operator|.
name|class
argument_list|)
decl_stmt|;
annotation|@
name|InterfaceAudience
operator|.
name|Private
annotation|@
name|InterfaceStability
operator|.
name|Unstable
annotation|@
name|VisibleForTesting
DECL|field|S3GUARD_DDB_CLIENT_FACTORY_IMPL
specifier|public
specifier|static
specifier|final
name|String
name|S3GUARD_DDB_CLIENT_FACTORY_IMPL
init|=
literal|"fs.s3a.s3guard.ddb.client.factory.impl"
decl_stmt|;
specifier|static
specifier|final
name|Class
argument_list|<
name|?
extends|extends
name|DynamoDBClientFactory
argument_list|>
DECL|field|S3GUARD_DDB_CLIENT_FACTORY_IMPL_DEFAULT
name|S3GUARD_DDB_CLIENT_FACTORY_IMPL_DEFAULT
init|=
name|DynamoDBClientFactory
operator|.
name|DefaultDynamoDBClientFactory
operator|.
name|class
decl_stmt|;
DECL|field|EMPTY_LISTING
specifier|private
specifier|static
specifier|final
name|S3AFileStatus
index|[]
name|EMPTY_LISTING
init|=
operator|new
name|S3AFileStatus
index|[
literal|0
index|]
decl_stmt|;
comment|// Utility class.  All static functions.
DECL|method|S3Guard ()
specifier|private
name|S3Guard
parameter_list|()
block|{ }
comment|/* Utility functions. */
comment|/**    * Create a new instance of the configured MetadataStore.    * The returned MetadataStore will have been initialized via    * {@link MetadataStore#initialize(FileSystem)} by this function before    * returning it.  Callers must clean up by calling    * {@link MetadataStore#close()} when done using the MetadataStore.    *    * @param fs  FileSystem whose Configuration specifies which    *            implementation to use.    * @return Reference to new MetadataStore.    * @throws IOException if the metadata store cannot be instantiated    */
annotation|@
name|Retries
operator|.
name|OnceTranslated
DECL|method|getMetadataStore (FileSystem fs)
specifier|public
specifier|static
name|MetadataStore
name|getMetadataStore
parameter_list|(
name|FileSystem
name|fs
parameter_list|)
throws|throws
name|IOException
block|{
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|fs
argument_list|)
expr_stmt|;
name|Configuration
name|conf
init|=
name|fs
operator|.
name|getConf
argument_list|()
decl_stmt|;
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|MetadataStore
name|msInstance
decl_stmt|;
try|try
block|{
name|Class
argument_list|<
name|?
extends|extends
name|MetadataStore
argument_list|>
name|msClass
init|=
name|getMetadataStoreClass
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|msInstance
operator|=
name|ReflectionUtils
operator|.
name|newInstance
argument_list|(
name|msClass
argument_list|,
name|conf
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Using {} metadata store for {} filesystem"
argument_list|,
name|msClass
operator|.
name|getSimpleName
argument_list|()
argument_list|,
name|fs
operator|.
name|getScheme
argument_list|()
argument_list|)
expr_stmt|;
name|msInstance
operator|.
name|initialize
argument_list|(
name|fs
argument_list|)
expr_stmt|;
return|return
name|msInstance
return|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|e
parameter_list|)
block|{
comment|// Don't log this exception as it means the table doesn't exist yet;
comment|// rely on callers to catch and treat specially
throw|throw
name|e
throw|;
block|}
catch|catch
parameter_list|(
name|RuntimeException
decl||
name|IOException
name|e
parameter_list|)
block|{
name|String
name|message
init|=
literal|"Failed to instantiate metadata store "
operator|+
name|conf
operator|.
name|get
argument_list|(
name|S3_METADATA_STORE_IMPL
argument_list|)
operator|+
literal|" defined in "
operator|+
name|S3_METADATA_STORE_IMPL
operator|+
literal|": "
operator|+
name|e
decl_stmt|;
name|LOG
operator|.
name|error
argument_list|(
name|message
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|instanceof
name|IOException
condition|)
block|{
throw|throw
name|e
throw|;
block|}
else|else
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|message
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
block|}
DECL|method|getMetadataStoreClass ( Configuration conf)
specifier|static
name|Class
argument_list|<
name|?
extends|extends
name|MetadataStore
argument_list|>
name|getMetadataStoreClass
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
if|if
condition|(
name|conf
operator|==
literal|null
condition|)
block|{
return|return
name|NullMetadataStore
operator|.
name|class
return|;
block|}
if|if
condition|(
name|conf
operator|.
name|get
argument_list|(
name|S3_METADATA_STORE_IMPL
argument_list|)
operator|!=
literal|null
operator|&&
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Metastore option source {}"
argument_list|,
operator|(
name|Object
operator|)
name|conf
operator|.
name|getPropertySources
argument_list|(
name|S3_METADATA_STORE_IMPL
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Class
argument_list|<
name|?
extends|extends
name|MetadataStore
argument_list|>
name|aClass
init|=
name|conf
operator|.
name|getClass
argument_list|(
name|S3_METADATA_STORE_IMPL
argument_list|,
name|NullMetadataStore
operator|.
name|class
argument_list|,
name|MetadataStore
operator|.
name|class
argument_list|)
decl_stmt|;
return|return
name|aClass
return|;
block|}
comment|/**    * Helper function which puts a given S3AFileStatus into the MetadataStore and    * returns the same S3AFileStatus. Instrumentation monitors the put operation.    * @param ms MetadataStore to {@code put()} into.    * @param status status to store    * @param instrumentation instrumentation of the s3a file system    * @param timeProvider Time provider to use when writing entries    * @return The same status as passed in    * @throws IOException if metadata store update failed    */
annotation|@
name|RetryTranslated
DECL|method|putAndReturn (MetadataStore ms, S3AFileStatus status, S3AInstrumentation instrumentation, ITtlTimeProvider timeProvider)
specifier|public
specifier|static
name|S3AFileStatus
name|putAndReturn
parameter_list|(
name|MetadataStore
name|ms
parameter_list|,
name|S3AFileStatus
name|status
parameter_list|,
name|S3AInstrumentation
name|instrumentation
parameter_list|,
name|ITtlTimeProvider
name|timeProvider
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|putAndReturn
argument_list|(
name|ms
argument_list|,
name|status
argument_list|,
name|instrumentation
argument_list|,
name|timeProvider
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**    * Helper function which puts a given S3AFileStatus into the MetadataStore and    * returns the same S3AFileStatus. Instrumentation monitors the put operation.    * @param ms MetadataStore to {@code put()} into.    * @param status status to store    * @param instrumentation instrumentation of the s3a file system    * @param timeProvider Time provider to use when writing entries    * @param operationState possibly-null metastore state tracker.    * @return The same status as passed in    * @throws IOException if metadata store update failed    */
annotation|@
name|RetryTranslated
DECL|method|putAndReturn ( final MetadataStore ms, final S3AFileStatus status, final S3AInstrumentation instrumentation, final ITtlTimeProvider timeProvider, @Nullable final BulkOperationState operationState)
specifier|public
specifier|static
name|S3AFileStatus
name|putAndReturn
parameter_list|(
specifier|final
name|MetadataStore
name|ms
parameter_list|,
specifier|final
name|S3AFileStatus
name|status
parameter_list|,
specifier|final
name|S3AInstrumentation
name|instrumentation
parameter_list|,
specifier|final
name|ITtlTimeProvider
name|timeProvider
parameter_list|,
annotation|@
name|Nullable
specifier|final
name|BulkOperationState
name|operationState
parameter_list|)
throws|throws
name|IOException
block|{
name|long
name|startTimeNano
init|=
name|System
operator|.
name|nanoTime
argument_list|()
decl_stmt|;
try|try
block|{
name|putWithTtl
argument_list|(
name|ms
argument_list|,
operator|new
name|PathMetadata
argument_list|(
name|status
argument_list|)
argument_list|,
name|timeProvider
argument_list|,
name|operationState
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|instrumentation
operator|.
name|addValueToQuantiles
argument_list|(
name|S3GUARD_METADATASTORE_PUT_PATH_LATENCY
argument_list|,
operator|(
name|System
operator|.
name|nanoTime
argument_list|()
operator|-
name|startTimeNano
operator|)
argument_list|)
expr_stmt|;
name|instrumentation
operator|.
name|incrementCounter
argument_list|(
name|S3GUARD_METADATASTORE_PUT_PATH_REQUEST
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
comment|/**    * Initiate a bulk write and create an operation state for it.    * This may then be passed into put operations.    * @param metastore store    * @param operation the type of the operation.    * @param path path under which updates will be explicitly put.    * @return a store-specific state to pass into the put operations, or null    * @throws IOException failure    */
DECL|method|initiateBulkWrite ( @ullable final MetadataStore metastore, final BulkOperationState.OperationType operation, final Path path)
specifier|public
specifier|static
name|BulkOperationState
name|initiateBulkWrite
parameter_list|(
annotation|@
name|Nullable
specifier|final
name|MetadataStore
name|metastore
parameter_list|,
specifier|final
name|BulkOperationState
operator|.
name|OperationType
name|operation
parameter_list|,
specifier|final
name|Path
name|path
parameter_list|)
throws|throws
name|IOException
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|operation
operator|!=
name|BulkOperationState
operator|.
name|OperationType
operator|.
name|Rename
argument_list|,
literal|"Rename operations cannot be started through initiateBulkWrite"
argument_list|)
expr_stmt|;
if|if
condition|(
name|metastore
operator|==
literal|null
operator|||
name|isNullMetadataStore
argument_list|(
name|metastore
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
else|else
block|{
return|return
name|metastore
operator|.
name|initiateBulkWrite
argument_list|(
name|operation
argument_list|,
name|path
argument_list|)
return|;
block|}
block|}
comment|/**    * Convert the data of a directory listing to an array of {@link FileStatus}    * entries. Tombstones are filtered out at this point. If the listing is null    * an empty array is returned.    * @param dirMeta directory listing -may be null    * @return a possibly-empty array of file status entries    */
DECL|method|dirMetaToStatuses (DirListingMetadata dirMeta)
specifier|public
specifier|static
name|S3AFileStatus
index|[]
name|dirMetaToStatuses
parameter_list|(
name|DirListingMetadata
name|dirMeta
parameter_list|)
block|{
if|if
condition|(
name|dirMeta
operator|==
literal|null
condition|)
block|{
return|return
name|EMPTY_LISTING
return|;
block|}
name|Collection
argument_list|<
name|PathMetadata
argument_list|>
name|listing
init|=
name|dirMeta
operator|.
name|getListing
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|FileStatus
argument_list|>
name|statuses
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|PathMetadata
name|pm
range|:
name|listing
control|)
block|{
if|if
condition|(
operator|!
name|pm
operator|.
name|isDeleted
argument_list|()
condition|)
block|{
name|statuses
operator|.
name|add
argument_list|(
name|pm
operator|.
name|getFileStatus
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|statuses
operator|.
name|toArray
argument_list|(
operator|new
name|S3AFileStatus
index|[
literal|0
index|]
argument_list|)
return|;
block|}
comment|/**    * Given directory listing metadata from both the backing store and the    * MetadataStore, merge the two sources of truth to create a consistent    * view of the current directory contents, which can be returned to clients.    *    * Also update the MetadataStore to reflect the resulting directory listing.    *    * In not authoritative case: update file metadata if mod_time in listing    * of a file is greater then what is currently in the ms    *    * @param ms MetadataStore to use.    * @param path path to directory    * @param backingStatuses Directory listing from the backing store.    * @param dirMeta  Directory listing from MetadataStore.  May be null.    * @param isAuthoritative State of authoritative mode    * @param timeProvider Time provider to use when updating entries    * @return Final result of directory listing.    * @throws IOException if metadata store update failed    */
DECL|method|dirListingUnion (MetadataStore ms, Path path, List<S3AFileStatus> backingStatuses, DirListingMetadata dirMeta, boolean isAuthoritative, ITtlTimeProvider timeProvider)
specifier|public
specifier|static
name|FileStatus
index|[]
name|dirListingUnion
parameter_list|(
name|MetadataStore
name|ms
parameter_list|,
name|Path
name|path
parameter_list|,
name|List
argument_list|<
name|S3AFileStatus
argument_list|>
name|backingStatuses
parameter_list|,
name|DirListingMetadata
name|dirMeta
parameter_list|,
name|boolean
name|isAuthoritative
parameter_list|,
name|ITtlTimeProvider
name|timeProvider
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Fast-path for NullMetadataStore
if|if
condition|(
name|isNullMetadataStore
argument_list|(
name|ms
argument_list|)
condition|)
block|{
return|return
name|backingStatuses
operator|.
name|toArray
argument_list|(
operator|new
name|FileStatus
index|[
name|backingStatuses
operator|.
name|size
argument_list|()
index|]
argument_list|)
return|;
block|}
name|assertQualified
argument_list|(
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|dirMeta
operator|==
literal|null
condition|)
block|{
comment|// The metadataStore had zero state for this directory
name|dirMeta
operator|=
operator|new
name|DirListingMetadata
argument_list|(
name|path
argument_list|,
name|DirListingMetadata
operator|.
name|EMPTY_DIR
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
name|Set
argument_list|<
name|Path
argument_list|>
name|deleted
init|=
name|dirMeta
operator|.
name|listTombstones
argument_list|()
decl_stmt|;
comment|// Since we treat the MetadataStore as a "fresher" or "consistent" view
comment|// of metadata, we always use its metadata first.
comment|// Since the authoritative case is already handled outside this function,
comment|// we will basically start with the set of directory entries in the
comment|// DirListingMetadata, and add any that only exist in the backingStatuses.
name|boolean
name|changed
init|=
literal|false
decl_stmt|;
specifier|final
name|Map
argument_list|<
name|Path
argument_list|,
name|FileStatus
argument_list|>
name|dirMetaMap
init|=
name|dirMeta
operator|.
name|getListing
argument_list|()
operator|.
name|stream
argument_list|()
operator|.
name|collect
argument_list|(
name|Collectors
operator|.
name|toMap
argument_list|(
name|pm
lambda|->
name|pm
operator|.
name|getFileStatus
argument_list|()
operator|.
name|getPath
argument_list|()
argument_list|,
name|PathMetadata
operator|::
name|getFileStatus
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|S3AFileStatus
name|s
range|:
name|backingStatuses
control|)
block|{
if|if
condition|(
name|deleted
operator|.
name|contains
argument_list|(
name|s
operator|.
name|getPath
argument_list|()
argument_list|)
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
operator|!
name|isAuthoritative
condition|)
block|{
name|FileStatus
name|status
init|=
name|dirMetaMap
operator|.
name|get
argument_list|(
name|s
operator|.
name|getPath
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|status
operator|!=
literal|null
operator|&&
name|s
operator|.
name|getModificationTime
argument_list|()
operator|>
name|status
operator|.
name|getModificationTime
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Update ms with newer metadata of: {}"
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|S3Guard
operator|.
name|putWithTtl
argument_list|(
name|ms
argument_list|,
operator|new
name|PathMetadata
argument_list|(
name|s
argument_list|)
argument_list|,
name|timeProvider
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Minor race condition here.  Multiple threads could add to this
comment|// mutable DirListingMetadata.  Since it is backed by a
comment|// ConcurrentHashMap, the last put() wins.
comment|// More concerning is two threads racing on listStatus() and delete().
comment|// Any FileSystem has similar race conditions, but we could persist
comment|// a stale entry longer.  We could expose an atomic
comment|// DirListingMetadata#putIfNotPresent()
name|boolean
name|updated
init|=
name|dirMeta
operator|.
name|put
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|changed
operator|=
name|changed
operator|||
name|updated
expr_stmt|;
block|}
comment|// If dirMeta is not authoritative, but isAuthoritative is true the
comment|// directory metadata should be updated. Treat it as a change.
name|changed
operator|=
name|changed
operator|||
operator|(
operator|!
name|dirMeta
operator|.
name|isAuthoritative
argument_list|()
operator|&&
name|isAuthoritative
operator|)
expr_stmt|;
if|if
condition|(
name|changed
operator|&&
name|isAuthoritative
condition|)
block|{
name|dirMeta
operator|.
name|setAuthoritative
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|// This is the full directory contents
name|S3Guard
operator|.
name|putWithTtl
argument_list|(
name|ms
argument_list|,
name|dirMeta
argument_list|,
name|timeProvider
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
return|return
name|dirMetaToStatuses
argument_list|(
name|dirMeta
argument_list|)
return|;
block|}
comment|/**    * Although NullMetadataStore does nothing, callers may wish to avoid work    * (fast path) when the NullMetadataStore is in use.    * @param ms The MetadataStore to test    * @return true iff the MetadataStore is the null, or no-op, implementation.    */
DECL|method|isNullMetadataStore (MetadataStore ms)
specifier|public
specifier|static
name|boolean
name|isNullMetadataStore
parameter_list|(
name|MetadataStore
name|ms
parameter_list|)
block|{
return|return
operator|(
name|ms
operator|instanceof
name|NullMetadataStore
operator|)
return|;
block|}
comment|/**    * Update MetadataStore to reflect creation of the given  directories.    *    * If an IOException is raised while trying to update the entry, this    * operation catches the exception, swallows it and returns.    *    * @deprecated this is no longer called by {@code S3AFilesystem.innerMkDirs}.    * See: HADOOP-15079 (January 2018).    * It is currently retained because of its discussion in the method on    * atomicity and in case we need to reinstate it or adapt the current    * process of directory marker creation.    * But it is not being tested and so may age with time...consider    * deleting it in future if it's clear there's no need for it.    * @param ms    MetadataStore to update.    * @param dirs  null, or an ordered list of directories from leaf to root.    *              E.g. if /a/ exists, and  mkdirs(/a/b/c/d) is called, this    *              list will contain [/a/b/c/d, /a/b/c, /a/b].   /a/b/c/d is    *              an empty, dir, and the other dirs only contain their child    *              dir.    * @param owner Hadoop user name.    * @param authoritative Whether to mark new directories as authoritative.    * @param timeProvider Time provider.    */
annotation|@
name|Deprecated
annotation|@
name|Retries
operator|.
name|OnceExceptionsSwallowed
DECL|method|makeDirsOrdered (MetadataStore ms, List<Path> dirs, String owner, boolean authoritative, ITtlTimeProvider timeProvider)
specifier|public
specifier|static
name|void
name|makeDirsOrdered
parameter_list|(
name|MetadataStore
name|ms
parameter_list|,
name|List
argument_list|<
name|Path
argument_list|>
name|dirs
parameter_list|,
name|String
name|owner
parameter_list|,
name|boolean
name|authoritative
parameter_list|,
name|ITtlTimeProvider
name|timeProvider
parameter_list|)
block|{
if|if
condition|(
name|dirs
operator|==
literal|null
condition|)
block|{
return|return;
block|}
comment|/* We discussed atomicity of this implementation.      * The concern is that multiple clients could race to write different      * cached directories to the MetadataStore.  Two solutions are proposed:      * 1. Move mkdirs() into MetadataStore interface and let implementations      *    ensure they are atomic.      * 2. Specify that the semantics of MetadataStore#putListStatus() is      *    always additive,  That is, if MetadataStore has listStatus() state      *    for /a/b that contains [/a/b/file0, /a/b/file1], and we then call      *    putListStatus(/a/b -> [/a/b/file2, /a/b/file3], isAuthoritative=true),      *    then we will end up with final state of      *    [/a/b/file0, /a/b/file1, /a/b/file2, /a/b/file3], isAuthoritative =      *    true      */
name|S3AFileStatus
name|prevStatus
init|=
literal|null
decl_stmt|;
comment|// Use new batched put to reduce round trips.
name|List
argument_list|<
name|PathMetadata
argument_list|>
name|pathMetas
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|dirs
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
try|try
block|{
comment|// Iterate from leaf to root
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|dirs
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|boolean
name|isLeaf
init|=
operator|(
name|prevStatus
operator|==
literal|null
operator|)
decl_stmt|;
name|Path
name|f
init|=
name|dirs
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|assertQualified
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|S3AFileStatus
name|status
init|=
name|createUploadFileStatus
argument_list|(
name|f
argument_list|,
literal|true
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|owner
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
decl_stmt|;
comment|// We only need to put a DirListingMetadata if we are setting
comment|// authoritative bit
name|DirListingMetadata
name|dirMeta
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|authoritative
condition|)
block|{
name|Collection
argument_list|<
name|PathMetadata
argument_list|>
name|children
decl_stmt|;
if|if
condition|(
name|isLeaf
condition|)
block|{
name|children
operator|=
name|DirListingMetadata
operator|.
name|EMPTY_DIR
expr_stmt|;
block|}
else|else
block|{
name|children
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|children
operator|.
name|add
argument_list|(
operator|new
name|PathMetadata
argument_list|(
name|prevStatus
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|dirMeta
operator|=
operator|new
name|DirListingMetadata
argument_list|(
name|f
argument_list|,
name|children
argument_list|,
name|authoritative
argument_list|)
expr_stmt|;
name|S3Guard
operator|.
name|putWithTtl
argument_list|(
name|ms
argument_list|,
name|dirMeta
argument_list|,
name|timeProvider
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
name|pathMetas
operator|.
name|add
argument_list|(
operator|new
name|PathMetadata
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
name|prevStatus
operator|=
name|status
expr_stmt|;
block|}
comment|// Batched put
name|S3Guard
operator|.
name|putWithTtl
argument_list|(
name|ms
argument_list|,
name|pathMetas
argument_list|,
name|timeProvider
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"MetadataStore#put() failure:"
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Helper function that records the move of directory paths, adding    * resulting metadata to the supplied lists.    * Does not store in MetadataStore.    * @param ms  MetadataStore, used to make this a no-op, when it is    *            NullMetadataStore.    * @param srcPaths stores the source path here    * @param dstMetas stores destination metadata here    * @param srcPath  source path to store    * @param dstPath  destination path to store    * @param owner file owner to use in created records    */
DECL|method|addMoveDir (MetadataStore ms, Collection<Path> srcPaths, Collection<PathMetadata> dstMetas, Path srcPath, Path dstPath, String owner)
specifier|public
specifier|static
name|void
name|addMoveDir
parameter_list|(
name|MetadataStore
name|ms
parameter_list|,
name|Collection
argument_list|<
name|Path
argument_list|>
name|srcPaths
parameter_list|,
name|Collection
argument_list|<
name|PathMetadata
argument_list|>
name|dstMetas
parameter_list|,
name|Path
name|srcPath
parameter_list|,
name|Path
name|dstPath
parameter_list|,
name|String
name|owner
parameter_list|)
block|{
if|if
condition|(
name|isNullMetadataStore
argument_list|(
name|ms
argument_list|)
condition|)
block|{
return|return;
block|}
name|assertQualified
argument_list|(
name|srcPath
argument_list|,
name|dstPath
argument_list|)
expr_stmt|;
name|S3AFileStatus
name|dstStatus
init|=
name|createUploadFileStatus
argument_list|(
name|dstPath
argument_list|,
literal|true
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|owner
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|addMoveStatus
argument_list|(
name|srcPaths
argument_list|,
name|dstMetas
argument_list|,
name|srcPath
argument_list|,
name|dstStatus
argument_list|)
expr_stmt|;
block|}
comment|/**    * Like {@link #addMoveDir(MetadataStore, Collection, Collection, Path,    * Path, String)} (), but for files.    * @param ms  MetadataStore, used to make this a no-op, when it is    *            NullMetadataStore.    * @param srcPaths stores the source path here    * @param dstMetas stores destination metadata here    * @param srcPath  source path to store    * @param dstPath  destination path to store    * @param size length of file moved    * @param blockSize  blocksize to associate with destination file    * @param owner file owner to use in created records    * @param eTag the s3 object eTag of file moved    * @param versionId the s3 object versionId of file moved    */
DECL|method|addMoveFile (MetadataStore ms, Collection<Path> srcPaths, Collection<PathMetadata> dstMetas, Path srcPath, Path dstPath, long size, long blockSize, String owner, String eTag, String versionId)
specifier|public
specifier|static
name|void
name|addMoveFile
parameter_list|(
name|MetadataStore
name|ms
parameter_list|,
name|Collection
argument_list|<
name|Path
argument_list|>
name|srcPaths
parameter_list|,
name|Collection
argument_list|<
name|PathMetadata
argument_list|>
name|dstMetas
parameter_list|,
name|Path
name|srcPath
parameter_list|,
name|Path
name|dstPath
parameter_list|,
name|long
name|size
parameter_list|,
name|long
name|blockSize
parameter_list|,
name|String
name|owner
parameter_list|,
name|String
name|eTag
parameter_list|,
name|String
name|versionId
parameter_list|)
block|{
if|if
condition|(
name|isNullMetadataStore
argument_list|(
name|ms
argument_list|)
condition|)
block|{
return|return;
block|}
name|assertQualified
argument_list|(
name|srcPath
argument_list|,
name|dstPath
argument_list|)
expr_stmt|;
name|S3AFileStatus
name|dstStatus
init|=
name|createUploadFileStatus
argument_list|(
name|dstPath
argument_list|,
literal|false
argument_list|,
name|size
argument_list|,
name|blockSize
argument_list|,
name|owner
argument_list|,
name|eTag
argument_list|,
name|versionId
argument_list|)
decl_stmt|;
name|addMoveStatus
argument_list|(
name|srcPaths
argument_list|,
name|dstMetas
argument_list|,
name|srcPath
argument_list|,
name|dstStatus
argument_list|)
expr_stmt|;
block|}
comment|/**    * Helper method that records the move of all ancestors of a path.    *    * In S3A, an optimization is to delete unnecessary fake directory objects if    * the directory is non-empty. In that case, for a nested child to move, S3A    * is not listing and thus moving all its ancestors (up to source root). So we    * take care of those inferred directories of this path explicitly.    *    * As {@link #addMoveFile} and {@link #addMoveDir}, this method adds resulting    * metadata to the supplied lists. It does not update the MetadataStore.    *    * @param ms MetadataStore, no-op if it is NullMetadataStore    * @param srcPaths stores the source path here    * @param dstMetas stores destination metadata here    * @param srcRoot source root up to which (exclusive) should we add ancestors    * @param srcPath source path of the child to add ancestors    * @param dstPath destination path of the child to add ancestors    * @param owner Hadoop user name    */
DECL|method|addMoveAncestors (MetadataStore ms, Collection<Path> srcPaths, Collection<PathMetadata> dstMetas, Path srcRoot, Path srcPath, Path dstPath, String owner)
specifier|public
specifier|static
name|void
name|addMoveAncestors
parameter_list|(
name|MetadataStore
name|ms
parameter_list|,
name|Collection
argument_list|<
name|Path
argument_list|>
name|srcPaths
parameter_list|,
name|Collection
argument_list|<
name|PathMetadata
argument_list|>
name|dstMetas
parameter_list|,
name|Path
name|srcRoot
parameter_list|,
name|Path
name|srcPath
parameter_list|,
name|Path
name|dstPath
parameter_list|,
name|String
name|owner
parameter_list|)
block|{
if|if
condition|(
name|isNullMetadataStore
argument_list|(
name|ms
argument_list|)
condition|)
block|{
return|return;
block|}
name|assertQualified
argument_list|(
name|srcRoot
argument_list|,
name|srcPath
argument_list|,
name|dstPath
argument_list|)
expr_stmt|;
if|if
condition|(
name|srcPath
operator|.
name|equals
argument_list|(
name|srcRoot
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Skip moving ancestors of source root directory {}"
argument_list|,
name|srcRoot
argument_list|)
expr_stmt|;
return|return;
block|}
name|Path
name|parentSrc
init|=
name|srcPath
operator|.
name|getParent
argument_list|()
decl_stmt|;
name|Path
name|parentDst
init|=
name|dstPath
operator|.
name|getParent
argument_list|()
decl_stmt|;
while|while
condition|(
name|parentSrc
operator|!=
literal|null
operator|&&
operator|!
name|parentSrc
operator|.
name|isRoot
argument_list|()
operator|&&
operator|!
name|parentSrc
operator|.
name|equals
argument_list|(
name|srcRoot
argument_list|)
operator|&&
operator|!
name|srcPaths
operator|.
name|contains
argument_list|(
name|parentSrc
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Renaming non-listed parent {} to {}"
argument_list|,
name|parentSrc
argument_list|,
name|parentDst
argument_list|)
expr_stmt|;
name|S3Guard
operator|.
name|addMoveDir
argument_list|(
name|ms
argument_list|,
name|srcPaths
argument_list|,
name|dstMetas
argument_list|,
name|parentSrc
argument_list|,
name|parentDst
argument_list|,
name|owner
argument_list|)
expr_stmt|;
name|parentSrc
operator|=
name|parentSrc
operator|.
name|getParent
argument_list|()
expr_stmt|;
name|parentDst
operator|=
name|parentDst
operator|.
name|getParent
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * This adds all new ancestors of a path as directories.    * This forwards to    * {@link MetadataStore#addAncestors(Path, ITtlTimeProvider, BulkOperationState)}.    *<p>    * Originally it implemented the logic to probe for an add ancestors,    * but with the addition of a store-specific bulk operation state    * it became unworkable.    *    * @param metadataStore store    * @param qualifiedPath path to update    * @param operationState (nullable) operational state for a bulk update    * @throws IOException failure    */
annotation|@
name|Retries
operator|.
name|RetryTranslated
DECL|method|addAncestors ( final MetadataStore metadataStore, final Path qualifiedPath, final ITtlTimeProvider timeProvider, @Nullable final BulkOperationState operationState)
specifier|public
specifier|static
name|void
name|addAncestors
parameter_list|(
specifier|final
name|MetadataStore
name|metadataStore
parameter_list|,
specifier|final
name|Path
name|qualifiedPath
parameter_list|,
specifier|final
name|ITtlTimeProvider
name|timeProvider
parameter_list|,
annotation|@
name|Nullable
specifier|final
name|BulkOperationState
name|operationState
parameter_list|)
throws|throws
name|IOException
block|{
name|metadataStore
operator|.
name|addAncestors
argument_list|(
name|qualifiedPath
argument_list|,
name|timeProvider
argument_list|,
name|operationState
argument_list|)
expr_stmt|;
block|}
comment|/**    * Add the fact that a file was moved from a source path to a destination.    * @param srcPaths collection of source paths to update    * @param dstMetas collection of destination meta data entries to update.    * @param srcPath path of the source file.    * @param dstStatus status of the source file after it was copied.    */
DECL|method|addMoveStatus (Collection<Path> srcPaths, Collection<PathMetadata> dstMetas, Path srcPath, S3AFileStatus dstStatus)
specifier|private
specifier|static
name|void
name|addMoveStatus
parameter_list|(
name|Collection
argument_list|<
name|Path
argument_list|>
name|srcPaths
parameter_list|,
name|Collection
argument_list|<
name|PathMetadata
argument_list|>
name|dstMetas
parameter_list|,
name|Path
name|srcPath
parameter_list|,
name|S3AFileStatus
name|dstStatus
parameter_list|)
block|{
name|srcPaths
operator|.
name|add
argument_list|(
name|srcPath
argument_list|)
expr_stmt|;
name|dstMetas
operator|.
name|add
argument_list|(
operator|new
name|PathMetadata
argument_list|(
name|dstStatus
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Assert that the path is qualified with a host and scheme.    * @param p path to check    * @throws NullPointerException if either argument does not hold    */
DECL|method|assertQualified (Path p)
specifier|public
specifier|static
name|void
name|assertQualified
parameter_list|(
name|Path
name|p
parameter_list|)
block|{
name|URI
name|uri
init|=
name|p
operator|.
name|toUri
argument_list|()
decl_stmt|;
comment|// Paths must include bucket in case MetadataStore is shared between
comment|// multiple S3AFileSystem instances
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|uri
operator|.
name|getHost
argument_list|()
argument_list|,
literal|"Null host in "
operator|+
name|uri
argument_list|)
expr_stmt|;
comment|// This should never fail, but is retained for completeness.
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|uri
operator|.
name|getScheme
argument_list|()
argument_list|,
literal|"Null scheme in "
operator|+
name|uri
argument_list|)
expr_stmt|;
block|}
comment|/**    * Assert that all paths are valid.    * @param paths path to check    * @throws NullPointerException if either argument does not hold    */
DECL|method|assertQualified (Path...paths)
specifier|public
specifier|static
name|void
name|assertQualified
parameter_list|(
name|Path
modifier|...
name|paths
parameter_list|)
block|{
for|for
control|(
name|Path
name|path
range|:
name|paths
control|)
block|{
name|assertQualified
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Runtime implementation for TTL Time Provider interface.    */
DECL|class|TtlTimeProvider
specifier|public
specifier|static
class|class
name|TtlTimeProvider
implements|implements
name|ITtlTimeProvider
block|{
DECL|field|authoritativeDirTtl
specifier|private
name|long
name|authoritativeDirTtl
decl_stmt|;
DECL|method|TtlTimeProvider (long authoritativeDirTtl)
specifier|public
name|TtlTimeProvider
parameter_list|(
name|long
name|authoritativeDirTtl
parameter_list|)
block|{
name|this
operator|.
name|authoritativeDirTtl
operator|=
name|authoritativeDirTtl
expr_stmt|;
block|}
DECL|method|TtlTimeProvider (Configuration conf)
specifier|public
name|TtlTimeProvider
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
name|this
operator|.
name|authoritativeDirTtl
operator|=
name|conf
operator|.
name|getTimeDuration
argument_list|(
name|METADATASTORE_METADATA_TTL
argument_list|,
name|DEFAULT_METADATASTORE_METADATA_TTL
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getNow ()
specifier|public
name|long
name|getNow
parameter_list|()
block|{
return|return
name|System
operator|.
name|currentTimeMillis
argument_list|()
return|;
block|}
DECL|method|getMetadataTtl ()
annotation|@
name|Override
specifier|public
name|long
name|getMetadataTtl
parameter_list|()
block|{
return|return
name|authoritativeDirTtl
return|;
block|}
annotation|@
name|Override
DECL|method|equals (final Object o)
specifier|public
name|boolean
name|equals
parameter_list|(
specifier|final
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
name|this
operator|==
name|o
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
name|o
operator|==
literal|null
operator|||
name|getClass
argument_list|()
operator|!=
name|o
operator|.
name|getClass
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
specifier|final
name|TtlTimeProvider
name|that
init|=
operator|(
name|TtlTimeProvider
operator|)
name|o
decl_stmt|;
return|return
name|authoritativeDirTtl
operator|==
name|that
operator|.
name|authoritativeDirTtl
return|;
block|}
annotation|@
name|Override
DECL|method|hashCode ()
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|Objects
operator|.
name|hash
argument_list|(
name|authoritativeDirTtl
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
specifier|final
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|(
literal|"TtlTimeProvider{"
argument_list|)
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"authoritativeDirTtl="
argument_list|)
operator|.
name|append
argument_list|(
name|authoritativeDirTtl
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|" millis}"
argument_list|)
expr_stmt|;
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
comment|/**    * Put a directory entry, setting the updated timestamp of the    * directory and its children.    * @param ms metastore    * @param dirMeta directory    * @param timeProvider nullable time provider    * @throws IOException failure.    */
DECL|method|putWithTtl (MetadataStore ms, DirListingMetadata dirMeta, final ITtlTimeProvider timeProvider, @Nullable final BulkOperationState operationState)
specifier|public
specifier|static
name|void
name|putWithTtl
parameter_list|(
name|MetadataStore
name|ms
parameter_list|,
name|DirListingMetadata
name|dirMeta
parameter_list|,
specifier|final
name|ITtlTimeProvider
name|timeProvider
parameter_list|,
annotation|@
name|Nullable
specifier|final
name|BulkOperationState
name|operationState
parameter_list|)
throws|throws
name|IOException
block|{
name|long
name|now
init|=
name|timeProvider
operator|.
name|getNow
argument_list|()
decl_stmt|;
name|dirMeta
operator|.
name|setLastUpdated
argument_list|(
name|now
argument_list|)
expr_stmt|;
name|dirMeta
operator|.
name|getListing
argument_list|()
operator|.
name|forEach
argument_list|(
name|pm
lambda|->
name|pm
operator|.
name|setLastUpdated
argument_list|(
name|now
argument_list|)
argument_list|)
expr_stmt|;
name|ms
operator|.
name|put
argument_list|(
name|dirMeta
argument_list|,
name|operationState
argument_list|)
expr_stmt|;
block|}
comment|/**    * Put an entry, using the time provider to set its timestamp.    * @param ms metastore    * @param fileMeta entry to write    * @param timeProvider nullable time provider    * @param operationState nullable state for a bulk update    * @throws IOException failure.    */
DECL|method|putWithTtl (MetadataStore ms, PathMetadata fileMeta, @Nullable ITtlTimeProvider timeProvider, @Nullable final BulkOperationState operationState)
specifier|public
specifier|static
name|void
name|putWithTtl
parameter_list|(
name|MetadataStore
name|ms
parameter_list|,
name|PathMetadata
name|fileMeta
parameter_list|,
annotation|@
name|Nullable
name|ITtlTimeProvider
name|timeProvider
parameter_list|,
annotation|@
name|Nullable
specifier|final
name|BulkOperationState
name|operationState
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|timeProvider
operator|!=
literal|null
condition|)
block|{
name|fileMeta
operator|.
name|setLastUpdated
argument_list|(
name|timeProvider
operator|.
name|getNow
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"timeProvider is null, put {} without setting last_updated"
argument_list|,
name|fileMeta
argument_list|)
expr_stmt|;
block|}
name|ms
operator|.
name|put
argument_list|(
name|fileMeta
argument_list|,
name|operationState
argument_list|)
expr_stmt|;
block|}
comment|/**    * Put entries, using the time provider to set their timestamp.    * @param ms metastore    * @param fileMetas file metadata entries.    * @param timeProvider nullable time provider    * @param operationState nullable state for a bulk update    * @throws IOException failure.    */
DECL|method|putWithTtl (MetadataStore ms, Collection<? extends PathMetadata> fileMetas, @Nullable ITtlTimeProvider timeProvider, @Nullable final BulkOperationState operationState)
specifier|public
specifier|static
name|void
name|putWithTtl
parameter_list|(
name|MetadataStore
name|ms
parameter_list|,
name|Collection
argument_list|<
name|?
extends|extends
name|PathMetadata
argument_list|>
name|fileMetas
parameter_list|,
annotation|@
name|Nullable
name|ITtlTimeProvider
name|timeProvider
parameter_list|,
annotation|@
name|Nullable
specifier|final
name|BulkOperationState
name|operationState
parameter_list|)
throws|throws
name|IOException
block|{
name|patchLastUpdated
argument_list|(
name|fileMetas
argument_list|,
name|timeProvider
argument_list|)
expr_stmt|;
name|ms
operator|.
name|put
argument_list|(
name|fileMetas
argument_list|,
name|operationState
argument_list|)
expr_stmt|;
block|}
comment|/**    * Patch any collection of metadata entries with the timestamp    * of a time provider.    * This<i>MUST</i> be used when creating new entries for directories.    * @param fileMetas file metadata entries.    * @param timeProvider nullable time provider    */
DECL|method|patchLastUpdated ( final Collection<? extends PathMetadata> fileMetas, @Nullable final ITtlTimeProvider timeProvider)
specifier|static
name|void
name|patchLastUpdated
parameter_list|(
specifier|final
name|Collection
argument_list|<
name|?
extends|extends
name|PathMetadata
argument_list|>
name|fileMetas
parameter_list|,
annotation|@
name|Nullable
specifier|final
name|ITtlTimeProvider
name|timeProvider
parameter_list|)
block|{
if|if
condition|(
name|timeProvider
operator|!=
literal|null
condition|)
block|{
specifier|final
name|long
name|now
init|=
name|timeProvider
operator|.
name|getNow
argument_list|()
decl_stmt|;
name|fileMetas
operator|.
name|forEach
argument_list|(
name|fileMeta
lambda|->
name|fileMeta
operator|.
name|setLastUpdated
argument_list|(
name|now
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"timeProvider is null, put {} without setting last_updated"
argument_list|,
name|fileMetas
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Get a path entry provided it is not considered expired.    * @param ms metastore    * @param path path to look up.    * @param timeProvider nullable time provider    * @return the metadata or null if there as no entry.    * @throws IOException failure.    */
DECL|method|getWithTtl (MetadataStore ms, Path path, @Nullable ITtlTimeProvider timeProvider)
specifier|public
specifier|static
name|PathMetadata
name|getWithTtl
parameter_list|(
name|MetadataStore
name|ms
parameter_list|,
name|Path
name|path
parameter_list|,
annotation|@
name|Nullable
name|ITtlTimeProvider
name|timeProvider
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|PathMetadata
name|pathMetadata
init|=
name|ms
operator|.
name|get
argument_list|(
name|path
argument_list|)
decl_stmt|;
comment|// if timeProvider is null let's return with what the ms has
if|if
condition|(
name|timeProvider
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"timeProvider is null, returning pathMetadata as is"
argument_list|)
expr_stmt|;
return|return
name|pathMetadata
return|;
block|}
name|long
name|ttl
init|=
name|timeProvider
operator|.
name|getMetadataTtl
argument_list|()
decl_stmt|;
if|if
condition|(
name|pathMetadata
operator|!=
literal|null
condition|)
block|{
comment|// Special case: the path metadata's last updated is 0. This can happen
comment|// eg. with an old db using this implementation
if|if
condition|(
name|pathMetadata
operator|.
name|getLastUpdated
argument_list|()
operator|==
literal|0
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"PathMetadata TTL for {} is 0, so it will be returned as "
operator|+
literal|"not expired."
argument_list|,
name|path
argument_list|)
expr_stmt|;
return|return
name|pathMetadata
return|;
block|}
if|if
condition|(
operator|!
name|pathMetadata
operator|.
name|isExpired
argument_list|(
name|ttl
argument_list|,
name|timeProvider
operator|.
name|getNow
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|pathMetadata
return|;
block|}
else|else
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"PathMetadata TTl for {} is expired in metadata store."
argument_list|,
name|path
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/**    * List children; mark the result as non-auth if the TTL has expired.    * @param ms metastore    * @param path path to look up.    * @param timeProvider nullable time provider    * @return the listing of entries under a path, or null if there as no entry.    * @throws IOException failure.    */
DECL|method|listChildrenWithTtl (MetadataStore ms, Path path, @Nullable ITtlTimeProvider timeProvider)
specifier|public
specifier|static
name|DirListingMetadata
name|listChildrenWithTtl
parameter_list|(
name|MetadataStore
name|ms
parameter_list|,
name|Path
name|path
parameter_list|,
annotation|@
name|Nullable
name|ITtlTimeProvider
name|timeProvider
parameter_list|)
throws|throws
name|IOException
block|{
name|DirListingMetadata
name|dlm
init|=
name|ms
operator|.
name|listChildren
argument_list|(
name|path
argument_list|)
decl_stmt|;
if|if
condition|(
name|timeProvider
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"timeProvider is null, returning DirListingMetadata as is"
argument_list|)
expr_stmt|;
return|return
name|dlm
return|;
block|}
name|long
name|ttl
init|=
name|timeProvider
operator|.
name|getMetadataTtl
argument_list|()
decl_stmt|;
if|if
condition|(
name|dlm
operator|!=
literal|null
operator|&&
name|dlm
operator|.
name|isAuthoritative
argument_list|()
operator|&&
name|dlm
operator|.
name|isExpired
argument_list|(
name|ttl
argument_list|,
name|timeProvider
operator|.
name|getNow
argument_list|()
argument_list|)
condition|)
block|{
name|dlm
operator|.
name|setAuthoritative
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
return|return
name|dlm
return|;
block|}
block|}
end_class

end_unit

