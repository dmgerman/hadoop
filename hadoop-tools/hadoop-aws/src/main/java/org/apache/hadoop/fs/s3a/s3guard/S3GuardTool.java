begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *<p>  * http://www.apache.org/licenses/LICENSE-2.0  *<p>  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.fs.s3a.s3guard
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|s3guard
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileNotFoundException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|PrintStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URI
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URISyntaxException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Date
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Locale
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Scanner
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|com
operator|.
name|amazonaws
operator|.
name|services
operator|.
name|s3
operator|.
name|model
operator|.
name|MultipartUpload
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang3
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configured
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|LocatedFileStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|RemoteIterator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|MultipartUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|S3AFileStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|S3AFileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|S3AUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|auth
operator|.
name|delegation
operator|.
name|S3ADelegationTokens
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|commit
operator|.
name|CommitConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|select
operator|.
name|SelectTool
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|shell
operator|.
name|CommandFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|UserGroupInformation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|ExitUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|GenericOptionsParser
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Tool
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|ToolRunner
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|Constants
operator|.
name|*
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|Invoker
operator|.
name|LOG_EVENT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|service
operator|.
name|launcher
operator|.
name|LauncherExitCodes
operator|.
name|*
import|;
end_import

begin_comment
comment|/**  * CLI to manage S3Guard Metadata Store.  */
end_comment

begin_class
DECL|class|S3GuardTool
specifier|public
specifier|abstract
class|class
name|S3GuardTool
extends|extends
name|Configured
implements|implements
name|Tool
block|{
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|S3GuardTool
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|NAME
specifier|private
specifier|static
specifier|final
name|String
name|NAME
init|=
literal|"s3guard"
decl_stmt|;
DECL|field|COMMON_USAGE
specifier|private
specifier|static
specifier|final
name|String
name|COMMON_USAGE
init|=
literal|"When possible and not overridden by more specific options, metadata\n"
operator|+
literal|"repository information will be inferred from the S3A URL (if provided)"
operator|+
literal|"\n\n"
operator|+
literal|"Generic options supported are:\n"
operator|+
literal|"  -conf<config file> - specify an application configuration file\n"
operator|+
literal|"  -D<property=value> - define a value for a given property\n"
decl_stmt|;
DECL|field|USAGE
specifier|private
specifier|static
specifier|final
name|String
name|USAGE
init|=
name|NAME
operator|+
literal|" [command] [OPTIONS] [s3a://BUCKET]\n\n"
operator|+
literal|"Commands: \n"
operator|+
literal|"\t"
operator|+
name|Init
operator|.
name|NAME
operator|+
literal|" - "
operator|+
name|Init
operator|.
name|PURPOSE
operator|+
literal|"\n"
operator|+
literal|"\t"
operator|+
name|Destroy
operator|.
name|NAME
operator|+
literal|" - "
operator|+
name|Destroy
operator|.
name|PURPOSE
operator|+
literal|"\n"
operator|+
literal|"\t"
operator|+
name|Import
operator|.
name|NAME
operator|+
literal|" - "
operator|+
name|Import
operator|.
name|PURPOSE
operator|+
literal|"\n"
operator|+
literal|"\t"
operator|+
name|BucketInfo
operator|.
name|NAME
operator|+
literal|" - "
operator|+
name|BucketInfo
operator|.
name|PURPOSE
operator|+
literal|"\n"
operator|+
literal|"\t"
operator|+
name|Uploads
operator|.
name|NAME
operator|+
literal|" - "
operator|+
name|Uploads
operator|.
name|PURPOSE
operator|+
literal|"\n"
operator|+
literal|"\t"
operator|+
name|Diff
operator|.
name|NAME
operator|+
literal|" - "
operator|+
name|Diff
operator|.
name|PURPOSE
operator|+
literal|"\n"
operator|+
literal|"\t"
operator|+
name|Prune
operator|.
name|NAME
operator|+
literal|" - "
operator|+
name|Prune
operator|.
name|PURPOSE
operator|+
literal|"\n"
operator|+
literal|"\t"
operator|+
name|SetCapacity
operator|.
name|NAME
operator|+
literal|" - "
operator|+
name|SetCapacity
operator|.
name|PURPOSE
operator|+
literal|"\n"
operator|+
literal|"\t"
operator|+
name|SelectTool
operator|.
name|NAME
operator|+
literal|" - "
operator|+
name|SelectTool
operator|.
name|PURPOSE
operator|+
literal|"\n"
decl_stmt|;
DECL|field|DATA_IN_S3_IS_PRESERVED
specifier|private
specifier|static
specifier|final
name|String
name|DATA_IN_S3_IS_PRESERVED
init|=
literal|"(all data in S3 is preserved)"
decl_stmt|;
DECL|method|getUsage ()
specifier|public
specifier|abstract
name|String
name|getUsage
parameter_list|()
function_decl|;
comment|// Exit codes
DECL|field|SUCCESS
specifier|static
specifier|final
name|int
name|SUCCESS
init|=
name|EXIT_SUCCESS
decl_stmt|;
DECL|field|INVALID_ARGUMENT
specifier|static
specifier|final
name|int
name|INVALID_ARGUMENT
init|=
name|EXIT_COMMAND_ARGUMENT_ERROR
decl_stmt|;
DECL|field|E_USAGE
specifier|static
specifier|final
name|int
name|E_USAGE
init|=
name|EXIT_USAGE
decl_stmt|;
DECL|field|ERROR
specifier|static
specifier|final
name|int
name|ERROR
init|=
name|EXIT_FAIL
decl_stmt|;
DECL|field|E_BAD_STATE
specifier|static
specifier|final
name|int
name|E_BAD_STATE
init|=
name|EXIT_NOT_ACCEPTABLE
decl_stmt|;
DECL|field|E_NOT_FOUND
specifier|static
specifier|final
name|int
name|E_NOT_FOUND
init|=
name|EXIT_NOT_FOUND
decl_stmt|;
DECL|field|filesystem
specifier|private
name|S3AFileSystem
name|filesystem
decl_stmt|;
DECL|field|store
specifier|private
name|MetadataStore
name|store
decl_stmt|;
DECL|field|commandFormat
specifier|private
specifier|final
name|CommandFormat
name|commandFormat
decl_stmt|;
DECL|field|META_FLAG
specifier|public
specifier|static
specifier|final
name|String
name|META_FLAG
init|=
literal|"meta"
decl_stmt|;
comment|// These are common to prune, upload subcommands.
DECL|field|DAYS_FLAG
specifier|public
specifier|static
specifier|final
name|String
name|DAYS_FLAG
init|=
literal|"days"
decl_stmt|;
DECL|field|HOURS_FLAG
specifier|public
specifier|static
specifier|final
name|String
name|HOURS_FLAG
init|=
literal|"hours"
decl_stmt|;
DECL|field|MINUTES_FLAG
specifier|public
specifier|static
specifier|final
name|String
name|MINUTES_FLAG
init|=
literal|"minutes"
decl_stmt|;
DECL|field|SECONDS_FLAG
specifier|public
specifier|static
specifier|final
name|String
name|SECONDS_FLAG
init|=
literal|"seconds"
decl_stmt|;
DECL|field|AGE_OPTIONS_USAGE
specifier|public
specifier|static
specifier|final
name|String
name|AGE_OPTIONS_USAGE
init|=
literal|"[-days<days>] "
operator|+
literal|"[-hours<hours>] [-minutes<minutes>] [-seconds<seconds>]"
decl_stmt|;
DECL|field|REGION_FLAG
specifier|public
specifier|static
specifier|final
name|String
name|REGION_FLAG
init|=
literal|"region"
decl_stmt|;
DECL|field|READ_FLAG
specifier|public
specifier|static
specifier|final
name|String
name|READ_FLAG
init|=
literal|"read"
decl_stmt|;
DECL|field|WRITE_FLAG
specifier|public
specifier|static
specifier|final
name|String
name|WRITE_FLAG
init|=
literal|"write"
decl_stmt|;
DECL|field|TAG_FLAG
specifier|public
specifier|static
specifier|final
name|String
name|TAG_FLAG
init|=
literal|"tag"
decl_stmt|;
comment|/**    * Constructor a S3Guard tool with HDFS configuration.    * @param conf Configuration.    * @param opts any boolean options to support    */
DECL|method|S3GuardTool (Configuration conf, String...opts)
specifier|protected
name|S3GuardTool
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|String
modifier|...
name|opts
parameter_list|)
block|{
name|super
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|commandFormat
operator|=
operator|new
name|CommandFormat
argument_list|(
literal|0
argument_list|,
name|Integer
operator|.
name|MAX_VALUE
argument_list|,
name|opts
argument_list|)
expr_stmt|;
comment|// For metadata store URI
name|commandFormat
operator|.
name|addOptionWithValue
argument_list|(
name|META_FLAG
argument_list|)
expr_stmt|;
comment|// DDB region.
name|commandFormat
operator|.
name|addOptionWithValue
argument_list|(
name|REGION_FLAG
argument_list|)
expr_stmt|;
block|}
comment|/**    * Return sub-command name.    * @return sub-dommand name.    */
DECL|method|getName ()
specifier|public
specifier|abstract
name|String
name|getName
parameter_list|()
function_decl|;
comment|/**    * Parse DynamoDB region from either -m option or a S3 path.    *    * This function should only be called from {@link S3GuardTool.Init} or    * {@link S3GuardTool.Destroy}.    *    * @param paths remaining parameters from CLI.    * @throws IOException on I/O errors.    * @throws ExitUtil.ExitException on validation errors    */
DECL|method|parseDynamoDBRegion (List<String> paths)
specifier|protected
name|void
name|parseDynamoDBRegion
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|paths
parameter_list|)
throws|throws
name|IOException
block|{
name|Configuration
name|conf
init|=
name|getConf
argument_list|()
decl_stmt|;
name|String
name|fromCli
init|=
name|getCommandFormat
argument_list|()
operator|.
name|getOptValue
argument_list|(
name|REGION_FLAG
argument_list|)
decl_stmt|;
name|String
name|fromConf
init|=
name|conf
operator|.
name|get
argument_list|(
name|S3GUARD_DDB_REGION_KEY
argument_list|)
decl_stmt|;
name|boolean
name|hasS3Path
init|=
operator|!
name|paths
operator|.
name|isEmpty
argument_list|()
decl_stmt|;
if|if
condition|(
name|fromCli
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|fromCli
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
name|invalidArgs
argument_list|(
literal|"No region provided with -"
operator|+
name|REGION_FLAG
operator|+
literal|" flag"
argument_list|)
throw|;
block|}
if|if
condition|(
name|hasS3Path
condition|)
block|{
throw|throw
name|invalidArgs
argument_list|(
literal|"Providing both an S3 path and the"
operator|+
literal|" -"
operator|+
name|REGION_FLAG
operator|+
literal|" flag is not supported. If you need to specify a different "
operator|+
literal|"region than the S3 bucket, configure "
operator|+
name|S3GUARD_DDB_REGION_KEY
argument_list|)
throw|;
block|}
name|conf
operator|.
name|set
argument_list|(
name|S3GUARD_DDB_REGION_KEY
argument_list|,
name|fromCli
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|fromConf
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|fromConf
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
name|invalidArgs
argument_list|(
literal|"No region provided with config %s"
argument_list|,
name|S3GUARD_DDB_REGION_KEY
argument_list|)
throw|;
block|}
return|return;
block|}
if|if
condition|(
name|hasS3Path
condition|)
block|{
name|String
name|s3Path
init|=
name|paths
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|initS3AFileSystem
argument_list|(
name|s3Path
argument_list|)
expr_stmt|;
return|return;
block|}
throw|throw
name|invalidArgs
argument_list|(
literal|"No region found from -"
operator|+
name|REGION_FLAG
operator|+
literal|" flag, "
operator|+
literal|"config, or S3 bucket"
argument_list|)
throw|;
block|}
DECL|method|getDeltaComponent (TimeUnit unit, String arg)
specifier|private
name|long
name|getDeltaComponent
parameter_list|(
name|TimeUnit
name|unit
parameter_list|,
name|String
name|arg
parameter_list|)
block|{
name|String
name|raw
init|=
name|getCommandFormat
argument_list|()
operator|.
name|getOptValue
argument_list|(
name|arg
argument_list|)
decl_stmt|;
if|if
condition|(
name|raw
operator|==
literal|null
operator|||
name|raw
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|0
return|;
block|}
name|Long
name|parsed
init|=
name|Long
operator|.
name|parseLong
argument_list|(
name|raw
argument_list|)
decl_stmt|;
return|return
name|unit
operator|.
name|toMillis
argument_list|(
name|parsed
argument_list|)
return|;
block|}
comment|/**    * Convert all age options supplied to total milliseconds of time.    * @return Sum of all age options, or zero if none were given.    */
DECL|method|ageOptionsToMsec ()
name|long
name|ageOptionsToMsec
parameter_list|()
block|{
name|long
name|cliDelta
init|=
literal|0
decl_stmt|;
name|cliDelta
operator|+=
name|getDeltaComponent
argument_list|(
name|TimeUnit
operator|.
name|DAYS
argument_list|,
name|DAYS_FLAG
argument_list|)
expr_stmt|;
name|cliDelta
operator|+=
name|getDeltaComponent
argument_list|(
name|TimeUnit
operator|.
name|HOURS
argument_list|,
name|HOURS_FLAG
argument_list|)
expr_stmt|;
name|cliDelta
operator|+=
name|getDeltaComponent
argument_list|(
name|TimeUnit
operator|.
name|MINUTES
argument_list|,
name|MINUTES_FLAG
argument_list|)
expr_stmt|;
name|cliDelta
operator|+=
name|getDeltaComponent
argument_list|(
name|TimeUnit
operator|.
name|SECONDS
argument_list|,
name|SECONDS_FLAG
argument_list|)
expr_stmt|;
return|return
name|cliDelta
return|;
block|}
DECL|method|addAgeOptions ()
specifier|protected
name|void
name|addAgeOptions
parameter_list|()
block|{
name|CommandFormat
name|format
init|=
name|getCommandFormat
argument_list|()
decl_stmt|;
name|format
operator|.
name|addOptionWithValue
argument_list|(
name|DAYS_FLAG
argument_list|)
expr_stmt|;
name|format
operator|.
name|addOptionWithValue
argument_list|(
name|HOURS_FLAG
argument_list|)
expr_stmt|;
name|format
operator|.
name|addOptionWithValue
argument_list|(
name|MINUTES_FLAG
argument_list|)
expr_stmt|;
name|format
operator|.
name|addOptionWithValue
argument_list|(
name|SECONDS_FLAG
argument_list|)
expr_stmt|;
block|}
DECL|method|checkIfS3BucketIsGuarded (List<String> paths)
specifier|protected
name|void
name|checkIfS3BucketIsGuarded
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|paths
parameter_list|)
throws|throws
name|IOException
block|{
comment|// be sure that path is provided in params, so there's no IOoBE
name|String
name|s3Path
init|=
literal|""
decl_stmt|;
if|if
condition|(
operator|!
name|paths
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|s3Path
operator|=
name|paths
operator|.
name|get
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|// Check if DynamoDB url is set from arguments.
name|String
name|metadataStoreUri
init|=
name|getCommandFormat
argument_list|()
operator|.
name|getOptValue
argument_list|(
name|META_FLAG
argument_list|)
decl_stmt|;
if|if
condition|(
name|metadataStoreUri
operator|==
literal|null
operator|||
name|metadataStoreUri
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// If not set, check if filesystem is guarded by creating an
comment|// S3AFileSystem and check if hasMetadataStore is true
try|try
init|(
name|S3AFileSystem
name|s3AFileSystem
init|=
operator|(
name|S3AFileSystem
operator|)
name|S3AFileSystem
operator|.
name|newInstance
argument_list|(
name|toUri
argument_list|(
name|s3Path
argument_list|)
argument_list|,
name|getConf
argument_list|()
argument_list|)
init|)
block|{
name|Preconditions
operator|.
name|checkState
argument_list|(
name|s3AFileSystem
operator|.
name|hasMetadataStore
argument_list|()
argument_list|,
literal|"The S3 bucket is unguarded. "
operator|+
name|getName
argument_list|()
operator|+
literal|" can not be used on an unguarded bucket."
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Check if bucket or DDB table name is set.    * @param paths position arguments in which S3 path is provided.    */
DECL|method|checkBucketNameOrDDBTableNameProvided (List<String> paths)
specifier|protected
name|void
name|checkBucketNameOrDDBTableNameProvided
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|paths
parameter_list|)
block|{
name|String
name|s3Path
init|=
literal|null
decl_stmt|;
if|if
condition|(
operator|!
name|paths
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|s3Path
operator|=
name|paths
operator|.
name|get
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|String
name|metadataStoreUri
init|=
name|getCommandFormat
argument_list|()
operator|.
name|getOptValue
argument_list|(
name|META_FLAG
argument_list|)
decl_stmt|;
if|if
condition|(
name|metadataStoreUri
operator|==
literal|null
operator|&&
name|s3Path
operator|==
literal|null
condition|)
block|{
throw|throw
name|invalidArgs
argument_list|(
literal|"S3 bucket url or DDB table name have to be provided "
operator|+
literal|"explicitly to use "
operator|+
name|getName
argument_list|()
operator|+
literal|" command."
argument_list|)
throw|;
block|}
block|}
comment|/**    * Parse metadata store from command line option or HDFS configuration.    *    * @param forceCreate override the auto-creation setting to true.    * @return a initialized metadata store.    * @throws IOException on unsupported metadata store.    */
DECL|method|initMetadataStore (boolean forceCreate)
specifier|protected
name|MetadataStore
name|initMetadataStore
parameter_list|(
name|boolean
name|forceCreate
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|getStore
argument_list|()
operator|!=
literal|null
condition|)
block|{
return|return
name|getStore
argument_list|()
return|;
block|}
name|Configuration
name|conf
decl_stmt|;
if|if
condition|(
name|filesystem
operator|==
literal|null
condition|)
block|{
name|conf
operator|=
name|getConf
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|conf
operator|=
name|filesystem
operator|.
name|getConf
argument_list|()
expr_stmt|;
block|}
name|String
name|metaURI
init|=
name|getCommandFormat
argument_list|()
operator|.
name|getOptValue
argument_list|(
name|META_FLAG
argument_list|)
decl_stmt|;
if|if
condition|(
name|metaURI
operator|!=
literal|null
operator|&&
operator|!
name|metaURI
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|URI
name|uri
init|=
name|URI
operator|.
name|create
argument_list|(
name|metaURI
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Create metadata store: {}"
argument_list|,
name|uri
operator|+
literal|" scheme: "
operator|+
name|uri
operator|.
name|getScheme
argument_list|()
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|uri
operator|.
name|getScheme
argument_list|()
operator|.
name|toLowerCase
argument_list|(
name|Locale
operator|.
name|ENGLISH
argument_list|)
condition|)
block|{
case|case
literal|"local"
case|:
name|setStore
argument_list|(
operator|new
name|LocalMetadataStore
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
literal|"dynamodb"
case|:
name|setStore
argument_list|(
operator|new
name|DynamoDBMetadataStore
argument_list|()
argument_list|)
expr_stmt|;
name|conf
operator|.
name|set
argument_list|(
name|S3GUARD_DDB_TABLE_NAME_KEY
argument_list|,
name|uri
operator|.
name|getAuthority
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|forceCreate
condition|)
block|{
name|conf
operator|.
name|setBoolean
argument_list|(
name|S3GUARD_DDB_TABLE_CREATE_KEY
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
throw|throw
operator|new
name|IOException
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Metadata store %s is not supported"
argument_list|,
name|uri
argument_list|)
argument_list|)
throw|;
block|}
block|}
else|else
block|{
comment|// CLI does not specify metadata store URI, it uses default metadata store
comment|// DynamoDB instead.
name|setStore
argument_list|(
operator|new
name|DynamoDBMetadataStore
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|forceCreate
condition|)
block|{
name|conf
operator|.
name|setBoolean
argument_list|(
name|S3GUARD_DDB_TABLE_CREATE_KEY
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|filesystem
operator|==
literal|null
condition|)
block|{
name|getStore
argument_list|()
operator|.
name|initialize
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|getStore
argument_list|()
operator|.
name|initialize
argument_list|(
name|filesystem
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Metadata store {} is initialized."
argument_list|,
name|getStore
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|getStore
argument_list|()
return|;
block|}
comment|/**    * Create and initialize a new S3A FileSystem instance.    * This instance is always created without S3Guard, so allowing    * a previously created metastore to be patched in.    *    * Note: this is a bit convoluted as it needs to also handle the situation    * of a per-bucket option in core-site.xml, which isn't easily overridden.    * The new config and the setting of the values before any    * {@code Configuration.get()} calls are critical.    *    * @param path s3a URI    * @throws IOException failure to init filesystem    * @throws ExitUtil.ExitException if the FS is not an S3A FS    */
DECL|method|initS3AFileSystem (String path)
specifier|protected
name|void
name|initS3AFileSystem
parameter_list|(
name|String
name|path
parameter_list|)
throws|throws
name|IOException
block|{
name|URI
name|uri
init|=
name|toUri
argument_list|(
name|path
argument_list|)
decl_stmt|;
comment|// Make sure that S3AFileSystem does not hold an actual MetadataStore
comment|// implementation.
name|Configuration
name|conf
init|=
operator|new
name|Configuration
argument_list|(
name|getConf
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|nullStore
init|=
name|NullMetadataStore
operator|.
name|class
operator|.
name|getName
argument_list|()
decl_stmt|;
name|conf
operator|.
name|set
argument_list|(
name|S3_METADATA_STORE_IMPL
argument_list|,
name|nullStore
argument_list|)
expr_stmt|;
name|String
name|bucket
init|=
name|uri
operator|.
name|getHost
argument_list|()
decl_stmt|;
name|S3AUtils
operator|.
name|setBucketOption
argument_list|(
name|conf
argument_list|,
name|bucket
argument_list|,
name|S3_METADATA_STORE_IMPL
argument_list|,
name|S3GUARD_METASTORE_NULL
argument_list|)
expr_stmt|;
name|String
name|updatedBucketOption
init|=
name|S3AUtils
operator|.
name|getBucketOption
argument_list|(
name|conf
argument_list|,
name|bucket
argument_list|,
name|S3_METADATA_STORE_IMPL
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"updated bucket store option {}"
argument_list|,
name|updatedBucketOption
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkState
argument_list|(
name|S3GUARD_METASTORE_NULL
operator|.
name|equals
argument_list|(
name|updatedBucketOption
argument_list|)
argument_list|,
literal|"Expected bucket option to be %s but was %s"
argument_list|,
name|S3GUARD_METASTORE_NULL
argument_list|,
name|updatedBucketOption
argument_list|)
expr_stmt|;
name|FileSystem
name|fs
init|=
name|FileSystem
operator|.
name|newInstance
argument_list|(
name|uri
argument_list|,
name|conf
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|fs
operator|instanceof
name|S3AFileSystem
operator|)
condition|)
block|{
throw|throw
name|invalidArgs
argument_list|(
literal|"URI %s is not a S3A file system: %s"
argument_list|,
name|uri
argument_list|,
name|fs
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
throw|;
block|}
name|filesystem
operator|=
operator|(
name|S3AFileSystem
operator|)
name|fs
expr_stmt|;
block|}
comment|/**    * Parse CLI arguments and returns the position arguments.    * The options are stored in {@link #commandFormat}.    *    * @param args command line arguments.    * @return the position arguments from CLI.    */
DECL|method|parseArgs (String[] args)
specifier|protected
name|List
argument_list|<
name|String
argument_list|>
name|parseArgs
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
block|{
return|return
name|getCommandFormat
argument_list|()
operator|.
name|parse
argument_list|(
name|args
argument_list|,
literal|1
argument_list|)
return|;
block|}
DECL|method|getFilesystem ()
specifier|protected
name|S3AFileSystem
name|getFilesystem
parameter_list|()
block|{
return|return
name|filesystem
return|;
block|}
DECL|method|setFilesystem (S3AFileSystem filesystem)
specifier|protected
name|void
name|setFilesystem
parameter_list|(
name|S3AFileSystem
name|filesystem
parameter_list|)
block|{
name|this
operator|.
name|filesystem
operator|=
name|filesystem
expr_stmt|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|getStore ()
specifier|public
name|MetadataStore
name|getStore
parameter_list|()
block|{
return|return
name|store
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|setStore (MetadataStore store)
specifier|protected
name|void
name|setStore
parameter_list|(
name|MetadataStore
name|store
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|store
argument_list|)
expr_stmt|;
name|this
operator|.
name|store
operator|=
name|store
expr_stmt|;
block|}
DECL|method|getCommandFormat ()
specifier|protected
name|CommandFormat
name|getCommandFormat
parameter_list|()
block|{
return|return
name|commandFormat
return|;
block|}
annotation|@
name|Override
DECL|method|run (String[] args)
specifier|public
specifier|final
name|int
name|run
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
throws|throws
name|Exception
block|{
return|return
name|run
argument_list|(
name|args
argument_list|,
name|System
operator|.
name|out
argument_list|)
return|;
block|}
comment|/**    * Run the tool, capturing the output (if the tool supports that).    *    * As well as returning an exit code, the implementations can choose to    * throw an instance of {@link ExitUtil.ExitException} with their exit    * code set to the desired exit value. The exit code of such an exception    * is used for the tool's exit code, and the stack trace only logged at    * debug.    * @param args argument list    * @param out output stream    * @return the exit code to return.    * @throws Exception on any failure    */
DECL|method|run (String[] args, PrintStream out)
specifier|public
specifier|abstract
name|int
name|run
parameter_list|(
name|String
index|[]
name|args
parameter_list|,
name|PrintStream
name|out
parameter_list|)
throws|throws
name|Exception
throws|,
name|ExitUtil
operator|.
name|ExitException
function_decl|;
comment|/**    * Create the metadata store.    */
DECL|class|Init
specifier|static
class|class
name|Init
extends|extends
name|S3GuardTool
block|{
DECL|field|NAME
specifier|public
specifier|static
specifier|final
name|String
name|NAME
init|=
literal|"init"
decl_stmt|;
DECL|field|PURPOSE
specifier|public
specifier|static
specifier|final
name|String
name|PURPOSE
init|=
literal|"initialize metadata repository"
decl_stmt|;
DECL|field|USAGE
specifier|private
specifier|static
specifier|final
name|String
name|USAGE
init|=
name|NAME
operator|+
literal|" [OPTIONS] [s3a://BUCKET]\n"
operator|+
literal|"\t"
operator|+
name|PURPOSE
operator|+
literal|"\n\n"
operator|+
literal|"Common options:\n"
operator|+
literal|"  -"
operator|+
name|META_FLAG
operator|+
literal|" URL - Metadata repository details "
operator|+
literal|"(implementation-specific)\n"
operator|+
literal|"\n"
operator|+
literal|"Amazon DynamoDB-specific options:\n"
operator|+
literal|"  -"
operator|+
name|REGION_FLAG
operator|+
literal|" REGION - Service region for connections\n"
operator|+
literal|"  -"
operator|+
name|READ_FLAG
operator|+
literal|" UNIT - Provisioned read throughput units\n"
operator|+
literal|"  -"
operator|+
name|WRITE_FLAG
operator|+
literal|" UNIT - Provisioned write through put units\n"
operator|+
literal|"  -"
operator|+
name|TAG_FLAG
operator|+
literal|" key=value; list of tags to tag dynamo table\n"
operator|+
literal|"\n"
operator|+
literal|"  URLs for Amazon DynamoDB are of the form dynamodb://TABLE_NAME.\n"
operator|+
literal|"  Specifying both the -"
operator|+
name|REGION_FLAG
operator|+
literal|" option and an S3A path\n"
operator|+
literal|"  is not supported."
decl_stmt|;
DECL|method|Init (Configuration conf)
name|Init
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
name|super
argument_list|(
name|conf
argument_list|)
expr_stmt|;
comment|// read capacity.
name|getCommandFormat
argument_list|()
operator|.
name|addOptionWithValue
argument_list|(
name|READ_FLAG
argument_list|)
expr_stmt|;
comment|// write capacity.
name|getCommandFormat
argument_list|()
operator|.
name|addOptionWithValue
argument_list|(
name|WRITE_FLAG
argument_list|)
expr_stmt|;
comment|// tag
name|getCommandFormat
argument_list|()
operator|.
name|addOptionWithValue
argument_list|(
name|TAG_FLAG
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getName ()
specifier|public
name|String
name|getName
parameter_list|()
block|{
return|return
name|NAME
return|;
block|}
annotation|@
name|Override
DECL|method|getUsage ()
specifier|public
name|String
name|getUsage
parameter_list|()
block|{
return|return
name|USAGE
return|;
block|}
annotation|@
name|Override
DECL|method|run (String[] args, PrintStream out)
specifier|public
name|int
name|run
parameter_list|(
name|String
index|[]
name|args
parameter_list|,
name|PrintStream
name|out
parameter_list|)
throws|throws
name|Exception
block|{
name|List
argument_list|<
name|String
argument_list|>
name|paths
init|=
name|parseArgs
argument_list|(
name|args
argument_list|)
decl_stmt|;
try|try
block|{
name|checkBucketNameOrDDBTableNameProvided
argument_list|(
name|paths
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ExitUtil
operator|.
name|ExitException
name|e
parameter_list|)
block|{
name|errorln
argument_list|(
name|USAGE
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
name|String
name|readCap
init|=
name|getCommandFormat
argument_list|()
operator|.
name|getOptValue
argument_list|(
name|READ_FLAG
argument_list|)
decl_stmt|;
if|if
condition|(
name|readCap
operator|!=
literal|null
operator|&&
operator|!
name|readCap
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|int
name|readCapacity
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|readCap
argument_list|)
decl_stmt|;
name|getConf
argument_list|()
operator|.
name|setInt
argument_list|(
name|S3GUARD_DDB_TABLE_CAPACITY_READ_KEY
argument_list|,
name|readCapacity
argument_list|)
expr_stmt|;
block|}
name|String
name|writeCap
init|=
name|getCommandFormat
argument_list|()
operator|.
name|getOptValue
argument_list|(
name|WRITE_FLAG
argument_list|)
decl_stmt|;
if|if
condition|(
name|writeCap
operator|!=
literal|null
operator|&&
operator|!
name|writeCap
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|int
name|writeCapacity
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|writeCap
argument_list|)
decl_stmt|;
name|getConf
argument_list|()
operator|.
name|setInt
argument_list|(
name|S3GUARD_DDB_TABLE_CAPACITY_WRITE_KEY
argument_list|,
name|writeCapacity
argument_list|)
expr_stmt|;
block|}
name|String
name|tags
init|=
name|getCommandFormat
argument_list|()
operator|.
name|getOptValue
argument_list|(
name|TAG_FLAG
argument_list|)
decl_stmt|;
if|if
condition|(
name|tags
operator|!=
literal|null
operator|&&
operator|!
name|tags
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|String
index|[]
name|stringList
init|=
name|tags
operator|.
name|split
argument_list|(
literal|";"
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|tagsKV
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|kv
range|:
name|stringList
control|)
block|{
if|if
condition|(
name|kv
operator|.
name|isEmpty
argument_list|()
operator|||
operator|!
name|kv
operator|.
name|contains
argument_list|(
literal|"="
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|String
index|[]
name|kvSplit
init|=
name|kv
operator|.
name|split
argument_list|(
literal|"="
argument_list|)
decl_stmt|;
name|tagsKV
operator|.
name|put
argument_list|(
name|kvSplit
index|[
literal|0
index|]
argument_list|,
name|kvSplit
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|kv
range|:
name|tagsKV
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|getConf
argument_list|()
operator|.
name|set
argument_list|(
name|S3GUARD_DDB_TABLE_TAG
operator|+
name|kv
operator|.
name|getKey
argument_list|()
argument_list|,
name|kv
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Validate parameters.
try|try
block|{
name|parseDynamoDBRegion
argument_list|(
name|paths
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ExitUtil
operator|.
name|ExitException
name|e
parameter_list|)
block|{
name|errorln
argument_list|(
name|USAGE
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
name|MetadataStore
name|store
init|=
name|initMetadataStore
argument_list|(
literal|true
argument_list|)
decl_stmt|;
name|printStoreDiagnostics
argument_list|(
name|out
argument_list|,
name|store
argument_list|)
expr_stmt|;
return|return
name|SUCCESS
return|;
block|}
block|}
comment|/**    * Change the capacity of the metadata store.    */
DECL|class|SetCapacity
specifier|static
class|class
name|SetCapacity
extends|extends
name|S3GuardTool
block|{
DECL|field|NAME
specifier|public
specifier|static
specifier|final
name|String
name|NAME
init|=
literal|"set-capacity"
decl_stmt|;
DECL|field|PURPOSE
specifier|public
specifier|static
specifier|final
name|String
name|PURPOSE
init|=
literal|"Alter metadata store IO capacity"
decl_stmt|;
DECL|field|READ_CAP_INVALID
specifier|public
specifier|static
specifier|final
name|String
name|READ_CAP_INVALID
init|=
literal|"Read capacity must have "
operator|+
literal|"value greater than or equal to 1."
decl_stmt|;
DECL|field|WRITE_CAP_INVALID
specifier|public
specifier|static
specifier|final
name|String
name|WRITE_CAP_INVALID
init|=
literal|"Write capacity must have "
operator|+
literal|"value greater than or equal to 1."
decl_stmt|;
DECL|field|USAGE
specifier|private
specifier|static
specifier|final
name|String
name|USAGE
init|=
name|NAME
operator|+
literal|" [OPTIONS] [s3a://BUCKET]\n"
operator|+
literal|"\t"
operator|+
name|PURPOSE
operator|+
literal|"\n\n"
operator|+
literal|"Common options:\n"
operator|+
literal|"  -"
operator|+
name|META_FLAG
operator|+
literal|" URL - Metadata repository details "
operator|+
literal|"(implementation-specific)\n"
operator|+
literal|"\n"
operator|+
literal|"Amazon DynamoDB-specific options:\n"
operator|+
literal|"  -"
operator|+
name|READ_FLAG
operator|+
literal|" UNIT - Provisioned read throughput units\n"
operator|+
literal|"  -"
operator|+
name|WRITE_FLAG
operator|+
literal|" UNIT - Provisioned write through put units\n"
operator|+
literal|"\n"
operator|+
literal|"  URLs for Amazon DynamoDB are of the form dynamodb://TABLE_NAME.\n"
operator|+
literal|"  Specifying both the -"
operator|+
name|REGION_FLAG
operator|+
literal|" option and an S3A path\n"
operator|+
literal|"  is not supported."
decl_stmt|;
DECL|method|SetCapacity (Configuration conf)
name|SetCapacity
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
name|super
argument_list|(
name|conf
argument_list|)
expr_stmt|;
comment|// read capacity.
name|getCommandFormat
argument_list|()
operator|.
name|addOptionWithValue
argument_list|(
name|READ_FLAG
argument_list|)
expr_stmt|;
comment|// write capacity.
name|getCommandFormat
argument_list|()
operator|.
name|addOptionWithValue
argument_list|(
name|WRITE_FLAG
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getName ()
specifier|public
name|String
name|getName
parameter_list|()
block|{
return|return
name|NAME
return|;
block|}
annotation|@
name|Override
DECL|method|getUsage ()
specifier|public
name|String
name|getUsage
parameter_list|()
block|{
return|return
name|USAGE
return|;
block|}
annotation|@
name|Override
DECL|method|run (String[] args, PrintStream out)
specifier|public
name|int
name|run
parameter_list|(
name|String
index|[]
name|args
parameter_list|,
name|PrintStream
name|out
parameter_list|)
throws|throws
name|Exception
block|{
name|List
argument_list|<
name|String
argument_list|>
name|paths
init|=
name|parseArgs
argument_list|(
name|args
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|options
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|checkIfS3BucketIsGuarded
argument_list|(
name|paths
argument_list|)
expr_stmt|;
name|String
name|readCap
init|=
name|getCommandFormat
argument_list|()
operator|.
name|getOptValue
argument_list|(
name|READ_FLAG
argument_list|)
decl_stmt|;
if|if
condition|(
name|StringUtils
operator|.
name|isNotEmpty
argument_list|(
name|readCap
argument_list|)
condition|)
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|Integer
operator|.
name|parseInt
argument_list|(
name|readCap
argument_list|)
operator|>
literal|0
argument_list|,
name|READ_CAP_INVALID
argument_list|)
expr_stmt|;
name|S3GuardTool
operator|.
name|println
argument_list|(
name|out
argument_list|,
literal|"Read capacity set to %s"
argument_list|,
name|readCap
argument_list|)
expr_stmt|;
name|options
operator|.
name|put
argument_list|(
name|S3GUARD_DDB_TABLE_CAPACITY_READ_KEY
argument_list|,
name|readCap
argument_list|)
expr_stmt|;
block|}
name|String
name|writeCap
init|=
name|getCommandFormat
argument_list|()
operator|.
name|getOptValue
argument_list|(
name|WRITE_FLAG
argument_list|)
decl_stmt|;
if|if
condition|(
name|StringUtils
operator|.
name|isNotEmpty
argument_list|(
name|writeCap
argument_list|)
condition|)
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|Integer
operator|.
name|parseInt
argument_list|(
name|writeCap
argument_list|)
operator|>
literal|0
argument_list|,
name|WRITE_CAP_INVALID
argument_list|)
expr_stmt|;
name|S3GuardTool
operator|.
name|println
argument_list|(
name|out
argument_list|,
literal|"Write capacity set to %s"
argument_list|,
name|writeCap
argument_list|)
expr_stmt|;
name|options
operator|.
name|put
argument_list|(
name|S3GUARD_DDB_TABLE_CAPACITY_WRITE_KEY
argument_list|,
name|writeCap
argument_list|)
expr_stmt|;
block|}
comment|// Validate parameters.
try|try
block|{
name|parseDynamoDBRegion
argument_list|(
name|paths
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ExitUtil
operator|.
name|ExitException
name|e
parameter_list|)
block|{
name|errorln
argument_list|(
name|USAGE
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
name|MetadataStore
name|store
init|=
name|initMetadataStore
argument_list|(
literal|false
argument_list|)
decl_stmt|;
name|store
operator|.
name|updateParameters
argument_list|(
name|options
argument_list|)
expr_stmt|;
name|printStoreDiagnostics
argument_list|(
name|out
argument_list|,
name|store
argument_list|)
expr_stmt|;
return|return
name|SUCCESS
return|;
block|}
block|}
comment|/**    * Destroy a metadata store.    */
DECL|class|Destroy
specifier|static
class|class
name|Destroy
extends|extends
name|S3GuardTool
block|{
DECL|field|NAME
specifier|public
specifier|static
specifier|final
name|String
name|NAME
init|=
literal|"destroy"
decl_stmt|;
DECL|field|PURPOSE
specifier|public
specifier|static
specifier|final
name|String
name|PURPOSE
init|=
literal|"destroy Metadata Store data "
operator|+
name|DATA_IN_S3_IS_PRESERVED
decl_stmt|;
DECL|field|USAGE
specifier|private
specifier|static
specifier|final
name|String
name|USAGE
init|=
name|NAME
operator|+
literal|" [OPTIONS] [s3a://BUCKET]\n"
operator|+
literal|"\t"
operator|+
name|PURPOSE
operator|+
literal|"\n\n"
operator|+
literal|"Common options:\n"
operator|+
literal|"  -"
operator|+
name|META_FLAG
operator|+
literal|" URL - Metadata repository details "
operator|+
literal|"(implementation-specific)\n"
operator|+
literal|"\n"
operator|+
literal|"Amazon DynamoDB-specific options:\n"
operator|+
literal|"  -"
operator|+
name|REGION_FLAG
operator|+
literal|" REGION - Service region for connections\n"
operator|+
literal|"\n"
operator|+
literal|"  URLs for Amazon DynamoDB are of the form dynamodb://TABLE_NAME.\n"
operator|+
literal|"  Specifying both the -"
operator|+
name|REGION_FLAG
operator|+
literal|" option and an S3A path\n"
operator|+
literal|"  is not supported."
decl_stmt|;
DECL|method|Destroy (Configuration conf)
name|Destroy
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
name|super
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getName ()
specifier|public
name|String
name|getName
parameter_list|()
block|{
return|return
name|NAME
return|;
block|}
annotation|@
name|Override
DECL|method|getUsage ()
specifier|public
name|String
name|getUsage
parameter_list|()
block|{
return|return
name|USAGE
return|;
block|}
DECL|method|run (String[] args, PrintStream out)
specifier|public
name|int
name|run
parameter_list|(
name|String
index|[]
name|args
parameter_list|,
name|PrintStream
name|out
parameter_list|)
throws|throws
name|Exception
block|{
name|List
argument_list|<
name|String
argument_list|>
name|paths
init|=
name|parseArgs
argument_list|(
name|args
argument_list|)
decl_stmt|;
try|try
block|{
name|checkBucketNameOrDDBTableNameProvided
argument_list|(
name|paths
argument_list|)
expr_stmt|;
name|checkIfS3BucketIsGuarded
argument_list|(
name|paths
argument_list|)
expr_stmt|;
name|parseDynamoDBRegion
argument_list|(
name|paths
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ExitUtil
operator|.
name|ExitException
name|e
parameter_list|)
block|{
name|errorln
argument_list|(
name|USAGE
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
try|try
block|{
name|initMetadataStore
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|e
parameter_list|)
block|{
comment|// indication that the table was not found
name|println
argument_list|(
name|out
argument_list|,
literal|"Metadata Store does not exist."
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Failed to bind to store to be destroyed"
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
name|SUCCESS
return|;
block|}
name|Preconditions
operator|.
name|checkState
argument_list|(
name|getStore
argument_list|()
operator|!=
literal|null
argument_list|,
literal|"Metadata Store is not initialized"
argument_list|)
expr_stmt|;
name|getStore
argument_list|()
operator|.
name|destroy
argument_list|()
expr_stmt|;
name|println
argument_list|(
name|out
argument_list|,
literal|"Metadata store is deleted."
argument_list|)
expr_stmt|;
return|return
name|SUCCESS
return|;
block|}
block|}
comment|/**    * Import s3 metadata to the metadata store.    */
DECL|class|Import
specifier|static
class|class
name|Import
extends|extends
name|S3GuardTool
block|{
DECL|field|NAME
specifier|public
specifier|static
specifier|final
name|String
name|NAME
init|=
literal|"import"
decl_stmt|;
DECL|field|PURPOSE
specifier|public
specifier|static
specifier|final
name|String
name|PURPOSE
init|=
literal|"import metadata from existing S3 "
operator|+
literal|"data"
decl_stmt|;
DECL|field|USAGE
specifier|private
specifier|static
specifier|final
name|String
name|USAGE
init|=
name|NAME
operator|+
literal|" [OPTIONS] [s3a://BUCKET]\n"
operator|+
literal|"\t"
operator|+
name|PURPOSE
operator|+
literal|"\n\n"
operator|+
literal|"Common options:\n"
operator|+
literal|"  -"
operator|+
name|META_FLAG
operator|+
literal|" URL - Metadata repository details "
operator|+
literal|"(implementation-specific)\n"
operator|+
literal|"\n"
operator|+
literal|"Amazon DynamoDB-specific options:\n"
operator|+
literal|"  -"
operator|+
name|REGION_FLAG
operator|+
literal|" REGION - Service region for connections\n"
operator|+
literal|"\n"
operator|+
literal|"  URLs for Amazon DynamoDB are of the form dynamodb://TABLE_NAME.\n"
operator|+
literal|"  Specifying both the -"
operator|+
name|REGION_FLAG
operator|+
literal|" option and an S3A path\n"
operator|+
literal|"  is not supported."
decl_stmt|;
DECL|field|dirCache
specifier|private
specifier|final
name|Set
argument_list|<
name|Path
argument_list|>
name|dirCache
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
DECL|method|Import (Configuration conf)
name|Import
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
name|super
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getName ()
specifier|public
name|String
name|getName
parameter_list|()
block|{
return|return
name|NAME
return|;
block|}
annotation|@
name|Override
DECL|method|getUsage ()
specifier|public
name|String
name|getUsage
parameter_list|()
block|{
return|return
name|USAGE
return|;
block|}
comment|/**      * Put parents into MS and cache if the parents are not presented.      *      * @param f the file or an empty directory.      * @throws IOException on I/O errors.      */
DECL|method|putParentsIfNotPresent (FileStatus f)
specifier|private
name|void
name|putParentsIfNotPresent
parameter_list|(
name|FileStatus
name|f
parameter_list|)
throws|throws
name|IOException
block|{
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|Path
name|parent
init|=
name|f
operator|.
name|getPath
argument_list|()
operator|.
name|getParent
argument_list|()
decl_stmt|;
while|while
condition|(
name|parent
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|dirCache
operator|.
name|contains
argument_list|(
name|parent
argument_list|)
condition|)
block|{
return|return;
block|}
name|FileStatus
name|dir
init|=
name|DynamoDBMetadataStore
operator|.
name|makeDirStatus
argument_list|(
name|parent
argument_list|,
name|f
operator|.
name|getOwner
argument_list|()
argument_list|)
decl_stmt|;
name|getStore
argument_list|()
operator|.
name|put
argument_list|(
operator|new
name|PathMetadata
argument_list|(
name|dir
argument_list|)
argument_list|)
expr_stmt|;
name|dirCache
operator|.
name|add
argument_list|(
name|parent
argument_list|)
expr_stmt|;
name|parent
operator|=
name|parent
operator|.
name|getParent
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Recursively import every path under path.      * @return number of items inserted into MetadataStore      * @throws IOException on I/O errors.      */
DECL|method|importDir (FileStatus status)
specifier|private
name|long
name|importDir
parameter_list|(
name|FileStatus
name|status
parameter_list|)
throws|throws
name|IOException
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|status
operator|.
name|isDirectory
argument_list|()
argument_list|)
expr_stmt|;
name|RemoteIterator
argument_list|<
name|LocatedFileStatus
argument_list|>
name|it
init|=
name|getFilesystem
argument_list|()
operator|.
name|listFilesAndEmptyDirectories
argument_list|(
name|status
operator|.
name|getPath
argument_list|()
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|long
name|items
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|LocatedFileStatus
name|located
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|FileStatus
name|child
decl_stmt|;
if|if
condition|(
name|located
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
name|child
operator|=
name|DynamoDBMetadataStore
operator|.
name|makeDirStatus
argument_list|(
name|located
operator|.
name|getPath
argument_list|()
argument_list|,
name|located
operator|.
name|getOwner
argument_list|()
argument_list|)
expr_stmt|;
name|dirCache
operator|.
name|add
argument_list|(
name|child
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|child
operator|=
operator|new
name|S3AFileStatus
argument_list|(
name|located
operator|.
name|getLen
argument_list|()
argument_list|,
name|located
operator|.
name|getModificationTime
argument_list|()
argument_list|,
name|located
operator|.
name|getPath
argument_list|()
argument_list|,
name|located
operator|.
name|getBlockSize
argument_list|()
argument_list|,
name|located
operator|.
name|getOwner
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|putParentsIfNotPresent
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|getStore
argument_list|()
operator|.
name|put
argument_list|(
operator|new
name|PathMetadata
argument_list|(
name|child
argument_list|)
argument_list|)
expr_stmt|;
name|items
operator|++
expr_stmt|;
block|}
return|return
name|items
return|;
block|}
annotation|@
name|Override
DECL|method|run (String[] args, PrintStream out)
specifier|public
name|int
name|run
parameter_list|(
name|String
index|[]
name|args
parameter_list|,
name|PrintStream
name|out
parameter_list|)
throws|throws
name|Exception
block|{
name|List
argument_list|<
name|String
argument_list|>
name|paths
init|=
name|parseArgs
argument_list|(
name|args
argument_list|)
decl_stmt|;
if|if
condition|(
name|paths
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|errorln
argument_list|(
name|getUsage
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
name|invalidArgs
argument_list|(
literal|"no arguments"
argument_list|)
throw|;
block|}
name|String
name|s3Path
init|=
name|paths
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|initS3AFileSystem
argument_list|(
name|s3Path
argument_list|)
expr_stmt|;
name|URI
name|uri
init|=
name|toUri
argument_list|(
name|s3Path
argument_list|)
decl_stmt|;
name|String
name|filePath
init|=
name|uri
operator|.
name|getPath
argument_list|()
decl_stmt|;
if|if
condition|(
name|filePath
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// If they specify a naked S3 URI (e.g. s3a://bucket), we'll consider
comment|// root to be the path
name|filePath
operator|=
literal|"/"
expr_stmt|;
block|}
name|Path
name|path
init|=
operator|new
name|Path
argument_list|(
name|filePath
argument_list|)
decl_stmt|;
name|FileStatus
name|status
init|=
name|getFilesystem
argument_list|()
operator|.
name|getFileStatus
argument_list|(
name|path
argument_list|)
decl_stmt|;
try|try
block|{
name|initMetadataStore
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|e
parameter_list|)
block|{
throw|throw
name|storeNotFound
argument_list|(
name|e
argument_list|)
throw|;
block|}
name|long
name|items
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|status
operator|.
name|isFile
argument_list|()
condition|)
block|{
name|PathMetadata
name|meta
init|=
operator|new
name|PathMetadata
argument_list|(
name|status
argument_list|)
decl_stmt|;
name|getStore
argument_list|()
operator|.
name|put
argument_list|(
name|meta
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|items
operator|=
name|importDir
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
name|println
argument_list|(
name|out
argument_list|,
literal|"Inserted %d items into Metadata Store"
argument_list|,
name|items
argument_list|)
expr_stmt|;
return|return
name|SUCCESS
return|;
block|}
block|}
comment|/**    * Show diffs between the s3 and metadata store.    */
DECL|class|Diff
specifier|static
class|class
name|Diff
extends|extends
name|S3GuardTool
block|{
DECL|field|NAME
specifier|public
specifier|static
specifier|final
name|String
name|NAME
init|=
literal|"diff"
decl_stmt|;
DECL|field|PURPOSE
specifier|public
specifier|static
specifier|final
name|String
name|PURPOSE
init|=
literal|"report on delta between S3 and "
operator|+
literal|"repository"
decl_stmt|;
DECL|field|USAGE
specifier|private
specifier|static
specifier|final
name|String
name|USAGE
init|=
name|NAME
operator|+
literal|" [OPTIONS] s3a://BUCKET\n"
operator|+
literal|"\t"
operator|+
name|PURPOSE
operator|+
literal|"\n\n"
operator|+
literal|"Common options:\n"
operator|+
literal|"  -"
operator|+
name|META_FLAG
operator|+
literal|" URL - Metadata repository details "
operator|+
literal|"(implementation-specific)\n"
operator|+
literal|"\n"
operator|+
literal|"Amazon DynamoDB-specific options:\n"
operator|+
literal|"  -"
operator|+
name|REGION_FLAG
operator|+
literal|" REGION - Service region for connections\n"
operator|+
literal|"\n"
operator|+
literal|"  URLs for Amazon DynamoDB are of the form dynamodb://TABLE_NAME.\n"
operator|+
literal|"  Specifying both the -"
operator|+
name|REGION_FLAG
operator|+
literal|" option and an S3A path\n"
operator|+
literal|"  is not supported."
decl_stmt|;
DECL|field|SEP
specifier|private
specifier|static
specifier|final
name|String
name|SEP
init|=
literal|"\t"
decl_stmt|;
DECL|field|S3_PREFIX
specifier|static
specifier|final
name|String
name|S3_PREFIX
init|=
literal|"S3"
decl_stmt|;
DECL|field|MS_PREFIX
specifier|static
specifier|final
name|String
name|MS_PREFIX
init|=
literal|"MS"
decl_stmt|;
DECL|method|Diff (Configuration conf)
name|Diff
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
name|super
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getName ()
specifier|public
name|String
name|getName
parameter_list|()
block|{
return|return
name|NAME
return|;
block|}
annotation|@
name|Override
DECL|method|getUsage ()
specifier|public
name|String
name|getUsage
parameter_list|()
block|{
return|return
name|USAGE
return|;
block|}
comment|/**      * Formats the output of printing a FileStatus in S3guard diff tool.      * @param status the status to print.      * @return the string of output.      */
DECL|method|formatFileStatus (FileStatus status)
specifier|private
specifier|static
name|String
name|formatFileStatus
parameter_list|(
name|FileStatus
name|status
parameter_list|)
block|{
return|return
name|String
operator|.
name|format
argument_list|(
literal|"%s%s%d%s%s"
argument_list|,
name|status
operator|.
name|isDirectory
argument_list|()
condition|?
literal|"D"
else|:
literal|"F"
argument_list|,
name|SEP
argument_list|,
name|status
operator|.
name|getLen
argument_list|()
argument_list|,
name|SEP
argument_list|,
name|status
operator|.
name|getPath
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Compares metadata from 2 S3 FileStatus's to see if they differ.      * @param thisOne      * @param thatOne      * @return true if the metadata is not identical      */
DECL|method|differ (FileStatus thisOne, FileStatus thatOne)
specifier|private
specifier|static
name|boolean
name|differ
parameter_list|(
name|FileStatus
name|thisOne
parameter_list|,
name|FileStatus
name|thatOne
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
operator|!
operator|(
name|thisOne
operator|==
literal|null
operator|&&
name|thatOne
operator|==
literal|null
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|thisOne
operator|==
literal|null
operator|||
name|thatOne
operator|==
literal|null
operator|)
operator|||
operator|(
name|thisOne
operator|.
name|getLen
argument_list|()
operator|!=
name|thatOne
operator|.
name|getLen
argument_list|()
operator|)
operator|||
operator|(
name|thisOne
operator|.
name|isDirectory
argument_list|()
operator|!=
name|thatOne
operator|.
name|isDirectory
argument_list|()
operator|)
operator|||
operator|(
operator|!
name|thisOne
operator|.
name|isDirectory
argument_list|()
operator|&&
name|thisOne
operator|.
name|getModificationTime
argument_list|()
operator|!=
name|thatOne
operator|.
name|getModificationTime
argument_list|()
operator|)
return|;
block|}
comment|/**      * Print difference, if any, between two file statuses to the output stream.      *      * @param msStatus file status from metadata store.      * @param s3Status file status from S3.      * @param out output stream.      */
DECL|method|printDiff (FileStatus msStatus, FileStatus s3Status, PrintStream out)
specifier|private
specifier|static
name|void
name|printDiff
parameter_list|(
name|FileStatus
name|msStatus
parameter_list|,
name|FileStatus
name|s3Status
parameter_list|,
name|PrintStream
name|out
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
operator|!
operator|(
name|msStatus
operator|==
literal|null
operator|&&
name|s3Status
operator|==
literal|null
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|msStatus
operator|!=
literal|null
operator|&&
name|s3Status
operator|!=
literal|null
condition|)
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|msStatus
operator|.
name|getPath
argument_list|()
operator|.
name|equals
argument_list|(
name|s3Status
operator|.
name|getPath
argument_list|()
argument_list|)
argument_list|,
name|String
operator|.
name|format
argument_list|(
literal|"The path from metadata store and s3 are different:"
operator|+
literal|" ms=%s s3=%s"
argument_list|,
name|msStatus
operator|.
name|getPath
argument_list|()
argument_list|,
name|s3Status
operator|.
name|getPath
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|differ
argument_list|(
name|msStatus
argument_list|,
name|s3Status
argument_list|)
condition|)
block|{
if|if
condition|(
name|s3Status
operator|!=
literal|null
condition|)
block|{
name|println
argument_list|(
name|out
argument_list|,
literal|"%s%s%s"
argument_list|,
name|S3_PREFIX
argument_list|,
name|SEP
argument_list|,
name|formatFileStatus
argument_list|(
name|s3Status
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|msStatus
operator|!=
literal|null
condition|)
block|{
name|println
argument_list|(
name|out
argument_list|,
literal|"%s%s%s"
argument_list|,
name|MS_PREFIX
argument_list|,
name|SEP
argument_list|,
name|formatFileStatus
argument_list|(
name|msStatus
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Compare the metadata of the directory with the same path, on S3 and      * the metadata store, respectively. If one of them is null, consider the      * metadata of the directory and all its subdirectories are missing from      * the source.      *      * Pass the FileStatus obtained from s3 and metadata store to avoid one      * round trip to fetch the same metadata twice, because the FileStatus      * hve already been obtained from listStatus() / listChildren operations.      *      * @param msDir the directory FileStatus obtained from the metadata store.      * @param s3Dir the directory FileStatus obtained from S3.      * @param out the output stream to generate diff results.      * @throws IOException on I/O errors.      */
DECL|method|compareDir (FileStatus msDir, FileStatus s3Dir, PrintStream out)
specifier|private
name|void
name|compareDir
parameter_list|(
name|FileStatus
name|msDir
parameter_list|,
name|FileStatus
name|s3Dir
parameter_list|,
name|PrintStream
name|out
parameter_list|)
throws|throws
name|IOException
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
operator|!
operator|(
name|msDir
operator|==
literal|null
operator|&&
name|s3Dir
operator|==
literal|null
operator|)
argument_list|,
literal|"The path does not exist in metadata store and on s3."
argument_list|)
expr_stmt|;
if|if
condition|(
name|msDir
operator|!=
literal|null
operator|&&
name|s3Dir
operator|!=
literal|null
condition|)
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|msDir
operator|.
name|getPath
argument_list|()
operator|.
name|equals
argument_list|(
name|s3Dir
operator|.
name|getPath
argument_list|()
argument_list|)
argument_list|,
name|String
operator|.
name|format
argument_list|(
literal|"The path from metadata store and s3 are different:"
operator|+
literal|" ms=%s s3=%s"
argument_list|,
name|msDir
operator|.
name|getPath
argument_list|()
argument_list|,
name|s3Dir
operator|.
name|getPath
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Map
argument_list|<
name|Path
argument_list|,
name|FileStatus
argument_list|>
name|s3Children
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
if|if
condition|(
name|s3Dir
operator|!=
literal|null
operator|&&
name|s3Dir
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
for|for
control|(
name|FileStatus
name|status
range|:
name|getFilesystem
argument_list|()
operator|.
name|listStatus
argument_list|(
name|s3Dir
operator|.
name|getPath
argument_list|()
argument_list|)
control|)
block|{
name|s3Children
operator|.
name|put
argument_list|(
name|status
operator|.
name|getPath
argument_list|()
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
block|}
name|Map
argument_list|<
name|Path
argument_list|,
name|FileStatus
argument_list|>
name|msChildren
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
if|if
condition|(
name|msDir
operator|!=
literal|null
operator|&&
name|msDir
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
name|DirListingMetadata
name|dirMeta
init|=
name|getStore
argument_list|()
operator|.
name|listChildren
argument_list|(
name|msDir
operator|.
name|getPath
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|dirMeta
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|PathMetadata
name|meta
range|:
name|dirMeta
operator|.
name|getListing
argument_list|()
control|)
block|{
name|FileStatus
name|status
init|=
name|meta
operator|.
name|getFileStatus
argument_list|()
decl_stmt|;
name|msChildren
operator|.
name|put
argument_list|(
name|status
operator|.
name|getPath
argument_list|()
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|Set
argument_list|<
name|Path
argument_list|>
name|allPaths
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|(
name|s3Children
operator|.
name|keySet
argument_list|()
argument_list|)
decl_stmt|;
name|allPaths
operator|.
name|addAll
argument_list|(
name|msChildren
operator|.
name|keySet
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|Path
name|path
range|:
name|allPaths
control|)
block|{
name|FileStatus
name|s3Status
init|=
name|s3Children
operator|.
name|get
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|FileStatus
name|msStatus
init|=
name|msChildren
operator|.
name|get
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|printDiff
argument_list|(
name|msStatus
argument_list|,
name|s3Status
argument_list|,
name|out
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|s3Status
operator|!=
literal|null
operator|&&
name|s3Status
operator|.
name|isDirectory
argument_list|()
operator|)
operator|||
operator|(
name|msStatus
operator|!=
literal|null
operator|&&
name|msStatus
operator|.
name|isDirectory
argument_list|()
operator|)
condition|)
block|{
name|compareDir
argument_list|(
name|msStatus
argument_list|,
name|s3Status
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
block|}
name|out
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
comment|/**      * Compare both metadata store and S3 on the same path.      *      * @param path the path to be compared.      * @param out  the output stream to display results.      * @throws IOException on I/O errors.      */
DECL|method|compareRoot (Path path, PrintStream out)
specifier|private
name|void
name|compareRoot
parameter_list|(
name|Path
name|path
parameter_list|,
name|PrintStream
name|out
parameter_list|)
throws|throws
name|IOException
block|{
name|Path
name|qualified
init|=
name|getFilesystem
argument_list|()
operator|.
name|qualify
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|FileStatus
name|s3Status
init|=
literal|null
decl_stmt|;
try|try
block|{
name|s3Status
operator|=
name|getFilesystem
argument_list|()
operator|.
name|getFileStatus
argument_list|(
name|qualified
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|e
parameter_list|)
block|{
comment|/* ignored */
block|}
name|PathMetadata
name|meta
init|=
name|getStore
argument_list|()
operator|.
name|get
argument_list|(
name|qualified
argument_list|)
decl_stmt|;
name|FileStatus
name|msStatus
init|=
operator|(
name|meta
operator|!=
literal|null
operator|&&
operator|!
name|meta
operator|.
name|isDeleted
argument_list|()
operator|)
condition|?
name|meta
operator|.
name|getFileStatus
argument_list|()
else|:
literal|null
decl_stmt|;
name|compareDir
argument_list|(
name|msStatus
argument_list|,
name|s3Status
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|run (String[] args, PrintStream out)
specifier|public
name|int
name|run
parameter_list|(
name|String
index|[]
name|args
parameter_list|,
name|PrintStream
name|out
parameter_list|)
throws|throws
name|IOException
block|{
name|List
argument_list|<
name|String
argument_list|>
name|paths
init|=
name|parseArgs
argument_list|(
name|args
argument_list|)
decl_stmt|;
if|if
condition|(
name|paths
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|out
operator|.
name|println
argument_list|(
name|USAGE
argument_list|)
expr_stmt|;
throw|throw
name|invalidArgs
argument_list|(
literal|"no arguments"
argument_list|)
throw|;
block|}
name|String
name|s3Path
init|=
name|paths
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|initS3AFileSystem
argument_list|(
name|s3Path
argument_list|)
expr_stmt|;
name|initMetadataStore
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|URI
name|uri
init|=
name|toUri
argument_list|(
name|s3Path
argument_list|)
decl_stmt|;
name|Path
name|root
decl_stmt|;
if|if
condition|(
name|uri
operator|.
name|getPath
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|root
operator|=
operator|new
name|Path
argument_list|(
literal|"/"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|root
operator|=
operator|new
name|Path
argument_list|(
name|uri
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|root
operator|=
name|getFilesystem
argument_list|()
operator|.
name|qualify
argument_list|(
name|root
argument_list|)
expr_stmt|;
name|compareRoot
argument_list|(
name|root
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|out
operator|.
name|flush
argument_list|()
expr_stmt|;
return|return
name|SUCCESS
return|;
block|}
block|}
comment|/**    * Prune metadata that has not been modified recently.    */
DECL|class|Prune
specifier|static
class|class
name|Prune
extends|extends
name|S3GuardTool
block|{
DECL|field|NAME
specifier|public
specifier|static
specifier|final
name|String
name|NAME
init|=
literal|"prune"
decl_stmt|;
DECL|field|PURPOSE
specifier|public
specifier|static
specifier|final
name|String
name|PURPOSE
init|=
literal|"truncate older metadata from "
operator|+
literal|"repository "
operator|+
name|DATA_IN_S3_IS_PRESERVED
decl_stmt|;
empty_stmt|;
DECL|field|USAGE
specifier|private
specifier|static
specifier|final
name|String
name|USAGE
init|=
name|NAME
operator|+
literal|" [OPTIONS] [s3a://BUCKET]\n"
operator|+
literal|"\t"
operator|+
name|PURPOSE
operator|+
literal|"\n\n"
operator|+
literal|"Common options:\n"
operator|+
literal|"  -"
operator|+
name|META_FLAG
operator|+
literal|" URL - Metadata repository details "
operator|+
literal|"(implementation-specific)\n"
operator|+
literal|"Age options. Any combination of these integer-valued options:\n"
operator|+
name|AGE_OPTIONS_USAGE
operator|+
literal|"\n"
operator|+
literal|"Amazon DynamoDB-specific options:\n"
operator|+
literal|"  -"
operator|+
name|REGION_FLAG
operator|+
literal|" REGION - Service region for connections\n"
operator|+
literal|"\n"
operator|+
literal|"  URLs for Amazon DynamoDB are of the form dynamodb://TABLE_NAME.\n"
operator|+
literal|"  Specifying both the -"
operator|+
name|REGION_FLAG
operator|+
literal|" option and an S3A path\n"
operator|+
literal|"  is not supported."
decl_stmt|;
DECL|method|Prune (Configuration conf)
name|Prune
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
name|super
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|addAgeOptions
argument_list|()
expr_stmt|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|setMetadataStore (MetadataStore ms)
name|void
name|setMetadataStore
parameter_list|(
name|MetadataStore
name|ms
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|ms
argument_list|)
expr_stmt|;
name|this
operator|.
name|setStore
argument_list|(
name|ms
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getName ()
specifier|public
name|String
name|getName
parameter_list|()
block|{
return|return
name|NAME
return|;
block|}
annotation|@
name|Override
DECL|method|getUsage ()
specifier|public
name|String
name|getUsage
parameter_list|()
block|{
return|return
name|USAGE
return|;
block|}
DECL|method|run (String[] args, PrintStream out)
specifier|public
name|int
name|run
parameter_list|(
name|String
index|[]
name|args
parameter_list|,
name|PrintStream
name|out
parameter_list|)
throws|throws
name|InterruptedException
throws|,
name|IOException
block|{
name|List
argument_list|<
name|String
argument_list|>
name|paths
init|=
name|parseArgs
argument_list|(
name|args
argument_list|)
decl_stmt|;
try|try
block|{
name|parseDynamoDBRegion
argument_list|(
name|paths
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ExitUtil
operator|.
name|ExitException
name|e
parameter_list|)
block|{
name|errorln
argument_list|(
name|USAGE
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
name|initMetadataStore
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|Configuration
name|conf
init|=
name|getConf
argument_list|()
decl_stmt|;
name|long
name|confDelta
init|=
name|conf
operator|.
name|getLong
argument_list|(
name|S3GUARD_CLI_PRUNE_AGE
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|long
name|cliDelta
init|=
name|ageOptionsToMsec
argument_list|()
decl_stmt|;
if|if
condition|(
name|confDelta
operator|<=
literal|0
operator|&&
name|cliDelta
operator|<=
literal|0
condition|)
block|{
name|errorln
argument_list|(
literal|"You must specify a positive age for metadata to prune."
argument_list|)
expr_stmt|;
block|}
comment|// A delta provided on the CLI overrides if one is configured
name|long
name|delta
init|=
name|confDelta
decl_stmt|;
if|if
condition|(
name|cliDelta
operator|>
literal|0
condition|)
block|{
name|delta
operator|=
name|cliDelta
expr_stmt|;
block|}
name|long
name|now
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|long
name|divide
init|=
name|now
operator|-
name|delta
decl_stmt|;
comment|// remove the protocol from path string to get keyPrefix
comment|// by default the keyPrefix is "/" - unless the s3 URL is provided
name|String
name|keyPrefix
init|=
literal|"/"
decl_stmt|;
if|if
condition|(
name|paths
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|Path
name|path
init|=
operator|new
name|Path
argument_list|(
name|paths
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|keyPrefix
operator|=
name|PathMetadataDynamoDBTranslation
operator|.
name|pathToParentKey
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|getStore
argument_list|()
operator|.
name|prune
argument_list|(
name|divide
argument_list|,
name|keyPrefix
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|e
parameter_list|)
block|{
name|errorln
argument_list|(
literal|"Prune operation not supported in metadata store."
argument_list|)
expr_stmt|;
block|}
name|out
operator|.
name|flush
argument_list|()
expr_stmt|;
return|return
name|SUCCESS
return|;
block|}
block|}
comment|/**    * Get info about a bucket and its S3Guard integration status.    */
DECL|class|BucketInfo
specifier|static
class|class
name|BucketInfo
extends|extends
name|S3GuardTool
block|{
DECL|field|NAME
specifier|public
specifier|static
specifier|final
name|String
name|NAME
init|=
literal|"bucket-info"
decl_stmt|;
DECL|field|GUARDED_FLAG
specifier|public
specifier|static
specifier|final
name|String
name|GUARDED_FLAG
init|=
literal|"guarded"
decl_stmt|;
DECL|field|UNGUARDED_FLAG
specifier|public
specifier|static
specifier|final
name|String
name|UNGUARDED_FLAG
init|=
literal|"unguarded"
decl_stmt|;
DECL|field|AUTH_FLAG
specifier|public
specifier|static
specifier|final
name|String
name|AUTH_FLAG
init|=
literal|"auth"
decl_stmt|;
DECL|field|NONAUTH_FLAG
specifier|public
specifier|static
specifier|final
name|String
name|NONAUTH_FLAG
init|=
literal|"nonauth"
decl_stmt|;
DECL|field|ENCRYPTION_FLAG
specifier|public
specifier|static
specifier|final
name|String
name|ENCRYPTION_FLAG
init|=
literal|"encryption"
decl_stmt|;
DECL|field|MAGIC_FLAG
specifier|public
specifier|static
specifier|final
name|String
name|MAGIC_FLAG
init|=
literal|"magic"
decl_stmt|;
DECL|field|PURPOSE
specifier|public
specifier|static
specifier|final
name|String
name|PURPOSE
init|=
literal|"provide/check S3Guard information"
operator|+
literal|" about a specific bucket"
decl_stmt|;
DECL|field|USAGE
specifier|private
specifier|static
specifier|final
name|String
name|USAGE
init|=
name|NAME
operator|+
literal|" [OPTIONS] s3a://BUCKET\n"
operator|+
literal|"\t"
operator|+
name|PURPOSE
operator|+
literal|"\n\n"
operator|+
literal|"Common options:\n"
operator|+
literal|"  -"
operator|+
name|GUARDED_FLAG
operator|+
literal|" - Require S3Guard\n"
operator|+
literal|"  -"
operator|+
name|UNGUARDED_FLAG
operator|+
literal|" - Force S3Guard to be disabled\n"
operator|+
literal|"  -"
operator|+
name|AUTH_FLAG
operator|+
literal|" - Require the S3Guard mode to be \"authoritative\"\n"
operator|+
literal|"  -"
operator|+
name|NONAUTH_FLAG
operator|+
literal|" - Require the S3Guard mode to be \"non-authoritative\"\n"
operator|+
literal|"  -"
operator|+
name|MAGIC_FLAG
operator|+
literal|" - Require the S3 filesystem to be support the \"magic\" committer\n"
operator|+
literal|"  -"
operator|+
name|ENCRYPTION_FLAG
operator|+
literal|" -require {none, sse-s3, sse-kms} - Require encryption policy"
decl_stmt|;
DECL|method|BucketInfo (Configuration conf)
name|BucketInfo
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
name|super
argument_list|(
name|conf
argument_list|,
name|GUARDED_FLAG
argument_list|,
name|UNGUARDED_FLAG
argument_list|,
name|AUTH_FLAG
argument_list|,
name|NONAUTH_FLAG
argument_list|,
name|MAGIC_FLAG
argument_list|)
expr_stmt|;
name|CommandFormat
name|format
init|=
name|getCommandFormat
argument_list|()
decl_stmt|;
name|format
operator|.
name|addOptionWithValue
argument_list|(
name|ENCRYPTION_FLAG
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getName ()
specifier|public
name|String
name|getName
parameter_list|()
block|{
return|return
name|NAME
return|;
block|}
annotation|@
name|Override
DECL|method|getUsage ()
specifier|public
name|String
name|getUsage
parameter_list|()
block|{
return|return
name|USAGE
return|;
block|}
DECL|method|run (String[] args, PrintStream out)
specifier|public
name|int
name|run
parameter_list|(
name|String
index|[]
name|args
parameter_list|,
name|PrintStream
name|out
parameter_list|)
throws|throws
name|InterruptedException
throws|,
name|IOException
block|{
name|List
argument_list|<
name|String
argument_list|>
name|paths
init|=
name|parseArgs
argument_list|(
name|args
argument_list|)
decl_stmt|;
if|if
condition|(
name|paths
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|errorln
argument_list|(
name|getUsage
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
name|invalidArgs
argument_list|(
literal|"No bucket specified"
argument_list|)
throw|;
block|}
name|String
name|s3Path
init|=
name|paths
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|CommandFormat
name|commands
init|=
name|getCommandFormat
argument_list|()
decl_stmt|;
comment|// check if UNGUARDED_FLAG is passed and use NullMetadataStore in
comment|// config to avoid side effects like creating the table if not exists
if|if
condition|(
name|commands
operator|.
name|getOpt
argument_list|(
name|UNGUARDED_FLAG
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Unguarded flag is passed to command :"
operator|+
name|this
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|getConf
argument_list|()
operator|.
name|set
argument_list|(
name|S3_METADATA_STORE_IMPL
argument_list|,
name|S3GUARD_METASTORE_NULL
argument_list|)
expr_stmt|;
block|}
name|S3AFileSystem
name|fs
init|=
operator|(
name|S3AFileSystem
operator|)
name|FileSystem
operator|.
name|newInstance
argument_list|(
name|toUri
argument_list|(
name|s3Path
argument_list|)
argument_list|,
name|getConf
argument_list|()
argument_list|)
decl_stmt|;
name|setFilesystem
argument_list|(
name|fs
argument_list|)
expr_stmt|;
name|Configuration
name|conf
init|=
name|fs
operator|.
name|getConf
argument_list|()
decl_stmt|;
name|URI
name|fsUri
init|=
name|fs
operator|.
name|getUri
argument_list|()
decl_stmt|;
name|MetadataStore
name|store
init|=
name|fs
operator|.
name|getMetadataStore
argument_list|()
decl_stmt|;
name|println
argument_list|(
name|out
argument_list|,
literal|"Filesystem %s"
argument_list|,
name|fsUri
argument_list|)
expr_stmt|;
name|println
argument_list|(
name|out
argument_list|,
literal|"Location: %s"
argument_list|,
name|fs
operator|.
name|getBucketLocation
argument_list|()
argument_list|)
expr_stmt|;
name|boolean
name|usingS3Guard
init|=
operator|!
operator|(
name|store
operator|instanceof
name|NullMetadataStore
operator|)
decl_stmt|;
name|boolean
name|authMode
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|usingS3Guard
condition|)
block|{
name|out
operator|.
name|printf
argument_list|(
literal|"Filesystem %s is using S3Guard with store %s%n"
argument_list|,
name|fsUri
argument_list|,
name|store
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|printOption
argument_list|(
name|out
argument_list|,
literal|"Authoritative S3Guard"
argument_list|,
name|METADATASTORE_AUTHORITATIVE
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
name|authMode
operator|=
name|conf
operator|.
name|getBoolean
argument_list|(
name|METADATASTORE_AUTHORITATIVE
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|printStoreDiagnostics
argument_list|(
name|out
argument_list|,
name|store
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|println
argument_list|(
name|out
argument_list|,
literal|"Filesystem %s is not using S3Guard"
argument_list|,
name|fsUri
argument_list|)
expr_stmt|;
block|}
name|boolean
name|magic
init|=
name|fs
operator|.
name|hasCapability
argument_list|(
name|CommitConstants
operator|.
name|STORE_CAPABILITY_MAGIC_COMMITTER
argument_list|)
decl_stmt|;
name|println
argument_list|(
name|out
argument_list|,
literal|"The \"magic\" committer %s supported"
argument_list|,
name|magic
condition|?
literal|"is"
else|:
literal|"is not"
argument_list|)
expr_stmt|;
name|println
argument_list|(
name|out
argument_list|,
literal|"%nS3A Client"
argument_list|)
expr_stmt|;
name|String
name|endpoint
init|=
name|conf
operator|.
name|getTrimmed
argument_list|(
name|ENDPOINT
argument_list|,
literal|""
argument_list|)
decl_stmt|;
name|println
argument_list|(
name|out
argument_list|,
literal|"\tEndpoint: %s=%s"
argument_list|,
name|ENDPOINT
argument_list|,
name|StringUtils
operator|.
name|isNotEmpty
argument_list|(
name|endpoint
argument_list|)
condition|?
name|endpoint
else|:
literal|"(unset)"
argument_list|)
expr_stmt|;
name|String
name|encryption
init|=
name|printOption
argument_list|(
name|out
argument_list|,
literal|"\tEncryption"
argument_list|,
name|SERVER_SIDE_ENCRYPTION_ALGORITHM
argument_list|,
literal|"none"
argument_list|)
decl_stmt|;
name|printOption
argument_list|(
name|out
argument_list|,
literal|"\tInput seek policy"
argument_list|,
name|INPUT_FADVISE
argument_list|,
name|INPUT_FADV_NORMAL
argument_list|)
expr_stmt|;
comment|// look at delegation token support
if|if
condition|(
name|fs
operator|.
name|getDelegationTokens
argument_list|()
operator|.
name|isPresent
argument_list|()
condition|)
block|{
comment|// DT is enabled
name|S3ADelegationTokens
name|dtIntegration
init|=
name|fs
operator|.
name|getDelegationTokens
argument_list|()
operator|.
name|get
argument_list|()
decl_stmt|;
name|println
argument_list|(
name|out
argument_list|,
literal|"Delegation Support enabled: token kind = %s"
argument_list|,
name|dtIntegration
operator|.
name|getTokenKind
argument_list|()
argument_list|)
expr_stmt|;
name|UserGroupInformation
operator|.
name|AuthenticationMethod
name|authenticationMethod
init|=
name|UserGroupInformation
operator|.
name|getCurrentUser
argument_list|()
operator|.
name|getAuthenticationMethod
argument_list|()
decl_stmt|;
name|println
argument_list|(
name|out
argument_list|,
literal|"Hadoop security mode: %s"
argument_list|,
name|authenticationMethod
argument_list|)
expr_stmt|;
if|if
condition|(
name|UserGroupInformation
operator|.
name|isSecurityEnabled
argument_list|()
condition|)
block|{
name|println
argument_list|(
name|out
argument_list|,
literal|"Warning: security is disabled; tokens will not be collected"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|println
argument_list|(
name|out
argument_list|,
literal|"Delegation token support is disabled"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|usingS3Guard
condition|)
block|{
if|if
condition|(
name|commands
operator|.
name|getOpt
argument_list|(
name|UNGUARDED_FLAG
argument_list|)
condition|)
block|{
throw|throw
name|badState
argument_list|(
literal|"S3Guard is enabled for %s"
argument_list|,
name|fsUri
argument_list|)
throw|;
block|}
if|if
condition|(
name|commands
operator|.
name|getOpt
argument_list|(
name|AUTH_FLAG
argument_list|)
operator|&&
operator|!
name|authMode
condition|)
block|{
throw|throw
name|badState
argument_list|(
literal|"S3Guard is enabled for %s,"
operator|+
literal|" but not in authoritative mode"
argument_list|,
name|fsUri
argument_list|)
throw|;
block|}
if|if
condition|(
name|commands
operator|.
name|getOpt
argument_list|(
name|NONAUTH_FLAG
argument_list|)
operator|&&
name|authMode
condition|)
block|{
throw|throw
name|badState
argument_list|(
literal|"S3Guard is enabled in authoritative mode for %s"
argument_list|,
name|fsUri
argument_list|)
throw|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|commands
operator|.
name|getOpt
argument_list|(
name|GUARDED_FLAG
argument_list|)
condition|)
block|{
throw|throw
name|badState
argument_list|(
literal|"S3Guard is not enabled for %s"
argument_list|,
name|fsUri
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
name|commands
operator|.
name|getOpt
argument_list|(
name|MAGIC_FLAG
argument_list|)
operator|&&
operator|!
name|magic
condition|)
block|{
throw|throw
name|badState
argument_list|(
literal|"The magic committer is not enabled for %s"
argument_list|,
name|fsUri
argument_list|)
throw|;
block|}
name|String
name|desiredEncryption
init|=
name|getCommandFormat
argument_list|()
operator|.
name|getOptValue
argument_list|(
name|ENCRYPTION_FLAG
argument_list|)
decl_stmt|;
if|if
condition|(
name|StringUtils
operator|.
name|isNotEmpty
argument_list|(
name|desiredEncryption
argument_list|)
operator|&&
operator|!
name|desiredEncryption
operator|.
name|equalsIgnoreCase
argument_list|(
name|encryption
argument_list|)
condition|)
block|{
throw|throw
name|badState
argument_list|(
literal|"Bucket %s: required encryption is %s"
operator|+
literal|" but actual encryption is %s"
argument_list|,
name|fsUri
argument_list|,
name|desiredEncryption
argument_list|,
name|encryption
argument_list|)
throw|;
block|}
name|out
operator|.
name|flush
argument_list|()
expr_stmt|;
return|return
name|SUCCESS
return|;
block|}
DECL|method|printOption (PrintStream out, String description, String key, String defVal)
specifier|private
name|String
name|printOption
parameter_list|(
name|PrintStream
name|out
parameter_list|,
name|String
name|description
parameter_list|,
name|String
name|key
parameter_list|,
name|String
name|defVal
parameter_list|)
block|{
name|String
name|t
init|=
name|getFilesystem
argument_list|()
operator|.
name|getConf
argument_list|()
operator|.
name|getTrimmed
argument_list|(
name|key
argument_list|,
name|defVal
argument_list|)
decl_stmt|;
name|println
argument_list|(
name|out
argument_list|,
literal|"%s: %s=%s"
argument_list|,
name|description
argument_list|,
name|key
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
block|}
comment|/**    * Command to list / abort pending multipart uploads.    */
DECL|class|Uploads
specifier|static
class|class
name|Uploads
extends|extends
name|S3GuardTool
block|{
DECL|field|NAME
specifier|public
specifier|static
specifier|final
name|String
name|NAME
init|=
literal|"uploads"
decl_stmt|;
DECL|field|ABORT
specifier|public
specifier|static
specifier|final
name|String
name|ABORT
init|=
literal|"abort"
decl_stmt|;
DECL|field|LIST
specifier|public
specifier|static
specifier|final
name|String
name|LIST
init|=
literal|"list"
decl_stmt|;
DECL|field|EXPECT
specifier|public
specifier|static
specifier|final
name|String
name|EXPECT
init|=
literal|"expect"
decl_stmt|;
DECL|field|VERBOSE
specifier|public
specifier|static
specifier|final
name|String
name|VERBOSE
init|=
literal|"verbose"
decl_stmt|;
DECL|field|FORCE
specifier|public
specifier|static
specifier|final
name|String
name|FORCE
init|=
literal|"force"
decl_stmt|;
DECL|field|PURPOSE
specifier|public
specifier|static
specifier|final
name|String
name|PURPOSE
init|=
literal|"list or abort pending "
operator|+
literal|"multipart uploads"
decl_stmt|;
DECL|field|USAGE
specifier|private
specifier|static
specifier|final
name|String
name|USAGE
init|=
name|NAME
operator|+
literal|" [OPTIONS] "
operator|+
literal|"s3a://BUCKET[/path]\n"
operator|+
literal|"\t"
operator|+
name|PURPOSE
operator|+
literal|"\n\n"
operator|+
literal|"Common options:\n"
operator|+
literal|" (-"
operator|+
name|LIST
operator|+
literal|" | -"
operator|+
name|EXPECT
operator|+
literal|"<num-uploads> | -"
operator|+
name|ABORT
operator|+
literal|") [-"
operator|+
name|VERBOSE
operator|+
literal|"] "
operator|+
literal|"[<age-options>] [-force]\n"
operator|+
literal|"\t - Under given path, list or delete all uploads,"
operator|+
literal|" or only those \n"
operator|+
literal|"older than specified by<age-options>\n"
operator|+
literal|"<age-options> are any combination of the integer-valued options:\n"
operator|+
literal|"\t"
operator|+
name|AGE_OPTIONS_USAGE
operator|+
literal|"\n"
operator|+
literal|"-"
operator|+
name|EXPECT
operator|+
literal|" is similar to list, except no output is printed,\n"
operator|+
literal|"\tbut the exit code will be an error if the provided number\n"
operator|+
literal|"\tis different that the number of uploads found by the command.\n"
operator|+
literal|"-"
operator|+
name|FORCE
operator|+
literal|" option prevents the \"Are you sure\" prompt when\n"
operator|+
literal|"\tusing -"
operator|+
name|ABORT
decl_stmt|;
comment|/** Constant used for output and parsed by tests. */
DECL|field|TOTAL
specifier|public
specifier|static
specifier|final
name|String
name|TOTAL
init|=
literal|"Total"
decl_stmt|;
comment|/** Runs in one of three modes. */
DECL|enum|Mode
DECL|enumConstant|LIST
DECL|enumConstant|EXPECT
DECL|enumConstant|ABORT
specifier|private
enum|enum
name|Mode
block|{
name|LIST
block|,
name|EXPECT
block|,
name|ABORT
block|}
empty_stmt|;
DECL|field|mode
specifier|private
name|Mode
name|mode
init|=
literal|null
decl_stmt|;
comment|/** For Mode == EXPECT, expected listing size. */
DECL|field|expectedCount
specifier|private
name|int
name|expectedCount
decl_stmt|;
comment|/** List/abort uploads older than this many milliseconds. */
DECL|field|ageMsec
specifier|private
name|long
name|ageMsec
init|=
literal|0
decl_stmt|;
comment|/** Verbose output flag. */
DECL|field|verbose
specifier|private
name|boolean
name|verbose
init|=
literal|false
decl_stmt|;
comment|/** Whether to delete with out "are you sure" prompt. */
DECL|field|force
specifier|private
name|boolean
name|force
init|=
literal|false
decl_stmt|;
comment|/** Path prefix to use when searching multipart uploads. */
DECL|field|prefix
specifier|private
name|String
name|prefix
decl_stmt|;
DECL|method|Uploads (Configuration conf)
name|Uploads
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
name|super
argument_list|(
name|conf
argument_list|,
name|ABORT
argument_list|,
name|LIST
argument_list|,
name|VERBOSE
argument_list|,
name|FORCE
argument_list|)
expr_stmt|;
name|addAgeOptions
argument_list|()
expr_stmt|;
name|getCommandFormat
argument_list|()
operator|.
name|addOptionWithValue
argument_list|(
name|EXPECT
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getName ()
specifier|public
name|String
name|getName
parameter_list|()
block|{
return|return
name|NAME
return|;
block|}
annotation|@
name|Override
DECL|method|getUsage ()
specifier|public
name|String
name|getUsage
parameter_list|()
block|{
return|return
name|USAGE
return|;
block|}
DECL|method|run (String[] args, PrintStream out)
specifier|public
name|int
name|run
parameter_list|(
name|String
index|[]
name|args
parameter_list|,
name|PrintStream
name|out
parameter_list|)
throws|throws
name|InterruptedException
throws|,
name|IOException
block|{
name|List
argument_list|<
name|String
argument_list|>
name|paths
init|=
name|parseArgs
argument_list|(
name|args
argument_list|)
decl_stmt|;
if|if
condition|(
name|paths
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|errorln
argument_list|(
name|getUsage
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
name|invalidArgs
argument_list|(
literal|"No options specified"
argument_list|)
throw|;
block|}
name|processArgs
argument_list|(
name|paths
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|promptBeforeAbort
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|processUploads
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|out
operator|.
name|flush
argument_list|()
expr_stmt|;
return|return
name|SUCCESS
return|;
block|}
DECL|method|promptBeforeAbort (PrintStream out)
specifier|private
name|void
name|promptBeforeAbort
parameter_list|(
name|PrintStream
name|out
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|mode
operator|!=
name|Mode
operator|.
name|ABORT
operator|||
name|force
condition|)
block|{
return|return;
block|}
name|Scanner
name|scanner
init|=
operator|new
name|Scanner
argument_list|(
name|System
operator|.
name|in
argument_list|,
literal|"UTF-8"
argument_list|)
decl_stmt|;
name|out
operator|.
name|println
argument_list|(
literal|"Are you sure you want to delete any pending "
operator|+
literal|"uploads? (yes/no)>"
argument_list|)
expr_stmt|;
name|String
name|response
init|=
name|scanner
operator|.
name|nextLine
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
literal|"yes"
operator|.
name|equalsIgnoreCase
argument_list|(
name|response
argument_list|)
condition|)
block|{
throw|throw
name|S3GuardTool
operator|.
name|userAborted
argument_list|(
literal|"User did not answer yes, quitting."
argument_list|)
throw|;
block|}
block|}
DECL|method|processUploads (PrintStream out)
specifier|private
name|void
name|processUploads
parameter_list|(
name|PrintStream
name|out
parameter_list|)
throws|throws
name|IOException
block|{
name|MultipartUtils
operator|.
name|UploadIterator
name|uploads
decl_stmt|;
name|uploads
operator|=
name|getFilesystem
argument_list|()
operator|.
name|listUploads
argument_list|(
name|prefix
argument_list|)
expr_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|uploads
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|MultipartUpload
name|upload
init|=
name|uploads
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|olderThan
argument_list|(
name|upload
argument_list|,
name|ageMsec
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|count
operator|++
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|Mode
operator|.
name|ABORT
operator|||
name|mode
operator|==
name|Mode
operator|.
name|LIST
operator|||
name|verbose
condition|)
block|{
name|println
argument_list|(
name|out
argument_list|,
literal|"%s%s %s"
argument_list|,
name|mode
operator|==
name|Mode
operator|.
name|ABORT
condition|?
literal|"Deleting: "
else|:
literal|""
argument_list|,
name|upload
operator|.
name|getKey
argument_list|()
argument_list|,
name|upload
operator|.
name|getUploadId
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mode
operator|==
name|Mode
operator|.
name|ABORT
condition|)
block|{
name|getFilesystem
argument_list|()
operator|.
name|getWriteOperationHelper
argument_list|()
operator|.
name|abortMultipartUpload
argument_list|(
name|upload
operator|.
name|getKey
argument_list|()
argument_list|,
name|upload
operator|.
name|getUploadId
argument_list|()
argument_list|,
name|LOG_EVENT
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mode
operator|!=
name|Mode
operator|.
name|EXPECT
operator|||
name|verbose
condition|)
block|{
name|println
argument_list|(
name|out
argument_list|,
literal|"%s %d uploads %s."
argument_list|,
name|TOTAL
argument_list|,
name|count
argument_list|,
name|mode
operator|==
name|Mode
operator|.
name|ABORT
condition|?
literal|"deleted"
else|:
literal|"found"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mode
operator|==
name|Mode
operator|.
name|EXPECT
condition|)
block|{
if|if
condition|(
name|count
operator|!=
name|expectedCount
condition|)
block|{
throw|throw
name|badState
argument_list|(
literal|"Expected %d uploads, found %d"
argument_list|,
name|expectedCount
argument_list|,
name|count
argument_list|)
throw|;
block|}
block|}
block|}
comment|/**      * Check if upload is at least as old as given age.      * @param u upload to check      * @param msec age in milliseconds      * @return true iff u was created at least age milliseconds ago.      */
DECL|method|olderThan (MultipartUpload u, long msec)
specifier|private
name|boolean
name|olderThan
parameter_list|(
name|MultipartUpload
name|u
parameter_list|,
name|long
name|msec
parameter_list|)
block|{
name|Date
name|ageDate
init|=
operator|new
name|Date
argument_list|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|msec
argument_list|)
decl_stmt|;
return|return
name|ageDate
operator|.
name|compareTo
argument_list|(
name|u
operator|.
name|getInitiated
argument_list|()
argument_list|)
operator|>=
literal|0
return|;
block|}
DECL|method|processArgs (List<String> args, PrintStream out)
specifier|private
name|void
name|processArgs
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|args
parameter_list|,
name|PrintStream
name|out
parameter_list|)
throws|throws
name|IOException
block|{
name|CommandFormat
name|commands
init|=
name|getCommandFormat
argument_list|()
decl_stmt|;
name|String
name|err
init|=
literal|"Can only specify one of -"
operator|+
name|LIST
operator|+
literal|", "
operator|+
literal|" -"
operator|+
name|ABORT
operator|+
literal|", and "
operator|+
name|EXPECT
decl_stmt|;
comment|// Three mutually-exclusive options
if|if
condition|(
name|commands
operator|.
name|getOpt
argument_list|(
name|LIST
argument_list|)
condition|)
block|{
name|mode
operator|=
name|Mode
operator|.
name|LIST
expr_stmt|;
block|}
if|if
condition|(
name|commands
operator|.
name|getOpt
argument_list|(
name|ABORT
argument_list|)
condition|)
block|{
if|if
condition|(
name|mode
operator|!=
literal|null
condition|)
block|{
throw|throw
name|invalidArgs
argument_list|(
name|err
argument_list|)
throw|;
block|}
name|mode
operator|=
name|Mode
operator|.
name|ABORT
expr_stmt|;
block|}
name|String
name|expectVal
init|=
name|commands
operator|.
name|getOptValue
argument_list|(
name|EXPECT
argument_list|)
decl_stmt|;
if|if
condition|(
name|expectVal
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|mode
operator|!=
literal|null
condition|)
block|{
throw|throw
name|invalidArgs
argument_list|(
name|err
argument_list|)
throw|;
block|}
name|mode
operator|=
name|Mode
operator|.
name|EXPECT
expr_stmt|;
name|expectedCount
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|expectVal
argument_list|)
expr_stmt|;
block|}
comment|// Default to list
if|if
condition|(
name|mode
operator|==
literal|null
condition|)
block|{
name|vprintln
argument_list|(
name|out
argument_list|,
literal|"No mode specified, defaulting to -"
operator|+
name|LIST
argument_list|)
expr_stmt|;
name|mode
operator|=
name|Mode
operator|.
name|LIST
expr_stmt|;
block|}
comment|// Other flags
if|if
condition|(
name|commands
operator|.
name|getOpt
argument_list|(
name|VERBOSE
argument_list|)
condition|)
block|{
name|verbose
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|commands
operator|.
name|getOpt
argument_list|(
name|FORCE
argument_list|)
condition|)
block|{
name|force
operator|=
literal|true
expr_stmt|;
block|}
name|ageMsec
operator|=
name|ageOptionsToMsec
argument_list|()
expr_stmt|;
name|String
name|s3Path
init|=
name|args
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|URI
name|uri
init|=
name|S3GuardTool
operator|.
name|toUri
argument_list|(
name|s3Path
argument_list|)
decl_stmt|;
name|prefix
operator|=
name|uri
operator|.
name|getPath
argument_list|()
expr_stmt|;
if|if
condition|(
name|prefix
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|prefix
operator|=
name|prefix
operator|.
name|substring
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|vprintln
argument_list|(
name|out
argument_list|,
literal|"Command: %s, age %d msec, path %s (prefix \"%s\")"
argument_list|,
name|mode
operator|.
name|name
argument_list|()
argument_list|,
name|ageMsec
argument_list|,
name|s3Path
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
name|initS3AFileSystem
argument_list|(
name|s3Path
argument_list|)
expr_stmt|;
block|}
comment|/**      * If verbose flag is set, print a formatted string followed by a newline      * to the output stream.      * @param out destination      * @param format format string      * @param args optional arguments      */
DECL|method|vprintln (PrintStream out, String format, Object... args)
specifier|private
name|void
name|vprintln
parameter_list|(
name|PrintStream
name|out
parameter_list|,
name|String
name|format
parameter_list|,
name|Object
modifier|...
name|args
parameter_list|)
block|{
if|if
condition|(
name|verbose
condition|)
block|{
name|out
operator|.
name|println
argument_list|(
name|String
operator|.
name|format
argument_list|(
name|format
argument_list|,
name|args
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|field|command
specifier|private
specifier|static
name|S3GuardTool
name|command
decl_stmt|;
comment|/**    * Convert a path to a URI, catching any {@code URISyntaxException}    * and converting to an invalid args exception.    * @param s3Path path to convert to a URI    * @return a URI of the path    * @throws ExitUtil.ExitException INVALID_ARGUMENT if the URI is invalid    */
DECL|method|toUri (String s3Path)
specifier|protected
specifier|static
name|URI
name|toUri
parameter_list|(
name|String
name|s3Path
parameter_list|)
block|{
name|URI
name|uri
decl_stmt|;
try|try
block|{
name|uri
operator|=
operator|new
name|URI
argument_list|(
name|s3Path
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|URISyntaxException
name|e
parameter_list|)
block|{
throw|throw
name|invalidArgs
argument_list|(
literal|"Not a valid fileystem path: %s"
argument_list|,
name|s3Path
argument_list|)
throw|;
block|}
return|return
name|uri
return|;
block|}
DECL|method|printHelp ()
specifier|private
specifier|static
name|void
name|printHelp
parameter_list|()
block|{
if|if
condition|(
name|command
operator|==
literal|null
condition|)
block|{
name|errorln
argument_list|(
literal|"Usage: hadoop "
operator|+
name|USAGE
argument_list|)
expr_stmt|;
name|errorln
argument_list|(
literal|"\tperform S3Guard metadata store "
operator|+
literal|"administrative commands."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|errorln
argument_list|(
literal|"Usage: hadoop "
operator|+
name|command
operator|.
name|getUsage
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|errorln
argument_list|()
expr_stmt|;
name|errorln
argument_list|(
name|COMMON_USAGE
argument_list|)
expr_stmt|;
block|}
DECL|method|errorln ()
specifier|protected
specifier|static
name|void
name|errorln
parameter_list|()
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|()
expr_stmt|;
block|}
DECL|method|errorln (String x)
specifier|protected
specifier|static
name|void
name|errorln
parameter_list|(
name|String
name|x
parameter_list|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
comment|/**    * Print a formatted string followed by a newline to the output stream.    * @param out destination    * @param format format string    * @param args optional arguments    */
DECL|method|println (PrintStream out, String format, Object... args)
specifier|protected
specifier|static
name|void
name|println
parameter_list|(
name|PrintStream
name|out
parameter_list|,
name|String
name|format
parameter_list|,
name|Object
modifier|...
name|args
parameter_list|)
block|{
name|out
operator|.
name|println
argument_list|(
name|String
operator|.
name|format
argument_list|(
name|format
argument_list|,
name|args
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Retrieve and Print store diagnostics.    * @param out output stream    * @param store store    * @throws IOException Failure to retrieve the data.    */
DECL|method|printStoreDiagnostics (PrintStream out, MetadataStore store)
specifier|protected
specifier|static
name|void
name|printStoreDiagnostics
parameter_list|(
name|PrintStream
name|out
parameter_list|,
name|MetadataStore
name|store
parameter_list|)
throws|throws
name|IOException
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|diagnostics
init|=
name|store
operator|.
name|getDiagnostics
argument_list|()
decl_stmt|;
name|out
operator|.
name|println
argument_list|(
literal|"Metadata Store Diagnostics:"
argument_list|)
expr_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|entry
range|:
name|diagnostics
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|println
argument_list|(
name|out
argument_list|,
literal|"\t%s=%s"
argument_list|,
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Handle store not found by converting to an exit exception    * with specific error code.    * @param e exception    * @return a new exception to throw    */
DECL|method|storeNotFound ( FileNotFoundException e)
specifier|protected
specifier|static
name|ExitUtil
operator|.
name|ExitException
name|storeNotFound
parameter_list|(
name|FileNotFoundException
name|e
parameter_list|)
block|{
return|return
operator|new
name|ExitUtil
operator|.
name|ExitException
argument_list|(
name|E_NOT_FOUND
argument_list|,
name|e
operator|.
name|toString
argument_list|()
argument_list|,
name|e
argument_list|)
return|;
block|}
comment|/**    * Build the exception to raise on invalid arguments.    * @param format string format    * @param args optional arguments for the string    * @return a new exception to throw    */
DECL|method|invalidArgs ( String format, Object...args)
specifier|protected
specifier|static
name|ExitUtil
operator|.
name|ExitException
name|invalidArgs
parameter_list|(
name|String
name|format
parameter_list|,
name|Object
modifier|...
name|args
parameter_list|)
block|{
return|return
name|exitException
argument_list|(
name|INVALID_ARGUMENT
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
return|;
block|}
comment|/**    * Build the exception to raise on a bad store/bucket state.    * @param format string format    * @param args optional arguments for the string    * @return a new exception to throw    */
DECL|method|badState ( String format, Object...args)
specifier|protected
specifier|static
name|ExitUtil
operator|.
name|ExitException
name|badState
parameter_list|(
name|String
name|format
parameter_list|,
name|Object
modifier|...
name|args
parameter_list|)
block|{
name|int
name|exitCode
init|=
name|E_BAD_STATE
decl_stmt|;
return|return
name|exitException
argument_list|(
name|exitCode
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
return|;
block|}
comment|/**    * Build the exception to raise on user-aborted action.    * @param format string format    * @param args optional arguments for the string    * @return a new exception to throw    */
DECL|method|userAborted ( String format, Object...args)
specifier|protected
specifier|static
name|ExitUtil
operator|.
name|ExitException
name|userAborted
parameter_list|(
name|String
name|format
parameter_list|,
name|Object
modifier|...
name|args
parameter_list|)
block|{
return|return
name|exitException
argument_list|(
name|ERROR
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
return|;
block|}
comment|/**    * Build a exception to throw with a formatted message.    * @param exitCode exit code to use    * @param format string format    * @param args optional arguments for the string    * @return a new exception to throw    */
DECL|method|exitException ( final int exitCode, final String format, final Object... args)
specifier|protected
specifier|static
name|ExitUtil
operator|.
name|ExitException
name|exitException
parameter_list|(
specifier|final
name|int
name|exitCode
parameter_list|,
specifier|final
name|String
name|format
parameter_list|,
specifier|final
name|Object
modifier|...
name|args
parameter_list|)
block|{
return|return
operator|new
name|ExitUtil
operator|.
name|ExitException
argument_list|(
name|exitCode
argument_list|,
name|String
operator|.
name|format
argument_list|(
name|format
argument_list|,
name|args
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Execute the command with the given arguments.    *    * @param conf Hadoop configuration.    * @param args command specific arguments.    * @return exit code.    * @throws Exception on I/O errors.    */
DECL|method|run (Configuration conf, String...args)
specifier|public
specifier|static
name|int
name|run
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|String
modifier|...
name|args
parameter_list|)
throws|throws
name|Exception
block|{
comment|/* ToolRunner.run does this too, but we must do it before looking at     subCommand or instantiating the cmd object below */
name|String
index|[]
name|otherArgs
init|=
operator|new
name|GenericOptionsParser
argument_list|(
name|conf
argument_list|,
name|args
argument_list|)
operator|.
name|getRemainingArgs
argument_list|()
decl_stmt|;
if|if
condition|(
name|otherArgs
operator|.
name|length
operator|==
literal|0
condition|)
block|{
name|printHelp
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|ExitUtil
operator|.
name|ExitException
argument_list|(
name|E_USAGE
argument_list|,
literal|"No arguments provided"
argument_list|)
throw|;
block|}
specifier|final
name|String
name|subCommand
init|=
name|otherArgs
index|[
literal|0
index|]
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Executing command {}"
argument_list|,
name|subCommand
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|subCommand
condition|)
block|{
case|case
name|Init
operator|.
name|NAME
case|:
name|command
operator|=
operator|new
name|Init
argument_list|(
name|conf
argument_list|)
expr_stmt|;
break|break;
case|case
name|Destroy
operator|.
name|NAME
case|:
name|command
operator|=
operator|new
name|Destroy
argument_list|(
name|conf
argument_list|)
expr_stmt|;
break|break;
case|case
name|Import
operator|.
name|NAME
case|:
name|command
operator|=
operator|new
name|Import
argument_list|(
name|conf
argument_list|)
expr_stmt|;
break|break;
case|case
name|BucketInfo
operator|.
name|NAME
case|:
name|command
operator|=
operator|new
name|BucketInfo
argument_list|(
name|conf
argument_list|)
expr_stmt|;
break|break;
case|case
name|Diff
operator|.
name|NAME
case|:
name|command
operator|=
operator|new
name|Diff
argument_list|(
name|conf
argument_list|)
expr_stmt|;
break|break;
case|case
name|Prune
operator|.
name|NAME
case|:
name|command
operator|=
operator|new
name|Prune
argument_list|(
name|conf
argument_list|)
expr_stmt|;
break|break;
case|case
name|SetCapacity
operator|.
name|NAME
case|:
name|command
operator|=
operator|new
name|SetCapacity
argument_list|(
name|conf
argument_list|)
expr_stmt|;
break|break;
case|case
name|Uploads
operator|.
name|NAME
case|:
name|command
operator|=
operator|new
name|Uploads
argument_list|(
name|conf
argument_list|)
expr_stmt|;
break|break;
case|case
name|SelectTool
operator|.
name|NAME
case|:
comment|// the select tool is not technically a S3Guard tool, but it's on the CLI
comment|// because this is the defacto S3 CLI.
name|command
operator|=
operator|new
name|SelectTool
argument_list|(
name|conf
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printHelp
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|ExitUtil
operator|.
name|ExitException
argument_list|(
name|E_USAGE
argument_list|,
literal|"Unknown command "
operator|+
name|subCommand
argument_list|)
throw|;
block|}
return|return
name|ToolRunner
operator|.
name|run
argument_list|(
name|conf
argument_list|,
name|command
argument_list|,
name|otherArgs
argument_list|)
return|;
block|}
comment|/**    * Main entry point. Calls {@code System.exit()} on all execution paths.    * @param args argument list    */
DECL|method|main (String[] args)
specifier|public
specifier|static
name|void
name|main
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
block|{
try|try
block|{
name|int
name|ret
init|=
name|run
argument_list|(
operator|new
name|Configuration
argument_list|()
argument_list|,
name|args
argument_list|)
decl_stmt|;
name|exit
argument_list|(
name|ret
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|CommandFormat
operator|.
name|UnknownOptionException
name|e
parameter_list|)
block|{
name|errorln
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
name|printHelp
argument_list|()
expr_stmt|;
name|exit
argument_list|(
name|E_USAGE
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ExitUtil
operator|.
name|ExitException
name|e
parameter_list|)
block|{
comment|// explicitly raised exit code
name|exit
argument_list|(
name|e
operator|.
name|getExitCode
argument_list|()
argument_list|,
name|e
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|e
operator|.
name|printStackTrace
argument_list|(
name|System
operator|.
name|err
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|ERROR
argument_list|,
name|e
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|exit (int status, String text)
specifier|protected
specifier|static
name|void
name|exit
parameter_list|(
name|int
name|status
parameter_list|,
name|String
name|text
parameter_list|)
block|{
name|ExitUtil
operator|.
name|terminate
argument_list|(
name|status
argument_list|,
name|text
argument_list|)
expr_stmt|;
block|}
block|}
end_class

end_unit

