begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *<p>  * http://www.apache.org/licenses/LICENSE-2.0  *<p>  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.fs.s3a.s3guard
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|s3guard
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileNotFoundException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|InvalidParameterException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayDeque
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Queue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|com
operator|.
name|amazonaws
operator|.
name|services
operator|.
name|dynamodbv2
operator|.
name|document
operator|.
name|Item
import|;
end_import

begin_import
import|import
name|com
operator|.
name|amazonaws
operator|.
name|services
operator|.
name|dynamodbv2
operator|.
name|document
operator|.
name|PrimaryKey
import|;
end_import

begin_import
import|import
name|com
operator|.
name|amazonaws
operator|.
name|services
operator|.
name|dynamodbv2
operator|.
name|document
operator|.
name|ScanOutcome
import|;
end_import

begin_import
import|import
name|com
operator|.
name|amazonaws
operator|.
name|services
operator|.
name|dynamodbv2
operator|.
name|document
operator|.
name|Table
import|;
end_import

begin_import
import|import
name|com
operator|.
name|amazonaws
operator|.
name|services
operator|.
name|dynamodbv2
operator|.
name|document
operator|.
name|internal
operator|.
name|IteratorSupport
import|;
end_import

begin_import
import|import
name|com
operator|.
name|amazonaws
operator|.
name|services
operator|.
name|dynamodbv2
operator|.
name|document
operator|.
name|spec
operator|.
name|GetItemSpec
import|;
end_import

begin_import
import|import
name|com
operator|.
name|amazonaws
operator|.
name|services
operator|.
name|dynamodbv2
operator|.
name|xspec
operator|.
name|ExpressionSpecBuilder
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|S3AFileStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|S3AFileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|Tristate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StopWatch
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|util
operator|.
name|stream
operator|.
name|Collectors
operator|.
name|toList
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|util
operator|.
name|stream
operator|.
name|Collectors
operator|.
name|toSet
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|s3guard
operator|.
name|PathMetadataDynamoDBTranslation
operator|.
name|itemToPathMetadata
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|s3guard
operator|.
name|PathMetadataDynamoDBTranslation
operator|.
name|pathToKey
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|s3guard
operator|.
name|PathMetadataDynamoDBTranslation
operator|.
name|pathToParentKey
import|;
end_import

begin_comment
comment|/**  * Main class for the FSCK factored out from S3GuardTool  * The implementation uses fixed DynamoDBMetadataStore as the backing store  * for metadata.  *  * Functions:  *<ul>  *<li>Checking metadata consistency between S3 and metadatastore</li>  *<li>Checking the internal metadata consistency</li>  *</ul>  */
end_comment

begin_class
DECL|class|S3GuardFsck
specifier|public
class|class
name|S3GuardFsck
block|{
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|S3GuardFsck
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|ROOT_PATH_STRING
specifier|public
specifier|static
specifier|final
name|String
name|ROOT_PATH_STRING
init|=
literal|"/"
decl_stmt|;
DECL|field|rawFS
specifier|private
specifier|final
name|S3AFileSystem
name|rawFS
decl_stmt|;
DECL|field|metadataStore
specifier|private
specifier|final
name|DynamoDBMetadataStore
name|metadataStore
decl_stmt|;
DECL|field|MOD_TIME_RANGE
specifier|private
specifier|static
specifier|final
name|long
name|MOD_TIME_RANGE
init|=
literal|2000L
decl_stmt|;
comment|/**    * Creates an S3GuardFsck.    * @param fs the filesystem to compare to    * @param ms metadatastore the metadatastore to compare with (dynamo)    */
DECL|method|S3GuardFsck (S3AFileSystem fs, MetadataStore ms)
specifier|public
name|S3GuardFsck
parameter_list|(
name|S3AFileSystem
name|fs
parameter_list|,
name|MetadataStore
name|ms
parameter_list|)
throws|throws
name|InvalidParameterException
block|{
name|this
operator|.
name|rawFS
operator|=
name|fs
expr_stmt|;
if|if
condition|(
name|ms
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|InvalidParameterException
argument_list|(
literal|"S3A Bucket "
operator|+
name|fs
operator|.
name|getBucket
argument_list|()
operator|+
literal|" should be guarded by a "
operator|+
name|DynamoDBMetadataStore
operator|.
name|class
operator|.
name|getCanonicalName
argument_list|()
argument_list|)
throw|;
block|}
name|this
operator|.
name|metadataStore
operator|=
operator|(
name|DynamoDBMetadataStore
operator|)
name|ms
expr_stmt|;
name|Preconditions
operator|.
name|checkArgument
argument_list|(
operator|!
name|rawFS
operator|.
name|hasMetadataStore
argument_list|()
argument_list|,
literal|"Raw fs should not have a metadatastore."
argument_list|)
expr_stmt|;
block|}
comment|/**    * Compares S3 to MS.    * Iterative breadth first walk on the S3 structure from a given root.    * Creates a list of pairs (metadata in S3 and in the MetadataStore) where    * the consistency or any rule is violated.    * Uses {@link S3GuardFsckViolationHandler} to handle violations.    * The violations are listed in Enums: {@link Violation}    *    * @param p the root path to start the traversal    * @return a list of {@link ComparePair}    * @throws IOException    */
DECL|method|compareS3ToMs (Path p)
specifier|public
name|List
argument_list|<
name|ComparePair
argument_list|>
name|compareS3ToMs
parameter_list|(
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
name|StopWatch
name|stopwatch
init|=
operator|new
name|StopWatch
argument_list|()
decl_stmt|;
name|stopwatch
operator|.
name|start
argument_list|()
expr_stmt|;
name|int
name|scannedItems
init|=
literal|0
decl_stmt|;
specifier|final
name|Path
name|rootPath
init|=
name|rawFS
operator|.
name|qualify
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|S3AFileStatus
name|root
init|=
operator|(
name|S3AFileStatus
operator|)
name|rawFS
operator|.
name|getFileStatus
argument_list|(
name|rootPath
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|ComparePair
argument_list|>
name|comparePairs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|Queue
argument_list|<
name|S3AFileStatus
argument_list|>
name|queue
init|=
operator|new
name|ArrayDeque
argument_list|<>
argument_list|()
decl_stmt|;
name|queue
operator|.
name|add
argument_list|(
name|root
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|queue
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
specifier|final
name|S3AFileStatus
name|currentDir
init|=
name|queue
operator|.
name|poll
argument_list|()
decl_stmt|;
specifier|final
name|Path
name|currentDirPath
init|=
name|currentDir
operator|.
name|getPath
argument_list|()
decl_stmt|;
try|try
block|{
name|List
argument_list|<
name|FileStatus
argument_list|>
name|s3DirListing
init|=
name|Arrays
operator|.
name|asList
argument_list|(
name|rawFS
operator|.
name|listStatus
argument_list|(
name|currentDirPath
argument_list|)
argument_list|)
decl_stmt|;
comment|// Check authoritative directory flag.
name|compareAuthoritativeDirectoryFlag
argument_list|(
name|comparePairs
argument_list|,
name|currentDirPath
argument_list|,
name|s3DirListing
argument_list|)
expr_stmt|;
comment|// Add all descendant directory to the queue
name|s3DirListing
operator|.
name|stream
argument_list|()
operator|.
name|filter
argument_list|(
name|pm
lambda|->
name|pm
operator|.
name|isDirectory
argument_list|()
argument_list|)
operator|.
name|map
argument_list|(
name|S3AFileStatus
operator|.
name|class
operator|::
name|cast
argument_list|)
operator|.
name|forEach
argument_list|(
name|pm
lambda|->
name|queue
operator|.
name|add
argument_list|(
name|pm
argument_list|)
argument_list|)
expr_stmt|;
comment|// Check file and directory metadata for consistency.
specifier|final
name|List
argument_list|<
name|S3AFileStatus
argument_list|>
name|children
init|=
name|s3DirListing
operator|.
name|stream
argument_list|()
operator|.
name|filter
argument_list|(
name|status
lambda|->
operator|!
name|status
operator|.
name|isDirectory
argument_list|()
argument_list|)
operator|.
name|map
argument_list|(
name|S3AFileStatus
operator|.
name|class
operator|::
name|cast
argument_list|)
operator|.
name|collect
argument_list|(
name|toList
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|ComparePair
argument_list|>
name|compareResult
init|=
name|compareS3DirContentToMs
argument_list|(
name|currentDir
argument_list|,
name|children
argument_list|)
decl_stmt|;
name|comparePairs
operator|.
name|addAll
argument_list|(
name|compareResult
argument_list|)
expr_stmt|;
comment|// Increase the scanned file size.
comment|// One for the directory, one for the children.
name|scannedItems
operator|++
expr_stmt|;
name|scannedItems
operator|+=
name|children
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"The path has been deleted since it was queued: "
operator|+
name|currentDirPath
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
name|stopwatch
operator|.
name|stop
argument_list|()
expr_stmt|;
comment|// Create a handler and handle each violated pairs
name|S3GuardFsckViolationHandler
name|handler
init|=
operator|new
name|S3GuardFsckViolationHandler
argument_list|(
name|rawFS
argument_list|,
name|metadataStore
argument_list|)
decl_stmt|;
name|comparePairs
operator|.
name|forEach
argument_list|(
name|handler
operator|::
name|handle
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Total scan time: {}s"
argument_list|,
name|stopwatch
operator|.
name|now
argument_list|(
name|TimeUnit
operator|.
name|SECONDS
argument_list|)
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Scanned entries: {}"
argument_list|,
name|scannedItems
argument_list|)
expr_stmt|;
return|return
name|comparePairs
return|;
block|}
comment|/**    * Compare the directory contents if the listing is authoritative.    *    * @param comparePairs the list of compare pairs to add to    *                     if it contains a violation    * @param currentDirPath the current directory path    * @param s3DirListing the s3 directory listing to compare with    * @throws IOException    */
DECL|method|compareAuthoritativeDirectoryFlag (List<ComparePair> comparePairs, Path currentDirPath, List<FileStatus> s3DirListing)
specifier|private
name|void
name|compareAuthoritativeDirectoryFlag
parameter_list|(
name|List
argument_list|<
name|ComparePair
argument_list|>
name|comparePairs
parameter_list|,
name|Path
name|currentDirPath
parameter_list|,
name|List
argument_list|<
name|FileStatus
argument_list|>
name|s3DirListing
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|DirListingMetadata
name|msDirListing
init|=
name|metadataStore
operator|.
name|listChildren
argument_list|(
name|currentDirPath
argument_list|)
decl_stmt|;
if|if
condition|(
name|msDirListing
operator|!=
literal|null
operator|&&
name|msDirListing
operator|.
name|isAuthoritative
argument_list|()
condition|)
block|{
name|ComparePair
name|cP
init|=
operator|new
name|ComparePair
argument_list|(
name|s3DirListing
argument_list|,
name|msDirListing
argument_list|)
decl_stmt|;
if|if
condition|(
name|s3DirListing
operator|.
name|size
argument_list|()
operator|!=
name|msDirListing
operator|.
name|numEntries
argument_list|()
condition|)
block|{
name|cP
operator|.
name|violations
operator|.
name|add
argument_list|(
name|Violation
operator|.
name|AUTHORITATIVE_DIRECTORY_CONTENT_MISMATCH
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|final
name|Set
argument_list|<
name|Path
argument_list|>
name|msPaths
init|=
name|msDirListing
operator|.
name|getListing
argument_list|()
operator|.
name|stream
argument_list|()
operator|.
name|map
argument_list|(
name|pm
lambda|->
name|pm
operator|.
name|getFileStatus
argument_list|()
operator|.
name|getPath
argument_list|()
argument_list|)
operator|.
name|collect
argument_list|(
name|toSet
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|Path
argument_list|>
name|s3Paths
init|=
name|s3DirListing
operator|.
name|stream
argument_list|()
operator|.
name|map
argument_list|(
name|pm
lambda|->
name|pm
operator|.
name|getPath
argument_list|()
argument_list|)
operator|.
name|collect
argument_list|(
name|toSet
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|s3Paths
operator|.
name|equals
argument_list|(
name|msPaths
argument_list|)
condition|)
block|{
name|cP
operator|.
name|violations
operator|.
name|add
argument_list|(
name|Violation
operator|.
name|AUTHORITATIVE_DIRECTORY_CONTENT_MISMATCH
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cP
operator|.
name|containsViolation
argument_list|()
condition|)
block|{
name|comparePairs
operator|.
name|add
argument_list|(
name|cP
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Compares S3 directory content to the metadata store.    *    * @param s3CurrentDir file status of the current directory    * @param children the contents of the directory    * @return the compare pairs with violations of consistency    * @throws IOException    */
DECL|method|compareS3DirContentToMs ( S3AFileStatus s3CurrentDir, List<S3AFileStatus> children)
specifier|protected
name|List
argument_list|<
name|ComparePair
argument_list|>
name|compareS3DirContentToMs
parameter_list|(
name|S3AFileStatus
name|s3CurrentDir
parameter_list|,
name|List
argument_list|<
name|S3AFileStatus
argument_list|>
name|children
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|Path
name|path
init|=
name|s3CurrentDir
operator|.
name|getPath
argument_list|()
decl_stmt|;
specifier|final
name|PathMetadata
name|pathMetadata
init|=
name|metadataStore
operator|.
name|get
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|ComparePair
argument_list|>
name|violationComparePairs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|ComparePair
name|rootComparePair
init|=
name|compareFileStatusToPathMetadata
argument_list|(
name|s3CurrentDir
argument_list|,
name|pathMetadata
argument_list|)
decl_stmt|;
if|if
condition|(
name|rootComparePair
operator|.
name|containsViolation
argument_list|()
condition|)
block|{
name|violationComparePairs
operator|.
name|add
argument_list|(
name|rootComparePair
argument_list|)
expr_stmt|;
block|}
name|children
operator|.
name|forEach
argument_list|(
name|s3ChildMeta
lambda|->
block|{
try|try
block|{
specifier|final
name|PathMetadata
name|msChildMeta
init|=
name|metadataStore
operator|.
name|get
argument_list|(
name|s3ChildMeta
operator|.
name|getPath
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|ComparePair
name|comparePair
init|=
name|compareFileStatusToPathMetadata
argument_list|(
name|s3ChildMeta
argument_list|,
name|msChildMeta
argument_list|)
decl_stmt|;
if|if
condition|(
name|comparePair
operator|.
name|containsViolation
argument_list|()
condition|)
block|{
name|violationComparePairs
operator|.
name|add
argument_list|(
name|comparePair
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
return|return
name|violationComparePairs
return|;
block|}
comment|/**    * Compares a {@link S3AFileStatus} from S3 to a {@link PathMetadata}    * from the metadata store. Finds violated invariants and consistency    * issues.    *    * @param s3FileStatus the file status from S3    * @param msPathMetadata the path metadata from metadatastore    * @return {@link ComparePair} with the found issues    * @throws IOException    */
DECL|method|compareFileStatusToPathMetadata ( S3AFileStatus s3FileStatus, PathMetadata msPathMetadata)
specifier|protected
name|ComparePair
name|compareFileStatusToPathMetadata
parameter_list|(
name|S3AFileStatus
name|s3FileStatus
parameter_list|,
name|PathMetadata
name|msPathMetadata
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|Path
name|path
init|=
name|s3FileStatus
operator|.
name|getPath
argument_list|()
decl_stmt|;
if|if
condition|(
name|msPathMetadata
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Path: {} - Length S3: {}, MS: {} "
operator|+
literal|"- Etag S3: {}, MS: {} "
argument_list|,
name|path
argument_list|,
name|s3FileStatus
operator|.
name|getLen
argument_list|()
argument_list|,
name|msPathMetadata
operator|.
name|getFileStatus
argument_list|()
operator|.
name|getLen
argument_list|()
argument_list|,
name|s3FileStatus
operator|.
name|getETag
argument_list|()
argument_list|,
name|msPathMetadata
operator|.
name|getFileStatus
argument_list|()
operator|.
name|getETag
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Path: {} - Length S3: {} - Etag S3: {}, no record in MS."
argument_list|,
name|path
argument_list|,
name|s3FileStatus
operator|.
name|getLen
argument_list|()
argument_list|,
name|s3FileStatus
operator|.
name|getETag
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|ComparePair
name|comparePair
init|=
operator|new
name|ComparePair
argument_list|(
name|s3FileStatus
argument_list|,
name|msPathMetadata
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|path
operator|.
name|equals
argument_list|(
name|path
argument_list|(
name|ROOT_PATH_STRING
argument_list|)
argument_list|)
condition|)
block|{
specifier|final
name|Path
name|parentPath
init|=
name|path
operator|.
name|getParent
argument_list|()
decl_stmt|;
specifier|final
name|PathMetadata
name|parentPm
init|=
name|metadataStore
operator|.
name|get
argument_list|(
name|parentPath
argument_list|)
decl_stmt|;
if|if
condition|(
name|parentPm
operator|==
literal|null
condition|)
block|{
name|comparePair
operator|.
name|violations
operator|.
name|add
argument_list|(
name|Violation
operator|.
name|NO_PARENT_ENTRY
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|parentPm
operator|.
name|getFileStatus
argument_list|()
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
name|comparePair
operator|.
name|violations
operator|.
name|add
argument_list|(
name|Violation
operator|.
name|PARENT_IS_A_FILE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|parentPm
operator|.
name|isDeleted
argument_list|()
condition|)
block|{
name|comparePair
operator|.
name|violations
operator|.
name|add
argument_list|(
name|Violation
operator|.
name|PARENT_TOMBSTONED
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Entry is in the root directory, so there's no parent"
argument_list|)
expr_stmt|;
block|}
comment|// If the msPathMetadata is null, we RETURN because
comment|// there is no metadata compare with
if|if
condition|(
name|msPathMetadata
operator|==
literal|null
condition|)
block|{
name|comparePair
operator|.
name|violations
operator|.
name|add
argument_list|(
name|Violation
operator|.
name|NO_METADATA_ENTRY
argument_list|)
expr_stmt|;
return|return
name|comparePair
return|;
block|}
specifier|final
name|S3AFileStatus
name|msFileStatus
init|=
name|msPathMetadata
operator|.
name|getFileStatus
argument_list|()
decl_stmt|;
if|if
condition|(
name|s3FileStatus
operator|.
name|isDirectory
argument_list|()
operator|&&
operator|!
name|msFileStatus
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
name|comparePair
operator|.
name|violations
operator|.
name|add
argument_list|(
name|Violation
operator|.
name|DIR_IN_S3_FILE_IN_MS
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|s3FileStatus
operator|.
name|isDirectory
argument_list|()
operator|&&
name|msFileStatus
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
name|comparePair
operator|.
name|violations
operator|.
name|add
argument_list|(
name|Violation
operator|.
name|FILE_IN_S3_DIR_IN_MS
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|msPathMetadata
operator|.
name|isDeleted
argument_list|()
condition|)
block|{
name|comparePair
operator|.
name|violations
operator|.
name|add
argument_list|(
name|Violation
operator|.
name|TOMBSTONED_IN_MS_NOT_DELETED_IN_S3
argument_list|)
expr_stmt|;
block|}
comment|/**      * Attribute check      */
if|if
condition|(
name|s3FileStatus
operator|.
name|getLen
argument_list|()
operator|!=
name|msFileStatus
operator|.
name|getLen
argument_list|()
condition|)
block|{
name|comparePair
operator|.
name|violations
operator|.
name|add
argument_list|(
name|Violation
operator|.
name|LENGTH_MISMATCH
argument_list|)
expr_stmt|;
block|}
comment|// ModTime should be in the accuracy range defined.
name|long
name|modTimeDiff
init|=
name|Math
operator|.
name|abs
argument_list|(
name|s3FileStatus
operator|.
name|getModificationTime
argument_list|()
operator|-
name|msFileStatus
operator|.
name|getModificationTime
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|modTimeDiff
operator|>
name|MOD_TIME_RANGE
condition|)
block|{
name|comparePair
operator|.
name|violations
operator|.
name|add
argument_list|(
name|Violation
operator|.
name|MOD_TIME_MISMATCH
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|msPathMetadata
operator|.
name|getFileStatus
argument_list|()
operator|.
name|getVersionId
argument_list|()
operator|==
literal|null
operator|||
name|s3FileStatus
operator|.
name|getVersionId
argument_list|()
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Missing versionIDs skipped. A HEAD request is "
operator|+
literal|"required for each object to get the versionID."
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|s3FileStatus
operator|.
name|getVersionId
argument_list|()
operator|.
name|equals
argument_list|(
name|msFileStatus
operator|.
name|getVersionId
argument_list|()
argument_list|)
condition|)
block|{
name|comparePair
operator|.
name|violations
operator|.
name|add
argument_list|(
name|Violation
operator|.
name|VERSIONID_MISMATCH
argument_list|)
expr_stmt|;
block|}
comment|// check etag only for files, and not directories
if|if
condition|(
operator|!
name|s3FileStatus
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
if|if
condition|(
name|msPathMetadata
operator|.
name|getFileStatus
argument_list|()
operator|.
name|getETag
argument_list|()
operator|==
literal|null
condition|)
block|{
name|comparePair
operator|.
name|violations
operator|.
name|add
argument_list|(
name|Violation
operator|.
name|NO_ETAG
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s3FileStatus
operator|.
name|getETag
argument_list|()
operator|!=
literal|null
operator|&&
operator|!
name|s3FileStatus
operator|.
name|getETag
argument_list|()
operator|.
name|equals
argument_list|(
name|msFileStatus
operator|.
name|getETag
argument_list|()
argument_list|)
condition|)
block|{
name|comparePair
operator|.
name|violations
operator|.
name|add
argument_list|(
name|Violation
operator|.
name|ETAG_MISMATCH
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|comparePair
return|;
block|}
DECL|method|path (String s)
specifier|private
name|Path
name|path
parameter_list|(
name|String
name|s
parameter_list|)
block|{
return|return
name|rawFS
operator|.
name|makeQualified
argument_list|(
operator|new
name|Path
argument_list|(
name|s
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * A compare pair with the pair of metadata and the list of violations.    */
DECL|class|ComparePair
specifier|public
specifier|static
class|class
name|ComparePair
block|{
DECL|field|s3FileStatus
specifier|private
specifier|final
name|S3AFileStatus
name|s3FileStatus
decl_stmt|;
DECL|field|msPathMetadata
specifier|private
specifier|final
name|PathMetadata
name|msPathMetadata
decl_stmt|;
DECL|field|s3DirListing
specifier|private
specifier|final
name|List
argument_list|<
name|FileStatus
argument_list|>
name|s3DirListing
decl_stmt|;
DECL|field|msDirListing
specifier|private
specifier|final
name|DirListingMetadata
name|msDirListing
decl_stmt|;
DECL|field|path
specifier|private
specifier|final
name|Path
name|path
decl_stmt|;
DECL|field|violations
specifier|private
specifier|final
name|Set
argument_list|<
name|Violation
argument_list|>
name|violations
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
DECL|method|ComparePair (S3AFileStatus status, PathMetadata pm)
name|ComparePair
parameter_list|(
name|S3AFileStatus
name|status
parameter_list|,
name|PathMetadata
name|pm
parameter_list|)
block|{
name|this
operator|.
name|s3FileStatus
operator|=
name|status
expr_stmt|;
name|this
operator|.
name|msPathMetadata
operator|=
name|pm
expr_stmt|;
name|this
operator|.
name|s3DirListing
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|msDirListing
operator|=
literal|null
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|path
operator|=
name|status
operator|.
name|getPath
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|path
operator|=
name|pm
operator|.
name|getFileStatus
argument_list|()
operator|.
name|getPath
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|ComparePair (List<FileStatus> s3DirListing, DirListingMetadata msDirListing)
name|ComparePair
parameter_list|(
name|List
argument_list|<
name|FileStatus
argument_list|>
name|s3DirListing
parameter_list|,
name|DirListingMetadata
name|msDirListing
parameter_list|)
block|{
name|this
operator|.
name|s3DirListing
operator|=
name|s3DirListing
expr_stmt|;
name|this
operator|.
name|msDirListing
operator|=
name|msDirListing
expr_stmt|;
name|this
operator|.
name|s3FileStatus
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|msPathMetadata
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|path
operator|=
name|msDirListing
operator|.
name|getPath
argument_list|()
expr_stmt|;
block|}
DECL|method|getS3FileStatus ()
specifier|public
name|S3AFileStatus
name|getS3FileStatus
parameter_list|()
block|{
return|return
name|s3FileStatus
return|;
block|}
DECL|method|getMsPathMetadata ()
specifier|public
name|PathMetadata
name|getMsPathMetadata
parameter_list|()
block|{
return|return
name|msPathMetadata
return|;
block|}
DECL|method|getViolations ()
specifier|public
name|Set
argument_list|<
name|Violation
argument_list|>
name|getViolations
parameter_list|()
block|{
return|return
name|violations
return|;
block|}
DECL|method|containsViolation ()
specifier|public
name|boolean
name|containsViolation
parameter_list|()
block|{
return|return
operator|!
name|violations
operator|.
name|isEmpty
argument_list|()
return|;
block|}
DECL|method|getMsDirListing ()
specifier|public
name|DirListingMetadata
name|getMsDirListing
parameter_list|()
block|{
return|return
name|msDirListing
return|;
block|}
DECL|method|getS3DirListing ()
specifier|public
name|List
argument_list|<
name|FileStatus
argument_list|>
name|getS3DirListing
parameter_list|()
block|{
return|return
name|s3DirListing
return|;
block|}
DECL|method|getPath ()
specifier|public
name|Path
name|getPath
parameter_list|()
block|{
return|return
name|path
return|;
block|}
DECL|method|toString ()
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"ComparePair{"
operator|+
literal|"s3FileStatus="
operator|+
name|s3FileStatus
operator|+
literal|", msPathMetadata="
operator|+
name|msPathMetadata
operator|+
literal|", s3DirListing="
operator|+
name|s3DirListing
operator|+
literal|", msDirListing="
operator|+
name|msDirListing
operator|+
literal|", path="
operator|+
name|path
operator|+
literal|", violations="
operator|+
name|violations
operator|+
literal|'}'
return|;
block|}
block|}
comment|/**    * Check the DynamoDB metadatastore internally for consistency.    *<pre>    * Tasks to do here:    *  - find orphan entries (entries without a parent).    *  - find if a file's parent is not a directory (so the parent is a file).    *  - find entries where the parent is a tombstone.    *  - warn: no lastUpdated field.    *</pre>    */
DECL|method|checkDdbInternalConsistency (Path basePath)
specifier|public
name|List
argument_list|<
name|ComparePair
argument_list|>
name|checkDdbInternalConsistency
parameter_list|(
name|Path
name|basePath
parameter_list|)
throws|throws
name|IOException
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|basePath
operator|.
name|isAbsolute
argument_list|()
argument_list|,
literal|"path must be absolute"
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|ComparePair
argument_list|>
name|comparePairs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|String
name|rootStr
init|=
name|basePath
operator|.
name|toString
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Root for internal consistency check: {}"
argument_list|,
name|rootStr
argument_list|)
expr_stmt|;
name|StopWatch
name|stopwatch
init|=
operator|new
name|StopWatch
argument_list|()
decl_stmt|;
name|stopwatch
operator|.
name|start
argument_list|()
expr_stmt|;
specifier|final
name|Table
name|table
init|=
name|metadataStore
operator|.
name|getTable
argument_list|()
decl_stmt|;
specifier|final
name|String
name|username
init|=
name|metadataStore
operator|.
name|getUsername
argument_list|()
decl_stmt|;
name|DDBTree
name|ddbTree
init|=
operator|new
name|DDBTree
argument_list|()
decl_stmt|;
comment|/*      * I. Root node construction      * - If the root node is the real bucket root, a node is constructed instead of      *   doing a query to the ddb because the bucket root is not stored.      * - If the root node is not a real bucket root then the entry is queried from      *   the ddb and constructed from the result.      */
name|DDBPathMetadata
name|baseMeta
decl_stmt|;
if|if
condition|(
operator|!
name|basePath
operator|.
name|isRoot
argument_list|()
condition|)
block|{
name|PrimaryKey
name|rootKey
init|=
name|pathToKey
argument_list|(
name|basePath
argument_list|)
decl_stmt|;
specifier|final
name|GetItemSpec
name|spec
init|=
operator|new
name|GetItemSpec
argument_list|()
operator|.
name|withPrimaryKey
argument_list|(
name|rootKey
argument_list|)
operator|.
name|withConsistentRead
argument_list|(
literal|true
argument_list|)
decl_stmt|;
specifier|final
name|Item
name|baseItem
init|=
name|table
operator|.
name|getItem
argument_list|(
name|spec
argument_list|)
decl_stmt|;
name|baseMeta
operator|=
name|itemToPathMetadata
argument_list|(
name|baseItem
argument_list|,
name|username
argument_list|)
expr_stmt|;
if|if
condition|(
name|baseMeta
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|FileNotFoundException
argument_list|(
literal|"Base element metadata is null. "
operator|+
literal|"This means the base path element is missing, or wrong path was "
operator|+
literal|"passed as base path to the internal ddb consistency checker."
argument_list|)
throw|;
block|}
block|}
else|else
block|{
name|baseMeta
operator|=
operator|new
name|DDBPathMetadata
argument_list|(
operator|new
name|S3AFileStatus
argument_list|(
name|Tristate
operator|.
name|UNKNOWN
argument_list|,
name|basePath
argument_list|,
name|username
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|DDBTreeNode
name|root
init|=
operator|new
name|DDBTreeNode
argument_list|(
name|baseMeta
argument_list|)
decl_stmt|;
name|ddbTree
operator|.
name|addNode
argument_list|(
name|root
argument_list|)
expr_stmt|;
name|ddbTree
operator|.
name|setRoot
argument_list|(
name|root
argument_list|)
expr_stmt|;
comment|/*      * II. Build and check the descendant tree:      * 1. query all nodes where the prefix is the given root, and put it in the tree      * 2. Check connectivity: check if each parent is in the hashmap      *    - This is done in O(n): we only need to find the parent based on the      *      path with a hashmap lookup.      *    - Do a test if the graph is connected - if the parent is not in the      *      hashmap, we found an orphan entry.      *      * 3. Do test the elements for errors:      *    - File is a parent of a file.      *    - Entries where the parent is tombstoned but the entries are not.      *    - Warn on no lastUpdated field.      *      */
name|ExpressionSpecBuilder
name|builder
init|=
operator|new
name|ExpressionSpecBuilder
argument_list|()
decl_stmt|;
name|builder
operator|.
name|withCondition
argument_list|(
name|ExpressionSpecBuilder
operator|.
name|S
argument_list|(
literal|"parent"
argument_list|)
operator|.
name|beginsWith
argument_list|(
name|pathToParentKey
argument_list|(
name|basePath
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|IteratorSupport
argument_list|<
name|Item
argument_list|,
name|ScanOutcome
argument_list|>
name|resultIterator
init|=
name|table
operator|.
name|scan
argument_list|(
name|builder
operator|.
name|buildForScan
argument_list|()
argument_list|)
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|resultIterator
operator|.
name|forEachRemaining
argument_list|(
name|item
lambda|->
block|{
specifier|final
name|DDBPathMetadata
name|pmd
init|=
name|itemToPathMetadata
argument_list|(
name|item
argument_list|,
name|username
argument_list|)
decl_stmt|;
name|DDBTreeNode
name|ddbTreeNode
init|=
operator|new
name|DDBTreeNode
argument_list|(
name|pmd
argument_list|)
decl_stmt|;
name|ddbTree
operator|.
name|addNode
argument_list|(
name|ddbTreeNode
argument_list|)
expr_stmt|;
block|}
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Root: {}"
argument_list|,
name|ddbTree
operator|.
name|getRoot
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|Path
argument_list|,
name|DDBTreeNode
argument_list|>
name|entry
range|:
name|ddbTree
operator|.
name|getContentMap
argument_list|()
operator|.
name|entrySet
argument_list|()
control|)
block|{
specifier|final
name|DDBTreeNode
name|node
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
specifier|final
name|ComparePair
name|pair
init|=
operator|new
name|ComparePair
argument_list|(
literal|null
argument_list|,
name|node
operator|.
name|val
argument_list|)
decl_stmt|;
comment|// let's skip the root node when checking.
if|if
condition|(
name|node
operator|.
name|getVal
argument_list|()
operator|.
name|getFileStatus
argument_list|()
operator|.
name|getPath
argument_list|()
operator|.
name|isRoot
argument_list|()
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|node
operator|.
name|getVal
argument_list|()
operator|.
name|getLastUpdated
argument_list|()
operator|==
literal|0
condition|)
block|{
name|pair
operator|.
name|violations
operator|.
name|add
argument_list|(
name|Violation
operator|.
name|NO_LASTUPDATED_FIELD
argument_list|)
expr_stmt|;
block|}
comment|// skip further checking the basenode which is not the actual bucket root.
if|if
condition|(
name|node
operator|.
name|equals
argument_list|(
name|ddbTree
operator|.
name|getRoot
argument_list|()
argument_list|)
condition|)
block|{
continue|continue;
block|}
specifier|final
name|Path
name|parent
init|=
name|node
operator|.
name|getFileStatus
argument_list|()
operator|.
name|getPath
argument_list|()
operator|.
name|getParent
argument_list|()
decl_stmt|;
specifier|final
name|DDBTreeNode
name|parentNode
init|=
name|ddbTree
operator|.
name|getContentMap
argument_list|()
operator|.
name|get
argument_list|(
name|parent
argument_list|)
decl_stmt|;
if|if
condition|(
name|parentNode
operator|==
literal|null
condition|)
block|{
name|pair
operator|.
name|violations
operator|.
name|add
argument_list|(
name|Violation
operator|.
name|ORPHAN_DDB_ENTRY
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|node
operator|.
name|isTombstoned
argument_list|()
operator|&&
operator|!
name|parentNode
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
name|pair
operator|.
name|violations
operator|.
name|add
argument_list|(
name|Violation
operator|.
name|PARENT_IS_A_FILE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|node
operator|.
name|isTombstoned
argument_list|()
operator|&&
name|parentNode
operator|.
name|isTombstoned
argument_list|()
condition|)
block|{
name|pair
operator|.
name|violations
operator|.
name|add
argument_list|(
name|Violation
operator|.
name|PARENT_TOMBSTONED
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|pair
operator|.
name|violations
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|comparePairs
operator|.
name|add
argument_list|(
name|pair
argument_list|)
expr_stmt|;
block|}
name|node
operator|.
name|setParent
argument_list|(
name|parentNode
argument_list|)
expr_stmt|;
block|}
comment|// Create a handler and handle each violated pairs
name|S3GuardFsckViolationHandler
name|handler
init|=
operator|new
name|S3GuardFsckViolationHandler
argument_list|(
name|rawFS
argument_list|,
name|metadataStore
argument_list|)
decl_stmt|;
name|comparePairs
operator|.
name|forEach
argument_list|(
name|handler
operator|::
name|handle
argument_list|)
expr_stmt|;
name|stopwatch
operator|.
name|stop
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Total scan time: {}s"
argument_list|,
name|stopwatch
operator|.
name|now
argument_list|(
name|TimeUnit
operator|.
name|SECONDS
argument_list|)
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Scanned entries: {}"
argument_list|,
name|ddbTree
operator|.
name|contentMap
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|comparePairs
return|;
block|}
comment|/**    * DDBTree is the tree that represents the structure of items in the DynamoDB.    */
DECL|class|DDBTree
specifier|public
specifier|static
class|class
name|DDBTree
block|{
DECL|field|contentMap
specifier|private
specifier|final
name|Map
argument_list|<
name|Path
argument_list|,
name|DDBTreeNode
argument_list|>
name|contentMap
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|root
specifier|private
name|DDBTreeNode
name|root
decl_stmt|;
DECL|method|DDBTree ()
specifier|public
name|DDBTree
parameter_list|()
block|{     }
DECL|method|getContentMap ()
specifier|public
name|Map
argument_list|<
name|Path
argument_list|,
name|DDBTreeNode
argument_list|>
name|getContentMap
parameter_list|()
block|{
return|return
name|contentMap
return|;
block|}
DECL|method|getRoot ()
specifier|public
name|DDBTreeNode
name|getRoot
parameter_list|()
block|{
return|return
name|root
return|;
block|}
DECL|method|setRoot (DDBTreeNode root)
specifier|public
name|void
name|setRoot
parameter_list|(
name|DDBTreeNode
name|root
parameter_list|)
block|{
name|this
operator|.
name|root
operator|=
name|root
expr_stmt|;
block|}
DECL|method|addNode (DDBTreeNode pm)
specifier|public
name|void
name|addNode
parameter_list|(
name|DDBTreeNode
name|pm
parameter_list|)
block|{
name|contentMap
operator|.
name|put
argument_list|(
name|pm
operator|.
name|getVal
argument_list|()
operator|.
name|getFileStatus
argument_list|()
operator|.
name|getPath
argument_list|()
argument_list|,
name|pm
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"DDBTree{"
operator|+
literal|"contentMap="
operator|+
name|contentMap
operator|+
literal|", root="
operator|+
name|root
operator|+
literal|'}'
return|;
block|}
block|}
comment|/**    * Tree node for DDBTree.    */
DECL|class|DDBTreeNode
specifier|private
specifier|static
specifier|final
class|class
name|DDBTreeNode
block|{
DECL|field|val
specifier|private
specifier|final
name|DDBPathMetadata
name|val
decl_stmt|;
DECL|field|parent
specifier|private
name|DDBTreeNode
name|parent
decl_stmt|;
DECL|field|children
specifier|private
specifier|final
name|List
argument_list|<
name|DDBPathMetadata
argument_list|>
name|children
decl_stmt|;
DECL|method|DDBTreeNode (DDBPathMetadata pm)
specifier|private
name|DDBTreeNode
parameter_list|(
name|DDBPathMetadata
name|pm
parameter_list|)
block|{
name|this
operator|.
name|val
operator|=
name|pm
expr_stmt|;
name|this
operator|.
name|parent
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|children
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
expr_stmt|;
block|}
DECL|method|getVal ()
specifier|public
name|DDBPathMetadata
name|getVal
parameter_list|()
block|{
return|return
name|val
return|;
block|}
DECL|method|getParent ()
specifier|public
name|DDBTreeNode
name|getParent
parameter_list|()
block|{
return|return
name|parent
return|;
block|}
DECL|method|setParent (DDBTreeNode parent)
specifier|public
name|void
name|setParent
parameter_list|(
name|DDBTreeNode
name|parent
parameter_list|)
block|{
name|this
operator|.
name|parent
operator|=
name|parent
expr_stmt|;
block|}
DECL|method|getChildren ()
specifier|public
name|List
argument_list|<
name|DDBPathMetadata
argument_list|>
name|getChildren
parameter_list|()
block|{
return|return
name|children
return|;
block|}
DECL|method|isDirectory ()
specifier|public
name|boolean
name|isDirectory
parameter_list|()
block|{
return|return
name|val
operator|.
name|getFileStatus
argument_list|()
operator|.
name|isDirectory
argument_list|()
return|;
block|}
DECL|method|getFileStatus ()
specifier|public
name|S3AFileStatus
name|getFileStatus
parameter_list|()
block|{
return|return
name|val
operator|.
name|getFileStatus
argument_list|()
return|;
block|}
DECL|method|isTombstoned ()
specifier|public
name|boolean
name|isTombstoned
parameter_list|()
block|{
return|return
name|val
operator|.
name|isDeleted
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"DDBTreeNode{"
operator|+
literal|"val="
operator|+
name|val
operator|+
literal|", parent="
operator|+
name|parent
operator|+
literal|", children="
operator|+
name|children
operator|+
literal|'}'
return|;
block|}
block|}
comment|/**    * Violation with severity and the handler.    * Defines the severity of the violation between 0-2    * where 0 is the most severe and 2 is the least severe.    */
DECL|enum|Violation
specifier|public
enum|enum
name|Violation
block|{
comment|/**      * No entry in metadatastore.      */
DECL|enumConstant|NO_METADATA_ENTRY
name|NO_METADATA_ENTRY
argument_list|(
literal|1
argument_list|,
name|S3GuardFsckViolationHandler
operator|.
name|NoMetadataEntry
operator|.
name|class
argument_list|)
block|,
comment|/**      * A file or directory entry does not have a parent entry - excluding      * files and directories in the root.      */
DECL|enumConstant|NO_PARENT_ENTRY
name|NO_PARENT_ENTRY
argument_list|(
literal|0
argument_list|,
name|S3GuardFsckViolationHandler
operator|.
name|NoParentEntry
operator|.
name|class
argument_list|)
block|,
comment|/**      * An entryâs parent is a file.      */
DECL|enumConstant|PARENT_IS_A_FILE
name|PARENT_IS_A_FILE
argument_list|(
literal|0
argument_list|,
name|S3GuardFsckViolationHandler
operator|.
name|ParentIsAFile
operator|.
name|class
argument_list|)
block|,
comment|/**      * A file exists under a path for which there is a      * tombstone entry in the MS.      */
DECL|enumConstant|PARENT_TOMBSTONED
name|PARENT_TOMBSTONED
argument_list|(
literal|0
argument_list|,
name|S3GuardFsckViolationHandler
operator|.
name|ParentTombstoned
operator|.
name|class
argument_list|)
block|,
comment|/**      * A directory in S3 is a file entry in the MS.      */
DECL|enumConstant|DIR_IN_S3_FILE_IN_MS
name|DIR_IN_S3_FILE_IN_MS
argument_list|(
literal|0
argument_list|,
name|S3GuardFsckViolationHandler
operator|.
name|DirInS3FileInMs
operator|.
name|class
argument_list|)
block|,
comment|/**      * A file in S3 is a directory in the MS.      */
DECL|enumConstant|FILE_IN_S3_DIR_IN_MS
name|FILE_IN_S3_DIR_IN_MS
argument_list|(
literal|0
argument_list|,
name|S3GuardFsckViolationHandler
operator|.
name|FileInS3DirInMs
operator|.
name|class
argument_list|)
block|,
DECL|enumConstant|AUTHORITATIVE_DIRECTORY_CONTENT_MISMATCH
name|AUTHORITATIVE_DIRECTORY_CONTENT_MISMATCH
argument_list|(
literal|1
argument_list|,
name|S3GuardFsckViolationHandler
operator|.
name|AuthDirContentMismatch
operator|.
name|class
argument_list|)
block|,
comment|/**      * An entry in the MS is tombstoned, but the object is not deleted on S3.      */
DECL|enumConstant|TOMBSTONED_IN_MS_NOT_DELETED_IN_S3
name|TOMBSTONED_IN_MS_NOT_DELETED_IN_S3
argument_list|(
literal|0
argument_list|,
name|S3GuardFsckViolationHandler
operator|.
name|TombstonedInMsNotDeletedInS3
operator|.
name|class
argument_list|)
block|,
comment|/**      * Attribute mismatch.      */
DECL|enumConstant|LENGTH_MISMATCH
name|LENGTH_MISMATCH
argument_list|(
literal|0
argument_list|,
name|S3GuardFsckViolationHandler
operator|.
name|LengthMismatch
operator|.
name|class
argument_list|)
block|,
DECL|enumConstant|MOD_TIME_MISMATCH
name|MOD_TIME_MISMATCH
argument_list|(
literal|2
argument_list|,
name|S3GuardFsckViolationHandler
operator|.
name|ModTimeMismatch
operator|.
name|class
argument_list|)
block|,
comment|/**      * If there's a versionID the mismatch is severe.      */
DECL|enumConstant|VERSIONID_MISMATCH
name|VERSIONID_MISMATCH
argument_list|(
literal|0
argument_list|,
name|S3GuardFsckViolationHandler
operator|.
name|VersionIdMismatch
operator|.
name|class
argument_list|)
block|,
comment|/**      * If there's an etag the mismatch is severe.      */
DECL|enumConstant|ETAG_MISMATCH
name|ETAG_MISMATCH
argument_list|(
literal|0
argument_list|,
name|S3GuardFsckViolationHandler
operator|.
name|EtagMismatch
operator|.
name|class
argument_list|)
block|,
comment|/**      * Don't worry too much if we don't have an etag.      */
DECL|enumConstant|NO_ETAG
name|NO_ETAG
argument_list|(
literal|2
argument_list|,
name|S3GuardFsckViolationHandler
operator|.
name|NoEtag
operator|.
name|class
argument_list|)
block|,
comment|/**      * The entry does not have a parent in ddb.      */
DECL|enumConstant|ORPHAN_DDB_ENTRY
name|ORPHAN_DDB_ENTRY
argument_list|(
literal|0
argument_list|,
name|S3GuardFsckViolationHandler
operator|.
name|OrphanDDBEntry
operator|.
name|class
argument_list|)
block|,
comment|/**      * The entry's lastUpdated field is empty.      */
DECL|enumConstant|NO_LASTUPDATED_FIELD
name|NO_LASTUPDATED_FIELD
argument_list|(
literal|2
argument_list|,
name|S3GuardFsckViolationHandler
operator|.
name|NoLastUpdatedField
operator|.
name|class
argument_list|)
block|;
DECL|field|severity
specifier|private
specifier|final
name|int
name|severity
decl_stmt|;
DECL|field|handler
specifier|private
specifier|final
name|Class
argument_list|<
name|?
extends|extends
name|S3GuardFsckViolationHandler
operator|.
name|ViolationHandler
argument_list|>
name|handler
decl_stmt|;
DECL|method|Violation (int s, Class<? extends S3GuardFsckViolationHandler.ViolationHandler> h)
name|Violation
parameter_list|(
name|int
name|s
parameter_list|,
name|Class
argument_list|<
name|?
extends|extends
name|S3GuardFsckViolationHandler
operator|.
name|ViolationHandler
argument_list|>
name|h
parameter_list|)
block|{
name|this
operator|.
name|severity
operator|=
name|s
expr_stmt|;
name|this
operator|.
name|handler
operator|=
name|h
expr_stmt|;
block|}
DECL|method|getSeverity ()
specifier|public
name|int
name|getSeverity
parameter_list|()
block|{
return|return
name|severity
return|;
block|}
DECL|method|getHandler ()
specifier|public
name|Class
argument_list|<
name|?
extends|extends
name|S3GuardFsckViolationHandler
operator|.
name|ViolationHandler
argument_list|>
name|getHandler
parameter_list|()
block|{
return|return
name|handler
return|;
block|}
block|}
block|}
end_class

end_unit

