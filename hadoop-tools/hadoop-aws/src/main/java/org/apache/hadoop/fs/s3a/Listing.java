begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.fs.s3a
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
package|;
end_package

begin_import
import|import
name|com
operator|.
name|amazonaws
operator|.
name|AmazonClientException
import|;
end_import

begin_import
import|import
name|com
operator|.
name|amazonaws
operator|.
name|services
operator|.
name|s3
operator|.
name|model
operator|.
name|ListObjectsRequest
import|;
end_import

begin_import
import|import
name|com
operator|.
name|amazonaws
operator|.
name|services
operator|.
name|s3
operator|.
name|model
operator|.
name|ObjectListing
import|;
end_import

begin_import
import|import
name|com
operator|.
name|amazonaws
operator|.
name|services
operator|.
name|s3
operator|.
name|model
operator|.
name|S3ObjectSummary
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|LocatedFileStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|PathFilter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|RemoteIterator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ListIterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NoSuchElementException
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|Constants
operator|.
name|S3N_FOLDER_SUFFIX
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|S3AUtils
operator|.
name|createFileStatus
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|S3AUtils
operator|.
name|objectRepresentsDirectory
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|S3AUtils
operator|.
name|stringify
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|S3AUtils
operator|.
name|translateException
import|;
end_import

begin_comment
comment|/**  * Place for the S3A listing classes; keeps all the small classes under control.  */
end_comment

begin_class
DECL|class|Listing
specifier|public
class|class
name|Listing
block|{
DECL|field|owner
specifier|private
specifier|final
name|S3AFileSystem
name|owner
decl_stmt|;
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|S3AFileSystem
operator|.
name|LOG
decl_stmt|;
DECL|method|Listing (S3AFileSystem owner)
specifier|public
name|Listing
parameter_list|(
name|S3AFileSystem
name|owner
parameter_list|)
block|{
name|this
operator|.
name|owner
operator|=
name|owner
expr_stmt|;
block|}
comment|/**    * Create a FileStatus iterator against a path, with a given    * list object request.    * @param listPath path of the listing    * @param request initial request to make    * @param filter the filter on which paths to accept    * @param acceptor the class/predicate to decide which entries to accept    * in the listing based on the full file status.    * @return the iterator    * @throws IOException IO Problems    */
DECL|method|createFileStatusListingIterator ( Path listPath, ListObjectsRequest request, PathFilter filter, Listing.FileStatusAcceptor acceptor)
name|FileStatusListingIterator
name|createFileStatusListingIterator
parameter_list|(
name|Path
name|listPath
parameter_list|,
name|ListObjectsRequest
name|request
parameter_list|,
name|PathFilter
name|filter
parameter_list|,
name|Listing
operator|.
name|FileStatusAcceptor
name|acceptor
parameter_list|)
throws|throws
name|IOException
block|{
return|return
operator|new
name|FileStatusListingIterator
argument_list|(
operator|new
name|ObjectListingIterator
argument_list|(
name|listPath
argument_list|,
name|request
argument_list|)
argument_list|,
name|filter
argument_list|,
name|acceptor
argument_list|)
return|;
block|}
comment|/**    * Create a located status iterator over a file status iterator.    * @param statusIterator an iterator over the remote status entries    * @return a new remote iterator    */
DECL|method|createLocatedFileStatusIterator ( RemoteIterator<FileStatus> statusIterator)
name|LocatedFileStatusIterator
name|createLocatedFileStatusIterator
parameter_list|(
name|RemoteIterator
argument_list|<
name|FileStatus
argument_list|>
name|statusIterator
parameter_list|)
block|{
return|return
operator|new
name|LocatedFileStatusIterator
argument_list|(
name|statusIterator
argument_list|)
return|;
block|}
comment|/**    * Interface to implement by the logic deciding whether to accept a summary    * entry or path as a valid file or directory.    */
DECL|interface|FileStatusAcceptor
interface|interface
name|FileStatusAcceptor
block|{
comment|/**      * Predicate to decide whether or not to accept a summary entry.      * @param keyPath qualified path to the entry      * @param summary summary entry      * @return true if the entry is accepted (i.e. that a status entry      * should be generated.      */
DECL|method|accept (Path keyPath, S3ObjectSummary summary)
name|boolean
name|accept
parameter_list|(
name|Path
name|keyPath
parameter_list|,
name|S3ObjectSummary
name|summary
parameter_list|)
function_decl|;
comment|/**      * Predicate to decide whether or not to accept a prefix.      * @param keyPath qualified path to the entry      * @param commonPrefix the prefix      * @return true if the entry is accepted (i.e. that a status entry      * should be generated.)      */
DECL|method|accept (Path keyPath, String commonPrefix)
name|boolean
name|accept
parameter_list|(
name|Path
name|keyPath
parameter_list|,
name|String
name|commonPrefix
parameter_list|)
function_decl|;
block|}
comment|/**    * A remote iterator which only iterates over a single `LocatedFileStatus`    * value.    *    * If the status value is null, the iterator declares that it has no data.    * This iterator is used to handle {@link listStatus()} calls where the path    * handed in refers to a file, not a directory: this is the iterator    * returned.    */
DECL|class|SingleStatusRemoteIterator
specifier|static
specifier|final
class|class
name|SingleStatusRemoteIterator
implements|implements
name|RemoteIterator
argument_list|<
name|LocatedFileStatus
argument_list|>
block|{
comment|/**      * The status to return; set to null after the first iteration.      */
DECL|field|status
specifier|private
name|LocatedFileStatus
name|status
decl_stmt|;
comment|/**      * Constructor.      * @param status status value: may be null, in which case      * the iterator is empty.      */
DECL|method|SingleStatusRemoteIterator (LocatedFileStatus status)
specifier|public
name|SingleStatusRemoteIterator
parameter_list|(
name|LocatedFileStatus
name|status
parameter_list|)
block|{
name|this
operator|.
name|status
operator|=
name|status
expr_stmt|;
block|}
comment|/**      * {@inheritDoc}      * @return true if there is a file status to return: this is always false      * for the second iteration, and may be false for the first.      * @throws IOException never      */
annotation|@
name|Override
DECL|method|hasNext ()
specifier|public
name|boolean
name|hasNext
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|status
operator|!=
literal|null
return|;
block|}
comment|/**      * {@inheritDoc}      * @return the non-null status element passed in when the instance was      * constructed, if it ha not already been retrieved.      * @throws IOException never      * @throws NoSuchElementException if this is the second call, or it is      * the first call and a null {@link LocatedFileStatus} entry was passed      * to the constructor.      */
annotation|@
name|Override
DECL|method|next ()
specifier|public
name|LocatedFileStatus
name|next
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|hasNext
argument_list|()
condition|)
block|{
name|LocatedFileStatus
name|s
init|=
name|this
operator|.
name|status
decl_stmt|;
name|status
operator|=
literal|null
expr_stmt|;
return|return
name|s
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|NoSuchElementException
argument_list|()
throw|;
block|}
block|}
block|}
comment|/**    * Wraps up object listing into a remote iterator which will ask for more    * listing data if needed.    *    * This is a complex operation, especially the process to determine    * if there are more entries remaining. If there are no more results    * remaining in the (filtered) results of the current listing request, then    * another request is made<i>and those results filtered</i> before the    * iterator can declare that there is more data available.    *    * The need to filter the results precludes the iterator from simply    * declaring that if the {@link S3AFileSystem.ObjectListingIterator#hasNext()}    * is true then there are more results. Instead the next batch of results must    * be retrieved and filtered.    *    * What does this mean? It means that remote requests to retrieve new    * batches of object listings are made in the {@link #hasNext()} call;    * the {@link #next()} call simply returns the filtered results of the last    * listing processed. However, do note that {@link #next()} calls    * {@link #hasNext()} during its operation. This is critical to ensure    * that a listing obtained through a sequence of {@link #next()} will    * complete with the same set of results as a classic    * {@code while(it.hasNext()} loop.    *    * Thread safety: None.    */
DECL|class|FileStatusListingIterator
class|class
name|FileStatusListingIterator
implements|implements
name|RemoteIterator
argument_list|<
name|FileStatus
argument_list|>
block|{
comment|/** Source of objects. */
DECL|field|source
specifier|private
specifier|final
name|ObjectListingIterator
name|source
decl_stmt|;
comment|/** Filter of paths from API call. */
DECL|field|filter
specifier|private
specifier|final
name|PathFilter
name|filter
decl_stmt|;
comment|/** Filter of entries from file status. */
DECL|field|acceptor
specifier|private
specifier|final
name|FileStatusAcceptor
name|acceptor
decl_stmt|;
comment|/** request batch size. */
DECL|field|batchSize
specifier|private
name|int
name|batchSize
decl_stmt|;
comment|/** Iterator over the current set of results. */
DECL|field|statusBatchIterator
specifier|private
name|ListIterator
argument_list|<
name|FileStatus
argument_list|>
name|statusBatchIterator
decl_stmt|;
comment|/**      * Create an iterator over file status entries.      * @param source the listing iterator from a listObjects call.      * @param filter the filter on which paths to accept      * @param acceptor the class/predicate to decide which entries to accept      * in the listing based on the full file status.      * @throws IOException IO Problems      */
DECL|method|FileStatusListingIterator (ObjectListingIterator source, PathFilter filter, FileStatusAcceptor acceptor)
name|FileStatusListingIterator
parameter_list|(
name|ObjectListingIterator
name|source
parameter_list|,
name|PathFilter
name|filter
parameter_list|,
name|FileStatusAcceptor
name|acceptor
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|source
operator|=
name|source
expr_stmt|;
name|this
operator|.
name|filter
operator|=
name|filter
expr_stmt|;
name|this
operator|.
name|acceptor
operator|=
name|acceptor
expr_stmt|;
comment|// build the first set of results. This will not trigger any
comment|// remote IO, assuming the source iterator is in its initial
comment|// iteration
name|requestNextBatch
argument_list|()
expr_stmt|;
block|}
comment|/**      * Report whether or not there is new data available.      * If there is data in the local filtered list, return true.      * Else: request more data util that condition is met, or there      * is no more remote listing data.      * @return true if a call to {@link #next()} will succeed.      * @throws IOException      */
annotation|@
name|Override
DECL|method|hasNext ()
specifier|public
name|boolean
name|hasNext
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|statusBatchIterator
operator|.
name|hasNext
argument_list|()
operator|||
name|requestNextBatch
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|next ()
specifier|public
name|FileStatus
name|next
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|hasNext
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|NoSuchElementException
argument_list|()
throw|;
block|}
return|return
name|statusBatchIterator
operator|.
name|next
argument_list|()
return|;
block|}
comment|/**      * Try to retrieve another batch.      * Note that for the initial batch,      * {@link S3AFileSystem.ObjectListingIterator} does not generate a request;      * it simply returns the initial set.      *      * @return true if a new batch was created.      * @throws IOException IO problems      */
DECL|method|requestNextBatch ()
specifier|private
name|boolean
name|requestNextBatch
parameter_list|()
throws|throws
name|IOException
block|{
comment|// look for more object listing batches being available
while|while
condition|(
name|source
operator|.
name|hasNext
argument_list|()
condition|)
block|{
comment|// if available, retrieve it and build the next status
if|if
condition|(
name|buildNextStatusBatch
argument_list|(
name|source
operator|.
name|next
argument_list|()
argument_list|)
condition|)
block|{
comment|// this batch successfully generated entries matching the filters/
comment|// acceptors; declare that the request was successful
return|return
literal|true
return|;
block|}
else|else
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"All entries in batch were filtered...continuing"
argument_list|)
expr_stmt|;
block|}
block|}
comment|// if this code is reached, it means that all remaining
comment|// object lists have been retrieved, and there are no new entries
comment|// to return.
return|return
literal|false
return|;
block|}
comment|/**      * Build the next status batch from a listing.      * @param objects the next object listing      * @return true if this added any entries after filtering      */
DECL|method|buildNextStatusBatch (ObjectListing objects)
specifier|private
name|boolean
name|buildNextStatusBatch
parameter_list|(
name|ObjectListing
name|objects
parameter_list|)
block|{
comment|// counters for debug logs
name|int
name|added
init|=
literal|0
decl_stmt|,
name|ignored
init|=
literal|0
decl_stmt|;
comment|// list to fill in with results. Initial size will be list maximum.
name|List
argument_list|<
name|FileStatus
argument_list|>
name|stats
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|objects
operator|.
name|getObjectSummaries
argument_list|()
operator|.
name|size
argument_list|()
operator|+
name|objects
operator|.
name|getCommonPrefixes
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
comment|// objects
for|for
control|(
name|S3ObjectSummary
name|summary
range|:
name|objects
operator|.
name|getObjectSummaries
argument_list|()
control|)
block|{
name|String
name|key
init|=
name|summary
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|Path
name|keyPath
init|=
name|owner
operator|.
name|keyToQualifiedPath
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"{}: {}"
argument_list|,
name|keyPath
argument_list|,
name|stringify
argument_list|(
name|summary
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Skip over keys that are ourselves and old S3N _$folder$ files
if|if
condition|(
name|acceptor
operator|.
name|accept
argument_list|(
name|keyPath
argument_list|,
name|summary
argument_list|)
operator|&&
name|filter
operator|.
name|accept
argument_list|(
name|keyPath
argument_list|)
condition|)
block|{
name|FileStatus
name|status
init|=
name|createFileStatus
argument_list|(
name|keyPath
argument_list|,
name|summary
argument_list|,
name|owner
operator|.
name|getDefaultBlockSize
argument_list|(
name|keyPath
argument_list|)
argument_list|,
name|owner
operator|.
name|getUsername
argument_list|()
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Adding: {}"
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|stats
operator|.
name|add
argument_list|(
name|status
argument_list|)
expr_stmt|;
name|added
operator|++
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Ignoring: {}"
argument_list|,
name|keyPath
argument_list|)
expr_stmt|;
name|ignored
operator|++
expr_stmt|;
block|}
block|}
comment|// prefixes: always directories
for|for
control|(
name|String
name|prefix
range|:
name|objects
operator|.
name|getCommonPrefixes
argument_list|()
control|)
block|{
name|Path
name|keyPath
init|=
name|owner
operator|.
name|keyToQualifiedPath
argument_list|(
name|prefix
argument_list|)
decl_stmt|;
if|if
condition|(
name|acceptor
operator|.
name|accept
argument_list|(
name|keyPath
argument_list|,
name|prefix
argument_list|)
operator|&&
name|filter
operator|.
name|accept
argument_list|(
name|keyPath
argument_list|)
condition|)
block|{
name|FileStatus
name|status
init|=
operator|new
name|S3AFileStatus
argument_list|(
literal|false
argument_list|,
name|keyPath
argument_list|,
name|owner
operator|.
name|getUsername
argument_list|()
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Adding directory: {}"
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|added
operator|++
expr_stmt|;
name|stats
operator|.
name|add
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Ignoring directory: {}"
argument_list|,
name|keyPath
argument_list|)
expr_stmt|;
name|ignored
operator|++
expr_stmt|;
block|}
block|}
comment|// finish up
name|batchSize
operator|=
name|stats
operator|.
name|size
argument_list|()
expr_stmt|;
name|statusBatchIterator
operator|=
name|stats
operator|.
name|listIterator
argument_list|()
expr_stmt|;
name|boolean
name|hasNext
init|=
name|statusBatchIterator
operator|.
name|hasNext
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Added {} entries; ignored {}; hasNext={}; hasMoreObjects={}"
argument_list|,
name|added
argument_list|,
name|ignored
argument_list|,
name|hasNext
argument_list|,
name|objects
operator|.
name|isTruncated
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|hasNext
return|;
block|}
comment|/**      * Get the number of entries in the current batch.      * @return a number, possibly zero.      */
DECL|method|getBatchSize ()
specifier|public
name|int
name|getBatchSize
parameter_list|()
block|{
return|return
name|batchSize
return|;
block|}
block|}
comment|/**    * Wraps up AWS `ListObjects` requests in a remote iterator    * which will ask for more listing data if needed.    *    * That is:    *    * 1. The first invocation of the {@link #next()} call will return the results    * of the first request, the one created during the construction of the    * instance.    *    * 2. Second and later invocations will continue the ongoing listing,    * calling {@link #continueListObjects(ObjectListing)} to request the next    * batch of results.    *    * 3. The {@link #hasNext()} predicate returns true for the initial call,    * where {@link #next()} will return the initial results. It declares    * that it has future results iff the last executed request was truncated.    *    * Thread safety: none.    */
DECL|class|ObjectListingIterator
class|class
name|ObjectListingIterator
implements|implements
name|RemoteIterator
argument_list|<
name|ObjectListing
argument_list|>
block|{
comment|/** The path listed. */
DECL|field|listPath
specifier|private
specifier|final
name|Path
name|listPath
decl_stmt|;
comment|/** The most recent listing results. */
DECL|field|objects
specifier|private
name|ObjectListing
name|objects
decl_stmt|;
comment|/** Indicator that this is the first listing. */
DECL|field|firstListing
specifier|private
name|boolean
name|firstListing
init|=
literal|true
decl_stmt|;
comment|/**      * Count of how many listings have been requested      * (including initial result).      */
DECL|field|listingCount
specifier|private
name|int
name|listingCount
init|=
literal|1
decl_stmt|;
comment|/**      * Maximum keys in a request.      */
DECL|field|maxKeys
specifier|private
name|int
name|maxKeys
decl_stmt|;
comment|/**      * Constructor -calls `listObjects()` on the request to populate the      * initial set of results/fail if there was a problem talking to the bucket.      * @param listPath path of the listing      * @param request initial request to make      * */
DECL|method|ObjectListingIterator ( Path listPath, ListObjectsRequest request)
name|ObjectListingIterator
parameter_list|(
name|Path
name|listPath
parameter_list|,
name|ListObjectsRequest
name|request
parameter_list|)
block|{
name|this
operator|.
name|listPath
operator|=
name|listPath
expr_stmt|;
name|this
operator|.
name|maxKeys
operator|=
name|owner
operator|.
name|getMaxKeys
argument_list|()
expr_stmt|;
name|this
operator|.
name|objects
operator|=
name|owner
operator|.
name|listObjects
argument_list|(
name|request
argument_list|)
expr_stmt|;
block|}
comment|/**      * Declare that the iterator has data if it is either is the initial      * iteration or it is a later one and the last listing obtained was      * incomplete.      * @throws IOException never: there is no IO in this operation.      */
annotation|@
name|Override
DECL|method|hasNext ()
specifier|public
name|boolean
name|hasNext
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|firstListing
operator|||
name|objects
operator|.
name|isTruncated
argument_list|()
return|;
block|}
comment|/**      * Ask for the next listing.      * For the first invocation, this returns the initial set, with no      * remote IO. For later requests, S3 will be queried, hence the calls      * may block or fail.      * @return the next object listing.      * @throws IOException if a query made of S3 fails.      * @throws NoSuchElementException if there is no more data to list.      */
annotation|@
name|Override
DECL|method|next ()
specifier|public
name|ObjectListing
name|next
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|firstListing
condition|)
block|{
comment|// on the first listing, don't request more data.
comment|// Instead just clear the firstListing flag so that it future calls
comment|// will request new data.
name|firstListing
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
try|try
block|{
if|if
condition|(
operator|!
name|objects
operator|.
name|isTruncated
argument_list|()
condition|)
block|{
comment|// nothing more to request: fail.
throw|throw
operator|new
name|NoSuchElementException
argument_list|(
literal|"No more results in listing of "
operator|+
name|listPath
argument_list|)
throw|;
block|}
comment|// need to request a new set of objects.
name|LOG
operator|.
name|debug
argument_list|(
literal|"[{}], Requesting next {} objects under {}"
argument_list|,
name|listingCount
argument_list|,
name|maxKeys
argument_list|,
name|listPath
argument_list|)
expr_stmt|;
name|objects
operator|=
name|owner
operator|.
name|continueListObjects
argument_list|(
name|objects
argument_list|)
expr_stmt|;
name|listingCount
operator|++
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"New listing status: {}"
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|AmazonClientException
name|e
parameter_list|)
block|{
throw|throw
name|translateException
argument_list|(
literal|"listObjects()"
argument_list|,
name|listPath
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
return|return
name|objects
return|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"Object listing iterator against "
operator|+
name|listPath
operator|+
literal|"; listing count "
operator|+
name|listingCount
operator|+
literal|"; isTruncated="
operator|+
name|objects
operator|.
name|isTruncated
argument_list|()
return|;
block|}
comment|/**      * Get the path listed.      * @return the path used in this listing.      */
DECL|method|getListPath ()
specifier|public
name|Path
name|getListPath
parameter_list|()
block|{
return|return
name|listPath
return|;
block|}
comment|/**      * Get the count of listing requests.      * @return the counter of requests made (including the initial lookup).      */
DECL|method|getListingCount ()
specifier|public
name|int
name|getListingCount
parameter_list|()
block|{
return|return
name|listingCount
return|;
block|}
block|}
comment|/**    * Accept all entries except the base path and those which map to S3N    * pseudo directory markers.    */
DECL|class|AcceptFilesOnly
specifier|static
class|class
name|AcceptFilesOnly
implements|implements
name|FileStatusAcceptor
block|{
DECL|field|qualifiedPath
specifier|private
specifier|final
name|Path
name|qualifiedPath
decl_stmt|;
DECL|method|AcceptFilesOnly (Path qualifiedPath)
specifier|public
name|AcceptFilesOnly
parameter_list|(
name|Path
name|qualifiedPath
parameter_list|)
block|{
name|this
operator|.
name|qualifiedPath
operator|=
name|qualifiedPath
expr_stmt|;
block|}
comment|/**      * Reject a summary entry if the key path is the qualified Path, or      * it ends with {@code "_$folder$"}.      * @param keyPath key path of the entry      * @param summary summary entry      * @return true if the entry is accepted (i.e. that a status entry      * should be generated.      */
annotation|@
name|Override
DECL|method|accept (Path keyPath, S3ObjectSummary summary)
specifier|public
name|boolean
name|accept
parameter_list|(
name|Path
name|keyPath
parameter_list|,
name|S3ObjectSummary
name|summary
parameter_list|)
block|{
return|return
operator|!
name|keyPath
operator|.
name|equals
argument_list|(
name|qualifiedPath
argument_list|)
operator|&&
operator|!
name|summary
operator|.
name|getKey
argument_list|()
operator|.
name|endsWith
argument_list|(
name|S3N_FOLDER_SUFFIX
argument_list|)
operator|&&
operator|!
name|objectRepresentsDirectory
argument_list|(
name|summary
operator|.
name|getKey
argument_list|()
argument_list|,
name|summary
operator|.
name|getSize
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Accept no directory paths.      * @param keyPath qualified path to the entry      * @param prefix common prefix in listing.      * @return false, always.      */
annotation|@
name|Override
DECL|method|accept (Path keyPath, String prefix)
specifier|public
name|boolean
name|accept
parameter_list|(
name|Path
name|keyPath
parameter_list|,
name|String
name|prefix
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
block|}
comment|/**    * Take a remote iterator over a set of {@link FileStatus} instances and    * return a remote iterator of {@link LocatedFileStatus} instances.    */
DECL|class|LocatedFileStatusIterator
class|class
name|LocatedFileStatusIterator
implements|implements
name|RemoteIterator
argument_list|<
name|LocatedFileStatus
argument_list|>
block|{
DECL|field|statusIterator
specifier|private
specifier|final
name|RemoteIterator
argument_list|<
name|FileStatus
argument_list|>
name|statusIterator
decl_stmt|;
comment|/**      * Constructor.      * @param statusIterator an iterator over the remote status entries      */
DECL|method|LocatedFileStatusIterator (RemoteIterator<FileStatus> statusIterator)
name|LocatedFileStatusIterator
parameter_list|(
name|RemoteIterator
argument_list|<
name|FileStatus
argument_list|>
name|statusIterator
parameter_list|)
block|{
name|this
operator|.
name|statusIterator
operator|=
name|statusIterator
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|hasNext ()
specifier|public
name|boolean
name|hasNext
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|statusIterator
operator|.
name|hasNext
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|next ()
specifier|public
name|LocatedFileStatus
name|next
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|owner
operator|.
name|toLocatedFileStatus
argument_list|(
name|statusIterator
operator|.
name|next
argument_list|()
argument_list|)
return|;
block|}
block|}
comment|/**    * Accept all entries except the base path and those which map to S3N    * pseudo directory markers.    */
DECL|class|AcceptAllButSelfAndS3nDirs
specifier|static
class|class
name|AcceptAllButSelfAndS3nDirs
implements|implements
name|FileStatusAcceptor
block|{
comment|/** Base path. */
DECL|field|qualifiedPath
specifier|private
specifier|final
name|Path
name|qualifiedPath
decl_stmt|;
comment|/**      * Constructor.      * @param qualifiedPath an already-qualified path.      */
DECL|method|AcceptAllButSelfAndS3nDirs (Path qualifiedPath)
specifier|public
name|AcceptAllButSelfAndS3nDirs
parameter_list|(
name|Path
name|qualifiedPath
parameter_list|)
block|{
name|this
operator|.
name|qualifiedPath
operator|=
name|qualifiedPath
expr_stmt|;
block|}
comment|/**      * Reject a summary entry if the key path is the qualified Path, or      * it ends with {@code "_$folder$"}.      * @param keyPath key path of the entry      * @param summary summary entry      * @return true if the entry is accepted (i.e. that a status entry      * should be generated.)      */
annotation|@
name|Override
DECL|method|accept (Path keyPath, S3ObjectSummary summary)
specifier|public
name|boolean
name|accept
parameter_list|(
name|Path
name|keyPath
parameter_list|,
name|S3ObjectSummary
name|summary
parameter_list|)
block|{
return|return
operator|!
name|keyPath
operator|.
name|equals
argument_list|(
name|qualifiedPath
argument_list|)
operator|&&
operator|!
name|summary
operator|.
name|getKey
argument_list|()
operator|.
name|endsWith
argument_list|(
name|S3N_FOLDER_SUFFIX
argument_list|)
return|;
block|}
comment|/**      * Accept all prefixes except the one for the base path, "self".      * @param keyPath qualified path to the entry      * @param prefix common prefix in listing.      * @return true if the entry is accepted (i.e. that a status entry      * should be generated.      */
annotation|@
name|Override
DECL|method|accept (Path keyPath, String prefix)
specifier|public
name|boolean
name|accept
parameter_list|(
name|Path
name|keyPath
parameter_list|,
name|String
name|prefix
parameter_list|)
block|{
return|return
operator|!
name|keyPath
operator|.
name|equals
argument_list|(
name|qualifiedPath
argument_list|)
return|;
block|}
block|}
comment|/**    * A Path filter which accepts all filenames.    */
DECL|field|ACCEPT_ALL
specifier|static
specifier|final
name|PathFilter
name|ACCEPT_ALL
init|=
operator|new
name|PathFilter
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|accept
parameter_list|(
name|Path
name|file
parameter_list|)
block|{
return|return
literal|true
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"ACCEPT_ALL"
return|;
block|}
block|}
decl_stmt|;
block|}
end_class

end_unit

