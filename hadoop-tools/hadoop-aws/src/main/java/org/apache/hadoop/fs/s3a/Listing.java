begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.fs.s3a
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
package|;
end_package

begin_import
import|import
name|com
operator|.
name|amazonaws
operator|.
name|AmazonClientException
import|;
end_import

begin_import
import|import
name|com
operator|.
name|amazonaws
operator|.
name|services
operator|.
name|s3
operator|.
name|model
operator|.
name|S3ObjectSummary
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|LocatedFileStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|PathFilter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|RemoteIterator
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ListIterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NoSuchElementException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|Constants
operator|.
name|S3N_FOLDER_SUFFIX
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|S3AUtils
operator|.
name|createFileStatus
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|S3AUtils
operator|.
name|objectRepresentsDirectory
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|S3AUtils
operator|.
name|stringify
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|S3AUtils
operator|.
name|translateException
import|;
end_import

begin_comment
comment|/**  * Place for the S3A listing classes; keeps all the small classes under control.  */
end_comment

begin_class
DECL|class|Listing
specifier|public
class|class
name|Listing
block|{
DECL|field|owner
specifier|private
specifier|final
name|S3AFileSystem
name|owner
decl_stmt|;
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|S3AFileSystem
operator|.
name|LOG
decl_stmt|;
DECL|method|Listing (S3AFileSystem owner)
specifier|public
name|Listing
parameter_list|(
name|S3AFileSystem
name|owner
parameter_list|)
block|{
name|this
operator|.
name|owner
operator|=
name|owner
expr_stmt|;
block|}
comment|/**    * Create a FileStatus iterator against a provided list of file status, with    * a given status filter.    *    * @param fileStatuses the provided list of file status. NO remote calls.    * @param filter file path filter on which paths to accept    * @param acceptor the file status acceptor    * @return the file status iterator    */
DECL|method|createProvidedFileStatusIterator ( FileStatus[] fileStatuses, PathFilter filter, FileStatusAcceptor acceptor)
name|ProvidedFileStatusIterator
name|createProvidedFileStatusIterator
parameter_list|(
name|FileStatus
index|[]
name|fileStatuses
parameter_list|,
name|PathFilter
name|filter
parameter_list|,
name|FileStatusAcceptor
name|acceptor
parameter_list|)
block|{
return|return
operator|new
name|ProvidedFileStatusIterator
argument_list|(
name|fileStatuses
argument_list|,
name|filter
argument_list|,
name|acceptor
argument_list|)
return|;
block|}
comment|/**    * Create a FileStatus iterator against a path, with a given list object    * request.    *    * @param listPath path of the listing    * @param request initial request to make    * @param filter the filter on which paths to accept    * @param acceptor the class/predicate to decide which entries to accept    * in the listing based on the full file status.    * @return the iterator    * @throws IOException IO Problems    */
DECL|method|createFileStatusListingIterator ( Path listPath, S3ListRequest request, PathFilter filter, Listing.FileStatusAcceptor acceptor)
name|FileStatusListingIterator
name|createFileStatusListingIterator
parameter_list|(
name|Path
name|listPath
parameter_list|,
name|S3ListRequest
name|request
parameter_list|,
name|PathFilter
name|filter
parameter_list|,
name|Listing
operator|.
name|FileStatusAcceptor
name|acceptor
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|createFileStatusListingIterator
argument_list|(
name|listPath
argument_list|,
name|request
argument_list|,
name|filter
argument_list|,
name|acceptor
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**    * Create a FileStatus iterator against a path, with a given    * list object request.    * @param listPath path of the listing    * @param request initial request to make    * @param filter the filter on which paths to accept    * @param acceptor the class/predicate to decide which entries to accept    * in the listing based on the full file status.    * @param providedStatus the provided list of file status, which may contain    *                       items that are not listed from source.    * @return the iterator    * @throws IOException IO Problems    */
DECL|method|createFileStatusListingIterator ( Path listPath, S3ListRequest request, PathFilter filter, Listing.FileStatusAcceptor acceptor, RemoteIterator<FileStatus> providedStatus)
name|FileStatusListingIterator
name|createFileStatusListingIterator
parameter_list|(
name|Path
name|listPath
parameter_list|,
name|S3ListRequest
name|request
parameter_list|,
name|PathFilter
name|filter
parameter_list|,
name|Listing
operator|.
name|FileStatusAcceptor
name|acceptor
parameter_list|,
name|RemoteIterator
argument_list|<
name|FileStatus
argument_list|>
name|providedStatus
parameter_list|)
throws|throws
name|IOException
block|{
return|return
operator|new
name|FileStatusListingIterator
argument_list|(
operator|new
name|ObjectListingIterator
argument_list|(
name|listPath
argument_list|,
name|request
argument_list|)
argument_list|,
name|filter
argument_list|,
name|acceptor
argument_list|,
name|providedStatus
argument_list|)
return|;
block|}
comment|/**    * Create a located status iterator over a file status iterator.    * @param statusIterator an iterator over the remote status entries    * @return a new remote iterator    */
annotation|@
name|VisibleForTesting
DECL|method|createLocatedFileStatusIterator ( RemoteIterator<FileStatus> statusIterator)
name|LocatedFileStatusIterator
name|createLocatedFileStatusIterator
parameter_list|(
name|RemoteIterator
argument_list|<
name|FileStatus
argument_list|>
name|statusIterator
parameter_list|)
block|{
return|return
operator|new
name|LocatedFileStatusIterator
argument_list|(
name|statusIterator
argument_list|)
return|;
block|}
comment|/**    * Create an located status iterator that wraps another to filter out a set    * of recently deleted items.    * @param iterator an iterator over the remote located status entries.    * @param tombstones set of paths that are recently deleted and should be    *                   filtered.    * @return a new remote iterator.    */
annotation|@
name|VisibleForTesting
DECL|method|createTombstoneReconcilingIterator ( RemoteIterator<LocatedFileStatus> iterator, Set<Path> tombstones)
name|TombstoneReconcilingIterator
name|createTombstoneReconcilingIterator
parameter_list|(
name|RemoteIterator
argument_list|<
name|LocatedFileStatus
argument_list|>
name|iterator
parameter_list|,
name|Set
argument_list|<
name|Path
argument_list|>
name|tombstones
parameter_list|)
block|{
return|return
operator|new
name|TombstoneReconcilingIterator
argument_list|(
name|iterator
argument_list|,
name|tombstones
argument_list|)
return|;
block|}
comment|/**    * Interface to implement by the logic deciding whether to accept a summary    * entry or path as a valid file or directory.    */
DECL|interface|FileStatusAcceptor
interface|interface
name|FileStatusAcceptor
block|{
comment|/**      * Predicate to decide whether or not to accept a summary entry.      * @param keyPath qualified path to the entry      * @param summary summary entry      * @return true if the entry is accepted (i.e. that a status entry      * should be generated.      */
DECL|method|accept (Path keyPath, S3ObjectSummary summary)
name|boolean
name|accept
parameter_list|(
name|Path
name|keyPath
parameter_list|,
name|S3ObjectSummary
name|summary
parameter_list|)
function_decl|;
comment|/**      * Predicate to decide whether or not to accept a prefix.      * @param keyPath qualified path to the entry      * @param commonPrefix the prefix      * @return true if the entry is accepted (i.e. that a status entry      * should be generated.)      */
DECL|method|accept (Path keyPath, String commonPrefix)
name|boolean
name|accept
parameter_list|(
name|Path
name|keyPath
parameter_list|,
name|String
name|commonPrefix
parameter_list|)
function_decl|;
comment|/**      * Predicate to decide whether or not to accept a file status.      * @param status file status containing file path information      * @return true if the status is accepted else false      */
DECL|method|accept (FileStatus status)
name|boolean
name|accept
parameter_list|(
name|FileStatus
name|status
parameter_list|)
function_decl|;
block|}
comment|/**    * A remote iterator which only iterates over a single `LocatedFileStatus`    * value.    *    * If the status value is null, the iterator declares that it has no data.    * This iterator is used to handle {@link S3AFileSystem#listStatus} calls    * where the path handed in refers to a file, not a directory: this is the    * iterator returned.    */
DECL|class|SingleStatusRemoteIterator
specifier|static
specifier|final
class|class
name|SingleStatusRemoteIterator
implements|implements
name|RemoteIterator
argument_list|<
name|LocatedFileStatus
argument_list|>
block|{
comment|/**      * The status to return; set to null after the first iteration.      */
DECL|field|status
specifier|private
name|LocatedFileStatus
name|status
decl_stmt|;
comment|/**      * Constructor.      * @param status status value: may be null, in which case      * the iterator is empty.      */
DECL|method|SingleStatusRemoteIterator (LocatedFileStatus status)
specifier|public
name|SingleStatusRemoteIterator
parameter_list|(
name|LocatedFileStatus
name|status
parameter_list|)
block|{
name|this
operator|.
name|status
operator|=
name|status
expr_stmt|;
block|}
comment|/**      * {@inheritDoc}      * @return true if there is a file status to return: this is always false      * for the second iteration, and may be false for the first.      * @throws IOException never      */
annotation|@
name|Override
DECL|method|hasNext ()
specifier|public
name|boolean
name|hasNext
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|status
operator|!=
literal|null
return|;
block|}
comment|/**      * {@inheritDoc}      * @return the non-null status element passed in when the instance was      * constructed, if it ha not already been retrieved.      * @throws IOException never      * @throws NoSuchElementException if this is the second call, or it is      * the first call and a null {@link LocatedFileStatus} entry was passed      * to the constructor.      */
annotation|@
name|Override
DECL|method|next ()
specifier|public
name|LocatedFileStatus
name|next
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|hasNext
argument_list|()
condition|)
block|{
name|LocatedFileStatus
name|s
init|=
name|this
operator|.
name|status
decl_stmt|;
name|status
operator|=
literal|null
expr_stmt|;
return|return
name|s
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|NoSuchElementException
argument_list|()
throw|;
block|}
block|}
block|}
comment|/**    * This wraps up a provided non-null list of file status as a remote iterator.    *    * It firstly filters the provided list and later {@link #next} call will get    * from the filtered list. This suffers from scalability issues if the    * provided list is too large.    *    * There is no remote data to fetch.    */
DECL|class|ProvidedFileStatusIterator
specifier|static
class|class
name|ProvidedFileStatusIterator
implements|implements
name|RemoteIterator
argument_list|<
name|FileStatus
argument_list|>
block|{
DECL|field|filteredStatusList
specifier|private
specifier|final
name|ArrayList
argument_list|<
name|FileStatus
argument_list|>
name|filteredStatusList
decl_stmt|;
DECL|field|index
specifier|private
name|int
name|index
init|=
literal|0
decl_stmt|;
DECL|method|ProvidedFileStatusIterator (FileStatus[] fileStatuses, PathFilter filter, FileStatusAcceptor acceptor)
name|ProvidedFileStatusIterator
parameter_list|(
name|FileStatus
index|[]
name|fileStatuses
parameter_list|,
name|PathFilter
name|filter
parameter_list|,
name|FileStatusAcceptor
name|acceptor
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|fileStatuses
operator|!=
literal|null
argument_list|,
literal|"Null status list!"
argument_list|)
expr_stmt|;
name|filteredStatusList
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|fileStatuses
operator|.
name|length
argument_list|)
expr_stmt|;
for|for
control|(
name|FileStatus
name|status
range|:
name|fileStatuses
control|)
block|{
if|if
condition|(
name|filter
operator|.
name|accept
argument_list|(
name|status
operator|.
name|getPath
argument_list|()
argument_list|)
operator|&&
name|acceptor
operator|.
name|accept
argument_list|(
name|status
argument_list|)
condition|)
block|{
name|filteredStatusList
operator|.
name|add
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
block|}
name|filteredStatusList
operator|.
name|trimToSize
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|hasNext ()
specifier|public
name|boolean
name|hasNext
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|index
operator|<
name|filteredStatusList
operator|.
name|size
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|next ()
specifier|public
name|FileStatus
name|next
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|hasNext
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|NoSuchElementException
argument_list|()
throw|;
block|}
return|return
name|filteredStatusList
operator|.
name|get
argument_list|(
name|index
operator|++
argument_list|)
return|;
block|}
block|}
comment|/**    * Wraps up object listing into a remote iterator which will ask for more    * listing data if needed.    *    * This is a complex operation, especially the process to determine    * if there are more entries remaining. If there are no more results    * remaining in the (filtered) results of the current listing request, then    * another request is made<i>and those results filtered</i> before the    * iterator can declare that there is more data available.    *    * The need to filter the results precludes the iterator from simply    * declaring that if the {@link ObjectListingIterator#hasNext()}    * is true then there are more results. Instead the next batch of results must    * be retrieved and filtered.    *    * What does this mean? It means that remote requests to retrieve new    * batches of object listings are made in the {@link #hasNext()} call;    * the {@link #next()} call simply returns the filtered results of the last    * listing processed. However, do note that {@link #next()} calls    * {@link #hasNext()} during its operation. This is critical to ensure    * that a listing obtained through a sequence of {@link #next()} will    * complete with the same set of results as a classic    * {@code while(it.hasNext()} loop.    *    * Thread safety: None.    */
DECL|class|FileStatusListingIterator
class|class
name|FileStatusListingIterator
implements|implements
name|RemoteIterator
argument_list|<
name|FileStatus
argument_list|>
block|{
comment|/** Source of objects. */
DECL|field|source
specifier|private
specifier|final
name|ObjectListingIterator
name|source
decl_stmt|;
comment|/** Filter of paths from API call. */
DECL|field|filter
specifier|private
specifier|final
name|PathFilter
name|filter
decl_stmt|;
comment|/** Filter of entries from file status. */
DECL|field|acceptor
specifier|private
specifier|final
name|FileStatusAcceptor
name|acceptor
decl_stmt|;
comment|/** request batch size. */
DECL|field|batchSize
specifier|private
name|int
name|batchSize
decl_stmt|;
comment|/** Iterator over the current set of results. */
DECL|field|statusBatchIterator
specifier|private
name|ListIterator
argument_list|<
name|FileStatus
argument_list|>
name|statusBatchIterator
decl_stmt|;
DECL|field|providedStatus
specifier|private
specifier|final
name|Set
argument_list|<
name|FileStatus
argument_list|>
name|providedStatus
decl_stmt|;
DECL|field|providedStatusIterator
specifier|private
name|Iterator
argument_list|<
name|FileStatus
argument_list|>
name|providedStatusIterator
decl_stmt|;
comment|/**      * Create an iterator over file status entries.      * @param source the listing iterator from a listObjects call.      * @param filter the filter on which paths to accept      * @param acceptor the class/predicate to decide which entries to accept      * in the listing based on the full file status.      * @param providedStatus the provided list of file status, which may contain      *                       items that are not listed from source.      * @throws IOException IO Problems      */
DECL|method|FileStatusListingIterator (ObjectListingIterator source, PathFilter filter, FileStatusAcceptor acceptor, RemoteIterator<FileStatus> providedStatus)
name|FileStatusListingIterator
parameter_list|(
name|ObjectListingIterator
name|source
parameter_list|,
name|PathFilter
name|filter
parameter_list|,
name|FileStatusAcceptor
name|acceptor
parameter_list|,
name|RemoteIterator
argument_list|<
name|FileStatus
argument_list|>
name|providedStatus
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|source
operator|=
name|source
expr_stmt|;
name|this
operator|.
name|filter
operator|=
name|filter
expr_stmt|;
name|this
operator|.
name|acceptor
operator|=
name|acceptor
expr_stmt|;
name|this
operator|.
name|providedStatus
operator|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
expr_stmt|;
for|for
control|(
init|;
name|providedStatus
operator|!=
literal|null
operator|&&
name|providedStatus
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
specifier|final
name|FileStatus
name|status
init|=
name|providedStatus
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|filter
operator|.
name|accept
argument_list|(
name|status
operator|.
name|getPath
argument_list|()
argument_list|)
operator|&&
name|acceptor
operator|.
name|accept
argument_list|(
name|status
argument_list|)
condition|)
block|{
name|this
operator|.
name|providedStatus
operator|.
name|add
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
block|}
comment|// build the first set of results. This will not trigger any
comment|// remote IO, assuming the source iterator is in its initial
comment|// iteration
name|requestNextBatch
argument_list|()
expr_stmt|;
block|}
comment|/**      * Report whether or not there is new data available.      * If there is data in the local filtered list, return true.      * Else: request more data util that condition is met, or there      * is no more remote listing data.      * Lastly, return true if the {@code providedStatusIterator}      * has left items.      * @return true if a call to {@link #next()} will succeed.      * @throws IOException      */
annotation|@
name|Override
DECL|method|hasNext ()
specifier|public
name|boolean
name|hasNext
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|sourceHasNext
argument_list|()
operator|||
name|providedStatusIterator
operator|.
name|hasNext
argument_list|()
return|;
block|}
DECL|method|sourceHasNext ()
specifier|private
name|boolean
name|sourceHasNext
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|statusBatchIterator
operator|.
name|hasNext
argument_list|()
operator|||
name|requestNextBatch
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
else|else
block|{
comment|// turn to file status that are only in provided list
if|if
condition|(
name|providedStatusIterator
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Start iterating the provided status."
argument_list|)
expr_stmt|;
name|providedStatusIterator
operator|=
name|providedStatus
operator|.
name|iterator
argument_list|()
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|next ()
specifier|public
name|FileStatus
name|next
parameter_list|()
throws|throws
name|IOException
block|{
specifier|final
name|FileStatus
name|status
decl_stmt|;
if|if
condition|(
name|sourceHasNext
argument_list|()
condition|)
block|{
name|status
operator|=
name|statusBatchIterator
operator|.
name|next
argument_list|()
expr_stmt|;
comment|// We remove from provided list the file status listed by S3 so that
comment|// this does not return duplicate items.
if|if
condition|(
name|providedStatus
operator|.
name|remove
argument_list|(
name|status
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Removed the status from provided file status {}"
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|providedStatusIterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|status
operator|=
name|providedStatusIterator
operator|.
name|next
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Returning provided file status {}"
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|NoSuchElementException
argument_list|()
throw|;
block|}
block|}
return|return
name|status
return|;
block|}
comment|/**      * Try to retrieve another batch.      * Note that for the initial batch,      * {@link ObjectListingIterator} does not generate a request;      * it simply returns the initial set.      *      * @return true if a new batch was created.      * @throws IOException IO problems      */
DECL|method|requestNextBatch ()
specifier|private
name|boolean
name|requestNextBatch
parameter_list|()
throws|throws
name|IOException
block|{
comment|// look for more object listing batches being available
while|while
condition|(
name|source
operator|.
name|hasNext
argument_list|()
condition|)
block|{
comment|// if available, retrieve it and build the next status
if|if
condition|(
name|buildNextStatusBatch
argument_list|(
name|source
operator|.
name|next
argument_list|()
argument_list|)
condition|)
block|{
comment|// this batch successfully generated entries matching the filters/
comment|// acceptors; declare that the request was successful
return|return
literal|true
return|;
block|}
else|else
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"All entries in batch were filtered...continuing"
argument_list|)
expr_stmt|;
block|}
block|}
comment|// if this code is reached, it means that all remaining
comment|// object lists have been retrieved, and there are no new entries
comment|// to return.
return|return
literal|false
return|;
block|}
comment|/**      * Build the next status batch from a listing.      * @param objects the next object listing      * @return true if this added any entries after filtering      */
DECL|method|buildNextStatusBatch (S3ListResult objects)
specifier|private
name|boolean
name|buildNextStatusBatch
parameter_list|(
name|S3ListResult
name|objects
parameter_list|)
block|{
comment|// counters for debug logs
name|int
name|added
init|=
literal|0
decl_stmt|,
name|ignored
init|=
literal|0
decl_stmt|;
comment|// list to fill in with results. Initial size will be list maximum.
name|List
argument_list|<
name|FileStatus
argument_list|>
name|stats
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|objects
operator|.
name|getObjectSummaries
argument_list|()
operator|.
name|size
argument_list|()
operator|+
name|objects
operator|.
name|getCommonPrefixes
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
comment|// objects
for|for
control|(
name|S3ObjectSummary
name|summary
range|:
name|objects
operator|.
name|getObjectSummaries
argument_list|()
control|)
block|{
name|String
name|key
init|=
name|summary
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|Path
name|keyPath
init|=
name|owner
operator|.
name|keyToQualifiedPath
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"{}: {}"
argument_list|,
name|keyPath
argument_list|,
name|stringify
argument_list|(
name|summary
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Skip over keys that are ourselves and old S3N _$folder$ files
if|if
condition|(
name|acceptor
operator|.
name|accept
argument_list|(
name|keyPath
argument_list|,
name|summary
argument_list|)
operator|&&
name|filter
operator|.
name|accept
argument_list|(
name|keyPath
argument_list|)
condition|)
block|{
name|FileStatus
name|status
init|=
name|createFileStatus
argument_list|(
name|keyPath
argument_list|,
name|summary
argument_list|,
name|owner
operator|.
name|getDefaultBlockSize
argument_list|(
name|keyPath
argument_list|)
argument_list|,
name|owner
operator|.
name|getUsername
argument_list|()
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Adding: {}"
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|stats
operator|.
name|add
argument_list|(
name|status
argument_list|)
expr_stmt|;
name|added
operator|++
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Ignoring: {}"
argument_list|,
name|keyPath
argument_list|)
expr_stmt|;
name|ignored
operator|++
expr_stmt|;
block|}
block|}
comment|// prefixes: always directories
for|for
control|(
name|String
name|prefix
range|:
name|objects
operator|.
name|getCommonPrefixes
argument_list|()
control|)
block|{
name|Path
name|keyPath
init|=
name|owner
operator|.
name|keyToQualifiedPath
argument_list|(
name|prefix
argument_list|)
decl_stmt|;
if|if
condition|(
name|acceptor
operator|.
name|accept
argument_list|(
name|keyPath
argument_list|,
name|prefix
argument_list|)
operator|&&
name|filter
operator|.
name|accept
argument_list|(
name|keyPath
argument_list|)
condition|)
block|{
name|FileStatus
name|status
init|=
operator|new
name|S3AFileStatus
argument_list|(
name|Tristate
operator|.
name|FALSE
argument_list|,
name|keyPath
argument_list|,
name|owner
operator|.
name|getUsername
argument_list|()
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Adding directory: {}"
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|added
operator|++
expr_stmt|;
name|stats
operator|.
name|add
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Ignoring directory: {}"
argument_list|,
name|keyPath
argument_list|)
expr_stmt|;
name|ignored
operator|++
expr_stmt|;
block|}
block|}
comment|// finish up
name|batchSize
operator|=
name|stats
operator|.
name|size
argument_list|()
expr_stmt|;
name|statusBatchIterator
operator|=
name|stats
operator|.
name|listIterator
argument_list|()
expr_stmt|;
name|boolean
name|hasNext
init|=
name|statusBatchIterator
operator|.
name|hasNext
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Added {} entries; ignored {}; hasNext={}; hasMoreObjects={}"
argument_list|,
name|added
argument_list|,
name|ignored
argument_list|,
name|hasNext
argument_list|,
name|objects
operator|.
name|isTruncated
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|hasNext
return|;
block|}
comment|/**      * Get the number of entries in the current batch.      * @return a number, possibly zero.      */
DECL|method|getBatchSize ()
specifier|public
name|int
name|getBatchSize
parameter_list|()
block|{
return|return
name|batchSize
return|;
block|}
block|}
comment|/**    * Wraps up AWS `ListObjects` requests in a remote iterator    * which will ask for more listing data if needed.    *    * That is:    *    * 1. The first invocation of the {@link #next()} call will return the results    * of the first request, the one created during the construction of the    * instance.    *    * 2. Second and later invocations will continue the ongoing listing,    * calling {@link S3AFileSystem#continueListObjects} to request the next    * batch of results.    *    * 3. The {@link #hasNext()} predicate returns true for the initial call,    * where {@link #next()} will return the initial results. It declares    * that it has future results iff the last executed request was truncated.    *    * Thread safety: none.    */
DECL|class|ObjectListingIterator
class|class
name|ObjectListingIterator
implements|implements
name|RemoteIterator
argument_list|<
name|S3ListResult
argument_list|>
block|{
comment|/** The path listed. */
DECL|field|listPath
specifier|private
specifier|final
name|Path
name|listPath
decl_stmt|;
comment|/** The most recent listing results. */
DECL|field|objects
specifier|private
name|S3ListResult
name|objects
decl_stmt|;
comment|/** The most recent listing request. */
DECL|field|request
specifier|private
name|S3ListRequest
name|request
decl_stmt|;
comment|/** Indicator that this is the first listing. */
DECL|field|firstListing
specifier|private
name|boolean
name|firstListing
init|=
literal|true
decl_stmt|;
comment|/**      * Count of how many listings have been requested      * (including initial result).      */
DECL|field|listingCount
specifier|private
name|int
name|listingCount
init|=
literal|1
decl_stmt|;
comment|/**      * Maximum keys in a request.      */
DECL|field|maxKeys
specifier|private
name|int
name|maxKeys
decl_stmt|;
comment|/**      * Constructor -calls `listObjects()` on the request to populate the      * initial set of results/fail if there was a problem talking to the bucket.      * @param listPath path of the listing      * @param request initial request to make      * @throws IOException if listObjects raises one.      */
DECL|method|ObjectListingIterator ( Path listPath, S3ListRequest request)
name|ObjectListingIterator
parameter_list|(
name|Path
name|listPath
parameter_list|,
name|S3ListRequest
name|request
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|listPath
operator|=
name|listPath
expr_stmt|;
name|this
operator|.
name|maxKeys
operator|=
name|owner
operator|.
name|getMaxKeys
argument_list|()
expr_stmt|;
name|this
operator|.
name|objects
operator|=
name|owner
operator|.
name|listObjects
argument_list|(
name|request
argument_list|)
expr_stmt|;
name|this
operator|.
name|request
operator|=
name|request
expr_stmt|;
block|}
comment|/**      * Declare that the iterator has data if it is either is the initial      * iteration or it is a later one and the last listing obtained was      * incomplete.      * @throws IOException never: there is no IO in this operation.      */
annotation|@
name|Override
DECL|method|hasNext ()
specifier|public
name|boolean
name|hasNext
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|firstListing
operator|||
name|objects
operator|.
name|isTruncated
argument_list|()
return|;
block|}
comment|/**      * Ask for the next listing.      * For the first invocation, this returns the initial set, with no      * remote IO. For later requests, S3 will be queried, hence the calls      * may block or fail.      * @return the next object listing.      * @throws IOException if a query made of S3 fails.      * @throws NoSuchElementException if there is no more data to list.      */
annotation|@
name|Override
annotation|@
name|Retries
operator|.
name|RetryTranslated
DECL|method|next ()
specifier|public
name|S3ListResult
name|next
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|firstListing
condition|)
block|{
comment|// on the first listing, don't request more data.
comment|// Instead just clear the firstListing flag so that it future calls
comment|// will request new data.
name|firstListing
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
try|try
block|{
if|if
condition|(
operator|!
name|objects
operator|.
name|isTruncated
argument_list|()
condition|)
block|{
comment|// nothing more to request: fail.
throw|throw
operator|new
name|NoSuchElementException
argument_list|(
literal|"No more results in listing of "
operator|+
name|listPath
argument_list|)
throw|;
block|}
comment|// need to request a new set of objects.
name|LOG
operator|.
name|debug
argument_list|(
literal|"[{}], Requesting next {} objects under {}"
argument_list|,
name|listingCount
argument_list|,
name|maxKeys
argument_list|,
name|listPath
argument_list|)
expr_stmt|;
name|objects
operator|=
name|owner
operator|.
name|continueListObjects
argument_list|(
name|request
argument_list|,
name|objects
argument_list|)
expr_stmt|;
name|listingCount
operator|++
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"New listing status: {}"
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|AmazonClientException
name|e
parameter_list|)
block|{
throw|throw
name|translateException
argument_list|(
literal|"listObjects()"
argument_list|,
name|listPath
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
return|return
name|objects
return|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"Object listing iterator against "
operator|+
name|listPath
operator|+
literal|"; listing count "
operator|+
name|listingCount
operator|+
literal|"; isTruncated="
operator|+
name|objects
operator|.
name|isTruncated
argument_list|()
return|;
block|}
comment|/**      * Get the path listed.      * @return the path used in this listing.      */
DECL|method|getListPath ()
specifier|public
name|Path
name|getListPath
parameter_list|()
block|{
return|return
name|listPath
return|;
block|}
comment|/**      * Get the count of listing requests.      * @return the counter of requests made (including the initial lookup).      */
DECL|method|getListingCount ()
specifier|public
name|int
name|getListingCount
parameter_list|()
block|{
return|return
name|listingCount
return|;
block|}
block|}
comment|/**    * Accept all entries except the base path and those which map to S3N    * pseudo directory markers.    */
DECL|class|AcceptFilesOnly
specifier|static
class|class
name|AcceptFilesOnly
implements|implements
name|FileStatusAcceptor
block|{
DECL|field|qualifiedPath
specifier|private
specifier|final
name|Path
name|qualifiedPath
decl_stmt|;
DECL|method|AcceptFilesOnly (Path qualifiedPath)
specifier|public
name|AcceptFilesOnly
parameter_list|(
name|Path
name|qualifiedPath
parameter_list|)
block|{
name|this
operator|.
name|qualifiedPath
operator|=
name|qualifiedPath
expr_stmt|;
block|}
comment|/**      * Reject a summary entry if the key path is the qualified Path, or      * it ends with {@code "_$folder$"}.      * @param keyPath key path of the entry      * @param summary summary entry      * @return true if the entry is accepted (i.e. that a status entry      * should be generated.      */
annotation|@
name|Override
DECL|method|accept (Path keyPath, S3ObjectSummary summary)
specifier|public
name|boolean
name|accept
parameter_list|(
name|Path
name|keyPath
parameter_list|,
name|S3ObjectSummary
name|summary
parameter_list|)
block|{
return|return
operator|!
name|keyPath
operator|.
name|equals
argument_list|(
name|qualifiedPath
argument_list|)
operator|&&
operator|!
name|summary
operator|.
name|getKey
argument_list|()
operator|.
name|endsWith
argument_list|(
name|S3N_FOLDER_SUFFIX
argument_list|)
operator|&&
operator|!
name|objectRepresentsDirectory
argument_list|(
name|summary
operator|.
name|getKey
argument_list|()
argument_list|,
name|summary
operator|.
name|getSize
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Accept no directory paths.      * @param keyPath qualified path to the entry      * @param prefix common prefix in listing.      * @return false, always.      */
annotation|@
name|Override
DECL|method|accept (Path keyPath, String prefix)
specifier|public
name|boolean
name|accept
parameter_list|(
name|Path
name|keyPath
parameter_list|,
name|String
name|prefix
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
annotation|@
name|Override
DECL|method|accept (FileStatus status)
specifier|public
name|boolean
name|accept
parameter_list|(
name|FileStatus
name|status
parameter_list|)
block|{
return|return
operator|(
name|status
operator|!=
literal|null
operator|)
operator|&&
name|status
operator|.
name|isFile
argument_list|()
return|;
block|}
block|}
comment|/**    * Take a remote iterator over a set of {@link FileStatus} instances and    * return a remote iterator of {@link LocatedFileStatus} instances.    */
DECL|class|LocatedFileStatusIterator
class|class
name|LocatedFileStatusIterator
implements|implements
name|RemoteIterator
argument_list|<
name|LocatedFileStatus
argument_list|>
block|{
DECL|field|statusIterator
specifier|private
specifier|final
name|RemoteIterator
argument_list|<
name|FileStatus
argument_list|>
name|statusIterator
decl_stmt|;
comment|/**      * Constructor.      * @param statusIterator an iterator over the remote status entries      */
DECL|method|LocatedFileStatusIterator (RemoteIterator<FileStatus> statusIterator)
name|LocatedFileStatusIterator
parameter_list|(
name|RemoteIterator
argument_list|<
name|FileStatus
argument_list|>
name|statusIterator
parameter_list|)
block|{
name|this
operator|.
name|statusIterator
operator|=
name|statusIterator
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|hasNext ()
specifier|public
name|boolean
name|hasNext
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|statusIterator
operator|.
name|hasNext
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|next ()
specifier|public
name|LocatedFileStatus
name|next
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|owner
operator|.
name|toLocatedFileStatus
argument_list|(
name|statusIterator
operator|.
name|next
argument_list|()
argument_list|)
return|;
block|}
block|}
comment|/**    * Wraps another iterator and filters out files that appear in the provided    * set of tombstones.  Will read ahead in the iterator when necessary to    * ensure that emptiness is detected early enough if only deleted objects    * remain in the source iterator.    */
DECL|class|TombstoneReconcilingIterator
specifier|static
class|class
name|TombstoneReconcilingIterator
implements|implements
name|RemoteIterator
argument_list|<
name|LocatedFileStatus
argument_list|>
block|{
DECL|field|next
specifier|private
name|LocatedFileStatus
name|next
init|=
literal|null
decl_stmt|;
DECL|field|iterator
specifier|private
specifier|final
name|RemoteIterator
argument_list|<
name|LocatedFileStatus
argument_list|>
name|iterator
decl_stmt|;
DECL|field|tombstones
specifier|private
specifier|final
name|Set
argument_list|<
name|Path
argument_list|>
name|tombstones
decl_stmt|;
comment|/**      * @param iterator Source iterator to filter      * @param tombstones set of tombstone markers to filter out of results      */
DECL|method|TombstoneReconcilingIterator (RemoteIterator<LocatedFileStatus> iterator, Set<Path> tombstones)
name|TombstoneReconcilingIterator
parameter_list|(
name|RemoteIterator
argument_list|<
name|LocatedFileStatus
argument_list|>
name|iterator
parameter_list|,
name|Set
argument_list|<
name|Path
argument_list|>
name|tombstones
parameter_list|)
block|{
name|this
operator|.
name|iterator
operator|=
name|iterator
expr_stmt|;
if|if
condition|(
name|tombstones
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|tombstones
operator|=
name|tombstones
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|tombstones
operator|=
name|Collections
operator|.
name|EMPTY_SET
expr_stmt|;
block|}
block|}
DECL|method|fetch ()
specifier|private
name|boolean
name|fetch
parameter_list|()
throws|throws
name|IOException
block|{
while|while
condition|(
name|next
operator|==
literal|null
operator|&&
name|iterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|LocatedFileStatus
name|candidate
init|=
name|iterator
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|tombstones
operator|.
name|contains
argument_list|(
name|candidate
operator|.
name|getPath
argument_list|()
argument_list|)
condition|)
block|{
name|next
operator|=
name|candidate
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
DECL|method|hasNext ()
specifier|public
name|boolean
name|hasNext
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|next
operator|!=
literal|null
condition|)
block|{
return|return
literal|true
return|;
block|}
return|return
name|fetch
argument_list|()
return|;
block|}
DECL|method|next ()
specifier|public
name|LocatedFileStatus
name|next
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|hasNext
argument_list|()
condition|)
block|{
name|LocatedFileStatus
name|result
init|=
name|next
decl_stmt|;
name|next
operator|=
literal|null
expr_stmt|;
name|fetch
argument_list|()
expr_stmt|;
return|return
name|result
return|;
block|}
throw|throw
operator|new
name|NoSuchElementException
argument_list|()
throw|;
block|}
block|}
comment|/**    * Accept all entries except those which map to S3N pseudo directory markers.    */
DECL|class|AcceptAllButS3nDirs
specifier|static
class|class
name|AcceptAllButS3nDirs
implements|implements
name|FileStatusAcceptor
block|{
DECL|method|accept (Path keyPath, S3ObjectSummary summary)
specifier|public
name|boolean
name|accept
parameter_list|(
name|Path
name|keyPath
parameter_list|,
name|S3ObjectSummary
name|summary
parameter_list|)
block|{
return|return
operator|!
name|summary
operator|.
name|getKey
argument_list|()
operator|.
name|endsWith
argument_list|(
name|S3N_FOLDER_SUFFIX
argument_list|)
return|;
block|}
DECL|method|accept (Path keyPath, String prefix)
specifier|public
name|boolean
name|accept
parameter_list|(
name|Path
name|keyPath
parameter_list|,
name|String
name|prefix
parameter_list|)
block|{
return|return
operator|!
name|keyPath
operator|.
name|toString
argument_list|()
operator|.
name|endsWith
argument_list|(
name|S3N_FOLDER_SUFFIX
argument_list|)
return|;
block|}
DECL|method|accept (FileStatus status)
specifier|public
name|boolean
name|accept
parameter_list|(
name|FileStatus
name|status
parameter_list|)
block|{
return|return
operator|!
name|status
operator|.
name|getPath
argument_list|()
operator|.
name|toString
argument_list|()
operator|.
name|endsWith
argument_list|(
name|S3N_FOLDER_SUFFIX
argument_list|)
return|;
block|}
block|}
comment|/**    * Accept all entries except the base path and those which map to S3N    * pseudo directory markers.    */
DECL|class|AcceptAllButSelfAndS3nDirs
specifier|static
class|class
name|AcceptAllButSelfAndS3nDirs
implements|implements
name|FileStatusAcceptor
block|{
comment|/** Base path. */
DECL|field|qualifiedPath
specifier|private
specifier|final
name|Path
name|qualifiedPath
decl_stmt|;
comment|/**      * Constructor.      * @param qualifiedPath an already-qualified path.      */
DECL|method|AcceptAllButSelfAndS3nDirs (Path qualifiedPath)
specifier|public
name|AcceptAllButSelfAndS3nDirs
parameter_list|(
name|Path
name|qualifiedPath
parameter_list|)
block|{
name|this
operator|.
name|qualifiedPath
operator|=
name|qualifiedPath
expr_stmt|;
block|}
comment|/**      * Reject a summary entry if the key path is the qualified Path, or      * it ends with {@code "_$folder$"}.      * @param keyPath key path of the entry      * @param summary summary entry      * @return true if the entry is accepted (i.e. that a status entry      * should be generated.)      */
annotation|@
name|Override
DECL|method|accept (Path keyPath, S3ObjectSummary summary)
specifier|public
name|boolean
name|accept
parameter_list|(
name|Path
name|keyPath
parameter_list|,
name|S3ObjectSummary
name|summary
parameter_list|)
block|{
return|return
operator|!
name|keyPath
operator|.
name|equals
argument_list|(
name|qualifiedPath
argument_list|)
operator|&&
operator|!
name|summary
operator|.
name|getKey
argument_list|()
operator|.
name|endsWith
argument_list|(
name|S3N_FOLDER_SUFFIX
argument_list|)
return|;
block|}
comment|/**      * Accept all prefixes except the one for the base path, "self".      * @param keyPath qualified path to the entry      * @param prefix common prefix in listing.      * @return true if the entry is accepted (i.e. that a status entry      * should be generated.      */
annotation|@
name|Override
DECL|method|accept (Path keyPath, String prefix)
specifier|public
name|boolean
name|accept
parameter_list|(
name|Path
name|keyPath
parameter_list|,
name|String
name|prefix
parameter_list|)
block|{
return|return
operator|!
name|keyPath
operator|.
name|equals
argument_list|(
name|qualifiedPath
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|accept (FileStatus status)
specifier|public
name|boolean
name|accept
parameter_list|(
name|FileStatus
name|status
parameter_list|)
block|{
return|return
operator|(
name|status
operator|!=
literal|null
operator|)
operator|&&
operator|!
name|status
operator|.
name|getPath
argument_list|()
operator|.
name|equals
argument_list|(
name|qualifiedPath
argument_list|)
return|;
block|}
block|}
block|}
end_class

end_unit

