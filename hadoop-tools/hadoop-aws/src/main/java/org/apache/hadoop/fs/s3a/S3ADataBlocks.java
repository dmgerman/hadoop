begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.fs.s3a
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|BufferedOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Closeable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|EOFException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileNotFoundException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FilterInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|ByteBuffer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicBoolean
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FSExceptionMessages
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|DirectBufferPool
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|S3ADataBlocks
operator|.
name|DataBlock
operator|.
name|DestState
operator|.
name|*
import|;
end_import

begin_comment
comment|/**  * Set of classes to support output streaming into blocks which are then  * uploaded as partitions.  */
end_comment

begin_class
DECL|class|S3ADataBlocks
specifier|final
class|class
name|S3ADataBlocks
block|{
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|S3ADataBlocks
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|method|S3ADataBlocks ()
specifier|private
name|S3ADataBlocks
parameter_list|()
block|{   }
comment|/**    * Validate args to a write command. These are the same validation checks    * expected for any implementation of {@code OutputStream.write()}.    * @param b byte array containing data    * @param off offset in array where to start    * @param len number of bytes to be written    * @throws NullPointerException for a null buffer    * @throws IndexOutOfBoundsException if indices are out of range    */
DECL|method|validateWriteArgs (byte[] b, int off, int len)
specifier|static
name|void
name|validateWriteArgs
parameter_list|(
name|byte
index|[]
name|b
parameter_list|,
name|int
name|off
parameter_list|,
name|int
name|len
parameter_list|)
throws|throws
name|IOException
block|{
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|off
operator|<
literal|0
operator|)
operator|||
operator|(
name|off
operator|>
name|b
operator|.
name|length
operator|)
operator|||
operator|(
name|len
operator|<
literal|0
operator|)
operator|||
operator|(
operator|(
name|off
operator|+
name|len
operator|)
operator|>
name|b
operator|.
name|length
operator|)
operator|||
operator|(
operator|(
name|off
operator|+
name|len
operator|)
operator|<
literal|0
operator|)
condition|)
block|{
throw|throw
operator|new
name|IndexOutOfBoundsException
argument_list|(
literal|"write (b["
operator|+
name|b
operator|.
name|length
operator|+
literal|"], "
operator|+
name|off
operator|+
literal|", "
operator|+
name|len
operator|+
literal|')'
argument_list|)
throw|;
block|}
block|}
comment|/**    * Create a factory.    * @param owner factory owner    * @param name factory name -the option from {@link Constants}.    * @return the factory, ready to be initialized.    * @throws IllegalArgumentException if the name is unknown.    */
DECL|method|createFactory (S3AFileSystem owner, String name)
specifier|static
name|BlockFactory
name|createFactory
parameter_list|(
name|S3AFileSystem
name|owner
parameter_list|,
name|String
name|name
parameter_list|)
block|{
switch|switch
condition|(
name|name
condition|)
block|{
case|case
name|Constants
operator|.
name|FAST_UPLOAD_BUFFER_ARRAY
case|:
return|return
operator|new
name|ArrayBlockFactory
argument_list|(
name|owner
argument_list|)
return|;
case|case
name|Constants
operator|.
name|FAST_UPLOAD_BUFFER_DISK
case|:
return|return
operator|new
name|DiskBlockFactory
argument_list|(
name|owner
argument_list|)
return|;
case|case
name|Constants
operator|.
name|FAST_UPLOAD_BYTEBUFFER
case|:
return|return
operator|new
name|ByteBufferBlockFactory
argument_list|(
name|owner
argument_list|)
return|;
default|default:
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Unsupported block buffer"
operator|+
literal|" \""
operator|+
name|name
operator|+
literal|'"'
argument_list|)
throw|;
block|}
block|}
comment|/**    * Base class for block factories.    */
DECL|class|BlockFactory
specifier|static
specifier|abstract
class|class
name|BlockFactory
implements|implements
name|Closeable
block|{
DECL|field|owner
specifier|private
specifier|final
name|S3AFileSystem
name|owner
decl_stmt|;
DECL|method|BlockFactory (S3AFileSystem owner)
specifier|protected
name|BlockFactory
parameter_list|(
name|S3AFileSystem
name|owner
parameter_list|)
block|{
name|this
operator|.
name|owner
operator|=
name|owner
expr_stmt|;
block|}
comment|/**      * Create a block.      * @param limit limit of the block.      * @return a new block.      */
DECL|method|create (int limit)
specifier|abstract
name|DataBlock
name|create
parameter_list|(
name|int
name|limit
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/**      * Implement any close/cleanup operation.      * Base class is a no-op      * @throws IOException -ideally, it shouldn't.      */
annotation|@
name|Override
DECL|method|close ()
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{     }
comment|/**      * Owner.      */
DECL|method|getOwner ()
specifier|protected
name|S3AFileSystem
name|getOwner
parameter_list|()
block|{
return|return
name|owner
return|;
block|}
block|}
comment|/**    * This represents a block being uploaded.    */
DECL|class|DataBlock
specifier|static
specifier|abstract
class|class
name|DataBlock
implements|implements
name|Closeable
block|{
DECL|enum|DestState
DECL|enumConstant|Writing
DECL|enumConstant|Upload
DECL|enumConstant|Closed
enum|enum
name|DestState
block|{
name|Writing
block|,
name|Upload
block|,
name|Closed
block|}
DECL|field|state
specifier|private
specifier|volatile
name|DestState
name|state
init|=
name|Writing
decl_stmt|;
comment|/**      * Atomically enter a state, verifying current state.      * @param current current state. null means "no check"      * @param next next state      * @throws IllegalStateException if the current state is not as expected      */
DECL|method|enterState (DestState current, DestState next)
specifier|protected
specifier|synchronized
specifier|final
name|void
name|enterState
parameter_list|(
name|DestState
name|current
parameter_list|,
name|DestState
name|next
parameter_list|)
throws|throws
name|IllegalStateException
block|{
name|verifyState
argument_list|(
name|current
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"{}: entering state {}"
argument_list|,
name|this
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|state
operator|=
name|next
expr_stmt|;
block|}
comment|/**      * Verify that the block is in the declared state.      * @param expected expected state.      * @throws IllegalStateException if the DataBlock is in the wrong state      */
DECL|method|verifyState (DestState expected)
specifier|protected
specifier|final
name|void
name|verifyState
parameter_list|(
name|DestState
name|expected
parameter_list|)
throws|throws
name|IllegalStateException
block|{
if|if
condition|(
name|expected
operator|!=
literal|null
operator|&&
name|state
operator|!=
name|expected
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Expected stream state "
operator|+
name|expected
operator|+
literal|" -but actual state is "
operator|+
name|state
operator|+
literal|" in "
operator|+
name|this
argument_list|)
throw|;
block|}
block|}
comment|/**      * Current state.      * @return the current state.      */
DECL|method|getState ()
specifier|final
name|DestState
name|getState
parameter_list|()
block|{
return|return
name|state
return|;
block|}
comment|/**      * Return the current data size.      * @return the size of the data      */
DECL|method|dataSize ()
specifier|abstract
name|int
name|dataSize
parameter_list|()
function_decl|;
comment|/**      * Predicate to verify that the block has the capacity to write      * the given set of bytes.      * @param bytes number of bytes desired to be written.      * @return true if there is enough space.      */
DECL|method|hasCapacity (long bytes)
specifier|abstract
name|boolean
name|hasCapacity
parameter_list|(
name|long
name|bytes
parameter_list|)
function_decl|;
comment|/**      * Predicate to check if there is data in the block.      * @return true if there is      */
DECL|method|hasData ()
name|boolean
name|hasData
parameter_list|()
block|{
return|return
name|dataSize
argument_list|()
operator|>
literal|0
return|;
block|}
comment|/**      * The remaining capacity in the block before it is full.      * @return the number of bytes remaining.      */
DECL|method|remainingCapacity ()
specifier|abstract
name|int
name|remainingCapacity
parameter_list|()
function_decl|;
comment|/**      * Write a series of bytes from the buffer, from the offset.      * Returns the number of bytes written.      * Only valid in the state {@code Writing}.      * Base class verifies the state but does no writing.      * @param buffer buffer      * @param offset offset      * @param length length of write      * @return number of bytes written      * @throws IOException trouble      */
DECL|method|write (byte[] buffer, int offset, int length)
name|int
name|write
parameter_list|(
name|byte
index|[]
name|buffer
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
throws|throws
name|IOException
block|{
name|verifyState
argument_list|(
name|Writing
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|buffer
operator|!=
literal|null
argument_list|,
literal|"Null buffer"
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|length
operator|>=
literal|0
argument_list|,
literal|"length is negative"
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|offset
operator|>=
literal|0
argument_list|,
literal|"offset is negative"
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkArgument
argument_list|(
operator|!
operator|(
name|buffer
operator|.
name|length
operator|-
name|offset
operator|<
name|length
operator|)
argument_list|,
literal|"buffer shorter than amount of data to write"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/**      * Flush the output.      * Only valid in the state {@code Writing}.      * In the base class, this is a no-op      * @throws IOException any IO problem.      */
DECL|method|flush ()
name|void
name|flush
parameter_list|()
throws|throws
name|IOException
block|{
name|verifyState
argument_list|(
name|Writing
argument_list|)
expr_stmt|;
block|}
comment|/**      * Switch to the upload state and return a stream for uploading.      * Base class calls {@link #enterState(DestState, DestState)} to      * manage the state machine.      * @return the stream      * @throws IOException trouble      */
DECL|method|startUpload ()
name|InputStream
name|startUpload
parameter_list|()
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Start datablock upload"
argument_list|)
expr_stmt|;
name|enterState
argument_list|(
name|Writing
argument_list|,
name|Upload
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
comment|/**      * Enter the closed state.      * @return true if the class was in any other state, implying that      * the subclass should do its close operations      */
DECL|method|enterClosedState ()
specifier|protected
specifier|synchronized
name|boolean
name|enterClosedState
parameter_list|()
block|{
if|if
condition|(
operator|!
name|state
operator|.
name|equals
argument_list|(
name|Closed
argument_list|)
condition|)
block|{
name|enterState
argument_list|(
literal|null
argument_list|,
name|Closed
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|close ()
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|enterClosedState
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Closed {}"
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|innerClose
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Inner close logic for subclasses to implement.      */
DECL|method|innerClose ()
specifier|protected
name|void
name|innerClose
parameter_list|()
throws|throws
name|IOException
block|{      }
block|}
comment|// ====================================================================
comment|/**    * Use byte arrays on the heap for storage.    */
DECL|class|ArrayBlockFactory
specifier|static
class|class
name|ArrayBlockFactory
extends|extends
name|BlockFactory
block|{
DECL|method|ArrayBlockFactory (S3AFileSystem owner)
name|ArrayBlockFactory
parameter_list|(
name|S3AFileSystem
name|owner
parameter_list|)
block|{
name|super
argument_list|(
name|owner
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|create (int limit)
name|DataBlock
name|create
parameter_list|(
name|int
name|limit
parameter_list|)
throws|throws
name|IOException
block|{
return|return
operator|new
name|ByteArrayBlock
argument_list|(
name|limit
argument_list|)
return|;
block|}
block|}
DECL|class|S3AByteArrayOutputStream
specifier|static
class|class
name|S3AByteArrayOutputStream
extends|extends
name|ByteArrayOutputStream
block|{
DECL|method|S3AByteArrayOutputStream (int size)
name|S3AByteArrayOutputStream
parameter_list|(
name|int
name|size
parameter_list|)
block|{
name|super
argument_list|(
name|size
argument_list|)
expr_stmt|;
block|}
comment|/**      * InputStream backed by the internal byte array      *      * @return      */
DECL|method|getInputStream ()
name|ByteArrayInputStream
name|getInputStream
parameter_list|()
block|{
name|ByteArrayInputStream
name|bin
init|=
operator|new
name|ByteArrayInputStream
argument_list|(
name|this
operator|.
name|buf
argument_list|,
literal|0
argument_list|,
name|count
argument_list|)
decl_stmt|;
name|this
operator|.
name|reset
argument_list|()
expr_stmt|;
name|this
operator|.
name|buf
operator|=
literal|null
expr_stmt|;
return|return
name|bin
return|;
block|}
block|}
comment|/**    * Stream to memory via a {@code ByteArrayOutputStream}.    *    * This was taken from {@code S3AFastOutputStream} and has the    * same problem which surfaced there: it can consume a lot of heap space    * proportional to the mismatch between writes to the stream and    * the JVM-wide upload bandwidth to the S3 endpoint.    * The memory consumption can be limited by tuning the filesystem settings    * to restrict the number of queued/active uploads.    */
DECL|class|ByteArrayBlock
specifier|static
class|class
name|ByteArrayBlock
extends|extends
name|DataBlock
block|{
DECL|field|buffer
specifier|private
name|S3AByteArrayOutputStream
name|buffer
decl_stmt|;
DECL|field|limit
specifier|private
specifier|final
name|int
name|limit
decl_stmt|;
comment|// cache data size so that it is consistent after the buffer is reset.
DECL|field|dataSize
specifier|private
name|Integer
name|dataSize
decl_stmt|;
DECL|method|ByteArrayBlock (int limit)
name|ByteArrayBlock
parameter_list|(
name|int
name|limit
parameter_list|)
block|{
name|this
operator|.
name|limit
operator|=
name|limit
expr_stmt|;
name|buffer
operator|=
operator|new
name|S3AByteArrayOutputStream
argument_list|(
name|limit
argument_list|)
expr_stmt|;
block|}
comment|/**      * Get the amount of data; if there is no buffer then the size is 0.      * @return the amount of data available to upload.      */
annotation|@
name|Override
DECL|method|dataSize ()
name|int
name|dataSize
parameter_list|()
block|{
return|return
name|dataSize
operator|!=
literal|null
condition|?
name|dataSize
else|:
name|buffer
operator|.
name|size
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|startUpload ()
name|InputStream
name|startUpload
parameter_list|()
throws|throws
name|IOException
block|{
name|super
operator|.
name|startUpload
argument_list|()
expr_stmt|;
name|dataSize
operator|=
name|buffer
operator|.
name|size
argument_list|()
expr_stmt|;
name|ByteArrayInputStream
name|bufferData
init|=
name|buffer
operator|.
name|getInputStream
argument_list|()
decl_stmt|;
name|buffer
operator|=
literal|null
expr_stmt|;
return|return
name|bufferData
return|;
block|}
annotation|@
name|Override
DECL|method|hasCapacity (long bytes)
name|boolean
name|hasCapacity
parameter_list|(
name|long
name|bytes
parameter_list|)
block|{
return|return
name|dataSize
argument_list|()
operator|+
name|bytes
operator|<=
name|limit
return|;
block|}
annotation|@
name|Override
DECL|method|remainingCapacity ()
name|int
name|remainingCapacity
parameter_list|()
block|{
return|return
name|limit
operator|-
name|dataSize
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|write (byte[] b, int offset, int len)
name|int
name|write
parameter_list|(
name|byte
index|[]
name|b
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|len
parameter_list|)
throws|throws
name|IOException
block|{
name|super
operator|.
name|write
argument_list|(
name|b
argument_list|,
name|offset
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|int
name|written
init|=
name|Math
operator|.
name|min
argument_list|(
name|remainingCapacity
argument_list|()
argument_list|,
name|len
argument_list|)
decl_stmt|;
name|buffer
operator|.
name|write
argument_list|(
name|b
argument_list|,
name|offset
argument_list|,
name|written
argument_list|)
expr_stmt|;
return|return
name|written
return|;
block|}
annotation|@
name|Override
DECL|method|innerClose ()
specifier|protected
name|void
name|innerClose
parameter_list|()
block|{
name|buffer
operator|=
literal|null
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"ByteArrayBlock{"
operator|+
literal|"state="
operator|+
name|getState
argument_list|()
operator|+
literal|", limit="
operator|+
name|limit
operator|+
literal|", dataSize="
operator|+
name|dataSize
operator|+
literal|'}'
return|;
block|}
block|}
comment|// ====================================================================
comment|/**    * Stream via Direct ByteBuffers; these are allocated off heap    * via {@link DirectBufferPool}.    * This is actually the most complex of all the block factories,    * due to the need to explicitly recycle buffers; in comparison, the    * {@link DiskBlock} buffer delegates the work of deleting files to    * the {@link DiskBlock.FileDeletingInputStream}. Here the    * input stream {@link ByteBufferInputStream} has a similar task, along    * with the foundational work of streaming data from a byte array.    */
DECL|class|ByteBufferBlockFactory
specifier|static
class|class
name|ByteBufferBlockFactory
extends|extends
name|BlockFactory
block|{
DECL|field|bufferPool
specifier|private
specifier|final
name|DirectBufferPool
name|bufferPool
init|=
operator|new
name|DirectBufferPool
argument_list|()
decl_stmt|;
DECL|field|buffersOutstanding
specifier|private
specifier|final
name|AtomicInteger
name|buffersOutstanding
init|=
operator|new
name|AtomicInteger
argument_list|(
literal|0
argument_list|)
decl_stmt|;
DECL|method|ByteBufferBlockFactory (S3AFileSystem owner)
name|ByteBufferBlockFactory
parameter_list|(
name|S3AFileSystem
name|owner
parameter_list|)
block|{
name|super
argument_list|(
name|owner
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|create (int limit)
name|ByteBufferBlock
name|create
parameter_list|(
name|int
name|limit
parameter_list|)
throws|throws
name|IOException
block|{
return|return
operator|new
name|ByteBufferBlock
argument_list|(
name|limit
argument_list|)
return|;
block|}
DECL|method|requestBuffer (int limit)
specifier|private
name|ByteBuffer
name|requestBuffer
parameter_list|(
name|int
name|limit
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Requesting buffer of size {}"
argument_list|,
name|limit
argument_list|)
expr_stmt|;
name|buffersOutstanding
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
return|return
name|bufferPool
operator|.
name|getBuffer
argument_list|(
name|limit
argument_list|)
return|;
block|}
DECL|method|releaseBuffer (ByteBuffer buffer)
specifier|private
name|void
name|releaseBuffer
parameter_list|(
name|ByteBuffer
name|buffer
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Releasing buffer"
argument_list|)
expr_stmt|;
name|bufferPool
operator|.
name|returnBuffer
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|buffersOutstanding
operator|.
name|decrementAndGet
argument_list|()
expr_stmt|;
block|}
comment|/**      * Get count of outstanding buffers.      * @return the current buffer count      */
DECL|method|getOutstandingBufferCount ()
specifier|public
name|int
name|getOutstandingBufferCount
parameter_list|()
block|{
return|return
name|buffersOutstanding
operator|.
name|get
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"ByteBufferBlockFactory{"
operator|+
literal|"buffersOutstanding="
operator|+
name|buffersOutstanding
operator|+
literal|'}'
return|;
block|}
comment|/**      * A DataBlock which requests a buffer from pool on creation; returns      * it when the output stream is closed.      */
DECL|class|ByteBufferBlock
class|class
name|ByteBufferBlock
extends|extends
name|DataBlock
block|{
DECL|field|buffer
specifier|private
name|ByteBuffer
name|buffer
decl_stmt|;
DECL|field|bufferSize
specifier|private
specifier|final
name|int
name|bufferSize
decl_stmt|;
comment|// cache data size so that it is consistent after the buffer is reset.
DECL|field|dataSize
specifier|private
name|Integer
name|dataSize
decl_stmt|;
comment|/**        * Instantiate. This will request a ByteBuffer of the desired size.        * @param bufferSize buffer size        */
DECL|method|ByteBufferBlock (int bufferSize)
name|ByteBufferBlock
parameter_list|(
name|int
name|bufferSize
parameter_list|)
block|{
name|this
operator|.
name|bufferSize
operator|=
name|bufferSize
expr_stmt|;
name|buffer
operator|=
name|requestBuffer
argument_list|(
name|bufferSize
argument_list|)
expr_stmt|;
block|}
comment|/**        * Get the amount of data; if there is no buffer then the size is 0.        * @return the amount of data available to upload.        */
annotation|@
name|Override
DECL|method|dataSize ()
name|int
name|dataSize
parameter_list|()
block|{
return|return
name|dataSize
operator|!=
literal|null
condition|?
name|dataSize
else|:
name|bufferCapacityUsed
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|startUpload ()
name|ByteBufferInputStream
name|startUpload
parameter_list|()
throws|throws
name|IOException
block|{
name|super
operator|.
name|startUpload
argument_list|()
expr_stmt|;
name|dataSize
operator|=
name|bufferCapacityUsed
argument_list|()
expr_stmt|;
comment|// set the buffer up from reading from the beginning
name|buffer
operator|.
name|limit
argument_list|(
name|buffer
operator|.
name|position
argument_list|()
argument_list|)
expr_stmt|;
name|buffer
operator|.
name|position
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
operator|new
name|ByteBufferInputStream
argument_list|(
name|dataSize
argument_list|,
name|buffer
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|hasCapacity (long bytes)
specifier|public
name|boolean
name|hasCapacity
parameter_list|(
name|long
name|bytes
parameter_list|)
block|{
return|return
name|bytes
operator|<=
name|remainingCapacity
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|remainingCapacity ()
specifier|public
name|int
name|remainingCapacity
parameter_list|()
block|{
return|return
name|buffer
operator|!=
literal|null
condition|?
name|buffer
operator|.
name|remaining
argument_list|()
else|:
literal|0
return|;
block|}
DECL|method|bufferCapacityUsed ()
specifier|private
name|int
name|bufferCapacityUsed
parameter_list|()
block|{
return|return
name|buffer
operator|.
name|capacity
argument_list|()
operator|-
name|buffer
operator|.
name|remaining
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|write (byte[] b, int offset, int len)
name|int
name|write
parameter_list|(
name|byte
index|[]
name|b
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|len
parameter_list|)
throws|throws
name|IOException
block|{
name|super
operator|.
name|write
argument_list|(
name|b
argument_list|,
name|offset
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|int
name|written
init|=
name|Math
operator|.
name|min
argument_list|(
name|remainingCapacity
argument_list|()
argument_list|,
name|len
argument_list|)
decl_stmt|;
name|buffer
operator|.
name|put
argument_list|(
name|b
argument_list|,
name|offset
argument_list|,
name|written
argument_list|)
expr_stmt|;
return|return
name|written
return|;
block|}
annotation|@
name|Override
DECL|method|innerClose ()
specifier|protected
name|void
name|innerClose
parameter_list|()
block|{
name|buffer
operator|=
literal|null
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"ByteBufferBlock{"
operator|+
literal|"state="
operator|+
name|getState
argument_list|()
operator|+
literal|", dataSize="
operator|+
name|dataSize
argument_list|()
operator|+
literal|", limit="
operator|+
name|bufferSize
operator|+
literal|", remainingCapacity="
operator|+
name|remainingCapacity
argument_list|()
operator|+
literal|'}'
return|;
block|}
block|}
comment|/**      * Provide an input stream from a byte buffer; supporting      * {@link #mark(int)}, which is required to enable replay of failed      * PUT attempts.      * This input stream returns the buffer to the pool afterwards.      */
DECL|class|ByteBufferInputStream
class|class
name|ByteBufferInputStream
extends|extends
name|InputStream
block|{
DECL|field|size
specifier|private
specifier|final
name|int
name|size
decl_stmt|;
DECL|field|byteBuffer
specifier|private
name|ByteBuffer
name|byteBuffer
decl_stmt|;
DECL|method|ByteBufferInputStream (int size, ByteBuffer byteBuffer)
name|ByteBufferInputStream
parameter_list|(
name|int
name|size
parameter_list|,
name|ByteBuffer
name|byteBuffer
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Creating ByteBufferInputStream of size {}"
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|this
operator|.
name|size
operator|=
name|size
expr_stmt|;
name|this
operator|.
name|byteBuffer
operator|=
name|byteBuffer
expr_stmt|;
block|}
comment|/**        * Return the buffer to the pool after the stream is closed.        */
annotation|@
name|Override
DECL|method|close ()
specifier|public
specifier|synchronized
name|void
name|close
parameter_list|()
block|{
if|if
condition|(
name|byteBuffer
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"releasing buffer"
argument_list|)
expr_stmt|;
name|releaseBuffer
argument_list|(
name|byteBuffer
argument_list|)
expr_stmt|;
name|byteBuffer
operator|=
literal|null
expr_stmt|;
block|}
block|}
comment|/**        * Verify that the stream is open.        * @throws IOException if the stream is closed        */
DECL|method|verifyOpen ()
specifier|private
name|void
name|verifyOpen
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|byteBuffer
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|FSExceptionMessages
operator|.
name|STREAM_IS_CLOSED
argument_list|)
throw|;
block|}
block|}
DECL|method|read ()
specifier|public
specifier|synchronized
name|int
name|read
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|available
argument_list|()
operator|>
literal|0
condition|)
block|{
return|return
name|byteBuffer
operator|.
name|get
argument_list|()
operator|&
literal|0xFF
return|;
block|}
else|else
block|{
return|return
operator|-
literal|1
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|skip (long offset)
specifier|public
specifier|synchronized
name|long
name|skip
parameter_list|(
name|long
name|offset
parameter_list|)
throws|throws
name|IOException
block|{
name|verifyOpen
argument_list|()
expr_stmt|;
name|long
name|newPos
init|=
name|position
argument_list|()
operator|+
name|offset
decl_stmt|;
if|if
condition|(
name|newPos
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|EOFException
argument_list|(
name|FSExceptionMessages
operator|.
name|NEGATIVE_SEEK
argument_list|)
throw|;
block|}
if|if
condition|(
name|newPos
operator|>
name|size
condition|)
block|{
throw|throw
operator|new
name|EOFException
argument_list|(
name|FSExceptionMessages
operator|.
name|CANNOT_SEEK_PAST_EOF
argument_list|)
throw|;
block|}
name|byteBuffer
operator|.
name|position
argument_list|(
operator|(
name|int
operator|)
name|newPos
argument_list|)
expr_stmt|;
return|return
name|newPos
return|;
block|}
annotation|@
name|Override
DECL|method|available ()
specifier|public
specifier|synchronized
name|int
name|available
parameter_list|()
block|{
name|Preconditions
operator|.
name|checkState
argument_list|(
name|byteBuffer
operator|!=
literal|null
argument_list|,
name|FSExceptionMessages
operator|.
name|STREAM_IS_CLOSED
argument_list|)
expr_stmt|;
return|return
name|byteBuffer
operator|.
name|remaining
argument_list|()
return|;
block|}
comment|/**        * Get the current buffer position.        * @return the buffer position        */
DECL|method|position ()
specifier|public
specifier|synchronized
name|int
name|position
parameter_list|()
block|{
return|return
name|byteBuffer
operator|.
name|position
argument_list|()
return|;
block|}
comment|/**        * Check if there is data left.        * @return true if there is data remaining in the buffer.        */
DECL|method|hasRemaining ()
specifier|public
specifier|synchronized
name|boolean
name|hasRemaining
parameter_list|()
block|{
return|return
name|byteBuffer
operator|.
name|hasRemaining
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|mark (int readlimit)
specifier|public
specifier|synchronized
name|void
name|mark
parameter_list|(
name|int
name|readlimit
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"mark at {}"
argument_list|,
name|position
argument_list|()
argument_list|)
expr_stmt|;
name|byteBuffer
operator|.
name|mark
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|reset ()
specifier|public
specifier|synchronized
name|void
name|reset
parameter_list|()
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"reset"
argument_list|)
expr_stmt|;
name|byteBuffer
operator|.
name|reset
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|markSupported ()
specifier|public
name|boolean
name|markSupported
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
comment|/**        * Read in data.        * @param buffer destination buffer        * @param offset offset within the buffer        * @param length length of bytes to read        * @throws EOFException if the position is negative        * @throws IndexOutOfBoundsException if there isn't space for the        * amount of data requested.        * @throws IllegalArgumentException other arguments are invalid.        */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"NullableProblems"
argument_list|)
DECL|method|read (byte[] buffer, int offset, int length)
specifier|public
specifier|synchronized
name|int
name|read
parameter_list|(
name|byte
index|[]
name|buffer
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
throws|throws
name|IOException
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|length
operator|>=
literal|0
argument_list|,
literal|"length is negative"
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|buffer
operator|!=
literal|null
argument_list|,
literal|"Null buffer"
argument_list|)
expr_stmt|;
if|if
condition|(
name|buffer
operator|.
name|length
operator|-
name|offset
operator|<
name|length
condition|)
block|{
throw|throw
operator|new
name|IndexOutOfBoundsException
argument_list|(
name|FSExceptionMessages
operator|.
name|TOO_MANY_BYTES_FOR_DEST_BUFFER
operator|+
literal|": request length ="
operator|+
name|length
operator|+
literal|", with offset ="
operator|+
name|offset
operator|+
literal|"; buffer capacity ="
operator|+
operator|(
name|buffer
operator|.
name|length
operator|-
name|offset
operator|)
argument_list|)
throw|;
block|}
name|verifyOpen
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|hasRemaining
argument_list|()
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
name|int
name|toRead
init|=
name|Math
operator|.
name|min
argument_list|(
name|length
argument_list|,
name|available
argument_list|()
argument_list|)
decl_stmt|;
name|byteBuffer
operator|.
name|get
argument_list|(
name|buffer
argument_list|,
name|offset
argument_list|,
name|toRead
argument_list|)
expr_stmt|;
return|return
name|toRead
return|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
specifier|final
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|(
literal|"ByteBufferInputStream{"
argument_list|)
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"size="
argument_list|)
operator|.
name|append
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|ByteBuffer
name|buffer
init|=
name|this
operator|.
name|byteBuffer
decl_stmt|;
if|if
condition|(
name|buffer
operator|!=
literal|null
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|", available="
argument_list|)
operator|.
name|append
argument_list|(
name|buffer
operator|.
name|remaining
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
literal|'}'
argument_list|)
expr_stmt|;
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
block|}
comment|// ====================================================================
comment|/**    * Buffer blocks to disk.    */
DECL|class|DiskBlockFactory
specifier|static
class|class
name|DiskBlockFactory
extends|extends
name|BlockFactory
block|{
DECL|method|DiskBlockFactory (S3AFileSystem owner)
name|DiskBlockFactory
parameter_list|(
name|S3AFileSystem
name|owner
parameter_list|)
block|{
name|super
argument_list|(
name|owner
argument_list|)
expr_stmt|;
block|}
comment|/**      * Create a temp file and a block which writes to it.      * @param limit limit of the block.      * @return the new block      * @throws IOException IO problems      */
annotation|@
name|Override
DECL|method|create (int limit)
name|DataBlock
name|create
parameter_list|(
name|int
name|limit
parameter_list|)
throws|throws
name|IOException
block|{
name|File
name|destFile
init|=
name|getOwner
argument_list|()
operator|.
name|createTmpFileForWrite
argument_list|(
literal|"s3ablock"
argument_list|,
name|limit
argument_list|,
name|getOwner
argument_list|()
operator|.
name|getConf
argument_list|()
argument_list|)
decl_stmt|;
return|return
operator|new
name|DiskBlock
argument_list|(
name|destFile
argument_list|,
name|limit
argument_list|)
return|;
block|}
block|}
comment|/**    * Stream to a file.    * This will stop at the limit; the caller is expected to create a new block    */
DECL|class|DiskBlock
specifier|static
class|class
name|DiskBlock
extends|extends
name|DataBlock
block|{
DECL|field|bytesWritten
specifier|private
name|int
name|bytesWritten
decl_stmt|;
DECL|field|bufferFile
specifier|private
specifier|final
name|File
name|bufferFile
decl_stmt|;
DECL|field|limit
specifier|private
specifier|final
name|int
name|limit
decl_stmt|;
DECL|field|out
specifier|private
name|BufferedOutputStream
name|out
decl_stmt|;
DECL|field|uploadStream
specifier|private
name|InputStream
name|uploadStream
decl_stmt|;
DECL|method|DiskBlock (File bufferFile, int limit)
name|DiskBlock
parameter_list|(
name|File
name|bufferFile
parameter_list|,
name|int
name|limit
parameter_list|)
throws|throws
name|FileNotFoundException
block|{
name|this
operator|.
name|limit
operator|=
name|limit
expr_stmt|;
name|this
operator|.
name|bufferFile
operator|=
name|bufferFile
expr_stmt|;
name|out
operator|=
operator|new
name|BufferedOutputStream
argument_list|(
operator|new
name|FileOutputStream
argument_list|(
name|bufferFile
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|dataSize ()
name|int
name|dataSize
parameter_list|()
block|{
return|return
name|bytesWritten
return|;
block|}
annotation|@
name|Override
DECL|method|hasCapacity (long bytes)
name|boolean
name|hasCapacity
parameter_list|(
name|long
name|bytes
parameter_list|)
block|{
return|return
name|dataSize
argument_list|()
operator|+
name|bytes
operator|<=
name|limit
return|;
block|}
annotation|@
name|Override
DECL|method|remainingCapacity ()
name|int
name|remainingCapacity
parameter_list|()
block|{
return|return
name|limit
operator|-
name|bytesWritten
return|;
block|}
annotation|@
name|Override
DECL|method|write (byte[] b, int offset, int len)
name|int
name|write
parameter_list|(
name|byte
index|[]
name|b
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|len
parameter_list|)
throws|throws
name|IOException
block|{
name|super
operator|.
name|write
argument_list|(
name|b
argument_list|,
name|offset
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|int
name|written
init|=
name|Math
operator|.
name|min
argument_list|(
name|remainingCapacity
argument_list|()
argument_list|,
name|len
argument_list|)
decl_stmt|;
name|out
operator|.
name|write
argument_list|(
name|b
argument_list|,
name|offset
argument_list|,
name|written
argument_list|)
expr_stmt|;
name|bytesWritten
operator|+=
name|written
expr_stmt|;
return|return
name|written
return|;
block|}
annotation|@
name|Override
DECL|method|startUpload ()
name|InputStream
name|startUpload
parameter_list|()
throws|throws
name|IOException
block|{
name|super
operator|.
name|startUpload
argument_list|()
expr_stmt|;
try|try
block|{
name|out
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|out
operator|.
name|close
argument_list|()
expr_stmt|;
name|out
operator|=
literal|null
expr_stmt|;
block|}
name|uploadStream
operator|=
operator|new
name|FileInputStream
argument_list|(
name|bufferFile
argument_list|)
expr_stmt|;
return|return
operator|new
name|FileDeletingInputStream
argument_list|(
name|uploadStream
argument_list|)
return|;
block|}
comment|/**      * The close operation will delete the destination file if it still      * exists.      * @throws IOException IO problems      */
annotation|@
name|Override
DECL|method|innerClose ()
specifier|protected
name|void
name|innerClose
parameter_list|()
throws|throws
name|IOException
block|{
specifier|final
name|DestState
name|state
init|=
name|getState
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Closing {}"
argument_list|,
name|this
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|Writing
case|:
if|if
condition|(
name|bufferFile
operator|.
name|exists
argument_list|()
condition|)
block|{
comment|// file was not uploaded
name|LOG
operator|.
name|debug
argument_list|(
literal|"Deleting buffer file as upload did not start"
argument_list|)
expr_stmt|;
name|boolean
name|deleted
init|=
name|bufferFile
operator|.
name|delete
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|deleted
operator|&&
name|bufferFile
operator|.
name|exists
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to delete buffer file {}"
argument_list|,
name|bufferFile
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|Upload
case|:
name|LOG
operator|.
name|debug
argument_list|(
literal|"Buffer file {} exists âclose upload stream"
argument_list|,
name|bufferFile
argument_list|)
expr_stmt|;
break|break;
case|case
name|Closed
case|:
comment|// no-op
break|break;
default|default:
comment|// this state can never be reached, but checkstyle complains, so
comment|// it is here.
block|}
block|}
comment|/**      * Flush operation will flush to disk.      * @throws IOException IOE raised on FileOutputStream      */
annotation|@
name|Override
DECL|method|flush ()
name|void
name|flush
parameter_list|()
throws|throws
name|IOException
block|{
name|super
operator|.
name|flush
argument_list|()
expr_stmt|;
name|out
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|String
name|sb
init|=
literal|"FileBlock{"
operator|+
literal|"destFile="
operator|+
name|bufferFile
operator|+
literal|", state="
operator|+
name|getState
argument_list|()
operator|+
literal|", dataSize="
operator|+
name|dataSize
argument_list|()
operator|+
literal|", limit="
operator|+
name|limit
operator|+
literal|'}'
decl_stmt|;
return|return
name|sb
return|;
block|}
comment|/**      * An input stream which deletes the buffer file when closed.      */
DECL|class|FileDeletingInputStream
specifier|private
specifier|final
class|class
name|FileDeletingInputStream
extends|extends
name|FilterInputStream
block|{
DECL|field|closed
specifier|private
specifier|final
name|AtomicBoolean
name|closed
init|=
operator|new
name|AtomicBoolean
argument_list|(
literal|false
argument_list|)
decl_stmt|;
DECL|method|FileDeletingInputStream (InputStream source)
name|FileDeletingInputStream
parameter_list|(
name|InputStream
name|source
parameter_list|)
block|{
name|super
argument_list|(
name|source
argument_list|)
expr_stmt|;
block|}
comment|/**        * Delete the input file when closed.        * @throws IOException IO problem        */
annotation|@
name|Override
DECL|method|close ()
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
try|try
block|{
name|super
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|closed
operator|.
name|getAndSet
argument_list|(
literal|true
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|bufferFile
operator|.
name|delete
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"delete({}) returned false"
argument_list|,
name|bufferFile
operator|.
name|getAbsoluteFile
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
block|}
end_class

end_unit

