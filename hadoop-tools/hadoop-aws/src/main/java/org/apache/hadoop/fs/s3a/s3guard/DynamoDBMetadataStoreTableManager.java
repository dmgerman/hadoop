begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.fs.s3a.s3guard
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|s3guard
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileNotFoundException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InterruptedIOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Date
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Optional
import|;
end_import

begin_import
import|import
name|com
operator|.
name|amazonaws
operator|.
name|AmazonClientException
import|;
end_import

begin_import
import|import
name|com
operator|.
name|amazonaws
operator|.
name|SdkBaseException
import|;
end_import

begin_import
import|import
name|com
operator|.
name|amazonaws
operator|.
name|services
operator|.
name|dynamodbv2
operator|.
name|AmazonDynamoDB
import|;
end_import

begin_import
import|import
name|com
operator|.
name|amazonaws
operator|.
name|services
operator|.
name|dynamodbv2
operator|.
name|document
operator|.
name|DynamoDB
import|;
end_import

begin_import
import|import
name|com
operator|.
name|amazonaws
operator|.
name|services
operator|.
name|dynamodbv2
operator|.
name|document
operator|.
name|Item
import|;
end_import

begin_import
import|import
name|com
operator|.
name|amazonaws
operator|.
name|services
operator|.
name|dynamodbv2
operator|.
name|document
operator|.
name|PrimaryKey
import|;
end_import

begin_import
import|import
name|com
operator|.
name|amazonaws
operator|.
name|services
operator|.
name|dynamodbv2
operator|.
name|document
operator|.
name|PutItemOutcome
import|;
end_import

begin_import
import|import
name|com
operator|.
name|amazonaws
operator|.
name|services
operator|.
name|dynamodbv2
operator|.
name|document
operator|.
name|Table
import|;
end_import

begin_import
import|import
name|com
operator|.
name|amazonaws
operator|.
name|services
operator|.
name|dynamodbv2
operator|.
name|model
operator|.
name|AmazonDynamoDBException
import|;
end_import

begin_import
import|import
name|com
operator|.
name|amazonaws
operator|.
name|services
operator|.
name|dynamodbv2
operator|.
name|model
operator|.
name|BillingMode
import|;
end_import

begin_import
import|import
name|com
operator|.
name|amazonaws
operator|.
name|services
operator|.
name|dynamodbv2
operator|.
name|model
operator|.
name|CreateTableRequest
import|;
end_import

begin_import
import|import
name|com
operator|.
name|amazonaws
operator|.
name|services
operator|.
name|dynamodbv2
operator|.
name|model
operator|.
name|ListTagsOfResourceRequest
import|;
end_import

begin_import
import|import
name|com
operator|.
name|amazonaws
operator|.
name|services
operator|.
name|dynamodbv2
operator|.
name|model
operator|.
name|ProvisionedThroughput
import|;
end_import

begin_import
import|import
name|com
operator|.
name|amazonaws
operator|.
name|services
operator|.
name|dynamodbv2
operator|.
name|model
operator|.
name|ProvisionedThroughputDescription
import|;
end_import

begin_import
import|import
name|com
operator|.
name|amazonaws
operator|.
name|services
operator|.
name|dynamodbv2
operator|.
name|model
operator|.
name|ResourceInUseException
import|;
end_import

begin_import
import|import
name|com
operator|.
name|amazonaws
operator|.
name|services
operator|.
name|dynamodbv2
operator|.
name|model
operator|.
name|ResourceNotFoundException
import|;
end_import

begin_import
import|import
name|com
operator|.
name|amazonaws
operator|.
name|services
operator|.
name|dynamodbv2
operator|.
name|model
operator|.
name|ScanRequest
import|;
end_import

begin_import
import|import
name|com
operator|.
name|amazonaws
operator|.
name|services
operator|.
name|dynamodbv2
operator|.
name|model
operator|.
name|ScanResult
import|;
end_import

begin_import
import|import
name|com
operator|.
name|amazonaws
operator|.
name|services
operator|.
name|dynamodbv2
operator|.
name|model
operator|.
name|TableDescription
import|;
end_import

begin_import
import|import
name|com
operator|.
name|amazonaws
operator|.
name|services
operator|.
name|dynamodbv2
operator|.
name|model
operator|.
name|Tag
import|;
end_import

begin_import
import|import
name|com
operator|.
name|amazonaws
operator|.
name|services
operator|.
name|dynamodbv2
operator|.
name|model
operator|.
name|TagResourceRequest
import|;
end_import

begin_import
import|import
name|com
operator|.
name|amazonaws
operator|.
name|waiters
operator|.
name|WaiterTimedOutException
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|AWSClientIOException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|Invoker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|Retries
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|retry
operator|.
name|RetryPolicies
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|retry
operator|.
name|RetryPolicy
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|lang
operator|.
name|String
operator|.
name|valueOf
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|Constants
operator|.
name|S3GUARD_DDB_TABLE_CAPACITY_READ_DEFAULT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|Constants
operator|.
name|S3GUARD_DDB_TABLE_CAPACITY_READ_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|Constants
operator|.
name|S3GUARD_DDB_TABLE_CAPACITY_WRITE_DEFAULT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|Constants
operator|.
name|S3GUARD_DDB_TABLE_CAPACITY_WRITE_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|Constants
operator|.
name|S3GUARD_DDB_TABLE_CREATE_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|Constants
operator|.
name|S3GUARD_DDB_TABLE_TAG
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|S3AUtils
operator|.
name|translateException
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|s3guard
operator|.
name|DynamoDBMetadataStore
operator|.
name|E_ON_DEMAND_NO_SET_CAPACITY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|s3guard
operator|.
name|DynamoDBMetadataStore
operator|.
name|VERSION
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|s3guard
operator|.
name|DynamoDBMetadataStore
operator|.
name|VERSION_MARKER_ITEM_NAME
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|s3guard
operator|.
name|DynamoDBMetadataStore
operator|.
name|VERSION_MARKER_TAG_NAME
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|s3guard
operator|.
name|PathMetadataDynamoDBTranslation
operator|.
name|attributeDefinitions
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|s3guard
operator|.
name|PathMetadataDynamoDBTranslation
operator|.
name|createVersionMarker
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|s3guard
operator|.
name|PathMetadataDynamoDBTranslation
operator|.
name|createVersionMarkerPrimaryKey
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|s3guard
operator|.
name|PathMetadataDynamoDBTranslation
operator|.
name|extractCreationTimeFromMarker
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|s3guard
operator|.
name|PathMetadataDynamoDBTranslation
operator|.
name|extractVersionFromMarker
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3a
operator|.
name|s3guard
operator|.
name|PathMetadataDynamoDBTranslation
operator|.
name|keySchema
import|;
end_import

begin_comment
comment|/**  * Managing dynamo tables for S3Guard dynamodb based metadatastore.  * Factored out from DynamoDBMetadataStore.  */
end_comment

begin_class
DECL|class|DynamoDBMetadataStoreTableManager
specifier|public
class|class
name|DynamoDBMetadataStoreTableManager
block|{
DECL|field|LOG
specifier|public
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|DynamoDBMetadataStoreTableManager
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/** Error: version marker not found in table but the table is not empty. */
DECL|field|E_NO_VERSION_MARKER_AND_NOT_EMPTY
specifier|public
specifier|static
specifier|final
name|String
name|E_NO_VERSION_MARKER_AND_NOT_EMPTY
init|=
literal|"S3Guard table lacks version marker, and it is not empty."
decl_stmt|;
comment|/** Error: version mismatch. */
DECL|field|E_INCOMPATIBLE_TAG_VERSION
specifier|public
specifier|static
specifier|final
name|String
name|E_INCOMPATIBLE_TAG_VERSION
init|=
literal|"Database table is from an incompatible S3Guard version based on table TAG."
decl_stmt|;
comment|/** Error: version mismatch. */
DECL|field|E_INCOMPATIBLE_ITEM_VERSION
specifier|public
specifier|static
specifier|final
name|String
name|E_INCOMPATIBLE_ITEM_VERSION
init|=
literal|"Database table is from an incompatible S3Guard version based on table ITEM."
decl_stmt|;
comment|/** Invoker for IO. Until configured properly, use try-once. */
DECL|field|invoker
specifier|private
name|Invoker
name|invoker
init|=
operator|new
name|Invoker
argument_list|(
name|RetryPolicies
operator|.
name|TRY_ONCE_THEN_FAIL
argument_list|,
name|Invoker
operator|.
name|NO_OP
argument_list|)
decl_stmt|;
DECL|field|amazonDynamoDB
specifier|final
specifier|private
name|AmazonDynamoDB
name|amazonDynamoDB
decl_stmt|;
DECL|field|dynamoDB
specifier|final
specifier|private
name|DynamoDB
name|dynamoDB
decl_stmt|;
DECL|field|tableName
specifier|final
specifier|private
name|String
name|tableName
decl_stmt|;
DECL|field|region
specifier|final
specifier|private
name|String
name|region
decl_stmt|;
DECL|field|conf
specifier|final
specifier|private
name|Configuration
name|conf
decl_stmt|;
DECL|field|readOp
specifier|final
specifier|private
name|Invoker
name|readOp
decl_stmt|;
DECL|field|batchWriteRetryPolicy
specifier|final
specifier|private
name|RetryPolicy
name|batchWriteRetryPolicy
decl_stmt|;
DECL|field|table
specifier|private
name|Table
name|table
decl_stmt|;
DECL|field|tableArn
specifier|private
name|String
name|tableArn
decl_stmt|;
DECL|method|DynamoDBMetadataStoreTableManager (DynamoDB dynamoDB, String tableName, String region, AmazonDynamoDB amazonDynamoDB, Configuration conf, Invoker readOp, RetryPolicy batchWriteCapacityExceededEvents)
specifier|public
name|DynamoDBMetadataStoreTableManager
parameter_list|(
name|DynamoDB
name|dynamoDB
parameter_list|,
name|String
name|tableName
parameter_list|,
name|String
name|region
parameter_list|,
name|AmazonDynamoDB
name|amazonDynamoDB
parameter_list|,
name|Configuration
name|conf
parameter_list|,
name|Invoker
name|readOp
parameter_list|,
name|RetryPolicy
name|batchWriteCapacityExceededEvents
parameter_list|)
block|{
name|this
operator|.
name|dynamoDB
operator|=
name|dynamoDB
expr_stmt|;
name|this
operator|.
name|amazonDynamoDB
operator|=
name|amazonDynamoDB
expr_stmt|;
name|this
operator|.
name|tableName
operator|=
name|tableName
expr_stmt|;
name|this
operator|.
name|region
operator|=
name|region
expr_stmt|;
name|this
operator|.
name|conf
operator|=
name|conf
expr_stmt|;
name|this
operator|.
name|readOp
operator|=
name|readOp
expr_stmt|;
name|this
operator|.
name|batchWriteRetryPolicy
operator|=
name|batchWriteCapacityExceededEvents
expr_stmt|;
block|}
comment|/**    * Create a table if it does not exist and wait for it to become active.    *    * If a table with the intended name already exists, then it uses that table.    * Otherwise, it will automatically create the table if the config    * {@link org.apache.hadoop.fs.s3a.Constants#S3GUARD_DDB_TABLE_CREATE_KEY} is    * enabled. The DynamoDB table creation API is asynchronous.  This method wait    * for the table to become active after sending the creation request, so    * overall, this method is synchronous, and the table is guaranteed to exist    * after this method returns successfully.    *    * The wait for a table becoming active is Retry+Translated; it can fail    * while a table is not yet ready.    *    * @throws IOException if table does not exist and auto-creation is disabled;    * or table is being deleted, or any other I/O exception occurred.    */
annotation|@
name|VisibleForTesting
annotation|@
name|Retries
operator|.
name|RetryTranslated
DECL|method|initTable ()
name|Table
name|initTable
parameter_list|()
throws|throws
name|IOException
block|{
name|table
operator|=
name|dynamoDB
operator|.
name|getTable
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
try|try
block|{
try|try
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Binding to table {}"
argument_list|,
name|tableName
argument_list|)
expr_stmt|;
name|TableDescription
name|description
init|=
name|table
operator|.
name|describe
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Table state: {}"
argument_list|,
name|description
argument_list|)
expr_stmt|;
name|tableArn
operator|=
name|description
operator|.
name|getTableArn
argument_list|()
expr_stmt|;
specifier|final
name|String
name|status
init|=
name|description
operator|.
name|getTableStatus
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|status
condition|)
block|{
case|case
literal|"CREATING"
case|:
name|LOG
operator|.
name|debug
argument_list|(
literal|"Table {} in region {} is being created/updated. This may"
operator|+
literal|" indicate that the table is being operated by another "
operator|+
literal|"concurrent thread or process. Waiting for active..."
argument_list|,
name|tableName
argument_list|,
name|region
argument_list|)
expr_stmt|;
name|waitForTableActive
argument_list|(
name|table
argument_list|)
expr_stmt|;
break|break;
case|case
literal|"DELETING"
case|:
throw|throw
operator|new
name|FileNotFoundException
argument_list|(
literal|"DynamoDB table "
operator|+
literal|"'"
operator|+
name|tableName
operator|+
literal|"' is being "
operator|+
literal|"deleted in region "
operator|+
name|region
argument_list|)
throw|;
case|case
literal|"UPDATING"
case|:
comment|// table being updated; it can still be used.
name|LOG
operator|.
name|debug
argument_list|(
literal|"Table is being updated."
argument_list|)
expr_stmt|;
break|break;
case|case
literal|"ACTIVE"
case|:
break|break;
default|default:
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unknown DynamoDB table status "
operator|+
name|status
operator|+
literal|": tableName='"
operator|+
name|tableName
operator|+
literal|"', region="
operator|+
name|region
argument_list|)
throw|;
block|}
name|verifyVersionCompatibility
argument_list|()
expr_stmt|;
specifier|final
name|Item
name|versionMarker
init|=
name|getVersionMarkerItem
argument_list|()
decl_stmt|;
name|Long
name|created
init|=
name|extractCreationTimeFromMarker
argument_list|(
name|versionMarker
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Using existing DynamoDB table {} in region {} created {}"
argument_list|,
name|tableName
argument_list|,
name|region
argument_list|,
operator|(
name|created
operator|!=
literal|null
operator|)
condition|?
operator|new
name|Date
argument_list|(
name|created
argument_list|)
else|:
literal|null
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ResourceNotFoundException
name|rnfe
parameter_list|)
block|{
if|if
condition|(
name|conf
operator|.
name|getBoolean
argument_list|(
name|S3GUARD_DDB_TABLE_CREATE_KEY
argument_list|,
literal|false
argument_list|)
condition|)
block|{
name|long
name|readCapacity
init|=
name|conf
operator|.
name|getLong
argument_list|(
name|S3GUARD_DDB_TABLE_CAPACITY_READ_KEY
argument_list|,
name|S3GUARD_DDB_TABLE_CAPACITY_READ_DEFAULT
argument_list|)
decl_stmt|;
name|long
name|writeCapacity
init|=
name|conf
operator|.
name|getLong
argument_list|(
name|S3GUARD_DDB_TABLE_CAPACITY_WRITE_KEY
argument_list|,
name|S3GUARD_DDB_TABLE_CAPACITY_WRITE_DEFAULT
argument_list|)
decl_stmt|;
name|ProvisionedThroughput
name|capacity
decl_stmt|;
if|if
condition|(
name|readCapacity
operator|>
literal|0
operator|&&
name|writeCapacity
operator|>
literal|0
condition|)
block|{
name|capacity
operator|=
operator|new
name|ProvisionedThroughput
argument_list|(
name|readCapacity
argument_list|,
name|writeCapacity
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// at least one capacity value is<= 0
comment|// verify they are both exactly zero
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|readCapacity
operator|==
literal|0
operator|&&
name|writeCapacity
operator|==
literal|0
argument_list|,
literal|"S3Guard table read capacity %d and and write capacity %d"
operator|+
literal|" are inconsistent"
argument_list|,
name|readCapacity
argument_list|,
name|writeCapacity
argument_list|)
expr_stmt|;
comment|// and set the capacity to null for per-request billing.
name|capacity
operator|=
literal|null
expr_stmt|;
block|}
name|createTable
argument_list|(
name|capacity
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|(
name|FileNotFoundException
operator|)
operator|new
name|FileNotFoundException
argument_list|(
literal|"DynamoDB table '"
operator|+
name|tableName
operator|+
literal|"' does not "
operator|+
literal|"exist in region "
operator|+
name|region
operator|+
literal|"; auto-creation is turned off"
argument_list|)
operator|.
name|initCause
argument_list|(
name|rnfe
argument_list|)
throw|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|AmazonClientException
name|e
parameter_list|)
block|{
throw|throw
name|translateException
argument_list|(
literal|"initTable"
argument_list|,
name|tableName
argument_list|,
name|e
argument_list|)
throw|;
block|}
return|return
name|table
return|;
block|}
DECL|method|tagTableWithVersionMarker ()
specifier|protected
name|void
name|tagTableWithVersionMarker
parameter_list|()
block|{
try|try
block|{
name|TagResourceRequest
name|tagResourceRequest
init|=
operator|new
name|TagResourceRequest
argument_list|()
operator|.
name|withResourceArn
argument_list|(
name|table
operator|.
name|getDescription
argument_list|()
operator|.
name|getTableArn
argument_list|()
argument_list|)
operator|.
name|withTags
argument_list|(
name|newVersionMarkerTag
argument_list|()
argument_list|)
decl_stmt|;
name|amazonDynamoDB
operator|.
name|tagResource
argument_list|(
name|tagResourceRequest
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|AmazonDynamoDBException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Exception during tagging table: {}"
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|getVersionMarkerFromTags (Table table, AmazonDynamoDB addb)
specifier|protected
specifier|static
name|Item
name|getVersionMarkerFromTags
parameter_list|(
name|Table
name|table
parameter_list|,
name|AmazonDynamoDB
name|addb
parameter_list|)
block|{
name|List
argument_list|<
name|Tag
argument_list|>
name|tags
init|=
literal|null
decl_stmt|;
try|try
block|{
specifier|final
name|TableDescription
name|description
init|=
name|table
operator|.
name|describe
argument_list|()
decl_stmt|;
name|ListTagsOfResourceRequest
name|listTagsOfResourceRequest
init|=
operator|new
name|ListTagsOfResourceRequest
argument_list|()
operator|.
name|withResourceArn
argument_list|(
name|description
operator|.
name|getTableArn
argument_list|()
argument_list|)
decl_stmt|;
name|tags
operator|=
name|addb
operator|.
name|listTagsOfResource
argument_list|(
name|listTagsOfResourceRequest
argument_list|)
operator|.
name|getTags
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ResourceNotFoundException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Table: {} not found."
argument_list|,
name|table
operator|.
name|getTableName
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
catch|catch
parameter_list|(
name|AmazonDynamoDBException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Exception while getting tags from the dynamo table: {}"
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tags
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
specifier|final
name|Optional
argument_list|<
name|Tag
argument_list|>
name|first
init|=
name|tags
operator|.
name|stream
argument_list|()
operator|.
name|filter
argument_list|(
name|tag
lambda|->
name|tag
operator|.
name|getKey
argument_list|()
operator|.
name|equals
argument_list|(
name|VERSION_MARKER_TAG_NAME
argument_list|)
argument_list|)
operator|.
name|findFirst
argument_list|()
decl_stmt|;
if|if
condition|(
name|first
operator|.
name|isPresent
argument_list|()
condition|)
block|{
specifier|final
name|Tag
name|vmTag
init|=
name|first
operator|.
name|get
argument_list|()
decl_stmt|;
return|return
name|createVersionMarker
argument_list|(
name|vmTag
operator|.
name|getKey
argument_list|()
argument_list|,
name|Integer
operator|.
name|parseInt
argument_list|(
name|vmTag
operator|.
name|getValue
argument_list|()
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
comment|/**    * Create a table, wait for it to become active, then add the version    * marker.    * Creating an setting up the table isn't wrapped by any retry operations;    * the wait for a table to become available is RetryTranslated.    * The tags are added to the table during creation, not after creation.    * We can assume that tagging and creating the table is a single atomic    * operation.    *    * @param capacity capacity to provision. If null: create a per-request    * table.    * @throws IOException on any failure.    * @throws InterruptedIOException if the wait was interrupted    */
annotation|@
name|Retries
operator|.
name|OnceMixed
DECL|method|createTable (ProvisionedThroughput capacity)
specifier|private
name|void
name|createTable
parameter_list|(
name|ProvisionedThroughput
name|capacity
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
name|String
name|mode
decl_stmt|;
name|CreateTableRequest
name|request
init|=
operator|new
name|CreateTableRequest
argument_list|()
operator|.
name|withTableName
argument_list|(
name|tableName
argument_list|)
operator|.
name|withKeySchema
argument_list|(
name|keySchema
argument_list|()
argument_list|)
operator|.
name|withAttributeDefinitions
argument_list|(
name|attributeDefinitions
argument_list|()
argument_list|)
operator|.
name|withTags
argument_list|(
name|getTableTagsFromConfig
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|capacity
operator|!=
literal|null
condition|)
block|{
name|mode
operator|=
name|String
operator|.
name|format
argument_list|(
literal|"with provisioned read capacity %d and"
operator|+
literal|" write capacity %s"
argument_list|,
name|capacity
operator|.
name|getReadCapacityUnits
argument_list|()
argument_list|,
name|capacity
operator|.
name|getWriteCapacityUnits
argument_list|()
argument_list|)
expr_stmt|;
name|request
operator|.
name|withProvisionedThroughput
argument_list|(
name|capacity
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mode
operator|=
literal|"with pay-per-request billing"
expr_stmt|;
name|request
operator|.
name|withBillingMode
argument_list|(
name|BillingMode
operator|.
name|PAY_PER_REQUEST
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Creating non-existent DynamoDB table {} in region {} {}"
argument_list|,
name|tableName
argument_list|,
name|region
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|table
operator|=
name|dynamoDB
operator|.
name|createTable
argument_list|(
name|request
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Awaiting table becoming active"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ResourceInUseException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"ResourceInUseException while creating DynamoDB table {} "
operator|+
literal|"in region {}.  This may indicate that the table was "
operator|+
literal|"created by another concurrent thread or process."
argument_list|,
name|tableName
argument_list|,
name|region
argument_list|)
expr_stmt|;
block|}
name|waitForTableActive
argument_list|(
name|table
argument_list|)
expr_stmt|;
name|putVersionMarkerItemToTable
argument_list|()
expr_stmt|;
block|}
comment|/**    *  Return tags from configuration and the version marker for adding to    *  dynamo table during creation.    */
annotation|@
name|Retries
operator|.
name|OnceRaw
DECL|method|getTableTagsFromConfig ()
specifier|public
name|List
argument_list|<
name|Tag
argument_list|>
name|getTableTagsFromConfig
parameter_list|()
block|{
name|List
argument_list|<
name|Tag
argument_list|>
name|tags
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
comment|// from configuration
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|tagProperties
init|=
name|conf
operator|.
name|getPropsWithPrefix
argument_list|(
name|S3GUARD_DDB_TABLE_TAG
argument_list|)
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|tagMapEntry
range|:
name|tagProperties
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|Tag
name|tag
init|=
operator|new
name|Tag
argument_list|()
operator|.
name|withKey
argument_list|(
name|tagMapEntry
operator|.
name|getKey
argument_list|()
argument_list|)
operator|.
name|withValue
argument_list|(
name|tagMapEntry
operator|.
name|getValue
argument_list|()
argument_list|)
decl_stmt|;
name|tags
operator|.
name|add
argument_list|(
name|tag
argument_list|)
expr_stmt|;
block|}
comment|// add the version marker
name|tags
operator|.
name|add
argument_list|(
name|newVersionMarkerTag
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|tags
return|;
block|}
comment|/**    * Create a new version marker tag.    * @return a new version marker tag    */
DECL|method|newVersionMarkerTag ()
specifier|private
specifier|static
name|Tag
name|newVersionMarkerTag
parameter_list|()
block|{
return|return
operator|new
name|Tag
argument_list|()
operator|.
name|withKey
argument_list|(
name|VERSION_MARKER_TAG_NAME
argument_list|)
operator|.
name|withValue
argument_list|(
name|valueOf
argument_list|(
name|VERSION
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Verify that a table version is compatible with this S3Guard client.    *    * Checks for consistency between the version marker as the item and tag.    *    *<pre>    *   1. If the table lacks both version markers AND it's empty,    *      both markers will be added.    *      If the table is not empty the check throws IOException    *   2. If there's no version marker ITEM, the compatibility with the TAG    *      will be checked, and the version marker ITEM will be added if the    *      TAG version is compatible.    *      If the TAG version is not compatible, the check throws OException    *   3. If there's no version marker TAG, the compatibility with the ITEM    *      version marker will be checked, and the version marker ITEM will be    *      added if the ITEM version is compatible.    *      If the ITEM version is not compatible, the check throws IOException    *   4. If the TAG and ITEM versions are both present then both will be checked    *      for compatibility. If the ITEM or TAG version marker is not compatible,    *      the check throws IOException    *</pre>    *    * @throws IOException on any incompatibility    */
annotation|@
name|VisibleForTesting
DECL|method|verifyVersionCompatibility ()
specifier|protected
name|void
name|verifyVersionCompatibility
parameter_list|()
throws|throws
name|IOException
block|{
specifier|final
name|Item
name|versionMarkerItem
init|=
name|getVersionMarkerItem
argument_list|()
decl_stmt|;
specifier|final
name|Item
name|versionMarkerFromTag
init|=
name|getVersionMarkerFromTags
argument_list|(
name|table
argument_list|,
name|amazonDynamoDB
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"versionMarkerItem: {};  versionMarkerFromTag: {}"
argument_list|,
name|versionMarkerItem
argument_list|,
name|versionMarkerFromTag
argument_list|)
expr_stmt|;
if|if
condition|(
name|versionMarkerItem
operator|==
literal|null
operator|&&
name|versionMarkerFromTag
operator|==
literal|null
condition|)
block|{
if|if
condition|(
operator|!
name|isEmptyTable
argument_list|(
name|tableName
argument_list|,
name|amazonDynamoDB
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Table is not empty but missing the version maker. Failing."
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
name|E_NO_VERSION_MARKER_AND_NOT_EMPTY
operator|+
literal|" Table: "
operator|+
name|tableName
argument_list|)
throw|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Table {} contains no version marker item or tag. "
operator|+
literal|"The table is empty, so the version marker will be added "
operator|+
literal|"as TAG and ITEM."
argument_list|,
name|tableName
argument_list|)
expr_stmt|;
name|tagTableWithVersionMarker
argument_list|()
expr_stmt|;
name|putVersionMarkerItemToTable
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|versionMarkerItem
operator|==
literal|null
operator|&&
name|versionMarkerFromTag
operator|!=
literal|null
condition|)
block|{
specifier|final
name|int
name|tagVersionMarker
init|=
name|extractVersionFromMarker
argument_list|(
name|versionMarkerFromTag
argument_list|)
decl_stmt|;
name|throwExceptionOnVersionMismatch
argument_list|(
name|tagVersionMarker
argument_list|,
name|tableName
argument_list|,
name|E_INCOMPATIBLE_TAG_VERSION
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Table {} contains no version marker ITEM but contains "
operator|+
literal|"compatible version marker TAG. Restoring the version marker "
operator|+
literal|"item from tag."
argument_list|,
name|tableName
argument_list|)
expr_stmt|;
name|putVersionMarkerItemToTable
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|versionMarkerItem
operator|!=
literal|null
operator|&&
name|versionMarkerFromTag
operator|==
literal|null
condition|)
block|{
specifier|final
name|int
name|itemVersionMarker
init|=
name|extractVersionFromMarker
argument_list|(
name|versionMarkerItem
argument_list|)
decl_stmt|;
name|throwExceptionOnVersionMismatch
argument_list|(
name|itemVersionMarker
argument_list|,
name|tableName
argument_list|,
name|E_INCOMPATIBLE_ITEM_VERSION
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Table {} contains no version marker TAG but contains "
operator|+
literal|"compatible version marker ITEM. Restoring the version marker "
operator|+
literal|"item from item."
argument_list|,
name|tableName
argument_list|)
expr_stmt|;
name|tagTableWithVersionMarker
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|versionMarkerItem
operator|!=
literal|null
operator|&&
name|versionMarkerFromTag
operator|!=
literal|null
condition|)
block|{
specifier|final
name|int
name|tagVersionMarker
init|=
name|extractVersionFromMarker
argument_list|(
name|versionMarkerFromTag
argument_list|)
decl_stmt|;
specifier|final
name|int
name|itemVersionMarker
init|=
name|extractVersionFromMarker
argument_list|(
name|versionMarkerItem
argument_list|)
decl_stmt|;
name|throwExceptionOnVersionMismatch
argument_list|(
name|tagVersionMarker
argument_list|,
name|tableName
argument_list|,
name|E_INCOMPATIBLE_TAG_VERSION
argument_list|)
expr_stmt|;
name|throwExceptionOnVersionMismatch
argument_list|(
name|itemVersionMarker
argument_list|,
name|tableName
argument_list|,
name|E_INCOMPATIBLE_ITEM_VERSION
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Table {} contains correct version marker TAG and ITEM."
argument_list|,
name|tableName
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|isEmptyTable (String tableName, AmazonDynamoDB aadb)
specifier|private
specifier|static
name|boolean
name|isEmptyTable
parameter_list|(
name|String
name|tableName
parameter_list|,
name|AmazonDynamoDB
name|aadb
parameter_list|)
block|{
specifier|final
name|ScanRequest
name|req
init|=
operator|new
name|ScanRequest
argument_list|()
operator|.
name|withTableName
argument_list|(
name|tableName
argument_list|)
operator|.
name|withLimit
argument_list|(
literal|1
argument_list|)
decl_stmt|;
specifier|final
name|ScanResult
name|result
init|=
name|aadb
operator|.
name|scan
argument_list|(
name|req
argument_list|)
decl_stmt|;
return|return
name|result
operator|.
name|getCount
argument_list|()
operator|==
literal|0
return|;
block|}
DECL|method|throwExceptionOnVersionMismatch (int actual, String tableName, String exMsg)
specifier|private
specifier|static
name|void
name|throwExceptionOnVersionMismatch
parameter_list|(
name|int
name|actual
parameter_list|,
name|String
name|tableName
parameter_list|,
name|String
name|exMsg
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|VERSION
operator|!=
name|actual
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|exMsg
operator|+
literal|" Table "
operator|+
name|tableName
operator|+
literal|" Expected version: "
operator|+
name|VERSION
operator|+
literal|" actual tag version: "
operator|+
name|actual
argument_list|)
throw|;
block|}
block|}
comment|/**    * Add version marker to the dynamo table.    */
annotation|@
name|Retries
operator|.
name|OnceRaw
DECL|method|putVersionMarkerItemToTable ()
specifier|private
name|void
name|putVersionMarkerItemToTable
parameter_list|()
block|{
specifier|final
name|Item
name|marker
init|=
name|createVersionMarker
argument_list|(
name|VERSION_MARKER_ITEM_NAME
argument_list|,
name|VERSION
argument_list|,
name|System
operator|.
name|currentTimeMillis
argument_list|()
argument_list|)
decl_stmt|;
name|putItem
argument_list|(
name|marker
argument_list|)
expr_stmt|;
block|}
comment|/**    * Wait for table being active.    * @param t table to block on.    * @throws IOException IO problems    * @throws InterruptedIOException if the wait was interrupted    * @throws IllegalArgumentException if an exception was raised in the waiter    */
annotation|@
name|Retries
operator|.
name|RetryTranslated
DECL|method|waitForTableActive (Table t)
specifier|private
name|void
name|waitForTableActive
parameter_list|(
name|Table
name|t
parameter_list|)
throws|throws
name|IOException
block|{
name|invoker
operator|.
name|retry
argument_list|(
literal|"Waiting for active state of table "
operator|+
name|tableName
argument_list|,
literal|null
argument_list|,
literal|true
argument_list|,
parameter_list|()
lambda|->
block|{
try|try
block|{
name|t
operator|.
name|waitForActive
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|ex
parameter_list|)
block|{
throw|throw
name|translateTableWaitFailure
argument_list|(
name|tableName
argument_list|,
name|ex
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Interrupted while waiting for table {} in region {}"
operator|+
literal|" active"
argument_list|,
name|tableName
argument_list|,
name|region
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
throw|throw
operator|(
name|InterruptedIOException
operator|)
operator|new
name|InterruptedIOException
argument_list|(
literal|"DynamoDB table '"
operator|+
name|tableName
operator|+
literal|"' is not active yet in region "
operator|+
name|region
argument_list|)
operator|.
name|initCause
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
comment|/**    * Handle a table wait failure by extracting any inner cause and    * converting it, or, if unconvertable by wrapping    * the IllegalArgumentException in an IOE.    *    * @param name name of the table    * @param e exception    * @return an IOE to raise.    */
annotation|@
name|VisibleForTesting
DECL|method|translateTableWaitFailure ( final String name, IllegalArgumentException e)
specifier|static
name|IOException
name|translateTableWaitFailure
parameter_list|(
specifier|final
name|String
name|name
parameter_list|,
name|IllegalArgumentException
name|e
parameter_list|)
block|{
specifier|final
name|SdkBaseException
name|ex
init|=
name|extractInnerException
argument_list|(
name|e
argument_list|)
decl_stmt|;
if|if
condition|(
name|ex
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|ex
operator|instanceof
name|WaiterTimedOutException
condition|)
block|{
comment|// a timeout waiting for state change: extract the
comment|// message from the outer exception, but translate
comment|// the inner one for the throttle policy.
return|return
operator|new
name|AWSClientIOException
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|ex
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|translateException
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|name
argument_list|,
name|ex
argument_list|)
return|;
block|}
block|}
else|else
block|{
return|return
operator|new
name|IOException
argument_list|(
name|e
argument_list|)
return|;
block|}
block|}
comment|/**    * Take an {@code IllegalArgumentException} raised by a DDB operation    * and if it contains an inner SDK exception, unwrap it.    * @param ex exception.    * @return the inner AWS exception or null.    */
DECL|method|extractInnerException ( IllegalArgumentException ex)
specifier|public
specifier|static
name|SdkBaseException
name|extractInnerException
parameter_list|(
name|IllegalArgumentException
name|ex
parameter_list|)
block|{
if|if
condition|(
name|ex
operator|.
name|getCause
argument_list|()
operator|instanceof
name|SdkBaseException
condition|)
block|{
return|return
operator|(
name|SdkBaseException
operator|)
name|ex
operator|.
name|getCause
argument_list|()
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
comment|/**    * Get the version mark item in the existing DynamoDB table.    *    * As the version marker item may be created by another concurrent thread or    * process, we sleep and retry a limited number times if the lookup returns    * with a null value.    * DDB throttling is always retried.    */
annotation|@
name|VisibleForTesting
annotation|@
name|Retries
operator|.
name|RetryTranslated
DECL|method|getVersionMarkerItem ()
specifier|protected
name|Item
name|getVersionMarkerItem
parameter_list|()
throws|throws
name|IOException
block|{
specifier|final
name|PrimaryKey
name|versionMarkerKey
init|=
name|createVersionMarkerPrimaryKey
argument_list|(
name|VERSION_MARKER_ITEM_NAME
argument_list|)
decl_stmt|;
name|int
name|retryCount
init|=
literal|0
decl_stmt|;
comment|// look for a version marker, with usual throttling/failure retries.
name|Item
name|versionMarker
init|=
name|queryVersionMarker
argument_list|(
name|versionMarkerKey
argument_list|)
decl_stmt|;
while|while
condition|(
name|versionMarker
operator|==
literal|null
condition|)
block|{
comment|// The marker was null.
comment|// Two possibilities
comment|// 1. This isn't a S3Guard table.
comment|// 2. This is a S3Guard table in construction; another thread/process
comment|//    is about to write/actively writing the version marker.
comment|// So that state #2 is handled, batchWriteRetryPolicy is used to manage
comment|// retries.
comment|// This will mean that if the cause is actually #1, failure will not
comment|// be immediate. As this will ultimately result in a failure to
comment|// init S3Guard and the S3A FS, this isn't going to be a performance
comment|// bottleneck -simply a slightly slower failure report than would otherwise
comment|// be seen.
comment|// "if your settings are broken, performance is not your main issue"
try|try
block|{
name|RetryPolicy
operator|.
name|RetryAction
name|action
init|=
name|batchWriteRetryPolicy
operator|.
name|shouldRetry
argument_list|(
literal|null
argument_list|,
name|retryCount
argument_list|,
literal|0
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|action
operator|.
name|action
operator|==
name|RetryPolicy
operator|.
name|RetryAction
operator|.
name|RetryDecision
operator|.
name|FAIL
condition|)
block|{
break|break;
block|}
else|else
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"No version marker found in the DynamoDB table: {}. "
operator|+
literal|"Sleeping {} ms before next retry"
argument_list|,
name|tableName
argument_list|,
name|action
operator|.
name|delayMillis
argument_list|)
expr_stmt|;
name|Thread
operator|.
name|sleep
argument_list|(
name|action
operator|.
name|delayMillis
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"initTable: Unexpected exception "
operator|+
name|e
argument_list|,
name|e
argument_list|)
throw|;
block|}
name|retryCount
operator|++
expr_stmt|;
name|versionMarker
operator|=
name|queryVersionMarker
argument_list|(
name|versionMarkerKey
argument_list|)
expr_stmt|;
block|}
return|return
name|versionMarker
return|;
block|}
comment|/**    * Issue the query to get the version marker, with throttling for overloaded    * DDB tables.    * @param versionMarkerKey key to look up    * @return the marker    * @throws IOException failure    */
annotation|@
name|Retries
operator|.
name|RetryTranslated
DECL|method|queryVersionMarker (final PrimaryKey versionMarkerKey)
specifier|private
name|Item
name|queryVersionMarker
parameter_list|(
specifier|final
name|PrimaryKey
name|versionMarkerKey
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|readOp
operator|.
name|retry
argument_list|(
literal|"getVersionMarkerItem"
argument_list|,
name|VERSION_MARKER_ITEM_NAME
argument_list|,
literal|true
argument_list|,
parameter_list|()
lambda|->
name|table
operator|.
name|getItem
argument_list|(
name|versionMarkerKey
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * PUT a single item to the table.    * @param item item to put    * @return the outcome.    */
annotation|@
name|Retries
operator|.
name|OnceRaw
DECL|method|putItem (Item item)
specifier|private
name|PutItemOutcome
name|putItem
parameter_list|(
name|Item
name|item
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Putting item {}"
argument_list|,
name|item
argument_list|)
expr_stmt|;
return|return
name|table
operator|.
name|putItem
argument_list|(
name|item
argument_list|)
return|;
block|}
comment|/**    * Provision the table with given read and write capacity units.    * Call will fail if the table is busy, or the new values match the current    * ones.    *<p>    * Until the AWS SDK lets us switch a table to on-demand, an attempt to    * set the I/O capacity to zero will fail.    * @param readCapacity read units: must be greater than zero    * @param writeCapacity write units: must be greater than zero    * @throws IOException on a failure    */
annotation|@
name|Retries
operator|.
name|RetryTranslated
DECL|method|provisionTable (Long readCapacity, Long writeCapacity)
name|void
name|provisionTable
parameter_list|(
name|Long
name|readCapacity
parameter_list|,
name|Long
name|writeCapacity
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|readCapacity
operator|==
literal|0
operator|||
name|writeCapacity
operator|==
literal|0
condition|)
block|{
comment|// table is pay on demand
throw|throw
operator|new
name|IOException
argument_list|(
name|E_ON_DEMAND_NO_SET_CAPACITY
argument_list|)
throw|;
block|}
specifier|final
name|ProvisionedThroughput
name|toProvision
init|=
operator|new
name|ProvisionedThroughput
argument_list|()
operator|.
name|withReadCapacityUnits
argument_list|(
name|readCapacity
argument_list|)
operator|.
name|withWriteCapacityUnits
argument_list|(
name|writeCapacity
argument_list|)
decl_stmt|;
name|invoker
operator|.
name|retry
argument_list|(
literal|"ProvisionTable"
argument_list|,
name|tableName
argument_list|,
literal|true
argument_list|,
parameter_list|()
lambda|->
block|{
specifier|final
name|ProvisionedThroughputDescription
name|p
init|=
name|table
operator|.
name|updateTable
argument_list|(
name|toProvision
argument_list|)
operator|.
name|getProvisionedThroughput
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Provision table {} in region {}: readCapacityUnits={}, "
operator|+
literal|"writeCapacityUnits={}"
argument_list|,
name|tableName
argument_list|,
name|region
argument_list|,
name|p
operator|.
name|getReadCapacityUnits
argument_list|()
argument_list|,
name|p
operator|.
name|getWriteCapacityUnits
argument_list|()
argument_list|)
expr_stmt|;
block|}
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Retries
operator|.
name|RetryTranslated
DECL|method|destroy ()
specifier|public
name|void
name|destroy
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|table
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"In destroy(): no table to delete"
argument_list|)
expr_stmt|;
return|return;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Deleting DynamoDB table {} in region {}"
argument_list|,
name|tableName
argument_list|,
name|region
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|dynamoDB
argument_list|,
literal|"Not connected to DynamoDB"
argument_list|)
expr_stmt|;
try|try
block|{
name|invoker
operator|.
name|retry
argument_list|(
literal|"delete"
argument_list|,
literal|null
argument_list|,
literal|true
argument_list|,
parameter_list|()
lambda|->
name|table
operator|.
name|delete
argument_list|()
argument_list|)
expr_stmt|;
name|table
operator|.
name|waitForDelete
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|TableDeleteTimeoutException
argument_list|(
name|tableName
argument_list|,
literal|"Timeout waiting for the table "
operator|+
name|getTableArn
argument_list|()
operator|+
literal|" to be deleted"
argument_list|,
name|ex
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|rnfe
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"FileNotFoundException while deleting DynamoDB table {} in "
operator|+
literal|"region {}.  This may indicate that the table does not exist, "
operator|+
literal|"or has been deleted by another concurrent thread or process."
argument_list|,
name|tableName
argument_list|,
name|region
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
literal|"Interrupted while waiting for DynamoDB table {} being deleted"
argument_list|,
name|tableName
argument_list|,
name|ie
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|InterruptedIOException
argument_list|(
literal|"Table "
operator|+
name|tableName
operator|+
literal|" in region "
operator|+
name|region
operator|+
literal|" has not been deleted"
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Retries
operator|.
name|RetryTranslated
annotation|@
name|VisibleForTesting
DECL|method|provisionTableBlocking (Long readCapacity, Long writeCapacity)
name|void
name|provisionTableBlocking
parameter_list|(
name|Long
name|readCapacity
parameter_list|,
name|Long
name|writeCapacity
parameter_list|)
throws|throws
name|IOException
block|{
name|provisionTable
argument_list|(
name|readCapacity
argument_list|,
name|writeCapacity
argument_list|)
expr_stmt|;
name|waitForTableActive
argument_list|(
name|table
argument_list|)
expr_stmt|;
block|}
DECL|method|getTable ()
specifier|public
name|Table
name|getTable
parameter_list|()
block|{
return|return
name|table
return|;
block|}
DECL|method|getTableArn ()
specifier|public
name|String
name|getTableArn
parameter_list|()
block|{
return|return
name|tableArn
return|;
block|}
block|}
end_class

end_unit

