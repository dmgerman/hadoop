begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.fs.s3
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileNotFoundException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URI
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceStability
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FSDataInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FSDataOutputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileAlreadyExistsException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|ParentNotDirectoryException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|permission
operator|.
name|FsPermission
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|s3native
operator|.
name|NativeS3FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|retry
operator|.
name|RetryPolicies
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|retry
operator|.
name|RetryPolicy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|retry
operator|.
name|RetryProxy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Progressable
import|;
end_import

begin_comment
comment|/**  * A block-based {@link FileSystem} backed by  *<a href="http://aws.amazon.com/s3">Amazon S3</a>.  *  * @see NativeS3FileSystem  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Public
annotation|@
name|InterfaceStability
operator|.
name|Stable
DECL|class|S3FileSystem
specifier|public
class|class
name|S3FileSystem
extends|extends
name|FileSystem
block|{
DECL|field|uri
specifier|private
name|URI
name|uri
decl_stmt|;
DECL|field|store
specifier|private
name|FileSystemStore
name|store
decl_stmt|;
DECL|field|workingDir
specifier|private
name|Path
name|workingDir
decl_stmt|;
DECL|method|S3FileSystem ()
specifier|public
name|S3FileSystem
parameter_list|()
block|{
comment|// set store in initialize()
block|}
DECL|method|S3FileSystem (FileSystemStore store)
specifier|public
name|S3FileSystem
parameter_list|(
name|FileSystemStore
name|store
parameter_list|)
block|{
name|this
operator|.
name|store
operator|=
name|store
expr_stmt|;
block|}
comment|/**    * Return the protocol scheme for the FileSystem.    *    * @return<code>s3</code>    */
annotation|@
name|Override
DECL|method|getScheme ()
specifier|public
name|String
name|getScheme
parameter_list|()
block|{
return|return
literal|"s3"
return|;
block|}
annotation|@
name|Override
DECL|method|getUri ()
specifier|public
name|URI
name|getUri
parameter_list|()
block|{
return|return
name|uri
return|;
block|}
annotation|@
name|Override
DECL|method|initialize (URI uri, Configuration conf)
specifier|public
name|void
name|initialize
parameter_list|(
name|URI
name|uri
parameter_list|,
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|super
operator|.
name|initialize
argument_list|(
name|uri
argument_list|,
name|conf
argument_list|)
expr_stmt|;
if|if
condition|(
name|store
operator|==
literal|null
condition|)
block|{
name|store
operator|=
name|createDefaultStore
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
name|store
operator|.
name|initialize
argument_list|(
name|uri
argument_list|,
name|conf
argument_list|)
expr_stmt|;
name|setConf
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|uri
operator|=
name|URI
operator|.
name|create
argument_list|(
name|uri
operator|.
name|getScheme
argument_list|()
operator|+
literal|"://"
operator|+
name|uri
operator|.
name|getAuthority
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|workingDir
operator|=
operator|new
name|Path
argument_list|(
literal|"/user"
argument_list|,
name|System
operator|.
name|getProperty
argument_list|(
literal|"user.name"
argument_list|)
argument_list|)
operator|.
name|makeQualified
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
DECL|method|createDefaultStore (Configuration conf)
specifier|private
specifier|static
name|FileSystemStore
name|createDefaultStore
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
name|FileSystemStore
name|store
init|=
operator|new
name|Jets3tFileSystemStore
argument_list|()
decl_stmt|;
name|RetryPolicy
name|basePolicy
init|=
name|RetryPolicies
operator|.
name|retryUpToMaximumCountWithFixedSleep
argument_list|(
name|conf
operator|.
name|getInt
argument_list|(
literal|"fs.s3.maxRetries"
argument_list|,
literal|4
argument_list|)
argument_list|,
name|conf
operator|.
name|getLong
argument_list|(
literal|"fs.s3.sleepTimeSeconds"
argument_list|,
literal|10
argument_list|)
argument_list|,
name|TimeUnit
operator|.
name|SECONDS
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|Class
argument_list|<
name|?
extends|extends
name|Exception
argument_list|>
argument_list|,
name|RetryPolicy
argument_list|>
name|exceptionToPolicyMap
init|=
operator|new
name|HashMap
argument_list|<
name|Class
argument_list|<
name|?
extends|extends
name|Exception
argument_list|>
argument_list|,
name|RetryPolicy
argument_list|>
argument_list|()
decl_stmt|;
name|exceptionToPolicyMap
operator|.
name|put
argument_list|(
name|IOException
operator|.
name|class
argument_list|,
name|basePolicy
argument_list|)
expr_stmt|;
name|exceptionToPolicyMap
operator|.
name|put
argument_list|(
name|S3Exception
operator|.
name|class
argument_list|,
name|basePolicy
argument_list|)
expr_stmt|;
name|RetryPolicy
name|methodPolicy
init|=
name|RetryPolicies
operator|.
name|retryByException
argument_list|(
name|RetryPolicies
operator|.
name|TRY_ONCE_THEN_FAIL
argument_list|,
name|exceptionToPolicyMap
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|RetryPolicy
argument_list|>
name|methodNameToPolicyMap
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|RetryPolicy
argument_list|>
argument_list|()
decl_stmt|;
name|methodNameToPolicyMap
operator|.
name|put
argument_list|(
literal|"storeBlock"
argument_list|,
name|methodPolicy
argument_list|)
expr_stmt|;
name|methodNameToPolicyMap
operator|.
name|put
argument_list|(
literal|"retrieveBlock"
argument_list|,
name|methodPolicy
argument_list|)
expr_stmt|;
return|return
operator|(
name|FileSystemStore
operator|)
name|RetryProxy
operator|.
name|create
argument_list|(
name|FileSystemStore
operator|.
name|class
argument_list|,
name|store
argument_list|,
name|methodNameToPolicyMap
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|getWorkingDirectory ()
specifier|public
name|Path
name|getWorkingDirectory
parameter_list|()
block|{
return|return
name|workingDir
return|;
block|}
annotation|@
name|Override
DECL|method|setWorkingDirectory (Path dir)
specifier|public
name|void
name|setWorkingDirectory
parameter_list|(
name|Path
name|dir
parameter_list|)
block|{
name|workingDir
operator|=
name|makeAbsolute
argument_list|(
name|dir
argument_list|)
expr_stmt|;
block|}
DECL|method|makeAbsolute (Path path)
specifier|private
name|Path
name|makeAbsolute
parameter_list|(
name|Path
name|path
parameter_list|)
block|{
if|if
condition|(
name|path
operator|.
name|isAbsolute
argument_list|()
condition|)
block|{
return|return
name|path
return|;
block|}
return|return
operator|new
name|Path
argument_list|(
name|workingDir
argument_list|,
name|path
argument_list|)
return|;
block|}
comment|/**    * @param permission Currently ignored.    */
annotation|@
name|Override
DECL|method|mkdirs (Path path, FsPermission permission)
specifier|public
name|boolean
name|mkdirs
parameter_list|(
name|Path
name|path
parameter_list|,
name|FsPermission
name|permission
parameter_list|)
throws|throws
name|IOException
block|{
name|Path
name|absolutePath
init|=
name|makeAbsolute
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Path
argument_list|>
name|paths
init|=
operator|new
name|ArrayList
argument_list|<
name|Path
argument_list|>
argument_list|()
decl_stmt|;
do|do
block|{
name|paths
operator|.
name|add
argument_list|(
literal|0
argument_list|,
name|absolutePath
argument_list|)
expr_stmt|;
name|absolutePath
operator|=
name|absolutePath
operator|.
name|getParent
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|absolutePath
operator|!=
literal|null
condition|)
do|;
name|boolean
name|result
init|=
literal|true
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|paths
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|Path
name|p
init|=
name|paths
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
try|try
block|{
name|result
operator|&=
name|mkdir
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|FileAlreadyExistsException
name|e
parameter_list|)
block|{
if|if
condition|(
name|i
operator|+
literal|1
operator|<
name|paths
operator|.
name|size
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|ParentNotDirectoryException
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
throw|;
block|}
throw|throw
name|e
throw|;
block|}
block|}
return|return
name|result
return|;
block|}
DECL|method|mkdir (Path path)
specifier|private
name|boolean
name|mkdir
parameter_list|(
name|Path
name|path
parameter_list|)
throws|throws
name|IOException
block|{
name|Path
name|absolutePath
init|=
name|makeAbsolute
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|INode
name|inode
init|=
name|store
operator|.
name|retrieveINode
argument_list|(
name|absolutePath
argument_list|)
decl_stmt|;
if|if
condition|(
name|inode
operator|==
literal|null
condition|)
block|{
name|store
operator|.
name|storeINode
argument_list|(
name|absolutePath
argument_list|,
name|INode
operator|.
name|DIRECTORY_INODE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|inode
operator|.
name|isFile
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|FileAlreadyExistsException
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Can't make directory for path %s since it is a file."
argument_list|,
name|absolutePath
argument_list|)
argument_list|)
throw|;
block|}
return|return
literal|true
return|;
block|}
annotation|@
name|Override
DECL|method|isFile (Path path)
specifier|public
name|boolean
name|isFile
parameter_list|(
name|Path
name|path
parameter_list|)
throws|throws
name|IOException
block|{
name|INode
name|inode
init|=
name|store
operator|.
name|retrieveINode
argument_list|(
name|makeAbsolute
argument_list|(
name|path
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|inode
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
name|inode
operator|.
name|isFile
argument_list|()
return|;
block|}
DECL|method|checkFile (Path path)
specifier|private
name|INode
name|checkFile
parameter_list|(
name|Path
name|path
parameter_list|)
throws|throws
name|IOException
block|{
name|INode
name|inode
init|=
name|store
operator|.
name|retrieveINode
argument_list|(
name|makeAbsolute
argument_list|(
name|path
argument_list|)
argument_list|)
decl_stmt|;
name|String
name|message
init|=
name|String
operator|.
name|format
argument_list|(
literal|"No such file: '%s'"
argument_list|,
name|path
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|inode
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|FileNotFoundException
argument_list|(
name|message
operator|+
literal|" does not exist"
argument_list|)
throw|;
block|}
if|if
condition|(
name|inode
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|FileNotFoundException
argument_list|(
name|message
operator|+
literal|" is a directory"
argument_list|)
throw|;
block|}
return|return
name|inode
return|;
block|}
annotation|@
name|Override
DECL|method|listStatus (Path f)
specifier|public
name|FileStatus
index|[]
name|listStatus
parameter_list|(
name|Path
name|f
parameter_list|)
throws|throws
name|IOException
block|{
name|Path
name|absolutePath
init|=
name|makeAbsolute
argument_list|(
name|f
argument_list|)
decl_stmt|;
name|INode
name|inode
init|=
name|store
operator|.
name|retrieveINode
argument_list|(
name|absolutePath
argument_list|)
decl_stmt|;
if|if
condition|(
name|inode
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|FileNotFoundException
argument_list|(
literal|"File "
operator|+
name|f
operator|+
literal|" does not exist."
argument_list|)
throw|;
block|}
if|if
condition|(
name|inode
operator|.
name|isFile
argument_list|()
condition|)
block|{
return|return
operator|new
name|FileStatus
index|[]
block|{
operator|new
name|S3FileStatus
argument_list|(
name|f
operator|.
name|makeQualified
argument_list|(
name|this
argument_list|)
argument_list|,
name|inode
argument_list|)
block|}
return|;
block|}
name|ArrayList
argument_list|<
name|FileStatus
argument_list|>
name|ret
init|=
operator|new
name|ArrayList
argument_list|<
name|FileStatus
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Path
name|p
range|:
name|store
operator|.
name|listSubPaths
argument_list|(
name|absolutePath
argument_list|)
control|)
block|{
name|ret
operator|.
name|add
argument_list|(
name|getFileStatus
argument_list|(
name|p
operator|.
name|makeQualified
argument_list|(
name|this
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
operator|.
name|toArray
argument_list|(
operator|new
name|FileStatus
index|[
literal|0
index|]
argument_list|)
return|;
block|}
comment|/** This optional operation is not yet supported. */
annotation|@
name|Override
DECL|method|append (Path f, int bufferSize, Progressable progress)
specifier|public
name|FSDataOutputStream
name|append
parameter_list|(
name|Path
name|f
parameter_list|,
name|int
name|bufferSize
parameter_list|,
name|Progressable
name|progress
parameter_list|)
throws|throws
name|IOException
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Not supported"
argument_list|)
throw|;
block|}
comment|/**    * @param permission Currently ignored.    */
annotation|@
name|Override
DECL|method|create (Path file, FsPermission permission, boolean overwrite, int bufferSize, short replication, long blockSize, Progressable progress)
specifier|public
name|FSDataOutputStream
name|create
parameter_list|(
name|Path
name|file
parameter_list|,
name|FsPermission
name|permission
parameter_list|,
name|boolean
name|overwrite
parameter_list|,
name|int
name|bufferSize
parameter_list|,
name|short
name|replication
parameter_list|,
name|long
name|blockSize
parameter_list|,
name|Progressable
name|progress
parameter_list|)
throws|throws
name|IOException
block|{
name|INode
name|inode
init|=
name|store
operator|.
name|retrieveINode
argument_list|(
name|makeAbsolute
argument_list|(
name|file
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|inode
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|overwrite
operator|&&
operator|!
name|inode
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
name|delete
argument_list|(
name|file
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|String
name|message
init|=
name|String
operator|.
name|format
argument_list|(
literal|"File already exists: '%s'"
argument_list|,
name|file
argument_list|)
decl_stmt|;
if|if
condition|(
name|inode
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
name|message
operator|=
name|message
operator|+
literal|" is a directory"
expr_stmt|;
block|}
throw|throw
operator|new
name|FileAlreadyExistsException
argument_list|(
name|message
argument_list|)
throw|;
block|}
block|}
else|else
block|{
name|Path
name|parent
init|=
name|file
operator|.
name|getParent
argument_list|()
decl_stmt|;
if|if
condition|(
name|parent
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
operator|!
name|mkdirs
argument_list|(
name|parent
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Mkdirs failed to create "
operator|+
name|parent
operator|.
name|toString
argument_list|()
argument_list|)
throw|;
block|}
block|}
block|}
return|return
operator|new
name|FSDataOutputStream
argument_list|(
operator|new
name|S3OutputStream
argument_list|(
name|getConf
argument_list|()
argument_list|,
name|store
argument_list|,
name|makeAbsolute
argument_list|(
name|file
argument_list|)
argument_list|,
name|blockSize
argument_list|,
name|progress
argument_list|,
name|bufferSize
argument_list|)
argument_list|,
name|statistics
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|open (Path path, int bufferSize)
specifier|public
name|FSDataInputStream
name|open
parameter_list|(
name|Path
name|path
parameter_list|,
name|int
name|bufferSize
parameter_list|)
throws|throws
name|IOException
block|{
name|INode
name|inode
init|=
name|checkFile
argument_list|(
name|path
argument_list|)
decl_stmt|;
return|return
operator|new
name|FSDataInputStream
argument_list|(
operator|new
name|S3InputStream
argument_list|(
name|getConf
argument_list|()
argument_list|,
name|store
argument_list|,
name|inode
argument_list|,
name|statistics
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|rename (Path src, Path dst)
specifier|public
name|boolean
name|rename
parameter_list|(
name|Path
name|src
parameter_list|,
name|Path
name|dst
parameter_list|)
throws|throws
name|IOException
block|{
name|Path
name|absoluteSrc
init|=
name|makeAbsolute
argument_list|(
name|src
argument_list|)
decl_stmt|;
specifier|final
name|String
name|debugPreamble
init|=
literal|"Renaming '"
operator|+
name|src
operator|+
literal|"' to '"
operator|+
name|dst
operator|+
literal|"' - "
decl_stmt|;
name|INode
name|srcINode
init|=
name|store
operator|.
name|retrieveINode
argument_list|(
name|absoluteSrc
argument_list|)
decl_stmt|;
name|boolean
name|debugEnabled
init|=
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
decl_stmt|;
if|if
condition|(
name|srcINode
operator|==
literal|null
condition|)
block|{
comment|// src path doesn't exist
if|if
condition|(
name|debugEnabled
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|debugPreamble
operator|+
literal|"returning false as src does not exist"
argument_list|)
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
name|Path
name|absoluteDst
init|=
name|makeAbsolute
argument_list|(
name|dst
argument_list|)
decl_stmt|;
comment|//validate the parent dir of the destination
name|Path
name|dstParent
init|=
name|absoluteDst
operator|.
name|getParent
argument_list|()
decl_stmt|;
if|if
condition|(
name|dstParent
operator|!=
literal|null
condition|)
block|{
comment|//if the dst parent is not root, make sure it exists
name|INode
name|dstParentINode
init|=
name|store
operator|.
name|retrieveINode
argument_list|(
name|dstParent
argument_list|)
decl_stmt|;
if|if
condition|(
name|dstParentINode
operator|==
literal|null
condition|)
block|{
comment|// dst parent doesn't exist
if|if
condition|(
name|debugEnabled
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|debugPreamble
operator|+
literal|"returning false as dst parent does not exist"
argument_list|)
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
if|if
condition|(
name|dstParentINode
operator|.
name|isFile
argument_list|()
condition|)
block|{
comment|// dst parent exists but is a file
if|if
condition|(
name|debugEnabled
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|debugPreamble
operator|+
literal|"returning false as dst parent exists and is a file"
argument_list|)
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
block|}
comment|//get status of source
name|boolean
name|srcIsFile
init|=
name|srcINode
operator|.
name|isFile
argument_list|()
decl_stmt|;
name|INode
name|dstINode
init|=
name|store
operator|.
name|retrieveINode
argument_list|(
name|absoluteDst
argument_list|)
decl_stmt|;
name|boolean
name|destExists
init|=
name|dstINode
operator|!=
literal|null
decl_stmt|;
name|boolean
name|destIsDir
init|=
name|destExists
operator|&&
operator|!
name|dstINode
operator|.
name|isFile
argument_list|()
decl_stmt|;
if|if
condition|(
name|srcIsFile
condition|)
block|{
comment|//source is a simple file
if|if
condition|(
name|destExists
condition|)
block|{
if|if
condition|(
name|destIsDir
condition|)
block|{
comment|//outcome #1 dest exists and is dir -filename to subdir of dest
if|if
condition|(
name|debugEnabled
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|debugPreamble
operator|+
literal|"copying src file under dest dir to "
operator|+
name|absoluteDst
argument_list|)
expr_stmt|;
block|}
name|absoluteDst
operator|=
operator|new
name|Path
argument_list|(
name|absoluteDst
argument_list|,
name|absoluteSrc
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|//outcome #2 dest it's a file: fail iff different from src
name|boolean
name|renamingOnToSelf
init|=
name|absoluteSrc
operator|.
name|equals
argument_list|(
name|absoluteDst
argument_list|)
decl_stmt|;
if|if
condition|(
name|debugEnabled
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|debugPreamble
operator|+
literal|"copying file onto file, outcome is "
operator|+
name|renamingOnToSelf
argument_list|)
expr_stmt|;
block|}
return|return
name|renamingOnToSelf
return|;
block|}
block|}
else|else
block|{
comment|// #3 dest does not exist: use dest as path for rename
if|if
condition|(
name|debugEnabled
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|debugPreamble
operator|+
literal|"copying file onto file"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|//here the source exists and is a directory
comment|// outcomes (given we know the parent dir exists if we get this far)
comment|// #1 destination is a file: fail
comment|// #2 destination is a directory: create a new dir under that one
comment|// #3 destination doesn't exist: create a new dir with that name
comment|// #3 and #4 are only allowed if the dest path is not == or under src
if|if
condition|(
name|destExists
condition|)
block|{
if|if
condition|(
operator|!
name|destIsDir
condition|)
block|{
comment|// #1 destination is a file: fail
if|if
condition|(
name|debugEnabled
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|debugPreamble
operator|+
literal|"returning false as src is a directory, but not dest"
argument_list|)
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
else|else
block|{
comment|// the destination dir exists
comment|// destination for rename becomes a subdir of the target name
name|absoluteDst
operator|=
operator|new
name|Path
argument_list|(
name|absoluteDst
argument_list|,
name|absoluteSrc
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|debugEnabled
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|debugPreamble
operator|+
literal|"copying src dir under dest dir to "
operator|+
name|absoluteDst
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|//the final destination directory is now know, so validate it for
comment|//illegal moves
if|if
condition|(
name|absoluteSrc
operator|.
name|equals
argument_list|(
name|absoluteDst
argument_list|)
condition|)
block|{
comment|//you can't rename a directory onto itself
if|if
condition|(
name|debugEnabled
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|debugPreamble
operator|+
literal|"Dest==source&& isDir -failing"
argument_list|)
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
if|if
condition|(
name|absoluteDst
operator|.
name|toString
argument_list|()
operator|.
name|startsWith
argument_list|(
name|absoluteSrc
operator|.
name|toString
argument_list|()
operator|+
literal|"/"
argument_list|)
condition|)
block|{
comment|//you can't move a directory under itself
if|if
condition|(
name|debugEnabled
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|debugPreamble
operator|+
literal|"dst is equal to or under src dir -failing"
argument_list|)
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
block|}
comment|//here the dest path is set up -so rename
return|return
name|renameRecursive
argument_list|(
name|absoluteSrc
argument_list|,
name|absoluteDst
argument_list|)
return|;
block|}
DECL|method|renameRecursive (Path src, Path dst)
specifier|private
name|boolean
name|renameRecursive
parameter_list|(
name|Path
name|src
parameter_list|,
name|Path
name|dst
parameter_list|)
throws|throws
name|IOException
block|{
name|INode
name|srcINode
init|=
name|store
operator|.
name|retrieveINode
argument_list|(
name|src
argument_list|)
decl_stmt|;
name|store
operator|.
name|storeINode
argument_list|(
name|dst
argument_list|,
name|srcINode
argument_list|)
expr_stmt|;
name|store
operator|.
name|deleteINode
argument_list|(
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
name|srcINode
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
for|for
control|(
name|Path
name|oldSrc
range|:
name|store
operator|.
name|listDeepSubPaths
argument_list|(
name|src
argument_list|)
control|)
block|{
name|INode
name|inode
init|=
name|store
operator|.
name|retrieveINode
argument_list|(
name|oldSrc
argument_list|)
decl_stmt|;
if|if
condition|(
name|inode
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
name|String
name|oldSrcPath
init|=
name|oldSrc
operator|.
name|toUri
argument_list|()
operator|.
name|getPath
argument_list|()
decl_stmt|;
name|String
name|srcPath
init|=
name|src
operator|.
name|toUri
argument_list|()
operator|.
name|getPath
argument_list|()
decl_stmt|;
name|String
name|dstPath
init|=
name|dst
operator|.
name|toUri
argument_list|()
operator|.
name|getPath
argument_list|()
decl_stmt|;
name|Path
name|newDst
init|=
operator|new
name|Path
argument_list|(
name|oldSrcPath
operator|.
name|replaceFirst
argument_list|(
name|srcPath
argument_list|,
name|dstPath
argument_list|)
argument_list|)
decl_stmt|;
name|store
operator|.
name|storeINode
argument_list|(
name|newDst
argument_list|,
name|inode
argument_list|)
expr_stmt|;
name|store
operator|.
name|deleteINode
argument_list|(
name|oldSrc
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|true
return|;
block|}
annotation|@
name|Override
DECL|method|delete (Path path, boolean recursive)
specifier|public
name|boolean
name|delete
parameter_list|(
name|Path
name|path
parameter_list|,
name|boolean
name|recursive
parameter_list|)
throws|throws
name|IOException
block|{
name|Path
name|absolutePath
init|=
name|makeAbsolute
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|INode
name|inode
init|=
name|store
operator|.
name|retrieveINode
argument_list|(
name|absolutePath
argument_list|)
decl_stmt|;
if|if
condition|(
name|inode
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|inode
operator|.
name|isFile
argument_list|()
condition|)
block|{
name|store
operator|.
name|deleteINode
argument_list|(
name|absolutePath
argument_list|)
expr_stmt|;
for|for
control|(
name|Block
name|block
range|:
name|inode
operator|.
name|getBlocks
argument_list|()
control|)
block|{
name|store
operator|.
name|deleteBlock
argument_list|(
name|block
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|FileStatus
index|[]
name|contents
init|=
literal|null
decl_stmt|;
try|try
block|{
name|contents
operator|=
name|listStatus
argument_list|(
name|absolutePath
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|fnfe
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|(
name|contents
operator|.
name|length
operator|!=
literal|0
operator|)
operator|&&
operator|(
operator|!
name|recursive
operator|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Directory "
operator|+
name|path
operator|.
name|toString
argument_list|()
operator|+
literal|" is not empty."
argument_list|)
throw|;
block|}
for|for
control|(
name|FileStatus
name|p
range|:
name|contents
control|)
block|{
if|if
condition|(
operator|!
name|delete
argument_list|(
name|p
operator|.
name|getPath
argument_list|()
argument_list|,
name|recursive
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
name|store
operator|.
name|deleteINode
argument_list|(
name|absolutePath
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
comment|/**    * FileStatus for S3 file systems.    */
annotation|@
name|Override
DECL|method|getFileStatus (Path f)
specifier|public
name|FileStatus
name|getFileStatus
parameter_list|(
name|Path
name|f
parameter_list|)
throws|throws
name|IOException
block|{
name|INode
name|inode
init|=
name|store
operator|.
name|retrieveINode
argument_list|(
name|makeAbsolute
argument_list|(
name|f
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|inode
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|FileNotFoundException
argument_list|(
name|f
operator|+
literal|": No such file or directory."
argument_list|)
throw|;
block|}
return|return
operator|new
name|S3FileStatus
argument_list|(
name|f
operator|.
name|makeQualified
argument_list|(
name|this
argument_list|)
argument_list|,
name|inode
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|getDefaultBlockSize ()
specifier|public
name|long
name|getDefaultBlockSize
parameter_list|()
block|{
return|return
name|getConf
argument_list|()
operator|.
name|getLong
argument_list|(
literal|"fs.s3.block.size"
argument_list|,
literal|64
operator|*
literal|1024
operator|*
literal|1024
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|getCanonicalServiceName ()
specifier|public
name|String
name|getCanonicalServiceName
parameter_list|()
block|{
comment|// Does not support Token
return|return
literal|null
return|;
block|}
comment|// diagnostic methods
DECL|method|dump ()
name|void
name|dump
parameter_list|()
throws|throws
name|IOException
block|{
name|store
operator|.
name|dump
argument_list|()
expr_stmt|;
block|}
DECL|method|purge ()
name|void
name|purge
parameter_list|()
throws|throws
name|IOException
block|{
name|store
operator|.
name|purge
argument_list|()
expr_stmt|;
block|}
DECL|class|S3FileStatus
specifier|private
specifier|static
class|class
name|S3FileStatus
extends|extends
name|FileStatus
block|{
DECL|method|S3FileStatus (Path f, INode inode)
name|S3FileStatus
parameter_list|(
name|Path
name|f
parameter_list|,
name|INode
name|inode
parameter_list|)
throws|throws
name|IOException
block|{
name|super
argument_list|(
name|findLength
argument_list|(
name|inode
argument_list|)
argument_list|,
name|inode
operator|.
name|isDirectory
argument_list|()
argument_list|,
literal|1
argument_list|,
name|findBlocksize
argument_list|(
name|inode
argument_list|)
argument_list|,
literal|0
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
DECL|method|findLength (INode inode)
specifier|private
specifier|static
name|long
name|findLength
parameter_list|(
name|INode
name|inode
parameter_list|)
block|{
if|if
condition|(
operator|!
name|inode
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
name|long
name|length
init|=
literal|0L
decl_stmt|;
for|for
control|(
name|Block
name|block
range|:
name|inode
operator|.
name|getBlocks
argument_list|()
control|)
block|{
name|length
operator|+=
name|block
operator|.
name|getLength
argument_list|()
expr_stmt|;
block|}
return|return
name|length
return|;
block|}
return|return
literal|0
return|;
block|}
DECL|method|findBlocksize (INode inode)
specifier|private
specifier|static
name|long
name|findBlocksize
parameter_list|(
name|INode
name|inode
parameter_list|)
block|{
specifier|final
name|Block
index|[]
name|ret
init|=
name|inode
operator|.
name|getBlocks
argument_list|()
decl_stmt|;
return|return
name|ret
operator|==
literal|null
condition|?
literal|0L
else|:
name|ret
index|[
literal|0
index|]
operator|.
name|getLength
argument_list|()
return|;
block|}
block|}
block|}
end_class

end_unit

