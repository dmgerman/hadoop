begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.tools.dynamometer
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|tools
operator|.
name|dynamometer
package|;
end_package

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Joiner
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Splitter
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Optional
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|Supplier
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|tools
operator|.
name|dynamometer
operator|.
name|workloadgenerator
operator|.
name|audit
operator|.
name|AuditReplayMapper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|tools
operator|.
name|dynamometer
operator|.
name|workloadgenerator
operator|.
name|WorkloadDriver
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileNotFoundException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URI
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URL
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|ByteBuffer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|Files
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|Paths
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Properties
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|stream
operator|.
name|Collectors
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|zip
operator|.
name|ZipEntry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|zip
operator|.
name|ZipOutputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|cli
operator|.
name|CommandLine
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|cli
operator|.
name|CommandLineParser
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|cli
operator|.
name|GnuParser
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|cli
operator|.
name|HelpFormatter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|cli
operator|.
name|Option
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|cli
operator|.
name|OptionGroup
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|cli
operator|.
name|Options
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|cli
operator|.
name|ParseException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceStability
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configured
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|DataOutputBuffer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|Job
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|JobStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|MRJobConfig
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|Credentials
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|UserGroupInformation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|token
operator|.
name|Token
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|ClassUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Tool
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|ToolRunner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|ApplicationConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|ApplicationConstants
operator|.
name|Environment
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|protocolrecords
operator|.
name|GetNewApplicationResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ApplicationAccessType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ApplicationId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ApplicationReport
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ApplicationSubmissionContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ContainerLaunchContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|LocalResource
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|LocalResourceType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|LocalResourceVisibility
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|QueueInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|Resource
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|YarnApplicationState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|YarnClusterMetrics
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|client
operator|.
name|api
operator|.
name|YarnClient
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|client
operator|.
name|api
operator|.
name|YarnClientApplication
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|conf
operator|.
name|YarnConfiguration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|exceptions
operator|.
name|YarnException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|util
operator|.
name|Records
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Assert
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_comment
comment|/**  * Client for submitting a Dynamometer YARN application, and optionally, a  * workload MapReduce job. This client uploads resources to HDFS as necessary  * for them to be accessed by the YARN app, then launches an  * {@link ApplicationMaster}, which is responsible for managing the lifetime of  * the application.  *<p>  * The Dynamometer YARN application starts up the DataNodes of an HDFS  * cluster. If the namenode_servicerpc_addr option is specified, it should point  * to the service RPC address of an existing namenode, which the datanodes will  * talk to. Else, a namenode will be launched internal to this YARN application.  * The ApplicationMaster's logs contain links to the NN / DN containers to be  * able to access their logs. Some of this information is also printed by the  * client.  *<p>  * The application will store files in the submitting user's home directory  * under a `.dynamometer/applicationID/` folder. This is mostly for uses  * internal to the application, but if the NameNode is launched through YARN,  * the NameNode's metrics will also be uploaded to a file `namenode_metrics`  * within this folder. This file is also accessible as part of the NameNode's  * logs, but this centralized location is easier to access for subsequent  * parsing.  *<p>  * If the NameNode is launched internally, this Client will monitor the  * status of the NameNode, printing information about its availability as the  * DataNodes register (e.g., outstanding under replicated blocks as block  * reports arrive). If this is configured to launch the workload job, once the  * NameNode has gathered information from all of its DataNodes, the client will  * launch a workload job which is configured to act against the newly launched  * NameNode. Once the workload job completes, the infrastructure application  * will be shut down. At this time only the audit log replay  * ({@link AuditReplayMapper}) workload is supported.  *<p>  * If there is no workload job configured, this application will, by  * default, persist indefinitely until killed by YARN. You can specify the  * timeout option to have it exit automatically after some time. This timeout  * will enforced if there is a workload job configured as well.  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Public
annotation|@
name|InterfaceStability
operator|.
name|Unstable
DECL|class|Client
specifier|public
class|class
name|Client
extends|extends
name|Configured
implements|implements
name|Tool
block|{
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|Client
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|APPNAME_ARG
specifier|public
specifier|static
specifier|final
name|String
name|APPNAME_ARG
init|=
literal|"appname"
decl_stmt|;
DECL|field|APPNAME_DEFAULT
specifier|public
specifier|static
specifier|final
name|String
name|APPNAME_DEFAULT
init|=
literal|"DynamometerTest"
decl_stmt|;
DECL|field|QUEUE_ARG
specifier|public
specifier|static
specifier|final
name|String
name|QUEUE_ARG
init|=
literal|"queue"
decl_stmt|;
DECL|field|QUEUE_DEFAULT
specifier|public
specifier|static
specifier|final
name|String
name|QUEUE_DEFAULT
init|=
literal|"default"
decl_stmt|;
DECL|field|TIMEOUT_ARG
specifier|public
specifier|static
specifier|final
name|String
name|TIMEOUT_ARG
init|=
literal|"timeout"
decl_stmt|;
DECL|field|TIMEOUT_DEFAULT
specifier|public
specifier|static
specifier|final
name|String
name|TIMEOUT_DEFAULT
init|=
literal|"-1"
decl_stmt|;
DECL|field|HADOOP_VERSION_ARG
specifier|public
specifier|static
specifier|final
name|String
name|HADOOP_VERSION_ARG
init|=
literal|"hadoop_version"
decl_stmt|;
DECL|field|HADOOP_BINARY_PATH_ARG
specifier|public
specifier|static
specifier|final
name|String
name|HADOOP_BINARY_PATH_ARG
init|=
literal|"hadoop_binary_path"
decl_stmt|;
DECL|field|NAMENODE_SERVICERPC_ADDR_ARG
specifier|public
specifier|static
specifier|final
name|String
name|NAMENODE_SERVICERPC_ADDR_ARG
init|=
literal|"namenode_servicerpc_addr"
decl_stmt|;
DECL|field|FS_IMAGE_DIR_ARG
specifier|public
specifier|static
specifier|final
name|String
name|FS_IMAGE_DIR_ARG
init|=
literal|"fs_image_dir"
decl_stmt|;
DECL|field|BLOCK_LIST_PATH_ARG
specifier|public
specifier|static
specifier|final
name|String
name|BLOCK_LIST_PATH_ARG
init|=
literal|"block_list_path"
decl_stmt|;
DECL|field|CONF_PATH_ARG
specifier|public
specifier|static
specifier|final
name|String
name|CONF_PATH_ARG
init|=
literal|"conf_path"
decl_stmt|;
DECL|field|MASTER_VCORES_ARG
specifier|public
specifier|static
specifier|final
name|String
name|MASTER_VCORES_ARG
init|=
literal|"master_vcores"
decl_stmt|;
DECL|field|MASTER_VCORES_DEFAULT
specifier|public
specifier|static
specifier|final
name|String
name|MASTER_VCORES_DEFAULT
init|=
literal|"1"
decl_stmt|;
DECL|field|MASTER_MEMORY_MB_ARG
specifier|public
specifier|static
specifier|final
name|String
name|MASTER_MEMORY_MB_ARG
init|=
literal|"master_memory_mb"
decl_stmt|;
DECL|field|MASTER_MEMORY_MB_DEFAULT
specifier|public
specifier|static
specifier|final
name|String
name|MASTER_MEMORY_MB_DEFAULT
init|=
literal|"2048"
decl_stmt|;
DECL|field|TOKEN_FILE_LOCATION_ARG
specifier|public
specifier|static
specifier|final
name|String
name|TOKEN_FILE_LOCATION_ARG
init|=
literal|"token_file_location"
decl_stmt|;
DECL|field|WORKLOAD_REPLAY_ENABLE_ARG
specifier|public
specifier|static
specifier|final
name|String
name|WORKLOAD_REPLAY_ENABLE_ARG
init|=
literal|"workload_replay_enable"
decl_stmt|;
DECL|field|WORKLOAD_INPUT_PATH_ARG
specifier|public
specifier|static
specifier|final
name|String
name|WORKLOAD_INPUT_PATH_ARG
init|=
literal|"workload_input_path"
decl_stmt|;
DECL|field|WORKLOAD_THREADS_PER_MAPPER_ARG
specifier|public
specifier|static
specifier|final
name|String
name|WORKLOAD_THREADS_PER_MAPPER_ARG
init|=
literal|"workload_threads_per_mapper"
decl_stmt|;
DECL|field|WORKLOAD_START_DELAY_ARG
specifier|public
specifier|static
specifier|final
name|String
name|WORKLOAD_START_DELAY_ARG
init|=
literal|"workload_start_delay"
decl_stmt|;
DECL|field|WORKLOAD_RATE_FACTOR_ARG
specifier|public
specifier|static
specifier|final
name|String
name|WORKLOAD_RATE_FACTOR_ARG
init|=
literal|"workload_rate_factor"
decl_stmt|;
DECL|field|WORKLOAD_RATE_FACTOR_DEFAULT
specifier|public
specifier|static
specifier|final
name|String
name|WORKLOAD_RATE_FACTOR_DEFAULT
init|=
literal|"1.0"
decl_stmt|;
DECL|field|WORKLOAD_CONFIG_ARG
specifier|public
specifier|static
specifier|final
name|String
name|WORKLOAD_CONFIG_ARG
init|=
literal|"workload_config"
decl_stmt|;
DECL|field|ARCHIVE_FILE_TYPES
specifier|private
specifier|static
specifier|final
name|String
index|[]
name|ARCHIVE_FILE_TYPES
init|=
block|{
literal|".zip"
block|,
literal|".tar"
block|,
literal|".tgz"
block|,
literal|".tar.gz"
block|}
decl_stmt|;
DECL|field|START_SCRIPT_LOCATION
specifier|private
specifier|static
specifier|final
name|String
name|START_SCRIPT_LOCATION
init|=
name|Client
operator|.
name|class
operator|.
name|getClassLoader
argument_list|()
operator|.
name|getResource
argument_list|(
name|DynoConstants
operator|.
name|START_SCRIPT
operator|.
name|getResourcePath
argument_list|()
argument_list|)
operator|.
name|toString
argument_list|()
decl_stmt|;
DECL|field|yarnClient
specifier|private
name|YarnClient
name|yarnClient
decl_stmt|;
comment|// Application master specific info to register a new Application with RM/ASM
DECL|field|appName
specifier|private
name|String
name|appName
init|=
literal|""
decl_stmt|;
comment|// Queue for App master
DECL|field|amQueue
specifier|private
name|String
name|amQueue
init|=
literal|""
decl_stmt|;
comment|// Amt. of memory resource to request for to run the App Master
DECL|field|amMemory
specifier|private
name|int
name|amMemory
init|=
literal|10
decl_stmt|;
comment|// Amt. of virtual core resource to request for to run the App Master
DECL|field|amVCores
specifier|private
name|int
name|amVCores
init|=
literal|1
decl_stmt|;
comment|// Dependency JARs. Should include, at minimum, the JAR for the App Master
DECL|field|dependencyJars
specifier|private
specifier|final
name|String
index|[]
name|dependencyJars
decl_stmt|;
DECL|field|hadoopBinary
specifier|private
name|String
name|hadoopBinary
init|=
literal|""
decl_stmt|;
comment|// Location of DN conf zip
DECL|field|confPath
specifier|private
name|String
name|confPath
init|=
literal|""
decl_stmt|;
comment|// Location of root dir for DN block image zips
DECL|field|blockListPath
specifier|private
name|String
name|blockListPath
init|=
literal|""
decl_stmt|;
comment|// Location of NN fs image
DECL|field|fsImagePath
specifier|private
name|String
name|fsImagePath
init|=
literal|""
decl_stmt|;
comment|// Location of NN fs image md5 file
DECL|field|fsImageMD5Path
specifier|private
name|String
name|fsImageMD5Path
init|=
literal|""
decl_stmt|;
comment|// Location of NN VERSION file
DECL|field|versionFilePath
specifier|private
name|String
name|versionFilePath
init|=
literal|""
decl_stmt|;
comment|// Service RPC address of the NameNode, if it is external
DECL|field|remoteNameNodeRpcAddress
specifier|private
name|String
name|remoteNameNodeRpcAddress
init|=
literal|""
decl_stmt|;
comment|// True iff the NameNode should be launched within YARN
DECL|field|launchNameNode
specifier|private
name|boolean
name|launchNameNode
decl_stmt|;
comment|// The path to the file which contains the delegation tokens to be used for
comment|// the launched
comment|// containers (may be null)
DECL|field|tokenFileLocation
specifier|private
name|String
name|tokenFileLocation
decl_stmt|;
comment|// Holds all of the options which are passed to the AM
DECL|field|amOptions
specifier|private
name|AMOptions
name|amOptions
decl_stmt|;
comment|// The ApplicationId of the YARN infrastructure application.
DECL|field|infraAppId
specifier|private
name|ApplicationId
name|infraAppId
decl_stmt|;
comment|// The current state of the YARN infrastructure application.
DECL|field|infraAppState
specifier|private
specifier|volatile
name|YarnApplicationState
name|infraAppState
init|=
name|YarnApplicationState
operator|.
name|NEW
decl_stmt|;
DECL|field|workloadAppState
specifier|private
specifier|volatile
name|JobStatus
operator|.
name|State
name|workloadAppState
init|=
name|JobStatus
operator|.
name|State
operator|.
name|PREP
decl_stmt|;
comment|// Total number of DataNodes which will be launched.
DECL|field|numTotalDataNodes
specifier|private
name|int
name|numTotalDataNodes
decl_stmt|;
comment|// Whether or not the workload job should be launched.
DECL|field|launchWorkloadJob
specifier|private
name|boolean
name|launchWorkloadJob
init|=
literal|false
decl_stmt|;
comment|// The workload job itself.
DECL|field|workloadJob
specifier|private
specifier|volatile
name|Job
name|workloadJob
decl_stmt|;
comment|// The input path for the workload job.
DECL|field|workloadInputPath
specifier|private
name|String
name|workloadInputPath
init|=
literal|""
decl_stmt|;
comment|// The number of threads to use per mapper for the workload job.
DECL|field|workloadThreadsPerMapper
specifier|private
name|int
name|workloadThreadsPerMapper
decl_stmt|;
comment|// The startup delay for the workload job.
DECL|field|workloadStartDelayMs
specifier|private
name|long
name|workloadStartDelayMs
decl_stmt|;
DECL|field|workloadRateFactor
specifier|private
name|double
name|workloadRateFactor
init|=
literal|0.0
decl_stmt|;
DECL|field|workloadExtraConfigs
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|workloadExtraConfigs
decl_stmt|;
comment|// Start time for client
DECL|field|clientStartTime
specifier|private
specifier|final
name|long
name|clientStartTime
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
comment|// Timeout threshold for client. Kill app after time interval expires.
DECL|field|clientTimeout
specifier|private
name|long
name|clientTimeout
decl_stmt|;
comment|// Command line options
DECL|field|opts
specifier|private
name|Options
name|opts
decl_stmt|;
comment|/**    * @param args Command line arguments    * @throws Exception on error    */
DECL|method|main (String[] args)
specifier|public
specifier|static
name|void
name|main
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
throws|throws
name|Exception
block|{
name|Client
name|client
init|=
operator|new
name|Client
argument_list|(
name|ClassUtil
operator|.
name|findContainingJar
argument_list|(
name|ApplicationMaster
operator|.
name|class
argument_list|)
argument_list|,
comment|// JUnit is required by MiniDFSCluster at runtime, but is not included
comment|// in standard Hadoop dependencies, so it must explicitly included here
name|ClassUtil
operator|.
name|findContainingJar
argument_list|(
name|Assert
operator|.
name|class
argument_list|)
argument_list|)
decl_stmt|;
name|System
operator|.
name|exit
argument_list|(
name|ToolRunner
operator|.
name|run
argument_list|(
operator|new
name|YarnConfiguration
argument_list|()
argument_list|,
name|client
argument_list|,
name|args
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|run (String[] args)
specifier|public
name|int
name|run
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
block|{
name|boolean
name|result
decl_stmt|;
try|try
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Initializing Client"
argument_list|)
expr_stmt|;
try|try
block|{
name|boolean
name|doRun
init|=
name|init
argument_list|(
name|args
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|doRun
condition|)
block|{
return|return
literal|0
return|;
block|}
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
name|e
operator|.
name|getLocalizedMessage
argument_list|()
argument_list|)
expr_stmt|;
name|printUsage
argument_list|()
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|result
operator|=
name|run
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Error running Client"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|result
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Application completed successfully"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|LOG
operator|.
name|error
argument_list|(
literal|"Application failed to complete successfully"
argument_list|)
expr_stmt|;
return|return
literal|2
return|;
block|}
DECL|method|Client (String... dependencyJars)
specifier|public
name|Client
parameter_list|(
name|String
modifier|...
name|dependencyJars
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|dependencyJars
operator|!=
literal|null
operator|&&
name|dependencyJars
operator|.
name|length
operator|>
literal|0
argument_list|,
literal|"Must specify at least one dependency JAR for the ApplicationMaster"
argument_list|)
expr_stmt|;
name|this
operator|.
name|dependencyJars
operator|=
name|dependencyJars
expr_stmt|;
name|opts
operator|=
operator|new
name|Options
argument_list|()
expr_stmt|;
name|opts
operator|.
name|addOption
argument_list|(
name|APPNAME_ARG
argument_list|,
literal|true
argument_list|,
literal|"Application Name. (default '"
operator|+
name|APPNAME_DEFAULT
operator|+
literal|"')"
argument_list|)
expr_stmt|;
name|opts
operator|.
name|addOption
argument_list|(
name|QUEUE_ARG
argument_list|,
literal|true
argument_list|,
literal|"RM Queue in which this application is "
operator|+
literal|"to be submitted (default '"
operator|+
name|QUEUE_DEFAULT
operator|+
literal|"')"
argument_list|)
expr_stmt|;
name|opts
operator|.
name|addOption
argument_list|(
name|TIMEOUT_ARG
argument_list|,
literal|true
argument_list|,
literal|"Application timeout in milliseconds "
operator|+
literal|"(default "
operator|+
name|TIMEOUT_DEFAULT
operator|+
literal|" = unlimited)"
argument_list|)
expr_stmt|;
name|opts
operator|.
name|addOption
argument_list|(
name|MASTER_MEMORY_MB_ARG
argument_list|,
literal|true
argument_list|,
literal|"Amount of memory in MB to be "
operator|+
literal|"requested to run the application master (default "
operator|+
name|MASTER_MEMORY_MB_DEFAULT
operator|+
literal|")"
argument_list|)
expr_stmt|;
name|opts
operator|.
name|addOption
argument_list|(
name|MASTER_VCORES_ARG
argument_list|,
literal|true
argument_list|,
literal|"Amount of virtual cores to be "
operator|+
literal|"requested to run the application master (default "
operator|+
name|MASTER_VCORES_DEFAULT
operator|+
literal|")"
argument_list|)
expr_stmt|;
comment|// Dynamometer
name|opts
operator|.
name|addOption
argument_list|(
name|CONF_PATH_ARG
argument_list|,
literal|true
argument_list|,
literal|"Location of the directory or archive "
operator|+
literal|"containing the Hadoop configuration. If this is already on a "
operator|+
literal|"remote FS, will save the copy step, but must be an archive file. "
operator|+
literal|"This must have the standard Hadoop conf layout containing e.g. "
operator|+
literal|"etc/hadoop/*-site.xml"
argument_list|)
expr_stmt|;
name|opts
operator|.
name|addOption
argument_list|(
name|BLOCK_LIST_PATH_ARG
argument_list|,
literal|true
argument_list|,
literal|"Location on HDFS of the files containing the DN block lists."
argument_list|)
expr_stmt|;
name|opts
operator|.
name|addOption
argument_list|(
name|FS_IMAGE_DIR_ARG
argument_list|,
literal|true
argument_list|,
literal|"Location of the directory "
operator|+
literal|"containing, at minimum, the VERSION file for the namenode. If "
operator|+
literal|"running the namenode within YARN (namenode_info_path is not "
operator|+
literal|"specified), this must also include the fsimage file and its md5 "
operator|+
literal|"hash with names conforming to: `fsimage_XXXXXXXX[.md5]`."
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|option
range|:
operator|new
name|String
index|[]
block|{
name|CONF_PATH_ARG
block|,
name|BLOCK_LIST_PATH_ARG
block|,
name|FS_IMAGE_DIR_ARG
block|}
control|)
block|{
name|opts
operator|.
name|getOption
argument_list|(
name|option
argument_list|)
operator|.
name|setRequired
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
name|OptionGroup
name|hadoopBinaryGroup
init|=
operator|new
name|OptionGroup
argument_list|()
decl_stmt|;
name|hadoopBinaryGroup
operator|.
name|addOption
argument_list|(
operator|new
name|Option
argument_list|(
name|HADOOP_BINARY_PATH_ARG
argument_list|,
literal|true
argument_list|,
literal|"Location of Hadoop binary to be deployed (archive). One of this or "
operator|+
literal|"hadoop_version is required."
argument_list|)
argument_list|)
expr_stmt|;
name|hadoopBinaryGroup
operator|.
name|addOption
argument_list|(
operator|new
name|Option
argument_list|(
name|HADOOP_VERSION_ARG
argument_list|,
literal|true
argument_list|,
literal|"Version of Hadoop (like '2.7.4' or '3.0.0-beta1') for which to "
operator|+
literal|"download a binary. If this is specified, a Hadoop tarball "
operator|+
literal|"will be downloaded from an Apache mirror. By default the "
operator|+
literal|"Berkeley OCF mirror is used; specify "
operator|+
name|DynoInfraUtils
operator|.
name|APACHE_DOWNLOAD_MIRROR_KEY
operator|+
literal|" as a configuration or system property to change which mirror "
operator|+
literal|"is used. The tarball will be downloaded to the working "
operator|+
literal|"directory. One of this or hadoop_binary_path is required."
argument_list|)
argument_list|)
expr_stmt|;
name|hadoopBinaryGroup
operator|.
name|setRequired
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|opts
operator|.
name|addOptionGroup
argument_list|(
name|hadoopBinaryGroup
argument_list|)
expr_stmt|;
name|opts
operator|.
name|addOption
argument_list|(
name|NAMENODE_SERVICERPC_ADDR_ARG
argument_list|,
literal|true
argument_list|,
literal|"Specify this option "
operator|+
literal|"to run the NameNode external to YARN. This is the service RPC "
operator|+
literal|"address of the NameNode, e.g. localhost:9020."
argument_list|)
expr_stmt|;
name|opts
operator|.
name|addOption
argument_list|(
name|TOKEN_FILE_LOCATION_ARG
argument_list|,
literal|true
argument_list|,
literal|"If specified, this file "
operator|+
literal|"will be used as the delegation token(s) for the launched "
operator|+
literal|"containers. Otherwise, the delegation token(s) for the default "
operator|+
literal|"FileSystem will be used."
argument_list|)
expr_stmt|;
name|AMOptions
operator|.
name|setOptions
argument_list|(
name|opts
argument_list|)
expr_stmt|;
name|opts
operator|.
name|addOption
argument_list|(
name|WORKLOAD_REPLAY_ENABLE_ARG
argument_list|,
literal|false
argument_list|,
literal|"If specified, this "
operator|+
literal|"client will additionally launch the workload replay job to replay "
operator|+
literal|"audit logs against the HDFS cluster which is started."
argument_list|)
expr_stmt|;
name|opts
operator|.
name|addOption
argument_list|(
name|WORKLOAD_INPUT_PATH_ARG
argument_list|,
literal|true
argument_list|,
literal|"Location of the audit traces to replay (Required for workload)"
argument_list|)
expr_stmt|;
name|opts
operator|.
name|addOption
argument_list|(
name|WORKLOAD_THREADS_PER_MAPPER_ARG
argument_list|,
literal|true
argument_list|,
literal|"Number of threads "
operator|+
literal|"per mapper to use to replay the workload. (default "
operator|+
name|AuditReplayMapper
operator|.
name|NUM_THREADS_DEFAULT
operator|+
literal|")"
argument_list|)
expr_stmt|;
name|opts
operator|.
name|addOption
argument_list|(
name|WORKLOAD_START_DELAY_ARG
argument_list|,
literal|true
argument_list|,
literal|"Delay between launching "
operator|+
literal|"the Workload MR job and starting the audit logic replay; this is "
operator|+
literal|"used in an attempt to allow all mappers to be launched before any "
operator|+
literal|"of them start replaying. Workloads with more mappers may need a "
operator|+
literal|"longer delay to get all of the containers allocated. Human-readable "
operator|+
literal|"units accepted (e.g. 30s, 10m). (default "
operator|+
name|WorkloadDriver
operator|.
name|START_TIME_OFFSET_DEFAULT
operator|+
literal|")"
argument_list|)
expr_stmt|;
name|opts
operator|.
name|addOption
argument_list|(
name|WORKLOAD_RATE_FACTOR_ARG
argument_list|,
literal|true
argument_list|,
literal|"Rate factor "
operator|+
literal|"(multiplicative speed factor) to apply to workload replay (Default "
operator|+
name|WORKLOAD_RATE_FACTOR_DEFAULT
operator|+
literal|")"
argument_list|)
expr_stmt|;
name|opts
operator|.
name|addOption
argument_list|(
name|WORKLOAD_CONFIG_ARG
argument_list|,
literal|true
argument_list|,
literal|"Additional configurations to "
operator|+
literal|"pass only to the workload job. This can be used multiple times "
operator|+
literal|"and should be specified as a key=value pair, e.g. '-"
operator|+
name|WORKLOAD_CONFIG_ARG
operator|+
literal|" conf.one=val1 -"
operator|+
name|WORKLOAD_CONFIG_ARG
operator|+
literal|" conf.two=val2'"
argument_list|)
expr_stmt|;
block|}
comment|/**    * Helper function to print out usage.    */
DECL|method|printUsage ()
specifier|private
name|void
name|printUsage
parameter_list|()
block|{
name|HelpFormatter
name|formatter
init|=
operator|new
name|HelpFormatter
argument_list|()
decl_stmt|;
comment|// Option names are long so increasing the width is helpful
name|formatter
operator|.
name|setWidth
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|formatter
operator|.
name|printHelp
argument_list|(
literal|"Client"
argument_list|,
name|opts
argument_list|)
expr_stmt|;
block|}
comment|/**    * Parse command line options.    *    * @param args Parsed command line options    * @return Whether the init was successful to run the client    * @throws ParseException on error while parsing    * @throws IOException for other errors    */
DECL|method|init (String[] args)
specifier|public
name|boolean
name|init
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
throws|throws
name|ParseException
throws|,
name|IOException
block|{
name|CommandLineParser
name|parser
init|=
operator|new
name|GnuParser
argument_list|()
decl_stmt|;
if|if
condition|(
name|parser
operator|.
name|parse
argument_list|(
operator|new
name|Options
argument_list|()
operator|.
name|addOption
argument_list|(
literal|"h"
argument_list|,
literal|"help"
argument_list|,
literal|false
argument_list|,
literal|"Shows this message."
argument_list|)
argument_list|,
name|args
argument_list|,
literal|true
argument_list|)
operator|.
name|hasOption
argument_list|(
literal|"h"
argument_list|)
condition|)
block|{
name|printUsage
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
name|CommandLine
name|cliParser
init|=
name|parser
operator|.
name|parse
argument_list|(
name|opts
argument_list|,
name|args
argument_list|)
decl_stmt|;
name|yarnClient
operator|=
name|YarnClient
operator|.
name|createYarnClient
argument_list|()
expr_stmt|;
name|yarnClient
operator|.
name|init
argument_list|(
name|getConf
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Starting with arguments: [\"{}\"]"
argument_list|,
name|Joiner
operator|.
name|on
argument_list|(
literal|"\" \""
argument_list|)
operator|.
name|join
argument_list|(
name|args
argument_list|)
argument_list|)
expr_stmt|;
name|Path
name|fsImageDir
init|=
operator|new
name|Path
argument_list|(
name|cliParser
operator|.
name|getOptionValue
argument_list|(
name|FS_IMAGE_DIR_ARG
argument_list|,
literal|""
argument_list|)
argument_list|)
decl_stmt|;
name|versionFilePath
operator|=
operator|new
name|Path
argument_list|(
name|fsImageDir
argument_list|,
literal|"VERSION"
argument_list|)
operator|.
name|toString
argument_list|()
expr_stmt|;
if|if
condition|(
name|cliParser
operator|.
name|hasOption
argument_list|(
name|NAMENODE_SERVICERPC_ADDR_ARG
argument_list|)
condition|)
block|{
name|launchNameNode
operator|=
literal|false
expr_stmt|;
name|remoteNameNodeRpcAddress
operator|=
name|cliParser
operator|.
name|getOptionValue
argument_list|(
name|NAMENODE_SERVICERPC_ADDR_ARG
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|launchNameNode
operator|=
literal|true
expr_stmt|;
name|FileSystem
name|localFS
init|=
name|FileSystem
operator|.
name|getLocal
argument_list|(
name|getConf
argument_list|()
argument_list|)
decl_stmt|;
name|fsImageDir
operator|=
name|fsImageDir
operator|.
name|makeQualified
argument_list|(
name|localFS
operator|.
name|getUri
argument_list|()
argument_list|,
name|localFS
operator|.
name|getWorkingDirectory
argument_list|()
argument_list|)
expr_stmt|;
name|FileSystem
name|fsImageFS
init|=
name|fsImageDir
operator|.
name|getFileSystem
argument_list|(
name|getConf
argument_list|()
argument_list|)
decl_stmt|;
name|FileStatus
index|[]
name|fsImageFiles
init|=
name|fsImageFS
operator|.
name|listStatus
argument_list|(
name|fsImageDir
argument_list|,
parameter_list|(
name|path
parameter_list|)
lambda|->
name|path
operator|.
name|getName
argument_list|()
operator|.
name|matches
argument_list|(
literal|"^fsimage_(\\d)+$"
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|fsImageFiles
operator|.
name|length
operator|!=
literal|1
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Must be exactly one fsimage file present in fs_image_dir"
argument_list|)
throw|;
block|}
name|fsImagePath
operator|=
name|fsImageFiles
index|[
literal|0
index|]
operator|.
name|getPath
argument_list|()
operator|.
name|toString
argument_list|()
expr_stmt|;
name|fsImageMD5Path
operator|=
name|fsImageFiles
index|[
literal|0
index|]
operator|.
name|getPath
argument_list|()
operator|.
name|suffix
argument_list|(
literal|".md5"
argument_list|)
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|amMemory
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Invalid memory specified for "
operator|+
literal|"application master, exiting. Specified memory="
operator|+
name|amMemory
argument_list|)
throw|;
block|}
if|if
condition|(
name|amVCores
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Invalid virtual cores specified for "
operator|+
literal|"application master, exiting. Specified virtual cores="
operator|+
name|amVCores
argument_list|)
throw|;
block|}
name|this
operator|.
name|appName
operator|=
name|cliParser
operator|.
name|getOptionValue
argument_list|(
name|APPNAME_ARG
argument_list|,
name|APPNAME_DEFAULT
argument_list|)
expr_stmt|;
name|this
operator|.
name|amQueue
operator|=
name|cliParser
operator|.
name|getOptionValue
argument_list|(
name|QUEUE_ARG
argument_list|,
name|QUEUE_DEFAULT
argument_list|)
expr_stmt|;
name|this
operator|.
name|amMemory
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|cliParser
operator|.
name|getOptionValue
argument_list|(
name|MASTER_MEMORY_MB_ARG
argument_list|,
name|MASTER_MEMORY_MB_DEFAULT
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|amVCores
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|cliParser
operator|.
name|getOptionValue
argument_list|(
name|MASTER_VCORES_ARG
argument_list|,
name|MASTER_VCORES_DEFAULT
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|confPath
operator|=
name|cliParser
operator|.
name|getOptionValue
argument_list|(
name|CONF_PATH_ARG
argument_list|)
expr_stmt|;
name|this
operator|.
name|blockListPath
operator|=
name|cliParser
operator|.
name|getOptionValue
argument_list|(
name|BLOCK_LIST_PATH_ARG
argument_list|)
expr_stmt|;
if|if
condition|(
name|cliParser
operator|.
name|hasOption
argument_list|(
name|HADOOP_BINARY_PATH_ARG
argument_list|)
condition|)
block|{
name|this
operator|.
name|hadoopBinary
operator|=
name|cliParser
operator|.
name|getOptionValue
argument_list|(
name|HADOOP_BINARY_PATH_ARG
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|hadoopBinary
operator|=
name|DynoInfraUtils
operator|.
name|fetchHadoopTarball
argument_list|(
operator|new
name|File
argument_list|(
literal|"."
argument_list|)
operator|.
name|getAbsoluteFile
argument_list|()
argument_list|,
name|cliParser
operator|.
name|getOptionValue
argument_list|(
name|HADOOP_VERSION_ARG
argument_list|)
argument_list|,
name|getConf
argument_list|()
argument_list|,
name|LOG
argument_list|)
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
name|this
operator|.
name|amOptions
operator|=
name|AMOptions
operator|.
name|initFromParser
argument_list|(
name|cliParser
argument_list|)
expr_stmt|;
name|this
operator|.
name|clientTimeout
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|cliParser
operator|.
name|getOptionValue
argument_list|(
name|TIMEOUT_ARG
argument_list|,
name|TIMEOUT_DEFAULT
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|tokenFileLocation
operator|=
name|cliParser
operator|.
name|getOptionValue
argument_list|(
name|TOKEN_FILE_LOCATION_ARG
argument_list|)
expr_stmt|;
name|amOptions
operator|.
name|verify
argument_list|()
expr_stmt|;
name|Path
name|blockPath
init|=
operator|new
name|Path
argument_list|(
name|blockListPath
argument_list|)
decl_stmt|;
name|FileSystem
name|blockListFS
init|=
name|blockPath
operator|.
name|getFileSystem
argument_list|(
name|getConf
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|blockListFS
operator|.
name|getUri
argument_list|()
operator|.
name|equals
argument_list|(
name|FileSystem
operator|.
name|getLocal
argument_list|(
name|getConf
argument_list|()
argument_list|)
operator|.
name|getUri
argument_list|()
argument_list|)
operator|||
operator|!
name|blockListFS
operator|.
name|exists
argument_list|(
name|blockPath
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"block list path must already exist on remote fs!"
argument_list|)
throw|;
block|}
name|numTotalDataNodes
operator|=
name|blockListFS
operator|.
name|listStatus
argument_list|(
name|blockPath
argument_list|,
name|DynoConstants
operator|.
name|BLOCK_LIST_FILE_FILTER
argument_list|)
operator|.
name|length
expr_stmt|;
if|if
condition|(
name|cliParser
operator|.
name|hasOption
argument_list|(
name|WORKLOAD_REPLAY_ENABLE_ARG
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|cliParser
operator|.
name|hasOption
argument_list|(
name|WORKLOAD_INPUT_PATH_ARG
argument_list|)
operator|||
operator|!
name|cliParser
operator|.
name|hasOption
argument_list|(
name|WORKLOAD_START_DELAY_ARG
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"workload_replay_enable was "
operator|+
literal|"specified; must include all required workload_ parameters."
argument_list|)
throw|;
block|}
name|launchWorkloadJob
operator|=
literal|true
expr_stmt|;
name|workloadInputPath
operator|=
name|cliParser
operator|.
name|getOptionValue
argument_list|(
name|WORKLOAD_INPUT_PATH_ARG
argument_list|)
expr_stmt|;
name|workloadThreadsPerMapper
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|cliParser
operator|.
name|getOptionValue
argument_list|(
name|WORKLOAD_THREADS_PER_MAPPER_ARG
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
name|AuditReplayMapper
operator|.
name|NUM_THREADS_DEFAULT
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|workloadRateFactor
operator|=
name|Double
operator|.
name|parseDouble
argument_list|(
name|cliParser
operator|.
name|getOptionValue
argument_list|(
name|WORKLOAD_RATE_FACTOR_ARG
argument_list|,
name|WORKLOAD_RATE_FACTOR_DEFAULT
argument_list|)
argument_list|)
expr_stmt|;
name|workloadExtraConfigs
operator|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
expr_stmt|;
if|if
condition|(
name|cliParser
operator|.
name|getOptionValues
argument_list|(
name|WORKLOAD_CONFIG_ARG
argument_list|)
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|String
name|opt
range|:
name|cliParser
operator|.
name|getOptionValues
argument_list|(
name|WORKLOAD_CONFIG_ARG
argument_list|)
control|)
block|{
name|Iterator
argument_list|<
name|String
argument_list|>
name|kvPair
init|=
name|Splitter
operator|.
name|on
argument_list|(
literal|"="
argument_list|)
operator|.
name|trimResults
argument_list|()
operator|.
name|split
argument_list|(
name|opt
argument_list|)
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|workloadExtraConfigs
operator|.
name|put
argument_list|(
name|kvPair
operator|.
name|next
argument_list|()
argument_list|,
name|kvPair
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|String
name|delayString
init|=
name|cliParser
operator|.
name|getOptionValue
argument_list|(
name|WORKLOAD_START_DELAY_ARG
argument_list|,
name|WorkloadDriver
operator|.
name|START_TIME_OFFSET_DEFAULT
argument_list|)
decl_stmt|;
comment|// Store a temporary config to leverage Configuration's time duration
comment|// parsing.
name|getConf
argument_list|()
operator|.
name|set
argument_list|(
literal|"___temp___"
argument_list|,
name|delayString
argument_list|)
expr_stmt|;
name|workloadStartDelayMs
operator|=
name|getConf
argument_list|()
operator|.
name|getTimeDuration
argument_list|(
literal|"___temp___"
argument_list|,
literal|0
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Main run function for the client.    *    * @return true if application completed successfully    * @throws IOException for general issues    * @throws YarnException for issues while contacting YARN daemons    */
DECL|method|run ()
specifier|public
name|boolean
name|run
parameter_list|()
throws|throws
name|IOException
throws|,
name|YarnException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Running Client"
argument_list|)
expr_stmt|;
name|yarnClient
operator|.
name|start
argument_list|()
expr_stmt|;
name|YarnClusterMetrics
name|clusterMetrics
init|=
name|yarnClient
operator|.
name|getYarnClusterMetrics
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Got Cluster metric info from ASM, numNodeManagers={}"
argument_list|,
name|clusterMetrics
operator|.
name|getNumNodeManagers
argument_list|()
argument_list|)
expr_stmt|;
name|QueueInfo
name|queueInfo
init|=
name|yarnClient
operator|.
name|getQueueInfo
argument_list|(
name|this
operator|.
name|amQueue
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Queue info: queueName={}, queueCurrentCapacity={}, "
operator|+
literal|"queueMaxCapacity={}, queueApplicationCount={}, "
operator|+
literal|"queueChildQueueCount={}"
argument_list|,
name|queueInfo
operator|.
name|getQueueName
argument_list|()
argument_list|,
name|queueInfo
operator|.
name|getCurrentCapacity
argument_list|()
argument_list|,
name|queueInfo
operator|.
name|getMaximumCapacity
argument_list|()
argument_list|,
name|queueInfo
operator|.
name|getApplications
argument_list|()
operator|.
name|size
argument_list|()
argument_list|,
name|queueInfo
operator|.
name|getChildQueues
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
comment|// Get a new application id
name|YarnClientApplication
name|app
init|=
name|yarnClient
operator|.
name|createApplication
argument_list|()
decl_stmt|;
name|GetNewApplicationResponse
name|appResponse
init|=
name|app
operator|.
name|getNewApplicationResponse
argument_list|()
decl_stmt|;
name|long
name|maxMem
init|=
name|appResponse
operator|.
name|getMaximumResourceCapability
argument_list|()
operator|.
name|getMemorySize
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Max mem capabililty of resources in this cluster "
operator|+
name|maxMem
argument_list|)
expr_stmt|;
name|int
name|maxVCores
init|=
name|appResponse
operator|.
name|getMaximumResourceCapability
argument_list|()
operator|.
name|getVirtualCores
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Max virtual cores capabililty of resources in this cluster {}"
argument_list|,
name|maxVCores
argument_list|)
expr_stmt|;
if|if
condition|(
name|amMemory
operator|>
name|maxMem
operator|||
name|amMemory
argument_list|<
literal|0
operator|||
name|amVCores
argument_list|>
name|maxVCores
operator|||
name|amVCores
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Invalid AM memory or vcores: memory="
operator|+
name|amMemory
operator|+
literal|", vcores="
operator|+
name|amVCores
argument_list|)
throw|;
block|}
name|amOptions
operator|.
name|verify
argument_list|(
name|maxMem
argument_list|,
name|maxVCores
argument_list|)
expr_stmt|;
comment|// set the application name
name|ApplicationSubmissionContext
name|appContext
init|=
name|app
operator|.
name|getApplicationSubmissionContext
argument_list|()
decl_stmt|;
name|infraAppId
operator|=
name|appContext
operator|.
name|getApplicationId
argument_list|()
expr_stmt|;
name|appContext
operator|.
name|setApplicationName
argument_list|(
name|appName
argument_list|)
expr_stmt|;
comment|// Set up the container launch context for the application master
name|ContainerLaunchContext
name|amContainer
init|=
name|Records
operator|.
name|newRecord
argument_list|(
name|ContainerLaunchContext
operator|.
name|class
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|ApplicationAccessType
argument_list|,
name|String
argument_list|>
name|acls
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|acls
operator|.
name|put
argument_list|(
name|ApplicationAccessType
operator|.
name|VIEW_APP
argument_list|,
name|getConf
argument_list|()
operator|.
name|get
argument_list|(
name|MRJobConfig
operator|.
name|JOB_ACL_VIEW_JOB
argument_list|,
name|MRJobConfig
operator|.
name|DEFAULT_JOB_ACL_VIEW_JOB
argument_list|)
argument_list|)
expr_stmt|;
name|amContainer
operator|.
name|setApplicationACLs
argument_list|(
name|acls
argument_list|)
expr_stmt|;
name|FileSystem
name|fs
init|=
name|FileSystem
operator|.
name|get
argument_list|(
name|getConf
argument_list|()
argument_list|)
decl_stmt|;
name|fs
operator|.
name|mkdirs
argument_list|(
name|getRemoteStoragePath
argument_list|(
name|getConf
argument_list|()
argument_list|,
name|infraAppId
argument_list|)
argument_list|)
expr_stmt|;
comment|// Set the env variables to be setup in the env where the application master
comment|// will be run
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|env
init|=
name|setupRemoteResourcesGetEnv
argument_list|()
decl_stmt|;
name|amContainer
operator|.
name|setEnvironment
argument_list|(
name|env
argument_list|)
expr_stmt|;
comment|// All of the resources for both AM and NN/DNs have been put on remote
comment|// storage
comment|// Only the application master JAR is needed as a local resource for the AM
comment|// so
comment|// we explicitly add it here
name|Map
argument_list|<
name|String
argument_list|,
name|LocalResource
argument_list|>
name|localResources
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|LocalResource
name|scRsrc
init|=
name|LocalResource
operator|.
name|newInstance
argument_list|(
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|URL
operator|.
name|fromPath
argument_list|(
name|DynoConstants
operator|.
name|DYNO_DEPENDENCIES
operator|.
name|getPath
argument_list|(
name|env
argument_list|)
argument_list|)
argument_list|,
name|LocalResourceType
operator|.
name|ARCHIVE
argument_list|,
name|LocalResourceVisibility
operator|.
name|APPLICATION
argument_list|,
name|DynoConstants
operator|.
name|DYNO_DEPENDENCIES
operator|.
name|getLength
argument_list|(
name|env
argument_list|)
argument_list|,
name|DynoConstants
operator|.
name|DYNO_DEPENDENCIES
operator|.
name|getTimestamp
argument_list|(
name|env
argument_list|)
argument_list|)
decl_stmt|;
name|localResources
operator|.
name|put
argument_list|(
name|DynoConstants
operator|.
name|DYNO_DEPENDENCIES
operator|.
name|getResourcePath
argument_list|()
argument_list|,
name|scRsrc
argument_list|)
expr_stmt|;
comment|// Set local resource info into app master container launch context
name|amContainer
operator|.
name|setLocalResources
argument_list|(
name|localResources
argument_list|)
expr_stmt|;
comment|// Set the necessary command to execute the application master
name|amContainer
operator|.
name|setCommands
argument_list|(
name|getAMCommand
argument_list|()
argument_list|)
expr_stmt|;
name|Resource
name|capability
init|=
name|Records
operator|.
name|newRecord
argument_list|(
name|Resource
operator|.
name|class
argument_list|)
decl_stmt|;
name|capability
operator|.
name|setMemorySize
argument_list|(
name|amMemory
argument_list|)
expr_stmt|;
name|capability
operator|.
name|setVirtualCores
argument_list|(
name|amVCores
argument_list|)
expr_stmt|;
name|appContext
operator|.
name|setResource
argument_list|(
name|capability
argument_list|)
expr_stmt|;
comment|// Setup security tokens
if|if
condition|(
name|UserGroupInformation
operator|.
name|isSecurityEnabled
argument_list|()
condition|)
block|{
name|ByteBuffer
name|fsTokens
decl_stmt|;
if|if
condition|(
name|tokenFileLocation
operator|!=
literal|null
condition|)
block|{
name|fsTokens
operator|=
name|ByteBuffer
operator|.
name|wrap
argument_list|(
name|Files
operator|.
name|readAllBytes
argument_list|(
name|Paths
operator|.
name|get
argument_list|(
name|tokenFileLocation
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Credentials
name|credentials
init|=
operator|new
name|Credentials
argument_list|()
decl_stmt|;
name|String
name|tokenRenewer
init|=
name|getConf
argument_list|()
operator|.
name|get
argument_list|(
name|YarnConfiguration
operator|.
name|RM_PRINCIPAL
argument_list|)
decl_stmt|;
if|if
condition|(
name|tokenRenewer
operator|==
literal|null
operator|||
name|tokenRenewer
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Can't get Master Kerberos principal for the "
operator|+
literal|"RM to use as renewer"
argument_list|)
throw|;
block|}
comment|// For now, only getting tokens for the default file-system.
specifier|final
name|Token
argument_list|<
name|?
argument_list|>
index|[]
name|tokens
init|=
name|fs
operator|.
name|addDelegationTokens
argument_list|(
name|tokenRenewer
argument_list|,
name|credentials
argument_list|)
decl_stmt|;
if|if
condition|(
name|tokens
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|Token
argument_list|<
name|?
argument_list|>
name|token
range|:
name|tokens
control|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Got dt for "
operator|+
name|fs
operator|.
name|getUri
argument_list|()
operator|+
literal|"; "
operator|+
name|token
argument_list|)
expr_stmt|;
block|}
block|}
name|DataOutputBuffer
name|dob
init|=
operator|new
name|DataOutputBuffer
argument_list|()
decl_stmt|;
name|credentials
operator|.
name|writeTokenStorageToStream
argument_list|(
name|dob
argument_list|)
expr_stmt|;
name|fsTokens
operator|=
name|ByteBuffer
operator|.
name|wrap
argument_list|(
name|dob
operator|.
name|getData
argument_list|()
argument_list|,
literal|0
argument_list|,
name|dob
operator|.
name|getLength
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|amContainer
operator|.
name|setTokens
argument_list|(
name|fsTokens
argument_list|)
expr_stmt|;
block|}
name|appContext
operator|.
name|setAMContainerSpec
argument_list|(
name|amContainer
argument_list|)
expr_stmt|;
comment|// Set the queue to which this application is to be submitted in the RM
name|appContext
operator|.
name|setQueue
argument_list|(
name|amQueue
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Submitting application to RM"
argument_list|)
expr_stmt|;
name|yarnClient
operator|.
name|submitApplication
argument_list|(
name|appContext
argument_list|)
expr_stmt|;
comment|// Monitor the application
return|return
name|monitorInfraApplication
argument_list|()
return|;
block|}
comment|/**    * Set up the remote resources for the application. Upload them to remote    * storage as necessary, and set up the requisite environment variables. Does    * not set up any local resources.    *    * @return A Map representing the environment to be used for the    *         ApplicationMaster containing the information about all of the    *         remote resources.    */
DECL|method|setupRemoteResourcesGetEnv ()
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|setupRemoteResourcesGetEnv
parameter_list|()
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Set the environment for the application master"
argument_list|)
expr_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|env
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|// Copy local resources to a remote FS to prepare them for localization
comment|// by containers. We do not need to set them as local resources here as
comment|// the AM does not need them.
if|if
condition|(
name|launchNameNode
condition|)
block|{
name|setupRemoteResource
argument_list|(
name|infraAppId
argument_list|,
name|DynoConstants
operator|.
name|FS_IMAGE
argument_list|,
name|env
argument_list|,
name|fsImagePath
argument_list|)
expr_stmt|;
name|setupRemoteResource
argument_list|(
name|infraAppId
argument_list|,
name|DynoConstants
operator|.
name|FS_IMAGE_MD5
argument_list|,
name|env
argument_list|,
name|fsImageMD5Path
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|env
operator|.
name|put
argument_list|(
name|DynoConstants
operator|.
name|REMOTE_NN_RPC_ADDR_ENV
argument_list|,
name|remoteNameNodeRpcAddress
argument_list|)
expr_stmt|;
block|}
name|setupRemoteResource
argument_list|(
name|infraAppId
argument_list|,
name|DynoConstants
operator|.
name|VERSION
argument_list|,
name|env
argument_list|,
name|versionFilePath
argument_list|)
expr_stmt|;
name|setupRemoteResource
argument_list|(
name|infraAppId
argument_list|,
name|DynoConstants
operator|.
name|CONF_ZIP
argument_list|,
name|env
argument_list|,
name|confPath
argument_list|)
expr_stmt|;
name|setupRemoteResource
argument_list|(
name|infraAppId
argument_list|,
name|DynoConstants
operator|.
name|START_SCRIPT
argument_list|,
name|env
argument_list|,
name|START_SCRIPT_LOCATION
argument_list|)
expr_stmt|;
name|setupRemoteResource
argument_list|(
name|infraAppId
argument_list|,
name|DynoConstants
operator|.
name|HADOOP_BINARY
argument_list|,
name|env
argument_list|,
name|hadoopBinary
argument_list|)
expr_stmt|;
name|setupRemoteResource
argument_list|(
name|infraAppId
argument_list|,
name|DynoConstants
operator|.
name|DYNO_DEPENDENCIES
argument_list|,
name|env
argument_list|,
name|dependencyJars
argument_list|)
expr_stmt|;
name|env
operator|.
name|put
argument_list|(
name|DynoConstants
operator|.
name|BLOCK_LIST_PATH_ENV
argument_list|,
name|blockListPath
argument_list|)
expr_stmt|;
name|env
operator|.
name|put
argument_list|(
name|DynoConstants
operator|.
name|JOB_ACL_VIEW_ENV
argument_list|,
name|getConf
argument_list|()
operator|.
name|get
argument_list|(
name|MRJobConfig
operator|.
name|JOB_ACL_VIEW_JOB
argument_list|,
name|MRJobConfig
operator|.
name|DEFAULT_JOB_ACL_VIEW_JOB
argument_list|)
argument_list|)
expr_stmt|;
name|env
operator|.
name|put
argument_list|(
name|DynoConstants
operator|.
name|REMOTE_STORAGE_PATH_ENV
argument_list|,
name|getRemoteStoragePath
argument_list|(
name|getConf
argument_list|()
argument_list|,
name|infraAppId
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|env
operator|.
name|put
argument_list|(
name|Environment
operator|.
name|CLASSPATH
operator|.
name|key
argument_list|()
argument_list|,
name|getAMClassPathEnv
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|env
return|;
block|}
DECL|method|getAMClassPathEnv ()
specifier|private
name|String
name|getAMClassPathEnv
parameter_list|()
block|{
comment|// Add AppMaster.jar location to classpath
comment|// At some point we should not be required to add
comment|// the hadoop specific classpaths to the env.
comment|// It should be provided out of the box.
comment|// For now setting all required classpaths including
comment|// the classpath to "." for the application jar
name|StringBuilder
name|classPathEnv
init|=
operator|new
name|StringBuilder
argument_list|(
name|Environment
operator|.
name|CLASSPATH
operator|.
name|$
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
name|ApplicationConstants
operator|.
name|CLASS_PATH_SEPARATOR
argument_list|)
operator|.
name|append
argument_list|(
literal|"./"
argument_list|)
operator|.
name|append
argument_list|(
name|DynoConstants
operator|.
name|DYNO_DEPENDENCIES
operator|.
name|getResourcePath
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|"/*"
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|c
range|:
name|getConf
argument_list|()
operator|.
name|getStrings
argument_list|(
name|YarnConfiguration
operator|.
name|YARN_APPLICATION_CLASSPATH
argument_list|,
name|YarnConfiguration
operator|.
name|DEFAULT_YARN_APPLICATION_CLASSPATH
argument_list|)
control|)
block|{
name|classPathEnv
operator|.
name|append
argument_list|(
name|ApplicationConstants
operator|.
name|CLASS_PATH_SEPARATOR
argument_list|)
expr_stmt|;
name|classPathEnv
operator|.
name|append
argument_list|(
name|c
operator|.
name|trim
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|classPathEnv
operator|.
name|append
argument_list|(
name|ApplicationConstants
operator|.
name|CLASS_PATH_SEPARATOR
argument_list|)
operator|.
name|append
argument_list|(
literal|"./log4j.properties"
argument_list|)
expr_stmt|;
comment|// add the runtime classpath needed for tests to work
if|if
condition|(
name|getConf
argument_list|()
operator|.
name|getBoolean
argument_list|(
name|YarnConfiguration
operator|.
name|IS_MINI_YARN_CLUSTER
argument_list|,
literal|false
argument_list|)
condition|)
block|{
name|classPathEnv
operator|.
name|append
argument_list|(
name|ApplicationConstants
operator|.
name|CLASS_PATH_SEPARATOR
argument_list|)
expr_stmt|;
name|classPathEnv
operator|.
name|append
argument_list|(
name|System
operator|.
name|getProperty
argument_list|(
literal|"java.class.path"
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|classPathEnv
operator|.
name|toString
argument_list|()
return|;
block|}
DECL|method|getAMCommand ()
specifier|private
name|List
argument_list|<
name|String
argument_list|>
name|getAMCommand
parameter_list|()
block|{
name|List
argument_list|<
name|String
argument_list|>
name|vargs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
comment|// Set java executable command
name|vargs
operator|.
name|add
argument_list|(
name|Environment
operator|.
name|JAVA_HOME
operator|.
name|$
argument_list|()
operator|+
literal|"/bin/java"
argument_list|)
expr_stmt|;
comment|// Set Xmx based on am memory size
name|long
name|appMasterHeapSize
init|=
name|Math
operator|.
name|round
argument_list|(
name|amMemory
operator|*
literal|0.85
argument_list|)
decl_stmt|;
name|vargs
operator|.
name|add
argument_list|(
literal|"-Xmx"
operator|+
name|appMasterHeapSize
operator|+
literal|"m"
argument_list|)
expr_stmt|;
comment|// Set class name
name|vargs
operator|.
name|add
argument_list|(
name|ApplicationMaster
operator|.
name|class
operator|.
name|getCanonicalName
argument_list|()
argument_list|)
expr_stmt|;
comment|// Set params for Application Master
name|amOptions
operator|.
name|addToVargs
argument_list|(
name|vargs
argument_list|)
expr_stmt|;
name|vargs
operator|.
name|add
argument_list|(
literal|"1>"
operator|+
name|ApplicationConstants
operator|.
name|LOG_DIR_EXPANSION_VAR
operator|+
literal|"/stdout"
argument_list|)
expr_stmt|;
name|vargs
operator|.
name|add
argument_list|(
literal|"2>"
operator|+
name|ApplicationConstants
operator|.
name|LOG_DIR_EXPANSION_VAR
operator|+
literal|"/stderr"
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Completed setting up app master command: "
operator|+
name|vargs
argument_list|)
expr_stmt|;
return|return
name|Lists
operator|.
name|newArrayList
argument_list|(
name|Joiner
operator|.
name|on
argument_list|(
literal|" "
argument_list|)
operator|.
name|join
argument_list|(
name|vargs
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Upload a local resource to HDFS, or if it is nonlocal, just set environment    * appropriately. The location, length and timestamp information is added to    * AM container's environment, so it can launch containers later with the    * correct resource settings.    */
DECL|method|setupRemoteResource (ApplicationId appId, DynoResource resource, Map<String, String> env, String... srcPaths)
specifier|private
name|void
name|setupRemoteResource
parameter_list|(
name|ApplicationId
name|appId
parameter_list|,
name|DynoResource
name|resource
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|env
parameter_list|,
name|String
modifier|...
name|srcPaths
parameter_list|)
throws|throws
name|IOException
block|{
name|FileStatus
name|remoteFileStatus
decl_stmt|;
name|Path
name|dstPath
decl_stmt|;
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|srcPaths
operator|.
name|length
operator|>
literal|0
argument_list|,
literal|"Must supply at least one source path"
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|resource
operator|.
name|getType
argument_list|()
operator|==
name|LocalResourceType
operator|.
name|ARCHIVE
operator|||
name|srcPaths
operator|.
name|length
operator|==
literal|1
argument_list|,
literal|"Can only specify multiple source paths if using an ARCHIVE type"
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|URI
argument_list|>
name|srcURIs
init|=
name|Arrays
operator|.
name|stream
argument_list|(
name|srcPaths
argument_list|)
operator|.
name|map
argument_list|(
name|URI
operator|::
name|create
argument_list|)
operator|.
name|collect
argument_list|(
name|Collectors
operator|.
name|toList
argument_list|()
argument_list|)
decl_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|srcSchemes
init|=
name|srcURIs
operator|.
name|stream
argument_list|()
operator|.
name|map
argument_list|(
name|URI
operator|::
name|getScheme
argument_list|)
operator|.
name|collect
argument_list|(
name|Collectors
operator|.
name|toSet
argument_list|()
argument_list|)
decl_stmt|;
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|srcSchemes
operator|.
name|size
argument_list|()
operator|==
literal|1
argument_list|,
literal|"All source paths must have the same scheme"
argument_list|)
expr_stmt|;
name|String
name|srcScheme
init|=
name|srcSchemes
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
decl_stmt|;
name|String
name|srcPathString
init|=
literal|"["
operator|+
name|Joiner
operator|.
name|on
argument_list|(
literal|","
argument_list|)
operator|.
name|join
argument_list|(
name|srcPaths
argument_list|)
operator|+
literal|"]"
decl_stmt|;
if|if
condition|(
name|srcScheme
operator|==
literal|null
operator|||
name|srcScheme
operator|.
name|equals
argument_list|(
name|FileSystem
operator|.
name|getLocal
argument_list|(
name|getConf
argument_list|()
argument_list|)
operator|.
name|getScheme
argument_list|()
argument_list|)
operator|||
name|srcScheme
operator|.
name|equals
argument_list|(
literal|"jar"
argument_list|)
condition|)
block|{
comment|// Need to upload this resource to remote storage
name|List
argument_list|<
name|File
argument_list|>
name|srcFiles
init|=
name|srcURIs
operator|.
name|stream
argument_list|()
operator|.
name|map
argument_list|(
name|URI
operator|::
name|getSchemeSpecificPart
argument_list|)
operator|.
name|map
argument_list|(
name|File
operator|::
operator|new
argument_list|)
operator|.
name|collect
argument_list|(
name|Collectors
operator|.
name|toList
argument_list|()
argument_list|)
decl_stmt|;
name|Path
name|dstPathBase
init|=
name|getRemoteStoragePath
argument_list|(
name|getConf
argument_list|()
argument_list|,
name|appId
argument_list|)
decl_stmt|;
name|boolean
name|shouldArchive
init|=
name|srcFiles
operator|.
name|size
argument_list|()
operator|>
literal|1
operator|||
name|srcFiles
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|isDirectory
argument_list|()
operator|||
operator|(
name|resource
operator|.
name|getType
argument_list|()
operator|==
name|LocalResourceType
operator|.
name|ARCHIVE
operator|&&
name|Arrays
operator|.
name|stream
argument_list|(
name|ARCHIVE_FILE_TYPES
argument_list|)
operator|.
name|noneMatch
argument_list|(
name|suffix
lambda|->
name|srcFiles
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getName
argument_list|()
operator|.
name|endsWith
argument_list|(
name|suffix
argument_list|)
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|shouldArchive
condition|)
block|{
if|if
condition|(
literal|"jar"
operator|.
name|equals
argument_list|(
name|srcScheme
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Resources in JARs "
operator|+
literal|"can't be zipped; resource %s is ARCHIVE and src is: %s"
argument_list|,
name|resource
operator|.
name|getResourcePath
argument_list|()
argument_list|,
name|srcPathString
argument_list|)
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|resource
operator|.
name|getType
argument_list|()
operator|!=
name|LocalResourceType
operator|.
name|ARCHIVE
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Resource type is %s but srcPaths were: %s"
argument_list|,
name|resource
operator|.
name|getType
argument_list|()
argument_list|,
name|srcPathString
argument_list|)
argument_list|)
throw|;
block|}
name|dstPath
operator|=
operator|new
name|Path
argument_list|(
name|dstPathBase
argument_list|,
name|resource
operator|.
name|getResourcePath
argument_list|()
argument_list|)
operator|.
name|suffix
argument_list|(
literal|".zip"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dstPath
operator|=
operator|new
name|Path
argument_list|(
name|dstPathBase
argument_list|,
name|srcFiles
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|FileSystem
name|remoteFS
init|=
name|dstPath
operator|.
name|getFileSystem
argument_list|(
name|getConf
argument_list|()
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Uploading resource "
operator|+
name|resource
operator|+
literal|" from "
operator|+
name|srcPathString
operator|+
literal|" to "
operator|+
name|dstPath
argument_list|)
expr_stmt|;
try|try
init|(
name|OutputStream
name|outputStream
init|=
name|remoteFS
operator|.
name|create
argument_list|(
name|dstPath
argument_list|,
literal|true
argument_list|)
init|)
block|{
if|if
condition|(
literal|"jar"
operator|.
name|equals
argument_list|(
name|srcScheme
argument_list|)
condition|)
block|{
try|try
init|(
name|InputStream
name|inputStream
init|=
operator|new
name|URL
argument_list|(
name|srcPaths
index|[
literal|0
index|]
argument_list|)
operator|.
name|openStream
argument_list|()
init|)
block|{
name|IOUtils
operator|.
name|copyBytes
argument_list|(
name|inputStream
argument_list|,
name|outputStream
argument_list|,
name|getConf
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|shouldArchive
condition|)
block|{
name|List
argument_list|<
name|File
argument_list|>
name|filesToZip
decl_stmt|;
if|if
condition|(
name|srcFiles
operator|.
name|size
argument_list|()
operator|==
literal|1
operator|&&
name|srcFiles
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
name|File
index|[]
name|childFiles
init|=
name|srcFiles
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|listFiles
argument_list|()
decl_stmt|;
if|if
condition|(
name|childFiles
operator|==
literal|null
operator|||
name|childFiles
operator|.
name|length
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Specified a directory to archive with no contents"
argument_list|)
throw|;
block|}
name|filesToZip
operator|=
name|Lists
operator|.
name|newArrayList
argument_list|(
name|childFiles
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|filesToZip
operator|=
name|srcFiles
expr_stmt|;
block|}
name|ZipOutputStream
name|zout
init|=
operator|new
name|ZipOutputStream
argument_list|(
name|outputStream
argument_list|)
decl_stmt|;
for|for
control|(
name|File
name|fileToZip
range|:
name|filesToZip
control|)
block|{
name|addFileToZipRecursively
argument_list|(
name|fileToZip
operator|.
name|getParentFile
argument_list|()
argument_list|,
name|fileToZip
argument_list|,
name|zout
argument_list|)
expr_stmt|;
block|}
name|zout
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
else|else
block|{
try|try
init|(
name|InputStream
name|inputStream
init|=
operator|new
name|FileInputStream
argument_list|(
name|srcFiles
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
init|)
block|{
name|IOUtils
operator|.
name|copyBytes
argument_list|(
name|inputStream
argument_list|,
name|outputStream
argument_list|,
name|getConf
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|remoteFileStatus
operator|=
name|remoteFS
operator|.
name|getFileStatus
argument_list|(
name|dstPath
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|srcPaths
operator|.
name|length
operator|>
literal|1
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"If resource is on remote, must be "
operator|+
literal|"a single file: "
operator|+
name|srcPathString
argument_list|)
throw|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Using resource {} directly from current location: {}"
argument_list|,
name|resource
argument_list|,
name|srcPaths
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|dstPath
operator|=
operator|new
name|Path
argument_list|(
name|srcPaths
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|// non-local file system; we can just use it directly from where it is
name|remoteFileStatus
operator|=
name|FileSystem
operator|.
name|get
argument_list|(
name|dstPath
operator|.
name|toUri
argument_list|()
argument_list|,
name|getConf
argument_list|()
argument_list|)
operator|.
name|getFileStatus
argument_list|(
name|dstPath
argument_list|)
expr_stmt|;
if|if
condition|(
name|remoteFileStatus
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"If resource is on remote "
operator|+
literal|"filesystem, must be a file: "
operator|+
name|srcPaths
index|[
literal|0
index|]
argument_list|)
throw|;
block|}
block|}
name|env
operator|.
name|put
argument_list|(
name|resource
operator|.
name|getLocationEnvVar
argument_list|()
argument_list|,
name|dstPath
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|env
operator|.
name|put
argument_list|(
name|resource
operator|.
name|getTimestampEnvVar
argument_list|()
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
name|remoteFileStatus
operator|.
name|getModificationTime
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|env
operator|.
name|put
argument_list|(
name|resource
operator|.
name|getLengthEnvVar
argument_list|()
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
name|remoteFileStatus
operator|.
name|getLen
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Get the directory on the default FS which will be used for storing files    * relevant to this Dynamometer application. This is inside of the    * {@value DynoConstants#DYNAMOMETER_STORAGE_DIR} directory within the    * submitter's home directory.    *    * @param conf Configuration for this application.    * @param appId This application's ID.    * @return Fully qualified path on the default FS.    */
DECL|method|getRemoteStoragePath (Configuration conf, ApplicationId appId)
specifier|private
specifier|static
name|Path
name|getRemoteStoragePath
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|ApplicationId
name|appId
parameter_list|)
throws|throws
name|IOException
block|{
name|FileSystem
name|remoteFS
init|=
name|FileSystem
operator|.
name|get
argument_list|(
name|conf
argument_list|)
decl_stmt|;
return|return
name|remoteFS
operator|.
name|makeQualified
argument_list|(
operator|new
name|Path
argument_list|(
name|remoteFS
operator|.
name|getHomeDirectory
argument_list|()
argument_list|,
name|DynoConstants
operator|.
name|DYNAMOMETER_STORAGE_DIR
operator|+
literal|"/"
operator|+
name|appId
argument_list|)
argument_list|)
return|;
block|}
DECL|method|addFileToZipRecursively (File root, File file, ZipOutputStream out)
specifier|private
name|void
name|addFileToZipRecursively
parameter_list|(
name|File
name|root
parameter_list|,
name|File
name|file
parameter_list|,
name|ZipOutputStream
name|out
parameter_list|)
throws|throws
name|IOException
block|{
name|File
index|[]
name|files
init|=
name|file
operator|.
name|listFiles
argument_list|()
decl_stmt|;
if|if
condition|(
name|files
operator|==
literal|null
condition|)
block|{
comment|// Not a directory
name|String
name|relativePath
init|=
name|file
operator|.
name|getAbsolutePath
argument_list|()
operator|.
name|substring
argument_list|(
name|root
operator|.
name|getAbsolutePath
argument_list|()
operator|.
name|length
argument_list|()
operator|+
literal|1
argument_list|)
decl_stmt|;
try|try
block|{
try|try
init|(
name|FileInputStream
name|in
init|=
operator|new
name|FileInputStream
argument_list|(
name|file
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
init|)
block|{
name|out
operator|.
name|putNextEntry
argument_list|(
operator|new
name|ZipEntry
argument_list|(
name|relativePath
argument_list|)
argument_list|)
expr_stmt|;
name|IOUtils
operator|.
name|copyBytes
argument_list|(
name|in
argument_list|,
name|out
argument_list|,
name|getConf
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|out
operator|.
name|closeEntry
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|fnfe
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Skipping file; it is a symlink with a nonexistent target: {}"
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|File
name|containedFile
range|:
name|files
control|)
block|{
name|addFileToZipRecursively
argument_list|(
name|root
argument_list|,
name|containedFile
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Monitor the submitted application for completion. Kill application if time    * expires.    *    * @return true if application completed successfully    */
DECL|method|monitorInfraApplication ()
specifier|private
name|boolean
name|monitorInfraApplication
parameter_list|()
throws|throws
name|YarnException
throws|,
name|IOException
block|{
name|boolean
name|loggedApplicationInfo
init|=
literal|false
decl_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
name|Thread
name|namenodeMonitoringThread
init|=
operator|new
name|Thread
argument_list|(
parameter_list|()
lambda|->
block|{
name|Supplier
argument_list|<
name|Boolean
argument_list|>
name|exitCritera
init|=
parameter_list|()
lambda|->
name|isCompleted
argument_list|(
name|infraAppState
argument_list|)
decl_stmt|;
name|Optional
argument_list|<
name|Properties
argument_list|>
name|namenodeProperties
init|=
name|Optional
operator|.
name|empty
argument_list|()
decl_stmt|;
while|while
condition|(
operator|!
name|exitCritera
operator|.
name|get
argument_list|()
condition|)
block|{
try|try
block|{
if|if
condition|(
operator|!
name|namenodeProperties
operator|.
name|isPresent
argument_list|()
condition|)
block|{
name|namenodeProperties
operator|=
name|DynoInfraUtils
operator|.
name|waitForAndGetNameNodeProperties
argument_list|(
name|exitCritera
argument_list|,
name|getConf
argument_list|()
argument_list|,
name|getNameNodeInfoPath
argument_list|()
argument_list|,
name|LOG
argument_list|)
expr_stmt|;
if|if
condition|(
name|namenodeProperties
operator|.
name|isPresent
argument_list|()
condition|)
block|{
name|Properties
name|props
init|=
name|namenodeProperties
operator|.
name|get
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"NameNode can be reached via HDFS at: {}"
argument_list|,
name|DynoInfraUtils
operator|.
name|getNameNodeHdfsUri
argument_list|(
name|props
argument_list|)
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"NameNode web UI available at: {}"
argument_list|,
name|DynoInfraUtils
operator|.
name|getNameNodeWebUri
argument_list|(
name|props
argument_list|)
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"NameNode can be tracked at: {}"
argument_list|,
name|DynoInfraUtils
operator|.
name|getNameNodeTrackingUri
argument_list|(
name|props
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Only happens if we should be shutting down
break|break;
block|}
block|}
name|DynoInfraUtils
operator|.
name|waitForNameNodeStartup
argument_list|(
name|namenodeProperties
operator|.
name|get
argument_list|()
argument_list|,
name|exitCritera
argument_list|,
name|LOG
argument_list|)
expr_stmt|;
name|DynoInfraUtils
operator|.
name|waitForNameNodeReadiness
argument_list|(
name|namenodeProperties
operator|.
name|get
argument_list|()
argument_list|,
name|numTotalDataNodes
argument_list|,
literal|false
argument_list|,
name|exitCritera
argument_list|,
name|getConf
argument_list|()
argument_list|,
name|LOG
argument_list|)
expr_stmt|;
break|break;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unexpected exception while waiting for NameNode readiness"
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
return|return;
block|}
block|}
if|if
condition|(
operator|!
name|isCompleted
argument_list|(
name|infraAppState
argument_list|)
operator|&&
name|launchWorkloadJob
condition|)
block|{
name|launchAndMonitorWorkloadDriver
argument_list|(
name|namenodeProperties
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
decl_stmt|;
if|if
condition|(
name|launchNameNode
condition|)
block|{
name|namenodeMonitoringThread
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
while|while
condition|(
literal|true
condition|)
block|{
comment|// Check app status every 1 second.
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Thread sleep in monitoring loop interrupted"
argument_list|)
expr_stmt|;
block|}
comment|// Get application report for the appId we are interested in
name|ApplicationReport
name|report
init|=
name|yarnClient
operator|.
name|getApplicationReport
argument_list|(
name|infraAppId
argument_list|)
decl_stmt|;
if|if
condition|(
name|report
operator|.
name|getTrackingUrl
argument_list|()
operator|!=
literal|null
operator|&&
operator|!
name|loggedApplicationInfo
condition|)
block|{
name|loggedApplicationInfo
operator|=
literal|true
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Track the application at: "
operator|+
name|report
operator|.
name|getTrackingUrl
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Kill the application using: yarn application -kill "
operator|+
name|report
operator|.
name|getApplicationId
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Got application report from ASM for: appId={}, "
operator|+
literal|"clientToAMToken={}, appDiagnostics={}, appMasterHost={}, "
operator|+
literal|"appQueue={}, appMasterRpcPort={}, appStartTime={}, "
operator|+
literal|"yarnAppState={}, distributedFinalState={}, appTrackingUrl={}, "
operator|+
literal|"appUser={}"
argument_list|,
name|infraAppId
operator|.
name|getId
argument_list|()
argument_list|,
name|report
operator|.
name|getClientToAMToken
argument_list|()
argument_list|,
name|report
operator|.
name|getDiagnostics
argument_list|()
argument_list|,
name|report
operator|.
name|getHost
argument_list|()
argument_list|,
name|report
operator|.
name|getQueue
argument_list|()
argument_list|,
name|report
operator|.
name|getRpcPort
argument_list|()
argument_list|,
name|report
operator|.
name|getStartTime
argument_list|()
argument_list|,
name|report
operator|.
name|getYarnApplicationState
argument_list|()
argument_list|,
name|report
operator|.
name|getFinalApplicationStatus
argument_list|()
argument_list|,
name|report
operator|.
name|getTrackingUrl
argument_list|()
argument_list|,
name|report
operator|.
name|getUser
argument_list|()
argument_list|)
expr_stmt|;
name|infraAppState
operator|=
name|report
operator|.
name|getYarnApplicationState
argument_list|()
expr_stmt|;
if|if
condition|(
name|infraAppState
operator|==
name|YarnApplicationState
operator|.
name|KILLED
condition|)
block|{
if|if
condition|(
operator|!
name|launchWorkloadJob
condition|)
block|{
name|success
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|workloadJob
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Infra app was killed before workload job was launched."
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|workloadJob
operator|.
name|isComplete
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Infra app was killed before workload job completed."
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|workloadJob
operator|.
name|isSuccessful
argument_list|()
condition|)
block|{
name|success
operator|=
literal|true
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Infra app was killed; exiting from client."
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|infraAppState
operator|==
name|YarnApplicationState
operator|.
name|FINISHED
operator|||
name|infraAppState
operator|==
name|YarnApplicationState
operator|.
name|FAILED
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Infra app exited unexpectedly. YarnState="
operator|+
name|infraAppState
operator|.
name|toString
argument_list|()
operator|+
literal|". Exiting from client."
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|clientTimeout
operator|!=
operator|-
literal|1
operator|)
operator|&&
operator|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|>
operator|(
name|clientStartTime
operator|+
name|clientTimeout
operator|)
operator|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Reached client specified timeout of {} ms for application. "
operator|+
literal|"Killing application"
argument_list|,
name|clientTimeout
argument_list|)
expr_stmt|;
name|attemptCleanup
argument_list|()
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|isCompleted
argument_list|(
name|workloadAppState
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Killing infrastructure app"
argument_list|)
expr_stmt|;
try|try
block|{
name|forceKillApplication
argument_list|(
name|infraAppId
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|YarnException
decl||
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Exception encountered while killing infra app"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|launchNameNode
condition|)
block|{
try|try
block|{
name|namenodeMonitoringThread
operator|.
name|interrupt
argument_list|()
expr_stmt|;
name|namenodeMonitoringThread
operator|.
name|join
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Interrupted while joining workload job thread; "
operator|+
literal|"continuing to cleanup."
argument_list|)
expr_stmt|;
block|}
block|}
name|attemptCleanup
argument_list|()
expr_stmt|;
return|return
name|success
return|;
block|}
comment|/**    * Return the path to the property file containing information about the    * launched NameNode.    */
annotation|@
name|VisibleForTesting
DECL|method|getNameNodeInfoPath ()
name|Path
name|getNameNodeInfoPath
parameter_list|()
throws|throws
name|IOException
block|{
return|return
operator|new
name|Path
argument_list|(
name|getRemoteStoragePath
argument_list|(
name|getConf
argument_list|()
argument_list|,
name|infraAppId
argument_list|)
argument_list|,
name|DynoConstants
operator|.
name|NN_INFO_FILE_NAME
argument_list|)
return|;
block|}
comment|/**    * Launch the workload driver ({@link WorkloadDriver}) and monitor the job.    * Waits for the launched job to complete.    *    * @param nameNodeProperties The set of properties with information about the    *                           launched NameNode.    */
DECL|method|launchAndMonitorWorkloadDriver (Properties nameNodeProperties)
specifier|private
name|void
name|launchAndMonitorWorkloadDriver
parameter_list|(
name|Properties
name|nameNodeProperties
parameter_list|)
block|{
name|URI
name|nameNodeURI
init|=
name|DynoInfraUtils
operator|.
name|getNameNodeHdfsUri
argument_list|(
name|nameNodeProperties
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Launching workload job using input path: "
operator|+
name|workloadInputPath
argument_list|)
expr_stmt|;
try|try
block|{
name|long
name|workloadStartTime
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|+
name|workloadStartDelayMs
decl_stmt|;
name|Configuration
name|workloadConf
init|=
operator|new
name|Configuration
argument_list|(
name|getConf
argument_list|()
argument_list|)
decl_stmt|;
name|workloadConf
operator|.
name|set
argument_list|(
name|AuditReplayMapper
operator|.
name|INPUT_PATH_KEY
argument_list|,
name|workloadInputPath
argument_list|)
expr_stmt|;
name|workloadConf
operator|.
name|setInt
argument_list|(
name|AuditReplayMapper
operator|.
name|NUM_THREADS_KEY
argument_list|,
name|workloadThreadsPerMapper
argument_list|)
expr_stmt|;
name|workloadConf
operator|.
name|setDouble
argument_list|(
name|AuditReplayMapper
operator|.
name|RATE_FACTOR_KEY
argument_list|,
name|workloadRateFactor
argument_list|)
expr_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|configPair
range|:
name|workloadExtraConfigs
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|workloadConf
operator|.
name|set
argument_list|(
name|configPair
operator|.
name|getKey
argument_list|()
argument_list|,
name|configPair
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|workloadJob
operator|=
name|WorkloadDriver
operator|.
name|getJobForSubmission
argument_list|(
name|workloadConf
argument_list|,
name|nameNodeURI
operator|.
name|toString
argument_list|()
argument_list|,
name|workloadStartTime
argument_list|,
name|AuditReplayMapper
operator|.
name|class
argument_list|)
expr_stmt|;
name|workloadJob
operator|.
name|submit
argument_list|()
expr_stmt|;
while|while
condition|(
operator|!
name|isCompleted
argument_list|(
name|infraAppState
argument_list|)
operator|&&
operator|!
name|isCompleted
argument_list|(
name|workloadAppState
argument_list|)
condition|)
block|{
name|workloadJob
operator|.
name|monitorAndPrintJob
argument_list|()
expr_stmt|;
name|Thread
operator|.
name|sleep
argument_list|(
literal|5000
argument_list|)
expr_stmt|;
name|workloadAppState
operator|=
name|workloadJob
operator|.
name|getJobState
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|isCompleted
argument_list|(
name|workloadAppState
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Workload job completed successfully!"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Workload job failed."
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Exception encountered while running workload job"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Best-effort attempt to clean up any remaining applications (infrastructure    * or workload).    */
DECL|method|attemptCleanup ()
specifier|public
name|void
name|attemptCleanup
parameter_list|()
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Attempting to clean up remaining running applications."
argument_list|)
expr_stmt|;
if|if
condition|(
name|workloadJob
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|workloadAppState
operator|=
name|workloadJob
operator|.
name|getJobState
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Unable to fetch completion status of workload job. Will "
operator|+
literal|"proceed to attempt to kill it."
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|isCompleted
argument_list|(
name|workloadAppState
argument_list|)
condition|)
block|{
try|try
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Attempting to kill workload app: {}"
argument_list|,
name|workloadJob
operator|.
name|getJobID
argument_list|()
argument_list|)
expr_stmt|;
name|workloadJob
operator|.
name|killJob
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Killed workload app"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to kill workload app ({})"
argument_list|,
name|workloadJob
operator|.
name|getJobID
argument_list|()
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|infraAppId
operator|!=
literal|null
operator|&&
operator|!
name|isCompleted
argument_list|(
name|infraAppState
argument_list|)
condition|)
block|{
try|try
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Attempting to kill infrastructure app: "
operator|+
name|infraAppId
argument_list|)
expr_stmt|;
name|forceKillApplication
argument_list|(
name|infraAppId
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Killed infrastructure app"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|YarnException
decl||
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to kill infrastructure app ({})"
argument_list|,
name|infraAppId
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Check if the input state represents completion.    */
DECL|method|isCompleted (JobStatus.State state)
specifier|private
specifier|static
name|boolean
name|isCompleted
parameter_list|(
name|JobStatus
operator|.
name|State
name|state
parameter_list|)
block|{
return|return
name|state
operator|==
name|JobStatus
operator|.
name|State
operator|.
name|SUCCEEDED
operator|||
name|state
operator|==
name|JobStatus
operator|.
name|State
operator|.
name|FAILED
operator|||
name|state
operator|==
name|JobStatus
operator|.
name|State
operator|.
name|KILLED
return|;
block|}
comment|/**    * Check if the input state represents completion.    */
DECL|method|isCompleted (YarnApplicationState state)
specifier|private
specifier|static
name|boolean
name|isCompleted
parameter_list|(
name|YarnApplicationState
name|state
parameter_list|)
block|{
return|return
name|state
operator|==
name|YarnApplicationState
operator|.
name|FINISHED
operator|||
name|state
operator|==
name|YarnApplicationState
operator|.
name|FAILED
operator|||
name|state
operator|==
name|YarnApplicationState
operator|.
name|KILLED
return|;
block|}
comment|/**    * Kill a submitted application by sending a call to the AM.    *    * @param appId Application Id to be killed.    */
DECL|method|forceKillApplication (ApplicationId appId)
specifier|private
name|void
name|forceKillApplication
parameter_list|(
name|ApplicationId
name|appId
parameter_list|)
throws|throws
name|YarnException
throws|,
name|IOException
block|{
comment|// Response can be ignored as it is non-null on success or
comment|// throws an exception in case of failures
name|yarnClient
operator|.
name|killApplication
argument_list|(
name|appId
argument_list|)
expr_stmt|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|getWorkloadJob ()
name|Job
name|getWorkloadJob
parameter_list|()
block|{
return|return
name|workloadJob
return|;
block|}
block|}
end_class

end_unit

