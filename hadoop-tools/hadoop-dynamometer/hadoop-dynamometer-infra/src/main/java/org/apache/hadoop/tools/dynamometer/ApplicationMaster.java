begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.tools.dynamometer
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|tools
operator|.
name|dynamometer
package|;
end_package

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Joiner
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|primitives
operator|.
name|Ints
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|ByteBuffer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Optional
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Properties
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Random
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|Supplier
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|cli
operator|.
name|CommandLine
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|cli
operator|.
name|GnuParser
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|cli
operator|.
name|HelpFormatter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|cli
operator|.
name|Options
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|cli
operator|.
name|ParseException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang3
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceStability
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|DataOutputBuffer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|net
operator|.
name|NetUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|Credentials
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|UserGroupInformation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|ApplicationConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|ApplicationConstants
operator|.
name|Environment
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|ContainerManagementProtocol
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ApplicationAccessType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ApplicationAttemptId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|Container
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ContainerId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ContainerLaunchContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ContainerState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ContainerStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|FinalApplicationStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|LocalResource
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|LocalResourceType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|LocalResourceVisibility
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|NodeReport
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|Priority
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|Resource
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|URL
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|UpdatedContainer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|client
operator|.
name|api
operator|.
name|AMRMClient
operator|.
name|ContainerRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|client
operator|.
name|api
operator|.
name|async
operator|.
name|AMRMClientAsync
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|client
operator|.
name|api
operator|.
name|async
operator|.
name|NMClientAsync
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|client
operator|.
name|api
operator|.
name|async
operator|.
name|impl
operator|.
name|NMClientAsyncImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|conf
operator|.
name|YarnConfiguration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|exceptions
operator|.
name|YarnException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|security
operator|.
name|AMRMTokenIdentifier
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|util
operator|.
name|Records
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_comment
comment|/**  * The ApplicationMaster for Dynamometer. This will launch DataNodes in YARN  * containers. If the RPC address of a NameNode is specified, it will configure  * the DataNodes to talk to that NameNode. Else, a NameNode will be launched as  * part of this YARN application. This does not implement any retry/failure  * handling.  * TODO: Add proper retry/failure handling  *  *<p/>The AM will persist until it has run for a period of time equal to the  * timeout specified or until the application is killed.  *  *<p/>If the NameNode is launched internally, it will upload some information  * onto the remote HDFS instance (i.e., the default FileSystem) about its  * hostname and ports. This is in the location determined by the  * {@link DynoConstants#DYNAMOMETER_STORAGE_DIR} and  * {@link DynoConstants#NN_INFO_FILE_NAME} constants and is in the  * {@link Properties} file format. This is consumed by this AM as well as the  * {@link Client} to determine how to contact the NameNode.  *  *<p/>Information about the location of the DataNodes is logged by the AM.  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Public
annotation|@
name|InterfaceStability
operator|.
name|Unstable
DECL|class|ApplicationMaster
specifier|public
class|class
name|ApplicationMaster
block|{
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|ApplicationMaster
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|RAND
specifier|private
specifier|static
specifier|final
name|Random
name|RAND
init|=
operator|new
name|Random
argument_list|()
decl_stmt|;
comment|// Configuration
DECL|field|conf
specifier|private
name|Configuration
name|conf
decl_stmt|;
comment|// Handle to communicate with the Resource Manager
DECL|field|amRMClient
specifier|private
name|AMRMClientAsync
argument_list|<
name|ContainerRequest
argument_list|>
name|amRMClient
decl_stmt|;
comment|// Handle to communicate with the Node Manager
DECL|field|nmClientAsync
specifier|private
name|NMClientAsync
name|nmClientAsync
decl_stmt|;
comment|// Listen to process the response from the Node Manager
DECL|field|containerListener
specifier|private
name|NMCallbackHandler
name|containerListener
decl_stmt|;
comment|// The collection of options passed in via the Client
DECL|field|amOptions
specifier|private
name|AMOptions
name|amOptions
decl_stmt|;
DECL|field|blockListFiles
specifier|private
name|List
argument_list|<
name|LocalResource
argument_list|>
name|blockListFiles
decl_stmt|;
DECL|field|numTotalDataNodes
specifier|private
name|int
name|numTotalDataNodes
decl_stmt|;
DECL|field|numTotalDataNodeContainers
specifier|private
name|int
name|numTotalDataNodeContainers
decl_stmt|;
comment|// Counter for completed datanodes (complete denotes successful or failed )
DECL|field|numCompletedDataNodeContainers
specifier|private
name|AtomicInteger
name|numCompletedDataNodeContainers
init|=
operator|new
name|AtomicInteger
argument_list|()
decl_stmt|;
comment|// Allocated datanode count so that we know how many datanodes has the RM
comment|// allocated to us
DECL|field|numAllocatedDataNodeContainers
specifier|private
name|AtomicInteger
name|numAllocatedDataNodeContainers
init|=
operator|new
name|AtomicInteger
argument_list|()
decl_stmt|;
comment|// Count of failed datanodes
DECL|field|numFailedDataNodeContainers
specifier|private
name|AtomicInteger
name|numFailedDataNodeContainers
init|=
operator|new
name|AtomicInteger
argument_list|()
decl_stmt|;
comment|// True iff the application has completed and is ready for cleanup
comment|// Once true, will never be false. This variable should not be accessed
comment|// directly but rather through the isComplete, waitForCompletion, and
comment|// markCompleted methods.
DECL|field|completed
specifier|private
name|boolean
name|completed
init|=
literal|false
decl_stmt|;
DECL|field|completionLock
specifier|private
specifier|final
name|Object
name|completionLock
init|=
operator|new
name|Object
argument_list|()
decl_stmt|;
DECL|field|allTokens
specifier|private
name|ByteBuffer
name|allTokens
decl_stmt|;
comment|// Launch threads
DECL|field|launchThreads
specifier|private
name|List
argument_list|<
name|Thread
argument_list|>
name|launchThreads
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
comment|// True iff this AM should launch and manage a Namanode
DECL|field|launchNameNode
specifier|private
name|boolean
name|launchNameNode
decl_stmt|;
comment|// The service RPC address of a remote NameNode to be contacted by the
comment|// launched DataNodes
DECL|field|namenodeServiceRpcAddress
specifier|private
name|String
name|namenodeServiceRpcAddress
init|=
literal|""
decl_stmt|;
comment|// Directory to use for remote storage (a location on the remote FS which
comment|// can be accessed by all components)
DECL|field|remoteStoragePath
specifier|private
name|Path
name|remoteStoragePath
decl_stmt|;
comment|// The ACLs to view the launched containers
DECL|field|applicationAcls
specifier|private
name|Map
argument_list|<
name|ApplicationAccessType
argument_list|,
name|String
argument_list|>
name|applicationAcls
decl_stmt|;
comment|// The container the NameNode is running within
DECL|field|namenodeContainer
specifier|private
specifier|volatile
name|Container
name|namenodeContainer
decl_stmt|;
comment|// Map of the containers that the DataNodes are running within
DECL|field|datanodeContainers
specifier|private
name|ConcurrentMap
argument_list|<
name|ContainerId
argument_list|,
name|Container
argument_list|>
name|datanodeContainers
init|=
operator|new
name|ConcurrentHashMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|// Username of the user who launched this application.
DECL|field|launchingUser
specifier|private
name|String
name|launchingUser
decl_stmt|;
comment|/**    * @param args Command line args    */
DECL|method|main (String[] args)
specifier|public
specifier|static
name|void
name|main
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
block|{
name|boolean
name|result
init|=
literal|false
decl_stmt|;
try|try
block|{
name|ApplicationMaster
name|appMaster
init|=
operator|new
name|ApplicationMaster
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Initializing ApplicationMaster"
argument_list|)
expr_stmt|;
name|boolean
name|doRun
init|=
name|appMaster
operator|.
name|init
argument_list|(
name|args
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|doRun
condition|)
block|{
name|System
operator|.
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
name|appMaster
operator|.
name|run
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Error running ApplicationMaster"
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|System
operator|.
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Application Master completed successfully. exiting"
argument_list|)
expr_stmt|;
name|System
operator|.
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Application Master failed. exiting"
argument_list|)
expr_stmt|;
name|System
operator|.
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|ApplicationMaster ()
specifier|public
name|ApplicationMaster
parameter_list|()
block|{
comment|// Set up the configuration
name|conf
operator|=
operator|new
name|YarnConfiguration
argument_list|()
expr_stmt|;
block|}
comment|/**    * Parse command line options.    *    * @param args Command line args    * @return Whether init successful and run should be invoked    */
DECL|method|init (String[] args)
specifier|public
name|boolean
name|init
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
throws|throws
name|ParseException
block|{
name|Options
name|opts
init|=
operator|new
name|Options
argument_list|()
decl_stmt|;
name|AMOptions
operator|.
name|setOptions
argument_list|(
name|opts
argument_list|)
expr_stmt|;
name|CommandLine
name|cliParser
init|=
operator|new
name|GnuParser
argument_list|()
operator|.
name|parse
argument_list|(
name|opts
argument_list|,
name|args
argument_list|)
decl_stmt|;
if|if
condition|(
name|args
operator|.
name|length
operator|==
literal|0
condition|)
block|{
name|printUsage
argument_list|(
name|opts
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"No args specified for application master to initialize"
argument_list|)
throw|;
block|}
if|if
condition|(
name|cliParser
operator|.
name|hasOption
argument_list|(
literal|"help"
argument_list|)
condition|)
block|{
name|printUsage
argument_list|(
name|opts
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|envs
init|=
name|System
operator|.
name|getenv
argument_list|()
decl_stmt|;
name|remoteStoragePath
operator|=
operator|new
name|Path
argument_list|(
name|envs
operator|.
name|get
argument_list|(
name|DynoConstants
operator|.
name|REMOTE_STORAGE_PATH_ENV
argument_list|)
argument_list|)
expr_stmt|;
name|applicationAcls
operator|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
expr_stmt|;
name|applicationAcls
operator|.
name|put
argument_list|(
name|ApplicationAccessType
operator|.
name|VIEW_APP
argument_list|,
name|envs
operator|.
name|get
argument_list|(
name|DynoConstants
operator|.
name|JOB_ACL_VIEW_ENV
argument_list|)
argument_list|)
expr_stmt|;
name|launchingUser
operator|=
name|envs
operator|.
name|get
argument_list|(
name|Environment
operator|.
name|USER
operator|.
name|name
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|envs
operator|.
name|containsKey
argument_list|(
name|DynoConstants
operator|.
name|REMOTE_NN_RPC_ADDR_ENV
argument_list|)
condition|)
block|{
name|launchNameNode
operator|=
literal|false
expr_stmt|;
name|namenodeServiceRpcAddress
operator|=
name|envs
operator|.
name|get
argument_list|(
name|DynoConstants
operator|.
name|REMOTE_NN_RPC_ADDR_ENV
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|launchNameNode
operator|=
literal|true
expr_stmt|;
comment|// namenodeServiceRpcAddress will be set in run() once properties are
comment|// available
block|}
name|ContainerId
name|containerId
init|=
name|ContainerId
operator|.
name|fromString
argument_list|(
name|envs
operator|.
name|get
argument_list|(
name|Environment
operator|.
name|CONTAINER_ID
operator|.
name|name
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|ApplicationAttemptId
name|appAttemptID
init|=
name|containerId
operator|.
name|getApplicationAttemptId
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Application master for app: appId={}, clusterTimestamp={}, "
operator|+
literal|"attemptId={}"
argument_list|,
name|appAttemptID
operator|.
name|getApplicationId
argument_list|()
operator|.
name|getId
argument_list|()
argument_list|,
name|appAttemptID
operator|.
name|getApplicationId
argument_list|()
operator|.
name|getClusterTimestamp
argument_list|()
argument_list|,
name|appAttemptID
operator|.
name|getAttemptId
argument_list|()
argument_list|)
expr_stmt|;
name|amOptions
operator|=
name|AMOptions
operator|.
name|initFromParser
argument_list|(
name|cliParser
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|/**    * Helper function to print usage.    *    * @param opts arsed command line options    */
DECL|method|printUsage (Options opts)
specifier|private
name|void
name|printUsage
parameter_list|(
name|Options
name|opts
parameter_list|)
block|{
operator|new
name|HelpFormatter
argument_list|()
operator|.
name|printHelp
argument_list|(
literal|"ApplicationMaster"
argument_list|,
name|opts
argument_list|)
expr_stmt|;
block|}
comment|/**    * Main run function for the application master.    *    * @return True if the application completed successfully; false if if exited    *         unexpectedly, failed, was killed, etc.    */
DECL|method|run ()
specifier|public
name|boolean
name|run
parameter_list|()
throws|throws
name|YarnException
throws|,
name|IOException
throws|,
name|InterruptedException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Starting ApplicationMaster"
argument_list|)
expr_stmt|;
name|Credentials
name|credentials
init|=
name|UserGroupInformation
operator|.
name|getCurrentUser
argument_list|()
operator|.
name|getCredentials
argument_list|()
decl_stmt|;
name|DataOutputBuffer
name|dob
init|=
operator|new
name|DataOutputBuffer
argument_list|()
decl_stmt|;
name|credentials
operator|.
name|writeTokenStorageToStream
argument_list|(
name|dob
argument_list|)
expr_stmt|;
comment|// Now remove the AM->RM token so that containers cannot access it.
name|credentials
operator|.
name|getAllTokens
argument_list|()
operator|.
name|removeIf
argument_list|(
parameter_list|(
name|token
parameter_list|)
lambda|->
name|token
operator|.
name|getKind
argument_list|()
operator|.
name|equals
argument_list|(
name|AMRMTokenIdentifier
operator|.
name|KIND_NAME
argument_list|)
argument_list|)
expr_stmt|;
name|allTokens
operator|=
name|ByteBuffer
operator|.
name|wrap
argument_list|(
name|dob
operator|.
name|getData
argument_list|()
argument_list|,
literal|0
argument_list|,
name|dob
operator|.
name|getLength
argument_list|()
argument_list|)
expr_stmt|;
name|AMRMClientAsync
operator|.
name|AbstractCallbackHandler
name|allocListener
init|=
operator|new
name|RMCallbackHandler
argument_list|()
decl_stmt|;
name|amRMClient
operator|=
name|AMRMClientAsync
operator|.
name|createAMRMClientAsync
argument_list|(
literal|1000
argument_list|,
name|allocListener
argument_list|)
expr_stmt|;
name|amRMClient
operator|.
name|init
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|amRMClient
operator|.
name|start
argument_list|()
expr_stmt|;
name|containerListener
operator|=
name|createNMCallbackHandler
argument_list|()
expr_stmt|;
name|nmClientAsync
operator|=
operator|new
name|NMClientAsyncImpl
argument_list|(
name|containerListener
argument_list|)
expr_stmt|;
name|nmClientAsync
operator|.
name|init
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|nmClientAsync
operator|.
name|start
argument_list|()
expr_stmt|;
comment|// Register self with ResourceManager
comment|// This will start heartbeating to the RM
name|String
name|appMasterHostname
init|=
name|NetUtils
operator|.
name|getHostname
argument_list|()
decl_stmt|;
name|amRMClient
operator|.
name|registerApplicationMaster
argument_list|(
name|appMasterHostname
argument_list|,
operator|-
literal|1
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|// Supplier to use to indicate to wait-loops to stop waiting
name|Supplier
argument_list|<
name|Boolean
argument_list|>
name|exitCritera
init|=
name|this
operator|::
name|isComplete
decl_stmt|;
name|Optional
argument_list|<
name|Properties
argument_list|>
name|namenodeProperties
init|=
name|Optional
operator|.
name|empty
argument_list|()
decl_stmt|;
if|if
condition|(
name|launchNameNode
condition|)
block|{
name|ContainerRequest
name|nnContainerRequest
init|=
name|setupContainerAskForRM
argument_list|(
name|amOptions
operator|.
name|getNameNodeMemoryMB
argument_list|()
argument_list|,
name|amOptions
operator|.
name|getNameNodeVirtualCores
argument_list|()
argument_list|,
literal|0
argument_list|,
name|amOptions
operator|.
name|getNameNodeNodeLabelExpression
argument_list|()
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Requested NameNode ask: "
operator|+
name|nnContainerRequest
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|amRMClient
operator|.
name|addContainerRequest
argument_list|(
name|nnContainerRequest
argument_list|)
expr_stmt|;
comment|// Wait for the NN container to make its information available on the
comment|// shared
comment|// remote file storage
name|Path
name|namenodeInfoPath
init|=
operator|new
name|Path
argument_list|(
name|remoteStoragePath
argument_list|,
name|DynoConstants
operator|.
name|NN_INFO_FILE_NAME
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Waiting on availability of NameNode information at "
operator|+
name|namenodeInfoPath
argument_list|)
expr_stmt|;
name|namenodeProperties
operator|=
name|DynoInfraUtils
operator|.
name|waitForAndGetNameNodeProperties
argument_list|(
name|exitCritera
argument_list|,
name|conf
argument_list|,
name|namenodeInfoPath
argument_list|,
name|LOG
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|namenodeProperties
operator|.
name|isPresent
argument_list|()
condition|)
block|{
name|cleanup
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
name|namenodeServiceRpcAddress
operator|=
name|DynoInfraUtils
operator|.
name|getNameNodeServiceRpcAddr
argument_list|(
name|namenodeProperties
operator|.
name|get
argument_list|()
argument_list|)
operator|.
name|toString
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"NameNode information: "
operator|+
name|namenodeProperties
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"NameNode can be reached at: "
operator|+
name|DynoInfraUtils
operator|.
name|getNameNodeHdfsUri
argument_list|(
name|namenodeProperties
operator|.
name|get
argument_list|()
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|DynoInfraUtils
operator|.
name|waitForNameNodeStartup
argument_list|(
name|namenodeProperties
operator|.
name|get
argument_list|()
argument_list|,
name|exitCritera
argument_list|,
name|LOG
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Using remote NameNode with RPC address: "
operator|+
name|namenodeServiceRpcAddress
argument_list|)
expr_stmt|;
block|}
name|blockListFiles
operator|=
name|Collections
operator|.
name|synchronizedList
argument_list|(
name|getDataNodeBlockListingFiles
argument_list|()
argument_list|)
expr_stmt|;
name|numTotalDataNodes
operator|=
name|blockListFiles
operator|.
name|size
argument_list|()
expr_stmt|;
if|if
condition|(
name|numTotalDataNodes
operator|==
literal|0
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"No block listing files were found! Cannot run with 0 DataNodes."
argument_list|)
expr_stmt|;
name|markCompleted
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
name|numTotalDataNodeContainers
operator|=
operator|(
name|int
operator|)
name|Math
operator|.
name|ceil
argument_list|(
operator|(
operator|(
name|double
operator|)
name|numTotalDataNodes
operator|)
operator|/
name|Math
operator|.
name|max
argument_list|(
literal|1
argument_list|,
name|amOptions
operator|.
name|getDataNodesPerCluster
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Requesting {} DataNode containers with {} MB memory, {} vcores"
argument_list|,
name|numTotalDataNodeContainers
argument_list|,
name|amOptions
operator|.
name|getDataNodeMemoryMB
argument_list|()
argument_list|,
name|amOptions
operator|.
name|getDataNodeVirtualCores
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numTotalDataNodeContainers
condition|;
operator|++
name|i
control|)
block|{
name|ContainerRequest
name|datanodeAsk
init|=
name|setupContainerAskForRM
argument_list|(
name|amOptions
operator|.
name|getDataNodeMemoryMB
argument_list|()
argument_list|,
name|amOptions
operator|.
name|getDataNodeVirtualCores
argument_list|()
argument_list|,
literal|1
argument_list|,
name|amOptions
operator|.
name|getDataNodeNodeLabelExpression
argument_list|()
argument_list|)
decl_stmt|;
name|amRMClient
operator|.
name|addContainerRequest
argument_list|(
name|datanodeAsk
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Requested datanode ask: "
operator|+
name|datanodeAsk
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Finished requesting datanode containers"
argument_list|)
expr_stmt|;
if|if
condition|(
name|launchNameNode
condition|)
block|{
name|DynoInfraUtils
operator|.
name|waitForNameNodeReadiness
argument_list|(
name|namenodeProperties
operator|.
name|get
argument_list|()
argument_list|,
name|numTotalDataNodes
argument_list|,
literal|true
argument_list|,
name|exitCritera
argument_list|,
name|conf
argument_list|,
name|LOG
argument_list|)
expr_stmt|;
block|}
name|waitForCompletion
argument_list|()
expr_stmt|;
return|return
name|cleanup
argument_list|()
return|;
block|}
DECL|method|createNMCallbackHandler ()
specifier|private
name|NMCallbackHandler
name|createNMCallbackHandler
parameter_list|()
block|{
return|return
operator|new
name|NMCallbackHandler
argument_list|()
return|;
block|}
comment|/**    * Wait until the application has finished and is ready for cleanup.    */
DECL|method|waitForCompletion ()
specifier|private
name|void
name|waitForCompletion
parameter_list|()
throws|throws
name|InterruptedException
block|{
synchronized|synchronized
init|(
name|completionLock
init|)
block|{
while|while
condition|(
operator|!
name|completed
condition|)
block|{
name|completionLock
operator|.
name|wait
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Check completion status of the application.    *    * @return True iff it has completed.    */
DECL|method|isComplete ()
specifier|private
name|boolean
name|isComplete
parameter_list|()
block|{
synchronized|synchronized
init|(
name|completionLock
init|)
block|{
return|return
name|completed
return|;
block|}
block|}
comment|/**    * Mark that this application should begin cleaning up and exit.    */
DECL|method|markCompleted ()
specifier|private
name|void
name|markCompleted
parameter_list|()
block|{
synchronized|synchronized
init|(
name|completionLock
init|)
block|{
name|completed
operator|=
literal|true
expr_stmt|;
name|completionLock
operator|.
name|notify
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * @return True iff the application successfully completed    */
DECL|method|cleanup ()
specifier|private
name|boolean
name|cleanup
parameter_list|()
block|{
comment|// Join all launched threads
comment|// needed for when we time out
comment|// and we need to release containers
for|for
control|(
name|Thread
name|launchThread
range|:
name|launchThreads
control|)
block|{
try|try
block|{
name|launchThread
operator|.
name|join
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Exception thrown in thread join: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
name|e
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
block|}
comment|// When the application completes, it should stop all running containers
name|LOG
operator|.
name|info
argument_list|(
literal|"Application completed. Stopping running containers"
argument_list|)
expr_stmt|;
name|nmClientAsync
operator|.
name|stop
argument_list|()
expr_stmt|;
comment|// When the application completes, it should send a finish application
comment|// signal to the RM
name|LOG
operator|.
name|info
argument_list|(
literal|"Application completed. Signalling finish to RM"
argument_list|)
expr_stmt|;
name|FinalApplicationStatus
name|appStatus
decl_stmt|;
name|String
name|appMessage
init|=
literal|null
decl_stmt|;
name|boolean
name|success
decl_stmt|;
if|if
condition|(
name|numFailedDataNodeContainers
operator|.
name|get
argument_list|()
operator|==
literal|0
operator|&&
name|numCompletedDataNodeContainers
operator|.
name|get
argument_list|()
operator|==
name|numTotalDataNodes
condition|)
block|{
name|appStatus
operator|=
name|FinalApplicationStatus
operator|.
name|SUCCEEDED
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|appStatus
operator|=
name|FinalApplicationStatus
operator|.
name|FAILED
expr_stmt|;
name|appMessage
operator|=
literal|"Diagnostics: total="
operator|+
name|numTotalDataNodeContainers
operator|+
literal|", completed="
operator|+
name|numCompletedDataNodeContainers
operator|.
name|get
argument_list|()
operator|+
literal|", allocated="
operator|+
name|numAllocatedDataNodeContainers
operator|.
name|get
argument_list|()
operator|+
literal|", failed="
operator|+
name|numFailedDataNodeContainers
operator|.
name|get
argument_list|()
expr_stmt|;
name|success
operator|=
literal|false
expr_stmt|;
block|}
try|try
block|{
name|amRMClient
operator|.
name|unregisterApplicationMaster
argument_list|(
name|appStatus
argument_list|,
name|appMessage
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|YarnException
decl||
name|IOException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Failed to unregister application"
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
name|amRMClient
operator|.
name|stop
argument_list|()
expr_stmt|;
return|return
name|success
return|;
block|}
DECL|class|RMCallbackHandler
specifier|private
class|class
name|RMCallbackHandler
extends|extends
name|AMRMClientAsync
operator|.
name|AbstractCallbackHandler
block|{
annotation|@
name|Override
DECL|method|onContainersCompleted ( List<ContainerStatus> completedContainers)
specifier|public
name|void
name|onContainersCompleted
parameter_list|(
name|List
argument_list|<
name|ContainerStatus
argument_list|>
name|completedContainers
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Got response from RM for container ask, completedCnt="
operator|+
name|completedContainers
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|ContainerStatus
name|containerStatus
range|:
name|completedContainers
control|)
block|{
name|String
name|containerInfo
init|=
literal|"containerID="
operator|+
name|containerStatus
operator|.
name|getContainerId
argument_list|()
operator|+
literal|", state="
operator|+
name|containerStatus
operator|.
name|getState
argument_list|()
operator|+
literal|", exitStatus="
operator|+
name|containerStatus
operator|.
name|getExitStatus
argument_list|()
operator|+
literal|", diagnostics="
operator|+
name|StringUtils
operator|.
name|abbreviate
argument_list|(
name|containerStatus
operator|.
name|getDiagnostics
argument_list|()
argument_list|,
literal|1000
argument_list|)
decl_stmt|;
name|String
name|component
decl_stmt|;
if|if
condition|(
name|isNameNode
argument_list|(
name|containerStatus
operator|.
name|getContainerId
argument_list|()
argument_list|)
condition|)
block|{
name|component
operator|=
literal|"NAMENODE"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isDataNode
argument_list|(
name|containerStatus
operator|.
name|getContainerId
argument_list|()
argument_list|)
condition|)
block|{
name|component
operator|=
literal|"DATANODE"
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Received container status for unknown container: "
operator|+
name|containerInfo
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Got container status for "
operator|+
name|component
operator|+
literal|": "
operator|+
name|containerInfo
argument_list|)
expr_stmt|;
comment|// non complete containers should not be here
assert|assert
operator|(
name|containerStatus
operator|.
name|getState
argument_list|()
operator|==
name|ContainerState
operator|.
name|COMPLETE
operator|)
assert|;
if|if
condition|(
name|component
operator|.
name|equals
argument_list|(
literal|"NAMENODE"
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"NameNode container completed; marking application as done"
argument_list|)
expr_stmt|;
name|markCompleted
argument_list|()
expr_stmt|;
block|}
comment|// increment counters for completed/failed containers
name|int
name|exitStatus
init|=
name|containerStatus
operator|.
name|getExitStatus
argument_list|()
decl_stmt|;
name|int
name|completedIdx
init|=
name|numCompletedDataNodeContainers
operator|.
name|incrementAndGet
argument_list|()
decl_stmt|;
if|if
condition|(
literal|0
operator|!=
name|exitStatus
condition|)
block|{
name|numFailedDataNodeContainers
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"DataNode {} completed successfully, containerId={}"
argument_list|,
name|completedIdx
argument_list|,
name|containerStatus
operator|.
name|getContainerId
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|numCompletedDataNodeContainers
operator|.
name|get
argument_list|()
operator|==
name|numTotalDataNodeContainers
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"All datanode containers completed; marking application as done"
argument_list|)
expr_stmt|;
name|markCompleted
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|onContainersAllocated (List<Container> allocatedContainers)
specifier|public
name|void
name|onContainersAllocated
parameter_list|(
name|List
argument_list|<
name|Container
argument_list|>
name|allocatedContainers
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Got response from RM for container ask, allocatedCnt="
operator|+
name|allocatedContainers
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|Container
name|container
range|:
name|allocatedContainers
control|)
block|{
name|LaunchContainerRunnable
name|containerLauncher
decl_stmt|;
name|String
name|componentType
decl_stmt|;
name|Resource
name|rsrc
init|=
name|container
operator|.
name|getResource
argument_list|()
decl_stmt|;
if|if
condition|(
name|launchNameNode
operator|&&
name|rsrc
operator|.
name|getMemorySize
argument_list|()
operator|>=
name|amOptions
operator|.
name|getNameNodeMemoryMB
argument_list|()
operator|&&
name|rsrc
operator|.
name|getVirtualCores
argument_list|()
operator|>=
name|amOptions
operator|.
name|getNameNodeVirtualCores
argument_list|()
operator|&&
name|namenodeContainer
operator|==
literal|null
condition|)
block|{
name|namenodeContainer
operator|=
name|container
expr_stmt|;
name|componentType
operator|=
literal|"NAMENODE"
expr_stmt|;
name|containerLauncher
operator|=
operator|new
name|LaunchContainerRunnable
argument_list|(
name|container
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rsrc
operator|.
name|getMemorySize
argument_list|()
operator|>=
name|amOptions
operator|.
name|getDataNodeMemoryMB
argument_list|()
operator|&&
name|rsrc
operator|.
name|getVirtualCores
argument_list|()
operator|>=
name|amOptions
operator|.
name|getDataNodeVirtualCores
argument_list|()
operator|&&
name|numAllocatedDataNodeContainers
operator|.
name|get
argument_list|()
operator|<
name|numTotalDataNodes
condition|)
block|{
if|if
condition|(
name|launchNameNode
operator|&&
name|namenodeContainer
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Received a container with following resources suited "
operator|+
literal|"for a DataNode but no NameNode container exists: "
operator|+
literal|"containerMem="
operator|+
name|rsrc
operator|.
name|getMemorySize
argument_list|()
operator|+
literal|", containerVcores="
operator|+
name|rsrc
operator|.
name|getVirtualCores
argument_list|()
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|numAllocatedDataNodeContainers
operator|.
name|getAndIncrement
argument_list|()
expr_stmt|;
name|datanodeContainers
operator|.
name|put
argument_list|(
name|container
operator|.
name|getId
argument_list|()
argument_list|,
name|container
argument_list|)
expr_stmt|;
name|componentType
operator|=
literal|"DATANODE"
expr_stmt|;
name|containerLauncher
operator|=
operator|new
name|LaunchContainerRunnable
argument_list|(
name|container
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Received unwanted container allocation: "
operator|+
name|container
argument_list|)
expr_stmt|;
name|nmClientAsync
operator|.
name|stopContainerAsync
argument_list|(
name|container
operator|.
name|getId
argument_list|()
argument_list|,
name|container
operator|.
name|getNodeId
argument_list|()
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Launching "
operator|+
name|componentType
operator|+
literal|" on a new container."
operator|+
literal|", containerId="
operator|+
name|container
operator|.
name|getId
argument_list|()
operator|+
literal|", containerNode="
operator|+
name|container
operator|.
name|getNodeId
argument_list|()
operator|.
name|getHost
argument_list|()
operator|+
literal|":"
operator|+
name|container
operator|.
name|getNodeId
argument_list|()
operator|.
name|getPort
argument_list|()
operator|+
literal|", containerNodeURI="
operator|+
name|container
operator|.
name|getNodeHttpAddress
argument_list|()
operator|+
literal|", containerResourceMemory="
operator|+
name|rsrc
operator|.
name|getMemorySize
argument_list|()
operator|+
literal|", containerResourceVirtualCores="
operator|+
name|rsrc
operator|.
name|getVirtualCores
argument_list|()
argument_list|)
expr_stmt|;
name|Thread
name|launchThread
init|=
operator|new
name|Thread
argument_list|(
name|containerLauncher
argument_list|)
decl_stmt|;
comment|// launch and start the container on a separate thread to keep
comment|// the main thread unblocked
comment|// as all containers may not be allocated at one go.
name|launchThreads
operator|.
name|add
argument_list|(
name|launchThread
argument_list|)
expr_stmt|;
name|launchThread
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|onShutdownRequest ()
specifier|public
name|void
name|onShutdownRequest
parameter_list|()
block|{
name|markCompleted
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|onNodesUpdated (List<NodeReport> updatedNodes)
specifier|public
name|void
name|onNodesUpdated
parameter_list|(
name|List
argument_list|<
name|NodeReport
argument_list|>
name|updatedNodes
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"onNodesUpdated: "
operator|+
name|Joiner
operator|.
name|on
argument_list|(
literal|","
argument_list|)
operator|.
name|join
argument_list|(
name|updatedNodes
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getProgress ()
specifier|public
name|float
name|getProgress
parameter_list|()
block|{
return|return
literal|0.0f
return|;
block|}
annotation|@
name|Override
DECL|method|onError (Throwable e)
specifier|public
name|void
name|onError
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|markCompleted
argument_list|()
expr_stmt|;
name|amRMClient
operator|.
name|stop
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|onContainersUpdated (List<UpdatedContainer> containers)
specifier|public
name|void
name|onContainersUpdated
parameter_list|(
name|List
argument_list|<
name|UpdatedContainer
argument_list|>
name|containers
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"onContainersUpdated: "
operator|+
name|Joiner
operator|.
name|on
argument_list|(
literal|","
argument_list|)
operator|.
name|join
argument_list|(
name|containers
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
DECL|class|NMCallbackHandler
specifier|private
class|class
name|NMCallbackHandler
extends|extends
name|NMClientAsync
operator|.
name|AbstractCallbackHandler
block|{
annotation|@
name|Override
DECL|method|onContainerStopped (ContainerId containerId)
specifier|public
name|void
name|onContainerStopped
parameter_list|(
name|ContainerId
name|containerId
parameter_list|)
block|{
if|if
condition|(
name|isNameNode
argument_list|(
name|containerId
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"NameNode container stopped: "
operator|+
name|containerId
argument_list|)
expr_stmt|;
name|namenodeContainer
operator|=
literal|null
expr_stmt|;
name|markCompleted
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isDataNode
argument_list|(
name|containerId
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"DataNode container stopped: "
operator|+
name|containerId
argument_list|)
expr_stmt|;
name|datanodeContainers
operator|.
name|remove
argument_list|(
name|containerId
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"onContainerStopped received unknown container ID: "
operator|+
name|containerId
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|onContainerStatusReceived (ContainerId containerId, ContainerStatus containerStatus)
specifier|public
name|void
name|onContainerStatusReceived
parameter_list|(
name|ContainerId
name|containerId
parameter_list|,
name|ContainerStatus
name|containerStatus
parameter_list|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Container Status: id="
operator|+
name|containerId
operator|+
literal|", status="
operator|+
name|containerStatus
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|onContainerStarted (ContainerId containerId, Map<String, ByteBuffer> allServiceResponse)
specifier|public
name|void
name|onContainerStarted
parameter_list|(
name|ContainerId
name|containerId
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|ByteBuffer
argument_list|>
name|allServiceResponse
parameter_list|)
block|{
if|if
condition|(
name|isNameNode
argument_list|(
name|containerId
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"NameNode container started at ID "
operator|+
name|containerId
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isDataNode
argument_list|(
name|containerId
argument_list|)
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Succeeded to start DataNode Container "
operator|+
name|containerId
argument_list|)
expr_stmt|;
block|}
name|nmClientAsync
operator|.
name|getContainerStatusAsync
argument_list|(
name|containerId
argument_list|,
name|datanodeContainers
operator|.
name|get
argument_list|(
name|containerId
argument_list|)
operator|.
name|getNodeId
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"onContainerStarted received unknown container ID: "
operator|+
name|containerId
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|onStartContainerError (ContainerId containerId, Throwable t)
specifier|public
name|void
name|onStartContainerError
parameter_list|(
name|ContainerId
name|containerId
parameter_list|,
name|Throwable
name|t
parameter_list|)
block|{
if|if
condition|(
name|isNameNode
argument_list|(
name|containerId
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Failed to start namenode container ID "
operator|+
name|containerId
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|namenodeContainer
operator|=
literal|null
expr_stmt|;
name|markCompleted
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isDataNode
argument_list|(
name|containerId
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Failed to start DataNode Container "
operator|+
name|containerId
argument_list|)
expr_stmt|;
name|datanodeContainers
operator|.
name|remove
argument_list|(
name|containerId
argument_list|)
expr_stmt|;
name|numCompletedDataNodeContainers
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
name|numFailedDataNodeContainers
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"onStartContainerError received unknown container ID: "
operator|+
name|containerId
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|onGetContainerStatusError (ContainerId containerId, Throwable t)
specifier|public
name|void
name|onGetContainerStatusError
parameter_list|(
name|ContainerId
name|containerId
parameter_list|,
name|Throwable
name|t
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Failed to query the status of Container "
operator|+
name|containerId
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|onStopContainerError (ContainerId containerId, Throwable t)
specifier|public
name|void
name|onStopContainerError
parameter_list|(
name|ContainerId
name|containerId
parameter_list|,
name|Throwable
name|t
parameter_list|)
block|{
if|if
condition|(
name|isNameNode
argument_list|(
name|containerId
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Failed to stop NameNode container ID "
operator|+
name|containerId
argument_list|)
expr_stmt|;
name|namenodeContainer
operator|=
literal|null
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isDataNode
argument_list|(
name|containerId
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Failed to stop DataNode Container "
operator|+
name|containerId
argument_list|)
expr_stmt|;
name|datanodeContainers
operator|.
name|remove
argument_list|(
name|containerId
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"onStopContainerError received unknown containerID: "
operator|+
name|containerId
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
annotation|@
name|Deprecated
DECL|method|onContainerResourceIncreased (ContainerId containerId, Resource resource)
specifier|public
name|void
name|onContainerResourceIncreased
parameter_list|(
name|ContainerId
name|containerId
parameter_list|,
name|Resource
name|resource
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"onContainerResourceIncreased: {}, {}"
argument_list|,
name|containerId
argument_list|,
name|resource
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|onContainerResourceUpdated (ContainerId containerId, Resource resource)
specifier|public
name|void
name|onContainerResourceUpdated
parameter_list|(
name|ContainerId
name|containerId
parameter_list|,
name|Resource
name|resource
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"onContainerResourceUpdated: {}, {}"
argument_list|,
name|containerId
argument_list|,
name|resource
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
annotation|@
name|Deprecated
DECL|method|onIncreaseContainerResourceError (ContainerId containerId, Throwable t)
specifier|public
name|void
name|onIncreaseContainerResourceError
parameter_list|(
name|ContainerId
name|containerId
parameter_list|,
name|Throwable
name|t
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"onIncreaseContainerResourceError: {}"
argument_list|,
name|containerId
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|onUpdateContainerResourceError (ContainerId containerId, Throwable t)
specifier|public
name|void
name|onUpdateContainerResourceError
parameter_list|(
name|ContainerId
name|containerId
parameter_list|,
name|Throwable
name|t
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"onUpdateContainerResourceError: {}"
argument_list|,
name|containerId
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Thread to connect to the {@link ContainerManagementProtocol} and launch the    * container that will execute the shell command.    */
DECL|class|LaunchContainerRunnable
specifier|private
class|class
name|LaunchContainerRunnable
implements|implements
name|Runnable
block|{
comment|// Allocated container
DECL|field|container
specifier|private
name|Container
name|container
decl_stmt|;
DECL|field|isNameNodeLauncher
specifier|private
name|boolean
name|isNameNodeLauncher
decl_stmt|;
comment|/**      * @param lcontainer Allocated container      * @param isNameNode True iff this should launch a NameNode      */
DECL|method|LaunchContainerRunnable (Container lcontainer, boolean isNameNode)
name|LaunchContainerRunnable
parameter_list|(
name|Container
name|lcontainer
parameter_list|,
name|boolean
name|isNameNode
parameter_list|)
block|{
name|this
operator|.
name|container
operator|=
name|lcontainer
expr_stmt|;
name|this
operator|.
name|isNameNodeLauncher
operator|=
name|isNameNode
expr_stmt|;
block|}
comment|/**      * Get the map of local resources to be used for launching this container.      */
DECL|method|getLocalResources ()
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|LocalResource
argument_list|>
name|getLocalResources
parameter_list|()
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|LocalResource
argument_list|>
name|localResources
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|envs
init|=
name|System
operator|.
name|getenv
argument_list|()
decl_stmt|;
name|addAsLocalResourceFromEnv
argument_list|(
name|DynoConstants
operator|.
name|CONF_ZIP
argument_list|,
name|localResources
argument_list|,
name|envs
argument_list|)
expr_stmt|;
name|addAsLocalResourceFromEnv
argument_list|(
name|DynoConstants
operator|.
name|START_SCRIPT
argument_list|,
name|localResources
argument_list|,
name|envs
argument_list|)
expr_stmt|;
name|addAsLocalResourceFromEnv
argument_list|(
name|DynoConstants
operator|.
name|HADOOP_BINARY
argument_list|,
name|localResources
argument_list|,
name|envs
argument_list|)
expr_stmt|;
name|addAsLocalResourceFromEnv
argument_list|(
name|DynoConstants
operator|.
name|VERSION
argument_list|,
name|localResources
argument_list|,
name|envs
argument_list|)
expr_stmt|;
name|addAsLocalResourceFromEnv
argument_list|(
name|DynoConstants
operator|.
name|DYNO_DEPENDENCIES
argument_list|,
name|localResources
argument_list|,
name|envs
argument_list|)
expr_stmt|;
if|if
condition|(
name|isNameNodeLauncher
condition|)
block|{
name|addAsLocalResourceFromEnv
argument_list|(
name|DynoConstants
operator|.
name|FS_IMAGE
argument_list|,
name|localResources
argument_list|,
name|envs
argument_list|)
expr_stmt|;
name|addAsLocalResourceFromEnv
argument_list|(
name|DynoConstants
operator|.
name|FS_IMAGE_MD5
argument_list|,
name|localResources
argument_list|,
name|envs
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|blockFilesToLocalize
init|=
name|Math
operator|.
name|max
argument_list|(
literal|1
argument_list|,
name|amOptions
operator|.
name|getDataNodesPerCluster
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|blockFilesToLocalize
condition|;
name|i
operator|++
control|)
block|{
try|try
block|{
name|localResources
operator|.
name|put
argument_list|(
name|DynoConstants
operator|.
name|BLOCK_LIST_RESOURCE_PATH_PREFIX
operator|+
name|i
argument_list|,
name|blockListFiles
operator|.
name|remove
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IndexOutOfBoundsException
name|e
parameter_list|)
block|{
break|break;
block|}
block|}
block|}
return|return
name|localResources
return|;
block|}
comment|/**      * Connects to CM, sets up container launch context for shell command and      * eventually dispatches the container start request to the CM.      */
annotation|@
name|Override
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Setting up container launch context for containerid="
operator|+
name|container
operator|.
name|getId
argument_list|()
operator|+
literal|", isNameNode="
operator|+
name|isNameNodeLauncher
argument_list|)
expr_stmt|;
name|ContainerLaunchContext
name|ctx
init|=
name|Records
operator|.
name|newRecord
argument_list|(
name|ContainerLaunchContext
operator|.
name|class
argument_list|)
decl_stmt|;
comment|// Set the environment
name|ctx
operator|.
name|setEnvironment
argument_list|(
name|amOptions
operator|.
name|getShellEnv
argument_list|()
argument_list|)
expr_stmt|;
name|ctx
operator|.
name|setApplicationACLs
argument_list|(
name|applicationAcls
argument_list|)
expr_stmt|;
try|try
block|{
name|ctx
operator|.
name|setLocalResources
argument_list|(
name|getLocalResources
argument_list|()
argument_list|)
expr_stmt|;
name|ctx
operator|.
name|setCommands
argument_list|(
name|getContainerStartCommand
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Error while configuring container!"
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// Set up tokens for the container
name|ctx
operator|.
name|setTokens
argument_list|(
name|allTokens
operator|.
name|duplicate
argument_list|()
argument_list|)
expr_stmt|;
name|nmClientAsync
operator|.
name|startContainerAsync
argument_list|(
name|container
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Starting {}; track at: http://{}/node/containerlogs/{}/{}/"
argument_list|,
name|isNameNodeLauncher
condition|?
literal|"NAMENODE"
else|:
literal|"DATANODE"
argument_list|,
name|container
operator|.
name|getNodeHttpAddress
argument_list|()
argument_list|,
name|container
operator|.
name|getId
argument_list|()
argument_list|,
name|launchingUser
argument_list|)
expr_stmt|;
block|}
comment|/**      * Return the command used to start this container.      */
DECL|method|getContainerStartCommand ()
specifier|private
name|List
argument_list|<
name|String
argument_list|>
name|getContainerStartCommand
parameter_list|()
throws|throws
name|IOException
block|{
comment|// Set the necessary command to execute on the allocated container
name|List
argument_list|<
name|String
argument_list|>
name|vargs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
comment|// Set executable command
name|vargs
operator|.
name|add
argument_list|(
literal|"./"
operator|+
name|DynoConstants
operator|.
name|START_SCRIPT
operator|.
name|getResourcePath
argument_list|()
argument_list|)
expr_stmt|;
name|String
name|component
init|=
name|isNameNodeLauncher
condition|?
literal|"namenode"
else|:
literal|"datanode"
decl_stmt|;
name|vargs
operator|.
name|add
argument_list|(
name|component
argument_list|)
expr_stmt|;
if|if
condition|(
name|isNameNodeLauncher
condition|)
block|{
name|vargs
operator|.
name|add
argument_list|(
name|remoteStoragePath
operator|.
name|getFileSystem
argument_list|(
name|conf
argument_list|)
operator|.
name|makeQualified
argument_list|(
name|remoteStoragePath
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|vargs
operator|.
name|add
argument_list|(
name|namenodeServiceRpcAddress
argument_list|)
expr_stmt|;
name|vargs
operator|.
name|add
argument_list|(
name|String
operator|.
name|valueOf
argument_list|(
name|amOptions
operator|.
name|getDataNodeLaunchDelaySec
argument_list|()
operator|<
literal|1
condition|?
literal|0
else|:
name|RAND
operator|.
name|nextInt
argument_list|(
name|Ints
operator|.
name|checkedCast
argument_list|(
name|amOptions
operator|.
name|getDataNodeLaunchDelaySec
argument_list|()
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Add log redirect params
name|vargs
operator|.
name|add
argument_list|(
literal|"1>"
operator|+
name|ApplicationConstants
operator|.
name|LOG_DIR_EXPANSION_VAR
operator|+
literal|"/stdout"
argument_list|)
expr_stmt|;
name|vargs
operator|.
name|add
argument_list|(
literal|"2>"
operator|+
name|ApplicationConstants
operator|.
name|LOG_DIR_EXPANSION_VAR
operator|+
literal|"/stderr"
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Completed setting up command for "
operator|+
name|component
operator|+
literal|": "
operator|+
name|vargs
argument_list|)
expr_stmt|;
return|return
name|Lists
operator|.
name|newArrayList
argument_list|(
name|Joiner
operator|.
name|on
argument_list|(
literal|" "
argument_list|)
operator|.
name|join
argument_list|(
name|vargs
argument_list|)
argument_list|)
return|;
block|}
comment|/**      * Add the given resource into the map of resources, using information from      * the supplied environment variables.      *      * @param resource The resource to add.      * @param localResources Map of local resources to insert into.      * @param env Map of environment variables.      */
DECL|method|addAsLocalResourceFromEnv (DynoResource resource, Map<String, LocalResource> localResources, Map<String, String> env)
specifier|public
name|void
name|addAsLocalResourceFromEnv
parameter_list|(
name|DynoResource
name|resource
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|LocalResource
argument_list|>
name|localResources
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|env
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Adding resource to localResources: "
operator|+
name|resource
argument_list|)
expr_stmt|;
name|String
name|resourcePath
init|=
name|resource
operator|.
name|getResourcePath
argument_list|()
decl_stmt|;
if|if
condition|(
name|resourcePath
operator|==
literal|null
condition|)
block|{
comment|// Default to using the file name in the path
name|resourcePath
operator|=
name|resource
operator|.
name|getPath
argument_list|(
name|env
argument_list|)
operator|.
name|getName
argument_list|()
expr_stmt|;
block|}
name|localResources
operator|.
name|put
argument_list|(
name|resourcePath
argument_list|,
name|LocalResource
operator|.
name|newInstance
argument_list|(
name|URL
operator|.
name|fromPath
argument_list|(
name|resource
operator|.
name|getPath
argument_list|(
name|env
argument_list|)
argument_list|)
argument_list|,
name|resource
operator|.
name|getType
argument_list|()
argument_list|,
name|LocalResourceVisibility
operator|.
name|APPLICATION
argument_list|,
name|resource
operator|.
name|getLength
argument_list|(
name|env
argument_list|)
argument_list|,
name|resource
operator|.
name|getTimestamp
argument_list|(
name|env
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|getDataNodeBlockListingFiles ()
specifier|private
name|List
argument_list|<
name|LocalResource
argument_list|>
name|getDataNodeBlockListingFiles
parameter_list|()
throws|throws
name|IOException
block|{
name|Path
name|blockListDirPath
init|=
operator|new
name|Path
argument_list|(
name|System
operator|.
name|getenv
argument_list|()
operator|.
name|get
argument_list|(
name|DynoConstants
operator|.
name|BLOCK_LIST_PATH_ENV
argument_list|)
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Looking for block listing files in "
operator|+
name|blockListDirPath
argument_list|)
expr_stmt|;
name|FileSystem
name|blockZipFS
init|=
name|blockListDirPath
operator|.
name|getFileSystem
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|LocalResource
argument_list|>
name|files
init|=
operator|new
name|LinkedList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|FileStatus
name|stat
range|:
name|blockZipFS
operator|.
name|listStatus
argument_list|(
name|blockListDirPath
argument_list|,
name|DynoConstants
operator|.
name|BLOCK_LIST_FILE_FILTER
argument_list|)
control|)
block|{
name|LocalResource
name|blockListResource
init|=
name|LocalResource
operator|.
name|newInstance
argument_list|(
name|URL
operator|.
name|fromPath
argument_list|(
name|stat
operator|.
name|getPath
argument_list|()
argument_list|)
argument_list|,
name|LocalResourceType
operator|.
name|FILE
argument_list|,
name|LocalResourceVisibility
operator|.
name|APPLICATION
argument_list|,
name|stat
operator|.
name|getLen
argument_list|()
argument_list|,
name|stat
operator|.
name|getModificationTime
argument_list|()
argument_list|)
decl_stmt|;
name|files
operator|.
name|add
argument_list|(
name|blockListResource
argument_list|)
expr_stmt|;
block|}
return|return
name|files
return|;
block|}
comment|/**    * Return true iff {@code containerId} represents the NameNode container.    */
DECL|method|isNameNode (ContainerId containerId)
specifier|private
name|boolean
name|isNameNode
parameter_list|(
name|ContainerId
name|containerId
parameter_list|)
block|{
return|return
name|namenodeContainer
operator|!=
literal|null
operator|&&
name|namenodeContainer
operator|.
name|getId
argument_list|()
operator|.
name|equals
argument_list|(
name|containerId
argument_list|)
return|;
block|}
comment|/**    * Return true iff {@code containerId} represents a DataNode container.    */
DECL|method|isDataNode (ContainerId containerId)
specifier|private
name|boolean
name|isDataNode
parameter_list|(
name|ContainerId
name|containerId
parameter_list|)
block|{
return|return
name|datanodeContainers
operator|.
name|containsKey
argument_list|(
name|containerId
argument_list|)
return|;
block|}
comment|/**    * Setup the request that will be sent to the RM for the container ask.    *    * @return the setup ResourceRequest to be sent to RM    */
DECL|method|setupContainerAskForRM (int memory, int vcores, int priority, String nodeLabel)
specifier|private
name|ContainerRequest
name|setupContainerAskForRM
parameter_list|(
name|int
name|memory
parameter_list|,
name|int
name|vcores
parameter_list|,
name|int
name|priority
parameter_list|,
name|String
name|nodeLabel
parameter_list|)
block|{
name|Priority
name|pri
init|=
name|Records
operator|.
name|newRecord
argument_list|(
name|Priority
operator|.
name|class
argument_list|)
decl_stmt|;
name|pri
operator|.
name|setPriority
argument_list|(
name|priority
argument_list|)
expr_stmt|;
comment|// Set up resource type requirements
comment|// For now, memory and CPU are supported so we set memory and cpu
comment|// requirements
name|Resource
name|capability
init|=
name|Records
operator|.
name|newRecord
argument_list|(
name|Resource
operator|.
name|class
argument_list|)
decl_stmt|;
name|capability
operator|.
name|setMemorySize
argument_list|(
name|memory
argument_list|)
expr_stmt|;
name|capability
operator|.
name|setVirtualCores
argument_list|(
name|vcores
argument_list|)
expr_stmt|;
return|return
operator|new
name|ContainerRequest
argument_list|(
name|capability
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|pri
argument_list|,
literal|true
argument_list|,
name|nodeLabel
argument_list|)
return|;
block|}
block|}
end_class

end_unit

