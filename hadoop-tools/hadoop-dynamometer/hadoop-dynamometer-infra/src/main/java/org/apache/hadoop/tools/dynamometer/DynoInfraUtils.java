begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.tools.dynamometer
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|tools
operator|.
name|dynamometer
package|;
end_package

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Joiner
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileNotFoundException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|HttpURLConnection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|InetSocketAddress
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|MalformedURLException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URI
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URL
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|StandardCharsets
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Optional
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Properties
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicBoolean
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|Supplier
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|io
operator|.
name|FileUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|io
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceStability
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|CommonConfigurationKeysPublic
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FSDataInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSUtilClient
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DistributedFileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|client
operator|.
name|BlockReportOptions
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|ClientDatanodeProtocol
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|DatanodeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|net
operator|.
name|NetUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|UserGroupInformation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Time
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|YarnUncaughtExceptionHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|ApplicationConstants
operator|.
name|Environment
import|;
end_import

begin_import
import|import
name|org
operator|.
name|codehaus
operator|.
name|jackson
operator|.
name|JsonFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|codehaus
operator|.
name|jackson
operator|.
name|JsonParser
import|;
end_import

begin_import
import|import
name|org
operator|.
name|codehaus
operator|.
name|jackson
operator|.
name|JsonToken
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_comment
comment|/**  * A collection of utilities used by the Dynamometer infrastructure application.  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
annotation|@
name|InterfaceStability
operator|.
name|Unstable
DECL|class|DynoInfraUtils
specifier|public
specifier|final
class|class
name|DynoInfraUtils
block|{
DECL|method|DynoInfraUtils ()
specifier|private
name|DynoInfraUtils
parameter_list|()
block|{}
DECL|field|DYNO_CONF_PREFIX
specifier|public
specifier|static
specifier|final
name|String
name|DYNO_CONF_PREFIX
init|=
literal|"dyno."
decl_stmt|;
DECL|field|DYNO_INFRA_PREFIX
specifier|public
specifier|static
specifier|final
name|String
name|DYNO_INFRA_PREFIX
init|=
name|DYNO_CONF_PREFIX
operator|+
literal|"infra."
decl_stmt|;
DECL|field|APACHE_DOWNLOAD_MIRROR_KEY
specifier|public
specifier|static
specifier|final
name|String
name|APACHE_DOWNLOAD_MIRROR_KEY
init|=
name|DYNO_CONF_PREFIX
operator|+
literal|"apache-mirror"
decl_stmt|;
comment|// Set a generic mirror as the default.
DECL|field|APACHE_DOWNLOAD_MIRROR_DEFAULT
specifier|public
specifier|static
specifier|final
name|String
name|APACHE_DOWNLOAD_MIRROR_DEFAULT
init|=
literal|"http://mirrors.ocf.berkeley.edu/apache/"
decl_stmt|;
DECL|field|APACHE_DOWNLOAD_MIRROR_SUFFIX_FORMAT
specifier|private
specifier|static
specifier|final
name|String
name|APACHE_DOWNLOAD_MIRROR_SUFFIX_FORMAT
init|=
literal|"hadoop/common/hadoop-%s/hadoop-%s.tar.gz"
decl_stmt|;
DECL|field|HADOOP_TAR_FILENAME_FORMAT
specifier|public
specifier|static
specifier|final
name|String
name|HADOOP_TAR_FILENAME_FORMAT
init|=
literal|"hadoop-%s.tar.gz"
decl_stmt|;
DECL|field|DATANODE_LIVE_MIN_FRACTION_KEY
specifier|public
specifier|static
specifier|final
name|String
name|DATANODE_LIVE_MIN_FRACTION_KEY
init|=
name|DYNO_INFRA_PREFIX
operator|+
literal|"ready.datanode-min-fraction"
decl_stmt|;
DECL|field|DATANODE_LIVE_MIN_FRACTION_DEFAULT
specifier|public
specifier|static
specifier|final
name|float
name|DATANODE_LIVE_MIN_FRACTION_DEFAULT
init|=
literal|0.99f
decl_stmt|;
DECL|field|MISSING_BLOCKS_MAX_FRACTION_KEY
specifier|public
specifier|static
specifier|final
name|String
name|MISSING_BLOCKS_MAX_FRACTION_KEY
init|=
name|DYNO_INFRA_PREFIX
operator|+
literal|"ready.missing-blocks-max-fraction"
decl_stmt|;
DECL|field|MISSING_BLOCKS_MAX_FRACTION_DEFAULT
specifier|public
specifier|static
specifier|final
name|float
name|MISSING_BLOCKS_MAX_FRACTION_DEFAULT
init|=
literal|0.0001f
decl_stmt|;
DECL|field|UNDERREPLICATED_BLOCKS_MAX_FRACTION_KEY
specifier|public
specifier|static
specifier|final
name|String
name|UNDERREPLICATED_BLOCKS_MAX_FRACTION_KEY
init|=
name|DYNO_INFRA_PREFIX
operator|+
literal|"ready.underreplicated-blocks-max-fraction"
decl_stmt|;
DECL|field|UNDERREPLICATED_BLOCKS_MAX_FRACTION_DEFAULT
specifier|public
specifier|static
specifier|final
name|float
name|UNDERREPLICATED_BLOCKS_MAX_FRACTION_DEFAULT
init|=
literal|0.01f
decl_stmt|;
comment|// The JMX bean queries to execute for various beans.
DECL|field|NAMENODE_STARTUP_PROGRESS_JMX_QUERY
specifier|public
specifier|static
specifier|final
name|String
name|NAMENODE_STARTUP_PROGRESS_JMX_QUERY
init|=
literal|"Hadoop:service=NameNode,name=StartupProgress"
decl_stmt|;
DECL|field|FSNAMESYSTEM_JMX_QUERY
specifier|public
specifier|static
specifier|final
name|String
name|FSNAMESYSTEM_JMX_QUERY
init|=
literal|"Hadoop:service=NameNode,name=FSNamesystem"
decl_stmt|;
DECL|field|FSNAMESYSTEM_STATE_JMX_QUERY
specifier|public
specifier|static
specifier|final
name|String
name|FSNAMESYSTEM_STATE_JMX_QUERY
init|=
literal|"Hadoop:service=NameNode,name=FSNamesystemState"
decl_stmt|;
DECL|field|NAMENODE_INFO_JMX_QUERY
specifier|public
specifier|static
specifier|final
name|String
name|NAMENODE_INFO_JMX_QUERY
init|=
literal|"Hadoop:service=NameNode,name=NameNodeInfo"
decl_stmt|;
comment|// The JMX property names of various properties.
DECL|field|JMX_MISSING_BLOCKS
specifier|public
specifier|static
specifier|final
name|String
name|JMX_MISSING_BLOCKS
init|=
literal|"MissingBlocks"
decl_stmt|;
DECL|field|JMX_UNDER_REPLICATED_BLOCKS
specifier|public
specifier|static
specifier|final
name|String
name|JMX_UNDER_REPLICATED_BLOCKS
init|=
literal|"UnderReplicatedBlocks"
decl_stmt|;
DECL|field|JMX_BLOCKS_TOTAL
specifier|public
specifier|static
specifier|final
name|String
name|JMX_BLOCKS_TOTAL
init|=
literal|"BlocksTotal"
decl_stmt|;
DECL|field|JMX_LIVE_NODE_COUNT
specifier|public
specifier|static
specifier|final
name|String
name|JMX_LIVE_NODE_COUNT
init|=
literal|"NumLiveDataNodes"
decl_stmt|;
DECL|field|JMX_LIVE_NODES_LIST
specifier|public
specifier|static
specifier|final
name|String
name|JMX_LIVE_NODES_LIST
init|=
literal|"LiveNodes"
decl_stmt|;
comment|/**    * If a file matching {@value HADOOP_TAR_FILENAME_FORMAT} and {@code version}    * is found in {@code destinationDir}, return its path. Otherwise, first    * download the tarball from an Apache mirror. If the    * {@value APACHE_DOWNLOAD_MIRROR_KEY} configuration or system property    * (checked in that order) is set, use that as the mirror; else use    * {@value APACHE_DOWNLOAD_MIRROR_DEFAULT}.    *    * @param version The version of Hadoop to download, like "2.7.4"    *                or "3.0.0-beta1"    * @return The path to the tarball.    */
DECL|method|fetchHadoopTarball (File destinationDir, String version, Configuration conf, Logger log)
specifier|public
specifier|static
name|File
name|fetchHadoopTarball
parameter_list|(
name|File
name|destinationDir
parameter_list|,
name|String
name|version
parameter_list|,
name|Configuration
name|conf
parameter_list|,
name|Logger
name|log
parameter_list|)
throws|throws
name|IOException
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Looking for Hadoop tarball for version: "
operator|+
name|version
argument_list|)
expr_stmt|;
name|File
name|destinationFile
init|=
operator|new
name|File
argument_list|(
name|destinationDir
argument_list|,
name|String
operator|.
name|format
argument_list|(
name|HADOOP_TAR_FILENAME_FORMAT
argument_list|,
name|version
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|destinationFile
operator|.
name|exists
argument_list|()
condition|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Found tarball at: "
operator|+
name|destinationFile
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|destinationFile
return|;
block|}
name|String
name|apacheMirror
init|=
name|conf
operator|.
name|get
argument_list|(
name|APACHE_DOWNLOAD_MIRROR_KEY
argument_list|)
decl_stmt|;
if|if
condition|(
name|apacheMirror
operator|==
literal|null
condition|)
block|{
name|apacheMirror
operator|=
name|System
operator|.
name|getProperty
argument_list|(
name|APACHE_DOWNLOAD_MIRROR_KEY
argument_list|,
name|APACHE_DOWNLOAD_MIRROR_DEFAULT
argument_list|)
expr_stmt|;
block|}
name|destinationDir
operator|.
name|mkdirs
argument_list|()
expr_stmt|;
name|URL
name|downloadURL
init|=
operator|new
name|URL
argument_list|(
name|apacheMirror
operator|+
name|String
operator|.
name|format
argument_list|(
name|APACHE_DOWNLOAD_MIRROR_SUFFIX_FORMAT
argument_list|,
name|version
argument_list|,
name|version
argument_list|)
argument_list|)
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Downloading tarball from:<{}> to<{}>"
argument_list|,
name|downloadURL
argument_list|,
name|destinationFile
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
name|FileUtils
operator|.
name|copyURLToFile
argument_list|(
name|downloadURL
argument_list|,
name|destinationFile
argument_list|,
literal|10000
argument_list|,
literal|60000
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Completed downloading of Hadoop tarball"
argument_list|)
expr_stmt|;
return|return
name|destinationFile
return|;
block|}
comment|/**    * Get the URI that can be used to access the launched NameNode for HDFS RPCs.    *    * @param nameNodeProperties The set of properties representing the    *                           information about the launched NameNode.    * @return The HDFS URI.    */
DECL|method|getNameNodeHdfsUri (Properties nameNodeProperties)
specifier|static
name|URI
name|getNameNodeHdfsUri
parameter_list|(
name|Properties
name|nameNodeProperties
parameter_list|)
block|{
return|return
name|URI
operator|.
name|create
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"hdfs://%s:%s/"
argument_list|,
name|nameNodeProperties
operator|.
name|getProperty
argument_list|(
name|DynoConstants
operator|.
name|NN_HOSTNAME
argument_list|)
argument_list|,
name|nameNodeProperties
operator|.
name|getProperty
argument_list|(
name|DynoConstants
operator|.
name|NN_RPC_PORT
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Get the URI that can be used to access the launched NameNode for HDFS    * Service RPCs (i.e. from DataNodes).    *    * @param nameNodeProperties The set of properties representing the    *                           information about the launched NameNode.    * @return The service RPC URI.    */
DECL|method|getNameNodeServiceRpcAddr (Properties nameNodeProperties)
specifier|static
name|URI
name|getNameNodeServiceRpcAddr
parameter_list|(
name|Properties
name|nameNodeProperties
parameter_list|)
block|{
return|return
name|URI
operator|.
name|create
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"hdfs://%s:%s/"
argument_list|,
name|nameNodeProperties
operator|.
name|getProperty
argument_list|(
name|DynoConstants
operator|.
name|NN_HOSTNAME
argument_list|)
argument_list|,
name|nameNodeProperties
operator|.
name|getProperty
argument_list|(
name|DynoConstants
operator|.
name|NN_SERVICERPC_PORT
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Get the URI that can be used to access the launched NameNode's web UI, e.g.    * for JMX calls.    *    * @param nameNodeProperties The set of properties representing the    *                           information about the launched NameNode.    * @return The URI to the web UI.    */
DECL|method|getNameNodeWebUri (Properties nameNodeProperties)
specifier|static
name|URI
name|getNameNodeWebUri
parameter_list|(
name|Properties
name|nameNodeProperties
parameter_list|)
block|{
return|return
name|URI
operator|.
name|create
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"http://%s:%s/"
argument_list|,
name|nameNodeProperties
operator|.
name|getProperty
argument_list|(
name|DynoConstants
operator|.
name|NN_HOSTNAME
argument_list|)
argument_list|,
name|nameNodeProperties
operator|.
name|getProperty
argument_list|(
name|DynoConstants
operator|.
name|NN_HTTP_PORT
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Get the URI that can be used to access the tracking interface for the    * NameNode, i.e. the web UI of the NodeManager hosting the NameNode    * container.    *    * @param nameNodeProperties The set of properties representing the    *                           information about the launched NameNode.    * @return The tracking URI.    */
DECL|method|getNameNodeTrackingUri (Properties nameNodeProperties)
specifier|static
name|URI
name|getNameNodeTrackingUri
parameter_list|(
name|Properties
name|nameNodeProperties
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|URI
operator|.
name|create
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"http://%s:%s/node/containerlogs/%s/%s/"
argument_list|,
name|nameNodeProperties
operator|.
name|getProperty
argument_list|(
name|DynoConstants
operator|.
name|NN_HOSTNAME
argument_list|)
argument_list|,
name|nameNodeProperties
operator|.
name|getProperty
argument_list|(
name|Environment
operator|.
name|NM_HTTP_PORT
operator|.
name|name
argument_list|()
argument_list|)
argument_list|,
name|nameNodeProperties
operator|.
name|getProperty
argument_list|(
name|Environment
operator|.
name|CONTAINER_ID
operator|.
name|name
argument_list|()
argument_list|)
argument_list|,
name|UserGroupInformation
operator|.
name|getCurrentUser
argument_list|()
operator|.
name|getShortUserName
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Get the set of properties representing information about the launched    * NameNode. This method will wait for the information to be available until    * it is interrupted, or {@code shouldExit} returns true. It polls for a file    * present at {@code nameNodeInfoPath} once a second and uses that file to    * load the NameNode information.    *    * @param shouldExit Should return true iff this should stop waiting.    * @param conf The configuration.    * @param nameNodeInfoPath The path at which to expect the NameNode    *                         information file to be present.    * @param log Where to log information.    * @return Absent if this exited prematurely (i.e. due to {@code shouldExit}),    *         else returns a set of properties representing information about the    *         launched NameNode.    */
DECL|method|waitForAndGetNameNodeProperties ( Supplier<Boolean> shouldExit, Configuration conf, Path nameNodeInfoPath, Logger log)
specifier|static
name|Optional
argument_list|<
name|Properties
argument_list|>
name|waitForAndGetNameNodeProperties
parameter_list|(
name|Supplier
argument_list|<
name|Boolean
argument_list|>
name|shouldExit
parameter_list|,
name|Configuration
name|conf
parameter_list|,
name|Path
name|nameNodeInfoPath
parameter_list|,
name|Logger
name|log
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
while|while
condition|(
operator|!
name|shouldExit
operator|.
name|get
argument_list|()
condition|)
block|{
try|try
init|(
name|FSDataInputStream
name|nnInfoInputStream
init|=
name|nameNodeInfoPath
operator|.
name|getFileSystem
argument_list|(
name|conf
argument_list|)
operator|.
name|open
argument_list|(
name|nameNodeInfoPath
argument_list|)
init|)
block|{
name|Properties
name|nameNodeProperties
init|=
operator|new
name|Properties
argument_list|()
decl_stmt|;
name|nameNodeProperties
operator|.
name|load
argument_list|(
name|nnInfoInputStream
argument_list|)
expr_stmt|;
return|return
name|Optional
operator|.
name|of
argument_list|(
name|nameNodeProperties
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|fnfe
parameter_list|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"NameNode host information not yet available"
argument_list|)
expr_stmt|;
name|Thread
operator|.
name|sleep
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Unable to fetch NameNode host information; retrying"
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
name|Thread
operator|.
name|sleep
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|Optional
operator|.
name|empty
argument_list|()
return|;
block|}
comment|/**    * Wait for the launched NameNode to finish starting up. Continues until    * {@code shouldExit} returns true.    *    * @param nameNodeProperties The set of properties containing information    *                           about the NameNode.    * @param shouldExit Should return true iff this should stop waiting.    * @param log Where to log information.    */
DECL|method|waitForNameNodeStartup (Properties nameNodeProperties, Supplier<Boolean> shouldExit, Logger log)
specifier|static
name|void
name|waitForNameNodeStartup
parameter_list|(
name|Properties
name|nameNodeProperties
parameter_list|,
name|Supplier
argument_list|<
name|Boolean
argument_list|>
name|shouldExit
parameter_list|,
name|Logger
name|log
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
if|if
condition|(
name|shouldExit
operator|.
name|get
argument_list|()
condition|)
block|{
return|return;
block|}
name|log
operator|.
name|info
argument_list|(
literal|"Waiting for NameNode to finish starting up..."
argument_list|)
expr_stmt|;
name|waitForNameNodeJMXValue
argument_list|(
literal|"Startup progress"
argument_list|,
name|NAMENODE_STARTUP_PROGRESS_JMX_QUERY
argument_list|,
literal|"PercentComplete"
argument_list|,
literal|1.0
argument_list|,
literal|0.01
argument_list|,
literal|false
argument_list|,
name|nameNodeProperties
argument_list|,
name|shouldExit
argument_list|,
name|log
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"NameNode has started!"
argument_list|)
expr_stmt|;
block|}
comment|/**    * Wait for the launched NameNode to be ready, i.e. to have at least 99% of    * its DataNodes register, have fewer than 0.01% of its blocks missing, and    * less than 1% of its blocks under replicated. Continues until the criteria    * have been met or {@code shouldExit} returns true.    *    * @param nameNodeProperties The set of properties containing information    *                           about the NameNode.    * @param numTotalDataNodes Total expected number of DataNodes to register.    * @param shouldExit Should return true iff this should stop waiting.    * @param log Where to log information.    */
DECL|method|waitForNameNodeReadiness (final Properties nameNodeProperties, int numTotalDataNodes, boolean triggerBlockReports, Supplier<Boolean> shouldExit, final Configuration conf, final Logger log)
specifier|static
name|void
name|waitForNameNodeReadiness
parameter_list|(
specifier|final
name|Properties
name|nameNodeProperties
parameter_list|,
name|int
name|numTotalDataNodes
parameter_list|,
name|boolean
name|triggerBlockReports
parameter_list|,
name|Supplier
argument_list|<
name|Boolean
argument_list|>
name|shouldExit
parameter_list|,
specifier|final
name|Configuration
name|conf
parameter_list|,
specifier|final
name|Logger
name|log
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
if|if
condition|(
name|shouldExit
operator|.
name|get
argument_list|()
condition|)
block|{
return|return;
block|}
name|int
name|minDataNodes
init|=
call|(
name|int
call|)
argument_list|(
name|conf
operator|.
name|getFloat
argument_list|(
name|DATANODE_LIVE_MIN_FRACTION_KEY
argument_list|,
name|DATANODE_LIVE_MIN_FRACTION_DEFAULT
argument_list|)
operator|*
name|numTotalDataNodes
argument_list|)
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Waiting for %d DataNodes to register with the NameNode..."
argument_list|,
name|minDataNodes
argument_list|)
argument_list|)
expr_stmt|;
name|waitForNameNodeJMXValue
argument_list|(
literal|"Number of live DataNodes"
argument_list|,
name|FSNAMESYSTEM_STATE_JMX_QUERY
argument_list|,
name|JMX_LIVE_NODE_COUNT
argument_list|,
name|minDataNodes
argument_list|,
name|numTotalDataNodes
operator|*
literal|0.001
argument_list|,
literal|false
argument_list|,
name|nameNodeProperties
argument_list|,
name|shouldExit
argument_list|,
name|log
argument_list|)
expr_stmt|;
specifier|final
name|int
name|totalBlocks
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|fetchNameNodeJMXValue
argument_list|(
name|nameNodeProperties
argument_list|,
name|FSNAMESYSTEM_STATE_JMX_QUERY
argument_list|,
name|JMX_BLOCKS_TOTAL
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|AtomicBoolean
name|doneWaiting
init|=
operator|new
name|AtomicBoolean
argument_list|(
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|triggerBlockReports
condition|)
block|{
comment|// This will be significantly lower than the actual expected number of
comment|// blocks because it does not
comment|// take into account replication factor. However the block reports are
comment|// pretty binary; either a full
comment|// report has been received or it hasn't. Thus we don't mind the large
comment|// underestimate here.
specifier|final
name|int
name|blockThreshold
init|=
name|totalBlocks
operator|/
name|numTotalDataNodes
operator|*
literal|2
decl_stmt|;
comment|// The Configuration object here is based on the host cluster, which may
comment|// have security enabled; we need to disable it to talk to the Dyno NN
name|conf
operator|.
name|set
argument_list|(
name|CommonConfigurationKeysPublic
operator|.
name|HADOOP_SECURITY_AUTHENTICATION
argument_list|,
literal|"simple"
argument_list|)
expr_stmt|;
name|conf
operator|.
name|set
argument_list|(
name|CommonConfigurationKeysPublic
operator|.
name|HADOOP_SECURITY_AUTHORIZATION
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
specifier|final
name|DistributedFileSystem
name|dfs
init|=
operator|(
name|DistributedFileSystem
operator|)
name|FileSystem
operator|.
name|get
argument_list|(
name|getNameNodeHdfsUri
argument_list|(
name|nameNodeProperties
argument_list|)
argument_list|,
name|conf
argument_list|)
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Launching thread to trigger block reports for Datanodes with<"
operator|+
name|blockThreshold
operator|+
literal|" blocks reported"
argument_list|)
expr_stmt|;
name|Thread
name|blockReportThread
init|=
operator|new
name|Thread
argument_list|(
parameter_list|()
lambda|->
block|{
comment|// Here we count both Missing and UnderReplicated within under
comment|// replicated
name|long
name|lastUnderRepBlocks
init|=
name|Long
operator|.
name|MAX_VALUE
decl_stmt|;
try|try
block|{
while|while
condition|(
literal|true
condition|)
block|{
comment|// this will eventually exit via an interrupt
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|TimeUnit
operator|.
name|MINUTES
operator|.
name|toMillis
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|long
name|underRepBlocks
init|=
name|Long
operator|.
name|parseLong
argument_list|(
name|fetchNameNodeJMXValue
argument_list|(
name|nameNodeProperties
argument_list|,
name|FSNAMESYSTEM_JMX_QUERY
argument_list|,
name|JMX_MISSING_BLOCKS
argument_list|)
argument_list|)
operator|+
name|Long
operator|.
name|parseLong
argument_list|(
name|fetchNameNodeJMXValue
argument_list|(
name|nameNodeProperties
argument_list|,
name|FSNAMESYSTEM_STATE_JMX_QUERY
argument_list|,
name|JMX_UNDER_REPLICATED_BLOCKS
argument_list|)
argument_list|)
decl_stmt|;
name|long
name|blockDecrease
init|=
name|lastUnderRepBlocks
operator|-
name|underRepBlocks
decl_stmt|;
name|lastUnderRepBlocks
operator|=
name|underRepBlocks
expr_stmt|;
if|if
condition|(
name|blockDecrease
argument_list|<
literal|0
operator|||
name|blockDecrease
argument_list|>
argument_list|(
name|totalBlocks
operator|*
literal|0.001
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|String
name|liveNodeListString
init|=
name|fetchNameNodeJMXValue
argument_list|(
name|nameNodeProperties
argument_list|,
name|NAMENODE_INFO_JMX_QUERY
argument_list|,
name|JMX_LIVE_NODES_LIST
argument_list|)
decl_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|datanodesToReport
init|=
name|parseStaleDataNodeList
argument_list|(
name|liveNodeListString
argument_list|,
name|blockThreshold
argument_list|,
name|log
argument_list|)
decl_stmt|;
if|if
condition|(
name|datanodesToReport
operator|.
name|isEmpty
argument_list|()
operator|&&
name|doneWaiting
operator|.
name|get
argument_list|()
condition|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"BlockReportThread exiting; all DataNodes have "
operator|+
literal|"reported blocks"
argument_list|)
expr_stmt|;
break|break;
block|}
name|log
operator|.
name|info
argument_list|(
literal|"Queueing {} Datanodes for block report: {}"
argument_list|,
name|datanodesToReport
operator|.
name|size
argument_list|()
argument_list|,
name|Joiner
operator|.
name|on
argument_list|(
literal|","
argument_list|)
operator|.
name|join
argument_list|(
name|datanodesToReport
argument_list|)
argument_list|)
expr_stmt|;
name|DatanodeInfo
index|[]
name|datanodes
init|=
name|dfs
operator|.
name|getDataNodeStats
argument_list|()
decl_stmt|;
name|int
name|cnt
init|=
literal|0
decl_stmt|;
for|for
control|(
name|DatanodeInfo
name|datanode
range|:
name|datanodes
control|)
block|{
if|if
condition|(
name|datanodesToReport
operator|.
name|contains
argument_list|(
name|datanode
operator|.
name|getXferAddr
argument_list|(
literal|true
argument_list|)
argument_list|)
condition|)
block|{
name|Thread
operator|.
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|// to throw an interrupt if one is found
name|triggerDataNodeBlockReport
argument_list|(
name|conf
argument_list|,
name|datanode
operator|.
name|getIpcAddr
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|cnt
operator|++
expr_stmt|;
name|Thread
operator|.
name|sleep
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cnt
operator|!=
name|datanodesToReport
operator|.
name|size
argument_list|()
condition|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Found {} Datanodes to queue block reports for but "
operator|+
literal|"was only able to trigger {}"
argument_list|,
name|datanodesToReport
operator|.
name|size
argument_list|()
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Exception encountered in block report thread"
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
comment|// Do nothing; just exit
block|}
name|log
operator|.
name|info
argument_list|(
literal|"Block reporting thread exiting"
argument_list|)
expr_stmt|;
block|}
argument_list|)
decl_stmt|;
name|blockReportThread
operator|.
name|setDaemon
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|blockReportThread
operator|.
name|setUncaughtExceptionHandler
argument_list|(
operator|new
name|YarnUncaughtExceptionHandler
argument_list|()
argument_list|)
expr_stmt|;
name|blockReportThread
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
name|float
name|maxMissingBlocks
init|=
name|totalBlocks
operator|*
name|conf
operator|.
name|getFloat
argument_list|(
name|MISSING_BLOCKS_MAX_FRACTION_KEY
argument_list|,
name|MISSING_BLOCKS_MAX_FRACTION_DEFAULT
argument_list|)
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Waiting for MissingBlocks to fall below {}..."
argument_list|,
name|maxMissingBlocks
argument_list|)
expr_stmt|;
name|waitForNameNodeJMXValue
argument_list|(
literal|"Number of missing blocks"
argument_list|,
name|FSNAMESYSTEM_JMX_QUERY
argument_list|,
name|JMX_MISSING_BLOCKS
argument_list|,
name|maxMissingBlocks
argument_list|,
name|totalBlocks
operator|*
literal|0.0001
argument_list|,
literal|true
argument_list|,
name|nameNodeProperties
argument_list|,
name|shouldExit
argument_list|,
name|log
argument_list|)
expr_stmt|;
name|float
name|maxUnderreplicatedBlocks
init|=
name|totalBlocks
operator|*
name|conf
operator|.
name|getFloat
argument_list|(
name|UNDERREPLICATED_BLOCKS_MAX_FRACTION_KEY
argument_list|,
name|UNDERREPLICATED_BLOCKS_MAX_FRACTION_DEFAULT
argument_list|)
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Waiting for UnderReplicatedBlocks to fall below {}..."
argument_list|,
name|maxUnderreplicatedBlocks
argument_list|)
expr_stmt|;
name|waitForNameNodeJMXValue
argument_list|(
literal|"Number of under replicated blocks"
argument_list|,
name|FSNAMESYSTEM_STATE_JMX_QUERY
argument_list|,
name|JMX_UNDER_REPLICATED_BLOCKS
argument_list|,
name|maxUnderreplicatedBlocks
argument_list|,
name|totalBlocks
operator|*
literal|0.001
argument_list|,
literal|true
argument_list|,
name|nameNodeProperties
argument_list|,
name|shouldExit
argument_list|,
name|log
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"NameNode is ready for use!"
argument_list|)
expr_stmt|;
name|doneWaiting
operator|.
name|set
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**    * Trigger a block report on a given DataNode.    *    * @param conf Configuration    * @param dataNodeTarget The target; should be like {@code<host>:<port>}    */
DECL|method|triggerDataNodeBlockReport (Configuration conf, String dataNodeTarget)
specifier|private
specifier|static
name|void
name|triggerDataNodeBlockReport
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|String
name|dataNodeTarget
parameter_list|)
throws|throws
name|IOException
block|{
name|InetSocketAddress
name|datanodeAddr
init|=
name|NetUtils
operator|.
name|createSocketAddr
argument_list|(
name|dataNodeTarget
argument_list|)
decl_stmt|;
name|ClientDatanodeProtocol
name|dnProtocol
init|=
name|DFSUtilClient
operator|.
name|createClientDatanodeProtocolProxy
argument_list|(
name|datanodeAddr
argument_list|,
name|UserGroupInformation
operator|.
name|getCurrentUser
argument_list|()
argument_list|,
name|conf
argument_list|,
name|NetUtils
operator|.
name|getSocketFactory
argument_list|(
name|conf
argument_list|,
name|ClientDatanodeProtocol
operator|.
name|class
argument_list|)
argument_list|)
decl_stmt|;
name|dnProtocol
operator|.
name|triggerBlockReport
argument_list|(
operator|new
name|BlockReportOptions
operator|.
name|Factory
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Poll the launched NameNode's JMX for a specific value, waiting for it to    * cross some threshold. Continues until the threshold has been crossed or    * {@code shouldExit} returns true. Periodically logs the current value.    *    * @param valueName The human-readable name of the value which is being    *                  polled (for printing purposes only).    * @param jmxBeanQuery The JMX bean query to execute; should return a JMX    *                     property matching {@code jmxProperty}.    * @param jmxProperty The name of the JMX property whose value should be    *                    polled.    * @param threshold The threshold value to wait for the JMX property to be    *                  above/below.    * @param printThreshold The threshold between each log statement; controls    *                       how frequently the value is printed. For example,    *                       if this was 10, a statement would be logged every    *                       time the value has changed by more than 10.    * @param decreasing True iff the property's value is decreasing and this    *                   should wait until it is lower than threshold; else the    *                   value is treated as increasing and will wait until it    *                   is higher than threshold.    * @param nameNodeProperties The set of properties containing information    *                           about the NameNode.    * @param shouldExit Should return true iff this should stop waiting.    * @param log Where to log information.    */
DECL|method|waitForNameNodeJMXValue (String valueName, String jmxBeanQuery, String jmxProperty, double threshold, double printThreshold, boolean decreasing, Properties nameNodeProperties, Supplier<Boolean> shouldExit, Logger log)
specifier|private
specifier|static
name|void
name|waitForNameNodeJMXValue
parameter_list|(
name|String
name|valueName
parameter_list|,
name|String
name|jmxBeanQuery
parameter_list|,
name|String
name|jmxProperty
parameter_list|,
name|double
name|threshold
parameter_list|,
name|double
name|printThreshold
parameter_list|,
name|boolean
name|decreasing
parameter_list|,
name|Properties
name|nameNodeProperties
parameter_list|,
name|Supplier
argument_list|<
name|Boolean
argument_list|>
name|shouldExit
parameter_list|,
name|Logger
name|log
parameter_list|)
throws|throws
name|InterruptedException
block|{
name|double
name|lastPrintedValue
init|=
name|decreasing
condition|?
name|Double
operator|.
name|MAX_VALUE
else|:
name|Double
operator|.
name|MIN_VALUE
decl_stmt|;
name|double
name|value
decl_stmt|;
name|int
name|retryCount
init|=
literal|0
decl_stmt|;
name|long
name|startTime
init|=
name|Time
operator|.
name|monotonicNow
argument_list|()
decl_stmt|;
while|while
condition|(
operator|!
name|shouldExit
operator|.
name|get
argument_list|()
condition|)
block|{
try|try
block|{
name|value
operator|=
name|Double
operator|.
name|parseDouble
argument_list|(
name|fetchNameNodeJMXValue
argument_list|(
name|nameNodeProperties
argument_list|,
name|jmxBeanQuery
argument_list|,
name|jmxProperty
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|decreasing
operator|&&
name|value
operator|<=
name|threshold
operator|)
operator|||
operator|(
operator|!
name|decreasing
operator|&&
name|value
operator|>=
name|threshold
operator|)
condition|)
block|{
name|log
operator|.
name|info
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"%s = %.2f; %s threshold of %.2f; done waiting after %d ms."
argument_list|,
name|valueName
argument_list|,
name|value
argument_list|,
name|decreasing
condition|?
literal|"below"
else|:
literal|"above"
argument_list|,
name|threshold
argument_list|,
name|Time
operator|.
name|monotonicNow
argument_list|()
operator|-
name|startTime
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|Math
operator|.
name|abs
argument_list|(
name|value
operator|-
name|lastPrintedValue
argument_list|)
operator|>=
name|printThreshold
condition|)
block|{
name|log
operator|.
name|info
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"%s: %.2f"
argument_list|,
name|valueName
argument_list|,
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|lastPrintedValue
operator|=
name|value
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
if|if
condition|(
operator|++
name|retryCount
operator|%
literal|20
operator|==
literal|0
condition|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Unable to fetch {}; retried {} times / waited {} ms"
argument_list|,
name|valueName
argument_list|,
name|retryCount
argument_list|,
name|Time
operator|.
name|monotonicNow
argument_list|()
operator|-
name|startTime
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
block|}
block|}
name|Thread
operator|.
name|sleep
argument_list|(
literal|3000
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|parseStaleDataNodeList (String liveNodeJsonString, final int blockThreshold, final Logger log)
specifier|static
name|Set
argument_list|<
name|String
argument_list|>
name|parseStaleDataNodeList
parameter_list|(
name|String
name|liveNodeJsonString
parameter_list|,
specifier|final
name|int
name|blockThreshold
parameter_list|,
specifier|final
name|Logger
name|log
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|dataNodesToReport
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
name|JsonFactory
name|fac
init|=
operator|new
name|JsonFactory
argument_list|()
decl_stmt|;
name|JsonParser
name|parser
init|=
name|fac
operator|.
name|createJsonParser
argument_list|(
name|IOUtils
operator|.
name|toInputStream
argument_list|(
name|liveNodeJsonString
argument_list|,
name|StandardCharsets
operator|.
name|UTF_8
operator|.
name|name
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|objectDepth
init|=
literal|0
decl_stmt|;
name|String
name|currentNodeAddr
init|=
literal|null
decl_stmt|;
for|for
control|(
name|JsonToken
name|tok
init|=
name|parser
operator|.
name|nextToken
argument_list|()
init|;
name|tok
operator|!=
literal|null
condition|;
name|tok
operator|=
name|parser
operator|.
name|nextToken
argument_list|()
control|)
block|{
if|if
condition|(
name|tok
operator|==
name|JsonToken
operator|.
name|START_OBJECT
condition|)
block|{
name|objectDepth
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tok
operator|==
name|JsonToken
operator|.
name|END_OBJECT
condition|)
block|{
name|objectDepth
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tok
operator|==
name|JsonToken
operator|.
name|FIELD_NAME
condition|)
block|{
if|if
condition|(
name|objectDepth
operator|==
literal|1
condition|)
block|{
comment|// This is where the Datanode identifiers are stored
name|currentNodeAddr
operator|=
name|parser
operator|.
name|getCurrentName
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|objectDepth
operator|==
literal|2
condition|)
block|{
if|if
condition|(
name|parser
operator|.
name|getCurrentName
argument_list|()
operator|.
name|equals
argument_list|(
literal|"numBlocks"
argument_list|)
condition|)
block|{
name|JsonToken
name|valueToken
init|=
name|parser
operator|.
name|nextToken
argument_list|()
decl_stmt|;
if|if
condition|(
name|valueToken
operator|!=
name|JsonToken
operator|.
name|VALUE_NUMBER_INT
operator|||
name|currentNodeAddr
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Malformed LiveNodes JSON; "
operator|+
literal|"got token = %s; currentNodeAddr = %s: %s"
argument_list|,
name|valueToken
argument_list|,
name|currentNodeAddr
argument_list|,
name|liveNodeJsonString
argument_list|)
argument_list|)
throw|;
block|}
name|int
name|numBlocks
init|=
name|parser
operator|.
name|getIntValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|numBlocks
operator|<
name|blockThreshold
condition|)
block|{
name|log
operator|.
name|debug
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Queueing Datanode<%s> for block report; numBlocks = %d"
argument_list|,
name|currentNodeAddr
argument_list|,
name|numBlocks
argument_list|)
argument_list|)
expr_stmt|;
name|dataNodesToReport
operator|.
name|add
argument_list|(
name|currentNodeAddr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|log
operator|.
name|debug
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Not queueing Datanode<%s> for block report; numBlocks = %d"
argument_list|,
name|currentNodeAddr
argument_list|,
name|numBlocks
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
return|return
name|dataNodesToReport
return|;
block|}
comment|/**    * Fetch a value from the launched NameNode's JMX.    *    * @param nameNodeProperties The set of properties containing information    *                           about the NameNode.    * @param jmxBeanQuery The JMX bean query to execute; should return a    *                     JMX property matching {@code jmxProperty}.    * @param property The name of the JMX property whose value should be polled.    * @return The value associated with the property.    */
DECL|method|fetchNameNodeJMXValue (Properties nameNodeProperties, String jmxBeanQuery, String property)
specifier|static
name|String
name|fetchNameNodeJMXValue
parameter_list|(
name|Properties
name|nameNodeProperties
parameter_list|,
name|String
name|jmxBeanQuery
parameter_list|,
name|String
name|property
parameter_list|)
throws|throws
name|IOException
block|{
name|URI
name|nnWebUri
init|=
name|getNameNodeWebUri
argument_list|(
name|nameNodeProperties
argument_list|)
decl_stmt|;
name|URL
name|queryURL
decl_stmt|;
try|try
block|{
name|queryURL
operator|=
operator|new
name|URL
argument_list|(
name|nnWebUri
operator|.
name|getScheme
argument_list|()
argument_list|,
name|nnWebUri
operator|.
name|getHost
argument_list|()
argument_list|,
name|nnWebUri
operator|.
name|getPort
argument_list|()
argument_list|,
literal|"/jmx?qry="
operator|+
name|jmxBeanQuery
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|MalformedURLException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Invalid JMX query: \""
operator|+
name|jmxBeanQuery
operator|+
literal|"\" against "
operator|+
literal|"NameNode URI: "
operator|+
name|nnWebUri
argument_list|)
throw|;
block|}
name|HttpURLConnection
name|conn
init|=
operator|(
name|HttpURLConnection
operator|)
name|queryURL
operator|.
name|openConnection
argument_list|()
decl_stmt|;
if|if
condition|(
name|conn
operator|.
name|getResponseCode
argument_list|()
operator|!=
literal|200
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unable to retrieve JMX: "
operator|+
name|conn
operator|.
name|getResponseMessage
argument_list|()
argument_list|)
throw|;
block|}
name|InputStream
name|in
init|=
name|conn
operator|.
name|getInputStream
argument_list|()
decl_stmt|;
name|JsonFactory
name|fac
init|=
operator|new
name|JsonFactory
argument_list|()
decl_stmt|;
name|JsonParser
name|parser
init|=
name|fac
operator|.
name|createJsonParser
argument_list|(
name|in
argument_list|)
decl_stmt|;
if|if
condition|(
name|parser
operator|.
name|nextToken
argument_list|()
operator|!=
name|JsonToken
operator|.
name|START_OBJECT
operator|||
name|parser
operator|.
name|nextToken
argument_list|()
operator|!=
name|JsonToken
operator|.
name|FIELD_NAME
operator|||
operator|!
name|parser
operator|.
name|getCurrentName
argument_list|()
operator|.
name|equals
argument_list|(
literal|"beans"
argument_list|)
operator|||
name|parser
operator|.
name|nextToken
argument_list|()
operator|!=
name|JsonToken
operator|.
name|START_ARRAY
operator|||
name|parser
operator|.
name|nextToken
argument_list|()
operator|!=
name|JsonToken
operator|.
name|START_OBJECT
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unexpected format of JMX JSON response for: "
operator|+
name|jmxBeanQuery
argument_list|)
throw|;
block|}
name|int
name|objectDepth
init|=
literal|1
decl_stmt|;
name|String
name|ret
init|=
literal|null
decl_stmt|;
while|while
condition|(
name|objectDepth
operator|>
literal|0
condition|)
block|{
name|JsonToken
name|tok
init|=
name|parser
operator|.
name|nextToken
argument_list|()
decl_stmt|;
if|if
condition|(
name|tok
operator|==
name|JsonToken
operator|.
name|START_OBJECT
condition|)
block|{
name|objectDepth
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tok
operator|==
name|JsonToken
operator|.
name|END_OBJECT
condition|)
block|{
name|objectDepth
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tok
operator|==
name|JsonToken
operator|.
name|FIELD_NAME
condition|)
block|{
if|if
condition|(
name|parser
operator|.
name|getCurrentName
argument_list|()
operator|.
name|equals
argument_list|(
name|property
argument_list|)
condition|)
block|{
name|parser
operator|.
name|nextToken
argument_list|()
expr_stmt|;
name|ret
operator|=
name|parser
operator|.
name|getText
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
block|}
name|parser
operator|.
name|close
argument_list|()
expr_stmt|;
name|in
operator|.
name|close
argument_list|()
expr_stmt|;
name|conn
operator|.
name|disconnect
argument_list|()
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Property "
operator|+
name|property
operator|+
literal|" not found within "
operator|+
name|jmxBeanQuery
argument_list|)
throw|;
block|}
else|else
block|{
return|return
name|ret
return|;
block|}
block|}
block|}
end_class

end_unit

