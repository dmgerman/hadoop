begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.tools
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|tools
package|;
end_package

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|cli
operator|.
name|CommandLine
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|cli
operator|.
name|CommandLineParser
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|cli
operator|.
name|GnuParser
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|cli
operator|.
name|HelpFormatter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|cli
operator|.
name|Option
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|cli
operator|.
name|Options
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|cli
operator|.
name|ParseException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|io
operator|.
name|output
operator|.
name|FileWriterWithEncoding
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|RemoteIterator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|permission
operator|.
name|FsAction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|permission
operator|.
name|FsPermission
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|JobConf
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Tool
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|ToolRunner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ApplicationId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ApplicationReport
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|LogAggregationStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|applications
operator|.
name|distributedshell
operator|.
name|ApplicationMaster
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|applications
operator|.
name|distributedshell
operator|.
name|Client
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|client
operator|.
name|api
operator|.
name|YarnClient
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|conf
operator|.
name|YarnConfiguration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|exceptions
operator|.
name|ApplicationNotFoundException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|exceptions
operator|.
name|YarnException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|logaggregation
operator|.
name|filecontroller
operator|.
name|LogAggregationFileController
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|logaggregation
operator|.
name|filecontroller
operator|.
name|LogAggregationFileControllerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|util
operator|.
name|ConverterUtils
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_comment
comment|/**  * This tool moves Aggregated Log files into HAR archives using the  * {@link HadoopArchives} tool and the Distributed Shell via the  * {@link HadoopArchiveLogsRunner}.  */
end_comment

begin_class
DECL|class|HadoopArchiveLogs
specifier|public
class|class
name|HadoopArchiveLogs
implements|implements
name|Tool
block|{
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|HadoopArchiveLogs
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|HELP_OPTION
specifier|private
specifier|static
specifier|final
name|String
name|HELP_OPTION
init|=
literal|"help"
decl_stmt|;
DECL|field|MAX_ELIGIBLE_APPS_OPTION
specifier|private
specifier|static
specifier|final
name|String
name|MAX_ELIGIBLE_APPS_OPTION
init|=
literal|"maxEligibleApps"
decl_stmt|;
DECL|field|MIN_NUM_LOG_FILES_OPTION
specifier|private
specifier|static
specifier|final
name|String
name|MIN_NUM_LOG_FILES_OPTION
init|=
literal|"minNumberLogFiles"
decl_stmt|;
DECL|field|MAX_TOTAL_LOGS_SIZE_OPTION
specifier|private
specifier|static
specifier|final
name|String
name|MAX_TOTAL_LOGS_SIZE_OPTION
init|=
literal|"maxTotalLogsSize"
decl_stmt|;
DECL|field|MEMORY_OPTION
specifier|private
specifier|static
specifier|final
name|String
name|MEMORY_OPTION
init|=
literal|"memory"
decl_stmt|;
DECL|field|VERBOSE_OPTION
specifier|private
specifier|static
specifier|final
name|String
name|VERBOSE_OPTION
init|=
literal|"verbose"
decl_stmt|;
DECL|field|FORCE_OPTION
specifier|private
specifier|static
specifier|final
name|String
name|FORCE_OPTION
init|=
literal|"force"
decl_stmt|;
DECL|field|NO_PROXY_OPTION
specifier|private
specifier|static
specifier|final
name|String
name|NO_PROXY_OPTION
init|=
literal|"noProxy"
decl_stmt|;
DECL|field|DEFAULT_MAX_ELIGIBLE
specifier|private
specifier|static
specifier|final
name|int
name|DEFAULT_MAX_ELIGIBLE
init|=
operator|-
literal|1
decl_stmt|;
DECL|field|DEFAULT_MIN_NUM_LOG_FILES
specifier|private
specifier|static
specifier|final
name|int
name|DEFAULT_MIN_NUM_LOG_FILES
init|=
literal|20
decl_stmt|;
DECL|field|DEFAULT_MAX_TOTAL_LOGS_SIZE
specifier|private
specifier|static
specifier|final
name|long
name|DEFAULT_MAX_TOTAL_LOGS_SIZE
init|=
literal|1024L
decl_stmt|;
DECL|field|DEFAULT_MEMORY
specifier|private
specifier|static
specifier|final
name|long
name|DEFAULT_MEMORY
init|=
literal|1024L
decl_stmt|;
annotation|@
name|VisibleForTesting
DECL|field|maxEligible
name|int
name|maxEligible
init|=
name|DEFAULT_MAX_ELIGIBLE
decl_stmt|;
annotation|@
name|VisibleForTesting
DECL|field|minNumLogFiles
name|int
name|minNumLogFiles
init|=
name|DEFAULT_MIN_NUM_LOG_FILES
decl_stmt|;
annotation|@
name|VisibleForTesting
DECL|field|maxTotalLogsSize
name|long
name|maxTotalLogsSize
init|=
name|DEFAULT_MAX_TOTAL_LOGS_SIZE
operator|*
literal|1024L
operator|*
literal|1024L
decl_stmt|;
annotation|@
name|VisibleForTesting
DECL|field|memory
name|long
name|memory
init|=
name|DEFAULT_MEMORY
decl_stmt|;
DECL|field|verbose
specifier|private
name|boolean
name|verbose
init|=
literal|false
decl_stmt|;
annotation|@
name|VisibleForTesting
DECL|field|force
name|boolean
name|force
init|=
literal|false
decl_stmt|;
annotation|@
name|VisibleForTesting
DECL|field|proxy
name|boolean
name|proxy
init|=
literal|true
decl_stmt|;
annotation|@
name|VisibleForTesting
DECL|field|eligibleApplications
name|Set
argument_list|<
name|AppInfo
argument_list|>
name|eligibleApplications
decl_stmt|;
DECL|field|workingDirs
specifier|private
name|Set
argument_list|<
name|Path
argument_list|>
name|workingDirs
decl_stmt|;
DECL|field|conf
specifier|private
name|JobConf
name|conf
decl_stmt|;
DECL|method|HadoopArchiveLogs (Configuration conf)
specifier|public
name|HadoopArchiveLogs
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
name|setConf
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|eligibleApplications
operator|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
expr_stmt|;
name|workingDirs
operator|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
expr_stmt|;
block|}
DECL|method|main (String[] args)
specifier|public
specifier|static
name|void
name|main
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
block|{
name|JobConf
name|job
init|=
operator|new
name|JobConf
argument_list|(
name|HadoopArchiveLogs
operator|.
name|class
argument_list|)
decl_stmt|;
name|HadoopArchiveLogs
name|hal
init|=
operator|new
name|HadoopArchiveLogs
argument_list|(
name|job
argument_list|)
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
try|try
block|{
name|ret
operator|=
name|ToolRunner
operator|.
name|run
argument_list|(
name|hal
argument_list|,
name|args
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Exception"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
name|e
operator|.
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|String
name|s
init|=
name|e
operator|.
name|getLocalizedMessage
argument_list|()
decl_stmt|;
if|if
condition|(
name|s
operator|!=
literal|null
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|e
operator|.
name|printStackTrace
argument_list|(
name|System
operator|.
name|err
argument_list|)
expr_stmt|;
block|}
name|System
operator|.
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|System
operator|.
name|exit
argument_list|(
name|ret
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|run (String[] args)
specifier|public
name|int
name|run
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
throws|throws
name|Exception
block|{
name|int
name|exitCode
init|=
literal|1
decl_stmt|;
name|handleOpts
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|FileSystem
name|fs
init|=
literal|null
decl_stmt|;
name|LogAggregationFileControllerFactory
name|factory
init|=
operator|new
name|LogAggregationFileControllerFactory
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|LogAggregationFileController
argument_list|>
name|fileControllers
init|=
name|factory
operator|.
name|getConfiguredLogAggregationFileControllerList
argument_list|()
decl_stmt|;
if|if
condition|(
name|fileControllers
operator|==
literal|null
operator|||
name|fileControllers
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Can not find any valid fileControllers."
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"The configurated fileControllers:"
operator|+
name|YarnConfiguration
operator|.
name|LOG_AGGREGATION_FILE_FORMATS
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
try|try
block|{
name|fs
operator|=
name|FileSystem
operator|.
name|get
argument_list|(
name|conf
argument_list|)
expr_stmt|;
comment|// find eligibleApplications for all the fileControllers
name|int
name|previousTotal
init|=
literal|0
decl_stmt|;
for|for
control|(
name|LogAggregationFileController
name|fileController
range|:
name|fileControllers
control|)
block|{
name|Path
name|remoteRootLogDir
init|=
name|fileController
operator|.
name|getRemoteRootLogDir
argument_list|()
decl_stmt|;
name|String
name|suffix
init|=
name|fileController
operator|.
name|getRemoteRootLogDirSuffix
argument_list|()
decl_stmt|;
name|Path
name|workingDir
init|=
operator|new
name|Path
argument_list|(
name|remoteRootLogDir
argument_list|,
literal|"archive-logs-work"
argument_list|)
decl_stmt|;
if|if
condition|(
name|verbose
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"LogAggregationFileController:"
operator|+
name|fileController
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Remote Log Dir Root: "
operator|+
name|remoteRootLogDir
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Log Suffix: "
operator|+
name|suffix
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Working Dir: "
operator|+
name|workingDir
argument_list|)
expr_stmt|;
block|}
name|checkFilesAndSeedApps
argument_list|(
name|fs
argument_list|,
name|remoteRootLogDir
argument_list|,
name|suffix
argument_list|,
name|workingDir
argument_list|)
expr_stmt|;
name|filterAppsByAggregatedStatus
argument_list|()
expr_stmt|;
if|if
condition|(
name|eligibleApplications
operator|.
name|size
argument_list|()
operator|>
name|previousTotal
condition|)
block|{
name|workingDirs
operator|.
name|add
argument_list|(
name|workingDir
argument_list|)
expr_stmt|;
name|previousTotal
operator|=
name|eligibleApplications
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
block|}
name|checkMaxEligible
argument_list|()
expr_stmt|;
if|if
condition|(
name|workingDirs
operator|.
name|isEmpty
argument_list|()
operator|||
name|eligibleApplications
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"No eligible applications to process"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
for|for
control|(
name|Path
name|workingDir
range|:
name|workingDirs
control|)
block|{
if|if
condition|(
operator|!
name|prepareWorkingDir
argument_list|(
name|fs
argument_list|,
name|workingDir
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Failed to create the workingDir:"
operator|+
name|workingDir
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|(
literal|"Will process the following applications:"
argument_list|)
decl_stmt|;
for|for
control|(
name|AppInfo
name|app
range|:
name|eligibleApplications
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|"\n\t"
argument_list|)
operator|.
name|append
argument_list|(
name|app
operator|.
name|getAppId
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
name|sb
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|File
name|localScript
init|=
name|File
operator|.
name|createTempFile
argument_list|(
literal|"hadoop-archive-logs-"
argument_list|,
literal|".sh"
argument_list|)
decl_stmt|;
name|generateScript
argument_list|(
name|localScript
argument_list|)
expr_stmt|;
name|exitCode
operator|=
name|runDistributedShell
argument_list|(
name|localScript
argument_list|)
condition|?
literal|0
else|:
literal|1
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|fs
operator|!=
literal|null
condition|)
block|{
comment|// Cleanup working directory
for|for
control|(
name|Path
name|workingDir
range|:
name|workingDirs
control|)
block|{
name|fs
operator|.
name|delete
argument_list|(
name|workingDir
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
name|fs
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|exitCode
return|;
block|}
DECL|method|handleOpts (String[] args)
specifier|private
name|void
name|handleOpts
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
throws|throws
name|ParseException
block|{
name|Options
name|opts
init|=
operator|new
name|Options
argument_list|()
decl_stmt|;
name|Option
name|helpOpt
init|=
operator|new
name|Option
argument_list|(
name|HELP_OPTION
argument_list|,
literal|false
argument_list|,
literal|"Prints this message"
argument_list|)
decl_stmt|;
name|Option
name|maxEligibleOpt
init|=
operator|new
name|Option
argument_list|(
name|MAX_ELIGIBLE_APPS_OPTION
argument_list|,
literal|true
argument_list|,
literal|"The maximum number of eligible apps to process (default: "
operator|+
name|DEFAULT_MAX_ELIGIBLE
operator|+
literal|" (all))"
argument_list|)
decl_stmt|;
name|maxEligibleOpt
operator|.
name|setArgName
argument_list|(
literal|"n"
argument_list|)
expr_stmt|;
name|Option
name|minNumLogFilesOpt
init|=
operator|new
name|Option
argument_list|(
name|MIN_NUM_LOG_FILES_OPTION
argument_list|,
literal|true
argument_list|,
literal|"The minimum number of log files required to be eligible (default: "
operator|+
name|DEFAULT_MIN_NUM_LOG_FILES
operator|+
literal|")"
argument_list|)
decl_stmt|;
name|minNumLogFilesOpt
operator|.
name|setArgName
argument_list|(
literal|"n"
argument_list|)
expr_stmt|;
name|Option
name|maxTotalLogsSizeOpt
init|=
operator|new
name|Option
argument_list|(
name|MAX_TOTAL_LOGS_SIZE_OPTION
argument_list|,
literal|true
argument_list|,
literal|"The maximum total logs size (in megabytes) required to be eligible"
operator|+
literal|" (default: "
operator|+
name|DEFAULT_MAX_TOTAL_LOGS_SIZE
operator|+
literal|")"
argument_list|)
decl_stmt|;
name|maxTotalLogsSizeOpt
operator|.
name|setArgName
argument_list|(
literal|"megabytes"
argument_list|)
expr_stmt|;
name|Option
name|memoryOpt
init|=
operator|new
name|Option
argument_list|(
name|MEMORY_OPTION
argument_list|,
literal|true
argument_list|,
literal|"The amount of memory (in megabytes) for each container (default: "
operator|+
name|DEFAULT_MEMORY
operator|+
literal|")"
argument_list|)
decl_stmt|;
name|memoryOpt
operator|.
name|setArgName
argument_list|(
literal|"megabytes"
argument_list|)
expr_stmt|;
name|Option
name|verboseOpt
init|=
operator|new
name|Option
argument_list|(
name|VERBOSE_OPTION
argument_list|,
literal|false
argument_list|,
literal|"Print more details."
argument_list|)
decl_stmt|;
name|Option
name|forceOpt
init|=
operator|new
name|Option
argument_list|(
name|FORCE_OPTION
argument_list|,
literal|false
argument_list|,
literal|"Force recreating the working directory if an existing one is found. "
operator|+
literal|"This should only be used if you know that another instance is "
operator|+
literal|"not currently running"
argument_list|)
decl_stmt|;
name|Option
name|noProxyOpt
init|=
operator|new
name|Option
argument_list|(
name|NO_PROXY_OPTION
argument_list|,
literal|false
argument_list|,
literal|"When specified, all processing will be done as the user running this"
operator|+
literal|" command (or the Yarn user if DefaultContainerExecutor is in "
operator|+
literal|"use). When not specified, all processing will be done as the "
operator|+
literal|"user who owns that application; if the user running this command"
operator|+
literal|" is not allowed to impersonate that user, it will fail"
argument_list|)
decl_stmt|;
name|opts
operator|.
name|addOption
argument_list|(
name|helpOpt
argument_list|)
expr_stmt|;
name|opts
operator|.
name|addOption
argument_list|(
name|maxEligibleOpt
argument_list|)
expr_stmt|;
name|opts
operator|.
name|addOption
argument_list|(
name|minNumLogFilesOpt
argument_list|)
expr_stmt|;
name|opts
operator|.
name|addOption
argument_list|(
name|maxTotalLogsSizeOpt
argument_list|)
expr_stmt|;
name|opts
operator|.
name|addOption
argument_list|(
name|memoryOpt
argument_list|)
expr_stmt|;
name|opts
operator|.
name|addOption
argument_list|(
name|verboseOpt
argument_list|)
expr_stmt|;
name|opts
operator|.
name|addOption
argument_list|(
name|forceOpt
argument_list|)
expr_stmt|;
name|opts
operator|.
name|addOption
argument_list|(
name|noProxyOpt
argument_list|)
expr_stmt|;
try|try
block|{
name|CommandLineParser
name|parser
init|=
operator|new
name|GnuParser
argument_list|()
decl_stmt|;
name|CommandLine
name|commandLine
init|=
name|parser
operator|.
name|parse
argument_list|(
name|opts
argument_list|,
name|args
argument_list|)
decl_stmt|;
if|if
condition|(
name|commandLine
operator|.
name|hasOption
argument_list|(
name|HELP_OPTION
argument_list|)
condition|)
block|{
name|HelpFormatter
name|formatter
init|=
operator|new
name|HelpFormatter
argument_list|()
decl_stmt|;
name|formatter
operator|.
name|printHelp
argument_list|(
literal|"mapred archive-logs"
argument_list|,
name|opts
argument_list|)
expr_stmt|;
name|System
operator|.
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|commandLine
operator|.
name|hasOption
argument_list|(
name|MAX_ELIGIBLE_APPS_OPTION
argument_list|)
condition|)
block|{
name|maxEligible
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|commandLine
operator|.
name|getOptionValue
argument_list|(
name|MAX_ELIGIBLE_APPS_OPTION
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|maxEligible
operator|==
literal|0
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Setting "
operator|+
name|MAX_ELIGIBLE_APPS_OPTION
operator|+
literal|" to 0 accomplishes "
operator|+
literal|"nothing. Please either set it to a negative value "
operator|+
literal|"(default, all) or a more reasonable value."
argument_list|)
expr_stmt|;
name|System
operator|.
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|commandLine
operator|.
name|hasOption
argument_list|(
name|MIN_NUM_LOG_FILES_OPTION
argument_list|)
condition|)
block|{
name|minNumLogFiles
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|commandLine
operator|.
name|getOptionValue
argument_list|(
name|MIN_NUM_LOG_FILES_OPTION
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|commandLine
operator|.
name|hasOption
argument_list|(
name|MAX_TOTAL_LOGS_SIZE_OPTION
argument_list|)
condition|)
block|{
name|maxTotalLogsSize
operator|=
name|Long
operator|.
name|parseLong
argument_list|(
name|commandLine
operator|.
name|getOptionValue
argument_list|(
name|MAX_TOTAL_LOGS_SIZE_OPTION
argument_list|)
argument_list|)
expr_stmt|;
name|maxTotalLogsSize
operator|*=
literal|1024L
operator|*
literal|1024L
expr_stmt|;
block|}
if|if
condition|(
name|commandLine
operator|.
name|hasOption
argument_list|(
name|MEMORY_OPTION
argument_list|)
condition|)
block|{
name|memory
operator|=
name|Long
operator|.
name|parseLong
argument_list|(
name|commandLine
operator|.
name|getOptionValue
argument_list|(
name|MEMORY_OPTION
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|commandLine
operator|.
name|hasOption
argument_list|(
name|VERBOSE_OPTION
argument_list|)
condition|)
block|{
name|verbose
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|commandLine
operator|.
name|hasOption
argument_list|(
name|FORCE_OPTION
argument_list|)
condition|)
block|{
name|force
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|commandLine
operator|.
name|hasOption
argument_list|(
name|NO_PROXY_OPTION
argument_list|)
condition|)
block|{
name|proxy
operator|=
literal|false
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|ParseException
name|pe
parameter_list|)
block|{
name|HelpFormatter
name|formatter
init|=
operator|new
name|HelpFormatter
argument_list|()
decl_stmt|;
name|formatter
operator|.
name|printHelp
argument_list|(
literal|"mapred archive-logs"
argument_list|,
name|opts
argument_list|)
expr_stmt|;
throw|throw
name|pe
throw|;
block|}
block|}
annotation|@
name|VisibleForTesting
DECL|method|prepareWorkingDir (FileSystem fs, Path workingDir)
name|boolean
name|prepareWorkingDir
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Path
name|workingDir
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|fs
operator|.
name|exists
argument_list|(
name|workingDir
argument_list|)
condition|)
block|{
if|if
condition|(
name|force
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Existing Working Dir detected: -"
operator|+
name|FORCE_OPTION
operator|+
literal|" specified -> recreating Working Dir"
argument_list|)
expr_stmt|;
name|fs
operator|.
name|delete
argument_list|(
name|workingDir
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Existing Working Dir detected: -"
operator|+
name|FORCE_OPTION
operator|+
literal|" not specified -> exiting"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
name|fs
operator|.
name|mkdirs
argument_list|(
name|workingDir
argument_list|)
expr_stmt|;
name|fs
operator|.
name|setPermission
argument_list|(
name|workingDir
argument_list|,
operator|new
name|FsPermission
argument_list|(
name|FsAction
operator|.
name|ALL
argument_list|,
name|FsAction
operator|.
name|ALL
argument_list|,
name|FsAction
operator|.
name|ALL
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|filterAppsByAggregatedStatus ()
name|void
name|filterAppsByAggregatedStatus
parameter_list|()
throws|throws
name|IOException
throws|,
name|YarnException
block|{
name|YarnClient
name|client
init|=
name|YarnClient
operator|.
name|createYarnClient
argument_list|()
decl_stmt|;
try|try
block|{
name|client
operator|.
name|init
argument_list|(
name|getConf
argument_list|()
argument_list|)
expr_stmt|;
name|client
operator|.
name|start
argument_list|()
expr_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|AppInfo
argument_list|>
name|it
init|=
name|eligibleApplications
operator|.
name|iterator
argument_list|()
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|AppInfo
name|app
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
try|try
block|{
name|ApplicationReport
name|report
init|=
name|client
operator|.
name|getApplicationReport
argument_list|(
name|ApplicationId
operator|.
name|fromString
argument_list|(
name|app
operator|.
name|getAppId
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|LogAggregationStatus
name|aggStatus
init|=
name|report
operator|.
name|getLogAggregationStatus
argument_list|()
decl_stmt|;
if|if
condition|(
name|aggStatus
operator|.
name|equals
argument_list|(
name|LogAggregationStatus
operator|.
name|RUNNING
argument_list|)
operator|||
name|aggStatus
operator|.
name|equals
argument_list|(
name|LogAggregationStatus
operator|.
name|RUNNING_WITH_FAILURE
argument_list|)
operator|||
name|aggStatus
operator|.
name|equals
argument_list|(
name|LogAggregationStatus
operator|.
name|NOT_START
argument_list|)
operator|||
name|aggStatus
operator|.
name|equals
argument_list|(
name|LogAggregationStatus
operator|.
name|DISABLED
argument_list|)
operator|||
name|aggStatus
operator|.
name|equals
argument_list|(
name|LogAggregationStatus
operator|.
name|FAILED
argument_list|)
condition|)
block|{
if|if
condition|(
name|verbose
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Skipping "
operator|+
name|app
operator|.
name|getAppId
argument_list|()
operator|+
literal|" due to aggregation status being "
operator|+
name|aggStatus
argument_list|)
expr_stmt|;
block|}
name|it
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|verbose
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
name|app
operator|.
name|getAppId
argument_list|()
operator|+
literal|" has aggregation status "
operator|+
name|aggStatus
argument_list|)
expr_stmt|;
block|}
name|app
operator|.
name|setFinishTime
argument_list|(
name|report
operator|.
name|getFinishTime
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|ApplicationNotFoundException
name|e
parameter_list|)
block|{
comment|// Assume the aggregation has finished
if|if
condition|(
name|verbose
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
name|app
operator|.
name|getAppId
argument_list|()
operator|+
literal|" not in the ResourceManager"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
finally|finally
block|{
if|if
condition|(
name|client
operator|!=
literal|null
condition|)
block|{
name|client
operator|.
name|stop
argument_list|()
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|VisibleForTesting
DECL|method|checkFilesAndSeedApps (FileSystem fs, Path remoteRootLogDir, String suffix, Path workingDir)
name|void
name|checkFilesAndSeedApps
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Path
name|remoteRootLogDir
parameter_list|,
name|String
name|suffix
parameter_list|,
name|Path
name|workingDir
parameter_list|)
throws|throws
name|IOException
block|{
for|for
control|(
name|RemoteIterator
argument_list|<
name|FileStatus
argument_list|>
name|userIt
init|=
name|fs
operator|.
name|listStatusIterator
argument_list|(
name|remoteRootLogDir
argument_list|)
init|;
name|userIt
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Path
name|userLogPath
init|=
name|userIt
operator|.
name|next
argument_list|()
operator|.
name|getPath
argument_list|()
decl_stmt|;
try|try
block|{
for|for
control|(
name|RemoteIterator
argument_list|<
name|FileStatus
argument_list|>
name|appIt
init|=
name|fs
operator|.
name|listStatusIterator
argument_list|(
operator|new
name|Path
argument_list|(
name|userLogPath
argument_list|,
name|suffix
argument_list|)
argument_list|)
init|;
name|appIt
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Path
name|appLogPath
init|=
name|appIt
operator|.
name|next
argument_list|()
operator|.
name|getPath
argument_list|()
decl_stmt|;
try|try
block|{
name|FileStatus
index|[]
name|files
init|=
name|fs
operator|.
name|listStatus
argument_list|(
name|appLogPath
argument_list|)
decl_stmt|;
if|if
condition|(
name|files
operator|.
name|length
operator|>=
name|minNumLogFiles
condition|)
block|{
name|boolean
name|eligible
init|=
literal|true
decl_stmt|;
name|long
name|totalFileSize
init|=
literal|0L
decl_stmt|;
for|for
control|(
name|FileStatus
name|file
range|:
name|files
control|)
block|{
if|if
condition|(
name|file
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|appLogPath
operator|.
name|getName
argument_list|()
operator|+
literal|".har"
argument_list|)
condition|)
block|{
name|eligible
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Skipping "
operator|+
name|appLogPath
operator|.
name|getName
argument_list|()
operator|+
literal|" due to existing .har file"
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
name|totalFileSize
operator|+=
name|file
operator|.
name|getLen
argument_list|()
expr_stmt|;
if|if
condition|(
name|totalFileSize
operator|>
name|maxTotalLogsSize
condition|)
block|{
name|eligible
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Skipping "
operator|+
name|appLogPath
operator|.
name|getName
argument_list|()
operator|+
literal|" due to "
operator|+
literal|"total file size being too large ("
operator|+
name|totalFileSize
operator|+
literal|"> "
operator|+
name|maxTotalLogsSize
operator|+
literal|")"
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
if|if
condition|(
name|eligible
condition|)
block|{
if|if
condition|(
name|verbose
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Adding "
operator|+
name|appLogPath
operator|.
name|getName
argument_list|()
operator|+
literal|" for user "
operator|+
name|userLogPath
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|AppInfo
name|context
init|=
operator|new
name|AppInfo
argument_list|()
decl_stmt|;
name|context
operator|.
name|setAppId
argument_list|(
name|appLogPath
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|context
operator|.
name|setUser
argument_list|(
name|userLogPath
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|context
operator|.
name|setSuffix
argument_list|(
name|suffix
argument_list|)
expr_stmt|;
name|context
operator|.
name|setRemoteRootLogDir
argument_list|(
name|remoteRootLogDir
argument_list|)
expr_stmt|;
name|context
operator|.
name|setWorkingDir
argument_list|(
name|workingDir
argument_list|)
expr_stmt|;
name|eligibleApplications
operator|.
name|add
argument_list|(
name|context
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|verbose
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Skipping "
operator|+
name|appLogPath
operator|.
name|getName
argument_list|()
operator|+
literal|" due to not "
operator|+
literal|"having enough log files ("
operator|+
name|files
operator|.
name|length
operator|+
literal|"< "
operator|+
name|minNumLogFiles
operator|+
literal|")"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
comment|// Ignore any apps we can't read
if|if
condition|(
name|verbose
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Skipping logs under "
operator|+
name|appLogPath
operator|+
literal|" due to "
operator|+
name|ioe
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
comment|// Ignore any apps we can't read
if|if
condition|(
name|verbose
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Skipping all logs under "
operator|+
name|userLogPath
operator|+
literal|" due to "
operator|+
name|ioe
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
annotation|@
name|VisibleForTesting
DECL|method|checkMaxEligible ()
name|void
name|checkMaxEligible
parameter_list|()
block|{
comment|// If we have too many eligible apps, remove the newest ones first
if|if
condition|(
name|maxEligible
operator|>
literal|0
operator|&&
name|eligibleApplications
operator|.
name|size
argument_list|()
operator|>
name|maxEligible
condition|)
block|{
if|if
condition|(
name|verbose
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Too many applications ("
operator|+
name|eligibleApplications
operator|.
name|size
argument_list|()
operator|+
literal|"> "
operator|+
name|maxEligible
operator|+
literal|")"
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|AppInfo
argument_list|>
name|sortedApplications
init|=
operator|new
name|ArrayList
argument_list|<
name|AppInfo
argument_list|>
argument_list|(
name|eligibleApplications
argument_list|)
decl_stmt|;
name|Collections
operator|.
name|sort
argument_list|(
name|sortedApplications
argument_list|,
operator|new
name|Comparator
argument_list|<
name|AppInfo
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|int
name|compare
parameter_list|(
name|AppInfo
name|o1
parameter_list|,
name|AppInfo
name|o2
parameter_list|)
block|{
name|int
name|lCompare
init|=
name|Long
operator|.
name|compare
argument_list|(
name|o1
operator|.
name|getFinishTime
argument_list|()
argument_list|,
name|o2
operator|.
name|getFinishTime
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|lCompare
operator|==
literal|0
condition|)
block|{
return|return
name|o1
operator|.
name|getAppId
argument_list|()
operator|.
name|compareTo
argument_list|(
name|o2
operator|.
name|getAppId
argument_list|()
argument_list|)
return|;
block|}
return|return
name|lCompare
return|;
block|}
block|}
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
name|maxEligible
init|;
name|i
operator|<
name|sortedApplications
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|verbose
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Removing "
operator|+
name|sortedApplications
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|eligibleApplications
operator|.
name|remove
argument_list|(
name|sortedApplications
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/*   The generated script looks like this:   #!/bin/bash   set -e   set -x   if [ "$YARN_SHELL_ID" == "1" ]; then         appId="application_1440448768987_0001"         user="rkanter"         workingDir="/tmp/logs/archive-logs-work"         remoteRootLogDir="/tmp/logs"         suffix="logs"   elif [ "$YARN_SHELL_ID" == "2" ]; then         appId="application_1440448768987_0002"         user="rkanter"         workingDir="/tmp/logs/archive-logs-work"         remoteRootLogDir="/tmp/logs"         suffix="logs"   else         echo "Unknown Mapping!"         exit 1   fi   export HADOOP_CLIENT_OPTS="-Xmx1024m"   export HADOOP_CLASSPATH=/dist/share/hadoop/tools/lib/hadoop-archive-logs-2.8.0-SNAPSHOT.jar:/dist/share/hadoop/tools/lib/hadoop-archives-2.8.0-SNAPSHOT.jar   "$HADOOP_HOME"/bin/hadoop org.apache.hadoop.tools.HadoopArchiveLogsRunner -appId "$appId" -user "$user" -workingDir "$workingDir" -remoteRootLogDir "$remoteRootLogDir" -suffix "$suffix"    */
annotation|@
name|VisibleForTesting
DECL|method|generateScript (File localScript)
name|void
name|generateScript
parameter_list|(
name|File
name|localScript
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|verbose
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Generating script at: "
operator|+
name|localScript
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|String
name|halrJarPath
init|=
name|HadoopArchiveLogsRunner
operator|.
name|class
operator|.
name|getProtectionDomain
argument_list|()
operator|.
name|getCodeSource
argument_list|()
operator|.
name|getLocation
argument_list|()
operator|.
name|getPath
argument_list|()
decl_stmt|;
name|String
name|harJarPath
init|=
name|HadoopArchives
operator|.
name|class
operator|.
name|getProtectionDomain
argument_list|()
operator|.
name|getCodeSource
argument_list|()
operator|.
name|getLocation
argument_list|()
operator|.
name|getPath
argument_list|()
decl_stmt|;
name|String
name|classpath
init|=
name|halrJarPath
operator|+
name|File
operator|.
name|pathSeparator
operator|+
name|harJarPath
decl_stmt|;
name|FileWriterWithEncoding
name|fw
init|=
literal|null
decl_stmt|;
try|try
block|{
name|fw
operator|=
operator|new
name|FileWriterWithEncoding
argument_list|(
name|localScript
argument_list|,
literal|"UTF-8"
argument_list|)
expr_stmt|;
name|fw
operator|.
name|write
argument_list|(
literal|"#!/bin/bash\nset -e\nset -x\n"
argument_list|)
expr_stmt|;
name|int
name|containerCount
init|=
literal|1
decl_stmt|;
for|for
control|(
name|AppInfo
name|context
range|:
name|eligibleApplications
control|)
block|{
name|fw
operator|.
name|write
argument_list|(
literal|"if [ \"$YARN_SHELL_ID\" == \""
argument_list|)
expr_stmt|;
name|fw
operator|.
name|write
argument_list|(
name|Integer
operator|.
name|toString
argument_list|(
name|containerCount
argument_list|)
argument_list|)
expr_stmt|;
name|fw
operator|.
name|write
argument_list|(
literal|"\" ]; then\n\tappId=\""
argument_list|)
expr_stmt|;
name|fw
operator|.
name|write
argument_list|(
name|context
operator|.
name|getAppId
argument_list|()
argument_list|)
expr_stmt|;
name|fw
operator|.
name|write
argument_list|(
literal|"\"\n\tuser=\""
argument_list|)
expr_stmt|;
name|fw
operator|.
name|write
argument_list|(
name|context
operator|.
name|getUser
argument_list|()
argument_list|)
expr_stmt|;
name|fw
operator|.
name|write
argument_list|(
literal|"\"\n\tworkingDir=\""
argument_list|)
expr_stmt|;
name|fw
operator|.
name|write
argument_list|(
name|context
operator|.
name|getWorkingDir
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|fw
operator|.
name|write
argument_list|(
literal|"\"\n\tremoteRootLogDir=\""
argument_list|)
expr_stmt|;
name|fw
operator|.
name|write
argument_list|(
name|context
operator|.
name|getRemoteRootLogDir
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|fw
operator|.
name|write
argument_list|(
literal|"\"\n\tsuffix=\""
argument_list|)
expr_stmt|;
name|fw
operator|.
name|write
argument_list|(
name|context
operator|.
name|getSuffix
argument_list|()
argument_list|)
expr_stmt|;
name|fw
operator|.
name|write
argument_list|(
literal|"\"\nel"
argument_list|)
expr_stmt|;
name|containerCount
operator|++
expr_stmt|;
block|}
name|fw
operator|.
name|write
argument_list|(
literal|"se\n\techo \"Unknown Mapping!\"\n\texit 1\nfi\n"
argument_list|)
expr_stmt|;
name|fw
operator|.
name|write
argument_list|(
literal|"export HADOOP_CLIENT_OPTS=\"-Xmx"
argument_list|)
expr_stmt|;
name|fw
operator|.
name|write
argument_list|(
name|Long
operator|.
name|toString
argument_list|(
name|memory
argument_list|)
argument_list|)
expr_stmt|;
name|fw
operator|.
name|write
argument_list|(
literal|"m\"\n"
argument_list|)
expr_stmt|;
name|fw
operator|.
name|write
argument_list|(
literal|"export HADOOP_CLASSPATH="
argument_list|)
expr_stmt|;
name|fw
operator|.
name|write
argument_list|(
name|classpath
argument_list|)
expr_stmt|;
name|fw
operator|.
name|write
argument_list|(
literal|"\n\"$HADOOP_HOME\"/bin/hadoop "
argument_list|)
expr_stmt|;
name|fw
operator|.
name|write
argument_list|(
name|HadoopArchiveLogsRunner
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|fw
operator|.
name|write
argument_list|(
literal|" -appId \"$appId\" -user \"$user\" -workingDir "
argument_list|)
expr_stmt|;
name|fw
operator|.
name|write
argument_list|(
literal|"\"$workingDir\""
argument_list|)
expr_stmt|;
name|fw
operator|.
name|write
argument_list|(
literal|" -remoteRootLogDir "
argument_list|)
expr_stmt|;
name|fw
operator|.
name|write
argument_list|(
literal|"\"$remoteRootLogDir\""
argument_list|)
expr_stmt|;
name|fw
operator|.
name|write
argument_list|(
literal|" -suffix "
argument_list|)
expr_stmt|;
name|fw
operator|.
name|write
argument_list|(
literal|"\"$suffix\""
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|proxy
condition|)
block|{
name|fw
operator|.
name|write
argument_list|(
literal|" -noProxy\n"
argument_list|)
expr_stmt|;
block|}
name|fw
operator|.
name|write
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|fw
operator|!=
literal|null
condition|)
block|{
name|fw
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
block|}
DECL|method|runDistributedShell (File localScript)
specifier|private
name|boolean
name|runDistributedShell
parameter_list|(
name|File
name|localScript
parameter_list|)
throws|throws
name|Exception
block|{
name|String
index|[]
name|dsArgs
init|=
block|{
literal|"--appname"
block|,
literal|"ArchiveLogs"
block|,
literal|"--jar"
block|,
name|ApplicationMaster
operator|.
name|class
operator|.
name|getProtectionDomain
argument_list|()
operator|.
name|getCodeSource
argument_list|()
operator|.
name|getLocation
argument_list|()
operator|.
name|getPath
argument_list|()
block|,
literal|"--num_containers"
block|,
name|Integer
operator|.
name|toString
argument_list|(
name|eligibleApplications
operator|.
name|size
argument_list|()
argument_list|)
block|,
literal|"--container_memory"
block|,
name|Long
operator|.
name|toString
argument_list|(
name|memory
argument_list|)
block|,
literal|"--shell_script"
block|,
name|localScript
operator|.
name|getAbsolutePath
argument_list|()
block|}
decl_stmt|;
if|if
condition|(
name|verbose
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Running Distributed Shell with arguments: "
operator|+
name|Arrays
operator|.
name|toString
argument_list|(
name|dsArgs
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|final
name|Client
name|dsClient
init|=
operator|new
name|Client
argument_list|(
operator|new
name|Configuration
argument_list|(
name|conf
argument_list|)
argument_list|)
decl_stmt|;
name|dsClient
operator|.
name|init
argument_list|(
name|dsArgs
argument_list|)
expr_stmt|;
return|return
name|dsClient
operator|.
name|run
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|setConf (Configuration conf)
specifier|public
name|void
name|setConf
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
if|if
condition|(
name|conf
operator|instanceof
name|JobConf
condition|)
block|{
name|this
operator|.
name|conf
operator|=
operator|(
name|JobConf
operator|)
name|conf
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|conf
operator|=
operator|new
name|JobConf
argument_list|(
name|conf
argument_list|,
name|HadoopArchiveLogs
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|getConf ()
specifier|public
name|Configuration
name|getConf
parameter_list|()
block|{
return|return
name|this
operator|.
name|conf
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|class|AppInfo
specifier|static
class|class
name|AppInfo
block|{
DECL|field|appId
specifier|private
name|String
name|appId
decl_stmt|;
DECL|field|remoteRootLogDir
specifier|private
name|Path
name|remoteRootLogDir
decl_stmt|;
DECL|field|suffix
specifier|private
name|String
name|suffix
decl_stmt|;
DECL|field|workingDir
specifier|private
name|Path
name|workingDir
decl_stmt|;
DECL|field|user
specifier|private
name|String
name|user
decl_stmt|;
DECL|field|finishTime
specifier|private
name|long
name|finishTime
decl_stmt|;
DECL|method|AppInfo ()
name|AppInfo
parameter_list|()
block|{}
DECL|method|AppInfo (String appId, String user)
name|AppInfo
parameter_list|(
name|String
name|appId
parameter_list|,
name|String
name|user
parameter_list|)
block|{
name|this
operator|.
name|setAppId
argument_list|(
name|appId
argument_list|)
expr_stmt|;
name|this
operator|.
name|setUser
argument_list|(
name|user
argument_list|)
expr_stmt|;
block|}
DECL|method|getAppId ()
specifier|public
name|String
name|getAppId
parameter_list|()
block|{
return|return
name|appId
return|;
block|}
DECL|method|setAppId (String appId)
specifier|public
name|void
name|setAppId
parameter_list|(
name|String
name|appId
parameter_list|)
block|{
name|this
operator|.
name|appId
operator|=
name|appId
expr_stmt|;
block|}
DECL|method|getRemoteRootLogDir ()
specifier|public
name|Path
name|getRemoteRootLogDir
parameter_list|()
block|{
return|return
name|remoteRootLogDir
return|;
block|}
DECL|method|setRemoteRootLogDir (Path remoteRootLogDir)
specifier|public
name|void
name|setRemoteRootLogDir
parameter_list|(
name|Path
name|remoteRootLogDir
parameter_list|)
block|{
name|this
operator|.
name|remoteRootLogDir
operator|=
name|remoteRootLogDir
expr_stmt|;
block|}
DECL|method|getSuffix ()
specifier|public
name|String
name|getSuffix
parameter_list|()
block|{
return|return
name|suffix
return|;
block|}
DECL|method|setSuffix (String suffix)
specifier|public
name|void
name|setSuffix
parameter_list|(
name|String
name|suffix
parameter_list|)
block|{
name|this
operator|.
name|suffix
operator|=
name|suffix
expr_stmt|;
block|}
DECL|method|getWorkingDir ()
specifier|public
name|Path
name|getWorkingDir
parameter_list|()
block|{
return|return
name|workingDir
return|;
block|}
DECL|method|setWorkingDir (Path workingDir)
specifier|public
name|void
name|setWorkingDir
parameter_list|(
name|Path
name|workingDir
parameter_list|)
block|{
name|this
operator|.
name|workingDir
operator|=
name|workingDir
expr_stmt|;
block|}
DECL|method|getUser ()
specifier|public
name|String
name|getUser
parameter_list|()
block|{
return|return
name|user
return|;
block|}
DECL|method|setUser (String user)
specifier|public
name|void
name|setUser
parameter_list|(
name|String
name|user
parameter_list|)
block|{
name|this
operator|.
name|user
operator|=
name|user
expr_stmt|;
block|}
DECL|method|getFinishTime ()
specifier|public
name|long
name|getFinishTime
parameter_list|()
block|{
return|return
name|finishTime
return|;
block|}
DECL|method|setFinishTime (long finishTime)
specifier|public
name|void
name|setFinishTime
parameter_list|(
name|long
name|finishTime
parameter_list|)
block|{
name|this
operator|.
name|finishTime
operator|=
name|finishTime
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|equals (Object o)
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
name|this
operator|==
name|o
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
name|o
operator|==
literal|null
operator|||
name|getClass
argument_list|()
operator|!=
name|o
operator|.
name|getClass
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
name|AppInfo
name|appInfo
init|=
operator|(
name|AppInfo
operator|)
name|o
decl_stmt|;
if|if
condition|(
name|appId
operator|!=
literal|null
condition|?
operator|!
name|appId
operator|.
name|equals
argument_list|(
name|appInfo
operator|.
name|appId
argument_list|)
else|:
name|appInfo
operator|.
name|appId
operator|!=
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|user
operator|!=
literal|null
condition|?
operator|!
name|user
operator|.
name|equals
argument_list|(
name|appInfo
operator|.
name|user
argument_list|)
else|:
name|appInfo
operator|.
name|user
operator|!=
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|suffix
operator|!=
literal|null
condition|?
operator|!
name|suffix
operator|.
name|equals
argument_list|(
name|appInfo
operator|.
name|suffix
argument_list|)
else|:
name|appInfo
operator|.
name|suffix
operator|!=
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|workingDir
operator|!=
literal|null
condition|?
operator|!
name|workingDir
operator|.
name|equals
argument_list|(
name|appInfo
operator|.
name|workingDir
argument_list|)
else|:
name|appInfo
operator|.
name|workingDir
operator|!=
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|remoteRootLogDir
operator|!=
literal|null
condition|?
operator|!
name|remoteRootLogDir
operator|.
name|equals
argument_list|(
name|appInfo
operator|.
name|remoteRootLogDir
argument_list|)
else|:
name|appInfo
operator|.
name|remoteRootLogDir
operator|!=
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
name|Long
operator|.
name|compare
argument_list|(
name|finishTime
argument_list|,
name|appInfo
operator|.
name|finishTime
argument_list|)
operator|==
literal|0
return|;
block|}
annotation|@
name|Override
DECL|method|hashCode ()
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
name|int
name|result
init|=
name|appId
operator|!=
literal|null
condition|?
name|appId
operator|.
name|hashCode
argument_list|()
else|:
literal|0
decl_stmt|;
name|result
operator|=
literal|31
operator|*
name|result
operator|+
operator|(
name|user
operator|!=
literal|null
condition|?
name|user
operator|.
name|hashCode
argument_list|()
else|:
literal|0
operator|)
expr_stmt|;
name|result
operator|=
literal|31
operator|*
name|result
operator|+
operator|(
name|suffix
operator|!=
literal|null
condition|?
name|suffix
operator|.
name|hashCode
argument_list|()
else|:
literal|0
operator|)
expr_stmt|;
name|result
operator|=
literal|31
operator|*
name|result
operator|+
operator|(
name|workingDir
operator|!=
literal|null
condition|?
name|workingDir
operator|.
name|hashCode
argument_list|()
else|:
literal|0
operator|)
expr_stmt|;
name|result
operator|=
literal|31
operator|*
name|result
operator|+
operator|(
name|remoteRootLogDir
operator|!=
literal|null
condition|?
name|remoteRootLogDir
operator|.
name|hashCode
argument_list|()
else|:
literal|0
operator|)
expr_stmt|;
name|result
operator|=
literal|31
operator|*
name|result
operator|+
name|Long
operator|.
name|valueOf
argument_list|(
name|finishTime
argument_list|)
operator|.
name|hashCode
argument_list|()
expr_stmt|;
return|return
name|result
return|;
block|}
block|}
block|}
end_class

end_unit

