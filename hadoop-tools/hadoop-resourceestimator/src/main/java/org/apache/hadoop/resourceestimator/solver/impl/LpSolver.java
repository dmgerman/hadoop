begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  *  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  *  */
end_comment

begin_package
DECL|package|org.apache.hadoop.resourceestimator.solver.impl
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|resourceestimator
operator|.
name|solver
operator|.
name|impl
package|;
end_package

begin_import
import|import
name|java
operator|.
name|math
operator|.
name|BigDecimal
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|resourceestimator
operator|.
name|common
operator|.
name|api
operator|.
name|RecurrenceId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|resourceestimator
operator|.
name|common
operator|.
name|api
operator|.
name|ResourceSkyline
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|resourceestimator
operator|.
name|common
operator|.
name|config
operator|.
name|ResourceEstimatorConfiguration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|resourceestimator
operator|.
name|skylinestore
operator|.
name|api
operator|.
name|PredictionSkylineStore
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|resourceestimator
operator|.
name|skylinestore
operator|.
name|exceptions
operator|.
name|SkylineStoreException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|resourceestimator
operator|.
name|solver
operator|.
name|api
operator|.
name|Solver
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|resourceestimator
operator|.
name|solver
operator|.
name|exceptions
operator|.
name|SolverException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|resourceestimator
operator|.
name|solver
operator|.
name|preprocess
operator|.
name|SolverPreprocessor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|Resource
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|reservation
operator|.
name|RLESparseResourceAllocation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|reservation
operator|.
name|ReservationInterval
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|util
operator|.
name|resource
operator|.
name|DefaultResourceCalculator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|ojalgo
operator|.
name|optimisation
operator|.
name|Expression
import|;
end_import

begin_import
import|import
name|org
operator|.
name|ojalgo
operator|.
name|optimisation
operator|.
name|ExpressionsBasedModel
import|;
end_import

begin_import
import|import
name|org
operator|.
name|ojalgo
operator|.
name|optimisation
operator|.
name|Optimisation
operator|.
name|Result
import|;
end_import

begin_import
import|import
name|org
operator|.
name|ojalgo
operator|.
name|optimisation
operator|.
name|Variable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_comment
comment|/**  * A LP(Linear Programming) solution to predict recurring pipeline's  * {@link Resource} requirements, and generate Hadoop {@code RDL} requests which  * will be used to make recurring resource reservation.  */
end_comment

begin_class
DECL|class|LpSolver
specifier|public
class|class
name|LpSolver
extends|extends
name|BaseSolver
implements|implements
name|Solver
block|{
DECL|field|LOGGER
specifier|private
specifier|static
specifier|final
name|Logger
name|LOGGER
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|LpSolver
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|preprocessor
specifier|private
specifier|final
name|SolverPreprocessor
name|preprocessor
init|=
operator|new
name|SolverPreprocessor
argument_list|()
decl_stmt|;
comment|/**    * Controls the balance between over-allocation and under-allocation.    */
DECL|field|alpha
specifier|private
name|double
name|alpha
decl_stmt|;
comment|/**    * Controls the generalization of the solver.    */
DECL|field|beta
specifier|private
name|double
name|beta
decl_stmt|;
comment|/**    * The minimum number of job runs required to run the solver.    */
DECL|field|minJobRuns
specifier|private
name|int
name|minJobRuns
decl_stmt|;
comment|/**    * The time interval which is used to discretize job execution.    */
DECL|field|timeInterval
specifier|private
name|int
name|timeInterval
decl_stmt|;
comment|/**    * The PredictionSkylineStore to store the predicted ResourceSkyline for new    * run.    */
DECL|field|predictionSkylineStore
specifier|private
name|PredictionSkylineStore
name|predictionSkylineStore
decl_stmt|;
DECL|method|init (final Configuration config, PredictionSkylineStore skylineStore)
annotation|@
name|Override
specifier|public
specifier|final
name|void
name|init
parameter_list|(
specifier|final
name|Configuration
name|config
parameter_list|,
name|PredictionSkylineStore
name|skylineStore
parameter_list|)
block|{
name|this
operator|.
name|alpha
operator|=
name|config
operator|.
name|getDouble
argument_list|(
name|ResourceEstimatorConfiguration
operator|.
name|SOLVER_ALPHA_KEY
argument_list|,
literal|0.1
argument_list|)
expr_stmt|;
name|this
operator|.
name|beta
operator|=
name|config
operator|.
name|getDouble
argument_list|(
name|ResourceEstimatorConfiguration
operator|.
name|SOLVER_BETA_KEY
argument_list|,
literal|0.1
argument_list|)
expr_stmt|;
name|this
operator|.
name|minJobRuns
operator|=
name|config
operator|.
name|getInt
argument_list|(
name|ResourceEstimatorConfiguration
operator|.
name|SOLVER_MIN_JOB_RUN_KEY
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|this
operator|.
name|timeInterval
operator|=
name|config
operator|.
name|getInt
argument_list|(
name|ResourceEstimatorConfiguration
operator|.
name|TIME_INTERVAL_KEY
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|this
operator|.
name|predictionSkylineStore
operator|=
name|skylineStore
expr_stmt|;
block|}
comment|/**    * Generate over-allocation constraints.    *    * @param lpModel            the LP model.    * @param cJobITimeK         actual container allocation for job i in time    *                           interval k.    * @param oa                 container over-allocation.    * @param x                  predicted container allocation.    * @param indexJobITimeK     index for job i at time interval k.    * @param timeK              index for time interval k.    */
DECL|method|generateOverAllocationConstraints ( final ExpressionsBasedModel lpModel, final double cJobITimeK, final Variable[] oa, final Variable[] x, final int indexJobITimeK, final int timeK)
specifier|private
name|void
name|generateOverAllocationConstraints
parameter_list|(
specifier|final
name|ExpressionsBasedModel
name|lpModel
parameter_list|,
specifier|final
name|double
name|cJobITimeK
parameter_list|,
specifier|final
name|Variable
index|[]
name|oa
parameter_list|,
specifier|final
name|Variable
index|[]
name|x
parameter_list|,
specifier|final
name|int
name|indexJobITimeK
parameter_list|,
specifier|final
name|int
name|timeK
parameter_list|)
block|{
comment|// oa_job_i_timeK>= x_timeK - cJobITimeK
name|Expression
name|overAllocExpression
init|=
name|lpModel
operator|.
name|addExpression
argument_list|(
literal|"over_alloc_"
operator|+
name|indexJobITimeK
argument_list|)
decl_stmt|;
name|overAllocExpression
operator|.
name|set
argument_list|(
name|oa
index|[
name|indexJobITimeK
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|overAllocExpression
operator|.
name|set
argument_list|(
name|x
index|[
name|timeK
index|]
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|overAllocExpression
operator|.
name|lower
argument_list|(
operator|-
name|cJobITimeK
argument_list|)
expr_stmt|;
comment|//>=
block|}
comment|/**    * Generate under-allocation constraints.    *    * @param lpModel            the LP model.    * @param cJobITimeK     actual container allocation for job i in time    *                           interval k.    * @param uaPredict          absolute container under-allocation.    * @param ua                 recursive container under-allocation.    * @param x                  predicted container allocation.    * @param indexJobITimeK index for job i at time interval k.    * @param timeK             index for time interval k.    */
DECL|method|generateUnderAllocationConstraints ( final ExpressionsBasedModel lpModel, final double cJobITimeK, final Variable[] uaPredict, final Variable[] ua, final Variable[] x, final int indexJobITimeK, final int timeK)
specifier|private
name|void
name|generateUnderAllocationConstraints
parameter_list|(
specifier|final
name|ExpressionsBasedModel
name|lpModel
parameter_list|,
specifier|final
name|double
name|cJobITimeK
parameter_list|,
specifier|final
name|Variable
index|[]
name|uaPredict
parameter_list|,
specifier|final
name|Variable
index|[]
name|ua
parameter_list|,
specifier|final
name|Variable
index|[]
name|x
parameter_list|,
specifier|final
name|int
name|indexJobITimeK
parameter_list|,
specifier|final
name|int
name|timeK
parameter_list|)
block|{
comment|// uaPredict_job_i_timeK + x_timeK>= cJobITimeK
name|Expression
name|underAllocPredictExpression
init|=
name|lpModel
operator|.
name|addExpression
argument_list|(
literal|"under_alloc_predict_"
operator|+
name|indexJobITimeK
argument_list|)
decl_stmt|;
name|underAllocPredictExpression
operator|.
name|set
argument_list|(
name|uaPredict
index|[
name|indexJobITimeK
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|underAllocPredictExpression
operator|.
name|set
argument_list|(
name|x
index|[
name|timeK
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|underAllocPredictExpression
operator|.
name|lower
argument_list|(
name|cJobITimeK
argument_list|)
expr_stmt|;
comment|//>=
if|if
condition|(
name|timeK
operator|>=
literal|1
condition|)
block|{
comment|/** Recursively calculate container under-allocation. */
comment|// ua_job_i_timeK>= ua_job_i_time_(k-1) + cJobITimeK - x_timeK
name|Expression
name|underAllocExpression
init|=
name|lpModel
operator|.
name|addExpression
argument_list|(
literal|"under_alloc_"
operator|+
name|indexJobITimeK
argument_list|)
decl_stmt|;
name|underAllocExpression
operator|.
name|set
argument_list|(
name|ua
index|[
name|indexJobITimeK
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|underAllocExpression
operator|.
name|set
argument_list|(
name|ua
index|[
name|indexJobITimeK
operator|-
literal|1
index|]
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|underAllocExpression
operator|.
name|set
argument_list|(
name|x
index|[
name|timeK
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|underAllocExpression
operator|.
name|lower
argument_list|(
name|cJobITimeK
argument_list|)
expr_stmt|;
comment|//>=
block|}
else|else
block|{
comment|/** Initial value for container under-allocation. */
comment|// ua_job_i_time_0>= cJobI_time_0 - x_time_0
name|Expression
name|underAllocExpression
init|=
name|lpModel
operator|.
name|addExpression
argument_list|(
literal|"under_alloc_"
operator|+
name|indexJobITimeK
argument_list|)
decl_stmt|;
name|underAllocExpression
operator|.
name|set
argument_list|(
name|ua
index|[
name|indexJobITimeK
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|underAllocExpression
operator|.
name|set
argument_list|(
name|x
index|[
name|timeK
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|underAllocExpression
operator|.
name|lower
argument_list|(
name|cJobITimeK
argument_list|)
expr_stmt|;
comment|//>=
block|}
block|}
comment|/**    * Generate solver objective.    *    * @param objective LP solver objective.    * @param numJobs   number of history runs of the recurring pipeline.    * @param jobLen    (maximum) job lenght of the recurring pipeline.    * @param oa        container over-allocation.    * @param ua        recursive container under-allocation.    * @param eps       regularization parameter.    */
DECL|method|generateObjective (final Expression objective, final int numJobs, final int jobLen, final Variable[] oa, final Variable[] ua, final Variable eps)
specifier|private
name|void
name|generateObjective
parameter_list|(
specifier|final
name|Expression
name|objective
parameter_list|,
specifier|final
name|int
name|numJobs
parameter_list|,
specifier|final
name|int
name|jobLen
parameter_list|,
specifier|final
name|Variable
index|[]
name|oa
parameter_list|,
specifier|final
name|Variable
index|[]
name|ua
parameter_list|,
specifier|final
name|Variable
name|eps
parameter_list|)
block|{
name|int
name|indexJobITimeK
decl_stmt|;
comment|// sum Over_Allocation
for|for
control|(
name|int
name|indexJobI
init|=
literal|0
init|;
name|indexJobI
operator|<
name|numJobs
condition|;
name|indexJobI
operator|++
control|)
block|{
for|for
control|(
name|int
name|timeK
init|=
literal|0
init|;
name|timeK
operator|<
name|jobLen
condition|;
name|timeK
operator|++
control|)
block|{
name|indexJobITimeK
operator|=
name|indexJobI
operator|*
name|jobLen
operator|+
name|timeK
expr_stmt|;
name|objective
operator|.
name|set
argument_list|(
name|oa
index|[
name|indexJobITimeK
index|]
argument_list|,
name|alpha
operator|/
name|numJobs
argument_list|)
expr_stmt|;
block|}
block|}
comment|// sum Under_Allocation
name|int
name|indexJobITimeN
decl_stmt|;
for|for
control|(
name|int
name|indexJobI
init|=
literal|0
init|;
name|indexJobI
operator|<
name|numJobs
condition|;
name|indexJobI
operator|++
control|)
block|{
name|indexJobITimeN
operator|=
name|indexJobI
operator|*
name|jobLen
operator|+
name|jobLen
operator|-
literal|1
expr_stmt|;
name|objective
operator|.
name|set
argument_list|(
name|ua
index|[
name|indexJobITimeN
index|]
argument_list|,
operator|(
literal|1
operator|-
name|alpha
operator|)
operator|/
name|numJobs
argument_list|)
expr_stmt|;
block|}
name|objective
operator|.
name|set
argument_list|(
name|eps
argument_list|,
name|beta
argument_list|)
expr_stmt|;
name|objective
operator|.
name|weight
argument_list|(
name|BigDecimal
operator|.
name|valueOf
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Get the job length of recurring pipeline.    *    * @param resourceSkylines the history ResourceSkylines allocated to the    *                         recurring pipeline.    * @param numJobs          number of history runs of the recurring pipeline.    * @return length of (discretized time intervals of) the recurring pipeline.    */
DECL|method|getJobLen (final List<ResourceSkyline> resourceSkylines, final int numJobs)
specifier|private
name|int
name|getJobLen
parameter_list|(
specifier|final
name|List
argument_list|<
name|ResourceSkyline
argument_list|>
name|resourceSkylines
parameter_list|,
specifier|final
name|int
name|numJobs
parameter_list|)
block|{
name|int
name|curLen
init|=
literal|0
decl_stmt|;
name|int
name|jobLen
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|indexJobI
init|=
literal|0
init|;
name|indexJobI
operator|<
name|numJobs
condition|;
name|indexJobI
operator|++
control|)
block|{
name|curLen
operator|=
call|(
name|int
call|)
argument_list|(
name|resourceSkylines
operator|.
name|get
argument_list|(
name|indexJobI
argument_list|)
operator|.
name|getSkylineList
argument_list|()
operator|.
name|getLatestNonNullTime
argument_list|()
operator|-
name|resourceSkylines
operator|.
name|get
argument_list|(
name|indexJobI
argument_list|)
operator|.
name|getSkylineList
argument_list|()
operator|.
name|getEarliestStartTime
argument_list|()
operator|+
name|timeInterval
operator|-
literal|1
argument_list|)
operator|/
name|timeInterval
expr_stmt|;
comment|// for round up
if|if
condition|(
name|jobLen
operator|<
name|curLen
condition|)
block|{
name|jobLen
operator|=
name|curLen
expr_stmt|;
block|}
block|}
return|return
name|jobLen
return|;
block|}
DECL|method|solve ( final Map<RecurrenceId, List<ResourceSkyline>> jobHistory)
annotation|@
name|Override
specifier|public
specifier|final
name|RLESparseResourceAllocation
name|solve
parameter_list|(
specifier|final
name|Map
argument_list|<
name|RecurrenceId
argument_list|,
name|List
argument_list|<
name|ResourceSkyline
argument_list|>
argument_list|>
name|jobHistory
parameter_list|)
throws|throws
name|SolverException
throws|,
name|SkylineStoreException
block|{
comment|// TODO: addHistory timeout support for this function, and ideally we should
comment|// return the confidence
comment|// level associated with the predicted resource.
name|preprocessor
operator|.
name|validate
argument_list|(
name|jobHistory
argument_list|,
name|timeInterval
argument_list|)
expr_stmt|;
specifier|final
name|List
argument_list|<
name|ResourceSkyline
argument_list|>
name|resourceSkylines
init|=
name|preprocessor
operator|.
name|aggregateSkylines
argument_list|(
name|jobHistory
argument_list|,
name|minJobRuns
argument_list|)
decl_stmt|;
specifier|final
name|int
name|numJobs
init|=
name|resourceSkylines
operator|.
name|size
argument_list|()
decl_stmt|;
specifier|final
name|int
name|jobLen
init|=
name|getJobLen
argument_list|(
name|resourceSkylines
argument_list|,
name|numJobs
argument_list|)
decl_stmt|;
comment|/** Create variables. */
specifier|final
name|ExpressionsBasedModel
name|lpModel
init|=
operator|new
name|ExpressionsBasedModel
argument_list|()
decl_stmt|;
name|Variable
index|[]
name|oa
init|=
operator|new
name|Variable
index|[
name|jobLen
operator|*
name|numJobs
index|]
decl_stmt|;
name|Variable
index|[]
name|ua
init|=
operator|new
name|Variable
index|[
name|jobLen
operator|*
name|numJobs
index|]
decl_stmt|;
name|Variable
index|[]
name|uaPredict
init|=
operator|new
name|Variable
index|[
name|jobLen
operator|*
name|numJobs
index|]
decl_stmt|;
name|Variable
index|[]
name|x
init|=
operator|new
name|Variable
index|[
name|jobLen
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|jobLen
operator|*
name|numJobs
condition|;
name|i
operator|++
control|)
block|{
name|oa
index|[
name|i
index|]
operator|=
operator|new
name|Variable
argument_list|(
literal|"oa"
operator|+
name|i
argument_list|)
operator|.
name|lower
argument_list|(
name|BigDecimal
operator|.
name|valueOf
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|ua
index|[
name|i
index|]
operator|=
operator|new
name|Variable
argument_list|(
literal|"ua"
operator|+
name|i
argument_list|)
operator|.
name|lower
argument_list|(
name|BigDecimal
operator|.
name|valueOf
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|uaPredict
index|[
name|i
index|]
operator|=
operator|new
name|Variable
argument_list|(
literal|"uaPredict"
operator|+
name|i
argument_list|)
operator|.
name|lower
argument_list|(
name|BigDecimal
operator|.
name|valueOf
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|jobLen
condition|;
name|i
operator|++
control|)
block|{
name|x
index|[
name|i
index|]
operator|=
operator|new
name|Variable
argument_list|(
literal|"x"
argument_list|)
operator|.
name|lower
argument_list|(
name|BigDecimal
operator|.
name|valueOf
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|lpModel
operator|.
name|addVariables
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|lpModel
operator|.
name|addVariables
argument_list|(
name|oa
argument_list|)
expr_stmt|;
name|lpModel
operator|.
name|addVariables
argument_list|(
name|ua
argument_list|)
expr_stmt|;
name|lpModel
operator|.
name|addVariables
argument_list|(
name|uaPredict
argument_list|)
expr_stmt|;
name|Variable
name|eps
init|=
operator|new
name|Variable
argument_list|(
literal|"epsilon"
argument_list|)
operator|.
name|lower
argument_list|(
name|BigDecimal
operator|.
name|valueOf
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|lpModel
operator|.
name|addVariable
argument_list|(
name|eps
argument_list|)
expr_stmt|;
comment|/** Set constraints. */
name|int
name|indexJobITimeK
init|=
literal|0
decl_stmt|;
name|double
name|cJobI
init|=
literal|0
decl_stmt|;
name|double
name|cJobITimeK
init|=
literal|0
decl_stmt|;
name|ResourceSkyline
name|resourceSkyline
decl_stmt|;
name|int
index|[]
name|containerNums
decl_stmt|;
comment|// 1. sum(job_i){sum(timeK){1/cJobI * uaPredict_job_i_timeK}}<= numJobs
comment|// * eps
name|Expression
name|regularizationConstraint
init|=
name|lpModel
operator|.
name|addExpression
argument_list|(
literal|"regularization"
argument_list|)
decl_stmt|;
name|regularizationConstraint
operator|.
name|set
argument_list|(
name|eps
argument_list|,
operator|-
name|numJobs
argument_list|)
expr_stmt|;
name|regularizationConstraint
operator|.
name|upper
argument_list|(
name|BigDecimal
operator|.
name|valueOf
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|//<= 0
for|for
control|(
name|int
name|indexJobI
init|=
literal|0
init|;
name|indexJobI
operator|<
name|resourceSkylines
operator|.
name|size
argument_list|()
condition|;
name|indexJobI
operator|++
control|)
block|{
name|resourceSkyline
operator|=
name|resourceSkylines
operator|.
name|get
argument_list|(
name|indexJobI
argument_list|)
expr_stmt|;
comment|// the # of containers consumed by job i in discretized time intervals
name|containerNums
operator|=
name|preprocessor
operator|.
name|getDiscreteSkyline
argument_list|(
name|resourceSkyline
operator|.
name|getSkylineList
argument_list|()
argument_list|,
name|timeInterval
argument_list|,
name|resourceSkyline
operator|.
name|getContainerSpec
argument_list|()
operator|.
name|getMemorySize
argument_list|()
argument_list|,
name|jobLen
argument_list|)
expr_stmt|;
comment|// the aggregated # of containers consumed by job i during its lifespan
name|cJobI
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|containerNums
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|cJobI
operator|=
name|cJobI
operator|+
name|containerNums
index|[
name|i
index|]
expr_stmt|;
block|}
for|for
control|(
name|int
name|timeK
init|=
literal|0
init|;
name|timeK
operator|<
name|jobLen
condition|;
name|timeK
operator|++
control|)
block|{
name|indexJobITimeK
operator|=
name|indexJobI
operator|*
name|jobLen
operator|+
name|timeK
expr_stmt|;
comment|// the # of containers consumed by job i in the k-th time interval
name|cJobITimeK
operator|=
name|containerNums
index|[
name|timeK
index|]
expr_stmt|;
name|regularizationConstraint
operator|.
name|set
argument_list|(
name|uaPredict
index|[
name|indexJobITimeK
index|]
argument_list|,
literal|1
operator|/
name|cJobI
argument_list|)
expr_stmt|;
name|generateOverAllocationConstraints
argument_list|(
name|lpModel
argument_list|,
name|cJobITimeK
argument_list|,
name|oa
argument_list|,
name|x
argument_list|,
name|indexJobITimeK
argument_list|,
name|timeK
argument_list|)
expr_stmt|;
name|generateUnderAllocationConstraints
argument_list|(
name|lpModel
argument_list|,
name|cJobITimeK
argument_list|,
name|uaPredict
argument_list|,
name|ua
argument_list|,
name|x
argument_list|,
name|indexJobITimeK
argument_list|,
name|timeK
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Set objective. */
name|Expression
name|objective
init|=
name|lpModel
operator|.
name|addExpression
argument_list|(
literal|"objective"
argument_list|)
decl_stmt|;
name|generateObjective
argument_list|(
name|objective
argument_list|,
name|numJobs
argument_list|,
name|jobLen
argument_list|,
name|oa
argument_list|,
name|ua
argument_list|,
name|eps
argument_list|)
expr_stmt|;
comment|/** Solve the model. */
specifier|final
name|Result
name|lpResult
init|=
name|lpModel
operator|.
name|minimise
argument_list|()
decl_stmt|;
specifier|final
name|TreeMap
argument_list|<
name|Long
argument_list|,
name|Resource
argument_list|>
name|treeMap
init|=
operator|new
name|TreeMap
argument_list|<>
argument_list|()
decl_stmt|;
name|RLESparseResourceAllocation
name|result
init|=
operator|new
name|RLESparseResourceAllocation
argument_list|(
name|treeMap
argument_list|,
operator|new
name|DefaultResourceCalculator
argument_list|()
argument_list|)
decl_stmt|;
name|ReservationInterval
name|riAdd
decl_stmt|;
name|Resource
name|containerSpec
init|=
name|resourceSkylines
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getContainerSpec
argument_list|()
decl_stmt|;
name|String
name|pipelineId
init|=
operator|(
operator|(
name|RecurrenceId
operator|)
name|jobHistory
operator|.
name|keySet
argument_list|()
operator|.
name|toArray
argument_list|()
index|[
literal|0
index|]
operator|)
operator|.
name|getPipelineId
argument_list|()
decl_stmt|;
name|Resource
name|resource
decl_stmt|;
for|for
control|(
name|int
name|indexTimeK
init|=
literal|0
init|;
name|indexTimeK
operator|<
name|jobLen
condition|;
name|indexTimeK
operator|++
control|)
block|{
name|riAdd
operator|=
operator|new
name|ReservationInterval
argument_list|(
name|indexTimeK
operator|*
name|timeInterval
argument_list|,
operator|(
name|indexTimeK
operator|+
literal|1
operator|)
operator|*
name|timeInterval
argument_list|)
expr_stmt|;
name|resource
operator|=
name|Resource
operator|.
name|newInstance
argument_list|(
name|containerSpec
operator|.
name|getMemorySize
argument_list|()
operator|*
operator|(
name|int
operator|)
name|lpResult
operator|.
name|doubleValue
argument_list|(
name|indexTimeK
argument_list|)
argument_list|,
name|containerSpec
operator|.
name|getVirtualCores
argument_list|()
operator|*
operator|(
name|int
operator|)
name|lpResult
operator|.
name|doubleValue
argument_list|(
name|indexTimeK
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|.
name|addInterval
argument_list|(
name|riAdd
argument_list|,
name|resource
argument_list|)
expr_stmt|;
name|LOGGER
operator|.
name|debug
argument_list|(
literal|"time interval: {}, container: {}."
argument_list|,
name|indexTimeK
argument_list|,
name|lpResult
operator|.
name|doubleValue
argument_list|(
name|indexTimeK
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|predictionSkylineStore
operator|.
name|addEstimation
argument_list|(
name|pipelineId
argument_list|,
name|result
argument_list|)
expr_stmt|;
comment|/**      * TODO: 1. We can calculate the estimated error (over-allocation,      * under-allocation) of our prediction which could be used to generate      * confidence level for our prediction; 2. Also, we can modify our model to      * take job input data size (and maybe stage info) into consideration; 3. We      * can also try to generate such conclusion: our prediction under-allocates      * X amount of resources from time 0 to time 100 compared with 95% of      * history runs; 4. We can build framework-specific versions of estimator      * (such as scope/spark/hive, etc.) and provides more specific suggestions.      * For example, we may say: for spark job i, its task size is X GB while the      * container memory allocation is Y GB; as a result, its shuffling stage is      * 20% slower than ideal case due to the disk spilling operations, etc. 5.      * If we have more information of jobs (other than ResourceSkyline), we may      * have such conclusion: job i is 20% slower than 90% of history runs, and      * it is because part of its tasks are running together with job j's tasks.      * In this case, we not only predict the amount of resource needed for job      * i, but also how to place the resource requirements to clusters; 6. We may      * monitor job progress, and dynamically increase/decrease container      * allocations to satisfy job deadline while minimizing the cost; 7. We may      * allow users to specify a budget (say $100 per job run), and optimize the      * resource allocation under the budget constraints. 8. ...      */
return|return
name|result
return|;
block|}
DECL|method|close ()
annotation|@
name|Override
specifier|public
specifier|final
name|void
name|close
parameter_list|()
block|{
comment|// TODO: currently place holder
block|}
block|}
end_class

end_unit

