begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.fs.azure
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|azure
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|azure
operator|.
name|PageBlobFormatHelpers
operator|.
name|PAGE_DATA_SIZE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|azure
operator|.
name|PageBlobFormatHelpers
operator|.
name|PAGE_HEADER_SIZE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|azure
operator|.
name|PageBlobFormatHelpers
operator|.
name|PAGE_SIZE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|azure
operator|.
name|PageBlobFormatHelpers
operator|.
name|fromShort
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|azure
operator|.
name|PageBlobFormatHelpers
operator|.
name|withMD5Checking
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Locale
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|CountDownLatch
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|LinkedBlockingQueue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ThreadPoolExecutor
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|StreamCapabilities
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Syncable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|azure
operator|.
name|StorageInterface
operator|.
name|CloudPageBlobWrapper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang3
operator|.
name|exception
operator|.
name|ExceptionUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|microsoft
operator|.
name|azure
operator|.
name|storage
operator|.
name|OperationContext
import|;
end_import

begin_import
import|import
name|com
operator|.
name|microsoft
operator|.
name|azure
operator|.
name|storage
operator|.
name|StorageException
import|;
end_import

begin_import
import|import
name|com
operator|.
name|microsoft
operator|.
name|azure
operator|.
name|storage
operator|.
name|blob
operator|.
name|BlobRequestOptions
import|;
end_import

begin_import
import|import
name|com
operator|.
name|microsoft
operator|.
name|azure
operator|.
name|storage
operator|.
name|blob
operator|.
name|CloudPageBlob
import|;
end_import

begin_comment
comment|/**  * An output stream that write file data to a page blob stored using ASV's  * custom format.  */
end_comment

begin_class
DECL|class|PageBlobOutputStream
specifier|final
class|class
name|PageBlobOutputStream
extends|extends
name|OutputStream
implements|implements
name|Syncable
implements|,
name|StreamCapabilities
block|{
comment|/**    * The maximum number of raw bytes Azure Storage allows us to upload in a    * single request (4 MB).    */
DECL|field|MAX_RAW_BYTES_PER_REQUEST
specifier|private
specifier|static
specifier|final
name|int
name|MAX_RAW_BYTES_PER_REQUEST
init|=
literal|4
operator|*
literal|1024
operator|*
literal|1024
decl_stmt|;
comment|/**    * The maximum number of pages Azure Storage allows us to upload in a    * single request.    */
DECL|field|MAX_PAGES_IN_REQUEST
specifier|private
specifier|static
specifier|final
name|int
name|MAX_PAGES_IN_REQUEST
init|=
name|MAX_RAW_BYTES_PER_REQUEST
operator|/
name|PAGE_SIZE
decl_stmt|;
comment|/**    * The maximum number of data bytes (header not included) we can upload    * in a single request. I'm limiting it to (N - 1) pages to account for    * the possibility that we may have to rewrite the previous request's    * last page.    */
DECL|field|MAX_DATA_BYTES_PER_REQUEST
specifier|private
specifier|static
specifier|final
name|int
name|MAX_DATA_BYTES_PER_REQUEST
init|=
name|PAGE_DATA_SIZE
operator|*
operator|(
name|MAX_PAGES_IN_REQUEST
operator|-
literal|1
operator|)
decl_stmt|;
DECL|field|blob
specifier|private
specifier|final
name|CloudPageBlobWrapper
name|blob
decl_stmt|;
DECL|field|opContext
specifier|private
specifier|final
name|OperationContext
name|opContext
decl_stmt|;
comment|/**    * If the IO thread encounters an error, it'll store it here.    */
DECL|field|lastError
specifier|private
specifier|volatile
name|IOException
name|lastError
decl_stmt|;
comment|/**    * Current size of the page blob in bytes. It may be extended if the file    * gets full.    */
DECL|field|currentBlobSize
specifier|private
name|long
name|currentBlobSize
decl_stmt|;
comment|/**    * The current byte offset we're at in the blob (how many bytes we've    * uploaded to the server).    */
DECL|field|currentBlobOffset
specifier|private
name|long
name|currentBlobOffset
decl_stmt|;
comment|/**    * The data in the last page that we wrote to the server, in case we have to    * overwrite it in the new request.    */
DECL|field|previousLastPageDataWritten
specifier|private
name|byte
index|[]
name|previousLastPageDataWritten
init|=
operator|new
name|byte
index|[
literal|0
index|]
decl_stmt|;
comment|/**    * The current buffer we're writing to before sending to the server.    */
DECL|field|outBuffer
specifier|private
name|ByteArrayOutputStream
name|outBuffer
decl_stmt|;
comment|/**    * The task queue for writing to the server.    */
DECL|field|ioQueue
specifier|private
specifier|final
name|LinkedBlockingQueue
argument_list|<
name|Runnable
argument_list|>
name|ioQueue
decl_stmt|;
comment|/**    * The thread pool we're using for writing to the server. Note that the IO    * write is NOT designed for parallelism, so there can only be one thread    * in that pool (I'm using the thread pool mainly for the lifetime management    * capabilities, otherwise I'd have just used a simple Thread).    */
DECL|field|ioThreadPool
specifier|private
specifier|final
name|ThreadPoolExecutor
name|ioThreadPool
decl_stmt|;
comment|// The last task given to the ioThreadPool to execute, to allow
comment|// waiting until it's done.
DECL|field|lastQueuedTask
specifier|private
name|WriteRequest
name|lastQueuedTask
decl_stmt|;
comment|// Whether the stream has been closed.
DECL|field|closed
specifier|private
name|boolean
name|closed
init|=
literal|false
decl_stmt|;
DECL|field|LOG
specifier|public
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|AzureNativeFileSystemStore
operator|.
name|class
argument_list|)
decl_stmt|;
comment|// Set the minimum page blob file size to 128MB, which is>> the default
comment|// block size of 32MB. This default block size is often used as the
comment|// hbase.regionserver.hlog.blocksize.
comment|// The goal is to have a safe minimum size for HBase log files to allow them
comment|// to be filled and rolled without exceeding the minimum size. A larger size
comment|// can be used by setting the fs.azure.page.blob.size configuration variable.
DECL|field|PAGE_BLOB_MIN_SIZE
specifier|public
specifier|static
specifier|final
name|long
name|PAGE_BLOB_MIN_SIZE
init|=
literal|128L
operator|*
literal|1024L
operator|*
literal|1024L
decl_stmt|;
comment|// The default and minimum amount to extend a page blob by if it starts
comment|// to get full.
specifier|public
specifier|static
specifier|final
name|long
DECL|field|PAGE_BLOB_DEFAULT_EXTENSION_SIZE
name|PAGE_BLOB_DEFAULT_EXTENSION_SIZE
init|=
literal|128L
operator|*
literal|1024L
operator|*
literal|1024L
decl_stmt|;
comment|// The configured page blob extension size (either the default, or if greater,
comment|// the value configured in fs.azure.page.blob.extension.size
DECL|field|configuredPageBlobExtensionSize
specifier|private
name|long
name|configuredPageBlobExtensionSize
decl_stmt|;
comment|/**    * Constructs an output stream over the given page blob.    *    * @param blob the blob that this stream is associated with.    * @param opContext an object used to track the execution of the operation    * @throws StorageException if anything goes wrong creating the blob.    */
DECL|method|PageBlobOutputStream (final CloudPageBlobWrapper blob, final OperationContext opContext, final Configuration conf)
specifier|public
name|PageBlobOutputStream
parameter_list|(
specifier|final
name|CloudPageBlobWrapper
name|blob
parameter_list|,
specifier|final
name|OperationContext
name|opContext
parameter_list|,
specifier|final
name|Configuration
name|conf
parameter_list|)
throws|throws
name|StorageException
block|{
name|this
operator|.
name|blob
operator|=
name|blob
expr_stmt|;
name|this
operator|.
name|outBuffer
operator|=
operator|new
name|ByteArrayOutputStream
argument_list|()
expr_stmt|;
name|this
operator|.
name|opContext
operator|=
name|opContext
expr_stmt|;
name|this
operator|.
name|lastQueuedTask
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|ioQueue
operator|=
operator|new
name|LinkedBlockingQueue
argument_list|<
name|Runnable
argument_list|>
argument_list|()
expr_stmt|;
comment|// As explained above: the IO writes are not designed for parallelism,
comment|// so we only have one thread in this thread pool.
name|this
operator|.
name|ioThreadPool
operator|=
operator|new
name|ThreadPoolExecutor
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
name|TimeUnit
operator|.
name|SECONDS
argument_list|,
name|ioQueue
argument_list|)
expr_stmt|;
comment|// Make page blob files have a size that is the greater of a
comment|// minimum size, or the value of fs.azure.page.blob.size from configuration.
name|long
name|pageBlobConfigSize
init|=
name|conf
operator|.
name|getLong
argument_list|(
literal|"fs.azure.page.blob.size"
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Read value of fs.azure.page.blob.size as "
operator|+
name|pageBlobConfigSize
operator|+
literal|" from configuration (0 if not present)."
argument_list|)
expr_stmt|;
name|long
name|pageBlobSize
init|=
name|Math
operator|.
name|max
argument_list|(
name|PAGE_BLOB_MIN_SIZE
argument_list|,
name|pageBlobConfigSize
argument_list|)
decl_stmt|;
comment|// Ensure that the pageBlobSize is a multiple of page size.
if|if
condition|(
name|pageBlobSize
operator|%
name|PAGE_SIZE
operator|!=
literal|0
condition|)
block|{
name|pageBlobSize
operator|+=
name|PAGE_SIZE
operator|-
name|pageBlobSize
operator|%
name|PAGE_SIZE
expr_stmt|;
block|}
name|blob
operator|.
name|create
argument_list|(
name|pageBlobSize
argument_list|,
operator|new
name|BlobRequestOptions
argument_list|()
argument_list|,
name|opContext
argument_list|)
expr_stmt|;
name|currentBlobSize
operator|=
name|pageBlobSize
expr_stmt|;
comment|// Set the page blob extension size. It must be a minimum of the default
comment|// value.
name|configuredPageBlobExtensionSize
operator|=
name|conf
operator|.
name|getLong
argument_list|(
literal|"fs.azure.page.blob.extension.size"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|configuredPageBlobExtensionSize
operator|<
name|PAGE_BLOB_DEFAULT_EXTENSION_SIZE
condition|)
block|{
name|configuredPageBlobExtensionSize
operator|=
name|PAGE_BLOB_DEFAULT_EXTENSION_SIZE
expr_stmt|;
block|}
comment|// make sure it is a multiple of the page size
if|if
condition|(
name|configuredPageBlobExtensionSize
operator|%
name|PAGE_SIZE
operator|!=
literal|0
condition|)
block|{
name|configuredPageBlobExtensionSize
operator|+=
name|PAGE_SIZE
operator|-
name|configuredPageBlobExtensionSize
operator|%
name|PAGE_SIZE
expr_stmt|;
block|}
block|}
DECL|method|checkStreamState ()
specifier|private
name|void
name|checkStreamState
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|lastError
operator|!=
literal|null
condition|)
block|{
throw|throw
name|lastError
throw|;
block|}
block|}
comment|/**    * Query the stream for a specific capability.    *    * @param capability string to query the stream support for.    * @return true for hsync and hflush.    */
annotation|@
name|Override
DECL|method|hasCapability (String capability)
specifier|public
name|boolean
name|hasCapability
parameter_list|(
name|String
name|capability
parameter_list|)
block|{
switch|switch
condition|(
name|capability
operator|.
name|toLowerCase
argument_list|(
name|Locale
operator|.
name|ENGLISH
argument_list|)
condition|)
block|{
case|case
name|StreamCapabilities
operator|.
name|HSYNC
case|:
case|case
name|StreamCapabilities
operator|.
name|HFLUSH
case|:
return|return
literal|true
return|;
default|default:
return|return
literal|false
return|;
block|}
block|}
comment|/**    * Closes this output stream and releases any system resources associated with    * this stream. If any data remains in the buffer it is committed to the    * service.    */
annotation|@
name|Override
DECL|method|close ()
specifier|public
specifier|synchronized
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|closed
condition|)
block|{
return|return;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Closing page blob output stream."
argument_list|)
expr_stmt|;
name|flush
argument_list|()
expr_stmt|;
name|checkStreamState
argument_list|()
expr_stmt|;
name|ioThreadPool
operator|.
name|shutdown
argument_list|()
expr_stmt|;
try|try
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|ioThreadPool
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ioThreadPool
operator|.
name|awaitTermination
argument_list|(
literal|10
argument_list|,
name|TimeUnit
operator|.
name|MINUTES
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Timed out after 10 minutes waiting for IO requests to finish"
argument_list|)
expr_stmt|;
name|NativeAzureFileSystemHelper
operator|.
name|logAllLiveStackTraces
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
name|ioThreadPool
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Timed out waiting for IO requests to finish"
argument_list|)
throw|;
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Caught InterruptedException"
argument_list|)
expr_stmt|;
comment|// Restore the interrupted status
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
name|closed
operator|=
literal|true
expr_stmt|;
block|}
comment|/**    * A single write request for data to write to Azure storage.    */
DECL|class|WriteRequest
specifier|private
class|class
name|WriteRequest
implements|implements
name|Runnable
block|{
DECL|field|dataPayload
specifier|private
specifier|final
name|byte
index|[]
name|dataPayload
decl_stmt|;
DECL|field|doneSignal
specifier|private
specifier|final
name|CountDownLatch
name|doneSignal
init|=
operator|new
name|CountDownLatch
argument_list|(
literal|1
argument_list|)
decl_stmt|;
DECL|method|WriteRequest (byte[] dataPayload)
specifier|public
name|WriteRequest
parameter_list|(
name|byte
index|[]
name|dataPayload
parameter_list|)
block|{
name|this
operator|.
name|dataPayload
operator|=
name|dataPayload
expr_stmt|;
block|}
DECL|method|waitTillDone ()
specifier|public
name|void
name|waitTillDone
parameter_list|()
throws|throws
name|InterruptedException
block|{
name|doneSignal
operator|.
name|await
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
try|try
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"before runInternal()"
argument_list|)
expr_stmt|;
name|runInternal
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"after runInternal()"
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|doneSignal
operator|.
name|countDown
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|runInternal ()
specifier|private
name|void
name|runInternal
parameter_list|()
block|{
if|if
condition|(
name|lastError
operator|!=
literal|null
condition|)
block|{
comment|// We're already in an error state, no point doing anything.
return|return;
block|}
if|if
condition|(
name|dataPayload
operator|.
name|length
operator|==
literal|0
condition|)
block|{
comment|// Nothing to do.
return|return;
block|}
comment|// Since we have to rewrite the last request's last page's data
comment|// (may be empty), total data size is our data plus whatever was
comment|// left from there.
specifier|final
name|int
name|totalDataBytes
init|=
name|dataPayload
operator|.
name|length
operator|+
name|previousLastPageDataWritten
operator|.
name|length
decl_stmt|;
comment|// Calculate the total number of pages we're writing to the server.
specifier|final
name|int
name|numberOfPages
init|=
operator|(
name|totalDataBytes
operator|/
name|PAGE_DATA_SIZE
operator|)
operator|+
operator|(
name|totalDataBytes
operator|%
name|PAGE_DATA_SIZE
operator|==
literal|0
condition|?
literal|0
else|:
literal|1
operator|)
decl_stmt|;
comment|// Fill up the raw bytes we're writing.
name|byte
index|[]
name|rawPayload
init|=
operator|new
name|byte
index|[
name|numberOfPages
operator|*
name|PAGE_SIZE
index|]
decl_stmt|;
comment|// Keep track of the size of the last page we uploaded.
name|int
name|currentLastPageDataSize
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|int
name|page
init|=
literal|0
init|;
name|page
operator|<
name|numberOfPages
condition|;
name|page
operator|++
control|)
block|{
comment|// Our current byte offset in the data.
name|int
name|dataOffset
init|=
name|page
operator|*
name|PAGE_DATA_SIZE
decl_stmt|;
comment|// Our current byte offset in the raw buffer.
name|int
name|rawOffset
init|=
name|page
operator|*
name|PAGE_SIZE
decl_stmt|;
comment|// The size of the data in the current page.
specifier|final
name|short
name|currentPageDataSize
init|=
operator|(
name|short
operator|)
name|Math
operator|.
name|min
argument_list|(
name|PAGE_DATA_SIZE
argument_list|,
name|totalDataBytes
operator|-
name|dataOffset
argument_list|)
decl_stmt|;
comment|// Save off this page's size as the potential last page's size.
name|currentLastPageDataSize
operator|=
name|currentPageDataSize
expr_stmt|;
comment|// Write out the page size in the header.
specifier|final
name|byte
index|[]
name|header
init|=
name|fromShort
argument_list|(
name|currentPageDataSize
argument_list|)
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|header
argument_list|,
literal|0
argument_list|,
name|rawPayload
argument_list|,
name|rawOffset
argument_list|,
name|header
operator|.
name|length
argument_list|)
expr_stmt|;
name|rawOffset
operator|+=
name|header
operator|.
name|length
expr_stmt|;
name|int
name|bytesToCopyFromDataPayload
init|=
name|currentPageDataSize
decl_stmt|;
if|if
condition|(
name|dataOffset
operator|<
name|previousLastPageDataWritten
operator|.
name|length
condition|)
block|{
comment|// First write out the last page's data.
specifier|final
name|int
name|bytesToCopyFromLastPage
init|=
name|Math
operator|.
name|min
argument_list|(
name|currentPageDataSize
argument_list|,
name|previousLastPageDataWritten
operator|.
name|length
operator|-
name|dataOffset
argument_list|)
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|previousLastPageDataWritten
argument_list|,
name|dataOffset
argument_list|,
name|rawPayload
argument_list|,
name|rawOffset
argument_list|,
name|bytesToCopyFromLastPage
argument_list|)
expr_stmt|;
name|bytesToCopyFromDataPayload
operator|-=
name|bytesToCopyFromLastPage
expr_stmt|;
name|rawOffset
operator|+=
name|bytesToCopyFromLastPage
expr_stmt|;
name|dataOffset
operator|+=
name|bytesToCopyFromLastPage
expr_stmt|;
block|}
if|if
condition|(
name|dataOffset
operator|>=
name|previousLastPageDataWritten
operator|.
name|length
condition|)
block|{
comment|// Then write the current payload's data.
name|System
operator|.
name|arraycopy
argument_list|(
name|dataPayload
argument_list|,
name|dataOffset
operator|-
name|previousLastPageDataWritten
operator|.
name|length
argument_list|,
name|rawPayload
argument_list|,
name|rawOffset
argument_list|,
name|bytesToCopyFromDataPayload
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Raw payload constructed, ship it off to the server.
name|writePayloadToServer
argument_list|(
name|rawPayload
argument_list|)
expr_stmt|;
comment|// Post-send bookkeeping.
name|currentBlobOffset
operator|+=
name|rawPayload
operator|.
name|length
expr_stmt|;
if|if
condition|(
name|currentLastPageDataSize
operator|<
name|PAGE_DATA_SIZE
condition|)
block|{
comment|// Partial page, save it off so it's overwritten in the next request.
specifier|final
name|int
name|startOffset
init|=
operator|(
name|numberOfPages
operator|-
literal|1
operator|)
operator|*
name|PAGE_SIZE
operator|+
name|PAGE_HEADER_SIZE
decl_stmt|;
name|previousLastPageDataWritten
operator|=
name|Arrays
operator|.
name|copyOfRange
argument_list|(
name|rawPayload
argument_list|,
name|startOffset
argument_list|,
name|startOffset
operator|+
name|currentLastPageDataSize
argument_list|)
expr_stmt|;
comment|// Since we're rewriting this page, set our current offset in the server
comment|// to that page's beginning.
name|currentBlobOffset
operator|-=
name|PAGE_SIZE
expr_stmt|;
block|}
else|else
block|{
comment|// It wasn't a partial page, we won't need to rewrite it.
name|previousLastPageDataWritten
operator|=
operator|new
name|byte
index|[
literal|0
index|]
expr_stmt|;
block|}
comment|// Extend the file if we need more room in the file. This typically takes
comment|// less than 200 milliseconds if it has to actually be done,
comment|// so it is okay to include it in a write and won't cause a long pause.
comment|// Other writes can be queued behind this write in any case.
name|conditionalExtendFile
argument_list|()
expr_stmt|;
block|}
comment|/**      * Writes the given raw payload to Azure Storage at the current blob      * offset.      */
DECL|method|writePayloadToServer (byte[] rawPayload)
specifier|private
name|void
name|writePayloadToServer
parameter_list|(
name|byte
index|[]
name|rawPayload
parameter_list|)
block|{
specifier|final
name|ByteArrayInputStream
name|wrapperStream
init|=
operator|new
name|ByteArrayInputStream
argument_list|(
name|rawPayload
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"writing payload of "
operator|+
name|rawPayload
operator|.
name|length
operator|+
literal|" bytes to Azure page blob"
argument_list|)
expr_stmt|;
try|try
block|{
name|long
name|start
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|blob
operator|.
name|uploadPages
argument_list|(
name|wrapperStream
argument_list|,
name|currentBlobOffset
argument_list|,
name|rawPayload
operator|.
name|length
argument_list|,
name|withMD5Checking
argument_list|()
argument_list|,
name|PageBlobOutputStream
operator|.
name|this
operator|.
name|opContext
argument_list|)
expr_stmt|;
name|long
name|end
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|trace
argument_list|(
literal|"Azure uploadPages time for "
operator|+
name|rawPayload
operator|.
name|length
operator|+
literal|" bytes = "
operator|+
operator|(
name|end
operator|-
name|start
operator|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|ExceptionUtils
operator|.
name|getStackTrace
argument_list|(
name|ex
argument_list|)
argument_list|)
expr_stmt|;
name|lastError
operator|=
name|ex
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|StorageException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|ExceptionUtils
operator|.
name|getStackTrace
argument_list|(
name|ex
argument_list|)
argument_list|)
expr_stmt|;
name|lastError
operator|=
operator|new
name|IOException
argument_list|(
name|ex
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lastError
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Caught error in PageBlobOutputStream#writePayloadToServer()"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|flushIOBuffers ()
specifier|private
specifier|synchronized
name|void
name|flushIOBuffers
parameter_list|()
block|{
if|if
condition|(
name|outBuffer
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return;
block|}
name|lastQueuedTask
operator|=
operator|new
name|WriteRequest
argument_list|(
name|outBuffer
operator|.
name|toByteArray
argument_list|()
argument_list|)
expr_stmt|;
name|ioThreadPool
operator|.
name|execute
argument_list|(
name|lastQueuedTask
argument_list|)
expr_stmt|;
name|outBuffer
operator|=
operator|new
name|ByteArrayOutputStream
argument_list|()
expr_stmt|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|waitForLastFlushCompletion ()
specifier|synchronized
name|void
name|waitForLastFlushCompletion
parameter_list|()
throws|throws
name|IOException
block|{
try|try
block|{
if|if
condition|(
name|lastQueuedTask
operator|!=
literal|null
condition|)
block|{
name|lastQueuedTask
operator|.
name|waitTillDone
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e1
parameter_list|)
block|{
comment|// Restore the interrupted status
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Extend the page blob file if we are close to the end.    */
DECL|method|conditionalExtendFile ()
specifier|private
name|void
name|conditionalExtendFile
parameter_list|()
block|{
comment|// maximum allowed size of an Azure page blob (1 terabyte)
specifier|final
name|long
name|MAX_PAGE_BLOB_SIZE
init|=
literal|1024L
operator|*
literal|1024L
operator|*
literal|1024L
operator|*
literal|1024L
decl_stmt|;
comment|// If blob is already at the maximum size, then don't try to extend it.
if|if
condition|(
name|currentBlobSize
operator|==
name|MAX_PAGE_BLOB_SIZE
condition|)
block|{
return|return;
block|}
comment|// If we are within the maximum write size of the end of the file,
if|if
condition|(
name|currentBlobSize
operator|-
name|currentBlobOffset
operator|<=
name|MAX_RAW_BYTES_PER_REQUEST
condition|)
block|{
comment|// Extend the file. Retry up to 3 times with back-off.
name|CloudPageBlob
name|cloudPageBlob
init|=
operator|(
name|CloudPageBlob
operator|)
name|blob
operator|.
name|getBlob
argument_list|()
decl_stmt|;
name|long
name|newSize
init|=
name|currentBlobSize
operator|+
name|configuredPageBlobExtensionSize
decl_stmt|;
comment|// Make sure we don't exceed maximum blob size.
if|if
condition|(
name|newSize
operator|>
name|MAX_PAGE_BLOB_SIZE
condition|)
block|{
name|newSize
operator|=
name|MAX_PAGE_BLOB_SIZE
expr_stmt|;
block|}
specifier|final
name|int
name|MAX_RETRIES
init|=
literal|3
decl_stmt|;
name|int
name|retries
init|=
literal|1
decl_stmt|;
name|boolean
name|resizeDone
init|=
literal|false
decl_stmt|;
while|while
condition|(
operator|!
name|resizeDone
operator|&&
name|retries
operator|<=
name|MAX_RETRIES
condition|)
block|{
try|try
block|{
name|cloudPageBlob
operator|.
name|resize
argument_list|(
name|newSize
argument_list|)
expr_stmt|;
name|resizeDone
operator|=
literal|true
expr_stmt|;
name|currentBlobSize
operator|=
name|newSize
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|StorageException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to extend size of "
operator|+
name|cloudPageBlob
operator|.
name|getUri
argument_list|()
argument_list|)
expr_stmt|;
try|try
block|{
comment|// sleep 2, 8, 18 seconds for up to 3 retries
name|Thread
operator|.
name|sleep
argument_list|(
literal|2000
operator|*
name|retries
operator|*
name|retries
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e1
parameter_list|)
block|{
comment|// Restore the interrupted status
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|retries
operator|++
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**    * Flushes this output stream and forces any buffered output bytes to be    * written out. If any data remains in the buffer it is committed to the    * service. Data is queued for writing but not forced out to the service    * before the call returns.    */
annotation|@
name|Override
DECL|method|flush ()
specifier|public
name|void
name|flush
parameter_list|()
throws|throws
name|IOException
block|{
name|checkStreamState
argument_list|()
expr_stmt|;
name|flushIOBuffers
argument_list|()
expr_stmt|;
block|}
comment|/**    * Writes b.length bytes from the specified byte array to this output stream.    *    * @param data    *          the byte array to write.    *    * @throws IOException    *           if an I/O error occurs. In particular, an IOException may be    *           thrown if the output stream has been closed.    */
annotation|@
name|Override
DECL|method|write (final byte[] data)
specifier|public
name|void
name|write
parameter_list|(
specifier|final
name|byte
index|[]
name|data
parameter_list|)
throws|throws
name|IOException
block|{
name|write
argument_list|(
name|data
argument_list|,
literal|0
argument_list|,
name|data
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
comment|/**    * Writes length bytes from the specified byte array starting at offset to    * this output stream.    *    * @param data    *          the byte array to write.    * @param offset    *          the start offset in the data.    * @param length    *          the number of bytes to write.    * @throws IOException    *           if an I/O error occurs. In particular, an IOException may be    *           thrown if the output stream has been closed.    */
annotation|@
name|Override
DECL|method|write (final byte[] data, final int offset, final int length)
specifier|public
name|void
name|write
parameter_list|(
specifier|final
name|byte
index|[]
name|data
parameter_list|,
specifier|final
name|int
name|offset
parameter_list|,
specifier|final
name|int
name|length
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|offset
operator|<
literal|0
operator|||
name|length
argument_list|<
literal|0
operator|||
name|length
argument_list|>
name|data
operator|.
name|length
operator|-
name|offset
condition|)
block|{
throw|throw
operator|new
name|IndexOutOfBoundsException
argument_list|()
throw|;
block|}
name|writeInternal
argument_list|(
name|data
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
comment|/**    * Writes the specified byte to this output stream. The general contract for    * write is that one byte is written to the output stream. The byte to be    * written is the eight low-order bits of the argument b. The 24 high-order    * bits of b are ignored.    *    * @param byteVal    *          the byteValue to write.    * @throws IOException    *           if an I/O error occurs. In particular, an IOException may be    *           thrown if the output stream has been closed.    */
annotation|@
name|Override
DECL|method|write (final int byteVal)
specifier|public
name|void
name|write
parameter_list|(
specifier|final
name|int
name|byteVal
parameter_list|)
throws|throws
name|IOException
block|{
name|write
argument_list|(
operator|new
name|byte
index|[]
block|{
call|(
name|byte
call|)
argument_list|(
name|byteVal
operator|&
literal|0xFF
argument_list|)
block|}
argument_list|)
expr_stmt|;
block|}
comment|/**    * Writes the data to the buffer and triggers writes to the service as needed.    *    * @param data    *          the byte array to write.    * @param offset    *          the start offset in the data.    * @param length    *          the number of bytes to write.    * @throws IOException    *           if an I/O error occurs. In particular, an IOException may be    *           thrown if the output stream has been closed.    */
DECL|method|writeInternal (final byte[] data, int offset, int length)
specifier|private
specifier|synchronized
name|void
name|writeInternal
parameter_list|(
specifier|final
name|byte
index|[]
name|data
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
throws|throws
name|IOException
block|{
while|while
condition|(
name|length
operator|>
literal|0
condition|)
block|{
name|checkStreamState
argument_list|()
expr_stmt|;
specifier|final
name|int
name|availableBufferBytes
init|=
name|MAX_DATA_BYTES_PER_REQUEST
operator|-
name|this
operator|.
name|outBuffer
operator|.
name|size
argument_list|()
decl_stmt|;
specifier|final
name|int
name|nextWrite
init|=
name|Math
operator|.
name|min
argument_list|(
name|availableBufferBytes
argument_list|,
name|length
argument_list|)
decl_stmt|;
name|outBuffer
operator|.
name|write
argument_list|(
name|data
argument_list|,
name|offset
argument_list|,
name|nextWrite
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|nextWrite
expr_stmt|;
name|length
operator|-=
name|nextWrite
expr_stmt|;
if|if
condition|(
name|outBuffer
operator|.
name|size
argument_list|()
operator|>
name|MAX_DATA_BYTES_PER_REQUEST
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Internal error: maximum write size "
operator|+
name|Integer
operator|.
name|toString
argument_list|(
name|MAX_DATA_BYTES_PER_REQUEST
argument_list|)
operator|+
literal|"exceeded."
argument_list|)
throw|;
block|}
if|if
condition|(
name|outBuffer
operator|.
name|size
argument_list|()
operator|==
name|MAX_DATA_BYTES_PER_REQUEST
condition|)
block|{
name|flushIOBuffers
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Force all data in the output stream to be written to Azure storage.    * Wait to return until this is complete.    */
annotation|@
name|Override
DECL|method|hsync ()
specifier|public
specifier|synchronized
name|void
name|hsync
parameter_list|()
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Entering PageBlobOutputStream#hsync()."
argument_list|)
expr_stmt|;
name|long
name|start
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|flush
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
name|ioThreadPool
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
name|lastQueuedTask
operator|!=
literal|null
condition|)
block|{
name|lastQueuedTask
operator|.
name|waitTillDone
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e1
parameter_list|)
block|{
comment|// Restore the interrupted status
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Leaving PageBlobOutputStream#hsync(). Total hsync duration = "
operator|+
operator|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|start
operator|)
operator|+
literal|" msec."
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|hflush ()
specifier|public
name|void
name|hflush
parameter_list|()
throws|throws
name|IOException
block|{
comment|// hflush is required to force data to storage, so call hsync,
comment|// which does that.
name|hsync
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Deprecated
DECL|method|sync ()
specifier|public
name|void
name|sync
parameter_list|()
throws|throws
name|IOException
block|{
comment|// Sync has been deprecated in favor of hflush.
name|hflush
argument_list|()
expr_stmt|;
block|}
comment|// For unit testing purposes: kill the IO threads.
annotation|@
name|VisibleForTesting
DECL|method|killIoThreads ()
name|void
name|killIoThreads
parameter_list|()
block|{
name|ioThreadPool
operator|.
name|shutdownNow
argument_list|()
expr_stmt|;
block|}
block|}
end_class

end_unit

