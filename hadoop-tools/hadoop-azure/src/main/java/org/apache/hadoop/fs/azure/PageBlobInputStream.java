begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.fs.azure
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|azure
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|azure
operator|.
name|PageBlobFormatHelpers
operator|.
name|PAGE_DATA_SIZE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|azure
operator|.
name|PageBlobFormatHelpers
operator|.
name|PAGE_HEADER_SIZE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|azure
operator|.
name|PageBlobFormatHelpers
operator|.
name|PAGE_SIZE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|azure
operator|.
name|PageBlobFormatHelpers
operator|.
name|toShort
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|azure
operator|.
name|PageBlobFormatHelpers
operator|.
name|withMD5Checking
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|EOFException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FSExceptionMessages
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|azure
operator|.
name|StorageInterface
operator|.
name|CloudPageBlobWrapper
import|;
end_import

begin_import
import|import
name|com
operator|.
name|microsoft
operator|.
name|azure
operator|.
name|storage
operator|.
name|OperationContext
import|;
end_import

begin_import
import|import
name|com
operator|.
name|microsoft
operator|.
name|azure
operator|.
name|storage
operator|.
name|StorageException
import|;
end_import

begin_import
import|import
name|com
operator|.
name|microsoft
operator|.
name|azure
operator|.
name|storage
operator|.
name|blob
operator|.
name|BlobRequestOptions
import|;
end_import

begin_import
import|import
name|com
operator|.
name|microsoft
operator|.
name|azure
operator|.
name|storage
operator|.
name|blob
operator|.
name|PageRange
import|;
end_import

begin_comment
comment|/**  * An input stream that reads file data from a page blob stored  * using ASV's custom format.  */
end_comment

begin_class
DECL|class|PageBlobInputStream
specifier|final
class|class
name|PageBlobInputStream
extends|extends
name|InputStream
block|{
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|PageBlobInputStream
operator|.
name|class
argument_list|)
decl_stmt|;
comment|// The blob we're reading from.
DECL|field|blob
specifier|private
specifier|final
name|CloudPageBlobWrapper
name|blob
decl_stmt|;
comment|// The operation context to use for storage requests.
DECL|field|opContext
specifier|private
specifier|final
name|OperationContext
name|opContext
decl_stmt|;
comment|// The number of pages remaining to be read from the server.
DECL|field|numberOfPagesRemaining
specifier|private
name|long
name|numberOfPagesRemaining
decl_stmt|;
comment|// The current byte offset to start reading from the server next,
comment|// equivalent to (total number of pages we've read) * (page size).
DECL|field|currentOffsetInBlob
specifier|private
name|long
name|currentOffsetInBlob
decl_stmt|;
comment|// The buffer holding the current data we last read from the server.
DECL|field|currentBuffer
specifier|private
name|byte
index|[]
name|currentBuffer
decl_stmt|;
comment|// The current byte offset we're at in the buffer.
DECL|field|currentBufferOffset
specifier|private
name|int
name|currentBufferOffset
decl_stmt|;
comment|// The current buffer length
DECL|field|currentBufferLength
specifier|private
name|int
name|currentBufferLength
decl_stmt|;
comment|// Maximum number of pages to get per any one request.
DECL|field|MAX_PAGES_PER_DOWNLOAD
specifier|private
specifier|static
specifier|final
name|int
name|MAX_PAGES_PER_DOWNLOAD
init|=
literal|4
operator|*
literal|1024
operator|*
literal|1024
operator|/
name|PAGE_SIZE
decl_stmt|;
comment|// Whether the stream has been closed.
DECL|field|closed
specifier|private
name|boolean
name|closed
init|=
literal|false
decl_stmt|;
comment|// Total stream size, or -1 if not initialized.
DECL|field|pageBlobSize
name|long
name|pageBlobSize
init|=
operator|-
literal|1
decl_stmt|;
comment|// Current position in stream of valid data.
DECL|field|filePosition
name|long
name|filePosition
init|=
literal|0
decl_stmt|;
comment|/**    * Helper method to extract the actual data size of a page blob.    * This typically involves 2 service requests (one for page ranges, another    * for the last page's data).    *    * @param blob The blob to get the size from.    * @param opContext The operation context to use for the requests.    * @return The total data size of the blob in bytes.    * @throws IOException If the format is corrupt.    * @throws StorageException If anything goes wrong in the requests.    */
DECL|method|getPageBlobDataSize (CloudPageBlobWrapper blob, OperationContext opContext)
specifier|public
specifier|static
name|long
name|getPageBlobDataSize
parameter_list|(
name|CloudPageBlobWrapper
name|blob
parameter_list|,
name|OperationContext
name|opContext
parameter_list|)
throws|throws
name|IOException
throws|,
name|StorageException
block|{
comment|// Get the page ranges for the blob. There should be one range starting
comment|// at byte 0, but we tolerate (and ignore) ranges after the first one.
name|ArrayList
argument_list|<
name|PageRange
argument_list|>
name|pageRanges
init|=
name|blob
operator|.
name|downloadPageRanges
argument_list|(
operator|new
name|BlobRequestOptions
argument_list|()
argument_list|,
name|opContext
argument_list|)
decl_stmt|;
if|if
condition|(
name|pageRanges
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
if|if
condition|(
name|pageRanges
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getStartOffset
argument_list|()
operator|!=
literal|0
condition|)
block|{
comment|// Not expected: we always upload our page blobs as a contiguous range
comment|// starting at byte 0.
throw|throw
name|badStartRangeException
argument_list|(
name|blob
argument_list|,
name|pageRanges
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
throw|;
block|}
name|long
name|totalRawBlobSize
init|=
name|pageRanges
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getEndOffset
argument_list|()
operator|+
literal|1
decl_stmt|;
comment|// Get the last page.
name|long
name|lastPageStart
init|=
name|totalRawBlobSize
operator|-
name|PAGE_SIZE
decl_stmt|;
name|ByteArrayOutputStream
name|baos
init|=
operator|new
name|ByteArrayOutputStream
argument_list|(
name|PageBlobFormatHelpers
operator|.
name|PAGE_SIZE
argument_list|)
decl_stmt|;
name|blob
operator|.
name|downloadRange
argument_list|(
name|lastPageStart
argument_list|,
name|PAGE_SIZE
argument_list|,
name|baos
argument_list|,
operator|new
name|BlobRequestOptions
argument_list|()
argument_list|,
name|opContext
argument_list|)
expr_stmt|;
name|byte
index|[]
name|lastPage
init|=
name|baos
operator|.
name|toByteArray
argument_list|()
decl_stmt|;
name|short
name|lastPageSize
init|=
name|getPageSize
argument_list|(
name|blob
argument_list|,
name|lastPage
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|long
name|totalNumberOfPages
init|=
name|totalRawBlobSize
operator|/
name|PAGE_SIZE
decl_stmt|;
return|return
operator|(
name|totalNumberOfPages
operator|-
literal|1
operator|)
operator|*
name|PAGE_DATA_SIZE
operator|+
name|lastPageSize
return|;
block|}
comment|/**    * Constructs a stream over the given page blob.    */
DECL|method|PageBlobInputStream (CloudPageBlobWrapper blob, OperationContext opContext)
specifier|public
name|PageBlobInputStream
parameter_list|(
name|CloudPageBlobWrapper
name|blob
parameter_list|,
name|OperationContext
name|opContext
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|blob
operator|=
name|blob
expr_stmt|;
name|this
operator|.
name|opContext
operator|=
name|opContext
expr_stmt|;
name|ArrayList
argument_list|<
name|PageRange
argument_list|>
name|allRanges
decl_stmt|;
try|try
block|{
name|allRanges
operator|=
name|blob
operator|.
name|downloadPageRanges
argument_list|(
operator|new
name|BlobRequestOptions
argument_list|()
argument_list|,
name|opContext
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|StorageException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|e
argument_list|)
throw|;
block|}
if|if
condition|(
name|allRanges
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|allRanges
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getStartOffset
argument_list|()
operator|!=
literal|0
condition|)
block|{
throw|throw
name|badStartRangeException
argument_list|(
name|blob
argument_list|,
name|allRanges
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
throw|;
block|}
if|if
condition|(
name|allRanges
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Blob %s has %d page ranges beyond the first range. "
operator|+
literal|"Only reading the first range."
argument_list|,
name|blob
operator|.
name|getUri
argument_list|()
argument_list|,
name|allRanges
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|numberOfPagesRemaining
operator|=
operator|(
name|allRanges
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getEndOffset
argument_list|()
operator|+
literal|1
operator|)
operator|/
name|PAGE_SIZE
expr_stmt|;
block|}
else|else
block|{
name|numberOfPagesRemaining
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/** Return the size of the remaining available bytes    * if the size is less than or equal to {@link Integer#MAX_VALUE},    * otherwise, return {@link Integer#MAX_VALUE}.    *    * This is to match the behavior of DFSInputStream.available(),    * which some clients may rely on (HBase write-ahead log reading in    * particular).    */
annotation|@
name|Override
DECL|method|available ()
specifier|public
specifier|synchronized
name|int
name|available
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|closed
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Stream closed"
argument_list|)
throw|;
block|}
if|if
condition|(
name|pageBlobSize
operator|==
operator|-
literal|1
condition|)
block|{
try|try
block|{
name|pageBlobSize
operator|=
name|getPageBlobDataSize
argument_list|(
name|blob
argument_list|,
name|opContext
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|StorageException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unable to get page blob size."
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
specifier|final
name|long
name|remaining
init|=
name|pageBlobSize
operator|-
name|filePosition
decl_stmt|;
return|return
name|remaining
operator|<=
name|Integer
operator|.
name|MAX_VALUE
condition|?
operator|(
name|int
operator|)
name|remaining
else|:
name|Integer
operator|.
name|MAX_VALUE
return|;
block|}
annotation|@
name|Override
DECL|method|close ()
specifier|public
specifier|synchronized
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
name|closed
operator|=
literal|true
expr_stmt|;
block|}
DECL|method|dataAvailableInBuffer ()
specifier|private
name|boolean
name|dataAvailableInBuffer
parameter_list|()
block|{
return|return
name|currentBuffer
operator|!=
literal|null
operator|&&
name|currentBufferOffset
operator|<
name|currentBufferLength
return|;
block|}
comment|/**    * Check our buffer and download more from the server if needed.    * If data is not available in the buffer, method downloads maximum    * page blob download size (4MB) or if there is less then 4MB left,    * all remaining pages.    * If we are on the last page, method will return true even if    * we reached the end of stream.    * @return true if there's more data in the buffer, false if buffer is empty    *         and we reached the end of the blob.    * @throws IOException    */
DECL|method|ensureDataInBuffer ()
specifier|private
specifier|synchronized
name|boolean
name|ensureDataInBuffer
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|dataAvailableInBuffer
argument_list|()
condition|)
block|{
comment|// We still have some data in our buffer.
return|return
literal|true
return|;
block|}
name|currentBuffer
operator|=
literal|null
expr_stmt|;
name|currentBufferOffset
operator|=
literal|0
expr_stmt|;
name|currentBufferLength
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|numberOfPagesRemaining
operator|==
literal|0
condition|)
block|{
comment|// No more data to read.
return|return
literal|false
return|;
block|}
specifier|final
name|long
name|pagesToRead
init|=
name|Math
operator|.
name|min
argument_list|(
name|MAX_PAGES_PER_DOWNLOAD
argument_list|,
name|numberOfPagesRemaining
argument_list|)
decl_stmt|;
specifier|final
name|int
name|bufferSize
init|=
call|(
name|int
call|)
argument_list|(
name|pagesToRead
operator|*
name|PAGE_SIZE
argument_list|)
decl_stmt|;
comment|// Download page to current buffer.
try|try
block|{
comment|// Create a byte array output stream to capture the results of the
comment|// download.
name|ByteArrayOutputStream
name|baos
init|=
operator|new
name|ByteArrayOutputStream
argument_list|(
name|bufferSize
argument_list|)
decl_stmt|;
name|blob
operator|.
name|downloadRange
argument_list|(
name|currentOffsetInBlob
argument_list|,
name|bufferSize
argument_list|,
name|baos
argument_list|,
name|withMD5Checking
argument_list|()
argument_list|,
name|opContext
argument_list|)
expr_stmt|;
name|validateDataIntegrity
argument_list|(
name|baos
operator|.
name|toByteArray
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|StorageException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|e
argument_list|)
throw|;
block|}
name|numberOfPagesRemaining
operator|-=
name|pagesToRead
expr_stmt|;
name|currentOffsetInBlob
operator|+=
name|bufferSize
expr_stmt|;
return|return
literal|true
return|;
block|}
DECL|method|validateDataIntegrity (byte[] buffer)
specifier|private
name|void
name|validateDataIntegrity
parameter_list|(
name|byte
index|[]
name|buffer
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|buffer
operator|.
name|length
operator|%
name|PAGE_SIZE
operator|!=
literal|0
condition|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"Unexpected buffer size: "
operator|+
name|buffer
operator|.
name|length
argument_list|)
throw|;
block|}
name|int
name|bufferLength
init|=
literal|0
decl_stmt|;
name|int
name|numberOfPages
init|=
name|buffer
operator|.
name|length
operator|/
name|PAGE_SIZE
decl_stmt|;
name|long
name|totalPagesAfterCurrent
init|=
name|numberOfPagesRemaining
decl_stmt|;
for|for
control|(
name|int
name|page
init|=
literal|0
init|;
name|page
operator|<
name|numberOfPages
condition|;
name|page
operator|++
control|)
block|{
comment|// Calculate the number of pages that exist in the blob after this one
name|totalPagesAfterCurrent
operator|--
expr_stmt|;
name|short
name|currentPageSize
init|=
name|getPageSize
argument_list|(
name|blob
argument_list|,
name|buffer
argument_list|,
name|page
operator|*
name|PAGE_SIZE
argument_list|)
decl_stmt|;
comment|// Only the last page can be partially filled.
if|if
condition|(
name|currentPageSize
argument_list|<
name|PAGE_DATA_SIZE
operator|&&
name|totalPagesAfterCurrent
argument_list|>
literal|0
condition|)
block|{
throw|throw
name|fileCorruptException
argument_list|(
name|blob
argument_list|,
name|String
operator|.
name|format
argument_list|(
literal|"Page with partial data found in the middle (%d pages from the"
operator|+
literal|" end) that only has %d bytes of data."
argument_list|,
name|totalPagesAfterCurrent
argument_list|,
name|currentPageSize
argument_list|)
argument_list|)
throw|;
block|}
name|bufferLength
operator|+=
name|currentPageSize
operator|+
name|PAGE_HEADER_SIZE
expr_stmt|;
block|}
name|currentBufferOffset
operator|=
name|PAGE_HEADER_SIZE
expr_stmt|;
name|currentBufferLength
operator|=
name|bufferLength
expr_stmt|;
name|currentBuffer
operator|=
name|buffer
expr_stmt|;
block|}
comment|// Reads the page size from the page header at the given offset.
DECL|method|getPageSize (CloudPageBlobWrapper blob, byte[] data, int offset)
specifier|private
specifier|static
name|short
name|getPageSize
parameter_list|(
name|CloudPageBlobWrapper
name|blob
parameter_list|,
name|byte
index|[]
name|data
parameter_list|,
name|int
name|offset
parameter_list|)
throws|throws
name|IOException
block|{
name|short
name|pageSize
init|=
name|toShort
argument_list|(
name|data
index|[
name|offset
index|]
argument_list|,
name|data
index|[
name|offset
operator|+
literal|1
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|pageSize
argument_list|<
literal|0
operator|||
name|pageSize
argument_list|>
name|PAGE_DATA_SIZE
condition|)
block|{
throw|throw
name|fileCorruptException
argument_list|(
name|blob
argument_list|,
name|String
operator|.
name|format
argument_list|(
literal|"Unexpected page size in the header: %d."
argument_list|,
name|pageSize
argument_list|)
argument_list|)
throw|;
block|}
return|return
name|pageSize
return|;
block|}
annotation|@
name|Override
DECL|method|read (byte[] outputBuffer, int offset, int len)
specifier|public
specifier|synchronized
name|int
name|read
parameter_list|(
name|byte
index|[]
name|outputBuffer
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|len
parameter_list|)
throws|throws
name|IOException
block|{
comment|// If len is zero return 0 per the InputStream contract
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
name|int
name|numberOfBytesRead
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|ensureDataInBuffer
argument_list|()
condition|)
block|{
break|break;
block|}
name|int
name|bytesRemainingInCurrentPage
init|=
name|getBytesRemainingInCurrentPage
argument_list|()
decl_stmt|;
name|int
name|numBytesToRead
init|=
name|Math
operator|.
name|min
argument_list|(
name|len
argument_list|,
name|bytesRemainingInCurrentPage
argument_list|)
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|currentBuffer
argument_list|,
name|currentBufferOffset
argument_list|,
name|outputBuffer
argument_list|,
name|offset
argument_list|,
name|numBytesToRead
argument_list|)
expr_stmt|;
name|numberOfBytesRead
operator|+=
name|numBytesToRead
expr_stmt|;
name|offset
operator|+=
name|numBytesToRead
expr_stmt|;
name|len
operator|-=
name|numBytesToRead
expr_stmt|;
if|if
condition|(
name|numBytesToRead
operator|==
name|bytesRemainingInCurrentPage
condition|)
block|{
comment|// We've finished this page, move on to the next.
name|advancePagesInBuffer
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|currentBufferOffset
operator|+=
name|numBytesToRead
expr_stmt|;
block|}
block|}
comment|// if outputBuffer len is> 0 and zero bytes were read, we reached
comment|// an EOF
if|if
condition|(
name|numberOfBytesRead
operator|==
literal|0
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
name|filePosition
operator|+=
name|numberOfBytesRead
expr_stmt|;
return|return
name|numberOfBytesRead
return|;
block|}
annotation|@
name|Override
DECL|method|read ()
specifier|public
name|int
name|read
parameter_list|()
throws|throws
name|IOException
block|{
name|byte
index|[]
name|oneByte
init|=
operator|new
name|byte
index|[
literal|1
index|]
decl_stmt|;
name|int
name|result
init|=
name|read
argument_list|(
name|oneByte
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|<
literal|0
condition|)
block|{
return|return
name|result
return|;
block|}
return|return
name|oneByte
index|[
literal|0
index|]
return|;
block|}
comment|/**    * Skips over and discards<code>n</code> bytes of data from this input    * stream. The<code>skip</code> method may, for a variety of reasons, end    * up skipping over some smaller number of bytes, possibly<code>0</code>.    * This may result from any of a number of conditions; reaching end of file    * before<code>n</code> bytes have been skipped is only one possibility.    * The actual number of bytes skipped is returned. If {@code n} is    * negative, the {@code skip} method for class {@code InputStream} always    * returns 0, and no bytes are skipped. Subclasses may handle the negative    * value differently.    *    *<p> The<code>skip</code> method of this class creates a    * byte array and then repeatedly reads into it until<code>n</code> bytes    * have been read or the end of the stream has been reached. Subclasses are    * encouraged to provide a more efficient implementation of this method.    * For instance, the implementation may depend on the ability to seek.    *    * @param      n   the number of bytes to be skipped.    * @return     the actual number of bytes skipped.    * @exception  IOException  if the stream does not support seek,    *                          or if some other I/O error occurs.    */
annotation|@
name|Override
DECL|method|skip (long n)
specifier|public
specifier|synchronized
name|long
name|skip
parameter_list|(
name|long
name|n
parameter_list|)
throws|throws
name|IOException
block|{
name|long
name|skipped
init|=
name|skipImpl
argument_list|(
name|n
argument_list|)
decl_stmt|;
name|filePosition
operator|+=
name|skipped
expr_stmt|;
comment|// track the position in the stream
return|return
name|skipped
return|;
block|}
DECL|method|skipImpl (long n)
specifier|private
name|long
name|skipImpl
parameter_list|(
name|long
name|n
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
comment|// First skip within the current buffer as much as possible.
name|long
name|skippedWithinBuffer
init|=
name|skipWithinBuffer
argument_list|(
name|n
argument_list|)
decl_stmt|;
if|if
condition|(
name|skippedWithinBuffer
operator|>
name|n
condition|)
block|{
comment|// TO CONSIDER: Using a contracts framework such as Google's cofoja for
comment|// these post-conditions.
throw|throw
operator|new
name|AssertionError
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Bug in skipWithinBuffer: it skipped over %d bytes when asked to "
operator|+
literal|"skip %d bytes."
argument_list|,
name|skippedWithinBuffer
argument_list|,
name|n
argument_list|)
argument_list|)
throw|;
block|}
name|n
operator|-=
name|skippedWithinBuffer
expr_stmt|;
name|long
name|skipped
init|=
name|skippedWithinBuffer
decl_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
return|return
name|skipped
return|;
block|}
if|if
condition|(
name|numberOfPagesRemaining
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|EOFException
argument_list|(
name|FSExceptionMessages
operator|.
name|CANNOT_SEEK_PAST_EOF
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|numberOfPagesRemaining
operator|>
literal|1
condition|)
block|{
comment|// skip over as many pages as we can, but we must read the last
comment|// page as it may not be full
name|long
name|pagesToSkipOver
init|=
name|Math
operator|.
name|min
argument_list|(
name|n
operator|/
name|PAGE_DATA_SIZE
argument_list|,
name|numberOfPagesRemaining
operator|-
literal|1
argument_list|)
decl_stmt|;
name|numberOfPagesRemaining
operator|-=
name|pagesToSkipOver
expr_stmt|;
name|currentOffsetInBlob
operator|+=
name|pagesToSkipOver
operator|*
name|PAGE_SIZE
expr_stmt|;
name|skipped
operator|+=
name|pagesToSkipOver
operator|*
name|PAGE_DATA_SIZE
expr_stmt|;
name|n
operator|-=
name|pagesToSkipOver
operator|*
name|PAGE_DATA_SIZE
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
return|return
name|skipped
return|;
block|}
comment|// Now read in at the current position, and skip within current buffer.
if|if
condition|(
operator|!
name|ensureDataInBuffer
argument_list|()
condition|)
block|{
return|return
name|skipped
return|;
block|}
return|return
name|skipped
operator|+
name|skipWithinBuffer
argument_list|(
name|n
argument_list|)
return|;
block|}
comment|/**    * Skip over n bytes within the current buffer or just over skip the whole    * buffer if n is greater than the bytes remaining in the buffer.    * @param n The number of data bytes to skip.    * @return The number of bytes actually skipped.    * @throws IOException if data corruption found in the buffer.    */
DECL|method|skipWithinBuffer (long n)
specifier|private
name|long
name|skipWithinBuffer
parameter_list|(
name|long
name|n
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|dataAvailableInBuffer
argument_list|()
condition|)
block|{
return|return
literal|0
return|;
block|}
name|long
name|skipped
init|=
literal|0
decl_stmt|;
comment|// First skip within the current page.
name|skipped
operator|=
name|skipWithinCurrentPage
argument_list|(
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|skipped
operator|>
name|n
condition|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Bug in skipWithinCurrentPage: it skipped over %d bytes when asked"
operator|+
literal|" to skip %d bytes."
argument_list|,
name|skipped
argument_list|,
name|n
argument_list|)
argument_list|)
throw|;
block|}
name|n
operator|-=
name|skipped
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
operator|||
operator|!
name|dataAvailableInBuffer
argument_list|()
condition|)
block|{
return|return
name|skipped
return|;
block|}
comment|// Calculate how many whole pages (pages before the possibly partially
comment|// filled last page) remain.
name|int
name|currentPageIndex
init|=
name|currentBufferOffset
operator|/
name|PAGE_SIZE
decl_stmt|;
name|int
name|numberOfPagesInBuffer
init|=
name|currentBuffer
operator|.
name|length
operator|/
name|PAGE_SIZE
decl_stmt|;
name|int
name|wholePagesRemaining
init|=
name|numberOfPagesInBuffer
operator|-
name|currentPageIndex
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|n
operator|<
operator|(
name|PAGE_DATA_SIZE
operator|*
name|wholePagesRemaining
operator|)
condition|)
block|{
comment|// I'm within one of the whole pages remaining, skip in there.
name|advancePagesInBuffer
argument_list|(
call|(
name|int
call|)
argument_list|(
name|n
operator|/
name|PAGE_DATA_SIZE
argument_list|)
argument_list|)
expr_stmt|;
name|currentBufferOffset
operator|+=
name|n
operator|%
name|PAGE_DATA_SIZE
expr_stmt|;
return|return
name|n
operator|+
name|skipped
return|;
block|}
comment|// Skip over the whole pages.
name|advancePagesInBuffer
argument_list|(
name|wholePagesRemaining
argument_list|)
expr_stmt|;
name|skipped
operator|+=
name|wholePagesRemaining
operator|*
name|PAGE_DATA_SIZE
expr_stmt|;
name|n
operator|-=
name|wholePagesRemaining
operator|*
name|PAGE_DATA_SIZE
expr_stmt|;
comment|// At this point we know we need to skip to somewhere in the last page,
comment|// or just go to the end.
return|return
name|skipWithinCurrentPage
argument_list|(
name|n
argument_list|)
operator|+
name|skipped
return|;
block|}
comment|/**    * Skip over n bytes within the current page or just over skip the whole    * page if n is greater than the bytes remaining in the page.    * @param n The number of data bytes to skip.    * @return The number of bytes actually skipped.    * @throws IOException if data corruption found in the buffer.    */
DECL|method|skipWithinCurrentPage (long n)
specifier|private
name|long
name|skipWithinCurrentPage
parameter_list|(
name|long
name|n
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|remainingBytesInCurrentPage
init|=
name|getBytesRemainingInCurrentPage
argument_list|()
decl_stmt|;
if|if
condition|(
name|n
operator|<=
name|remainingBytesInCurrentPage
condition|)
block|{
name|currentBufferOffset
operator|+=
name|n
expr_stmt|;
return|return
name|n
return|;
block|}
else|else
block|{
name|advancePagesInBuffer
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
name|remainingBytesInCurrentPage
return|;
block|}
block|}
comment|/**    * Gets the number of bytes remaining within the current page in the buffer.    * @return The number of bytes remaining.    * @throws IOException if data corruption found in the buffer.    */
DECL|method|getBytesRemainingInCurrentPage ()
specifier|private
name|int
name|getBytesRemainingInCurrentPage
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|dataAvailableInBuffer
argument_list|()
condition|)
block|{
return|return
literal|0
return|;
block|}
comment|// Calculate our current position relative to the start of the current
comment|// page.
name|int
name|currentDataOffsetInPage
init|=
operator|(
name|currentBufferOffset
operator|%
name|PAGE_SIZE
operator|)
operator|-
name|PAGE_HEADER_SIZE
decl_stmt|;
name|int
name|pageBoundary
init|=
name|getCurrentPageStartInBuffer
argument_list|()
decl_stmt|;
comment|// Get the data size of the current page from the header.
name|short
name|sizeOfCurrentPage
init|=
name|getPageSize
argument_list|(
name|blob
argument_list|,
name|currentBuffer
argument_list|,
name|pageBoundary
argument_list|)
decl_stmt|;
return|return
name|sizeOfCurrentPage
operator|-
name|currentDataOffsetInPage
return|;
block|}
DECL|method|badStartRangeException (CloudPageBlobWrapper blob, PageRange startRange)
specifier|private
specifier|static
name|IOException
name|badStartRangeException
parameter_list|(
name|CloudPageBlobWrapper
name|blob
parameter_list|,
name|PageRange
name|startRange
parameter_list|)
block|{
return|return
name|fileCorruptException
argument_list|(
name|blob
argument_list|,
name|String
operator|.
name|format
argument_list|(
literal|"Page blobs for ASV should always use a page range starting at byte 0. "
operator|+
literal|"This starts at byte %d."
argument_list|,
name|startRange
operator|.
name|getStartOffset
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
DECL|method|advancePagesInBuffer (int numberOfPages)
specifier|private
name|void
name|advancePagesInBuffer
parameter_list|(
name|int
name|numberOfPages
parameter_list|)
block|{
name|currentBufferOffset
operator|=
name|getCurrentPageStartInBuffer
argument_list|()
operator|+
operator|(
name|numberOfPages
operator|*
name|PAGE_SIZE
operator|)
operator|+
name|PAGE_HEADER_SIZE
expr_stmt|;
block|}
DECL|method|getCurrentPageStartInBuffer ()
specifier|private
name|int
name|getCurrentPageStartInBuffer
parameter_list|()
block|{
return|return
name|PAGE_SIZE
operator|*
operator|(
name|currentBufferOffset
operator|/
name|PAGE_SIZE
operator|)
return|;
block|}
DECL|method|fileCorruptException (CloudPageBlobWrapper blob, String reason)
specifier|private
specifier|static
name|IOException
name|fileCorruptException
parameter_list|(
name|CloudPageBlobWrapper
name|blob
parameter_list|,
name|String
name|reason
parameter_list|)
block|{
return|return
operator|new
name|IOException
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"The page blob: '%s' is corrupt or has an unexpected format: %s."
argument_list|,
name|blob
operator|.
name|getUri
argument_list|()
argument_list|,
name|reason
argument_list|)
argument_list|)
return|;
block|}
block|}
end_class

end_unit

