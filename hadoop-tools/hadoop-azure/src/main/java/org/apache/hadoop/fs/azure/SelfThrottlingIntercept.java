begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.fs.azure
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|azure
package|;
end_package

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|HttpURLConnection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Date
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|com
operator|.
name|microsoft
operator|.
name|azure
operator|.
name|storage
operator|.
name|OperationContext
import|;
end_import

begin_import
import|import
name|com
operator|.
name|microsoft
operator|.
name|azure
operator|.
name|storage
operator|.
name|RequestResult
import|;
end_import

begin_import
import|import
name|com
operator|.
name|microsoft
operator|.
name|azure
operator|.
name|storage
operator|.
name|ResponseReceivedEvent
import|;
end_import

begin_import
import|import
name|com
operator|.
name|microsoft
operator|.
name|azure
operator|.
name|storage
operator|.
name|SendingRequestEvent
import|;
end_import

begin_import
import|import
name|com
operator|.
name|microsoft
operator|.
name|azure
operator|.
name|storage
operator|.
name|StorageEvent
import|;
end_import

begin_comment
comment|/*  * Self throttling is implemented by hooking into send& response callbacks   * One instance of this class is created per operationContext so each blobUpload/blobDownload/etc.  *   * Self throttling only applies to 2nd and subsequent packets of an operation.  This is a simple way to   * ensure it only affects bulk transfers and not every tiny request.  *   * A blobDownload will involve sequential packet transmissions and so there are no concurrency concerns  * A blobUpload will generally involve concurrent upload worker threads that share one operationContext and one throttling instance.  *   -- we do not track the latencies for each worker thread as they are doing similar work and will rarely collide in practice.    *   -- concurrent access to lastE2Edelay must be protected.    *       -- volatile is necessary and should be sufficient to protect simple access to primitive values (java 1.5 onwards)   *       -- synchronized{} blocks are also used to be conservative and for easier maintenance.  *     * If an operation were to perform concurrent GETs and PUTs there is the possibility of getting confused regarding  * whether lastE2Edelay was a read or write measurement.  This scenario does not occur.  *  * readFactor  = target read throughput as factor of unrestricted throughput.  * writeFactor = target write throughput as factor of unrestricted throughput.  *   * As we introduce delays it is important to only measure the actual E2E latency and not the augmented latency  * To achieve this, we fiddle the 'startDate' of the transfer tracking object.  */
end_comment

begin_comment
comment|/**  *   * Introduces delays in our Azure traffic to prevent overrunning the server-side throttling limits.  *  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
DECL|class|SelfThrottlingIntercept
specifier|public
class|class
name|SelfThrottlingIntercept
block|{
DECL|field|LOG
specifier|public
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|SelfThrottlingIntercept
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|readFactor
specifier|private
specifier|final
name|float
name|readFactor
decl_stmt|;
DECL|field|writeFactor
specifier|private
specifier|final
name|float
name|writeFactor
decl_stmt|;
DECL|field|operationContext
specifier|private
specifier|final
name|OperationContext
name|operationContext
decl_stmt|;
comment|// Concurrency: access to non-final members must be thread-safe
DECL|field|lastE2Elatency
specifier|private
name|long
name|lastE2Elatency
decl_stmt|;
DECL|method|SelfThrottlingIntercept (OperationContext operationContext, float readFactor, float writeFactor)
specifier|public
name|SelfThrottlingIntercept
parameter_list|(
name|OperationContext
name|operationContext
parameter_list|,
name|float
name|readFactor
parameter_list|,
name|float
name|writeFactor
parameter_list|)
block|{
name|this
operator|.
name|operationContext
operator|=
name|operationContext
expr_stmt|;
name|this
operator|.
name|readFactor
operator|=
name|readFactor
expr_stmt|;
name|this
operator|.
name|writeFactor
operator|=
name|writeFactor
expr_stmt|;
block|}
DECL|method|hook (OperationContext operationContext, float readFactor, float writeFactor)
specifier|public
specifier|static
name|void
name|hook
parameter_list|(
name|OperationContext
name|operationContext
parameter_list|,
name|float
name|readFactor
parameter_list|,
name|float
name|writeFactor
parameter_list|)
block|{
name|SelfThrottlingIntercept
name|throttler
init|=
operator|new
name|SelfThrottlingIntercept
argument_list|(
name|operationContext
argument_list|,
name|readFactor
argument_list|,
name|writeFactor
argument_list|)
decl_stmt|;
name|ResponseReceivedListener
name|responseListener
init|=
name|throttler
operator|.
expr|new
name|ResponseReceivedListener
argument_list|()
decl_stmt|;
name|SendingRequestListener
name|sendingListener
init|=
name|throttler
operator|.
expr|new
name|SendingRequestListener
argument_list|()
decl_stmt|;
name|operationContext
operator|.
name|getResponseReceivedEventHandler
argument_list|()
operator|.
name|addListener
argument_list|(
name|responseListener
argument_list|)
expr_stmt|;
name|operationContext
operator|.
name|getSendingRequestEventHandler
argument_list|()
operator|.
name|addListener
argument_list|(
name|sendingListener
argument_list|)
expr_stmt|;
block|}
DECL|method|responseReceived (ResponseReceivedEvent event)
specifier|public
name|void
name|responseReceived
parameter_list|(
name|ResponseReceivedEvent
name|event
parameter_list|)
block|{
name|RequestResult
name|result
init|=
name|event
operator|.
name|getRequestResult
argument_list|()
decl_stmt|;
name|Date
name|startDate
init|=
name|result
operator|.
name|getStartDate
argument_list|()
decl_stmt|;
name|Date
name|stopDate
init|=
name|result
operator|.
name|getStopDate
argument_list|()
decl_stmt|;
name|long
name|elapsed
init|=
name|stopDate
operator|.
name|getTime
argument_list|()
operator|-
name|startDate
operator|.
name|getTime
argument_list|()
decl_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
name|this
operator|.
name|lastE2Elatency
operator|=
name|elapsed
expr_stmt|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|int
name|statusCode
init|=
name|result
operator|.
name|getStatusCode
argument_list|()
decl_stmt|;
name|String
name|etag
init|=
name|result
operator|.
name|getEtag
argument_list|()
decl_stmt|;
name|HttpURLConnection
name|urlConnection
init|=
operator|(
name|HttpURLConnection
operator|)
name|event
operator|.
name|getConnectionObject
argument_list|()
decl_stmt|;
name|int
name|contentLength
init|=
name|urlConnection
operator|.
name|getContentLength
argument_list|()
decl_stmt|;
name|String
name|requestMethod
init|=
name|urlConnection
operator|.
name|getRequestMethod
argument_list|()
decl_stmt|;
name|long
name|threadId
init|=
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getId
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"SelfThrottlingIntercept:: ResponseReceived: threadId=%d, Status=%d, Elapsed(ms)=%d, ETAG=%s, contentLength=%d, requestMethod=%s"
argument_list|,
name|threadId
argument_list|,
name|statusCode
argument_list|,
name|elapsed
argument_list|,
name|etag
argument_list|,
name|contentLength
argument_list|,
name|requestMethod
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|sendingRequest (SendingRequestEvent sendEvent)
specifier|public
name|void
name|sendingRequest
parameter_list|(
name|SendingRequestEvent
name|sendEvent
parameter_list|)
block|{
name|long
name|lastLatency
decl_stmt|;
name|boolean
name|operationIsRead
decl_stmt|;
comment|// for logging
synchronized|synchronized
init|(
name|this
init|)
block|{
name|lastLatency
operator|=
name|this
operator|.
name|lastE2Elatency
expr_stmt|;
block|}
name|float
name|sleepMultiple
decl_stmt|;
name|HttpURLConnection
name|urlConnection
init|=
operator|(
name|HttpURLConnection
operator|)
name|sendEvent
operator|.
name|getConnectionObject
argument_list|()
decl_stmt|;
comment|// Azure REST API never uses POST, so PUT is a sufficient test for an
comment|// upload.
if|if
condition|(
name|urlConnection
operator|.
name|getRequestMethod
argument_list|()
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"PUT"
argument_list|)
condition|)
block|{
name|operationIsRead
operator|=
literal|false
expr_stmt|;
name|sleepMultiple
operator|=
operator|(
literal|1
operator|/
name|writeFactor
operator|)
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|operationIsRead
operator|=
literal|true
expr_stmt|;
name|sleepMultiple
operator|=
operator|(
literal|1
operator|/
name|readFactor
operator|)
operator|-
literal|1
expr_stmt|;
block|}
name|long
name|sleepDuration
init|=
call|(
name|long
call|)
argument_list|(
name|sleepMultiple
operator|*
name|lastLatency
argument_list|)
decl_stmt|;
if|if
condition|(
name|sleepDuration
operator|<
literal|0
condition|)
block|{
name|sleepDuration
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|sleepDuration
operator|>
literal|0
condition|)
block|{
try|try
block|{
comment|// Thread.sleep() is not exact but it seems sufficiently accurate for
comment|// our needs. If needed this could become a loop of small waits that
comment|// tracks actual
comment|// elapsed time.
name|Thread
operator|.
name|sleep
argument_list|(
name|sleepDuration
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
comment|// reset to avoid counting the sleep against request latency
name|sendEvent
operator|.
name|getRequestResult
argument_list|()
operator|.
name|setStartDate
argument_list|(
operator|new
name|Date
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|boolean
name|isFirstRequest
init|=
operator|(
name|lastLatency
operator|==
literal|0
operator|)
decl_stmt|;
name|long
name|threadId
init|=
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getId
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|" SelfThrottlingIntercept:: SendingRequest:   threadId=%d, requestType=%s, isFirstRequest=%b, sleepDuration=%d"
argument_list|,
name|threadId
argument_list|,
name|operationIsRead
condition|?
literal|"read "
else|:
literal|"write"
argument_list|,
name|isFirstRequest
argument_list|,
name|sleepDuration
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// simply forwards back to the main class.
comment|// this is necessary as our main class cannot implement two base-classes.
annotation|@
name|InterfaceAudience
operator|.
name|Private
DECL|class|SendingRequestListener
class|class
name|SendingRequestListener
extends|extends
name|StorageEvent
argument_list|<
name|SendingRequestEvent
argument_list|>
block|{
annotation|@
name|Override
DECL|method|eventOccurred (SendingRequestEvent event)
specifier|public
name|void
name|eventOccurred
parameter_list|(
name|SendingRequestEvent
name|event
parameter_list|)
block|{
name|sendingRequest
argument_list|(
name|event
argument_list|)
expr_stmt|;
block|}
block|}
comment|// simply forwards back to the main class.
comment|// this is necessary as our main class cannot implement two base-classes.
annotation|@
name|InterfaceAudience
operator|.
name|Private
DECL|class|ResponseReceivedListener
class|class
name|ResponseReceivedListener
extends|extends
name|StorageEvent
argument_list|<
name|ResponseReceivedEvent
argument_list|>
block|{
annotation|@
name|Override
DECL|method|eventOccurred (ResponseReceivedEvent event)
specifier|public
name|void
name|eventOccurred
parameter_list|(
name|ResponseReceivedEvent
name|event
parameter_list|)
block|{
name|responseReceived
argument_list|(
name|event
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

