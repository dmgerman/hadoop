begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.fs.azurebfs
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|azurebfs
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileNotFoundException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|HttpURLConnection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URI
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URISyntaxException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|EnumSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Callable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutionException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutorService
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Executors
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Future
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang3
operator|.
name|ArrayUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|azurebfs
operator|.
name|services
operator|.
name|AbfsClient
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|azurebfs
operator|.
name|services
operator|.
name|AbfsClientThrottlingIntercept
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceStability
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|BlockLocation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|CommonPathCapabilities
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|CreateFlag
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FSDataInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FSDataOutputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileAlreadyExistsException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|PathIOException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|azurebfs
operator|.
name|constants
operator|.
name|FileSystemConfigurations
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|azurebfs
operator|.
name|constants
operator|.
name|FileSystemUriSchemes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|azurebfs
operator|.
name|contracts
operator|.
name|exceptions
operator|.
name|AbfsRestOperationException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|azurebfs
operator|.
name|contracts
operator|.
name|exceptions
operator|.
name|AzureBlobFileSystemException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|azurebfs
operator|.
name|contracts
operator|.
name|exceptions
operator|.
name|FileSystemOperationUnhandledException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|azurebfs
operator|.
name|contracts
operator|.
name|exceptions
operator|.
name|InvalidUriAuthorityException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|azurebfs
operator|.
name|contracts
operator|.
name|exceptions
operator|.
name|InvalidUriException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|azurebfs
operator|.
name|contracts
operator|.
name|services
operator|.
name|AzureServiceErrorCode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|azurebfs
operator|.
name|extensions
operator|.
name|AbfsAuthorizationException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|azurebfs
operator|.
name|extensions
operator|.
name|AbfsAuthorizer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|azurebfs
operator|.
name|security
operator|.
name|AbfsDelegationTokenManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|permission
operator|.
name|AclEntry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|permission
operator|.
name|AclStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|permission
operator|.
name|FsAction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|permission
operator|.
name|FsPermission
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|AccessControlException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|token
operator|.
name|Token
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|UserGroupInformation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Progressable
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|impl
operator|.
name|PathCapabilitiesSupport
operator|.
name|validatePathCapabilityArgs
import|;
end_import

begin_comment
comment|/**  * A {@link org.apache.hadoop.fs.FileSystem} for reading and writing files stored on<a  * href="http://store.azure.com/">Windows Azure</a>  */
end_comment

begin_class
annotation|@
name|InterfaceStability
operator|.
name|Evolving
DECL|class|AzureBlobFileSystem
specifier|public
class|class
name|AzureBlobFileSystem
extends|extends
name|FileSystem
block|{
DECL|field|LOG
specifier|public
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|AzureBlobFileSystem
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|uri
specifier|private
name|URI
name|uri
decl_stmt|;
DECL|field|workingDir
specifier|private
name|Path
name|workingDir
decl_stmt|;
DECL|field|abfsStore
specifier|private
name|AzureBlobFileSystemStore
name|abfsStore
decl_stmt|;
DECL|field|isClosed
specifier|private
name|boolean
name|isClosed
decl_stmt|;
DECL|field|delegationTokenEnabled
specifier|private
name|boolean
name|delegationTokenEnabled
init|=
literal|false
decl_stmt|;
DECL|field|delegationTokenManager
specifier|private
name|AbfsDelegationTokenManager
name|delegationTokenManager
decl_stmt|;
DECL|field|authorizer
specifier|private
name|AbfsAuthorizer
name|authorizer
decl_stmt|;
annotation|@
name|Override
DECL|method|initialize (URI uri, Configuration configuration)
specifier|public
name|void
name|initialize
parameter_list|(
name|URI
name|uri
parameter_list|,
name|Configuration
name|configuration
parameter_list|)
throws|throws
name|IOException
block|{
name|uri
operator|=
name|ensureAuthority
argument_list|(
name|uri
argument_list|,
name|configuration
argument_list|)
expr_stmt|;
name|super
operator|.
name|initialize
argument_list|(
name|uri
argument_list|,
name|configuration
argument_list|)
expr_stmt|;
name|setConf
argument_list|(
name|configuration
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Initializing AzureBlobFileSystem for {}"
argument_list|,
name|uri
argument_list|)
expr_stmt|;
name|this
operator|.
name|uri
operator|=
name|URI
operator|.
name|create
argument_list|(
name|uri
operator|.
name|getScheme
argument_list|()
operator|+
literal|"://"
operator|+
name|uri
operator|.
name|getAuthority
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|abfsStore
operator|=
operator|new
name|AzureBlobFileSystemStore
argument_list|(
name|uri
argument_list|,
name|this
operator|.
name|isSecureScheme
argument_list|()
argument_list|,
name|configuration
argument_list|)
expr_stmt|;
specifier|final
name|AbfsConfiguration
name|abfsConfiguration
init|=
name|abfsStore
operator|.
name|getAbfsConfiguration
argument_list|()
decl_stmt|;
name|this
operator|.
name|setWorkingDirectory
argument_list|(
name|this
operator|.
name|getHomeDirectory
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|abfsConfiguration
operator|.
name|getCreateRemoteFileSystemDuringInitialization
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|this
operator|.
name|fileSystemExists
argument_list|()
condition|)
block|{
try|try
block|{
name|this
operator|.
name|createFileSystem
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|AzureBlobFileSystemException
name|ex
parameter_list|)
block|{
name|checkException
argument_list|(
literal|null
argument_list|,
name|ex
argument_list|,
name|AzureServiceErrorCode
operator|.
name|FILE_SYSTEM_ALREADY_EXISTS
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|UserGroupInformation
operator|.
name|isSecurityEnabled
argument_list|()
condition|)
block|{
name|this
operator|.
name|delegationTokenEnabled
operator|=
name|abfsConfiguration
operator|.
name|isDelegationTokenManagerEnabled
argument_list|()
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|delegationTokenEnabled
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Initializing DelegationTokenManager for {}"
argument_list|,
name|uri
argument_list|)
expr_stmt|;
name|this
operator|.
name|delegationTokenManager
operator|=
name|abfsConfiguration
operator|.
name|getDelegationTokenManager
argument_list|()
expr_stmt|;
name|delegationTokenManager
operator|.
name|bind
argument_list|(
name|getUri
argument_list|()
argument_list|,
name|configuration
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Created DelegationTokenManager {}"
argument_list|,
name|delegationTokenManager
argument_list|)
expr_stmt|;
block|}
block|}
name|AbfsClientThrottlingIntercept
operator|.
name|initializeSingleton
argument_list|(
name|abfsConfiguration
operator|.
name|isAutoThrottlingEnabled
argument_list|()
argument_list|)
expr_stmt|;
comment|// Initialize ABFS authorizer
comment|//
name|this
operator|.
name|authorizer
operator|=
name|abfsConfiguration
operator|.
name|getAbfsAuthorizer
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
specifier|final
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|(
literal|"AzureBlobFileSystem{"
argument_list|)
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"uri="
argument_list|)
operator|.
name|append
argument_list|(
name|uri
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|", user='"
argument_list|)
operator|.
name|append
argument_list|(
name|abfsStore
operator|.
name|getUser
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|'\''
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|", primaryUserGroup='"
argument_list|)
operator|.
name|append
argument_list|(
name|abfsStore
operator|.
name|getPrimaryGroup
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|'\''
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|'}'
argument_list|)
expr_stmt|;
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
DECL|method|isSecureScheme ()
specifier|public
name|boolean
name|isSecureScheme
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
annotation|@
name|Override
DECL|method|getUri ()
specifier|public
name|URI
name|getUri
parameter_list|()
block|{
return|return
name|this
operator|.
name|uri
return|;
block|}
annotation|@
name|Override
DECL|method|open (final Path path, final int bufferSize)
specifier|public
name|FSDataInputStream
name|open
parameter_list|(
specifier|final
name|Path
name|path
parameter_list|,
specifier|final
name|int
name|bufferSize
parameter_list|)
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"AzureBlobFileSystem.open path: {} bufferSize: {}"
argument_list|,
name|path
argument_list|,
name|bufferSize
argument_list|)
expr_stmt|;
name|Path
name|qualifiedPath
init|=
name|makeQualified
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|performAbfsAuthCheck
argument_list|(
name|FsAction
operator|.
name|READ
argument_list|,
name|qualifiedPath
argument_list|)
expr_stmt|;
try|try
block|{
name|InputStream
name|inputStream
init|=
name|abfsStore
operator|.
name|openFileForRead
argument_list|(
name|qualifiedPath
argument_list|,
name|statistics
argument_list|)
decl_stmt|;
return|return
operator|new
name|FSDataInputStream
argument_list|(
name|inputStream
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|AzureBlobFileSystemException
name|ex
parameter_list|)
block|{
name|checkException
argument_list|(
name|path
argument_list|,
name|ex
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|create (final Path f, final FsPermission permission, final boolean overwrite, final int bufferSize, final short replication, final long blockSize, final Progressable progress)
specifier|public
name|FSDataOutputStream
name|create
parameter_list|(
specifier|final
name|Path
name|f
parameter_list|,
specifier|final
name|FsPermission
name|permission
parameter_list|,
specifier|final
name|boolean
name|overwrite
parameter_list|,
specifier|final
name|int
name|bufferSize
parameter_list|,
specifier|final
name|short
name|replication
parameter_list|,
specifier|final
name|long
name|blockSize
parameter_list|,
specifier|final
name|Progressable
name|progress
parameter_list|)
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"AzureBlobFileSystem.create path: {} permission: {} overwrite: {} bufferSize: {}"
argument_list|,
name|f
argument_list|,
name|permission
argument_list|,
name|overwrite
argument_list|,
name|blockSize
argument_list|)
expr_stmt|;
name|trailingPeriodCheck
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|Path
name|qualifiedPath
init|=
name|makeQualified
argument_list|(
name|f
argument_list|)
decl_stmt|;
name|performAbfsAuthCheck
argument_list|(
name|FsAction
operator|.
name|WRITE
argument_list|,
name|qualifiedPath
argument_list|)
expr_stmt|;
try|try
block|{
name|OutputStream
name|outputStream
init|=
name|abfsStore
operator|.
name|createFile
argument_list|(
name|qualifiedPath
argument_list|,
name|overwrite
argument_list|,
name|permission
operator|==
literal|null
condition|?
name|FsPermission
operator|.
name|getFileDefault
argument_list|()
else|:
name|permission
argument_list|,
name|FsPermission
operator|.
name|getUMask
argument_list|(
name|getConf
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
return|return
operator|new
name|FSDataOutputStream
argument_list|(
name|outputStream
argument_list|,
name|statistics
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|AzureBlobFileSystemException
name|ex
parameter_list|)
block|{
name|checkException
argument_list|(
name|f
argument_list|,
name|ex
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
annotation|@
name|Override
annotation|@
name|SuppressWarnings
argument_list|(
literal|"deprecation"
argument_list|)
DECL|method|createNonRecursive (final Path f, final FsPermission permission, final boolean overwrite, final int bufferSize, final short replication, final long blockSize, final Progressable progress)
specifier|public
name|FSDataOutputStream
name|createNonRecursive
parameter_list|(
specifier|final
name|Path
name|f
parameter_list|,
specifier|final
name|FsPermission
name|permission
parameter_list|,
specifier|final
name|boolean
name|overwrite
parameter_list|,
specifier|final
name|int
name|bufferSize
parameter_list|,
specifier|final
name|short
name|replication
parameter_list|,
specifier|final
name|long
name|blockSize
parameter_list|,
specifier|final
name|Progressable
name|progress
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|Path
name|parent
init|=
name|f
operator|.
name|getParent
argument_list|()
decl_stmt|;
specifier|final
name|FileStatus
name|parentFileStatus
init|=
name|tryGetFileStatus
argument_list|(
name|parent
argument_list|)
decl_stmt|;
if|if
condition|(
name|parentFileStatus
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|FileNotFoundException
argument_list|(
literal|"Cannot create file "
operator|+
name|f
operator|.
name|getName
argument_list|()
operator|+
literal|" because parent folder does not exist."
argument_list|)
throw|;
block|}
return|return
name|create
argument_list|(
name|f
argument_list|,
name|permission
argument_list|,
name|overwrite
argument_list|,
name|bufferSize
argument_list|,
name|replication
argument_list|,
name|blockSize
argument_list|,
name|progress
argument_list|)
return|;
block|}
annotation|@
name|Override
annotation|@
name|SuppressWarnings
argument_list|(
literal|"deprecation"
argument_list|)
DECL|method|createNonRecursive (final Path f, final FsPermission permission, final EnumSet<CreateFlag> flags, final int bufferSize, final short replication, final long blockSize, final Progressable progress)
specifier|public
name|FSDataOutputStream
name|createNonRecursive
parameter_list|(
specifier|final
name|Path
name|f
parameter_list|,
specifier|final
name|FsPermission
name|permission
parameter_list|,
specifier|final
name|EnumSet
argument_list|<
name|CreateFlag
argument_list|>
name|flags
parameter_list|,
specifier|final
name|int
name|bufferSize
parameter_list|,
specifier|final
name|short
name|replication
parameter_list|,
specifier|final
name|long
name|blockSize
parameter_list|,
specifier|final
name|Progressable
name|progress
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Check if file should be appended or overwritten. Assume that the file
comment|// is overwritten on if the CREATE and OVERWRITE create flags are set.
specifier|final
name|EnumSet
argument_list|<
name|CreateFlag
argument_list|>
name|createflags
init|=
name|EnumSet
operator|.
name|of
argument_list|(
name|CreateFlag
operator|.
name|CREATE
argument_list|,
name|CreateFlag
operator|.
name|OVERWRITE
argument_list|)
decl_stmt|;
specifier|final
name|boolean
name|overwrite
init|=
name|flags
operator|.
name|containsAll
argument_list|(
name|createflags
argument_list|)
decl_stmt|;
comment|// Delegate the create non-recursive call.
return|return
name|this
operator|.
name|createNonRecursive
argument_list|(
name|f
argument_list|,
name|permission
argument_list|,
name|overwrite
argument_list|,
name|bufferSize
argument_list|,
name|replication
argument_list|,
name|blockSize
argument_list|,
name|progress
argument_list|)
return|;
block|}
annotation|@
name|Override
annotation|@
name|SuppressWarnings
argument_list|(
literal|"deprecation"
argument_list|)
DECL|method|createNonRecursive (final Path f, final boolean overwrite, final int bufferSize, final short replication, final long blockSize, final Progressable progress)
specifier|public
name|FSDataOutputStream
name|createNonRecursive
parameter_list|(
specifier|final
name|Path
name|f
parameter_list|,
specifier|final
name|boolean
name|overwrite
parameter_list|,
specifier|final
name|int
name|bufferSize
parameter_list|,
specifier|final
name|short
name|replication
parameter_list|,
specifier|final
name|long
name|blockSize
parameter_list|,
specifier|final
name|Progressable
name|progress
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|this
operator|.
name|createNonRecursive
argument_list|(
name|f
argument_list|,
name|FsPermission
operator|.
name|getFileDefault
argument_list|()
argument_list|,
name|overwrite
argument_list|,
name|bufferSize
argument_list|,
name|replication
argument_list|,
name|blockSize
argument_list|,
name|progress
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|append (final Path f, final int bufferSize, final Progressable progress)
specifier|public
name|FSDataOutputStream
name|append
parameter_list|(
specifier|final
name|Path
name|f
parameter_list|,
specifier|final
name|int
name|bufferSize
parameter_list|,
specifier|final
name|Progressable
name|progress
parameter_list|)
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"AzureBlobFileSystem.append path: {} bufferSize: {}"
argument_list|,
name|f
operator|.
name|toString
argument_list|()
argument_list|,
name|bufferSize
argument_list|)
expr_stmt|;
name|Path
name|qualifiedPath
init|=
name|makeQualified
argument_list|(
name|f
argument_list|)
decl_stmt|;
name|performAbfsAuthCheck
argument_list|(
name|FsAction
operator|.
name|WRITE
argument_list|,
name|qualifiedPath
argument_list|)
expr_stmt|;
try|try
block|{
name|OutputStream
name|outputStream
init|=
name|abfsStore
operator|.
name|openFileForWrite
argument_list|(
name|qualifiedPath
argument_list|,
literal|false
argument_list|)
decl_stmt|;
return|return
operator|new
name|FSDataOutputStream
argument_list|(
name|outputStream
argument_list|,
name|statistics
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|AzureBlobFileSystemException
name|ex
parameter_list|)
block|{
name|checkException
argument_list|(
name|f
argument_list|,
name|ex
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
DECL|method|rename (final Path src, final Path dst)
specifier|public
name|boolean
name|rename
parameter_list|(
specifier|final
name|Path
name|src
parameter_list|,
specifier|final
name|Path
name|dst
parameter_list|)
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"AzureBlobFileSystem.rename src: {} dst: {}"
argument_list|,
name|src
operator|.
name|toString
argument_list|()
argument_list|,
name|dst
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|trailingPeriodCheck
argument_list|(
name|dst
argument_list|)
expr_stmt|;
name|Path
name|parentFolder
init|=
name|src
operator|.
name|getParent
argument_list|()
decl_stmt|;
if|if
condition|(
name|parentFolder
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
name|Path
name|qualifiedSrcPath
init|=
name|makeQualified
argument_list|(
name|src
argument_list|)
decl_stmt|;
name|Path
name|qualifiedDstPath
init|=
name|makeQualified
argument_list|(
name|dst
argument_list|)
decl_stmt|;
comment|// rename under same folder;
if|if
condition|(
name|makeQualified
argument_list|(
name|parentFolder
argument_list|)
operator|.
name|equals
argument_list|(
name|qualifiedDstPath
argument_list|)
condition|)
block|{
return|return
name|tryGetFileStatus
argument_list|(
name|qualifiedSrcPath
argument_list|)
operator|!=
literal|null
return|;
block|}
name|FileStatus
name|dstFileStatus
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|qualifiedSrcPath
operator|.
name|equals
argument_list|(
name|qualifiedDstPath
argument_list|)
condition|)
block|{
comment|// rename to itself
comment|// - if it doesn't exist, return false
comment|// - if it is file, return true
comment|// - if it is dir, return false.
name|dstFileStatus
operator|=
name|tryGetFileStatus
argument_list|(
name|qualifiedDstPath
argument_list|)
expr_stmt|;
if|if
condition|(
name|dstFileStatus
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
name|dstFileStatus
operator|.
name|isDirectory
argument_list|()
condition|?
literal|false
else|:
literal|true
return|;
block|}
comment|// Non-HNS account need to check dst status on driver side.
if|if
condition|(
operator|!
name|abfsStore
operator|.
name|getIsNamespaceEnabled
argument_list|()
operator|&&
name|dstFileStatus
operator|==
literal|null
condition|)
block|{
name|dstFileStatus
operator|=
name|tryGetFileStatus
argument_list|(
name|qualifiedDstPath
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|String
name|sourceFileName
init|=
name|src
operator|.
name|getName
argument_list|()
decl_stmt|;
name|Path
name|adjustedDst
init|=
name|dst
decl_stmt|;
if|if
condition|(
name|dstFileStatus
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
operator|!
name|dstFileStatus
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
return|return
name|qualifiedSrcPath
operator|.
name|equals
argument_list|(
name|qualifiedDstPath
argument_list|)
return|;
block|}
name|adjustedDst
operator|=
operator|new
name|Path
argument_list|(
name|dst
argument_list|,
name|sourceFileName
argument_list|)
expr_stmt|;
block|}
name|qualifiedDstPath
operator|=
name|makeQualified
argument_list|(
name|adjustedDst
argument_list|)
expr_stmt|;
name|performAbfsAuthCheck
argument_list|(
name|FsAction
operator|.
name|READ_WRITE
argument_list|,
name|qualifiedSrcPath
argument_list|,
name|qualifiedDstPath
argument_list|)
expr_stmt|;
name|abfsStore
operator|.
name|rename
argument_list|(
name|qualifiedSrcPath
argument_list|,
name|qualifiedDstPath
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
catch|catch
parameter_list|(
name|AzureBlobFileSystemException
name|ex
parameter_list|)
block|{
name|checkException
argument_list|(
name|src
argument_list|,
name|ex
argument_list|,
name|AzureServiceErrorCode
operator|.
name|PATH_ALREADY_EXISTS
argument_list|,
name|AzureServiceErrorCode
operator|.
name|INVALID_RENAME_SOURCE_PATH
argument_list|,
name|AzureServiceErrorCode
operator|.
name|SOURCE_PATH_NOT_FOUND
argument_list|,
name|AzureServiceErrorCode
operator|.
name|INVALID_SOURCE_OR_DESTINATION_RESOURCE_TYPE
argument_list|,
name|AzureServiceErrorCode
operator|.
name|RENAME_DESTINATION_PARENT_PATH_NOT_FOUND
argument_list|,
name|AzureServiceErrorCode
operator|.
name|INTERNAL_OPERATION_ABORT
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|delete (final Path f, final boolean recursive)
specifier|public
name|boolean
name|delete
parameter_list|(
specifier|final
name|Path
name|f
parameter_list|,
specifier|final
name|boolean
name|recursive
parameter_list|)
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"AzureBlobFileSystem.delete path: {} recursive: {}"
argument_list|,
name|f
operator|.
name|toString
argument_list|()
argument_list|,
name|recursive
argument_list|)
expr_stmt|;
name|Path
name|qualifiedPath
init|=
name|makeQualified
argument_list|(
name|f
argument_list|)
decl_stmt|;
name|performAbfsAuthCheck
argument_list|(
name|FsAction
operator|.
name|WRITE
argument_list|,
name|qualifiedPath
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|.
name|isRoot
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|recursive
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
name|deleteRoot
argument_list|()
return|;
block|}
try|try
block|{
name|abfsStore
operator|.
name|delete
argument_list|(
name|qualifiedPath
argument_list|,
name|recursive
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
catch|catch
parameter_list|(
name|AzureBlobFileSystemException
name|ex
parameter_list|)
block|{
name|checkException
argument_list|(
name|f
argument_list|,
name|ex
argument_list|,
name|AzureServiceErrorCode
operator|.
name|PATH_NOT_FOUND
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|listStatus (final Path f)
specifier|public
name|FileStatus
index|[]
name|listStatus
parameter_list|(
specifier|final
name|Path
name|f
parameter_list|)
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"AzureBlobFileSystem.listStatus path: {}"
argument_list|,
name|f
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|Path
name|qualifiedPath
init|=
name|makeQualified
argument_list|(
name|f
argument_list|)
decl_stmt|;
name|performAbfsAuthCheck
argument_list|(
name|FsAction
operator|.
name|READ
argument_list|,
name|qualifiedPath
argument_list|)
expr_stmt|;
try|try
block|{
name|FileStatus
index|[]
name|result
init|=
name|abfsStore
operator|.
name|listStatus
argument_list|(
name|qualifiedPath
argument_list|)
decl_stmt|;
return|return
name|result
return|;
block|}
catch|catch
parameter_list|(
name|AzureBlobFileSystemException
name|ex
parameter_list|)
block|{
name|checkException
argument_list|(
name|f
argument_list|,
name|ex
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
comment|/**    * Performs a check for (.) until root in the path to throw an exception.    * The purpose is to differentiate between dir/dir1 and dir/dir1.    * Without the exception the behavior seen is dir1. will appear    * to be present without it's actual creation as dir/dir1 and dir/dir1. are    * treated as identical.    * @param path the path to be checked for trailing period (.)    * @throws IllegalArgumentException if the path has a trailing period (.)    */
DECL|method|trailingPeriodCheck (Path path)
specifier|private
name|void
name|trailingPeriodCheck
parameter_list|(
name|Path
name|path
parameter_list|)
throws|throws
name|IllegalArgumentException
block|{
while|while
condition|(
operator|!
name|path
operator|.
name|isRoot
argument_list|()
condition|)
block|{
name|String
name|pathToString
init|=
name|path
operator|.
name|toString
argument_list|()
decl_stmt|;
if|if
condition|(
name|pathToString
operator|.
name|length
argument_list|()
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|pathToString
operator|.
name|charAt
argument_list|(
name|pathToString
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
operator|==
literal|'.'
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"ABFS does not allow files or directories to end with a dot."
argument_list|)
throw|;
block|}
name|path
operator|=
name|path
operator|.
name|getParent
argument_list|()
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
block|}
block|}
annotation|@
name|Override
DECL|method|mkdirs (final Path f, final FsPermission permission)
specifier|public
name|boolean
name|mkdirs
parameter_list|(
specifier|final
name|Path
name|f
parameter_list|,
specifier|final
name|FsPermission
name|permission
parameter_list|)
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"AzureBlobFileSystem.mkdirs path: {} permissions: {}"
argument_list|,
name|f
argument_list|,
name|permission
argument_list|)
expr_stmt|;
name|trailingPeriodCheck
argument_list|(
name|f
argument_list|)
expr_stmt|;
specifier|final
name|Path
name|parentFolder
init|=
name|f
operator|.
name|getParent
argument_list|()
decl_stmt|;
if|if
condition|(
name|parentFolder
operator|==
literal|null
condition|)
block|{
comment|// Cannot create root
return|return
literal|true
return|;
block|}
name|Path
name|qualifiedPath
init|=
name|makeQualified
argument_list|(
name|f
argument_list|)
decl_stmt|;
name|performAbfsAuthCheck
argument_list|(
name|FsAction
operator|.
name|WRITE
argument_list|,
name|qualifiedPath
argument_list|)
expr_stmt|;
try|try
block|{
name|abfsStore
operator|.
name|createDirectory
argument_list|(
name|qualifiedPath
argument_list|,
name|permission
operator|==
literal|null
condition|?
name|FsPermission
operator|.
name|getDirDefault
argument_list|()
else|:
name|permission
argument_list|,
name|FsPermission
operator|.
name|getUMask
argument_list|(
name|getConf
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
catch|catch
parameter_list|(
name|AzureBlobFileSystemException
name|ex
parameter_list|)
block|{
name|checkException
argument_list|(
name|f
argument_list|,
name|ex
argument_list|,
name|AzureServiceErrorCode
operator|.
name|PATH_ALREADY_EXISTS
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|close ()
specifier|public
specifier|synchronized
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|isClosed
condition|)
block|{
return|return;
block|}
comment|// does all the delete-on-exit calls, and may be slow.
name|super
operator|.
name|close
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"AzureBlobFileSystem.close"
argument_list|)
expr_stmt|;
name|IOUtils
operator|.
name|cleanupWithLogger
argument_list|(
name|LOG
argument_list|,
name|abfsStore
argument_list|,
name|delegationTokenManager
argument_list|)
expr_stmt|;
name|this
operator|.
name|isClosed
operator|=
literal|true
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getFileStatus (final Path f)
specifier|public
name|FileStatus
name|getFileStatus
parameter_list|(
specifier|final
name|Path
name|f
parameter_list|)
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"AzureBlobFileSystem.getFileStatus path: {}"
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|Path
name|qualifiedPath
init|=
name|makeQualified
argument_list|(
name|f
argument_list|)
decl_stmt|;
name|performAbfsAuthCheck
argument_list|(
name|FsAction
operator|.
name|READ
argument_list|,
name|qualifiedPath
argument_list|)
expr_stmt|;
try|try
block|{
return|return
name|abfsStore
operator|.
name|getFileStatus
argument_list|(
name|qualifiedPath
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|AzureBlobFileSystemException
name|ex
parameter_list|)
block|{
name|checkException
argument_list|(
name|f
argument_list|,
name|ex
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
comment|/**    * Qualify a path to one which uses this FileSystem and, if relative,    * made absolute.    * @param path to qualify.    * @return this path if it contains a scheme and authority and is absolute, or    * a new path that includes a path and authority and is fully qualified    * @see Path#makeQualified(URI, Path)    * @throws IllegalArgumentException if the path has a schema/URI different    * from this FileSystem.    */
annotation|@
name|Override
DECL|method|makeQualified (Path path)
specifier|public
name|Path
name|makeQualified
parameter_list|(
name|Path
name|path
parameter_list|)
block|{
comment|// To support format: abfs://{dfs.nameservices}/file/path,
comment|// path need to be first converted to URI, then get the raw path string,
comment|// during which {dfs.nameservices} will be omitted.
if|if
condition|(
name|path
operator|!=
literal|null
condition|)
block|{
name|String
name|uriPath
init|=
name|path
operator|.
name|toUri
argument_list|()
operator|.
name|getPath
argument_list|()
decl_stmt|;
name|path
operator|=
name|uriPath
operator|.
name|isEmpty
argument_list|()
condition|?
name|path
else|:
operator|new
name|Path
argument_list|(
name|uriPath
argument_list|)
expr_stmt|;
block|}
return|return
name|super
operator|.
name|makeQualified
argument_list|(
name|path
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|getWorkingDirectory ()
specifier|public
name|Path
name|getWorkingDirectory
parameter_list|()
block|{
return|return
name|this
operator|.
name|workingDir
return|;
block|}
annotation|@
name|Override
DECL|method|setWorkingDirectory (final Path newDir)
specifier|public
name|void
name|setWorkingDirectory
parameter_list|(
specifier|final
name|Path
name|newDir
parameter_list|)
block|{
if|if
condition|(
name|newDir
operator|.
name|isAbsolute
argument_list|()
condition|)
block|{
name|this
operator|.
name|workingDir
operator|=
name|newDir
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|workingDir
operator|=
operator|new
name|Path
argument_list|(
name|workingDir
argument_list|,
name|newDir
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|getScheme ()
specifier|public
name|String
name|getScheme
parameter_list|()
block|{
return|return
name|FileSystemUriSchemes
operator|.
name|ABFS_SCHEME
return|;
block|}
annotation|@
name|Override
DECL|method|getHomeDirectory ()
specifier|public
name|Path
name|getHomeDirectory
parameter_list|()
block|{
return|return
name|makeQualified
argument_list|(
operator|new
name|Path
argument_list|(
name|FileSystemConfigurations
operator|.
name|USER_HOME_DIRECTORY_PREFIX
operator|+
literal|"/"
operator|+
name|abfsStore
operator|.
name|getUser
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Return an array containing hostnames, offset and size of    * portions of the given file. For ABFS we'll just lie and give    * fake hosts to make sure we get many splits in MR jobs.    */
annotation|@
name|Override
DECL|method|getFileBlockLocations (FileStatus file, long start, long len)
specifier|public
name|BlockLocation
index|[]
name|getFileBlockLocations
parameter_list|(
name|FileStatus
name|file
parameter_list|,
name|long
name|start
parameter_list|,
name|long
name|len
parameter_list|)
block|{
if|if
condition|(
name|file
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
operator|(
name|start
operator|<
literal|0
operator|)
operator|||
operator|(
name|len
operator|<
literal|0
operator|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Invalid start or len parameter"
argument_list|)
throw|;
block|}
if|if
condition|(
name|file
operator|.
name|getLen
argument_list|()
operator|<
name|start
condition|)
block|{
return|return
operator|new
name|BlockLocation
index|[
literal|0
index|]
return|;
block|}
specifier|final
name|String
name|blobLocationHost
init|=
name|abfsStore
operator|.
name|getAbfsConfiguration
argument_list|()
operator|.
name|getAzureBlockLocationHost
argument_list|()
decl_stmt|;
specifier|final
name|String
index|[]
name|name
init|=
block|{
name|blobLocationHost
block|}
decl_stmt|;
specifier|final
name|String
index|[]
name|host
init|=
block|{
name|blobLocationHost
block|}
decl_stmt|;
name|long
name|blockSize
init|=
name|file
operator|.
name|getBlockSize
argument_list|()
decl_stmt|;
if|if
condition|(
name|blockSize
operator|<=
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The block size for the given file is not a positive number: "
operator|+
name|blockSize
argument_list|)
throw|;
block|}
name|int
name|numberOfLocations
init|=
call|(
name|int
call|)
argument_list|(
name|len
operator|/
name|blockSize
argument_list|)
operator|+
operator|(
operator|(
name|len
operator|%
name|blockSize
operator|==
literal|0
operator|)
condition|?
literal|0
else|:
literal|1
operator|)
decl_stmt|;
name|BlockLocation
index|[]
name|locations
init|=
operator|new
name|BlockLocation
index|[
name|numberOfLocations
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|locations
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|long
name|currentOffset
init|=
name|start
operator|+
operator|(
name|i
operator|*
name|blockSize
operator|)
decl_stmt|;
name|long
name|currentLength
init|=
name|Math
operator|.
name|min
argument_list|(
name|blockSize
argument_list|,
name|start
operator|+
name|len
operator|-
name|currentOffset
argument_list|)
decl_stmt|;
name|locations
index|[
name|i
index|]
operator|=
operator|new
name|BlockLocation
argument_list|(
name|name
argument_list|,
name|host
argument_list|,
name|currentOffset
argument_list|,
name|currentLength
argument_list|)
expr_stmt|;
block|}
return|return
name|locations
return|;
block|}
annotation|@
name|Override
DECL|method|finalize ()
specifier|protected
name|void
name|finalize
parameter_list|()
throws|throws
name|Throwable
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"finalize() called."
argument_list|)
expr_stmt|;
name|close
argument_list|()
expr_stmt|;
name|super
operator|.
name|finalize
argument_list|()
expr_stmt|;
block|}
comment|/**    * Get the username of the FS.    * @return the short name of the user who instantiated the FS    */
DECL|method|getOwnerUser ()
specifier|public
name|String
name|getOwnerUser
parameter_list|()
block|{
return|return
name|abfsStore
operator|.
name|getUser
argument_list|()
return|;
block|}
comment|/**    * Get the group name of the owner of the FS.    * @return primary group name    */
DECL|method|getOwnerUserPrimaryGroup ()
specifier|public
name|String
name|getOwnerUserPrimaryGroup
parameter_list|()
block|{
return|return
name|abfsStore
operator|.
name|getPrimaryGroup
argument_list|()
return|;
block|}
DECL|method|deleteRoot ()
specifier|private
name|boolean
name|deleteRoot
parameter_list|()
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Deleting root content"
argument_list|)
expr_stmt|;
specifier|final
name|ExecutorService
name|executorService
init|=
name|Executors
operator|.
name|newFixedThreadPool
argument_list|(
literal|10
argument_list|)
decl_stmt|;
try|try
block|{
specifier|final
name|FileStatus
index|[]
name|ls
init|=
name|listStatus
argument_list|(
name|makeQualified
argument_list|(
operator|new
name|Path
argument_list|(
name|File
operator|.
name|separator
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|ArrayList
argument_list|<
name|Future
argument_list|>
name|deleteTasks
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
specifier|final
name|FileStatus
name|fs
range|:
name|ls
control|)
block|{
specifier|final
name|Future
name|deleteTask
init|=
name|executorService
operator|.
name|submit
argument_list|(
operator|new
name|Callable
argument_list|<
name|Void
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Void
name|call
parameter_list|()
throws|throws
name|Exception
block|{
name|delete
argument_list|(
name|fs
operator|.
name|getPath
argument_list|()
argument_list|,
name|fs
operator|.
name|isDirectory
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
argument_list|)
decl_stmt|;
name|deleteTasks
operator|.
name|add
argument_list|(
name|deleteTask
argument_list|)
expr_stmt|;
block|}
for|for
control|(
specifier|final
name|Future
name|deleteTask
range|:
name|deleteTasks
control|)
block|{
name|execute
argument_list|(
literal|"deleteRoot"
argument_list|,
operator|new
name|Callable
argument_list|<
name|Void
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Void
name|call
parameter_list|()
throws|throws
name|Exception
block|{
name|deleteTask
operator|.
name|get
argument_list|()
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|executorService
operator|.
name|shutdownNow
argument_list|()
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Set owner of a path (i.e. a file or a directory).    * The parameters owner and group cannot both be null.    *    * @param path  The path    * @param owner If it is null, the original username remains unchanged.    * @param group If it is null, the original groupname remains unchanged.    */
annotation|@
name|Override
DECL|method|setOwner (final Path path, final String owner, final String group)
specifier|public
name|void
name|setOwner
parameter_list|(
specifier|final
name|Path
name|path
parameter_list|,
specifier|final
name|String
name|owner
parameter_list|,
specifier|final
name|String
name|group
parameter_list|)
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"AzureBlobFileSystem.setOwner path: {}"
argument_list|,
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|getIsNamespaceEnabled
argument_list|()
condition|)
block|{
name|super
operator|.
name|setOwner
argument_list|(
name|path
argument_list|,
name|owner
argument_list|,
name|group
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|owner
operator|==
literal|null
operator|||
name|owner
operator|.
name|isEmpty
argument_list|()
operator|)
operator|&&
operator|(
name|group
operator|==
literal|null
operator|||
name|group
operator|.
name|isEmpty
argument_list|()
operator|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"A valid owner or group must be specified."
argument_list|)
throw|;
block|}
name|Path
name|qualifiedPath
init|=
name|makeQualified
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|performAbfsAuthCheck
argument_list|(
name|FsAction
operator|.
name|WRITE
argument_list|,
name|qualifiedPath
argument_list|)
expr_stmt|;
try|try
block|{
name|abfsStore
operator|.
name|setOwner
argument_list|(
name|qualifiedPath
argument_list|,
name|owner
argument_list|,
name|group
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|AzureBlobFileSystemException
name|ex
parameter_list|)
block|{
name|checkException
argument_list|(
name|path
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Set permission of a path.    *    * @param path       The path    * @param permission Access permission    */
annotation|@
name|Override
DECL|method|setPermission (final Path path, final FsPermission permission)
specifier|public
name|void
name|setPermission
parameter_list|(
specifier|final
name|Path
name|path
parameter_list|,
specifier|final
name|FsPermission
name|permission
parameter_list|)
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"AzureBlobFileSystem.setPermission path: {}"
argument_list|,
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|getIsNamespaceEnabled
argument_list|()
condition|)
block|{
name|super
operator|.
name|setPermission
argument_list|(
name|path
argument_list|,
name|permission
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|permission
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The permission can't be null"
argument_list|)
throw|;
block|}
name|Path
name|qualifiedPath
init|=
name|makeQualified
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|performAbfsAuthCheck
argument_list|(
name|FsAction
operator|.
name|WRITE
argument_list|,
name|qualifiedPath
argument_list|)
expr_stmt|;
try|try
block|{
name|abfsStore
operator|.
name|setPermission
argument_list|(
name|qualifiedPath
argument_list|,
name|permission
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|AzureBlobFileSystemException
name|ex
parameter_list|)
block|{
name|checkException
argument_list|(
name|path
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Modifies ACL entries of files and directories.  This method can add new ACL    * entries or modify the permissions on existing ACL entries.  All existing    * ACL entries that are not specified in this call are retained without    * changes.  (Modifications are merged into the current ACL.)    *    * @param path    Path to modify    * @param aclSpec List of AbfsAclEntry describing modifications    * @throws IOException if an ACL could not be modified    */
annotation|@
name|Override
DECL|method|modifyAclEntries (final Path path, final List<AclEntry> aclSpec)
specifier|public
name|void
name|modifyAclEntries
parameter_list|(
specifier|final
name|Path
name|path
parameter_list|,
specifier|final
name|List
argument_list|<
name|AclEntry
argument_list|>
name|aclSpec
parameter_list|)
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"AzureBlobFileSystem.modifyAclEntries path: {}"
argument_list|,
name|path
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|getIsNamespaceEnabled
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"modifyAclEntries is only supported by storage accounts with the "
operator|+
literal|"hierarchical namespace enabled."
argument_list|)
throw|;
block|}
if|if
condition|(
name|aclSpec
operator|==
literal|null
operator|||
name|aclSpec
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The value of the aclSpec parameter is invalid."
argument_list|)
throw|;
block|}
name|Path
name|qualifiedPath
init|=
name|makeQualified
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|performAbfsAuthCheck
argument_list|(
name|FsAction
operator|.
name|WRITE
argument_list|,
name|qualifiedPath
argument_list|)
expr_stmt|;
try|try
block|{
name|abfsStore
operator|.
name|modifyAclEntries
argument_list|(
name|qualifiedPath
argument_list|,
name|aclSpec
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|AzureBlobFileSystemException
name|ex
parameter_list|)
block|{
name|checkException
argument_list|(
name|path
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Removes ACL entries from files and directories.  Other ACL entries are    * retained.    *    * @param path    Path to modify    * @param aclSpec List of AclEntry describing entries to remove    * @throws IOException if an ACL could not be modified    */
annotation|@
name|Override
DECL|method|removeAclEntries (final Path path, final List<AclEntry> aclSpec)
specifier|public
name|void
name|removeAclEntries
parameter_list|(
specifier|final
name|Path
name|path
parameter_list|,
specifier|final
name|List
argument_list|<
name|AclEntry
argument_list|>
name|aclSpec
parameter_list|)
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"AzureBlobFileSystem.removeAclEntries path: {}"
argument_list|,
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|getIsNamespaceEnabled
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"removeAclEntries is only supported by storage accounts with the "
operator|+
literal|"hierarchical namespace enabled."
argument_list|)
throw|;
block|}
if|if
condition|(
name|aclSpec
operator|==
literal|null
operator|||
name|aclSpec
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The aclSpec argument is invalid."
argument_list|)
throw|;
block|}
name|Path
name|qualifiedPath
init|=
name|makeQualified
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|performAbfsAuthCheck
argument_list|(
name|FsAction
operator|.
name|WRITE
argument_list|,
name|qualifiedPath
argument_list|)
expr_stmt|;
try|try
block|{
name|abfsStore
operator|.
name|removeAclEntries
argument_list|(
name|qualifiedPath
argument_list|,
name|aclSpec
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|AzureBlobFileSystemException
name|ex
parameter_list|)
block|{
name|checkException
argument_list|(
name|path
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Removes all default ACL entries from files and directories.    *    * @param path Path to modify    * @throws IOException if an ACL could not be modified    */
annotation|@
name|Override
DECL|method|removeDefaultAcl (final Path path)
specifier|public
name|void
name|removeDefaultAcl
parameter_list|(
specifier|final
name|Path
name|path
parameter_list|)
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"AzureBlobFileSystem.removeDefaultAcl path: {}"
argument_list|,
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|getIsNamespaceEnabled
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"removeDefaultAcl is only supported by storage accounts with the "
operator|+
literal|"hierarchical namespace enabled."
argument_list|)
throw|;
block|}
name|Path
name|qualifiedPath
init|=
name|makeQualified
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|performAbfsAuthCheck
argument_list|(
name|FsAction
operator|.
name|WRITE
argument_list|,
name|qualifiedPath
argument_list|)
expr_stmt|;
try|try
block|{
name|abfsStore
operator|.
name|removeDefaultAcl
argument_list|(
name|qualifiedPath
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|AzureBlobFileSystemException
name|ex
parameter_list|)
block|{
name|checkException
argument_list|(
name|path
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Removes all but the base ACL entries of files and directories.  The entries    * for user, group, and others are retained for compatibility with permission    * bits.    *    * @param path Path to modify    * @throws IOException if an ACL could not be removed    */
annotation|@
name|Override
DECL|method|removeAcl (final Path path)
specifier|public
name|void
name|removeAcl
parameter_list|(
specifier|final
name|Path
name|path
parameter_list|)
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"AzureBlobFileSystem.removeAcl path: {}"
argument_list|,
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|getIsNamespaceEnabled
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"removeAcl is only supported by storage accounts with the "
operator|+
literal|"hierarchical namespace enabled."
argument_list|)
throw|;
block|}
name|Path
name|qualifiedPath
init|=
name|makeQualified
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|performAbfsAuthCheck
argument_list|(
name|FsAction
operator|.
name|WRITE
argument_list|,
name|qualifiedPath
argument_list|)
expr_stmt|;
try|try
block|{
name|abfsStore
operator|.
name|removeAcl
argument_list|(
name|qualifiedPath
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|AzureBlobFileSystemException
name|ex
parameter_list|)
block|{
name|checkException
argument_list|(
name|path
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Fully replaces ACL of files and directories, discarding all existing    * entries.    *    * @param path    Path to modify    * @param aclSpec List of AclEntry describing modifications, must include    *                entries for user, group, and others for compatibility with    *                permission bits.    * @throws IOException if an ACL could not be modified    */
annotation|@
name|Override
DECL|method|setAcl (final Path path, final List<AclEntry> aclSpec)
specifier|public
name|void
name|setAcl
parameter_list|(
specifier|final
name|Path
name|path
parameter_list|,
specifier|final
name|List
argument_list|<
name|AclEntry
argument_list|>
name|aclSpec
parameter_list|)
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"AzureBlobFileSystem.setAcl path: {}"
argument_list|,
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|getIsNamespaceEnabled
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"setAcl is only supported by storage accounts with the hierarchical "
operator|+
literal|"namespace enabled."
argument_list|)
throw|;
block|}
if|if
condition|(
name|aclSpec
operator|==
literal|null
operator|||
name|aclSpec
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The aclSpec argument is invalid."
argument_list|)
throw|;
block|}
name|Path
name|qualifiedPath
init|=
name|makeQualified
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|performAbfsAuthCheck
argument_list|(
name|FsAction
operator|.
name|WRITE
argument_list|,
name|qualifiedPath
argument_list|)
expr_stmt|;
try|try
block|{
name|abfsStore
operator|.
name|setAcl
argument_list|(
name|qualifiedPath
argument_list|,
name|aclSpec
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|AzureBlobFileSystemException
name|ex
parameter_list|)
block|{
name|checkException
argument_list|(
name|path
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Gets the ACL of a file or directory.    *    * @param path Path to get    * @return AbfsAclStatus describing the ACL of the file or directory    * @throws IOException if an ACL could not be read    */
annotation|@
name|Override
DECL|method|getAclStatus (final Path path)
specifier|public
name|AclStatus
name|getAclStatus
parameter_list|(
specifier|final
name|Path
name|path
parameter_list|)
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"AzureBlobFileSystem.getAclStatus path: {}"
argument_list|,
name|path
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|getIsNamespaceEnabled
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"getAclStatus is only supported by storage account with the "
operator|+
literal|"hierarchical namespace enabled."
argument_list|)
throw|;
block|}
name|Path
name|qualifiedPath
init|=
name|makeQualified
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|performAbfsAuthCheck
argument_list|(
name|FsAction
operator|.
name|READ
argument_list|,
name|qualifiedPath
argument_list|)
expr_stmt|;
try|try
block|{
return|return
name|abfsStore
operator|.
name|getAclStatus
argument_list|(
name|qualifiedPath
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|AzureBlobFileSystemException
name|ex
parameter_list|)
block|{
name|checkException
argument_list|(
name|path
argument_list|,
name|ex
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
comment|/**    * Checks if the user can access a path.  The mode specifies which access    * checks to perform.  If the requested permissions are granted, then the    * method returns normally.  If access is denied, then the method throws an    * {@link AccessControlException}.    *    * @param path Path to check    * @param mode type of access to check    * @throws AccessControlException        if access is denied    * @throws java.io.FileNotFoundException if the path does not exist    * @throws IOException                   see specific implementation    */
annotation|@
name|Override
DECL|method|access (final Path path, FsAction mode)
specifier|public
name|void
name|access
parameter_list|(
specifier|final
name|Path
name|path
parameter_list|,
name|FsAction
name|mode
parameter_list|)
throws|throws
name|IOException
block|{
comment|// TODO: make it no-op to unblock hive permission issue for now.
comment|// Will add a long term fix similar to the implementation in AdlFileSystem.
block|}
DECL|method|tryGetFileStatus (final Path f)
specifier|private
name|FileStatus
name|tryGetFileStatus
parameter_list|(
specifier|final
name|Path
name|f
parameter_list|)
block|{
try|try
block|{
return|return
name|getFileStatus
argument_list|(
name|f
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"File not found {}"
argument_list|,
name|f
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
DECL|method|fileSystemExists ()
specifier|private
name|boolean
name|fileSystemExists
parameter_list|()
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"AzureBlobFileSystem.fileSystemExists uri: {}"
argument_list|,
name|uri
argument_list|)
expr_stmt|;
try|try
block|{
name|abfsStore
operator|.
name|getFilesystemProperties
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|AzureBlobFileSystemException
name|ex
parameter_list|)
block|{
try|try
block|{
name|checkException
argument_list|(
literal|null
argument_list|,
name|ex
argument_list|)
expr_stmt|;
comment|// Because HEAD request won't contain message body,
comment|// there is not way to get the storage error code
comment|// workaround here is to check its status code.
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|e
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
DECL|method|createFileSystem ()
specifier|private
name|void
name|createFileSystem
parameter_list|()
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"AzureBlobFileSystem.createFileSystem uri: {}"
argument_list|,
name|uri
argument_list|)
expr_stmt|;
try|try
block|{
name|abfsStore
operator|.
name|createFilesystem
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|AzureBlobFileSystemException
name|ex
parameter_list|)
block|{
name|checkException
argument_list|(
literal|null
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|ensureAuthority (URI uri, final Configuration conf)
specifier|private
name|URI
name|ensureAuthority
parameter_list|(
name|URI
name|uri
parameter_list|,
specifier|final
name|Configuration
name|conf
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|uri
argument_list|,
literal|"uri"
argument_list|)
expr_stmt|;
if|if
condition|(
name|uri
operator|.
name|getAuthority
argument_list|()
operator|==
literal|null
condition|)
block|{
specifier|final
name|URI
name|defaultUri
init|=
name|FileSystem
operator|.
name|getDefaultUri
argument_list|(
name|conf
argument_list|)
decl_stmt|;
if|if
condition|(
name|defaultUri
operator|!=
literal|null
operator|&&
name|isAbfsScheme
argument_list|(
name|defaultUri
operator|.
name|getScheme
argument_list|()
argument_list|)
condition|)
block|{
try|try
block|{
comment|// Reconstruct the URI with the authority from the default URI.
name|uri
operator|=
operator|new
name|URI
argument_list|(
name|uri
operator|.
name|getScheme
argument_list|()
argument_list|,
name|defaultUri
operator|.
name|getAuthority
argument_list|()
argument_list|,
name|uri
operator|.
name|getPath
argument_list|()
argument_list|,
name|uri
operator|.
name|getQuery
argument_list|()
argument_list|,
name|uri
operator|.
name|getFragment
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|URISyntaxException
name|e
parameter_list|)
block|{
comment|// This should never happen.
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
operator|new
name|InvalidUriException
argument_list|(
name|uri
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
block|}
block|}
if|if
condition|(
name|uri
operator|.
name|getAuthority
argument_list|()
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
operator|new
name|InvalidUriAuthorityException
argument_list|(
name|uri
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
return|return
name|uri
return|;
block|}
DECL|method|isAbfsScheme (final String scheme)
specifier|private
name|boolean
name|isAbfsScheme
parameter_list|(
specifier|final
name|String
name|scheme
parameter_list|)
block|{
if|if
condition|(
name|scheme
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|scheme
operator|.
name|equals
argument_list|(
name|FileSystemUriSchemes
operator|.
name|ABFS_SCHEME
argument_list|)
operator|||
name|scheme
operator|.
name|equals
argument_list|(
name|FileSystemUriSchemes
operator|.
name|ABFS_SECURE_SCHEME
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|execute ( final String scopeDescription, final Callable<T> callableFileOperation)
argument_list|<
name|T
argument_list|>
name|FileSystemOperation
argument_list|<
name|T
argument_list|>
name|execute
parameter_list|(
specifier|final
name|String
name|scopeDescription
parameter_list|,
specifier|final
name|Callable
argument_list|<
name|T
argument_list|>
name|callableFileOperation
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|execute
argument_list|(
name|scopeDescription
argument_list|,
name|callableFileOperation
argument_list|,
literal|null
argument_list|)
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|execute ( final String scopeDescription, final Callable<T> callableFileOperation, T defaultResultValue)
argument_list|<
name|T
argument_list|>
name|FileSystemOperation
argument_list|<
name|T
argument_list|>
name|execute
parameter_list|(
specifier|final
name|String
name|scopeDescription
parameter_list|,
specifier|final
name|Callable
argument_list|<
name|T
argument_list|>
name|callableFileOperation
parameter_list|,
name|T
name|defaultResultValue
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
specifier|final
name|T
name|executionResult
init|=
name|callableFileOperation
operator|.
name|call
argument_list|()
decl_stmt|;
return|return
operator|new
name|FileSystemOperation
argument_list|<>
argument_list|(
name|executionResult
argument_list|,
literal|null
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|AbfsRestOperationException
name|abfsRestOperationException
parameter_list|)
block|{
return|return
operator|new
name|FileSystemOperation
argument_list|<>
argument_list|(
name|defaultResultValue
argument_list|,
name|abfsRestOperationException
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|AzureBlobFileSystemException
name|azureBlobFileSystemException
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|azureBlobFileSystemException
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|Exception
name|exception
parameter_list|)
block|{
if|if
condition|(
name|exception
operator|instanceof
name|ExecutionException
condition|)
block|{
name|exception
operator|=
operator|(
name|Exception
operator|)
name|getRootCause
argument_list|(
name|exception
argument_list|)
expr_stmt|;
block|}
specifier|final
name|FileSystemOperationUnhandledException
name|fileSystemOperationUnhandledException
init|=
operator|new
name|FileSystemOperationUnhandledException
argument_list|(
name|exception
argument_list|)
decl_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
name|fileSystemOperationUnhandledException
argument_list|)
throw|;
block|}
block|}
comment|/**    * Given a path and exception, choose which IOException subclass    * to create.    * Will return if and only iff the error code is in the list of allowed    * error codes.    * @param path path of operation triggering exception; may be null    * @param exception the exception caught    * @param allowedErrorCodesList varargs list of error codes.    * @throws IOException if the exception error code is not on the allowed list.    */
DECL|method|checkException (final Path path, final AzureBlobFileSystemException exception, final AzureServiceErrorCode... allowedErrorCodesList)
specifier|private
name|void
name|checkException
parameter_list|(
specifier|final
name|Path
name|path
parameter_list|,
specifier|final
name|AzureBlobFileSystemException
name|exception
parameter_list|,
specifier|final
name|AzureServiceErrorCode
modifier|...
name|allowedErrorCodesList
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|exception
operator|instanceof
name|AbfsRestOperationException
condition|)
block|{
name|AbfsRestOperationException
name|ere
init|=
operator|(
name|AbfsRestOperationException
operator|)
name|exception
decl_stmt|;
if|if
condition|(
name|ArrayUtils
operator|.
name|contains
argument_list|(
name|allowedErrorCodesList
argument_list|,
name|ere
operator|.
name|getErrorCode
argument_list|()
argument_list|)
condition|)
block|{
return|return;
block|}
name|int
name|statusCode
init|=
name|ere
operator|.
name|getStatusCode
argument_list|()
decl_stmt|;
comment|//AbfsRestOperationException.getMessage() contains full error info including path/uri.
if|if
condition|(
name|statusCode
operator|==
name|HttpURLConnection
operator|.
name|HTTP_NOT_FOUND
condition|)
block|{
throw|throw
operator|(
name|IOException
operator|)
operator|new
name|FileNotFoundException
argument_list|(
name|ere
operator|.
name|getMessage
argument_list|()
argument_list|)
operator|.
name|initCause
argument_list|(
name|exception
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|statusCode
operator|==
name|HttpURLConnection
operator|.
name|HTTP_CONFLICT
condition|)
block|{
throw|throw
operator|(
name|IOException
operator|)
operator|new
name|FileAlreadyExistsException
argument_list|(
name|ere
operator|.
name|getMessage
argument_list|()
argument_list|)
operator|.
name|initCause
argument_list|(
name|exception
argument_list|)
throw|;
block|}
else|else
block|{
throw|throw
name|ere
throw|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|path
operator|==
literal|null
condition|)
block|{
throw|throw
name|exception
throw|;
block|}
comment|// record info of path
throw|throw
operator|new
name|PathIOException
argument_list|(
name|path
operator|.
name|toString
argument_list|()
argument_list|,
name|exception
argument_list|)
throw|;
block|}
block|}
comment|/**    * Gets the root cause of a provided {@link Throwable}.  If there is no cause for the    * {@link Throwable} provided into this function, the original {@link Throwable} is returned.    *    * @param throwable starting {@link Throwable}    * @return root cause {@link Throwable}    */
DECL|method|getRootCause (Throwable throwable)
specifier|private
name|Throwable
name|getRootCause
parameter_list|(
name|Throwable
name|throwable
parameter_list|)
block|{
if|if
condition|(
name|throwable
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"throwable can not be null"
argument_list|)
throw|;
block|}
name|Throwable
name|result
init|=
name|throwable
decl_stmt|;
while|while
condition|(
name|result
operator|.
name|getCause
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|result
operator|=
name|result
operator|.
name|getCause
argument_list|()
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
comment|/**    * Get a delegation token from remote service endpoint if    * 'fs.azure.enable.kerberos.support' is set to 'true', and    * 'fs.azure.enable.delegation.token' is set to 'true'.    * @param renewer the account name that is allowed to renew the token.    * @return delegation token    * @throws IOException thrown when getting the current user.    */
annotation|@
name|Override
DECL|method|getDelegationToken (final String renewer)
specifier|public
specifier|synchronized
name|Token
argument_list|<
name|?
argument_list|>
name|getDelegationToken
parameter_list|(
specifier|final
name|String
name|renewer
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|this
operator|.
name|delegationTokenEnabled
condition|?
name|this
operator|.
name|delegationTokenManager
operator|.
name|getDelegationToken
argument_list|(
name|renewer
argument_list|)
else|:
name|super
operator|.
name|getDelegationToken
argument_list|(
name|renewer
argument_list|)
return|;
block|}
comment|/**    * If Delegation tokens are enabled, the canonical service name of    * this filesystem is the filesystem URI.    * @return either the filesystem URI as a string, or null.    */
annotation|@
name|Override
DECL|method|getCanonicalServiceName ()
specifier|public
name|String
name|getCanonicalServiceName
parameter_list|()
block|{
name|String
name|name
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|delegationTokenManager
operator|!=
literal|null
condition|)
block|{
name|name
operator|=
name|delegationTokenManager
operator|.
name|getCanonicalServiceName
argument_list|()
expr_stmt|;
block|}
return|return
name|name
operator|!=
literal|null
condition|?
name|name
else|:
name|super
operator|.
name|getCanonicalServiceName
argument_list|()
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|getFsStatistics ()
name|FileSystem
operator|.
name|Statistics
name|getFsStatistics
parameter_list|()
block|{
return|return
name|this
operator|.
name|statistics
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|class|FileSystemOperation
specifier|static
class|class
name|FileSystemOperation
parameter_list|<
name|T
parameter_list|>
block|{
DECL|field|result
specifier|private
specifier|final
name|T
name|result
decl_stmt|;
DECL|field|exception
specifier|private
specifier|final
name|AbfsRestOperationException
name|exception
decl_stmt|;
DECL|method|FileSystemOperation (final T result, final AbfsRestOperationException exception)
name|FileSystemOperation
parameter_list|(
specifier|final
name|T
name|result
parameter_list|,
specifier|final
name|AbfsRestOperationException
name|exception
parameter_list|)
block|{
name|this
operator|.
name|result
operator|=
name|result
expr_stmt|;
name|this
operator|.
name|exception
operator|=
name|exception
expr_stmt|;
block|}
DECL|method|failed ()
specifier|public
name|boolean
name|failed
parameter_list|()
block|{
return|return
name|this
operator|.
name|exception
operator|!=
literal|null
return|;
block|}
block|}
annotation|@
name|VisibleForTesting
DECL|method|getAbfsStore ()
name|AzureBlobFileSystemStore
name|getAbfsStore
parameter_list|()
block|{
return|return
name|abfsStore
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|getAbfsClient ()
name|AbfsClient
name|getAbfsClient
parameter_list|()
block|{
return|return
name|abfsStore
operator|.
name|getClient
argument_list|()
return|;
block|}
comment|/**    * Get any Delegation Token manager created by the filesystem.    * @return the DT manager or null.    */
annotation|@
name|VisibleForTesting
DECL|method|getDelegationTokenManager ()
name|AbfsDelegationTokenManager
name|getDelegationTokenManager
parameter_list|()
block|{
return|return
name|delegationTokenManager
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|getIsNamespaceEnabled ()
name|boolean
name|getIsNamespaceEnabled
parameter_list|()
throws|throws
name|AzureBlobFileSystemException
block|{
return|return
name|abfsStore
operator|.
name|getIsNamespaceEnabled
argument_list|()
return|;
block|}
comment|/**    * Use ABFS authorizer to check if user is authorized to perform specific    * {@link FsAction} on specified {@link Path}s.    *    * @param action The {@link FsAction} being requested on the provided {@link Path}s.    * @param paths The absolute paths of the storage being accessed.    * @throws AbfsAuthorizationException on authorization failure.    * @throws IOException network problems or similar.    * @throws IllegalArgumentException if the required parameters are not provided.    */
DECL|method|performAbfsAuthCheck (FsAction action, Path... paths)
specifier|private
name|void
name|performAbfsAuthCheck
parameter_list|(
name|FsAction
name|action
parameter_list|,
name|Path
modifier|...
name|paths
parameter_list|)
throws|throws
name|AbfsAuthorizationException
throws|,
name|IOException
block|{
if|if
condition|(
name|authorizer
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"ABFS authorizer is not initialized. No authorization check will be performed."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|paths
operator|.
name|length
operator|>
literal|0
argument_list|,
literal|"no paths supplied for authorization check"
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Auth check for action: {} on paths: {}"
argument_list|,
name|action
operator|.
name|toString
argument_list|()
argument_list|,
name|Arrays
operator|.
name|toString
argument_list|(
name|paths
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|authorizer
operator|.
name|isAuthorized
argument_list|(
name|action
argument_list|,
name|paths
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|AbfsAuthorizationException
argument_list|(
literal|"User is not authorized for action "
operator|+
name|action
operator|.
name|toString
argument_list|()
operator|+
literal|" on paths: "
operator|+
name|Arrays
operator|.
name|toString
argument_list|(
name|paths
argument_list|)
argument_list|)
throw|;
block|}
block|}
block|}
annotation|@
name|Override
DECL|method|hasPathCapability (final Path path, final String capability)
specifier|public
name|boolean
name|hasPathCapability
parameter_list|(
specifier|final
name|Path
name|path
parameter_list|,
specifier|final
name|String
name|capability
parameter_list|)
throws|throws
name|IOException
block|{
comment|// qualify the path to make sure that it refers to the current FS.
specifier|final
name|Path
name|p
init|=
name|makeQualified
argument_list|(
name|path
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|validatePathCapabilityArgs
argument_list|(
name|p
argument_list|,
name|capability
argument_list|)
condition|)
block|{
case|case
name|CommonPathCapabilities
operator|.
name|FS_PERMISSIONS
case|:
case|case
name|CommonPathCapabilities
operator|.
name|FS_APPEND
case|:
return|return
literal|true
return|;
case|case
name|CommonPathCapabilities
operator|.
name|FS_ACLS
case|:
return|return
name|getIsNamespaceEnabled
argument_list|()
return|;
default|default:
return|return
name|super
operator|.
name|hasPathCapability
argument_list|(
name|p
argument_list|,
name|capability
argument_list|)
return|;
block|}
block|}
block|}
end_class

end_unit

