begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.fs.azure
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|azure
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|StandardCharsets
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Calendar
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Locale
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|UUID
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Random
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TimeZone
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|LinkedBlockingQueue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ThreadFactory
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ThreadPoolExecutor
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FSExceptionMessages
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|codec
operator|.
name|binary
operator|.
name|Base64
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|azure
operator|.
name|StorageInterface
operator|.
name|CloudBlockBlobWrapper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eclipse
operator|.
name|jetty
operator|.
name|util
operator|.
name|log
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|com
operator|.
name|microsoft
operator|.
name|azure
operator|.
name|storage
operator|.
name|AccessCondition
import|;
end_import

begin_import
import|import
name|com
operator|.
name|microsoft
operator|.
name|azure
operator|.
name|storage
operator|.
name|OperationContext
import|;
end_import

begin_import
import|import
name|com
operator|.
name|microsoft
operator|.
name|azure
operator|.
name|storage
operator|.
name|StorageException
import|;
end_import

begin_import
import|import
name|com
operator|.
name|microsoft
operator|.
name|azure
operator|.
name|storage
operator|.
name|blob
operator|.
name|BlobRequestOptions
import|;
end_import

begin_import
import|import
name|com
operator|.
name|microsoft
operator|.
name|azure
operator|.
name|storage
operator|.
name|blob
operator|.
name|BlockEntry
import|;
end_import

begin_import
import|import
name|com
operator|.
name|microsoft
operator|.
name|azure
operator|.
name|storage
operator|.
name|blob
operator|.
name|BlockListingFilter
import|;
end_import

begin_comment
comment|/**  * Stream object that implememnts append for Block Blobs in WASB.  */
end_comment

begin_class
DECL|class|BlockBlobAppendStream
specifier|public
class|class
name|BlockBlobAppendStream
extends|extends
name|OutputStream
block|{
DECL|field|key
specifier|private
specifier|final
name|String
name|key
decl_stmt|;
DECL|field|bufferSize
specifier|private
specifier|final
name|int
name|bufferSize
decl_stmt|;
DECL|field|outBuffer
specifier|private
name|ByteArrayOutputStream
name|outBuffer
decl_stmt|;
DECL|field|blob
specifier|private
specifier|final
name|CloudBlockBlobWrapper
name|blob
decl_stmt|;
DECL|field|opContext
specifier|private
specifier|final
name|OperationContext
name|opContext
decl_stmt|;
comment|/**    * Variable to track if the stream has been closed.    */
DECL|field|closed
specifier|private
name|boolean
name|closed
init|=
literal|false
decl_stmt|;
comment|/**    * Variable to track if the append lease is released.    */
DECL|field|leaseFreed
specifier|private
specifier|volatile
name|boolean
name|leaseFreed
decl_stmt|;
comment|/**    * Variable to track if the append stream has been    * initialized.    */
DECL|field|initialized
specifier|private
name|boolean
name|initialized
init|=
literal|false
decl_stmt|;
comment|/**    *  Last IOException encountered    */
DECL|field|lastError
specifier|private
specifier|volatile
name|IOException
name|lastError
init|=
literal|null
decl_stmt|;
comment|/**    * List to keep track of the uncommitted azure storage    * block ids    */
DECL|field|uncommittedBlockEntries
specifier|private
specifier|final
name|List
argument_list|<
name|BlockEntry
argument_list|>
name|uncommittedBlockEntries
decl_stmt|;
DECL|field|UNSET_BLOCKS_COUNT
specifier|private
specifier|static
specifier|final
name|int
name|UNSET_BLOCKS_COUNT
init|=
operator|-
literal|1
decl_stmt|;
comment|/**    * Variable to hold the next block id to be used for azure    * storage blocks.    */
DECL|field|nextBlockCount
specifier|private
name|long
name|nextBlockCount
init|=
name|UNSET_BLOCKS_COUNT
decl_stmt|;
comment|/**    * Variable to hold the block id prefix to be used for azure    * storage blocks from azure-storage-java sdk version 4.2.0 onwards    */
DECL|field|blockIdPrefix
specifier|private
name|String
name|blockIdPrefix
init|=
literal|null
decl_stmt|;
DECL|field|sequenceGenerator
specifier|private
specifier|final
name|Random
name|sequenceGenerator
init|=
operator|new
name|Random
argument_list|()
decl_stmt|;
comment|/**    *  Time to wait to renew lease in milliseconds    */
DECL|field|LEASE_RENEWAL_PERIOD
specifier|private
specifier|static
specifier|final
name|int
name|LEASE_RENEWAL_PERIOD
init|=
literal|10000
decl_stmt|;
comment|/**    *  Number of times to retry for lease renewal    */
DECL|field|MAX_LEASE_RENEWAL_RETRY_COUNT
specifier|private
specifier|static
specifier|final
name|int
name|MAX_LEASE_RENEWAL_RETRY_COUNT
init|=
literal|3
decl_stmt|;
comment|/**    *  Time to wait before retrying to set the lease    */
DECL|field|LEASE_RENEWAL_RETRY_SLEEP_PERIOD
specifier|private
specifier|static
specifier|final
name|int
name|LEASE_RENEWAL_RETRY_SLEEP_PERIOD
init|=
literal|500
decl_stmt|;
comment|/**    *  Metadata key used on the blob to indicate append lease is active    */
DECL|field|APPEND_LEASE
specifier|public
specifier|static
specifier|final
name|String
name|APPEND_LEASE
init|=
literal|"append_lease"
decl_stmt|;
comment|/**    * Timeout value for the append lease in millisecs. If the lease is not    * renewed within 30 seconds then another thread can acquire the append lease    * on the blob    */
DECL|field|APPEND_LEASE_TIMEOUT
specifier|public
specifier|static
specifier|final
name|int
name|APPEND_LEASE_TIMEOUT
init|=
literal|30000
decl_stmt|;
comment|/**    *  Metdata key used on the blob to indicate last modified time of append lease    */
DECL|field|APPEND_LEASE_LAST_MODIFIED
specifier|public
specifier|static
specifier|final
name|String
name|APPEND_LEASE_LAST_MODIFIED
init|=
literal|"append_lease_last_modified"
decl_stmt|;
comment|/**    * Number of times block upload needs is retried.    */
DECL|field|MAX_BLOCK_UPLOAD_RETRIES
specifier|private
specifier|static
specifier|final
name|int
name|MAX_BLOCK_UPLOAD_RETRIES
init|=
literal|3
decl_stmt|;
comment|/**    * Wait time between block upload retries in millisecs.    */
DECL|field|BLOCK_UPLOAD_RETRY_INTERVAL
specifier|private
specifier|static
specifier|final
name|int
name|BLOCK_UPLOAD_RETRY_INTERVAL
init|=
literal|1000
decl_stmt|;
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|BlockBlobAppendStream
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|MAX_BLOCK_COUNT
specifier|private
specifier|static
specifier|final
name|int
name|MAX_BLOCK_COUNT
init|=
literal|100000
decl_stmt|;
DECL|field|ioThreadPool
specifier|private
name|ThreadPoolExecutor
name|ioThreadPool
decl_stmt|;
comment|/**    * Atomic integer to provide thread id for thread names for uploader threads.    */
DECL|field|threadSequenceNumber
specifier|private
specifier|final
name|AtomicInteger
name|threadSequenceNumber
decl_stmt|;
comment|/**    * Prefix to be used for thread names for uploader threads.    */
DECL|field|THREAD_ID_PREFIX
specifier|private
specifier|static
specifier|final
name|String
name|THREAD_ID_PREFIX
init|=
literal|"BlockBlobAppendStream"
decl_stmt|;
DECL|field|UTC_STR
specifier|private
specifier|static
specifier|final
name|String
name|UTC_STR
init|=
literal|"UTC"
decl_stmt|;
DECL|method|BlockBlobAppendStream (final CloudBlockBlobWrapper blob, final String aKey, final int bufferSize, final OperationContext opContext)
specifier|public
name|BlockBlobAppendStream
parameter_list|(
specifier|final
name|CloudBlockBlobWrapper
name|blob
parameter_list|,
specifier|final
name|String
name|aKey
parameter_list|,
specifier|final
name|int
name|bufferSize
parameter_list|,
specifier|final
name|OperationContext
name|opContext
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
literal|null
operator|==
name|aKey
operator|||
literal|0
operator|==
name|aKey
operator|.
name|length
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Illegal argument: The key string is null or empty"
argument_list|)
throw|;
block|}
if|if
condition|(
literal|0
operator|>=
name|bufferSize
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Illegal argument bufferSize cannot be zero or negative"
argument_list|)
throw|;
block|}
name|this
operator|.
name|blob
operator|=
name|blob
expr_stmt|;
name|this
operator|.
name|opContext
operator|=
name|opContext
expr_stmt|;
name|this
operator|.
name|key
operator|=
name|aKey
expr_stmt|;
name|this
operator|.
name|bufferSize
operator|=
name|bufferSize
expr_stmt|;
name|this
operator|.
name|threadSequenceNumber
operator|=
operator|new
name|AtomicInteger
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|this
operator|.
name|blockIdPrefix
operator|=
literal|null
expr_stmt|;
name|setBlocksCountAndBlockIdPrefix
argument_list|()
expr_stmt|;
name|this
operator|.
name|outBuffer
operator|=
operator|new
name|ByteArrayOutputStream
argument_list|(
name|bufferSize
argument_list|)
expr_stmt|;
name|this
operator|.
name|uncommittedBlockEntries
operator|=
operator|new
name|ArrayList
argument_list|<
name|BlockEntry
argument_list|>
argument_list|()
expr_stmt|;
comment|// Acquire append lease on the blob.
try|try
block|{
comment|//Set the append lease if the value of the append lease is false
if|if
condition|(
operator|!
name|updateBlobAppendMetadata
argument_list|(
literal|true
argument_list|,
literal|false
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to set Append Lease on the Blob : {} "
operator|+
literal|"Possibly because another client already has a create or append stream open on the Blob"
argument_list|,
name|key
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unable to set Append lease on the Blob. "
operator|+
literal|"Possibly because another client already had an append stream open on the Blob."
argument_list|)
throw|;
block|}
block|}
catch|catch
parameter_list|(
name|StorageException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Encountered Storage exception while acquiring append "
operator|+
literal|"lease on blob : {}. Storage Exception : {} ErrorCode : {}"
argument_list|,
name|key
argument_list|,
name|ex
argument_list|,
name|ex
operator|.
name|getErrorCode
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
name|ex
argument_list|)
throw|;
block|}
name|leaseFreed
operator|=
literal|false
expr_stmt|;
block|}
comment|/**    * Helper method that starts an Append Lease renewer thread and the    * thread pool.    */
DECL|method|initialize ()
specifier|public
specifier|synchronized
name|void
name|initialize
parameter_list|()
block|{
if|if
condition|(
name|initialized
condition|)
block|{
return|return;
block|}
comment|/*      * Start the thread for  Append lease renewer.      */
name|Thread
name|appendLeaseRenewer
init|=
operator|new
name|Thread
argument_list|(
operator|new
name|AppendRenewer
argument_list|()
argument_list|)
decl_stmt|;
name|appendLeaseRenewer
operator|.
name|setDaemon
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|appendLeaseRenewer
operator|.
name|setName
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"%s-AppendLeaseRenewer"
argument_list|,
name|key
argument_list|)
argument_list|)
expr_stmt|;
name|appendLeaseRenewer
operator|.
name|start
argument_list|()
expr_stmt|;
comment|/*      * Parameters to ThreadPoolExecutor:      * corePoolSize : the number of threads to keep in the pool, even if they are idle,      *                unless allowCoreThreadTimeOut is set      * maximumPoolSize : the maximum number of threads to allow in the pool      * keepAliveTime - when the number of threads is greater than the core,      *                 this is the maximum time that excess idle threads will      *                 wait for new tasks before terminating.      * unit - the time unit for the keepAliveTime argument      * workQueue - the queue to use for holding tasks before they are executed      *  This queue will hold only the Runnable tasks submitted by the execute method.      */
name|this
operator|.
name|ioThreadPool
operator|=
operator|new
name|ThreadPoolExecutor
argument_list|(
literal|4
argument_list|,
literal|4
argument_list|,
literal|2
argument_list|,
name|TimeUnit
operator|.
name|SECONDS
argument_list|,
operator|new
name|LinkedBlockingQueue
argument_list|<
name|Runnable
argument_list|>
argument_list|()
argument_list|,
operator|new
name|UploaderThreadFactory
argument_list|()
argument_list|)
expr_stmt|;
name|initialized
operator|=
literal|true
expr_stmt|;
block|}
comment|/**    * Get the blob name.    *    * @return String Blob name.    */
DECL|method|getKey ()
specifier|public
name|String
name|getKey
parameter_list|()
block|{
return|return
name|key
return|;
block|}
comment|/**    * Get the backing blob.    * @return buffer size of the stream.    */
DECL|method|getBufferSize ()
specifier|public
name|int
name|getBufferSize
parameter_list|()
block|{
return|return
name|bufferSize
return|;
block|}
comment|/**    * Writes the specified byte to this output stream. The general contract for    * write is that one byte is written to the output stream. The byte to be    * written is the eight low-order bits of the argument b. The 24 high-order    * bits of b are ignored.    *    * @param byteVal    *          the byteValue to write.    * @throws IOException    *           if an I/O error occurs. In particular, an IOException may be    *           thrown if the output stream has been closed.    */
annotation|@
name|Override
DECL|method|write (final int byteVal)
specifier|public
name|void
name|write
parameter_list|(
specifier|final
name|int
name|byteVal
parameter_list|)
throws|throws
name|IOException
block|{
name|write
argument_list|(
operator|new
name|byte
index|[]
block|{
call|(
name|byte
call|)
argument_list|(
name|byteVal
operator|&
literal|0xFF
argument_list|)
block|}
argument_list|)
expr_stmt|;
block|}
comment|/**    * Writes b.length bytes from the specified byte array to this output stream.    *    * @param data    *          the byte array to write.    *    * @throws IOException    *           if an I/O error occurs. In particular, an IOException may be    *           thrown if the output stream has been closed.    */
annotation|@
name|Override
DECL|method|write (final byte[] data)
specifier|public
name|void
name|write
parameter_list|(
specifier|final
name|byte
index|[]
name|data
parameter_list|)
throws|throws
name|IOException
block|{
name|write
argument_list|(
name|data
argument_list|,
literal|0
argument_list|,
name|data
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
comment|/**    * Writes length bytes from the specified byte array starting at offset to    * this output stream.    *    * @param data    *          the byte array to write.    * @param offset    *          the start offset in the data.    * @param length    *          the number of bytes to write.    * @throws IOException    *           if an I/O error occurs. In particular, an IOException may be    *           thrown if the output stream has been closed.    */
annotation|@
name|Override
DECL|method|write (final byte[] data, final int offset, final int length)
specifier|public
name|void
name|write
parameter_list|(
specifier|final
name|byte
index|[]
name|data
parameter_list|,
specifier|final
name|int
name|offset
parameter_list|,
specifier|final
name|int
name|length
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|offset
operator|<
literal|0
operator|||
name|length
argument_list|<
literal|0
operator|||
name|length
argument_list|>
name|data
operator|.
name|length
operator|-
name|offset
condition|)
block|{
throw|throw
operator|new
name|IndexOutOfBoundsException
argument_list|(
literal|"write API in append stream called with invalid arguments"
argument_list|)
throw|;
block|}
name|writeInternal
argument_list|(
name|data
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|close ()
specifier|public
specifier|synchronized
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|initialized
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Trying to close an uninitialized Append stream"
argument_list|)
throw|;
block|}
if|if
condition|(
name|closed
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|leaseFreed
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Attempting to close an append stream on blob : %s "
operator|+
literal|" that does not have lease on the Blob. Failing close"
argument_list|,
name|key
argument_list|)
argument_list|)
throw|;
block|}
if|if
condition|(
name|outBuffer
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|uploadBlockToStorage
argument_list|(
name|outBuffer
operator|.
name|toByteArray
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|ioThreadPool
operator|.
name|shutdown
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
operator|!
name|ioThreadPool
operator|.
name|awaitTermination
argument_list|(
literal|10
argument_list|,
name|TimeUnit
operator|.
name|MINUTES
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Time out occurred while waiting for IO request to finish in append"
operator|+
literal|" for blob : {}"
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|NativeAzureFileSystemHelper
operator|.
name|logAllLiveStackTraces
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Timed out waiting for IO requests to finish"
argument_list|)
throw|;
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|intrEx
parameter_list|)
block|{
comment|// Restore the interrupted status
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|error
argument_list|(
literal|"Upload block operation in append interrupted for blob {}. Failing close"
argument_list|,
name|key
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Append Commit interrupted."
argument_list|)
throw|;
block|}
comment|// Calling commit after all blocks are succesfully uploaded.
if|if
condition|(
name|lastError
operator|==
literal|null
condition|)
block|{
name|commitAppendBlocks
argument_list|()
expr_stmt|;
block|}
comment|// Perform cleanup.
name|cleanup
argument_list|()
expr_stmt|;
if|if
condition|(
name|lastError
operator|!=
literal|null
condition|)
block|{
throw|throw
name|lastError
throw|;
block|}
block|}
comment|/**    * Helper method that cleans up the append stream.    */
DECL|method|cleanup ()
specifier|private
specifier|synchronized
name|void
name|cleanup
parameter_list|()
block|{
name|closed
operator|=
literal|true
expr_stmt|;
try|try
block|{
comment|// Set the value of append lease to false if the value is set to true.
name|updateBlobAppendMetadata
argument_list|(
literal|false
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|StorageException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Append metadata update on the Blob : {} encountered Storage Exception : {} "
operator|+
literal|"Error Code : {}"
argument_list|,
name|key
argument_list|,
name|ex
argument_list|,
name|ex
operator|.
name|getErrorCode
argument_list|()
argument_list|)
expr_stmt|;
name|lastError
operator|=
operator|new
name|IOException
argument_list|(
name|ex
argument_list|)
expr_stmt|;
block|}
name|leaseFreed
operator|=
literal|true
expr_stmt|;
block|}
comment|/**    * Method to commit all the uncommited blocks to azure storage.    * If the commit fails then blocks are automatically cleaned up    * by Azure storage.    * @throws IOException    */
DECL|method|commitAppendBlocks ()
specifier|private
specifier|synchronized
name|void
name|commitAppendBlocks
parameter_list|()
throws|throws
name|IOException
block|{
name|SelfRenewingLease
name|lease
init|=
literal|null
decl_stmt|;
try|try
block|{
if|if
condition|(
name|uncommittedBlockEntries
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
comment|//Acquiring lease on the blob.
name|lease
operator|=
operator|new
name|SelfRenewingLease
argument_list|(
name|blob
argument_list|)
expr_stmt|;
comment|// Downloading existing blocks
name|List
argument_list|<
name|BlockEntry
argument_list|>
name|blockEntries
init|=
name|blob
operator|.
name|downloadBlockList
argument_list|(
name|BlockListingFilter
operator|.
name|COMMITTED
argument_list|,
operator|new
name|BlobRequestOptions
argument_list|()
argument_list|,
name|opContext
argument_list|)
decl_stmt|;
comment|// Adding uncommitted blocks.
name|blockEntries
operator|.
name|addAll
argument_list|(
name|uncommittedBlockEntries
argument_list|)
expr_stmt|;
name|AccessCondition
name|accessCondition
init|=
operator|new
name|AccessCondition
argument_list|()
decl_stmt|;
name|accessCondition
operator|.
name|setLeaseID
argument_list|(
name|lease
operator|.
name|getLeaseID
argument_list|()
argument_list|)
expr_stmt|;
name|blob
operator|.
name|commitBlockList
argument_list|(
name|blockEntries
argument_list|,
name|accessCondition
argument_list|,
operator|new
name|BlobRequestOptions
argument_list|()
argument_list|,
name|opContext
argument_list|)
expr_stmt|;
name|uncommittedBlockEntries
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|StorageException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Storage exception encountered during block commit phase of append for blob"
operator|+
literal|" : {} Storage Exception : {} Error Code: {}"
argument_list|,
name|key
argument_list|,
name|ex
argument_list|,
name|ex
operator|.
name|getErrorCode
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Encountered Exception while committing append blocks"
argument_list|,
name|ex
argument_list|)
throw|;
block|}
finally|finally
block|{
if|if
condition|(
name|lease
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|lease
operator|.
name|free
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|StorageException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Exception encountered while releasing lease for "
operator|+
literal|"blob : {} StorageException : {} ErrorCode : {}"
argument_list|,
name|key
argument_list|,
name|ex
argument_list|,
name|ex
operator|.
name|getErrorCode
argument_list|()
argument_list|)
expr_stmt|;
comment|// Swallowing exception here as the lease is cleaned up by the SelfRenewingLease object.
block|}
block|}
block|}
block|}
comment|/**    * Helper method used to generate the blockIDs. The algorithm used is similar to the Azure    * storage SDK.    */
DECL|method|setBlocksCountAndBlockIdPrefix ()
specifier|private
name|void
name|setBlocksCountAndBlockIdPrefix
parameter_list|()
throws|throws
name|IOException
block|{
try|try
block|{
if|if
condition|(
name|nextBlockCount
operator|==
name|UNSET_BLOCKS_COUNT
operator|&&
name|blockIdPrefix
operator|==
literal|null
condition|)
block|{
name|List
argument_list|<
name|BlockEntry
argument_list|>
name|blockEntries
init|=
name|blob
operator|.
name|downloadBlockList
argument_list|(
name|BlockListingFilter
operator|.
name|COMMITTED
argument_list|,
operator|new
name|BlobRequestOptions
argument_list|()
argument_list|,
name|opContext
argument_list|)
decl_stmt|;
name|String
name|blockZeroBlockId
init|=
operator|(
name|blockEntries
operator|.
name|size
argument_list|()
operator|>
literal|0
operator|)
condition|?
name|blockEntries
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getId
argument_list|()
else|:
literal|""
decl_stmt|;
name|String
name|prefix
init|=
name|UUID
operator|.
name|randomUUID
argument_list|()
operator|.
name|toString
argument_list|()
operator|+
literal|"-"
decl_stmt|;
name|String
name|sampleNewerVersionBlockId
init|=
name|generateNewerVersionBlockId
argument_list|(
name|prefix
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|blockEntries
operator|.
name|size
argument_list|()
operator|>
literal|0
operator|&&
name|blockZeroBlockId
operator|.
name|length
argument_list|()
operator|<
name|sampleNewerVersionBlockId
operator|.
name|length
argument_list|()
condition|)
block|{
comment|// If blob has already been created with 2.2.0, append subsequent blocks with older version (2.2.0) blockId
comment|// compute nextBlockCount, the way it was done before; and don't use blockIdPrefix
name|this
operator|.
name|blockIdPrefix
operator|=
literal|""
expr_stmt|;
name|nextBlockCount
operator|=
call|(
name|long
call|)
argument_list|(
name|sequenceGenerator
operator|.
name|nextInt
argument_list|(
name|Integer
operator|.
name|MAX_VALUE
argument_list|)
argument_list|)
operator|+
name|sequenceGenerator
operator|.
name|nextInt
argument_list|(
name|Integer
operator|.
name|MAX_VALUE
operator|-
name|MAX_BLOCK_COUNT
argument_list|)
expr_stmt|;
name|nextBlockCount
operator|+=
name|blockEntries
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// If there are no existing blocks, create the first block with newer version (4.2.0) blockId
comment|// If blob has already been created with 4.2.0, append subsequent blocks with newer version (4.2.0) blockId
name|this
operator|.
name|blockIdPrefix
operator|=
name|prefix
expr_stmt|;
name|nextBlockCount
operator|=
name|blockEntries
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|StorageException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Encountered storage exception during setting next Block Count and BlockId prefix."
operator|+
literal|" StorageException : {} ErrorCode : {}"
argument_list|,
name|ex
argument_list|,
name|ex
operator|.
name|getErrorCode
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
name|ex
argument_list|)
throw|;
block|}
block|}
comment|/**    * Helper method that generates the next block id for uploading a block to azure storage.    * @return String representing the block ID generated.    * @throws IOException    */
DECL|method|generateBlockId ()
specifier|private
name|String
name|generateBlockId
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|nextBlockCount
operator|==
name|UNSET_BLOCKS_COUNT
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Append Stream in invalid state. nextBlockCount not set correctly"
argument_list|)
throw|;
block|}
if|if
condition|(
name|this
operator|.
name|blockIdPrefix
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Append Stream in invalid state. blockIdPrefix not set correctly"
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|this
operator|.
name|blockIdPrefix
operator|.
name|equals
argument_list|(
literal|""
argument_list|)
condition|)
block|{
return|return
name|generateNewerVersionBlockId
argument_list|(
name|this
operator|.
name|blockIdPrefix
argument_list|,
name|nextBlockCount
operator|++
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|generateOlderVersionBlockId
argument_list|(
name|nextBlockCount
operator|++
argument_list|)
return|;
block|}
block|}
comment|/**    * Helper method that generates an older (2.2.0) version blockId    * @return String representing the block ID generated.    */
DECL|method|generateOlderVersionBlockId (long id)
specifier|private
name|String
name|generateOlderVersionBlockId
parameter_list|(
name|long
name|id
parameter_list|)
block|{
name|byte
index|[]
name|blockIdInBytes
init|=
name|getBytesFromLong
argument_list|(
name|id
argument_list|)
decl_stmt|;
return|return
operator|new
name|String
argument_list|(
name|Base64
operator|.
name|encodeBase64
argument_list|(
name|blockIdInBytes
argument_list|)
argument_list|,
name|StandardCharsets
operator|.
name|UTF_8
argument_list|)
return|;
block|}
comment|/**    * Helper method that generates an newer (4.2.0) version blockId    * @return String representing the block ID generated.    */
DECL|method|generateNewerVersionBlockId (String prefix, long id)
specifier|private
name|String
name|generateNewerVersionBlockId
parameter_list|(
name|String
name|prefix
parameter_list|,
name|long
name|id
parameter_list|)
block|{
name|String
name|blockIdSuffix
init|=
name|String
operator|.
name|format
argument_list|(
literal|"%06d"
argument_list|,
name|id
argument_list|)
decl_stmt|;
name|byte
index|[]
name|blockIdInBytes
init|=
operator|(
name|prefix
operator|+
name|blockIdSuffix
operator|)
operator|.
name|getBytes
argument_list|(
name|StandardCharsets
operator|.
name|UTF_8
argument_list|)
decl_stmt|;
return|return
operator|new
name|String
argument_list|(
name|Base64
operator|.
name|encodeBase64
argument_list|(
name|blockIdInBytes
argument_list|)
argument_list|,
name|StandardCharsets
operator|.
name|UTF_8
argument_list|)
return|;
block|}
comment|/**    * Returns a byte array that represents the data of a<code>long</code> value. This    * utility method is copied from com.microsoft.azure.storage.core.Utility class.    * This class is marked as internal, hence we clone the method here and not express    * dependency on the Utility Class    *    * @param value    *            The value from which the byte array will be returned.    *    * @return A byte array that represents the data of the specified<code>long</code> value.    */
DECL|method|getBytesFromLong (final long value)
specifier|private
specifier|static
name|byte
index|[]
name|getBytesFromLong
parameter_list|(
specifier|final
name|long
name|value
parameter_list|)
block|{
specifier|final
name|byte
index|[]
name|tempArray
init|=
operator|new
name|byte
index|[
literal|8
index|]
decl_stmt|;
for|for
control|(
name|int
name|m
init|=
literal|0
init|;
name|m
operator|<
literal|8
condition|;
name|m
operator|++
control|)
block|{
name|tempArray
index|[
literal|7
operator|-
name|m
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
operator|(
name|value
operator|>>
operator|(
literal|8
operator|*
name|m
operator|)
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
block|}
return|return
name|tempArray
return|;
block|}
comment|/**    * Helper method that creates a thread to upload a block to azure storage.    * @param payload    * @throws IOException    */
DECL|method|uploadBlockToStorage (byte[] payload)
specifier|private
specifier|synchronized
name|void
name|uploadBlockToStorage
parameter_list|(
name|byte
index|[]
name|payload
parameter_list|)
throws|throws
name|IOException
block|{
comment|// upload payload to azure storage
name|String
name|blockId
init|=
name|generateBlockId
argument_list|()
decl_stmt|;
comment|// Since uploads of the Azure storage are done in parallel threads, we go ahead
comment|// add the blockId in the uncommitted list. If the upload of the block fails
comment|// we don't commit the blockIds.
name|BlockEntry
name|blockEntry
init|=
operator|new
name|BlockEntry
argument_list|(
name|blockId
argument_list|)
decl_stmt|;
name|blockEntry
operator|.
name|setSize
argument_list|(
name|payload
operator|.
name|length
argument_list|)
expr_stmt|;
name|uncommittedBlockEntries
operator|.
name|add
argument_list|(
name|blockEntry
argument_list|)
expr_stmt|;
name|ioThreadPool
operator|.
name|execute
argument_list|(
operator|new
name|WriteRequest
argument_list|(
name|payload
argument_list|,
name|blockId
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Helper method to updated the Blob metadata during Append lease operations.    * Blob metadata is updated to holdLease value only if the current lease    * status is equal to testCondition and the last update on the blob metadata    * is less that 30 secs old.    * @param holdLease    * @param testCondition    * @return true if the updated lease operation was successful or false otherwise    * @throws StorageException    */
DECL|method|updateBlobAppendMetadata (boolean holdLease, boolean testCondition)
specifier|private
name|boolean
name|updateBlobAppendMetadata
parameter_list|(
name|boolean
name|holdLease
parameter_list|,
name|boolean
name|testCondition
parameter_list|)
throws|throws
name|StorageException
block|{
name|SelfRenewingLease
name|lease
init|=
literal|null
decl_stmt|;
name|StorageException
name|lastStorageException
init|=
literal|null
decl_stmt|;
name|int
name|leaseRenewalRetryCount
init|=
literal|0
decl_stmt|;
comment|/*      * Updating the Blob metadata honours following algorithm based on      *  1) If the append lease metadata is present      *  2) Last updated time of the append lease      *  3) Previous value of the Append lease metadata.      *      * The algorithm:      *  1) If append lease metadata is not part of the Blob. In this case      *     this is the first client to Append so we update the metadata.      *  2) If append lease metadata is present and timeout has occurred.      *     In this case irrespective of what the value of the append lease is we update the metadata.      *  3) If append lease metadata is present and is equal to testCondition value (passed as parameter)      *     and timeout has not occurred, we update the metadata.      *  4) If append lease metadata is present and is not equal to testCondition value (passed as parameter)      *     and timeout has not occurred, we do not update metadata and return false.      *      */
while|while
condition|(
name|leaseRenewalRetryCount
operator|<
name|MAX_LEASE_RENEWAL_RETRY_COUNT
condition|)
block|{
name|lastStorageException
operator|=
literal|null
expr_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
try|try
block|{
specifier|final
name|Calendar
name|currentCalendar
init|=
name|Calendar
operator|.
name|getInstance
argument_list|(
name|Locale
operator|.
name|US
argument_list|)
decl_stmt|;
name|currentCalendar
operator|.
name|setTimeZone
argument_list|(
name|TimeZone
operator|.
name|getTimeZone
argument_list|(
name|UTC_STR
argument_list|)
argument_list|)
expr_stmt|;
name|long
name|currentTime
init|=
name|currentCalendar
operator|.
name|getTime
argument_list|()
operator|.
name|getTime
argument_list|()
decl_stmt|;
comment|// Acquire lease on the blob.
name|lease
operator|=
operator|new
name|SelfRenewingLease
argument_list|(
name|blob
argument_list|)
expr_stmt|;
name|blob
operator|.
name|downloadAttributes
argument_list|(
name|opContext
argument_list|)
expr_stmt|;
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|metadata
init|=
name|blob
operator|.
name|getMetadata
argument_list|()
decl_stmt|;
if|if
condition|(
name|metadata
operator|.
name|containsKey
argument_list|(
name|APPEND_LEASE
argument_list|)
operator|&&
name|currentTime
operator|-
name|Long
operator|.
name|parseLong
argument_list|(
name|metadata
operator|.
name|get
argument_list|(
name|APPEND_LEASE_LAST_MODIFIED
argument_list|)
argument_list|)
operator|<=
name|BlockBlobAppendStream
operator|.
name|APPEND_LEASE_TIMEOUT
operator|&&
operator|!
name|metadata
operator|.
name|get
argument_list|(
name|APPEND_LEASE
argument_list|)
operator|.
name|equals
argument_list|(
name|Boolean
operator|.
name|toString
argument_list|(
name|testCondition
argument_list|)
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|metadata
operator|.
name|put
argument_list|(
name|APPEND_LEASE
argument_list|,
name|Boolean
operator|.
name|toString
argument_list|(
name|holdLease
argument_list|)
argument_list|)
expr_stmt|;
name|metadata
operator|.
name|put
argument_list|(
name|APPEND_LEASE_LAST_MODIFIED
argument_list|,
name|Long
operator|.
name|toString
argument_list|(
name|currentTime
argument_list|)
argument_list|)
expr_stmt|;
name|blob
operator|.
name|setMetadata
argument_list|(
name|metadata
argument_list|)
expr_stmt|;
name|AccessCondition
name|accessCondition
init|=
operator|new
name|AccessCondition
argument_list|()
decl_stmt|;
name|accessCondition
operator|.
name|setLeaseID
argument_list|(
name|lease
operator|.
name|getLeaseID
argument_list|()
argument_list|)
expr_stmt|;
name|blob
operator|.
name|uploadMetadata
argument_list|(
name|accessCondition
argument_list|,
literal|null
argument_list|,
name|opContext
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
catch|catch
parameter_list|(
name|StorageException
name|ex
parameter_list|)
block|{
name|lastStorageException
operator|=
name|ex
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Lease renewal for Blob : {} encountered Storage Exception : {} "
operator|+
literal|"Error Code : {}"
argument_list|,
name|key
argument_list|,
name|ex
argument_list|,
name|ex
operator|.
name|getErrorCode
argument_list|()
argument_list|)
expr_stmt|;
name|leaseRenewalRetryCount
operator|++
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|lease
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|lease
operator|.
name|free
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|StorageException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Encountered Storage exception while releasing lease for Blob {} "
operator|+
literal|"during Append  metadata operation. Storage Exception {} "
operator|+
literal|"Error Code : {} "
argument_list|,
name|key
argument_list|,
name|ex
argument_list|,
name|ex
operator|.
name|getErrorCode
argument_list|()
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|lease
operator|=
literal|null
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|leaseRenewalRetryCount
operator|==
name|MAX_LEASE_RENEWAL_RETRY_COUNT
condition|)
block|{
throw|throw
name|lastStorageException
throw|;
block|}
else|else
block|{
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|LEASE_RENEWAL_RETRY_SLEEP_PERIOD
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Blob append metadata updated method interrupted"
argument_list|)
expr_stmt|;
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|// The code should not enter here because the while loop will
comment|// always be executed and if the while loop is executed we
comment|// would returning from the while loop.
return|return
literal|false
return|;
block|}
comment|/**    * This is the only method that should be writing to outBuffer to maintain consistency of the outBuffer.    * @param data    * @param offset    * @param length    * @throws IOException    */
DECL|method|writeInternal (final byte[] data, final int offset, final int length)
specifier|private
specifier|synchronized
name|void
name|writeInternal
parameter_list|(
specifier|final
name|byte
index|[]
name|data
parameter_list|,
specifier|final
name|int
name|offset
parameter_list|,
specifier|final
name|int
name|length
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|initialized
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Trying to write to an un-initialized Append stream"
argument_list|)
throw|;
block|}
if|if
condition|(
name|closed
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|FSExceptionMessages
operator|.
name|STREAM_IS_CLOSED
argument_list|)
throw|;
block|}
if|if
condition|(
name|leaseFreed
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Write called on a append stream not holding lease. Failing Write"
argument_list|)
argument_list|)
throw|;
block|}
name|byte
index|[]
name|currentData
init|=
operator|new
name|byte
index|[
name|length
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|data
argument_list|,
name|offset
argument_list|,
name|currentData
argument_list|,
literal|0
argument_list|,
name|length
argument_list|)
expr_stmt|;
comment|// check to see if the data to be appended exceeds the
comment|// buffer size. If so we upload a block to azure storage.
while|while
condition|(
operator|(
name|outBuffer
operator|.
name|size
argument_list|()
operator|+
name|currentData
operator|.
name|length
operator|)
operator|>
name|bufferSize
condition|)
block|{
name|byte
index|[]
name|payload
init|=
operator|new
name|byte
index|[
name|bufferSize
index|]
decl_stmt|;
comment|// Add data from the existing buffer
name|System
operator|.
name|arraycopy
argument_list|(
name|outBuffer
operator|.
name|toByteArray
argument_list|()
argument_list|,
literal|0
argument_list|,
name|payload
argument_list|,
literal|0
argument_list|,
name|outBuffer
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
comment|// Updating the available size in the payload
name|int
name|availableSpaceInPayload
init|=
name|bufferSize
operator|-
name|outBuffer
operator|.
name|size
argument_list|()
decl_stmt|;
comment|// Adding data from the current call
name|System
operator|.
name|arraycopy
argument_list|(
name|currentData
argument_list|,
literal|0
argument_list|,
name|payload
argument_list|,
name|outBuffer
operator|.
name|size
argument_list|()
argument_list|,
name|availableSpaceInPayload
argument_list|)
expr_stmt|;
name|uploadBlockToStorage
argument_list|(
name|payload
argument_list|)
expr_stmt|;
comment|// updating the currentData buffer
name|byte
index|[]
name|tempBuffer
init|=
operator|new
name|byte
index|[
name|currentData
operator|.
name|length
operator|-
name|availableSpaceInPayload
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|currentData
argument_list|,
name|availableSpaceInPayload
argument_list|,
name|tempBuffer
argument_list|,
literal|0
argument_list|,
name|currentData
operator|.
name|length
operator|-
name|availableSpaceInPayload
argument_list|)
expr_stmt|;
name|currentData
operator|=
name|tempBuffer
expr_stmt|;
name|outBuffer
operator|=
operator|new
name|ByteArrayOutputStream
argument_list|(
name|bufferSize
argument_list|)
expr_stmt|;
block|}
name|outBuffer
operator|.
name|write
argument_list|(
name|currentData
argument_list|)
expr_stmt|;
block|}
comment|/**    * Runnable instance that uploads the block of data to azure storage.    *    *    */
DECL|class|WriteRequest
specifier|private
class|class
name|WriteRequest
implements|implements
name|Runnable
block|{
DECL|field|dataPayload
specifier|private
specifier|final
name|byte
index|[]
name|dataPayload
decl_stmt|;
DECL|field|blockId
specifier|private
specifier|final
name|String
name|blockId
decl_stmt|;
DECL|method|WriteRequest (byte[] dataPayload, String blockId)
specifier|public
name|WriteRequest
parameter_list|(
name|byte
index|[]
name|dataPayload
parameter_list|,
name|String
name|blockId
parameter_list|)
block|{
name|this
operator|.
name|dataPayload
operator|=
name|dataPayload
expr_stmt|;
name|this
operator|.
name|blockId
operator|=
name|blockId
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
name|int
name|uploadRetryAttempts
init|=
literal|0
decl_stmt|;
name|IOException
name|lastLocalException
init|=
literal|null
decl_stmt|;
while|while
condition|(
name|uploadRetryAttempts
operator|<
name|MAX_BLOCK_UPLOAD_RETRIES
condition|)
block|{
try|try
block|{
name|blob
operator|.
name|uploadBlock
argument_list|(
name|blockId
argument_list|,
operator|new
name|ByteArrayInputStream
argument_list|(
name|dataPayload
argument_list|)
argument_list|,
name|dataPayload
operator|.
name|length
argument_list|,
operator|new
name|BlobRequestOptions
argument_list|()
argument_list|,
name|opContext
argument_list|)
expr_stmt|;
break|break;
block|}
catch|catch
parameter_list|(
name|Exception
name|ioe
parameter_list|)
block|{
name|Log
operator|.
name|getLog
argument_list|()
operator|.
name|debug
argument_list|(
literal|"Encountered exception during uploading block for Blob : {} Exception : {}"
argument_list|,
name|key
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
name|uploadRetryAttempts
operator|++
expr_stmt|;
name|lastLocalException
operator|=
operator|new
name|IOException
argument_list|(
literal|"Encountered Exception while uploading block"
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|BLOCK_UPLOAD_RETRY_INTERVAL
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|uploadRetryAttempts
operator|==
name|MAX_BLOCK_UPLOAD_RETRIES
condition|)
block|{
name|lastError
operator|=
name|lastLocalException
expr_stmt|;
block|}
block|}
block|}
comment|/**    * A ThreadFactory that creates uploader thread with    * meaningful names helpful for debugging purposes.    */
DECL|class|UploaderThreadFactory
class|class
name|UploaderThreadFactory
implements|implements
name|ThreadFactory
block|{
annotation|@
name|Override
DECL|method|newThread (Runnable r)
specifier|public
name|Thread
name|newThread
parameter_list|(
name|Runnable
name|r
parameter_list|)
block|{
name|Thread
name|t
init|=
operator|new
name|Thread
argument_list|(
name|r
argument_list|)
decl_stmt|;
name|t
operator|.
name|setName
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"%s-%s-%d"
argument_list|,
name|THREAD_ID_PREFIX
argument_list|,
name|key
argument_list|,
name|threadSequenceNumber
operator|.
name|getAndIncrement
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
block|}
comment|/**    * A deamon thread that renews the Append lease on the blob.    * The thread sleeps for LEASE_RENEWAL_PERIOD time before renewing    * the lease. If an error is encountered while renewing the lease    * then an lease is released by this thread, which fails all other    * operations.    */
DECL|class|AppendRenewer
specifier|private
class|class
name|AppendRenewer
implements|implements
name|Runnable
block|{
annotation|@
name|Override
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
while|while
condition|(
operator|!
name|leaseFreed
condition|)
block|{
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|LEASE_RENEWAL_PERIOD
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Appender Renewer thread interrupted"
argument_list|)
expr_stmt|;
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
name|Log
operator|.
name|getLog
argument_list|()
operator|.
name|debug
argument_list|(
literal|"Attempting to renew append lease on {}"
argument_list|,
name|key
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
operator|!
name|leaseFreed
condition|)
block|{
comment|// Update the blob metadata to renew the append lease
if|if
condition|(
operator|!
name|updateBlobAppendMetadata
argument_list|(
literal|true
argument_list|,
literal|true
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to re-acquire append lease on the Blob {} "
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|leaseFreed
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|StorageException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Lease renewal for Blob : {} encountered "
operator|+
literal|"Storage Exception : {} Error Code : {}"
argument_list|,
name|key
argument_list|,
name|ex
argument_list|,
name|ex
operator|.
name|getErrorCode
argument_list|()
argument_list|)
expr_stmt|;
comment|// We swallow the exception here because if the blob metadata is not updated for
comment|// APPEND_LEASE_TIMEOUT period, another thread would be able to detect this and
comment|// continue forward if it needs to append.
name|leaseFreed
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_class

end_unit

