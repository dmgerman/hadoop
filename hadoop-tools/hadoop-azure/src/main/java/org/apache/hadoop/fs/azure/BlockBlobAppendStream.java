begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.fs.azure
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|azure
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|ByteBuffer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|StandardCharsets
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Locale
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|UUID
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Random
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentLinkedDeque
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentLinkedQueue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|CountDownLatch
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|LinkedBlockingQueue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Semaphore
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ThreadFactory
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ThreadPoolExecutor
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicLong
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicReference
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FSExceptionMessages
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|codec
operator|.
name|binary
operator|.
name|Base64
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|StreamCapabilities
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Syncable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|azure
operator|.
name|StorageInterface
operator|.
name|CloudBlockBlobWrapper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|ElasticByteBufferPool
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|com
operator|.
name|microsoft
operator|.
name|azure
operator|.
name|storage
operator|.
name|AccessCondition
import|;
end_import

begin_import
import|import
name|com
operator|.
name|microsoft
operator|.
name|azure
operator|.
name|storage
operator|.
name|OperationContext
import|;
end_import

begin_import
import|import
name|com
operator|.
name|microsoft
operator|.
name|azure
operator|.
name|storage
operator|.
name|StorageException
import|;
end_import

begin_import
import|import
name|com
operator|.
name|microsoft
operator|.
name|azure
operator|.
name|storage
operator|.
name|StorageErrorCodeStrings
import|;
end_import

begin_import
import|import
name|com
operator|.
name|microsoft
operator|.
name|azure
operator|.
name|storage
operator|.
name|blob
operator|.
name|BlobRequestOptions
import|;
end_import

begin_import
import|import
name|com
operator|.
name|microsoft
operator|.
name|azure
operator|.
name|storage
operator|.
name|blob
operator|.
name|BlockEntry
import|;
end_import

begin_import
import|import
name|com
operator|.
name|microsoft
operator|.
name|azure
operator|.
name|storage
operator|.
name|blob
operator|.
name|BlockListingFilter
import|;
end_import

begin_import
import|import
name|com
operator|.
name|microsoft
operator|.
name|azure
operator|.
name|storage
operator|.
name|blob
operator|.
name|BlockSearchMode
import|;
end_import

begin_comment
comment|/**  * Stream object that implements append for Block Blobs in WASB.  *  * The stream object implements hflush/hsync and block compaction. Block  * compaction is the process of replacing a sequence of small blocks with one  * big block. Azure Block blobs supports up to 50000 blocks and every  * hflush/hsync generates one block. When the number of blocks is above 32000,  * the process of compaction decreases the total number of blocks, if possible.  * If compaction is disabled, hflush/hsync are empty functions.  *  * The stream object uses background threads for uploading the blocks and the  * block blob list. Blocks can be uploaded concurrently. However, when the block  * list is uploaded, block uploading should stop. If a block is uploaded before  * the block list and the block id is not in the list, the block will be lost.  * If the block is uploaded after the block list and the block id is in the  * list, the block list upload will fail. The exclusive access for the block  * list upload is managed by uploadingSemaphore.  */
end_comment

begin_class
DECL|class|BlockBlobAppendStream
specifier|public
class|class
name|BlockBlobAppendStream
extends|extends
name|OutputStream
implements|implements
name|Syncable
implements|,
name|StreamCapabilities
block|{
comment|/**    * The name of the blob/file.    */
DECL|field|key
specifier|private
specifier|final
name|String
name|key
decl_stmt|;
comment|/**    * This variable tracks if this is new blob or existing one.    */
DECL|field|blobExist
specifier|private
name|boolean
name|blobExist
decl_stmt|;
comment|/**    * When the blob exist, to to prevent concurrent write we take a lease.    * Taking a lease is not necessary for new blobs.    */
DECL|field|lease
specifier|private
name|SelfRenewingLease
name|lease
init|=
literal|null
decl_stmt|;
comment|/**    * The support for process of compaction is optional.    */
DECL|field|compactionEnabled
specifier|private
specifier|final
name|boolean
name|compactionEnabled
decl_stmt|;
comment|/**    * The number of blocks above each block compaction is triggered.    */
DECL|field|DEFAULT_ACTIVATE_COMPACTION_BLOCK_COUNT
specifier|private
specifier|static
specifier|final
name|int
name|DEFAULT_ACTIVATE_COMPACTION_BLOCK_COUNT
init|=
literal|32000
decl_stmt|;
comment|/**    * The number of blocks above each block compaction is triggered.    */
DECL|field|activateCompactionBlockCount
specifier|private
name|int
name|activateCompactionBlockCount
init|=
name|DEFAULT_ACTIVATE_COMPACTION_BLOCK_COUNT
decl_stmt|;
comment|/**    * The size of the output buffer. Writes store the data in outBuffer until    * either the size is above maxBlockSize or hflush/hsync is called.    */
DECL|field|maxBlockSize
specifier|private
specifier|final
name|AtomicInteger
name|maxBlockSize
decl_stmt|;
comment|/**    * The current buffer where writes are stored.    */
DECL|field|outBuffer
specifier|private
name|ByteBuffer
name|outBuffer
decl_stmt|;
comment|/**    * The size of the blob that has been successfully stored in the Azure Blob    * service.    */
DECL|field|committedBlobLength
specifier|private
specifier|final
name|AtomicLong
name|committedBlobLength
init|=
operator|new
name|AtomicLong
argument_list|(
literal|0
argument_list|)
decl_stmt|;
comment|/**    * Position of last block in the blob.    */
DECL|field|blobLength
specifier|private
specifier|volatile
name|long
name|blobLength
init|=
literal|0
decl_stmt|;
comment|/**    * Minutes waiting before the close operation timed out.    */
DECL|field|CLOSE_UPLOAD_DELAY
specifier|private
specifier|static
specifier|final
name|int
name|CLOSE_UPLOAD_DELAY
init|=
literal|10
decl_stmt|;
comment|/**    * Keep alive time for the threadpool.    */
DECL|field|THREADPOOL_KEEP_ALIVE
specifier|private
specifier|static
specifier|final
name|int
name|THREADPOOL_KEEP_ALIVE
init|=
literal|30
decl_stmt|;
comment|/**    * Azure Block Blob used for the stream.    */
DECL|field|blob
specifier|private
specifier|final
name|CloudBlockBlobWrapper
name|blob
decl_stmt|;
comment|/**    * Azure Storage operation context.    */
DECL|field|opContext
specifier|private
specifier|final
name|OperationContext
name|opContext
decl_stmt|;
comment|/**    * Commands send from client calls to the background thread pool.    */
DECL|class|UploadCommand
specifier|private
specifier|abstract
class|class
name|UploadCommand
block|{
comment|// the blob offset for the command
DECL|field|commandBlobOffset
specifier|private
specifier|final
name|long
name|commandBlobOffset
decl_stmt|;
comment|// command completion latch
DECL|field|completed
specifier|private
specifier|final
name|CountDownLatch
name|completed
init|=
operator|new
name|CountDownLatch
argument_list|(
literal|1
argument_list|)
decl_stmt|;
DECL|method|UploadCommand (long offset)
name|UploadCommand
parameter_list|(
name|long
name|offset
parameter_list|)
block|{
name|this
operator|.
name|commandBlobOffset
operator|=
name|offset
expr_stmt|;
block|}
DECL|method|getCommandBlobOffset ()
name|long
name|getCommandBlobOffset
parameter_list|()
block|{
return|return
name|commandBlobOffset
return|;
block|}
DECL|method|await ()
name|void
name|await
parameter_list|()
throws|throws
name|InterruptedException
block|{
name|completed
operator|.
name|await
argument_list|()
expr_stmt|;
block|}
DECL|method|awaitAsDependent ()
name|void
name|awaitAsDependent
parameter_list|()
throws|throws
name|InterruptedException
block|{
name|await
argument_list|()
expr_stmt|;
block|}
DECL|method|setCompleted ()
name|void
name|setCompleted
parameter_list|()
block|{
name|completed
operator|.
name|countDown
argument_list|()
expr_stmt|;
block|}
DECL|method|execute ()
name|void
name|execute
parameter_list|()
throws|throws
name|InterruptedException
throws|,
name|IOException
block|{}
DECL|method|dump ()
name|void
name|dump
parameter_list|()
block|{}
block|}
comment|/**    * The list of recent commands. Before block list is committed, all the block    * listed in the list must be uploaded. activeBlockCommands is used for    * enumerating the blocks and waiting on the latch until the block is    * uploaded.    */
DECL|field|activeBlockCommands
specifier|private
specifier|final
name|ConcurrentLinkedQueue
argument_list|<
name|UploadCommand
argument_list|>
name|activeBlockCommands
init|=
operator|new
name|ConcurrentLinkedQueue
argument_list|<>
argument_list|()
decl_stmt|;
comment|/**    * Variable to track if the stream has been closed.    */
DECL|field|closed
specifier|private
specifier|volatile
name|boolean
name|closed
init|=
literal|false
decl_stmt|;
comment|/**    *  First IOException encountered.    */
DECL|field|firstError
specifier|private
specifier|final
name|AtomicReference
argument_list|<
name|IOException
argument_list|>
name|firstError
init|=
operator|new
name|AtomicReference
argument_list|<>
argument_list|()
decl_stmt|;
comment|/**    * Flag set when the first error has been thrown.    */
DECL|field|firstErrorThrown
specifier|private
name|boolean
name|firstErrorThrown
init|=
literal|false
decl_stmt|;
comment|/**    * Semaphore for serializing block uploads with NativeAzureFileSystem.    *    * The semaphore starts with number of permits equal to the number of block    * upload threads. Each block upload thread needs one permit to start the    * upload. The put block list acquires all the permits before the block list    * is committed.    */
DECL|field|uploadingSemaphore
specifier|private
specifier|final
name|Semaphore
name|uploadingSemaphore
init|=
operator|new
name|Semaphore
argument_list|(
name|MAX_NUMBER_THREADS_IN_THREAD_POOL
argument_list|,
literal|true
argument_list|)
decl_stmt|;
comment|/**    * Queue storing buffers with the size of the Azure block ready for    * reuse. The pool allows reusing the blocks instead of allocating new    * blocks. After the data is sent to the service, the buffer is returned    * back to the queue    */
DECL|field|poolReadyByteBuffers
specifier|private
specifier|final
name|ElasticByteBufferPool
name|poolReadyByteBuffers
init|=
operator|new
name|ElasticByteBufferPool
argument_list|()
decl_stmt|;
comment|/**    * The blob's block list.    */
DECL|field|blockEntries
specifier|private
specifier|final
name|List
argument_list|<
name|BlockEntry
argument_list|>
name|blockEntries
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|DEFAULT_CAPACITY_BLOCK_ENTRIES
argument_list|)
decl_stmt|;
DECL|field|DEFAULT_CAPACITY_BLOCK_ENTRIES
specifier|private
specifier|static
specifier|final
name|int
name|DEFAULT_CAPACITY_BLOCK_ENTRIES
init|=
literal|1024
decl_stmt|;
comment|/**    * The uncommitted blob's block list.    */
DECL|field|uncommittedBlockEntries
specifier|private
specifier|final
name|ConcurrentLinkedDeque
argument_list|<
name|BlockEntry
argument_list|>
name|uncommittedBlockEntries
init|=
operator|new
name|ConcurrentLinkedDeque
argument_list|<>
argument_list|()
decl_stmt|;
comment|/**    * Variable to hold the next block id to be used for azure storage blocks.    */
DECL|field|UNSET_BLOCKS_COUNT
specifier|private
specifier|static
specifier|final
name|int
name|UNSET_BLOCKS_COUNT
init|=
operator|-
literal|1
decl_stmt|;
DECL|field|nextBlockCount
specifier|private
name|long
name|nextBlockCount
init|=
name|UNSET_BLOCKS_COUNT
decl_stmt|;
comment|/**    * Variable to hold the block id prefix to be used for azure storage blocks.    */
DECL|field|blockIdPrefix
specifier|private
name|String
name|blockIdPrefix
init|=
literal|null
decl_stmt|;
comment|/**    *  Maximum number of threads in block upload thread pool.    */
DECL|field|MAX_NUMBER_THREADS_IN_THREAD_POOL
specifier|private
specifier|static
specifier|final
name|int
name|MAX_NUMBER_THREADS_IN_THREAD_POOL
init|=
literal|4
decl_stmt|;
comment|/**    * Number of times block upload needs is retried.    */
DECL|field|MAX_BLOCK_UPLOAD_RETRIES
specifier|private
specifier|static
specifier|final
name|int
name|MAX_BLOCK_UPLOAD_RETRIES
init|=
literal|3
decl_stmt|;
comment|/**    * Wait time between block upload retries in milliseconds.    */
DECL|field|BLOCK_UPLOAD_RETRY_INTERVAL
specifier|private
specifier|static
specifier|final
name|int
name|BLOCK_UPLOAD_RETRY_INTERVAL
init|=
literal|1000
decl_stmt|;
comment|/**    * Logger.    */
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|BlockBlobAppendStream
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/**    * The absolute maximum of blocks for a blob. It includes committed and    * temporary blocks.    */
DECL|field|MAX_BLOCK_COUNT
specifier|private
specifier|static
specifier|final
name|int
name|MAX_BLOCK_COUNT
init|=
literal|100000
decl_stmt|;
comment|/**    * The upload thread pool executor.    */
DECL|field|ioThreadPool
specifier|private
name|ThreadPoolExecutor
name|ioThreadPool
decl_stmt|;
comment|/**    * Azure Storage access conditions for the blob.    */
DECL|field|accessCondition
specifier|private
specifier|final
name|AccessCondition
name|accessCondition
init|=
operator|new
name|AccessCondition
argument_list|()
decl_stmt|;
comment|/**    * Atomic integer to provide thread id for thread names for uploader threads.    */
DECL|field|threadSequenceNumber
specifier|private
specifier|final
name|AtomicInteger
name|threadSequenceNumber
decl_stmt|;
comment|/**    * Prefix to be used for thread names for uploader threads.    */
DECL|field|THREAD_ID_PREFIX
specifier|private
specifier|static
specifier|final
name|String
name|THREAD_ID_PREFIX
init|=
literal|"append-blockblob"
decl_stmt|;
comment|/**    * BlockBlobAppendStream constructor.    *    * @param blob    *          Azure Block Blob    * @param aKey    *          blob's name    * @param bufferSize    *          the maximum size of a blob block.    * @param compactionEnabled    *          is the compaction process enabled for this blob    * @param opContext    *          Azure Store operation context for the blob    * @throws IOException    *           if an I/O error occurs. In particular, an IOException may be    *           thrown if the output stream cannot be used for append operations    */
DECL|method|BlockBlobAppendStream (final CloudBlockBlobWrapper blob, final String aKey, final int bufferSize, final boolean compactionEnabled, final OperationContext opContext)
specifier|public
name|BlockBlobAppendStream
parameter_list|(
specifier|final
name|CloudBlockBlobWrapper
name|blob
parameter_list|,
specifier|final
name|String
name|aKey
parameter_list|,
specifier|final
name|int
name|bufferSize
parameter_list|,
specifier|final
name|boolean
name|compactionEnabled
parameter_list|,
specifier|final
name|OperationContext
name|opContext
parameter_list|)
throws|throws
name|IOException
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|StringUtils
operator|.
name|isNotEmpty
argument_list|(
name|aKey
argument_list|)
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|bufferSize
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|this
operator|.
name|blob
operator|=
name|blob
expr_stmt|;
name|this
operator|.
name|opContext
operator|=
name|opContext
expr_stmt|;
name|this
operator|.
name|key
operator|=
name|aKey
expr_stmt|;
name|this
operator|.
name|maxBlockSize
operator|=
operator|new
name|AtomicInteger
argument_list|(
name|bufferSize
argument_list|)
expr_stmt|;
name|this
operator|.
name|threadSequenceNumber
operator|=
operator|new
name|AtomicInteger
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|this
operator|.
name|blockIdPrefix
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|compactionEnabled
operator|=
name|compactionEnabled
expr_stmt|;
name|this
operator|.
name|blobExist
operator|=
literal|true
expr_stmt|;
name|this
operator|.
name|outBuffer
operator|=
name|poolReadyByteBuffers
operator|.
name|getBuffer
argument_list|(
literal|false
argument_list|,
name|maxBlockSize
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
try|try
block|{
comment|// download the block list
name|blockEntries
operator|.
name|addAll
argument_list|(
name|blob
operator|.
name|downloadBlockList
argument_list|(
name|BlockListingFilter
operator|.
name|COMMITTED
argument_list|,
operator|new
name|BlobRequestOptions
argument_list|()
argument_list|,
name|opContext
argument_list|)
argument_list|)
expr_stmt|;
name|blobLength
operator|=
name|blob
operator|.
name|getProperties
argument_list|()
operator|.
name|getLength
argument_list|()
expr_stmt|;
name|committedBlobLength
operator|.
name|set
argument_list|(
name|blobLength
argument_list|)
expr_stmt|;
comment|// Acquiring lease on the blob.
name|lease
operator|=
operator|new
name|SelfRenewingLease
argument_list|(
name|blob
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|accessCondition
operator|.
name|setLeaseID
argument_list|(
name|lease
operator|.
name|getLeaseID
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|StorageException
name|ex
parameter_list|)
block|{
if|if
condition|(
name|ex
operator|.
name|getErrorCode
argument_list|()
operator|.
name|equals
argument_list|(
name|StorageErrorCodeStrings
operator|.
name|BLOB_NOT_FOUND
argument_list|)
condition|)
block|{
name|blobExist
operator|=
literal|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ex
operator|.
name|getErrorCode
argument_list|()
operator|.
name|equals
argument_list|(
name|StorageErrorCodeStrings
operator|.
name|LEASE_ALREADY_PRESENT
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|AzureException
argument_list|(
literal|"Unable to set Append lease on the Blob: "
operator|+
name|ex
argument_list|,
name|ex
argument_list|)
throw|;
block|}
else|else
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Encountered storage exception."
operator|+
literal|" StorageException : {} ErrorCode : {}"
argument_list|,
name|ex
argument_list|,
name|ex
operator|.
name|getErrorCode
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|AzureException
argument_list|(
name|ex
argument_list|)
throw|;
block|}
block|}
name|setBlocksCountAndBlockIdPrefix
argument_list|(
name|blockEntries
argument_list|)
expr_stmt|;
name|this
operator|.
name|ioThreadPool
operator|=
operator|new
name|ThreadPoolExecutor
argument_list|(
name|MAX_NUMBER_THREADS_IN_THREAD_POOL
argument_list|,
name|MAX_NUMBER_THREADS_IN_THREAD_POOL
argument_list|,
name|THREADPOOL_KEEP_ALIVE
argument_list|,
name|TimeUnit
operator|.
name|SECONDS
argument_list|,
operator|new
name|LinkedBlockingQueue
argument_list|<>
argument_list|()
argument_list|,
operator|new
name|UploaderThreadFactory
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Set payload size of the stream.    * It is intended to be used for unit testing purposes only.    */
annotation|@
name|VisibleForTesting
DECL|method|setMaxBlockSize (int size)
specifier|synchronized
name|void
name|setMaxBlockSize
parameter_list|(
name|int
name|size
parameter_list|)
block|{
name|maxBlockSize
operator|.
name|set
argument_list|(
name|size
argument_list|)
expr_stmt|;
comment|// it is for testing only so we can abandon the previously allocated
comment|// payload
name|this
operator|.
name|outBuffer
operator|=
name|ByteBuffer
operator|.
name|allocate
argument_list|(
name|maxBlockSize
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Set compaction parameters.    * It is intended to be used for unit testing purposes only.    */
annotation|@
name|VisibleForTesting
DECL|method|setCompactionBlockCount (int activationCount)
name|void
name|setCompactionBlockCount
parameter_list|(
name|int
name|activationCount
parameter_list|)
block|{
name|activateCompactionBlockCount
operator|=
name|activationCount
expr_stmt|;
block|}
comment|/**    * Get the list of block entries. It is used for testing purposes only.    * @return List of block entries.    */
annotation|@
name|VisibleForTesting
DECL|method|getBlockList ()
name|List
argument_list|<
name|BlockEntry
argument_list|>
name|getBlockList
parameter_list|()
throws|throws
name|StorageException
throws|,
name|IOException
block|{
return|return
name|blob
operator|.
name|downloadBlockList
argument_list|(
name|BlockListingFilter
operator|.
name|COMMITTED
argument_list|,
operator|new
name|BlobRequestOptions
argument_list|()
argument_list|,
name|opContext
argument_list|)
return|;
block|}
comment|/**    * Writes the specified byte to this output stream. The general contract for    * write is that one byte is written to the output stream. The byte to be    * written is the eight low-order bits of the argument b. The 24 high-order    * bits of b are ignored.    *    * @param byteVal    *          the byteValue to write.    * @throws IOException    *           if an I/O error occurs. In particular, an IOException may be    *           thrown if the output stream has been closed.    */
annotation|@
name|Override
DECL|method|write (final int byteVal)
specifier|public
name|void
name|write
parameter_list|(
specifier|final
name|int
name|byteVal
parameter_list|)
throws|throws
name|IOException
block|{
name|write
argument_list|(
operator|new
name|byte
index|[]
block|{
call|(
name|byte
call|)
argument_list|(
name|byteVal
operator|&
literal|0xFF
argument_list|)
block|}
argument_list|)
expr_stmt|;
block|}
comment|/**    * Writes length bytes from the specified byte array starting at offset to    * this output stream.    *    * @param data    *          the byte array to write.    * @param offset    *          the start offset in the data.    * @param length    *          the number of bytes to write.    * @throws IOException    *           if an I/O error occurs. In particular, an IOException may be    *           thrown if the output stream has been closed.    */
annotation|@
name|Override
DECL|method|write (final byte[] data, int offset, int length)
specifier|public
specifier|synchronized
name|void
name|write
parameter_list|(
specifier|final
name|byte
index|[]
name|data
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
throws|throws
name|IOException
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|data
operator|!=
literal|null
argument_list|,
literal|"null data"
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|<
literal|0
operator|||
name|length
argument_list|<
literal|0
operator|||
name|length
argument_list|>
name|data
operator|.
name|length
operator|-
name|offset
condition|)
block|{
throw|throw
operator|new
name|IndexOutOfBoundsException
argument_list|()
throw|;
block|}
if|if
condition|(
name|closed
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|FSExceptionMessages
operator|.
name|STREAM_IS_CLOSED
argument_list|)
throw|;
block|}
while|while
condition|(
name|outBuffer
operator|.
name|remaining
argument_list|()
operator|<
name|length
condition|)
block|{
name|int
name|remaining
init|=
name|outBuffer
operator|.
name|remaining
argument_list|()
decl_stmt|;
name|outBuffer
operator|.
name|put
argument_list|(
name|data
argument_list|,
name|offset
argument_list|,
name|remaining
argument_list|)
expr_stmt|;
comment|// upload payload to azure storage
name|addBlockUploadCommand
argument_list|()
expr_stmt|;
name|offset
operator|+=
name|remaining
expr_stmt|;
name|length
operator|-=
name|remaining
expr_stmt|;
block|}
name|outBuffer
operator|.
name|put
argument_list|(
name|data
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
comment|/**    * Flushes this output stream and forces any buffered output bytes to be    * written out. If any data remains in the payload it is committed to the    * service. Data is queued for writing and forced out to the service    * before the call returns.    */
annotation|@
name|Override
DECL|method|flush ()
specifier|public
name|void
name|flush
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|closed
condition|)
block|{
comment|// calling close() after the stream is closed starts with call to flush()
return|return;
block|}
name|addBlockUploadCommand
argument_list|()
expr_stmt|;
if|if
condition|(
name|committedBlobLength
operator|.
name|get
argument_list|()
operator|<
name|blobLength
condition|)
block|{
try|try
block|{
comment|// wait until the block list is committed
name|addFlushCommand
argument_list|()
operator|.
name|await
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Force all data in the output stream to be written to Azure storage.    * Wait to return until this is complete.    */
annotation|@
name|Override
DECL|method|hsync ()
specifier|public
name|void
name|hsync
parameter_list|()
throws|throws
name|IOException
block|{
comment|// when block compaction is disabled, hsync is empty function
if|if
condition|(
name|compactionEnabled
condition|)
block|{
name|flush
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Force all data in the output stream to be written to Azure storage.    * Wait to return until this is complete.    */
annotation|@
name|Override
DECL|method|hflush ()
specifier|public
name|void
name|hflush
parameter_list|()
throws|throws
name|IOException
block|{
comment|// when block compaction is disabled, hflush is empty function
if|if
condition|(
name|compactionEnabled
condition|)
block|{
name|flush
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * The Synchronization capabilities of this stream depend upon the compaction    * policy.    * @param capability string to query the stream support for.    * @return true for hsync and hflush when compaction is enabled.    */
annotation|@
name|Override
DECL|method|hasCapability (String capability)
specifier|public
name|boolean
name|hasCapability
parameter_list|(
name|String
name|capability
parameter_list|)
block|{
if|if
condition|(
operator|!
name|compactionEnabled
condition|)
block|{
return|return
literal|false
return|;
block|}
switch|switch
condition|(
name|capability
operator|.
name|toLowerCase
argument_list|(
name|Locale
operator|.
name|ENGLISH
argument_list|)
condition|)
block|{
case|case
name|StreamCapabilities
operator|.
name|HSYNC
case|:
case|case
name|StreamCapabilities
operator|.
name|HFLUSH
case|:
return|return
literal|true
return|;
default|default:
return|return
literal|false
return|;
block|}
block|}
comment|/**    * Force all data in the output stream to be written to Azure storage.    * Wait to return until this is complete. Close the access to the stream and    * shutdown the upload thread pool.    * If the blob was created, its lease will be released.    * Any error encountered caught in threads and stored will be rethrown here    * after cleanup.    */
annotation|@
name|Override
DECL|method|close ()
specifier|public
specifier|synchronized
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"close {} "
argument_list|,
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|closed
condition|)
block|{
return|return;
block|}
comment|// Upload the last block regardless of compactionEnabled flag
name|flush
argument_list|()
expr_stmt|;
comment|// Initiates an orderly shutdown in which previously submitted tasks are
comment|// executed.
name|ioThreadPool
operator|.
name|shutdown
argument_list|()
expr_stmt|;
try|try
block|{
comment|// wait up to CLOSE_UPLOAD_DELAY minutes to upload all the blocks
if|if
condition|(
operator|!
name|ioThreadPool
operator|.
name|awaitTermination
argument_list|(
name|CLOSE_UPLOAD_DELAY
argument_list|,
name|TimeUnit
operator|.
name|MINUTES
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Time out occurred while close() is waiting for IO request to"
operator|+
literal|" finish in append"
operator|+
literal|" for blob : {}"
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|NativeAzureFileSystemHelper
operator|.
name|logAllLiveStackTraces
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|AzureException
argument_list|(
literal|"Timed out waiting for IO requests to finish"
argument_list|)
throw|;
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ex
parameter_list|)
block|{
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
comment|// release the lease
if|if
condition|(
name|firstError
operator|.
name|get
argument_list|()
operator|==
literal|null
operator|&&
name|blobExist
condition|)
block|{
try|try
block|{
name|lease
operator|.
name|free
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|StorageException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Lease free update blob {} encountered Storage Exception:"
operator|+
literal|" {} Error Code : {}"
argument_list|,
name|key
argument_list|,
name|ex
argument_list|,
name|ex
operator|.
name|getErrorCode
argument_list|()
argument_list|)
expr_stmt|;
name|maybeSetFirstError
argument_list|(
operator|new
name|AzureException
argument_list|(
name|ex
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|closed
operator|=
literal|true
expr_stmt|;
comment|// finally, throw the first exception raised if it has not
comment|// been thrown elsewhere.
if|if
condition|(
name|firstError
operator|.
name|get
argument_list|()
operator|!=
literal|null
operator|&&
operator|!
name|firstErrorThrown
condition|)
block|{
throw|throw
name|firstError
operator|.
name|get
argument_list|()
throw|;
block|}
block|}
comment|/**    * Helper method used to generate the blockIDs. The algorithm used is similar    * to the Azure storage SDK.    */
DECL|method|setBlocksCountAndBlockIdPrefix (List<BlockEntry> blockEntries)
specifier|private
name|void
name|setBlocksCountAndBlockIdPrefix
parameter_list|(
name|List
argument_list|<
name|BlockEntry
argument_list|>
name|blockEntries
parameter_list|)
block|{
if|if
condition|(
name|nextBlockCount
operator|==
name|UNSET_BLOCKS_COUNT
operator|&&
name|blockIdPrefix
operator|==
literal|null
condition|)
block|{
name|Random
name|sequenceGenerator
init|=
operator|new
name|Random
argument_list|()
decl_stmt|;
name|String
name|blockZeroBlockId
init|=
operator|(
operator|!
name|blockEntries
operator|.
name|isEmpty
argument_list|()
operator|)
condition|?
name|blockEntries
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getId
argument_list|()
else|:
literal|""
decl_stmt|;
name|String
name|prefix
init|=
name|UUID
operator|.
name|randomUUID
argument_list|()
operator|.
name|toString
argument_list|()
operator|+
literal|"-"
decl_stmt|;
name|String
name|sampleNewerVersionBlockId
init|=
name|generateNewerVersionBlockId
argument_list|(
name|prefix
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|blockEntries
operator|.
name|isEmpty
argument_list|()
operator|&&
name|blockZeroBlockId
operator|.
name|length
argument_list|()
operator|<
name|sampleNewerVersionBlockId
operator|.
name|length
argument_list|()
condition|)
block|{
comment|// If blob has already been created with 2.2.0, append subsequent blocks
comment|// with older version (2.2.0) blockId compute nextBlockCount, the way it
comment|// was done before; and don't use blockIdPrefix
name|this
operator|.
name|blockIdPrefix
operator|=
literal|""
expr_stmt|;
name|nextBlockCount
operator|=
call|(
name|long
call|)
argument_list|(
name|sequenceGenerator
operator|.
name|nextInt
argument_list|(
name|Integer
operator|.
name|MAX_VALUE
argument_list|)
argument_list|)
operator|+
name|sequenceGenerator
operator|.
name|nextInt
argument_list|(
name|Integer
operator|.
name|MAX_VALUE
operator|-
name|MAX_BLOCK_COUNT
argument_list|)
expr_stmt|;
name|nextBlockCount
operator|+=
name|blockEntries
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// If there are no existing blocks, create the first block with newer
comment|// version (4.2.0) blockId. If blob has already been created with 4.2.0,
comment|// append subsequent blocks with newer version (4.2.0) blockId
name|this
operator|.
name|blockIdPrefix
operator|=
name|prefix
expr_stmt|;
name|nextBlockCount
operator|=
name|blockEntries
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Helper method that generates the next block id for uploading a block to    * azure storage.    * @return String representing the block ID generated.    * @throws IOException if the stream is in invalid state    */
DECL|method|generateBlockId ()
specifier|private
name|String
name|generateBlockId
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|nextBlockCount
operator|==
name|UNSET_BLOCKS_COUNT
operator|||
name|blockIdPrefix
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|AzureException
argument_list|(
literal|"Append Stream in invalid state. nextBlockCount not set correctly"
argument_list|)
throw|;
block|}
return|return
operator|(
operator|!
name|blockIdPrefix
operator|.
name|isEmpty
argument_list|()
operator|)
condition|?
name|generateNewerVersionBlockId
argument_list|(
name|blockIdPrefix
argument_list|,
name|nextBlockCount
operator|++
argument_list|)
else|:
name|generateOlderVersionBlockId
argument_list|(
name|nextBlockCount
operator|++
argument_list|)
return|;
block|}
comment|/**    * Helper method that generates an older (2.2.0) version blockId.    * @return String representing the block ID generated.    */
DECL|method|generateOlderVersionBlockId (long id)
specifier|private
name|String
name|generateOlderVersionBlockId
parameter_list|(
name|long
name|id
parameter_list|)
block|{
name|byte
index|[]
name|blockIdInBytes
init|=
operator|new
name|byte
index|[
literal|8
index|]
decl_stmt|;
for|for
control|(
name|int
name|m
init|=
literal|0
init|;
name|m
operator|<
literal|8
condition|;
name|m
operator|++
control|)
block|{
name|blockIdInBytes
index|[
literal|7
operator|-
name|m
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
operator|(
name|id
operator|>>
operator|(
literal|8
operator|*
name|m
operator|)
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|String
argument_list|(
name|Base64
operator|.
name|encodeBase64
argument_list|(
name|blockIdInBytes
argument_list|)
argument_list|,
name|StandardCharsets
operator|.
name|UTF_8
argument_list|)
return|;
block|}
comment|/**    * Helper method that generates an newer (4.2.0) version blockId.    * @return String representing the block ID generated.    */
DECL|method|generateNewerVersionBlockId (String prefix, long id)
specifier|private
name|String
name|generateNewerVersionBlockId
parameter_list|(
name|String
name|prefix
parameter_list|,
name|long
name|id
parameter_list|)
block|{
name|String
name|blockIdSuffix
init|=
name|String
operator|.
name|format
argument_list|(
literal|"%06d"
argument_list|,
name|id
argument_list|)
decl_stmt|;
name|byte
index|[]
name|blockIdInBytes
init|=
operator|(
name|prefix
operator|+
name|blockIdSuffix
operator|)
operator|.
name|getBytes
argument_list|(
name|StandardCharsets
operator|.
name|UTF_8
argument_list|)
decl_stmt|;
return|return
operator|new
name|String
argument_list|(
name|Base64
operator|.
name|encodeBase64
argument_list|(
name|blockIdInBytes
argument_list|)
argument_list|,
name|StandardCharsets
operator|.
name|UTF_8
argument_list|)
return|;
block|}
comment|/**    * This is shared between upload block Runnable and CommitBlockList. The    * method captures retry logic    * @param blockId block name    * @param dataPayload block content    */
DECL|method|writeBlockRequestInternal (String blockId, ByteBuffer dataPayload, boolean bufferPoolBuffer)
specifier|private
name|void
name|writeBlockRequestInternal
parameter_list|(
name|String
name|blockId
parameter_list|,
name|ByteBuffer
name|dataPayload
parameter_list|,
name|boolean
name|bufferPoolBuffer
parameter_list|)
block|{
name|IOException
name|lastLocalException
init|=
literal|null
decl_stmt|;
name|int
name|uploadRetryAttempts
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|uploadRetryAttempts
operator|<
name|MAX_BLOCK_UPLOAD_RETRIES
condition|)
block|{
try|try
block|{
name|long
name|startTime
init|=
name|System
operator|.
name|nanoTime
argument_list|()
decl_stmt|;
name|blob
operator|.
name|uploadBlock
argument_list|(
name|blockId
argument_list|,
name|accessCondition
argument_list|,
operator|new
name|ByteArrayInputStream
argument_list|(
name|dataPayload
operator|.
name|array
argument_list|()
argument_list|)
argument_list|,
name|dataPayload
operator|.
name|position
argument_list|()
argument_list|,
operator|new
name|BlobRequestOptions
argument_list|()
argument_list|,
name|opContext
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"upload block finished for {} ms. block {} "
argument_list|,
name|TimeUnit
operator|.
name|NANOSECONDS
operator|.
name|toMillis
argument_list|(
name|System
operator|.
name|nanoTime
argument_list|()
operator|-
name|startTime
argument_list|)
argument_list|,
name|blockId
argument_list|)
expr_stmt|;
break|break;
block|}
catch|catch
parameter_list|(
name|Exception
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Encountered exception during uploading block for Blob {}"
operator|+
literal|" Exception : {}"
argument_list|,
name|key
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
name|uploadRetryAttempts
operator|++
expr_stmt|;
name|lastLocalException
operator|=
operator|new
name|AzureException
argument_list|(
literal|"Encountered Exception while uploading block: "
operator|+
name|ioe
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|BLOCK_UPLOAD_RETRY_INTERVAL
operator|*
operator|(
name|uploadRetryAttempts
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|bufferPoolBuffer
condition|)
block|{
name|poolReadyByteBuffers
operator|.
name|putBuffer
argument_list|(
name|dataPayload
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|uploadRetryAttempts
operator|==
name|MAX_BLOCK_UPLOAD_RETRIES
condition|)
block|{
name|maybeSetFirstError
argument_list|(
name|lastLocalException
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Set {@link #firstError} to the exception if it is not already set.    * @param exception exception to save    */
DECL|method|maybeSetFirstError (IOException exception)
specifier|private
name|void
name|maybeSetFirstError
parameter_list|(
name|IOException
name|exception
parameter_list|)
block|{
name|firstError
operator|.
name|compareAndSet
argument_list|(
literal|null
argument_list|,
name|exception
argument_list|)
expr_stmt|;
block|}
comment|/**    * Throw the first error caught if it has not been raised already    * @throws IOException if one is caught and needs to be thrown.    */
DECL|method|maybeThrowFirstError ()
specifier|private
name|void
name|maybeThrowFirstError
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|firstError
operator|.
name|get
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|firstErrorThrown
operator|=
literal|true
expr_stmt|;
throw|throw
name|firstError
operator|.
name|get
argument_list|()
throw|;
block|}
block|}
comment|/**    * Write block list. The method captures retry logic    */
DECL|method|writeBlockListRequestInternal ()
specifier|private
name|void
name|writeBlockListRequestInternal
parameter_list|()
block|{
name|IOException
name|lastLocalException
init|=
literal|null
decl_stmt|;
name|int
name|uploadRetryAttempts
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|uploadRetryAttempts
operator|<
name|MAX_BLOCK_UPLOAD_RETRIES
condition|)
block|{
try|try
block|{
name|long
name|startTime
init|=
name|System
operator|.
name|nanoTime
argument_list|()
decl_stmt|;
name|blob
operator|.
name|commitBlockList
argument_list|(
name|blockEntries
argument_list|,
name|accessCondition
argument_list|,
operator|new
name|BlobRequestOptions
argument_list|()
argument_list|,
name|opContext
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Upload block list took {} ms for blob {} "
argument_list|,
name|TimeUnit
operator|.
name|NANOSECONDS
operator|.
name|toMillis
argument_list|(
name|System
operator|.
name|nanoTime
argument_list|()
operator|-
name|startTime
argument_list|)
argument_list|,
name|key
argument_list|)
expr_stmt|;
break|break;
block|}
catch|catch
parameter_list|(
name|Exception
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Encountered exception during uploading block for Blob {}"
operator|+
literal|" Exception : {}"
argument_list|,
name|key
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
name|uploadRetryAttempts
operator|++
expr_stmt|;
name|lastLocalException
operator|=
operator|new
name|AzureException
argument_list|(
literal|"Encountered Exception while uploading block: "
operator|+
name|ioe
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|BLOCK_UPLOAD_RETRY_INTERVAL
operator|*
operator|(
name|uploadRetryAttempts
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|uploadRetryAttempts
operator|==
name|MAX_BLOCK_UPLOAD_RETRIES
condition|)
block|{
name|maybeSetFirstError
argument_list|(
name|lastLocalException
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * A ThreadFactory that creates uploader thread with    * meaningful names helpful for debugging purposes.    */
DECL|class|UploaderThreadFactory
class|class
name|UploaderThreadFactory
implements|implements
name|ThreadFactory
block|{
annotation|@
name|Override
DECL|method|newThread (Runnable r)
specifier|public
name|Thread
name|newThread
parameter_list|(
name|Runnable
name|r
parameter_list|)
block|{
name|Thread
name|t
init|=
operator|new
name|Thread
argument_list|(
name|r
argument_list|)
decl_stmt|;
name|t
operator|.
name|setName
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"%s-%d"
argument_list|,
name|THREAD_ID_PREFIX
argument_list|,
name|threadSequenceNumber
operator|.
name|getAndIncrement
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
block|}
comment|/**    * Upload block commands.    */
DECL|class|UploadBlockCommand
specifier|private
class|class
name|UploadBlockCommand
extends|extends
name|UploadCommand
block|{
comment|// the block content for upload
DECL|field|payload
specifier|private
specifier|final
name|ByteBuffer
name|payload
decl_stmt|;
comment|// description of the block
DECL|field|entry
specifier|private
specifier|final
name|BlockEntry
name|entry
decl_stmt|;
DECL|method|UploadBlockCommand (String blockId, ByteBuffer payload)
name|UploadBlockCommand
parameter_list|(
name|String
name|blockId
parameter_list|,
name|ByteBuffer
name|payload
parameter_list|)
block|{
name|super
argument_list|(
name|blobLength
argument_list|)
expr_stmt|;
name|BlockEntry
name|blockEntry
init|=
operator|new
name|BlockEntry
argument_list|(
name|blockId
argument_list|)
decl_stmt|;
name|blockEntry
operator|.
name|setSize
argument_list|(
name|payload
operator|.
name|position
argument_list|()
argument_list|)
expr_stmt|;
name|blockEntry
operator|.
name|setSearchMode
argument_list|(
name|BlockSearchMode
operator|.
name|LATEST
argument_list|)
expr_stmt|;
name|this
operator|.
name|payload
operator|=
name|payload
expr_stmt|;
name|this
operator|.
name|entry
operator|=
name|blockEntry
expr_stmt|;
name|uncommittedBlockEntries
operator|.
name|add
argument_list|(
name|blockEntry
argument_list|)
expr_stmt|;
block|}
comment|/**      * Execute command.      */
DECL|method|execute ()
name|void
name|execute
parameter_list|()
throws|throws
name|InterruptedException
block|{
name|uploadingSemaphore
operator|.
name|acquire
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|writeBlockRequestInternal
argument_list|(
name|entry
operator|.
name|getId
argument_list|()
argument_list|,
name|payload
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|uploadingSemaphore
operator|.
name|release
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
DECL|method|dump ()
name|void
name|dump
parameter_list|()
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"upload block {} size: {} for blob {}"
argument_list|,
name|entry
operator|.
name|getId
argument_list|()
argument_list|,
name|entry
operator|.
name|getSize
argument_list|()
argument_list|,
name|key
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Upload blob block list commands.    */
DECL|class|UploadBlockListCommand
specifier|private
class|class
name|UploadBlockListCommand
extends|extends
name|UploadCommand
block|{
DECL|field|lastBlock
specifier|private
name|BlockEntry
name|lastBlock
init|=
literal|null
decl_stmt|;
DECL|method|UploadBlockListCommand ()
name|UploadBlockListCommand
parameter_list|()
block|{
name|super
argument_list|(
name|blobLength
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|uncommittedBlockEntries
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|lastBlock
operator|=
name|uncommittedBlockEntries
operator|.
name|getLast
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|awaitAsDependent ()
name|void
name|awaitAsDependent
parameter_list|()
throws|throws
name|InterruptedException
block|{
comment|// empty. later commit block does not need to wait previous commit block
comment|// lists.
block|}
DECL|method|dump ()
name|void
name|dump
parameter_list|()
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"commit block list with {} blocks for blob {}"
argument_list|,
name|uncommittedBlockEntries
operator|.
name|size
argument_list|()
argument_list|,
name|key
argument_list|)
expr_stmt|;
block|}
comment|/**      * Execute command.      */
DECL|method|execute ()
specifier|public
name|void
name|execute
parameter_list|()
throws|throws
name|InterruptedException
throws|,
name|IOException
block|{
if|if
condition|(
name|committedBlobLength
operator|.
name|get
argument_list|()
operator|>=
name|getCommandBlobOffset
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"commit already applied for {}"
argument_list|,
name|key
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|lastBlock
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"nothing to commit for {}"
argument_list|,
name|key
argument_list|)
expr_stmt|;
return|return;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"active commands: {} for {}"
argument_list|,
name|activeBlockCommands
operator|.
name|size
argument_list|()
argument_list|,
name|key
argument_list|)
expr_stmt|;
for|for
control|(
name|UploadCommand
name|activeCommand
range|:
name|activeBlockCommands
control|)
block|{
if|if
condition|(
name|activeCommand
operator|.
name|getCommandBlobOffset
argument_list|()
operator|<
name|getCommandBlobOffset
argument_list|()
condition|)
block|{
name|activeCommand
operator|.
name|dump
argument_list|()
expr_stmt|;
name|activeCommand
operator|.
name|awaitAsDependent
argument_list|()
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
block|}
comment|// stop all uploads until the block list is committed
name|uploadingSemaphore
operator|.
name|acquire
argument_list|(
name|MAX_NUMBER_THREADS_IN_THREAD_POOL
argument_list|)
expr_stmt|;
name|BlockEntry
name|uncommittedBlock
decl_stmt|;
do|do
block|{
name|uncommittedBlock
operator|=
name|uncommittedBlockEntries
operator|.
name|poll
argument_list|()
expr_stmt|;
name|blockEntries
operator|.
name|add
argument_list|(
name|uncommittedBlock
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|uncommittedBlock
operator|!=
name|lastBlock
condition|)
do|;
if|if
condition|(
name|blockEntries
operator|.
name|size
argument_list|()
operator|>
name|activateCompactionBlockCount
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Block compaction: activated with {} blocks for {}"
argument_list|,
name|blockEntries
operator|.
name|size
argument_list|()
argument_list|,
name|key
argument_list|)
expr_stmt|;
comment|// Block compaction
name|long
name|startCompaction
init|=
name|System
operator|.
name|nanoTime
argument_list|()
decl_stmt|;
name|blockCompaction
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Block compaction finished for {} ms with {} blocks for {}"
argument_list|,
name|TimeUnit
operator|.
name|NANOSECONDS
operator|.
name|toMillis
argument_list|(
name|System
operator|.
name|nanoTime
argument_list|()
operator|-
name|startCompaction
argument_list|)
argument_list|,
name|blockEntries
operator|.
name|size
argument_list|()
argument_list|,
name|key
argument_list|)
expr_stmt|;
block|}
name|writeBlockListRequestInternal
argument_list|()
expr_stmt|;
name|uploadingSemaphore
operator|.
name|release
argument_list|(
name|MAX_NUMBER_THREADS_IN_THREAD_POOL
argument_list|)
expr_stmt|;
comment|// remove blocks previous commands
for|for
control|(
name|Iterator
argument_list|<
name|UploadCommand
argument_list|>
name|it
init|=
name|activeBlockCommands
operator|.
name|iterator
argument_list|()
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|UploadCommand
name|activeCommand
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|activeCommand
operator|.
name|getCommandBlobOffset
argument_list|()
operator|<=
name|getCommandBlobOffset
argument_list|()
condition|)
block|{
name|it
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
block|}
name|committedBlobLength
operator|.
name|set
argument_list|(
name|getCommandBlobOffset
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**      * Internal output stream with read access to the internal buffer.      */
DECL|class|ByteArrayOutputStreamInternal
specifier|private
class|class
name|ByteArrayOutputStreamInternal
extends|extends
name|ByteArrayOutputStream
block|{
DECL|method|ByteArrayOutputStreamInternal (int size)
name|ByteArrayOutputStreamInternal
parameter_list|(
name|int
name|size
parameter_list|)
block|{
name|super
argument_list|(
name|size
argument_list|)
expr_stmt|;
block|}
DECL|method|getByteArray ()
name|byte
index|[]
name|getByteArray
parameter_list|()
block|{
return|return
name|buf
return|;
block|}
block|}
comment|/**      * Block compaction process.      *      * Block compaction is only enabled when the number of blocks exceeds      * activateCompactionBlockCount. The algorithm searches for the longest      * segment [b..e) where (e-b)> 2&& |b| + |b+1| ... |e-1|< maxBlockSize      * such that size(b1) + size(b2) + ... + size(bn)< maximum-block-size.      * It then downloads the blocks in the sequence, concatenates the data to      * form a single block, uploads this new block, and updates the block      * list to replace the sequence of blocks with the new block.      */
DECL|method|blockCompaction ()
specifier|private
name|void
name|blockCompaction
parameter_list|()
throws|throws
name|IOException
block|{
comment|//current segment [segmentBegin, segmentEnd) and file offset/size of the
comment|// current segment
name|int
name|segmentBegin
init|=
literal|0
decl_stmt|,
name|segmentEnd
init|=
literal|0
decl_stmt|;
name|long
name|segmentOffsetBegin
init|=
literal|0
decl_stmt|,
name|segmentOffsetEnd
init|=
literal|0
decl_stmt|;
comment|//longest segment [maxSegmentBegin, maxSegmentEnd) and file offset/size of
comment|// the longest segment
name|int
name|maxSegmentBegin
init|=
literal|0
decl_stmt|,
name|maxSegmentEnd
init|=
literal|0
decl_stmt|;
name|long
name|maxSegmentOffsetBegin
init|=
literal|0
decl_stmt|,
name|maxSegmentOffsetEnd
init|=
literal|0
decl_stmt|;
for|for
control|(
name|BlockEntry
name|block
range|:
name|blockEntries
control|)
block|{
name|segmentEnd
operator|++
expr_stmt|;
name|segmentOffsetEnd
operator|+=
name|block
operator|.
name|getSize
argument_list|()
expr_stmt|;
if|if
condition|(
name|segmentOffsetEnd
operator|-
name|segmentOffsetBegin
operator|>
name|maxBlockSize
operator|.
name|get
argument_list|()
condition|)
block|{
if|if
condition|(
name|segmentEnd
operator|-
name|segmentBegin
operator|>
literal|2
condition|)
block|{
if|if
condition|(
name|maxSegmentEnd
operator|-
name|maxSegmentBegin
operator|<
name|segmentEnd
operator|-
name|segmentBegin
condition|)
block|{
name|maxSegmentBegin
operator|=
name|segmentBegin
expr_stmt|;
name|maxSegmentEnd
operator|=
name|segmentEnd
expr_stmt|;
name|maxSegmentOffsetBegin
operator|=
name|segmentOffsetBegin
expr_stmt|;
name|maxSegmentOffsetEnd
operator|=
name|segmentOffsetEnd
operator|-
name|block
operator|.
name|getSize
argument_list|()
expr_stmt|;
block|}
block|}
name|segmentBegin
operator|=
name|segmentEnd
operator|-
literal|1
expr_stmt|;
name|segmentOffsetBegin
operator|=
name|segmentOffsetEnd
operator|-
name|block
operator|.
name|getSize
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|maxSegmentEnd
operator|-
name|maxSegmentBegin
operator|>
literal|1
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Block compaction: {} blocks for {}"
argument_list|,
name|maxSegmentEnd
operator|-
name|maxSegmentBegin
argument_list|,
name|key
argument_list|)
expr_stmt|;
comment|// download synchronously all the blocks from the azure storage
name|ByteArrayOutputStreamInternal
name|blockOutputStream
init|=
operator|new
name|ByteArrayOutputStreamInternal
argument_list|(
name|maxBlockSize
operator|.
name|get
argument_list|()
argument_list|)
decl_stmt|;
try|try
block|{
name|long
name|length
init|=
name|maxSegmentOffsetEnd
operator|-
name|maxSegmentOffsetBegin
decl_stmt|;
name|blob
operator|.
name|downloadRange
argument_list|(
name|maxSegmentOffsetBegin
argument_list|,
name|length
argument_list|,
name|blockOutputStream
argument_list|,
operator|new
name|BlobRequestOptions
argument_list|()
argument_list|,
name|opContext
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|StorageException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Storage exception encountered during block compaction phase"
operator|+
literal|" : {} Storage Exception : {} Error Code: {}"
argument_list|,
name|key
argument_list|,
name|ex
argument_list|,
name|ex
operator|.
name|getErrorCode
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|AzureException
argument_list|(
literal|"Encountered Exception while committing append blocks "
operator|+
name|ex
argument_list|,
name|ex
argument_list|)
throw|;
block|}
comment|// upload synchronously new block to the azure storage
name|String
name|blockId
init|=
name|generateBlockId
argument_list|()
decl_stmt|;
name|ByteBuffer
name|byteBuffer
init|=
name|ByteBuffer
operator|.
name|wrap
argument_list|(
name|blockOutputStream
operator|.
name|getByteArray
argument_list|()
argument_list|)
decl_stmt|;
name|byteBuffer
operator|.
name|position
argument_list|(
name|blockOutputStream
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|writeBlockRequestInternal
argument_list|(
name|blockId
argument_list|,
name|byteBuffer
argument_list|,
literal|false
argument_list|)
expr_stmt|;
comment|// replace blocks from the longest segment with new block id
name|blockEntries
operator|.
name|subList
argument_list|(
name|maxSegmentBegin
operator|+
literal|1
argument_list|,
name|maxSegmentEnd
operator|-
literal|1
argument_list|)
operator|.
name|clear
argument_list|()
expr_stmt|;
name|BlockEntry
name|newBlock
init|=
name|blockEntries
operator|.
name|get
argument_list|(
name|maxSegmentBegin
argument_list|)
decl_stmt|;
name|newBlock
operator|.
name|setId
argument_list|(
name|blockId
argument_list|)
expr_stmt|;
name|newBlock
operator|.
name|setSearchMode
argument_list|(
name|BlockSearchMode
operator|.
name|LATEST
argument_list|)
expr_stmt|;
name|newBlock
operator|.
name|setSize
argument_list|(
name|maxSegmentOffsetEnd
operator|-
name|maxSegmentOffsetBegin
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Prepare block upload command and queue the command in thread pool executor.    */
DECL|method|addBlockUploadCommand ()
specifier|private
specifier|synchronized
name|void
name|addBlockUploadCommand
parameter_list|()
throws|throws
name|IOException
block|{
name|maybeThrowFirstError
argument_list|()
expr_stmt|;
if|if
condition|(
name|blobExist
operator|&&
name|lease
operator|.
name|isFreed
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|AzureException
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Attempting to upload a block on blob : %s "
operator|+
literal|" that does not have lease on the Blob. Failing upload"
argument_list|,
name|key
argument_list|)
argument_list|)
throw|;
block|}
name|int
name|blockSize
init|=
name|outBuffer
operator|.
name|position
argument_list|()
decl_stmt|;
if|if
condition|(
name|blockSize
operator|>
literal|0
condition|)
block|{
name|UploadCommand
name|command
init|=
operator|new
name|UploadBlockCommand
argument_list|(
name|generateBlockId
argument_list|()
argument_list|,
name|outBuffer
argument_list|)
decl_stmt|;
name|activeBlockCommands
operator|.
name|add
argument_list|(
name|command
argument_list|)
expr_stmt|;
name|blobLength
operator|+=
name|blockSize
expr_stmt|;
name|outBuffer
operator|=
name|poolReadyByteBuffers
operator|.
name|getBuffer
argument_list|(
literal|false
argument_list|,
name|maxBlockSize
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
name|ioThreadPool
operator|.
name|execute
argument_list|(
operator|new
name|WriteRequest
argument_list|(
name|command
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Prepare block list commit command and queue the command in thread pool    * executor.    */
DECL|method|addFlushCommand ()
specifier|private
specifier|synchronized
name|UploadCommand
name|addFlushCommand
parameter_list|()
throws|throws
name|IOException
block|{
name|maybeThrowFirstError
argument_list|()
expr_stmt|;
if|if
condition|(
name|blobExist
operator|&&
name|lease
operator|.
name|isFreed
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|AzureException
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Attempting to upload block list on blob : %s"
operator|+
literal|" that does not have lease on the Blob. Failing upload"
argument_list|,
name|key
argument_list|)
argument_list|)
throw|;
block|}
name|UploadCommand
name|command
init|=
operator|new
name|UploadBlockListCommand
argument_list|()
decl_stmt|;
name|activeBlockCommands
operator|.
name|add
argument_list|(
name|command
argument_list|)
expr_stmt|;
name|ioThreadPool
operator|.
name|execute
argument_list|(
operator|new
name|WriteRequest
argument_list|(
name|command
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|command
return|;
block|}
comment|/**    * Runnable instance that uploads the block of data to azure storage.    */
DECL|class|WriteRequest
specifier|private
class|class
name|WriteRequest
implements|implements
name|Runnable
block|{
DECL|field|command
specifier|private
specifier|final
name|UploadCommand
name|command
decl_stmt|;
DECL|method|WriteRequest (UploadCommand command)
name|WriteRequest
parameter_list|(
name|UploadCommand
name|command
parameter_list|)
block|{
name|this
operator|.
name|command
operator|=
name|command
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
try|try
block|{
name|command
operator|.
name|dump
argument_list|()
expr_stmt|;
name|long
name|startTime
init|=
name|System
operator|.
name|nanoTime
argument_list|()
decl_stmt|;
name|command
operator|.
name|execute
argument_list|()
expr_stmt|;
name|command
operator|.
name|setCompleted
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"command finished for {} ms"
argument_list|,
name|TimeUnit
operator|.
name|NANOSECONDS
operator|.
name|toMillis
argument_list|(
name|System
operator|.
name|nanoTime
argument_list|()
operator|-
name|startTime
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Encountered exception during execution of command for Blob :"
operator|+
literal|" {} Exception : {}"
argument_list|,
name|key
argument_list|,
name|ex
argument_list|)
expr_stmt|;
name|firstError
operator|.
name|compareAndSet
argument_list|(
literal|null
argument_list|,
operator|new
name|AzureException
argument_list|(
name|ex
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_class

end_unit

