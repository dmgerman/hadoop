begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *<p>  * http://www.apache.org/licenses/LICENSE-2.0  *<p>  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.fs.azurebfs.services
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|azurebfs
operator|.
name|services
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|azurebfs
operator|.
name|contracts
operator|.
name|services
operator|.
name|ReadBufferStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Queue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Stack
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|CountDownLatch
import|;
end_import

begin_comment
comment|/**  * The Read Buffer Manager for Rest AbfsClient  */
end_comment

begin_class
DECL|class|ReadBufferManager
specifier|final
class|class
name|ReadBufferManager
block|{
DECL|field|LOGGER
specifier|private
specifier|static
specifier|final
name|Logger
name|LOGGER
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|ReadBufferManager
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|NUM_BUFFERS
specifier|private
specifier|static
specifier|final
name|int
name|NUM_BUFFERS
init|=
literal|16
decl_stmt|;
DECL|field|BLOCK_SIZE
specifier|private
specifier|static
specifier|final
name|int
name|BLOCK_SIZE
init|=
literal|4
operator|*
literal|1024
operator|*
literal|1024
decl_stmt|;
DECL|field|NUM_THREADS
specifier|private
specifier|static
specifier|final
name|int
name|NUM_THREADS
init|=
literal|8
decl_stmt|;
DECL|field|THRESHOLD_AGE_MILLISECONDS
specifier|private
specifier|static
specifier|final
name|int
name|THRESHOLD_AGE_MILLISECONDS
init|=
literal|3000
decl_stmt|;
comment|// have to see if 3 seconds is a good threshold
DECL|field|threads
specifier|private
name|Thread
index|[]
name|threads
init|=
operator|new
name|Thread
index|[
name|NUM_THREADS
index|]
decl_stmt|;
DECL|field|buffers
specifier|private
name|byte
index|[]
index|[]
name|buffers
decl_stmt|;
comment|// array of byte[] buffers, to hold the data that is read
DECL|field|freeList
specifier|private
name|Stack
argument_list|<
name|Integer
argument_list|>
name|freeList
init|=
operator|new
name|Stack
argument_list|<
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
comment|// indices in buffers[] array that are available
DECL|field|readAheadQueue
specifier|private
name|Queue
argument_list|<
name|ReadBuffer
argument_list|>
name|readAheadQueue
init|=
operator|new
name|LinkedList
argument_list|<
name|ReadBuffer
argument_list|>
argument_list|()
decl_stmt|;
comment|// queue of requests that are not picked up by any worker thread yet
DECL|field|inProgressList
specifier|private
name|LinkedList
argument_list|<
name|ReadBuffer
argument_list|>
name|inProgressList
init|=
operator|new
name|LinkedList
argument_list|<
name|ReadBuffer
argument_list|>
argument_list|()
decl_stmt|;
comment|// requests being processed by worker threads
DECL|field|completedReadList
specifier|private
name|LinkedList
argument_list|<
name|ReadBuffer
argument_list|>
name|completedReadList
init|=
operator|new
name|LinkedList
argument_list|<
name|ReadBuffer
argument_list|>
argument_list|()
decl_stmt|;
comment|// buffers available for reading
DECL|field|BUFFER_MANAGER
specifier|private
specifier|static
specifier|final
name|ReadBufferManager
name|BUFFER_MANAGER
decl_stmt|;
comment|// singleton, initialized in static initialization block
static|static
block|{
name|BUFFER_MANAGER
operator|=
operator|new
name|ReadBufferManager
argument_list|()
expr_stmt|;
name|BUFFER_MANAGER
operator|.
name|init
argument_list|()
expr_stmt|;
block|}
DECL|method|getBufferManager ()
specifier|static
name|ReadBufferManager
name|getBufferManager
parameter_list|()
block|{
return|return
name|BUFFER_MANAGER
return|;
block|}
DECL|method|init ()
specifier|private
name|void
name|init
parameter_list|()
block|{
name|buffers
operator|=
operator|new
name|byte
index|[
name|NUM_BUFFERS
index|]
index|[]
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|NUM_BUFFERS
condition|;
name|i
operator|++
control|)
block|{
name|buffers
index|[
name|i
index|]
operator|=
operator|new
name|byte
index|[
name|BLOCK_SIZE
index|]
expr_stmt|;
comment|// same buffers are reused. The byte array never goes back to GC
name|freeList
operator|.
name|add
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|NUM_THREADS
condition|;
name|i
operator|++
control|)
block|{
name|Thread
name|t
init|=
operator|new
name|Thread
argument_list|(
operator|new
name|ReadBufferWorker
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
name|t
operator|.
name|setDaemon
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|threads
index|[
name|i
index|]
operator|=
name|t
expr_stmt|;
name|t
operator|.
name|setName
argument_list|(
literal|"ABFS-prefetch-"
operator|+
name|i
argument_list|)
expr_stmt|;
name|t
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
name|ReadBufferWorker
operator|.
name|UNLEASH_WORKERS
operator|.
name|countDown
argument_list|()
expr_stmt|;
block|}
comment|// hide instance constructor
DECL|method|ReadBufferManager ()
specifier|private
name|ReadBufferManager
parameter_list|()
block|{   }
comment|/*    *    *  AbfsInputStream-facing methods    *    */
comment|/**    * {@link AbfsInputStream} calls this method to queue read-aheads    *    * @param stream          The {@link AbfsInputStream} for which to do the read-ahead    * @param requestedOffset The offset in the file which shoukd be read    * @param requestedLength The length to read    */
DECL|method|queueReadAhead (final AbfsInputStream stream, final long requestedOffset, final int requestedLength)
name|void
name|queueReadAhead
parameter_list|(
specifier|final
name|AbfsInputStream
name|stream
parameter_list|,
specifier|final
name|long
name|requestedOffset
parameter_list|,
specifier|final
name|int
name|requestedLength
parameter_list|)
block|{
if|if
condition|(
name|LOGGER
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOGGER
operator|.
name|trace
argument_list|(
literal|"Start Queueing readAhead for "
operator|+
name|stream
operator|.
name|getPath
argument_list|()
operator|+
literal|" offset "
operator|+
name|requestedOffset
operator|+
literal|" length "
operator|+
name|requestedLength
argument_list|)
expr_stmt|;
block|}
name|ReadBuffer
name|buffer
decl_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
if|if
condition|(
name|isAlreadyQueued
argument_list|(
name|stream
argument_list|,
name|requestedOffset
argument_list|)
condition|)
block|{
return|return;
comment|// already queued, do not queue again
block|}
if|if
condition|(
name|freeList
operator|.
name|size
argument_list|()
operator|==
literal|0
operator|&&
operator|!
name|tryEvict
argument_list|()
condition|)
block|{
return|return;
comment|// no buffers available, cannot queue anything
block|}
name|buffer
operator|=
operator|new
name|ReadBuffer
argument_list|()
expr_stmt|;
name|buffer
operator|.
name|setStream
argument_list|(
name|stream
argument_list|)
expr_stmt|;
name|buffer
operator|.
name|setOffset
argument_list|(
name|requestedOffset
argument_list|)
expr_stmt|;
name|buffer
operator|.
name|setLength
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|buffer
operator|.
name|setRequestedLength
argument_list|(
name|requestedLength
argument_list|)
expr_stmt|;
name|buffer
operator|.
name|setStatus
argument_list|(
name|ReadBufferStatus
operator|.
name|NOT_AVAILABLE
argument_list|)
expr_stmt|;
name|buffer
operator|.
name|setLatch
argument_list|(
operator|new
name|CountDownLatch
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|Integer
name|bufferIndex
init|=
name|freeList
operator|.
name|pop
argument_list|()
decl_stmt|;
comment|// will return a value, since we have checked size> 0 already
name|buffer
operator|.
name|setBuffer
argument_list|(
name|buffers
index|[
name|bufferIndex
index|]
argument_list|)
expr_stmt|;
name|buffer
operator|.
name|setBufferindex
argument_list|(
name|bufferIndex
argument_list|)
expr_stmt|;
name|readAheadQueue
operator|.
name|add
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|notifyAll
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|LOGGER
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOGGER
operator|.
name|trace
argument_list|(
literal|"Done q-ing readAhead for file "
operator|+
name|stream
operator|.
name|getPath
argument_list|()
operator|+
literal|" offset "
operator|+
name|requestedOffset
operator|+
literal|" buffer idx "
operator|+
name|buffer
operator|.
name|getBufferindex
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * {@link AbfsInputStream} calls this method read any bytes already available in a buffer (thereby saving a    * remote read). This returns the bytes if the data already exists in buffer. If there is a buffer that is reading    * the requested offset, then this method blocks until that read completes. If the data is queued in a read-ahead    * but not picked up by a worker thread yet, then it cancels that read-ahead and reports cache miss. This is because    * depending on worker thread availability, the read-ahead may take a while - the calling thread can do it's own    * read to get the data faster (copmared to the read waiting in queue for an indeterminate amount of time).    *    * @param stream   the file to read bytes for    * @param position the offset in the file to do a read for    * @param length   the length to read    * @param buffer   the buffer to read data into. Note that the buffer will be written into from offset 0.    * @return the number of bytes read    */
DECL|method|getBlock (final AbfsInputStream stream, final long position, final int length, final byte[] buffer)
name|int
name|getBlock
parameter_list|(
specifier|final
name|AbfsInputStream
name|stream
parameter_list|,
specifier|final
name|long
name|position
parameter_list|,
specifier|final
name|int
name|length
parameter_list|,
specifier|final
name|byte
index|[]
name|buffer
parameter_list|)
block|{
comment|// not synchronized, so have to be careful with locking
if|if
condition|(
name|LOGGER
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOGGER
operator|.
name|trace
argument_list|(
literal|"getBlock for file "
operator|+
name|stream
operator|.
name|getPath
argument_list|()
operator|+
literal|" position "
operator|+
name|position
operator|+
literal|" thread "
operator|+
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|waitForProcess
argument_list|(
name|stream
argument_list|,
name|position
argument_list|)
expr_stmt|;
name|int
name|bytesRead
init|=
literal|0
decl_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
name|bytesRead
operator|=
name|getBlockFromCompletedQueue
argument_list|(
name|stream
argument_list|,
name|position
argument_list|,
name|length
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bytesRead
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|LOGGER
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOGGER
operator|.
name|trace
argument_list|(
literal|"Done read from Cache for "
operator|+
name|stream
operator|.
name|getPath
argument_list|()
operator|+
literal|" position "
operator|+
name|position
operator|+
literal|" length "
operator|+
name|bytesRead
argument_list|)
expr_stmt|;
block|}
return|return
name|bytesRead
return|;
block|}
comment|// otherwise, just say we got nothing - calling thread can do it's own read
return|return
literal|0
return|;
block|}
comment|/*    *    *  Internal methods    *    */
DECL|method|waitForProcess (final AbfsInputStream stream, final long position)
specifier|private
name|void
name|waitForProcess
parameter_list|(
specifier|final
name|AbfsInputStream
name|stream
parameter_list|,
specifier|final
name|long
name|position
parameter_list|)
block|{
name|ReadBuffer
name|readBuf
decl_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
name|clearFromReadAheadQueue
argument_list|(
name|stream
argument_list|,
name|position
argument_list|)
expr_stmt|;
name|readBuf
operator|=
name|getFromList
argument_list|(
name|inProgressList
argument_list|,
name|stream
argument_list|,
name|position
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|readBuf
operator|!=
literal|null
condition|)
block|{
comment|// if in in-progress queue, then block for it
try|try
block|{
if|if
condition|(
name|LOGGER
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOGGER
operator|.
name|trace
argument_list|(
literal|"got a relevant read buffer for file "
operator|+
name|stream
operator|.
name|getPath
argument_list|()
operator|+
literal|" offset "
operator|+
name|readBuf
operator|.
name|getOffset
argument_list|()
operator|+
literal|" buffer idx "
operator|+
name|readBuf
operator|.
name|getBufferindex
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|readBuf
operator|.
name|getLatch
argument_list|()
operator|.
name|await
argument_list|()
expr_stmt|;
comment|// blocking wait on the caller stream's thread
comment|// Note on correctness: readBuf gets out of inProgressList only in 1 place: after worker thread
comment|// is done processing it (in doneReading). There, the latch is set after removing the buffer from
comment|// inProgressList. So this latch is safe to be outside the synchronized block.
comment|// Putting it in synchronized would result in a deadlock, since this thread would be holding the lock
comment|// while waiting, so no one will be able to  change any state. If this becomes more complex in the future,
comment|// then the latch cane be removed and replaced with wait/notify whenever inProgressList is touched.
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ex
parameter_list|)
block|{
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|LOGGER
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOGGER
operator|.
name|trace
argument_list|(
literal|"latch done for file "
operator|+
name|stream
operator|.
name|getPath
argument_list|()
operator|+
literal|" buffer idx "
operator|+
name|readBuf
operator|.
name|getBufferindex
argument_list|()
operator|+
literal|" length "
operator|+
name|readBuf
operator|.
name|getLength
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * If any buffer in the completedlist can be reclaimed then reclaim it and return the buffer to free list.    * The objective is to find just one buffer - there is no advantage to evicting more than one.    *    * @return whether the eviction succeeeded - i.e., were we able to free up one buffer    */
DECL|method|tryEvict ()
specifier|private
specifier|synchronized
name|boolean
name|tryEvict
parameter_list|()
block|{
name|ReadBuffer
name|nodeToEvict
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|completedReadList
operator|.
name|size
argument_list|()
operator|<=
literal|0
condition|)
block|{
return|return
literal|false
return|;
comment|// there are no evict-able buffers
block|}
comment|// first, try buffers where all bytes have been consumed (approximated as first and last bytes consumed)
for|for
control|(
name|ReadBuffer
name|buf
range|:
name|completedReadList
control|)
block|{
if|if
condition|(
name|buf
operator|.
name|isFirstByteConsumed
argument_list|()
operator|&&
name|buf
operator|.
name|isLastByteConsumed
argument_list|()
condition|)
block|{
name|nodeToEvict
operator|=
name|buf
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|nodeToEvict
operator|!=
literal|null
condition|)
block|{
return|return
name|evict
argument_list|(
name|nodeToEvict
argument_list|)
return|;
block|}
comment|// next, try buffers where any bytes have been consumed (may be a bad idea? have to experiment and see)
for|for
control|(
name|ReadBuffer
name|buf
range|:
name|completedReadList
control|)
block|{
if|if
condition|(
name|buf
operator|.
name|isAnyByteConsumed
argument_list|()
condition|)
block|{
name|nodeToEvict
operator|=
name|buf
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|nodeToEvict
operator|!=
literal|null
condition|)
block|{
return|return
name|evict
argument_list|(
name|nodeToEvict
argument_list|)
return|;
block|}
comment|// next, try any old nodes that have not been consumed
name|long
name|earliestBirthday
init|=
name|Long
operator|.
name|MAX_VALUE
decl_stmt|;
for|for
control|(
name|ReadBuffer
name|buf
range|:
name|completedReadList
control|)
block|{
if|if
condition|(
name|buf
operator|.
name|getTimeStamp
argument_list|()
operator|<
name|earliestBirthday
condition|)
block|{
name|nodeToEvict
operator|=
name|buf
expr_stmt|;
name|earliestBirthday
operator|=
name|buf
operator|.
name|getTimeStamp
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|currentTimeMillis
argument_list|()
operator|-
name|earliestBirthday
operator|>
name|THRESHOLD_AGE_MILLISECONDS
operator|)
operator|&&
operator|(
name|nodeToEvict
operator|!=
literal|null
operator|)
condition|)
block|{
return|return
name|evict
argument_list|(
name|nodeToEvict
argument_list|)
return|;
block|}
comment|// nothing can be evicted
return|return
literal|false
return|;
block|}
DECL|method|evict (final ReadBuffer buf)
specifier|private
name|boolean
name|evict
parameter_list|(
specifier|final
name|ReadBuffer
name|buf
parameter_list|)
block|{
name|freeList
operator|.
name|push
argument_list|(
name|buf
operator|.
name|getBufferindex
argument_list|()
argument_list|)
expr_stmt|;
name|completedReadList
operator|.
name|remove
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOGGER
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOGGER
operator|.
name|trace
argument_list|(
literal|"Evicting buffer idx "
operator|+
name|buf
operator|.
name|getBufferindex
argument_list|()
operator|+
literal|"; was used for file "
operator|+
name|buf
operator|.
name|getStream
argument_list|()
operator|.
name|getPath
argument_list|()
operator|+
literal|" offset "
operator|+
name|buf
operator|.
name|getOffset
argument_list|()
operator|+
literal|" length "
operator|+
name|buf
operator|.
name|getLength
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
DECL|method|isAlreadyQueued (final AbfsInputStream stream, final long requestedOffset)
specifier|private
name|boolean
name|isAlreadyQueued
parameter_list|(
specifier|final
name|AbfsInputStream
name|stream
parameter_list|,
specifier|final
name|long
name|requestedOffset
parameter_list|)
block|{
comment|// returns true if any part of the buffer is already queued
return|return
operator|(
name|isInList
argument_list|(
name|readAheadQueue
argument_list|,
name|stream
argument_list|,
name|requestedOffset
argument_list|)
operator|||
name|isInList
argument_list|(
name|inProgressList
argument_list|,
name|stream
argument_list|,
name|requestedOffset
argument_list|)
operator|||
name|isInList
argument_list|(
name|completedReadList
argument_list|,
name|stream
argument_list|,
name|requestedOffset
argument_list|)
operator|)
return|;
block|}
DECL|method|isInList (final Collection<ReadBuffer> list, final AbfsInputStream stream, final long requestedOffset)
specifier|private
name|boolean
name|isInList
parameter_list|(
specifier|final
name|Collection
argument_list|<
name|ReadBuffer
argument_list|>
name|list
parameter_list|,
specifier|final
name|AbfsInputStream
name|stream
parameter_list|,
specifier|final
name|long
name|requestedOffset
parameter_list|)
block|{
return|return
operator|(
name|getFromList
argument_list|(
name|list
argument_list|,
name|stream
argument_list|,
name|requestedOffset
argument_list|)
operator|!=
literal|null
operator|)
return|;
block|}
DECL|method|getFromList (final Collection<ReadBuffer> list, final AbfsInputStream stream, final long requestedOffset)
specifier|private
name|ReadBuffer
name|getFromList
parameter_list|(
specifier|final
name|Collection
argument_list|<
name|ReadBuffer
argument_list|>
name|list
parameter_list|,
specifier|final
name|AbfsInputStream
name|stream
parameter_list|,
specifier|final
name|long
name|requestedOffset
parameter_list|)
block|{
for|for
control|(
name|ReadBuffer
name|buffer
range|:
name|list
control|)
block|{
if|if
condition|(
name|buffer
operator|.
name|getStream
argument_list|()
operator|==
name|stream
condition|)
block|{
if|if
condition|(
name|buffer
operator|.
name|getStatus
argument_list|()
operator|==
name|ReadBufferStatus
operator|.
name|AVAILABLE
operator|&&
name|requestedOffset
operator|>=
name|buffer
operator|.
name|getOffset
argument_list|()
operator|&&
name|requestedOffset
operator|<
name|buffer
operator|.
name|getOffset
argument_list|()
operator|+
name|buffer
operator|.
name|getLength
argument_list|()
condition|)
block|{
return|return
name|buffer
return|;
block|}
elseif|else
if|if
condition|(
name|requestedOffset
operator|>=
name|buffer
operator|.
name|getOffset
argument_list|()
operator|&&
name|requestedOffset
operator|<
name|buffer
operator|.
name|getOffset
argument_list|()
operator|+
name|buffer
operator|.
name|getRequestedLength
argument_list|()
condition|)
block|{
return|return
name|buffer
return|;
block|}
block|}
block|}
return|return
literal|null
return|;
block|}
DECL|method|clearFromReadAheadQueue (final AbfsInputStream stream, final long requestedOffset)
specifier|private
name|void
name|clearFromReadAheadQueue
parameter_list|(
specifier|final
name|AbfsInputStream
name|stream
parameter_list|,
specifier|final
name|long
name|requestedOffset
parameter_list|)
block|{
name|ReadBuffer
name|buffer
init|=
name|getFromList
argument_list|(
name|readAheadQueue
argument_list|,
name|stream
argument_list|,
name|requestedOffset
argument_list|)
decl_stmt|;
if|if
condition|(
name|buffer
operator|!=
literal|null
condition|)
block|{
name|readAheadQueue
operator|.
name|remove
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|notifyAll
argument_list|()
expr_stmt|;
comment|// lock is held in calling method
name|freeList
operator|.
name|push
argument_list|(
name|buffer
operator|.
name|getBufferindex
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|getBlockFromCompletedQueue (final AbfsInputStream stream, final long position, final int length, final byte[] buffer)
specifier|private
name|int
name|getBlockFromCompletedQueue
parameter_list|(
specifier|final
name|AbfsInputStream
name|stream
parameter_list|,
specifier|final
name|long
name|position
parameter_list|,
specifier|final
name|int
name|length
parameter_list|,
specifier|final
name|byte
index|[]
name|buffer
parameter_list|)
block|{
name|ReadBuffer
name|buf
init|=
name|getFromList
argument_list|(
name|completedReadList
argument_list|,
name|stream
argument_list|,
name|position
argument_list|)
decl_stmt|;
if|if
condition|(
name|buf
operator|==
literal|null
operator|||
name|position
operator|>=
name|buf
operator|.
name|getOffset
argument_list|()
operator|+
name|buf
operator|.
name|getLength
argument_list|()
condition|)
block|{
return|return
literal|0
return|;
block|}
name|int
name|cursor
init|=
call|(
name|int
call|)
argument_list|(
name|position
operator|-
name|buf
operator|.
name|getOffset
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|availableLengthInBuffer
init|=
name|buf
operator|.
name|getLength
argument_list|()
operator|-
name|cursor
decl_stmt|;
name|int
name|lengthToCopy
init|=
name|Math
operator|.
name|min
argument_list|(
name|length
argument_list|,
name|availableLengthInBuffer
argument_list|)
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|buf
operator|.
name|getBuffer
argument_list|()
argument_list|,
name|cursor
argument_list|,
name|buffer
argument_list|,
literal|0
argument_list|,
name|lengthToCopy
argument_list|)
expr_stmt|;
if|if
condition|(
name|cursor
operator|==
literal|0
condition|)
block|{
name|buf
operator|.
name|setFirstByteConsumed
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cursor
operator|+
name|lengthToCopy
operator|==
name|buf
operator|.
name|getLength
argument_list|()
condition|)
block|{
name|buf
operator|.
name|setLastByteConsumed
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
name|buf
operator|.
name|setAnyByteConsumed
argument_list|(
literal|true
argument_list|)
expr_stmt|;
return|return
name|lengthToCopy
return|;
block|}
comment|/*    *    *  ReadBufferWorker-thread-facing methods    *    */
comment|/**    * ReadBufferWorker thread calls this to get the next buffer that it should work on.    *    * @return {@link ReadBuffer}    * @throws InterruptedException if thread is interrupted    */
DECL|method|getNextBlockToRead ()
name|ReadBuffer
name|getNextBlockToRead
parameter_list|()
throws|throws
name|InterruptedException
block|{
name|ReadBuffer
name|buffer
init|=
literal|null
decl_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
comment|//buffer = readAheadQueue.take();  // blocking method
while|while
condition|(
name|readAheadQueue
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
name|wait
argument_list|()
expr_stmt|;
block|}
name|buffer
operator|=
name|readAheadQueue
operator|.
name|remove
argument_list|()
expr_stmt|;
name|notifyAll
argument_list|()
expr_stmt|;
if|if
condition|(
name|buffer
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
comment|// should never happen
block|}
name|buffer
operator|.
name|setStatus
argument_list|(
name|ReadBufferStatus
operator|.
name|READING_IN_PROGRESS
argument_list|)
expr_stmt|;
name|inProgressList
operator|.
name|add
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|LOGGER
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOGGER
operator|.
name|trace
argument_list|(
literal|"ReadBufferWorker picked file "
operator|+
name|buffer
operator|.
name|getStream
argument_list|()
operator|.
name|getPath
argument_list|()
operator|+
literal|" for offset "
operator|+
name|buffer
operator|.
name|getOffset
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|buffer
return|;
block|}
comment|/**    * ReadBufferWorker thread calls this method to post completion    *    * @param buffer            the buffer whose read was completed    * @param result            the {@link ReadBufferStatus} after the read operation in the worker thread    * @param bytesActuallyRead the number of bytes that the worker thread was actually able to read    */
DECL|method|doneReading (final ReadBuffer buffer, final ReadBufferStatus result, final int bytesActuallyRead)
name|void
name|doneReading
parameter_list|(
specifier|final
name|ReadBuffer
name|buffer
parameter_list|,
specifier|final
name|ReadBufferStatus
name|result
parameter_list|,
specifier|final
name|int
name|bytesActuallyRead
parameter_list|)
block|{
if|if
condition|(
name|LOGGER
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOGGER
operator|.
name|trace
argument_list|(
literal|"ReadBufferWorker completed file "
operator|+
name|buffer
operator|.
name|getStream
argument_list|()
operator|.
name|getPath
argument_list|()
operator|+
literal|" for offset "
operator|+
name|buffer
operator|.
name|getOffset
argument_list|()
operator|+
literal|" bytes "
operator|+
name|bytesActuallyRead
argument_list|)
expr_stmt|;
block|}
synchronized|synchronized
init|(
name|this
init|)
block|{
name|inProgressList
operator|.
name|remove
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ReadBufferStatus
operator|.
name|AVAILABLE
operator|&&
name|bytesActuallyRead
operator|>
literal|0
condition|)
block|{
name|buffer
operator|.
name|setStatus
argument_list|(
name|ReadBufferStatus
operator|.
name|AVAILABLE
argument_list|)
expr_stmt|;
name|buffer
operator|.
name|setTimeStamp
argument_list|(
name|currentTimeMillis
argument_list|()
argument_list|)
expr_stmt|;
name|buffer
operator|.
name|setLength
argument_list|(
name|bytesActuallyRead
argument_list|)
expr_stmt|;
name|completedReadList
operator|.
name|add
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|freeList
operator|.
name|push
argument_list|(
name|buffer
operator|.
name|getBufferindex
argument_list|()
argument_list|)
expr_stmt|;
comment|// buffer should go out of scope after the end of the calling method in ReadBufferWorker, and eligible for GC
block|}
block|}
comment|//outside the synchronized, since anyone receiving a wake-up from the latch must see safe-published results
name|buffer
operator|.
name|getLatch
argument_list|()
operator|.
name|countDown
argument_list|()
expr_stmt|;
comment|// wake up waiting threads (if any)
block|}
comment|/**    * Similar to System.currentTimeMillis, except implemented with System.nanoTime().    * System.currentTimeMillis can go backwards when system clock is changed (e.g., with NTP time synchronization),    * making it unsuitable for measuring time intervals. nanotime is strictly monotonically increasing,    * so it is much more suitable to measuring intervals.    *    * @return current time in milliseconds    */
DECL|method|currentTimeMillis ()
specifier|private
name|long
name|currentTimeMillis
parameter_list|()
block|{
return|return
name|System
operator|.
name|nanoTime
argument_list|()
operator|/
literal|1000
operator|/
literal|1000
return|;
block|}
block|}
end_class

end_unit

