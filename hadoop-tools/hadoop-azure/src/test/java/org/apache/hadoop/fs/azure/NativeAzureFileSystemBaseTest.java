begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.fs.azure
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|azure
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileNotFoundException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Calendar
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Date
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TimeZone
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FSDataInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FSDataOutputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|contract
operator|.
name|ContractTestUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|permission
operator|.
name|FsPermission
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|UserGroupInformation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Test
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|azure
operator|.
name|NativeAzureFileSystem
operator|.
name|FolderRenamePending
import|;
end_import

begin_import
import|import
name|com
operator|.
name|microsoft
operator|.
name|azure
operator|.
name|storage
operator|.
name|AccessCondition
import|;
end_import

begin_import
import|import
name|com
operator|.
name|microsoft
operator|.
name|azure
operator|.
name|storage
operator|.
name|StorageException
import|;
end_import

begin_import
import|import
name|com
operator|.
name|microsoft
operator|.
name|azure
operator|.
name|storage
operator|.
name|blob
operator|.
name|CloudBlob
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|azure
operator|.
name|integration
operator|.
name|AzureTestUtils
operator|.
name|readStringFromFile
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|azure
operator|.
name|integration
operator|.
name|AzureTestUtils
operator|.
name|writeStringToFile
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|azure
operator|.
name|integration
operator|.
name|AzureTestUtils
operator|.
name|writeStringToStream
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|test
operator|.
name|GenericTestUtils
operator|.
name|*
import|;
end_import

begin_comment
comment|/*  * Tests the Native Azure file system (WASB) against an actual blob store if  * provided in the environment.  * Subclasses implement createTestAccount() to hit local&mock storage with the same test code.  *   * For hand-testing: remove "abstract" keyword and copy in an implementation of createTestAccount  * from one of the subclasses  */
end_comment

begin_class
DECL|class|NativeAzureFileSystemBaseTest
specifier|public
specifier|abstract
class|class
name|NativeAzureFileSystemBaseTest
extends|extends
name|AbstractWasbTestBase
block|{
DECL|field|modifiedTimeErrorMargin
specifier|private
specifier|final
name|long
name|modifiedTimeErrorMargin
init|=
literal|5
operator|*
literal|1000
decl_stmt|;
comment|// Give it +/-5 seconds
DECL|field|LOG
specifier|public
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|NativeAzureFileSystemBaseTest
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|fs
specifier|protected
name|NativeAzureFileSystem
name|fs
decl_stmt|;
annotation|@
name|Override
DECL|method|setUp ()
specifier|public
name|void
name|setUp
parameter_list|()
throws|throws
name|Exception
block|{
name|super
operator|.
name|setUp
argument_list|()
expr_stmt|;
name|fs
operator|=
name|getFileSystem
argument_list|()
expr_stmt|;
block|}
comment|/**    * Assert that a path does not exist.    *    * @param message message to include in the assertion failure message    * @param path path in the filesystem    * @throws IOException IO problems    */
DECL|method|assertPathDoesNotExist (String message, Path path)
specifier|public
name|void
name|assertPathDoesNotExist
parameter_list|(
name|String
name|message
parameter_list|,
name|Path
name|path
parameter_list|)
throws|throws
name|IOException
block|{
name|ContractTestUtils
operator|.
name|assertPathDoesNotExist
argument_list|(
name|fs
argument_list|,
name|message
argument_list|,
name|path
argument_list|)
expr_stmt|;
block|}
comment|/**    * Assert that a path exists.    *    * @param message message to include in the assertion failure message    * @param path path in the filesystem    * @throws IOException IO problems    */
DECL|method|assertPathExists (String message, Path path)
specifier|public
name|void
name|assertPathExists
parameter_list|(
name|String
name|message
parameter_list|,
name|Path
name|path
parameter_list|)
throws|throws
name|IOException
block|{
name|ContractTestUtils
operator|.
name|assertPathExists
argument_list|(
name|fs
argument_list|,
name|message
argument_list|,
name|path
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testCheckingNonExistentOneLetterFile ()
specifier|public
name|void
name|testCheckingNonExistentOneLetterFile
parameter_list|()
throws|throws
name|Exception
block|{
name|assertPathDoesNotExist
argument_list|(
literal|"one letter file"
argument_list|,
operator|new
name|Path
argument_list|(
literal|"/a"
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testStoreRetrieveFile ()
specifier|public
name|void
name|testStoreRetrieveFile
parameter_list|()
throws|throws
name|Exception
block|{
name|Path
name|testFile
init|=
name|methodPath
argument_list|()
decl_stmt|;
name|writeString
argument_list|(
name|testFile
argument_list|,
literal|"Testing"
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|fs
operator|.
name|exists
argument_list|(
name|testFile
argument_list|)
argument_list|)
expr_stmt|;
name|FileStatus
name|status
init|=
name|fs
operator|.
name|getFileStatus
argument_list|(
name|testFile
argument_list|)
decl_stmt|;
name|assertNotNull
argument_list|(
name|status
argument_list|)
expr_stmt|;
comment|// By default, files should be have masked permissions
comment|// that grant RW to user, and R to group/other
name|assertEquals
argument_list|(
operator|new
name|FsPermission
argument_list|(
operator|(
name|short
operator|)
literal|0644
argument_list|)
argument_list|,
name|status
operator|.
name|getPermission
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Testing"
argument_list|,
name|readString
argument_list|(
name|testFile
argument_list|)
argument_list|)
expr_stmt|;
name|fs
operator|.
name|delete
argument_list|(
name|testFile
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testStoreDeleteFolder ()
specifier|public
name|void
name|testStoreDeleteFolder
parameter_list|()
throws|throws
name|Exception
block|{
name|Path
name|testFolder
init|=
name|methodPath
argument_list|()
decl_stmt|;
name|assertFalse
argument_list|(
name|fs
operator|.
name|exists
argument_list|(
name|testFolder
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|fs
operator|.
name|mkdirs
argument_list|(
name|testFolder
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|fs
operator|.
name|exists
argument_list|(
name|testFolder
argument_list|)
argument_list|)
expr_stmt|;
name|FileStatus
name|status
init|=
name|fs
operator|.
name|getFileStatus
argument_list|(
name|testFolder
argument_list|)
decl_stmt|;
name|assertNotNull
argument_list|(
name|status
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|status
operator|.
name|isDirectory
argument_list|()
argument_list|)
expr_stmt|;
comment|// By default, directories should be have masked permissions
comment|// that grant RWX to user, and RX to group/other
name|assertEquals
argument_list|(
operator|new
name|FsPermission
argument_list|(
operator|(
name|short
operator|)
literal|0755
argument_list|)
argument_list|,
name|status
operator|.
name|getPermission
argument_list|()
argument_list|)
expr_stmt|;
name|Path
name|innerFile
init|=
operator|new
name|Path
argument_list|(
name|testFolder
argument_list|,
literal|"innerFile"
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|fs
operator|.
name|createNewFile
argument_list|(
name|innerFile
argument_list|)
argument_list|)
expr_stmt|;
name|assertPathExists
argument_list|(
literal|"inner file"
argument_list|,
name|innerFile
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|fs
operator|.
name|delete
argument_list|(
name|testFolder
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|assertPathDoesNotExist
argument_list|(
literal|"inner file"
argument_list|,
name|innerFile
argument_list|)
expr_stmt|;
name|assertPathDoesNotExist
argument_list|(
literal|"testFolder"
argument_list|,
name|testFolder
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testFileOwnership ()
specifier|public
name|void
name|testFileOwnership
parameter_list|()
throws|throws
name|Exception
block|{
name|Path
name|testFile
init|=
name|methodPath
argument_list|()
decl_stmt|;
name|writeString
argument_list|(
name|testFile
argument_list|,
literal|"Testing"
argument_list|)
expr_stmt|;
name|testOwnership
argument_list|(
name|testFile
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testFolderOwnership ()
specifier|public
name|void
name|testFolderOwnership
parameter_list|()
throws|throws
name|Exception
block|{
name|Path
name|testFolder
init|=
name|methodPath
argument_list|()
decl_stmt|;
name|fs
operator|.
name|mkdirs
argument_list|(
name|testFolder
argument_list|)
expr_stmt|;
name|testOwnership
argument_list|(
name|testFolder
argument_list|)
expr_stmt|;
block|}
DECL|method|testOwnership (Path pathUnderTest)
specifier|private
name|void
name|testOwnership
parameter_list|(
name|Path
name|pathUnderTest
parameter_list|)
throws|throws
name|IOException
block|{
name|FileStatus
name|ret
init|=
name|fs
operator|.
name|getFileStatus
argument_list|(
name|pathUnderTest
argument_list|)
decl_stmt|;
name|UserGroupInformation
name|currentUser
init|=
name|UserGroupInformation
operator|.
name|getCurrentUser
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
name|ret
operator|.
name|getOwner
argument_list|()
operator|.
name|equals
argument_list|(
name|currentUser
operator|.
name|getShortUserName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|fs
operator|.
name|delete
argument_list|(
name|pathUnderTest
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
DECL|method|ignoreStickyBit (FsPermission original)
specifier|private
specifier|static
name|FsPermission
name|ignoreStickyBit
parameter_list|(
name|FsPermission
name|original
parameter_list|)
block|{
return|return
operator|new
name|FsPermission
argument_list|(
name|original
operator|.
name|getUserAction
argument_list|()
argument_list|,
name|original
operator|.
name|getGroupAction
argument_list|()
argument_list|,
name|original
operator|.
name|getOtherAction
argument_list|()
argument_list|)
return|;
block|}
comment|// When FsPermission applies a UMask, it loses sticky bit information.
comment|// And since we always apply UMask, we should ignore whether the sticky
comment|// bit is equal or not.
DECL|method|assertEqualsIgnoreStickyBit (FsPermission expected, FsPermission actual)
specifier|private
specifier|static
name|void
name|assertEqualsIgnoreStickyBit
parameter_list|(
name|FsPermission
name|expected
parameter_list|,
name|FsPermission
name|actual
parameter_list|)
block|{
name|assertEquals
argument_list|(
name|ignoreStickyBit
argument_list|(
name|expected
argument_list|)
argument_list|,
name|ignoreStickyBit
argument_list|(
name|actual
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testFilePermissions ()
specifier|public
name|void
name|testFilePermissions
parameter_list|()
throws|throws
name|Exception
block|{
name|Path
name|testFile
init|=
name|methodPath
argument_list|()
decl_stmt|;
name|FsPermission
name|permission
init|=
name|FsPermission
operator|.
name|createImmutable
argument_list|(
operator|(
name|short
operator|)
literal|644
argument_list|)
decl_stmt|;
name|createEmptyFile
argument_list|(
name|testFile
argument_list|,
name|permission
argument_list|)
expr_stmt|;
name|FileStatus
name|ret
init|=
name|fs
operator|.
name|getFileStatus
argument_list|(
name|testFile
argument_list|)
decl_stmt|;
name|assertEqualsIgnoreStickyBit
argument_list|(
name|permission
argument_list|,
name|ret
operator|.
name|getPermission
argument_list|()
argument_list|)
expr_stmt|;
name|fs
operator|.
name|delete
argument_list|(
name|testFile
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testFolderPermissions ()
specifier|public
name|void
name|testFolderPermissions
parameter_list|()
throws|throws
name|Exception
block|{
name|Path
name|testFolder
init|=
name|methodPath
argument_list|()
decl_stmt|;
name|FsPermission
name|permission
init|=
name|FsPermission
operator|.
name|createImmutable
argument_list|(
operator|(
name|short
operator|)
literal|644
argument_list|)
decl_stmt|;
name|fs
operator|.
name|mkdirs
argument_list|(
name|testFolder
argument_list|,
name|permission
argument_list|)
expr_stmt|;
name|FileStatus
name|ret
init|=
name|fs
operator|.
name|getFileStatus
argument_list|(
name|testFolder
argument_list|)
decl_stmt|;
name|assertEqualsIgnoreStickyBit
argument_list|(
name|permission
argument_list|,
name|ret
operator|.
name|getPermission
argument_list|()
argument_list|)
expr_stmt|;
name|fs
operator|.
name|delete
argument_list|(
name|testFolder
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
DECL|method|testDeepFileCreationBase (String testFilePath, String firstDirPath, String middleDirPath, short permissionShort, short umaskedPermissionShort)
name|void
name|testDeepFileCreationBase
parameter_list|(
name|String
name|testFilePath
parameter_list|,
name|String
name|firstDirPath
parameter_list|,
name|String
name|middleDirPath
parameter_list|,
name|short
name|permissionShort
parameter_list|,
name|short
name|umaskedPermissionShort
parameter_list|)
throws|throws
name|Exception
block|{
name|Path
name|testFile
init|=
operator|new
name|Path
argument_list|(
name|testFilePath
argument_list|)
decl_stmt|;
name|Path
name|firstDir
init|=
operator|new
name|Path
argument_list|(
name|firstDirPath
argument_list|)
decl_stmt|;
name|Path
name|middleDir
init|=
operator|new
name|Path
argument_list|(
name|middleDirPath
argument_list|)
decl_stmt|;
name|FsPermission
name|permission
init|=
name|FsPermission
operator|.
name|createImmutable
argument_list|(
name|permissionShort
argument_list|)
decl_stmt|;
name|FsPermission
name|umaskedPermission
init|=
name|FsPermission
operator|.
name|createImmutable
argument_list|(
name|umaskedPermissionShort
argument_list|)
decl_stmt|;
name|createEmptyFile
argument_list|(
name|testFile
argument_list|,
name|permission
argument_list|)
expr_stmt|;
name|FsPermission
name|rootPerm
init|=
name|fs
operator|.
name|getFileStatus
argument_list|(
name|firstDir
operator|.
name|getParent
argument_list|()
argument_list|)
operator|.
name|getPermission
argument_list|()
decl_stmt|;
name|FsPermission
name|inheritPerm
init|=
name|FsPermission
operator|.
name|createImmutable
argument_list|(
call|(
name|short
call|)
argument_list|(
name|rootPerm
operator|.
name|toShort
argument_list|()
operator||
literal|0300
argument_list|)
argument_list|)
decl_stmt|;
name|assertPathExists
argument_list|(
literal|"test file"
argument_list|,
name|testFile
argument_list|)
expr_stmt|;
name|assertPathExists
argument_list|(
literal|"firstDir"
argument_list|,
name|firstDir
argument_list|)
expr_stmt|;
name|assertPathExists
argument_list|(
literal|"middleDir"
argument_list|,
name|middleDir
argument_list|)
expr_stmt|;
comment|// verify that the indirectly created directory inherited its permissions from the root directory
name|FileStatus
name|directoryStatus
init|=
name|fs
operator|.
name|getFileStatus
argument_list|(
name|middleDir
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|directoryStatus
operator|.
name|isDirectory
argument_list|()
argument_list|)
expr_stmt|;
name|assertEqualsIgnoreStickyBit
argument_list|(
name|inheritPerm
argument_list|,
name|directoryStatus
operator|.
name|getPermission
argument_list|()
argument_list|)
expr_stmt|;
comment|// verify that the file itself has the permissions as specified
name|FileStatus
name|fileStatus
init|=
name|fs
operator|.
name|getFileStatus
argument_list|(
name|testFile
argument_list|)
decl_stmt|;
name|assertFalse
argument_list|(
name|fileStatus
operator|.
name|isDirectory
argument_list|()
argument_list|)
expr_stmt|;
name|assertEqualsIgnoreStickyBit
argument_list|(
name|umaskedPermission
argument_list|,
name|fileStatus
operator|.
name|getPermission
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|fs
operator|.
name|delete
argument_list|(
name|firstDir
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|assertPathDoesNotExist
argument_list|(
literal|"deleted file"
argument_list|,
name|testFile
argument_list|)
expr_stmt|;
comment|// An alternative test scenario would've been to delete the file first,
comment|// and then check for the existence of the upper folders still. But that
comment|// doesn't actually work as expected right now.
block|}
annotation|@
name|Test
DECL|method|testDeepFileCreation ()
specifier|public
name|void
name|testDeepFileCreation
parameter_list|()
throws|throws
name|Exception
block|{
comment|// normal permissions in user home
name|testDeepFileCreationBase
argument_list|(
literal|"deep/file/creation/test"
argument_list|,
literal|"deep"
argument_list|,
literal|"deep/file/creation"
argument_list|,
operator|(
name|short
operator|)
literal|0644
argument_list|,
operator|(
name|short
operator|)
literal|0644
argument_list|)
expr_stmt|;
comment|// extra permissions in user home. umask will change the actual permissions.
name|testDeepFileCreationBase
argument_list|(
literal|"deep/file/creation/test"
argument_list|,
literal|"deep"
argument_list|,
literal|"deep/file/creation"
argument_list|,
operator|(
name|short
operator|)
literal|0777
argument_list|,
operator|(
name|short
operator|)
literal|0755
argument_list|)
expr_stmt|;
comment|// normal permissions in root
name|testDeepFileCreationBase
argument_list|(
literal|"/deep/file/creation/test"
argument_list|,
literal|"/deep"
argument_list|,
literal|"/deep/file/creation"
argument_list|,
operator|(
name|short
operator|)
literal|0644
argument_list|,
operator|(
name|short
operator|)
literal|0644
argument_list|)
expr_stmt|;
comment|// less permissions in root
name|testDeepFileCreationBase
argument_list|(
literal|"/deep/file/creation/test"
argument_list|,
literal|"/deep"
argument_list|,
literal|"/deep/file/creation"
argument_list|,
operator|(
name|short
operator|)
literal|0700
argument_list|,
operator|(
name|short
operator|)
literal|0700
argument_list|)
expr_stmt|;
comment|// one indirectly created directory in root
name|testDeepFileCreationBase
argument_list|(
literal|"/deep/file"
argument_list|,
literal|"/deep"
argument_list|,
literal|"/deep"
argument_list|,
operator|(
name|short
operator|)
literal|0644
argument_list|,
operator|(
name|short
operator|)
literal|0644
argument_list|)
expr_stmt|;
comment|// one indirectly created directory in user home
name|testDeepFileCreationBase
argument_list|(
literal|"deep/file"
argument_list|,
literal|"deep"
argument_list|,
literal|"deep"
argument_list|,
operator|(
name|short
operator|)
literal|0644
argument_list|,
operator|(
name|short
operator|)
literal|0644
argument_list|)
expr_stmt|;
block|}
DECL|enum|RenameVariation
specifier|private
specifier|static
enum|enum
name|RenameVariation
block|{
DECL|enumConstant|NormalFileName
DECL|enumConstant|SourceInAFolder
DECL|enumConstant|SourceWithSpace
DECL|enumConstant|SourceWithPlusAndPercent
name|NormalFileName
block|,
name|SourceInAFolder
block|,
name|SourceWithSpace
block|,
name|SourceWithPlusAndPercent
block|}
annotation|@
name|Test
DECL|method|testRename ()
specifier|public
name|void
name|testRename
parameter_list|()
throws|throws
name|Exception
block|{
for|for
control|(
name|RenameVariation
name|variation
range|:
name|RenameVariation
operator|.
name|values
argument_list|()
control|)
block|{
name|System
operator|.
name|out
operator|.
name|printf
argument_list|(
literal|"Rename variation: %s\n"
argument_list|,
name|variation
argument_list|)
expr_stmt|;
name|Path
name|originalFile
decl_stmt|;
switch|switch
condition|(
name|variation
condition|)
block|{
case|case
name|NormalFileName
case|:
name|originalFile
operator|=
operator|new
name|Path
argument_list|(
literal|"fileToRename"
argument_list|)
expr_stmt|;
break|break;
case|case
name|SourceInAFolder
case|:
name|originalFile
operator|=
operator|new
name|Path
argument_list|(
literal|"file/to/rename"
argument_list|)
expr_stmt|;
break|break;
case|case
name|SourceWithSpace
case|:
name|originalFile
operator|=
operator|new
name|Path
argument_list|(
literal|"file to rename"
argument_list|)
expr_stmt|;
break|break;
case|case
name|SourceWithPlusAndPercent
case|:
name|originalFile
operator|=
operator|new
name|Path
argument_list|(
literal|"file+to%rename"
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|Exception
argument_list|(
literal|"Unknown variation"
argument_list|)
throw|;
block|}
name|Path
name|destinationFile
init|=
operator|new
name|Path
argument_list|(
literal|"file/resting/destination"
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|fs
operator|.
name|createNewFile
argument_list|(
name|originalFile
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|fs
operator|.
name|exists
argument_list|(
name|originalFile
argument_list|)
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|fs
operator|.
name|rename
argument_list|(
name|originalFile
argument_list|,
name|destinationFile
argument_list|)
argument_list|)
expr_stmt|;
comment|// Parent directory
comment|// doesn't exist
name|assertTrue
argument_list|(
name|fs
operator|.
name|mkdirs
argument_list|(
name|destinationFile
operator|.
name|getParent
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|boolean
name|result
init|=
name|fs
operator|.
name|rename
argument_list|(
name|originalFile
argument_list|,
name|destinationFile
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|fs
operator|.
name|exists
argument_list|(
name|destinationFile
argument_list|)
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|fs
operator|.
name|exists
argument_list|(
name|originalFile
argument_list|)
argument_list|)
expr_stmt|;
name|fs
operator|.
name|delete
argument_list|(
name|destinationFile
operator|.
name|getParent
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Test
DECL|method|testRenameImplicitFolder ()
specifier|public
name|void
name|testRenameImplicitFolder
parameter_list|()
throws|throws
name|Exception
block|{
name|Path
name|testFile
init|=
operator|new
name|Path
argument_list|(
literal|"deep/file/rename/test"
argument_list|)
decl_stmt|;
name|FsPermission
name|permission
init|=
name|FsPermission
operator|.
name|createImmutable
argument_list|(
operator|(
name|short
operator|)
literal|644
argument_list|)
decl_stmt|;
name|createEmptyFile
argument_list|(
name|testFile
argument_list|,
name|permission
argument_list|)
expr_stmt|;
name|boolean
name|renameResult
init|=
name|fs
operator|.
name|rename
argument_list|(
operator|new
name|Path
argument_list|(
literal|"deep/file"
argument_list|)
argument_list|,
operator|new
name|Path
argument_list|(
literal|"deep/renamed"
argument_list|)
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|renameResult
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|fs
operator|.
name|exists
argument_list|(
name|testFile
argument_list|)
argument_list|)
expr_stmt|;
name|FileStatus
name|newStatus
init|=
name|fs
operator|.
name|getFileStatus
argument_list|(
operator|new
name|Path
argument_list|(
literal|"deep/renamed/rename/test"
argument_list|)
argument_list|)
decl_stmt|;
name|assertNotNull
argument_list|(
name|newStatus
argument_list|)
expr_stmt|;
name|assertEqualsIgnoreStickyBit
argument_list|(
name|permission
argument_list|,
name|newStatus
operator|.
name|getPermission
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|fs
operator|.
name|delete
argument_list|(
operator|new
name|Path
argument_list|(
literal|"deep"
argument_list|)
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|enum|RenameFolderVariation
specifier|private
enum|enum
name|RenameFolderVariation
block|{
DECL|enumConstant|CreateFolderAndInnerFile
DECL|enumConstant|CreateJustInnerFile
DECL|enumConstant|CreateJustFolder
name|CreateFolderAndInnerFile
block|,
name|CreateJustInnerFile
block|,
name|CreateJustFolder
block|}
annotation|@
name|Test
DECL|method|testRenameFolder ()
specifier|public
name|void
name|testRenameFolder
parameter_list|()
throws|throws
name|Exception
block|{
for|for
control|(
name|RenameFolderVariation
name|variation
range|:
name|RenameFolderVariation
operator|.
name|values
argument_list|()
control|)
block|{
name|Path
name|originalFolder
init|=
operator|new
name|Path
argument_list|(
literal|"folderToRename"
argument_list|)
decl_stmt|;
if|if
condition|(
name|variation
operator|!=
name|RenameFolderVariation
operator|.
name|CreateJustInnerFile
condition|)
block|{
name|assertTrue
argument_list|(
name|fs
operator|.
name|mkdirs
argument_list|(
name|originalFolder
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Path
name|innerFile
init|=
operator|new
name|Path
argument_list|(
name|originalFolder
argument_list|,
literal|"innerFile"
argument_list|)
decl_stmt|;
name|Path
name|innerFile2
init|=
operator|new
name|Path
argument_list|(
name|originalFolder
argument_list|,
literal|"innerFile2"
argument_list|)
decl_stmt|;
if|if
condition|(
name|variation
operator|!=
name|RenameFolderVariation
operator|.
name|CreateJustFolder
condition|)
block|{
name|assertTrue
argument_list|(
name|fs
operator|.
name|createNewFile
argument_list|(
name|innerFile
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|fs
operator|.
name|createNewFile
argument_list|(
name|innerFile2
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Path
name|destination
init|=
operator|new
name|Path
argument_list|(
literal|"renamedFolder"
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|fs
operator|.
name|rename
argument_list|(
name|originalFolder
argument_list|,
name|destination
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|fs
operator|.
name|exists
argument_list|(
name|destination
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|variation
operator|!=
name|RenameFolderVariation
operator|.
name|CreateJustFolder
condition|)
block|{
name|assertTrue
argument_list|(
name|fs
operator|.
name|exists
argument_list|(
operator|new
name|Path
argument_list|(
name|destination
argument_list|,
name|innerFile
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|fs
operator|.
name|exists
argument_list|(
operator|new
name|Path
argument_list|(
name|destination
argument_list|,
name|innerFile2
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|assertFalse
argument_list|(
name|fs
operator|.
name|exists
argument_list|(
name|originalFolder
argument_list|)
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|fs
operator|.
name|exists
argument_list|(
name|innerFile
argument_list|)
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|fs
operator|.
name|exists
argument_list|(
name|innerFile2
argument_list|)
argument_list|)
expr_stmt|;
name|fs
operator|.
name|delete
argument_list|(
name|destination
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Test
DECL|method|testCopyFromLocalFileSystem ()
specifier|public
name|void
name|testCopyFromLocalFileSystem
parameter_list|()
throws|throws
name|Exception
block|{
name|Path
name|localFilePath
init|=
operator|new
name|Path
argument_list|(
name|System
operator|.
name|getProperty
argument_list|(
literal|"test.build.data"
argument_list|,
literal|"azure_test"
argument_list|)
argument_list|)
decl_stmt|;
name|FileSystem
name|localFs
init|=
name|FileSystem
operator|.
name|get
argument_list|(
operator|new
name|Configuration
argument_list|()
argument_list|)
decl_stmt|;
name|localFs
operator|.
name|delete
argument_list|(
name|localFilePath
argument_list|,
literal|true
argument_list|)
expr_stmt|;
try|try
block|{
name|writeStringToFile
argument_list|(
name|localFs
argument_list|,
name|localFilePath
argument_list|,
literal|"Testing"
argument_list|)
expr_stmt|;
name|Path
name|dstPath
init|=
name|methodPath
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
name|FileUtil
operator|.
name|copy
argument_list|(
name|localFs
argument_list|,
name|localFilePath
argument_list|,
name|fs
argument_list|,
name|dstPath
argument_list|,
literal|false
argument_list|,
name|fs
operator|.
name|getConf
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|assertPathExists
argument_list|(
literal|"coied from local"
argument_list|,
name|dstPath
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Testing"
argument_list|,
name|readStringFromFile
argument_list|(
name|fs
argument_list|,
name|dstPath
argument_list|)
argument_list|)
expr_stmt|;
name|fs
operator|.
name|delete
argument_list|(
name|dstPath
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|localFs
operator|.
name|delete
argument_list|(
name|localFilePath
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Test
DECL|method|testListDirectory ()
specifier|public
name|void
name|testListDirectory
parameter_list|()
throws|throws
name|Exception
block|{
name|Path
name|rootFolder
init|=
operator|new
name|Path
argument_list|(
literal|"testingList"
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|fs
operator|.
name|mkdirs
argument_list|(
name|rootFolder
argument_list|)
argument_list|)
expr_stmt|;
name|FileStatus
index|[]
name|listed
init|=
name|fs
operator|.
name|listStatus
argument_list|(
name|rootFolder
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|listed
operator|.
name|length
argument_list|)
expr_stmt|;
name|Path
name|innerFolder
init|=
operator|new
name|Path
argument_list|(
name|rootFolder
argument_list|,
literal|"inner"
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|fs
operator|.
name|mkdirs
argument_list|(
name|innerFolder
argument_list|)
argument_list|)
expr_stmt|;
name|listed
operator|=
name|fs
operator|.
name|listStatus
argument_list|(
name|rootFolder
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|listed
operator|.
name|length
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|listed
index|[
literal|0
index|]
operator|.
name|isDirectory
argument_list|()
argument_list|)
expr_stmt|;
name|Path
name|innerFile
init|=
operator|new
name|Path
argument_list|(
name|innerFolder
argument_list|,
literal|"innerFile"
argument_list|)
decl_stmt|;
name|writeString
argument_list|(
name|innerFile
argument_list|,
literal|"testing"
argument_list|)
expr_stmt|;
name|listed
operator|=
name|fs
operator|.
name|listStatus
argument_list|(
name|rootFolder
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|listed
operator|.
name|length
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|listed
index|[
literal|0
index|]
operator|.
name|isDirectory
argument_list|()
argument_list|)
expr_stmt|;
name|listed
operator|=
name|fs
operator|.
name|listStatus
argument_list|(
name|innerFolder
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|listed
operator|.
name|length
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|listed
index|[
literal|0
index|]
operator|.
name|isDirectory
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|fs
operator|.
name|delete
argument_list|(
name|rootFolder
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testUriEncoding ()
specifier|public
name|void
name|testUriEncoding
parameter_list|()
throws|throws
name|Exception
block|{
name|fs
operator|.
name|create
argument_list|(
operator|new
name|Path
argument_list|(
literal|"p/t%5Fe"
argument_list|)
argument_list|)
operator|.
name|close
argument_list|()
expr_stmt|;
name|FileStatus
index|[]
name|listing
init|=
name|fs
operator|.
name|listStatus
argument_list|(
operator|new
name|Path
argument_list|(
literal|"p"
argument_list|)
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|listing
operator|.
name|length
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"t%5Fe"
argument_list|,
name|listing
index|[
literal|0
index|]
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|fs
operator|.
name|rename
argument_list|(
operator|new
name|Path
argument_list|(
literal|"p"
argument_list|)
argument_list|,
operator|new
name|Path
argument_list|(
literal|"q"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|fs
operator|.
name|delete
argument_list|(
operator|new
name|Path
argument_list|(
literal|"q"
argument_list|)
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testUriEncodingMoreComplexCharacters ()
specifier|public
name|void
name|testUriEncodingMoreComplexCharacters
parameter_list|()
throws|throws
name|Exception
block|{
comment|// Create a file name with URI reserved characters, plus the percent
name|String
name|fileName
init|=
literal|"!#$'()*;=[]%"
decl_stmt|;
name|String
name|directoryName
init|=
literal|"*;=[]%!#$'()"
decl_stmt|;
name|fs
operator|.
name|create
argument_list|(
operator|new
name|Path
argument_list|(
name|directoryName
argument_list|,
name|fileName
argument_list|)
argument_list|)
operator|.
name|close
argument_list|()
expr_stmt|;
name|FileStatus
index|[]
name|listing
init|=
name|fs
operator|.
name|listStatus
argument_list|(
operator|new
name|Path
argument_list|(
name|directoryName
argument_list|)
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|listing
operator|.
name|length
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|fileName
argument_list|,
name|listing
index|[
literal|0
index|]
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|FileStatus
name|status
init|=
name|fs
operator|.
name|getFileStatus
argument_list|(
operator|new
name|Path
argument_list|(
name|directoryName
argument_list|,
name|fileName
argument_list|)
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|fileName
argument_list|,
name|status
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|InputStream
name|stream
init|=
name|fs
operator|.
name|open
argument_list|(
operator|new
name|Path
argument_list|(
name|directoryName
argument_list|,
name|fileName
argument_list|)
argument_list|)
decl_stmt|;
name|assertNotNull
argument_list|(
name|stream
argument_list|)
expr_stmt|;
name|stream
operator|.
name|close
argument_list|()
expr_stmt|;
name|assertTrue
argument_list|(
name|fs
operator|.
name|delete
argument_list|(
operator|new
name|Path
argument_list|(
name|directoryName
argument_list|,
name|fileName
argument_list|)
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|fs
operator|.
name|delete
argument_list|(
operator|new
name|Path
argument_list|(
name|directoryName
argument_list|)
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testChineseCharacters ()
specifier|public
name|void
name|testChineseCharacters
parameter_list|()
throws|throws
name|Exception
block|{
comment|// Create a file and a folder with Chinese (non-ASCI) characters
name|String
name|chinese
init|=
literal|""
operator|+
literal|'\u963f'
operator|+
literal|'\u4db5'
decl_stmt|;
name|String
name|fileName
init|=
literal|"filename"
operator|+
name|chinese
decl_stmt|;
name|String
name|directoryName
init|=
name|chinese
decl_stmt|;
name|fs
operator|.
name|create
argument_list|(
operator|new
name|Path
argument_list|(
name|directoryName
argument_list|,
name|fileName
argument_list|)
argument_list|)
operator|.
name|close
argument_list|()
expr_stmt|;
name|FileStatus
index|[]
name|listing
init|=
name|fs
operator|.
name|listStatus
argument_list|(
operator|new
name|Path
argument_list|(
name|directoryName
argument_list|)
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|listing
operator|.
name|length
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|fileName
argument_list|,
name|listing
index|[
literal|0
index|]
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|FileStatus
name|status
init|=
name|fs
operator|.
name|getFileStatus
argument_list|(
operator|new
name|Path
argument_list|(
name|directoryName
argument_list|,
name|fileName
argument_list|)
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|fileName
argument_list|,
name|status
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|InputStream
name|stream
init|=
name|fs
operator|.
name|open
argument_list|(
operator|new
name|Path
argument_list|(
name|directoryName
argument_list|,
name|fileName
argument_list|)
argument_list|)
decl_stmt|;
name|assertNotNull
argument_list|(
name|stream
argument_list|)
expr_stmt|;
name|stream
operator|.
name|close
argument_list|()
expr_stmt|;
name|assertTrue
argument_list|(
name|fs
operator|.
name|delete
argument_list|(
operator|new
name|Path
argument_list|(
name|directoryName
argument_list|,
name|fileName
argument_list|)
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|fs
operator|.
name|delete
argument_list|(
operator|new
name|Path
argument_list|(
name|directoryName
argument_list|)
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testChineseCharactersFolderRename ()
specifier|public
name|void
name|testChineseCharactersFolderRename
parameter_list|()
throws|throws
name|Exception
block|{
comment|// Create a file and a folder with Chinese (non-ASCI) characters
name|String
name|chinese
init|=
literal|""
operator|+
literal|'\u963f'
operator|+
literal|'\u4db5'
decl_stmt|;
name|String
name|fileName
init|=
literal|"filename"
operator|+
name|chinese
decl_stmt|;
name|String
name|srcDirectoryName
init|=
name|chinese
decl_stmt|;
name|String
name|targetDirectoryName
init|=
literal|"target"
operator|+
name|chinese
decl_stmt|;
name|fs
operator|.
name|create
argument_list|(
operator|new
name|Path
argument_list|(
name|srcDirectoryName
argument_list|,
name|fileName
argument_list|)
argument_list|)
operator|.
name|close
argument_list|()
expr_stmt|;
name|fs
operator|.
name|rename
argument_list|(
operator|new
name|Path
argument_list|(
name|srcDirectoryName
argument_list|)
argument_list|,
operator|new
name|Path
argument_list|(
name|targetDirectoryName
argument_list|)
argument_list|)
expr_stmt|;
name|FileStatus
index|[]
name|listing
init|=
name|fs
operator|.
name|listStatus
argument_list|(
operator|new
name|Path
argument_list|(
name|targetDirectoryName
argument_list|)
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|listing
operator|.
name|length
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|fileName
argument_list|,
name|listing
index|[
literal|0
index|]
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|FileStatus
name|status
init|=
name|fs
operator|.
name|getFileStatus
argument_list|(
operator|new
name|Path
argument_list|(
name|targetDirectoryName
argument_list|,
name|fileName
argument_list|)
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|fileName
argument_list|,
name|status
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|fs
operator|.
name|delete
argument_list|(
operator|new
name|Path
argument_list|(
name|targetDirectoryName
argument_list|,
name|fileName
argument_list|)
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|fs
operator|.
name|delete
argument_list|(
operator|new
name|Path
argument_list|(
name|targetDirectoryName
argument_list|)
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testReadingDirectoryAsFile ()
specifier|public
name|void
name|testReadingDirectoryAsFile
parameter_list|()
throws|throws
name|Exception
block|{
name|Path
name|dir
init|=
name|methodPath
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
name|fs
operator|.
name|mkdirs
argument_list|(
name|dir
argument_list|)
argument_list|)
expr_stmt|;
try|try
block|{
name|fs
operator|.
name|open
argument_list|(
name|dir
argument_list|)
operator|.
name|close
argument_list|()
expr_stmt|;
name|assertTrue
argument_list|(
literal|"Should've thrown"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|ex
parameter_list|)
block|{
name|assertExceptionContains
argument_list|(
literal|"a directory not a file."
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Test
DECL|method|testCreatingFileOverDirectory ()
specifier|public
name|void
name|testCreatingFileOverDirectory
parameter_list|()
throws|throws
name|Exception
block|{
name|Path
name|dir
init|=
name|methodPath
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
name|fs
operator|.
name|mkdirs
argument_list|(
name|dir
argument_list|)
argument_list|)
expr_stmt|;
try|try
block|{
name|fs
operator|.
name|create
argument_list|(
name|dir
argument_list|)
operator|.
name|close
argument_list|()
expr_stmt|;
name|assertTrue
argument_list|(
literal|"Should've thrown"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
name|assertExceptionContains
argument_list|(
literal|"Cannot create file"
argument_list|,
name|ex
argument_list|)
expr_stmt|;
name|assertExceptionContains
argument_list|(
literal|"already exists as a directory"
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Test
DECL|method|testInputStreamReadWithZeroSizeBuffer ()
specifier|public
name|void
name|testInputStreamReadWithZeroSizeBuffer
parameter_list|()
throws|throws
name|Exception
block|{
name|Path
name|newFile
init|=
name|methodPath
argument_list|()
decl_stmt|;
name|OutputStream
name|output
init|=
name|fs
operator|.
name|create
argument_list|(
name|newFile
argument_list|)
decl_stmt|;
name|output
operator|.
name|write
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|output
operator|.
name|close
argument_list|()
expr_stmt|;
name|InputStream
name|input
init|=
name|fs
operator|.
name|open
argument_list|(
name|newFile
argument_list|)
decl_stmt|;
name|int
name|result
init|=
name|input
operator|.
name|read
argument_list|(
operator|new
name|byte
index|[
literal|2
index|]
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testInputStreamReadWithBufferReturnsMinusOneOnEof ()
specifier|public
name|void
name|testInputStreamReadWithBufferReturnsMinusOneOnEof
parameter_list|()
throws|throws
name|Exception
block|{
name|Path
name|newFile
init|=
name|methodPath
argument_list|()
decl_stmt|;
name|OutputStream
name|output
init|=
name|fs
operator|.
name|create
argument_list|(
name|newFile
argument_list|)
decl_stmt|;
name|output
operator|.
name|write
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|output
operator|.
name|close
argument_list|()
expr_stmt|;
comment|// Read first byte back
name|InputStream
name|input
init|=
name|fs
operator|.
name|open
argument_list|(
name|newFile
argument_list|)
decl_stmt|;
name|byte
index|[]
name|buff
init|=
operator|new
name|byte
index|[
literal|1
index|]
decl_stmt|;
name|int
name|result
init|=
name|input
operator|.
name|read
argument_list|(
name|buff
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|10
argument_list|,
name|buff
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|// Issue another read and make sure it returns -1
name|buff
index|[
literal|0
index|]
operator|=
literal|2
expr_stmt|;
name|result
operator|=
name|input
operator|.
name|read
argument_list|(
name|buff
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
operator|-
literal|1
argument_list|,
name|result
argument_list|)
expr_stmt|;
comment|// Buffer is intact
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|buff
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testInputStreamReadWithBufferReturnsMinusOneOnEofForLargeBuffer ()
specifier|public
name|void
name|testInputStreamReadWithBufferReturnsMinusOneOnEofForLargeBuffer
parameter_list|()
throws|throws
name|Exception
block|{
name|Path
name|newFile
init|=
name|methodPath
argument_list|()
decl_stmt|;
name|OutputStream
name|output
init|=
name|fs
operator|.
name|create
argument_list|(
name|newFile
argument_list|)
decl_stmt|;
name|byte
index|[]
name|outputBuff
init|=
operator|new
name|byte
index|[
literal|97331
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|outputBuff
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
name|outputBuff
index|[
name|i
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
name|Math
operator|.
name|random
argument_list|()
operator|*
literal|255
argument_list|)
expr_stmt|;
block|}
name|output
operator|.
name|write
argument_list|(
name|outputBuff
argument_list|)
expr_stmt|;
name|output
operator|.
name|close
argument_list|()
expr_stmt|;
comment|// Read the content of the file
name|InputStream
name|input
init|=
name|fs
operator|.
name|open
argument_list|(
name|newFile
argument_list|)
decl_stmt|;
name|byte
index|[]
name|buff
init|=
operator|new
name|byte
index|[
literal|131072
index|]
decl_stmt|;
name|int
name|result
init|=
name|input
operator|.
name|read
argument_list|(
name|buff
argument_list|,
literal|0
argument_list|,
name|buff
operator|.
name|length
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|outputBuff
operator|.
name|length
argument_list|,
name|result
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|outputBuff
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
name|assertEquals
argument_list|(
name|outputBuff
index|[
name|i
index|]
argument_list|,
name|buff
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|// Issue another read and make sure it returns -1
name|buff
operator|=
operator|new
name|byte
index|[
literal|131072
index|]
expr_stmt|;
name|result
operator|=
name|input
operator|.
name|read
argument_list|(
name|buff
argument_list|,
literal|0
argument_list|,
name|buff
operator|.
name|length
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
operator|-
literal|1
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testInputStreamReadIntReturnsMinusOneOnEof ()
specifier|public
name|void
name|testInputStreamReadIntReturnsMinusOneOnEof
parameter_list|()
throws|throws
name|Exception
block|{
name|Path
name|newFile
init|=
name|methodPath
argument_list|()
decl_stmt|;
name|OutputStream
name|output
init|=
name|fs
operator|.
name|create
argument_list|(
name|newFile
argument_list|)
decl_stmt|;
name|output
operator|.
name|write
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|output
operator|.
name|close
argument_list|()
expr_stmt|;
comment|// Read first byte back
name|InputStream
name|input
init|=
name|fs
operator|.
name|open
argument_list|(
name|newFile
argument_list|)
decl_stmt|;
name|int
name|value
init|=
name|input
operator|.
name|read
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
literal|10
argument_list|,
name|value
argument_list|)
expr_stmt|;
comment|// Issue another read and make sure it returns -1
name|value
operator|=
name|input
operator|.
name|read
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
operator|-
literal|1
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testSetPermissionOnFile ()
specifier|public
name|void
name|testSetPermissionOnFile
parameter_list|()
throws|throws
name|Exception
block|{
name|Path
name|newFile
init|=
name|methodPath
argument_list|()
decl_stmt|;
name|OutputStream
name|output
init|=
name|fs
operator|.
name|create
argument_list|(
name|newFile
argument_list|)
decl_stmt|;
name|output
operator|.
name|write
argument_list|(
literal|13
argument_list|)
expr_stmt|;
name|output
operator|.
name|close
argument_list|()
expr_stmt|;
name|FsPermission
name|newPermission
init|=
operator|new
name|FsPermission
argument_list|(
operator|(
name|short
operator|)
literal|0700
argument_list|)
decl_stmt|;
name|fs
operator|.
name|setPermission
argument_list|(
name|newFile
argument_list|,
name|newPermission
argument_list|)
expr_stmt|;
name|FileStatus
name|newStatus
init|=
name|fs
operator|.
name|getFileStatus
argument_list|(
name|newFile
argument_list|)
decl_stmt|;
name|assertNotNull
argument_list|(
name|newStatus
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|newPermission
argument_list|,
name|newStatus
operator|.
name|getPermission
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"supergroup"
argument_list|,
name|newStatus
operator|.
name|getGroup
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|UserGroupInformation
operator|.
name|getCurrentUser
argument_list|()
operator|.
name|getShortUserName
argument_list|()
argument_list|,
name|newStatus
operator|.
name|getOwner
argument_list|()
argument_list|)
expr_stmt|;
comment|// Don't check the file length for page blobs. Only block blobs
comment|// provide the actual length of bytes written.
if|if
condition|(
operator|!
operator|(
name|this
operator|instanceof
name|ITestNativeAzureFSPageBlobLive
operator|)
condition|)
block|{
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|newStatus
operator|.
name|getLen
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Test
DECL|method|testSetPermissionOnFolder ()
specifier|public
name|void
name|testSetPermissionOnFolder
parameter_list|()
throws|throws
name|Exception
block|{
name|Path
name|newFolder
init|=
name|methodPath
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
name|fs
operator|.
name|mkdirs
argument_list|(
name|newFolder
argument_list|)
argument_list|)
expr_stmt|;
name|FsPermission
name|newPermission
init|=
operator|new
name|FsPermission
argument_list|(
operator|(
name|short
operator|)
literal|0600
argument_list|)
decl_stmt|;
name|fs
operator|.
name|setPermission
argument_list|(
name|newFolder
argument_list|,
name|newPermission
argument_list|)
expr_stmt|;
name|FileStatus
name|newStatus
init|=
name|fs
operator|.
name|getFileStatus
argument_list|(
name|newFolder
argument_list|)
decl_stmt|;
name|assertNotNull
argument_list|(
name|newStatus
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|newPermission
argument_list|,
name|newStatus
operator|.
name|getPermission
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|newStatus
operator|.
name|isDirectory
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testSetOwnerOnFile ()
specifier|public
name|void
name|testSetOwnerOnFile
parameter_list|()
throws|throws
name|Exception
block|{
name|Path
name|newFile
init|=
name|methodPath
argument_list|()
decl_stmt|;
name|OutputStream
name|output
init|=
name|fs
operator|.
name|create
argument_list|(
name|newFile
argument_list|)
decl_stmt|;
name|output
operator|.
name|write
argument_list|(
literal|13
argument_list|)
expr_stmt|;
name|output
operator|.
name|close
argument_list|()
expr_stmt|;
name|fs
operator|.
name|setOwner
argument_list|(
name|newFile
argument_list|,
literal|"newUser"
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|FileStatus
name|newStatus
init|=
name|fs
operator|.
name|getFileStatus
argument_list|(
name|newFile
argument_list|)
decl_stmt|;
name|assertNotNull
argument_list|(
name|newStatus
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"newUser"
argument_list|,
name|newStatus
operator|.
name|getOwner
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"supergroup"
argument_list|,
name|newStatus
operator|.
name|getGroup
argument_list|()
argument_list|)
expr_stmt|;
comment|// File length is only reported to be the size of bytes written to the file for block blobs.
comment|// So only check it for block blobs, not page blobs.
if|if
condition|(
operator|!
operator|(
name|this
operator|instanceof
name|ITestNativeAzureFSPageBlobLive
operator|)
condition|)
block|{
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|newStatus
operator|.
name|getLen
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|fs
operator|.
name|setOwner
argument_list|(
name|newFile
argument_list|,
literal|null
argument_list|,
literal|"newGroup"
argument_list|)
expr_stmt|;
name|newStatus
operator|=
name|fs
operator|.
name|getFileStatus
argument_list|(
name|newFile
argument_list|)
expr_stmt|;
name|assertNotNull
argument_list|(
name|newStatus
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"newUser"
argument_list|,
name|newStatus
operator|.
name|getOwner
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"newGroup"
argument_list|,
name|newStatus
operator|.
name|getGroup
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testSetOwnerOnFolder ()
specifier|public
name|void
name|testSetOwnerOnFolder
parameter_list|()
throws|throws
name|Exception
block|{
name|Path
name|newFolder
init|=
name|methodPath
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
name|fs
operator|.
name|mkdirs
argument_list|(
name|newFolder
argument_list|)
argument_list|)
expr_stmt|;
name|fs
operator|.
name|setOwner
argument_list|(
name|newFolder
argument_list|,
literal|"newUser"
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|FileStatus
name|newStatus
init|=
name|fs
operator|.
name|getFileStatus
argument_list|(
name|newFolder
argument_list|)
decl_stmt|;
name|assertNotNull
argument_list|(
name|newStatus
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"newUser"
argument_list|,
name|newStatus
operator|.
name|getOwner
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|newStatus
operator|.
name|isDirectory
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testModifiedTimeForFile ()
specifier|public
name|void
name|testModifiedTimeForFile
parameter_list|()
throws|throws
name|Exception
block|{
name|Path
name|testFile
init|=
name|methodPath
argument_list|()
decl_stmt|;
name|fs
operator|.
name|create
argument_list|(
name|testFile
argument_list|)
operator|.
name|close
argument_list|()
expr_stmt|;
name|testModifiedTime
argument_list|(
name|testFile
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testModifiedTimeForFolder ()
specifier|public
name|void
name|testModifiedTimeForFolder
parameter_list|()
throws|throws
name|Exception
block|{
name|Path
name|testFolder
init|=
name|methodPath
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
name|fs
operator|.
name|mkdirs
argument_list|(
name|testFolder
argument_list|)
argument_list|)
expr_stmt|;
name|testModifiedTime
argument_list|(
name|testFolder
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testFolderLastModifiedTime ()
specifier|public
name|void
name|testFolderLastModifiedTime
parameter_list|()
throws|throws
name|Exception
block|{
name|Path
name|parentFolder
init|=
name|methodPath
argument_list|()
decl_stmt|;
name|Path
name|innerFile
init|=
operator|new
name|Path
argument_list|(
name|parentFolder
argument_list|,
literal|"innerfile"
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|fs
operator|.
name|mkdirs
argument_list|(
name|parentFolder
argument_list|)
argument_list|)
expr_stmt|;
comment|// Create file
name|long
name|lastModifiedTime
init|=
name|fs
operator|.
name|getFileStatus
argument_list|(
name|parentFolder
argument_list|)
operator|.
name|getModificationTime
argument_list|()
decl_stmt|;
comment|// Wait at least the error margin
name|Thread
operator|.
name|sleep
argument_list|(
name|modifiedTimeErrorMargin
operator|+
literal|1
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|fs
operator|.
name|createNewFile
argument_list|(
name|innerFile
argument_list|)
argument_list|)
expr_stmt|;
comment|// The parent folder last modified time should have changed because we
comment|// create an inner file.
name|assertFalse
argument_list|(
name|testModifiedTime
argument_list|(
name|parentFolder
argument_list|,
name|lastModifiedTime
argument_list|)
argument_list|)
expr_stmt|;
name|testModifiedTime
argument_list|(
name|parentFolder
argument_list|)
expr_stmt|;
comment|// Rename file
name|lastModifiedTime
operator|=
name|fs
operator|.
name|getFileStatus
argument_list|(
name|parentFolder
argument_list|)
operator|.
name|getModificationTime
argument_list|()
expr_stmt|;
name|Path
name|destFolder
init|=
operator|new
name|Path
argument_list|(
literal|"testDestFolder"
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|fs
operator|.
name|mkdirs
argument_list|(
name|destFolder
argument_list|)
argument_list|)
expr_stmt|;
name|long
name|destLastModifiedTime
init|=
name|fs
operator|.
name|getFileStatus
argument_list|(
name|destFolder
argument_list|)
operator|.
name|getModificationTime
argument_list|()
decl_stmt|;
name|Thread
operator|.
name|sleep
argument_list|(
name|modifiedTimeErrorMargin
operator|+
literal|1
argument_list|)
expr_stmt|;
name|Path
name|destFile
init|=
operator|new
name|Path
argument_list|(
name|destFolder
argument_list|,
literal|"innerfile"
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|fs
operator|.
name|rename
argument_list|(
name|innerFile
argument_list|,
name|destFile
argument_list|)
argument_list|)
expr_stmt|;
comment|// Both source and destination folder last modified time should have changed
comment|// because of renaming.
name|assertFalse
argument_list|(
name|testModifiedTime
argument_list|(
name|parentFolder
argument_list|,
name|lastModifiedTime
argument_list|)
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|testModifiedTime
argument_list|(
name|destFolder
argument_list|,
name|destLastModifiedTime
argument_list|)
argument_list|)
expr_stmt|;
name|testModifiedTime
argument_list|(
name|parentFolder
argument_list|)
expr_stmt|;
name|testModifiedTime
argument_list|(
name|destFolder
argument_list|)
expr_stmt|;
comment|// Delete file
name|destLastModifiedTime
operator|=
name|fs
operator|.
name|getFileStatus
argument_list|(
name|destFolder
argument_list|)
operator|.
name|getModificationTime
argument_list|()
expr_stmt|;
comment|// Wait at least the error margin
name|Thread
operator|.
name|sleep
argument_list|(
name|modifiedTimeErrorMargin
operator|+
literal|1
argument_list|)
expr_stmt|;
name|fs
operator|.
name|delete
argument_list|(
name|destFile
argument_list|,
literal|false
argument_list|)
expr_stmt|;
comment|// The parent folder last modified time should have changed because we
comment|// delete an inner file.
name|assertFalse
argument_list|(
name|testModifiedTime
argument_list|(
name|destFolder
argument_list|,
name|destLastModifiedTime
argument_list|)
argument_list|)
expr_stmt|;
name|testModifiedTime
argument_list|(
name|destFolder
argument_list|)
expr_stmt|;
block|}
comment|/**    * Verify we can get file status of a directory with various forms of    * the directory file name, including the nonstandard but legal form    * ending in "/.". Check that we're getting status for a directory.    */
annotation|@
name|Test
DECL|method|testListSlash ()
specifier|public
name|void
name|testListSlash
parameter_list|()
throws|throws
name|Exception
block|{
name|Path
name|testFolder
init|=
operator|new
name|Path
argument_list|(
literal|"/testFolder"
argument_list|)
decl_stmt|;
name|Path
name|testFile
init|=
operator|new
name|Path
argument_list|(
name|testFolder
argument_list|,
literal|"testFile"
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|fs
operator|.
name|mkdirs
argument_list|(
name|testFolder
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|fs
operator|.
name|createNewFile
argument_list|(
name|testFile
argument_list|)
argument_list|)
expr_stmt|;
name|FileStatus
name|status
decl_stmt|;
name|status
operator|=
name|fs
operator|.
name|getFileStatus
argument_list|(
operator|new
name|Path
argument_list|(
literal|"/testFolder"
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|status
operator|.
name|isDirectory
argument_list|()
argument_list|)
expr_stmt|;
name|status
operator|=
name|fs
operator|.
name|getFileStatus
argument_list|(
operator|new
name|Path
argument_list|(
literal|"/testFolder/"
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|status
operator|.
name|isDirectory
argument_list|()
argument_list|)
expr_stmt|;
name|status
operator|=
name|fs
operator|.
name|getFileStatus
argument_list|(
operator|new
name|Path
argument_list|(
literal|"/testFolder/."
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|status
operator|.
name|isDirectory
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testCannotCreatePageBlobByDefault ()
specifier|public
name|void
name|testCannotCreatePageBlobByDefault
parameter_list|()
throws|throws
name|Exception
block|{
comment|// Verify that the page blob directory list configuration setting
comment|// is not set in the default configuration.
name|Configuration
name|conf
init|=
operator|new
name|Configuration
argument_list|()
decl_stmt|;
name|String
index|[]
name|rawPageBlobDirs
init|=
name|conf
operator|.
name|getStrings
argument_list|(
name|AzureNativeFileSystemStore
operator|.
name|KEY_PAGE_BLOB_DIRECTORIES
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|rawPageBlobDirs
operator|==
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/*    * Set up a situation where a folder rename is partway finished.    * Then apply redo to finish the rename.    *    * The original source folder *would* have had contents    * folderToRename  (0 byte dummy file for directory)    * folderToRename/innerFile    * folderToRename/innerFile2    *    * The actual source folder (after partial rename and failure)    *    * folderToRename    * folderToRename/innerFile2    *    * The actual target folder (after partial rename and failure)    *    * renamedFolder    * renamedFolder/innerFile    */
annotation|@
name|Test
DECL|method|testRedoRenameFolder ()
specifier|public
name|void
name|testRedoRenameFolder
parameter_list|()
throws|throws
name|IOException
block|{
comment|// create original folder
name|String
name|srcKey
init|=
literal|"folderToRename"
decl_stmt|;
name|Path
name|originalFolder
init|=
operator|new
name|Path
argument_list|(
name|srcKey
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|fs
operator|.
name|mkdirs
argument_list|(
name|originalFolder
argument_list|)
argument_list|)
expr_stmt|;
name|Path
name|innerFile
init|=
operator|new
name|Path
argument_list|(
name|originalFolder
argument_list|,
literal|"innerFile"
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|fs
operator|.
name|createNewFile
argument_list|(
name|innerFile
argument_list|)
argument_list|)
expr_stmt|;
name|Path
name|innerFile2
init|=
operator|new
name|Path
argument_list|(
name|originalFolder
argument_list|,
literal|"innerFile2"
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|fs
operator|.
name|createNewFile
argument_list|(
name|innerFile2
argument_list|)
argument_list|)
expr_stmt|;
name|String
name|dstKey
init|=
literal|"renamedFolder"
decl_stmt|;
comment|// propose (but don't do) the rename
name|Path
name|home
init|=
name|fs
operator|.
name|getHomeDirectory
argument_list|()
decl_stmt|;
name|String
name|relativeHomeDir
init|=
name|getRelativePath
argument_list|(
name|home
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
name|NativeAzureFileSystem
operator|.
name|FolderRenamePending
name|pending
init|=
operator|new
name|NativeAzureFileSystem
operator|.
name|FolderRenamePending
argument_list|(
name|relativeHomeDir
operator|+
literal|"/"
operator|+
name|srcKey
argument_list|,
name|relativeHomeDir
operator|+
literal|"/"
operator|+
name|dstKey
argument_list|,
literal|null
argument_list|,
operator|(
name|NativeAzureFileSystem
operator|)
name|fs
argument_list|)
decl_stmt|;
comment|// get the rename pending file contents
name|String
name|renameDescription
init|=
name|pending
operator|.
name|makeRenamePendingFileContents
argument_list|()
decl_stmt|;
comment|// Remove one file from source folder to simulate a partially done
comment|// rename operation.
name|assertTrue
argument_list|(
name|fs
operator|.
name|delete
argument_list|(
name|innerFile
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
comment|// Create the destination folder with just one file in it, again
comment|// to simulate a partially done rename.
name|Path
name|destination
init|=
operator|new
name|Path
argument_list|(
name|dstKey
argument_list|)
decl_stmt|;
name|Path
name|innerDest
init|=
operator|new
name|Path
argument_list|(
name|destination
argument_list|,
literal|"innerFile"
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|fs
operator|.
name|createNewFile
argument_list|(
name|innerDest
argument_list|)
argument_list|)
expr_stmt|;
comment|// Create a rename-pending file and write rename information to it.
specifier|final
name|String
name|renamePendingStr
init|=
literal|"folderToRename-RenamePending.json"
decl_stmt|;
name|Path
name|renamePendingFile
init|=
operator|new
name|Path
argument_list|(
name|renamePendingStr
argument_list|)
decl_stmt|;
name|FSDataOutputStream
name|out
init|=
name|fs
operator|.
name|create
argument_list|(
name|renamePendingFile
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|out
operator|!=
literal|null
argument_list|)
expr_stmt|;
name|writeStringToStream
argument_list|(
name|out
argument_list|,
name|renameDescription
argument_list|)
expr_stmt|;
comment|// Redo the rename operation based on the contents of the -RenamePending.json file.
comment|// Trigger the redo by checking for existence of the original folder. It must appear
comment|// to not exist.
name|assertFalse
argument_list|(
name|fs
operator|.
name|exists
argument_list|(
name|originalFolder
argument_list|)
argument_list|)
expr_stmt|;
comment|// Verify that the target is there, and the source is gone.
name|assertTrue
argument_list|(
name|fs
operator|.
name|exists
argument_list|(
name|destination
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|fs
operator|.
name|exists
argument_list|(
operator|new
name|Path
argument_list|(
name|destination
argument_list|,
name|innerFile
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|fs
operator|.
name|exists
argument_list|(
operator|new
name|Path
argument_list|(
name|destination
argument_list|,
name|innerFile2
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|fs
operator|.
name|exists
argument_list|(
name|originalFolder
argument_list|)
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|fs
operator|.
name|exists
argument_list|(
name|innerFile
argument_list|)
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|fs
operator|.
name|exists
argument_list|(
name|innerFile2
argument_list|)
argument_list|)
expr_stmt|;
comment|// Verify that there's no RenamePending file left.
name|assertFalse
argument_list|(
name|fs
operator|.
name|exists
argument_list|(
name|renamePendingFile
argument_list|)
argument_list|)
expr_stmt|;
comment|// Verify that we can list the target directory.
name|FileStatus
index|[]
name|listed
init|=
name|fs
operator|.
name|listStatus
argument_list|(
name|destination
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|listed
operator|.
name|length
argument_list|)
expr_stmt|;
comment|// List the home directory and show the contents is a directory.
name|Path
name|root
init|=
name|fs
operator|.
name|getHomeDirectory
argument_list|()
decl_stmt|;
name|listed
operator|=
name|fs
operator|.
name|listStatus
argument_list|(
name|root
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|listed
operator|.
name|length
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|listed
index|[
literal|0
index|]
operator|.
name|isDirectory
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * If there is a folder to be renamed inside a parent folder,    * then when you list the parent folder, you should only see    * the final result, after the rename.    */
annotation|@
name|Test
DECL|method|testRedoRenameFolderInFolderListing ()
specifier|public
name|void
name|testRedoRenameFolderInFolderListing
parameter_list|()
throws|throws
name|IOException
block|{
comment|// create original folder
name|String
name|parent
init|=
literal|"parent"
decl_stmt|;
name|Path
name|parentFolder
init|=
operator|new
name|Path
argument_list|(
name|parent
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|fs
operator|.
name|mkdirs
argument_list|(
name|parentFolder
argument_list|)
argument_list|)
expr_stmt|;
name|Path
name|inner
init|=
operator|new
name|Path
argument_list|(
name|parentFolder
argument_list|,
literal|"innerFolder"
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|fs
operator|.
name|mkdirs
argument_list|(
name|inner
argument_list|)
argument_list|)
expr_stmt|;
name|Path
name|inner2
init|=
operator|new
name|Path
argument_list|(
name|parentFolder
argument_list|,
literal|"innerFolder2"
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|fs
operator|.
name|mkdirs
argument_list|(
name|inner2
argument_list|)
argument_list|)
expr_stmt|;
name|Path
name|innerFile
init|=
operator|new
name|Path
argument_list|(
name|inner2
argument_list|,
literal|"file"
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|fs
operator|.
name|createNewFile
argument_list|(
name|innerFile
argument_list|)
argument_list|)
expr_stmt|;
name|Path
name|inner2renamed
init|=
operator|new
name|Path
argument_list|(
name|parentFolder
argument_list|,
literal|"innerFolder2Renamed"
argument_list|)
decl_stmt|;
comment|// propose (but don't do) the rename of innerFolder2
name|Path
name|home
init|=
name|fs
operator|.
name|getHomeDirectory
argument_list|()
decl_stmt|;
name|String
name|relativeHomeDir
init|=
name|getRelativePath
argument_list|(
name|home
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
name|NativeAzureFileSystem
operator|.
name|FolderRenamePending
name|pending
init|=
operator|new
name|NativeAzureFileSystem
operator|.
name|FolderRenamePending
argument_list|(
name|relativeHomeDir
operator|+
literal|"/"
operator|+
name|inner2
argument_list|,
name|relativeHomeDir
operator|+
literal|"/"
operator|+
name|inner2renamed
argument_list|,
literal|null
argument_list|,
operator|(
name|NativeAzureFileSystem
operator|)
name|fs
argument_list|)
decl_stmt|;
comment|// Create a rename-pending file and write rename information to it.
specifier|final
name|String
name|renamePendingStr
init|=
name|inner2
operator|+
name|FolderRenamePending
operator|.
name|SUFFIX
decl_stmt|;
name|Path
name|renamePendingFile
init|=
operator|new
name|Path
argument_list|(
name|renamePendingStr
argument_list|)
decl_stmt|;
name|FSDataOutputStream
name|out
init|=
name|fs
operator|.
name|create
argument_list|(
name|renamePendingFile
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|out
operator|!=
literal|null
argument_list|)
expr_stmt|;
name|writeStringToStream
argument_list|(
name|out
argument_list|,
name|pending
operator|.
name|makeRenamePendingFileContents
argument_list|()
argument_list|)
expr_stmt|;
comment|// Redo the rename operation based on the contents of the
comment|// -RenamePending.json file. Trigger the redo by checking for existence of
comment|// the original folder. It must appear to not exist.
name|FileStatus
index|[]
name|listed
init|=
name|fs
operator|.
name|listStatus
argument_list|(
name|parentFolder
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|listed
operator|.
name|length
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|listed
index|[
literal|0
index|]
operator|.
name|isDirectory
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|listed
index|[
literal|1
index|]
operator|.
name|isDirectory
argument_list|()
argument_list|)
expr_stmt|;
comment|// The rename pending file is not a directory, so at this point we know the
comment|// redo has been done.
name|assertFalse
argument_list|(
name|fs
operator|.
name|exists
argument_list|(
name|inner2
argument_list|)
argument_list|)
expr_stmt|;
comment|// verify original folder is gone
name|assertTrue
argument_list|(
name|fs
operator|.
name|exists
argument_list|(
name|inner2renamed
argument_list|)
argument_list|)
expr_stmt|;
comment|// verify the target is there
name|assertTrue
argument_list|(
name|fs
operator|.
name|exists
argument_list|(
operator|new
name|Path
argument_list|(
name|inner2renamed
argument_list|,
literal|"file"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * There is a nested folder and file under the folder to be renamed    * and the process crashes after the nested folder has been renamed but not the file.    * then when you list the parent folder, pending renames should be redone    * Apache jira HADOOP-12780    */
annotation|@
name|Test
DECL|method|testRedoRenameFolderRenameInProgress ()
specifier|public
name|void
name|testRedoRenameFolderRenameInProgress
parameter_list|()
throws|throws
name|IOException
block|{
comment|// create original folder
name|String
name|parent
init|=
literal|"parent"
decl_stmt|;
name|Path
name|parentFolder
init|=
operator|new
name|Path
argument_list|(
name|parent
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|fs
operator|.
name|mkdirs
argument_list|(
name|parentFolder
argument_list|)
argument_list|)
expr_stmt|;
name|Path
name|folderToBeRenamed
init|=
operator|new
name|Path
argument_list|(
name|parentFolder
argument_list|,
literal|"folderToBeRenamed"
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|fs
operator|.
name|mkdirs
argument_list|(
name|folderToBeRenamed
argument_list|)
argument_list|)
expr_stmt|;
name|String
name|innerFolderName
init|=
literal|"innerFolder"
decl_stmt|;
name|Path
name|inner
init|=
operator|new
name|Path
argument_list|(
name|folderToBeRenamed
argument_list|,
name|innerFolderName
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|fs
operator|.
name|mkdirs
argument_list|(
name|inner
argument_list|)
argument_list|)
expr_stmt|;
name|String
name|innerFileName
init|=
literal|"file"
decl_stmt|;
name|Path
name|innerFile
init|=
operator|new
name|Path
argument_list|(
name|inner
argument_list|,
name|innerFileName
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|fs
operator|.
name|createNewFile
argument_list|(
name|innerFile
argument_list|)
argument_list|)
expr_stmt|;
name|Path
name|renamedFolder
init|=
operator|new
name|Path
argument_list|(
name|parentFolder
argument_list|,
literal|"renamedFolder"
argument_list|)
decl_stmt|;
comment|// propose (but don't do) the rename of innerFolder2
name|Path
name|home
init|=
name|fs
operator|.
name|getHomeDirectory
argument_list|()
decl_stmt|;
name|String
name|relativeHomeDir
init|=
name|getRelativePath
argument_list|(
name|home
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
name|NativeAzureFileSystem
operator|.
name|FolderRenamePending
name|pending
init|=
operator|new
name|NativeAzureFileSystem
operator|.
name|FolderRenamePending
argument_list|(
name|relativeHomeDir
operator|+
literal|"/"
operator|+
name|folderToBeRenamed
argument_list|,
name|relativeHomeDir
operator|+
literal|"/"
operator|+
name|renamedFolder
argument_list|,
literal|null
argument_list|,
operator|(
name|NativeAzureFileSystem
operator|)
name|fs
argument_list|)
decl_stmt|;
comment|// Create a rename-pending file and write rename information to it.
specifier|final
name|String
name|renamePendingStr
init|=
name|folderToBeRenamed
operator|+
name|FolderRenamePending
operator|.
name|SUFFIX
decl_stmt|;
name|Path
name|renamePendingFile
init|=
operator|new
name|Path
argument_list|(
name|renamePendingStr
argument_list|)
decl_stmt|;
name|FSDataOutputStream
name|out
init|=
name|fs
operator|.
name|create
argument_list|(
name|renamePendingFile
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|out
operator|!=
literal|null
argument_list|)
expr_stmt|;
name|writeStringToStream
argument_list|(
name|out
argument_list|,
name|pending
operator|.
name|makeRenamePendingFileContents
argument_list|()
argument_list|)
expr_stmt|;
comment|// Rename inner folder to simulate the scenario where rename has started and
comment|// only one directory has been renamed but not the files under it
operator|(
operator|(
name|NativeAzureFileSystem
operator|)
name|fs
operator|)
operator|.
name|getStoreInterface
argument_list|()
operator|.
name|rename
argument_list|(
name|relativeHomeDir
operator|+
literal|"/"
operator|+
name|inner
argument_list|,
name|relativeHomeDir
operator|+
literal|"/"
operator|+
name|renamedFolder
operator|+
literal|"/"
operator|+
name|innerFolderName
argument_list|,
literal|true
argument_list|,
literal|null
argument_list|)
expr_stmt|;
comment|// Instead of using fs.exist use store.explicitFileExists because fs.exist will return true
comment|// even if directory has been renamed, but there are still file under that directory
name|assertFalse
argument_list|(
operator|(
operator|(
name|NativeAzureFileSystem
operator|)
name|fs
operator|)
operator|.
name|getStoreInterface
argument_list|()
operator|.
name|explicitFileExists
argument_list|(
name|relativeHomeDir
operator|+
literal|"/"
operator|+
name|inner
argument_list|)
argument_list|)
expr_stmt|;
comment|// verify the explicit inner folder is gone
name|assertTrue
argument_list|(
operator|(
operator|(
name|NativeAzureFileSystem
operator|)
name|fs
operator|)
operator|.
name|getStoreInterface
argument_list|()
operator|.
name|explicitFileExists
argument_list|(
name|relativeHomeDir
operator|+
literal|"/"
operator|+
name|innerFile
argument_list|)
argument_list|)
expr_stmt|;
comment|// verify inner file is present
comment|// Redo the rename operation based on the contents of the
comment|// -RenamePending.json file. Trigger the redo by checking for existence of
comment|// the original folder. It must appear to not exist.
name|FileStatus
index|[]
name|listed
init|=
name|fs
operator|.
name|listStatus
argument_list|(
name|parentFolder
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|listed
operator|.
name|length
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|listed
index|[
literal|0
index|]
operator|.
name|isDirectory
argument_list|()
argument_list|)
expr_stmt|;
comment|// The rename pending file is not a directory, so at this point we know the
comment|// redo has been done.
name|assertFalse
argument_list|(
name|fs
operator|.
name|exists
argument_list|(
name|inner
argument_list|)
argument_list|)
expr_stmt|;
comment|// verify original folder is gone
name|assertFalse
argument_list|(
name|fs
operator|.
name|exists
argument_list|(
name|innerFile
argument_list|)
argument_list|)
expr_stmt|;
comment|// verify original file is gone
name|assertTrue
argument_list|(
name|fs
operator|.
name|exists
argument_list|(
name|renamedFolder
argument_list|)
argument_list|)
expr_stmt|;
comment|// verify the target is there
name|assertTrue
argument_list|(
name|fs
operator|.
name|exists
argument_list|(
operator|new
name|Path
argument_list|(
name|renamedFolder
argument_list|,
name|innerFolderName
operator|+
literal|"/"
operator|+
name|innerFileName
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Test the situation when the rename metadata file is empty    * i.e. it is created but not written yet. In that case in next rename    * this empty file should be deleted. As zero byte metadata file means    * rename has not started yet. This is to emulate the scenario where    * the process crashes just after creating rename metadata file.    *  We had a bug (HADOOP-12678) that in that case listing used to fail and    * hbase master did not use to come up    */
annotation|@
name|Test
DECL|method|testRedoRenameFolderInFolderListingWithZeroByteRenameMetadata ()
specifier|public
name|void
name|testRedoRenameFolderInFolderListingWithZeroByteRenameMetadata
parameter_list|()
throws|throws
name|IOException
block|{
comment|// create original folder
name|String
name|parent
init|=
literal|"parent"
decl_stmt|;
name|Path
name|parentFolder
init|=
operator|new
name|Path
argument_list|(
name|parent
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|fs
operator|.
name|mkdirs
argument_list|(
name|parentFolder
argument_list|)
argument_list|)
expr_stmt|;
name|Path
name|inner
init|=
operator|new
name|Path
argument_list|(
name|parentFolder
argument_list|,
literal|"innerFolder"
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|fs
operator|.
name|mkdirs
argument_list|(
name|inner
argument_list|)
argument_list|)
expr_stmt|;
name|Path
name|inner2
init|=
operator|new
name|Path
argument_list|(
name|parentFolder
argument_list|,
literal|"innerFolder2"
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|fs
operator|.
name|mkdirs
argument_list|(
name|inner2
argument_list|)
argument_list|)
expr_stmt|;
name|Path
name|innerFile
init|=
operator|new
name|Path
argument_list|(
name|inner2
argument_list|,
literal|"file"
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|fs
operator|.
name|createNewFile
argument_list|(
name|innerFile
argument_list|)
argument_list|)
expr_stmt|;
name|Path
name|inner2renamed
init|=
operator|new
name|Path
argument_list|(
name|parentFolder
argument_list|,
literal|"innerFolder2Renamed"
argument_list|)
decl_stmt|;
comment|// Create an empty rename-pending file
specifier|final
name|String
name|renamePendingStr
init|=
name|inner2
operator|+
name|FolderRenamePending
operator|.
name|SUFFIX
decl_stmt|;
name|Path
name|renamePendingFile
init|=
operator|new
name|Path
argument_list|(
name|renamePendingStr
argument_list|)
decl_stmt|;
name|FSDataOutputStream
name|out
init|=
name|fs
operator|.
name|create
argument_list|(
name|renamePendingFile
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|out
operator|!=
literal|null
argument_list|)
expr_stmt|;
name|out
operator|.
name|close
argument_list|()
expr_stmt|;
comment|// Redo the rename operation based on the contents of the
comment|// -RenamePending.json file. Trigger the redo by listing
comment|// the parent folder. It should not throw and it should
comment|// delete empty rename pending file
name|FileStatus
index|[]
name|listed
init|=
name|fs
operator|.
name|listStatus
argument_list|(
name|parentFolder
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|listed
operator|.
name|length
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|listed
index|[
literal|0
index|]
operator|.
name|isDirectory
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|listed
index|[
literal|1
index|]
operator|.
name|isDirectory
argument_list|()
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|fs
operator|.
name|exists
argument_list|(
name|renamePendingFile
argument_list|)
argument_list|)
expr_stmt|;
comment|// Verify that even if rename pending file is deleted,
comment|// deletion should handle that
name|Path
name|home
init|=
name|fs
operator|.
name|getHomeDirectory
argument_list|()
decl_stmt|;
name|String
name|relativeHomeDir
init|=
name|getRelativePath
argument_list|(
name|home
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
name|NativeAzureFileSystem
operator|.
name|FolderRenamePending
name|pending
init|=
operator|new
name|NativeAzureFileSystem
operator|.
name|FolderRenamePending
argument_list|(
name|relativeHomeDir
operator|+
literal|"/"
operator|+
name|inner2
argument_list|,
name|relativeHomeDir
operator|+
literal|"/"
operator|+
name|inner2renamed
argument_list|,
literal|null
argument_list|,
operator|(
name|NativeAzureFileSystem
operator|)
name|fs
argument_list|)
decl_stmt|;
name|pending
operator|.
name|deleteRenamePendingFile
argument_list|(
name|fs
argument_list|,
name|renamePendingFile
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|fs
operator|.
name|exists
argument_list|(
name|inner2
argument_list|)
argument_list|)
expr_stmt|;
comment|// verify original folder is there
name|assertFalse
argument_list|(
name|fs
operator|.
name|exists
argument_list|(
name|inner2renamed
argument_list|)
argument_list|)
expr_stmt|;
comment|// verify the target is not there
block|}
comment|/**    * Test the situation where a rename pending file exists but the rename    * is really done. This could happen if the rename process died just    * before deleting the rename pending file. It exercises a non-standard    * code path in redo().    */
annotation|@
name|Test
DECL|method|testRenameRedoFolderAlreadyDone ()
specifier|public
name|void
name|testRenameRedoFolderAlreadyDone
parameter_list|()
throws|throws
name|IOException
block|{
comment|// create only destination folder
name|String
name|orig
init|=
literal|"originalFolder"
decl_stmt|;
name|String
name|dest
init|=
literal|"renamedFolder"
decl_stmt|;
name|Path
name|destPath
init|=
operator|new
name|Path
argument_list|(
name|dest
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|fs
operator|.
name|mkdirs
argument_list|(
name|destPath
argument_list|)
argument_list|)
expr_stmt|;
comment|// propose (but don't do) the rename of innerFolder2
name|Path
name|home
init|=
name|fs
operator|.
name|getHomeDirectory
argument_list|()
decl_stmt|;
name|String
name|relativeHomeDir
init|=
name|getRelativePath
argument_list|(
name|home
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
name|NativeAzureFileSystem
operator|.
name|FolderRenamePending
name|pending
init|=
operator|new
name|NativeAzureFileSystem
operator|.
name|FolderRenamePending
argument_list|(
name|relativeHomeDir
operator|+
literal|"/"
operator|+
name|orig
argument_list|,
name|relativeHomeDir
operator|+
literal|"/"
operator|+
name|dest
argument_list|,
literal|null
argument_list|,
operator|(
name|NativeAzureFileSystem
operator|)
name|fs
argument_list|)
decl_stmt|;
comment|// Create a rename-pending file and write rename information to it.
specifier|final
name|String
name|renamePendingStr
init|=
name|orig
operator|+
name|FolderRenamePending
operator|.
name|SUFFIX
decl_stmt|;
name|Path
name|renamePendingFile
init|=
operator|new
name|Path
argument_list|(
name|renamePendingStr
argument_list|)
decl_stmt|;
name|FSDataOutputStream
name|out
init|=
name|fs
operator|.
name|create
argument_list|(
name|renamePendingFile
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|out
operator|!=
literal|null
argument_list|)
expr_stmt|;
name|writeStringToStream
argument_list|(
name|out
argument_list|,
name|pending
operator|.
name|makeRenamePendingFileContents
argument_list|()
argument_list|)
expr_stmt|;
try|try
block|{
name|pending
operator|.
name|redo
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|fail
argument_list|()
expr_stmt|;
block|}
comment|// Make sure rename pending file is gone.
name|FileStatus
index|[]
name|listed
init|=
name|fs
operator|.
name|listStatus
argument_list|(
operator|new
name|Path
argument_list|(
literal|"/"
argument_list|)
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|"Pending directory still found"
argument_list|,
literal|1
argument_list|,
name|listed
operator|.
name|length
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|listed
index|[
literal|0
index|]
operator|.
name|isDirectory
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testRedoFolderRenameAll ()
specifier|public
name|void
name|testRedoFolderRenameAll
parameter_list|()
throws|throws
name|IllegalArgumentException
throws|,
name|IOException
block|{
block|{
name|FileFolder
name|original
init|=
operator|new
name|FileFolder
argument_list|(
literal|"folderToRename"
argument_list|)
decl_stmt|;
name|original
operator|.
name|add
argument_list|(
literal|"innerFile"
argument_list|)
operator|.
name|add
argument_list|(
literal|"innerFile2"
argument_list|)
expr_stmt|;
name|FileFolder
name|partialSrc
init|=
name|original
operator|.
name|copy
argument_list|()
decl_stmt|;
name|FileFolder
name|partialDst
init|=
name|original
operator|.
name|copy
argument_list|()
decl_stmt|;
name|partialDst
operator|.
name|setName
argument_list|(
literal|"renamedFolder"
argument_list|)
expr_stmt|;
name|partialSrc
operator|.
name|setPresent
argument_list|(
literal|0
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|partialDst
operator|.
name|setPresent
argument_list|(
literal|1
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|testRenameRedoFolderSituation
argument_list|(
name|original
argument_list|,
name|partialSrc
argument_list|,
name|partialDst
argument_list|)
expr_stmt|;
block|}
block|{
name|FileFolder
name|original
init|=
operator|new
name|FileFolder
argument_list|(
literal|"folderToRename"
argument_list|)
decl_stmt|;
name|original
operator|.
name|add
argument_list|(
literal|"file1"
argument_list|)
operator|.
name|add
argument_list|(
literal|"file2"
argument_list|)
operator|.
name|add
argument_list|(
literal|"file3"
argument_list|)
expr_stmt|;
name|FileFolder
name|partialSrc
init|=
name|original
operator|.
name|copy
argument_list|()
decl_stmt|;
name|FileFolder
name|partialDst
init|=
name|original
operator|.
name|copy
argument_list|()
decl_stmt|;
name|partialDst
operator|.
name|setName
argument_list|(
literal|"renamedFolder"
argument_list|)
expr_stmt|;
comment|// Set up this state before the redo:
comment|// folderToRename: file1       file3
comment|// renamedFolder:  file1 file2
comment|// This gives code coverage for all 3 expected cases for individual file
comment|// redo.
name|partialSrc
operator|.
name|setPresent
argument_list|(
literal|1
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|partialDst
operator|.
name|setPresent
argument_list|(
literal|2
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|testRenameRedoFolderSituation
argument_list|(
name|original
argument_list|,
name|partialSrc
argument_list|,
name|partialDst
argument_list|)
expr_stmt|;
block|}
block|{
comment|// Simulate a situation with folder with a large number of files in it.
comment|// For the first half of the files, they will be in the destination
comment|// but not the source. For the second half, they will be in the source
comment|// but not the destination. There will be one file in the middle that is
comment|// in both source and destination. Then trigger redo and verify.
comment|// For testing larger folder sizes, manually change this, temporarily, and
comment|// edit the SIZE value.
specifier|final
name|int
name|SIZE
init|=
literal|5
decl_stmt|;
name|assertTrue
argument_list|(
name|SIZE
operator|>=
literal|3
argument_list|)
expr_stmt|;
comment|// Try a lot of files in the folder.
name|FileFolder
name|original
init|=
operator|new
name|FileFolder
argument_list|(
literal|"folderToRename"
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|SIZE
condition|;
name|i
operator|++
control|)
block|{
name|original
operator|.
name|add
argument_list|(
literal|"file"
operator|+
name|Integer
operator|.
name|toString
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|FileFolder
name|partialSrc
init|=
name|original
operator|.
name|copy
argument_list|()
decl_stmt|;
name|FileFolder
name|partialDst
init|=
name|original
operator|.
name|copy
argument_list|()
decl_stmt|;
name|partialDst
operator|.
name|setName
argument_list|(
literal|"renamedFolder"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|SIZE
condition|;
name|i
operator|++
control|)
block|{
name|partialSrc
operator|.
name|setPresent
argument_list|(
name|i
argument_list|,
name|i
operator|>=
name|SIZE
operator|/
literal|2
argument_list|)
expr_stmt|;
name|partialDst
operator|.
name|setPresent
argument_list|(
name|i
argument_list|,
name|i
operator|<=
name|SIZE
operator|/
literal|2
argument_list|)
expr_stmt|;
block|}
name|testRenameRedoFolderSituation
argument_list|(
name|original
argument_list|,
name|partialSrc
argument_list|,
name|partialDst
argument_list|)
expr_stmt|;
block|}
block|{
comment|// Do a nested folder, like so:
comment|// folderToRename:
comment|//   nestedFolder: a, b, c
comment|//   p
comment|//   q
comment|//
comment|// Then delete file 'a' from the source and add it to destination.
comment|// Then trigger redo.
name|FileFolder
name|original
init|=
operator|new
name|FileFolder
argument_list|(
literal|"folderToRename"
argument_list|)
decl_stmt|;
name|FileFolder
name|nested
init|=
operator|new
name|FileFolder
argument_list|(
literal|"nestedFolder"
argument_list|)
decl_stmt|;
name|nested
operator|.
name|add
argument_list|(
literal|"a"
argument_list|)
operator|.
name|add
argument_list|(
literal|"b"
argument_list|)
operator|.
name|add
argument_list|(
literal|"c"
argument_list|)
expr_stmt|;
name|original
operator|.
name|add
argument_list|(
name|nested
argument_list|)
operator|.
name|add
argument_list|(
literal|"p"
argument_list|)
operator|.
name|add
argument_list|(
literal|"q"
argument_list|)
expr_stmt|;
name|FileFolder
name|partialSrc
init|=
name|original
operator|.
name|copy
argument_list|()
decl_stmt|;
name|FileFolder
name|partialDst
init|=
name|original
operator|.
name|copy
argument_list|()
decl_stmt|;
name|partialDst
operator|.
name|setName
argument_list|(
literal|"renamedFolder"
argument_list|)
expr_stmt|;
comment|// logically remove 'a' from source
name|partialSrc
operator|.
name|getMember
argument_list|(
literal|0
argument_list|)
operator|.
name|setPresent
argument_list|(
literal|0
argument_list|,
literal|false
argument_list|)
expr_stmt|;
comment|// logically eliminate b, c from destination
name|partialDst
operator|.
name|getMember
argument_list|(
literal|0
argument_list|)
operator|.
name|setPresent
argument_list|(
literal|1
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|partialDst
operator|.
name|getMember
argument_list|(
literal|0
argument_list|)
operator|.
name|setPresent
argument_list|(
literal|2
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|testRenameRedoFolderSituation
argument_list|(
name|original
argument_list|,
name|partialSrc
argument_list|,
name|partialDst
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|testRenameRedoFolderSituation ( FileFolder fullSrc, FileFolder partialSrc, FileFolder partialDst)
specifier|private
name|void
name|testRenameRedoFolderSituation
parameter_list|(
name|FileFolder
name|fullSrc
parameter_list|,
name|FileFolder
name|partialSrc
parameter_list|,
name|FileFolder
name|partialDst
parameter_list|)
throws|throws
name|IllegalArgumentException
throws|,
name|IOException
block|{
comment|// make file folder tree for source
name|fullSrc
operator|.
name|create
argument_list|()
expr_stmt|;
comment|// set up rename pending file
name|fullSrc
operator|.
name|makeRenamePending
argument_list|(
name|partialDst
argument_list|)
expr_stmt|;
comment|// prune away some files (as marked) from source to simulate partial rename
name|partialSrc
operator|.
name|prune
argument_list|()
expr_stmt|;
comment|// Create only the files indicated for the destination to indicate a partial rename.
name|partialDst
operator|.
name|create
argument_list|()
expr_stmt|;
comment|// trigger redo
name|assertFalse
argument_list|(
name|fullSrc
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
comment|// verify correct results
name|partialDst
operator|.
name|verifyExists
argument_list|()
expr_stmt|;
name|fullSrc
operator|.
name|verifyGone
argument_list|()
expr_stmt|;
comment|// delete the new folder to leave no garbage behind
name|fs
operator|.
name|delete
argument_list|(
operator|new
name|Path
argument_list|(
name|partialDst
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|// Mock up of a generalized folder (which can also be a leaf-level file)
comment|// for rename redo testing.
DECL|class|FileFolder
specifier|private
class|class
name|FileFolder
block|{
DECL|field|name
specifier|private
name|String
name|name
decl_stmt|;
comment|// For rename testing, indicates whether an expected
comment|// file is present in the source or target folder.
DECL|field|present
specifier|private
name|boolean
name|present
decl_stmt|;
DECL|field|members
name|ArrayList
argument_list|<
name|FileFolder
argument_list|>
name|members
decl_stmt|;
comment|// Null if a leaf file, otherwise not null.
comment|// Make a new, empty folder (not a regular leaf file).
DECL|method|FileFolder (String name)
specifier|public
name|FileFolder
parameter_list|(
name|String
name|name
parameter_list|)
block|{
name|this
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|this
operator|.
name|present
operator|=
literal|true
expr_stmt|;
name|members
operator|=
operator|new
name|ArrayList
argument_list|<
name|FileFolder
argument_list|>
argument_list|()
expr_stmt|;
block|}
DECL|method|getMember (int i)
specifier|public
name|FileFolder
name|getMember
parameter_list|(
name|int
name|i
parameter_list|)
block|{
return|return
name|members
operator|.
name|get
argument_list|(
name|i
argument_list|)
return|;
block|}
comment|// Verify a folder and all its contents are gone. This is only to
comment|// be called on the root of a FileFolder.
DECL|method|verifyGone ()
specifier|public
name|void
name|verifyGone
parameter_list|()
throws|throws
name|IllegalArgumentException
throws|,
name|IOException
block|{
name|assertFalse
argument_list|(
name|fs
operator|.
name|exists
argument_list|(
operator|new
name|Path
argument_list|(
name|name
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|isFolder
argument_list|()
argument_list|)
expr_stmt|;
name|verifyGone
argument_list|(
operator|new
name|Path
argument_list|(
name|name
argument_list|)
argument_list|,
name|members
argument_list|)
expr_stmt|;
block|}
DECL|method|verifyGone (Path prefix, ArrayList<FileFolder> members2)
specifier|private
name|void
name|verifyGone
parameter_list|(
name|Path
name|prefix
parameter_list|,
name|ArrayList
argument_list|<
name|FileFolder
argument_list|>
name|members2
parameter_list|)
throws|throws
name|IOException
block|{
for|for
control|(
name|FileFolder
name|f
range|:
name|members2
control|)
block|{
name|f
operator|.
name|verifyGone
argument_list|(
name|prefix
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|verifyGone (Path prefix)
specifier|private
name|void
name|verifyGone
parameter_list|(
name|Path
name|prefix
parameter_list|)
throws|throws
name|IOException
block|{
name|assertFalse
argument_list|(
name|fs
operator|.
name|exists
argument_list|(
operator|new
name|Path
argument_list|(
name|prefix
argument_list|,
name|name
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|isLeaf
argument_list|()
condition|)
block|{
return|return;
block|}
for|for
control|(
name|FileFolder
name|f
range|:
name|members
control|)
block|{
name|f
operator|.
name|verifyGone
argument_list|(
operator|new
name|Path
argument_list|(
name|prefix
argument_list|,
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|verifyExists ()
specifier|public
name|void
name|verifyExists
parameter_list|()
throws|throws
name|IllegalArgumentException
throws|,
name|IOException
block|{
comment|// verify the root is present
name|assertTrue
argument_list|(
name|fs
operator|.
name|exists
argument_list|(
operator|new
name|Path
argument_list|(
name|name
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|isFolder
argument_list|()
argument_list|)
expr_stmt|;
comment|// check the members
name|verifyExists
argument_list|(
operator|new
name|Path
argument_list|(
name|name
argument_list|)
argument_list|,
name|members
argument_list|)
expr_stmt|;
block|}
DECL|method|verifyExists (Path prefix, ArrayList<FileFolder> members2)
specifier|private
name|void
name|verifyExists
parameter_list|(
name|Path
name|prefix
parameter_list|,
name|ArrayList
argument_list|<
name|FileFolder
argument_list|>
name|members2
parameter_list|)
throws|throws
name|IOException
block|{
for|for
control|(
name|FileFolder
name|f
range|:
name|members2
control|)
block|{
name|f
operator|.
name|verifyExists
argument_list|(
name|prefix
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|verifyExists (Path prefix)
specifier|private
name|void
name|verifyExists
parameter_list|(
name|Path
name|prefix
parameter_list|)
throws|throws
name|IOException
block|{
comment|// verify this file/folder is present
name|assertTrue
argument_list|(
name|fs
operator|.
name|exists
argument_list|(
operator|new
name|Path
argument_list|(
name|prefix
argument_list|,
name|name
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// verify members are present
if|if
condition|(
name|isLeaf
argument_list|()
condition|)
block|{
return|return;
block|}
for|for
control|(
name|FileFolder
name|f
range|:
name|members
control|)
block|{
name|f
operator|.
name|verifyExists
argument_list|(
operator|new
name|Path
argument_list|(
name|prefix
argument_list|,
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|exists ()
specifier|public
name|boolean
name|exists
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|fs
operator|.
name|exists
argument_list|(
operator|new
name|Path
argument_list|(
name|name
argument_list|)
argument_list|)
return|;
block|}
comment|// Make a rename pending file for the situation where we rename
comment|// this object (the source) to the specified destination.
DECL|method|makeRenamePending (FileFolder dst)
specifier|public
name|void
name|makeRenamePending
parameter_list|(
name|FileFolder
name|dst
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Propose (but don't do) the rename.
name|Path
name|home
init|=
name|fs
operator|.
name|getHomeDirectory
argument_list|()
decl_stmt|;
name|String
name|relativeHomeDir
init|=
name|getRelativePath
argument_list|(
name|home
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
name|NativeAzureFileSystem
operator|.
name|FolderRenamePending
name|pending
init|=
operator|new
name|NativeAzureFileSystem
operator|.
name|FolderRenamePending
argument_list|(
name|relativeHomeDir
operator|+
literal|"/"
operator|+
name|this
operator|.
name|getName
argument_list|()
argument_list|,
name|relativeHomeDir
operator|+
literal|"/"
operator|+
name|dst
operator|.
name|getName
argument_list|()
argument_list|,
literal|null
argument_list|,
operator|(
name|NativeAzureFileSystem
operator|)
name|fs
argument_list|)
decl_stmt|;
comment|// Get the rename pending file contents.
name|String
name|renameDescription
init|=
name|pending
operator|.
name|makeRenamePendingFileContents
argument_list|()
decl_stmt|;
comment|// Create a rename-pending file and write rename information to it.
specifier|final
name|String
name|renamePendingStr
init|=
name|this
operator|.
name|getName
argument_list|()
operator|+
literal|"-RenamePending.json"
decl_stmt|;
name|Path
name|renamePendingFile
init|=
operator|new
name|Path
argument_list|(
name|renamePendingStr
argument_list|)
decl_stmt|;
name|FSDataOutputStream
name|out
init|=
name|fs
operator|.
name|create
argument_list|(
name|renamePendingFile
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|out
operator|!=
literal|null
argument_list|)
expr_stmt|;
name|writeStringToStream
argument_list|(
name|out
argument_list|,
name|renameDescription
argument_list|)
expr_stmt|;
block|}
comment|// set whether a child is present or not
DECL|method|setPresent (int i, boolean b)
specifier|public
name|void
name|setPresent
parameter_list|(
name|int
name|i
parameter_list|,
name|boolean
name|b
parameter_list|)
block|{
name|members
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|setPresent
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
comment|// Make an uninitialized folder
DECL|method|FileFolder ()
specifier|private
name|FileFolder
parameter_list|()
block|{
name|this
operator|.
name|present
operator|=
literal|true
expr_stmt|;
block|}
DECL|method|setPresent (boolean value)
specifier|public
name|void
name|setPresent
parameter_list|(
name|boolean
name|value
parameter_list|)
block|{
name|present
operator|=
name|value
expr_stmt|;
block|}
DECL|method|makeLeaf (String name)
specifier|public
name|FileFolder
name|makeLeaf
parameter_list|(
name|String
name|name
parameter_list|)
block|{
name|FileFolder
name|f
init|=
operator|new
name|FileFolder
argument_list|()
decl_stmt|;
name|f
operator|.
name|setName
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return
name|f
return|;
block|}
DECL|method|setName (String name)
name|void
name|setName
parameter_list|(
name|String
name|name
parameter_list|)
block|{
name|this
operator|.
name|name
operator|=
name|name
expr_stmt|;
block|}
DECL|method|getName ()
specifier|public
name|String
name|getName
parameter_list|()
block|{
return|return
name|name
return|;
block|}
DECL|method|isLeaf ()
specifier|public
name|boolean
name|isLeaf
parameter_list|()
block|{
return|return
name|members
operator|==
literal|null
return|;
block|}
DECL|method|isFolder ()
specifier|public
name|boolean
name|isFolder
parameter_list|()
block|{
return|return
name|members
operator|!=
literal|null
return|;
block|}
DECL|method|add (FileFolder folder)
name|FileFolder
name|add
parameter_list|(
name|FileFolder
name|folder
parameter_list|)
block|{
name|members
operator|.
name|add
argument_list|(
name|folder
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|// Add a leaf file (by convention, if you pass a string argument, you get a leaf).
DECL|method|add (String file)
name|FileFolder
name|add
parameter_list|(
name|String
name|file
parameter_list|)
block|{
name|FileFolder
name|leaf
init|=
name|makeLeaf
argument_list|(
name|file
argument_list|)
decl_stmt|;
name|members
operator|.
name|add
argument_list|(
name|leaf
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|copy ()
specifier|public
name|FileFolder
name|copy
parameter_list|()
block|{
if|if
condition|(
name|isLeaf
argument_list|()
condition|)
block|{
return|return
name|makeLeaf
argument_list|(
name|name
argument_list|)
return|;
block|}
else|else
block|{
name|FileFolder
name|f
init|=
operator|new
name|FileFolder
argument_list|(
name|name
argument_list|)
decl_stmt|;
for|for
control|(
name|FileFolder
name|member
range|:
name|members
control|)
block|{
name|f
operator|.
name|add
argument_list|(
name|member
operator|.
name|copy
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|f
return|;
block|}
block|}
comment|// Create the folder structure. Return true on success, or else false.
DECL|method|create ()
specifier|public
name|void
name|create
parameter_list|()
throws|throws
name|IllegalArgumentException
throws|,
name|IOException
block|{
name|create
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
DECL|method|create (Path prefix)
specifier|private
name|void
name|create
parameter_list|(
name|Path
name|prefix
parameter_list|)
throws|throws
name|IllegalArgumentException
throws|,
name|IOException
block|{
if|if
condition|(
name|isFolder
argument_list|()
condition|)
block|{
if|if
condition|(
name|present
condition|)
block|{
name|assertTrue
argument_list|(
name|fs
operator|.
name|mkdirs
argument_list|(
name|makePath
argument_list|(
name|prefix
argument_list|,
name|name
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|create
argument_list|(
name|makePath
argument_list|(
name|prefix
argument_list|,
name|name
argument_list|)
argument_list|,
name|members
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isLeaf
argument_list|()
condition|)
block|{
if|if
condition|(
name|present
condition|)
block|{
name|assertTrue
argument_list|(
name|fs
operator|.
name|createNewFile
argument_list|(
name|makePath
argument_list|(
name|prefix
argument_list|,
name|name
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|assertTrue
argument_list|(
literal|"The object must be a (leaf) file or a folder."
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|create (Path prefix, ArrayList<FileFolder> members2)
specifier|private
name|void
name|create
parameter_list|(
name|Path
name|prefix
parameter_list|,
name|ArrayList
argument_list|<
name|FileFolder
argument_list|>
name|members2
parameter_list|)
throws|throws
name|IllegalArgumentException
throws|,
name|IOException
block|{
for|for
control|(
name|FileFolder
name|f
range|:
name|members2
control|)
block|{
name|f
operator|.
name|create
argument_list|(
name|prefix
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|makePath (Path prefix, String name)
specifier|private
name|Path
name|makePath
parameter_list|(
name|Path
name|prefix
parameter_list|,
name|String
name|name
parameter_list|)
block|{
if|if
condition|(
name|prefix
operator|==
literal|null
condition|)
block|{
return|return
operator|new
name|Path
argument_list|(
name|name
argument_list|)
return|;
block|}
else|else
block|{
return|return
operator|new
name|Path
argument_list|(
name|prefix
argument_list|,
name|name
argument_list|)
return|;
block|}
block|}
comment|// Remove the files marked as not present.
DECL|method|prune ()
specifier|public
name|void
name|prune
parameter_list|()
throws|throws
name|IOException
block|{
name|prune
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
DECL|method|prune (Path prefix)
specifier|private
name|void
name|prune
parameter_list|(
name|Path
name|prefix
parameter_list|)
throws|throws
name|IOException
block|{
name|Path
name|path
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|prefix
operator|==
literal|null
condition|)
block|{
name|path
operator|=
operator|new
name|Path
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|path
operator|=
operator|new
name|Path
argument_list|(
name|prefix
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isLeaf
argument_list|()
operator|&&
operator|!
name|present
condition|)
block|{
name|assertTrue
argument_list|(
name|fs
operator|.
name|delete
argument_list|(
name|path
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isFolder
argument_list|()
operator|&&
operator|!
name|present
condition|)
block|{
name|assertTrue
argument_list|(
name|fs
operator|.
name|delete
argument_list|(
name|path
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isFolder
argument_list|()
condition|)
block|{
for|for
control|(
name|FileFolder
name|f
range|:
name|members
control|)
block|{
name|f
operator|.
name|prune
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
DECL|method|getRelativePath (String path)
specifier|private
name|String
name|getRelativePath
parameter_list|(
name|String
name|path
parameter_list|)
block|{
comment|// example input: wasb://wasbtests-ehans-1404322046279@ehans9.blob.core.windows.net/user/ehans/folderToRename
comment|// example result: user/ehans/folderToRename
comment|// Find the third / position and return input substring after that.
name|int
name|slashCount
init|=
literal|0
decl_stmt|;
comment|// number of slashes so far
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|path
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|path
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
operator|==
literal|'/'
condition|)
block|{
name|slashCount
operator|++
expr_stmt|;
if|if
condition|(
name|slashCount
operator|==
literal|3
condition|)
block|{
return|return
name|path
operator|.
name|substring
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|path
operator|.
name|length
argument_list|()
argument_list|)
return|;
block|}
block|}
block|}
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Incorrect path prefix -- expected wasb://.../..."
argument_list|)
throw|;
block|}
annotation|@
name|Test
DECL|method|testCloseFileSystemTwice ()
specifier|public
name|void
name|testCloseFileSystemTwice
parameter_list|()
throws|throws
name|Exception
block|{
comment|//make sure close() can be called multiple times without doing any harm
name|fs
operator|.
name|close
argument_list|()
expr_stmt|;
name|fs
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|// Test the available() method for the input stream returned by fs.open().
comment|// This works for both page and block blobs.
DECL|field|FILE_SIZE
name|int
name|FILE_SIZE
init|=
literal|4
operator|*
literal|1024
operator|*
literal|1024
operator|+
literal|1
decl_stmt|;
comment|// Make this 1 bigger than internal
comment|// buffer used in BlobInputStream
comment|// to exercise that case.
DECL|field|MAX_STRIDE
name|int
name|MAX_STRIDE
init|=
name|FILE_SIZE
operator|+
literal|1
decl_stmt|;
DECL|field|PATH
name|Path
name|PATH
init|=
operator|new
name|Path
argument_list|(
literal|"/available.dat"
argument_list|)
decl_stmt|;
annotation|@
name|Test
DECL|method|testAvailable ()
specifier|public
name|void
name|testAvailable
parameter_list|()
throws|throws
name|IOException
block|{
comment|// write FILE_SIZE bytes to page blob
name|FSDataOutputStream
name|out
init|=
name|fs
operator|.
name|create
argument_list|(
name|PATH
argument_list|)
decl_stmt|;
name|byte
index|[]
name|data
init|=
operator|new
name|byte
index|[
name|FILE_SIZE
index|]
decl_stmt|;
name|Arrays
operator|.
name|fill
argument_list|(
name|data
argument_list|,
operator|(
name|byte
operator|)
literal|5
argument_list|)
expr_stmt|;
name|out
operator|.
name|write
argument_list|(
name|data
argument_list|,
literal|0
argument_list|,
name|FILE_SIZE
argument_list|)
expr_stmt|;
name|out
operator|.
name|close
argument_list|()
expr_stmt|;
comment|// Test available() for different read sizes
name|verifyAvailable
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|verifyAvailable
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|verifyAvailable
argument_list|(
literal|5000
argument_list|)
expr_stmt|;
name|verifyAvailable
argument_list|(
name|FILE_SIZE
argument_list|)
expr_stmt|;
name|verifyAvailable
argument_list|(
name|MAX_STRIDE
argument_list|)
expr_stmt|;
name|fs
operator|.
name|delete
argument_list|(
name|PATH
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|// Verify that available() for the input stream is always>= 1 unless we've
comment|// consumed all the input, and then it is 0. This is to match expectations by
comment|// HBase which were set based on behavior of DFSInputStream.available().
DECL|method|verifyAvailable (int readStride)
specifier|private
name|void
name|verifyAvailable
parameter_list|(
name|int
name|readStride
parameter_list|)
throws|throws
name|IOException
block|{
name|FSDataInputStream
name|in
init|=
name|fs
operator|.
name|open
argument_list|(
name|PATH
argument_list|)
decl_stmt|;
try|try
block|{
name|byte
index|[]
name|inputBuffer
init|=
operator|new
name|byte
index|[
name|MAX_STRIDE
index|]
decl_stmt|;
name|int
name|position
init|=
literal|0
decl_stmt|;
name|int
name|bytesRead
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|bytesRead
operator|!=
name|FILE_SIZE
condition|)
block|{
name|bytesRead
operator|+=
name|in
operator|.
name|read
argument_list|(
name|inputBuffer
argument_list|,
name|position
argument_list|,
name|readStride
argument_list|)
expr_stmt|;
name|int
name|available
init|=
name|in
operator|.
name|available
argument_list|()
decl_stmt|;
if|if
condition|(
name|bytesRead
operator|<
name|FILE_SIZE
condition|)
block|{
if|if
condition|(
name|available
operator|<
literal|1
condition|)
block|{
name|fail
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"expected available> 0 but got: "
operator|+
literal|"position = %d, bytesRead = %d, in.available() = %d"
argument_list|,
name|position
argument_list|,
name|bytesRead
argument_list|,
name|available
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|int
name|available
init|=
name|in
operator|.
name|available
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
name|available
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|in
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Test
DECL|method|testGetFileSizeFromListing ()
specifier|public
name|void
name|testGetFileSizeFromListing
parameter_list|()
throws|throws
name|IOException
block|{
name|Path
name|path
init|=
operator|new
name|Path
argument_list|(
literal|"file.dat"
argument_list|)
decl_stmt|;
specifier|final
name|int
name|PAGE_SIZE
init|=
literal|512
decl_stmt|;
specifier|final
name|int
name|FILE_SIZE
init|=
name|PAGE_SIZE
operator|+
literal|1
decl_stmt|;
comment|// write FILE_SIZE bytes to page blob
name|FSDataOutputStream
name|out
init|=
name|fs
operator|.
name|create
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|byte
index|[]
name|data
init|=
operator|new
name|byte
index|[
name|FILE_SIZE
index|]
decl_stmt|;
name|Arrays
operator|.
name|fill
argument_list|(
name|data
argument_list|,
operator|(
name|byte
operator|)
literal|5
argument_list|)
expr_stmt|;
name|out
operator|.
name|write
argument_list|(
name|data
argument_list|,
literal|0
argument_list|,
name|FILE_SIZE
argument_list|)
expr_stmt|;
name|out
operator|.
name|close
argument_list|()
expr_stmt|;
comment|// list the file to get its properties
name|FileStatus
index|[]
name|status
init|=
name|fs
operator|.
name|listStatus
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|status
operator|.
name|length
argument_list|)
expr_stmt|;
comment|// The file length should report the number of bytes
comment|// written for either page or block blobs (subclasses
comment|// of this test class will exercise both).
name|assertEquals
argument_list|(
name|FILE_SIZE
argument_list|,
name|status
index|[
literal|0
index|]
operator|.
name|getLen
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testModifiedTime (Path testPath, long time)
specifier|private
name|boolean
name|testModifiedTime
parameter_list|(
name|Path
name|testPath
parameter_list|,
name|long
name|time
parameter_list|)
throws|throws
name|Exception
block|{
name|FileStatus
name|fileStatus
init|=
name|fs
operator|.
name|getFileStatus
argument_list|(
name|testPath
argument_list|)
decl_stmt|;
specifier|final
name|long
name|errorMargin
init|=
name|modifiedTimeErrorMargin
decl_stmt|;
name|long
name|lastModified
init|=
name|fileStatus
operator|.
name|getModificationTime
argument_list|()
decl_stmt|;
return|return
operator|(
name|lastModified
operator|>
operator|(
name|time
operator|-
name|errorMargin
operator|)
operator|&&
name|lastModified
operator|<
operator|(
name|time
operator|+
name|errorMargin
operator|)
operator|)
return|;
block|}
annotation|@
name|Test
DECL|method|testCreateNonRecursive ()
specifier|public
name|void
name|testCreateNonRecursive
parameter_list|()
throws|throws
name|Exception
block|{
name|Path
name|testFolder
init|=
operator|new
name|Path
argument_list|(
literal|"/testFolder"
argument_list|)
decl_stmt|;
name|Path
name|testFile
init|=
operator|new
name|Path
argument_list|(
name|testFolder
argument_list|,
literal|"testFile"
argument_list|)
decl_stmt|;
try|try
block|{
name|fs
operator|.
name|createNonRecursive
argument_list|(
name|testFile
argument_list|,
literal|true
argument_list|,
literal|1024
argument_list|,
operator|(
name|short
operator|)
literal|1
argument_list|,
literal|1024
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"Should've thrown"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|e
parameter_list|)
block|{     }
name|fs
operator|.
name|mkdirs
argument_list|(
name|testFolder
argument_list|)
expr_stmt|;
name|fs
operator|.
name|createNonRecursive
argument_list|(
name|testFile
argument_list|,
literal|true
argument_list|,
literal|1024
argument_list|,
operator|(
name|short
operator|)
literal|1
argument_list|,
literal|1024
argument_list|,
literal|null
argument_list|)
operator|.
name|close
argument_list|()
expr_stmt|;
name|assertTrue
argument_list|(
name|fs
operator|.
name|exists
argument_list|(
name|testFile
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|testFileEndingInDot ()
specifier|public
name|void
name|testFileEndingInDot
parameter_list|()
throws|throws
name|Exception
block|{
name|Path
name|testFolder
init|=
operator|new
name|Path
argument_list|(
literal|"/testFolder."
argument_list|)
decl_stmt|;
name|Path
name|testFile
init|=
operator|new
name|Path
argument_list|(
name|testFolder
argument_list|,
literal|"testFile."
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|fs
operator|.
name|mkdirs
argument_list|(
name|testFolder
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|fs
operator|.
name|createNewFile
argument_list|(
name|testFile
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|fs
operator|.
name|exists
argument_list|(
name|testFile
argument_list|)
argument_list|)
expr_stmt|;
name|FileStatus
index|[]
name|listed
init|=
name|fs
operator|.
name|listStatus
argument_list|(
name|testFolder
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|listed
operator|.
name|length
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"testFile."
argument_list|,
name|listed
index|[
literal|0
index|]
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testModifiedTime (Path testPath)
specifier|private
name|void
name|testModifiedTime
parameter_list|(
name|Path
name|testPath
parameter_list|)
throws|throws
name|Exception
block|{
name|Calendar
name|utc
init|=
name|Calendar
operator|.
name|getInstance
argument_list|(
name|TimeZone
operator|.
name|getTimeZone
argument_list|(
literal|"UTC"
argument_list|)
argument_list|)
decl_stmt|;
name|long
name|currentUtcTime
init|=
name|utc
operator|.
name|getTime
argument_list|()
operator|.
name|getTime
argument_list|()
decl_stmt|;
name|FileStatus
name|fileStatus
init|=
name|fs
operator|.
name|getFileStatus
argument_list|(
name|testPath
argument_list|)
decl_stmt|;
specifier|final
name|long
name|errorMargin
init|=
literal|60
operator|*
literal|1000
decl_stmt|;
comment|// Give it +/-60 seconds
name|assertTrue
argument_list|(
literal|"Modification time "
operator|+
operator|new
name|Date
argument_list|(
name|fileStatus
operator|.
name|getModificationTime
argument_list|()
argument_list|)
operator|+
literal|" is not close to now: "
operator|+
name|utc
operator|.
name|getTime
argument_list|()
argument_list|,
name|fileStatus
operator|.
name|getModificationTime
argument_list|()
operator|>
operator|(
name|currentUtcTime
operator|-
name|errorMargin
operator|)
operator|&&
name|fileStatus
operator|.
name|getModificationTime
argument_list|()
operator|<
operator|(
name|currentUtcTime
operator|+
name|errorMargin
operator|)
argument_list|)
expr_stmt|;
block|}
DECL|method|createEmptyFile (Path testFile, FsPermission permission)
specifier|private
name|void
name|createEmptyFile
parameter_list|(
name|Path
name|testFile
parameter_list|,
name|FsPermission
name|permission
parameter_list|)
throws|throws
name|IOException
block|{
name|FSDataOutputStream
name|outputStream
init|=
name|fs
operator|.
name|create
argument_list|(
name|testFile
argument_list|,
name|permission
argument_list|,
literal|true
argument_list|,
literal|4096
argument_list|,
operator|(
name|short
operator|)
literal|1
argument_list|,
literal|1024
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|outputStream
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
DECL|method|readString (Path testFile)
specifier|private
name|String
name|readString
parameter_list|(
name|Path
name|testFile
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|readStringFromFile
argument_list|(
name|fs
argument_list|,
name|testFile
argument_list|)
return|;
block|}
DECL|method|writeString (Path path, String value)
specifier|private
name|void
name|writeString
parameter_list|(
name|Path
name|path
parameter_list|,
name|String
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|writeStringToFile
argument_list|(
name|fs
argument_list|,
name|path
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
comment|// Acquire and free a Lease object. Wait for more than the lease
comment|// timeout, to make sure the lease renews itself.
DECL|method|testSelfRenewingLease ()
specifier|public
name|void
name|testSelfRenewingLease
parameter_list|()
throws|throws
name|IllegalArgumentException
throws|,
name|IOException
throws|,
name|InterruptedException
throws|,
name|StorageException
block|{
name|SelfRenewingLease
name|lease
decl_stmt|;
specifier|final
name|String
name|FILE_KEY
init|=
literal|"file"
decl_stmt|;
name|fs
operator|.
name|create
argument_list|(
operator|new
name|Path
argument_list|(
name|FILE_KEY
argument_list|)
argument_list|)
expr_stmt|;
name|NativeAzureFileSystem
name|nfs
init|=
operator|(
name|NativeAzureFileSystem
operator|)
name|fs
decl_stmt|;
name|String
name|fullKey
init|=
name|nfs
operator|.
name|pathToKey
argument_list|(
name|nfs
operator|.
name|makeAbsolute
argument_list|(
operator|new
name|Path
argument_list|(
name|FILE_KEY
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|AzureNativeFileSystemStore
name|store
init|=
name|nfs
operator|.
name|getStore
argument_list|()
decl_stmt|;
name|lease
operator|=
name|store
operator|.
name|acquireLease
argument_list|(
name|fullKey
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|lease
operator|.
name|getLeaseID
argument_list|()
operator|!=
literal|null
argument_list|)
expr_stmt|;
comment|// The sleep time for the keep-alive thread is 40 seconds, so sleep just
comment|// a little beyond that, to make sure the keep-alive thread wakes up
comment|// and renews the lease.
name|Thread
operator|.
name|sleep
argument_list|(
literal|42000
argument_list|)
expr_stmt|;
name|lease
operator|.
name|free
argument_list|()
expr_stmt|;
comment|// Check that the lease is really freed.
name|CloudBlob
name|blob
init|=
name|lease
operator|.
name|getCloudBlob
argument_list|()
decl_stmt|;
comment|// Try to acquire it again, using direct Azure blob access.
comment|// If that succeeds, then the lease was already freed.
name|String
name|differentLeaseID
init|=
literal|null
decl_stmt|;
try|try
block|{
name|differentLeaseID
operator|=
name|blob
operator|.
name|acquireLease
argument_list|(
literal|15
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|e
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
name|fail
argument_list|(
literal|"Caught exception trying to directly re-acquire lease from Azure"
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|assertTrue
argument_list|(
name|differentLeaseID
operator|!=
literal|null
argument_list|)
expr_stmt|;
name|AccessCondition
name|accessCondition
init|=
name|AccessCondition
operator|.
name|generateEmptyCondition
argument_list|()
decl_stmt|;
name|accessCondition
operator|.
name|setLeaseID
argument_list|(
name|differentLeaseID
argument_list|)
expr_stmt|;
name|blob
operator|.
name|releaseLease
argument_list|(
name|accessCondition
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Test
comment|// Acquire a SelfRenewingLease object. Wait for more than the lease
comment|// timeout, to make sure the lease renews itself. Delete the file.
comment|// That will automatically free the lease.
comment|// (that should work without any failures).
DECL|method|testSelfRenewingLeaseFileDelete ()
specifier|public
name|void
name|testSelfRenewingLeaseFileDelete
parameter_list|()
throws|throws
name|IllegalArgumentException
throws|,
name|IOException
throws|,
name|InterruptedException
throws|,
name|StorageException
block|{
name|SelfRenewingLease
name|lease
decl_stmt|;
specifier|final
name|String
name|FILE_KEY
init|=
literal|"file"
decl_stmt|;
specifier|final
name|Path
name|path
init|=
operator|new
name|Path
argument_list|(
name|FILE_KEY
argument_list|)
decl_stmt|;
name|fs
operator|.
name|create
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|NativeAzureFileSystem
name|nfs
init|=
operator|(
name|NativeAzureFileSystem
operator|)
name|fs
decl_stmt|;
name|String
name|fullKey
init|=
name|nfs
operator|.
name|pathToKey
argument_list|(
name|nfs
operator|.
name|makeAbsolute
argument_list|(
name|path
argument_list|)
argument_list|)
decl_stmt|;
name|lease
operator|=
name|nfs
operator|.
name|getStore
argument_list|()
operator|.
name|acquireLease
argument_list|(
name|fullKey
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|lease
operator|.
name|getLeaseID
argument_list|()
operator|!=
literal|null
argument_list|)
expr_stmt|;
comment|// The sleep time for the keep-alive thread is 40 seconds, so sleep just
comment|// a little beyond that, to make sure the keep-alive thread wakes up
comment|// and renews the lease.
name|Thread
operator|.
name|sleep
argument_list|(
literal|42000
argument_list|)
expr_stmt|;
name|nfs
operator|.
name|getStore
argument_list|()
operator|.
name|delete
argument_list|(
name|fullKey
argument_list|,
name|lease
argument_list|)
expr_stmt|;
comment|// Check that the file is really gone and the lease is freed.
name|assertTrue
argument_list|(
operator|!
name|fs
operator|.
name|exists
argument_list|(
name|path
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|lease
operator|.
name|isFreed
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Variables to check assertions in next test.
DECL|field|firstEndTime
specifier|private
name|long
name|firstEndTime
decl_stmt|;
DECL|field|secondStartTime
specifier|private
name|long
name|secondStartTime
decl_stmt|;
comment|// Create two threads. One will get a lease on a file.
comment|// The second one will try to get the lease and thus block.
comment|// Then the first one will free the lease and the second
comment|// one will get it and proceed.
annotation|@
name|Test
DECL|method|testLeaseAsDistributedLock ()
specifier|public
name|void
name|testLeaseAsDistributedLock
parameter_list|()
throws|throws
name|IllegalArgumentException
throws|,
name|IOException
block|{
specifier|final
name|String
name|LEASE_LOCK_FILE_KEY
init|=
literal|"file"
decl_stmt|;
name|fs
operator|.
name|create
argument_list|(
operator|new
name|Path
argument_list|(
name|LEASE_LOCK_FILE_KEY
argument_list|)
argument_list|)
expr_stmt|;
name|NativeAzureFileSystem
name|nfs
init|=
operator|(
name|NativeAzureFileSystem
operator|)
name|fs
decl_stmt|;
name|String
name|fullKey
init|=
name|nfs
operator|.
name|pathToKey
argument_list|(
name|nfs
operator|.
name|makeAbsolute
argument_list|(
operator|new
name|Path
argument_list|(
name|LEASE_LOCK_FILE_KEY
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|Thread
name|first
init|=
operator|new
name|Thread
argument_list|(
operator|new
name|LeaseLockAction
argument_list|(
literal|"first-thread"
argument_list|,
name|fullKey
argument_list|)
argument_list|)
decl_stmt|;
name|first
operator|.
name|start
argument_list|()
expr_stmt|;
name|Thread
name|second
init|=
operator|new
name|Thread
argument_list|(
operator|new
name|LeaseLockAction
argument_list|(
literal|"second-thread"
argument_list|,
name|fullKey
argument_list|)
argument_list|)
decl_stmt|;
name|second
operator|.
name|start
argument_list|()
expr_stmt|;
try|try
block|{
comment|// Wait for the two  threads to finish.
name|first
operator|.
name|join
argument_list|()
expr_stmt|;
name|second
operator|.
name|join
argument_list|()
expr_stmt|;
name|assertTrue
argument_list|(
name|firstEndTime
operator|<
name|secondStartTime
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|fail
argument_list|(
literal|"Unable to wait for threads to finish"
argument_list|)
expr_stmt|;
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
block|}
DECL|class|LeaseLockAction
specifier|private
class|class
name|LeaseLockAction
implements|implements
name|Runnable
block|{
DECL|field|name
specifier|private
name|String
name|name
decl_stmt|;
DECL|field|key
specifier|private
name|String
name|key
decl_stmt|;
DECL|method|LeaseLockAction (String name, String key)
name|LeaseLockAction
parameter_list|(
name|String
name|name
parameter_list|,
name|String
name|key
parameter_list|)
block|{
name|this
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|this
operator|.
name|key
operator|=
name|key
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"starting thread "
operator|+
name|name
argument_list|)
expr_stmt|;
name|SelfRenewingLease
name|lease
init|=
literal|null
decl_stmt|;
name|NativeAzureFileSystem
name|nfs
init|=
operator|(
name|NativeAzureFileSystem
operator|)
name|fs
decl_stmt|;
if|if
condition|(
name|name
operator|.
name|equals
argument_list|(
literal|"first-thread"
argument_list|)
condition|)
block|{
try|try
block|{
name|lease
operator|=
name|nfs
operator|.
name|getStore
argument_list|()
operator|.
name|acquireLease
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|name
operator|+
literal|" acquired lease "
operator|+
name|lease
operator|.
name|getLeaseID
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|AzureException
name|e
parameter_list|)
block|{
name|assertTrue
argument_list|(
literal|"Unanticipated exception"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
name|assertTrue
argument_list|(
name|lease
operator|!=
literal|null
argument_list|)
expr_stmt|;
try|try
block|{
comment|// Sleep long enough for the lease to renew once.
name|Thread
operator|.
name|sleep
argument_list|(
name|SelfRenewingLease
operator|.
name|LEASE_RENEWAL_PERIOD
operator|+
literal|2000
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
try|try
block|{
name|firstEndTime
operator|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
expr_stmt|;
name|lease
operator|.
name|free
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|name
operator|+
literal|" freed lease "
operator|+
name|lease
operator|.
name|getLeaseID
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|StorageException
name|e
parameter_list|)
block|{
name|fail
argument_list|(
literal|"Unanticipated exception"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|name
operator|.
name|equals
argument_list|(
literal|"second-thread"
argument_list|)
condition|)
block|{
try|try
block|{
comment|// sleep 2 sec to let first thread get ahead of this one
name|Thread
operator|.
name|sleep
argument_list|(
literal|2000
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
try|try
block|{
name|LOG
operator|.
name|info
argument_list|(
name|name
operator|+
literal|" before getting lease"
argument_list|)
expr_stmt|;
name|lease
operator|=
name|nfs
operator|.
name|getStore
argument_list|()
operator|.
name|acquireLease
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|secondStartTime
operator|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|name
operator|+
literal|" acquired lease "
operator|+
name|lease
operator|.
name|getLeaseID
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|AzureException
name|e
parameter_list|)
block|{
name|assertTrue
argument_list|(
literal|"Unanticipated exception"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
name|assertTrue
argument_list|(
name|lease
operator|!=
literal|null
argument_list|)
expr_stmt|;
try|try
block|{
name|lease
operator|.
name|free
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|name
operator|+
literal|" freed lease "
operator|+
name|lease
operator|.
name|getLeaseID
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|StorageException
name|e
parameter_list|)
block|{
name|assertTrue
argument_list|(
literal|"Unanticipated exception"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|fail
argument_list|(
literal|"Unknown thread name"
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
name|name
operator|+
literal|" is exiting."
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

