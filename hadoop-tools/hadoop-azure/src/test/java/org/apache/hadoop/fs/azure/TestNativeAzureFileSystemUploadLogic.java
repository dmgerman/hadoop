begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.fs.azure
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|azure
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertEquals
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertNotNull
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|After
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Before
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Ignore
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Test
import|;
end_import

begin_comment
comment|/**  * Tests for the upload, buffering and flush logic in WASB.  */
end_comment

begin_class
DECL|class|TestNativeAzureFileSystemUploadLogic
specifier|public
class|class
name|TestNativeAzureFileSystemUploadLogic
block|{
DECL|field|testAccount
specifier|private
name|AzureBlobStorageTestAccount
name|testAccount
decl_stmt|;
comment|// Just an arbitrary number so that the values I write have a predictable
comment|// pattern: 0, 1, 2, .. , 45, 46, 0, 1, 2, ...
DECL|field|byteValuePeriod
specifier|static
specifier|final
name|int
name|byteValuePeriod
init|=
literal|47
decl_stmt|;
annotation|@
name|Before
DECL|method|setUp ()
specifier|public
name|void
name|setUp
parameter_list|()
throws|throws
name|Exception
block|{
name|testAccount
operator|=
name|AzureBlobStorageTestAccount
operator|.
name|createMock
argument_list|()
expr_stmt|;
block|}
annotation|@
name|After
DECL|method|tearDown ()
specifier|public
name|void
name|tearDown
parameter_list|()
throws|throws
name|Exception
block|{
if|if
condition|(
name|testAccount
operator|!=
literal|null
condition|)
block|{
name|testAccount
operator|.
name|cleanup
argument_list|()
expr_stmt|;
name|testAccount
operator|=
literal|null
expr_stmt|;
block|}
block|}
comment|/**    * Various scenarios to test in how often we flush data while uploading.    */
DECL|enum|FlushFrequencyVariation
specifier|private
enum|enum
name|FlushFrequencyVariation
block|{
comment|/**      * Flush before even a single in-memory buffer is full.      */
DECL|enumConstant|BeforeSingleBufferFull
name|BeforeSingleBufferFull
block|,
comment|/**      * Flush after a single in-memory buffer is full.      */
DECL|enumConstant|AfterSingleBufferFull
name|AfterSingleBufferFull
block|,
comment|/**      * Flush after all the in-memory buffers got full and were      * automatically flushed to the backing store.      */
DECL|enumConstant|AfterAllRingBufferFull
name|AfterAllRingBufferFull
block|,   }
comment|/**    * Tests that we upload consistently if we flush after every little    * bit of data.    */
annotation|@
name|Test
annotation|@
name|Ignore
comment|/* flush() no longer does anything. @@TODO: implement a force-flush and reinstate this test */
DECL|method|testConsistencyAfterSmallFlushes ()
specifier|public
name|void
name|testConsistencyAfterSmallFlushes
parameter_list|()
throws|throws
name|Exception
block|{
name|testConsistencyAfterManyFlushes
argument_list|(
name|FlushFrequencyVariation
operator|.
name|BeforeSingleBufferFull
argument_list|)
expr_stmt|;
block|}
comment|/**    * Tests that we upload consistently if we flush after every medium-sized    * bit of data.    */
annotation|@
name|Test
annotation|@
name|Ignore
comment|/* flush() no longer does anything. @@TODO: implement a force-flush and reinstate this test */
DECL|method|testConsistencyAfterMediumFlushes ()
specifier|public
name|void
name|testConsistencyAfterMediumFlushes
parameter_list|()
throws|throws
name|Exception
block|{
name|testConsistencyAfterManyFlushes
argument_list|(
name|FlushFrequencyVariation
operator|.
name|AfterSingleBufferFull
argument_list|)
expr_stmt|;
block|}
comment|/**    * Tests that we upload consistently if we flush after every large chunk    * of data.    */
annotation|@
name|Test
annotation|@
name|Ignore
comment|/* flush() no longer does anything. @@TODO: implement a force-flush and reinstate this test */
DECL|method|testConsistencyAfterLargeFlushes ()
specifier|public
name|void
name|testConsistencyAfterLargeFlushes
parameter_list|()
throws|throws
name|Exception
block|{
name|testConsistencyAfterManyFlushes
argument_list|(
name|FlushFrequencyVariation
operator|.
name|AfterAllRingBufferFull
argument_list|)
expr_stmt|;
block|}
comment|/**    * Makes sure the data in the given input is what I'd expect.    * @param inStream The input stream.    * @param expectedSize The expected size of the data in there.    */
DECL|method|assertDataInStream (InputStream inStream, int expectedSize)
specifier|private
name|void
name|assertDataInStream
parameter_list|(
name|InputStream
name|inStream
parameter_list|,
name|int
name|expectedSize
parameter_list|)
throws|throws
name|Exception
block|{
name|int
name|byteRead
decl_stmt|;
name|int
name|countBytes
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|byteRead
operator|=
name|inStream
operator|.
name|read
argument_list|()
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|assertEquals
argument_list|(
name|countBytes
operator|%
name|byteValuePeriod
argument_list|,
name|byteRead
argument_list|)
expr_stmt|;
name|countBytes
operator|++
expr_stmt|;
block|}
name|assertEquals
argument_list|(
name|expectedSize
argument_list|,
name|countBytes
argument_list|)
expr_stmt|;
block|}
comment|/**    * Checks that the data in the given file is what I'd expect.    * @param file The file to check.    * @param expectedSize The expected size of the data in there.    */
DECL|method|assertDataInFile (Path file, int expectedSize)
specifier|private
name|void
name|assertDataInFile
parameter_list|(
name|Path
name|file
parameter_list|,
name|int
name|expectedSize
parameter_list|)
throws|throws
name|Exception
block|{
name|InputStream
name|inStream
init|=
name|testAccount
operator|.
name|getFileSystem
argument_list|()
operator|.
name|open
argument_list|(
name|file
argument_list|)
decl_stmt|;
name|assertDataInStream
argument_list|(
name|inStream
argument_list|,
name|expectedSize
argument_list|)
expr_stmt|;
name|inStream
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|/**    * Checks that the data in the current temporary upload blob    * is what I'd expect.    * @param expectedSize The expected size of the data in there.    */
DECL|method|assertDataInTempBlob (int expectedSize)
specifier|private
name|void
name|assertDataInTempBlob
parameter_list|(
name|int
name|expectedSize
parameter_list|)
throws|throws
name|Exception
block|{
comment|// Look for the temporary upload blob in the backing store.
name|InMemoryBlockBlobStore
name|backingStore
init|=
name|testAccount
operator|.
name|getMockStorage
argument_list|()
operator|.
name|getBackingStore
argument_list|()
decl_stmt|;
name|String
name|tempKey
init|=
literal|null
decl_stmt|;
for|for
control|(
name|String
name|key
range|:
name|backingStore
operator|.
name|getKeys
argument_list|()
control|)
block|{
if|if
condition|(
name|key
operator|.
name|contains
argument_list|(
name|NativeAzureFileSystem
operator|.
name|AZURE_TEMP_FOLDER
argument_list|)
condition|)
block|{
comment|// Assume this is the one we're looking for.
name|tempKey
operator|=
name|key
expr_stmt|;
break|break;
block|}
block|}
name|assertNotNull
argument_list|(
name|tempKey
argument_list|)
expr_stmt|;
name|InputStream
name|inStream
init|=
operator|new
name|ByteArrayInputStream
argument_list|(
name|backingStore
operator|.
name|getContent
argument_list|(
name|tempKey
argument_list|)
argument_list|)
decl_stmt|;
name|assertDataInStream
argument_list|(
name|inStream
argument_list|,
name|expectedSize
argument_list|)
expr_stmt|;
name|inStream
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|/**    * Tests the given scenario for uploading a file while flushing    * periodically and making sure the data is always consistent    * with what I'd expect.    * @param variation The variation/scenario to test.    */
DECL|method|testConsistencyAfterManyFlushes (FlushFrequencyVariation variation)
specifier|private
name|void
name|testConsistencyAfterManyFlushes
parameter_list|(
name|FlushFrequencyVariation
name|variation
parameter_list|)
throws|throws
name|Exception
block|{
name|Path
name|uploadedFile
init|=
operator|new
name|Path
argument_list|(
literal|"/uploadedFile"
argument_list|)
decl_stmt|;
name|OutputStream
name|outStream
init|=
name|testAccount
operator|.
name|getFileSystem
argument_list|()
operator|.
name|create
argument_list|(
name|uploadedFile
argument_list|)
decl_stmt|;
specifier|final
name|int
name|totalSize
init|=
literal|9123
decl_stmt|;
name|int
name|flushPeriod
decl_stmt|;
switch|switch
condition|(
name|variation
condition|)
block|{
case|case
name|BeforeSingleBufferFull
case|:
name|flushPeriod
operator|=
literal|300
expr_stmt|;
break|break;
case|case
name|AfterSingleBufferFull
case|:
name|flushPeriod
operator|=
literal|600
expr_stmt|;
break|break;
case|case
name|AfterAllRingBufferFull
case|:
name|flushPeriod
operator|=
literal|1600
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Unknown variation: "
operator|+
name|variation
argument_list|)
throw|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|totalSize
condition|;
name|i
operator|++
control|)
block|{
name|outStream
operator|.
name|write
argument_list|(
name|i
operator|%
name|byteValuePeriod
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|%
name|flushPeriod
operator|==
literal|0
condition|)
block|{
name|outStream
operator|.
name|flush
argument_list|()
expr_stmt|;
name|assertDataInTempBlob
argument_list|(
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|outStream
operator|.
name|close
argument_list|()
expr_stmt|;
name|assertDataInFile
argument_list|(
name|uploadedFile
argument_list|,
name|totalSize
argument_list|)
expr_stmt|;
block|}
block|}
end_class

end_unit

