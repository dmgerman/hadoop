begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.tools.mapred.lib
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|tools
operator|.
name|mapred
operator|.
name|lib
package|;
end_package

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|lib
operator|.
name|input
operator|.
name|FileSplit
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|tools
operator|.
name|DistCpConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|tools
operator|.
name|util
operator|.
name|DistCpUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|Text
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|SequenceFile
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|tools
operator|.
name|CopyListingFileStatus
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_comment
comment|/**  * DynamicInputFormat implements the "Worker pattern" for DistCp.  * Rather than to split up the copy-list into a set of static splits,  * the DynamicInputFormat does the following:  * 1. Splits the copy-list into small chunks on the DFS.  * 2. Creates a set of empty "dynamic" splits, that each consume as many chunks  *    as it can.  * This arrangement ensures that a single slow mapper won't slow down the entire  * job (since the slack will be picked up by other mappers, who consume more  * chunks.)  * By varying the split-ratio, one can vary chunk sizes to achieve different  * performance characteristics.   */
end_comment

begin_class
DECL|class|DynamicInputFormat
specifier|public
class|class
name|DynamicInputFormat
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|InputFormat
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|DynamicInputFormat
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|CONF_LABEL_LISTING_SPLIT_RATIO
specifier|private
specifier|static
specifier|final
name|String
name|CONF_LABEL_LISTING_SPLIT_RATIO
init|=
literal|"mapred.listing.split.ratio"
decl_stmt|;
DECL|field|CONF_LABEL_NUM_SPLITS
specifier|private
specifier|static
specifier|final
name|String
name|CONF_LABEL_NUM_SPLITS
init|=
literal|"mapred.num.splits"
decl_stmt|;
DECL|field|CONF_LABEL_NUM_ENTRIES_PER_CHUNK
specifier|private
specifier|static
specifier|final
name|String
name|CONF_LABEL_NUM_ENTRIES_PER_CHUNK
init|=
literal|"mapred.num.entries.per.chunk"
decl_stmt|;
DECL|field|chunkContext
specifier|private
name|DynamicInputChunkContext
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|chunkContext
init|=
literal|null
decl_stmt|;
comment|/**    * Implementation of InputFormat::getSplits(). This method splits up the    * copy-listing file into chunks, and assigns the first batch to different    * tasks.    * @param jobContext JobContext for the map job.    * @return The list of (empty) dynamic input-splits.    * @throws IOException    * @throws InterruptedException    */
annotation|@
name|Override
DECL|method|getSplits (JobContext jobContext)
specifier|public
name|List
argument_list|<
name|InputSplit
argument_list|>
name|getSplits
parameter_list|(
name|JobContext
name|jobContext
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"DynamicInputFormat: Getting splits for job:"
operator|+
name|jobContext
operator|.
name|getJobID
argument_list|()
argument_list|)
expr_stmt|;
name|chunkContext
operator|=
name|getChunkContext
argument_list|(
name|jobContext
operator|.
name|getConfiguration
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|createSplits
argument_list|(
name|jobContext
argument_list|,
name|splitCopyListingIntoChunksWithShuffle
argument_list|(
name|jobContext
argument_list|)
argument_list|)
return|;
block|}
DECL|method|createSplits (JobContext jobContext, List<DynamicInputChunk> chunks)
specifier|private
name|List
argument_list|<
name|InputSplit
argument_list|>
name|createSplits
parameter_list|(
name|JobContext
name|jobContext
parameter_list|,
name|List
argument_list|<
name|DynamicInputChunk
argument_list|>
name|chunks
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|numMaps
init|=
name|getNumMapTasks
argument_list|(
name|jobContext
operator|.
name|getConfiguration
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|int
name|nSplits
init|=
name|Math
operator|.
name|min
argument_list|(
name|numMaps
argument_list|,
name|chunks
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|InputSplit
argument_list|>
name|splits
init|=
operator|new
name|ArrayList
argument_list|<
name|InputSplit
argument_list|>
argument_list|(
name|nSplits
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nSplits
condition|;
operator|++
name|i
control|)
block|{
name|TaskID
name|taskId
init|=
operator|new
name|TaskID
argument_list|(
name|jobContext
operator|.
name|getJobID
argument_list|()
argument_list|,
name|TaskType
operator|.
name|MAP
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|chunks
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|assignTo
argument_list|(
name|taskId
argument_list|)
expr_stmt|;
name|splits
operator|.
name|add
argument_list|(
operator|new
name|FileSplit
argument_list|(
name|chunks
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getPath
argument_list|()
argument_list|,
literal|0
argument_list|,
comment|// Setting non-zero length for FileSplit size, to avoid a possible
comment|// future when 0-sized file-splits are considered "empty" and skipped
comment|// over.
name|getMinRecordsPerChunk
argument_list|(
name|jobContext
operator|.
name|getConfiguration
argument_list|()
argument_list|)
argument_list|,
literal|null
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|DistCpUtils
operator|.
name|publish
argument_list|(
name|jobContext
operator|.
name|getConfiguration
argument_list|()
argument_list|,
name|CONF_LABEL_NUM_SPLITS
argument_list|,
name|splits
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|splits
return|;
block|}
DECL|field|N_CHUNKS_OPEN_AT_ONCE_DEFAULT
specifier|private
specifier|static
name|int
name|N_CHUNKS_OPEN_AT_ONCE_DEFAULT
init|=
literal|16
decl_stmt|;
DECL|method|getChunkContext ( Configuration configuration)
specifier|public
name|DynamicInputChunkContext
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getChunkContext
parameter_list|(
name|Configuration
name|configuration
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|chunkContext
operator|==
literal|null
condition|)
block|{
name|chunkContext
operator|=
operator|new
name|DynamicInputChunkContext
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|configuration
argument_list|)
expr_stmt|;
block|}
return|return
name|chunkContext
return|;
block|}
DECL|method|splitCopyListingIntoChunksWithShuffle (JobContext context)
specifier|private
name|List
argument_list|<
name|DynamicInputChunk
argument_list|>
name|splitCopyListingIntoChunksWithShuffle
parameter_list|(
name|JobContext
name|context
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|Configuration
name|configuration
init|=
name|context
operator|.
name|getConfiguration
argument_list|()
decl_stmt|;
name|int
name|numRecords
init|=
name|getNumberOfRecords
argument_list|(
name|configuration
argument_list|)
decl_stmt|;
name|int
name|numMaps
init|=
name|getNumMapTasks
argument_list|(
name|configuration
argument_list|)
decl_stmt|;
name|int
name|maxChunksTolerable
init|=
name|getMaxChunksTolerable
argument_list|(
name|configuration
argument_list|)
decl_stmt|;
comment|// Number of chunks each map will process, on average.
name|int
name|splitRatio
init|=
name|getListingSplitRatio
argument_list|(
name|configuration
argument_list|,
name|numMaps
argument_list|,
name|numRecords
argument_list|)
decl_stmt|;
name|validateNumChunksUsing
argument_list|(
name|splitRatio
argument_list|,
name|numMaps
argument_list|,
name|maxChunksTolerable
argument_list|)
expr_stmt|;
name|int
name|numEntriesPerChunk
init|=
operator|(
name|int
operator|)
name|Math
operator|.
name|ceil
argument_list|(
operator|(
name|float
operator|)
name|numRecords
operator|/
operator|(
name|splitRatio
operator|*
name|numMaps
operator|)
argument_list|)
decl_stmt|;
name|DistCpUtils
operator|.
name|publish
argument_list|(
name|context
operator|.
name|getConfiguration
argument_list|()
argument_list|,
name|CONF_LABEL_NUM_ENTRIES_PER_CHUNK
argument_list|,
name|numEntriesPerChunk
argument_list|)
expr_stmt|;
specifier|final
name|int
name|nChunksTotal
init|=
operator|(
name|int
operator|)
name|Math
operator|.
name|ceil
argument_list|(
operator|(
name|float
operator|)
name|numRecords
operator|/
name|numEntriesPerChunk
argument_list|)
decl_stmt|;
name|int
name|nChunksOpenAtOnce
init|=
name|Math
operator|.
name|min
argument_list|(
name|N_CHUNKS_OPEN_AT_ONCE_DEFAULT
argument_list|,
name|nChunksTotal
argument_list|)
decl_stmt|;
name|Path
name|listingPath
init|=
name|getListingFilePath
argument_list|(
name|configuration
argument_list|)
decl_stmt|;
name|SequenceFile
operator|.
name|Reader
name|reader
init|=
operator|new
name|SequenceFile
operator|.
name|Reader
argument_list|(
name|configuration
argument_list|,
name|SequenceFile
operator|.
name|Reader
operator|.
name|file
argument_list|(
name|listingPath
argument_list|)
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|DynamicInputChunk
argument_list|>
name|openChunks
init|=
operator|new
name|ArrayList
argument_list|<
name|DynamicInputChunk
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|DynamicInputChunk
argument_list|>
name|chunksFinal
init|=
operator|new
name|ArrayList
argument_list|<
name|DynamicInputChunk
argument_list|>
argument_list|()
decl_stmt|;
name|CopyListingFileStatus
name|fileStatus
init|=
operator|new
name|CopyListingFileStatus
argument_list|()
decl_stmt|;
name|Text
name|relPath
init|=
operator|new
name|Text
argument_list|()
decl_stmt|;
name|int
name|recordCounter
init|=
literal|0
decl_stmt|;
name|int
name|chunkCount
init|=
literal|0
decl_stmt|;
try|try
block|{
while|while
condition|(
name|reader
operator|.
name|next
argument_list|(
name|relPath
argument_list|,
name|fileStatus
argument_list|)
condition|)
block|{
if|if
condition|(
name|recordCounter
operator|%
operator|(
name|nChunksOpenAtOnce
operator|*
name|numEntriesPerChunk
operator|)
operator|==
literal|0
condition|)
block|{
comment|// All chunks full. Create new chunk-set.
name|closeAll
argument_list|(
name|openChunks
argument_list|)
expr_stmt|;
name|chunksFinal
operator|.
name|addAll
argument_list|(
name|openChunks
argument_list|)
expr_stmt|;
name|openChunks
operator|=
name|createChunks
argument_list|(
name|chunkCount
argument_list|,
name|nChunksTotal
argument_list|,
name|nChunksOpenAtOnce
argument_list|)
expr_stmt|;
name|chunkCount
operator|+=
name|openChunks
operator|.
name|size
argument_list|()
expr_stmt|;
name|nChunksOpenAtOnce
operator|=
name|openChunks
operator|.
name|size
argument_list|()
expr_stmt|;
name|recordCounter
operator|=
literal|0
expr_stmt|;
block|}
comment|// Shuffle into open chunks.
name|openChunks
operator|.
name|get
argument_list|(
name|recordCounter
operator|%
name|nChunksOpenAtOnce
argument_list|)
operator|.
name|write
argument_list|(
name|relPath
argument_list|,
name|fileStatus
argument_list|)
expr_stmt|;
operator|++
name|recordCounter
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|closeAll
argument_list|(
name|openChunks
argument_list|)
expr_stmt|;
name|chunksFinal
operator|.
name|addAll
argument_list|(
name|openChunks
argument_list|)
expr_stmt|;
name|IOUtils
operator|.
name|closeStream
argument_list|(
name|reader
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Number of dynamic-chunk-files created: "
operator|+
name|chunksFinal
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|chunksFinal
return|;
block|}
DECL|method|validateNumChunksUsing (int splitRatio, int numMaps, int maxChunksTolerable)
specifier|private
specifier|static
name|void
name|validateNumChunksUsing
parameter_list|(
name|int
name|splitRatio
parameter_list|,
name|int
name|numMaps
parameter_list|,
name|int
name|maxChunksTolerable
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|splitRatio
operator|*
name|numMaps
operator|>
name|maxChunksTolerable
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Too many chunks created with splitRatio:"
operator|+
name|splitRatio
operator|+
literal|", numMaps:"
operator|+
name|numMaps
operator|+
literal|". Reduce numMaps or decrease split-ratio to proceed."
argument_list|)
throw|;
block|}
DECL|method|closeAll (List<DynamicInputChunk> chunks)
specifier|private
specifier|static
name|void
name|closeAll
parameter_list|(
name|List
argument_list|<
name|DynamicInputChunk
argument_list|>
name|chunks
parameter_list|)
block|{
for|for
control|(
name|DynamicInputChunk
name|chunk
range|:
name|chunks
control|)
name|chunk
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
DECL|method|createChunks (int chunkCount, int nChunksTotal, int nChunksOpenAtOnce)
specifier|private
name|List
argument_list|<
name|DynamicInputChunk
argument_list|>
name|createChunks
parameter_list|(
name|int
name|chunkCount
parameter_list|,
name|int
name|nChunksTotal
parameter_list|,
name|int
name|nChunksOpenAtOnce
parameter_list|)
throws|throws
name|IOException
block|{
name|List
argument_list|<
name|DynamicInputChunk
argument_list|>
name|chunks
init|=
operator|new
name|ArrayList
argument_list|<
name|DynamicInputChunk
argument_list|>
argument_list|()
decl_stmt|;
name|int
name|chunkIdUpperBound
init|=
name|Math
operator|.
name|min
argument_list|(
name|nChunksTotal
argument_list|,
name|chunkCount
operator|+
name|nChunksOpenAtOnce
argument_list|)
decl_stmt|;
comment|// If there will be fewer than nChunksOpenAtOnce chunks left after
comment|// the current batch of chunks, fold the remaining chunks into
comment|// the current batch.
if|if
condition|(
name|nChunksTotal
operator|-
name|chunkIdUpperBound
operator|<
name|nChunksOpenAtOnce
condition|)
name|chunkIdUpperBound
operator|=
name|nChunksTotal
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
name|chunkCount
init|;
name|i
operator|<
name|chunkIdUpperBound
condition|;
operator|++
name|i
control|)
name|chunks
operator|.
name|add
argument_list|(
name|createChunk
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|chunks
return|;
block|}
DECL|method|createChunk (int chunkId)
specifier|private
name|DynamicInputChunk
name|createChunk
parameter_list|(
name|int
name|chunkId
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|chunkContext
operator|.
name|createChunkForWrite
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"%05d"
argument_list|,
name|chunkId
argument_list|)
argument_list|)
return|;
block|}
DECL|method|getListingFilePath (Configuration configuration)
specifier|private
specifier|static
name|Path
name|getListingFilePath
parameter_list|(
name|Configuration
name|configuration
parameter_list|)
block|{
name|String
name|listingFilePathString
init|=
name|configuration
operator|.
name|get
argument_list|(
name|DistCpConstants
operator|.
name|CONF_LABEL_LISTING_FILE_PATH
argument_list|,
literal|""
argument_list|)
decl_stmt|;
assert|assert
operator|!
name|listingFilePathString
operator|.
name|equals
argument_list|(
literal|""
argument_list|)
operator|:
literal|"Listing file not found."
assert|;
name|Path
name|listingFilePath
init|=
operator|new
name|Path
argument_list|(
name|listingFilePathString
argument_list|)
decl_stmt|;
try|try
block|{
assert|assert
name|listingFilePath
operator|.
name|getFileSystem
argument_list|(
name|configuration
argument_list|)
operator|.
name|exists
argument_list|(
name|listingFilePath
argument_list|)
operator|:
literal|"Listing file: "
operator|+
name|listingFilePath
operator|+
literal|" not found."
assert|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
assert|assert
literal|false
operator|:
literal|"Listing file: "
operator|+
name|listingFilePath
operator|+
literal|" couldn't be accessed. "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
assert|;
block|}
return|return
name|listingFilePath
return|;
block|}
DECL|method|getNumberOfRecords (Configuration configuration)
specifier|private
specifier|static
name|int
name|getNumberOfRecords
parameter_list|(
name|Configuration
name|configuration
parameter_list|)
block|{
return|return
name|DistCpUtils
operator|.
name|getInt
argument_list|(
name|configuration
argument_list|,
name|DistCpConstants
operator|.
name|CONF_LABEL_TOTAL_NUMBER_OF_RECORDS
argument_list|)
return|;
block|}
DECL|method|getNumMapTasks (Configuration configuration)
specifier|private
specifier|static
name|int
name|getNumMapTasks
parameter_list|(
name|Configuration
name|configuration
parameter_list|)
block|{
return|return
name|DistCpUtils
operator|.
name|getInt
argument_list|(
name|configuration
argument_list|,
name|JobContext
operator|.
name|NUM_MAPS
argument_list|)
return|;
block|}
DECL|method|getListingSplitRatio (Configuration configuration, int numMaps, int numPaths)
specifier|private
specifier|static
name|int
name|getListingSplitRatio
parameter_list|(
name|Configuration
name|configuration
parameter_list|,
name|int
name|numMaps
parameter_list|,
name|int
name|numPaths
parameter_list|)
block|{
return|return
name|configuration
operator|.
name|getInt
argument_list|(
name|CONF_LABEL_LISTING_SPLIT_RATIO
argument_list|,
name|getSplitRatio
argument_list|(
name|numMaps
argument_list|,
name|numPaths
argument_list|,
name|configuration
argument_list|)
argument_list|)
return|;
block|}
DECL|method|getMaxChunksTolerable (Configuration conf)
specifier|private
specifier|static
name|int
name|getMaxChunksTolerable
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
name|int
name|maxChunksTolerable
init|=
name|conf
operator|.
name|getInt
argument_list|(
name|DistCpConstants
operator|.
name|CONF_LABEL_MAX_CHUNKS_TOLERABLE
argument_list|,
name|DistCpConstants
operator|.
name|MAX_CHUNKS_TOLERABLE_DEFAULT
argument_list|)
decl_stmt|;
if|if
condition|(
name|maxChunksTolerable
operator|<=
literal|0
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|DistCpConstants
operator|.
name|CONF_LABEL_MAX_CHUNKS_TOLERABLE
operator|+
literal|" should be positive. Fall back to default value: "
operator|+
name|DistCpConstants
operator|.
name|MAX_CHUNKS_TOLERABLE_DEFAULT
argument_list|)
expr_stmt|;
name|maxChunksTolerable
operator|=
name|DistCpConstants
operator|.
name|MAX_CHUNKS_TOLERABLE_DEFAULT
expr_stmt|;
block|}
return|return
name|maxChunksTolerable
return|;
block|}
DECL|method|getMaxChunksIdeal (Configuration conf)
specifier|private
specifier|static
name|int
name|getMaxChunksIdeal
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
name|int
name|maxChunksIdeal
init|=
name|conf
operator|.
name|getInt
argument_list|(
name|DistCpConstants
operator|.
name|CONF_LABEL_MAX_CHUNKS_IDEAL
argument_list|,
name|DistCpConstants
operator|.
name|MAX_CHUNKS_IDEAL_DEFAULT
argument_list|)
decl_stmt|;
if|if
condition|(
name|maxChunksIdeal
operator|<=
literal|0
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|DistCpConstants
operator|.
name|CONF_LABEL_MAX_CHUNKS_IDEAL
operator|+
literal|" should be positive. Fall back to default value: "
operator|+
name|DistCpConstants
operator|.
name|MAX_CHUNKS_IDEAL_DEFAULT
argument_list|)
expr_stmt|;
name|maxChunksIdeal
operator|=
name|DistCpConstants
operator|.
name|MAX_CHUNKS_IDEAL_DEFAULT
expr_stmt|;
block|}
return|return
name|maxChunksIdeal
return|;
block|}
DECL|method|getMinRecordsPerChunk (Configuration conf)
specifier|private
specifier|static
name|int
name|getMinRecordsPerChunk
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
name|int
name|minRecordsPerChunk
init|=
name|conf
operator|.
name|getInt
argument_list|(
name|DistCpConstants
operator|.
name|CONF_LABEL_MIN_RECORDS_PER_CHUNK
argument_list|,
name|DistCpConstants
operator|.
name|MIN_RECORDS_PER_CHUNK_DEFAULT
argument_list|)
decl_stmt|;
if|if
condition|(
name|minRecordsPerChunk
operator|<=
literal|0
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|DistCpConstants
operator|.
name|CONF_LABEL_MIN_RECORDS_PER_CHUNK
operator|+
literal|" should be positive. Fall back to default value: "
operator|+
name|DistCpConstants
operator|.
name|MIN_RECORDS_PER_CHUNK_DEFAULT
argument_list|)
expr_stmt|;
name|minRecordsPerChunk
operator|=
name|DistCpConstants
operator|.
name|MIN_RECORDS_PER_CHUNK_DEFAULT
expr_stmt|;
block|}
return|return
name|minRecordsPerChunk
return|;
block|}
DECL|method|getSplitRatio (Configuration conf)
specifier|private
specifier|static
name|int
name|getSplitRatio
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
name|int
name|splitRatio
init|=
name|conf
operator|.
name|getInt
argument_list|(
name|DistCpConstants
operator|.
name|CONF_LABEL_SPLIT_RATIO
argument_list|,
name|DistCpConstants
operator|.
name|SPLIT_RATIO_DEFAULT
argument_list|)
decl_stmt|;
if|if
condition|(
name|splitRatio
operator|<=
literal|0
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|DistCpConstants
operator|.
name|CONF_LABEL_SPLIT_RATIO
operator|+
literal|" should be positive. Fall back to default value: "
operator|+
name|DistCpConstants
operator|.
name|SPLIT_RATIO_DEFAULT
argument_list|)
expr_stmt|;
name|splitRatio
operator|=
name|DistCpConstants
operator|.
name|SPLIT_RATIO_DEFAULT
expr_stmt|;
block|}
return|return
name|splitRatio
return|;
block|}
comment|/**    * Package private, for testability.    * @param nMaps The number of maps requested for.    * @param nRecords The number of records to be copied.    * @return The number of splits each map should handle, ideally.    */
DECL|method|getSplitRatio (int nMaps, int nRecords)
specifier|static
name|int
name|getSplitRatio
parameter_list|(
name|int
name|nMaps
parameter_list|,
name|int
name|nRecords
parameter_list|)
block|{
return|return
name|getSplitRatio
argument_list|(
name|nMaps
argument_list|,
name|nRecords
argument_list|,
operator|new
name|Configuration
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Package private, for testability.    * @param nMaps The number of maps requested for.    * @param nRecords The number of records to be copied.    * @param conf The configuration set by users.    * @return The number of splits each map should handle, ideally.    */
DECL|method|getSplitRatio (int nMaps, int nRecords, Configuration conf)
specifier|static
name|int
name|getSplitRatio
parameter_list|(
name|int
name|nMaps
parameter_list|,
name|int
name|nRecords
parameter_list|,
name|Configuration
name|conf
parameter_list|)
block|{
name|int
name|maxChunksIdeal
init|=
name|getMaxChunksIdeal
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|int
name|minRecordsPerChunk
init|=
name|getMinRecordsPerChunk
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|int
name|splitRatio
init|=
name|getSplitRatio
argument_list|(
name|conf
argument_list|)
decl_stmt|;
if|if
condition|(
name|nMaps
operator|==
literal|1
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"nMaps == 1. Why use DynamicInputFormat?"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|nMaps
operator|>
name|maxChunksIdeal
condition|)
return|return
name|splitRatio
return|;
name|int
name|nPickups
init|=
operator|(
name|int
operator|)
name|Math
operator|.
name|ceil
argument_list|(
operator|(
name|float
operator|)
name|maxChunksIdeal
operator|/
name|nMaps
argument_list|)
decl_stmt|;
name|int
name|nRecordsPerChunk
init|=
operator|(
name|int
operator|)
name|Math
operator|.
name|ceil
argument_list|(
operator|(
name|float
operator|)
name|nRecords
operator|/
operator|(
name|nMaps
operator|*
name|nPickups
operator|)
argument_list|)
decl_stmt|;
return|return
name|nRecordsPerChunk
operator|<
name|minRecordsPerChunk
condition|?
name|splitRatio
else|:
name|nPickups
return|;
block|}
DECL|method|getNumEntriesPerChunk (Configuration configuration)
specifier|static
name|int
name|getNumEntriesPerChunk
parameter_list|(
name|Configuration
name|configuration
parameter_list|)
block|{
return|return
name|DistCpUtils
operator|.
name|getInt
argument_list|(
name|configuration
argument_list|,
name|CONF_LABEL_NUM_ENTRIES_PER_CHUNK
argument_list|)
return|;
block|}
comment|/**    * Implementation of Inputformat::createRecordReader().    * @param inputSplit The split for which the RecordReader is required.    * @param taskAttemptContext TaskAttemptContext for the current attempt.    * @return DynamicRecordReader instance.    * @throws IOException    * @throws InterruptedException    */
annotation|@
name|Override
DECL|method|createRecordReader ( InputSplit inputSplit, TaskAttemptContext taskAttemptContext)
specifier|public
name|RecordReader
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|createRecordReader
parameter_list|(
name|InputSplit
name|inputSplit
parameter_list|,
name|TaskAttemptContext
name|taskAttemptContext
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|chunkContext
operator|=
name|getChunkContext
argument_list|(
name|taskAttemptContext
operator|.
name|getConfiguration
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|new
name|DynamicRecordReader
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|chunkContext
argument_list|)
return|;
block|}
block|}
end_class

end_unit

