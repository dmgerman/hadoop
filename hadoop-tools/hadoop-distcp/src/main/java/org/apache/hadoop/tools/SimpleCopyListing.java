begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.tools
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|tools
package|;
end_package

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|SnapshotDiffReport
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|SequenceFile
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|Text
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|tools
operator|.
name|DistCpOptions
operator|.
name|FileAttribute
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|tools
operator|.
name|util
operator|.
name|DistCpUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|tools
operator|.
name|util
operator|.
name|ProducerConsumer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|tools
operator|.
name|util
operator|.
name|WorkReport
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|tools
operator|.
name|util
operator|.
name|WorkRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|tools
operator|.
name|util
operator|.
name|WorkRequestProcessor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|security
operator|.
name|TokenCache
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|Credentials
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileNotFoundException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Random
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|tools
operator|.
name|DistCpConstants
operator|.
name|HDFS_RESERVED_RAW_DIRECTORY_NAME
import|;
end_import

begin_comment
comment|/**  * The SimpleCopyListing is responsible for making the exhaustive list of  * all files/directories under its specified list of input-paths.  * These are written into the specified copy-listing file.  * Note: The SimpleCopyListing doesn't handle wild-cards in the input-paths.  */
end_comment

begin_class
DECL|class|SimpleCopyListing
specifier|public
class|class
name|SimpleCopyListing
extends|extends
name|CopyListing
block|{
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|SimpleCopyListing
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|DEFAULT_FILE_STATUS_SIZE
specifier|public
specifier|static
specifier|final
name|int
name|DEFAULT_FILE_STATUS_SIZE
init|=
literal|1000
decl_stmt|;
DECL|field|DEFAULT_RANDOMIZE_FILE_LISTING
specifier|public
specifier|static
specifier|final
name|boolean
name|DEFAULT_RANDOMIZE_FILE_LISTING
init|=
literal|true
decl_stmt|;
DECL|field|totalPaths
specifier|private
name|long
name|totalPaths
init|=
literal|0
decl_stmt|;
DECL|field|totalDirs
specifier|private
name|long
name|totalDirs
init|=
literal|0
decl_stmt|;
DECL|field|totalBytesToCopy
specifier|private
name|long
name|totalBytesToCopy
init|=
literal|0
decl_stmt|;
DECL|field|numListstatusThreads
specifier|private
name|int
name|numListstatusThreads
init|=
literal|1
decl_stmt|;
DECL|field|fileStatusLimit
specifier|private
specifier|final
name|int
name|fileStatusLimit
decl_stmt|;
DECL|field|randomizeFileListing
specifier|private
specifier|final
name|boolean
name|randomizeFileListing
decl_stmt|;
DECL|field|maxRetries
specifier|private
specifier|final
name|int
name|maxRetries
init|=
literal|3
decl_stmt|;
DECL|field|copyFilter
specifier|private
name|CopyFilter
name|copyFilter
decl_stmt|;
DECL|field|distCpSync
specifier|private
name|DistCpSync
name|distCpSync
decl_stmt|;
DECL|field|rnd
specifier|private
specifier|final
name|Random
name|rnd
init|=
operator|new
name|Random
argument_list|()
decl_stmt|;
comment|/**    * Protected constructor, to initialize configuration.    *    * @param configuration The input configuration, with which the source/target FileSystems may be accessed.    * @param credentials - Credentials object on which the FS delegation tokens are cached. If null    * delegation token caching is skipped    */
DECL|method|SimpleCopyListing (Configuration configuration, Credentials credentials)
specifier|protected
name|SimpleCopyListing
parameter_list|(
name|Configuration
name|configuration
parameter_list|,
name|Credentials
name|credentials
parameter_list|)
block|{
name|super
argument_list|(
name|configuration
argument_list|,
name|credentials
argument_list|)
expr_stmt|;
name|numListstatusThreads
operator|=
name|getConf
argument_list|()
operator|.
name|getInt
argument_list|(
name|DistCpConstants
operator|.
name|CONF_LABEL_LISTSTATUS_THREADS
argument_list|,
name|DistCpConstants
operator|.
name|DEFAULT_LISTSTATUS_THREADS
argument_list|)
expr_stmt|;
name|fileStatusLimit
operator|=
name|Math
operator|.
name|max
argument_list|(
literal|1
argument_list|,
name|getConf
argument_list|()
operator|.
name|getInt
argument_list|(
name|DistCpConstants
operator|.
name|CONF_LABEL_SIMPLE_LISTING_FILESTATUS_SIZE
argument_list|,
name|DEFAULT_FILE_STATUS_SIZE
argument_list|)
argument_list|)
expr_stmt|;
name|randomizeFileListing
operator|=
name|getConf
argument_list|()
operator|.
name|getBoolean
argument_list|(
name|DistCpConstants
operator|.
name|CONF_LABEL_SIMPLE_LISTING_RANDOMIZE_FILES
argument_list|,
name|DEFAULT_RANDOMIZE_FILE_LISTING
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"numListstatusThreads="
operator|+
name|numListstatusThreads
operator|+
literal|", fileStatusLimit="
operator|+
name|fileStatusLimit
operator|+
literal|", randomizeFileListing="
operator|+
name|randomizeFileListing
argument_list|)
expr_stmt|;
block|}
name|copyFilter
operator|=
name|CopyFilter
operator|.
name|getCopyFilter
argument_list|(
name|getConf
argument_list|()
argument_list|)
expr_stmt|;
name|copyFilter
operator|.
name|initialize
argument_list|()
expr_stmt|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|SimpleCopyListing (Configuration configuration, Credentials credentials, int numListstatusThreads, int fileStatusLimit, boolean randomizeFileListing)
specifier|protected
name|SimpleCopyListing
parameter_list|(
name|Configuration
name|configuration
parameter_list|,
name|Credentials
name|credentials
parameter_list|,
name|int
name|numListstatusThreads
parameter_list|,
name|int
name|fileStatusLimit
parameter_list|,
name|boolean
name|randomizeFileListing
parameter_list|)
block|{
name|super
argument_list|(
name|configuration
argument_list|,
name|credentials
argument_list|)
expr_stmt|;
name|this
operator|.
name|numListstatusThreads
operator|=
name|numListstatusThreads
expr_stmt|;
name|this
operator|.
name|fileStatusLimit
operator|=
name|Math
operator|.
name|max
argument_list|(
literal|1
argument_list|,
name|fileStatusLimit
argument_list|)
expr_stmt|;
name|this
operator|.
name|randomizeFileListing
operator|=
name|randomizeFileListing
expr_stmt|;
block|}
DECL|method|SimpleCopyListing (Configuration configuration, Credentials credentials, DistCpSync distCpSync)
specifier|protected
name|SimpleCopyListing
parameter_list|(
name|Configuration
name|configuration
parameter_list|,
name|Credentials
name|credentials
parameter_list|,
name|DistCpSync
name|distCpSync
parameter_list|)
block|{
name|this
argument_list|(
name|configuration
argument_list|,
name|credentials
argument_list|)
expr_stmt|;
name|this
operator|.
name|distCpSync
operator|=
name|distCpSync
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|validatePaths (DistCpOptions options)
specifier|protected
name|void
name|validatePaths
parameter_list|(
name|DistCpOptions
name|options
parameter_list|)
throws|throws
name|IOException
throws|,
name|InvalidInputException
block|{
name|Path
name|targetPath
init|=
name|options
operator|.
name|getTargetPath
argument_list|()
decl_stmt|;
name|FileSystem
name|targetFS
init|=
name|targetPath
operator|.
name|getFileSystem
argument_list|(
name|getConf
argument_list|()
argument_list|)
decl_stmt|;
name|boolean
name|targetExists
init|=
literal|false
decl_stmt|;
name|boolean
name|targetIsFile
init|=
literal|false
decl_stmt|;
try|try
block|{
name|targetIsFile
operator|=
name|targetFS
operator|.
name|getFileStatus
argument_list|(
name|targetPath
argument_list|)
operator|.
name|isFile
argument_list|()
expr_stmt|;
name|targetExists
operator|=
literal|true
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|ignored
parameter_list|)
block|{     }
name|targetPath
operator|=
name|targetFS
operator|.
name|makeQualified
argument_list|(
name|targetPath
argument_list|)
expr_stmt|;
specifier|final
name|boolean
name|targetIsReservedRaw
init|=
name|Path
operator|.
name|getPathWithoutSchemeAndAuthority
argument_list|(
name|targetPath
argument_list|)
operator|.
name|toString
argument_list|()
operator|.
name|startsWith
argument_list|(
name|HDFS_RESERVED_RAW_DIRECTORY_NAME
argument_list|)
decl_stmt|;
comment|//If target is a file, then source has to be single file
if|if
condition|(
name|targetIsFile
condition|)
block|{
if|if
condition|(
name|options
operator|.
name|getSourcePaths
argument_list|()
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
throw|throw
operator|new
name|InvalidInputException
argument_list|(
literal|"Multiple source being copied to a file: "
operator|+
name|targetPath
argument_list|)
throw|;
block|}
name|Path
name|srcPath
init|=
name|options
operator|.
name|getSourcePaths
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|FileSystem
name|sourceFS
init|=
name|srcPath
operator|.
name|getFileSystem
argument_list|(
name|getConf
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|sourceFS
operator|.
name|isFile
argument_list|(
name|srcPath
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|InvalidInputException
argument_list|(
literal|"Cannot copy "
operator|+
name|srcPath
operator|+
literal|", which is not a file to "
operator|+
name|targetPath
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
name|options
operator|.
name|shouldAtomicCommit
argument_list|()
operator|&&
name|targetExists
condition|)
block|{
throw|throw
operator|new
name|InvalidInputException
argument_list|(
literal|"Target path for atomic-commit already exists: "
operator|+
name|targetPath
operator|+
literal|". Cannot atomic-commit to pre-existing target-path."
argument_list|)
throw|;
block|}
for|for
control|(
name|Path
name|path
range|:
name|options
operator|.
name|getSourcePaths
argument_list|()
control|)
block|{
name|FileSystem
name|fs
init|=
name|path
operator|.
name|getFileSystem
argument_list|(
name|getConf
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|fs
operator|.
name|exists
argument_list|(
name|path
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|InvalidInputException
argument_list|(
name|path
operator|+
literal|" doesn't exist"
argument_list|)
throw|;
block|}
if|if
condition|(
name|Path
operator|.
name|getPathWithoutSchemeAndAuthority
argument_list|(
name|path
argument_list|)
operator|.
name|toString
argument_list|()
operator|.
name|startsWith
argument_list|(
name|HDFS_RESERVED_RAW_DIRECTORY_NAME
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|targetIsReservedRaw
condition|)
block|{
specifier|final
name|String
name|msg
init|=
literal|"The source path '"
operator|+
name|path
operator|+
literal|"' starts with "
operator|+
name|HDFS_RESERVED_RAW_DIRECTORY_NAME
operator|+
literal|" but the target path '"
operator|+
name|targetPath
operator|+
literal|"' does not. Either all or none of the paths must "
operator|+
literal|"have this prefix."
decl_stmt|;
throw|throw
operator|new
name|InvalidInputException
argument_list|(
name|msg
argument_list|)
throw|;
block|}
block|}
elseif|else
if|if
condition|(
name|targetIsReservedRaw
condition|)
block|{
specifier|final
name|String
name|msg
init|=
literal|"The target path '"
operator|+
name|targetPath
operator|+
literal|"' starts with "
operator|+
name|HDFS_RESERVED_RAW_DIRECTORY_NAME
operator|+
literal|" but the source path '"
operator|+
name|path
operator|+
literal|"' does not. Either all or none of the paths must "
operator|+
literal|"have this prefix."
decl_stmt|;
throw|throw
operator|new
name|InvalidInputException
argument_list|(
name|msg
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
name|targetIsReservedRaw
condition|)
block|{
name|options
operator|.
name|preserveRawXattrs
argument_list|()
expr_stmt|;
name|getConf
argument_list|()
operator|.
name|setBoolean
argument_list|(
name|DistCpConstants
operator|.
name|CONF_LABEL_PRESERVE_RAWXATTRS
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/* This is requires to allow map tasks to access each of the source        clusters. This would retrieve the delegation token for each unique        file system and add them to job's private credential store      */
name|Credentials
name|credentials
init|=
name|getCredentials
argument_list|()
decl_stmt|;
if|if
condition|(
name|credentials
operator|!=
literal|null
condition|)
block|{
name|Path
index|[]
name|inputPaths
init|=
name|options
operator|.
name|getSourcePaths
argument_list|()
operator|.
name|toArray
argument_list|(
operator|new
name|Path
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
name|TokenCache
operator|.
name|obtainTokensForNamenodes
argument_list|(
name|credentials
argument_list|,
name|inputPaths
argument_list|,
name|getConf
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|doBuildListing (Path pathToListingFile, DistCpOptions options)
specifier|protected
name|void
name|doBuildListing
parameter_list|(
name|Path
name|pathToListingFile
parameter_list|,
name|DistCpOptions
name|options
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|options
operator|.
name|shouldUseSnapshotDiff
argument_list|()
condition|)
block|{
name|doBuildListingWithSnapshotDiff
argument_list|(
name|getWriter
argument_list|(
name|pathToListingFile
argument_list|)
argument_list|,
name|options
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|doBuildListing
argument_list|(
name|getWriter
argument_list|(
name|pathToListingFile
argument_list|)
argument_list|,
name|options
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Get a path with its scheme and authority.    */
DECL|method|getPathWithSchemeAndAuthority (Path path)
specifier|private
name|Path
name|getPathWithSchemeAndAuthority
parameter_list|(
name|Path
name|path
parameter_list|)
throws|throws
name|IOException
block|{
name|FileSystem
name|fs
init|=
name|path
operator|.
name|getFileSystem
argument_list|(
name|getConf
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|scheme
init|=
name|path
operator|.
name|toUri
argument_list|()
operator|.
name|getScheme
argument_list|()
decl_stmt|;
if|if
condition|(
name|scheme
operator|==
literal|null
condition|)
block|{
name|scheme
operator|=
name|fs
operator|.
name|getUri
argument_list|()
operator|.
name|getScheme
argument_list|()
expr_stmt|;
block|}
name|String
name|authority
init|=
name|path
operator|.
name|toUri
argument_list|()
operator|.
name|getAuthority
argument_list|()
decl_stmt|;
if|if
condition|(
name|authority
operator|==
literal|null
condition|)
block|{
name|authority
operator|=
name|fs
operator|.
name|getUri
argument_list|()
operator|.
name|getAuthority
argument_list|()
expr_stmt|;
block|}
return|return
operator|new
name|Path
argument_list|(
name|scheme
argument_list|,
name|authority
argument_list|,
name|makeQualified
argument_list|(
name|path
argument_list|)
operator|.
name|toUri
argument_list|()
operator|.
name|getPath
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Write a single file/directory to the sequence file.    * @throws IOException    */
DECL|method|addToFileListing (SequenceFile.Writer fileListWriter, Path sourceRoot, Path path, DistCpOptions options)
specifier|private
name|void
name|addToFileListing
parameter_list|(
name|SequenceFile
operator|.
name|Writer
name|fileListWriter
parameter_list|,
name|Path
name|sourceRoot
parameter_list|,
name|Path
name|path
parameter_list|,
name|DistCpOptions
name|options
parameter_list|)
throws|throws
name|IOException
block|{
name|sourceRoot
operator|=
name|getPathWithSchemeAndAuthority
argument_list|(
name|sourceRoot
argument_list|)
expr_stmt|;
name|path
operator|=
name|getPathWithSchemeAndAuthority
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|path
operator|=
name|makeQualified
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|FileSystem
name|sourceFS
init|=
name|sourceRoot
operator|.
name|getFileSystem
argument_list|(
name|getConf
argument_list|()
argument_list|)
decl_stmt|;
name|FileStatus
name|fileStatus
init|=
name|sourceFS
operator|.
name|getFileStatus
argument_list|(
name|path
argument_list|)
decl_stmt|;
specifier|final
name|boolean
name|preserveAcls
init|=
name|options
operator|.
name|shouldPreserve
argument_list|(
name|FileAttribute
operator|.
name|ACL
argument_list|)
decl_stmt|;
specifier|final
name|boolean
name|preserveXAttrs
init|=
name|options
operator|.
name|shouldPreserve
argument_list|(
name|FileAttribute
operator|.
name|XATTR
argument_list|)
decl_stmt|;
specifier|final
name|boolean
name|preserveRawXAttrs
init|=
name|options
operator|.
name|shouldPreserveRawXattrs
argument_list|()
decl_stmt|;
name|CopyListingFileStatus
name|fileCopyListingStatus
init|=
name|DistCpUtils
operator|.
name|toCopyListingFileStatus
argument_list|(
name|sourceFS
argument_list|,
name|fileStatus
argument_list|,
name|preserveAcls
argument_list|,
name|preserveXAttrs
argument_list|,
name|preserveRawXAttrs
argument_list|)
decl_stmt|;
name|writeToFileListingRoot
argument_list|(
name|fileListWriter
argument_list|,
name|fileCopyListingStatus
argument_list|,
name|sourceRoot
argument_list|,
name|options
argument_list|)
expr_stmt|;
block|}
comment|/**    * Build a copy list based on the snapshot diff report.    *    * Any file/directory changed or created will be in the list. Deleted    * files/directories will not be in the list, since they are handled by    * {@link org.apache.hadoop.tools.DistCpSync#sync}. An item can be    * created/modified and renamed, in which case, the target path is put    * into the list.    * @throws IOException    */
annotation|@
name|VisibleForTesting
DECL|method|doBuildListingWithSnapshotDiff ( SequenceFile.Writer fileListWriter, DistCpOptions options)
specifier|protected
name|void
name|doBuildListingWithSnapshotDiff
parameter_list|(
name|SequenceFile
operator|.
name|Writer
name|fileListWriter
parameter_list|,
name|DistCpOptions
name|options
parameter_list|)
throws|throws
name|IOException
block|{
name|ArrayList
argument_list|<
name|DiffInfo
argument_list|>
name|diffList
init|=
name|distCpSync
operator|.
name|prepareDiffListForCopyListing
argument_list|()
decl_stmt|;
name|Path
name|sourceRoot
init|=
name|options
operator|.
name|getSourcePaths
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|FileSystem
name|sourceFS
init|=
name|sourceRoot
operator|.
name|getFileSystem
argument_list|(
name|getConf
argument_list|()
argument_list|)
decl_stmt|;
try|try
block|{
name|List
argument_list|<
name|FileStatusInfo
argument_list|>
name|fileStatuses
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
for|for
control|(
name|DiffInfo
name|diff
range|:
name|diffList
control|)
block|{
comment|// add snapshot paths prefix
name|diff
operator|.
name|setTarget
argument_list|(
operator|new
name|Path
argument_list|(
name|options
operator|.
name|getSourcePaths
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|diff
operator|.
name|getTarget
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|diff
operator|.
name|getType
argument_list|()
operator|==
name|SnapshotDiffReport
operator|.
name|DiffType
operator|.
name|MODIFY
condition|)
block|{
name|addToFileListing
argument_list|(
name|fileListWriter
argument_list|,
name|sourceRoot
argument_list|,
name|diff
operator|.
name|getTarget
argument_list|()
argument_list|,
name|options
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|diff
operator|.
name|getType
argument_list|()
operator|==
name|SnapshotDiffReport
operator|.
name|DiffType
operator|.
name|CREATE
condition|)
block|{
name|addToFileListing
argument_list|(
name|fileListWriter
argument_list|,
name|sourceRoot
argument_list|,
name|diff
operator|.
name|getTarget
argument_list|()
argument_list|,
name|options
argument_list|)
expr_stmt|;
name|FileStatus
name|sourceStatus
init|=
name|sourceFS
operator|.
name|getFileStatus
argument_list|(
name|diff
operator|.
name|getTarget
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|sourceStatus
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Adding source dir for traverse: "
operator|+
name|sourceStatus
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|HashSet
argument_list|<
name|String
argument_list|>
name|excludeList
init|=
name|distCpSync
operator|.
name|getTraverseExcludeList
argument_list|(
name|diff
operator|.
name|getSource
argument_list|()
argument_list|,
name|options
operator|.
name|getSourcePaths
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|ArrayList
argument_list|<
name|FileStatus
argument_list|>
name|sourceDirs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|sourceDirs
operator|.
name|add
argument_list|(
name|sourceStatus
argument_list|)
expr_stmt|;
name|traverseDirectory
argument_list|(
name|fileListWriter
argument_list|,
name|sourceFS
argument_list|,
name|sourceDirs
argument_list|,
name|sourceRoot
argument_list|,
name|options
argument_list|,
name|excludeList
argument_list|,
name|fileStatuses
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|randomizeFileListing
condition|)
block|{
name|writeToFileListing
argument_list|(
name|fileStatuses
argument_list|,
name|fileListWriter
argument_list|)
expr_stmt|;
block|}
name|fileListWriter
operator|.
name|close
argument_list|()
expr_stmt|;
name|fileListWriter
operator|=
literal|null
expr_stmt|;
block|}
finally|finally
block|{
name|IOUtils
operator|.
name|cleanup
argument_list|(
name|LOG
argument_list|,
name|fileListWriter
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Collect the list of     *   {@literal<sourceRelativePath, sourceFileStatus>}    * to be copied and write to the sequence file. In essence, any file or    * directory that need to be copied or sync-ed is written as an entry to the    * sequence file, with the possible exception of the source root:    *     when either -update (sync) or -overwrite switch is specified, and if    *     the the source root is a directory, then the source root entry is not     *     written to the sequence file, because only the contents of the source    *     directory need to be copied in this case.    * See {@link org.apache.hadoop.tools.util.DistCpUtils#getRelativePath} for    *     how relative path is computed.    * See computeSourceRootPath method for how the root path of the source is    *     computed.    * @param fileListWriter    * @param options    * @throws IOException    */
annotation|@
name|VisibleForTesting
DECL|method|doBuildListing (SequenceFile.Writer fileListWriter, DistCpOptions options)
specifier|protected
name|void
name|doBuildListing
parameter_list|(
name|SequenceFile
operator|.
name|Writer
name|fileListWriter
parameter_list|,
name|DistCpOptions
name|options
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|options
operator|.
name|getNumListstatusThreads
argument_list|()
operator|>
literal|0
condition|)
block|{
name|numListstatusThreads
operator|=
name|options
operator|.
name|getNumListstatusThreads
argument_list|()
expr_stmt|;
block|}
try|try
block|{
name|List
argument_list|<
name|FileStatusInfo
argument_list|>
name|statusList
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
for|for
control|(
name|Path
name|path
range|:
name|options
operator|.
name|getSourcePaths
argument_list|()
control|)
block|{
name|FileSystem
name|sourceFS
init|=
name|path
operator|.
name|getFileSystem
argument_list|(
name|getConf
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|boolean
name|preserveAcls
init|=
name|options
operator|.
name|shouldPreserve
argument_list|(
name|FileAttribute
operator|.
name|ACL
argument_list|)
decl_stmt|;
specifier|final
name|boolean
name|preserveXAttrs
init|=
name|options
operator|.
name|shouldPreserve
argument_list|(
name|FileAttribute
operator|.
name|XATTR
argument_list|)
decl_stmt|;
specifier|final
name|boolean
name|preserveRawXAttrs
init|=
name|options
operator|.
name|shouldPreserveRawXattrs
argument_list|()
decl_stmt|;
name|path
operator|=
name|makeQualified
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|FileStatus
name|rootStatus
init|=
name|sourceFS
operator|.
name|getFileStatus
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|Path
name|sourcePathRoot
init|=
name|computeSourceRootPath
argument_list|(
name|rootStatus
argument_list|,
name|options
argument_list|)
decl_stmt|;
name|FileStatus
index|[]
name|sourceFiles
init|=
name|sourceFS
operator|.
name|listStatus
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|boolean
name|explore
init|=
operator|(
name|sourceFiles
operator|!=
literal|null
operator|&&
name|sourceFiles
operator|.
name|length
operator|>
literal|0
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|explore
operator|||
name|rootStatus
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
name|CopyListingFileStatus
name|rootCopyListingStatus
init|=
name|DistCpUtils
operator|.
name|toCopyListingFileStatus
argument_list|(
name|sourceFS
argument_list|,
name|rootStatus
argument_list|,
name|preserveAcls
argument_list|,
name|preserveXAttrs
argument_list|,
name|preserveRawXAttrs
argument_list|)
decl_stmt|;
name|writeToFileListingRoot
argument_list|(
name|fileListWriter
argument_list|,
name|rootCopyListingStatus
argument_list|,
name|sourcePathRoot
argument_list|,
name|options
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|explore
condition|)
block|{
name|ArrayList
argument_list|<
name|FileStatus
argument_list|>
name|sourceDirs
init|=
operator|new
name|ArrayList
argument_list|<
name|FileStatus
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|FileStatus
name|sourceStatus
range|:
name|sourceFiles
control|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Recording source-path: "
operator|+
name|sourceStatus
operator|.
name|getPath
argument_list|()
operator|+
literal|" for copy."
argument_list|)
expr_stmt|;
block|}
name|CopyListingFileStatus
name|sourceCopyListingStatus
init|=
name|DistCpUtils
operator|.
name|toCopyListingFileStatus
argument_list|(
name|sourceFS
argument_list|,
name|sourceStatus
argument_list|,
name|preserveAcls
operator|&&
name|sourceStatus
operator|.
name|isDirectory
argument_list|()
argument_list|,
name|preserveXAttrs
operator|&&
name|sourceStatus
operator|.
name|isDirectory
argument_list|()
argument_list|,
name|preserveRawXAttrs
operator|&&
name|sourceStatus
operator|.
name|isDirectory
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|randomizeFileListing
condition|)
block|{
name|addToFileListing
argument_list|(
name|statusList
argument_list|,
operator|new
name|FileStatusInfo
argument_list|(
name|sourceCopyListingStatus
argument_list|,
name|sourcePathRoot
argument_list|)
argument_list|,
name|fileListWriter
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|writeToFileListing
argument_list|(
name|fileListWriter
argument_list|,
name|sourceCopyListingStatus
argument_list|,
name|sourcePathRoot
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sourceStatus
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Adding source dir for traverse: "
operator|+
name|sourceStatus
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|sourceDirs
operator|.
name|add
argument_list|(
name|sourceStatus
argument_list|)
expr_stmt|;
block|}
block|}
name|traverseDirectory
argument_list|(
name|fileListWriter
argument_list|,
name|sourceFS
argument_list|,
name|sourceDirs
argument_list|,
name|sourcePathRoot
argument_list|,
name|options
argument_list|,
literal|null
argument_list|,
name|statusList
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|randomizeFileListing
condition|)
block|{
name|writeToFileListing
argument_list|(
name|statusList
argument_list|,
name|fileListWriter
argument_list|)
expr_stmt|;
block|}
name|fileListWriter
operator|.
name|close
argument_list|()
expr_stmt|;
name|printStats
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Build file listing completed."
argument_list|)
expr_stmt|;
name|fileListWriter
operator|=
literal|null
expr_stmt|;
block|}
finally|finally
block|{
name|IOUtils
operator|.
name|cleanup
argument_list|(
name|LOG
argument_list|,
name|fileListWriter
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|addToFileListing (List<FileStatusInfo> fileStatusInfoList, FileStatusInfo statusInfo, SequenceFile.Writer fileListWriter)
specifier|private
name|void
name|addToFileListing
parameter_list|(
name|List
argument_list|<
name|FileStatusInfo
argument_list|>
name|fileStatusInfoList
parameter_list|,
name|FileStatusInfo
name|statusInfo
parameter_list|,
name|SequenceFile
operator|.
name|Writer
name|fileListWriter
parameter_list|)
throws|throws
name|IOException
block|{
name|fileStatusInfoList
operator|.
name|add
argument_list|(
name|statusInfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|fileStatusInfoList
operator|.
name|size
argument_list|()
operator|>
name|fileStatusLimit
condition|)
block|{
name|writeToFileListing
argument_list|(
name|fileStatusInfoList
argument_list|,
name|fileListWriter
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|VisibleForTesting
DECL|method|setSeedForRandomListing (long seed)
name|void
name|setSeedForRandomListing
parameter_list|(
name|long
name|seed
parameter_list|)
block|{
name|this
operator|.
name|rnd
operator|.
name|setSeed
argument_list|(
name|seed
argument_list|)
expr_stmt|;
block|}
DECL|method|writeToFileListing (List<FileStatusInfo> fileStatusInfoList, SequenceFile.Writer fileListWriter)
specifier|private
name|void
name|writeToFileListing
parameter_list|(
name|List
argument_list|<
name|FileStatusInfo
argument_list|>
name|fileStatusInfoList
parameter_list|,
name|SequenceFile
operator|.
name|Writer
name|fileListWriter
parameter_list|)
throws|throws
name|IOException
block|{
comment|/**      * In cloud storage systems, it is possible to get region hotspot.      * Shuffling paths can avoid such cases and also ensure that      * some mappers do not get lots of similar paths.      */
name|Collections
operator|.
name|shuffle
argument_list|(
name|fileStatusInfoList
argument_list|,
name|rnd
argument_list|)
expr_stmt|;
for|for
control|(
name|FileStatusInfo
name|fileStatusInfo
range|:
name|fileStatusInfoList
control|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Adding "
operator|+
name|fileStatusInfo
operator|.
name|fileStatus
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|writeToFileListing
argument_list|(
name|fileListWriter
argument_list|,
name|fileStatusInfo
operator|.
name|fileStatus
argument_list|,
name|fileStatusInfo
operator|.
name|sourceRootPath
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Number of paths written to fileListing="
operator|+
name|fileStatusInfoList
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|fileStatusInfoList
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
DECL|class|FileStatusInfo
specifier|private
specifier|static
class|class
name|FileStatusInfo
block|{
DECL|field|fileStatus
specifier|private
name|CopyListingFileStatus
name|fileStatus
decl_stmt|;
DECL|field|sourceRootPath
specifier|private
name|Path
name|sourceRootPath
decl_stmt|;
DECL|method|FileStatusInfo (CopyListingFileStatus fileStatus, Path sourceRootPath)
name|FileStatusInfo
parameter_list|(
name|CopyListingFileStatus
name|fileStatus
parameter_list|,
name|Path
name|sourceRootPath
parameter_list|)
block|{
name|this
operator|.
name|fileStatus
operator|=
name|fileStatus
expr_stmt|;
name|this
operator|.
name|sourceRootPath
operator|=
name|sourceRootPath
expr_stmt|;
block|}
block|}
DECL|method|computeSourceRootPath (FileStatus sourceStatus, DistCpOptions options)
specifier|private
name|Path
name|computeSourceRootPath
parameter_list|(
name|FileStatus
name|sourceStatus
parameter_list|,
name|DistCpOptions
name|options
parameter_list|)
throws|throws
name|IOException
block|{
name|Path
name|target
init|=
name|options
operator|.
name|getTargetPath
argument_list|()
decl_stmt|;
name|FileSystem
name|targetFS
init|=
name|target
operator|.
name|getFileSystem
argument_list|(
name|getConf
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|boolean
name|targetPathExists
init|=
name|options
operator|.
name|getTargetPathExists
argument_list|()
decl_stmt|;
name|boolean
name|solitaryFile
init|=
name|options
operator|.
name|getSourcePaths
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|1
operator|&&
operator|!
name|sourceStatus
operator|.
name|isDirectory
argument_list|()
decl_stmt|;
if|if
condition|(
name|solitaryFile
condition|)
block|{
if|if
condition|(
operator|!
name|targetPathExists
operator|||
name|targetFS
operator|.
name|isFile
argument_list|(
name|target
argument_list|)
condition|)
block|{
return|return
name|sourceStatus
operator|.
name|getPath
argument_list|()
return|;
block|}
else|else
block|{
return|return
name|sourceStatus
operator|.
name|getPath
argument_list|()
operator|.
name|getParent
argument_list|()
return|;
block|}
block|}
else|else
block|{
name|boolean
name|specialHandling
init|=
operator|(
name|options
operator|.
name|getSourcePaths
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|1
operator|&&
operator|!
name|targetPathExists
operator|)
operator|||
name|options
operator|.
name|shouldSyncFolder
argument_list|()
operator|||
name|options
operator|.
name|shouldOverwrite
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|specialHandling
operator|&&
name|sourceStatus
operator|.
name|isDirectory
argument_list|()
operator|)
operator|||
name|sourceStatus
operator|.
name|getPath
argument_list|()
operator|.
name|isRoot
argument_list|()
condition|)
block|{
return|return
name|sourceStatus
operator|.
name|getPath
argument_list|()
return|;
block|}
else|else
block|{
return|return
name|sourceStatus
operator|.
name|getPath
argument_list|()
operator|.
name|getParent
argument_list|()
return|;
block|}
block|}
block|}
comment|/**    * Provide an option to skip copy of a path, Allows for exclusion    * of files such as {@link org.apache.hadoop.mapreduce.lib.output.FileOutputCommitter#SUCCEEDED_FILE_NAME}    * @param path - Path being considered for copy while building the file listing    * @return - True if the path should be considered for copy, false otherwise    */
DECL|method|shouldCopy (Path path)
specifier|protected
name|boolean
name|shouldCopy
parameter_list|(
name|Path
name|path
parameter_list|)
block|{
return|return
name|copyFilter
operator|.
name|shouldCopy
argument_list|(
name|path
argument_list|)
return|;
block|}
comment|/** {@inheritDoc} */
annotation|@
name|Override
DECL|method|getBytesToCopy ()
specifier|protected
name|long
name|getBytesToCopy
parameter_list|()
block|{
return|return
name|totalBytesToCopy
return|;
block|}
comment|/** {@inheritDoc} */
annotation|@
name|Override
DECL|method|getNumberOfPaths ()
specifier|protected
name|long
name|getNumberOfPaths
parameter_list|()
block|{
return|return
name|totalPaths
return|;
block|}
DECL|method|makeQualified (Path path)
specifier|private
name|Path
name|makeQualified
parameter_list|(
name|Path
name|path
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|FileSystem
name|fs
init|=
name|path
operator|.
name|getFileSystem
argument_list|(
name|getConf
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|path
operator|.
name|makeQualified
argument_list|(
name|fs
operator|.
name|getUri
argument_list|()
argument_list|,
name|fs
operator|.
name|getWorkingDirectory
argument_list|()
argument_list|)
return|;
block|}
DECL|method|getWriter (Path pathToListFile)
specifier|private
name|SequenceFile
operator|.
name|Writer
name|getWriter
parameter_list|(
name|Path
name|pathToListFile
parameter_list|)
throws|throws
name|IOException
block|{
name|FileSystem
name|fs
init|=
name|pathToListFile
operator|.
name|getFileSystem
argument_list|(
name|getConf
argument_list|()
argument_list|)
decl_stmt|;
name|fs
operator|.
name|delete
argument_list|(
name|pathToListFile
argument_list|,
literal|false
argument_list|)
expr_stmt|;
return|return
name|SequenceFile
operator|.
name|createWriter
argument_list|(
name|getConf
argument_list|()
argument_list|,
name|SequenceFile
operator|.
name|Writer
operator|.
name|file
argument_list|(
name|pathToListFile
argument_list|)
argument_list|,
name|SequenceFile
operator|.
name|Writer
operator|.
name|keyClass
argument_list|(
name|Text
operator|.
name|class
argument_list|)
argument_list|,
name|SequenceFile
operator|.
name|Writer
operator|.
name|valueClass
argument_list|(
name|CopyListingFileStatus
operator|.
name|class
argument_list|)
argument_list|,
name|SequenceFile
operator|.
name|Writer
operator|.
name|compression
argument_list|(
name|SequenceFile
operator|.
name|CompressionType
operator|.
name|NONE
argument_list|)
argument_list|)
return|;
block|}
comment|/*    *  Private class to implement WorkRequestProcessor interface. It processes    *  each directory (represented by FileStatus item) and returns a list of all    *  file-system objects in that directory (files and directories). In case of    *  retriable exceptions it increments retry counter and returns the same    *  directory for later retry.    */
DECL|class|FileStatusProcessor
specifier|private
specifier|static
class|class
name|FileStatusProcessor
implements|implements
name|WorkRequestProcessor
argument_list|<
name|FileStatus
argument_list|,
name|FileStatus
index|[]
argument_list|>
block|{
DECL|field|fileSystem
specifier|private
name|FileSystem
name|fileSystem
decl_stmt|;
DECL|field|excludeList
specifier|private
name|HashSet
argument_list|<
name|String
argument_list|>
name|excludeList
decl_stmt|;
DECL|method|FileStatusProcessor (FileSystem fileSystem, HashSet<String> excludeList)
specifier|public
name|FileStatusProcessor
parameter_list|(
name|FileSystem
name|fileSystem
parameter_list|,
name|HashSet
argument_list|<
name|String
argument_list|>
name|excludeList
parameter_list|)
block|{
name|this
operator|.
name|fileSystem
operator|=
name|fileSystem
expr_stmt|;
name|this
operator|.
name|excludeList
operator|=
name|excludeList
expr_stmt|;
block|}
comment|/**      * Get FileStatuses for a given path.      * Exclude the some renamed FileStatuses since they are already handled by      * {@link org.apache.hadoop.tools.DistCpSync#sync}.      * @return an array of file status      */
DECL|method|getFileStatus (Path path)
specifier|private
name|FileStatus
index|[]
name|getFileStatus
parameter_list|(
name|Path
name|path
parameter_list|)
throws|throws
name|IOException
block|{
name|FileStatus
index|[]
name|fileStatuses
init|=
name|fileSystem
operator|.
name|listStatus
argument_list|(
name|path
argument_list|)
decl_stmt|;
if|if
condition|(
name|excludeList
operator|!=
literal|null
operator|&&
name|excludeList
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|ArrayList
argument_list|<
name|FileStatus
argument_list|>
name|fileStatusList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|FileStatus
name|status
range|:
name|fileStatuses
control|)
block|{
if|if
condition|(
operator|!
name|excludeList
operator|.
name|contains
argument_list|(
name|status
operator|.
name|getPath
argument_list|()
operator|.
name|toUri
argument_list|()
operator|.
name|getPath
argument_list|()
argument_list|)
condition|)
block|{
name|fileStatusList
operator|.
name|add
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
block|}
name|fileStatuses
operator|=
name|fileStatusList
operator|.
name|toArray
argument_list|(
operator|new
name|FileStatus
index|[
name|fileStatusList
operator|.
name|size
argument_list|()
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|fileStatuses
return|;
block|}
comment|/*      *  Processor for FileSystem.listStatus().      *      *  @param workRequest  Input work item that contains FileStatus item which      *                      is a parent directory we want to list.      *  @return Outputs WorkReport<FileStatus[]> with a list of objects in the      *          directory (array of objects, empty if parent directory is      *          empty). In case of intermittent exception we increment retry      *          counter and return the list containing the parent directory).      */
DECL|method|processItem ( WorkRequest<FileStatus> workRequest)
specifier|public
name|WorkReport
argument_list|<
name|FileStatus
index|[]
argument_list|>
name|processItem
parameter_list|(
name|WorkRequest
argument_list|<
name|FileStatus
argument_list|>
name|workRequest
parameter_list|)
block|{
name|FileStatus
name|parent
init|=
name|workRequest
operator|.
name|getItem
argument_list|()
decl_stmt|;
name|int
name|retry
init|=
name|workRequest
operator|.
name|getRetry
argument_list|()
decl_stmt|;
name|WorkReport
argument_list|<
name|FileStatus
index|[]
argument_list|>
name|result
init|=
literal|null
decl_stmt|;
try|try
block|{
if|if
condition|(
name|retry
operator|>
literal|0
condition|)
block|{
name|int
name|sleepSeconds
init|=
literal|2
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|retry
condition|;
name|i
operator|++
control|)
block|{
name|sleepSeconds
operator|*=
literal|2
expr_stmt|;
block|}
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
literal|1000
operator|*
name|sleepSeconds
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Interrupted while sleeping in exponential backoff."
argument_list|)
expr_stmt|;
block|}
block|}
name|result
operator|=
operator|new
name|WorkReport
argument_list|<
name|FileStatus
index|[]
argument_list|>
argument_list|(
name|getFileStatus
argument_list|(
name|parent
operator|.
name|getPath
argument_list|()
argument_list|)
argument_list|,
name|retry
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|fnf
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"FileNotFoundException exception in listStatus: "
operator|+
name|fnf
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
name|result
operator|=
operator|new
name|WorkReport
argument_list|<
name|FileStatus
index|[]
argument_list|>
argument_list|(
operator|new
name|FileStatus
index|[
literal|0
index|]
argument_list|,
name|retry
argument_list|,
literal|true
argument_list|,
name|fnf
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Exception in listStatus. Will send for retry."
argument_list|)
expr_stmt|;
name|FileStatus
index|[]
name|parentList
init|=
operator|new
name|FileStatus
index|[
literal|1
index|]
decl_stmt|;
name|parentList
index|[
literal|0
index|]
operator|=
name|parent
expr_stmt|;
name|result
operator|=
operator|new
name|WorkReport
argument_list|<
name|FileStatus
index|[]
argument_list|>
argument_list|(
name|parentList
argument_list|,
name|retry
operator|+
literal|1
argument_list|,
literal|false
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
block|}
DECL|method|printStats ()
specifier|private
name|void
name|printStats
parameter_list|()
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Paths (files+dirs) cnt = "
operator|+
name|totalPaths
operator|+
literal|"; dirCnt = "
operator|+
name|totalDirs
argument_list|)
expr_stmt|;
block|}
DECL|method|maybePrintStats ()
specifier|private
name|void
name|maybePrintStats
parameter_list|()
block|{
if|if
condition|(
name|totalPaths
operator|%
literal|100000
operator|==
literal|0
condition|)
block|{
name|printStats
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|traverseDirectory (SequenceFile.Writer fileListWriter, FileSystem sourceFS, ArrayList<FileStatus> sourceDirs, Path sourcePathRoot, DistCpOptions options, HashSet<String> excludeList, List<FileStatusInfo> fileStatuses)
specifier|private
name|void
name|traverseDirectory
parameter_list|(
name|SequenceFile
operator|.
name|Writer
name|fileListWriter
parameter_list|,
name|FileSystem
name|sourceFS
parameter_list|,
name|ArrayList
argument_list|<
name|FileStatus
argument_list|>
name|sourceDirs
parameter_list|,
name|Path
name|sourcePathRoot
parameter_list|,
name|DistCpOptions
name|options
parameter_list|,
name|HashSet
argument_list|<
name|String
argument_list|>
name|excludeList
parameter_list|,
name|List
argument_list|<
name|FileStatusInfo
argument_list|>
name|fileStatuses
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|boolean
name|preserveAcls
init|=
name|options
operator|.
name|shouldPreserve
argument_list|(
name|FileAttribute
operator|.
name|ACL
argument_list|)
decl_stmt|;
specifier|final
name|boolean
name|preserveXAttrs
init|=
name|options
operator|.
name|shouldPreserve
argument_list|(
name|FileAttribute
operator|.
name|XATTR
argument_list|)
decl_stmt|;
specifier|final
name|boolean
name|preserveRawXattrs
init|=
name|options
operator|.
name|shouldPreserveRawXattrs
argument_list|()
decl_stmt|;
assert|assert
name|numListstatusThreads
operator|>
literal|0
assert|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Starting thread pool of "
operator|+
name|numListstatusThreads
operator|+
literal|" listStatus workers."
argument_list|)
expr_stmt|;
block|}
name|ProducerConsumer
argument_list|<
name|FileStatus
argument_list|,
name|FileStatus
index|[]
argument_list|>
name|workers
init|=
operator|new
name|ProducerConsumer
argument_list|<
name|FileStatus
argument_list|,
name|FileStatus
index|[]
argument_list|>
argument_list|(
name|numListstatusThreads
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numListstatusThreads
condition|;
name|i
operator|++
control|)
block|{
name|workers
operator|.
name|addWorker
argument_list|(
operator|new
name|FileStatusProcessor
argument_list|(
name|sourcePathRoot
operator|.
name|getFileSystem
argument_list|(
name|getConf
argument_list|()
argument_list|)
argument_list|,
name|excludeList
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|FileStatus
name|status
range|:
name|sourceDirs
control|)
block|{
name|workers
operator|.
name|put
argument_list|(
operator|new
name|WorkRequest
argument_list|<
name|FileStatus
argument_list|>
argument_list|(
name|status
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|workers
operator|.
name|hasWork
argument_list|()
condition|)
block|{
try|try
block|{
name|WorkReport
argument_list|<
name|FileStatus
index|[]
argument_list|>
name|workResult
init|=
name|workers
operator|.
name|take
argument_list|()
decl_stmt|;
name|int
name|retry
init|=
name|workResult
operator|.
name|getRetry
argument_list|()
decl_stmt|;
for|for
control|(
name|FileStatus
name|child
range|:
name|workResult
operator|.
name|getItem
argument_list|()
control|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Recording source-path: "
operator|+
name|child
operator|.
name|getPath
argument_list|()
operator|+
literal|" for copy."
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|workResult
operator|.
name|getSuccess
argument_list|()
condition|)
block|{
name|CopyListingFileStatus
name|childCopyListingStatus
init|=
name|DistCpUtils
operator|.
name|toCopyListingFileStatus
argument_list|(
name|sourceFS
argument_list|,
name|child
argument_list|,
name|preserveAcls
operator|&&
name|child
operator|.
name|isDirectory
argument_list|()
argument_list|,
name|preserveXAttrs
operator|&&
name|child
operator|.
name|isDirectory
argument_list|()
argument_list|,
name|preserveRawXattrs
operator|&&
name|child
operator|.
name|isDirectory
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|randomizeFileListing
condition|)
block|{
name|addToFileListing
argument_list|(
name|fileStatuses
argument_list|,
operator|new
name|FileStatusInfo
argument_list|(
name|childCopyListingStatus
argument_list|,
name|sourcePathRoot
argument_list|)
argument_list|,
name|fileListWriter
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|writeToFileListing
argument_list|(
name|fileListWriter
argument_list|,
name|childCopyListingStatus
argument_list|,
name|sourcePathRoot
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|retry
operator|<
name|maxRetries
condition|)
block|{
if|if
condition|(
name|child
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Traversing into source dir: "
operator|+
name|child
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|workers
operator|.
name|put
argument_list|(
operator|new
name|WorkRequest
argument_list|<
name|FileStatus
argument_list|>
argument_list|(
name|child
argument_list|,
name|retry
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Giving up on "
operator|+
name|child
operator|.
name|getPath
argument_list|()
operator|+
literal|" after "
operator|+
name|retry
operator|+
literal|" retries."
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Could not get item from childQueue. Retrying..."
argument_list|)
expr_stmt|;
block|}
block|}
name|workers
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
DECL|method|writeToFileListingRoot (SequenceFile.Writer fileListWriter, CopyListingFileStatus fileStatus, Path sourcePathRoot, DistCpOptions options)
specifier|private
name|void
name|writeToFileListingRoot
parameter_list|(
name|SequenceFile
operator|.
name|Writer
name|fileListWriter
parameter_list|,
name|CopyListingFileStatus
name|fileStatus
parameter_list|,
name|Path
name|sourcePathRoot
parameter_list|,
name|DistCpOptions
name|options
parameter_list|)
throws|throws
name|IOException
block|{
name|boolean
name|syncOrOverwrite
init|=
name|options
operator|.
name|shouldSyncFolder
argument_list|()
operator|||
name|options
operator|.
name|shouldOverwrite
argument_list|()
decl_stmt|;
if|if
condition|(
name|fileStatus
operator|.
name|getPath
argument_list|()
operator|.
name|equals
argument_list|(
name|sourcePathRoot
argument_list|)
operator|&&
name|fileStatus
operator|.
name|isDirectory
argument_list|()
operator|&&
name|syncOrOverwrite
condition|)
block|{
comment|// Skip the root-paths when syncOrOverwrite
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Skip "
operator|+
name|fileStatus
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
name|writeToFileListing
argument_list|(
name|fileListWriter
argument_list|,
name|fileStatus
argument_list|,
name|sourcePathRoot
argument_list|)
expr_stmt|;
block|}
DECL|method|writeToFileListing (SequenceFile.Writer fileListWriter, CopyListingFileStatus fileStatus, Path sourcePathRoot)
specifier|private
name|void
name|writeToFileListing
parameter_list|(
name|SequenceFile
operator|.
name|Writer
name|fileListWriter
parameter_list|,
name|CopyListingFileStatus
name|fileStatus
parameter_list|,
name|Path
name|sourcePathRoot
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"REL PATH: "
operator|+
name|DistCpUtils
operator|.
name|getRelativePath
argument_list|(
name|sourcePathRoot
argument_list|,
name|fileStatus
operator|.
name|getPath
argument_list|()
argument_list|)
operator|+
literal|", FULL PATH: "
operator|+
name|fileStatus
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|shouldCopy
argument_list|(
name|fileStatus
operator|.
name|getPath
argument_list|()
argument_list|)
condition|)
block|{
return|return;
block|}
name|fileListWriter
operator|.
name|append
argument_list|(
operator|new
name|Text
argument_list|(
name|DistCpUtils
operator|.
name|getRelativePath
argument_list|(
name|sourcePathRoot
argument_list|,
name|fileStatus
operator|.
name|getPath
argument_list|()
argument_list|)
argument_list|)
argument_list|,
name|fileStatus
argument_list|)
expr_stmt|;
name|fileListWriter
operator|.
name|sync
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|fileStatus
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
name|totalBytesToCopy
operator|+=
name|fileStatus
operator|.
name|getLen
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|totalDirs
operator|++
expr_stmt|;
block|}
name|totalPaths
operator|++
expr_stmt|;
name|maybePrintStats
argument_list|()
expr_stmt|;
block|}
block|}
end_class

end_unit

