begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.tools.mapred
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|tools
operator|.
name|mapred
package|;
end_package

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|SequenceFile
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|Text
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|RemoteException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|JobContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|JobStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|TaskAttemptContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|lib
operator|.
name|output
operator|.
name|FileOutputCommitter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|tools
operator|.
name|CopyListing
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|tools
operator|.
name|CopyListingFileStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|tools
operator|.
name|DistCpConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|tools
operator|.
name|DistCpOptionSwitch
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|tools
operator|.
name|DistCpContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|tools
operator|.
name|DistCpOptions
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|tools
operator|.
name|DistCpOptions
operator|.
name|FileAttribute
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|tools
operator|.
name|GlobbedCopyListing
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|tools
operator|.
name|util
operator|.
name|DistCpUtils
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileNotFoundException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|EnumSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|tools
operator|.
name|DistCpConstants
operator|.
name|*
import|;
end_import

begin_comment
comment|/**  * The CopyCommitter class is DistCp's OutputCommitter implementation. It is  * responsible for handling the completion/cleanup of the DistCp run.  * Specifically, it does the following:  *  1. Cleanup of the meta-folder (where DistCp maintains its file-list, etc.)  *  2. Preservation of user/group/replication-factor on any directories that  *     have been copied. (Files are taken care of in their map-tasks.)  *  3. Atomic-move of data from the temporary work-folder to the final path  *     (if atomic-commit was opted for).  *  4. Deletion of files from the target that are missing at source (if opted for).  *  5. Cleanup of any partially copied files, from previous, failed attempts.  */
end_comment

begin_class
DECL|class|CopyCommitter
specifier|public
class|class
name|CopyCommitter
extends|extends
name|FileOutputCommitter
block|{
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|CopyCommitter
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|taskAttemptContext
specifier|private
specifier|final
name|TaskAttemptContext
name|taskAttemptContext
decl_stmt|;
DECL|field|syncFolder
specifier|private
name|boolean
name|syncFolder
init|=
literal|false
decl_stmt|;
DECL|field|overwrite
specifier|private
name|boolean
name|overwrite
init|=
literal|false
decl_stmt|;
DECL|field|targetPathExists
specifier|private
name|boolean
name|targetPathExists
init|=
literal|true
decl_stmt|;
DECL|field|ignoreFailures
specifier|private
name|boolean
name|ignoreFailures
init|=
literal|false
decl_stmt|;
DECL|field|skipCrc
specifier|private
name|boolean
name|skipCrc
init|=
literal|false
decl_stmt|;
DECL|field|blocksPerChunk
specifier|private
name|int
name|blocksPerChunk
init|=
literal|0
decl_stmt|;
comment|/**    * Create a output committer    *    * @param outputPath the job's output path    * @param context    the task's context    * @throws IOException - Exception if any    */
DECL|method|CopyCommitter (Path outputPath, TaskAttemptContext context)
specifier|public
name|CopyCommitter
parameter_list|(
name|Path
name|outputPath
parameter_list|,
name|TaskAttemptContext
name|context
parameter_list|)
throws|throws
name|IOException
block|{
name|super
argument_list|(
name|outputPath
argument_list|,
name|context
argument_list|)
expr_stmt|;
name|blocksPerChunk
operator|=
name|context
operator|.
name|getConfiguration
argument_list|()
operator|.
name|getInt
argument_list|(
name|DistCpOptionSwitch
operator|.
name|BLOCKS_PER_CHUNK
operator|.
name|getConfigLabel
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"blocks per chunk {}"
argument_list|,
name|blocksPerChunk
argument_list|)
expr_stmt|;
name|skipCrc
operator|=
name|context
operator|.
name|getConfiguration
argument_list|()
operator|.
name|getBoolean
argument_list|(
name|DistCpOptionSwitch
operator|.
name|SKIP_CRC
operator|.
name|getConfigLabel
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"skip CRC is {}"
argument_list|,
name|skipCrc
argument_list|)
expr_stmt|;
name|this
operator|.
name|taskAttemptContext
operator|=
name|context
expr_stmt|;
block|}
comment|/** {@inheritDoc} */
annotation|@
name|Override
DECL|method|commitJob (JobContext jobContext)
specifier|public
name|void
name|commitJob
parameter_list|(
name|JobContext
name|jobContext
parameter_list|)
throws|throws
name|IOException
block|{
name|Configuration
name|conf
init|=
name|jobContext
operator|.
name|getConfiguration
argument_list|()
decl_stmt|;
name|syncFolder
operator|=
name|conf
operator|.
name|getBoolean
argument_list|(
name|DistCpConstants
operator|.
name|CONF_LABEL_SYNC_FOLDERS
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|overwrite
operator|=
name|conf
operator|.
name|getBoolean
argument_list|(
name|DistCpConstants
operator|.
name|CONF_LABEL_OVERWRITE
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|targetPathExists
operator|=
name|conf
operator|.
name|getBoolean
argument_list|(
name|DistCpConstants
operator|.
name|CONF_LABEL_TARGET_PATH_EXISTS
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|ignoreFailures
operator|=
name|conf
operator|.
name|getBoolean
argument_list|(
name|DistCpOptionSwitch
operator|.
name|IGNORE_FAILURES
operator|.
name|getConfigLabel
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|blocksPerChunk
operator|>
literal|0
condition|)
block|{
name|concatFileChunks
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
name|super
operator|.
name|commitJob
argument_list|(
name|jobContext
argument_list|)
expr_stmt|;
name|cleanupTempFiles
argument_list|(
name|jobContext
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
name|conf
operator|.
name|getBoolean
argument_list|(
name|DistCpConstants
operator|.
name|CONF_LABEL_DELETE_MISSING
argument_list|,
literal|false
argument_list|)
condition|)
block|{
name|deleteMissing
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|conf
operator|.
name|getBoolean
argument_list|(
name|DistCpConstants
operator|.
name|CONF_LABEL_ATOMIC_COPY
argument_list|,
literal|false
argument_list|)
condition|)
block|{
name|commitData
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|conf
operator|.
name|get
argument_list|(
name|CONF_LABEL_TRACK_MISSING
argument_list|)
operator|!=
literal|null
condition|)
block|{
comment|// save missing information to a directory
name|trackMissing
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
comment|// for HDFS-14621, should preserve status after -delete
name|String
name|attributes
init|=
name|conf
operator|.
name|get
argument_list|(
name|DistCpConstants
operator|.
name|CONF_LABEL_PRESERVE_STATUS
argument_list|)
decl_stmt|;
specifier|final
name|boolean
name|preserveRawXattrs
init|=
name|conf
operator|.
name|getBoolean
argument_list|(
name|DistCpConstants
operator|.
name|CONF_LABEL_PRESERVE_RAWXATTRS
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|attributes
operator|!=
literal|null
operator|&&
operator|!
name|attributes
operator|.
name|isEmpty
argument_list|()
operator|)
operator|||
name|preserveRawXattrs
condition|)
block|{
name|preserveFileAttributesForDirectories
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
name|taskAttemptContext
operator|.
name|setStatus
argument_list|(
literal|"Commit Successful"
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|cleanup
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** {@inheritDoc} */
annotation|@
name|Override
DECL|method|abortJob (JobContext jobContext, JobStatus.State state)
specifier|public
name|void
name|abortJob
parameter_list|(
name|JobContext
name|jobContext
parameter_list|,
name|JobStatus
operator|.
name|State
name|state
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
name|super
operator|.
name|abortJob
argument_list|(
name|jobContext
argument_list|,
name|state
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|cleanupTempFiles
argument_list|(
name|jobContext
argument_list|)
expr_stmt|;
name|cleanup
argument_list|(
name|jobContext
operator|.
name|getConfiguration
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|cleanupTempFiles (JobContext context)
specifier|private
name|void
name|cleanupTempFiles
parameter_list|(
name|JobContext
name|context
parameter_list|)
block|{
try|try
block|{
name|Configuration
name|conf
init|=
name|context
operator|.
name|getConfiguration
argument_list|()
decl_stmt|;
name|Path
name|targetWorkPath
init|=
operator|new
name|Path
argument_list|(
name|conf
operator|.
name|get
argument_list|(
name|DistCpConstants
operator|.
name|CONF_LABEL_TARGET_WORK_PATH
argument_list|)
argument_list|)
decl_stmt|;
name|FileSystem
name|targetFS
init|=
name|targetWorkPath
operator|.
name|getFileSystem
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|String
name|jobId
init|=
name|context
operator|.
name|getJobID
argument_list|()
operator|.
name|toString
argument_list|()
decl_stmt|;
name|deleteAttemptTempFiles
argument_list|(
name|targetWorkPath
argument_list|,
name|targetFS
argument_list|,
name|jobId
argument_list|)
expr_stmt|;
name|deleteAttemptTempFiles
argument_list|(
name|targetWorkPath
operator|.
name|getParent
argument_list|()
argument_list|,
name|targetFS
argument_list|,
name|jobId
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Unable to cleanup temp files"
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|deleteAttemptTempFiles (Path targetWorkPath, FileSystem targetFS, String jobId)
specifier|private
name|void
name|deleteAttemptTempFiles
parameter_list|(
name|Path
name|targetWorkPath
parameter_list|,
name|FileSystem
name|targetFS
parameter_list|,
name|String
name|jobId
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|targetWorkPath
operator|==
literal|null
condition|)
block|{
return|return;
block|}
name|FileStatus
index|[]
name|tempFiles
init|=
name|targetFS
operator|.
name|globStatus
argument_list|(
operator|new
name|Path
argument_list|(
name|targetWorkPath
argument_list|,
literal|".distcp.tmp."
operator|+
name|jobId
operator|.
name|replaceAll
argument_list|(
literal|"job"
argument_list|,
literal|"attempt"
argument_list|)
operator|+
literal|"*"
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|tempFiles
operator|!=
literal|null
operator|&&
name|tempFiles
operator|.
name|length
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|FileStatus
name|file
range|:
name|tempFiles
control|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Cleaning up "
operator|+
name|file
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
name|targetFS
operator|.
name|delete
argument_list|(
name|file
operator|.
name|getPath
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Cleanup meta folder and other temporary files    *    * @param conf - Job Configuration    */
DECL|method|cleanup (Configuration conf)
specifier|private
name|void
name|cleanup
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
name|Path
name|metaFolder
init|=
operator|new
name|Path
argument_list|(
name|conf
operator|.
name|get
argument_list|(
name|DistCpConstants
operator|.
name|CONF_LABEL_META_FOLDER
argument_list|)
argument_list|)
decl_stmt|;
try|try
block|{
name|FileSystem
name|fs
init|=
name|metaFolder
operator|.
name|getFileSystem
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Cleaning up temporary work folder: "
operator|+
name|metaFolder
argument_list|)
expr_stmt|;
name|fs
operator|.
name|delete
argument_list|(
name|metaFolder
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ignore
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Exception encountered "
argument_list|,
name|ignore
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|isFileNotFoundException (IOException e)
specifier|private
name|boolean
name|isFileNotFoundException
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
if|if
condition|(
name|e
operator|instanceof
name|FileNotFoundException
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
name|e
operator|instanceof
name|RemoteException
condition|)
block|{
return|return
operator|(
operator|(
name|RemoteException
operator|)
name|e
operator|)
operator|.
name|unwrapRemoteException
argument_list|()
operator|instanceof
name|FileNotFoundException
return|;
block|}
return|return
literal|false
return|;
block|}
comment|/**    * Concat chunk files for the same file into one.    * Iterate through copy listing, identify chunk files for the same file,    * concat them into one.    */
DECL|method|concatFileChunks (Configuration conf)
specifier|private
name|void
name|concatFileChunks
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"concat file chunks ..."
argument_list|)
expr_stmt|;
name|String
name|spath
init|=
name|conf
operator|.
name|get
argument_list|(
name|DistCpConstants
operator|.
name|CONF_LABEL_LISTING_FILE_PATH
argument_list|)
decl_stmt|;
if|if
condition|(
name|spath
operator|==
literal|null
operator|||
name|spath
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return;
block|}
name|Path
name|sourceListing
init|=
operator|new
name|Path
argument_list|(
name|spath
argument_list|)
decl_stmt|;
name|SequenceFile
operator|.
name|Reader
name|sourceReader
init|=
operator|new
name|SequenceFile
operator|.
name|Reader
argument_list|(
name|conf
argument_list|,
name|SequenceFile
operator|.
name|Reader
operator|.
name|file
argument_list|(
name|sourceListing
argument_list|)
argument_list|)
decl_stmt|;
name|Path
name|targetRoot
init|=
operator|new
name|Path
argument_list|(
name|conf
operator|.
name|get
argument_list|(
name|DistCpConstants
operator|.
name|CONF_LABEL_TARGET_WORK_PATH
argument_list|)
argument_list|)
decl_stmt|;
try|try
block|{
name|CopyListingFileStatus
name|srcFileStatus
init|=
operator|new
name|CopyListingFileStatus
argument_list|()
decl_stmt|;
name|Text
name|srcRelPath
init|=
operator|new
name|Text
argument_list|()
decl_stmt|;
name|CopyListingFileStatus
name|lastFileStatus
init|=
literal|null
decl_stmt|;
name|LinkedList
argument_list|<
name|Path
argument_list|>
name|allChunkPaths
init|=
operator|new
name|LinkedList
argument_list|<
name|Path
argument_list|>
argument_list|()
decl_stmt|;
comment|// Iterate over every source path that was copied.
while|while
condition|(
name|sourceReader
operator|.
name|next
argument_list|(
name|srcRelPath
argument_list|,
name|srcFileStatus
argument_list|)
condition|)
block|{
if|if
condition|(
name|srcFileStatus
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
continue|continue;
block|}
name|Path
name|targetFile
init|=
operator|new
name|Path
argument_list|(
name|targetRoot
operator|.
name|toString
argument_list|()
operator|+
literal|"/"
operator|+
name|srcRelPath
argument_list|)
decl_stmt|;
name|Path
name|targetFileChunkPath
init|=
name|DistCpUtils
operator|.
name|getSplitChunkPath
argument_list|(
name|targetFile
argument_list|,
name|srcFileStatus
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"  add "
operator|+
name|targetFileChunkPath
operator|+
literal|" to concat."
argument_list|)
expr_stmt|;
block|}
name|allChunkPaths
operator|.
name|add
argument_list|(
name|targetFileChunkPath
argument_list|)
expr_stmt|;
if|if
condition|(
name|srcFileStatus
operator|.
name|getChunkOffset
argument_list|()
operator|+
name|srcFileStatus
operator|.
name|getChunkLength
argument_list|()
operator|==
name|srcFileStatus
operator|.
name|getLen
argument_list|()
condition|)
block|{
comment|// This is the last chunk of the splits, consolidate allChunkPaths
try|try
block|{
name|concatFileChunks
argument_list|(
name|conf
argument_list|,
name|srcFileStatus
operator|.
name|getPath
argument_list|()
argument_list|,
name|targetFile
argument_list|,
name|allChunkPaths
argument_list|,
name|srcFileStatus
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// If the concat failed because a chunk file doesn't exist,
comment|// then we assume that the CopyMapper has skipped copying this
comment|// file, and we ignore the exception here.
comment|// If a chunk file should have been created but it was not, then
comment|// the CopyMapper would have failed.
if|if
condition|(
operator|!
name|isFileNotFoundException
argument_list|(
name|e
argument_list|)
condition|)
block|{
name|String
name|emsg
init|=
literal|"Failed to concat chunk files for "
operator|+
name|targetFile
decl_stmt|;
if|if
condition|(
operator|!
name|ignoreFailures
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|emsg
argument_list|,
name|e
argument_list|)
throw|;
block|}
else|else
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|emsg
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|allChunkPaths
operator|.
name|clear
argument_list|()
expr_stmt|;
name|lastFileStatus
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|lastFileStatus
operator|==
literal|null
condition|)
block|{
name|lastFileStatus
operator|=
operator|new
name|CopyListingFileStatus
argument_list|(
name|srcFileStatus
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Two neighboring chunks have to be consecutive ones for the same
comment|// file, for them to be merged
if|if
condition|(
operator|!
name|srcFileStatus
operator|.
name|getPath
argument_list|()
operator|.
name|equals
argument_list|(
name|lastFileStatus
operator|.
name|getPath
argument_list|()
argument_list|)
operator|||
name|srcFileStatus
operator|.
name|getChunkOffset
argument_list|()
operator|!=
operator|(
name|lastFileStatus
operator|.
name|getChunkOffset
argument_list|()
operator|+
name|lastFileStatus
operator|.
name|getChunkLength
argument_list|()
operator|)
condition|)
block|{
name|String
name|emsg
init|=
literal|"Inconsistent sequence file: current "
operator|+
literal|"chunk file "
operator|+
name|srcFileStatus
operator|+
literal|" doesnt match prior "
operator|+
literal|"entry "
operator|+
name|lastFileStatus
decl_stmt|;
if|if
condition|(
operator|!
name|ignoreFailures
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|emsg
argument_list|)
throw|;
block|}
else|else
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|emsg
operator|+
literal|", skipping concat this set."
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|lastFileStatus
operator|.
name|setChunkOffset
argument_list|(
name|srcFileStatus
operator|.
name|getChunkOffset
argument_list|()
argument_list|)
expr_stmt|;
name|lastFileStatus
operator|.
name|setChunkLength
argument_list|(
name|srcFileStatus
operator|.
name|getChunkLength
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
finally|finally
block|{
name|IOUtils
operator|.
name|closeStream
argument_list|(
name|sourceReader
argument_list|)
expr_stmt|;
block|}
block|}
comment|// This method changes the target-directories' file-attributes (owner,
comment|// user/group permissions, etc.) based on the corresponding source directories.
DECL|method|preserveFileAttributesForDirectories (Configuration conf)
specifier|private
name|void
name|preserveFileAttributesForDirectories
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|attrSymbols
init|=
name|conf
operator|.
name|get
argument_list|(
name|DistCpConstants
operator|.
name|CONF_LABEL_PRESERVE_STATUS
argument_list|)
decl_stmt|;
specifier|final
name|boolean
name|syncOrOverwrite
init|=
name|syncFolder
operator|||
name|overwrite
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"About to preserve attributes: "
operator|+
name|attrSymbols
argument_list|)
expr_stmt|;
name|EnumSet
argument_list|<
name|FileAttribute
argument_list|>
name|attributes
init|=
name|DistCpUtils
operator|.
name|unpackAttributes
argument_list|(
name|attrSymbols
argument_list|)
decl_stmt|;
specifier|final
name|boolean
name|preserveRawXattrs
init|=
name|conf
operator|.
name|getBoolean
argument_list|(
name|DistCpConstants
operator|.
name|CONF_LABEL_PRESERVE_RAWXATTRS
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|Path
name|sourceListing
init|=
operator|new
name|Path
argument_list|(
name|conf
operator|.
name|get
argument_list|(
name|DistCpConstants
operator|.
name|CONF_LABEL_LISTING_FILE_PATH
argument_list|)
argument_list|)
decl_stmt|;
name|FileSystem
name|clusterFS
init|=
name|sourceListing
operator|.
name|getFileSystem
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|SequenceFile
operator|.
name|Reader
name|sourceReader
init|=
operator|new
name|SequenceFile
operator|.
name|Reader
argument_list|(
name|conf
argument_list|,
name|SequenceFile
operator|.
name|Reader
operator|.
name|file
argument_list|(
name|sourceListing
argument_list|)
argument_list|)
decl_stmt|;
name|long
name|totalLen
init|=
name|clusterFS
operator|.
name|getFileStatus
argument_list|(
name|sourceListing
argument_list|)
operator|.
name|getLen
argument_list|()
decl_stmt|;
name|Path
name|targetRoot
init|=
operator|new
name|Path
argument_list|(
name|conf
operator|.
name|get
argument_list|(
name|DistCpConstants
operator|.
name|CONF_LABEL_TARGET_WORK_PATH
argument_list|)
argument_list|)
decl_stmt|;
name|long
name|preservedEntries
init|=
literal|0
decl_stmt|;
try|try
block|{
name|CopyListingFileStatus
name|srcFileStatus
init|=
operator|new
name|CopyListingFileStatus
argument_list|()
decl_stmt|;
name|Text
name|srcRelPath
init|=
operator|new
name|Text
argument_list|()
decl_stmt|;
comment|// Iterate over every source path that was copied.
while|while
condition|(
name|sourceReader
operator|.
name|next
argument_list|(
name|srcRelPath
argument_list|,
name|srcFileStatus
argument_list|)
condition|)
block|{
comment|// File-attributes for files are set at the time of copy,
comment|// in the map-task.
if|if
condition|(
operator|!
name|srcFileStatus
operator|.
name|isDirectory
argument_list|()
condition|)
continue|continue;
name|Path
name|targetFile
init|=
operator|new
name|Path
argument_list|(
name|targetRoot
operator|.
name|toString
argument_list|()
operator|+
literal|"/"
operator|+
name|srcRelPath
argument_list|)
decl_stmt|;
comment|//
comment|// Skip the root folder when syncOrOverwrite is true.
comment|//
if|if
condition|(
name|targetRoot
operator|.
name|equals
argument_list|(
name|targetFile
argument_list|)
operator|&&
name|syncOrOverwrite
condition|)
continue|continue;
name|FileSystem
name|targetFS
init|=
name|targetFile
operator|.
name|getFileSystem
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|DistCpUtils
operator|.
name|preserve
argument_list|(
name|targetFS
argument_list|,
name|targetFile
argument_list|,
name|srcFileStatus
argument_list|,
name|attributes
argument_list|,
name|preserveRawXattrs
argument_list|)
expr_stmt|;
name|taskAttemptContext
operator|.
name|progress
argument_list|()
expr_stmt|;
name|taskAttemptContext
operator|.
name|setStatus
argument_list|(
literal|"Preserving status on directory entries. ["
operator|+
name|sourceReader
operator|.
name|getPosition
argument_list|()
operator|*
literal|100
operator|/
name|totalLen
operator|+
literal|"%]"
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|IOUtils
operator|.
name|closeStream
argument_list|(
name|sourceReader
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Preserved status on "
operator|+
name|preservedEntries
operator|+
literal|" dir entries on target"
argument_list|)
expr_stmt|;
block|}
comment|/**    * Track all the missing files by saving the listings to the tracking    * directory.    * This is the same as listing phase of the    * {@link #deleteMissing(Configuration)} operation.    * @param conf configuration to read options from, and for FS instantiation.    * @throws IOException IO failure    */
DECL|method|trackMissing (Configuration conf)
specifier|private
name|void
name|trackMissing
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
comment|// destination directory for all output files
name|Path
name|trackDir
init|=
operator|new
name|Path
argument_list|(
name|conf
operator|.
name|get
argument_list|(
name|DistCpConstants
operator|.
name|CONF_LABEL_TRACK_MISSING
argument_list|)
argument_list|)
decl_stmt|;
comment|// where is the existing source listing?
name|Path
name|sourceListing
init|=
operator|new
name|Path
argument_list|(
name|conf
operator|.
name|get
argument_list|(
name|DistCpConstants
operator|.
name|CONF_LABEL_LISTING_FILE_PATH
argument_list|)
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Tracking file changes to directory {}"
argument_list|,
name|trackDir
argument_list|)
expr_stmt|;
comment|// the destination path is under the track directory
name|Path
name|sourceSortedListing
init|=
operator|new
name|Path
argument_list|(
name|trackDir
argument_list|,
name|DistCpConstants
operator|.
name|SOURCE_SORTED_FILE
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Source listing {}"
argument_list|,
name|sourceSortedListing
argument_list|)
expr_stmt|;
name|DistCpUtils
operator|.
name|sortListing
argument_list|(
name|conf
argument_list|,
name|sourceListing
argument_list|,
name|sourceSortedListing
argument_list|)
expr_stmt|;
comment|// Similarly, create the listing of target-files. Sort alphabetically.
comment|// target listing will be deleted after the sort
name|Path
name|targetListing
init|=
operator|new
name|Path
argument_list|(
name|trackDir
argument_list|,
name|TARGET_LISTING_FILE
argument_list|)
decl_stmt|;
name|Path
name|sortedTargetListing
init|=
operator|new
name|Path
argument_list|(
name|trackDir
argument_list|,
name|TARGET_SORTED_FILE
argument_list|)
decl_stmt|;
comment|// list the target
name|listTargetFiles
argument_list|(
name|conf
argument_list|,
name|targetListing
argument_list|,
name|sortedTargetListing
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Target listing {}"
argument_list|,
name|sortedTargetListing
argument_list|)
expr_stmt|;
name|targetListing
operator|.
name|getFileSystem
argument_list|(
name|conf
argument_list|)
operator|.
name|delete
argument_list|(
name|targetListing
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/**    * Deletes "extra" files and directories from the target, if they're not    * available at the source.    * @param conf configuration to read options from, and for FS instantiation.    * @throws IOException IO failure    */
DECL|method|deleteMissing (Configuration conf)
specifier|private
name|void
name|deleteMissing
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"-delete option is enabled. About to remove entries from "
operator|+
literal|"target that are missing in source"
argument_list|)
expr_stmt|;
name|long
name|listingStart
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
comment|// Sort the source-file listing alphabetically.
name|Path
name|sourceListing
init|=
operator|new
name|Path
argument_list|(
name|conf
operator|.
name|get
argument_list|(
name|DistCpConstants
operator|.
name|CONF_LABEL_LISTING_FILE_PATH
argument_list|)
argument_list|)
decl_stmt|;
name|FileSystem
name|clusterFS
init|=
name|sourceListing
operator|.
name|getFileSystem
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|Path
name|sortedSourceListing
init|=
name|DistCpUtils
operator|.
name|sortListing
argument_list|(
name|conf
argument_list|,
name|sourceListing
argument_list|)
decl_stmt|;
name|long
name|sourceListingCompleted
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Source listing completed in {}"
argument_list|,
name|formatDuration
argument_list|(
name|sourceListingCompleted
operator|-
name|listingStart
argument_list|)
argument_list|)
expr_stmt|;
comment|// Similarly, create the listing of target-files. Sort alphabetically.
name|Path
name|targetListing
init|=
operator|new
name|Path
argument_list|(
name|sourceListing
operator|.
name|getParent
argument_list|()
argument_list|,
literal|"targetListing.seq"
argument_list|)
decl_stmt|;
name|Path
name|sortedTargetListing
init|=
operator|new
name|Path
argument_list|(
name|targetListing
operator|.
name|toString
argument_list|()
operator|+
literal|"_sorted"
argument_list|)
decl_stmt|;
name|Path
name|targetFinalPath
init|=
name|listTargetFiles
argument_list|(
name|conf
argument_list|,
name|targetListing
argument_list|,
name|sortedTargetListing
argument_list|)
decl_stmt|;
name|long
name|totalLen
init|=
name|clusterFS
operator|.
name|getFileStatus
argument_list|(
name|sortedTargetListing
argument_list|)
operator|.
name|getLen
argument_list|()
decl_stmt|;
name|SequenceFile
operator|.
name|Reader
name|sourceReader
init|=
operator|new
name|SequenceFile
operator|.
name|Reader
argument_list|(
name|conf
argument_list|,
name|SequenceFile
operator|.
name|Reader
operator|.
name|file
argument_list|(
name|sortedSourceListing
argument_list|)
argument_list|)
decl_stmt|;
name|SequenceFile
operator|.
name|Reader
name|targetReader
init|=
operator|new
name|SequenceFile
operator|.
name|Reader
argument_list|(
name|conf
argument_list|,
name|SequenceFile
operator|.
name|Reader
operator|.
name|file
argument_list|(
name|sortedTargetListing
argument_list|)
argument_list|)
decl_stmt|;
comment|// Walk both source and target file listings.
comment|// Delete all from target that doesn't also exist on source.
name|long
name|deletionStart
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Destination listing completed in {}"
argument_list|,
name|formatDuration
argument_list|(
name|deletionStart
operator|-
name|sourceListingCompleted
argument_list|)
argument_list|)
expr_stmt|;
name|long
name|deletedEntries
init|=
literal|0
decl_stmt|;
name|long
name|filesDeleted
init|=
literal|0
decl_stmt|;
name|long
name|missingDeletes
init|=
literal|0
decl_stmt|;
name|long
name|failedDeletes
init|=
literal|0
decl_stmt|;
name|long
name|skippedDeletes
init|=
literal|0
decl_stmt|;
name|long
name|deletedDirectories
init|=
literal|0
decl_stmt|;
comment|// this is an arbitrary constant.
specifier|final
name|DeletedDirTracker
name|tracker
init|=
operator|new
name|DeletedDirTracker
argument_list|(
literal|1000
argument_list|)
decl_stmt|;
try|try
block|{
name|CopyListingFileStatus
name|srcFileStatus
init|=
operator|new
name|CopyListingFileStatus
argument_list|()
decl_stmt|;
name|Text
name|srcRelPath
init|=
operator|new
name|Text
argument_list|()
decl_stmt|;
name|CopyListingFileStatus
name|trgtFileStatus
init|=
operator|new
name|CopyListingFileStatus
argument_list|()
decl_stmt|;
name|Text
name|trgtRelPath
init|=
operator|new
name|Text
argument_list|()
decl_stmt|;
specifier|final
name|FileSystem
name|targetFS
init|=
name|targetFinalPath
operator|.
name|getFileSystem
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|boolean
name|showProgress
decl_stmt|;
name|boolean
name|srcAvailable
init|=
name|sourceReader
operator|.
name|next
argument_list|(
name|srcRelPath
argument_list|,
name|srcFileStatus
argument_list|)
decl_stmt|;
while|while
condition|(
name|targetReader
operator|.
name|next
argument_list|(
name|trgtRelPath
argument_list|,
name|trgtFileStatus
argument_list|)
condition|)
block|{
comment|// Skip sources that don't exist on target.
while|while
condition|(
name|srcAvailable
operator|&&
name|trgtRelPath
operator|.
name|compareTo
argument_list|(
name|srcRelPath
argument_list|)
operator|>
literal|0
condition|)
block|{
name|srcAvailable
operator|=
name|sourceReader
operator|.
name|next
argument_list|(
name|srcRelPath
argument_list|,
name|srcFileStatus
argument_list|)
expr_stmt|;
block|}
name|Path
name|targetEntry
init|=
name|trgtFileStatus
operator|.
name|getPath
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Comparing {} and {}"
argument_list|,
name|srcFileStatus
operator|.
name|getPath
argument_list|()
argument_list|,
name|targetEntry
argument_list|)
expr_stmt|;
if|if
condition|(
name|srcAvailable
operator|&&
name|trgtRelPath
operator|.
name|equals
argument_list|(
name|srcRelPath
argument_list|)
condition|)
continue|continue;
comment|// Target doesn't exist at source. Try to delete it.
if|if
condition|(
name|tracker
operator|.
name|shouldDelete
argument_list|(
name|trgtFileStatus
argument_list|)
condition|)
block|{
name|showProgress
operator|=
literal|true
expr_stmt|;
try|try
block|{
if|if
condition|(
name|targetFS
operator|.
name|delete
argument_list|(
name|targetEntry
argument_list|,
literal|true
argument_list|)
condition|)
block|{
comment|// the delete worked. Unless the file is actually missing, this is the
name|LOG
operator|.
name|info
argument_list|(
literal|"Deleted "
operator|+
name|targetEntry
operator|+
literal|" - missing at source"
argument_list|)
expr_stmt|;
name|deletedEntries
operator|++
expr_stmt|;
if|if
condition|(
name|trgtFileStatus
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
name|deletedDirectories
operator|++
expr_stmt|;
block|}
else|else
block|{
name|filesDeleted
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// delete returned false.
comment|// For all the filestores which implement the FS spec properly,
comment|// this means "the file wasn't there".
comment|// so track but don't worry about it.
name|LOG
operator|.
name|info
argument_list|(
literal|"delete({}) returned false ({})"
argument_list|,
name|targetEntry
argument_list|,
name|trgtFileStatus
argument_list|)
expr_stmt|;
name|missingDeletes
operator|++
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ignoreFailures
condition|)
block|{
throw|throw
name|e
throw|;
block|}
else|else
block|{
comment|// failed to delete, but ignoring errors. So continue
name|LOG
operator|.
name|info
argument_list|(
literal|"Failed to delete {}, ignoring exception {}"
argument_list|,
name|targetEntry
argument_list|,
name|e
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Failed to delete {}"
argument_list|,
name|targetEntry
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|// count and break out the loop
name|failedDeletes
operator|++
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Skipping deletion of {}"
argument_list|,
name|targetEntry
argument_list|)
expr_stmt|;
name|skippedDeletes
operator|++
expr_stmt|;
name|showProgress
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|showProgress
condition|)
block|{
comment|// update progress if there's been any FS IO/files deleted.
name|taskAttemptContext
operator|.
name|progress
argument_list|()
expr_stmt|;
name|taskAttemptContext
operator|.
name|setStatus
argument_list|(
literal|"Deleting removed files from target. ["
operator|+
name|targetReader
operator|.
name|getPosition
argument_list|()
operator|*
literal|100
operator|/
name|totalLen
operator|+
literal|"%]"
argument_list|)
expr_stmt|;
block|}
block|}
comment|// if the FS toString() call prints statistics, they get logged here
name|LOG
operator|.
name|info
argument_list|(
literal|"Completed deletion of files from {}"
argument_list|,
name|targetFS
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|IOUtils
operator|.
name|closeStream
argument_list|(
name|sourceReader
argument_list|)
expr_stmt|;
name|IOUtils
operator|.
name|closeStream
argument_list|(
name|targetReader
argument_list|)
expr_stmt|;
block|}
name|long
name|deletionEnd
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|long
name|deletedFileCount
init|=
name|deletedEntries
operator|-
name|deletedDirectories
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Deleted from target: files: {} directories: {};"
operator|+
literal|" skipped deletions {}; deletions already missing {};"
operator|+
literal|" failed deletes {}"
argument_list|,
name|deletedFileCount
argument_list|,
name|deletedDirectories
argument_list|,
name|skippedDeletes
argument_list|,
name|missingDeletes
argument_list|,
name|failedDeletes
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Number of tracked deleted directories {}"
argument_list|,
name|tracker
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Duration of deletions: {}"
argument_list|,
name|formatDuration
argument_list|(
name|deletionEnd
operator|-
name|deletionStart
argument_list|)
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Total duration of deletion operation: {}"
argument_list|,
name|formatDuration
argument_list|(
name|deletionEnd
operator|-
name|listingStart
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Take a duration and return a human-readable duration of    * hours:minutes:seconds.millis.    * @param duration to process    * @return a string for logging.    */
DECL|method|formatDuration (long duration)
specifier|private
name|String
name|formatDuration
parameter_list|(
name|long
name|duration
parameter_list|)
block|{
name|long
name|seconds
init|=
name|duration
operator|>
literal|0
condition|?
operator|(
name|duration
operator|/
literal|1000
operator|)
else|:
literal|0
decl_stmt|;
name|long
name|minutes
init|=
operator|(
name|seconds
operator|/
literal|60
operator|)
decl_stmt|;
name|long
name|hours
init|=
operator|(
name|minutes
operator|/
literal|60
operator|)
decl_stmt|;
return|return
name|String
operator|.
name|format
argument_list|(
literal|"%d:%02d:%02d.%03d"
argument_list|,
name|hours
argument_list|,
name|minutes
operator|%
literal|60
argument_list|,
name|seconds
operator|%
literal|60
argument_list|,
name|duration
operator|%
literal|1000
argument_list|)
return|;
block|}
comment|/**    * Build a listing of the target files, sorted and unsorted.    * @param conf configuration to work with    * @param targetListing target listing    * @param sortedTargetListing sorted version of the listing    * @return the target path of the operation    * @throws IOException IO failure.    */
DECL|method|listTargetFiles (final Configuration conf, final Path targetListing, final Path sortedTargetListing)
specifier|private
name|Path
name|listTargetFiles
parameter_list|(
specifier|final
name|Configuration
name|conf
parameter_list|,
specifier|final
name|Path
name|targetListing
parameter_list|,
specifier|final
name|Path
name|sortedTargetListing
parameter_list|)
throws|throws
name|IOException
block|{
name|CopyListing
name|target
init|=
operator|new
name|GlobbedCopyListing
argument_list|(
operator|new
name|Configuration
argument_list|(
name|conf
argument_list|)
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|Path
name|targetFinalPath
init|=
operator|new
name|Path
argument_list|(
name|conf
operator|.
name|get
argument_list|(
name|DistCpConstants
operator|.
name|CONF_LABEL_TARGET_FINAL_PATH
argument_list|)
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Path
argument_list|>
name|targets
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|targets
operator|.
name|add
argument_list|(
name|targetFinalPath
argument_list|)
expr_stmt|;
name|Path
name|resultNonePath
init|=
name|Path
operator|.
name|getPathWithoutSchemeAndAuthority
argument_list|(
name|targetFinalPath
argument_list|)
operator|.
name|toString
argument_list|()
operator|.
name|startsWith
argument_list|(
name|DistCpConstants
operator|.
name|HDFS_RESERVED_RAW_DIRECTORY_NAME
argument_list|)
condition|?
name|DistCpConstants
operator|.
name|RAW_NONE_PATH
else|:
name|DistCpConstants
operator|.
name|NONE_PATH
decl_stmt|;
comment|//
comment|// Set up options to be the same from the CopyListing.buildListing's
comment|// perspective, so to collect similar listings as when doing the copy
comment|//
comment|// thread count is picked up from the job
name|int
name|threads
init|=
name|conf
operator|.
name|getInt
argument_list|(
name|DistCpConstants
operator|.
name|CONF_LABEL_LISTSTATUS_THREADS
argument_list|,
name|DistCpConstants
operator|.
name|DEFAULT_LISTSTATUS_THREADS
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Scanning destination directory {} with thread count: {}"
argument_list|,
name|targetFinalPath
argument_list|,
name|threads
argument_list|)
expr_stmt|;
name|DistCpOptions
name|options
init|=
operator|new
name|DistCpOptions
operator|.
name|Builder
argument_list|(
name|targets
argument_list|,
name|resultNonePath
argument_list|)
operator|.
name|withOverwrite
argument_list|(
name|overwrite
argument_list|)
operator|.
name|withSyncFolder
argument_list|(
name|syncFolder
argument_list|)
operator|.
name|withNumListstatusThreads
argument_list|(
name|threads
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|DistCpContext
name|distCpContext
init|=
operator|new
name|DistCpContext
argument_list|(
name|options
argument_list|)
decl_stmt|;
name|distCpContext
operator|.
name|setTargetPathExists
argument_list|(
name|targetPathExists
argument_list|)
expr_stmt|;
name|target
operator|.
name|buildListing
argument_list|(
name|targetListing
argument_list|,
name|distCpContext
argument_list|)
expr_stmt|;
name|DistCpUtils
operator|.
name|sortListing
argument_list|(
name|conf
argument_list|,
name|targetListing
argument_list|,
name|sortedTargetListing
argument_list|)
expr_stmt|;
return|return
name|targetFinalPath
return|;
block|}
DECL|method|commitData (Configuration conf)
specifier|private
name|void
name|commitData
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|Path
name|workDir
init|=
operator|new
name|Path
argument_list|(
name|conf
operator|.
name|get
argument_list|(
name|DistCpConstants
operator|.
name|CONF_LABEL_TARGET_WORK_PATH
argument_list|)
argument_list|)
decl_stmt|;
name|Path
name|finalDir
init|=
operator|new
name|Path
argument_list|(
name|conf
operator|.
name|get
argument_list|(
name|DistCpConstants
operator|.
name|CONF_LABEL_TARGET_FINAL_PATH
argument_list|)
argument_list|)
decl_stmt|;
name|FileSystem
name|targetFS
init|=
name|workDir
operator|.
name|getFileSystem
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Atomic commit enabled. Moving "
operator|+
name|workDir
operator|+
literal|" to "
operator|+
name|finalDir
argument_list|)
expr_stmt|;
if|if
condition|(
name|targetFS
operator|.
name|exists
argument_list|(
name|finalDir
argument_list|)
operator|&&
name|targetFS
operator|.
name|exists
argument_list|(
name|workDir
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Pre-existing final-path found at: "
operator|+
name|finalDir
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Target-path can't be committed to because it "
operator|+
literal|"exists at "
operator|+
name|finalDir
operator|+
literal|". Copied data is in temp-dir: "
operator|+
name|workDir
operator|+
literal|". "
argument_list|)
throw|;
block|}
name|boolean
name|result
init|=
name|targetFS
operator|.
name|rename
argument_list|(
name|workDir
argument_list|,
name|finalDir
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|result
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Rename failed. Perhaps data already moved. Verifying..."
argument_list|)
expr_stmt|;
name|result
operator|=
name|targetFS
operator|.
name|exists
argument_list|(
name|finalDir
argument_list|)
operator|&&
operator|!
name|targetFS
operator|.
name|exists
argument_list|(
name|workDir
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Data committed successfully to "
operator|+
name|finalDir
argument_list|)
expr_stmt|;
name|taskAttemptContext
operator|.
name|setStatus
argument_list|(
literal|"Data committed successfully to "
operator|+
name|finalDir
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to commit data to "
operator|+
name|finalDir
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Atomic commit failed. Temporary data in "
operator|+
name|workDir
operator|+
literal|", Unable to move to "
operator|+
name|finalDir
argument_list|)
throw|;
block|}
block|}
comment|/**    * Concat the passed chunk files into one and rename it the targetFile.    */
DECL|method|concatFileChunks (Configuration conf, Path sourceFile, Path targetFile, LinkedList<Path> allChunkPaths, CopyListingFileStatus srcFileStatus)
specifier|private
name|void
name|concatFileChunks
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|Path
name|sourceFile
parameter_list|,
name|Path
name|targetFile
parameter_list|,
name|LinkedList
argument_list|<
name|Path
argument_list|>
name|allChunkPaths
parameter_list|,
name|CopyListingFileStatus
name|srcFileStatus
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|allChunkPaths
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"concat "
operator|+
name|targetFile
operator|+
literal|" allChunkSize+ "
operator|+
name|allChunkPaths
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|FileSystem
name|dstfs
init|=
name|targetFile
operator|.
name|getFileSystem
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|FileSystem
name|srcfs
init|=
name|sourceFile
operator|.
name|getFileSystem
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|Path
name|firstChunkFile
init|=
name|allChunkPaths
operator|.
name|removeFirst
argument_list|()
decl_stmt|;
name|Path
index|[]
name|restChunkFiles
init|=
operator|new
name|Path
index|[
name|allChunkPaths
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
name|allChunkPaths
operator|.
name|toArray
argument_list|(
name|restChunkFiles
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"concat: firstchunk: "
operator|+
name|dstfs
operator|.
name|getFileStatus
argument_list|(
name|firstChunkFile
argument_list|)
argument_list|)
expr_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Path
name|f
range|:
name|restChunkFiles
control|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"concat: other chunk: "
operator|+
name|i
operator|+
literal|": "
operator|+
name|dstfs
operator|.
name|getFileStatus
argument_list|(
name|f
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
block|}
name|dstfs
operator|.
name|concat
argument_list|(
name|firstChunkFile
argument_list|,
name|restChunkFiles
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"concat: result: "
operator|+
name|dstfs
operator|.
name|getFileStatus
argument_list|(
name|firstChunkFile
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|rename
argument_list|(
name|dstfs
argument_list|,
name|firstChunkFile
argument_list|,
name|targetFile
argument_list|)
expr_stmt|;
name|DistCpUtils
operator|.
name|compareFileLengthsAndChecksums
argument_list|(
name|srcFileStatus
operator|.
name|getLen
argument_list|()
argument_list|,
name|srcfs
argument_list|,
name|sourceFile
argument_list|,
literal|null
argument_list|,
name|dstfs
argument_list|,
name|targetFile
argument_list|,
name|skipCrc
argument_list|,
name|srcFileStatus
operator|.
name|getLen
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Rename tmp to dst on destFileSys.    * @param destFileSys the file ssystem    * @param tmp the source path    * @param dst the destination path    * @throws IOException if renaming failed    */
DECL|method|rename (FileSystem destFileSys, Path tmp, Path dst)
specifier|private
specifier|static
name|void
name|rename
parameter_list|(
name|FileSystem
name|destFileSys
parameter_list|,
name|Path
name|tmp
parameter_list|,
name|Path
name|dst
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
if|if
condition|(
name|destFileSys
operator|.
name|exists
argument_list|(
name|dst
argument_list|)
condition|)
block|{
name|destFileSys
operator|.
name|delete
argument_list|(
name|dst
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
name|destFileSys
operator|.
name|rename
argument_list|(
name|tmp
argument_list|,
name|dst
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Fail to rename tmp file (="
operator|+
name|tmp
operator|+
literal|") to destination file (="
operator|+
name|dst
operator|+
literal|")"
argument_list|,
name|ioe
argument_list|)
throw|;
block|}
block|}
block|}
end_class

end_unit

