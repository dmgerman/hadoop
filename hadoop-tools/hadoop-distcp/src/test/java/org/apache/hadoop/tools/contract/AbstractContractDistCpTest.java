begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.tools.contract
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|tools
operator|.
name|contract
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|contract
operator|.
name|ContractTestUtils
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|LocatedFileStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|RemoteIterator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|contract
operator|.
name|AbstractFSContractTestBase
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|contract
operator|.
name|ContractTestUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|SequenceFile
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|Text
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|Counter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|Job
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|test
operator|.
name|GenericTestUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|tools
operator|.
name|CopyListingFileStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|tools
operator|.
name|DistCp
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|tools
operator|.
name|DistCpConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|tools
operator|.
name|DistCpOptions
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|tools
operator|.
name|mapred
operator|.
name|CopyMapper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Before
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Rule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Test
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|rules
operator|.
name|TestName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_comment
comment|/**  * Contract test suite covering a file system's integration with DistCp.  The  * tests coordinate two file system instances: one "local", which is the local  * file system, and the other "remote", which is the file system implementation  * under test.  The tests in the suite cover both copying from local to remote  * (e.g. a backup use case) and copying from remote to local (e.g. a restore use  * case).  */
end_comment

begin_class
DECL|class|AbstractContractDistCpTest
specifier|public
specifier|abstract
class|class
name|AbstractContractDistCpTest
extends|extends
name|AbstractFSContractTestBase
block|{
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|AbstractContractDistCpTest
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|SCALE_TEST_DISTCP_FILE_SIZE_KB
specifier|public
specifier|static
specifier|final
name|String
name|SCALE_TEST_DISTCP_FILE_SIZE_KB
init|=
literal|"scale.test.distcp.file.size.kb"
decl_stmt|;
DECL|field|DEFAULT_DISTCP_SIZE_KB
specifier|public
specifier|static
specifier|final
name|int
name|DEFAULT_DISTCP_SIZE_KB
init|=
literal|1024
decl_stmt|;
DECL|field|MB
specifier|protected
specifier|static
specifier|final
name|int
name|MB
init|=
literal|1024
operator|*
literal|1024
decl_stmt|;
annotation|@
name|Rule
DECL|field|testName
specifier|public
name|TestName
name|testName
init|=
operator|new
name|TestName
argument_list|()
decl_stmt|;
comment|/**    * The timeout value is extended over the default so that large updates    * are allowed to take time, especially to remote stores.    * @return the current test timeout    */
DECL|method|getTestTimeoutMillis ()
specifier|protected
name|int
name|getTestTimeoutMillis
parameter_list|()
block|{
return|return
literal|15
operator|*
literal|60
operator|*
literal|1000
return|;
block|}
DECL|field|conf
specifier|private
name|Configuration
name|conf
decl_stmt|;
DECL|field|localFS
DECL|field|remoteFS
specifier|private
name|FileSystem
name|localFS
decl_stmt|,
name|remoteFS
decl_stmt|;
DECL|field|localDir
DECL|field|remoteDir
specifier|private
name|Path
name|localDir
decl_stmt|,
name|remoteDir
decl_stmt|;
DECL|field|inputDir
specifier|private
name|Path
name|inputDir
decl_stmt|;
DECL|field|inputSubDir1
specifier|private
name|Path
name|inputSubDir1
decl_stmt|;
DECL|field|inputSubDir2
specifier|private
name|Path
name|inputSubDir2
decl_stmt|;
DECL|field|inputSubDir4
specifier|private
name|Path
name|inputSubDir4
decl_stmt|;
DECL|field|inputFile1
specifier|private
name|Path
name|inputFile1
decl_stmt|;
DECL|field|inputFile2
specifier|private
name|Path
name|inputFile2
decl_stmt|;
DECL|field|inputFile3
specifier|private
name|Path
name|inputFile3
decl_stmt|;
DECL|field|inputFile4
specifier|private
name|Path
name|inputFile4
decl_stmt|;
DECL|field|inputFile5
specifier|private
name|Path
name|inputFile5
decl_stmt|;
DECL|field|outputDir
specifier|private
name|Path
name|outputDir
decl_stmt|;
DECL|field|outputSubDir1
specifier|private
name|Path
name|outputSubDir1
decl_stmt|;
DECL|field|outputSubDir2
specifier|private
name|Path
name|outputSubDir2
decl_stmt|;
DECL|field|outputSubDir4
specifier|private
name|Path
name|outputSubDir4
decl_stmt|;
DECL|field|outputFile1
specifier|private
name|Path
name|outputFile1
decl_stmt|;
DECL|field|outputFile2
specifier|private
name|Path
name|outputFile2
decl_stmt|;
DECL|field|outputFile3
specifier|private
name|Path
name|outputFile3
decl_stmt|;
DECL|field|outputFile4
specifier|private
name|Path
name|outputFile4
decl_stmt|;
DECL|field|outputFile5
specifier|private
name|Path
name|outputFile5
decl_stmt|;
DECL|field|inputDirUnderOutputDir
specifier|private
name|Path
name|inputDirUnderOutputDir
decl_stmt|;
annotation|@
name|Override
DECL|method|createConfiguration ()
specifier|protected
name|Configuration
name|createConfiguration
parameter_list|()
block|{
name|Configuration
name|newConf
init|=
operator|new
name|Configuration
argument_list|()
decl_stmt|;
name|newConf
operator|.
name|set
argument_list|(
literal|"mapred.job.tracker"
argument_list|,
literal|"local"
argument_list|)
expr_stmt|;
return|return
name|newConf
return|;
block|}
annotation|@
name|Before
annotation|@
name|Override
DECL|method|setup ()
specifier|public
name|void
name|setup
parameter_list|()
throws|throws
name|Exception
block|{
name|super
operator|.
name|setup
argument_list|()
expr_stmt|;
name|conf
operator|=
name|getContract
argument_list|()
operator|.
name|getConf
argument_list|()
expr_stmt|;
name|localFS
operator|=
name|FileSystem
operator|.
name|getLocal
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|remoteFS
operator|=
name|getFileSystem
argument_list|()
expr_stmt|;
comment|// Test paths are isolated by concrete subclass name and test method name.
comment|// All paths are fully qualified including scheme (not taking advantage of
comment|// default file system), so if something fails, the messages will make it
comment|// clear which paths are local and which paths are remote.
name|String
name|className
init|=
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
decl_stmt|;
name|String
name|testSubDir
init|=
name|className
operator|+
literal|"/"
operator|+
name|testName
operator|.
name|getMethodName
argument_list|()
decl_stmt|;
name|localDir
operator|=
name|localFS
operator|.
name|makeQualified
argument_list|(
operator|new
name|Path
argument_list|(
operator|new
name|Path
argument_list|(
name|GenericTestUtils
operator|.
name|getTestDir
argument_list|()
operator|.
name|toURI
argument_list|()
argument_list|)
argument_list|,
name|testSubDir
operator|+
literal|"/local"
argument_list|)
argument_list|)
expr_stmt|;
name|mkdirs
argument_list|(
name|localFS
argument_list|,
name|localDir
argument_list|)
expr_stmt|;
name|remoteDir
operator|=
name|path
argument_list|(
name|testSubDir
operator|+
literal|"/remote"
argument_list|)
expr_stmt|;
name|mkdirs
argument_list|(
name|remoteFS
argument_list|,
name|remoteDir
argument_list|)
expr_stmt|;
comment|// test teardown does this, but IDE-based test debugging can skip
comment|// that teardown; this guarantees the initial state is clean
name|remoteFS
operator|.
name|delete
argument_list|(
name|remoteDir
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|localFS
operator|.
name|delete
argument_list|(
name|localDir
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**    * Set up both input and output fields.    * @param src source tree    * @param dest dest tree    */
DECL|method|initPathFields (final Path src, final Path dest)
specifier|protected
name|void
name|initPathFields
parameter_list|(
specifier|final
name|Path
name|src
parameter_list|,
specifier|final
name|Path
name|dest
parameter_list|)
block|{
name|initInputFields
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|initOutputFields
argument_list|(
name|dest
argument_list|)
expr_stmt|;
block|}
comment|/**    * Output field setup.    * @param path path to set up    */
DECL|method|initOutputFields (final Path path)
specifier|protected
name|void
name|initOutputFields
parameter_list|(
specifier|final
name|Path
name|path
parameter_list|)
block|{
name|outputDir
operator|=
operator|new
name|Path
argument_list|(
name|path
argument_list|,
literal|"outputDir"
argument_list|)
expr_stmt|;
name|inputDirUnderOutputDir
operator|=
operator|new
name|Path
argument_list|(
name|outputDir
argument_list|,
literal|"inputDir"
argument_list|)
expr_stmt|;
name|outputFile1
operator|=
operator|new
name|Path
argument_list|(
name|inputDirUnderOutputDir
argument_list|,
literal|"file1"
argument_list|)
expr_stmt|;
name|outputSubDir1
operator|=
operator|new
name|Path
argument_list|(
name|inputDirUnderOutputDir
argument_list|,
literal|"subDir1"
argument_list|)
expr_stmt|;
name|outputFile2
operator|=
operator|new
name|Path
argument_list|(
name|outputSubDir1
argument_list|,
literal|"file2"
argument_list|)
expr_stmt|;
name|outputSubDir2
operator|=
operator|new
name|Path
argument_list|(
name|inputDirUnderOutputDir
argument_list|,
literal|"subDir2/subDir2"
argument_list|)
expr_stmt|;
name|outputFile3
operator|=
operator|new
name|Path
argument_list|(
name|outputSubDir2
argument_list|,
literal|"file3"
argument_list|)
expr_stmt|;
name|outputSubDir4
operator|=
operator|new
name|Path
argument_list|(
name|inputDirUnderOutputDir
argument_list|,
literal|"subDir4/subDir4"
argument_list|)
expr_stmt|;
name|outputFile4
operator|=
operator|new
name|Path
argument_list|(
name|outputSubDir4
argument_list|,
literal|"file4"
argument_list|)
expr_stmt|;
name|outputFile5
operator|=
operator|new
name|Path
argument_list|(
name|outputSubDir4
argument_list|,
literal|"file5"
argument_list|)
expr_stmt|;
block|}
comment|/**    * this path setup is used across different methods (copy, update, track)    * so they are set up as fields.    * @param srcDir source directory for these to go under.    */
DECL|method|initInputFields (final Path srcDir)
specifier|protected
name|void
name|initInputFields
parameter_list|(
specifier|final
name|Path
name|srcDir
parameter_list|)
block|{
name|inputDir
operator|=
operator|new
name|Path
argument_list|(
name|srcDir
argument_list|,
literal|"inputDir"
argument_list|)
expr_stmt|;
name|inputFile1
operator|=
operator|new
name|Path
argument_list|(
name|inputDir
argument_list|,
literal|"file1"
argument_list|)
expr_stmt|;
name|inputSubDir1
operator|=
operator|new
name|Path
argument_list|(
name|inputDir
argument_list|,
literal|"subDir1"
argument_list|)
expr_stmt|;
name|inputFile2
operator|=
operator|new
name|Path
argument_list|(
name|inputSubDir1
argument_list|,
literal|"file2"
argument_list|)
expr_stmt|;
name|inputSubDir2
operator|=
operator|new
name|Path
argument_list|(
name|inputDir
argument_list|,
literal|"subDir2/subDir2"
argument_list|)
expr_stmt|;
name|inputFile3
operator|=
operator|new
name|Path
argument_list|(
name|inputSubDir2
argument_list|,
literal|"file3"
argument_list|)
expr_stmt|;
name|inputSubDir4
operator|=
operator|new
name|Path
argument_list|(
name|inputDir
argument_list|,
literal|"subDir4/subDir4"
argument_list|)
expr_stmt|;
name|inputFile4
operator|=
operator|new
name|Path
argument_list|(
name|inputSubDir4
argument_list|,
literal|"file4"
argument_list|)
expr_stmt|;
name|inputFile5
operator|=
operator|new
name|Path
argument_list|(
name|inputSubDir4
argument_list|,
literal|"file5"
argument_list|)
expr_stmt|;
block|}
DECL|method|getLocalFS ()
specifier|protected
name|FileSystem
name|getLocalFS
parameter_list|()
block|{
return|return
name|localFS
return|;
block|}
DECL|method|getRemoteFS ()
specifier|protected
name|FileSystem
name|getRemoteFS
parameter_list|()
block|{
return|return
name|remoteFS
return|;
block|}
DECL|method|getLocalDir ()
specifier|protected
name|Path
name|getLocalDir
parameter_list|()
block|{
return|return
name|localDir
return|;
block|}
DECL|method|getRemoteDir ()
specifier|protected
name|Path
name|getRemoteDir
parameter_list|()
block|{
return|return
name|remoteDir
return|;
block|}
annotation|@
name|Test
DECL|method|testUpdateDeepDirectoryStructureToRemote ()
specifier|public
name|void
name|testUpdateDeepDirectoryStructureToRemote
parameter_list|()
throws|throws
name|Exception
block|{
name|describe
argument_list|(
literal|"update a deep directory structure from local to remote"
argument_list|)
expr_stmt|;
name|distCpDeepDirectoryStructure
argument_list|(
name|localFS
argument_list|,
name|localDir
argument_list|,
name|remoteFS
argument_list|,
name|remoteDir
argument_list|)
expr_stmt|;
name|distCpUpdateDeepDirectoryStructure
argument_list|(
name|inputDirUnderOutputDir
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testUpdateDeepDirectoryStructureNoChange ()
specifier|public
name|void
name|testUpdateDeepDirectoryStructureNoChange
parameter_list|()
throws|throws
name|Exception
block|{
name|describe
argument_list|(
literal|"update an unchanged directory structure"
operator|+
literal|" from local to remote; expect no copy"
argument_list|)
expr_stmt|;
name|Path
name|target
init|=
name|distCpDeepDirectoryStructure
argument_list|(
name|localFS
argument_list|,
name|localDir
argument_list|,
name|remoteFS
argument_list|,
name|remoteDir
argument_list|)
decl_stmt|;
name|describe
argument_list|(
literal|"\nExecuting Update\n"
argument_list|)
expr_stmt|;
name|Job
name|job
init|=
name|distCpUpdate
argument_list|(
name|localDir
argument_list|,
name|target
argument_list|)
decl_stmt|;
name|assertCounterInRange
argument_list|(
name|job
argument_list|,
name|CopyMapper
operator|.
name|Counter
operator|.
name|SKIP
argument_list|,
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|assertCounterInRange
argument_list|(
name|job
argument_list|,
name|CopyMapper
operator|.
name|Counter
operator|.
name|BYTESCOPIED
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/**    * Assert that a counter is in a range; min and max values are inclusive.    * @param job job to query    * @param counter counter to examine    * @param min min value, if negative "no minimum"    * @param max max value, if negative "no maximum"    * @throws IOException IO problem    */
DECL|method|assertCounterInRange (Job job, Enum<?> counter, long min, long max)
name|void
name|assertCounterInRange
parameter_list|(
name|Job
name|job
parameter_list|,
name|Enum
argument_list|<
name|?
argument_list|>
name|counter
parameter_list|,
name|long
name|min
parameter_list|,
name|long
name|max
parameter_list|)
throws|throws
name|IOException
block|{
name|Counter
name|c
init|=
name|job
operator|.
name|getCounters
argument_list|()
operator|.
name|findCounter
argument_list|(
name|counter
argument_list|)
decl_stmt|;
name|long
name|value
init|=
name|c
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|String
name|description
init|=
name|String
operator|.
name|format
argument_list|(
literal|"%s value %s"
argument_list|,
name|c
operator|.
name|getDisplayName
argument_list|()
argument_list|,
name|value
argument_list|)
decl_stmt|;
if|if
condition|(
name|min
operator|>=
literal|0
condition|)
block|{
name|assertTrue
argument_list|(
name|description
operator|+
literal|" too below minimum "
operator|+
name|min
argument_list|,
name|value
operator|>=
name|min
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|max
operator|>=
literal|0
condition|)
block|{
name|assertTrue
argument_list|(
name|description
operator|+
literal|" above maximum "
operator|+
name|max
argument_list|,
name|value
operator|<=
name|max
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Do a distcp from the local source to the destination filesystem.    * This is executed as part of    * {@link #testUpdateDeepDirectoryStructureToRemote()}; it's designed to be    * overidden or wrapped by subclasses which wish to add more assertions.    *    * Life is complicated here by the way that the src/dest paths    * on a distcp is different with -update.    * @param destDir output directory used by the initial distcp    * @return the distcp job    */
DECL|method|distCpUpdateDeepDirectoryStructure (final Path destDir)
specifier|protected
name|Job
name|distCpUpdateDeepDirectoryStructure
parameter_list|(
specifier|final
name|Path
name|destDir
parameter_list|)
throws|throws
name|Exception
block|{
name|describe
argument_list|(
literal|"Now do an incremental update with deletion of missing files"
argument_list|)
expr_stmt|;
name|Path
name|srcDir
init|=
name|inputDir
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Source directory = {}, dest={}"
argument_list|,
name|srcDir
argument_list|,
name|destDir
argument_list|)
expr_stmt|;
name|ContractTestUtils
operator|.
name|assertPathsExist
argument_list|(
name|localFS
argument_list|,
literal|"Paths for test are wrong"
argument_list|,
name|inputFile1
argument_list|,
name|inputFile2
argument_list|,
name|inputFile3
argument_list|,
name|inputFile4
argument_list|,
name|inputFile5
argument_list|)
expr_stmt|;
name|modifySourceDirectories
argument_list|()
expr_stmt|;
name|Job
name|job
init|=
name|distCpUpdate
argument_list|(
name|srcDir
argument_list|,
name|destDir
argument_list|)
decl_stmt|;
name|Path
name|outputFileNew1
init|=
operator|new
name|Path
argument_list|(
name|outputSubDir2
argument_list|,
literal|"newfile1"
argument_list|)
decl_stmt|;
name|lsR
argument_list|(
literal|"Updated Remote"
argument_list|,
name|remoteFS
argument_list|,
name|destDir
argument_list|)
expr_stmt|;
name|ContractTestUtils
operator|.
name|assertPathDoesNotExist
argument_list|(
name|remoteFS
argument_list|,
literal|" deleted from "
operator|+
name|inputFile1
argument_list|,
name|outputFile1
argument_list|)
expr_stmt|;
name|ContractTestUtils
operator|.
name|assertIsFile
argument_list|(
name|remoteFS
argument_list|,
name|outputFileNew1
argument_list|)
expr_stmt|;
name|ContractTestUtils
operator|.
name|assertPathsDoNotExist
argument_list|(
name|remoteFS
argument_list|,
literal|"DistCP should have deleted"
argument_list|,
name|outputFile3
argument_list|,
name|outputFile4
argument_list|,
name|outputSubDir4
argument_list|)
expr_stmt|;
name|assertCounterInRange
argument_list|(
name|job
argument_list|,
name|CopyMapper
operator|.
name|Counter
operator|.
name|COPY
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|assertCounterInRange
argument_list|(
name|job
argument_list|,
name|CopyMapper
operator|.
name|Counter
operator|.
name|SKIP
argument_list|,
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|job
return|;
block|}
comment|/**    * Run distcp -update srcDir destDir.    * @param srcDir local source directory    * @param destDir remote destination directory.    * @return the completed job    * @throws Exception any failure.    */
DECL|method|distCpUpdate (final Path srcDir, final Path destDir)
specifier|private
name|Job
name|distCpUpdate
parameter_list|(
specifier|final
name|Path
name|srcDir
parameter_list|,
specifier|final
name|Path
name|destDir
parameter_list|)
throws|throws
name|Exception
block|{
name|describe
argument_list|(
literal|"\nDistcp -update from "
operator|+
name|srcDir
operator|+
literal|" to "
operator|+
name|destDir
argument_list|)
expr_stmt|;
name|lsR
argument_list|(
literal|"Local to update"
argument_list|,
name|localFS
argument_list|,
name|srcDir
argument_list|)
expr_stmt|;
name|lsR
argument_list|(
literal|"Remote before update"
argument_list|,
name|remoteFS
argument_list|,
name|destDir
argument_list|)
expr_stmt|;
return|return
name|runDistCp
argument_list|(
name|buildWithStandardOptions
argument_list|(
operator|new
name|DistCpOptions
operator|.
name|Builder
argument_list|(
name|Collections
operator|.
name|singletonList
argument_list|(
name|srcDir
argument_list|)
argument_list|,
name|destDir
argument_list|)
operator|.
name|withDeleteMissing
argument_list|(
literal|true
argument_list|)
operator|.
name|withSyncFolder
argument_list|(
literal|true
argument_list|)
operator|.
name|withCRC
argument_list|(
literal|true
argument_list|)
operator|.
name|withOverwrite
argument_list|(
literal|false
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Update the source directories as various tests expect,    * including adding a new file.    * @return the path to the newly created file    * @throws IOException IO failure    */
DECL|method|modifySourceDirectories ()
specifier|private
name|Path
name|modifySourceDirectories
parameter_list|()
throws|throws
name|IOException
block|{
name|localFS
operator|.
name|delete
argument_list|(
name|inputFile1
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|localFS
operator|.
name|delete
argument_list|(
name|inputFile3
argument_list|,
literal|false
argument_list|)
expr_stmt|;
comment|// delete all of subdir4, so input/output file 4& 5 will go
name|localFS
operator|.
name|delete
argument_list|(
name|inputSubDir4
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|// add one new file
name|Path
name|inputFileNew1
init|=
operator|new
name|Path
argument_list|(
name|inputSubDir2
argument_list|,
literal|"newfile1"
argument_list|)
decl_stmt|;
name|ContractTestUtils
operator|.
name|touch
argument_list|(
name|localFS
argument_list|,
name|inputFileNew1
argument_list|)
expr_stmt|;
return|return
name|inputFileNew1
return|;
block|}
annotation|@
name|Test
DECL|method|testTrackDeepDirectoryStructureToRemote ()
specifier|public
name|void
name|testTrackDeepDirectoryStructureToRemote
parameter_list|()
throws|throws
name|Exception
block|{
name|describe
argument_list|(
literal|"copy a deep directory structure from local to remote"
argument_list|)
expr_stmt|;
name|Path
name|destDir
init|=
name|distCpDeepDirectoryStructure
argument_list|(
name|localFS
argument_list|,
name|localDir
argument_list|,
name|remoteFS
argument_list|,
name|remoteDir
argument_list|)
decl_stmt|;
name|ContractTestUtils
operator|.
name|assertIsDirectory
argument_list|(
name|remoteFS
argument_list|,
name|destDir
argument_list|)
expr_stmt|;
name|describe
argument_list|(
literal|"Now do an incremental update and save of missing files"
argument_list|)
expr_stmt|;
name|Path
name|srcDir
init|=
name|inputDir
decl_stmt|;
comment|// same path setup as in deepDirectoryStructure()
name|Path
name|trackDir
init|=
operator|new
name|Path
argument_list|(
name|localDir
argument_list|,
literal|"trackDir"
argument_list|)
decl_stmt|;
name|describe
argument_list|(
literal|"\nDirectories\n"
argument_list|)
expr_stmt|;
name|lsR
argument_list|(
literal|"Local to update"
argument_list|,
name|localFS
argument_list|,
name|srcDir
argument_list|)
expr_stmt|;
name|lsR
argument_list|(
literal|"Remote before update"
argument_list|,
name|remoteFS
argument_list|,
name|destDir
argument_list|)
expr_stmt|;
name|ContractTestUtils
operator|.
name|assertPathsExist
argument_list|(
name|localFS
argument_list|,
literal|"Paths for test are wrong"
argument_list|,
name|inputFile2
argument_list|,
name|inputFile3
argument_list|,
name|inputFile4
argument_list|,
name|inputFile5
argument_list|)
expr_stmt|;
name|Path
name|inputFileNew1
init|=
name|modifySourceDirectories
argument_list|()
decl_stmt|;
comment|// Distcp set to track but not delete
name|runDistCp
argument_list|(
name|buildWithStandardOptions
argument_list|(
operator|new
name|DistCpOptions
operator|.
name|Builder
argument_list|(
name|Collections
operator|.
name|singletonList
argument_list|(
name|srcDir
argument_list|)
argument_list|,
name|inputDirUnderOutputDir
argument_list|)
operator|.
name|withTrackMissing
argument_list|(
name|trackDir
argument_list|)
operator|.
name|withSyncFolder
argument_list|(
literal|true
argument_list|)
operator|.
name|withOverwrite
argument_list|(
literal|false
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|lsR
argument_list|(
literal|"tracked udpate"
argument_list|,
name|remoteFS
argument_list|,
name|destDir
argument_list|)
expr_stmt|;
comment|// new file went over
name|Path
name|outputFileNew1
init|=
operator|new
name|Path
argument_list|(
name|outputSubDir2
argument_list|,
literal|"newfile1"
argument_list|)
decl_stmt|;
name|ContractTestUtils
operator|.
name|assertIsFile
argument_list|(
name|remoteFS
argument_list|,
name|outputFileNew1
argument_list|)
expr_stmt|;
name|ContractTestUtils
operator|.
name|assertPathExists
argument_list|(
name|localFS
argument_list|,
literal|"tracking directory"
argument_list|,
name|trackDir
argument_list|)
expr_stmt|;
comment|// now read in the listings
name|Path
name|sortedSourceListing
init|=
operator|new
name|Path
argument_list|(
name|trackDir
argument_list|,
name|DistCpConstants
operator|.
name|SOURCE_SORTED_FILE
argument_list|)
decl_stmt|;
name|ContractTestUtils
operator|.
name|assertIsFile
argument_list|(
name|localFS
argument_list|,
name|sortedSourceListing
argument_list|)
expr_stmt|;
name|Path
name|sortedTargetListing
init|=
operator|new
name|Path
argument_list|(
name|trackDir
argument_list|,
name|DistCpConstants
operator|.
name|TARGET_SORTED_FILE
argument_list|)
decl_stmt|;
name|ContractTestUtils
operator|.
name|assertIsFile
argument_list|(
name|localFS
argument_list|,
name|sortedTargetListing
argument_list|)
expr_stmt|;
comment|// deletion didn't happen
name|ContractTestUtils
operator|.
name|assertPathsExist
argument_list|(
name|remoteFS
argument_list|,
literal|"DistCP should have retained"
argument_list|,
name|outputFile2
argument_list|,
name|outputFile3
argument_list|,
name|outputFile4
argument_list|,
name|outputSubDir4
argument_list|)
expr_stmt|;
comment|// now scan the table and see that things are there.
name|Map
argument_list|<
name|String
argument_list|,
name|Path
argument_list|>
name|sourceFiles
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|(
literal|10
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|Path
argument_list|>
name|targetFiles
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|(
literal|10
argument_list|)
decl_stmt|;
try|try
init|(
name|SequenceFile
operator|.
name|Reader
name|sourceReader
init|=
operator|new
name|SequenceFile
operator|.
name|Reader
argument_list|(
name|conf
argument_list|,
name|SequenceFile
operator|.
name|Reader
operator|.
name|file
argument_list|(
name|sortedSourceListing
argument_list|)
argument_list|)
init|;
name|SequenceFile
operator|.
name|Reader
name|targetReader
operator|=
operator|new
name|SequenceFile
operator|.
name|Reader
argument_list|(
name|conf
argument_list|,
name|SequenceFile
operator|.
name|Reader
operator|.
name|file
argument_list|(
name|sortedTargetListing
argument_list|)
argument_list|)
init|)
block|{
name|CopyListingFileStatus
name|copyStatus
init|=
operator|new
name|CopyListingFileStatus
argument_list|()
decl_stmt|;
name|Text
name|name
init|=
operator|new
name|Text
argument_list|()
decl_stmt|;
while|while
condition|(
name|sourceReader
operator|.
name|next
argument_list|(
name|name
argument_list|,
name|copyStatus
argument_list|)
condition|)
block|{
name|String
name|key
init|=
name|name
operator|.
name|toString
argument_list|()
decl_stmt|;
name|Path
name|path
init|=
name|copyStatus
operator|.
name|getPath
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"{}: {}"
argument_list|,
name|key
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|sourceFiles
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|path
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|targetReader
operator|.
name|next
argument_list|(
name|name
argument_list|,
name|copyStatus
argument_list|)
condition|)
block|{
name|String
name|key
init|=
name|name
operator|.
name|toString
argument_list|()
decl_stmt|;
name|Path
name|path
init|=
name|copyStatus
operator|.
name|getPath
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"{}: {}"
argument_list|,
name|key
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|targetFiles
operator|.
name|put
argument_list|(
name|name
operator|.
name|toString
argument_list|()
argument_list|,
name|copyStatus
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|// look for the new file in both lists
name|assertTrue
argument_list|(
literal|"No "
operator|+
name|outputFileNew1
operator|+
literal|" in source listing"
argument_list|,
name|sourceFiles
operator|.
name|containsValue
argument_list|(
name|inputFileNew1
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"No "
operator|+
name|outputFileNew1
operator|+
literal|" in target listing"
argument_list|,
name|targetFiles
operator|.
name|containsValue
argument_list|(
name|outputFileNew1
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"No "
operator|+
name|outputSubDir4
operator|+
literal|" in target listing"
argument_list|,
name|targetFiles
operator|.
name|containsValue
argument_list|(
name|outputSubDir4
argument_list|)
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
literal|"Found "
operator|+
name|inputSubDir4
operator|+
literal|" in source listing"
argument_list|,
name|sourceFiles
operator|.
name|containsValue
argument_list|(
name|inputSubDir4
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|lsR (final String description, final FileSystem fs, final Path dir)
specifier|public
name|void
name|lsR
parameter_list|(
specifier|final
name|String
name|description
parameter_list|,
specifier|final
name|FileSystem
name|fs
parameter_list|,
specifier|final
name|Path
name|dir
parameter_list|)
throws|throws
name|IOException
block|{
name|RemoteIterator
argument_list|<
name|LocatedFileStatus
argument_list|>
name|files
init|=
name|fs
operator|.
name|listFiles
argument_list|(
name|dir
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"{}: {}:"
argument_list|,
name|description
argument_list|,
name|dir
argument_list|)
expr_stmt|;
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
while|while
condition|(
name|files
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|LocatedFileStatus
name|status
init|=
name|files
operator|.
name|next
argument_list|()
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"  %s; type=%s; length=%d"
argument_list|,
name|status
operator|.
name|getPath
argument_list|()
argument_list|,
name|status
operator|.
name|isDirectory
argument_list|()
condition|?
literal|"dir"
else|:
literal|"file"
argument_list|,
name|status
operator|.
name|getLen
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"{}"
argument_list|,
name|sb
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|largeFilesToRemote ()
specifier|public
name|void
name|largeFilesToRemote
parameter_list|()
throws|throws
name|Exception
block|{
name|describe
argument_list|(
literal|"copy multiple large files from local to remote"
argument_list|)
expr_stmt|;
name|largeFiles
argument_list|(
name|localFS
argument_list|,
name|localDir
argument_list|,
name|remoteFS
argument_list|,
name|remoteDir
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testDeepDirectoryStructureFromRemote ()
specifier|public
name|void
name|testDeepDirectoryStructureFromRemote
parameter_list|()
throws|throws
name|Exception
block|{
name|describe
argument_list|(
literal|"copy a deep directory structure from remote to local"
argument_list|)
expr_stmt|;
name|distCpDeepDirectoryStructure
argument_list|(
name|remoteFS
argument_list|,
name|remoteDir
argument_list|,
name|localFS
argument_list|,
name|localDir
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testLargeFilesFromRemote ()
specifier|public
name|void
name|testLargeFilesFromRemote
parameter_list|()
throws|throws
name|Exception
block|{
name|describe
argument_list|(
literal|"copy multiple large files from remote to local"
argument_list|)
expr_stmt|;
name|largeFiles
argument_list|(
name|remoteFS
argument_list|,
name|remoteDir
argument_list|,
name|localFS
argument_list|,
name|localDir
argument_list|)
expr_stmt|;
block|}
comment|/**    * Executes a DistCp using a file system sub-tree with multiple nesting    * levels.    * The filenames are those of the fields initialized in setup.    *    * @param srcFS source FileSystem    * @param srcDir source directory    * @param dstFS destination FileSystem    * @param dstDir destination directory    * @return the target directory of the copy    * @throws Exception if there is a failure    */
DECL|method|distCpDeepDirectoryStructure (FileSystem srcFS, Path srcDir, FileSystem dstFS, Path dstDir)
specifier|private
name|Path
name|distCpDeepDirectoryStructure
parameter_list|(
name|FileSystem
name|srcFS
parameter_list|,
name|Path
name|srcDir
parameter_list|,
name|FileSystem
name|dstFS
parameter_list|,
name|Path
name|dstDir
parameter_list|)
throws|throws
name|Exception
block|{
name|initPathFields
argument_list|(
name|srcDir
argument_list|,
name|dstDir
argument_list|)
expr_stmt|;
name|mkdirs
argument_list|(
name|srcFS
argument_list|,
name|inputSubDir1
argument_list|)
expr_stmt|;
name|mkdirs
argument_list|(
name|srcFS
argument_list|,
name|inputSubDir2
argument_list|)
expr_stmt|;
name|byte
index|[]
name|data1
init|=
name|dataset
argument_list|(
literal|100
argument_list|,
literal|33
argument_list|,
literal|43
argument_list|)
decl_stmt|;
name|createFile
argument_list|(
name|srcFS
argument_list|,
name|inputFile1
argument_list|,
literal|true
argument_list|,
name|data1
argument_list|)
expr_stmt|;
name|byte
index|[]
name|data2
init|=
name|dataset
argument_list|(
literal|200
argument_list|,
literal|43
argument_list|,
literal|53
argument_list|)
decl_stmt|;
name|createFile
argument_list|(
name|srcFS
argument_list|,
name|inputFile2
argument_list|,
literal|true
argument_list|,
name|data2
argument_list|)
expr_stmt|;
name|byte
index|[]
name|data3
init|=
name|dataset
argument_list|(
literal|300
argument_list|,
literal|53
argument_list|,
literal|63
argument_list|)
decl_stmt|;
name|createFile
argument_list|(
name|srcFS
argument_list|,
name|inputFile3
argument_list|,
literal|true
argument_list|,
name|data3
argument_list|)
expr_stmt|;
name|createFile
argument_list|(
name|srcFS
argument_list|,
name|inputFile4
argument_list|,
literal|true
argument_list|,
name|dataset
argument_list|(
literal|400
argument_list|,
literal|53
argument_list|,
literal|63
argument_list|)
argument_list|)
expr_stmt|;
name|createFile
argument_list|(
name|srcFS
argument_list|,
name|inputFile5
argument_list|,
literal|true
argument_list|,
name|dataset
argument_list|(
literal|500
argument_list|,
literal|53
argument_list|,
literal|63
argument_list|)
argument_list|)
expr_stmt|;
name|Path
name|target
init|=
operator|new
name|Path
argument_list|(
name|dstDir
argument_list|,
literal|"outputDir"
argument_list|)
decl_stmt|;
name|runDistCp
argument_list|(
name|inputDir
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|ContractTestUtils
operator|.
name|assertIsDirectory
argument_list|(
name|dstFS
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|lsR
argument_list|(
literal|"Destination tree after distcp"
argument_list|,
name|dstFS
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|verifyFileContents
argument_list|(
name|dstFS
argument_list|,
operator|new
name|Path
argument_list|(
name|target
argument_list|,
literal|"inputDir/file1"
argument_list|)
argument_list|,
name|data1
argument_list|)
expr_stmt|;
name|verifyFileContents
argument_list|(
name|dstFS
argument_list|,
operator|new
name|Path
argument_list|(
name|target
argument_list|,
literal|"inputDir/subDir1/file2"
argument_list|)
argument_list|,
name|data2
argument_list|)
expr_stmt|;
name|verifyFileContents
argument_list|(
name|dstFS
argument_list|,
operator|new
name|Path
argument_list|(
name|target
argument_list|,
literal|"inputDir/subDir2/subDir2/file3"
argument_list|)
argument_list|,
name|data3
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
comment|/**    * Executes a test using multiple large files.    *    * @param srcFS source FileSystem    * @param srcDir source directory    * @param dstFS destination FileSystem    * @param dstDir destination directory    * @throws Exception if there is a failure    */
DECL|method|largeFiles (FileSystem srcFS, Path srcDir, FileSystem dstFS, Path dstDir)
specifier|private
name|void
name|largeFiles
parameter_list|(
name|FileSystem
name|srcFS
parameter_list|,
name|Path
name|srcDir
parameter_list|,
name|FileSystem
name|dstFS
parameter_list|,
name|Path
name|dstDir
parameter_list|)
throws|throws
name|Exception
block|{
name|initPathFields
argument_list|(
name|srcDir
argument_list|,
name|dstDir
argument_list|)
expr_stmt|;
name|Path
name|largeFile1
init|=
operator|new
name|Path
argument_list|(
name|inputDir
argument_list|,
literal|"file1"
argument_list|)
decl_stmt|;
name|Path
name|largeFile2
init|=
operator|new
name|Path
argument_list|(
name|inputDir
argument_list|,
literal|"file2"
argument_list|)
decl_stmt|;
name|Path
name|largeFile3
init|=
operator|new
name|Path
argument_list|(
name|inputDir
argument_list|,
literal|"file3"
argument_list|)
decl_stmt|;
name|mkdirs
argument_list|(
name|srcFS
argument_list|,
name|inputDir
argument_list|)
expr_stmt|;
name|int
name|fileSizeKb
init|=
name|conf
operator|.
name|getInt
argument_list|(
name|SCALE_TEST_DISTCP_FILE_SIZE_KB
argument_list|,
name|DEFAULT_DISTCP_SIZE_KB
argument_list|)
decl_stmt|;
name|int
name|fileSizeMb
init|=
name|fileSizeKb
operator|/
literal|1024
decl_stmt|;
name|getLogger
argument_list|()
operator|.
name|info
argument_list|(
literal|"{} with file size {}"
argument_list|,
name|testName
operator|.
name|getMethodName
argument_list|()
argument_list|,
name|fileSizeMb
argument_list|)
expr_stmt|;
name|byte
index|[]
name|data1
init|=
name|dataset
argument_list|(
operator|(
name|fileSizeMb
operator|+
literal|1
operator|)
operator|*
name|MB
argument_list|,
literal|33
argument_list|,
literal|43
argument_list|)
decl_stmt|;
name|createFile
argument_list|(
name|srcFS
argument_list|,
name|largeFile1
argument_list|,
literal|true
argument_list|,
name|data1
argument_list|)
expr_stmt|;
name|byte
index|[]
name|data2
init|=
name|dataset
argument_list|(
operator|(
name|fileSizeMb
operator|+
literal|2
operator|)
operator|*
name|MB
argument_list|,
literal|43
argument_list|,
literal|53
argument_list|)
decl_stmt|;
name|createFile
argument_list|(
name|srcFS
argument_list|,
name|largeFile2
argument_list|,
literal|true
argument_list|,
name|data2
argument_list|)
expr_stmt|;
name|byte
index|[]
name|data3
init|=
name|dataset
argument_list|(
operator|(
name|fileSizeMb
operator|+
literal|3
operator|)
operator|*
name|MB
argument_list|,
literal|53
argument_list|,
literal|63
argument_list|)
decl_stmt|;
name|createFile
argument_list|(
name|srcFS
argument_list|,
name|largeFile3
argument_list|,
literal|true
argument_list|,
name|data3
argument_list|)
expr_stmt|;
name|Path
name|target
init|=
operator|new
name|Path
argument_list|(
name|dstDir
argument_list|,
literal|"outputDir"
argument_list|)
decl_stmt|;
name|runDistCp
argument_list|(
name|inputDir
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|ContractTestUtils
operator|.
name|assertIsDirectory
argument_list|(
name|dstFS
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|verifyFileContents
argument_list|(
name|dstFS
argument_list|,
operator|new
name|Path
argument_list|(
name|target
argument_list|,
literal|"inputDir/file1"
argument_list|)
argument_list|,
name|data1
argument_list|)
expr_stmt|;
name|verifyFileContents
argument_list|(
name|dstFS
argument_list|,
operator|new
name|Path
argument_list|(
name|target
argument_list|,
literal|"inputDir/file2"
argument_list|)
argument_list|,
name|data2
argument_list|)
expr_stmt|;
name|verifyFileContents
argument_list|(
name|dstFS
argument_list|,
operator|new
name|Path
argument_list|(
name|target
argument_list|,
literal|"inputDir/file3"
argument_list|)
argument_list|,
name|data3
argument_list|)
expr_stmt|;
block|}
comment|/**    * Executes DistCp and asserts that the job finished successfully.    *    * @param src source path    * @param dst destination path    * @throws Exception if there is a failure    */
DECL|method|runDistCp (Path src, Path dst)
specifier|private
name|void
name|runDistCp
parameter_list|(
name|Path
name|src
parameter_list|,
name|Path
name|dst
parameter_list|)
throws|throws
name|Exception
block|{
name|runDistCp
argument_list|(
name|buildWithStandardOptions
argument_list|(
operator|new
name|DistCpOptions
operator|.
name|Builder
argument_list|(
name|Collections
operator|.
name|singletonList
argument_list|(
name|src
argument_list|)
argument_list|,
name|dst
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Run the distcp job.    * @param optons distcp options    * @return the job. It will have already completed.    * @throws Exception failure    */
DECL|method|runDistCp (final DistCpOptions options)
specifier|private
name|Job
name|runDistCp
parameter_list|(
specifier|final
name|DistCpOptions
name|options
parameter_list|)
throws|throws
name|Exception
block|{
name|Job
name|job
init|=
operator|new
name|DistCp
argument_list|(
name|conf
argument_list|,
name|options
argument_list|)
operator|.
name|execute
argument_list|()
decl_stmt|;
name|assertNotNull
argument_list|(
literal|"Unexpected null job returned from DistCp execution."
argument_list|,
name|job
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"DistCp job did not complete."
argument_list|,
name|job
operator|.
name|isComplete
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"DistCp job did not complete successfully."
argument_list|,
name|job
operator|.
name|isSuccessful
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|job
return|;
block|}
comment|/**    * Add any standard options and then build.    * @param builder DistCp option builder    * @return the build options    */
DECL|method|buildWithStandardOptions ( DistCpOptions.Builder builder)
specifier|private
name|DistCpOptions
name|buildWithStandardOptions
parameter_list|(
name|DistCpOptions
operator|.
name|Builder
name|builder
parameter_list|)
block|{
return|return
name|builder
operator|.
name|withNumListstatusThreads
argument_list|(
name|DistCpOptions
operator|.
name|MAX_NUM_LISTSTATUS_THREADS
argument_list|)
operator|.
name|build
argument_list|()
return|;
block|}
comment|/**    * Creates a directory and any ancestor directories required.    *    * @param fs FileSystem in which to create directories    * @param dir path of directory to create    * @throws Exception if there is a failure    */
DECL|method|mkdirs (FileSystem fs, Path dir)
specifier|private
specifier|static
name|void
name|mkdirs
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Path
name|dir
parameter_list|)
throws|throws
name|Exception
block|{
name|assertTrue
argument_list|(
literal|"Failed to mkdir "
operator|+
name|dir
argument_list|,
name|fs
operator|.
name|mkdirs
argument_list|(
name|dir
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_class

end_unit

