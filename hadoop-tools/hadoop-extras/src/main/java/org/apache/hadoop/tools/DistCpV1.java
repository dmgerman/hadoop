begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.tools
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|tools
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|BufferedReader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataInput
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataOutput
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileNotFoundException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStreamReader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|Charset
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|EnumSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Random
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Stack
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|StringTokenizer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FSDataInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FSDataOutputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileAlreadyExistsException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileChecksum
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Trash
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|permission
operator|.
name|FsPermission
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|QuotaExceededException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|LongWritable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|NullWritable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|SequenceFile
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|SequenceFile
operator|.
name|Reader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|Text
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|Writable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|WritableComparable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|SequenceFile
operator|.
name|Writer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|RemoteException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|FileOutputFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|FileSplit
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|InputFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|InputSplit
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|InvalidInputException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|JobClient
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|JobConf
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|Mapper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|OutputCollector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|RecordReader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|Reporter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|SequenceFileRecordReader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|JobSubmissionFiles
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|security
operator|.
name|TokenCache
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|AccessControlException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Tool
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|ToolRunner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
operator|.
name|TraditionalBinaryPrefix
import|;
end_import

begin_comment
comment|/**  * A Map-reduce program to recursively copy directories between  * different file-systems.  */
end_comment

begin_class
DECL|class|DistCpV1
specifier|public
class|class
name|DistCpV1
implements|implements
name|Tool
block|{
DECL|field|LOG
specifier|public
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|DistCpV1
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|NAME
specifier|private
specifier|static
specifier|final
name|String
name|NAME
init|=
literal|"distcp"
decl_stmt|;
DECL|field|usage
specifier|private
specifier|static
specifier|final
name|String
name|usage
init|=
name|NAME
operator|+
literal|" [OPTIONS]<srcurl>*<desturl>"
operator|+
literal|"\n\nOPTIONS:"
operator|+
literal|"\n-p[rbugpt]             Preserve status"
operator|+
literal|"\n                       r: replication number"
operator|+
literal|"\n                       b: block size"
operator|+
literal|"\n                       u: user"
operator|+
literal|"\n                       g: group"
operator|+
literal|"\n                       p: permission"
operator|+
literal|"\n                       t: modification and access times"
operator|+
literal|"\n                       -p alone is equivalent to -prbugpt"
operator|+
literal|"\n-i                     Ignore failures"
operator|+
literal|"\n-basedir<basedir>     Use<basedir> as the base directory when copying files from<srcurl>"
operator|+
literal|"\n-log<logdir>          Write logs to<logdir>"
operator|+
literal|"\n-m<num_maps>          Maximum number of simultaneous copies"
operator|+
literal|"\n-overwrite             Overwrite destination"
operator|+
literal|"\n-update                Overwrite if src size different from dst size"
operator|+
literal|"\n-skipcrccheck          Do not use CRC check to determine if src is "
operator|+
literal|"\n                       different from dest. Relevant only if -update"
operator|+
literal|"\n                       is specified"
operator|+
literal|"\n-f<urilist_uri>       Use list at<urilist_uri> as src list"
operator|+
literal|"\n-filelimit<n>         Limit the total number of files to be<= n"
operator|+
literal|"\n-sizelimit<n>         Limit the total size to be<= n bytes"
operator|+
literal|"\n-delete                Delete the files existing in the dst but not in src"
operator|+
literal|"\n-dryrun                Display count of files and total size of files"
operator|+
literal|"\n                        in src and then exit. Copy is not done at all."
operator|+
literal|"\n                        desturl should not be speicified with out -update."
operator|+
literal|"\n-mapredSslConf<f>     Filename of SSL configuration for mapper task"
operator|+
literal|"\n\nNOTE 1: if -overwrite or -update are set, each source URI is "
operator|+
literal|"\n      interpreted as an isomorphic update to an existing directory."
operator|+
literal|"\nFor example:"
operator|+
literal|"\nhadoop "
operator|+
name|NAME
operator|+
literal|" -p -update \"hdfs://A:8020/user/foo/bar\" "
operator|+
literal|"\"hdfs://B:8020/user/foo/baz\"\n"
operator|+
literal|"\n     would update all descendants of 'baz' also in 'bar'; it would "
operator|+
literal|"\n     *not* update /user/foo/baz/bar"
operator|+
literal|"\n\nNOTE 2: The parameter<n> in -filelimit and -sizelimit can be "
operator|+
literal|"\n     specified with symbolic representation.  For examples,"
operator|+
literal|"\n       1230k = 1230 * 1024 = 1259520"
operator|+
literal|"\n       891g = 891 * 1024^3 = 956703965184"
operator|+
literal|"\n"
decl_stmt|;
DECL|field|BYTES_PER_MAP
specifier|private
specifier|static
specifier|final
name|long
name|BYTES_PER_MAP
init|=
literal|256
operator|*
literal|1024
operator|*
literal|1024
decl_stmt|;
DECL|field|MAX_MAPS_PER_NODE
specifier|private
specifier|static
specifier|final
name|int
name|MAX_MAPS_PER_NODE
init|=
literal|20
decl_stmt|;
DECL|field|SYNC_FILE_MAX
specifier|private
specifier|static
specifier|final
name|int
name|SYNC_FILE_MAX
init|=
literal|10
decl_stmt|;
DECL|field|DEFAULT_FILE_RETRIES
specifier|private
specifier|static
specifier|final
name|int
name|DEFAULT_FILE_RETRIES
init|=
literal|3
decl_stmt|;
DECL|enum|Counter
DECL|enumConstant|COPY
DECL|enumConstant|SKIP
DECL|enumConstant|FAIL
DECL|enumConstant|BYTESCOPIED
DECL|enumConstant|BYTESEXPECTED
specifier|static
enum|enum
name|Counter
block|{
name|COPY
block|,
name|SKIP
block|,
name|FAIL
block|,
name|BYTESCOPIED
block|,
name|BYTESEXPECTED
block|}
DECL|enum|Options
specifier|static
enum|enum
name|Options
block|{
DECL|enumConstant|DELETE
name|DELETE
argument_list|(
literal|"-delete"
argument_list|,
name|NAME
operator|+
literal|".delete"
argument_list|)
block|,
DECL|enumConstant|FILE_LIMIT
name|FILE_LIMIT
argument_list|(
literal|"-filelimit"
argument_list|,
name|NAME
operator|+
literal|".limit.file"
argument_list|)
block|,
DECL|enumConstant|SIZE_LIMIT
name|SIZE_LIMIT
argument_list|(
literal|"-sizelimit"
argument_list|,
name|NAME
operator|+
literal|".limit.size"
argument_list|)
block|,
DECL|enumConstant|IGNORE_READ_FAILURES
name|IGNORE_READ_FAILURES
argument_list|(
literal|"-i"
argument_list|,
name|NAME
operator|+
literal|".ignore.read.failures"
argument_list|)
block|,
DECL|enumConstant|PRESERVE_STATUS
name|PRESERVE_STATUS
argument_list|(
literal|"-p"
argument_list|,
name|NAME
operator|+
literal|".preserve.status"
argument_list|)
block|,
DECL|enumConstant|OVERWRITE
name|OVERWRITE
argument_list|(
literal|"-overwrite"
argument_list|,
name|NAME
operator|+
literal|".overwrite.always"
argument_list|)
block|,
DECL|enumConstant|UPDATE
name|UPDATE
argument_list|(
literal|"-update"
argument_list|,
name|NAME
operator|+
literal|".overwrite.ifnewer"
argument_list|)
block|,
DECL|enumConstant|SKIPCRC
name|SKIPCRC
argument_list|(
literal|"-skipcrccheck"
argument_list|,
name|NAME
operator|+
literal|".skip.crc.check"
argument_list|)
block|;
DECL|field|cmd
DECL|field|propertyname
specifier|final
name|String
name|cmd
block|,
name|propertyname
block|;
DECL|method|Options (String cmd, String propertyname)
specifier|private
name|Options
parameter_list|(
name|String
name|cmd
parameter_list|,
name|String
name|propertyname
parameter_list|)
block|{
name|this
operator|.
name|cmd
operator|=
name|cmd
expr_stmt|;
name|this
operator|.
name|propertyname
operator|=
name|propertyname
expr_stmt|;
block|}
DECL|method|parseLong (String[] args, int offset)
specifier|private
name|long
name|parseLong
parameter_list|(
name|String
index|[]
name|args
parameter_list|,
name|int
name|offset
parameter_list|)
block|{
if|if
condition|(
name|offset
operator|==
name|args
operator|.
name|length
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"<n> not specified in "
operator|+
name|cmd
argument_list|)
throw|;
block|}
name|long
name|n
init|=
name|StringUtils
operator|.
name|TraditionalBinaryPrefix
operator|.
name|string2long
argument_list|(
name|args
index|[
name|offset
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|<=
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"n = "
operator|+
name|n
operator|+
literal|"<= 0 in "
operator|+
name|cmd
argument_list|)
throw|;
block|}
return|return
name|n
return|;
block|}
block|}
DECL|enum|FileAttribute
specifier|static
enum|enum
name|FileAttribute
block|{
DECL|enumConstant|BLOCK_SIZE
DECL|enumConstant|REPLICATION
DECL|enumConstant|USER
DECL|enumConstant|GROUP
DECL|enumConstant|PERMISSION
DECL|enumConstant|TIMES
name|BLOCK_SIZE
block|,
name|REPLICATION
block|,
name|USER
block|,
name|GROUP
block|,
name|PERMISSION
block|,
name|TIMES
block|;
DECL|field|symbol
specifier|final
name|char
name|symbol
decl_stmt|;
DECL|method|FileAttribute ()
specifier|private
name|FileAttribute
parameter_list|()
block|{
name|symbol
operator|=
name|StringUtils
operator|.
name|toLowerCase
argument_list|(
name|toString
argument_list|()
argument_list|)
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
DECL|method|parse (String s)
specifier|static
name|EnumSet
argument_list|<
name|FileAttribute
argument_list|>
name|parse
parameter_list|(
name|String
name|s
parameter_list|)
block|{
if|if
condition|(
name|s
operator|==
literal|null
operator|||
name|s
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
name|EnumSet
operator|.
name|allOf
argument_list|(
name|FileAttribute
operator|.
name|class
argument_list|)
return|;
block|}
name|EnumSet
argument_list|<
name|FileAttribute
argument_list|>
name|set
init|=
name|EnumSet
operator|.
name|noneOf
argument_list|(
name|FileAttribute
operator|.
name|class
argument_list|)
decl_stmt|;
name|FileAttribute
index|[]
name|attributes
init|=
name|values
argument_list|()
decl_stmt|;
for|for
control|(
name|char
name|c
range|:
name|s
operator|.
name|toCharArray
argument_list|()
control|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|attributes
operator|.
name|length
operator|&&
name|c
operator|!=
name|attributes
index|[
name|i
index|]
operator|.
name|symbol
condition|;
name|i
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|i
operator|<
name|attributes
operator|.
name|length
condition|)
block|{
if|if
condition|(
operator|!
name|set
operator|.
name|contains
argument_list|(
name|attributes
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|set
operator|.
name|add
argument_list|(
name|attributes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"There are more than one '"
operator|+
name|attributes
index|[
name|i
index|]
operator|.
name|symbol
operator|+
literal|"' in "
operator|+
name|s
argument_list|)
throw|;
block|}
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"'"
operator|+
name|c
operator|+
literal|"' in "
operator|+
name|s
operator|+
literal|" is undefined."
argument_list|)
throw|;
block|}
block|}
return|return
name|set
return|;
block|}
block|}
DECL|field|TMP_DIR_LABEL
specifier|static
specifier|final
name|String
name|TMP_DIR_LABEL
init|=
name|NAME
operator|+
literal|".tmp.dir"
decl_stmt|;
DECL|field|DST_DIR_LABEL
specifier|static
specifier|final
name|String
name|DST_DIR_LABEL
init|=
name|NAME
operator|+
literal|".dest.path"
decl_stmt|;
DECL|field|JOB_DIR_LABEL
specifier|static
specifier|final
name|String
name|JOB_DIR_LABEL
init|=
name|NAME
operator|+
literal|".job.dir"
decl_stmt|;
DECL|field|MAX_MAPS_LABEL
specifier|static
specifier|final
name|String
name|MAX_MAPS_LABEL
init|=
name|NAME
operator|+
literal|".max.map.tasks"
decl_stmt|;
DECL|field|SRC_LIST_LABEL
specifier|static
specifier|final
name|String
name|SRC_LIST_LABEL
init|=
name|NAME
operator|+
literal|".src.list"
decl_stmt|;
DECL|field|SRC_COUNT_LABEL
specifier|static
specifier|final
name|String
name|SRC_COUNT_LABEL
init|=
name|NAME
operator|+
literal|".src.count"
decl_stmt|;
DECL|field|TOTAL_SIZE_LABEL
specifier|static
specifier|final
name|String
name|TOTAL_SIZE_LABEL
init|=
name|NAME
operator|+
literal|".total.size"
decl_stmt|;
DECL|field|DST_DIR_LIST_LABEL
specifier|static
specifier|final
name|String
name|DST_DIR_LIST_LABEL
init|=
name|NAME
operator|+
literal|".dst.dir.list"
decl_stmt|;
DECL|field|BYTES_PER_MAP_LABEL
specifier|static
specifier|final
name|String
name|BYTES_PER_MAP_LABEL
init|=
name|NAME
operator|+
literal|".bytes.per.map"
decl_stmt|;
DECL|field|PRESERVE_STATUS_LABEL
specifier|static
specifier|final
name|String
name|PRESERVE_STATUS_LABEL
init|=
name|Options
operator|.
name|PRESERVE_STATUS
operator|.
name|propertyname
operator|+
literal|".value"
decl_stmt|;
DECL|field|FILE_RETRIES_LABEL
specifier|static
specifier|final
name|String
name|FILE_RETRIES_LABEL
init|=
name|NAME
operator|+
literal|".file.retries"
decl_stmt|;
DECL|field|conf
specifier|private
name|JobConf
name|conf
decl_stmt|;
DECL|method|setConf (Configuration conf)
specifier|public
name|void
name|setConf
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
if|if
condition|(
name|conf
operator|instanceof
name|JobConf
condition|)
block|{
name|this
operator|.
name|conf
operator|=
operator|(
name|JobConf
operator|)
name|conf
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|conf
operator|=
operator|new
name|JobConf
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|getConf ()
specifier|public
name|Configuration
name|getConf
parameter_list|()
block|{
return|return
name|conf
return|;
block|}
DECL|method|DistCpV1 (Configuration conf)
specifier|public
name|DistCpV1
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
name|setConf
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
comment|/**    * An input/output pair of filenames.    */
DECL|class|FilePair
specifier|static
class|class
name|FilePair
implements|implements
name|Writable
block|{
DECL|field|input
name|FileStatus
name|input
init|=
operator|new
name|FileStatus
argument_list|()
decl_stmt|;
DECL|field|output
name|String
name|output
decl_stmt|;
DECL|method|FilePair ()
name|FilePair
parameter_list|()
block|{ }
DECL|method|FilePair (FileStatus input, String output)
name|FilePair
parameter_list|(
name|FileStatus
name|input
parameter_list|,
name|String
name|output
parameter_list|)
block|{
name|this
operator|.
name|input
operator|=
name|input
expr_stmt|;
name|this
operator|.
name|output
operator|=
name|output
expr_stmt|;
block|}
DECL|method|readFields (DataInput in)
specifier|public
name|void
name|readFields
parameter_list|(
name|DataInput
name|in
parameter_list|)
throws|throws
name|IOException
block|{
name|input
operator|.
name|readFields
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|output
operator|=
name|Text
operator|.
name|readString
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
DECL|method|write (DataOutput out)
specifier|public
name|void
name|write
parameter_list|(
name|DataOutput
name|out
parameter_list|)
throws|throws
name|IOException
block|{
name|input
operator|.
name|write
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|Text
operator|.
name|writeString
argument_list|(
name|out
argument_list|,
name|output
argument_list|)
expr_stmt|;
block|}
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|input
operator|+
literal|" : "
operator|+
name|output
return|;
block|}
block|}
comment|/**    * InputFormat of a distcp job responsible for generating splits of the src    * file list.    */
DECL|class|CopyInputFormat
specifier|static
class|class
name|CopyInputFormat
implements|implements
name|InputFormat
argument_list|<
name|Text
argument_list|,
name|Text
argument_list|>
block|{
comment|/**      * Produce splits such that each is no greater than the quotient of the      * total size and the number of splits requested.      * @param job The handle to the JobConf object      * @param numSplits Number of splits requested      */
DECL|method|getSplits (JobConf job, int numSplits)
specifier|public
name|InputSplit
index|[]
name|getSplits
parameter_list|(
name|JobConf
name|job
parameter_list|,
name|int
name|numSplits
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|cnfiles
init|=
name|job
operator|.
name|getInt
argument_list|(
name|SRC_COUNT_LABEL
argument_list|,
operator|-
literal|1
argument_list|)
decl_stmt|;
name|long
name|cbsize
init|=
name|job
operator|.
name|getLong
argument_list|(
name|TOTAL_SIZE_LABEL
argument_list|,
operator|-
literal|1
argument_list|)
decl_stmt|;
name|String
name|srcfilelist
init|=
name|job
operator|.
name|get
argument_list|(
name|SRC_LIST_LABEL
argument_list|,
literal|""
argument_list|)
decl_stmt|;
if|if
condition|(
name|cnfiles
operator|<
literal|0
operator|||
name|cbsize
operator|<
literal|0
operator|||
literal|""
operator|.
name|equals
argument_list|(
name|srcfilelist
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Invalid metadata: #files("
operator|+
name|cnfiles
operator|+
literal|") total_size("
operator|+
name|cbsize
operator|+
literal|") listuri("
operator|+
name|srcfilelist
operator|+
literal|")"
argument_list|)
throw|;
block|}
name|Path
name|src
init|=
operator|new
name|Path
argument_list|(
name|srcfilelist
argument_list|)
decl_stmt|;
name|FileSystem
name|fs
init|=
name|src
operator|.
name|getFileSystem
argument_list|(
name|job
argument_list|)
decl_stmt|;
name|FileStatus
name|srcst
init|=
name|fs
operator|.
name|getFileStatus
argument_list|(
name|src
argument_list|)
decl_stmt|;
name|ArrayList
argument_list|<
name|FileSplit
argument_list|>
name|splits
init|=
operator|new
name|ArrayList
argument_list|<
name|FileSplit
argument_list|>
argument_list|(
name|numSplits
argument_list|)
decl_stmt|;
name|LongWritable
name|key
init|=
operator|new
name|LongWritable
argument_list|()
decl_stmt|;
name|FilePair
name|value
init|=
operator|new
name|FilePair
argument_list|()
decl_stmt|;
specifier|final
name|long
name|targetsize
init|=
name|cbsize
operator|/
name|numSplits
decl_stmt|;
name|long
name|pos
init|=
literal|0L
decl_stmt|;
name|long
name|last
init|=
literal|0L
decl_stmt|;
name|long
name|acc
init|=
literal|0L
decl_stmt|;
name|long
name|cbrem
init|=
name|srcst
operator|.
name|getLen
argument_list|()
decl_stmt|;
try|try
init|(
name|SequenceFile
operator|.
name|Reader
name|sl
init|=
operator|new
name|SequenceFile
operator|.
name|Reader
argument_list|(
name|job
argument_list|,
name|Reader
operator|.
name|file
argument_list|(
name|src
argument_list|)
argument_list|)
init|)
block|{
for|for
control|(
init|;
name|sl
operator|.
name|next
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
condition|;
name|last
operator|=
name|sl
operator|.
name|getPosition
argument_list|()
control|)
block|{
comment|// if adding this split would put this split past the target size,
comment|// cut the last split and put this next file in the next split.
if|if
condition|(
name|acc
operator|+
name|key
operator|.
name|get
argument_list|()
operator|>
name|targetsize
operator|&&
name|acc
operator|!=
literal|0
condition|)
block|{
name|long
name|splitsize
init|=
name|last
operator|-
name|pos
decl_stmt|;
name|splits
operator|.
name|add
argument_list|(
operator|new
name|FileSplit
argument_list|(
name|src
argument_list|,
name|pos
argument_list|,
name|splitsize
argument_list|,
operator|(
name|String
index|[]
operator|)
literal|null
argument_list|)
argument_list|)
expr_stmt|;
name|cbrem
operator|-=
name|splitsize
expr_stmt|;
name|pos
operator|=
name|last
expr_stmt|;
name|acc
operator|=
literal|0L
expr_stmt|;
block|}
name|acc
operator|+=
name|key
operator|.
name|get
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cbrem
operator|!=
literal|0
condition|)
block|{
name|splits
operator|.
name|add
argument_list|(
operator|new
name|FileSplit
argument_list|(
name|src
argument_list|,
name|pos
argument_list|,
name|cbrem
argument_list|,
operator|(
name|String
index|[]
operator|)
literal|null
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|splits
operator|.
name|toArray
argument_list|(
operator|new
name|FileSplit
index|[
name|splits
operator|.
name|size
argument_list|()
index|]
argument_list|)
return|;
block|}
comment|/**      * Returns a reader for this split of the src file list.      */
DECL|method|getRecordReader (InputSplit split, JobConf job, Reporter reporter)
specifier|public
name|RecordReader
argument_list|<
name|Text
argument_list|,
name|Text
argument_list|>
name|getRecordReader
parameter_list|(
name|InputSplit
name|split
parameter_list|,
name|JobConf
name|job
parameter_list|,
name|Reporter
name|reporter
parameter_list|)
throws|throws
name|IOException
block|{
return|return
operator|new
name|SequenceFileRecordReader
argument_list|<
name|Text
argument_list|,
name|Text
argument_list|>
argument_list|(
name|job
argument_list|,
operator|(
name|FileSplit
operator|)
name|split
argument_list|)
return|;
block|}
block|}
comment|/**    * FSCopyFilesMapper: The mapper for copying files between FileSystems.    */
DECL|class|CopyFilesMapper
specifier|static
class|class
name|CopyFilesMapper
implements|implements
name|Mapper
argument_list|<
name|LongWritable
argument_list|,
name|FilePair
argument_list|,
name|WritableComparable
argument_list|<
name|?
argument_list|>
argument_list|,
name|Text
argument_list|>
block|{
comment|// config
DECL|field|sizeBuf
specifier|private
name|int
name|sizeBuf
init|=
literal|128
operator|*
literal|1024
decl_stmt|;
DECL|field|destFileSys
specifier|private
name|FileSystem
name|destFileSys
init|=
literal|null
decl_stmt|;
DECL|field|ignoreReadFailures
specifier|private
name|boolean
name|ignoreReadFailures
decl_stmt|;
DECL|field|preserve_status
specifier|private
name|boolean
name|preserve_status
decl_stmt|;
DECL|field|preseved
specifier|private
name|EnumSet
argument_list|<
name|FileAttribute
argument_list|>
name|preseved
decl_stmt|;
DECL|field|overwrite
specifier|private
name|boolean
name|overwrite
decl_stmt|;
DECL|field|update
specifier|private
name|boolean
name|update
decl_stmt|;
DECL|field|destPath
specifier|private
name|Path
name|destPath
init|=
literal|null
decl_stmt|;
DECL|field|buffer
specifier|private
name|byte
index|[]
name|buffer
init|=
literal|null
decl_stmt|;
DECL|field|job
specifier|private
name|JobConf
name|job
decl_stmt|;
DECL|field|skipCRCCheck
specifier|private
name|boolean
name|skipCRCCheck
init|=
literal|false
decl_stmt|;
comment|// stats
DECL|field|failcount
specifier|private
name|int
name|failcount
init|=
literal|0
decl_stmt|;
DECL|field|skipcount
specifier|private
name|int
name|skipcount
init|=
literal|0
decl_stmt|;
DECL|field|copycount
specifier|private
name|int
name|copycount
init|=
literal|0
decl_stmt|;
DECL|method|getCountString ()
specifier|private
name|String
name|getCountString
parameter_list|()
block|{
return|return
literal|"Copied: "
operator|+
name|copycount
operator|+
literal|" Skipped: "
operator|+
name|skipcount
operator|+
literal|" Failed: "
operator|+
name|failcount
return|;
block|}
DECL|method|updateStatus (Reporter reporter)
specifier|private
name|void
name|updateStatus
parameter_list|(
name|Reporter
name|reporter
parameter_list|)
block|{
name|reporter
operator|.
name|setStatus
argument_list|(
name|getCountString
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**      * Return true if dst should be replaced by src and the update flag is set.      * Right now, this merely checks that the src and dst len are not equal.       * This should be improved on once modification times, CRCs, etc. can      * be meaningful in this context.      * @throws IOException       */
DECL|method|needsUpdate (FileStatus srcstatus, FileSystem dstfs, Path dstpath)
specifier|private
name|boolean
name|needsUpdate
parameter_list|(
name|FileStatus
name|srcstatus
parameter_list|,
name|FileSystem
name|dstfs
parameter_list|,
name|Path
name|dstpath
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|update
operator|&&
operator|!
name|sameFile
argument_list|(
name|srcstatus
operator|.
name|getPath
argument_list|()
operator|.
name|getFileSystem
argument_list|(
name|job
argument_list|)
argument_list|,
name|srcstatus
argument_list|,
name|dstfs
argument_list|,
name|dstpath
argument_list|,
name|skipCRCCheck
argument_list|)
return|;
block|}
DECL|method|create (Path f, Reporter reporter, FileStatus srcstat)
specifier|private
name|FSDataOutputStream
name|create
parameter_list|(
name|Path
name|f
parameter_list|,
name|Reporter
name|reporter
parameter_list|,
name|FileStatus
name|srcstat
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|destFileSys
operator|.
name|exists
argument_list|(
name|f
argument_list|)
condition|)
block|{
name|destFileSys
operator|.
name|delete
argument_list|(
name|f
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|preserve_status
condition|)
block|{
return|return
name|destFileSys
operator|.
name|create
argument_list|(
name|f
argument_list|,
literal|true
argument_list|,
name|sizeBuf
argument_list|,
name|reporter
argument_list|)
return|;
block|}
name|FsPermission
name|permission
init|=
name|preseved
operator|.
name|contains
argument_list|(
name|FileAttribute
operator|.
name|PERMISSION
argument_list|)
condition|?
name|srcstat
operator|.
name|getPermission
argument_list|()
else|:
literal|null
decl_stmt|;
name|short
name|replication
init|=
name|preseved
operator|.
name|contains
argument_list|(
name|FileAttribute
operator|.
name|REPLICATION
argument_list|)
condition|?
name|srcstat
operator|.
name|getReplication
argument_list|()
else|:
name|destFileSys
operator|.
name|getDefaultReplication
argument_list|(
name|f
argument_list|)
decl_stmt|;
name|long
name|blockSize
init|=
name|preseved
operator|.
name|contains
argument_list|(
name|FileAttribute
operator|.
name|BLOCK_SIZE
argument_list|)
condition|?
name|srcstat
operator|.
name|getBlockSize
argument_list|()
else|:
name|destFileSys
operator|.
name|getDefaultBlockSize
argument_list|(
name|f
argument_list|)
decl_stmt|;
return|return
name|destFileSys
operator|.
name|create
argument_list|(
name|f
argument_list|,
name|permission
argument_list|,
literal|true
argument_list|,
name|sizeBuf
argument_list|,
name|replication
argument_list|,
name|blockSize
argument_list|,
name|reporter
argument_list|)
return|;
block|}
comment|/**      * Validates copy by checking the sizes of files first and then      * checksums, if the filesystems support checksums.      * @param srcstat src path and metadata      * @param absdst dst path      * @return true if src& destination files are same      */
DECL|method|validateCopy (FileStatus srcstat, Path absdst)
specifier|private
name|boolean
name|validateCopy
parameter_list|(
name|FileStatus
name|srcstat
parameter_list|,
name|Path
name|absdst
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|destFileSys
operator|.
name|exists
argument_list|(
name|absdst
argument_list|)
condition|)
block|{
if|if
condition|(
name|sameFile
argument_list|(
name|srcstat
operator|.
name|getPath
argument_list|()
operator|.
name|getFileSystem
argument_list|(
name|job
argument_list|)
argument_list|,
name|srcstat
argument_list|,
name|destFileSys
argument_list|,
name|absdst
argument_list|,
name|skipCRCCheck
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/**      * Increment number of files copied and bytes copied and then report status      */
DECL|method|updateCopyStatus (FileStatus srcstat, Reporter reporter)
name|void
name|updateCopyStatus
parameter_list|(
name|FileStatus
name|srcstat
parameter_list|,
name|Reporter
name|reporter
parameter_list|)
block|{
name|copycount
operator|++
expr_stmt|;
name|reporter
operator|.
name|incrCounter
argument_list|(
name|Counter
operator|.
name|BYTESCOPIED
argument_list|,
name|srcstat
operator|.
name|getLen
argument_list|()
argument_list|)
expr_stmt|;
name|reporter
operator|.
name|incrCounter
argument_list|(
name|Counter
operator|.
name|COPY
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|updateStatus
argument_list|(
name|reporter
argument_list|)
expr_stmt|;
block|}
comment|/**      * Skip copying this file if already exists at the destination.      * Updates counters and copy status if skipping this file.      * @return true    if copy of this file can be skipped      */
DECL|method|skipCopyFile (FileStatus srcstat, Path absdst, OutputCollector<WritableComparable<?>, Text> outc, Reporter reporter)
specifier|private
name|boolean
name|skipCopyFile
parameter_list|(
name|FileStatus
name|srcstat
parameter_list|,
name|Path
name|absdst
parameter_list|,
name|OutputCollector
argument_list|<
name|WritableComparable
argument_list|<
name|?
argument_list|>
argument_list|,
name|Text
argument_list|>
name|outc
parameter_list|,
name|Reporter
name|reporter
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|destFileSys
operator|.
name|exists
argument_list|(
name|absdst
argument_list|)
operator|&&
operator|!
name|overwrite
operator|&&
operator|!
name|needsUpdate
argument_list|(
name|srcstat
argument_list|,
name|destFileSys
argument_list|,
name|absdst
argument_list|)
condition|)
block|{
name|outc
operator|.
name|collect
argument_list|(
literal|null
argument_list|,
operator|new
name|Text
argument_list|(
literal|"SKIP: "
operator|+
name|srcstat
operator|.
name|getPath
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|skipcount
expr_stmt|;
name|reporter
operator|.
name|incrCounter
argument_list|(
name|Counter
operator|.
name|SKIP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|updateStatus
argument_list|(
name|reporter
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
comment|/**      * Copies single file to the path specified by tmpfile.      * @param srcstat  src path and metadata      * @param tmpfile  temporary file to which copy is to be done      * @param absdst   actual destination path to which copy is to be done      * @param reporter      * @return Number of bytes copied      */
DECL|method|doCopyFile (FileStatus srcstat, Path tmpfile, Path absdst, Reporter reporter)
specifier|private
name|long
name|doCopyFile
parameter_list|(
name|FileStatus
name|srcstat
parameter_list|,
name|Path
name|tmpfile
parameter_list|,
name|Path
name|absdst
parameter_list|,
name|Reporter
name|reporter
parameter_list|)
throws|throws
name|IOException
block|{
name|long
name|bytesCopied
init|=
literal|0L
decl_stmt|;
name|Path
name|srcPath
init|=
name|srcstat
operator|.
name|getPath
argument_list|()
decl_stmt|;
comment|// open src file
try|try
init|(
name|FSDataInputStream
name|in
init|=
name|srcPath
operator|.
name|getFileSystem
argument_list|(
name|job
argument_list|)
operator|.
name|open
argument_list|(
name|srcPath
argument_list|)
init|)
block|{
name|reporter
operator|.
name|incrCounter
argument_list|(
name|Counter
operator|.
name|BYTESEXPECTED
argument_list|,
name|srcstat
operator|.
name|getLen
argument_list|()
argument_list|)
expr_stmt|;
comment|// open tmp file
try|try
init|(
name|FSDataOutputStream
name|out
init|=
name|create
argument_list|(
name|tmpfile
argument_list|,
name|reporter
argument_list|,
name|srcstat
argument_list|)
init|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Copying file "
operator|+
name|srcPath
operator|+
literal|" of size "
operator|+
name|srcstat
operator|.
name|getLen
argument_list|()
operator|+
literal|" bytes..."
argument_list|)
expr_stmt|;
comment|// copy file
for|for
control|(
name|int
name|bytesRead
init|;
operator|(
name|bytesRead
operator|=
name|in
operator|.
name|read
argument_list|(
name|buffer
argument_list|)
operator|)
operator|>=
literal|0
condition|;
control|)
block|{
name|out
operator|.
name|write
argument_list|(
name|buffer
argument_list|,
literal|0
argument_list|,
name|bytesRead
argument_list|)
expr_stmt|;
name|bytesCopied
operator|+=
name|bytesRead
expr_stmt|;
name|reporter
operator|.
name|setStatus
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"%.2f "
argument_list|,
name|bytesCopied
operator|*
literal|100.0
operator|/
name|srcstat
operator|.
name|getLen
argument_list|()
argument_list|)
operator|+
name|absdst
operator|+
literal|" [ "
operator|+
name|TraditionalBinaryPrefix
operator|.
name|long2String
argument_list|(
name|bytesCopied
argument_list|,
literal|""
argument_list|,
literal|1
argument_list|)
operator|+
literal|" / "
operator|+
name|TraditionalBinaryPrefix
operator|.
name|long2String
argument_list|(
name|srcstat
operator|.
name|getLen
argument_list|()
argument_list|,
literal|""
argument_list|,
literal|1
argument_list|)
operator|+
literal|" ]"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|bytesCopied
return|;
block|}
comment|/**      * Copy a file to a destination.      * @param srcstat src path and metadata      * @param relativedst relative dst path      * @param outc Log of skipped files      * @param reporter      * @throws IOException if copy fails(even if the validation of copy fails)      */
DECL|method|copy (FileStatus srcstat, Path relativedst, OutputCollector<WritableComparable<?>, Text> outc, Reporter reporter)
specifier|private
name|void
name|copy
parameter_list|(
name|FileStatus
name|srcstat
parameter_list|,
name|Path
name|relativedst
parameter_list|,
name|OutputCollector
argument_list|<
name|WritableComparable
argument_list|<
name|?
argument_list|>
argument_list|,
name|Text
argument_list|>
name|outc
parameter_list|,
name|Reporter
name|reporter
parameter_list|)
throws|throws
name|IOException
block|{
name|Path
name|absdst
init|=
operator|new
name|Path
argument_list|(
name|destPath
argument_list|,
name|relativedst
argument_list|)
decl_stmt|;
name|int
name|totfiles
init|=
name|job
operator|.
name|getInt
argument_list|(
name|SRC_COUNT_LABEL
argument_list|,
operator|-
literal|1
argument_list|)
decl_stmt|;
assert|assert
name|totfiles
operator|>=
literal|0
operator|:
literal|"Invalid file count "
operator|+
name|totfiles
assert|;
if|if
condition|(
name|totfiles
operator|==
literal|1
condition|)
block|{
comment|// Copying a single file; use dst path provided by user as
comment|// destination file rather than destination directory
name|Path
name|dstparent
init|=
name|absdst
operator|.
name|getParent
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|destFileSys
operator|.
name|exists
argument_list|(
name|dstparent
argument_list|)
operator|&&
name|destFileSys
operator|.
name|getFileStatus
argument_list|(
name|dstparent
argument_list|)
operator|.
name|isDirectory
argument_list|()
operator|)
condition|)
block|{
name|absdst
operator|=
name|dstparent
expr_stmt|;
block|}
block|}
comment|// if a directory, ensure created even if empty
if|if
condition|(
name|srcstat
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
if|if
condition|(
name|destFileSys
operator|.
name|exists
argument_list|(
name|absdst
argument_list|)
condition|)
block|{
if|if
condition|(
name|destFileSys
operator|.
name|getFileStatus
argument_list|(
name|absdst
argument_list|)
operator|.
name|isFile
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Failed to mkdirs: "
operator|+
name|absdst
operator|+
literal|" is a file."
argument_list|)
throw|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|destFileSys
operator|.
name|mkdirs
argument_list|(
name|absdst
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Failed to mkdirs "
operator|+
name|absdst
argument_list|)
throw|;
block|}
comment|// TODO: when modification times can be set, directories should be
comment|// emitted to reducers so they might be preserved. Also, mkdirs does
comment|// not currently return an error when the directory already exists;
comment|// if this changes, all directory work might as well be done in reduce
return|return;
block|}
comment|// Can we skip copying this file ?
if|if
condition|(
name|skipCopyFile
argument_list|(
name|srcstat
argument_list|,
name|absdst
argument_list|,
name|outc
argument_list|,
name|reporter
argument_list|)
condition|)
block|{
return|return;
block|}
name|Path
name|tmpfile
init|=
operator|new
name|Path
argument_list|(
name|job
operator|.
name|get
argument_list|(
name|TMP_DIR_LABEL
argument_list|)
argument_list|,
name|relativedst
argument_list|)
decl_stmt|;
comment|// do the actual copy to tmpfile
name|long
name|bytesCopied
init|=
name|doCopyFile
argument_list|(
name|srcstat
argument_list|,
name|tmpfile
argument_list|,
name|absdst
argument_list|,
name|reporter
argument_list|)
decl_stmt|;
if|if
condition|(
name|bytesCopied
operator|!=
name|srcstat
operator|.
name|getLen
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"File size not matched: copied "
operator|+
name|bytesString
argument_list|(
name|bytesCopied
argument_list|)
operator|+
literal|" to tmpfile (="
operator|+
name|tmpfile
operator|+
literal|") but expected "
operator|+
name|bytesString
argument_list|(
name|srcstat
operator|.
name|getLen
argument_list|()
argument_list|)
operator|+
literal|" from "
operator|+
name|srcstat
operator|.
name|getPath
argument_list|()
argument_list|)
throw|;
block|}
else|else
block|{
if|if
condition|(
name|destFileSys
operator|.
name|exists
argument_list|(
name|absdst
argument_list|)
operator|&&
name|destFileSys
operator|.
name|getFileStatus
argument_list|(
name|absdst
argument_list|)
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|absdst
operator|+
literal|" is a directory"
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|destFileSys
operator|.
name|mkdirs
argument_list|(
name|absdst
operator|.
name|getParent
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Failed to create parent dir: "
operator|+
name|absdst
operator|.
name|getParent
argument_list|()
argument_list|)
throw|;
block|}
name|rename
argument_list|(
name|tmpfile
argument_list|,
name|absdst
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|validateCopy
argument_list|(
name|srcstat
argument_list|,
name|absdst
argument_list|)
condition|)
block|{
name|destFileSys
operator|.
name|delete
argument_list|(
name|absdst
argument_list|,
literal|false
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Validation of copy of file "
operator|+
name|srcstat
operator|.
name|getPath
argument_list|()
operator|+
literal|" failed."
argument_list|)
throw|;
block|}
name|updateDestStatus
argument_list|(
name|srcstat
argument_list|,
name|destFileSys
operator|.
name|getFileStatus
argument_list|(
name|absdst
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// report at least once for each file
name|updateCopyStatus
argument_list|(
name|srcstat
argument_list|,
name|reporter
argument_list|)
expr_stmt|;
block|}
comment|/** rename tmp to dst, delete dst if already exists */
DECL|method|rename (Path tmp, Path dst)
specifier|private
name|void
name|rename
parameter_list|(
name|Path
name|tmp
parameter_list|,
name|Path
name|dst
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
if|if
condition|(
name|destFileSys
operator|.
name|exists
argument_list|(
name|dst
argument_list|)
condition|)
block|{
name|destFileSys
operator|.
name|delete
argument_list|(
name|dst
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|destFileSys
operator|.
name|rename
argument_list|(
name|tmp
argument_list|,
name|dst
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|()
throw|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|cause
parameter_list|)
block|{
throw|throw
operator|(
name|IOException
operator|)
operator|new
name|IOException
argument_list|(
literal|"Fail to rename tmp file (="
operator|+
name|tmp
operator|+
literal|") to destination file (="
operator|+
name|dst
operator|+
literal|")"
argument_list|)
operator|.
name|initCause
argument_list|(
name|cause
argument_list|)
throw|;
block|}
block|}
DECL|method|updateDestStatus (FileStatus src, FileStatus dst )
specifier|private
name|void
name|updateDestStatus
parameter_list|(
name|FileStatus
name|src
parameter_list|,
name|FileStatus
name|dst
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|preserve_status
condition|)
block|{
name|DistCpV1
operator|.
name|updateDestStatus
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|preseved
argument_list|,
name|destFileSys
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|bytesString (long b)
specifier|static
name|String
name|bytesString
parameter_list|(
name|long
name|b
parameter_list|)
block|{
return|return
name|b
operator|+
literal|" bytes ("
operator|+
name|TraditionalBinaryPrefix
operator|.
name|long2String
argument_list|(
name|b
argument_list|,
literal|""
argument_list|,
literal|1
argument_list|)
operator|+
literal|")"
return|;
block|}
comment|/**      * Copies a file and validates the copy by checking the checksums.      * If validation fails, retries (max number of tries is distcp.file.retries)      * to copy the file.      */
DECL|method|copyWithRetries (FileStatus srcstat, Path relativedst, OutputCollector<WritableComparable<?>, Text> out, Reporter reporter)
name|void
name|copyWithRetries
parameter_list|(
name|FileStatus
name|srcstat
parameter_list|,
name|Path
name|relativedst
parameter_list|,
name|OutputCollector
argument_list|<
name|WritableComparable
argument_list|<
name|?
argument_list|>
argument_list|,
name|Text
argument_list|>
name|out
parameter_list|,
name|Reporter
name|reporter
parameter_list|)
throws|throws
name|IOException
block|{
comment|// max tries to copy when validation of copy fails
specifier|final
name|int
name|maxRetries
init|=
name|job
operator|.
name|getInt
argument_list|(
name|FILE_RETRIES_LABEL
argument_list|,
name|DEFAULT_FILE_RETRIES
argument_list|)
decl_stmt|;
comment|// save update flag for later copies within the same map task
specifier|final
name|boolean
name|saveUpdate
init|=
name|update
decl_stmt|;
name|int
name|retryCnt
init|=
literal|1
decl_stmt|;
for|for
control|(
init|;
name|retryCnt
operator|<=
name|maxRetries
condition|;
name|retryCnt
operator|++
control|)
block|{
try|try
block|{
comment|//copy the file and validate copy
name|copy
argument_list|(
name|srcstat
argument_list|,
name|relativedst
argument_list|,
name|out
argument_list|,
name|reporter
argument_list|)
expr_stmt|;
break|break;
comment|// copy successful
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Copy of "
operator|+
name|srcstat
operator|.
name|getPath
argument_list|()
operator|+
literal|" failed."
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|retryCnt
operator|<
name|maxRetries
condition|)
block|{
comment|// copy failed and need to retry
name|LOG
operator|.
name|info
argument_list|(
literal|"Retrying copy of file "
operator|+
name|srcstat
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
name|update
operator|=
literal|true
expr_stmt|;
comment|// set update flag for retries
block|}
else|else
block|{
comment|// no more retries... Give up
name|update
operator|=
name|saveUpdate
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Copy of file failed even with "
operator|+
name|retryCnt
operator|+
literal|" tries."
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
block|}
block|}
comment|/** Mapper configuration.      * Extracts source and destination file system, as well as      * top-level paths on source and destination directories.      * Gets the named file systems, to be used later in map.      */
DECL|method|configure (JobConf job)
specifier|public
name|void
name|configure
parameter_list|(
name|JobConf
name|job
parameter_list|)
block|{
name|destPath
operator|=
operator|new
name|Path
argument_list|(
name|job
operator|.
name|get
argument_list|(
name|DST_DIR_LABEL
argument_list|,
literal|"/"
argument_list|)
argument_list|)
expr_stmt|;
try|try
block|{
name|destFileSys
operator|=
name|destPath
operator|.
name|getFileSystem
argument_list|(
name|job
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Unable to get the named file system."
argument_list|,
name|ex
argument_list|)
throw|;
block|}
name|sizeBuf
operator|=
name|job
operator|.
name|getInt
argument_list|(
literal|"copy.buf.size"
argument_list|,
literal|128
operator|*
literal|1024
argument_list|)
expr_stmt|;
name|buffer
operator|=
operator|new
name|byte
index|[
name|sizeBuf
index|]
expr_stmt|;
name|ignoreReadFailures
operator|=
name|job
operator|.
name|getBoolean
argument_list|(
name|Options
operator|.
name|IGNORE_READ_FAILURES
operator|.
name|propertyname
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|preserve_status
operator|=
name|job
operator|.
name|getBoolean
argument_list|(
name|Options
operator|.
name|PRESERVE_STATUS
operator|.
name|propertyname
argument_list|,
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|preserve_status
condition|)
block|{
name|preseved
operator|=
name|FileAttribute
operator|.
name|parse
argument_list|(
name|job
operator|.
name|get
argument_list|(
name|PRESERVE_STATUS_LABEL
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|update
operator|=
name|job
operator|.
name|getBoolean
argument_list|(
name|Options
operator|.
name|UPDATE
operator|.
name|propertyname
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|overwrite
operator|=
operator|!
name|update
operator|&&
name|job
operator|.
name|getBoolean
argument_list|(
name|Options
operator|.
name|OVERWRITE
operator|.
name|propertyname
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|skipCRCCheck
operator|=
name|job
operator|.
name|getBoolean
argument_list|(
name|Options
operator|.
name|SKIPCRC
operator|.
name|propertyname
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|this
operator|.
name|job
operator|=
name|job
expr_stmt|;
block|}
comment|/** Map method. Copies one file from source file system to destination.      * @param key src len      * @param value FilePair (FileStatus src, Path dst)      * @param out Log of failed copies      * @param reporter      */
DECL|method|map (LongWritable key, FilePair value, OutputCollector<WritableComparable<?>, Text> out, Reporter reporter)
specifier|public
name|void
name|map
parameter_list|(
name|LongWritable
name|key
parameter_list|,
name|FilePair
name|value
parameter_list|,
name|OutputCollector
argument_list|<
name|WritableComparable
argument_list|<
name|?
argument_list|>
argument_list|,
name|Text
argument_list|>
name|out
parameter_list|,
name|Reporter
name|reporter
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|FileStatus
name|srcstat
init|=
name|value
operator|.
name|input
decl_stmt|;
specifier|final
name|Path
name|relativedst
init|=
operator|new
name|Path
argument_list|(
name|value
operator|.
name|output
argument_list|)
decl_stmt|;
try|try
block|{
name|copyWithRetries
argument_list|(
name|srcstat
argument_list|,
name|relativedst
argument_list|,
name|out
argument_list|,
name|reporter
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
operator|++
name|failcount
expr_stmt|;
name|reporter
operator|.
name|incrCounter
argument_list|(
name|Counter
operator|.
name|FAIL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|updateStatus
argument_list|(
name|reporter
argument_list|)
expr_stmt|;
specifier|final
name|String
name|sfailure
init|=
literal|"FAIL "
operator|+
name|relativedst
operator|+
literal|" : "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
decl_stmt|;
name|out
operator|.
name|collect
argument_list|(
literal|null
argument_list|,
operator|new
name|Text
argument_list|(
name|sfailure
argument_list|)
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|sfailure
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|instanceof
name|FileNotFoundException
condition|)
block|{
specifier|final
name|String
name|s
init|=
literal|"Possible Cause for failure: Either the filesystem "
operator|+
name|srcstat
operator|.
name|getPath
argument_list|()
operator|.
name|getFileSystem
argument_list|(
name|job
argument_list|)
operator|+
literal|" is not accessible or the file is deleted"
decl_stmt|;
name|LOG
operator|.
name|error
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|out
operator|.
name|collect
argument_list|(
literal|null
argument_list|,
operator|new
name|Text
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
block|}
try|try
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
operator|++
name|i
control|)
block|{
try|try
block|{
specifier|final
name|Path
name|tmp
init|=
operator|new
name|Path
argument_list|(
name|job
operator|.
name|get
argument_list|(
name|TMP_DIR_LABEL
argument_list|)
argument_list|,
name|relativedst
argument_list|)
decl_stmt|;
if|if
condition|(
name|destFileSys
operator|.
name|delete
argument_list|(
name|tmp
argument_list|,
literal|true
argument_list|)
condition|)
break|break;
block|}
catch|catch
parameter_list|(
name|Throwable
name|ex
parameter_list|)
block|{
comment|// ignore, we are just cleaning up
name|LOG
operator|.
name|debug
argument_list|(
literal|"Ignoring cleanup exception"
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
comment|// update status, so we don't get timed out
name|updateStatus
argument_list|(
name|reporter
argument_list|)
expr_stmt|;
name|Thread
operator|.
name|sleep
argument_list|(
literal|3
operator|*
literal|1000
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|inte
parameter_list|)
block|{
throw|throw
operator|(
name|IOException
operator|)
operator|new
name|IOException
argument_list|()
operator|.
name|initCause
argument_list|(
name|inte
argument_list|)
throw|;
block|}
block|}
finally|finally
block|{
name|updateStatus
argument_list|(
name|reporter
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|close ()
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
literal|0
operator|==
name|failcount
operator|||
name|ignoreReadFailures
condition|)
block|{
return|return;
block|}
throw|throw
operator|new
name|IOException
argument_list|(
name|getCountString
argument_list|()
argument_list|)
throw|;
block|}
block|}
DECL|method|fetchFileList (Configuration conf, Path srcList)
specifier|private
specifier|static
name|List
argument_list|<
name|Path
argument_list|>
name|fetchFileList
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|Path
name|srcList
parameter_list|)
throws|throws
name|IOException
block|{
name|List
argument_list|<
name|Path
argument_list|>
name|result
init|=
operator|new
name|ArrayList
argument_list|<
name|Path
argument_list|>
argument_list|()
decl_stmt|;
name|FileSystem
name|fs
init|=
name|srcList
operator|.
name|getFileSystem
argument_list|(
name|conf
argument_list|)
decl_stmt|;
try|try
init|(
name|BufferedReader
name|input
init|=
operator|new
name|BufferedReader
argument_list|(
operator|new
name|InputStreamReader
argument_list|(
name|fs
operator|.
name|open
argument_list|(
name|srcList
argument_list|)
argument_list|,
name|Charset
operator|.
name|forName
argument_list|(
literal|"UTF-8"
argument_list|)
argument_list|)
argument_list|)
init|)
block|{
name|String
name|line
init|=
name|input
operator|.
name|readLine
argument_list|()
decl_stmt|;
while|while
condition|(
name|line
operator|!=
literal|null
condition|)
block|{
name|result
operator|.
name|add
argument_list|(
operator|new
name|Path
argument_list|(
name|line
argument_list|)
argument_list|)
expr_stmt|;
name|line
operator|=
name|input
operator|.
name|readLine
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
annotation|@
name|Deprecated
DECL|method|copy (Configuration conf, String srcPath, String destPath, Path logPath, boolean srcAsList, boolean ignoreReadFailures)
specifier|public
specifier|static
name|void
name|copy
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|String
name|srcPath
parameter_list|,
name|String
name|destPath
parameter_list|,
name|Path
name|logPath
parameter_list|,
name|boolean
name|srcAsList
parameter_list|,
name|boolean
name|ignoreReadFailures
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|Path
name|src
init|=
operator|new
name|Path
argument_list|(
name|srcPath
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Path
argument_list|>
name|tmp
init|=
operator|new
name|ArrayList
argument_list|<
name|Path
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|srcAsList
condition|)
block|{
name|tmp
operator|.
name|addAll
argument_list|(
name|fetchFileList
argument_list|(
name|conf
argument_list|,
name|src
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tmp
operator|.
name|add
argument_list|(
name|src
argument_list|)
expr_stmt|;
block|}
name|EnumSet
argument_list|<
name|Options
argument_list|>
name|flags
init|=
name|ignoreReadFailures
condition|?
name|EnumSet
operator|.
name|of
argument_list|(
name|Options
operator|.
name|IGNORE_READ_FAILURES
argument_list|)
else|:
name|EnumSet
operator|.
name|noneOf
argument_list|(
name|Options
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|final
name|Path
name|dst
init|=
operator|new
name|Path
argument_list|(
name|destPath
argument_list|)
decl_stmt|;
name|copy
argument_list|(
name|conf
argument_list|,
operator|new
name|Arguments
argument_list|(
name|tmp
argument_list|,
literal|null
argument_list|,
name|dst
argument_list|,
name|logPath
argument_list|,
name|flags
argument_list|,
literal|null
argument_list|,
name|Long
operator|.
name|MAX_VALUE
argument_list|,
name|Long
operator|.
name|MAX_VALUE
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** Sanity check for srcPath */
DECL|method|checkSrcPath (JobConf jobConf, List<Path> srcPaths)
specifier|private
specifier|static
name|void
name|checkSrcPath
parameter_list|(
name|JobConf
name|jobConf
parameter_list|,
name|List
argument_list|<
name|Path
argument_list|>
name|srcPaths
parameter_list|)
throws|throws
name|IOException
block|{
name|List
argument_list|<
name|IOException
argument_list|>
name|rslt
init|=
operator|new
name|ArrayList
argument_list|<
name|IOException
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Path
argument_list|>
name|unglobbed
init|=
operator|new
name|LinkedList
argument_list|<
name|Path
argument_list|>
argument_list|()
decl_stmt|;
name|Path
index|[]
name|ps
init|=
operator|new
name|Path
index|[
name|srcPaths
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
name|ps
operator|=
name|srcPaths
operator|.
name|toArray
argument_list|(
name|ps
argument_list|)
expr_stmt|;
name|TokenCache
operator|.
name|obtainTokensForNamenodes
argument_list|(
name|jobConf
operator|.
name|getCredentials
argument_list|()
argument_list|,
name|ps
argument_list|,
name|jobConf
argument_list|)
expr_stmt|;
for|for
control|(
name|Path
name|p
range|:
name|srcPaths
control|)
block|{
name|FileSystem
name|fs
init|=
name|p
operator|.
name|getFileSystem
argument_list|(
name|jobConf
argument_list|)
decl_stmt|;
name|FileStatus
index|[]
name|inputs
init|=
name|fs
operator|.
name|globStatus
argument_list|(
name|p
argument_list|)
decl_stmt|;
if|if
condition|(
name|inputs
operator|!=
literal|null
operator|&&
name|inputs
operator|.
name|length
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|FileStatus
name|onePath
range|:
name|inputs
control|)
block|{
name|unglobbed
operator|.
name|add
argument_list|(
name|onePath
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|rslt
operator|.
name|add
argument_list|(
operator|new
name|IOException
argument_list|(
literal|"Input source "
operator|+
name|p
operator|+
literal|" does not exist."
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|rslt
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|InvalidInputException
argument_list|(
name|rslt
argument_list|)
throw|;
block|}
name|srcPaths
operator|.
name|clear
argument_list|()
expr_stmt|;
name|srcPaths
operator|.
name|addAll
argument_list|(
name|unglobbed
argument_list|)
expr_stmt|;
block|}
comment|/**    * Driver to copy srcPath to destPath depending on required protocol.    * @param conf configuration    * @param args arguments    */
DECL|method|copy (final Configuration conf, final Arguments args )
specifier|static
name|void
name|copy
parameter_list|(
specifier|final
name|Configuration
name|conf
parameter_list|,
specifier|final
name|Arguments
name|args
parameter_list|)
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"srcPaths="
operator|+
name|args
operator|.
name|srcs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|args
operator|.
name|dryrun
operator|||
name|args
operator|.
name|flags
operator|.
name|contains
argument_list|(
name|Options
operator|.
name|UPDATE
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"destPath="
operator|+
name|args
operator|.
name|dst
argument_list|)
expr_stmt|;
block|}
name|JobConf
name|job
init|=
name|createJobConf
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|checkSrcPath
argument_list|(
name|job
argument_list|,
name|args
operator|.
name|srcs
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|.
name|preservedAttributes
operator|!=
literal|null
condition|)
block|{
name|job
operator|.
name|set
argument_list|(
name|PRESERVE_STATUS_LABEL
argument_list|,
name|args
operator|.
name|preservedAttributes
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|args
operator|.
name|mapredSslConf
operator|!=
literal|null
condition|)
block|{
name|job
operator|.
name|set
argument_list|(
literal|"dfs.https.client.keystore.resource"
argument_list|,
name|args
operator|.
name|mapredSslConf
argument_list|)
expr_stmt|;
block|}
comment|//Initialize the mapper
try|try
block|{
if|if
condition|(
name|setup
argument_list|(
name|conf
argument_list|,
name|job
argument_list|,
name|args
argument_list|)
condition|)
block|{
name|JobClient
operator|.
name|runJob
argument_list|(
name|job
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|args
operator|.
name|dryrun
condition|)
block|{
name|finalize
argument_list|(
name|conf
argument_list|,
name|job
argument_list|,
name|args
operator|.
name|dst
argument_list|,
name|args
operator|.
name|preservedAttributes
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|args
operator|.
name|dryrun
condition|)
block|{
comment|//delete tmp
name|fullyDelete
argument_list|(
name|job
operator|.
name|get
argument_list|(
name|TMP_DIR_LABEL
argument_list|)
argument_list|,
name|job
argument_list|)
expr_stmt|;
block|}
comment|//delete jobDirectory
name|fullyDelete
argument_list|(
name|job
operator|.
name|get
argument_list|(
name|JOB_DIR_LABEL
argument_list|)
argument_list|,
name|job
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|updateDestStatus (FileStatus src, FileStatus dst, EnumSet<FileAttribute> preseved, FileSystem destFileSys )
specifier|private
specifier|static
name|void
name|updateDestStatus
parameter_list|(
name|FileStatus
name|src
parameter_list|,
name|FileStatus
name|dst
parameter_list|,
name|EnumSet
argument_list|<
name|FileAttribute
argument_list|>
name|preseved
parameter_list|,
name|FileSystem
name|destFileSys
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|owner
init|=
literal|null
decl_stmt|;
name|String
name|group
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|preseved
operator|.
name|contains
argument_list|(
name|FileAttribute
operator|.
name|USER
argument_list|)
operator|&&
operator|!
name|src
operator|.
name|getOwner
argument_list|()
operator|.
name|equals
argument_list|(
name|dst
operator|.
name|getOwner
argument_list|()
argument_list|)
condition|)
block|{
name|owner
operator|=
name|src
operator|.
name|getOwner
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|preseved
operator|.
name|contains
argument_list|(
name|FileAttribute
operator|.
name|GROUP
argument_list|)
operator|&&
operator|!
name|src
operator|.
name|getGroup
argument_list|()
operator|.
name|equals
argument_list|(
name|dst
operator|.
name|getGroup
argument_list|()
argument_list|)
condition|)
block|{
name|group
operator|=
name|src
operator|.
name|getGroup
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|owner
operator|!=
literal|null
operator|||
name|group
operator|!=
literal|null
condition|)
block|{
name|destFileSys
operator|.
name|setOwner
argument_list|(
name|dst
operator|.
name|getPath
argument_list|()
argument_list|,
name|owner
argument_list|,
name|group
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|preseved
operator|.
name|contains
argument_list|(
name|FileAttribute
operator|.
name|PERMISSION
argument_list|)
operator|&&
operator|!
name|src
operator|.
name|getPermission
argument_list|()
operator|.
name|equals
argument_list|(
name|dst
operator|.
name|getPermission
argument_list|()
argument_list|)
condition|)
block|{
name|destFileSys
operator|.
name|setPermission
argument_list|(
name|dst
operator|.
name|getPath
argument_list|()
argument_list|,
name|src
operator|.
name|getPermission
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|preseved
operator|.
name|contains
argument_list|(
name|FileAttribute
operator|.
name|TIMES
argument_list|)
condition|)
block|{
name|destFileSys
operator|.
name|setTimes
argument_list|(
name|dst
operator|.
name|getPath
argument_list|()
argument_list|,
name|src
operator|.
name|getModificationTime
argument_list|()
argument_list|,
name|src
operator|.
name|getAccessTime
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|finalize (Configuration conf, JobConf jobconf, final Path destPath, String presevedAttributes)
specifier|static
specifier|private
name|void
name|finalize
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|JobConf
name|jobconf
parameter_list|,
specifier|final
name|Path
name|destPath
parameter_list|,
name|String
name|presevedAttributes
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|presevedAttributes
operator|==
literal|null
condition|)
block|{
return|return;
block|}
name|EnumSet
argument_list|<
name|FileAttribute
argument_list|>
name|preseved
init|=
name|FileAttribute
operator|.
name|parse
argument_list|(
name|presevedAttributes
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|preseved
operator|.
name|contains
argument_list|(
name|FileAttribute
operator|.
name|USER
argument_list|)
operator|&&
operator|!
name|preseved
operator|.
name|contains
argument_list|(
name|FileAttribute
operator|.
name|GROUP
argument_list|)
operator|&&
operator|!
name|preseved
operator|.
name|contains
argument_list|(
name|FileAttribute
operator|.
name|PERMISSION
argument_list|)
condition|)
block|{
return|return;
block|}
name|FileSystem
name|dstfs
init|=
name|destPath
operator|.
name|getFileSystem
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|Path
name|dstdirlist
init|=
operator|new
name|Path
argument_list|(
name|jobconf
operator|.
name|get
argument_list|(
name|DST_DIR_LIST_LABEL
argument_list|)
argument_list|)
decl_stmt|;
try|try
init|(
name|SequenceFile
operator|.
name|Reader
name|in
init|=
operator|new
name|SequenceFile
operator|.
name|Reader
argument_list|(
name|jobconf
argument_list|,
name|Reader
operator|.
name|file
argument_list|(
name|dstdirlist
argument_list|)
argument_list|)
init|)
block|{
name|Text
name|dsttext
init|=
operator|new
name|Text
argument_list|()
decl_stmt|;
name|FilePair
name|pair
init|=
operator|new
name|FilePair
argument_list|()
decl_stmt|;
for|for
control|(
init|;
name|in
operator|.
name|next
argument_list|(
name|dsttext
argument_list|,
name|pair
argument_list|)
condition|;
control|)
block|{
name|Path
name|absdst
init|=
operator|new
name|Path
argument_list|(
name|destPath
argument_list|,
name|pair
operator|.
name|output
argument_list|)
decl_stmt|;
name|updateDestStatus
argument_list|(
name|pair
operator|.
name|input
argument_list|,
name|dstfs
operator|.
name|getFileStatus
argument_list|(
name|absdst
argument_list|)
argument_list|,
name|preseved
argument_list|,
name|dstfs
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|class|Arguments
specifier|static
class|class
name|Arguments
block|{
DECL|field|srcs
specifier|final
name|List
argument_list|<
name|Path
argument_list|>
name|srcs
decl_stmt|;
DECL|field|basedir
specifier|final
name|Path
name|basedir
decl_stmt|;
DECL|field|dst
specifier|final
name|Path
name|dst
decl_stmt|;
DECL|field|log
specifier|final
name|Path
name|log
decl_stmt|;
DECL|field|flags
specifier|final
name|EnumSet
argument_list|<
name|Options
argument_list|>
name|flags
decl_stmt|;
DECL|field|preservedAttributes
specifier|final
name|String
name|preservedAttributes
decl_stmt|;
DECL|field|filelimit
specifier|final
name|long
name|filelimit
decl_stmt|;
DECL|field|sizelimit
specifier|final
name|long
name|sizelimit
decl_stmt|;
DECL|field|mapredSslConf
specifier|final
name|String
name|mapredSslConf
decl_stmt|;
DECL|field|dryrun
specifier|final
name|boolean
name|dryrun
decl_stmt|;
comment|/**      * Arguments for distcp      * @param srcs List of source paths      * @param basedir Base directory for copy      * @param dst Destination path      * @param log Log output directory      * @param flags Command-line flags      * @param preservedAttributes Preserved attributes       * @param filelimit File limit      * @param sizelimit Size limit      * @param mapredSslConf ssl configuration      * @param dryrun      */
DECL|method|Arguments (List<Path> srcs, Path basedir, Path dst, Path log, EnumSet<Options> flags, String preservedAttributes, long filelimit, long sizelimit, String mapredSslConf, boolean dryrun)
name|Arguments
parameter_list|(
name|List
argument_list|<
name|Path
argument_list|>
name|srcs
parameter_list|,
name|Path
name|basedir
parameter_list|,
name|Path
name|dst
parameter_list|,
name|Path
name|log
parameter_list|,
name|EnumSet
argument_list|<
name|Options
argument_list|>
name|flags
parameter_list|,
name|String
name|preservedAttributes
parameter_list|,
name|long
name|filelimit
parameter_list|,
name|long
name|sizelimit
parameter_list|,
name|String
name|mapredSslConf
parameter_list|,
name|boolean
name|dryrun
parameter_list|)
block|{
name|this
operator|.
name|srcs
operator|=
name|srcs
expr_stmt|;
name|this
operator|.
name|basedir
operator|=
name|basedir
expr_stmt|;
name|this
operator|.
name|dst
operator|=
name|dst
expr_stmt|;
name|this
operator|.
name|log
operator|=
name|log
expr_stmt|;
name|this
operator|.
name|flags
operator|=
name|flags
expr_stmt|;
name|this
operator|.
name|preservedAttributes
operator|=
name|preservedAttributes
expr_stmt|;
name|this
operator|.
name|filelimit
operator|=
name|filelimit
expr_stmt|;
name|this
operator|.
name|sizelimit
operator|=
name|sizelimit
expr_stmt|;
name|this
operator|.
name|mapredSslConf
operator|=
name|mapredSslConf
expr_stmt|;
name|this
operator|.
name|dryrun
operator|=
name|dryrun
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"this = "
operator|+
name|this
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|valueOf (String[] args, Configuration conf )
specifier|static
name|Arguments
name|valueOf
parameter_list|(
name|String
index|[]
name|args
parameter_list|,
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|List
argument_list|<
name|Path
argument_list|>
name|srcs
init|=
operator|new
name|ArrayList
argument_list|<
name|Path
argument_list|>
argument_list|()
decl_stmt|;
name|Path
name|dst
init|=
literal|null
decl_stmt|;
name|Path
name|log
init|=
literal|null
decl_stmt|;
name|Path
name|basedir
init|=
literal|null
decl_stmt|;
name|EnumSet
argument_list|<
name|Options
argument_list|>
name|flags
init|=
name|EnumSet
operator|.
name|noneOf
argument_list|(
name|Options
operator|.
name|class
argument_list|)
decl_stmt|;
name|String
name|presevedAttributes
init|=
literal|null
decl_stmt|;
name|String
name|mapredSslConf
init|=
literal|null
decl_stmt|;
name|long
name|filelimit
init|=
name|Long
operator|.
name|MAX_VALUE
decl_stmt|;
name|long
name|sizelimit
init|=
name|Long
operator|.
name|MAX_VALUE
decl_stmt|;
name|boolean
name|dryrun
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|idx
init|=
literal|0
init|;
name|idx
operator|<
name|args
operator|.
name|length
condition|;
name|idx
operator|++
control|)
block|{
name|Options
index|[]
name|opt
init|=
name|Options
operator|.
name|values
argument_list|()
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|opt
operator|.
name|length
operator|&&
operator|!
name|args
index|[
name|idx
index|]
operator|.
name|startsWith
argument_list|(
name|opt
index|[
name|i
index|]
operator|.
name|cmd
argument_list|)
condition|;
name|i
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|i
operator|<
name|opt
operator|.
name|length
condition|)
block|{
name|flags
operator|.
name|add
argument_list|(
name|opt
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt
index|[
name|i
index|]
operator|==
name|Options
operator|.
name|PRESERVE_STATUS
condition|)
block|{
name|presevedAttributes
operator|=
name|args
index|[
name|idx
index|]
operator|.
name|substring
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|FileAttribute
operator|.
name|parse
argument_list|(
name|presevedAttributes
argument_list|)
expr_stmt|;
comment|//validation
block|}
elseif|else
if|if
condition|(
name|opt
index|[
name|i
index|]
operator|==
name|Options
operator|.
name|FILE_LIMIT
condition|)
block|{
name|filelimit
operator|=
name|Options
operator|.
name|FILE_LIMIT
operator|.
name|parseLong
argument_list|(
name|args
argument_list|,
operator|++
name|idx
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|opt
index|[
name|i
index|]
operator|==
name|Options
operator|.
name|SIZE_LIMIT
condition|)
block|{
name|sizelimit
operator|=
name|Options
operator|.
name|SIZE_LIMIT
operator|.
name|parseLong
argument_list|(
name|args
argument_list|,
operator|++
name|idx
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
literal|"-f"
operator|.
name|equals
argument_list|(
name|args
index|[
name|idx
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
operator|++
name|idx
operator|==
name|args
operator|.
name|length
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"urilist_uri not specified in -f"
argument_list|)
throw|;
block|}
name|srcs
operator|.
name|addAll
argument_list|(
name|fetchFileList
argument_list|(
name|conf
argument_list|,
operator|new
name|Path
argument_list|(
name|args
index|[
name|idx
index|]
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|"-log"
operator|.
name|equals
argument_list|(
name|args
index|[
name|idx
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
operator|++
name|idx
operator|==
name|args
operator|.
name|length
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"logdir not specified in -log"
argument_list|)
throw|;
block|}
name|log
operator|=
operator|new
name|Path
argument_list|(
name|args
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|"-basedir"
operator|.
name|equals
argument_list|(
name|args
index|[
name|idx
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
operator|++
name|idx
operator|==
name|args
operator|.
name|length
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"basedir not specified in -basedir"
argument_list|)
throw|;
block|}
name|basedir
operator|=
operator|new
name|Path
argument_list|(
name|args
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|"-mapredSslConf"
operator|.
name|equals
argument_list|(
name|args
index|[
name|idx
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
operator|++
name|idx
operator|==
name|args
operator|.
name|length
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"ssl conf file not specified in -mapredSslConf"
argument_list|)
throw|;
block|}
name|mapredSslConf
operator|=
name|args
index|[
name|idx
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|"-dryrun"
operator|.
name|equals
argument_list|(
name|args
index|[
name|idx
index|]
argument_list|)
condition|)
block|{
name|dryrun
operator|=
literal|true
expr_stmt|;
name|dst
operator|=
operator|new
name|Path
argument_list|(
literal|"/tmp/distcp_dummy_dest"
argument_list|)
expr_stmt|;
comment|//dummy destination
block|}
elseif|else
if|if
condition|(
literal|"-m"
operator|.
name|equals
argument_list|(
name|args
index|[
name|idx
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
operator|++
name|idx
operator|==
name|args
operator|.
name|length
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"num_maps not specified in -m"
argument_list|)
throw|;
block|}
try|try
block|{
name|conf
operator|.
name|setInt
argument_list|(
name|MAX_MAPS_LABEL
argument_list|,
name|Integer
operator|.
name|parseInt
argument_list|(
name|args
index|[
name|idx
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Invalid argument to -m: "
operator|+
name|args
index|[
name|idx
index|]
argument_list|)
throw|;
block|}
block|}
elseif|else
if|if
condition|(
literal|'-'
operator|==
name|args
index|[
name|idx
index|]
operator|.
name|codePointAt
argument_list|(
literal|0
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Invalid switch "
operator|+
name|args
index|[
name|idx
index|]
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|idx
operator|==
name|args
operator|.
name|length
operator|-
literal|1
operator|&&
operator|(
operator|!
name|dryrun
operator|||
name|flags
operator|.
name|contains
argument_list|(
name|Options
operator|.
name|UPDATE
argument_list|)
operator|)
condition|)
block|{
name|dst
operator|=
operator|new
name|Path
argument_list|(
name|args
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|srcs
operator|.
name|add
argument_list|(
operator|new
name|Path
argument_list|(
name|args
index|[
name|idx
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// mandatory command-line parameters
if|if
condition|(
name|srcs
operator|.
name|isEmpty
argument_list|()
operator|||
name|dst
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Missing "
operator|+
operator|(
name|dst
operator|==
literal|null
condition|?
literal|"dst path"
else|:
literal|"src"
operator|)
argument_list|)
throw|;
block|}
comment|// incompatible command-line flags
specifier|final
name|boolean
name|isOverwrite
init|=
name|flags
operator|.
name|contains
argument_list|(
name|Options
operator|.
name|OVERWRITE
argument_list|)
decl_stmt|;
specifier|final
name|boolean
name|isUpdate
init|=
name|flags
operator|.
name|contains
argument_list|(
name|Options
operator|.
name|UPDATE
argument_list|)
decl_stmt|;
specifier|final
name|boolean
name|isDelete
init|=
name|flags
operator|.
name|contains
argument_list|(
name|Options
operator|.
name|DELETE
argument_list|)
decl_stmt|;
specifier|final
name|boolean
name|skipCRC
init|=
name|flags
operator|.
name|contains
argument_list|(
name|Options
operator|.
name|SKIPCRC
argument_list|)
decl_stmt|;
if|if
condition|(
name|isOverwrite
operator|&&
name|isUpdate
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Conflicting overwrite policies"
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|isUpdate
operator|&&
name|skipCRC
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|Options
operator|.
name|SKIPCRC
operator|.
name|cmd
operator|+
literal|" is relevant only with the "
operator|+
name|Options
operator|.
name|UPDATE
operator|.
name|cmd
operator|+
literal|" option"
argument_list|)
throw|;
block|}
if|if
condition|(
name|isDelete
operator|&&
operator|!
name|isOverwrite
operator|&&
operator|!
name|isUpdate
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|Options
operator|.
name|DELETE
operator|.
name|cmd
operator|+
literal|" must be specified with "
operator|+
name|Options
operator|.
name|OVERWRITE
operator|+
literal|" or "
operator|+
name|Options
operator|.
name|UPDATE
operator|+
literal|"."
argument_list|)
throw|;
block|}
return|return
operator|new
name|Arguments
argument_list|(
name|srcs
argument_list|,
name|basedir
argument_list|,
name|dst
argument_list|,
name|log
argument_list|,
name|flags
argument_list|,
name|presevedAttributes
argument_list|,
name|filelimit
argument_list|,
name|sizelimit
argument_list|,
name|mapredSslConf
argument_list|,
name|dryrun
argument_list|)
return|;
block|}
comment|/** {@inheritDoc} */
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|"{"
operator|+
literal|"\n  srcs = "
operator|+
name|srcs
operator|+
literal|"\n  dst = "
operator|+
name|dst
operator|+
literal|"\n  log = "
operator|+
name|log
operator|+
literal|"\n  flags = "
operator|+
name|flags
operator|+
literal|"\n  preservedAttributes = "
operator|+
name|preservedAttributes
operator|+
literal|"\n  filelimit = "
operator|+
name|filelimit
operator|+
literal|"\n  sizelimit = "
operator|+
name|sizelimit
operator|+
literal|"\n  mapredSslConf = "
operator|+
name|mapredSslConf
operator|+
literal|"\n}"
return|;
block|}
block|}
comment|/**    * This is the main driver for recursively copying directories    * across file systems. It takes at least two cmdline parameters. A source    * URL and a destination URL. It then essentially does an "ls -lR" on the    * source URL, and writes the output in a round-robin manner to all the map    * input files. The mapper actually copies the files allotted to it. The    * reduce is empty.    */
DECL|method|run (String[] args)
specifier|public
name|int
name|run
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
block|{
try|try
block|{
name|copy
argument_list|(
name|conf
argument_list|,
name|Arguments
operator|.
name|valueOf
argument_list|(
name|args
argument_list|,
name|conf
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
operator|+
literal|"\n"
operator|+
name|usage
argument_list|)
expr_stmt|;
name|ToolRunner
operator|.
name|printGenericCommandUsage
argument_list|(
name|System
operator|.
name|err
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
catch|catch
parameter_list|(
name|DuplicationException
name|e
parameter_list|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|DuplicationException
operator|.
name|ERROR_CODE
return|;
block|}
catch|catch
parameter_list|(
name|RemoteException
name|e
parameter_list|)
block|{
specifier|final
name|IOException
name|unwrapped
init|=
name|e
operator|.
name|unwrapRemoteException
argument_list|(
name|FileNotFoundException
operator|.
name|class
argument_list|,
name|AccessControlException
operator|.
name|class
argument_list|,
name|QuotaExceededException
operator|.
name|class
argument_list|)
decl_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|unwrapped
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|3
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"With failures, global counters are inaccurate; "
operator|+
literal|"consider running with -i"
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Copy failed: "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|999
return|;
block|}
block|}
DECL|method|main (String[] args)
specifier|public
specifier|static
name|void
name|main
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
throws|throws
name|Exception
block|{
name|JobConf
name|job
init|=
operator|new
name|JobConf
argument_list|(
name|DistCpV1
operator|.
name|class
argument_list|)
decl_stmt|;
name|DistCpV1
name|distcp
init|=
operator|new
name|DistCpV1
argument_list|(
name|job
argument_list|)
decl_stmt|;
name|int
name|res
init|=
name|ToolRunner
operator|.
name|run
argument_list|(
name|distcp
argument_list|,
name|args
argument_list|)
decl_stmt|;
name|System
operator|.
name|exit
argument_list|(
name|res
argument_list|)
expr_stmt|;
block|}
comment|/**    * Make a path relative with respect to a root path.    * absPath is always assumed to descend from root.    * Otherwise returned path is null.    */
DECL|method|makeRelative (Path root, Path absPath)
specifier|static
name|String
name|makeRelative
parameter_list|(
name|Path
name|root
parameter_list|,
name|Path
name|absPath
parameter_list|)
block|{
if|if
condition|(
operator|!
name|absPath
operator|.
name|isAbsolute
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"!absPath.isAbsolute(), absPath="
operator|+
name|absPath
argument_list|)
throw|;
block|}
name|String
name|p
init|=
name|absPath
operator|.
name|toUri
argument_list|()
operator|.
name|getPath
argument_list|()
decl_stmt|;
name|StringTokenizer
name|pathTokens
init|=
operator|new
name|StringTokenizer
argument_list|(
name|p
argument_list|,
literal|"/"
argument_list|)
decl_stmt|;
for|for
control|(
name|StringTokenizer
name|rootTokens
init|=
operator|new
name|StringTokenizer
argument_list|(
name|root
operator|.
name|toUri
argument_list|()
operator|.
name|getPath
argument_list|()
argument_list|,
literal|"/"
argument_list|)
init|;
name|rootTokens
operator|.
name|hasMoreTokens
argument_list|()
condition|;
control|)
block|{
if|if
condition|(
operator|!
name|rootTokens
operator|.
name|nextToken
argument_list|()
operator|.
name|equals
argument_list|(
name|pathTokens
operator|.
name|nextToken
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
block|}
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
init|;
name|pathTokens
operator|.
name|hasMoreTokens
argument_list|()
condition|;
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|pathTokens
operator|.
name|nextToken
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|pathTokens
operator|.
name|hasMoreTokens
argument_list|()
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|Path
operator|.
name|SEPARATOR
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|sb
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|?
literal|"."
else|:
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * Calculate how many maps to run.    * Number of maps is bounded by a minimum of the cumulative size of the    * copy / (distcp.bytes.per.map, default BYTES_PER_MAP or -m on the    * command line) and at most (distcp.max.map.tasks, default    * MAX_MAPS_PER_NODE * nodes in the cluster).    * @param totalBytes Count of total bytes for job    * @param job The job to configure    * @return Count of maps to run.    */
DECL|method|setMapCount (long totalBytes, JobConf job)
specifier|private
specifier|static
name|int
name|setMapCount
parameter_list|(
name|long
name|totalBytes
parameter_list|,
name|JobConf
name|job
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|numMaps
init|=
call|(
name|int
call|)
argument_list|(
name|totalBytes
operator|/
name|job
operator|.
name|getLong
argument_list|(
name|BYTES_PER_MAP_LABEL
argument_list|,
name|BYTES_PER_MAP
argument_list|)
argument_list|)
decl_stmt|;
name|numMaps
operator|=
name|Math
operator|.
name|min
argument_list|(
name|numMaps
argument_list|,
name|job
operator|.
name|getInt
argument_list|(
name|MAX_MAPS_LABEL
argument_list|,
name|MAX_MAPS_PER_NODE
operator|*
operator|new
name|JobClient
argument_list|(
name|job
argument_list|)
operator|.
name|getClusterStatus
argument_list|()
operator|.
name|getTaskTrackers
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|numMaps
operator|=
name|Math
operator|.
name|max
argument_list|(
name|numMaps
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|job
operator|.
name|setNumMapTasks
argument_list|(
name|numMaps
argument_list|)
expr_stmt|;
return|return
name|numMaps
return|;
block|}
comment|/** Fully delete dir */
DECL|method|fullyDelete (String dir, Configuration conf)
specifier|static
name|void
name|fullyDelete
parameter_list|(
name|String
name|dir
parameter_list|,
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|dir
operator|!=
literal|null
condition|)
block|{
name|Path
name|tmp
init|=
operator|new
name|Path
argument_list|(
name|dir
argument_list|)
decl_stmt|;
name|boolean
name|success
init|=
name|tmp
operator|.
name|getFileSystem
argument_list|(
name|conf
argument_list|)
operator|.
name|delete
argument_list|(
name|tmp
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|success
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Could not fully delete "
operator|+
name|tmp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|//Job configuration
DECL|method|createJobConf (Configuration conf)
specifier|private
specifier|static
name|JobConf
name|createJobConf
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
name|JobConf
name|jobconf
init|=
operator|new
name|JobConf
argument_list|(
name|conf
argument_list|,
name|DistCpV1
operator|.
name|class
argument_list|)
decl_stmt|;
name|jobconf
operator|.
name|setJobName
argument_list|(
name|conf
operator|.
name|get
argument_list|(
literal|"mapred.job.name"
argument_list|,
name|NAME
argument_list|)
argument_list|)
expr_stmt|;
comment|// turn off speculative execution, because DFS doesn't handle
comment|// multiple writers to the same file.
name|jobconf
operator|.
name|setMapSpeculativeExecution
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|jobconf
operator|.
name|setInputFormat
argument_list|(
name|CopyInputFormat
operator|.
name|class
argument_list|)
expr_stmt|;
name|jobconf
operator|.
name|setOutputKeyClass
argument_list|(
name|Text
operator|.
name|class
argument_list|)
expr_stmt|;
name|jobconf
operator|.
name|setOutputValueClass
argument_list|(
name|Text
operator|.
name|class
argument_list|)
expr_stmt|;
name|jobconf
operator|.
name|setMapperClass
argument_list|(
name|CopyFilesMapper
operator|.
name|class
argument_list|)
expr_stmt|;
name|jobconf
operator|.
name|setNumReduceTasks
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|jobconf
return|;
block|}
DECL|field|RANDOM
specifier|private
specifier|static
specifier|final
name|Random
name|RANDOM
init|=
operator|new
name|Random
argument_list|()
decl_stmt|;
DECL|method|getRandomId ()
specifier|public
specifier|static
name|String
name|getRandomId
parameter_list|()
block|{
return|return
name|Integer
operator|.
name|toString
argument_list|(
name|RANDOM
operator|.
name|nextInt
argument_list|(
name|Integer
operator|.
name|MAX_VALUE
argument_list|)
argument_list|,
literal|36
argument_list|)
return|;
block|}
comment|/**    * Increase the replication factor of _distcp_src_files to    * sqrt(min(maxMapsOnCluster, numMaps)). This is to reduce the chance of    * failing of distcp because of "not having a replication of _distcp_src_files    * available for reading for some maps".    */
DECL|method|setReplication (Configuration conf, JobConf jobConf, Path srcfilelist, int numMaps)
specifier|private
specifier|static
name|void
name|setReplication
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|JobConf
name|jobConf
parameter_list|,
name|Path
name|srcfilelist
parameter_list|,
name|int
name|numMaps
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|numMaxMaps
init|=
operator|new
name|JobClient
argument_list|(
name|jobConf
argument_list|)
operator|.
name|getClusterStatus
argument_list|()
operator|.
name|getMaxMapTasks
argument_list|()
decl_stmt|;
name|short
name|replication
init|=
operator|(
name|short
operator|)
name|Math
operator|.
name|ceil
argument_list|(
name|Math
operator|.
name|sqrt
argument_list|(
name|Math
operator|.
name|min
argument_list|(
name|numMaxMaps
argument_list|,
name|numMaps
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|FileSystem
name|fs
init|=
name|srcfilelist
operator|.
name|getFileSystem
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|FileStatus
name|srcStatus
init|=
name|fs
operator|.
name|getFileStatus
argument_list|(
name|srcfilelist
argument_list|)
decl_stmt|;
if|if
condition|(
name|srcStatus
operator|.
name|getReplication
argument_list|()
operator|<
name|replication
condition|)
block|{
if|if
condition|(
operator|!
name|fs
operator|.
name|setReplication
argument_list|(
name|srcfilelist
argument_list|,
name|replication
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unable to increase the replication of file "
operator|+
name|srcfilelist
argument_list|)
throw|;
block|}
block|}
block|}
comment|/**    * Does the dir already exist at destination ?    * @return true   if the dir already exists at destination    */
DECL|method|dirExists (Configuration conf, Path dst)
specifier|private
specifier|static
name|boolean
name|dirExists
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|Path
name|dst
parameter_list|)
throws|throws
name|IOException
block|{
name|FileSystem
name|destFileSys
init|=
name|dst
operator|.
name|getFileSystem
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|FileStatus
name|status
init|=
literal|null
decl_stmt|;
try|try
block|{
name|status
operator|=
name|destFileSys
operator|.
name|getFileStatus
argument_list|(
name|dst
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|e
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|status
operator|.
name|isFile
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|FileAlreadyExistsException
argument_list|(
literal|"Not a dir: "
operator|+
name|dst
operator|+
literal|" is a file."
argument_list|)
throw|;
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Initialize DFSCopyFileMapper specific job-configuration.    * @param conf : The dfs/mapred configuration.    * @param jobConf : The handle to the jobConf object to be initialized.    * @param args Arguments    * @return true if it is necessary to launch a job.    */
DECL|method|setup (Configuration conf, JobConf jobConf, final Arguments args)
specifier|static
name|boolean
name|setup
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|JobConf
name|jobConf
parameter_list|,
specifier|final
name|Arguments
name|args
parameter_list|)
throws|throws
name|IOException
block|{
name|jobConf
operator|.
name|set
argument_list|(
name|DST_DIR_LABEL
argument_list|,
name|args
operator|.
name|dst
operator|.
name|toUri
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
comment|//set boolean values
specifier|final
name|boolean
name|update
init|=
name|args
operator|.
name|flags
operator|.
name|contains
argument_list|(
name|Options
operator|.
name|UPDATE
argument_list|)
decl_stmt|;
specifier|final
name|boolean
name|skipCRCCheck
init|=
name|args
operator|.
name|flags
operator|.
name|contains
argument_list|(
name|Options
operator|.
name|SKIPCRC
argument_list|)
decl_stmt|;
specifier|final
name|boolean
name|overwrite
init|=
operator|!
name|update
operator|&&
name|args
operator|.
name|flags
operator|.
name|contains
argument_list|(
name|Options
operator|.
name|OVERWRITE
argument_list|)
operator|&&
operator|!
name|args
operator|.
name|dryrun
decl_stmt|;
name|jobConf
operator|.
name|setBoolean
argument_list|(
name|Options
operator|.
name|UPDATE
operator|.
name|propertyname
argument_list|,
name|update
argument_list|)
expr_stmt|;
name|jobConf
operator|.
name|setBoolean
argument_list|(
name|Options
operator|.
name|SKIPCRC
operator|.
name|propertyname
argument_list|,
name|skipCRCCheck
argument_list|)
expr_stmt|;
name|jobConf
operator|.
name|setBoolean
argument_list|(
name|Options
operator|.
name|OVERWRITE
operator|.
name|propertyname
argument_list|,
name|overwrite
argument_list|)
expr_stmt|;
name|jobConf
operator|.
name|setBoolean
argument_list|(
name|Options
operator|.
name|IGNORE_READ_FAILURES
operator|.
name|propertyname
argument_list|,
name|args
operator|.
name|flags
operator|.
name|contains
argument_list|(
name|Options
operator|.
name|IGNORE_READ_FAILURES
argument_list|)
argument_list|)
expr_stmt|;
name|jobConf
operator|.
name|setBoolean
argument_list|(
name|Options
operator|.
name|PRESERVE_STATUS
operator|.
name|propertyname
argument_list|,
name|args
operator|.
name|flags
operator|.
name|contains
argument_list|(
name|Options
operator|.
name|PRESERVE_STATUS
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|String
name|randomId
init|=
name|getRandomId
argument_list|()
decl_stmt|;
name|JobClient
name|jClient
init|=
operator|new
name|JobClient
argument_list|(
name|jobConf
argument_list|)
decl_stmt|;
name|Path
name|stagingArea
decl_stmt|;
try|try
block|{
name|stagingArea
operator|=
name|JobSubmissionFiles
operator|.
name|getStagingDir
argument_list|(
name|jClient
operator|.
name|getClusterHandle
argument_list|()
argument_list|,
name|conf
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|ie
argument_list|)
throw|;
block|}
name|Path
name|jobDirectory
init|=
operator|new
name|Path
argument_list|(
name|stagingArea
operator|+
name|NAME
operator|+
literal|"_"
operator|+
name|randomId
argument_list|)
decl_stmt|;
name|FsPermission
name|mapredSysPerms
init|=
operator|new
name|FsPermission
argument_list|(
name|JobSubmissionFiles
operator|.
name|JOB_DIR_PERMISSION
argument_list|)
decl_stmt|;
name|FileSystem
operator|.
name|mkdirs
argument_list|(
name|jClient
operator|.
name|getFs
argument_list|()
argument_list|,
name|jobDirectory
argument_list|,
name|mapredSysPerms
argument_list|)
expr_stmt|;
name|jobConf
operator|.
name|set
argument_list|(
name|JOB_DIR_LABEL
argument_list|,
name|jobDirectory
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|long
name|maxBytesPerMap
init|=
name|conf
operator|.
name|getLong
argument_list|(
name|BYTES_PER_MAP_LABEL
argument_list|,
name|BYTES_PER_MAP
argument_list|)
decl_stmt|;
name|FileSystem
name|dstfs
init|=
name|args
operator|.
name|dst
operator|.
name|getFileSystem
argument_list|(
name|conf
argument_list|)
decl_stmt|;
comment|// get tokens for all the required FileSystems..
name|TokenCache
operator|.
name|obtainTokensForNamenodes
argument_list|(
name|jobConf
operator|.
name|getCredentials
argument_list|()
argument_list|,
operator|new
name|Path
index|[]
block|{
name|args
operator|.
name|dst
block|}
argument_list|,
name|conf
argument_list|)
expr_stmt|;
name|boolean
name|dstExists
init|=
name|dstfs
operator|.
name|exists
argument_list|(
name|args
operator|.
name|dst
argument_list|)
decl_stmt|;
name|boolean
name|dstIsDir
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|dstExists
condition|)
block|{
name|dstIsDir
operator|=
name|dstfs
operator|.
name|getFileStatus
argument_list|(
name|args
operator|.
name|dst
argument_list|)
operator|.
name|isDirectory
argument_list|()
expr_stmt|;
block|}
comment|// default logPath
name|Path
name|logPath
init|=
name|args
operator|.
name|log
decl_stmt|;
if|if
condition|(
name|logPath
operator|==
literal|null
condition|)
block|{
name|String
name|filename
init|=
literal|"_distcp_logs_"
operator|+
name|randomId
decl_stmt|;
if|if
condition|(
operator|!
name|dstExists
operator|||
operator|!
name|dstIsDir
condition|)
block|{
name|Path
name|parent
init|=
name|args
operator|.
name|dst
operator|.
name|getParent
argument_list|()
decl_stmt|;
if|if
condition|(
literal|null
operator|==
name|parent
condition|)
block|{
comment|// If dst is '/' on S3, it might not exist yet, but dst.getParent()
comment|// will return null. In this case, use '/' as its own parent to prevent
comment|// NPE errors below.
name|parent
operator|=
name|args
operator|.
name|dst
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|dstfs
operator|.
name|exists
argument_list|(
name|parent
argument_list|)
condition|)
block|{
name|dstfs
operator|.
name|mkdirs
argument_list|(
name|parent
argument_list|)
expr_stmt|;
block|}
name|logPath
operator|=
operator|new
name|Path
argument_list|(
name|parent
argument_list|,
name|filename
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|logPath
operator|=
operator|new
name|Path
argument_list|(
name|args
operator|.
name|dst
argument_list|,
name|filename
argument_list|)
expr_stmt|;
block|}
block|}
name|FileOutputFormat
operator|.
name|setOutputPath
argument_list|(
name|jobConf
argument_list|,
name|logPath
argument_list|)
expr_stmt|;
comment|// create src list, dst list
name|FileSystem
name|jobfs
init|=
name|jobDirectory
operator|.
name|getFileSystem
argument_list|(
name|jobConf
argument_list|)
decl_stmt|;
name|Path
name|srcfilelist
init|=
operator|new
name|Path
argument_list|(
name|jobDirectory
argument_list|,
literal|"_distcp_src_files"
argument_list|)
decl_stmt|;
name|Path
name|dstfilelist
init|=
operator|new
name|Path
argument_list|(
name|jobDirectory
argument_list|,
literal|"_distcp_dst_files"
argument_list|)
decl_stmt|;
name|Path
name|dstdirlist
init|=
operator|new
name|Path
argument_list|(
name|jobDirectory
argument_list|,
literal|"_distcp_dst_dirs"
argument_list|)
decl_stmt|;
name|jobConf
operator|.
name|set
argument_list|(
name|SRC_LIST_LABEL
argument_list|,
name|srcfilelist
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|jobConf
operator|.
name|set
argument_list|(
name|DST_DIR_LIST_LABEL
argument_list|,
name|dstdirlist
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|srcCount
init|=
literal|0
decl_stmt|,
name|cnsyncf
init|=
literal|0
decl_stmt|,
name|dirsyn
init|=
literal|0
decl_stmt|;
name|long
name|fileCount
init|=
literal|0L
decl_stmt|,
name|dirCount
init|=
literal|0L
decl_stmt|,
name|byteCount
init|=
literal|0L
decl_stmt|,
name|cbsyncs
init|=
literal|0L
decl_stmt|,
name|skipFileCount
init|=
literal|0L
decl_stmt|,
name|skipByteCount
init|=
literal|0L
decl_stmt|;
try|try
init|(
name|SequenceFile
operator|.
name|Writer
name|src_writer
init|=
name|SequenceFile
operator|.
name|createWriter
argument_list|(
name|jobConf
argument_list|,
name|Writer
operator|.
name|file
argument_list|(
name|srcfilelist
argument_list|)
argument_list|,
name|Writer
operator|.
name|keyClass
argument_list|(
name|LongWritable
operator|.
name|class
argument_list|)
argument_list|,
name|Writer
operator|.
name|valueClass
argument_list|(
name|FilePair
operator|.
name|class
argument_list|)
argument_list|,
name|Writer
operator|.
name|compression
argument_list|(
name|SequenceFile
operator|.
name|CompressionType
operator|.
name|NONE
argument_list|)
argument_list|)
init|;
name|SequenceFile
operator|.
name|Writer
name|dst_writer
operator|=
name|SequenceFile
operator|.
name|createWriter
argument_list|(
name|jobConf
argument_list|,
name|Writer
operator|.
name|file
argument_list|(
name|dstfilelist
argument_list|)
argument_list|,
name|Writer
operator|.
name|keyClass
argument_list|(
name|Text
operator|.
name|class
argument_list|)
argument_list|,
name|Writer
operator|.
name|valueClass
argument_list|(
name|Text
operator|.
name|class
argument_list|)
argument_list|,
name|Writer
operator|.
name|compression
argument_list|(
name|SequenceFile
operator|.
name|CompressionType
operator|.
name|NONE
argument_list|)
argument_list|)
init|;
name|SequenceFile
operator|.
name|Writer
name|dir_writer
operator|=
name|SequenceFile
operator|.
name|createWriter
argument_list|(
name|jobConf
argument_list|,
name|Writer
operator|.
name|file
argument_list|(
name|dstdirlist
argument_list|)
argument_list|,
name|Writer
operator|.
name|keyClass
argument_list|(
name|Text
operator|.
name|class
argument_list|)
argument_list|,
name|Writer
operator|.
name|valueClass
argument_list|(
name|FilePair
operator|.
name|class
argument_list|)
argument_list|,
name|Writer
operator|.
name|compression
argument_list|(
name|SequenceFile
operator|.
name|CompressionType
operator|.
name|NONE
argument_list|)
argument_list|)
init|;
init|)
block|{
comment|// handle the case where the destination directory doesn't exist
comment|// and we've only a single src directory OR we're updating/overwriting
comment|// the contents of the destination directory.
specifier|final
name|boolean
name|special
init|=
operator|(
name|args
operator|.
name|srcs
operator|.
name|size
argument_list|()
operator|==
literal|1
operator|&&
operator|!
name|dstExists
operator|)
operator|||
name|update
operator|||
name|overwrite
decl_stmt|;
name|Path
name|basedir
init|=
literal|null
decl_stmt|;
name|HashSet
argument_list|<
name|Path
argument_list|>
name|parentDirsToCopy
init|=
operator|new
name|HashSet
argument_list|<
name|Path
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|args
operator|.
name|basedir
operator|!=
literal|null
condition|)
block|{
name|FileSystem
name|basefs
init|=
name|args
operator|.
name|basedir
operator|.
name|getFileSystem
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|basedir
operator|=
name|args
operator|.
name|basedir
operator|.
name|makeQualified
argument_list|(
name|basefs
operator|.
name|getUri
argument_list|()
argument_list|,
name|basefs
operator|.
name|getWorkingDirectory
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|basefs
operator|.
name|isDirectory
argument_list|(
name|basedir
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Basedir "
operator|+
name|basedir
operator|+
literal|" is not a directory."
argument_list|)
throw|;
block|}
block|}
for|for
control|(
name|Iterator
argument_list|<
name|Path
argument_list|>
name|srcItr
init|=
name|args
operator|.
name|srcs
operator|.
name|iterator
argument_list|()
init|;
name|srcItr
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
specifier|final
name|Path
name|src
init|=
name|srcItr
operator|.
name|next
argument_list|()
decl_stmt|;
name|FileSystem
name|srcfs
init|=
name|src
operator|.
name|getFileSystem
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|FileStatus
name|srcfilestat
init|=
name|srcfs
operator|.
name|getFileStatus
argument_list|(
name|src
argument_list|)
decl_stmt|;
name|Path
name|root
init|=
name|special
operator|&&
name|srcfilestat
operator|.
name|isDirectory
argument_list|()
condition|?
name|src
else|:
name|src
operator|.
name|getParent
argument_list|()
decl_stmt|;
if|if
condition|(
name|dstExists
operator|&&
operator|!
name|dstIsDir
operator|&&
operator|(
name|args
operator|.
name|srcs
operator|.
name|size
argument_list|()
operator|>
literal|1
operator|||
name|srcfilestat
operator|.
name|isDirectory
argument_list|()
operator|)
condition|)
block|{
comment|// destination should not be a file
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Destination "
operator|+
name|args
operator|.
name|dst
operator|+
literal|" should be a dir"
operator|+
literal|" if multiple source paths are there OR if"
operator|+
literal|" the source path is a dir"
argument_list|)
throw|;
block|}
if|if
condition|(
name|basedir
operator|!=
literal|null
condition|)
block|{
name|root
operator|=
name|basedir
expr_stmt|;
name|Path
name|parent
init|=
name|src
operator|.
name|getParent
argument_list|()
operator|.
name|makeQualified
argument_list|(
name|srcfs
operator|.
name|getUri
argument_list|()
argument_list|,
name|srcfs
operator|.
name|getWorkingDirectory
argument_list|()
argument_list|)
decl_stmt|;
while|while
condition|(
name|parent
operator|!=
literal|null
operator|&&
operator|!
name|parent
operator|.
name|equals
argument_list|(
name|basedir
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|parentDirsToCopy
operator|.
name|contains
argument_list|(
name|parent
argument_list|)
condition|)
block|{
name|parentDirsToCopy
operator|.
name|add
argument_list|(
name|parent
argument_list|)
expr_stmt|;
name|String
name|dst
init|=
name|makeRelative
argument_list|(
name|root
argument_list|,
name|parent
argument_list|)
decl_stmt|;
name|FileStatus
name|pst
init|=
name|srcfs
operator|.
name|getFileStatus
argument_list|(
name|parent
argument_list|)
decl_stmt|;
name|src_writer
operator|.
name|append
argument_list|(
operator|new
name|LongWritable
argument_list|(
literal|0
argument_list|)
argument_list|,
operator|new
name|FilePair
argument_list|(
name|pst
argument_list|,
name|dst
argument_list|)
argument_list|)
expr_stmt|;
name|dst_writer
operator|.
name|append
argument_list|(
operator|new
name|Text
argument_list|(
name|dst
argument_list|)
argument_list|,
operator|new
name|Text
argument_list|(
name|parent
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|dir_writer
operator|.
name|append
argument_list|(
operator|new
name|Text
argument_list|(
name|dst
argument_list|)
argument_list|,
operator|new
name|FilePair
argument_list|(
name|pst
argument_list|,
name|dst
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|dirsyn
operator|>
name|SYNC_FILE_MAX
condition|)
block|{
name|dirsyn
operator|=
literal|0
expr_stmt|;
name|dir_writer
operator|.
name|sync
argument_list|()
expr_stmt|;
block|}
block|}
name|parent
operator|=
name|parent
operator|.
name|getParent
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|parent
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Basedir "
operator|+
name|basedir
operator|+
literal|" is not a prefix of source path "
operator|+
name|src
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
name|srcfilestat
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
operator|++
name|srcCount
expr_stmt|;
specifier|final
name|String
name|dst
init|=
name|makeRelative
argument_list|(
name|root
argument_list|,
name|src
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|update
operator|||
operator|!
name|dirExists
argument_list|(
name|conf
argument_list|,
operator|new
name|Path
argument_list|(
name|args
operator|.
name|dst
argument_list|,
name|dst
argument_list|)
argument_list|)
condition|)
block|{
operator|++
name|dirCount
expr_stmt|;
name|src_writer
operator|.
name|append
argument_list|(
operator|new
name|LongWritable
argument_list|(
literal|0
argument_list|)
argument_list|,
operator|new
name|FilePair
argument_list|(
name|srcfilestat
argument_list|,
name|dst
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|dst_writer
operator|.
name|append
argument_list|(
operator|new
name|Text
argument_list|(
name|dst
argument_list|)
argument_list|,
operator|new
name|Text
argument_list|(
name|src
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Stack
argument_list|<
name|FileStatus
argument_list|>
name|pathstack
init|=
operator|new
name|Stack
argument_list|<
name|FileStatus
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|pathstack
operator|.
name|push
argument_list|(
name|srcfilestat
argument_list|)
init|;
operator|!
name|pathstack
operator|.
name|empty
argument_list|()
condition|;
control|)
block|{
name|FileStatus
name|cur
init|=
name|pathstack
operator|.
name|pop
argument_list|()
decl_stmt|;
name|FileStatus
index|[]
name|children
init|=
name|srcfs
operator|.
name|listStatus
argument_list|(
name|cur
operator|.
name|getPath
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|children
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|boolean
name|skipPath
init|=
literal|false
decl_stmt|;
specifier|final
name|FileStatus
name|child
init|=
name|children
index|[
name|i
index|]
decl_stmt|;
specifier|final
name|String
name|dst
init|=
name|makeRelative
argument_list|(
name|root
argument_list|,
name|child
operator|.
name|getPath
argument_list|()
argument_list|)
decl_stmt|;
operator|++
name|srcCount
expr_stmt|;
if|if
condition|(
name|child
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
name|pathstack
operator|.
name|push
argument_list|(
name|child
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|update
operator|||
operator|!
name|dirExists
argument_list|(
name|conf
argument_list|,
operator|new
name|Path
argument_list|(
name|args
operator|.
name|dst
argument_list|,
name|dst
argument_list|)
argument_list|)
condition|)
block|{
operator|++
name|dirCount
expr_stmt|;
block|}
else|else
block|{
name|skipPath
operator|=
literal|true
expr_stmt|;
comment|// skip creating dir at destination
block|}
block|}
else|else
block|{
name|Path
name|destPath
init|=
operator|new
name|Path
argument_list|(
name|args
operator|.
name|dst
argument_list|,
name|dst
argument_list|)
decl_stmt|;
if|if
condition|(
name|cur
operator|.
name|isFile
argument_list|()
operator|&&
operator|(
name|args
operator|.
name|srcs
operator|.
name|size
argument_list|()
operator|==
literal|1
operator|)
condition|)
block|{
comment|// Copying a single file; use dst path provided by user as
comment|// destination file rather than destination directory
name|Path
name|dstparent
init|=
name|destPath
operator|.
name|getParent
argument_list|()
decl_stmt|;
name|FileSystem
name|destFileSys
init|=
name|destPath
operator|.
name|getFileSystem
argument_list|(
name|jobConf
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|destFileSys
operator|.
name|exists
argument_list|(
name|dstparent
argument_list|)
operator|&&
name|destFileSys
operator|.
name|getFileStatus
argument_list|(
name|dstparent
argument_list|)
operator|.
name|isDirectory
argument_list|()
operator|)
condition|)
block|{
name|destPath
operator|=
name|dstparent
expr_stmt|;
block|}
block|}
comment|//skip path if the src and the dst files are the same.
name|skipPath
operator|=
name|update
operator|&&
name|sameFile
argument_list|(
name|srcfs
argument_list|,
name|child
argument_list|,
name|dstfs
argument_list|,
name|destPath
argument_list|,
name|skipCRCCheck
argument_list|)
expr_stmt|;
comment|//skip path if it exceed file limit or size limit
name|skipPath
operator||=
name|fileCount
operator|==
name|args
operator|.
name|filelimit
operator|||
name|byteCount
operator|+
name|child
operator|.
name|getLen
argument_list|()
operator|>
name|args
operator|.
name|sizelimit
expr_stmt|;
if|if
condition|(
operator|!
name|skipPath
condition|)
block|{
operator|++
name|fileCount
expr_stmt|;
name|byteCount
operator|+=
name|child
operator|.
name|getLen
argument_list|()
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"adding file "
operator|+
name|child
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
block|}
operator|++
name|cnsyncf
expr_stmt|;
name|cbsyncs
operator|+=
name|child
operator|.
name|getLen
argument_list|()
expr_stmt|;
if|if
condition|(
name|cnsyncf
operator|>
name|SYNC_FILE_MAX
operator|||
name|cbsyncs
operator|>
name|maxBytesPerMap
condition|)
block|{
name|src_writer
operator|.
name|sync
argument_list|()
expr_stmt|;
name|dst_writer
operator|.
name|sync
argument_list|()
expr_stmt|;
name|cnsyncf
operator|=
literal|0
expr_stmt|;
name|cbsyncs
operator|=
literal|0L
expr_stmt|;
block|}
block|}
else|else
block|{
operator|++
name|skipFileCount
expr_stmt|;
name|skipByteCount
operator|+=
name|child
operator|.
name|getLen
argument_list|()
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"skipping file "
operator|+
name|child
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|skipPath
condition|)
block|{
name|src_writer
operator|.
name|append
argument_list|(
operator|new
name|LongWritable
argument_list|(
name|child
operator|.
name|isDirectory
argument_list|()
condition|?
literal|0
else|:
name|child
operator|.
name|getLen
argument_list|()
argument_list|)
argument_list|,
operator|new
name|FilePair
argument_list|(
name|child
argument_list|,
name|dst
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|dst_writer
operator|.
name|append
argument_list|(
operator|new
name|Text
argument_list|(
name|dst
argument_list|)
argument_list|,
operator|new
name|Text
argument_list|(
name|child
operator|.
name|getPath
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cur
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
name|String
name|dst
init|=
name|makeRelative
argument_list|(
name|root
argument_list|,
name|cur
operator|.
name|getPath
argument_list|()
argument_list|)
decl_stmt|;
name|dir_writer
operator|.
name|append
argument_list|(
operator|new
name|Text
argument_list|(
name|dst
argument_list|)
argument_list|,
operator|new
name|FilePair
argument_list|(
name|cur
argument_list|,
name|dst
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|dirsyn
operator|>
name|SYNC_FILE_MAX
condition|)
block|{
name|dirsyn
operator|=
literal|0
expr_stmt|;
name|dir_writer
operator|.
name|sync
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"sourcePathsCount(files+directories)="
operator|+
name|srcCount
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"filesToCopyCount="
operator|+
name|fileCount
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"bytesToCopyCount="
operator|+
name|TraditionalBinaryPrefix
operator|.
name|long2String
argument_list|(
name|byteCount
argument_list|,
literal|""
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|update
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"filesToSkipCopyCount="
operator|+
name|skipFileCount
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"bytesToSkipCopyCount="
operator|+
name|TraditionalBinaryPrefix
operator|.
name|long2String
argument_list|(
name|skipByteCount
argument_list|,
literal|""
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|args
operator|.
name|dryrun
condition|)
block|{
return|return
literal|false
return|;
block|}
name|int
name|mapCount
init|=
name|setMapCount
argument_list|(
name|byteCount
argument_list|,
name|jobConf
argument_list|)
decl_stmt|;
comment|// Increase the replication of _distcp_src_files, if needed
name|setReplication
argument_list|(
name|conf
argument_list|,
name|jobConf
argument_list|,
name|srcfilelist
argument_list|,
name|mapCount
argument_list|)
expr_stmt|;
name|FileStatus
name|dststatus
init|=
literal|null
decl_stmt|;
try|try
block|{
name|dststatus
operator|=
name|dstfs
operator|.
name|getFileStatus
argument_list|(
name|args
operator|.
name|dst
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|fnfe
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
name|args
operator|.
name|dst
operator|+
literal|" does not exist."
argument_list|)
expr_stmt|;
block|}
comment|// create dest path dir if copying> 1 file
if|if
condition|(
name|dststatus
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|srcCount
operator|>
literal|1
operator|&&
operator|!
name|dstfs
operator|.
name|mkdirs
argument_list|(
name|args
operator|.
name|dst
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Failed to create"
operator|+
name|args
operator|.
name|dst
argument_list|)
throw|;
block|}
block|}
specifier|final
name|Path
name|sorted
init|=
operator|new
name|Path
argument_list|(
name|jobDirectory
argument_list|,
literal|"_distcp_sorted"
argument_list|)
decl_stmt|;
name|checkDuplication
argument_list|(
name|jobfs
argument_list|,
name|dstfilelist
argument_list|,
name|sorted
argument_list|,
name|conf
argument_list|)
expr_stmt|;
if|if
condition|(
name|dststatus
operator|!=
literal|null
operator|&&
name|args
operator|.
name|flags
operator|.
name|contains
argument_list|(
name|Options
operator|.
name|DELETE
argument_list|)
condition|)
block|{
name|long
name|deletedPathsCount
init|=
name|deleteNonexisting
argument_list|(
name|dstfs
argument_list|,
name|dststatus
argument_list|,
name|sorted
argument_list|,
name|jobfs
argument_list|,
name|jobDirectory
argument_list|,
name|jobConf
argument_list|,
name|conf
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"deletedPathsFromDestCount(files+directories)="
operator|+
name|deletedPathsCount
argument_list|)
expr_stmt|;
block|}
name|Path
name|tmpDir
init|=
operator|new
name|Path
argument_list|(
operator|(
name|dstExists
operator|&&
operator|!
name|dstIsDir
operator|)
operator|||
operator|(
operator|!
name|dstExists
operator|&&
name|srcCount
operator|==
literal|1
operator|)
condition|?
name|args
operator|.
name|dst
operator|.
name|getParent
argument_list|()
else|:
name|args
operator|.
name|dst
argument_list|,
literal|"_distcp_tmp_"
operator|+
name|randomId
argument_list|)
decl_stmt|;
name|jobConf
operator|.
name|set
argument_list|(
name|TMP_DIR_LABEL
argument_list|,
name|tmpDir
operator|.
name|toUri
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
comment|// Explicitly create the tmpDir to ensure that it can be cleaned
comment|// up by fullyDelete() later.
name|tmpDir
operator|.
name|getFileSystem
argument_list|(
name|conf
argument_list|)
operator|.
name|mkdirs
argument_list|(
name|tmpDir
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"sourcePathsCount="
operator|+
name|srcCount
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"filesToCopyCount="
operator|+
name|fileCount
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"bytesToCopyCount="
operator|+
name|TraditionalBinaryPrefix
operator|.
name|long2String
argument_list|(
name|byteCount
argument_list|,
literal|""
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|jobConf
operator|.
name|setInt
argument_list|(
name|SRC_COUNT_LABEL
argument_list|,
name|srcCount
argument_list|)
expr_stmt|;
name|jobConf
operator|.
name|setLong
argument_list|(
name|TOTAL_SIZE_LABEL
argument_list|,
name|byteCount
argument_list|)
expr_stmt|;
return|return
operator|(
name|fileCount
operator|+
name|dirCount
operator|)
operator|>
literal|0
return|;
block|}
comment|/**    * Check whether the contents of src and dst are the same.    *     * Return false if dstpath does not exist    *     * If the files have different sizes, return false.    *     * If the files have the same sizes, the file checksums will be compared.    *     * When file checksum is not supported in any of file systems,    * two files are considered as the same if they have the same size.    */
DECL|method|sameFile (FileSystem srcfs, FileStatus srcstatus, FileSystem dstfs, Path dstpath, boolean skipCRCCheck)
specifier|static
specifier|private
name|boolean
name|sameFile
parameter_list|(
name|FileSystem
name|srcfs
parameter_list|,
name|FileStatus
name|srcstatus
parameter_list|,
name|FileSystem
name|dstfs
parameter_list|,
name|Path
name|dstpath
parameter_list|,
name|boolean
name|skipCRCCheck
parameter_list|)
throws|throws
name|IOException
block|{
name|FileStatus
name|dststatus
decl_stmt|;
try|try
block|{
name|dststatus
operator|=
name|dstfs
operator|.
name|getFileStatus
argument_list|(
name|dstpath
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|fnfe
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
comment|//same length?
if|if
condition|(
name|srcstatus
operator|.
name|getLen
argument_list|()
operator|!=
name|dststatus
operator|.
name|getLen
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|skipCRCCheck
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Skipping the CRC check"
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|//get src checksum
specifier|final
name|FileChecksum
name|srccs
decl_stmt|;
try|try
block|{
name|srccs
operator|=
name|srcfs
operator|.
name|getFileChecksum
argument_list|(
name|srcstatus
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|fnfe
parameter_list|)
block|{
comment|/*        * Two possible cases:        * (1) src existed once but was deleted between the time period that        *     srcstatus was obtained and the try block above.        * (2) srcfs does not support file checksum and (incorrectly) throws        *     FNFE, e.g. some previous versions of HftpFileSystem.        * For case (1), it is okay to return true since src was already deleted.        * For case (2), true should be returned.          */
return|return
literal|true
return|;
block|}
comment|//compare checksums
try|try
block|{
specifier|final
name|FileChecksum
name|dstcs
init|=
name|dstfs
operator|.
name|getFileChecksum
argument_list|(
name|dststatus
operator|.
name|getPath
argument_list|()
argument_list|)
decl_stmt|;
comment|//return true if checksum is not supported
comment|//(i.e. some of the checksums is null)
return|return
name|srccs
operator|==
literal|null
operator|||
name|dstcs
operator|==
literal|null
operator|||
name|srccs
operator|.
name|equals
argument_list|(
name|dstcs
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|fnfe
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
block|}
comment|/**    * Delete the dst files/dirs which do not exist in src    *     * @return total count of files and directories deleted from destination    * @throws IOException    */
DECL|method|deleteNonexisting ( FileSystem dstfs, FileStatus dstroot, Path dstsorted, FileSystem jobfs, Path jobdir, JobConf jobconf, Configuration conf )
specifier|static
specifier|private
name|long
name|deleteNonexisting
parameter_list|(
name|FileSystem
name|dstfs
parameter_list|,
name|FileStatus
name|dstroot
parameter_list|,
name|Path
name|dstsorted
parameter_list|,
name|FileSystem
name|jobfs
parameter_list|,
name|Path
name|jobdir
parameter_list|,
name|JobConf
name|jobconf
parameter_list|,
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|dstroot
operator|.
name|isFile
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"dst must be a directory when option "
operator|+
name|Options
operator|.
name|DELETE
operator|.
name|cmd
operator|+
literal|" is set, but dst (= "
operator|+
name|dstroot
operator|.
name|getPath
argument_list|()
operator|+
literal|") is not a directory."
argument_list|)
throw|;
block|}
comment|//write dst lsr results
specifier|final
name|Path
name|dstlsr
init|=
operator|new
name|Path
argument_list|(
name|jobdir
argument_list|,
literal|"_distcp_dst_lsr"
argument_list|)
decl_stmt|;
try|try
init|(
specifier|final
name|SequenceFile
operator|.
name|Writer
name|writer
init|=
name|SequenceFile
operator|.
name|createWriter
argument_list|(
name|jobconf
argument_list|,
name|Writer
operator|.
name|file
argument_list|(
name|dstlsr
argument_list|)
argument_list|,
name|Writer
operator|.
name|keyClass
argument_list|(
name|Text
operator|.
name|class
argument_list|)
argument_list|,
name|Writer
operator|.
name|valueClass
argument_list|(
name|NullWritable
operator|.
name|class
argument_list|)
argument_list|,
name|Writer
operator|.
name|compression
argument_list|(
name|SequenceFile
operator|.
name|CompressionType
operator|.
name|NONE
argument_list|)
argument_list|)
init|)
block|{
comment|//do lsr to get all file statuses in dstroot
specifier|final
name|Stack
argument_list|<
name|FileStatus
argument_list|>
name|lsrstack
init|=
operator|new
name|Stack
argument_list|<
name|FileStatus
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|lsrstack
operator|.
name|push
argument_list|(
name|dstroot
argument_list|)
init|;
operator|!
name|lsrstack
operator|.
name|isEmpty
argument_list|()
condition|;
control|)
block|{
specifier|final
name|FileStatus
name|status
init|=
name|lsrstack
operator|.
name|pop
argument_list|()
decl_stmt|;
if|if
condition|(
name|status
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
for|for
control|(
name|FileStatus
name|child
range|:
name|dstfs
operator|.
name|listStatus
argument_list|(
name|status
operator|.
name|getPath
argument_list|()
argument_list|)
control|)
block|{
name|String
name|relative
init|=
name|makeRelative
argument_list|(
name|dstroot
operator|.
name|getPath
argument_list|()
argument_list|,
name|child
operator|.
name|getPath
argument_list|()
argument_list|)
decl_stmt|;
name|writer
operator|.
name|append
argument_list|(
operator|new
name|Text
argument_list|(
name|relative
argument_list|)
argument_list|,
name|NullWritable
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
name|lsrstack
operator|.
name|push
argument_list|(
name|child
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|//sort lsr results
specifier|final
name|Path
name|sortedlsr
init|=
operator|new
name|Path
argument_list|(
name|jobdir
argument_list|,
literal|"_distcp_dst_lsr_sorted"
argument_list|)
decl_stmt|;
name|SequenceFile
operator|.
name|Sorter
name|sorter
init|=
operator|new
name|SequenceFile
operator|.
name|Sorter
argument_list|(
name|jobfs
argument_list|,
operator|new
name|Text
operator|.
name|Comparator
argument_list|()
argument_list|,
name|Text
operator|.
name|class
argument_list|,
name|NullWritable
operator|.
name|class
argument_list|,
name|jobconf
argument_list|)
decl_stmt|;
name|sorter
operator|.
name|sort
argument_list|(
name|dstlsr
argument_list|,
name|sortedlsr
argument_list|)
expr_stmt|;
comment|//compare lsr list and dst list
name|long
name|deletedPathsCount
init|=
literal|0
decl_stmt|;
try|try
init|(
name|SequenceFile
operator|.
name|Reader
name|lsrin
init|=
operator|new
name|SequenceFile
operator|.
name|Reader
argument_list|(
name|jobconf
argument_list|,
name|Reader
operator|.
name|file
argument_list|(
name|sortedlsr
argument_list|)
argument_list|)
init|;
name|SequenceFile
operator|.
name|Reader
name|dstin
operator|=
operator|new
name|SequenceFile
operator|.
name|Reader
argument_list|(
name|jobconf
argument_list|,
name|Reader
operator|.
name|file
argument_list|(
name|dstsorted
argument_list|)
argument_list|)
init|)
block|{
comment|//compare sorted lsr list and sorted dst list
specifier|final
name|Text
name|lsrpath
init|=
operator|new
name|Text
argument_list|()
decl_stmt|;
specifier|final
name|Text
name|dstpath
init|=
operator|new
name|Text
argument_list|()
decl_stmt|;
specifier|final
name|Text
name|dstfrom
init|=
operator|new
name|Text
argument_list|()
decl_stmt|;
specifier|final
name|Trash
name|trash
init|=
operator|new
name|Trash
argument_list|(
name|dstfs
argument_list|,
name|conf
argument_list|)
decl_stmt|;
name|Path
name|lastpath
init|=
literal|null
decl_stmt|;
name|boolean
name|hasnext
init|=
name|dstin
operator|.
name|next
argument_list|(
name|dstpath
argument_list|,
name|dstfrom
argument_list|)
decl_stmt|;
while|while
condition|(
name|lsrin
operator|.
name|next
argument_list|(
name|lsrpath
argument_list|,
name|NullWritable
operator|.
name|get
argument_list|()
argument_list|)
condition|)
block|{
name|int
name|dst_cmp_lsr
init|=
name|dstpath
operator|.
name|compareTo
argument_list|(
name|lsrpath
argument_list|)
decl_stmt|;
while|while
condition|(
name|hasnext
operator|&&
name|dst_cmp_lsr
operator|<
literal|0
condition|)
block|{
name|hasnext
operator|=
name|dstin
operator|.
name|next
argument_list|(
name|dstpath
argument_list|,
name|dstfrom
argument_list|)
expr_stmt|;
name|dst_cmp_lsr
operator|=
name|dstpath
operator|.
name|compareTo
argument_list|(
name|lsrpath
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dst_cmp_lsr
operator|==
literal|0
condition|)
block|{
comment|//lsrpath exists in dst, skip it
name|hasnext
operator|=
name|dstin
operator|.
name|next
argument_list|(
name|dstpath
argument_list|,
name|dstfrom
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|//lsrpath does not exist, delete it
specifier|final
name|Path
name|rmpath
init|=
operator|new
name|Path
argument_list|(
name|dstroot
operator|.
name|getPath
argument_list|()
argument_list|,
name|lsrpath
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
operator|++
name|deletedPathsCount
expr_stmt|;
if|if
condition|(
operator|(
name|lastpath
operator|==
literal|null
operator|||
operator|!
name|isAncestorPath
argument_list|(
name|lastpath
argument_list|,
name|rmpath
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|trash
operator|.
name|moveToTrash
argument_list|(
name|rmpath
argument_list|)
operator|||
name|dstfs
operator|.
name|delete
argument_list|(
name|rmpath
argument_list|,
literal|true
argument_list|)
operator|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Failed to delete "
operator|+
name|rmpath
argument_list|)
throw|;
block|}
name|lastpath
operator|=
name|rmpath
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
name|deletedPathsCount
return|;
block|}
comment|//is x an ancestor path of y?
DECL|method|isAncestorPath (Path xp, Path yp)
specifier|static
specifier|private
name|boolean
name|isAncestorPath
parameter_list|(
name|Path
name|xp
parameter_list|,
name|Path
name|yp
parameter_list|)
block|{
specifier|final
name|String
name|x
init|=
name|xp
operator|.
name|toString
argument_list|()
decl_stmt|;
specifier|final
name|String
name|y
init|=
name|yp
operator|.
name|toString
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|y
operator|.
name|startsWith
argument_list|(
name|x
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
specifier|final
name|int
name|len
init|=
name|x
operator|.
name|length
argument_list|()
decl_stmt|;
return|return
name|y
operator|.
name|length
argument_list|()
operator|==
name|len
operator|||
name|y
operator|.
name|charAt
argument_list|(
name|len
argument_list|)
operator|==
name|Path
operator|.
name|SEPARATOR_CHAR
return|;
block|}
comment|/** Check whether the file list have duplication. */
DECL|method|checkDuplication (FileSystem fs, Path file, Path sorted, Configuration conf)
specifier|static
specifier|private
name|void
name|checkDuplication
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Path
name|file
parameter_list|,
name|Path
name|sorted
parameter_list|,
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|SequenceFile
operator|.
name|Sorter
name|sorter
init|=
operator|new
name|SequenceFile
operator|.
name|Sorter
argument_list|(
name|fs
argument_list|,
operator|new
name|Text
operator|.
name|Comparator
argument_list|()
argument_list|,
name|Text
operator|.
name|class
argument_list|,
name|Text
operator|.
name|class
argument_list|,
name|conf
argument_list|)
decl_stmt|;
name|sorter
operator|.
name|sort
argument_list|(
name|file
argument_list|,
name|sorted
argument_list|)
expr_stmt|;
try|try
init|(
name|SequenceFile
operator|.
name|Reader
name|in
init|=
operator|new
name|SequenceFile
operator|.
name|Reader
argument_list|(
name|conf
argument_list|,
name|Reader
operator|.
name|file
argument_list|(
name|sorted
argument_list|)
argument_list|)
init|)
block|{
name|Text
name|prevdst
init|=
literal|null
decl_stmt|,
name|curdst
init|=
operator|new
name|Text
argument_list|()
decl_stmt|;
name|Text
name|prevsrc
init|=
literal|null
decl_stmt|,
name|cursrc
init|=
operator|new
name|Text
argument_list|()
decl_stmt|;
for|for
control|(
init|;
name|in
operator|.
name|next
argument_list|(
name|curdst
argument_list|,
name|cursrc
argument_list|)
condition|;
control|)
block|{
if|if
condition|(
name|prevdst
operator|!=
literal|null
operator|&&
name|curdst
operator|.
name|equals
argument_list|(
name|prevdst
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|DuplicationException
argument_list|(
literal|"Invalid input, there are duplicated files in the sources: "
operator|+
name|prevsrc
operator|+
literal|", "
operator|+
name|cursrc
argument_list|)
throw|;
block|}
name|prevdst
operator|=
name|curdst
expr_stmt|;
name|curdst
operator|=
operator|new
name|Text
argument_list|()
expr_stmt|;
name|prevsrc
operator|=
name|cursrc
expr_stmt|;
name|cursrc
operator|=
operator|new
name|Text
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/** An exception class for duplicated source files. */
DECL|class|DuplicationException
specifier|public
specifier|static
class|class
name|DuplicationException
extends|extends
name|IOException
block|{
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|1L
decl_stmt|;
comment|/** Error code for this exception */
DECL|field|ERROR_CODE
specifier|public
specifier|static
specifier|final
name|int
name|ERROR_CODE
init|=
operator|-
literal|2
decl_stmt|;
DECL|method|DuplicationException (String message)
name|DuplicationException
parameter_list|(
name|String
name|message
parameter_list|)
block|{
name|super
argument_list|(
name|message
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

