begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  *  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdfs.web
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|web
package|;
end_package

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|BlockLocation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|CreateFlag
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FSDataInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FSDataOutputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FSInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|permission
operator|.
name|FsPermission
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|web
operator|.
name|resources
operator|.
name|ADLFlush
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|web
operator|.
name|resources
operator|.
name|ADLGetOpParam
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|web
operator|.
name|resources
operator|.
name|ADLPostOpParam
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|web
operator|.
name|resources
operator|.
name|ADLPutOpParam
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|web
operator|.
name|resources
operator|.
name|ADLVersionInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|web
operator|.
name|resources
operator|.
name|AppendADLNoRedirectParam
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|web
operator|.
name|resources
operator|.
name|BlockSizeParam
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|web
operator|.
name|resources
operator|.
name|BufferSizeParam
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|web
operator|.
name|resources
operator|.
name|CreateADLNoRedirectParam
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|web
operator|.
name|resources
operator|.
name|CreateFlagParam
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|web
operator|.
name|resources
operator|.
name|CreateParentParam
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|web
operator|.
name|resources
operator|.
name|GetOpParam
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|web
operator|.
name|resources
operator|.
name|HttpOpParam
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|web
operator|.
name|resources
operator|.
name|LeaseParam
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|web
operator|.
name|resources
operator|.
name|LengthParam
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|web
operator|.
name|resources
operator|.
name|OffsetParam
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|web
operator|.
name|resources
operator|.
name|OverwriteParam
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|web
operator|.
name|resources
operator|.
name|Param
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|web
operator|.
name|resources
operator|.
name|PermissionParam
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|web
operator|.
name|resources
operator|.
name|PutOpParam
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|web
operator|.
name|resources
operator|.
name|ReadADLNoRedirectParam
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|web
operator|.
name|resources
operator|.
name|ReplicationParam
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|UserGroupInformation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Progressable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|VersionInfo
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|HttpURLConnection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|SocketException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URI
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URL
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|EnumSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Callable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutionException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutorService
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Executors
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Future
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_comment
comment|/**  * Extended @see SWebHdfsFileSystem API. This class contains Azure data lake  * specific stability, Reliability and performance improvement.  *<p>  * Motivation behind PrivateAzureDataLakeFileSystem to encapsulate dependent  * implementation on org.apache.hadoop.hdfs.web package to configure query  * parameters, configuration over HTTP request send to backend .. etc. This  * class should be refactored and moved under package org.apache.hadoop.fs  * .adl once the required dependent changes are made into ASF code.  */
end_comment

begin_class
DECL|class|PrivateAzureDataLakeFileSystem
specifier|public
class|class
name|PrivateAzureDataLakeFileSystem
extends|extends
name|SWebHdfsFileSystem
block|{
DECL|field|SCHEME
specifier|public
specifier|static
specifier|final
name|String
name|SCHEME
init|=
literal|"adl"
decl_stmt|;
comment|// Feature configuration
DECL|field|featureGetBlockLocationLocallyBundled
specifier|private
name|boolean
name|featureGetBlockLocationLocallyBundled
init|=
literal|true
decl_stmt|;
DECL|field|featureConcurrentReadWithReadAhead
specifier|private
name|boolean
name|featureConcurrentReadWithReadAhead
init|=
literal|true
decl_stmt|;
DECL|field|featureRedirectOff
specifier|private
name|boolean
name|featureRedirectOff
init|=
literal|true
decl_stmt|;
DECL|field|featureFlushWhenEOF
specifier|private
name|boolean
name|featureFlushWhenEOF
init|=
literal|true
decl_stmt|;
DECL|field|overrideOwner
specifier|private
name|boolean
name|overrideOwner
init|=
literal|false
decl_stmt|;
DECL|field|maxConcurrentConnection
specifier|private
name|int
name|maxConcurrentConnection
decl_stmt|;
DECL|field|maxBufferSize
specifier|private
name|int
name|maxBufferSize
decl_stmt|;
DECL|field|userName
specifier|private
name|String
name|userName
decl_stmt|;
comment|/**    * Constructor.    */
DECL|method|PrivateAzureDataLakeFileSystem ()
specifier|public
name|PrivateAzureDataLakeFileSystem
parameter_list|()
block|{
try|try
block|{
name|userName
operator|=
name|UserGroupInformation
operator|.
name|getCurrentUser
argument_list|()
operator|.
name|getShortUserName
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|userName
operator|=
literal|"hadoop"
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|initialize (URI uri, Configuration conf)
specifier|public
specifier|synchronized
name|void
name|initialize
parameter_list|(
name|URI
name|uri
parameter_list|,
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|super
operator|.
name|initialize
argument_list|(
name|uri
argument_list|,
name|conf
argument_list|)
expr_stmt|;
name|overrideOwner
operator|=
name|getConf
argument_list|()
operator|.
name|getBoolean
argument_list|(
name|ADLConfKeys
operator|.
name|ADL_DEBUG_OVERRIDE_LOCAL_USER_AS_OWNER
argument_list|,
name|ADLConfKeys
operator|.
name|ADL_DEBUG_SET_LOCAL_USER_AS_OWNER_DEFAULT
argument_list|)
expr_stmt|;
name|featureRedirectOff
operator|=
name|getConf
argument_list|()
operator|.
name|getBoolean
argument_list|(
name|ADLConfKeys
operator|.
name|ADL_FEATURE_REDIRECT_OFF
argument_list|,
name|ADLConfKeys
operator|.
name|ADL_FEATURE_REDIRECT_OFF_DEFAULT
argument_list|)
expr_stmt|;
name|featureGetBlockLocationLocallyBundled
operator|=
name|getConf
argument_list|()
operator|.
name|getBoolean
argument_list|(
name|ADLConfKeys
operator|.
name|ADL_FEATURE_GET_BLOCK_LOCATION_LOCALLY_BUNDLED
argument_list|,
name|ADLConfKeys
operator|.
name|ADL_FEATURE_GET_BLOCK_LOCATION_LOCALLY_BUNDLED_DEFAULT
argument_list|)
expr_stmt|;
name|featureConcurrentReadWithReadAhead
operator|=
name|getConf
argument_list|()
operator|.
name|getBoolean
argument_list|(
name|ADLConfKeys
operator|.
name|ADL_FEATURE_CONCURRENT_READ_WITH_READ_AHEAD
argument_list|,
name|ADLConfKeys
operator|.
name|ADL_FEATURE_CONCURRENT_READ_WITH_READ_AHEAD_DEFAULT
argument_list|)
expr_stmt|;
name|maxBufferSize
operator|=
name|getConf
argument_list|()
operator|.
name|getInt
argument_list|(
name|ADLConfKeys
operator|.
name|ADL_FEATURE_CONCURRENT_READ_WITH_READ_AHEAD_BUFFER_SIZE
argument_list|,
name|ADLConfKeys
operator|.
name|ADL_FEATURE_CONCURRENT_READ_WITH_READ_AHEAD_BUFFER_SIZE_DEFAULT
argument_list|)
expr_stmt|;
name|maxConcurrentConnection
operator|=
name|getConf
argument_list|()
operator|.
name|getInt
argument_list|(
name|ADLConfKeys
operator|.
name|ADL_FEATURE_CONCURRENT_READ_AHEAD_MAX_CONCURRENT_CONN
argument_list|,
name|ADLConfKeys
operator|.
name|ADL_FEATURE_CONCURRENT_READ_AHEAD_MAX_CONCURRENT_CONN_DEFAULT
argument_list|)
expr_stmt|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|isFeatureGetBlockLocationLocallyBundled ()
specifier|protected
name|boolean
name|isFeatureGetBlockLocationLocallyBundled
parameter_list|()
block|{
return|return
name|featureGetBlockLocationLocallyBundled
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|isFeatureConcurrentReadWithReadAhead ()
specifier|protected
name|boolean
name|isFeatureConcurrentReadWithReadAhead
parameter_list|()
block|{
return|return
name|featureConcurrentReadWithReadAhead
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|isFeatureRedirectOff ()
specifier|protected
name|boolean
name|isFeatureRedirectOff
parameter_list|()
block|{
return|return
name|featureRedirectOff
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|isOverrideOwnerFeatureOn ()
specifier|protected
name|boolean
name|isOverrideOwnerFeatureOn
parameter_list|()
block|{
return|return
name|overrideOwner
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|getMaxBufferSize ()
specifier|protected
name|int
name|getMaxBufferSize
parameter_list|()
block|{
return|return
name|maxBufferSize
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|getMaxConcurrentConnection ()
specifier|protected
name|int
name|getMaxConcurrentConnection
parameter_list|()
block|{
return|return
name|maxConcurrentConnection
return|;
block|}
annotation|@
name|Override
DECL|method|getScheme ()
specifier|public
name|String
name|getScheme
parameter_list|()
block|{
return|return
name|SCHEME
return|;
block|}
comment|/**    * Constructing home directory locally is fine as long as Hadoop    * local user name and ADL user name relationship story is not fully baked    * yet.    *    * @return Hadoop local user home directory.    */
annotation|@
name|Override
DECL|method|getHomeDirectory ()
specifier|public
specifier|final
name|Path
name|getHomeDirectory
parameter_list|()
block|{
try|try
block|{
return|return
name|makeQualified
argument_list|(
operator|new
name|Path
argument_list|(
literal|"/user/"
operator|+
name|UserGroupInformation
operator|.
name|getCurrentUser
argument_list|()
operator|.
name|getShortUserName
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{     }
return|return
operator|new
name|Path
argument_list|(
literal|"/user/"
operator|+
name|userName
argument_list|)
return|;
block|}
comment|/**    * Azure data lake does not support user configuration for data replication    * hence not leaving system to query on    * azure data lake.    *    * Stub implementation    *    * @param p           Not honoured    * @param replication Not honoured    * @return True hard coded since ADL file system does not support    * replication configuration    * @throws IOException No exception would not thrown in this case however    *                     aligning with parent api definition.    */
annotation|@
name|Override
DECL|method|setReplication (final Path p, final short replication)
specifier|public
specifier|final
name|boolean
name|setReplication
parameter_list|(
specifier|final
name|Path
name|p
parameter_list|,
specifier|final
name|short
name|replication
parameter_list|)
throws|throws
name|IOException
block|{
return|return
literal|true
return|;
block|}
comment|/**    * @param f File/Folder path    * @return FileStatus instance containing metadata information of f    * @throws IOException For any system error    */
annotation|@
name|Override
DECL|method|getFileStatus (Path f)
specifier|public
name|FileStatus
name|getFileStatus
parameter_list|(
name|Path
name|f
parameter_list|)
throws|throws
name|IOException
block|{
name|statistics
operator|.
name|incrementReadOps
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|FileStatus
name|status
init|=
name|super
operator|.
name|getFileStatus
argument_list|(
name|f
argument_list|)
decl_stmt|;
if|if
condition|(
name|overrideOwner
condition|)
block|{
name|FileStatus
name|proxiedStatus
init|=
operator|new
name|FileStatus
argument_list|(
name|status
operator|.
name|getLen
argument_list|()
argument_list|,
name|status
operator|.
name|isDirectory
argument_list|()
argument_list|,
name|status
operator|.
name|getReplication
argument_list|()
argument_list|,
name|status
operator|.
name|getBlockSize
argument_list|()
argument_list|,
name|status
operator|.
name|getModificationTime
argument_list|()
argument_list|,
name|status
operator|.
name|getAccessTime
argument_list|()
argument_list|,
name|status
operator|.
name|getPermission
argument_list|()
argument_list|,
name|userName
argument_list|,
literal|"hdfs"
argument_list|,
name|status
operator|.
name|getPath
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|proxiedStatus
return|;
block|}
else|else
block|{
return|return
name|status
return|;
block|}
block|}
comment|/**    * Create call semantic is handled differently in case of ADL. Create    * semantics is translated to Create/Append    * semantics.    * 1. No dedicated connection to server.    * 2. Buffering is locally done, Once buffer is full or flush is invoked on    * the by the caller. All the pending    * data is pushed to ADL as APPEND operation code.    * 3. On close - Additional call is send to server to close the stream, and    * release lock from the stream.    *    * Necessity of Create/Append semantics is    * 1. ADL backend server does not allow idle connection for longer duration    * . In case of slow writer scenario,    * observed connection timeout/Connection reset causing occasional job    * failures.    * 2. Performance boost to jobs which are slow writer, avoided network latency    * 3. ADL equally better performing with multiple of 4MB chunk as append    * calls.    *    * @param f           File path    * @param permission  Access permission for the newly created file    * @param overwrite   Remove existing file and recreate new one if true    *                    otherwise throw error if file exist    * @param bufferSize  Buffer size, ADL backend does not honour    * @param replication Replication count, ADL backend does not honour    * @param blockSize   Block size, ADL backend does not honour    * @param progress    Progress indicator    * @return FSDataOutputStream OutputStream on which application can push    * stream of bytes    * @throws IOException when system error, internal server error or user error    */
annotation|@
name|Override
DECL|method|create (final Path f, final FsPermission permission, final boolean overwrite, final int bufferSize, final short replication, final long blockSize, final Progressable progress)
specifier|public
name|FSDataOutputStream
name|create
parameter_list|(
specifier|final
name|Path
name|f
parameter_list|,
specifier|final
name|FsPermission
name|permission
parameter_list|,
specifier|final
name|boolean
name|overwrite
parameter_list|,
specifier|final
name|int
name|bufferSize
parameter_list|,
specifier|final
name|short
name|replication
parameter_list|,
specifier|final
name|long
name|blockSize
parameter_list|,
specifier|final
name|Progressable
name|progress
parameter_list|)
throws|throws
name|IOException
block|{
name|statistics
operator|.
name|incrementWriteOps
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
operator|new
name|FSDataOutputStream
argument_list|(
operator|new
name|BatchAppendOutputStream
argument_list|(
name|f
argument_list|,
name|bufferSize
argument_list|,
operator|new
name|PermissionParam
argument_list|(
name|applyUMask
argument_list|(
name|permission
argument_list|)
argument_list|)
argument_list|,
operator|new
name|OverwriteParam
argument_list|(
name|overwrite
argument_list|)
argument_list|,
operator|new
name|BufferSizeParam
argument_list|(
name|bufferSize
argument_list|)
argument_list|,
operator|new
name|ReplicationParam
argument_list|(
name|replication
argument_list|)
argument_list|,
operator|new
name|BlockSizeParam
argument_list|(
name|blockSize
argument_list|)
argument_list|,
operator|new
name|ADLVersionInfo
argument_list|(
name|VersionInfo
operator|.
name|getVersion
argument_list|()
argument_list|)
argument_list|)
argument_list|,
name|statistics
argument_list|)
block|{     }
return|;
block|}
annotation|@
name|Override
DECL|method|createNonRecursive (final Path f, final FsPermission permission, final EnumSet<CreateFlag> flag, final int bufferSize, final short replication, final long blockSize, final Progressable progress)
specifier|public
name|FSDataOutputStream
name|createNonRecursive
parameter_list|(
specifier|final
name|Path
name|f
parameter_list|,
specifier|final
name|FsPermission
name|permission
parameter_list|,
specifier|final
name|EnumSet
argument_list|<
name|CreateFlag
argument_list|>
name|flag
parameter_list|,
specifier|final
name|int
name|bufferSize
parameter_list|,
specifier|final
name|short
name|replication
parameter_list|,
specifier|final
name|long
name|blockSize
parameter_list|,
specifier|final
name|Progressable
name|progress
parameter_list|)
throws|throws
name|IOException
block|{
name|statistics
operator|.
name|incrementWriteOps
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|String
name|leaseId
init|=
name|java
operator|.
name|util
operator|.
name|UUID
operator|.
name|randomUUID
argument_list|()
operator|.
name|toString
argument_list|()
decl_stmt|;
return|return
operator|new
name|FSDataOutputStream
argument_list|(
operator|new
name|BatchAppendOutputStream
argument_list|(
name|f
argument_list|,
name|bufferSize
argument_list|,
operator|new
name|PermissionParam
argument_list|(
name|applyUMask
argument_list|(
name|permission
argument_list|)
argument_list|)
argument_list|,
operator|new
name|CreateFlagParam
argument_list|(
name|flag
argument_list|)
argument_list|,
operator|new
name|CreateParentParam
argument_list|(
literal|false
argument_list|)
argument_list|,
operator|new
name|BufferSizeParam
argument_list|(
name|bufferSize
argument_list|)
argument_list|,
operator|new
name|ReplicationParam
argument_list|(
name|replication
argument_list|)
argument_list|,
operator|new
name|LeaseParam
argument_list|(
name|leaseId
argument_list|)
argument_list|,
operator|new
name|BlockSizeParam
argument_list|(
name|blockSize
argument_list|)
argument_list|,
operator|new
name|ADLVersionInfo
argument_list|(
name|VersionInfo
operator|.
name|getVersion
argument_list|()
argument_list|)
argument_list|)
argument_list|,
name|statistics
argument_list|)
block|{     }
return|;
block|}
comment|/**    * Since defined as private in parent class, redefined to pass through    * Create api implementation.    *    * @param permission    * @return FsPermission list    */
DECL|method|applyUMask (FsPermission permission)
specifier|private
name|FsPermission
name|applyUMask
parameter_list|(
name|FsPermission
name|permission
parameter_list|)
block|{
name|FsPermission
name|fsPermission
init|=
name|permission
decl_stmt|;
if|if
condition|(
name|fsPermission
operator|==
literal|null
condition|)
block|{
name|fsPermission
operator|=
name|FsPermission
operator|.
name|getDefault
argument_list|()
expr_stmt|;
block|}
return|return
name|fsPermission
operator|.
name|applyUMask
argument_list|(
name|FsPermission
operator|.
name|getUMask
argument_list|(
name|getConf
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Open call semantic is handled differently in case of ADL. Instead of    * network stream is returned to the user,    * Overridden FsInputStream is returned.    *    * 1. No dedicated connection to server.    * 2. Process level concurrent read ahead Buffering is done, This allows    * data to be available for caller quickly.    * 3. Number of byte to read ahead is configurable.    *    * Advantage of Process level concurrent read ahead Buffering semantics is    * 1. ADL backend server does not allow idle connection for longer duration    * . In case of slow reader scenario,    * observed connection timeout/Connection reset causing occasional job    * failures.    * 2. Performance boost to jobs which are slow reader, avoided network latency    * 3. Compressed format support like ORC, and large data files gains the    * most out of this implementation.    *    * Read ahead feature is configurable.    *    * @param f          File path    * @param buffersize Buffer size    * @return FSDataInputStream InputStream on which application can read    * stream of bytes    * @throws IOException when system error, internal server error or user error    */
annotation|@
name|Override
DECL|method|open (final Path f, final int buffersize)
specifier|public
name|FSDataInputStream
name|open
parameter_list|(
specifier|final
name|Path
name|f
parameter_list|,
specifier|final
name|int
name|buffersize
parameter_list|)
throws|throws
name|IOException
block|{
name|statistics
operator|.
name|incrementReadOps
argument_list|(
literal|1
argument_list|)
expr_stmt|;
specifier|final
name|HttpOpParam
operator|.
name|Op
name|op
init|=
name|GetOpParam
operator|.
name|Op
operator|.
name|OPEN
decl_stmt|;
comment|// use a runner so the open can recover from an invalid token
name|FsPathConnectionRunner
name|runner
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|featureConcurrentReadWithReadAhead
condition|)
block|{
name|URL
name|url
init|=
name|this
operator|.
name|toUrl
argument_list|(
name|op
argument_list|,
name|f
argument_list|,
operator|new
name|BufferSizeParam
argument_list|(
name|buffersize
argument_list|)
argument_list|,
operator|new
name|ReadADLNoRedirectParam
argument_list|(
literal|true
argument_list|)
argument_list|,
operator|new
name|ADLVersionInfo
argument_list|(
name|VersionInfo
operator|.
name|getVersion
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|BatchByteArrayInputStream
name|bb
init|=
operator|new
name|BatchByteArrayInputStream
argument_list|(
name|url
argument_list|,
name|f
argument_list|,
name|maxBufferSize
argument_list|,
name|maxConcurrentConnection
argument_list|)
decl_stmt|;
name|FSDataInputStream
name|fin
init|=
operator|new
name|FSDataInputStream
argument_list|(
name|bb
argument_list|)
decl_stmt|;
return|return
name|fin
return|;
block|}
else|else
block|{
if|if
condition|(
name|featureRedirectOff
condition|)
block|{
name|runner
operator|=
operator|new
name|FsPathConnectionRunner
argument_list|(
name|ADLGetOpParam
operator|.
name|Op
operator|.
name|OPEN
argument_list|,
name|f
argument_list|,
operator|new
name|BufferSizeParam
argument_list|(
name|buffersize
argument_list|)
argument_list|,
operator|new
name|ReadADLNoRedirectParam
argument_list|(
literal|true
argument_list|)
argument_list|,
operator|new
name|ADLVersionInfo
argument_list|(
name|VersionInfo
operator|.
name|getVersion
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|runner
operator|=
operator|new
name|FsPathConnectionRunner
argument_list|(
name|op
argument_list|,
name|f
argument_list|,
operator|new
name|BufferSizeParam
argument_list|(
name|buffersize
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|FSDataInputStream
argument_list|(
operator|new
name|OffsetUrlInputStream
argument_list|(
operator|new
name|UnresolvedUrlOpener
argument_list|(
name|runner
argument_list|)
argument_list|,
operator|new
name|OffsetUrlOpener
argument_list|(
literal|null
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
block|}
comment|/**    * @param f File/Folder path    * @return FileStatus array list    * @throws IOException For system error    */
annotation|@
name|Override
DECL|method|listStatus (final Path f)
specifier|public
name|FileStatus
index|[]
name|listStatus
parameter_list|(
specifier|final
name|Path
name|f
parameter_list|)
throws|throws
name|IOException
block|{
name|FileStatus
index|[]
name|fileStatuses
init|=
name|super
operator|.
name|listStatus
argument_list|(
name|f
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fileStatuses
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|overrideOwner
condition|)
block|{
name|fileStatuses
index|[
name|i
index|]
operator|=
operator|new
name|FileStatus
argument_list|(
name|fileStatuses
index|[
name|i
index|]
operator|.
name|getLen
argument_list|()
argument_list|,
name|fileStatuses
index|[
name|i
index|]
operator|.
name|isDirectory
argument_list|()
argument_list|,
name|fileStatuses
index|[
name|i
index|]
operator|.
name|getReplication
argument_list|()
argument_list|,
name|fileStatuses
index|[
name|i
index|]
operator|.
name|getBlockSize
argument_list|()
argument_list|,
name|fileStatuses
index|[
name|i
index|]
operator|.
name|getModificationTime
argument_list|()
argument_list|,
name|fileStatuses
index|[
name|i
index|]
operator|.
name|getAccessTime
argument_list|()
argument_list|,
name|fileStatuses
index|[
name|i
index|]
operator|.
name|getPermission
argument_list|()
argument_list|,
name|userName
argument_list|,
literal|"hdfs"
argument_list|,
name|fileStatuses
index|[
name|i
index|]
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|fileStatuses
return|;
block|}
annotation|@
name|Override
DECL|method|getFileBlockLocations (final FileStatus status, final long offset, final long length)
specifier|public
name|BlockLocation
index|[]
name|getFileBlockLocations
parameter_list|(
specifier|final
name|FileStatus
name|status
parameter_list|,
specifier|final
name|long
name|offset
parameter_list|,
specifier|final
name|long
name|length
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|status
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
name|featureGetBlockLocationLocallyBundled
condition|)
block|{
if|if
condition|(
operator|(
name|offset
operator|<
literal|0
operator|)
operator|||
operator|(
name|length
operator|<
literal|0
operator|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Invalid start or len parameter"
argument_list|)
throw|;
block|}
if|if
condition|(
name|status
operator|.
name|getLen
argument_list|()
operator|<
name|offset
condition|)
block|{
return|return
operator|new
name|BlockLocation
index|[
literal|0
index|]
return|;
block|}
specifier|final
name|String
index|[]
name|name
init|=
block|{
literal|"localhost"
block|}
decl_stmt|;
specifier|final
name|String
index|[]
name|host
init|=
block|{
literal|"localhost"
block|}
decl_stmt|;
name|long
name|blockSize
init|=
name|ADLConfKeys
operator|.
name|DEFAULT_EXTENT_SIZE
decl_stmt|;
comment|// Block size must be
comment|// non zero
name|int
name|numberOfLocations
init|=
call|(
name|int
call|)
argument_list|(
name|length
operator|/
name|blockSize
argument_list|)
operator|+
operator|(
operator|(
name|length
operator|%
name|blockSize
operator|==
literal|0
operator|)
condition|?
literal|0
else|:
literal|1
operator|)
decl_stmt|;
name|BlockLocation
index|[]
name|locations
init|=
operator|new
name|BlockLocation
index|[
name|numberOfLocations
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|locations
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|long
name|currentOffset
init|=
name|offset
operator|+
operator|(
name|i
operator|*
name|blockSize
operator|)
decl_stmt|;
name|long
name|currentLength
init|=
name|Math
operator|.
name|min
argument_list|(
name|blockSize
argument_list|,
name|offset
operator|+
name|length
operator|-
name|currentOffset
argument_list|)
decl_stmt|;
name|locations
index|[
name|i
index|]
operator|=
operator|new
name|BlockLocation
argument_list|(
name|name
argument_list|,
name|host
argument_list|,
name|currentOffset
argument_list|,
name|currentLength
argument_list|)
expr_stmt|;
block|}
return|return
name|locations
return|;
block|}
else|else
block|{
return|return
name|getFileBlockLocations
argument_list|(
name|status
operator|.
name|getPath
argument_list|()
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|getFileBlockLocations (final Path p, final long offset, final long length)
specifier|public
name|BlockLocation
index|[]
name|getFileBlockLocations
parameter_list|(
specifier|final
name|Path
name|p
parameter_list|,
specifier|final
name|long
name|offset
parameter_list|,
specifier|final
name|long
name|length
parameter_list|)
throws|throws
name|IOException
block|{
name|statistics
operator|.
name|incrementReadOps
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|featureGetBlockLocationLocallyBundled
condition|)
block|{
name|FileStatus
name|fileStatus
init|=
name|getFileStatus
argument_list|(
name|p
argument_list|)
decl_stmt|;
return|return
name|getFileBlockLocations
argument_list|(
name|fileStatus
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|super
operator|.
name|getFileBlockLocations
argument_list|(
name|p
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
return|;
block|}
block|}
DECL|enum|StreamState
enum|enum
name|StreamState
block|{
DECL|enumConstant|Initial
name|Initial
block|,
DECL|enumConstant|DataCachedInLocalBuffer
name|DataCachedInLocalBuffer
block|,
DECL|enumConstant|StreamEnd
name|StreamEnd
block|}
DECL|class|BatchAppendOutputStream
class|class
name|BatchAppendOutputStream
extends|extends
name|OutputStream
block|{
DECL|field|fsPath
specifier|private
name|Path
name|fsPath
decl_stmt|;
DECL|field|parameters
specifier|private
name|Param
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
index|[]
name|parameters
decl_stmt|;
DECL|field|data
specifier|private
name|byte
index|[]
name|data
init|=
literal|null
decl_stmt|;
DECL|field|offset
specifier|private
name|int
name|offset
init|=
literal|0
decl_stmt|;
DECL|field|length
specifier|private
name|long
name|length
init|=
literal|0
decl_stmt|;
DECL|field|eof
specifier|private
name|boolean
name|eof
init|=
literal|false
decl_stmt|;
DECL|field|hadError
specifier|private
name|boolean
name|hadError
init|=
literal|false
decl_stmt|;
DECL|field|dataBuffers
specifier|private
name|byte
index|[]
name|dataBuffers
init|=
literal|null
decl_stmt|;
DECL|field|bufSize
specifier|private
name|int
name|bufSize
init|=
literal|0
decl_stmt|;
DECL|field|streamClosed
specifier|private
name|boolean
name|streamClosed
init|=
literal|false
decl_stmt|;
DECL|method|BatchAppendOutputStream (Path path, int bufferSize, Param<?, ?>... param)
specifier|public
name|BatchAppendOutputStream
parameter_list|(
name|Path
name|path
parameter_list|,
name|int
name|bufferSize
parameter_list|,
name|Param
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
modifier|...
name|param
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|bufferSize
operator|<
operator|(
name|ADLConfKeys
operator|.
name|DEFAULT_BLOCK_SIZE
operator|)
condition|)
block|{
name|bufSize
operator|=
name|ADLConfKeys
operator|.
name|DEFAULT_BLOCK_SIZE
expr_stmt|;
block|}
else|else
block|{
name|bufSize
operator|=
name|bufferSize
expr_stmt|;
block|}
name|this
operator|.
name|fsPath
operator|=
name|path
expr_stmt|;
name|this
operator|.
name|parameters
operator|=
name|param
expr_stmt|;
name|this
operator|.
name|data
operator|=
name|getBuffer
argument_list|()
expr_stmt|;
name|FSDataOutputStream
name|createStream
init|=
literal|null
decl_stmt|;
try|try
block|{
if|if
condition|(
name|featureRedirectOff
condition|)
block|{
name|CreateADLNoRedirectParam
name|skipRedirect
init|=
operator|new
name|CreateADLNoRedirectParam
argument_list|(
literal|true
argument_list|)
decl_stmt|;
name|Param
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
index|[]
name|tmpParam
init|=
name|featureFlushWhenEOF
condition|?
operator|new
name|Param
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
index|[
name|param
operator|.
name|length
operator|+
literal|2
index|]
else|:
operator|new
name|Param
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
index|[
name|param
operator|.
name|length
operator|+
literal|1
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|param
argument_list|,
literal|0
argument_list|,
name|tmpParam
argument_list|,
literal|0
argument_list|,
name|param
operator|.
name|length
argument_list|)
expr_stmt|;
name|tmpParam
index|[
name|param
operator|.
name|length
index|]
operator|=
name|skipRedirect
expr_stmt|;
if|if
condition|(
name|featureFlushWhenEOF
condition|)
block|{
name|tmpParam
index|[
name|param
operator|.
name|length
operator|+
literal|1
index|]
operator|=
operator|new
name|ADLFlush
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
name|createStream
operator|=
operator|new
name|FsPathOutputStreamRunner
argument_list|(
name|ADLPutOpParam
operator|.
name|Op
operator|.
name|CREATE
argument_list|,
name|fsPath
argument_list|,
literal|1
argument_list|,
name|tmpParam
argument_list|)
operator|.
name|run
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|createStream
operator|=
operator|new
name|FsPathOutputStreamRunner
argument_list|(
name|PutOpParam
operator|.
name|Op
operator|.
name|CREATE
argument_list|,
name|fsPath
argument_list|,
literal|1
argument_list|,
name|param
argument_list|)
operator|.
name|run
argument_list|()
expr_stmt|;
block|}
block|}
finally|finally
block|{
if|if
condition|(
name|createStream
operator|!=
literal|null
condition|)
block|{
name|createStream
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
DECL|method|write (int b)
specifier|public
specifier|final
specifier|synchronized
name|void
name|write
parameter_list|(
name|int
name|b
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|streamClosed
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|fsPath
operator|+
literal|" stream object is closed."
argument_list|)
throw|;
block|}
if|if
condition|(
name|offset
operator|==
operator|(
name|data
operator|.
name|length
operator|)
condition|)
block|{
name|flush
argument_list|()
expr_stmt|;
block|}
name|data
index|[
name|offset
index|]
operator|=
operator|(
name|byte
operator|)
name|b
expr_stmt|;
name|offset
operator|++
expr_stmt|;
comment|// Statistics will get incremented again as part of the batch updates,
comment|// decrement here to avoid double value
if|if
condition|(
name|statistics
operator|!=
literal|null
condition|)
block|{
name|statistics
operator|.
name|incrementBytesWritten
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|write (byte[] buf, int off, int len)
specifier|public
specifier|final
specifier|synchronized
name|void
name|write
parameter_list|(
name|byte
index|[]
name|buf
parameter_list|,
name|int
name|off
parameter_list|,
name|int
name|len
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|streamClosed
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|fsPath
operator|+
literal|" stream object is closed."
argument_list|)
throw|;
block|}
name|int
name|bytesToWrite
init|=
name|len
decl_stmt|;
name|int
name|localOff
init|=
name|off
decl_stmt|;
name|int
name|localLen
init|=
name|len
decl_stmt|;
if|if
condition|(
name|localLen
operator|>=
name|data
operator|.
name|length
condition|)
block|{
comment|// Flush data that is already in our internal buffer
name|flush
argument_list|()
expr_stmt|;
comment|// Keep committing data until we have less than our internal buffers
comment|// length left
do|do
block|{
try|try
block|{
name|commit
argument_list|(
name|buf
argument_list|,
name|localOff
argument_list|,
name|data
operator|.
name|length
argument_list|,
name|eof
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|hadError
operator|=
literal|true
expr_stmt|;
throw|throw
name|e
throw|;
block|}
name|localOff
operator|+=
name|data
operator|.
name|length
expr_stmt|;
name|localLen
operator|-=
name|data
operator|.
name|length
expr_stmt|;
block|}
do|while
condition|(
name|localLen
operator|>=
name|data
operator|.
name|length
condition|)
do|;
block|}
comment|// At this point, we have less than data.length left to copy from users
comment|// buffer
if|if
condition|(
name|offset
operator|+
name|localLen
operator|>=
name|data
operator|.
name|length
condition|)
block|{
comment|// Users buffer has enough data left to fill our internal buffer
name|int
name|bytesToCopy
init|=
name|data
operator|.
name|length
operator|-
name|offset
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|buf
argument_list|,
name|localOff
argument_list|,
name|data
argument_list|,
name|offset
argument_list|,
name|bytesToCopy
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|bytesToCopy
expr_stmt|;
comment|// Flush our internal buffer
name|flush
argument_list|()
expr_stmt|;
name|localOff
operator|+=
name|bytesToCopy
expr_stmt|;
name|localLen
operator|-=
name|bytesToCopy
expr_stmt|;
block|}
if|if
condition|(
name|localLen
operator|>
literal|0
condition|)
block|{
comment|// Simply copy the remainder from the users buffer into our internal
comment|// buffer
name|System
operator|.
name|arraycopy
argument_list|(
name|buf
argument_list|,
name|localOff
argument_list|,
name|data
argument_list|,
name|offset
argument_list|,
name|localLen
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|localLen
expr_stmt|;
block|}
comment|// Statistics will get incremented again as part of the batch updates,
comment|// decrement here to avoid double value
if|if
condition|(
name|statistics
operator|!=
literal|null
condition|)
block|{
name|statistics
operator|.
name|incrementBytesWritten
argument_list|(
operator|-
name|bytesToWrite
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|flush ()
specifier|public
specifier|final
specifier|synchronized
name|void
name|flush
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|streamClosed
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|fsPath
operator|+
literal|" stream object is closed."
argument_list|)
throw|;
block|}
if|if
condition|(
name|offset
operator|>
literal|0
condition|)
block|{
try|try
block|{
name|commit
argument_list|(
name|data
argument_list|,
literal|0
argument_list|,
name|offset
argument_list|,
name|eof
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|hadError
operator|=
literal|true
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
name|offset
operator|=
literal|0
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|close ()
specifier|public
specifier|final
specifier|synchronized
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
comment|// Stream is closed earlier, return quietly.
if|if
condition|(
name|streamClosed
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|featureRedirectOff
condition|)
block|{
name|eof
operator|=
literal|true
expr_stmt|;
block|}
name|boolean
name|flushedSomething
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|hadError
condition|)
block|{
comment|// No point proceeding further since the error has occurred and
comment|// stream would be required to upload again.
name|streamClosed
operator|=
literal|true
expr_stmt|;
return|return;
block|}
else|else
block|{
name|flushedSomething
operator|=
name|offset
operator|>
literal|0
expr_stmt|;
try|try
block|{
name|flush
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|streamClosed
operator|=
literal|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|featureRedirectOff
condition|)
block|{
comment|// If we didn't flush anything from our internal buffer, we have to
comment|// call the service again
comment|// with an empty payload and flush=true in the url
if|if
condition|(
operator|!
name|flushedSomething
condition|)
block|{
try|try
block|{
name|commit
argument_list|(
literal|null
argument_list|,
literal|0
argument_list|,
name|ADLConfKeys
operator|.
name|KB
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|streamClosed
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
block|}
DECL|method|commit (byte[] buffer, int off, int len, boolean endOfFile)
specifier|private
name|void
name|commit
parameter_list|(
name|byte
index|[]
name|buffer
parameter_list|,
name|int
name|off
parameter_list|,
name|int
name|len
parameter_list|,
name|boolean
name|endOfFile
parameter_list|)
throws|throws
name|IOException
block|{
name|OutputStream
name|out
init|=
literal|null
decl_stmt|;
try|try
block|{
if|if
condition|(
name|featureRedirectOff
condition|)
block|{
name|AppendADLNoRedirectParam
name|skipRedirect
init|=
operator|new
name|AppendADLNoRedirectParam
argument_list|(
literal|true
argument_list|)
decl_stmt|;
name|Param
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
index|[]
name|tmpParam
init|=
name|featureFlushWhenEOF
condition|?
operator|new
name|Param
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
index|[
name|parameters
operator|.
name|length
operator|+
literal|3
index|]
else|:
operator|new
name|Param
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
index|[
name|parameters
operator|.
name|length
operator|+
literal|1
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|parameters
argument_list|,
literal|0
argument_list|,
name|tmpParam
argument_list|,
literal|0
argument_list|,
name|parameters
operator|.
name|length
argument_list|)
expr_stmt|;
name|tmpParam
index|[
name|parameters
operator|.
name|length
index|]
operator|=
name|skipRedirect
expr_stmt|;
if|if
condition|(
name|featureFlushWhenEOF
condition|)
block|{
name|tmpParam
index|[
name|parameters
operator|.
name|length
operator|+
literal|1
index|]
operator|=
operator|new
name|ADLFlush
argument_list|(
name|endOfFile
argument_list|)
expr_stmt|;
name|tmpParam
index|[
name|parameters
operator|.
name|length
operator|+
literal|2
index|]
operator|=
operator|new
name|OffsetParam
argument_list|(
name|length
argument_list|)
expr_stmt|;
block|}
name|out
operator|=
operator|new
name|FsPathOutputStreamRunner
argument_list|(
name|ADLPostOpParam
operator|.
name|Op
operator|.
name|APPEND
argument_list|,
name|fsPath
argument_list|,
name|len
argument_list|,
name|tmpParam
argument_list|)
operator|.
name|run
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|out
operator|=
operator|new
name|FsPathOutputStreamRunner
argument_list|(
name|ADLPostOpParam
operator|.
name|Op
operator|.
name|APPEND
argument_list|,
name|fsPath
argument_list|,
name|len
argument_list|,
name|parameters
argument_list|)
operator|.
name|run
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|buffer
operator|!=
literal|null
condition|)
block|{
name|out
operator|.
name|write
argument_list|(
name|buffer
argument_list|,
name|off
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|length
operator|+=
name|len
expr_stmt|;
block|}
block|}
finally|finally
block|{
if|if
condition|(
name|out
operator|!=
literal|null
condition|)
block|{
name|out
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
block|}
DECL|method|getBuffer ()
specifier|private
name|byte
index|[]
name|getBuffer
parameter_list|()
block|{
comment|// Switch between the first and second buffer
name|dataBuffers
operator|=
operator|new
name|byte
index|[
name|bufSize
index|]
expr_stmt|;
return|return
name|dataBuffers
return|;
block|}
block|}
comment|/**    * Read data from backend in chunks instead of persistent connection. This    * is to avoid slow reader causing socket    * timeout.    */
DECL|class|BatchByteArrayInputStream
specifier|protected
class|class
name|BatchByteArrayInputStream
extends|extends
name|FSInputStream
block|{
DECL|field|SIZE4MB
specifier|private
specifier|static
specifier|final
name|int
name|SIZE4MB
init|=
literal|4
operator|*
literal|1024
operator|*
literal|1024
decl_stmt|;
DECL|field|runner
specifier|private
specifier|final
name|URL
name|runner
decl_stmt|;
DECL|field|data
specifier|private
name|byte
index|[]
name|data
init|=
literal|null
decl_stmt|;
DECL|field|validDataHoldingSize
specifier|private
name|long
name|validDataHoldingSize
init|=
literal|0
decl_stmt|;
DECL|field|bufferOffset
specifier|private
name|int
name|bufferOffset
init|=
literal|0
decl_stmt|;
DECL|field|currentFileOffset
specifier|private
name|long
name|currentFileOffset
init|=
literal|0
decl_stmt|;
DECL|field|nextFileOffset
specifier|private
name|long
name|nextFileOffset
init|=
literal|0
decl_stmt|;
DECL|field|fileSize
specifier|private
name|long
name|fileSize
init|=
literal|0
decl_stmt|;
DECL|field|state
specifier|private
name|StreamState
name|state
init|=
name|StreamState
operator|.
name|Initial
decl_stmt|;
DECL|field|maxBufferSize
specifier|private
name|int
name|maxBufferSize
decl_stmt|;
DECL|field|maxConcurrentConnection
specifier|private
name|int
name|maxConcurrentConnection
decl_stmt|;
DECL|field|fsPath
specifier|private
name|Path
name|fsPath
decl_stmt|;
DECL|field|streamIsClosed
specifier|private
name|boolean
name|streamIsClosed
decl_stmt|;
DECL|field|subtasks
specifier|private
name|Future
index|[]
name|subtasks
init|=
literal|null
decl_stmt|;
DECL|method|BatchByteArrayInputStream (URL url, Path p, int bufferSize, int concurrentConnection)
name|BatchByteArrayInputStream
parameter_list|(
name|URL
name|url
parameter_list|,
name|Path
name|p
parameter_list|,
name|int
name|bufferSize
parameter_list|,
name|int
name|concurrentConnection
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|runner
operator|=
name|url
expr_stmt|;
name|fsPath
operator|=
name|p
expr_stmt|;
name|FileStatus
name|fStatus
init|=
name|getFileStatus
argument_list|(
name|fsPath
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|fStatus
operator|.
name|isFile
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Cannot open the directory "
operator|+
name|p
operator|+
literal|" for "
operator|+
literal|"reading"
argument_list|)
throw|;
block|}
name|fileSize
operator|=
name|fStatus
operator|.
name|getLen
argument_list|()
expr_stmt|;
name|this
operator|.
name|maxBufferSize
operator|=
name|bufferSize
expr_stmt|;
name|this
operator|.
name|maxConcurrentConnection
operator|=
name|concurrentConnection
expr_stmt|;
name|this
operator|.
name|streamIsClosed
operator|=
literal|false
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|read (long position, byte[] buffer, int offset, int length)
specifier|public
specifier|synchronized
specifier|final
name|int
name|read
parameter_list|(
name|long
name|position
parameter_list|,
name|byte
index|[]
name|buffer
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|streamIsClosed
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Stream already closed"
argument_list|)
throw|;
block|}
name|long
name|oldPos
init|=
name|this
operator|.
name|getPos
argument_list|()
decl_stmt|;
name|int
name|nread1
decl_stmt|;
try|try
block|{
name|this
operator|.
name|seek
argument_list|(
name|position
argument_list|)
expr_stmt|;
name|nread1
operator|=
name|this
operator|.
name|read
argument_list|(
name|buffer
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|this
operator|.
name|seek
argument_list|(
name|oldPos
argument_list|)
expr_stmt|;
block|}
return|return
name|nread1
return|;
block|}
annotation|@
name|Override
DECL|method|read ()
specifier|public
specifier|synchronized
specifier|final
name|int
name|read
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|streamIsClosed
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Stream already closed"
argument_list|)
throw|;
block|}
name|int
name|status
init|=
name|doBufferAvailabilityCheck
argument_list|()
decl_stmt|;
if|if
condition|(
name|status
operator|==
operator|-
literal|1
condition|)
block|{
return|return
name|status
return|;
block|}
name|int
name|ch
init|=
name|data
index|[
name|bufferOffset
operator|++
index|]
operator|&
operator|(
literal|0xff
operator|)
decl_stmt|;
if|if
condition|(
name|statistics
operator|!=
literal|null
condition|)
block|{
name|statistics
operator|.
name|incrementBytesRead
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|ch
return|;
block|}
annotation|@
name|Override
DECL|method|readFully (long position, byte[] buffer, int offset, int length)
specifier|public
specifier|synchronized
specifier|final
name|void
name|readFully
parameter_list|(
name|long
name|position
parameter_list|,
name|byte
index|[]
name|buffer
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|streamIsClosed
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Stream already closed"
argument_list|)
throw|;
block|}
name|super
operator|.
name|readFully
argument_list|(
name|position
argument_list|,
name|buffer
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|statistics
operator|!=
literal|null
condition|)
block|{
name|statistics
operator|.
name|incrementBytesRead
argument_list|(
name|length
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|read (byte[] b, int off, int len)
specifier|public
specifier|synchronized
specifier|final
name|int
name|read
parameter_list|(
name|byte
index|[]
name|b
parameter_list|,
name|int
name|off
parameter_list|,
name|int
name|len
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|b
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|()
throw|;
block|}
elseif|else
if|if
condition|(
name|off
operator|<
literal|0
operator|||
name|len
argument_list|<
literal|0
operator|||
name|len
argument_list|>
name|b
operator|.
name|length
operator|-
name|off
condition|)
block|{
throw|throw
operator|new
name|IndexOutOfBoundsException
argument_list|()
throw|;
block|}
elseif|else
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
if|if
condition|(
name|streamIsClosed
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Stream already closed"
argument_list|)
throw|;
block|}
name|int
name|status
init|=
name|doBufferAvailabilityCheck
argument_list|()
decl_stmt|;
if|if
condition|(
name|status
operator|==
operator|-
literal|1
condition|)
block|{
return|return
name|status
return|;
block|}
name|int
name|byteRead
init|=
literal|0
decl_stmt|;
name|long
name|availableBytes
init|=
name|validDataHoldingSize
operator|-
name|off
decl_stmt|;
name|long
name|requestedBytes
init|=
name|bufferOffset
operator|+
name|len
operator|-
name|off
decl_stmt|;
if|if
condition|(
name|requestedBytes
operator|<=
name|availableBytes
condition|)
block|{
name|System
operator|.
name|arraycopy
argument_list|(
name|data
argument_list|,
name|bufferOffset
argument_list|,
name|b
argument_list|,
name|off
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|bufferOffset
operator|+=
name|len
expr_stmt|;
name|byteRead
operator|=
name|len
expr_stmt|;
block|}
else|else
block|{
name|byteRead
operator|=
name|super
operator|.
name|read
argument_list|(
name|b
argument_list|,
name|off
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|statistics
operator|!=
literal|null
condition|)
block|{
name|statistics
operator|.
name|incrementBytesRead
argument_list|(
name|byteRead
argument_list|)
expr_stmt|;
block|}
return|return
name|byteRead
return|;
block|}
DECL|method|doBufferAvailabilityCheck ()
specifier|private
name|int
name|doBufferAvailabilityCheck
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|state
operator|==
name|StreamState
operator|.
name|Initial
condition|)
block|{
name|validDataHoldingSize
operator|=
name|fill
argument_list|(
name|nextFileOffset
argument_list|)
expr_stmt|;
block|}
name|long
name|dataReloadSize
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
operator|(
name|int
operator|)
name|validDataHoldingSize
condition|)
block|{
case|case
operator|-
literal|1
case|:
name|state
operator|=
name|StreamState
operator|.
name|StreamEnd
expr_stmt|;
return|return
operator|-
literal|1
return|;
case|case
literal|0
case|:
name|dataReloadSize
operator|=
name|fill
argument_list|(
name|nextFileOffset
argument_list|)
expr_stmt|;
if|if
condition|(
name|dataReloadSize
operator|<=
literal|0
condition|)
block|{
name|state
operator|=
name|StreamState
operator|.
name|StreamEnd
expr_stmt|;
return|return
operator|(
name|int
operator|)
name|dataReloadSize
return|;
block|}
else|else
block|{
name|validDataHoldingSize
operator|=
name|dataReloadSize
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|bufferOffset
operator|>=
name|validDataHoldingSize
condition|)
block|{
name|dataReloadSize
operator|=
name|fill
argument_list|(
name|nextFileOffset
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bufferOffset
operator|>=
operator|(
operator|(
name|dataReloadSize
operator|==
literal|0
operator|)
condition|?
name|validDataHoldingSize
else|:
name|dataReloadSize
operator|)
condition|)
block|{
name|state
operator|=
name|StreamState
operator|.
name|StreamEnd
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|validDataHoldingSize
operator|=
operator|(
operator|(
name|dataReloadSize
operator|==
literal|0
operator|)
condition|?
name|validDataHoldingSize
else|:
name|dataReloadSize
operator|)
expr_stmt|;
name|state
operator|=
name|StreamState
operator|.
name|DataCachedInLocalBuffer
expr_stmt|;
return|return
literal|0
return|;
block|}
DECL|method|fill (final long off)
specifier|private
name|long
name|fill
parameter_list|(
specifier|final
name|long
name|off
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|state
operator|==
name|StreamState
operator|.
name|StreamEnd
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|fileSize
operator|<=
name|off
condition|)
block|{
name|state
operator|=
name|StreamState
operator|.
name|StreamEnd
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|int
name|len
init|=
name|maxBufferSize
decl_stmt|;
name|long
name|fileOffset
init|=
literal|0
decl_stmt|;
name|boolean
name|isEntireFileCached
init|=
literal|true
decl_stmt|;
if|if
condition|(
operator|(
name|fileSize
operator|<=
name|maxBufferSize
operator|)
condition|)
block|{
name|len
operator|=
operator|(
name|int
operator|)
name|fileSize
expr_stmt|;
name|currentFileOffset
operator|=
literal|0
expr_stmt|;
name|nextFileOffset
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|len
operator|>
operator|(
name|fileSize
operator|-
name|off
operator|)
condition|)
block|{
name|len
operator|=
call|(
name|int
call|)
argument_list|(
name|fileSize
operator|-
name|off
argument_list|)
expr_stmt|;
block|}
synchronized|synchronized
init|(
name|BufferManager
operator|.
name|getLock
argument_list|()
init|)
block|{
if|if
condition|(
name|BufferManager
operator|.
name|getInstance
argument_list|()
operator|.
name|hasValidDataForOffset
argument_list|(
name|fsPath
operator|.
name|toString
argument_list|()
argument_list|,
name|off
argument_list|)
condition|)
block|{
name|len
operator|=
call|(
name|int
call|)
argument_list|(
name|BufferManager
operator|.
name|getInstance
argument_list|()
operator|.
name|getBufferOffset
argument_list|()
operator|+
name|BufferManager
operator|.
name|getInstance
argument_list|()
operator|.
name|getBufferSize
argument_list|()
operator|-
operator|(
name|int
operator|)
name|off
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
block|{
name|len
operator|=
name|maxBufferSize
expr_stmt|;
block|}
name|fileOffset
operator|=
name|off
expr_stmt|;
name|isEntireFileCached
operator|=
literal|false
expr_stmt|;
block|}
name|data
operator|=
literal|null
expr_stmt|;
name|BufferManager
name|bm
init|=
name|BufferManager
operator|.
name|getInstance
argument_list|()
decl_stmt|;
name|data
operator|=
name|bm
operator|.
name|getEmpty
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|boolean
name|fetchDataOverNetwork
init|=
literal|false
decl_stmt|;
synchronized|synchronized
init|(
name|BufferManager
operator|.
name|getLock
argument_list|()
init|)
block|{
if|if
condition|(
name|bm
operator|.
name|hasData
argument_list|(
name|fsPath
operator|.
name|toString
argument_list|()
argument_list|,
name|fileOffset
argument_list|,
name|len
argument_list|)
condition|)
block|{
try|try
block|{
name|bm
operator|.
name|get
argument_list|(
name|data
argument_list|,
name|fileOffset
argument_list|)
expr_stmt|;
name|validDataHoldingSize
operator|=
name|data
operator|.
name|length
expr_stmt|;
name|currentFileOffset
operator|=
name|fileOffset
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ArrayIndexOutOfBoundsException
name|e
parameter_list|)
block|{
name|fetchDataOverNetwork
operator|=
literal|true
expr_stmt|;
block|}
block|}
else|else
block|{
name|fetchDataOverNetwork
operator|=
literal|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fetchDataOverNetwork
condition|)
block|{
name|int
name|splitSize
init|=
name|getSplitSize
argument_list|(
name|len
argument_list|)
decl_stmt|;
try|try
block|{
name|validDataHoldingSize
operator|=
name|fillDataConcurrently
argument_list|(
name|data
argument_list|,
name|len
argument_list|,
name|fileOffset
argument_list|,
name|splitSize
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Interrupted filling buffer"
argument_list|,
name|e
argument_list|)
throw|;
block|}
synchronized|synchronized
init|(
name|BufferManager
operator|.
name|getLock
argument_list|()
init|)
block|{
name|bm
operator|.
name|add
argument_list|(
name|data
argument_list|,
name|fsPath
operator|.
name|toString
argument_list|()
argument_list|,
name|fileOffset
argument_list|)
expr_stmt|;
block|}
name|currentFileOffset
operator|=
name|nextFileOffset
expr_stmt|;
block|}
name|nextFileOffset
operator|+=
name|validDataHoldingSize
expr_stmt|;
name|state
operator|=
name|StreamState
operator|.
name|DataCachedInLocalBuffer
expr_stmt|;
name|bufferOffset
operator|=
name|isEntireFileCached
condition|?
operator|(
name|int
operator|)
name|off
else|:
literal|0
expr_stmt|;
return|return
name|validDataHoldingSize
return|;
block|}
DECL|method|getSplitSize (int size)
name|int
name|getSplitSize
parameter_list|(
name|int
name|size
parameter_list|)
block|{
if|if
condition|(
name|size
operator|<=
name|SIZE4MB
condition|)
block|{
return|return
literal|1
return|;
block|}
comment|// Not practical
if|if
condition|(
name|size
operator|>
name|maxBufferSize
condition|)
block|{
name|size
operator|=
name|maxBufferSize
expr_stmt|;
block|}
name|int
name|equalBufferSplit
init|=
name|Math
operator|.
name|max
argument_list|(
name|Math
operator|.
name|round
argument_list|(
name|size
operator|/
name|SIZE4MB
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|int
name|splitSize
init|=
name|Math
operator|.
name|min
argument_list|(
name|equalBufferSplit
argument_list|,
name|maxConcurrentConnection
argument_list|)
decl_stmt|;
return|return
name|splitSize
return|;
block|}
annotation|@
name|Override
DECL|method|seek (long pos)
specifier|public
specifier|synchronized
specifier|final
name|void
name|seek
parameter_list|(
name|long
name|pos
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|pos
operator|==
operator|-
literal|1
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Bad offset, cannot seek to "
operator|+
name|pos
argument_list|)
throw|;
block|}
name|BufferManager
name|bm
init|=
name|BufferManager
operator|.
name|getInstance
argument_list|()
decl_stmt|;
synchronized|synchronized
init|(
name|BufferManager
operator|.
name|getLock
argument_list|()
init|)
block|{
if|if
condition|(
name|bm
operator|.
name|hasValidDataForOffset
argument_list|(
name|fsPath
operator|.
name|toString
argument_list|()
argument_list|,
name|pos
argument_list|)
condition|)
block|{
name|state
operator|=
name|StreamState
operator|.
name|DataCachedInLocalBuffer
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pos
operator|>=
literal|0
condition|)
block|{
name|state
operator|=
name|StreamState
operator|.
name|Initial
expr_stmt|;
block|}
block|}
name|long
name|availableBytes
init|=
operator|(
name|currentFileOffset
operator|+
name|validDataHoldingSize
operator|)
decl_stmt|;
comment|// Check if this position falls under buffered data
if|if
condition|(
name|pos
operator|<
name|currentFileOffset
operator|||
name|availableBytes
operator|<=
literal|0
condition|)
block|{
name|validDataHoldingSize
operator|=
literal|0
expr_stmt|;
name|currentFileOffset
operator|=
name|pos
expr_stmt|;
name|nextFileOffset
operator|=
name|pos
expr_stmt|;
name|bufferOffset
operator|=
literal|0
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|pos
operator|<
name|availableBytes
operator|&&
name|pos
operator|>=
name|currentFileOffset
condition|)
block|{
name|state
operator|=
name|StreamState
operator|.
name|DataCachedInLocalBuffer
expr_stmt|;
name|bufferOffset
operator|=
call|(
name|int
call|)
argument_list|(
name|pos
operator|-
name|currentFileOffset
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|validDataHoldingSize
operator|=
literal|0
expr_stmt|;
name|currentFileOffset
operator|=
name|pos
expr_stmt|;
name|nextFileOffset
operator|=
name|pos
expr_stmt|;
name|bufferOffset
operator|=
literal|0
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|getPos ()
specifier|public
specifier|synchronized
specifier|final
name|long
name|getPos
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|streamIsClosed
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Stream already closed"
argument_list|)
throw|;
block|}
return|return
name|bufferOffset
operator|+
name|currentFileOffset
return|;
block|}
annotation|@
name|Override
DECL|method|available ()
specifier|public
specifier|synchronized
specifier|final
name|int
name|available
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|streamIsClosed
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Stream already closed"
argument_list|)
throw|;
block|}
return|return
name|Integer
operator|.
name|MAX_VALUE
return|;
block|}
annotation|@
name|Override
DECL|method|seekToNewSource (long targetPos)
specifier|public
specifier|final
name|boolean
name|seekToNewSource
parameter_list|(
name|long
name|targetPos
parameter_list|)
throws|throws
name|IOException
block|{
return|return
literal|false
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|fillDataConcurrently (byte[] byteArray, int length, long globalOffset, int splitSize)
specifier|private
name|int
name|fillDataConcurrently
parameter_list|(
name|byte
index|[]
name|byteArray
parameter_list|,
name|int
name|length
parameter_list|,
name|long
name|globalOffset
parameter_list|,
name|int
name|splitSize
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|ExecutorService
name|executor
init|=
name|Executors
operator|.
name|newFixedThreadPool
argument_list|(
name|splitSize
argument_list|)
decl_stmt|;
name|subtasks
operator|=
operator|new
name|Future
index|[
name|splitSize
index|]
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|splitSize
condition|;
name|i
operator|++
control|)
block|{
name|int
name|offset
init|=
name|i
operator|*
operator|(
name|length
operator|/
name|splitSize
operator|)
decl_stmt|;
name|int
name|splitLength
init|=
operator|(
name|splitSize
operator|==
operator|(
name|i
operator|+
literal|1
operator|)
operator|)
condition|?
operator|(
name|length
operator|/
name|splitSize
operator|)
operator|+
operator|(
name|length
operator|%
name|splitSize
operator|)
else|:
operator|(
name|length
operator|/
name|splitSize
operator|)
decl_stmt|;
name|subtasks
index|[
name|i
index|]
operator|=
name|executor
operator|.
name|submit
argument_list|(
operator|new
name|BackgroundReadThread
argument_list|(
name|byteArray
argument_list|,
name|offset
argument_list|,
name|splitLength
argument_list|,
name|globalOffset
operator|+
name|offset
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|executor
operator|.
name|shutdown
argument_list|()
expr_stmt|;
comment|// wait until all tasks are finished
name|executor
operator|.
name|awaitTermination
argument_list|(
name|ADLConfKeys
operator|.
name|DEFAULT_TIMEOUT_IN_SECONDS
argument_list|,
name|TimeUnit
operator|.
name|SECONDS
argument_list|)
expr_stmt|;
name|int
name|totalBytePainted
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|splitSize
condition|;
operator|++
name|i
control|)
block|{
try|try
block|{
name|totalBytePainted
operator|+=
operator|(
name|Integer
operator|)
name|subtasks
index|[
name|i
index|]
operator|.
name|get
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
name|e
operator|.
name|getCause
argument_list|()
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|ExecutionException
name|e
parameter_list|)
block|{
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
name|e
operator|.
name|getCause
argument_list|()
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
name|totalBytePainted
operator|!=
name|length
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Expected "
operator|+
name|length
operator|+
literal|" bytes, Got "
operator|+
name|totalBytePainted
operator|+
literal|" bytes"
argument_list|)
throw|;
block|}
return|return
name|totalBytePainted
return|;
block|}
annotation|@
name|Override
DECL|method|close ()
specifier|public
specifier|synchronized
specifier|final
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
synchronized|synchronized
init|(
name|BufferManager
operator|.
name|getLock
argument_list|()
init|)
block|{
name|BufferManager
operator|.
name|getInstance
argument_list|()
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
comment|//need to cleanup the above code the stream and connection close doesn't
comment|// happen here
comment|//flag set to mark close happened, cannot use the stream once closed
name|streamIsClosed
operator|=
literal|true
expr_stmt|;
block|}
comment|/**      * Reads data from the ADL backend from the specified global offset and      * given      * length. Read data from ADL backend is copied to buffer array from the      * offset value specified.      *      * @param buffer       Store read data from ADL backend in the buffer.      * @param offset       Store read data from ADL backend in the buffer      *                     from the      *                     offset.      * @param length       Size of the data read from the ADL backend.      * @param globalOffset Read data from file offset.      * @return Number of bytes read from the ADL backend      * @throws IOException For any intermittent server issues or internal      *                     failures.      */
DECL|method|fillUpData (byte[] buffer, int offset, int length, long globalOffset)
specifier|private
name|int
name|fillUpData
parameter_list|(
name|byte
index|[]
name|buffer
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|,
name|long
name|globalOffset
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|totalBytesRead
init|=
literal|0
decl_stmt|;
specifier|final
name|URL
name|offsetUrl
init|=
operator|new
name|URL
argument_list|(
name|runner
operator|+
literal|"&"
operator|+
operator|new
name|OffsetParam
argument_list|(
name|String
operator|.
name|valueOf
argument_list|(
name|globalOffset
argument_list|)
argument_list|)
operator|+
literal|"&"
operator|+
operator|new
name|LengthParam
argument_list|(
name|String
operator|.
name|valueOf
argument_list|(
name|length
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|HttpURLConnection
name|conn
init|=
operator|new
name|URLRunner
argument_list|(
name|GetOpParam
operator|.
name|Op
operator|.
name|OPEN
argument_list|,
name|offsetUrl
argument_list|,
literal|true
argument_list|)
operator|.
name|run
argument_list|()
decl_stmt|;
name|InputStream
name|in
init|=
name|conn
operator|.
name|getInputStream
argument_list|()
decl_stmt|;
try|try
block|{
name|int
name|bytesRead
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|bytesRead
operator|=
name|in
operator|.
name|read
argument_list|(
name|buffer
argument_list|,
operator|(
name|int
operator|)
name|offset
operator|+
name|totalBytesRead
argument_list|,
call|(
name|int
call|)
argument_list|(
name|length
operator|-
name|totalBytesRead
argument_list|)
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|totalBytesRead
operator|+=
name|bytesRead
expr_stmt|;
block|}
comment|// InputStream must be fully consumed to enable http keep-alive
if|if
condition|(
name|bytesRead
operator|==
literal|0
condition|)
block|{
comment|// Looking for EOF marker byte needs to be read.
if|if
condition|(
name|in
operator|.
name|read
argument_list|()
operator|!=
operator|-
literal|1
condition|)
block|{
throw|throw
operator|new
name|SocketException
argument_list|(
literal|"Server returned more than requested data."
argument_list|)
throw|;
block|}
block|}
block|}
finally|finally
block|{
name|in
operator|.
name|close
argument_list|()
expr_stmt|;
name|conn
operator|.
name|disconnect
argument_list|()
expr_stmt|;
block|}
return|return
name|totalBytesRead
return|;
block|}
DECL|class|BackgroundReadThread
specifier|private
class|class
name|BackgroundReadThread
implements|implements
name|Callable
block|{
DECL|field|data
specifier|private
specifier|final
name|byte
index|[]
name|data
decl_stmt|;
DECL|field|offset
specifier|private
name|int
name|offset
decl_stmt|;
DECL|field|length
specifier|private
name|int
name|length
decl_stmt|;
DECL|field|globalOffset
specifier|private
name|long
name|globalOffset
decl_stmt|;
DECL|method|BackgroundReadThread (byte[] buffer, int off, int size, long position)
name|BackgroundReadThread
parameter_list|(
name|byte
index|[]
name|buffer
parameter_list|,
name|int
name|off
parameter_list|,
name|int
name|size
parameter_list|,
name|long
name|position
parameter_list|)
block|{
name|this
operator|.
name|data
operator|=
name|buffer
expr_stmt|;
name|this
operator|.
name|offset
operator|=
name|off
expr_stmt|;
name|this
operator|.
name|length
operator|=
name|size
expr_stmt|;
name|this
operator|.
name|globalOffset
operator|=
name|position
expr_stmt|;
block|}
DECL|method|call ()
specifier|public
name|Object
name|call
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|fillUpData
argument_list|(
name|data
argument_list|,
name|offset
argument_list|,
name|length
argument_list|,
name|globalOffset
argument_list|)
return|;
block|}
block|}
block|}
block|}
end_class

end_unit

