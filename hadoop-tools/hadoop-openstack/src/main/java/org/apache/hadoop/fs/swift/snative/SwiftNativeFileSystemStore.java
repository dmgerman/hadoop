begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.fs.swift.snative
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|swift
operator|.
name|snative
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|httpclient
operator|.
name|Header
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|httpclient
operator|.
name|HttpStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|swift
operator|.
name|exceptions
operator|.
name|SwiftConfigurationException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|swift
operator|.
name|exceptions
operator|.
name|SwiftException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|swift
operator|.
name|exceptions
operator|.
name|SwiftInvalidResponseException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|swift
operator|.
name|exceptions
operator|.
name|SwiftOperationFailedException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|swift
operator|.
name|http
operator|.
name|HttpBodyContent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|swift
operator|.
name|http
operator|.
name|SwiftProtocolConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|swift
operator|.
name|http
operator|.
name|SwiftRestClient
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|swift
operator|.
name|util
operator|.
name|DurationStats
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|swift
operator|.
name|util
operator|.
name|JSONUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|swift
operator|.
name|util
operator|.
name|SwiftObjectPath
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|swift
operator|.
name|util
operator|.
name|SwiftUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|codehaus
operator|.
name|jackson
operator|.
name|map
operator|.
name|type
operator|.
name|CollectionType
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileNotFoundException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InterruptedIOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URI
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URISyntaxException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|text
operator|.
name|ParseException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|text
operator|.
name|SimpleDateFormat
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Matcher
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Pattern
import|;
end_import

begin_comment
comment|/**  * File system store implementation.  * Makes REST requests, parses data from responses  */
end_comment

begin_class
DECL|class|SwiftNativeFileSystemStore
specifier|public
class|class
name|SwiftNativeFileSystemStore
block|{
DECL|field|URI_PATTERN
specifier|private
specifier|static
specifier|final
name|Pattern
name|URI_PATTERN
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"\"\\S+?\""
argument_list|)
decl_stmt|;
DECL|field|PATTERN
specifier|private
specifier|static
specifier|final
name|String
name|PATTERN
init|=
literal|"EEE, d MMM yyyy hh:mm:ss zzz"
decl_stmt|;
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|SwiftNativeFileSystemStore
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|uri
specifier|private
name|URI
name|uri
decl_stmt|;
DECL|field|swiftRestClient
specifier|private
name|SwiftRestClient
name|swiftRestClient
decl_stmt|;
comment|/**    * Initalize the filesystem store -this creates the REST client binding.    *    * @param fsURI         URI of the filesystem, which is used to map to the filesystem-specific    *                      options in the configuration file    * @param configuration configuration    * @throws IOException on any failure.    */
DECL|method|initialize (URI fsURI, Configuration configuration)
specifier|public
name|void
name|initialize
parameter_list|(
name|URI
name|fsURI
parameter_list|,
name|Configuration
name|configuration
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|uri
operator|=
name|fsURI
expr_stmt|;
name|this
operator|.
name|swiftRestClient
operator|=
name|SwiftRestClient
operator|.
name|getInstance
argument_list|(
name|fsURI
argument_list|,
name|configuration
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"SwiftNativeFileSystemStore with "
operator|+
name|swiftRestClient
return|;
block|}
comment|/**    * Get the default blocksize of this (bound) filesystem    * @return the blocksize returned for all FileStatus queries,    * which is used by the MapReduce splitter.    */
DECL|method|getBlocksize ()
specifier|public
name|long
name|getBlocksize
parameter_list|()
block|{
return|return
literal|1024L
operator|*
name|swiftRestClient
operator|.
name|getBlocksizeKB
argument_list|()
return|;
block|}
DECL|method|getPartsizeKB ()
specifier|public
name|long
name|getPartsizeKB
parameter_list|()
block|{
return|return
name|swiftRestClient
operator|.
name|getPartSizeKB
argument_list|()
return|;
block|}
DECL|method|getBufferSizeKB ()
specifier|public
name|int
name|getBufferSizeKB
parameter_list|()
block|{
return|return
name|swiftRestClient
operator|.
name|getBufferSizeKB
argument_list|()
return|;
block|}
DECL|method|getThrottleDelay ()
specifier|public
name|int
name|getThrottleDelay
parameter_list|()
block|{
return|return
name|swiftRestClient
operator|.
name|getThrottleDelay
argument_list|()
return|;
block|}
comment|/**    * Upload a file/input stream of a specific length.    *    * @param path        destination path in the swift filesystem    * @param inputStream input data. This is closed afterwards, always    * @param length      length of the data    * @throws IOException on a problem    */
DECL|method|uploadFile (Path path, InputStream inputStream, long length)
specifier|public
name|void
name|uploadFile
parameter_list|(
name|Path
name|path
parameter_list|,
name|InputStream
name|inputStream
parameter_list|,
name|long
name|length
parameter_list|)
throws|throws
name|IOException
block|{
name|swiftRestClient
operator|.
name|upload
argument_list|(
name|toObjectPath
argument_list|(
name|path
argument_list|)
argument_list|,
name|inputStream
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
comment|/**    * Upload part of a larger file.    *    * @param path        destination path    * @param partNumber  item number in the path    * @param inputStream input data    * @param length      length of the data    * @throws IOException on a problem    */
DECL|method|uploadFilePart (Path path, int partNumber, InputStream inputStream, long length)
specifier|public
name|void
name|uploadFilePart
parameter_list|(
name|Path
name|path
parameter_list|,
name|int
name|partNumber
parameter_list|,
name|InputStream
name|inputStream
parameter_list|,
name|long
name|length
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|stringPath
init|=
name|path
operator|.
name|toUri
argument_list|()
operator|.
name|toString
argument_list|()
decl_stmt|;
name|String
name|partitionFilename
init|=
name|SwiftUtils
operator|.
name|partitionFilenameFromNumber
argument_list|(
name|partNumber
argument_list|)
decl_stmt|;
if|if
condition|(
name|stringPath
operator|.
name|endsWith
argument_list|(
literal|"/"
argument_list|)
condition|)
block|{
name|stringPath
operator|=
name|stringPath
operator|.
name|concat
argument_list|(
name|partitionFilename
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|stringPath
operator|=
name|stringPath
operator|.
name|concat
argument_list|(
literal|"/"
argument_list|)
operator|.
name|concat
argument_list|(
name|partitionFilename
argument_list|)
expr_stmt|;
block|}
name|swiftRestClient
operator|.
name|upload
argument_list|(
operator|new
name|SwiftObjectPath
argument_list|(
name|toDirPath
argument_list|(
name|path
argument_list|)
operator|.
name|getContainer
argument_list|()
argument_list|,
name|stringPath
argument_list|)
argument_list|,
name|inputStream
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
comment|/**    * Tell the Swift server to expect a multi-part upload by submitting    * a 0-byte file with the X-Object-Manifest header    *    * @param path path of final final    * @throws IOException    */
DECL|method|createManifestForPartUpload (Path path)
specifier|public
name|void
name|createManifestForPartUpload
parameter_list|(
name|Path
name|path
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|pathString
init|=
name|toObjectPath
argument_list|(
name|path
argument_list|)
operator|.
name|toString
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|pathString
operator|.
name|endsWith
argument_list|(
literal|"/"
argument_list|)
condition|)
block|{
name|pathString
operator|=
name|pathString
operator|.
name|concat
argument_list|(
literal|"/"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pathString
operator|.
name|startsWith
argument_list|(
literal|"/"
argument_list|)
condition|)
block|{
name|pathString
operator|=
name|pathString
operator|.
name|substring
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|swiftRestClient
operator|.
name|upload
argument_list|(
name|toObjectPath
argument_list|(
name|path
argument_list|)
argument_list|,
operator|new
name|ByteArrayInputStream
argument_list|(
operator|new
name|byte
index|[
literal|0
index|]
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|new
name|Header
argument_list|(
name|SwiftProtocolConstants
operator|.
name|X_OBJECT_MANIFEST
argument_list|,
name|pathString
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Get the metadata of an object    *    * @param path path    * @return file metadata. -or null if no headers were received back from the server.    * @throws IOException           on a problem    * @throws FileNotFoundException if there is nothing at the end    */
DECL|method|getObjectMetadata (Path path)
specifier|public
name|SwiftFileStatus
name|getObjectMetadata
parameter_list|(
name|Path
name|path
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|getObjectMetadata
argument_list|(
name|path
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|/**    * Get the HTTP headers, in case you really need the low-level    * metadata    * @param path path to probe    * @param newest newest or oldest?    * @return the header list    * @throws IOException IO problem    * @throws FileNotFoundException if there is nothing at the end    */
DECL|method|getObjectHeaders (Path path, boolean newest)
specifier|public
name|Header
index|[]
name|getObjectHeaders
parameter_list|(
name|Path
name|path
parameter_list|,
name|boolean
name|newest
parameter_list|)
throws|throws
name|IOException
throws|,
name|FileNotFoundException
block|{
name|SwiftObjectPath
name|objectPath
init|=
name|toObjectPath
argument_list|(
name|path
argument_list|)
decl_stmt|;
return|return
name|stat
argument_list|(
name|objectPath
argument_list|,
name|newest
argument_list|)
return|;
block|}
comment|/**    * Get the metadata of an object    *    * @param path path    * @param newest flag to say "set the newest header", otherwise take any entry    * @return file metadata. -or null if no headers were received back from the server.    * @throws IOException           on a problem    * @throws FileNotFoundException if there is nothing at the end    */
DECL|method|getObjectMetadata (Path path, boolean newest)
specifier|public
name|SwiftFileStatus
name|getObjectMetadata
parameter_list|(
name|Path
name|path
parameter_list|,
name|boolean
name|newest
parameter_list|)
throws|throws
name|IOException
throws|,
name|FileNotFoundException
block|{
name|SwiftObjectPath
name|objectPath
init|=
name|toObjectPath
argument_list|(
name|path
argument_list|)
decl_stmt|;
specifier|final
name|Header
index|[]
name|headers
init|=
name|stat
argument_list|(
name|objectPath
argument_list|,
name|newest
argument_list|)
decl_stmt|;
comment|//no headers is treated as a missing file
if|if
condition|(
name|headers
operator|.
name|length
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|FileNotFoundException
argument_list|(
literal|"Not Found "
operator|+
name|path
operator|.
name|toUri
argument_list|()
argument_list|)
throw|;
block|}
name|boolean
name|isDir
init|=
literal|false
decl_stmt|;
name|long
name|length
init|=
literal|0
decl_stmt|;
name|long
name|lastModified
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Header
name|header
range|:
name|headers
control|)
block|{
name|String
name|headerName
init|=
name|header
operator|.
name|getName
argument_list|()
decl_stmt|;
if|if
condition|(
name|headerName
operator|.
name|equals
argument_list|(
name|SwiftProtocolConstants
operator|.
name|X_CONTAINER_OBJECT_COUNT
argument_list|)
operator|||
name|headerName
operator|.
name|equals
argument_list|(
name|SwiftProtocolConstants
operator|.
name|X_CONTAINER_BYTES_USED
argument_list|)
condition|)
block|{
name|length
operator|=
literal|0
expr_stmt|;
name|isDir
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|SwiftProtocolConstants
operator|.
name|HEADER_CONTENT_LENGTH
operator|.
name|equals
argument_list|(
name|headerName
argument_list|)
condition|)
block|{
name|length
operator|=
name|Long
operator|.
name|parseLong
argument_list|(
name|header
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|SwiftProtocolConstants
operator|.
name|HEADER_LAST_MODIFIED
operator|.
name|equals
argument_list|(
name|headerName
argument_list|)
condition|)
block|{
specifier|final
name|SimpleDateFormat
name|simpleDateFormat
init|=
operator|new
name|SimpleDateFormat
argument_list|(
name|PATTERN
argument_list|)
decl_stmt|;
try|try
block|{
name|lastModified
operator|=
name|simpleDateFormat
operator|.
name|parse
argument_list|(
name|header
operator|.
name|getValue
argument_list|()
argument_list|)
operator|.
name|getTime
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ParseException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SwiftException
argument_list|(
literal|"Failed to parse "
operator|+
name|header
operator|.
name|toString
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
block|}
if|if
condition|(
name|lastModified
operator|==
literal|0
condition|)
block|{
name|lastModified
operator|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
expr_stmt|;
block|}
name|Path
name|correctSwiftPath
init|=
name|getCorrectSwiftPath
argument_list|(
name|path
argument_list|)
decl_stmt|;
return|return
operator|new
name|SwiftFileStatus
argument_list|(
name|length
argument_list|,
name|isDir
argument_list|,
literal|1
argument_list|,
name|getBlocksize
argument_list|()
argument_list|,
name|lastModified
argument_list|,
name|correctSwiftPath
argument_list|)
return|;
block|}
DECL|method|stat (SwiftObjectPath objectPath, boolean newest)
specifier|private
name|Header
index|[]
name|stat
parameter_list|(
name|SwiftObjectPath
name|objectPath
parameter_list|,
name|boolean
name|newest
parameter_list|)
throws|throws
name|IOException
block|{
name|Header
index|[]
name|headers
decl_stmt|;
if|if
condition|(
name|newest
condition|)
block|{
name|headers
operator|=
name|swiftRestClient
operator|.
name|headRequest
argument_list|(
literal|"getObjectMetadata-newest"
argument_list|,
name|objectPath
argument_list|,
name|SwiftRestClient
operator|.
name|NEWEST
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|headers
operator|=
name|swiftRestClient
operator|.
name|headRequest
argument_list|(
literal|"getObjectMetadata"
argument_list|,
name|objectPath
argument_list|)
expr_stmt|;
block|}
return|return
name|headers
return|;
block|}
comment|/**    * Get the object as an input stream    *    * @param path object path    * @return the input stream -this must be closed to terminate the connection    * @throws IOException           IO problems    * @throws FileNotFoundException path doesn't resolve to an object    */
DECL|method|getObject (Path path)
specifier|public
name|HttpBodyContent
name|getObject
parameter_list|(
name|Path
name|path
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|swiftRestClient
operator|.
name|getData
argument_list|(
name|toObjectPath
argument_list|(
name|path
argument_list|)
argument_list|,
name|SwiftRestClient
operator|.
name|NEWEST
argument_list|)
return|;
block|}
comment|/**    * Get the input stream starting from a specific point.    *    * @param path           path to object    * @param byteRangeStart starting point    * @param length         no. of bytes    * @return an input stream that must be closed    * @throws IOException IO problems    */
DECL|method|getObject (Path path, long byteRangeStart, long length)
specifier|public
name|HttpBodyContent
name|getObject
parameter_list|(
name|Path
name|path
parameter_list|,
name|long
name|byteRangeStart
parameter_list|,
name|long
name|length
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|swiftRestClient
operator|.
name|getData
argument_list|(
name|toObjectPath
argument_list|(
name|path
argument_list|)
argument_list|,
name|byteRangeStart
argument_list|,
name|length
argument_list|)
return|;
block|}
comment|/**    * List a directory.    * This is O(n) for the number of objects in this path.    *    *    *    * @param path working path    * @param listDeep ask for all the data    * @param newest ask for the newest data    * @return Collection of file statuses    * @throws IOException IO problems    * @throws FileNotFoundException if the path does not exist    */
DECL|method|listDirectory (SwiftObjectPath path, boolean listDeep, boolean newest)
specifier|private
name|List
argument_list|<
name|FileStatus
argument_list|>
name|listDirectory
parameter_list|(
name|SwiftObjectPath
name|path
parameter_list|,
name|boolean
name|listDeep
parameter_list|,
name|boolean
name|newest
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|byte
index|[]
name|bytes
decl_stmt|;
specifier|final
name|ArrayList
argument_list|<
name|FileStatus
argument_list|>
name|files
init|=
operator|new
name|ArrayList
argument_list|<
name|FileStatus
argument_list|>
argument_list|()
decl_stmt|;
specifier|final
name|Path
name|correctSwiftPath
init|=
name|getCorrectSwiftPath
argument_list|(
name|path
argument_list|)
decl_stmt|;
try|try
block|{
name|bytes
operator|=
name|swiftRestClient
operator|.
name|listDeepObjectsInDirectory
argument_list|(
name|path
argument_list|,
name|listDeep
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|e
parameter_list|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|""
operator|+
literal|"File/Directory not found "
operator|+
name|path
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|SwiftUtils
operator|.
name|isRootDir
argument_list|(
name|path
argument_list|)
condition|)
block|{
return|return
name|Collections
operator|.
name|emptyList
argument_list|()
return|;
block|}
else|else
block|{
throw|throw
name|e
throw|;
block|}
block|}
catch|catch
parameter_list|(
name|SwiftInvalidResponseException
name|e
parameter_list|)
block|{
comment|//bad HTTP error code
if|if
condition|(
name|e
operator|.
name|getStatusCode
argument_list|()
operator|==
name|HttpStatus
operator|.
name|SC_NO_CONTENT
condition|)
block|{
comment|//this can come back on a root list if the container is empty
if|if
condition|(
name|SwiftUtils
operator|.
name|isRootDir
argument_list|(
name|path
argument_list|)
condition|)
block|{
return|return
name|Collections
operator|.
name|emptyList
argument_list|()
return|;
block|}
else|else
block|{
comment|//NO_CONTENT returned on something other than the root directory;
comment|//see if it is there, and convert to empty list or not found
comment|//depending on whether the entry exists.
name|FileStatus
name|stat
init|=
name|getObjectMetadata
argument_list|(
name|correctSwiftPath
argument_list|,
name|newest
argument_list|)
decl_stmt|;
if|if
condition|(
name|stat
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
comment|//it's an empty directory. state that
return|return
name|Collections
operator|.
name|emptyList
argument_list|()
return|;
block|}
else|else
block|{
comment|//it's a file -return that as the status
name|files
operator|.
name|add
argument_list|(
name|stat
argument_list|)
expr_stmt|;
return|return
name|files
return|;
block|}
block|}
block|}
else|else
block|{
comment|//a different status code: rethrow immediately
throw|throw
name|e
throw|;
block|}
block|}
specifier|final
name|CollectionType
name|collectionType
init|=
name|JSONUtil
operator|.
name|getJsonMapper
argument_list|()
operator|.
name|getTypeFactory
argument_list|()
operator|.
name|constructCollectionType
argument_list|(
name|List
operator|.
name|class
argument_list|,
name|SwiftObjectFileStatus
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|SwiftObjectFileStatus
argument_list|>
name|fileStatusList
init|=
name|JSONUtil
operator|.
name|toObject
argument_list|(
operator|new
name|String
argument_list|(
name|bytes
argument_list|)
argument_list|,
name|collectionType
argument_list|)
decl_stmt|;
comment|//this can happen if user lists file /data/files/file
comment|//in this case swift will return empty array
if|if
condition|(
name|fileStatusList
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|SwiftFileStatus
name|objectMetadata
init|=
name|getObjectMetadata
argument_list|(
name|correctSwiftPath
argument_list|,
name|newest
argument_list|)
decl_stmt|;
if|if
condition|(
name|objectMetadata
operator|.
name|isFile
argument_list|()
condition|)
block|{
name|files
operator|.
name|add
argument_list|(
name|objectMetadata
argument_list|)
expr_stmt|;
block|}
return|return
name|files
return|;
block|}
for|for
control|(
name|SwiftObjectFileStatus
name|status
range|:
name|fileStatusList
control|)
block|{
if|if
condition|(
name|status
operator|.
name|getName
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|files
operator|.
name|add
argument_list|(
operator|new
name|SwiftFileStatus
argument_list|(
name|status
operator|.
name|getBytes
argument_list|()
argument_list|,
name|status
operator|.
name|getBytes
argument_list|()
operator|==
literal|0
argument_list|,
literal|1
argument_list|,
name|getBlocksize
argument_list|()
argument_list|,
name|status
operator|.
name|getLast_modified
argument_list|()
operator|.
name|getTime
argument_list|()
argument_list|,
name|getCorrectSwiftPath
argument_list|(
operator|new
name|Path
argument_list|(
name|status
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|files
return|;
block|}
comment|/**    * List all elements in this directory    *    *    *    * @param path     path to work with    * @param recursive do a recursive get    * @param newest ask for the newest, or can some out of date data work?    * @return the file statuses, or an empty array if there are no children    * @throws IOException           on IO problems    * @throws FileNotFoundException if the path is nonexistent    */
DECL|method|listSubPaths (Path path, boolean recursive, boolean newest)
specifier|public
name|FileStatus
index|[]
name|listSubPaths
parameter_list|(
name|Path
name|path
parameter_list|,
name|boolean
name|recursive
parameter_list|,
name|boolean
name|newest
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|Collection
argument_list|<
name|FileStatus
argument_list|>
name|fileStatuses
decl_stmt|;
name|fileStatuses
operator|=
name|listDirectory
argument_list|(
name|toDirPath
argument_list|(
name|path
argument_list|)
argument_list|,
name|recursive
argument_list|,
name|newest
argument_list|)
expr_stmt|;
return|return
name|fileStatuses
operator|.
name|toArray
argument_list|(
operator|new
name|FileStatus
index|[
name|fileStatuses
operator|.
name|size
argument_list|()
index|]
argument_list|)
return|;
block|}
comment|/**    * Create a directory    *    * @param path path    * @throws IOException    */
DECL|method|createDirectory (Path path)
specifier|public
name|void
name|createDirectory
parameter_list|(
name|Path
name|path
parameter_list|)
throws|throws
name|IOException
block|{
name|innerCreateDirectory
argument_list|(
name|toDirPath
argument_list|(
name|path
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * The inner directory creation option. This only creates    * the dir at the given path, not any parent dirs.    * @param swiftObjectPath swift object path at which a 0-byte blob should be    * put    * @throws IOException IO problems    */
DECL|method|innerCreateDirectory (SwiftObjectPath swiftObjectPath)
specifier|private
name|void
name|innerCreateDirectory
parameter_list|(
name|SwiftObjectPath
name|swiftObjectPath
parameter_list|)
throws|throws
name|IOException
block|{
name|swiftRestClient
operator|.
name|putRequest
argument_list|(
name|swiftObjectPath
argument_list|)
expr_stmt|;
block|}
DECL|method|toDirPath (Path path)
specifier|private
name|SwiftObjectPath
name|toDirPath
parameter_list|(
name|Path
name|path
parameter_list|)
throws|throws
name|SwiftConfigurationException
block|{
return|return
name|SwiftObjectPath
operator|.
name|fromPath
argument_list|(
name|uri
argument_list|,
name|path
argument_list|,
literal|false
argument_list|)
return|;
block|}
DECL|method|toObjectPath (Path path)
specifier|private
name|SwiftObjectPath
name|toObjectPath
parameter_list|(
name|Path
name|path
parameter_list|)
throws|throws
name|SwiftConfigurationException
block|{
return|return
name|SwiftObjectPath
operator|.
name|fromPath
argument_list|(
name|uri
argument_list|,
name|path
argument_list|)
return|;
block|}
comment|/**    * Try to find the specific server(s) on which the data lives    * @param path path to probe    * @return a possibly empty list of locations    * @throws IOException on problems determining the locations    */
DECL|method|getObjectLocation (Path path)
specifier|public
name|List
argument_list|<
name|URI
argument_list|>
name|getObjectLocation
parameter_list|(
name|Path
name|path
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|byte
index|[]
name|objectLocation
decl_stmt|;
name|objectLocation
operator|=
name|swiftRestClient
operator|.
name|getObjectLocation
argument_list|(
name|toObjectPath
argument_list|(
name|path
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|objectLocation
operator|==
literal|null
operator|||
name|objectLocation
operator|.
name|length
operator|==
literal|0
condition|)
block|{
comment|//no object location, return an empty list
return|return
operator|new
name|LinkedList
argument_list|<
name|URI
argument_list|>
argument_list|()
return|;
block|}
return|return
name|extractUris
argument_list|(
operator|new
name|String
argument_list|(
name|objectLocation
argument_list|)
argument_list|,
name|path
argument_list|)
return|;
block|}
comment|/**    * deletes object from Swift    *    * @param path path to delete    * @return true if the path was deleted by this specific operation.    * @throws IOException on a failure    */
DECL|method|deleteObject (Path path)
specifier|public
name|boolean
name|deleteObject
parameter_list|(
name|Path
name|path
parameter_list|)
throws|throws
name|IOException
block|{
name|SwiftObjectPath
name|swiftObjectPath
init|=
name|toObjectPath
argument_list|(
name|path
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|SwiftUtils
operator|.
name|isRootDir
argument_list|(
name|swiftObjectPath
argument_list|)
condition|)
block|{
return|return
name|swiftRestClient
operator|.
name|delete
argument_list|(
name|swiftObjectPath
argument_list|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Not deleting root directory entry"
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
block|}
comment|/**    * deletes a directory from Swift. This is not recursive    *    * @param path path to delete    * @return true if the path was deleted by this specific operation -or    *         the path was root and not acted on.    * @throws IOException on a failure    */
DECL|method|rmdir (Path path)
specifier|public
name|boolean
name|rmdir
parameter_list|(
name|Path
name|path
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|deleteObject
argument_list|(
name|path
argument_list|)
return|;
block|}
comment|/**    * Does the object exist    *    * @param path object path    * @return true if the metadata of an object could be retrieved    * @throws IOException IO problems other than FileNotFound, which    *                     is downgraded to an object does not exist return code    */
DECL|method|objectExists (Path path)
specifier|public
name|boolean
name|objectExists
parameter_list|(
name|Path
name|path
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|objectExists
argument_list|(
name|toObjectPath
argument_list|(
name|path
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Does the object exist    *    * @param path swift object path    * @return true if the metadata of an object could be retrieved    * @throws IOException IO problems other than FileNotFound, which    *                     is downgraded to an object does not exist return code    */
DECL|method|objectExists (SwiftObjectPath path)
specifier|public
name|boolean
name|objectExists
parameter_list|(
name|SwiftObjectPath
name|path
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
name|Header
index|[]
name|headers
init|=
name|swiftRestClient
operator|.
name|headRequest
argument_list|(
literal|"objectExists"
argument_list|,
name|path
argument_list|,
name|SwiftRestClient
operator|.
name|NEWEST
argument_list|)
decl_stmt|;
comment|//no headers is treated as a missing file
return|return
name|headers
operator|.
name|length
operator|!=
literal|0
return|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|e
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
block|}
comment|/**    * Rename through copy-and-delete. this is a consequence of the    * Swift filesystem using the path as the hash    * into the Distributed Hash Table, "the ring" of filenames.    *<p/>    * Because of the nature of the operation, it is not atomic.    *    * @param src source file/dir    * @param dst destination    * @throws IOException                   IO failure    * @throws SwiftOperationFailedException if the rename failed    * @throws FileNotFoundException         if the source directory is missing, or    *                                       the parent directory of the destination    */
DECL|method|rename (Path src, Path dst)
specifier|public
name|void
name|rename
parameter_list|(
name|Path
name|src
parameter_list|,
name|Path
name|dst
parameter_list|)
throws|throws
name|FileNotFoundException
throws|,
name|SwiftOperationFailedException
throws|,
name|IOException
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"mv "
operator|+
name|src
operator|+
literal|" "
operator|+
name|dst
argument_list|)
expr_stmt|;
block|}
name|boolean
name|renamingOnToSelf
init|=
name|src
operator|.
name|equals
argument_list|(
name|dst
argument_list|)
decl_stmt|;
name|SwiftObjectPath
name|srcObject
init|=
name|toObjectPath
argument_list|(
name|src
argument_list|)
decl_stmt|;
name|SwiftObjectPath
name|destObject
init|=
name|toObjectPath
argument_list|(
name|dst
argument_list|)
decl_stmt|;
if|if
condition|(
name|SwiftUtils
operator|.
name|isRootDir
argument_list|(
name|srcObject
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SwiftOperationFailedException
argument_list|(
literal|"cannot rename root dir"
argument_list|)
throw|;
block|}
specifier|final
name|SwiftFileStatus
name|srcMetadata
decl_stmt|;
name|srcMetadata
operator|=
name|getObjectMetadata
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|SwiftFileStatus
name|dstMetadata
decl_stmt|;
try|try
block|{
name|dstMetadata
operator|=
name|getObjectMetadata
argument_list|(
name|dst
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|e
parameter_list|)
block|{
comment|//destination does not exist.
name|LOG
operator|.
name|debug
argument_list|(
literal|"Destination does not exist"
argument_list|)
expr_stmt|;
name|dstMetadata
operator|=
literal|null
expr_stmt|;
block|}
comment|//check to see if the destination parent directory exists
name|Path
name|srcParent
init|=
name|src
operator|.
name|getParent
argument_list|()
decl_stmt|;
name|Path
name|dstParent
init|=
name|dst
operator|.
name|getParent
argument_list|()
decl_stmt|;
comment|//skip the overhead of a HEAD call if the src and dest share the same
comment|//parent dir (in which case the dest dir exists), or the destination
comment|//directory is root, in which case it must also exist
if|if
condition|(
name|dstParent
operator|!=
literal|null
operator|&&
operator|!
name|dstParent
operator|.
name|equals
argument_list|(
name|srcParent
argument_list|)
condition|)
block|{
try|try
block|{
name|getObjectMetadata
argument_list|(
name|dstParent
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|e
parameter_list|)
block|{
comment|//destination parent doesn't exist; bail out
name|LOG
operator|.
name|debug
argument_list|(
literal|"destination parent directory "
operator|+
name|dstParent
operator|+
literal|" doesn't exist"
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
name|boolean
name|destExists
init|=
name|dstMetadata
operator|!=
literal|null
decl_stmt|;
name|boolean
name|destIsDir
init|=
name|destExists
operator|&&
name|SwiftUtils
operator|.
name|isDirectory
argument_list|(
name|dstMetadata
argument_list|)
decl_stmt|;
comment|//calculate the destination
name|SwiftObjectPath
name|destPath
decl_stmt|;
comment|//enum the child entries and everything underneath
name|List
argument_list|<
name|FileStatus
argument_list|>
name|childStats
init|=
name|listDirectory
argument_list|(
name|srcObject
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|boolean
name|srcIsFile
init|=
operator|!
name|srcMetadata
operator|.
name|isDir
argument_list|()
decl_stmt|;
if|if
condition|(
name|srcIsFile
condition|)
block|{
comment|//source is a simple file OR a partitioned file
comment|// outcomes:
comment|// #1 dest exists and is file: fail
comment|// #2 dest exists and is dir: destination path becomes under dest dir
comment|// #3 dest does not exist: use dest as name
if|if
condition|(
name|destExists
condition|)
block|{
if|if
condition|(
name|destIsDir
condition|)
block|{
comment|//outcome #2 -move to subdir of dest
name|destPath
operator|=
name|toObjectPath
argument_list|(
operator|new
name|Path
argument_list|(
name|dst
argument_list|,
name|src
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|//outcome #1 dest it's a file: fail if differeent
if|if
condition|(
operator|!
name|renamingOnToSelf
condition|)
block|{
throw|throw
operator|new
name|SwiftOperationFailedException
argument_list|(
literal|"cannot rename a file over one that already exists"
argument_list|)
throw|;
block|}
else|else
block|{
comment|//is mv self self where self is a file. this becomes a no-op
name|LOG
operator|.
name|debug
argument_list|(
literal|"Renaming file onto self: no-op => success"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
else|else
block|{
comment|//outcome #3 -new entry
name|destPath
operator|=
name|toObjectPath
argument_list|(
name|dst
argument_list|)
expr_stmt|;
block|}
name|int
name|childCount
init|=
name|childStats
operator|.
name|size
argument_list|()
decl_stmt|;
comment|//here there is one of:
comment|// - a single object ==> standard file
comment|// ->
if|if
condition|(
name|childCount
operator|==
literal|0
condition|)
block|{
name|copyThenDeleteObject
argument_list|(
name|srcObject
argument_list|,
name|destPath
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|//do the copy
name|SwiftUtils
operator|.
name|debug
argument_list|(
name|LOG
argument_list|,
literal|"Source file appears to be partitioned."
operator|+
literal|" copying file and deleting children"
argument_list|)
expr_stmt|;
name|copyObject
argument_list|(
name|srcObject
argument_list|,
name|destPath
argument_list|)
expr_stmt|;
for|for
control|(
name|FileStatus
name|stat
range|:
name|childStats
control|)
block|{
name|SwiftUtils
operator|.
name|debug
argument_list|(
name|LOG
argument_list|,
literal|"Deleting partitioned file %s "
argument_list|,
name|stat
argument_list|)
expr_stmt|;
name|deleteObject
argument_list|(
name|stat
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|swiftRestClient
operator|.
name|delete
argument_list|(
name|srcObject
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|//here the source exists and is a directory
comment|// outcomes (given we know the parent dir exists if we get this far)
comment|// #1 destination is a file: fail
comment|// #2 destination is a directory: create a new dir under that one
comment|// #3 destination doesn't exist: create a new dir with that name
comment|// #3 and #4 are only allowed if the dest path is not == or under src
if|if
condition|(
name|destExists
operator|&&
operator|!
name|destIsDir
condition|)
block|{
comment|// #1 destination is a file: fail
throw|throw
operator|new
name|SwiftOperationFailedException
argument_list|(
literal|"the source is a directory, but not the destination"
argument_list|)
throw|;
block|}
name|Path
name|targetPath
decl_stmt|;
if|if
condition|(
name|destExists
condition|)
block|{
comment|// #2 destination is a directory: create a new dir under that one
name|targetPath
operator|=
operator|new
name|Path
argument_list|(
name|dst
argument_list|,
name|src
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// #3 destination doesn't exist: create a new dir with that name
name|targetPath
operator|=
name|dst
expr_stmt|;
block|}
name|SwiftObjectPath
name|targetObjectPath
init|=
name|toObjectPath
argument_list|(
name|targetPath
argument_list|)
decl_stmt|;
comment|//final check for any recursive operations
if|if
condition|(
name|srcObject
operator|.
name|isEqualToOrParentOf
argument_list|(
name|targetObjectPath
argument_list|)
condition|)
block|{
comment|//you can't rename a directory onto itself
throw|throw
operator|new
name|SwiftOperationFailedException
argument_list|(
literal|"cannot move a directory under itself"
argument_list|)
throw|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"mv  "
operator|+
name|srcObject
operator|+
literal|" "
operator|+
name|targetPath
argument_list|)
expr_stmt|;
name|logDirectory
argument_list|(
literal|"Directory to copy "
argument_list|,
name|srcObject
argument_list|,
name|childStats
argument_list|)
expr_stmt|;
comment|// iterative copy of everything under the directory.
comment|// by listing all children this can be done iteratively
comment|// rather than recursively -everything in this list is either a file
comment|// or a 0-byte-len file pretending to be a directory.
name|String
name|srcURI
init|=
name|src
operator|.
name|toUri
argument_list|()
operator|.
name|toString
argument_list|()
decl_stmt|;
name|int
name|prefixStripCount
init|=
name|srcURI
operator|.
name|length
argument_list|()
operator|+
literal|1
decl_stmt|;
for|for
control|(
name|FileStatus
name|fileStatus
range|:
name|childStats
control|)
block|{
name|Path
name|copySourcePath
init|=
name|fileStatus
operator|.
name|getPath
argument_list|()
decl_stmt|;
name|String
name|copySourceURI
init|=
name|copySourcePath
operator|.
name|toUri
argument_list|()
operator|.
name|toString
argument_list|()
decl_stmt|;
name|String
name|copyDestSubPath
init|=
name|copySourceURI
operator|.
name|substring
argument_list|(
name|prefixStripCount
argument_list|)
decl_stmt|;
name|Path
name|copyDestPath
init|=
operator|new
name|Path
argument_list|(
name|targetPath
argument_list|,
name|copyDestSubPath
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
comment|//trace to debug some low-level rename path problems; retained
comment|//in case they ever come back.
name|LOG
operator|.
name|trace
argument_list|(
literal|"srcURI="
operator|+
name|srcURI
operator|+
literal|"; copySourceURI="
operator|+
name|copySourceURI
operator|+
literal|"; copyDestSubPath="
operator|+
name|copyDestSubPath
operator|+
literal|"; copyDestPath="
operator|+
name|copyDestPath
argument_list|)
expr_stmt|;
block|}
name|SwiftObjectPath
name|copyDestination
init|=
name|toObjectPath
argument_list|(
name|copyDestPath
argument_list|)
decl_stmt|;
try|try
block|{
name|copyThenDeleteObject
argument_list|(
name|toObjectPath
argument_list|(
name|copySourcePath
argument_list|)
argument_list|,
name|copyDestination
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Skipping rename of "
operator|+
name|copySourcePath
argument_list|)
expr_stmt|;
block|}
comment|//add a throttle delay
name|throttle
argument_list|()
expr_stmt|;
block|}
comment|//now rename self. If missing, create the dest directory and warn
if|if
condition|(
operator|!
name|SwiftUtils
operator|.
name|isRootDir
argument_list|(
name|srcObject
argument_list|)
condition|)
block|{
try|try
block|{
name|copyThenDeleteObject
argument_list|(
name|srcObject
argument_list|,
name|targetObjectPath
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|e
parameter_list|)
block|{
comment|//create the destination directory
name|LOG
operator|.
name|warn
argument_list|(
literal|"Source directory deleted during rename"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|innerCreateDirectory
argument_list|(
name|destObject
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**    * Debug action to dump directory statuses to the debug log    *    * @param message    explanation    * @param objectPath object path (can be null)    * @param statuses   listing output    */
DECL|method|logDirectory (String message, SwiftObjectPath objectPath, Iterable<FileStatus> statuses)
specifier|private
name|void
name|logDirectory
parameter_list|(
name|String
name|message
parameter_list|,
name|SwiftObjectPath
name|objectPath
parameter_list|,
name|Iterable
argument_list|<
name|FileStatus
argument_list|>
name|statuses
parameter_list|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|message
operator|+
literal|": listing of "
operator|+
name|objectPath
argument_list|)
expr_stmt|;
for|for
control|(
name|FileStatus
name|fileStatus
range|:
name|statuses
control|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|fileStatus
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|copy (Path srcKey, Path dstKey)
specifier|public
name|void
name|copy
parameter_list|(
name|Path
name|srcKey
parameter_list|,
name|Path
name|dstKey
parameter_list|)
throws|throws
name|IOException
block|{
name|SwiftObjectPath
name|srcObject
init|=
name|toObjectPath
argument_list|(
name|srcKey
argument_list|)
decl_stmt|;
name|SwiftObjectPath
name|destObject
init|=
name|toObjectPath
argument_list|(
name|dstKey
argument_list|)
decl_stmt|;
name|swiftRestClient
operator|.
name|copyObject
argument_list|(
name|srcObject
argument_list|,
name|destObject
argument_list|)
expr_stmt|;
block|}
comment|/**    * Copy an object then, if the copy worked, delete it.    * If the copy failed, the source object is not deleted.    *    * @param srcObject  source object path    * @param destObject destination object path    * @throws IOException IO problems     */
DECL|method|copyThenDeleteObject (SwiftObjectPath srcObject, SwiftObjectPath destObject)
specifier|private
name|void
name|copyThenDeleteObject
parameter_list|(
name|SwiftObjectPath
name|srcObject
parameter_list|,
name|SwiftObjectPath
name|destObject
parameter_list|)
throws|throws
name|IOException
block|{
comment|//do the copy
name|copyObject
argument_list|(
name|srcObject
argument_list|,
name|destObject
argument_list|)
expr_stmt|;
comment|//getting here means the copy worked
name|swiftRestClient
operator|.
name|delete
argument_list|(
name|srcObject
argument_list|)
expr_stmt|;
block|}
comment|/**    * Copy an object    * @param srcObject  source object path    * @param destObject destination object path    * @throws IOException IO problems    */
DECL|method|copyObject (SwiftObjectPath srcObject, SwiftObjectPath destObject)
specifier|private
name|void
name|copyObject
parameter_list|(
name|SwiftObjectPath
name|srcObject
parameter_list|,
name|SwiftObjectPath
name|destObject
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|srcObject
operator|.
name|isEqualToOrParentOf
argument_list|(
name|destObject
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SwiftException
argument_list|(
literal|"Can't copy "
operator|+
name|srcObject
operator|+
literal|" onto "
operator|+
name|destObject
argument_list|)
throw|;
block|}
comment|//do the copy
name|boolean
name|copySucceeded
init|=
name|swiftRestClient
operator|.
name|copyObject
argument_list|(
name|srcObject
argument_list|,
name|destObject
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|copySucceeded
condition|)
block|{
throw|throw
operator|new
name|SwiftException
argument_list|(
literal|"Copy of "
operator|+
name|srcObject
operator|+
literal|" to "
operator|+
name|destObject
operator|+
literal|"failed"
argument_list|)
throw|;
block|}
block|}
comment|/**    * Take a Hadoop path and return one which uses the URI prefix and authority    * of this FS. It doesn't make a relative path absolute    * @param path path in    * @return path with a URI bound to this FS    * @throws SwiftException URI cannot be created.    */
DECL|method|getCorrectSwiftPath (Path path)
specifier|public
name|Path
name|getCorrectSwiftPath
parameter_list|(
name|Path
name|path
parameter_list|)
throws|throws
name|SwiftException
block|{
try|try
block|{
specifier|final
name|URI
name|fullUri
init|=
operator|new
name|URI
argument_list|(
name|uri
operator|.
name|getScheme
argument_list|()
argument_list|,
name|uri
operator|.
name|getAuthority
argument_list|()
argument_list|,
name|path
operator|.
name|toUri
argument_list|()
operator|.
name|getPath
argument_list|()
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
decl_stmt|;
return|return
operator|new
name|Path
argument_list|(
name|fullUri
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|URISyntaxException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SwiftException
argument_list|(
literal|"Specified path "
operator|+
name|path
operator|+
literal|" is incorrect"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**    * Builds a hadoop-Path from a swift path, inserting the URI authority    * of this FS instance    * @param path swift object path    * @return Hadoop path    * @throws SwiftException if the URI couldn't be created.    */
DECL|method|getCorrectSwiftPath (SwiftObjectPath path)
specifier|private
name|Path
name|getCorrectSwiftPath
parameter_list|(
name|SwiftObjectPath
name|path
parameter_list|)
throws|throws
name|SwiftException
block|{
try|try
block|{
specifier|final
name|URI
name|fullUri
init|=
operator|new
name|URI
argument_list|(
name|uri
operator|.
name|getScheme
argument_list|()
argument_list|,
name|uri
operator|.
name|getAuthority
argument_list|()
argument_list|,
name|path
operator|.
name|getObject
argument_list|()
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
decl_stmt|;
return|return
operator|new
name|Path
argument_list|(
name|fullUri
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|URISyntaxException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SwiftException
argument_list|(
literal|"Specified path "
operator|+
name|path
operator|+
literal|" is incorrect"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**    * extracts URIs from json    * @param json json to parse    * @param path path (used in exceptions)    * @return URIs    * @throws SwiftOperationFailedException on any problem parsing the JSON    */
DECL|method|extractUris (String json, Path path)
specifier|public
specifier|static
name|List
argument_list|<
name|URI
argument_list|>
name|extractUris
parameter_list|(
name|String
name|json
parameter_list|,
name|Path
name|path
parameter_list|)
throws|throws
name|SwiftOperationFailedException
block|{
specifier|final
name|Matcher
name|matcher
init|=
name|URI_PATTERN
operator|.
name|matcher
argument_list|(
name|json
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|URI
argument_list|>
name|result
init|=
operator|new
name|ArrayList
argument_list|<
name|URI
argument_list|>
argument_list|()
decl_stmt|;
while|while
condition|(
name|matcher
operator|.
name|find
argument_list|()
condition|)
block|{
specifier|final
name|String
name|s
init|=
name|matcher
operator|.
name|group
argument_list|()
decl_stmt|;
specifier|final
name|String
name|uri
init|=
name|s
operator|.
name|substring
argument_list|(
literal|1
argument_list|,
name|s
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
try|try
block|{
name|URI
name|createdUri
init|=
name|URI
operator|.
name|create
argument_list|(
name|uri
argument_list|)
decl_stmt|;
name|result
operator|.
name|add
argument_list|(
name|createdUri
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
comment|//failure to create the URI, which means this is bad JSON. Convert
comment|//to an exception with useful text
throw|throw
operator|new
name|SwiftOperationFailedException
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"could not convert \"%s\" into a URI."
operator|+
literal|" source: %s "
operator|+
literal|" first JSON: %s"
argument_list|,
name|uri
argument_list|,
name|path
argument_list|,
name|json
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
literal|256
argument_list|)
argument_list|)
argument_list|)
throw|;
block|}
block|}
return|return
name|result
return|;
block|}
comment|/**    * Insert a throttled wait if the throttle delay>0    * @throws InterruptedIOException if interrupted during sleep    */
DECL|method|throttle ()
specifier|public
name|void
name|throttle
parameter_list|()
throws|throws
name|InterruptedIOException
block|{
name|int
name|throttleDelay
init|=
name|getThrottleDelay
argument_list|()
decl_stmt|;
if|if
condition|(
name|throttleDelay
operator|>
literal|0
condition|)
block|{
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|throttleDelay
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
comment|//convert to an IOE
throw|throw
operator|(
name|InterruptedIOException
operator|)
operator|new
name|InterruptedIOException
argument_list|(
name|e
operator|.
name|toString
argument_list|()
argument_list|)
operator|.
name|initCause
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
block|}
comment|/**    * Get the current operation statistics    * @return a snapshot of the statistics    */
DECL|method|getOperationStatistics ()
specifier|public
name|List
argument_list|<
name|DurationStats
argument_list|>
name|getOperationStatistics
parameter_list|()
block|{
return|return
name|swiftRestClient
operator|.
name|getOperationStatistics
argument_list|()
return|;
block|}
comment|/**    * Delete the entire tree. This is an internal one with slightly different    * behavior: if an entry is missing, a {@link FileNotFoundException} is    * raised. This lets the caller distinguish a file not found with    * other reasons for failure, so handles race conditions in recursive    * directory deletes better.    *<p/>    * The problem being addressed is: caller A requests a recursive directory    * of directory /dir ; caller B requests a delete of a file /dir/file,    * between caller A enumerating the files contents, and requesting a delete    * of /dir/file. We want to recognise the special case    * "directed file is no longer there" and not convert that into a failure    *    * @param absolutePath  the path to delete.    * @param recursive if path is a directory and set to    *                  true, the directory is deleted else throws an exception if the    *                  directory is not empty    *                  case of a file the recursive can be set to either true or false.    * @return true if the object was deleted    * @throws IOException           IO problems    * @throws FileNotFoundException if a file/dir being deleted is not there -    *                               this includes entries below the specified path, (if the path is a dir    *                               and recursive is true)    */
DECL|method|delete (Path absolutePath, boolean recursive)
specifier|public
name|boolean
name|delete
parameter_list|(
name|Path
name|absolutePath
parameter_list|,
name|boolean
name|recursive
parameter_list|)
throws|throws
name|IOException
block|{
name|Path
name|swiftPath
init|=
name|getCorrectSwiftPath
argument_list|(
name|absolutePath
argument_list|)
decl_stmt|;
name|SwiftUtils
operator|.
name|debug
argument_list|(
name|LOG
argument_list|,
literal|"Deleting path '%s' recursive=%b"
argument_list|,
name|absolutePath
argument_list|,
name|recursive
argument_list|)
expr_stmt|;
name|boolean
name|askForNewest
init|=
literal|true
decl_stmt|;
name|SwiftFileStatus
name|fileStatus
init|=
name|getObjectMetadata
argument_list|(
name|swiftPath
argument_list|,
name|askForNewest
argument_list|)
decl_stmt|;
comment|//ask for the file/dir status, but don't demand the newest, as we
comment|//don't mind if the directory has changed
comment|//list all entries under this directory.
comment|//this will throw FileNotFoundException if the file isn't there
name|FileStatus
index|[]
name|statuses
init|=
name|listSubPaths
argument_list|(
name|absolutePath
argument_list|,
literal|true
argument_list|,
name|askForNewest
argument_list|)
decl_stmt|;
if|if
condition|(
name|statuses
operator|==
literal|null
condition|)
block|{
comment|//the directory went away during the non-atomic stages of the operation.
comment|// Return false as it was not this thread doing the deletion.
name|SwiftUtils
operator|.
name|debug
argument_list|(
name|LOG
argument_list|,
literal|"Path '%s' has no status -it has 'gone away'"
argument_list|,
name|absolutePath
argument_list|,
name|recursive
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|int
name|filecount
init|=
name|statuses
operator|.
name|length
decl_stmt|;
name|SwiftUtils
operator|.
name|debug
argument_list|(
name|LOG
argument_list|,
literal|"Path '%s' %d status entries'"
argument_list|,
name|absolutePath
argument_list|,
name|filecount
argument_list|)
expr_stmt|;
if|if
condition|(
name|filecount
operator|==
literal|0
condition|)
block|{
comment|//it's an empty directory or a path
name|rmdir
argument_list|(
name|absolutePath
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|SwiftUtils
operator|.
name|debug
argument_list|(
name|LOG
argument_list|,
literal|"%s"
argument_list|,
name|SwiftUtils
operator|.
name|fileStatsToString
argument_list|(
name|statuses
argument_list|,
literal|"\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|filecount
operator|==
literal|1
operator|&&
name|swiftPath
operator|.
name|equals
argument_list|(
name|statuses
index|[
literal|0
index|]
operator|.
name|getPath
argument_list|()
argument_list|)
condition|)
block|{
comment|// 1 entry => simple file and it is the target
comment|//simple file: delete it
name|SwiftUtils
operator|.
name|debug
argument_list|(
name|LOG
argument_list|,
literal|"Deleting simple file %s"
argument_list|,
name|absolutePath
argument_list|)
expr_stmt|;
name|deleteObject
argument_list|(
name|absolutePath
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|//>1 entry implies directory with children. Run through them,
comment|// but first check for the recursive flag and reject it *unless it looks
comment|// like a partitioned file (len> 0&& has children)
if|if
condition|(
operator|!
name|fileStatus
operator|.
name|isDir
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Multiple child entries but entry has data: assume partitioned"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|recursive
condition|)
block|{
comment|//if there are children, unless this is a recursive operation, fail immediately
throw|throw
operator|new
name|SwiftOperationFailedException
argument_list|(
literal|"Directory "
operator|+
name|fileStatus
operator|+
literal|" is not empty: "
operator|+
name|SwiftUtils
operator|.
name|fileStatsToString
argument_list|(
name|statuses
argument_list|,
literal|"; "
argument_list|)
argument_list|)
throw|;
block|}
comment|//delete the entries. including ourself.
for|for
control|(
name|FileStatus
name|entryStatus
range|:
name|statuses
control|)
block|{
name|Path
name|entryPath
init|=
name|entryStatus
operator|.
name|getPath
argument_list|()
decl_stmt|;
try|try
block|{
name|boolean
name|deleted
init|=
name|deleteObject
argument_list|(
name|entryPath
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|deleted
condition|)
block|{
name|SwiftUtils
operator|.
name|debug
argument_list|(
name|LOG
argument_list|,
literal|"Failed to delete entry '%s'; continuing"
argument_list|,
name|entryPath
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|e
parameter_list|)
block|{
comment|//the path went away -race conditions.
comment|//do not fail, as the outcome is still OK.
name|SwiftUtils
operator|.
name|debug
argument_list|(
name|LOG
argument_list|,
literal|"Path '%s' is no longer present; continuing"
argument_list|,
name|entryPath
argument_list|)
expr_stmt|;
block|}
name|throttle
argument_list|()
expr_stmt|;
block|}
comment|//now delete self
name|SwiftUtils
operator|.
name|debug
argument_list|(
name|LOG
argument_list|,
literal|"Deleting base entry %s"
argument_list|,
name|absolutePath
argument_list|)
expr_stmt|;
name|deleteObject
argument_list|(
name|absolutePath
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
end_class

end_unit

