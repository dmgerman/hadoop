begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.fs.swift.snative
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|swift
operator|.
name|snative
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|UserGroupInformation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|BlockLocation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FSDataInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FSDataOutputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileAlreadyExistsException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|ParentNotDirectoryException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|permission
operator|.
name|FsPermission
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|swift
operator|.
name|exceptions
operator|.
name|SwiftConfigurationException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|swift
operator|.
name|exceptions
operator|.
name|SwiftOperationFailedException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|swift
operator|.
name|exceptions
operator|.
name|SwiftUnsupportedFeatureException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|swift
operator|.
name|http
operator|.
name|SwiftProtocolConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|swift
operator|.
name|util
operator|.
name|DurationStats
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|swift
operator|.
name|util
operator|.
name|SwiftObjectPath
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|swift
operator|.
name|util
operator|.
name|SwiftUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Progressable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileNotFoundException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URI
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_comment
comment|/**  * Swift file system implementation. Extends Hadoop FileSystem  */
end_comment

begin_class
DECL|class|SwiftNativeFileSystem
specifier|public
class|class
name|SwiftNativeFileSystem
extends|extends
name|FileSystem
block|{
comment|/** filesystem prefix: {@value} */
DECL|field|SWIFT
specifier|public
specifier|static
specifier|final
name|String
name|SWIFT
init|=
literal|"swift"
decl_stmt|;
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|SwiftNativeFileSystem
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/**    * path to user work directory for storing temporary files    */
DECL|field|workingDir
specifier|private
name|Path
name|workingDir
decl_stmt|;
comment|/**    * Swift URI    */
DECL|field|uri
specifier|private
name|URI
name|uri
decl_stmt|;
comment|/**    * reference to swiftFileSystemStore    */
DECL|field|store
specifier|private
name|SwiftNativeFileSystemStore
name|store
decl_stmt|;
comment|/**    * Default constructor for Hadoop    */
DECL|method|SwiftNativeFileSystem ()
specifier|public
name|SwiftNativeFileSystem
parameter_list|()
block|{
comment|// set client in initialize()
block|}
comment|/**    * This constructor used for testing purposes    */
DECL|method|SwiftNativeFileSystem (SwiftNativeFileSystemStore store)
specifier|public
name|SwiftNativeFileSystem
parameter_list|(
name|SwiftNativeFileSystemStore
name|store
parameter_list|)
block|{
name|this
operator|.
name|store
operator|=
name|store
expr_stmt|;
block|}
comment|/**    * This is for testing    * @return the inner store class    */
DECL|method|getStore ()
specifier|public
name|SwiftNativeFileSystemStore
name|getStore
parameter_list|()
block|{
return|return
name|store
return|;
block|}
annotation|@
name|Override
DECL|method|getScheme ()
specifier|public
name|String
name|getScheme
parameter_list|()
block|{
return|return
name|SWIFT
return|;
block|}
comment|/**    * default class initialization.    *    * @param fsuri path to Swift    * @param conf  Hadoop configuration    * @throws IOException    */
annotation|@
name|Override
DECL|method|initialize (URI fsuri, Configuration conf)
specifier|public
name|void
name|initialize
parameter_list|(
name|URI
name|fsuri
parameter_list|,
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|super
operator|.
name|initialize
argument_list|(
name|fsuri
argument_list|,
name|conf
argument_list|)
expr_stmt|;
name|setConf
argument_list|(
name|conf
argument_list|)
expr_stmt|;
if|if
condition|(
name|store
operator|==
literal|null
condition|)
block|{
name|store
operator|=
operator|new
name|SwiftNativeFileSystemStore
argument_list|()
expr_stmt|;
block|}
name|this
operator|.
name|uri
operator|=
name|fsuri
expr_stmt|;
name|String
name|username
decl_stmt|;
try|try
block|{
name|username
operator|=
name|UserGroupInformation
operator|.
name|getCurrentUser
argument_list|()
operator|.
name|getShortUserName
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Unable to get user name. Fall back to system property "
operator|+
literal|"user.name"
argument_list|,
name|ex
argument_list|)
expr_stmt|;
name|username
operator|=
name|System
operator|.
name|getProperty
argument_list|(
literal|"user.name"
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|workingDir
operator|=
operator|new
name|Path
argument_list|(
literal|"/user"
argument_list|,
name|username
argument_list|)
operator|.
name|makeQualified
argument_list|(
name|uri
argument_list|,
operator|new
name|Path
argument_list|(
name|username
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Initializing SwiftNativeFileSystem against URI "
operator|+
name|uri
operator|+
literal|" and working dir "
operator|+
name|workingDir
argument_list|)
expr_stmt|;
block|}
name|store
operator|.
name|initialize
argument_list|(
name|uri
argument_list|,
name|conf
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"SwiftFileSystem initialized"
argument_list|)
expr_stmt|;
block|}
comment|/**    * @return path to Swift    */
annotation|@
name|Override
DECL|method|getUri ()
specifier|public
name|URI
name|getUri
parameter_list|()
block|{
return|return
name|uri
return|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"Swift FileSystem "
operator|+
name|store
return|;
block|}
comment|/**    * Path to user working directory    *    * @return Hadoop path    */
annotation|@
name|Override
DECL|method|getWorkingDirectory ()
specifier|public
name|Path
name|getWorkingDirectory
parameter_list|()
block|{
return|return
name|workingDir
return|;
block|}
comment|/**    * @param dir user working directory    */
annotation|@
name|Override
DECL|method|setWorkingDirectory (Path dir)
specifier|public
name|void
name|setWorkingDirectory
parameter_list|(
name|Path
name|dir
parameter_list|)
block|{
name|workingDir
operator|=
name|makeAbsolute
argument_list|(
name|dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"SwiftFileSystem.setWorkingDirectory to "
operator|+
name|dir
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Return a file status object that represents the path.    *    * @param path The path we want information from    * @return a FileStatus object    */
annotation|@
name|Override
DECL|method|getFileStatus (Path path)
specifier|public
name|FileStatus
name|getFileStatus
parameter_list|(
name|Path
name|path
parameter_list|)
throws|throws
name|IOException
block|{
name|Path
name|absolutePath
init|=
name|makeAbsolute
argument_list|(
name|path
argument_list|)
decl_stmt|;
return|return
name|store
operator|.
name|getObjectMetadata
argument_list|(
name|absolutePath
argument_list|)
return|;
block|}
comment|/**    * The blocksize of this filesystem is set by the property    * SwiftProtocolConstants.SWIFT_BLOCKSIZE;the default is the value of    * SwiftProtocolConstants.DEFAULT_SWIFT_BLOCKSIZE;    * @return the blocksize for this FS.    */
annotation|@
name|Override
DECL|method|getDefaultBlockSize ()
specifier|public
name|long
name|getDefaultBlockSize
parameter_list|()
block|{
return|return
name|store
operator|.
name|getBlocksize
argument_list|()
return|;
block|}
comment|/**    * The blocksize for this filesystem.    * @see #getDefaultBlockSize()    * @param f path of file    * @return the blocksize for the path    */
annotation|@
name|Override
DECL|method|getDefaultBlockSize (Path f)
specifier|public
name|long
name|getDefaultBlockSize
parameter_list|(
name|Path
name|f
parameter_list|)
block|{
return|return
name|store
operator|.
name|getBlocksize
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|getBlockSize (Path path)
specifier|public
name|long
name|getBlockSize
parameter_list|(
name|Path
name|path
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|store
operator|.
name|getBlocksize
argument_list|()
return|;
block|}
annotation|@
name|Override
annotation|@
name|SuppressWarnings
argument_list|(
literal|"deprecation"
argument_list|)
DECL|method|isFile (Path f)
specifier|public
name|boolean
name|isFile
parameter_list|(
name|Path
name|f
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
name|FileStatus
name|fileStatus
init|=
name|getFileStatus
argument_list|(
name|f
argument_list|)
decl_stmt|;
return|return
operator|!
name|SwiftUtils
operator|.
name|isDirectory
argument_list|(
name|fileStatus
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|e
parameter_list|)
block|{
return|return
literal|false
return|;
comment|// f does not exist
block|}
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"deprecation"
argument_list|)
annotation|@
name|Override
DECL|method|isDirectory (Path f)
specifier|public
name|boolean
name|isDirectory
parameter_list|(
name|Path
name|f
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
name|FileStatus
name|fileStatus
init|=
name|getFileStatus
argument_list|(
name|f
argument_list|)
decl_stmt|;
return|return
name|SwiftUtils
operator|.
name|isDirectory
argument_list|(
name|fileStatus
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|e
parameter_list|)
block|{
return|return
literal|false
return|;
comment|// f does not exist
block|}
block|}
comment|/**    * Override getCononicalServiceName because we don't support token in Swift    */
annotation|@
name|Override
DECL|method|getCanonicalServiceName ()
specifier|public
name|String
name|getCanonicalServiceName
parameter_list|()
block|{
comment|// Does not support Token
return|return
literal|null
return|;
block|}
comment|/**    * Return an array containing hostnames, offset and size of    * portions of the given file.  For a nonexistent    * file or regions, null will be returned.    *<p>    * This call is most helpful with DFS, where it returns    * hostnames of machines that contain the given file.    *<p>    * The FileSystem will simply return an elt containing 'localhost'.    */
annotation|@
name|Override
DECL|method|getFileBlockLocations (FileStatus file, long start, long len)
specifier|public
name|BlockLocation
index|[]
name|getFileBlockLocations
parameter_list|(
name|FileStatus
name|file
parameter_list|,
name|long
name|start
parameter_list|,
name|long
name|len
parameter_list|)
throws|throws
name|IOException
block|{
comment|//argument checks
if|if
condition|(
name|file
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
name|start
operator|<
literal|0
operator|||
name|len
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Negative start or len parameter"
operator|+
literal|" to getFileBlockLocations"
argument_list|)
throw|;
block|}
if|if
condition|(
name|file
operator|.
name|getLen
argument_list|()
operator|<=
name|start
condition|)
block|{
return|return
operator|new
name|BlockLocation
index|[
literal|0
index|]
return|;
block|}
comment|// Check if requested file in Swift is more than 5Gb. In this case
comment|// each block has its own location -which may be determinable
comment|// from the Swift client API, depending on the remote server
specifier|final
name|FileStatus
index|[]
name|listOfFileBlocks
init|=
name|store
operator|.
name|listSubPaths
argument_list|(
name|file
operator|.
name|getPath
argument_list|()
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|URI
argument_list|>
name|locations
init|=
operator|new
name|ArrayList
argument_list|<
name|URI
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|listOfFileBlocks
operator|.
name|length
operator|>
literal|1
condition|)
block|{
for|for
control|(
name|FileStatus
name|fileStatus
range|:
name|listOfFileBlocks
control|)
block|{
if|if
condition|(
name|SwiftObjectPath
operator|.
name|fromPath
argument_list|(
name|uri
argument_list|,
name|fileStatus
operator|.
name|getPath
argument_list|()
argument_list|)
operator|.
name|equals
argument_list|(
name|SwiftObjectPath
operator|.
name|fromPath
argument_list|(
name|uri
argument_list|,
name|file
operator|.
name|getPath
argument_list|()
argument_list|)
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|locations
operator|.
name|addAll
argument_list|(
name|store
operator|.
name|getObjectLocation
argument_list|(
name|fileStatus
operator|.
name|getPath
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|locations
operator|=
name|store
operator|.
name|getObjectLocation
argument_list|(
name|file
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|locations
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"No locations returned for "
operator|+
name|file
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
comment|//no locations were returned for the object
comment|//fall back to the superclass
name|String
index|[]
name|name
init|=
block|{
name|SwiftProtocolConstants
operator|.
name|BLOCK_LOCATION
block|}
decl_stmt|;
name|String
index|[]
name|host
init|=
block|{
literal|"localhost"
block|}
decl_stmt|;
name|String
index|[]
name|topology
init|=
block|{
name|SwiftProtocolConstants
operator|.
name|TOPOLOGY_PATH
block|}
decl_stmt|;
return|return
operator|new
name|BlockLocation
index|[]
block|{
operator|new
name|BlockLocation
argument_list|(
name|name
argument_list|,
name|host
argument_list|,
name|topology
argument_list|,
literal|0
argument_list|,
name|file
operator|.
name|getLen
argument_list|()
argument_list|)
block|}
return|;
block|}
specifier|final
name|String
index|[]
name|names
init|=
operator|new
name|String
index|[
name|locations
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
specifier|final
name|String
index|[]
name|hosts
init|=
operator|new
name|String
index|[
name|locations
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|URI
name|location
range|:
name|locations
control|)
block|{
name|hosts
index|[
name|i
index|]
operator|=
name|location
operator|.
name|getHost
argument_list|()
expr_stmt|;
name|names
index|[
name|i
index|]
operator|=
name|location
operator|.
name|getAuthority
argument_list|()
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
return|return
operator|new
name|BlockLocation
index|[]
block|{
operator|new
name|BlockLocation
argument_list|(
name|names
argument_list|,
name|hosts
argument_list|,
literal|0
argument_list|,
name|file
operator|.
name|getLen
argument_list|()
argument_list|)
block|}
return|;
block|}
comment|/**    * Create the parent directories.    * As an optimization, the entire hierarchy of parent    * directories is<i>Not</i> polled. Instead    * the tree is walked up from the last to the first,    * creating directories until one that exists is found.    *    * This strategy means if a file is created in an existing directory,    * one quick poll suffices.    *    * There is a big assumption here: that all parent directories of an existing    * directory also exists.    * @param path path to create.    * @param permission to apply to files    * @return true if the operation was successful    * @throws IOException on a problem    */
annotation|@
name|Override
DECL|method|mkdirs (Path path, FsPermission permission)
specifier|public
name|boolean
name|mkdirs
parameter_list|(
name|Path
name|path
parameter_list|,
name|FsPermission
name|permission
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"SwiftFileSystem.mkdirs: "
operator|+
name|path
argument_list|)
expr_stmt|;
block|}
name|Path
name|directory
init|=
name|makeAbsolute
argument_list|(
name|path
argument_list|)
decl_stmt|;
comment|//build a list of paths to create
name|List
argument_list|<
name|Path
argument_list|>
name|paths
init|=
operator|new
name|ArrayList
argument_list|<
name|Path
argument_list|>
argument_list|()
decl_stmt|;
while|while
condition|(
name|shouldCreate
argument_list|(
name|directory
argument_list|)
condition|)
block|{
comment|//this directory needs creation, add to the list
name|paths
operator|.
name|add
argument_list|(
literal|0
argument_list|,
name|directory
argument_list|)
expr_stmt|;
comment|//now see if the parent needs to be created
name|directory
operator|=
name|directory
operator|.
name|getParent
argument_list|()
expr_stmt|;
block|}
comment|//go through the list of directories to create
for|for
control|(
name|Path
name|p
range|:
name|paths
control|)
block|{
if|if
condition|(
name|isNotRoot
argument_list|(
name|p
argument_list|)
condition|)
block|{
comment|//perform a mkdir operation without any polling of
comment|//the far end first
name|forceMkdir
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
comment|//if an exception was not thrown, this operation is considered
comment|//a success
return|return
literal|true
return|;
block|}
DECL|method|isNotRoot (Path absolutePath)
specifier|private
name|boolean
name|isNotRoot
parameter_list|(
name|Path
name|absolutePath
parameter_list|)
block|{
return|return
operator|!
name|isRoot
argument_list|(
name|absolutePath
argument_list|)
return|;
block|}
DECL|method|isRoot (Path absolutePath)
specifier|private
name|boolean
name|isRoot
parameter_list|(
name|Path
name|absolutePath
parameter_list|)
block|{
return|return
name|absolutePath
operator|.
name|getParent
argument_list|()
operator|==
literal|null
return|;
block|}
comment|/**    * internal implementation of directory creation.    *    * @param path path to file    * @return boolean file is created; false: no need to create    * @throws IOException if specified path is file instead of directory    */
DECL|method|mkdir (Path path)
specifier|private
name|boolean
name|mkdir
parameter_list|(
name|Path
name|path
parameter_list|)
throws|throws
name|IOException
block|{
name|Path
name|directory
init|=
name|makeAbsolute
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|boolean
name|shouldCreate
init|=
name|shouldCreate
argument_list|(
name|directory
argument_list|)
decl_stmt|;
if|if
condition|(
name|shouldCreate
condition|)
block|{
name|forceMkdir
argument_list|(
name|directory
argument_list|)
expr_stmt|;
block|}
return|return
name|shouldCreate
return|;
block|}
comment|/**    * Should mkdir create this directory?    * If the directory is root : false    * If the entry exists and is a directory: false    * If the entry exists and is a file: exception    * else: true    * @param directory path to query    * @return true iff the directory should be created    * @throws IOException IO problems    * @throws ParentNotDirectoryException if the path references a file    */
DECL|method|shouldCreate (Path directory)
specifier|private
name|boolean
name|shouldCreate
parameter_list|(
name|Path
name|directory
parameter_list|)
throws|throws
name|IOException
block|{
name|FileStatus
name|fileStatus
decl_stmt|;
name|boolean
name|shouldCreate
decl_stmt|;
if|if
condition|(
name|isRoot
argument_list|(
name|directory
argument_list|)
condition|)
block|{
comment|//its the base dir, bail out immediately
return|return
literal|false
return|;
block|}
try|try
block|{
comment|//find out about the path
name|fileStatus
operator|=
name|getFileStatus
argument_list|(
name|directory
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SwiftUtils
operator|.
name|isDirectory
argument_list|(
name|fileStatus
argument_list|)
condition|)
block|{
comment|//if it's a file, raise an error
throw|throw
operator|new
name|ParentNotDirectoryException
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"%s: can't mkdir since it exists and is not a directory: %s"
argument_list|,
name|directory
argument_list|,
name|fileStatus
argument_list|)
argument_list|)
throw|;
block|}
else|else
block|{
comment|//path exists, and it is a directory
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"skipping mkdir("
operator|+
name|directory
operator|+
literal|") as it exists already"
argument_list|)
expr_stmt|;
block|}
name|shouldCreate
operator|=
literal|false
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|e
parameter_list|)
block|{
name|shouldCreate
operator|=
literal|true
expr_stmt|;
block|}
return|return
name|shouldCreate
return|;
block|}
comment|/**    * mkdir of a directory -irrespective of what was there underneath.    * There are no checks for the directory existing, there not    * being a path there, etc. etc. Those are assumed to have    * taken place already    * @param absolutePath path to create    * @throws IOException IO problems    */
DECL|method|forceMkdir (Path absolutePath)
specifier|private
name|void
name|forceMkdir
parameter_list|(
name|Path
name|absolutePath
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Making dir '"
operator|+
name|absolutePath
operator|+
literal|"' in Swift"
argument_list|)
expr_stmt|;
block|}
comment|//file is not found: it must be created
name|store
operator|.
name|createDirectory
argument_list|(
name|absolutePath
argument_list|)
expr_stmt|;
block|}
comment|/**    * List the statuses of the files/directories in the given path if the path is    * a directory.    *    * @param path given path    * @return the statuses of the files/directories in the given path    * @throws IOException    */
annotation|@
name|Override
DECL|method|listStatus (Path path)
specifier|public
name|FileStatus
index|[]
name|listStatus
parameter_list|(
name|Path
name|path
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"SwiftFileSystem.listStatus for: "
operator|+
name|path
argument_list|)
expr_stmt|;
block|}
return|return
name|store
operator|.
name|listSubPaths
argument_list|(
name|makeAbsolute
argument_list|(
name|path
argument_list|)
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|/**    * This optional operation is not supported    */
annotation|@
name|Override
DECL|method|append (Path f, int bufferSize, Progressable progress)
specifier|public
name|FSDataOutputStream
name|append
parameter_list|(
name|Path
name|f
parameter_list|,
name|int
name|bufferSize
parameter_list|,
name|Progressable
name|progress
parameter_list|)
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"SwiftFileSystem.append"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|SwiftUnsupportedFeatureException
argument_list|(
literal|"Not supported: append()"
argument_list|)
throw|;
block|}
comment|/**    * @param permission Currently ignored.    */
annotation|@
name|Override
DECL|method|create (Path file, FsPermission permission, boolean overwrite, int bufferSize, short replication, long blockSize, Progressable progress)
specifier|public
name|FSDataOutputStream
name|create
parameter_list|(
name|Path
name|file
parameter_list|,
name|FsPermission
name|permission
parameter_list|,
name|boolean
name|overwrite
parameter_list|,
name|int
name|bufferSize
parameter_list|,
name|short
name|replication
parameter_list|,
name|long
name|blockSize
parameter_list|,
name|Progressable
name|progress
parameter_list|)
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"SwiftFileSystem.create"
argument_list|)
expr_stmt|;
name|FileStatus
name|fileStatus
init|=
literal|null
decl_stmt|;
name|Path
name|absolutePath
init|=
name|makeAbsolute
argument_list|(
name|file
argument_list|)
decl_stmt|;
try|try
block|{
name|fileStatus
operator|=
name|getFileStatus
argument_list|(
name|absolutePath
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|e
parameter_list|)
block|{
comment|//the file isn't there.
block|}
if|if
condition|(
name|fileStatus
operator|!=
literal|null
condition|)
block|{
comment|//the path exists -action depends on whether or not it is a directory,
comment|//and what the overwrite policy is.
comment|//What is clear at this point is that if the entry exists, there's
comment|//no need to bother creating any parent entries
if|if
condition|(
name|fileStatus
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
comment|//here someone is trying to create a file over a directory
comment|/*    we can't throw an exception here as there is no easy way to distinguish      a file from the dir          throw new SwiftPathExistsException("Cannot create a file over a directory:"                                            + file);  */
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Overwriting either an empty file or a directory"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|overwrite
condition|)
block|{
comment|//overwrite set -> delete the object.
name|store
operator|.
name|delete
argument_list|(
name|absolutePath
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|FileAlreadyExistsException
argument_list|(
literal|"Path exists: "
operator|+
name|file
argument_list|)
throw|;
block|}
block|}
else|else
block|{
comment|// destination does not exist -trigger creation of the parent
name|Path
name|parent
init|=
name|file
operator|.
name|getParent
argument_list|()
decl_stmt|;
if|if
condition|(
name|parent
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
operator|!
name|mkdirs
argument_list|(
name|parent
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SwiftOperationFailedException
argument_list|(
literal|"Mkdirs failed to create "
operator|+
name|parent
argument_list|)
throw|;
block|}
block|}
block|}
name|SwiftNativeOutputStream
name|out
init|=
name|createSwiftOutputStream
argument_list|(
name|file
argument_list|)
decl_stmt|;
return|return
operator|new
name|FSDataOutputStream
argument_list|(
name|out
argument_list|,
name|statistics
argument_list|)
return|;
block|}
comment|/**    * Create the swift output stream    * @param path path to write to    * @return the new file    * @throws IOException    */
DECL|method|createSwiftOutputStream (Path path)
specifier|protected
name|SwiftNativeOutputStream
name|createSwiftOutputStream
parameter_list|(
name|Path
name|path
parameter_list|)
throws|throws
name|IOException
block|{
name|long
name|partSizeKB
init|=
name|getStore
argument_list|()
operator|.
name|getPartsizeKB
argument_list|()
decl_stmt|;
return|return
operator|new
name|SwiftNativeOutputStream
argument_list|(
name|getConf
argument_list|()
argument_list|,
name|getStore
argument_list|()
argument_list|,
name|path
operator|.
name|toUri
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|,
name|partSizeKB
argument_list|)
return|;
block|}
comment|/**    * Opens an FSDataInputStream at the indicated Path.    *    * @param path       the file name to open    * @param bufferSize the size of the buffer to be used.    * @return the input stream    * @throws FileNotFoundException if the file is not found    * @throws IOException any IO problem    */
annotation|@
name|Override
DECL|method|open (Path path, int bufferSize)
specifier|public
name|FSDataInputStream
name|open
parameter_list|(
name|Path
name|path
parameter_list|,
name|int
name|bufferSize
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|bufferSizeKB
init|=
name|getStore
argument_list|()
operator|.
name|getBufferSizeKB
argument_list|()
decl_stmt|;
name|long
name|readBlockSize
init|=
name|bufferSizeKB
operator|*
literal|1024L
decl_stmt|;
return|return
name|open
argument_list|(
name|path
argument_list|,
name|bufferSize
argument_list|,
name|readBlockSize
argument_list|)
return|;
block|}
comment|/**    * Low-level operation to also set the block size for this operation    * @param path       the file name to open    * @param bufferSize the size of the buffer to be used.    * @param readBlockSize how big should the read block/buffer size be?    * @return the input stream    * @throws FileNotFoundException if the file is not found    * @throws IOException any IO problem    */
DECL|method|open (Path path, int bufferSize, long readBlockSize)
specifier|public
name|FSDataInputStream
name|open
parameter_list|(
name|Path
name|path
parameter_list|,
name|int
name|bufferSize
parameter_list|,
name|long
name|readBlockSize
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|readBlockSize
operator|<=
literal|0
condition|)
block|{
throw|throw
operator|new
name|SwiftConfigurationException
argument_list|(
literal|"Bad remote buffer size"
argument_list|)
throw|;
block|}
name|Path
name|absolutePath
init|=
name|makeAbsolute
argument_list|(
name|path
argument_list|)
decl_stmt|;
return|return
operator|new
name|FSDataInputStream
argument_list|(
operator|new
name|StrictBufferedFSInputStream
argument_list|(
operator|new
name|SwiftNativeInputStream
argument_list|(
name|store
argument_list|,
name|statistics
argument_list|,
name|absolutePath
argument_list|,
name|readBlockSize
argument_list|)
argument_list|,
name|bufferSize
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Renames Path src to Path dst. On swift this uses copy-and-delete    * and<i>is not atomic</i>.    *    * @param src path    * @param dst path    * @return true if directory renamed, false otherwise    * @throws IOException on problems    */
annotation|@
name|Override
DECL|method|rename (Path src, Path dst)
specifier|public
name|boolean
name|rename
parameter_list|(
name|Path
name|src
parameter_list|,
name|Path
name|dst
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
name|store
operator|.
name|rename
argument_list|(
name|makeAbsolute
argument_list|(
name|src
argument_list|)
argument_list|,
name|makeAbsolute
argument_list|(
name|dst
argument_list|)
argument_list|)
expr_stmt|;
comment|//success
return|return
literal|true
return|;
block|}
catch|catch
parameter_list|(
name|SwiftOperationFailedException
name|e
parameter_list|)
block|{
comment|//downgrade to a failure
return|return
literal|false
return|;
block|}
catch|catch
parameter_list|(
name|FileAlreadyExistsException
name|e
parameter_list|)
block|{
comment|//downgrade to a failure
return|return
literal|false
return|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|e
parameter_list|)
block|{
comment|//downgrade to a failure
return|return
literal|false
return|;
block|}
block|}
comment|/**    * Delete a file or directory    *    * @param path      the path to delete.    * @param recursive if path is a directory and set to    *                  true, the directory is deleted else throws an exception if the    *                  directory is not empty    *                  case of a file the recursive can be set to either true or false.    * @return true if the object was deleted    * @throws IOException IO problems    */
annotation|@
name|Override
DECL|method|delete (Path path, boolean recursive)
specifier|public
name|boolean
name|delete
parameter_list|(
name|Path
name|path
parameter_list|,
name|boolean
name|recursive
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
return|return
name|store
operator|.
name|delete
argument_list|(
name|path
argument_list|,
name|recursive
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|e
parameter_list|)
block|{
comment|//base path was not found.
return|return
literal|false
return|;
block|}
block|}
comment|/**    * Delete a file.    * This method is abstract in Hadoop 1.x; in 2.x+ it is non-abstract    * and deprecated    */
annotation|@
name|Override
DECL|method|delete (Path f)
specifier|public
name|boolean
name|delete
parameter_list|(
name|Path
name|f
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|delete
argument_list|(
name|f
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|/**    * Makes path absolute    *    * @param path path to file    * @return absolute path    */
DECL|method|makeAbsolute (Path path)
specifier|protected
name|Path
name|makeAbsolute
parameter_list|(
name|Path
name|path
parameter_list|)
block|{
if|if
condition|(
name|path
operator|.
name|isAbsolute
argument_list|()
condition|)
block|{
return|return
name|path
return|;
block|}
return|return
operator|new
name|Path
argument_list|(
name|workingDir
argument_list|,
name|path
argument_list|)
return|;
block|}
comment|/**    * Get the current operation statistics    * @return a snapshot of the statistics    */
DECL|method|getOperationStatistics ()
specifier|public
name|List
argument_list|<
name|DurationStats
argument_list|>
name|getOperationStatistics
parameter_list|()
block|{
return|return
name|store
operator|.
name|getOperationStatistics
argument_list|()
return|;
block|}
comment|/**    * Low level method to do a deep listing of all entries, not stopping    * at the next directory entry. This is to let tests be confident that    * recursive deletes really are working.    * @param path path to recurse down    * @param newest ask for the newest data, potentially slower than not.    * @return a potentially empty array of file status    * @throws IOException any problem    */
annotation|@
name|InterfaceAudience
operator|.
name|Private
DECL|method|listRawFileStatus (Path path, boolean newest)
specifier|public
name|FileStatus
index|[]
name|listRawFileStatus
parameter_list|(
name|Path
name|path
parameter_list|,
name|boolean
name|newest
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|store
operator|.
name|listSubPaths
argument_list|(
name|makeAbsolute
argument_list|(
name|path
argument_list|)
argument_list|,
literal|true
argument_list|,
name|newest
argument_list|)
return|;
block|}
comment|/**    * Get the number of partitions written by an output stream    * This is for testing    * @param outputStream output stream    * @return the #of partitions written by that stream    */
annotation|@
name|InterfaceAudience
operator|.
name|Private
DECL|method|getPartitionsWritten (FSDataOutputStream outputStream)
specifier|public
specifier|static
name|int
name|getPartitionsWritten
parameter_list|(
name|FSDataOutputStream
name|outputStream
parameter_list|)
block|{
name|SwiftNativeOutputStream
name|snos
init|=
name|getSwiftNativeOutputStream
argument_list|(
name|outputStream
argument_list|)
decl_stmt|;
return|return
name|snos
operator|.
name|getPartitionsWritten
argument_list|()
return|;
block|}
DECL|method|getSwiftNativeOutputStream ( FSDataOutputStream outputStream)
specifier|private
specifier|static
name|SwiftNativeOutputStream
name|getSwiftNativeOutputStream
parameter_list|(
name|FSDataOutputStream
name|outputStream
parameter_list|)
block|{
name|OutputStream
name|wrappedStream
init|=
name|outputStream
operator|.
name|getWrappedStream
argument_list|()
decl_stmt|;
return|return
operator|(
name|SwiftNativeOutputStream
operator|)
name|wrappedStream
return|;
block|}
comment|/**    * Get the size of partitions written by an output stream    * This is for testing    *    * @param outputStream output stream    * @return partition size in bytes    */
annotation|@
name|InterfaceAudience
operator|.
name|Private
DECL|method|getPartitionSize (FSDataOutputStream outputStream)
specifier|public
specifier|static
name|long
name|getPartitionSize
parameter_list|(
name|FSDataOutputStream
name|outputStream
parameter_list|)
block|{
name|SwiftNativeOutputStream
name|snos
init|=
name|getSwiftNativeOutputStream
argument_list|(
name|outputStream
argument_list|)
decl_stmt|;
return|return
name|snos
operator|.
name|getFilePartSize
argument_list|()
return|;
block|}
comment|/**    * Get the the number of bytes written to an output stream    * This is for testing    *    * @param outputStream output stream    * @return partition size in bytes    */
annotation|@
name|InterfaceAudience
operator|.
name|Private
DECL|method|getBytesWritten (FSDataOutputStream outputStream)
specifier|public
specifier|static
name|long
name|getBytesWritten
parameter_list|(
name|FSDataOutputStream
name|outputStream
parameter_list|)
block|{
name|SwiftNativeOutputStream
name|snos
init|=
name|getSwiftNativeOutputStream
argument_list|(
name|outputStream
argument_list|)
decl_stmt|;
return|return
name|snos
operator|.
name|getBytesWritten
argument_list|()
return|;
block|}
comment|/**    * Get the the number of bytes uploaded by an output stream    * to the swift cluster.    * This is for testing    *    * @param outputStream output stream    * @return partition size in bytes    */
annotation|@
name|InterfaceAudience
operator|.
name|Private
DECL|method|getBytesUploaded (FSDataOutputStream outputStream)
specifier|public
specifier|static
name|long
name|getBytesUploaded
parameter_list|(
name|FSDataOutputStream
name|outputStream
parameter_list|)
block|{
name|SwiftNativeOutputStream
name|snos
init|=
name|getSwiftNativeOutputStream
argument_list|(
name|outputStream
argument_list|)
decl_stmt|;
return|return
name|snos
operator|.
name|getBytesUploaded
argument_list|()
return|;
block|}
block|}
end_class

end_unit

