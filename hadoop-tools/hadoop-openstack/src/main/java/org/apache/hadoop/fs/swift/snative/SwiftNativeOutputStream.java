begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.fs.swift.snative
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|swift
operator|.
name|snative
package|;
end_package

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|swift
operator|.
name|exceptions
operator|.
name|SwiftConnectionClosedException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|swift
operator|.
name|exceptions
operator|.
name|SwiftException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|swift
operator|.
name|exceptions
operator|.
name|SwiftInternalStateException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|swift
operator|.
name|util
operator|.
name|SwiftUtils
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|BufferedOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import

begin_comment
comment|/**  * Output stream, buffers data on local disk.  * Writes to Swift on the close() method, unless the  * file is significantly large that it is being written as partitions.  * In this case, the first partition is written on the first write that puts  * data over the partition, as may later writes. The close() then causes  * the final partition to be written, along with a partition manifest.  */
end_comment

begin_class
DECL|class|SwiftNativeOutputStream
class|class
name|SwiftNativeOutputStream
extends|extends
name|OutputStream
block|{
DECL|field|ATTEMPT_LIMIT
specifier|public
specifier|static
specifier|final
name|int
name|ATTEMPT_LIMIT
init|=
literal|3
decl_stmt|;
DECL|field|filePartSize
specifier|private
name|long
name|filePartSize
decl_stmt|;
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|SwiftNativeOutputStream
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|conf
specifier|private
name|Configuration
name|conf
decl_stmt|;
DECL|field|key
specifier|private
name|String
name|key
decl_stmt|;
DECL|field|backupFile
specifier|private
name|File
name|backupFile
decl_stmt|;
DECL|field|backupStream
specifier|private
name|OutputStream
name|backupStream
decl_stmt|;
DECL|field|nativeStore
specifier|private
name|SwiftNativeFileSystemStore
name|nativeStore
decl_stmt|;
DECL|field|closed
specifier|private
name|boolean
name|closed
decl_stmt|;
DECL|field|partNumber
specifier|private
name|int
name|partNumber
decl_stmt|;
DECL|field|blockOffset
specifier|private
name|long
name|blockOffset
decl_stmt|;
DECL|field|bytesWritten
specifier|private
name|long
name|bytesWritten
decl_stmt|;
DECL|field|bytesUploaded
specifier|private
name|long
name|bytesUploaded
decl_stmt|;
DECL|field|partUpload
specifier|private
name|boolean
name|partUpload
init|=
literal|false
decl_stmt|;
DECL|field|oneByte
specifier|final
name|byte
index|[]
name|oneByte
init|=
operator|new
name|byte
index|[
literal|1
index|]
decl_stmt|;
comment|/**    * Create an output stream    * @param conf configuration to use    * @param nativeStore native store to write through    * @param key the key to write    * @param partSizeKB the partition size    * @throws IOException    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"IOResourceOpenedButNotSafelyClosed"
argument_list|)
DECL|method|SwiftNativeOutputStream (Configuration conf, SwiftNativeFileSystemStore nativeStore, String key, long partSizeKB)
specifier|public
name|SwiftNativeOutputStream
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|SwiftNativeFileSystemStore
name|nativeStore
parameter_list|,
name|String
name|key
parameter_list|,
name|long
name|partSizeKB
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|conf
operator|=
name|conf
expr_stmt|;
name|this
operator|.
name|key
operator|=
name|key
expr_stmt|;
name|this
operator|.
name|backupFile
operator|=
name|newBackupFile
argument_list|()
expr_stmt|;
name|this
operator|.
name|nativeStore
operator|=
name|nativeStore
expr_stmt|;
name|this
operator|.
name|backupStream
operator|=
operator|new
name|BufferedOutputStream
argument_list|(
operator|new
name|FileOutputStream
argument_list|(
name|backupFile
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|partNumber
operator|=
literal|1
expr_stmt|;
name|this
operator|.
name|blockOffset
operator|=
literal|0
expr_stmt|;
name|this
operator|.
name|filePartSize
operator|=
literal|1024L
operator|*
name|partSizeKB
expr_stmt|;
block|}
DECL|method|newBackupFile ()
specifier|private
name|File
name|newBackupFile
parameter_list|()
throws|throws
name|IOException
block|{
name|File
name|dir
init|=
operator|new
name|File
argument_list|(
name|conf
operator|.
name|get
argument_list|(
literal|"hadoop.tmp.dir"
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|dir
operator|.
name|mkdirs
argument_list|()
operator|&&
operator|!
name|dir
operator|.
name|exists
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SwiftException
argument_list|(
literal|"Cannot create Swift buffer directory: "
operator|+
name|dir
argument_list|)
throw|;
block|}
name|File
name|result
init|=
name|File
operator|.
name|createTempFile
argument_list|(
literal|"output-"
argument_list|,
literal|".tmp"
argument_list|,
name|dir
argument_list|)
decl_stmt|;
name|result
operator|.
name|deleteOnExit
argument_list|()
expr_stmt|;
return|return
name|result
return|;
block|}
comment|/**    * Flush the local backing stream.    * This does not trigger a flush of data to the remote blobstore.    * @throws IOException    */
annotation|@
name|Override
DECL|method|flush ()
specifier|public
name|void
name|flush
parameter_list|()
throws|throws
name|IOException
block|{
name|backupStream
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
comment|/**    * check that the output stream is open    *    * @throws SwiftException if it is not    */
DECL|method|verifyOpen ()
specifier|private
specifier|synchronized
name|void
name|verifyOpen
parameter_list|()
throws|throws
name|SwiftException
block|{
if|if
condition|(
name|closed
condition|)
block|{
throw|throw
operator|new
name|SwiftConnectionClosedException
argument_list|()
throw|;
block|}
block|}
comment|/**    * Close the stream. This will trigger the upload of all locally cached    * data to the remote blobstore.    * @throws IOException IO problems uploading the data.    */
annotation|@
name|Override
DECL|method|close ()
specifier|public
specifier|synchronized
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|closed
condition|)
block|{
return|return;
block|}
try|try
block|{
name|closed
operator|=
literal|true
expr_stmt|;
comment|//formally declare as closed.
name|backupStream
operator|.
name|close
argument_list|()
expr_stmt|;
name|backupStream
operator|=
literal|null
expr_stmt|;
name|Path
name|keypath
init|=
operator|new
name|Path
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|partUpload
condition|)
block|{
name|partUpload
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|nativeStore
operator|.
name|createManifestForPartUpload
argument_list|(
name|keypath
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|uploadOnClose
argument_list|(
name|keypath
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|delete
argument_list|(
name|backupFile
argument_list|)
expr_stmt|;
name|backupFile
operator|=
literal|null
expr_stmt|;
block|}
assert|assert
name|backupStream
operator|==
literal|null
operator|:
literal|"backup stream has been reopened"
assert|;
block|}
comment|/**    * Upload a file when closed, either in one go, or, if the file is    * already partitioned, by uploading the remaining partition and a manifest.    * @param keypath key as a path    * @throws IOException IO Problems    */
DECL|method|uploadOnClose (Path keypath)
specifier|private
name|void
name|uploadOnClose
parameter_list|(
name|Path
name|keypath
parameter_list|)
throws|throws
name|IOException
block|{
name|boolean
name|uploadSuccess
init|=
literal|false
decl_stmt|;
name|int
name|attempt
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|!
name|uploadSuccess
condition|)
block|{
try|try
block|{
operator|++
name|attempt
expr_stmt|;
name|bytesUploaded
operator|+=
name|uploadFileAttempt
argument_list|(
name|keypath
argument_list|,
name|attempt
argument_list|)
expr_stmt|;
name|uploadSuccess
operator|=
literal|true
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Upload failed "
operator|+
name|e
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|attempt
operator|>
name|ATTEMPT_LIMIT
condition|)
block|{
throw|throw
name|e
throw|;
block|}
block|}
block|}
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"IOResourceOpenedButNotSafelyClosed"
argument_list|)
DECL|method|uploadFileAttempt (Path keypath, int attempt)
specifier|private
name|long
name|uploadFileAttempt
parameter_list|(
name|Path
name|keypath
parameter_list|,
name|int
name|attempt
parameter_list|)
throws|throws
name|IOException
block|{
name|long
name|uploadLen
init|=
name|backupFile
operator|.
name|length
argument_list|()
decl_stmt|;
name|SwiftUtils
operator|.
name|debug
argument_list|(
name|LOG
argument_list|,
literal|"Closing write of file %s;"
operator|+
literal|" localfile=%s of length %d - attempt %d"
argument_list|,
name|key
argument_list|,
name|backupFile
argument_list|,
name|uploadLen
argument_list|,
name|attempt
argument_list|)
expr_stmt|;
name|nativeStore
operator|.
name|uploadFile
argument_list|(
name|keypath
argument_list|,
operator|new
name|FileInputStream
argument_list|(
name|backupFile
argument_list|)
argument_list|,
name|uploadLen
argument_list|)
expr_stmt|;
return|return
name|uploadLen
return|;
block|}
annotation|@
name|Override
DECL|method|finalize ()
specifier|protected
name|void
name|finalize
parameter_list|()
throws|throws
name|Throwable
block|{
if|if
condition|(
operator|!
name|closed
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"stream not closed"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|backupFile
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Leaking backing file "
operator|+
name|backupFile
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|delete (File file)
specifier|private
name|void
name|delete
parameter_list|(
name|File
name|file
parameter_list|)
block|{
if|if
condition|(
name|file
operator|!=
literal|null
condition|)
block|{
name|SwiftUtils
operator|.
name|debug
argument_list|(
name|LOG
argument_list|,
literal|"deleting %s"
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|file
operator|.
name|delete
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Could not delete "
operator|+
name|file
argument_list|)
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
DECL|method|write (int b)
specifier|public
name|void
name|write
parameter_list|(
name|int
name|b
parameter_list|)
throws|throws
name|IOException
block|{
comment|//insert to a one byte array
name|oneByte
index|[
literal|0
index|]
operator|=
operator|(
name|byte
operator|)
name|b
expr_stmt|;
comment|//then delegate to the array writing routine
name|write
argument_list|(
name|oneByte
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|write (byte[] buffer, int offset, int len)
specifier|public
specifier|synchronized
name|void
name|write
parameter_list|(
name|byte
index|[]
name|buffer
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|len
parameter_list|)
throws|throws
name|IOException
block|{
comment|//validate args
if|if
condition|(
name|offset
operator|<
literal|0
operator|||
name|len
argument_list|<
literal|0
operator|||
operator|(
name|offset
operator|+
name|len
operator|)
argument_list|>
name|buffer
operator|.
name|length
condition|)
block|{
throw|throw
operator|new
name|IndexOutOfBoundsException
argument_list|(
literal|"Invalid offset/length for write"
argument_list|)
throw|;
block|}
comment|//validate the output stream
name|verifyOpen
argument_list|()
expr_stmt|;
name|SwiftUtils
operator|.
name|debug
argument_list|(
name|LOG
argument_list|,
literal|" write(offset=%d, len=%d)"
argument_list|,
name|offset
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|// if the size of file is greater than the partition limit
while|while
condition|(
name|blockOffset
operator|+
name|len
operator|>=
name|filePartSize
condition|)
block|{
comment|// - then partition the blob and upload as many partitions
comment|// are needed.
comment|//how many bytes to write for this partition.
name|int
name|subWriteLen
init|=
call|(
name|int
call|)
argument_list|(
name|filePartSize
operator|-
name|blockOffset
argument_list|)
decl_stmt|;
if|if
condition|(
name|subWriteLen
argument_list|<
literal|0
operator|||
name|subWriteLen
argument_list|>
name|len
condition|)
block|{
throw|throw
operator|new
name|SwiftInternalStateException
argument_list|(
literal|"Invalid subwrite len: "
operator|+
name|subWriteLen
operator|+
literal|" -buffer len: "
operator|+
name|len
argument_list|)
throw|;
block|}
name|writeToBackupStream
argument_list|(
name|buffer
argument_list|,
name|offset
argument_list|,
name|subWriteLen
argument_list|)
expr_stmt|;
comment|//move the offset along and length down
name|offset
operator|+=
name|subWriteLen
expr_stmt|;
name|len
operator|-=
name|subWriteLen
expr_stmt|;
comment|//now upload the partition that has just been filled up
comment|// (this also sets blockOffset=0)
name|partUpload
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
comment|//any remaining data is now written
name|writeToBackupStream
argument_list|(
name|buffer
argument_list|,
name|offset
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
comment|/**    * Write to the backup stream.    * Guarantees:    *<ol>    *<li>backupStream is open</li>    *<li>blockOffset + len&lt; filePartSize</li>    *</ol>    * @param buffer buffer to write    * @param offset offset in buffer    * @param len length of write.    * @throws IOException backup stream write failing    */
DECL|method|writeToBackupStream (byte[] buffer, int offset, int len)
specifier|private
name|void
name|writeToBackupStream
parameter_list|(
name|byte
index|[]
name|buffer
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|len
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|len
operator|>=
literal|0
operator|:
literal|"remainder to write is negative"
assert|;
name|SwiftUtils
operator|.
name|debug
argument_list|(
name|LOG
argument_list|,
literal|" writeToBackupStream(offset=%d, len=%d)"
argument_list|,
name|offset
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
comment|//no remainder -downgrade to no-op
return|return;
block|}
comment|//write the new data out to the backup stream
name|backupStream
operator|.
name|write
argument_list|(
name|buffer
argument_list|,
name|offset
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|//increment the counters
name|blockOffset
operator|+=
name|len
expr_stmt|;
name|bytesWritten
operator|+=
name|len
expr_stmt|;
block|}
comment|/**    * Upload a single partition. This deletes the local backing-file,    * and re-opens it to create a new one.    * @param closingUpload is this the final upload of an upload    * @throws IOException on IO problems    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"IOResourceOpenedButNotSafelyClosed"
argument_list|)
DECL|method|partUpload (boolean closingUpload)
specifier|private
name|void
name|partUpload
parameter_list|(
name|boolean
name|closingUpload
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|backupStream
operator|!=
literal|null
condition|)
block|{
name|backupStream
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|closingUpload
operator|&&
name|partUpload
operator|&&
name|backupFile
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
comment|//skipping the upload if
comment|// - it is close time
comment|// - the final partition is 0 bytes long
comment|// - one part has already been written
name|SwiftUtils
operator|.
name|debug
argument_list|(
name|LOG
argument_list|,
literal|"skipping upload of 0 byte final partition"
argument_list|)
expr_stmt|;
name|delete
argument_list|(
name|backupFile
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|partUpload
operator|=
literal|true
expr_stmt|;
name|boolean
name|uploadSuccess
init|=
literal|false
decl_stmt|;
name|int
name|attempt
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|!
name|uploadSuccess
condition|)
block|{
try|try
block|{
operator|++
name|attempt
expr_stmt|;
name|bytesUploaded
operator|+=
name|uploadFilePartAttempt
argument_list|(
name|attempt
argument_list|)
expr_stmt|;
name|uploadSuccess
operator|=
literal|true
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Upload failed "
operator|+
name|e
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|attempt
operator|>
name|ATTEMPT_LIMIT
condition|)
block|{
throw|throw
name|e
throw|;
block|}
block|}
block|}
name|delete
argument_list|(
name|backupFile
argument_list|)
expr_stmt|;
name|partNumber
operator|++
expr_stmt|;
name|blockOffset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|closingUpload
condition|)
block|{
comment|//if not the final upload, create a new output stream
name|backupFile
operator|=
name|newBackupFile
argument_list|()
expr_stmt|;
name|backupStream
operator|=
operator|new
name|BufferedOutputStream
argument_list|(
operator|new
name|FileOutputStream
argument_list|(
name|backupFile
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"IOResourceOpenedButNotSafelyClosed"
argument_list|)
DECL|method|uploadFilePartAttempt (int attempt)
specifier|private
name|long
name|uploadFilePartAttempt
parameter_list|(
name|int
name|attempt
parameter_list|)
throws|throws
name|IOException
block|{
name|long
name|uploadLen
init|=
name|backupFile
operator|.
name|length
argument_list|()
decl_stmt|;
name|SwiftUtils
operator|.
name|debug
argument_list|(
name|LOG
argument_list|,
literal|"Uploading part %d of file %s;"
operator|+
literal|" localfile=%s of length %d  - attempt %d"
argument_list|,
name|partNumber
argument_list|,
name|key
argument_list|,
name|backupFile
argument_list|,
name|uploadLen
argument_list|,
name|attempt
argument_list|)
expr_stmt|;
name|nativeStore
operator|.
name|uploadFilePart
argument_list|(
operator|new
name|Path
argument_list|(
name|key
argument_list|)
argument_list|,
name|partNumber
argument_list|,
operator|new
name|FileInputStream
argument_list|(
name|backupFile
argument_list|)
argument_list|,
name|uploadLen
argument_list|)
expr_stmt|;
return|return
name|uploadLen
return|;
block|}
comment|/**    * Get the file partition size    * @return the partition size    */
DECL|method|getFilePartSize ()
name|long
name|getFilePartSize
parameter_list|()
block|{
return|return
name|filePartSize
return|;
block|}
comment|/**    * Query the number of partitions written    * This is intended for testing    * @return the of partitions already written to the remote FS    */
DECL|method|getPartitionsWritten ()
specifier|synchronized
name|int
name|getPartitionsWritten
parameter_list|()
block|{
return|return
name|partNumber
operator|-
literal|1
return|;
block|}
comment|/**    * Get the number of bytes written to the output stream.    * This should always be less than or equal to bytesUploaded.    * @return the number of bytes written to this stream    */
DECL|method|getBytesWritten ()
name|long
name|getBytesWritten
parameter_list|()
block|{
return|return
name|bytesWritten
return|;
block|}
comment|/**    * Get the number of bytes uploaded to remote Swift cluster.    * bytesUploaded -bytesWritten = the number of bytes left to upload    * @return the number of bytes written to the remote endpoint    */
DECL|method|getBytesUploaded ()
name|long
name|getBytesUploaded
parameter_list|()
block|{
return|return
name|bytesUploaded
return|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"SwiftNativeOutputStream{"
operator|+
literal|", key='"
operator|+
name|key
operator|+
literal|'\''
operator|+
literal|", backupFile="
operator|+
name|backupFile
operator|+
literal|", closed="
operator|+
name|closed
operator|+
literal|", filePartSize="
operator|+
name|filePartSize
operator|+
literal|", partNumber="
operator|+
name|partNumber
operator|+
literal|", blockOffset="
operator|+
name|blockOffset
operator|+
literal|", partUpload="
operator|+
name|partUpload
operator|+
literal|", nativeStore="
operator|+
name|nativeStore
operator|+
literal|", bytesWritten="
operator|+
name|bytesWritten
operator|+
literal|", bytesUploaded="
operator|+
name|bytesUploaded
operator|+
literal|'}'
return|;
block|}
block|}
end_class

end_unit

