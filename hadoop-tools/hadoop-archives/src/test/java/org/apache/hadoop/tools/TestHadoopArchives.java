begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.tools
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|tools
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FilterInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|PrintStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URI
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|StringTokenizer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FSDataInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FSDataOutputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FsShell
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|HarFileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|LocalFileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|LocatedFileStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|RemoteIterator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|MiniDFSCluster
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|test
operator|.
name|GenericTestUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|JarFinder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|ToolRunner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|capacity
operator|.
name|CapacitySchedulerConfiguration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|After
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Assert
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|*
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
operator|.
name|getLogger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Before
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Test
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|event
operator|.
name|Level
import|;
end_import

begin_comment
comment|/**  * test {@link HadoopArchives}  */
end_comment

begin_class
DECL|class|TestHadoopArchives
specifier|public
class|class
name|TestHadoopArchives
block|{
DECL|field|HADOOP_ARCHIVES_JAR
specifier|public
specifier|static
specifier|final
name|String
name|HADOOP_ARCHIVES_JAR
init|=
name|JarFinder
operator|.
name|getJar
argument_list|(
name|HadoopArchives
operator|.
name|class
argument_list|)
decl_stmt|;
block|{
name|GenericTestUtils
operator|.
name|setLogLevel
argument_list|(
name|getLogger
argument_list|(
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|Groups
operator|.
name|class
argument_list|)
argument_list|,
name|Level
operator|.
name|ERROR
argument_list|)
expr_stmt|;
block|}
DECL|field|inputDir
specifier|private
specifier|static
specifier|final
name|String
name|inputDir
init|=
literal|"input"
decl_stmt|;
DECL|field|inputPath
specifier|private
name|Path
name|inputPath
decl_stmt|;
DECL|field|archivePath
specifier|private
name|Path
name|archivePath
decl_stmt|;
DECL|field|fileList
specifier|private
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|fileList
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|dfscluster
specifier|private
name|MiniDFSCluster
name|dfscluster
decl_stmt|;
DECL|field|conf
specifier|private
name|Configuration
name|conf
decl_stmt|;
DECL|field|fs
specifier|private
name|FileSystem
name|fs
decl_stmt|;
DECL|method|createFile (Path root, FileSystem fs, String... dirsAndFile )
specifier|private
specifier|static
name|String
name|createFile
parameter_list|(
name|Path
name|root
parameter_list|,
name|FileSystem
name|fs
parameter_list|,
name|String
modifier|...
name|dirsAndFile
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|fileBaseName
init|=
name|dirsAndFile
index|[
name|dirsAndFile
operator|.
name|length
operator|-
literal|1
index|]
decl_stmt|;
return|return
name|createFile
argument_list|(
name|root
argument_list|,
name|fs
argument_list|,
name|fileBaseName
operator|.
name|getBytes
argument_list|(
literal|"UTF-8"
argument_list|)
argument_list|,
name|dirsAndFile
argument_list|)
return|;
block|}
DECL|method|createFile (Path root, FileSystem fs, byte[] fileContent, String... dirsAndFile )
specifier|private
specifier|static
name|String
name|createFile
parameter_list|(
name|Path
name|root
parameter_list|,
name|FileSystem
name|fs
parameter_list|,
name|byte
index|[]
name|fileContent
parameter_list|,
name|String
modifier|...
name|dirsAndFile
parameter_list|)
throws|throws
name|IOException
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|segment
range|:
name|dirsAndFile
control|)
block|{
if|if
condition|(
name|sb
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|Path
operator|.
name|SEPARATOR
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
name|segment
argument_list|)
expr_stmt|;
block|}
specifier|final
name|Path
name|f
init|=
operator|new
name|Path
argument_list|(
name|root
argument_list|,
name|sb
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|FSDataOutputStream
name|out
init|=
name|fs
operator|.
name|create
argument_list|(
name|f
argument_list|)
decl_stmt|;
try|try
block|{
name|out
operator|.
name|write
argument_list|(
name|fileContent
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|out
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
annotation|@
name|Before
DECL|method|setUp ()
specifier|public
name|void
name|setUp
parameter_list|()
throws|throws
name|Exception
block|{
name|conf
operator|=
operator|new
name|Configuration
argument_list|()
expr_stmt|;
name|conf
operator|.
name|set
argument_list|(
name|CapacitySchedulerConfiguration
operator|.
name|PREFIX
operator|+
name|CapacitySchedulerConfiguration
operator|.
name|ROOT
operator|+
literal|"."
operator|+
name|CapacitySchedulerConfiguration
operator|.
name|QUEUES
argument_list|,
literal|"default"
argument_list|)
expr_stmt|;
name|conf
operator|.
name|set
argument_list|(
name|CapacitySchedulerConfiguration
operator|.
name|PREFIX
operator|+
name|CapacitySchedulerConfiguration
operator|.
name|ROOT
operator|+
literal|".default."
operator|+
name|CapacitySchedulerConfiguration
operator|.
name|CAPACITY
argument_list|,
literal|"100"
argument_list|)
expr_stmt|;
name|dfscluster
operator|=
operator|new
name|MiniDFSCluster
operator|.
name|Builder
argument_list|(
name|conf
argument_list|)
operator|.
name|checkExitOnShutdown
argument_list|(
literal|true
argument_list|)
operator|.
name|numDataNodes
argument_list|(
literal|3
argument_list|)
operator|.
name|format
argument_list|(
literal|true
argument_list|)
operator|.
name|racks
argument_list|(
literal|null
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
name|fs
operator|=
name|dfscluster
operator|.
name|getFileSystem
argument_list|()
expr_stmt|;
comment|// prepare archive path:
name|archivePath
operator|=
operator|new
name|Path
argument_list|(
name|fs
operator|.
name|getHomeDirectory
argument_list|()
argument_list|,
literal|"archive"
argument_list|)
expr_stmt|;
name|fs
operator|.
name|delete
argument_list|(
name|archivePath
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|// prepare input path:
name|inputPath
operator|=
operator|new
name|Path
argument_list|(
name|fs
operator|.
name|getHomeDirectory
argument_list|()
argument_list|,
name|inputDir
argument_list|)
expr_stmt|;
name|fs
operator|.
name|delete
argument_list|(
name|inputPath
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|fs
operator|.
name|mkdirs
argument_list|(
name|inputPath
argument_list|)
expr_stmt|;
comment|// create basic input files:
name|fileList
operator|.
name|add
argument_list|(
name|createFile
argument_list|(
name|inputPath
argument_list|,
name|fs
argument_list|,
literal|"a"
argument_list|)
argument_list|)
expr_stmt|;
name|fileList
operator|.
name|add
argument_list|(
name|createFile
argument_list|(
name|inputPath
argument_list|,
name|fs
argument_list|,
literal|"b"
argument_list|)
argument_list|)
expr_stmt|;
name|fileList
operator|.
name|add
argument_list|(
name|createFile
argument_list|(
name|inputPath
argument_list|,
name|fs
argument_list|,
literal|"c"
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|After
DECL|method|tearDown ()
specifier|public
name|void
name|tearDown
parameter_list|()
throws|throws
name|Exception
block|{
if|if
condition|(
name|dfscluster
operator|!=
literal|null
condition|)
block|{
name|dfscluster
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Test
DECL|method|testRelativePath ()
specifier|public
name|void
name|testRelativePath
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|Path
name|sub1
init|=
operator|new
name|Path
argument_list|(
name|inputPath
argument_list|,
literal|"dir1"
argument_list|)
decl_stmt|;
name|fs
operator|.
name|mkdirs
argument_list|(
name|sub1
argument_list|)
expr_stmt|;
name|createFile
argument_list|(
name|inputPath
argument_list|,
name|fs
argument_list|,
name|sub1
operator|.
name|getName
argument_list|()
argument_list|,
literal|"a"
argument_list|)
expr_stmt|;
specifier|final
name|FsShell
name|shell
init|=
operator|new
name|FsShell
argument_list|(
name|conf
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|originalPaths
init|=
name|lsr
argument_list|(
name|shell
argument_list|,
literal|"input"
argument_list|)
decl_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"originalPaths: "
operator|+
name|originalPaths
argument_list|)
expr_stmt|;
comment|// make the archive:
specifier|final
name|String
name|fullHarPathStr
init|=
name|makeArchive
argument_list|()
decl_stmt|;
comment|// compare results:
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|harPaths
init|=
name|lsr
argument_list|(
name|shell
argument_list|,
name|fullHarPathStr
argument_list|)
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|originalPaths
argument_list|,
name|harPaths
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testRelativePathWitRepl ()
specifier|public
name|void
name|testRelativePathWitRepl
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|Path
name|sub1
init|=
operator|new
name|Path
argument_list|(
name|inputPath
argument_list|,
literal|"dir1"
argument_list|)
decl_stmt|;
name|fs
operator|.
name|mkdirs
argument_list|(
name|sub1
argument_list|)
expr_stmt|;
name|createFile
argument_list|(
name|inputPath
argument_list|,
name|fs
argument_list|,
name|sub1
operator|.
name|getName
argument_list|()
argument_list|,
literal|"a"
argument_list|)
expr_stmt|;
specifier|final
name|FsShell
name|shell
init|=
operator|new
name|FsShell
argument_list|(
name|conf
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|originalPaths
init|=
name|lsr
argument_list|(
name|shell
argument_list|,
literal|"input"
argument_list|)
decl_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"originalPaths: "
operator|+
name|originalPaths
argument_list|)
expr_stmt|;
comment|// make the archive:
specifier|final
name|String
name|fullHarPathStr
init|=
name|makeArchiveWithRepl
argument_list|()
decl_stmt|;
comment|// compare results:
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|harPaths
init|=
name|lsr
argument_list|(
name|shell
argument_list|,
name|fullHarPathStr
argument_list|)
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|originalPaths
argument_list|,
name|harPaths
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testOutputPathValidity ()
specifier|public
name|void
name|testOutputPathValidity
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|String
name|inputPathStr
init|=
name|inputPath
operator|.
name|toUri
argument_list|()
operator|.
name|getPath
argument_list|()
decl_stmt|;
specifier|final
name|URI
name|uri
init|=
name|fs
operator|.
name|getUri
argument_list|()
decl_stmt|;
specifier|final
name|String
name|harName
init|=
literal|"foo.har"
decl_stmt|;
name|System
operator|.
name|setProperty
argument_list|(
name|HadoopArchives
operator|.
name|TEST_HADOOP_ARCHIVES_JAR_PATH
argument_list|,
name|HADOOP_ARCHIVES_JAR
argument_list|)
expr_stmt|;
specifier|final
name|HadoopArchives
name|har
init|=
operator|new
name|HadoopArchives
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|PrintStream
name|stderr
init|=
name|System
operator|.
name|err
decl_stmt|;
name|ByteArrayOutputStream
name|byteStream
init|=
operator|new
name|ByteArrayOutputStream
argument_list|()
decl_stmt|;
name|PrintStream
name|newErr
init|=
operator|new
name|PrintStream
argument_list|(
name|byteStream
argument_list|)
decl_stmt|;
name|System
operator|.
name|setErr
argument_list|(
name|newErr
argument_list|)
expr_stmt|;
comment|// fail if the archive path already exists
name|createFile
argument_list|(
name|archivePath
argument_list|,
name|fs
argument_list|,
name|harName
argument_list|)
expr_stmt|;
specifier|final
name|String
index|[]
name|args
init|=
block|{
literal|"-archiveName"
block|,
name|harName
block|,
literal|"-p"
block|,
name|inputPathStr
block|,
literal|"*"
block|,
name|archivePath
operator|.
name|toString
argument_list|()
block|}
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
operator|-
literal|1
argument_list|,
name|ToolRunner
operator|.
name|run
argument_list|(
name|har
argument_list|,
name|args
argument_list|)
argument_list|)
expr_stmt|;
name|String
name|output
init|=
name|byteStream
operator|.
name|toString
argument_list|()
decl_stmt|;
specifier|final
name|Path
name|outputPath
init|=
operator|new
name|Path
argument_list|(
name|archivePath
argument_list|,
name|harName
argument_list|)
decl_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
name|output
operator|.
name|indexOf
argument_list|(
literal|"Archive path: "
operator|+
name|outputPath
operator|.
name|toString
argument_list|()
operator|+
literal|" already exists"
argument_list|)
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
name|byteStream
operator|.
name|reset
argument_list|()
expr_stmt|;
comment|// fail if the destination directory is a file
name|createFile
argument_list|(
name|archivePath
argument_list|,
name|fs
argument_list|,
literal|"sub1"
argument_list|)
expr_stmt|;
specifier|final
name|Path
name|archivePath2
init|=
operator|new
name|Path
argument_list|(
name|archivePath
argument_list|,
literal|"sub1"
argument_list|)
decl_stmt|;
specifier|final
name|String
index|[]
name|args2
init|=
block|{
literal|"-archiveName"
block|,
name|harName
block|,
literal|"-p"
block|,
name|inputPathStr
block|,
literal|"*"
block|,
name|archivePath2
operator|.
name|toString
argument_list|()
block|}
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
operator|-
literal|1
argument_list|,
name|ToolRunner
operator|.
name|run
argument_list|(
name|har
argument_list|,
name|args2
argument_list|)
argument_list|)
expr_stmt|;
name|output
operator|=
name|byteStream
operator|.
name|toString
argument_list|()
expr_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
name|output
operator|.
name|indexOf
argument_list|(
literal|"Destination "
operator|+
name|archivePath2
operator|.
name|toString
argument_list|()
operator|+
literal|" should be a directory but is a file"
argument_list|)
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
name|System
operator|.
name|setErr
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testPathWithSpaces ()
specifier|public
name|void
name|testPathWithSpaces
parameter_list|()
throws|throws
name|Exception
block|{
comment|// create files/directories with spaces
name|createFile
argument_list|(
name|inputPath
argument_list|,
name|fs
argument_list|,
literal|"c c"
argument_list|)
expr_stmt|;
specifier|final
name|Path
name|sub1
init|=
operator|new
name|Path
argument_list|(
name|inputPath
argument_list|,
literal|"sub 1"
argument_list|)
decl_stmt|;
name|fs
operator|.
name|mkdirs
argument_list|(
name|sub1
argument_list|)
expr_stmt|;
name|createFile
argument_list|(
name|sub1
argument_list|,
name|fs
argument_list|,
literal|"file x y z"
argument_list|)
expr_stmt|;
name|createFile
argument_list|(
name|sub1
argument_list|,
name|fs
argument_list|,
literal|"file"
argument_list|)
expr_stmt|;
name|createFile
argument_list|(
name|sub1
argument_list|,
name|fs
argument_list|,
literal|"x"
argument_list|)
expr_stmt|;
name|createFile
argument_list|(
name|sub1
argument_list|,
name|fs
argument_list|,
literal|"y"
argument_list|)
expr_stmt|;
name|createFile
argument_list|(
name|sub1
argument_list|,
name|fs
argument_list|,
literal|"z"
argument_list|)
expr_stmt|;
specifier|final
name|Path
name|sub2
init|=
operator|new
name|Path
argument_list|(
name|inputPath
argument_list|,
literal|"sub 1 with suffix"
argument_list|)
decl_stmt|;
name|fs
operator|.
name|mkdirs
argument_list|(
name|sub2
argument_list|)
expr_stmt|;
name|createFile
argument_list|(
name|sub2
argument_list|,
name|fs
argument_list|,
literal|"z"
argument_list|)
expr_stmt|;
specifier|final
name|FsShell
name|shell
init|=
operator|new
name|FsShell
argument_list|(
name|conf
argument_list|)
decl_stmt|;
specifier|final
name|String
name|inputPathStr
init|=
name|inputPath
operator|.
name|toUri
argument_list|()
operator|.
name|getPath
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|originalPaths
init|=
name|lsr
argument_list|(
name|shell
argument_list|,
name|inputPathStr
argument_list|)
decl_stmt|;
comment|// make the archive:
specifier|final
name|String
name|fullHarPathStr
init|=
name|makeArchive
argument_list|()
decl_stmt|;
comment|// compare results
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|harPaths
init|=
name|lsr
argument_list|(
name|shell
argument_list|,
name|fullHarPathStr
argument_list|)
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|originalPaths
argument_list|,
name|harPaths
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testSingleFile ()
specifier|public
name|void
name|testSingleFile
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|Path
name|sub1
init|=
operator|new
name|Path
argument_list|(
name|inputPath
argument_list|,
literal|"dir1"
argument_list|)
decl_stmt|;
name|fs
operator|.
name|mkdirs
argument_list|(
name|sub1
argument_list|)
expr_stmt|;
name|String
name|singleFileName
init|=
literal|"a"
decl_stmt|;
name|createFile
argument_list|(
name|inputPath
argument_list|,
name|fs
argument_list|,
name|sub1
operator|.
name|getName
argument_list|()
argument_list|,
name|singleFileName
argument_list|)
expr_stmt|;
specifier|final
name|FsShell
name|shell
init|=
operator|new
name|FsShell
argument_list|(
name|conf
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|originalPaths
init|=
name|lsr
argument_list|(
name|shell
argument_list|,
name|sub1
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"originalPaths: "
operator|+
name|originalPaths
argument_list|)
expr_stmt|;
comment|// make the archive:
specifier|final
name|String
name|fullHarPathStr
init|=
name|makeArchive
argument_list|(
name|sub1
argument_list|,
name|singleFileName
argument_list|)
decl_stmt|;
comment|// compare results:
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|harPaths
init|=
name|lsr
argument_list|(
name|shell
argument_list|,
name|fullHarPathStr
argument_list|)
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|originalPaths
argument_list|,
name|harPaths
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testGlobFiles ()
specifier|public
name|void
name|testGlobFiles
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|Path
name|sub1
init|=
operator|new
name|Path
argument_list|(
name|inputPath
argument_list|,
literal|"dir1"
argument_list|)
decl_stmt|;
specifier|final
name|Path
name|sub2
init|=
operator|new
name|Path
argument_list|(
name|inputPath
argument_list|,
literal|"dir2"
argument_list|)
decl_stmt|;
name|fs
operator|.
name|mkdirs
argument_list|(
name|sub1
argument_list|)
expr_stmt|;
name|String
name|fileName
init|=
literal|"a"
decl_stmt|;
name|createFile
argument_list|(
name|inputPath
argument_list|,
name|fs
argument_list|,
name|sub1
operator|.
name|getName
argument_list|()
argument_list|,
name|fileName
argument_list|)
expr_stmt|;
name|createFile
argument_list|(
name|inputPath
argument_list|,
name|fs
argument_list|,
name|sub2
operator|.
name|getName
argument_list|()
argument_list|,
name|fileName
argument_list|)
expr_stmt|;
name|createFile
argument_list|(
name|inputPath
argument_list|,
name|fs
argument_list|,
name|sub1
operator|.
name|getName
argument_list|()
argument_list|,
literal|"b"
argument_list|)
expr_stmt|;
comment|// not part of result
specifier|final
name|String
name|glob
init|=
literal|"dir{1,2}/a"
decl_stmt|;
specifier|final
name|FsShell
name|shell
init|=
operator|new
name|FsShell
argument_list|(
name|conf
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|originalPaths
init|=
name|lsr
argument_list|(
name|shell
argument_list|,
name|inputPath
operator|.
name|toString
argument_list|()
argument_list|,
name|inputPath
operator|+
literal|"/"
operator|+
name|glob
argument_list|)
decl_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"originalPaths: "
operator|+
name|originalPaths
argument_list|)
expr_stmt|;
comment|// make the archive:
specifier|final
name|String
name|fullHarPathStr
init|=
name|makeArchive
argument_list|(
name|inputPath
argument_list|,
name|glob
argument_list|)
decl_stmt|;
comment|// compare results:
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|harPaths
init|=
name|lsr
argument_list|(
name|shell
argument_list|,
name|fullHarPathStr
argument_list|,
name|fullHarPathStr
operator|+
literal|"/"
operator|+
name|glob
argument_list|)
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|originalPaths
argument_list|,
name|harPaths
argument_list|)
expr_stmt|;
block|}
DECL|method|lsr (final FsShell shell, String rootDir)
specifier|private
specifier|static
name|List
argument_list|<
name|String
argument_list|>
name|lsr
parameter_list|(
specifier|final
name|FsShell
name|shell
parameter_list|,
name|String
name|rootDir
parameter_list|)
throws|throws
name|Exception
block|{
return|return
name|lsr
argument_list|(
name|shell
argument_list|,
name|rootDir
argument_list|,
literal|null
argument_list|)
return|;
block|}
DECL|method|lsr (final FsShell shell, String rootDir, String glob)
specifier|private
specifier|static
name|List
argument_list|<
name|String
argument_list|>
name|lsr
parameter_list|(
specifier|final
name|FsShell
name|shell
parameter_list|,
name|String
name|rootDir
parameter_list|,
name|String
name|glob
parameter_list|)
throws|throws
name|Exception
block|{
specifier|final
name|String
name|dir
init|=
name|glob
operator|==
literal|null
condition|?
name|rootDir
else|:
name|glob
decl_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"lsr root="
operator|+
name|rootDir
argument_list|)
expr_stmt|;
specifier|final
name|ByteArrayOutputStream
name|bytes
init|=
operator|new
name|ByteArrayOutputStream
argument_list|()
decl_stmt|;
specifier|final
name|PrintStream
name|out
init|=
operator|new
name|PrintStream
argument_list|(
name|bytes
argument_list|)
decl_stmt|;
specifier|final
name|PrintStream
name|oldOut
init|=
name|System
operator|.
name|out
decl_stmt|;
specifier|final
name|PrintStream
name|oldErr
init|=
name|System
operator|.
name|err
decl_stmt|;
name|System
operator|.
name|setOut
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|System
operator|.
name|setErr
argument_list|(
name|out
argument_list|)
expr_stmt|;
specifier|final
name|String
name|results
decl_stmt|;
try|try
block|{
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|shell
operator|.
name|run
argument_list|(
operator|new
name|String
index|[]
block|{
literal|"-lsr"
block|,
name|dir
block|}
argument_list|)
argument_list|)
expr_stmt|;
name|results
operator|=
name|bytes
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|IOUtils
operator|.
name|closeStream
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|System
operator|.
name|setOut
argument_list|(
name|oldOut
argument_list|)
expr_stmt|;
name|System
operator|.
name|setErr
argument_list|(
name|oldErr
argument_list|)
expr_stmt|;
block|}
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"lsr results:\n"
operator|+
name|results
argument_list|)
expr_stmt|;
name|String
name|dirname
init|=
name|rootDir
decl_stmt|;
if|if
condition|(
name|rootDir
operator|.
name|lastIndexOf
argument_list|(
name|Path
operator|.
name|SEPARATOR
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|dirname
operator|=
name|rootDir
operator|.
name|substring
argument_list|(
name|rootDir
operator|.
name|lastIndexOf
argument_list|(
name|Path
operator|.
name|SEPARATOR
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|paths
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|StringTokenizer
name|t
init|=
operator|new
name|StringTokenizer
argument_list|(
name|results
argument_list|,
literal|"\n"
argument_list|)
init|;
name|t
operator|.
name|hasMoreTokens
argument_list|()
condition|;
control|)
block|{
specifier|final
name|String
name|s
init|=
name|t
operator|.
name|nextToken
argument_list|()
decl_stmt|;
specifier|final
name|int
name|i
init|=
name|s
operator|.
name|indexOf
argument_list|(
name|dirname
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
block|{
name|paths
operator|.
name|add
argument_list|(
name|s
operator|.
name|substring
argument_list|(
name|i
operator|+
name|dirname
operator|.
name|length
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|Collections
operator|.
name|sort
argument_list|(
name|paths
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"lsr paths = "
operator|+
name|paths
operator|.
name|toString
argument_list|()
operator|.
name|replace
argument_list|(
literal|", "
argument_list|,
literal|",\n  "
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|paths
return|;
block|}
annotation|@
name|Test
DECL|method|testReadFileContent ()
specifier|public
name|void
name|testReadFileContent
parameter_list|()
throws|throws
name|Exception
block|{
name|fileList
operator|.
name|add
argument_list|(
name|createFile
argument_list|(
name|inputPath
argument_list|,
name|fs
argument_list|,
literal|"c c"
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|Path
name|sub1
init|=
operator|new
name|Path
argument_list|(
name|inputPath
argument_list|,
literal|"sub 1"
argument_list|)
decl_stmt|;
name|fs
operator|.
name|mkdirs
argument_list|(
name|sub1
argument_list|)
expr_stmt|;
name|fileList
operator|.
name|add
argument_list|(
name|createFile
argument_list|(
name|inputPath
argument_list|,
name|fs
argument_list|,
name|sub1
operator|.
name|getName
argument_list|()
argument_list|,
literal|"file x y z"
argument_list|)
argument_list|)
expr_stmt|;
name|fileList
operator|.
name|add
argument_list|(
name|createFile
argument_list|(
name|inputPath
argument_list|,
name|fs
argument_list|,
name|sub1
operator|.
name|getName
argument_list|()
argument_list|,
literal|"file"
argument_list|)
argument_list|)
expr_stmt|;
name|fileList
operator|.
name|add
argument_list|(
name|createFile
argument_list|(
name|inputPath
argument_list|,
name|fs
argument_list|,
name|sub1
operator|.
name|getName
argument_list|()
argument_list|,
literal|"x"
argument_list|)
argument_list|)
expr_stmt|;
name|fileList
operator|.
name|add
argument_list|(
name|createFile
argument_list|(
name|inputPath
argument_list|,
name|fs
argument_list|,
name|sub1
operator|.
name|getName
argument_list|()
argument_list|,
literal|"y"
argument_list|)
argument_list|)
expr_stmt|;
name|fileList
operator|.
name|add
argument_list|(
name|createFile
argument_list|(
name|inputPath
argument_list|,
name|fs
argument_list|,
name|sub1
operator|.
name|getName
argument_list|()
argument_list|,
literal|"z"
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|Path
name|sub2
init|=
operator|new
name|Path
argument_list|(
name|inputPath
argument_list|,
literal|"sub 1 with suffix"
argument_list|)
decl_stmt|;
name|fs
operator|.
name|mkdirs
argument_list|(
name|sub2
argument_list|)
expr_stmt|;
name|fileList
operator|.
name|add
argument_list|(
name|createFile
argument_list|(
name|inputPath
argument_list|,
name|fs
argument_list|,
name|sub2
operator|.
name|getName
argument_list|()
argument_list|,
literal|"z"
argument_list|)
argument_list|)
expr_stmt|;
comment|// Generate a big binary file content:
specifier|final
name|byte
index|[]
name|binContent
init|=
name|prepareBin
argument_list|()
decl_stmt|;
name|fileList
operator|.
name|add
argument_list|(
name|createFile
argument_list|(
name|inputPath
argument_list|,
name|fs
argument_list|,
name|binContent
argument_list|,
name|sub2
operator|.
name|getName
argument_list|()
argument_list|,
literal|"bin"
argument_list|)
argument_list|)
expr_stmt|;
name|fileList
operator|.
name|add
argument_list|(
name|createFile
argument_list|(
name|inputPath
argument_list|,
name|fs
argument_list|,
operator|new
name|byte
index|[
literal|0
index|]
argument_list|,
name|sub2
operator|.
name|getName
argument_list|()
argument_list|,
literal|"zero-length"
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|String
name|fullHarPathStr
init|=
name|makeArchive
argument_list|()
decl_stmt|;
comment|// Create fresh HarFs:
specifier|final
name|HarFileSystem
name|harFileSystem
init|=
operator|new
name|HarFileSystem
argument_list|(
name|fs
argument_list|)
decl_stmt|;
try|try
block|{
specifier|final
name|URI
name|harUri
init|=
operator|new
name|URI
argument_list|(
name|fullHarPathStr
argument_list|)
decl_stmt|;
name|harFileSystem
operator|.
name|initialize
argument_list|(
name|harUri
argument_list|,
name|fs
operator|.
name|getConf
argument_list|()
argument_list|)
expr_stmt|;
comment|// now read the file content and compare it against the expected:
name|int
name|readFileCount
init|=
literal|0
decl_stmt|;
for|for
control|(
specifier|final
name|String
name|pathStr0
range|:
name|fileList
control|)
block|{
specifier|final
name|Path
name|path
init|=
operator|new
name|Path
argument_list|(
name|fullHarPathStr
operator|+
name|Path
operator|.
name|SEPARATOR
operator|+
name|pathStr0
argument_list|)
decl_stmt|;
specifier|final
name|String
name|baseName
init|=
name|path
operator|.
name|getName
argument_list|()
decl_stmt|;
specifier|final
name|FileStatus
name|status
init|=
name|harFileSystem
operator|.
name|getFileStatus
argument_list|(
name|path
argument_list|)
decl_stmt|;
if|if
condition|(
name|status
operator|.
name|isFile
argument_list|()
condition|)
block|{
comment|// read the file:
specifier|final
name|byte
index|[]
name|actualContentSimple
init|=
name|readAllSimple
argument_list|(
name|harFileSystem
operator|.
name|open
argument_list|(
name|path
argument_list|)
argument_list|,
literal|true
argument_list|)
decl_stmt|;
specifier|final
name|byte
index|[]
name|actualContentBuffer
init|=
name|readAllWithBuffer
argument_list|(
name|harFileSystem
operator|.
name|open
argument_list|(
name|path
argument_list|)
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|assertArrayEquals
argument_list|(
name|actualContentSimple
argument_list|,
name|actualContentBuffer
argument_list|)
expr_stmt|;
specifier|final
name|byte
index|[]
name|actualContentFully
init|=
name|readAllWithReadFully
argument_list|(
name|actualContentSimple
operator|.
name|length
argument_list|,
name|harFileSystem
operator|.
name|open
argument_list|(
name|path
argument_list|)
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|assertArrayEquals
argument_list|(
name|actualContentSimple
argument_list|,
name|actualContentFully
argument_list|)
expr_stmt|;
specifier|final
name|byte
index|[]
name|actualContentSeek
init|=
name|readAllWithSeek
argument_list|(
name|actualContentSimple
operator|.
name|length
argument_list|,
name|harFileSystem
operator|.
name|open
argument_list|(
name|path
argument_list|)
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|assertArrayEquals
argument_list|(
name|actualContentSimple
argument_list|,
name|actualContentSeek
argument_list|)
expr_stmt|;
specifier|final
name|byte
index|[]
name|actualContentRead4
init|=
name|readAllWithRead4
argument_list|(
name|harFileSystem
operator|.
name|open
argument_list|(
name|path
argument_list|)
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|assertArrayEquals
argument_list|(
name|actualContentSimple
argument_list|,
name|actualContentRead4
argument_list|)
expr_stmt|;
specifier|final
name|byte
index|[]
name|actualContentSkip
init|=
name|readAllWithSkip
argument_list|(
name|actualContentSimple
operator|.
name|length
argument_list|,
name|harFileSystem
operator|.
name|open
argument_list|(
name|path
argument_list|)
argument_list|,
name|harFileSystem
operator|.
name|open
argument_list|(
name|path
argument_list|)
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|assertArrayEquals
argument_list|(
name|actualContentSimple
argument_list|,
name|actualContentSkip
argument_list|)
expr_stmt|;
if|if
condition|(
literal|"bin"
operator|.
name|equals
argument_list|(
name|baseName
argument_list|)
condition|)
block|{
name|assertArrayEquals
argument_list|(
name|binContent
argument_list|,
name|actualContentSimple
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|"zero-length"
operator|.
name|equals
argument_list|(
name|baseName
argument_list|)
condition|)
block|{
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|actualContentSimple
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|String
name|actual
init|=
operator|new
name|String
argument_list|(
name|actualContentSimple
argument_list|,
literal|"UTF-8"
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|baseName
argument_list|,
name|actual
argument_list|)
expr_stmt|;
block|}
name|readFileCount
operator|++
expr_stmt|;
block|}
block|}
name|assertEquals
argument_list|(
name|fileList
operator|.
name|size
argument_list|()
argument_list|,
name|readFileCount
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|harFileSystem
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|readAllSimple (FSDataInputStream fsdis, boolean close)
specifier|private
specifier|static
name|byte
index|[]
name|readAllSimple
parameter_list|(
name|FSDataInputStream
name|fsdis
parameter_list|,
name|boolean
name|close
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|ByteArrayOutputStream
name|baos
init|=
operator|new
name|ByteArrayOutputStream
argument_list|()
decl_stmt|;
try|try
block|{
name|int
name|b
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|b
operator|=
name|fsdis
operator|.
name|read
argument_list|()
expr_stmt|;
if|if
condition|(
name|b
operator|<
literal|0
condition|)
block|{
break|break;
block|}
else|else
block|{
name|baos
operator|.
name|write
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
block|}
name|baos
operator|.
name|close
argument_list|()
expr_stmt|;
return|return
name|baos
operator|.
name|toByteArray
argument_list|()
return|;
block|}
finally|finally
block|{
if|if
condition|(
name|close
condition|)
block|{
name|fsdis
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
block|}
DECL|method|readAllWithBuffer (FSDataInputStream fsdis, boolean close)
specifier|private
specifier|static
name|byte
index|[]
name|readAllWithBuffer
parameter_list|(
name|FSDataInputStream
name|fsdis
parameter_list|,
name|boolean
name|close
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
specifier|final
name|int
name|available
init|=
name|fsdis
operator|.
name|available
argument_list|()
decl_stmt|;
specifier|final
name|byte
index|[]
name|buffer
decl_stmt|;
specifier|final
name|ByteArrayOutputStream
name|baos
decl_stmt|;
if|if
condition|(
name|available
operator|<
literal|0
condition|)
block|{
name|buffer
operator|=
operator|new
name|byte
index|[
literal|1024
index|]
expr_stmt|;
name|baos
operator|=
operator|new
name|ByteArrayOutputStream
argument_list|(
name|buffer
operator|.
name|length
operator|*
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|buffer
operator|=
operator|new
name|byte
index|[
name|available
index|]
expr_stmt|;
name|baos
operator|=
operator|new
name|ByteArrayOutputStream
argument_list|(
name|available
argument_list|)
expr_stmt|;
block|}
name|int
name|readIntoBuffer
init|=
literal|0
decl_stmt|;
name|int
name|read
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|read
operator|=
name|fsdis
operator|.
name|read
argument_list|(
name|buffer
argument_list|,
name|readIntoBuffer
argument_list|,
name|buffer
operator|.
name|length
operator|-
name|readIntoBuffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
operator|<=
literal|0
condition|)
block|{
comment|// end of stream:
if|if
condition|(
name|readIntoBuffer
operator|>
literal|0
condition|)
block|{
name|baos
operator|.
name|write
argument_list|(
name|buffer
argument_list|,
literal|0
argument_list|,
name|readIntoBuffer
argument_list|)
expr_stmt|;
block|}
return|return
name|baos
operator|.
name|toByteArray
argument_list|()
return|;
block|}
else|else
block|{
name|readIntoBuffer
operator|+=
name|read
expr_stmt|;
if|if
condition|(
name|readIntoBuffer
operator|==
name|buffer
operator|.
name|length
condition|)
block|{
comment|// buffer is full, need to clean the buffer.
comment|// drop the buffered data to baos:
name|baos
operator|.
name|write
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
comment|// reset the counter to start reading to the buffer beginning:
name|readIntoBuffer
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|readIntoBuffer
operator|>
name|buffer
operator|.
name|length
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Read more than the buffer length: "
operator|+
name|readIntoBuffer
operator|+
literal|", buffer length = "
operator|+
name|buffer
operator|.
name|length
argument_list|)
throw|;
block|}
block|}
block|}
block|}
finally|finally
block|{
if|if
condition|(
name|close
condition|)
block|{
name|fsdis
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
block|}
DECL|method|readAllWithReadFully (int totalLength, FSDataInputStream fsdis, boolean close)
specifier|private
specifier|static
name|byte
index|[]
name|readAllWithReadFully
parameter_list|(
name|int
name|totalLength
parameter_list|,
name|FSDataInputStream
name|fsdis
parameter_list|,
name|boolean
name|close
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|ByteArrayOutputStream
name|baos
init|=
operator|new
name|ByteArrayOutputStream
argument_list|()
decl_stmt|;
comment|// Simulate reading of some data structures of known length:
specifier|final
name|byte
index|[]
name|buffer
init|=
operator|new
name|byte
index|[
literal|17
index|]
decl_stmt|;
specifier|final
name|int
name|times
init|=
name|totalLength
operator|/
name|buffer
operator|.
name|length
decl_stmt|;
specifier|final
name|int
name|remainder
init|=
name|totalLength
operator|%
name|buffer
operator|.
name|length
decl_stmt|;
comment|// it would be simpler to leave the position tracking to the
comment|// InputStream, but we need to check the methods #readFully(2)
comment|// and #readFully(4) that receive the position as a parameter:
name|int
name|position
init|=
literal|0
decl_stmt|;
try|try
block|{
comment|// read "data structures":
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|times
condition|;
name|i
operator|++
control|)
block|{
name|fsdis
operator|.
name|readFully
argument_list|(
name|position
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|position
operator|+=
name|buffer
operator|.
name|length
expr_stmt|;
name|baos
operator|.
name|write
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|remainder
operator|>
literal|0
condition|)
block|{
comment|// read the remainder:
name|fsdis
operator|.
name|readFully
argument_list|(
name|position
argument_list|,
name|buffer
argument_list|,
literal|0
argument_list|,
name|remainder
argument_list|)
expr_stmt|;
name|position
operator|+=
name|remainder
expr_stmt|;
name|baos
operator|.
name|write
argument_list|(
name|buffer
argument_list|,
literal|0
argument_list|,
name|remainder
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|fsdis
operator|.
name|readFully
argument_list|(
name|position
argument_list|,
name|buffer
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
comment|// okay
block|}
name|assertEquals
argument_list|(
name|totalLength
argument_list|,
name|position
argument_list|)
expr_stmt|;
specifier|final
name|byte
index|[]
name|result
init|=
name|baos
operator|.
name|toByteArray
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
name|totalLength
argument_list|,
name|result
operator|.
name|length
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
finally|finally
block|{
if|if
condition|(
name|close
condition|)
block|{
name|fsdis
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
block|}
DECL|method|readAllWithRead4 (FSDataInputStream fsdis, boolean close)
specifier|private
specifier|static
name|byte
index|[]
name|readAllWithRead4
parameter_list|(
name|FSDataInputStream
name|fsdis
parameter_list|,
name|boolean
name|close
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
specifier|final
name|ByteArrayOutputStream
name|baos
init|=
operator|new
name|ByteArrayOutputStream
argument_list|()
decl_stmt|;
specifier|final
name|byte
index|[]
name|buffer
init|=
operator|new
name|byte
index|[
literal|17
index|]
decl_stmt|;
name|int
name|totalRead
init|=
literal|0
decl_stmt|;
name|int
name|read
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|read
operator|=
name|fsdis
operator|.
name|read
argument_list|(
name|totalRead
argument_list|,
name|buffer
argument_list|,
literal|0
argument_list|,
name|buffer
operator|.
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
operator|>
literal|0
condition|)
block|{
name|totalRead
operator|+=
name|read
expr_stmt|;
name|baos
operator|.
name|write
argument_list|(
name|buffer
argument_list|,
literal|0
argument_list|,
name|read
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|read
operator|<
literal|0
condition|)
block|{
break|break;
comment|// EOF
block|}
else|else
block|{
comment|// read == 0:
comment|// zero result may be returned *only* in case if the 4th
comment|// parameter is 0. Since in our case this is 'buffer.length',
comment|// zero return value clearly indicates a bug:
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"FSDataInputStream#read(4) returned 0, while "
operator|+
literal|" the 4th method parameter is "
operator|+
name|buffer
operator|.
name|length
operator|+
literal|"."
argument_list|)
throw|;
block|}
block|}
specifier|final
name|byte
index|[]
name|result
init|=
name|baos
operator|.
name|toByteArray
argument_list|()
decl_stmt|;
return|return
name|result
return|;
block|}
finally|finally
block|{
if|if
condition|(
name|close
condition|)
block|{
name|fsdis
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
block|}
DECL|method|readAllWithSeek (final int totalLength, final FSDataInputStream fsdis, final boolean close)
specifier|private
specifier|static
name|byte
index|[]
name|readAllWithSeek
parameter_list|(
specifier|final
name|int
name|totalLength
parameter_list|,
specifier|final
name|FSDataInputStream
name|fsdis
parameter_list|,
specifier|final
name|boolean
name|close
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|byte
index|[]
name|result
init|=
operator|new
name|byte
index|[
name|totalLength
index|]
decl_stmt|;
name|long
name|pos
decl_stmt|;
try|try
block|{
comment|// read the data in the reverse order, from
comment|// the tail to the head by pieces of 'buffer' length:
specifier|final
name|byte
index|[]
name|buffer
init|=
operator|new
name|byte
index|[
literal|17
index|]
decl_stmt|;
specifier|final
name|int
name|times
init|=
name|totalLength
operator|/
name|buffer
operator|.
name|length
decl_stmt|;
name|int
name|read
decl_stmt|;
name|int
name|expectedRead
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|times
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|pos
operator|=
name|i
operator|*
name|buffer
operator|.
name|length
expr_stmt|;
name|fsdis
operator|.
name|seek
argument_list|(
name|pos
argument_list|)
expr_stmt|;
comment|// check that seek is successful:
name|assertEquals
argument_list|(
name|pos
argument_list|,
name|fsdis
operator|.
name|getPos
argument_list|()
argument_list|)
expr_stmt|;
name|read
operator|=
name|fsdis
operator|.
name|read
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
comment|// check we read right number of bytes:
if|if
condition|(
name|i
operator|==
name|times
condition|)
block|{
name|expectedRead
operator|=
name|totalLength
operator|%
name|buffer
operator|.
name|length
expr_stmt|;
comment|// remainder
if|if
condition|(
name|expectedRead
operator|==
literal|0
condition|)
block|{
comment|// zero remainder corresponds to the EOS, so
comment|// by the contract of DataInpitStream#read(byte[]) -1 should be
comment|// returned:
name|expectedRead
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|expectedRead
operator|=
name|buffer
operator|.
name|length
expr_stmt|;
block|}
name|assertEquals
argument_list|(
name|expectedRead
argument_list|,
name|read
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
operator|>
literal|0
condition|)
block|{
name|System
operator|.
name|arraycopy
argument_list|(
name|buffer
argument_list|,
literal|0
argument_list|,
name|result
argument_list|,
operator|(
name|int
operator|)
name|pos
argument_list|,
name|read
argument_list|)
expr_stmt|;
block|}
block|}
comment|// finally, check that #seek() to not existing position leads to IOE:
name|expectSeekIOE
argument_list|(
name|fsdis
argument_list|,
name|Long
operator|.
name|MAX_VALUE
argument_list|,
literal|"Seek to Long.MAX_VALUE should lead to IOE."
argument_list|)
expr_stmt|;
name|expectSeekIOE
argument_list|(
name|fsdis
argument_list|,
name|Long
operator|.
name|MIN_VALUE
argument_list|,
literal|"Seek to Long.MIN_VALUE should lead to IOE."
argument_list|)
expr_stmt|;
name|long
name|pp
init|=
operator|-
literal|1L
decl_stmt|;
name|expectSeekIOE
argument_list|(
name|fsdis
argument_list|,
name|pp
argument_list|,
literal|"Seek to "
operator|+
name|pp
operator|+
literal|" should lead to IOE."
argument_list|)
expr_stmt|;
comment|// NB: is is *possible* to #seek(length), but *impossible* to #seek(length + 1):
name|fsdis
operator|.
name|seek
argument_list|(
name|totalLength
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|totalLength
argument_list|,
name|fsdis
operator|.
name|getPos
argument_list|()
argument_list|)
expr_stmt|;
name|pp
operator|=
name|totalLength
operator|+
literal|1
expr_stmt|;
name|expectSeekIOE
argument_list|(
name|fsdis
argument_list|,
name|pp
argument_list|,
literal|"Seek to the length position + 1 ("
operator|+
name|pp
operator|+
literal|") should lead to IOE."
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
finally|finally
block|{
if|if
condition|(
name|close
condition|)
block|{
name|fsdis
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
block|}
DECL|method|expectSeekIOE (FSDataInputStream fsdis, long seekPos, String message)
specifier|private
specifier|static
name|void
name|expectSeekIOE
parameter_list|(
name|FSDataInputStream
name|fsdis
parameter_list|,
name|long
name|seekPos
parameter_list|,
name|String
name|message
parameter_list|)
block|{
try|try
block|{
name|fsdis
operator|.
name|seek
argument_list|(
name|seekPos
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|message
operator|+
literal|" (Position = "
operator|+
name|fsdis
operator|.
name|getPos
argument_list|()
operator|+
literal|")"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
comment|// okay
block|}
block|}
comment|/*    * Reads data by chunks from 2 input streams:    * reads chunk from stream 1, and skips this chunk in the stream 2;    * Then reads next chunk from stream 2, and skips this chunk in stream 1.     */
DECL|method|readAllWithSkip ( final int totalLength, final FSDataInputStream fsdis1, final FSDataInputStream fsdis2, final boolean close)
specifier|private
specifier|static
name|byte
index|[]
name|readAllWithSkip
parameter_list|(
specifier|final
name|int
name|totalLength
parameter_list|,
specifier|final
name|FSDataInputStream
name|fsdis1
parameter_list|,
specifier|final
name|FSDataInputStream
name|fsdis2
parameter_list|,
specifier|final
name|boolean
name|close
parameter_list|)
throws|throws
name|IOException
block|{
comment|// test negative skip arg:
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|fsdis1
operator|.
name|skip
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|// test zero skip arg:
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|fsdis1
operator|.
name|skip
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|ByteArrayOutputStream
name|baos
init|=
operator|new
name|ByteArrayOutputStream
argument_list|(
name|totalLength
argument_list|)
decl_stmt|;
try|try
block|{
comment|// read the data in the reverse order, from
comment|// the tail to the head by pieces of 'buffer' length:
specifier|final
name|byte
index|[]
name|buffer
init|=
operator|new
name|byte
index|[
literal|17
index|]
decl_stmt|;
specifier|final
name|int
name|times
init|=
name|totalLength
operator|/
name|buffer
operator|.
name|length
decl_stmt|;
specifier|final
name|int
name|remainder
init|=
name|totalLength
operator|%
name|buffer
operator|.
name|length
decl_stmt|;
name|long
name|skipped
decl_stmt|;
name|long
name|expectedPosition
decl_stmt|;
name|int
name|toGo
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<=
name|times
condition|;
name|i
operator|++
control|)
block|{
name|toGo
operator|=
operator|(
name|i
operator|<
name|times
operator|)
condition|?
name|buffer
operator|.
name|length
else|:
name|remainder
expr_stmt|;
if|if
condition|(
name|i
operator|%
literal|2
operator|==
literal|0
condition|)
block|{
name|fsdis1
operator|.
name|readFully
argument_list|(
name|buffer
argument_list|,
literal|0
argument_list|,
name|toGo
argument_list|)
expr_stmt|;
name|skipped
operator|=
name|skipUntilZero
argument_list|(
name|fsdis2
argument_list|,
name|toGo
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fsdis2
operator|.
name|readFully
argument_list|(
name|buffer
argument_list|,
literal|0
argument_list|,
name|toGo
argument_list|)
expr_stmt|;
name|skipped
operator|=
name|skipUntilZero
argument_list|(
name|fsdis1
argument_list|,
name|toGo
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|<
name|times
condition|)
block|{
name|assertEquals
argument_list|(
name|buffer
operator|.
name|length
argument_list|,
name|skipped
argument_list|)
expr_stmt|;
name|expectedPosition
operator|=
operator|(
name|i
operator|+
literal|1
operator|)
operator|*
name|buffer
operator|.
name|length
expr_stmt|;
block|}
else|else
block|{
comment|// remainder:
if|if
condition|(
name|remainder
operator|>
literal|0
condition|)
block|{
name|assertEquals
argument_list|(
name|remainder
argument_list|,
name|skipped
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|skipped
argument_list|)
expr_stmt|;
block|}
name|expectedPosition
operator|=
name|totalLength
expr_stmt|;
block|}
comment|// check if the 2 streams have equal and correct positions:
name|assertEquals
argument_list|(
name|expectedPosition
argument_list|,
name|fsdis1
operator|.
name|getPos
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|expectedPosition
argument_list|,
name|fsdis2
operator|.
name|getPos
argument_list|()
argument_list|)
expr_stmt|;
comment|// save the read data:
if|if
condition|(
name|toGo
operator|>
literal|0
condition|)
block|{
name|baos
operator|.
name|write
argument_list|(
name|buffer
argument_list|,
literal|0
argument_list|,
name|toGo
argument_list|)
expr_stmt|;
block|}
block|}
comment|// finally, check up if ended stream cannot skip:
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|fsdis1
operator|.
name|skip
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|fsdis1
operator|.
name|skip
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|fsdis1
operator|.
name|skip
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|fsdis1
operator|.
name|skip
argument_list|(
name|Long
operator|.
name|MAX_VALUE
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|baos
operator|.
name|toByteArray
argument_list|()
return|;
block|}
finally|finally
block|{
if|if
condition|(
name|close
condition|)
block|{
name|fsdis1
operator|.
name|close
argument_list|()
expr_stmt|;
name|fsdis2
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
block|}
DECL|method|skipUntilZero (final FilterInputStream fis, final long toSkip)
specifier|private
specifier|static
name|long
name|skipUntilZero
parameter_list|(
specifier|final
name|FilterInputStream
name|fis
parameter_list|,
specifier|final
name|long
name|toSkip
parameter_list|)
throws|throws
name|IOException
block|{
name|long
name|skipped
init|=
literal|0
decl_stmt|;
name|long
name|remainsToSkip
init|=
name|toSkip
decl_stmt|;
name|long
name|s
decl_stmt|;
while|while
condition|(
name|skipped
operator|<
name|toSkip
condition|)
block|{
name|s
operator|=
name|fis
operator|.
name|skip
argument_list|(
name|remainsToSkip
argument_list|)
expr_stmt|;
comment|// actually skippped
if|if
condition|(
name|s
operator|==
literal|0
condition|)
block|{
return|return
name|skipped
return|;
comment|// EOF or impossible to skip.
block|}
name|skipped
operator|+=
name|s
expr_stmt|;
name|remainsToSkip
operator|-=
name|s
expr_stmt|;
block|}
return|return
name|skipped
return|;
block|}
DECL|method|prepareBin ()
specifier|private
specifier|static
name|byte
index|[]
name|prepareBin
parameter_list|()
block|{
name|byte
index|[]
name|bb
init|=
operator|new
name|byte
index|[
literal|77777
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|bb
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
comment|// Generate unique values, as possible:
name|double
name|d
init|=
name|Math
operator|.
name|log
argument_list|(
name|i
operator|+
literal|2
argument_list|)
decl_stmt|;
name|long
name|bits
init|=
name|Double
operator|.
name|doubleToLongBits
argument_list|(
name|d
argument_list|)
decl_stmt|;
name|bb
index|[
name|i
index|]
operator|=
operator|(
name|byte
operator|)
name|bits
expr_stmt|;
block|}
return|return
name|bb
return|;
block|}
DECL|method|makeArchive ()
specifier|private
name|String
name|makeArchive
parameter_list|()
throws|throws
name|Exception
block|{
return|return
name|makeArchive
argument_list|(
name|inputPath
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/*    * Run the HadoopArchives tool to create an archive on the     * given file system.    */
DECL|method|makeArchive (Path parentPath, String relGlob)
specifier|private
name|String
name|makeArchive
parameter_list|(
name|Path
name|parentPath
parameter_list|,
name|String
name|relGlob
parameter_list|)
throws|throws
name|Exception
block|{
specifier|final
name|String
name|parentPathStr
init|=
name|parentPath
operator|.
name|toUri
argument_list|()
operator|.
name|getPath
argument_list|()
decl_stmt|;
specifier|final
name|String
name|relPathGlob
init|=
name|relGlob
operator|==
literal|null
condition|?
literal|"*"
else|:
name|relGlob
decl_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"parentPathStr = "
operator|+
name|parentPathStr
argument_list|)
expr_stmt|;
specifier|final
name|URI
name|uri
init|=
name|fs
operator|.
name|getUri
argument_list|()
decl_stmt|;
specifier|final
name|String
name|prefix
init|=
literal|"har://hdfs-"
operator|+
name|uri
operator|.
name|getHost
argument_list|()
operator|+
literal|":"
operator|+
name|uri
operator|.
name|getPort
argument_list|()
operator|+
name|archivePath
operator|.
name|toUri
argument_list|()
operator|.
name|getPath
argument_list|()
operator|+
name|Path
operator|.
name|SEPARATOR
decl_stmt|;
specifier|final
name|String
name|harName
init|=
literal|"foo.har"
decl_stmt|;
specifier|final
name|String
name|fullHarPathStr
init|=
name|prefix
operator|+
name|harName
decl_stmt|;
specifier|final
name|String
index|[]
name|args
init|=
block|{
literal|"-archiveName"
block|,
name|harName
block|,
literal|"-p"
block|,
name|parentPathStr
block|,
name|relPathGlob
block|,
name|archivePath
operator|.
name|toString
argument_list|()
block|}
decl_stmt|;
name|System
operator|.
name|setProperty
argument_list|(
name|HadoopArchives
operator|.
name|TEST_HADOOP_ARCHIVES_JAR_PATH
argument_list|,
name|HADOOP_ARCHIVES_JAR
argument_list|)
expr_stmt|;
specifier|final
name|HadoopArchives
name|har
init|=
operator|new
name|HadoopArchives
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|ToolRunner
operator|.
name|run
argument_list|(
name|har
argument_list|,
name|args
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|fullHarPathStr
return|;
block|}
comment|/*  * Run the HadoopArchives tool to create an archive on the  * given file system with a specified replication degree.  */
DECL|method|makeArchiveWithRepl ()
specifier|private
name|String
name|makeArchiveWithRepl
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|String
name|inputPathStr
init|=
name|inputPath
operator|.
name|toUri
argument_list|()
operator|.
name|getPath
argument_list|()
decl_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"inputPathStr = "
operator|+
name|inputPathStr
argument_list|)
expr_stmt|;
specifier|final
name|URI
name|uri
init|=
name|fs
operator|.
name|getUri
argument_list|()
decl_stmt|;
specifier|final
name|String
name|prefix
init|=
literal|"har://hdfs-"
operator|+
name|uri
operator|.
name|getHost
argument_list|()
operator|+
literal|":"
operator|+
name|uri
operator|.
name|getPort
argument_list|()
operator|+
name|archivePath
operator|.
name|toUri
argument_list|()
operator|.
name|getPath
argument_list|()
operator|+
name|Path
operator|.
name|SEPARATOR
decl_stmt|;
specifier|final
name|String
name|harName
init|=
literal|"foo.har"
decl_stmt|;
specifier|final
name|String
name|fullHarPathStr
init|=
name|prefix
operator|+
name|harName
decl_stmt|;
specifier|final
name|String
index|[]
name|args
init|=
block|{
literal|"-archiveName"
block|,
name|harName
block|,
literal|"-p"
block|,
name|inputPathStr
block|,
literal|"-r"
block|,
literal|"2"
block|,
literal|"*"
block|,
name|archivePath
operator|.
name|toString
argument_list|()
block|}
decl_stmt|;
name|System
operator|.
name|setProperty
argument_list|(
name|HadoopArchives
operator|.
name|TEST_HADOOP_ARCHIVES_JAR_PATH
argument_list|,
name|HADOOP_ARCHIVES_JAR
argument_list|)
expr_stmt|;
specifier|final
name|HadoopArchives
name|har
init|=
operator|new
name|HadoopArchives
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|ToolRunner
operator|.
name|run
argument_list|(
name|har
argument_list|,
name|args
argument_list|)
argument_list|)
expr_stmt|;
name|RemoteIterator
argument_list|<
name|LocatedFileStatus
argument_list|>
name|listFiles
init|=
name|fs
operator|.
name|listFiles
argument_list|(
operator|new
name|Path
argument_list|(
name|archivePath
operator|.
name|toString
argument_list|()
operator|+
literal|"/"
operator|+
name|harName
argument_list|)
argument_list|,
literal|false
argument_list|)
decl_stmt|;
while|while
condition|(
name|listFiles
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|LocatedFileStatus
name|next
init|=
name|listFiles
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|next
operator|.
name|getPath
argument_list|()
operator|.
name|toString
argument_list|()
operator|.
name|endsWith
argument_list|(
literal|"_SUCCESS"
argument_list|)
condition|)
block|{
name|assertEquals
argument_list|(
name|next
operator|.
name|getPath
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|,
literal|2
argument_list|,
name|next
operator|.
name|getReplication
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|fullHarPathStr
return|;
block|}
annotation|@
name|Test
comment|/*    * Tests copying from archive file system to a local file system    */
DECL|method|testCopyToLocal ()
specifier|public
name|void
name|testCopyToLocal
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|String
name|fullHarPathStr
init|=
name|makeArchive
argument_list|()
decl_stmt|;
comment|// make path to copy the file to:
specifier|final
name|String
name|tmpDir
init|=
name|System
operator|.
name|getProperty
argument_list|(
literal|"test.build.data"
argument_list|,
literal|"build/test/data"
argument_list|)
operator|+
literal|"/work-dir/har-fs-tmp"
decl_stmt|;
specifier|final
name|Path
name|tmpPath
init|=
operator|new
name|Path
argument_list|(
name|tmpDir
argument_list|)
decl_stmt|;
specifier|final
name|LocalFileSystem
name|localFs
init|=
name|FileSystem
operator|.
name|getLocal
argument_list|(
operator|new
name|Configuration
argument_list|()
argument_list|)
decl_stmt|;
name|localFs
operator|.
name|delete
argument_list|(
name|tmpPath
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|localFs
operator|.
name|mkdirs
argument_list|(
name|tmpPath
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|localFs
operator|.
name|exists
argument_list|(
name|tmpPath
argument_list|)
argument_list|)
expr_stmt|;
comment|// Create fresh HarFs:
specifier|final
name|HarFileSystem
name|harFileSystem
init|=
operator|new
name|HarFileSystem
argument_list|(
name|fs
argument_list|)
decl_stmt|;
try|try
block|{
specifier|final
name|URI
name|harUri
init|=
operator|new
name|URI
argument_list|(
name|fullHarPathStr
argument_list|)
decl_stmt|;
name|harFileSystem
operator|.
name|initialize
argument_list|(
name|harUri
argument_list|,
name|fs
operator|.
name|getConf
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|Path
name|sourcePath
init|=
operator|new
name|Path
argument_list|(
name|fullHarPathStr
operator|+
name|Path
operator|.
name|SEPARATOR
operator|+
literal|"a"
argument_list|)
decl_stmt|;
specifier|final
name|Path
name|targetPath
init|=
operator|new
name|Path
argument_list|(
name|tmpPath
argument_list|,
literal|"straus"
argument_list|)
decl_stmt|;
comment|// copy the Har file to a local file system:
name|harFileSystem
operator|.
name|copyToLocalFile
argument_list|(
literal|false
argument_list|,
name|sourcePath
argument_list|,
name|targetPath
argument_list|)
expr_stmt|;
name|FileStatus
name|straus
init|=
name|localFs
operator|.
name|getFileStatus
argument_list|(
name|targetPath
argument_list|)
decl_stmt|;
comment|// the file should contain just 1 character:
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|straus
operator|.
name|getLen
argument_list|()
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|harFileSystem
operator|.
name|close
argument_list|()
expr_stmt|;
name|localFs
operator|.
name|delete
argument_list|(
name|tmpPath
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

