begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.tools
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|tools
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataInput
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataOutput
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileNotFoundException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|UnsupportedEncodingException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URLEncoder
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Random
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|cli
operator|.
name|CommandLine
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|cli
operator|.
name|GnuParser
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|cli
operator|.
name|HelpFormatter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|cli
operator|.
name|Options
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|cli
operator|.
name|Parser
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FSDataInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FSDataOutputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|HarFileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|permission
operator|.
name|FsPermission
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|IntWritable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|LongWritable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|SequenceFile
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|Text
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|Writable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|FileInputFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|FileOutputFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|FileSplit
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|InputFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|InputSplit
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|JobClient
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|JobConf
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|Mapper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|OutputCollector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|RecordReader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|Reducer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|Reporter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|SequenceFileRecordReader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|lib
operator|.
name|NullOutputFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|Cluster
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|JobSubmissionFiles
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|MRJobConfig
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Tool
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|ToolRunner
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Charsets
import|;
end_import

begin_comment
comment|/**  * a archive creation utility.  * This class provides methods that can be used   * to create hadoop archives. For understanding of   * Hadoop archives look at {@link HarFileSystem}.  */
end_comment

begin_class
DECL|class|HadoopArchives
specifier|public
class|class
name|HadoopArchives
implements|implements
name|Tool
block|{
DECL|field|VERSION
specifier|public
specifier|static
specifier|final
name|int
name|VERSION
init|=
literal|3
decl_stmt|;
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|HadoopArchives
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|NAME
specifier|private
specifier|static
specifier|final
name|String
name|NAME
init|=
literal|"har"
decl_stmt|;
DECL|field|ARCHIVE_NAME
specifier|private
specifier|static
specifier|final
name|String
name|ARCHIVE_NAME
init|=
literal|"archiveName"
decl_stmt|;
DECL|field|REPLICATION
specifier|private
specifier|static
specifier|final
name|String
name|REPLICATION
init|=
literal|"r"
decl_stmt|;
DECL|field|PARENT_PATH
specifier|private
specifier|static
specifier|final
name|String
name|PARENT_PATH
init|=
literal|"p"
decl_stmt|;
DECL|field|HELP
specifier|private
specifier|static
specifier|final
name|String
name|HELP
init|=
literal|"help"
decl_stmt|;
DECL|field|SRC_LIST_LABEL
specifier|static
specifier|final
name|String
name|SRC_LIST_LABEL
init|=
name|NAME
operator|+
literal|".src.list"
decl_stmt|;
DECL|field|DST_DIR_LABEL
specifier|static
specifier|final
name|String
name|DST_DIR_LABEL
init|=
name|NAME
operator|+
literal|".dest.path"
decl_stmt|;
DECL|field|TMP_DIR_LABEL
specifier|static
specifier|final
name|String
name|TMP_DIR_LABEL
init|=
name|NAME
operator|+
literal|".tmp.dir"
decl_stmt|;
DECL|field|JOB_DIR_LABEL
specifier|static
specifier|final
name|String
name|JOB_DIR_LABEL
init|=
name|NAME
operator|+
literal|".job.dir"
decl_stmt|;
DECL|field|SRC_COUNT_LABEL
specifier|static
specifier|final
name|String
name|SRC_COUNT_LABEL
init|=
name|NAME
operator|+
literal|".src.count"
decl_stmt|;
DECL|field|TOTAL_SIZE_LABEL
specifier|static
specifier|final
name|String
name|TOTAL_SIZE_LABEL
init|=
name|NAME
operator|+
literal|".total.size"
decl_stmt|;
DECL|field|DST_HAR_LABEL
specifier|static
specifier|final
name|String
name|DST_HAR_LABEL
init|=
name|NAME
operator|+
literal|".archive.name"
decl_stmt|;
DECL|field|SRC_PARENT_LABEL
specifier|static
specifier|final
name|String
name|SRC_PARENT_LABEL
init|=
name|NAME
operator|+
literal|".parent.path"
decl_stmt|;
comment|/** the size of the blocks that will be created when archiving **/
DECL|field|HAR_BLOCKSIZE_LABEL
specifier|static
specifier|final
name|String
name|HAR_BLOCKSIZE_LABEL
init|=
name|NAME
operator|+
literal|".block.size"
decl_stmt|;
comment|/** the replication factor for the file in archiving. **/
DECL|field|HAR_REPLICATION_LABEL
specifier|static
specifier|final
name|String
name|HAR_REPLICATION_LABEL
init|=
name|NAME
operator|+
literal|".replication.factor"
decl_stmt|;
comment|/** the size of the part files that will be created when archiving **/
DECL|field|HAR_PARTSIZE_LABEL
specifier|static
specifier|final
name|String
name|HAR_PARTSIZE_LABEL
init|=
name|NAME
operator|+
literal|".partfile.size"
decl_stmt|;
comment|/** size of each part file size **/
DECL|field|partSize
name|long
name|partSize
init|=
literal|2
operator|*
literal|1024
operator|*
literal|1024
operator|*
literal|1024l
decl_stmt|;
comment|/** size of blocks in hadoop archives **/
DECL|field|blockSize
name|long
name|blockSize
init|=
literal|512
operator|*
literal|1024
operator|*
literal|1024l
decl_stmt|;
comment|/** the desired replication degree; default is 3 **/
DECL|field|repl
name|short
name|repl
init|=
literal|3
decl_stmt|;
DECL|field|usage
specifier|private
specifier|static
specifier|final
name|String
name|usage
init|=
literal|"archive"
operator|+
literal|"<-archiveName<NAME>.har><-p<parent path>> [-r<replication factor>]"
operator|+
literal|"<src>*<dest>"
operator|+
literal|"\n"
decl_stmt|;
DECL|field|conf
specifier|private
name|JobConf
name|conf
decl_stmt|;
DECL|method|setConf (Configuration conf)
specifier|public
name|void
name|setConf
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
if|if
condition|(
name|conf
operator|instanceof
name|JobConf
condition|)
block|{
name|this
operator|.
name|conf
operator|=
operator|(
name|JobConf
operator|)
name|conf
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|conf
operator|=
operator|new
name|JobConf
argument_list|(
name|conf
argument_list|,
name|HadoopArchives
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
comment|// This is for test purposes since MR2, different from Streaming
comment|// here it is not possible to add a JAR to the classpath the tool
comment|// will when running the mapreduce job.
name|String
name|testJar
init|=
name|System
operator|.
name|getProperty
argument_list|(
name|TEST_HADOOP_ARCHIVES_JAR_PATH
argument_list|,
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|testJar
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|conf
operator|.
name|setJar
argument_list|(
name|testJar
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|getConf ()
specifier|public
name|Configuration
name|getConf
parameter_list|()
block|{
return|return
name|this
operator|.
name|conf
return|;
block|}
DECL|method|HadoopArchives (Configuration conf)
specifier|public
name|HadoopArchives
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
name|setConf
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
comment|// check the src paths
DECL|method|checkPaths (Configuration conf, List<Path> paths)
specifier|private
specifier|static
name|void
name|checkPaths
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|List
argument_list|<
name|Path
argument_list|>
name|paths
parameter_list|)
throws|throws
name|IOException
block|{
for|for
control|(
name|Path
name|p
range|:
name|paths
control|)
block|{
name|FileSystem
name|fs
init|=
name|p
operator|.
name|getFileSystem
argument_list|(
name|conf
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|fs
operator|.
name|exists
argument_list|(
name|p
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|FileNotFoundException
argument_list|(
literal|"Source "
operator|+
name|p
operator|+
literal|" does not exist."
argument_list|)
throw|;
block|}
block|}
block|}
comment|/**    * this assumes that there are two types of files file/dir    * @param fs the input filesystem    * @param fdir the filestatusdir of the path      * @param out the list of paths output of recursive ls    * @throws IOException    */
DECL|method|recursivels (FileSystem fs, FileStatusDir fdir, List<FileStatusDir> out)
specifier|private
name|void
name|recursivels
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|FileStatusDir
name|fdir
parameter_list|,
name|List
argument_list|<
name|FileStatusDir
argument_list|>
name|out
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|fdir
operator|.
name|getFileStatus
argument_list|()
operator|.
name|isFile
argument_list|()
condition|)
block|{
name|out
operator|.
name|add
argument_list|(
name|fdir
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|out
operator|.
name|add
argument_list|(
name|fdir
argument_list|)
expr_stmt|;
name|FileStatus
index|[]
name|listStatus
init|=
name|fs
operator|.
name|listStatus
argument_list|(
name|fdir
operator|.
name|getFileStatus
argument_list|()
operator|.
name|getPath
argument_list|()
argument_list|)
decl_stmt|;
name|fdir
operator|.
name|setChildren
argument_list|(
name|listStatus
argument_list|)
expr_stmt|;
for|for
control|(
name|FileStatus
name|stat
range|:
name|listStatus
control|)
block|{
name|FileStatusDir
name|fstatDir
init|=
operator|new
name|FileStatusDir
argument_list|(
name|stat
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|recursivels
argument_list|(
name|fs
argument_list|,
name|fstatDir
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/** HarEntry is used in the {@link HArchivesMapper} as the input value. */
DECL|class|HarEntry
specifier|private
specifier|static
class|class
name|HarEntry
implements|implements
name|Writable
block|{
DECL|field|path
name|String
name|path
decl_stmt|;
DECL|field|children
name|String
index|[]
name|children
decl_stmt|;
DECL|method|HarEntry ()
name|HarEntry
parameter_list|()
block|{}
DECL|method|HarEntry (String path, String[] children)
name|HarEntry
parameter_list|(
name|String
name|path
parameter_list|,
name|String
index|[]
name|children
parameter_list|)
block|{
name|this
operator|.
name|path
operator|=
name|path
expr_stmt|;
name|this
operator|.
name|children
operator|=
name|children
expr_stmt|;
block|}
DECL|method|isDir ()
name|boolean
name|isDir
parameter_list|()
block|{
return|return
name|children
operator|!=
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|readFields (DataInput in)
specifier|public
name|void
name|readFields
parameter_list|(
name|DataInput
name|in
parameter_list|)
throws|throws
name|IOException
block|{
name|path
operator|=
name|Text
operator|.
name|readString
argument_list|(
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|in
operator|.
name|readBoolean
argument_list|()
condition|)
block|{
name|children
operator|=
operator|new
name|String
index|[
name|in
operator|.
name|readInt
argument_list|()
index|]
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|children
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|children
index|[
name|i
index|]
operator|=
name|Text
operator|.
name|readString
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|children
operator|=
literal|null
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|write (DataOutput out)
specifier|public
name|void
name|write
parameter_list|(
name|DataOutput
name|out
parameter_list|)
throws|throws
name|IOException
block|{
name|Text
operator|.
name|writeString
argument_list|(
name|out
argument_list|,
name|path
argument_list|)
expr_stmt|;
specifier|final
name|boolean
name|dir
init|=
name|isDir
argument_list|()
decl_stmt|;
name|out
operator|.
name|writeBoolean
argument_list|(
name|dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|dir
condition|)
block|{
name|out
operator|.
name|writeInt
argument_list|(
name|children
operator|.
name|length
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|c
range|:
name|children
control|)
block|{
name|Text
operator|.
name|writeString
argument_list|(
name|out
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**    * Input format of a hadoop archive job responsible for     * generating splits of the file list    */
DECL|class|HArchiveInputFormat
specifier|static
class|class
name|HArchiveInputFormat
implements|implements
name|InputFormat
argument_list|<
name|LongWritable
argument_list|,
name|HarEntry
argument_list|>
block|{
comment|//generate input splits from the src file lists
DECL|method|getSplits (JobConf jconf, int numSplits)
specifier|public
name|InputSplit
index|[]
name|getSplits
parameter_list|(
name|JobConf
name|jconf
parameter_list|,
name|int
name|numSplits
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|srcfilelist
init|=
name|jconf
operator|.
name|get
argument_list|(
name|SRC_LIST_LABEL
argument_list|,
literal|""
argument_list|)
decl_stmt|;
if|if
condition|(
literal|""
operator|.
name|equals
argument_list|(
name|srcfilelist
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unable to get the "
operator|+
literal|"src file for archive generation."
argument_list|)
throw|;
block|}
name|long
name|totalSize
init|=
name|jconf
operator|.
name|getLong
argument_list|(
name|TOTAL_SIZE_LABEL
argument_list|,
operator|-
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|totalSize
operator|==
operator|-
literal|1
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Invalid size of files to archive"
argument_list|)
throw|;
block|}
comment|//we should be safe since this is set by our own code
name|Path
name|src
init|=
operator|new
name|Path
argument_list|(
name|srcfilelist
argument_list|)
decl_stmt|;
name|FileSystem
name|fs
init|=
name|src
operator|.
name|getFileSystem
argument_list|(
name|jconf
argument_list|)
decl_stmt|;
name|FileStatus
name|fstatus
init|=
name|fs
operator|.
name|getFileStatus
argument_list|(
name|src
argument_list|)
decl_stmt|;
name|ArrayList
argument_list|<
name|FileSplit
argument_list|>
name|splits
init|=
operator|new
name|ArrayList
argument_list|<
name|FileSplit
argument_list|>
argument_list|(
name|numSplits
argument_list|)
decl_stmt|;
name|LongWritable
name|key
init|=
operator|new
name|LongWritable
argument_list|()
decl_stmt|;
specifier|final
name|HarEntry
name|value
init|=
operator|new
name|HarEntry
argument_list|()
decl_stmt|;
comment|// the remaining bytes in the file split
name|long
name|remaining
init|=
name|fstatus
operator|.
name|getLen
argument_list|()
decl_stmt|;
comment|// the count of sizes calculated till now
name|long
name|currentCount
init|=
literal|0L
decl_stmt|;
comment|// the endposition of the split
name|long
name|lastPos
init|=
literal|0L
decl_stmt|;
comment|// the start position of the split
name|long
name|startPos
init|=
literal|0L
decl_stmt|;
name|long
name|targetSize
init|=
name|totalSize
operator|/
name|numSplits
decl_stmt|;
comment|// create splits of size target size so that all the maps
comment|// have equals sized data to read and write to.
try|try
init|(
name|SequenceFile
operator|.
name|Reader
name|reader
init|=
operator|new
name|SequenceFile
operator|.
name|Reader
argument_list|(
name|fs
argument_list|,
name|src
argument_list|,
name|jconf
argument_list|)
init|)
block|{
while|while
condition|(
name|reader
operator|.
name|next
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
condition|)
block|{
if|if
condition|(
name|currentCount
operator|+
name|key
operator|.
name|get
argument_list|()
operator|>
name|targetSize
operator|&&
name|currentCount
operator|!=
literal|0
condition|)
block|{
name|long
name|size
init|=
name|lastPos
operator|-
name|startPos
decl_stmt|;
name|splits
operator|.
name|add
argument_list|(
operator|new
name|FileSplit
argument_list|(
name|src
argument_list|,
name|startPos
argument_list|,
name|size
argument_list|,
operator|(
name|String
index|[]
operator|)
literal|null
argument_list|)
argument_list|)
expr_stmt|;
name|remaining
operator|=
name|remaining
operator|-
name|size
expr_stmt|;
name|startPos
operator|=
name|lastPos
expr_stmt|;
name|currentCount
operator|=
literal|0L
expr_stmt|;
block|}
name|currentCount
operator|+=
name|key
operator|.
name|get
argument_list|()
expr_stmt|;
name|lastPos
operator|=
name|reader
operator|.
name|getPosition
argument_list|()
expr_stmt|;
block|}
comment|// the remaining not equal to the target size.
if|if
condition|(
name|remaining
operator|!=
literal|0
condition|)
block|{
name|splits
operator|.
name|add
argument_list|(
operator|new
name|FileSplit
argument_list|(
name|src
argument_list|,
name|startPos
argument_list|,
name|remaining
argument_list|,
operator|(
name|String
index|[]
operator|)
literal|null
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|splits
operator|.
name|toArray
argument_list|(
operator|new
name|FileSplit
index|[
name|splits
operator|.
name|size
argument_list|()
index|]
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|getRecordReader (InputSplit split, JobConf job, Reporter reporter)
specifier|public
name|RecordReader
argument_list|<
name|LongWritable
argument_list|,
name|HarEntry
argument_list|>
name|getRecordReader
parameter_list|(
name|InputSplit
name|split
parameter_list|,
name|JobConf
name|job
parameter_list|,
name|Reporter
name|reporter
parameter_list|)
throws|throws
name|IOException
block|{
return|return
operator|new
name|SequenceFileRecordReader
argument_list|<
name|LongWritable
argument_list|,
name|HarEntry
argument_list|>
argument_list|(
name|job
argument_list|,
operator|(
name|FileSplit
operator|)
name|split
argument_list|)
return|;
block|}
block|}
DECL|method|checkValidName (String name)
specifier|private
name|boolean
name|checkValidName
parameter_list|(
name|String
name|name
parameter_list|)
block|{
name|Path
name|tmp
init|=
operator|new
name|Path
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|tmp
operator|.
name|depth
argument_list|()
operator|!=
literal|1
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|name
operator|.
name|endsWith
argument_list|(
literal|".har"
argument_list|)
condition|)
return|return
literal|true
return|;
return|return
literal|false
return|;
block|}
DECL|method|largestDepth (List<Path> paths)
specifier|private
name|Path
name|largestDepth
parameter_list|(
name|List
argument_list|<
name|Path
argument_list|>
name|paths
parameter_list|)
block|{
name|Path
name|deepest
init|=
name|paths
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
for|for
control|(
name|Path
name|p
range|:
name|paths
control|)
block|{
if|if
condition|(
name|p
operator|.
name|depth
argument_list|()
operator|>
name|deepest
operator|.
name|depth
argument_list|()
condition|)
block|{
name|deepest
operator|=
name|p
expr_stmt|;
block|}
block|}
return|return
name|deepest
return|;
block|}
comment|/**    * truncate the prefix root from the full path    * @param fullPath the full path    * @param root the prefix root to be truncated    * @return the relative path    */
DECL|method|relPathToRoot (Path fullPath, Path root)
specifier|private
name|Path
name|relPathToRoot
parameter_list|(
name|Path
name|fullPath
parameter_list|,
name|Path
name|root
parameter_list|)
block|{
comment|// just take some effort to do it
comment|// rather than just using substring
comment|// so that we do not break sometime later
specifier|final
name|Path
name|justRoot
init|=
operator|new
name|Path
argument_list|(
name|Path
operator|.
name|SEPARATOR
argument_list|)
decl_stmt|;
if|if
condition|(
name|fullPath
operator|.
name|depth
argument_list|()
operator|==
name|root
operator|.
name|depth
argument_list|()
condition|)
block|{
return|return
name|justRoot
return|;
block|}
elseif|else
if|if
condition|(
name|fullPath
operator|.
name|depth
argument_list|()
operator|>
name|root
operator|.
name|depth
argument_list|()
condition|)
block|{
name|Path
name|retPath
init|=
operator|new
name|Path
argument_list|(
name|fullPath
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
name|Path
name|parent
init|=
name|fullPath
operator|.
name|getParent
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
operator|(
name|fullPath
operator|.
name|depth
argument_list|()
operator|-
name|root
operator|.
name|depth
argument_list|()
operator|-
literal|1
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|retPath
operator|=
operator|new
name|Path
argument_list|(
name|parent
operator|.
name|getName
argument_list|()
argument_list|,
name|retPath
argument_list|)
expr_stmt|;
name|parent
operator|=
name|parent
operator|.
name|getParent
argument_list|()
expr_stmt|;
block|}
return|return
operator|new
name|Path
argument_list|(
name|justRoot
argument_list|,
name|retPath
argument_list|)
return|;
block|}
return|return
literal|null
return|;
block|}
comment|/**    * this method writes all the valid top level directories     * into the srcWriter for indexing. This method is a little    * tricky. example-     * for an input with parent path /home/user/ and sources     * as /home/user/source/dir1, /home/user/source/dir2 - this     * will output<source, dir, dir1, dir2> (dir means that source is a dir    * with dir1 and dir2 as children) and<source/dir1, file, null>    * and<source/dir2, file, null>    * @param srcWriter the sequence file writer to write the    * directories to    * @param paths the source paths provided by the user. They    * are glob free and have full path (not relative paths)    * @param parentPath the parent path that you want the archives    * to be relative to. example - /home/user/dir1 can be archived with    * parent as /home or /home/user.    * @throws IOException    */
DECL|method|writeTopLevelDirs (SequenceFile.Writer srcWriter, List<Path> paths, Path parentPath)
specifier|private
name|void
name|writeTopLevelDirs
parameter_list|(
name|SequenceFile
operator|.
name|Writer
name|srcWriter
parameter_list|,
name|List
argument_list|<
name|Path
argument_list|>
name|paths
parameter_list|,
name|Path
name|parentPath
parameter_list|)
throws|throws
name|IOException
block|{
comment|// extract paths from absolute URI's
name|List
argument_list|<
name|Path
argument_list|>
name|justPaths
init|=
operator|new
name|ArrayList
argument_list|<
name|Path
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Path
name|p
range|:
name|paths
control|)
block|{
name|justPaths
operator|.
name|add
argument_list|(
operator|new
name|Path
argument_list|(
name|p
operator|.
name|toUri
argument_list|()
operator|.
name|getPath
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* find all the common parents of paths that are valid archive      * paths. The below is done so that we do not add a common path      * twice and also we need to only add valid child of a path that      * are specified the user.      */
name|TreeMap
argument_list|<
name|String
argument_list|,
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|>
name|allpaths
init|=
operator|new
name|TreeMap
argument_list|<
name|String
argument_list|,
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
comment|/* the largest depth of paths. the max number of times      * we need to iterate      */
name|Path
name|deepest
init|=
name|largestDepth
argument_list|(
name|paths
argument_list|)
decl_stmt|;
name|Path
name|root
init|=
operator|new
name|Path
argument_list|(
name|Path
operator|.
name|SEPARATOR
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|parentPath
operator|.
name|depth
argument_list|()
init|;
name|i
operator|<
name|deepest
operator|.
name|depth
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|List
argument_list|<
name|Path
argument_list|>
name|parents
init|=
operator|new
name|ArrayList
argument_list|<
name|Path
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Path
name|p
range|:
name|justPaths
control|)
block|{
if|if
condition|(
name|p
operator|.
name|compareTo
argument_list|(
name|root
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|//do nothing
block|}
else|else
block|{
name|Path
name|parent
init|=
name|p
operator|.
name|getParent
argument_list|()
decl_stmt|;
if|if
condition|(
literal|null
operator|!=
name|parent
condition|)
block|{
if|if
condition|(
name|allpaths
operator|.
name|containsKey
argument_list|(
name|parent
operator|.
name|toString
argument_list|()
argument_list|)
condition|)
block|{
name|HashSet
argument_list|<
name|String
argument_list|>
name|children
init|=
name|allpaths
operator|.
name|get
argument_list|(
name|parent
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
name|children
operator|.
name|add
argument_list|(
name|p
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|HashSet
argument_list|<
name|String
argument_list|>
name|children
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|children
operator|.
name|add
argument_list|(
name|p
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|allpaths
operator|.
name|put
argument_list|(
name|parent
operator|.
name|toString
argument_list|()
argument_list|,
name|children
argument_list|)
expr_stmt|;
block|}
name|parents
operator|.
name|add
argument_list|(
name|parent
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|justPaths
operator|=
name|parents
expr_stmt|;
block|}
name|Set
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|>
argument_list|>
name|keyVals
init|=
name|allpaths
operator|.
name|entrySet
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|>
name|entry
range|:
name|keyVals
control|)
block|{
specifier|final
name|Path
name|relPath
init|=
name|relPathToRoot
argument_list|(
operator|new
name|Path
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
argument_list|,
name|parentPath
argument_list|)
decl_stmt|;
if|if
condition|(
name|relPath
operator|!=
literal|null
condition|)
block|{
specifier|final
name|String
index|[]
name|children
init|=
operator|new
name|String
index|[
name|entry
operator|.
name|getValue
argument_list|()
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|String
name|child
range|:
name|entry
operator|.
name|getValue
argument_list|()
control|)
block|{
name|children
index|[
name|i
operator|++
index|]
operator|=
name|child
expr_stmt|;
block|}
name|append
argument_list|(
name|srcWriter
argument_list|,
literal|0L
argument_list|,
name|relPath
operator|.
name|toString
argument_list|()
argument_list|,
name|children
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|append (SequenceFile.Writer srcWriter, long len, String path, String[] children)
specifier|private
name|void
name|append
parameter_list|(
name|SequenceFile
operator|.
name|Writer
name|srcWriter
parameter_list|,
name|long
name|len
parameter_list|,
name|String
name|path
parameter_list|,
name|String
index|[]
name|children
parameter_list|)
throws|throws
name|IOException
block|{
name|srcWriter
operator|.
name|append
argument_list|(
operator|new
name|LongWritable
argument_list|(
name|len
argument_list|)
argument_list|,
operator|new
name|HarEntry
argument_list|(
name|path
argument_list|,
name|children
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * A static class that keeps    * track of status of a path     * and there children if path is a dir    */
DECL|class|FileStatusDir
specifier|static
class|class
name|FileStatusDir
block|{
DECL|field|fstatus
specifier|private
name|FileStatus
name|fstatus
decl_stmt|;
DECL|field|children
specifier|private
name|FileStatus
index|[]
name|children
init|=
literal|null
decl_stmt|;
comment|/**      * constructor for filestatusdir      * @param fstatus the filestatus object that maps to filestatusdir      * @param children the children list if fs is a directory      */
DECL|method|FileStatusDir (FileStatus fstatus, FileStatus[] children)
name|FileStatusDir
parameter_list|(
name|FileStatus
name|fstatus
parameter_list|,
name|FileStatus
index|[]
name|children
parameter_list|)
block|{
name|this
operator|.
name|fstatus
operator|=
name|fstatus
expr_stmt|;
name|this
operator|.
name|children
operator|=
name|children
expr_stmt|;
block|}
comment|/**      * set children of this object      * @param listStatus the list of children      */
DECL|method|setChildren (FileStatus[] listStatus)
specifier|public
name|void
name|setChildren
parameter_list|(
name|FileStatus
index|[]
name|listStatus
parameter_list|)
block|{
name|this
operator|.
name|children
operator|=
name|listStatus
expr_stmt|;
block|}
comment|/**      * the filestatus of this object      * @return the filestatus of this object      */
DECL|method|getFileStatus ()
name|FileStatus
name|getFileStatus
parameter_list|()
block|{
return|return
name|this
operator|.
name|fstatus
return|;
block|}
comment|/**      * the children list of this object, null if        * @return the children list      */
DECL|method|getChildren ()
name|FileStatus
index|[]
name|getChildren
parameter_list|()
block|{
return|return
name|this
operator|.
name|children
return|;
block|}
block|}
comment|/**archive the given source paths into    * the dest    * @param parentPath the parent path of all the source paths    * @param srcPaths the src paths to be archived    * @param dest the dest dir that will contain the archive    */
DECL|method|archive (Path parentPath, List<Path> srcPaths, String archiveName, Path dest)
name|void
name|archive
parameter_list|(
name|Path
name|parentPath
parameter_list|,
name|List
argument_list|<
name|Path
argument_list|>
name|srcPaths
parameter_list|,
name|String
name|archiveName
parameter_list|,
name|Path
name|dest
parameter_list|)
throws|throws
name|IOException
block|{
name|checkPaths
argument_list|(
name|conf
argument_list|,
name|srcPaths
argument_list|)
expr_stmt|;
name|int
name|numFiles
init|=
literal|0
decl_stmt|;
name|long
name|totalSize
init|=
literal|0
decl_stmt|;
name|FileSystem
name|fs
init|=
name|parentPath
operator|.
name|getFileSystem
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|this
operator|.
name|blockSize
operator|=
name|conf
operator|.
name|getLong
argument_list|(
name|HAR_BLOCKSIZE_LABEL
argument_list|,
name|blockSize
argument_list|)
expr_stmt|;
name|this
operator|.
name|partSize
operator|=
name|conf
operator|.
name|getLong
argument_list|(
name|HAR_PARTSIZE_LABEL
argument_list|,
name|partSize
argument_list|)
expr_stmt|;
name|conf
operator|.
name|setLong
argument_list|(
name|HAR_BLOCKSIZE_LABEL
argument_list|,
name|blockSize
argument_list|)
expr_stmt|;
name|conf
operator|.
name|setLong
argument_list|(
name|HAR_PARTSIZE_LABEL
argument_list|,
name|partSize
argument_list|)
expr_stmt|;
name|conf
operator|.
name|set
argument_list|(
name|DST_HAR_LABEL
argument_list|,
name|archiveName
argument_list|)
expr_stmt|;
name|conf
operator|.
name|set
argument_list|(
name|SRC_PARENT_LABEL
argument_list|,
name|parentPath
operator|.
name|makeQualified
argument_list|(
name|fs
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|conf
operator|.
name|setInt
argument_list|(
name|HAR_REPLICATION_LABEL
argument_list|,
name|repl
argument_list|)
expr_stmt|;
name|Path
name|outputPath
init|=
operator|new
name|Path
argument_list|(
name|dest
argument_list|,
name|archiveName
argument_list|)
decl_stmt|;
name|FileOutputFormat
operator|.
name|setOutputPath
argument_list|(
name|conf
argument_list|,
name|outputPath
argument_list|)
expr_stmt|;
name|FileSystem
name|outFs
init|=
name|outputPath
operator|.
name|getFileSystem
argument_list|(
name|conf
argument_list|)
decl_stmt|;
if|if
condition|(
name|outFs
operator|.
name|exists
argument_list|(
name|outputPath
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Archive path: "
operator|+
name|outputPath
operator|.
name|toString
argument_list|()
operator|+
literal|" already exists"
argument_list|)
throw|;
block|}
if|if
condition|(
name|outFs
operator|.
name|isFile
argument_list|(
name|dest
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Destination "
operator|+
name|dest
operator|.
name|toString
argument_list|()
operator|+
literal|" should be a directory but is a file"
argument_list|)
throw|;
block|}
name|conf
operator|.
name|set
argument_list|(
name|DST_DIR_LABEL
argument_list|,
name|outputPath
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|Path
name|stagingArea
decl_stmt|;
try|try
block|{
name|stagingArea
operator|=
name|JobSubmissionFiles
operator|.
name|getStagingDir
argument_list|(
operator|new
name|Cluster
argument_list|(
name|conf
argument_list|)
argument_list|,
name|conf
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|ie
argument_list|)
throw|;
block|}
name|Path
name|jobDirectory
init|=
operator|new
name|Path
argument_list|(
name|stagingArea
argument_list|,
name|NAME
operator|+
literal|"_"
operator|+
name|Integer
operator|.
name|toString
argument_list|(
operator|new
name|Random
argument_list|()
operator|.
name|nextInt
argument_list|(
name|Integer
operator|.
name|MAX_VALUE
argument_list|)
argument_list|,
literal|36
argument_list|)
argument_list|)
decl_stmt|;
name|FsPermission
name|mapredSysPerms
init|=
operator|new
name|FsPermission
argument_list|(
name|JobSubmissionFiles
operator|.
name|JOB_DIR_PERMISSION
argument_list|)
decl_stmt|;
name|FileSystem
operator|.
name|mkdirs
argument_list|(
name|jobDirectory
operator|.
name|getFileSystem
argument_list|(
name|conf
argument_list|)
argument_list|,
name|jobDirectory
argument_list|,
name|mapredSysPerms
argument_list|)
expr_stmt|;
name|conf
operator|.
name|set
argument_list|(
name|JOB_DIR_LABEL
argument_list|,
name|jobDirectory
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
comment|//get a tmp directory for input splits
name|FileSystem
name|jobfs
init|=
name|jobDirectory
operator|.
name|getFileSystem
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|Path
name|srcFiles
init|=
operator|new
name|Path
argument_list|(
name|jobDirectory
argument_list|,
literal|"_har_src_files"
argument_list|)
decl_stmt|;
name|conf
operator|.
name|set
argument_list|(
name|SRC_LIST_LABEL
argument_list|,
name|srcFiles
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|SequenceFile
operator|.
name|Writer
name|srcWriter
init|=
name|SequenceFile
operator|.
name|createWriter
argument_list|(
name|jobfs
argument_list|,
name|conf
argument_list|,
name|srcFiles
argument_list|,
name|LongWritable
operator|.
name|class
argument_list|,
name|HarEntry
operator|.
name|class
argument_list|,
name|SequenceFile
operator|.
name|CompressionType
operator|.
name|NONE
argument_list|)
decl_stmt|;
comment|// get the list of files
comment|// create single list of files and dirs
try|try
block|{
comment|// write the top level dirs in first
name|writeTopLevelDirs
argument_list|(
name|srcWriter
argument_list|,
name|srcPaths
argument_list|,
name|parentPath
argument_list|)
expr_stmt|;
name|srcWriter
operator|.
name|sync
argument_list|()
expr_stmt|;
comment|// these are the input paths passed
comment|// from the command line
comment|// we do a recursive ls on these paths
comment|// and then write them to the input file
comment|// one at a time
for|for
control|(
name|Path
name|src
range|:
name|srcPaths
control|)
block|{
name|ArrayList
argument_list|<
name|FileStatusDir
argument_list|>
name|allFiles
init|=
operator|new
name|ArrayList
argument_list|<
name|FileStatusDir
argument_list|>
argument_list|()
decl_stmt|;
name|FileStatus
name|fstatus
init|=
name|fs
operator|.
name|getFileStatus
argument_list|(
name|src
argument_list|)
decl_stmt|;
name|FileStatusDir
name|fdir
init|=
operator|new
name|FileStatusDir
argument_list|(
name|fstatus
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|recursivels
argument_list|(
name|fs
argument_list|,
name|fdir
argument_list|,
name|allFiles
argument_list|)
expr_stmt|;
for|for
control|(
name|FileStatusDir
name|statDir
range|:
name|allFiles
control|)
block|{
name|FileStatus
name|stat
init|=
name|statDir
operator|.
name|getFileStatus
argument_list|()
decl_stmt|;
name|long
name|len
init|=
name|stat
operator|.
name|isDirectory
argument_list|()
condition|?
literal|0
else|:
name|stat
operator|.
name|getLen
argument_list|()
decl_stmt|;
specifier|final
name|Path
name|path
init|=
name|relPathToRoot
argument_list|(
name|stat
operator|.
name|getPath
argument_list|()
argument_list|,
name|parentPath
argument_list|)
decl_stmt|;
specifier|final
name|String
index|[]
name|children
decl_stmt|;
if|if
condition|(
name|stat
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
comment|//get the children
name|FileStatus
index|[]
name|list
init|=
name|statDir
operator|.
name|getChildren
argument_list|()
decl_stmt|;
name|children
operator|=
operator|new
name|String
index|[
name|list
operator|.
name|length
index|]
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|list
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|children
index|[
name|i
index|]
operator|=
name|list
index|[
name|i
index|]
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
name|children
operator|=
literal|null
expr_stmt|;
block|}
name|append
argument_list|(
name|srcWriter
argument_list|,
name|len
argument_list|,
name|path
operator|.
name|toString
argument_list|()
argument_list|,
name|children
argument_list|)
expr_stmt|;
name|srcWriter
operator|.
name|sync
argument_list|()
expr_stmt|;
name|numFiles
operator|++
expr_stmt|;
name|totalSize
operator|+=
name|len
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
name|srcWriter
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
name|conf
operator|.
name|setInt
argument_list|(
name|SRC_COUNT_LABEL
argument_list|,
name|numFiles
argument_list|)
expr_stmt|;
name|conf
operator|.
name|setLong
argument_list|(
name|TOTAL_SIZE_LABEL
argument_list|,
name|totalSize
argument_list|)
expr_stmt|;
name|int
name|numMaps
init|=
call|(
name|int
call|)
argument_list|(
name|totalSize
operator|/
name|partSize
argument_list|)
decl_stmt|;
comment|//run atleast one map.
name|conf
operator|.
name|setNumMapTasks
argument_list|(
name|numMaps
operator|==
literal|0
condition|?
literal|1
else|:
name|numMaps
argument_list|)
expr_stmt|;
name|conf
operator|.
name|setNumReduceTasks
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|conf
operator|.
name|setInputFormat
argument_list|(
name|HArchiveInputFormat
operator|.
name|class
argument_list|)
expr_stmt|;
name|conf
operator|.
name|setOutputFormat
argument_list|(
name|NullOutputFormat
operator|.
name|class
argument_list|)
expr_stmt|;
name|conf
operator|.
name|setMapperClass
argument_list|(
name|HArchivesMapper
operator|.
name|class
argument_list|)
expr_stmt|;
name|conf
operator|.
name|setReducerClass
argument_list|(
name|HArchivesReducer
operator|.
name|class
argument_list|)
expr_stmt|;
name|conf
operator|.
name|setMapOutputKeyClass
argument_list|(
name|IntWritable
operator|.
name|class
argument_list|)
expr_stmt|;
name|conf
operator|.
name|setMapOutputValueClass
argument_list|(
name|Text
operator|.
name|class
argument_list|)
expr_stmt|;
name|FileInputFormat
operator|.
name|addInputPath
argument_list|(
name|conf
argument_list|,
name|jobDirectory
argument_list|)
expr_stmt|;
comment|//make sure no speculative execution is done
name|conf
operator|.
name|setSpeculativeExecution
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|JobClient
operator|.
name|runJob
argument_list|(
name|conf
argument_list|)
expr_stmt|;
comment|//delete the tmp job directory
try|try
block|{
name|jobfs
operator|.
name|delete
argument_list|(
name|jobDirectory
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ie
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Unable to clean tmp directory "
operator|+
name|jobDirectory
argument_list|)
expr_stmt|;
block|}
block|}
DECL|class|HArchivesMapper
specifier|static
class|class
name|HArchivesMapper
implements|implements
name|Mapper
argument_list|<
name|LongWritable
argument_list|,
name|HarEntry
argument_list|,
name|IntWritable
argument_list|,
name|Text
argument_list|>
block|{
DECL|field|conf
specifier|private
name|JobConf
name|conf
init|=
literal|null
decl_stmt|;
DECL|field|partId
name|int
name|partId
init|=
operator|-
literal|1
decl_stmt|;
DECL|field|tmpOutputDir
name|Path
name|tmpOutputDir
init|=
literal|null
decl_stmt|;
DECL|field|tmpOutput
name|Path
name|tmpOutput
init|=
literal|null
decl_stmt|;
DECL|field|partname
name|String
name|partname
init|=
literal|null
decl_stmt|;
DECL|field|rootPath
name|Path
name|rootPath
init|=
literal|null
decl_stmt|;
DECL|field|partStream
name|FSDataOutputStream
name|partStream
init|=
literal|null
decl_stmt|;
DECL|field|destFs
name|FileSystem
name|destFs
init|=
literal|null
decl_stmt|;
DECL|field|buffer
name|byte
index|[]
name|buffer
decl_stmt|;
DECL|field|buf_size
name|int
name|buf_size
init|=
literal|128
operator|*
literal|1024
decl_stmt|;
DECL|field|replication
specifier|private
name|int
name|replication
init|=
literal|3
decl_stmt|;
DECL|field|blockSize
name|long
name|blockSize
init|=
literal|512
operator|*
literal|1024
operator|*
literal|1024l
decl_stmt|;
comment|// configure the mapper and create
comment|// the part file.
comment|// use map reduce framework to write into
comment|// tmp files.
DECL|method|configure (JobConf conf)
specifier|public
name|void
name|configure
parameter_list|(
name|JobConf
name|conf
parameter_list|)
block|{
name|this
operator|.
name|conf
operator|=
name|conf
expr_stmt|;
name|replication
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|HAR_REPLICATION_LABEL
argument_list|,
literal|3
argument_list|)
expr_stmt|;
comment|// this is tightly tied to map reduce
comment|// since it does not expose an api
comment|// to get the partition
name|partId
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|MRJobConfig
operator|.
name|TASK_PARTITION
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|// create a file name using the partition
comment|// we need to write to this directory
name|tmpOutputDir
operator|=
name|FileOutputFormat
operator|.
name|getWorkOutputPath
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|blockSize
operator|=
name|conf
operator|.
name|getLong
argument_list|(
name|HAR_BLOCKSIZE_LABEL
argument_list|,
name|blockSize
argument_list|)
expr_stmt|;
comment|// get the output path and write to the tmp
comment|// directory
name|partname
operator|=
literal|"part-"
operator|+
name|partId
expr_stmt|;
name|tmpOutput
operator|=
operator|new
name|Path
argument_list|(
name|tmpOutputDir
argument_list|,
name|partname
argument_list|)
expr_stmt|;
name|rootPath
operator|=
operator|(
name|conf
operator|.
name|get
argument_list|(
name|SRC_PARENT_LABEL
argument_list|,
literal|null
argument_list|)
operator|==
literal|null
operator|)
condition|?
literal|null
else|:
operator|new
name|Path
argument_list|(
name|conf
operator|.
name|get
argument_list|(
name|SRC_PARENT_LABEL
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rootPath
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Unable to read parent "
operator|+
literal|"path for har from config"
argument_list|)
throw|;
block|}
try|try
block|{
name|destFs
operator|=
name|tmpOutput
operator|.
name|getFileSystem
argument_list|(
name|conf
argument_list|)
expr_stmt|;
comment|//this was a stale copy
if|if
condition|(
name|destFs
operator|.
name|exists
argument_list|(
name|tmpOutput
argument_list|)
condition|)
block|{
name|destFs
operator|.
name|delete
argument_list|(
name|tmpOutput
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
name|partStream
operator|=
name|destFs
operator|.
name|create
argument_list|(
name|tmpOutput
argument_list|,
literal|false
argument_list|,
name|conf
operator|.
name|getInt
argument_list|(
literal|"io.file.buffer.size"
argument_list|,
literal|4096
argument_list|)
argument_list|,
name|destFs
operator|.
name|getDefaultReplication
argument_list|(
name|tmpOutput
argument_list|)
argument_list|,
name|blockSize
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ie
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Unable to open output file "
operator|+
name|tmpOutput
argument_list|,
name|ie
argument_list|)
throw|;
block|}
name|buffer
operator|=
operator|new
name|byte
index|[
name|buf_size
index|]
expr_stmt|;
block|}
comment|// copy raw data.
DECL|method|copyData (Path input, FSDataInputStream fsin, FSDataOutputStream fout, Reporter reporter)
specifier|public
name|void
name|copyData
parameter_list|(
name|Path
name|input
parameter_list|,
name|FSDataInputStream
name|fsin
parameter_list|,
name|FSDataOutputStream
name|fout
parameter_list|,
name|Reporter
name|reporter
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
for|for
control|(
name|int
name|cbread
init|=
literal|0
init|;
operator|(
name|cbread
operator|=
name|fsin
operator|.
name|read
argument_list|(
name|buffer
argument_list|)
operator|)
operator|>=
literal|0
condition|;
control|)
block|{
name|fout
operator|.
name|write
argument_list|(
name|buffer
argument_list|,
literal|0
argument_list|,
name|cbread
argument_list|)
expr_stmt|;
name|reporter
operator|.
name|progress
argument_list|()
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|fsin
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * get rid of / in the beginning of path      * @param p the path      * @return return path without /      */
DECL|method|realPath (Path p, Path parent)
specifier|private
name|Path
name|realPath
parameter_list|(
name|Path
name|p
parameter_list|,
name|Path
name|parent
parameter_list|)
block|{
name|Path
name|rootPath
init|=
operator|new
name|Path
argument_list|(
name|Path
operator|.
name|SEPARATOR
argument_list|)
decl_stmt|;
if|if
condition|(
name|rootPath
operator|.
name|compareTo
argument_list|(
name|p
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
name|parent
return|;
block|}
return|return
operator|new
name|Path
argument_list|(
name|parent
argument_list|,
operator|new
name|Path
argument_list|(
name|p
operator|.
name|toString
argument_list|()
operator|.
name|substring
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
DECL|method|encodeName (String s)
specifier|private
specifier|static
name|String
name|encodeName
parameter_list|(
name|String
name|s
parameter_list|)
throws|throws
name|UnsupportedEncodingException
block|{
return|return
name|URLEncoder
operator|.
name|encode
argument_list|(
name|s
argument_list|,
literal|"UTF-8"
argument_list|)
return|;
block|}
DECL|method|encodeProperties ( FileStatus fStatus )
specifier|private
specifier|static
name|String
name|encodeProperties
parameter_list|(
name|FileStatus
name|fStatus
parameter_list|)
throws|throws
name|UnsupportedEncodingException
block|{
name|String
name|propStr
init|=
name|encodeName
argument_list|(
name|fStatus
operator|.
name|getModificationTime
argument_list|()
operator|+
literal|" "
operator|+
name|fStatus
operator|.
name|getPermission
argument_list|()
operator|.
name|toShort
argument_list|()
operator|+
literal|" "
operator|+
name|encodeName
argument_list|(
name|fStatus
operator|.
name|getOwner
argument_list|()
argument_list|)
operator|+
literal|" "
operator|+
name|encodeName
argument_list|(
name|fStatus
operator|.
name|getGroup
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|propStr
return|;
block|}
comment|// read files from the split input
comment|// and write it onto the part files.
comment|// also output hash(name) and string
comment|// for reducer to create index
comment|// and masterindex files.
DECL|method|map (LongWritable key, HarEntry value, OutputCollector<IntWritable, Text> out, Reporter reporter)
specifier|public
name|void
name|map
parameter_list|(
name|LongWritable
name|key
parameter_list|,
name|HarEntry
name|value
parameter_list|,
name|OutputCollector
argument_list|<
name|IntWritable
argument_list|,
name|Text
argument_list|>
name|out
parameter_list|,
name|Reporter
name|reporter
parameter_list|)
throws|throws
name|IOException
block|{
name|Path
name|relPath
init|=
operator|new
name|Path
argument_list|(
name|value
operator|.
name|path
argument_list|)
decl_stmt|;
name|int
name|hash
init|=
name|HarFileSystem
operator|.
name|getHarHash
argument_list|(
name|relPath
argument_list|)
decl_stmt|;
name|String
name|towrite
init|=
literal|null
decl_stmt|;
name|Path
name|srcPath
init|=
name|realPath
argument_list|(
name|relPath
argument_list|,
name|rootPath
argument_list|)
decl_stmt|;
name|long
name|startPos
init|=
name|partStream
operator|.
name|getPos
argument_list|()
decl_stmt|;
name|FileSystem
name|srcFs
init|=
name|srcPath
operator|.
name|getFileSystem
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|FileStatus
name|srcStatus
init|=
name|srcFs
operator|.
name|getFileStatus
argument_list|(
name|srcPath
argument_list|)
decl_stmt|;
name|String
name|propStr
init|=
name|encodeProperties
argument_list|(
name|srcStatus
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|.
name|isDir
argument_list|()
condition|)
block|{
name|towrite
operator|=
name|encodeName
argument_list|(
name|relPath
operator|.
name|toString
argument_list|()
argument_list|)
operator|+
literal|" dir "
operator|+
name|propStr
operator|+
literal|" 0 0 "
expr_stmt|;
name|StringBuffer
name|sbuff
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
name|sbuff
operator|.
name|append
argument_list|(
name|towrite
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|child
range|:
name|value
operator|.
name|children
control|)
block|{
name|sbuff
operator|.
name|append
argument_list|(
name|encodeName
argument_list|(
name|child
argument_list|)
operator|+
literal|" "
argument_list|)
expr_stmt|;
block|}
name|towrite
operator|=
name|sbuff
operator|.
name|toString
argument_list|()
expr_stmt|;
comment|//reading directories is also progress
name|reporter
operator|.
name|progress
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|FSDataInputStream
name|input
init|=
name|srcFs
operator|.
name|open
argument_list|(
name|srcStatus
operator|.
name|getPath
argument_list|()
argument_list|)
decl_stmt|;
name|reporter
operator|.
name|setStatus
argument_list|(
literal|"Copying file "
operator|+
name|srcStatus
operator|.
name|getPath
argument_list|()
operator|+
literal|" to archive."
argument_list|)
expr_stmt|;
name|copyData
argument_list|(
name|srcStatus
operator|.
name|getPath
argument_list|()
argument_list|,
name|input
argument_list|,
name|partStream
argument_list|,
name|reporter
argument_list|)
expr_stmt|;
name|towrite
operator|=
name|encodeName
argument_list|(
name|relPath
operator|.
name|toString
argument_list|()
argument_list|)
operator|+
literal|" file "
operator|+
name|partname
operator|+
literal|" "
operator|+
name|startPos
operator|+
literal|" "
operator|+
name|srcStatus
operator|.
name|getLen
argument_list|()
operator|+
literal|" "
operator|+
name|propStr
operator|+
literal|" "
expr_stmt|;
block|}
name|out
operator|.
name|collect
argument_list|(
operator|new
name|IntWritable
argument_list|(
name|hash
argument_list|)
argument_list|,
operator|new
name|Text
argument_list|(
name|towrite
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|close ()
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
comment|// close the part files.
name|partStream
operator|.
name|close
argument_list|()
expr_stmt|;
name|destFs
operator|.
name|setReplication
argument_list|(
name|tmpOutput
argument_list|,
operator|(
name|short
operator|)
name|replication
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** the reduce for creating the index and the master index     *     */
DECL|class|HArchivesReducer
specifier|static
class|class
name|HArchivesReducer
implements|implements
name|Reducer
argument_list|<
name|IntWritable
argument_list|,
name|Text
argument_list|,
name|Text
argument_list|,
name|Text
argument_list|>
block|{
DECL|field|conf
specifier|private
name|JobConf
name|conf
init|=
literal|null
decl_stmt|;
DECL|field|startIndex
specifier|private
name|long
name|startIndex
init|=
literal|0
decl_stmt|;
DECL|field|endIndex
specifier|private
name|long
name|endIndex
init|=
literal|0
decl_stmt|;
DECL|field|startPos
specifier|private
name|long
name|startPos
init|=
literal|0
decl_stmt|;
DECL|field|masterIndex
specifier|private
name|Path
name|masterIndex
init|=
literal|null
decl_stmt|;
DECL|field|index
specifier|private
name|Path
name|index
init|=
literal|null
decl_stmt|;
DECL|field|fs
specifier|private
name|FileSystem
name|fs
init|=
literal|null
decl_stmt|;
DECL|field|outStream
specifier|private
name|FSDataOutputStream
name|outStream
init|=
literal|null
decl_stmt|;
DECL|field|indexStream
specifier|private
name|FSDataOutputStream
name|indexStream
init|=
literal|null
decl_stmt|;
DECL|field|numIndexes
specifier|private
name|int
name|numIndexes
init|=
literal|1000
decl_stmt|;
DECL|field|tmpOutputDir
specifier|private
name|Path
name|tmpOutputDir
init|=
literal|null
decl_stmt|;
DECL|field|written
specifier|private
name|int
name|written
init|=
literal|0
decl_stmt|;
DECL|field|replication
specifier|private
name|int
name|replication
init|=
literal|3
decl_stmt|;
DECL|field|keyVal
specifier|private
name|int
name|keyVal
init|=
literal|0
decl_stmt|;
comment|// configure
DECL|method|configure (JobConf conf)
specifier|public
name|void
name|configure
parameter_list|(
name|JobConf
name|conf
parameter_list|)
block|{
name|this
operator|.
name|conf
operator|=
name|conf
expr_stmt|;
name|tmpOutputDir
operator|=
name|FileOutputFormat
operator|.
name|getWorkOutputPath
argument_list|(
name|this
operator|.
name|conf
argument_list|)
expr_stmt|;
name|masterIndex
operator|=
operator|new
name|Path
argument_list|(
name|tmpOutputDir
argument_list|,
literal|"_masterindex"
argument_list|)
expr_stmt|;
name|index
operator|=
operator|new
name|Path
argument_list|(
name|tmpOutputDir
argument_list|,
literal|"_index"
argument_list|)
expr_stmt|;
name|replication
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|HAR_REPLICATION_LABEL
argument_list|,
literal|3
argument_list|)
expr_stmt|;
try|try
block|{
name|fs
operator|=
name|masterIndex
operator|.
name|getFileSystem
argument_list|(
name|conf
argument_list|)
expr_stmt|;
if|if
condition|(
name|fs
operator|.
name|exists
argument_list|(
name|masterIndex
argument_list|)
condition|)
block|{
name|fs
operator|.
name|delete
argument_list|(
name|masterIndex
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fs
operator|.
name|exists
argument_list|(
name|index
argument_list|)
condition|)
block|{
name|fs
operator|.
name|delete
argument_list|(
name|index
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
name|indexStream
operator|=
name|fs
operator|.
name|create
argument_list|(
name|index
argument_list|)
expr_stmt|;
name|outStream
operator|=
name|fs
operator|.
name|create
argument_list|(
name|masterIndex
argument_list|)
expr_stmt|;
name|String
name|version
init|=
name|VERSION
operator|+
literal|" \n"
decl_stmt|;
name|outStream
operator|.
name|write
argument_list|(
name|version
operator|.
name|getBytes
argument_list|(
name|Charsets
operator|.
name|UTF_8
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
comment|// create the index and master index. The input to
comment|// the reduce is already sorted by the hash of the
comment|// files. SO we just need to write it to the index.
comment|// We update the masterindex as soon as we update
comment|// numIndex entries.
DECL|method|reduce (IntWritable key, Iterator<Text> values, OutputCollector<Text, Text> out, Reporter reporter)
specifier|public
name|void
name|reduce
parameter_list|(
name|IntWritable
name|key
parameter_list|,
name|Iterator
argument_list|<
name|Text
argument_list|>
name|values
parameter_list|,
name|OutputCollector
argument_list|<
name|Text
argument_list|,
name|Text
argument_list|>
name|out
parameter_list|,
name|Reporter
name|reporter
parameter_list|)
throws|throws
name|IOException
block|{
name|keyVal
operator|=
name|key
operator|.
name|get
argument_list|()
expr_stmt|;
while|while
condition|(
name|values
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Text
name|value
init|=
name|values
operator|.
name|next
argument_list|()
decl_stmt|;
name|String
name|towrite
init|=
name|value
operator|.
name|toString
argument_list|()
operator|+
literal|"\n"
decl_stmt|;
name|indexStream
operator|.
name|write
argument_list|(
name|towrite
operator|.
name|getBytes
argument_list|(
name|Charsets
operator|.
name|UTF_8
argument_list|)
argument_list|)
expr_stmt|;
name|written
operator|++
expr_stmt|;
if|if
condition|(
name|written
operator|>
name|numIndexes
operator|-
literal|1
condition|)
block|{
comment|// every 1000 indexes we report status
name|reporter
operator|.
name|setStatus
argument_list|(
literal|"Creating index for archives"
argument_list|)
expr_stmt|;
name|reporter
operator|.
name|progress
argument_list|()
expr_stmt|;
name|endIndex
operator|=
name|keyVal
expr_stmt|;
name|String
name|masterWrite
init|=
name|startIndex
operator|+
literal|" "
operator|+
name|endIndex
operator|+
literal|" "
operator|+
name|startPos
operator|+
literal|" "
operator|+
name|indexStream
operator|.
name|getPos
argument_list|()
operator|+
literal|" \n"
decl_stmt|;
name|outStream
operator|.
name|write
argument_list|(
name|masterWrite
operator|.
name|getBytes
argument_list|(
name|Charsets
operator|.
name|UTF_8
argument_list|)
argument_list|)
expr_stmt|;
name|startPos
operator|=
name|indexStream
operator|.
name|getPos
argument_list|()
expr_stmt|;
name|startIndex
operator|=
name|endIndex
expr_stmt|;
name|written
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
DECL|method|close ()
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
comment|//write the last part of the master index.
if|if
condition|(
name|written
operator|>
literal|0
condition|)
block|{
name|String
name|masterWrite
init|=
name|startIndex
operator|+
literal|" "
operator|+
name|keyVal
operator|+
literal|" "
operator|+
name|startPos
operator|+
literal|" "
operator|+
name|indexStream
operator|.
name|getPos
argument_list|()
operator|+
literal|" \n"
decl_stmt|;
name|outStream
operator|.
name|write
argument_list|(
name|masterWrite
operator|.
name|getBytes
argument_list|(
name|Charsets
operator|.
name|UTF_8
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// close the streams
name|outStream
operator|.
name|close
argument_list|()
expr_stmt|;
name|indexStream
operator|.
name|close
argument_list|()
expr_stmt|;
comment|// try increasing the replication
name|fs
operator|.
name|setReplication
argument_list|(
name|index
argument_list|,
operator|(
name|short
operator|)
name|replication
argument_list|)
expr_stmt|;
name|fs
operator|.
name|setReplication
argument_list|(
name|masterIndex
argument_list|,
operator|(
name|short
operator|)
name|replication
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|printUsage (Options opts, boolean printDetailed)
specifier|private
name|void
name|printUsage
parameter_list|(
name|Options
name|opts
parameter_list|,
name|boolean
name|printDetailed
parameter_list|)
block|{
name|HelpFormatter
name|helpFormatter
init|=
operator|new
name|HelpFormatter
argument_list|()
decl_stmt|;
if|if
condition|(
name|printDetailed
condition|)
block|{
name|helpFormatter
operator|.
name|printHelp
argument_list|(
name|usage
operator|.
name|length
argument_list|()
operator|+
literal|10
argument_list|,
name|usage
argument_list|,
literal|null
argument_list|,
name|opts
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|usage
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** the main driver for creating the archives    *  it takes at least three command line parameters. The parent path,     *  The src and the dest. It does an lsr on the source paths.    *  The mapper created archuves and the reducer creates     *  the archive index.    */
DECL|method|run (String[] args)
specifier|public
name|int
name|run
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
throws|throws
name|Exception
block|{
try|try
block|{
comment|// Parse CLI options
name|Options
name|options
init|=
operator|new
name|Options
argument_list|()
decl_stmt|;
name|options
operator|.
name|addOption
argument_list|(
name|ARCHIVE_NAME
argument_list|,
literal|true
argument_list|,
literal|"Name of the Archive. This is mandatory option"
argument_list|)
expr_stmt|;
name|options
operator|.
name|addOption
argument_list|(
name|PARENT_PATH
argument_list|,
literal|true
argument_list|,
literal|"Parent path of sources. This is mandatory option"
argument_list|)
expr_stmt|;
name|options
operator|.
name|addOption
argument_list|(
name|REPLICATION
argument_list|,
literal|true
argument_list|,
literal|"Replication factor archive files"
argument_list|)
expr_stmt|;
name|options
operator|.
name|addOption
argument_list|(
name|HELP
argument_list|,
literal|false
argument_list|,
literal|"Show the usage"
argument_list|)
expr_stmt|;
name|Parser
name|parser
init|=
operator|new
name|GnuParser
argument_list|()
decl_stmt|;
name|CommandLine
name|commandLine
init|=
name|parser
operator|.
name|parse
argument_list|(
name|options
argument_list|,
name|args
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|commandLine
operator|.
name|hasOption
argument_list|(
name|HELP
argument_list|)
condition|)
block|{
name|printUsage
argument_list|(
name|options
argument_list|,
literal|true
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|commandLine
operator|.
name|hasOption
argument_list|(
name|ARCHIVE_NAME
argument_list|)
condition|)
block|{
name|printUsage
argument_list|(
name|options
argument_list|,
literal|false
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Archive Name not specified."
argument_list|)
throw|;
block|}
name|String
name|archiveName
init|=
name|commandLine
operator|.
name|getOptionValue
argument_list|(
name|ARCHIVE_NAME
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|checkValidName
argument_list|(
name|archiveName
argument_list|)
condition|)
block|{
name|printUsage
argument_list|(
name|options
argument_list|,
literal|false
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Invalid name for archives. "
operator|+
name|archiveName
argument_list|)
throw|;
block|}
comment|//check to see if relative parent has been provided or not
comment|//this is a required parameter.
if|if
condition|(
operator|!
name|commandLine
operator|.
name|hasOption
argument_list|(
name|PARENT_PATH
argument_list|)
condition|)
block|{
name|printUsage
argument_list|(
name|options
argument_list|,
literal|false
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Parent path not specified."
argument_list|)
throw|;
block|}
name|Path
name|parentPath
init|=
operator|new
name|Path
argument_list|(
name|commandLine
operator|.
name|getOptionValue
argument_list|(
name|PARENT_PATH
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|parentPath
operator|.
name|isAbsolute
argument_list|()
condition|)
block|{
name|parentPath
operator|=
name|parentPath
operator|.
name|getFileSystem
argument_list|(
name|getConf
argument_list|()
argument_list|)
operator|.
name|makeQualified
argument_list|(
name|parentPath
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|commandLine
operator|.
name|hasOption
argument_list|(
name|REPLICATION
argument_list|)
condition|)
block|{
name|repl
operator|=
name|Short
operator|.
name|parseShort
argument_list|(
name|commandLine
operator|.
name|getOptionValue
argument_list|(
name|REPLICATION
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Remaining args
name|args
operator|=
name|commandLine
operator|.
name|getArgs
argument_list|()
expr_stmt|;
name|List
argument_list|<
name|Path
argument_list|>
name|srcPaths
init|=
operator|new
name|ArrayList
argument_list|<
name|Path
argument_list|>
argument_list|()
decl_stmt|;
name|Path
name|destPath
init|=
literal|null
decl_stmt|;
comment|//read the rest of the paths
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|args
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
operator|(
name|args
operator|.
name|length
operator|-
literal|1
operator|)
condition|)
block|{
name|destPath
operator|=
operator|new
name|Path
argument_list|(
name|args
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|destPath
operator|.
name|isAbsolute
argument_list|()
condition|)
block|{
name|destPath
operator|=
name|destPath
operator|.
name|getFileSystem
argument_list|(
name|getConf
argument_list|()
argument_list|)
operator|.
name|makeQualified
argument_list|(
name|destPath
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|Path
name|argPath
init|=
operator|new
name|Path
argument_list|(
name|args
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|argPath
operator|.
name|isAbsolute
argument_list|()
condition|)
block|{
name|printUsage
argument_list|(
name|options
argument_list|,
literal|false
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Source path "
operator|+
name|argPath
operator|+
literal|" is not relative to "
operator|+
name|parentPath
argument_list|)
throw|;
block|}
name|srcPaths
operator|.
name|add
argument_list|(
operator|new
name|Path
argument_list|(
name|parentPath
argument_list|,
name|argPath
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|destPath
operator|==
literal|null
condition|)
block|{
name|printUsage
argument_list|(
name|options
argument_list|,
literal|false
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Destination path not specified."
argument_list|)
throw|;
block|}
if|if
condition|(
name|srcPaths
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
comment|// assuming if the user does not specify path for sources
comment|// the whole parent directory needs to be archived.
name|srcPaths
operator|.
name|add
argument_list|(
name|parentPath
argument_list|)
expr_stmt|;
block|}
comment|// do a glob on the srcPaths and then pass it on
name|List
argument_list|<
name|Path
argument_list|>
name|globPaths
init|=
operator|new
name|ArrayList
argument_list|<
name|Path
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Path
name|p
range|:
name|srcPaths
control|)
block|{
name|FileSystem
name|fs
init|=
name|p
operator|.
name|getFileSystem
argument_list|(
name|getConf
argument_list|()
argument_list|)
decl_stmt|;
name|FileStatus
index|[]
name|statuses
init|=
name|fs
operator|.
name|globStatus
argument_list|(
name|p
argument_list|)
decl_stmt|;
if|if
condition|(
name|statuses
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|FileStatus
name|status
range|:
name|statuses
control|)
block|{
name|globPaths
operator|.
name|add
argument_list|(
name|fs
operator|.
name|makeQualified
argument_list|(
name|status
operator|.
name|getPath
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|globPaths
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"The resolved paths set is empty."
operator|+
literal|"  Please check whether the srcPaths exist, where srcPaths = "
operator|+
name|srcPaths
argument_list|)
throw|;
block|}
name|archive
argument_list|(
name|parentPath
argument_list|,
name|globPaths
argument_list|,
name|archiveName
argument_list|,
name|destPath
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ie
parameter_list|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
name|ie
operator|.
name|getLocalizedMessage
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
DECL|field|TEST_HADOOP_ARCHIVES_JAR_PATH
specifier|static
specifier|final
name|String
name|TEST_HADOOP_ARCHIVES_JAR_PATH
init|=
literal|"test.hadoop.archives.jar"
decl_stmt|;
comment|/** the main functions **/
DECL|method|main (String[] args)
specifier|public
specifier|static
name|void
name|main
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
block|{
name|JobConf
name|job
init|=
operator|new
name|JobConf
argument_list|(
name|HadoopArchives
operator|.
name|class
argument_list|)
decl_stmt|;
name|HadoopArchives
name|harchives
init|=
operator|new
name|HadoopArchives
argument_list|(
name|job
argument_list|)
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
try|try
block|{
name|ret
operator|=
name|ToolRunner
operator|.
name|run
argument_list|(
name|harchives
argument_list|,
name|args
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Exception in archives  "
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
name|e
operator|.
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|" in archives"
argument_list|)
expr_stmt|;
specifier|final
name|String
name|s
init|=
name|e
operator|.
name|getLocalizedMessage
argument_list|()
decl_stmt|;
if|if
condition|(
name|s
operator|!=
literal|null
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|e
operator|.
name|printStackTrace
argument_list|(
name|System
operator|.
name|err
argument_list|)
expr_stmt|;
block|}
name|System
operator|.
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|System
operator|.
name|exit
argument_list|(
name|ret
argument_list|)
expr_stmt|;
block|}
block|}
end_class

end_unit

