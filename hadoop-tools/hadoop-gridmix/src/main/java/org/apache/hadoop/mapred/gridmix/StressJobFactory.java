begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *<p/>  * http://www.apache.org/licenses/LICENSE-2.0  *<p/>  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.mapred.gridmix
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|gridmix
package|;
end_package

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|ClusterStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|gridmix
operator|.
name|Statistics
operator|.
name|ClusterStats
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|gridmix
operator|.
name|Statistics
operator|.
name|JobStats
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|JobID
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|JobStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|UserGroupInformation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|tools
operator|.
name|rumen
operator|.
name|JobStory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|tools
operator|.
name|rumen
operator|.
name|JobStoryProducer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|CountDownLatch
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicBoolean
import|;
end_import

begin_class
DECL|class|StressJobFactory
specifier|public
class|class
name|StressJobFactory
extends|extends
name|JobFactory
argument_list|<
name|Statistics
operator|.
name|ClusterStats
argument_list|>
block|{
DECL|field|LOG
specifier|public
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|StressJobFactory
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|loadStatus
specifier|private
specifier|final
name|LoadStatus
name|loadStatus
init|=
operator|new
name|LoadStatus
argument_list|()
decl_stmt|;
comment|/**    * The minimum ratio between pending+running map tasks (aka. incomplete map    * tasks) and cluster map slot capacity for us to consider the cluster is    * overloaded. For running maps, we only count them partially. Namely, a 40%    * completed map is counted as 0.6 map tasks in our calculation.    */
DECL|field|OVERLOAD_MAPTASK_MAPSLOT_RATIO
specifier|private
specifier|static
specifier|final
name|float
name|OVERLOAD_MAPTASK_MAPSLOT_RATIO
init|=
literal|2.0f
decl_stmt|;
DECL|field|CONF_OVERLOAD_MAPTASK_MAPSLOT_RATIO
specifier|public
specifier|static
specifier|final
name|String
name|CONF_OVERLOAD_MAPTASK_MAPSLOT_RATIO
init|=
literal|"gridmix.throttle.maps.task-to-slot-ratio"
decl_stmt|;
DECL|field|overloadMapTaskMapSlotRatio
specifier|final
name|float
name|overloadMapTaskMapSlotRatio
decl_stmt|;
comment|/**    * The minimum ratio between pending+running reduce tasks (aka. incomplete    * reduce tasks) and cluster reduce slot capacity for us to consider the    * cluster is overloaded. For running reduces, we only count them partially.    * Namely, a 40% completed reduce is counted as 0.6 reduce tasks in our    * calculation.    */
DECL|field|OVERLOAD_REDUCETASK_REDUCESLOT_RATIO
specifier|private
specifier|static
specifier|final
name|float
name|OVERLOAD_REDUCETASK_REDUCESLOT_RATIO
init|=
literal|2.5f
decl_stmt|;
DECL|field|CONF_OVERLOAD_REDUCETASK_REDUCESLOT_RATIO
specifier|public
specifier|static
specifier|final
name|String
name|CONF_OVERLOAD_REDUCETASK_REDUCESLOT_RATIO
init|=
literal|"gridmix.throttle.reduces.task-to-slot-ratio"
decl_stmt|;
DECL|field|overloadReduceTaskReduceSlotRatio
specifier|final
name|float
name|overloadReduceTaskReduceSlotRatio
decl_stmt|;
comment|/**    * The maximum share of the cluster's mapslot capacity that can be counted    * toward a job's incomplete map tasks in overload calculation.    */
DECL|field|MAX_MAPSLOT_SHARE_PER_JOB
specifier|private
specifier|static
specifier|final
name|float
name|MAX_MAPSLOT_SHARE_PER_JOB
init|=
literal|0.1f
decl_stmt|;
DECL|field|CONF_MAX_MAPSLOT_SHARE_PER_JOB
specifier|public
specifier|static
specifier|final
name|String
name|CONF_MAX_MAPSLOT_SHARE_PER_JOB
init|=
literal|"gridmix.throttle.maps.max-slot-share-per-job"
decl_stmt|;
DECL|field|maxMapSlotSharePerJob
specifier|final
name|float
name|maxMapSlotSharePerJob
decl_stmt|;
comment|/**    * The maximum share of the cluster's reduceslot capacity that can be counted    * toward a job's incomplete reduce tasks in overload calculation.    */
DECL|field|MAX_REDUCESLOT_SHARE_PER_JOB
specifier|private
specifier|static
specifier|final
name|float
name|MAX_REDUCESLOT_SHARE_PER_JOB
init|=
literal|0.1f
decl_stmt|;
DECL|field|CONF_MAX_REDUCESLOT_SHARE_PER_JOB
specifier|public
specifier|static
specifier|final
name|String
name|CONF_MAX_REDUCESLOT_SHARE_PER_JOB
init|=
literal|"gridmix.throttle.reducess.max-slot-share-per-job"
decl_stmt|;
DECL|field|maxReduceSlotSharePerJob
specifier|final
name|float
name|maxReduceSlotSharePerJob
decl_stmt|;
comment|/**    * The ratio of the maximum number of pending+running jobs over the number of    * task trackers.    */
DECL|field|MAX_JOB_TRACKER_RATIO
specifier|private
specifier|static
specifier|final
name|float
name|MAX_JOB_TRACKER_RATIO
init|=
literal|1.0f
decl_stmt|;
DECL|field|CONF_MAX_JOB_TRACKER_RATIO
specifier|public
specifier|static
specifier|final
name|String
name|CONF_MAX_JOB_TRACKER_RATIO
init|=
literal|"gridmix.throttle.jobs-to-tracker-ratio"
decl_stmt|;
DECL|field|maxJobTrackerRatio
specifier|final
name|float
name|maxJobTrackerRatio
decl_stmt|;
comment|/**    * Represents a list of blacklisted jobs. Jobs are blacklisted when either     * they are complete or their status cannot be obtained. Stress mode will     * ignore blacklisted jobs from its overload computation.    */
DECL|field|blacklistedJobs
specifier|private
name|Set
argument_list|<
name|JobID
argument_list|>
name|blacklistedJobs
init|=
operator|new
name|HashSet
argument_list|<
name|JobID
argument_list|>
argument_list|()
decl_stmt|;
comment|/**    * Creating a new instance does not start the thread.    *    * @param submitter   Component to which deserialized jobs are passed    * @param jobProducer Stream of job traces with which to construct a    *                    {@link org.apache.hadoop.tools.rumen.ZombieJobProducer}    * @param scratch     Directory into which to write output from simulated jobs    * @param conf        Config passed to all jobs to be submitted    * @param startFlag   Latch released from main to start pipeline    * @throws java.io.IOException    */
DECL|method|StressJobFactory ( JobSubmitter submitter, JobStoryProducer jobProducer, Path scratch, Configuration conf, CountDownLatch startFlag, UserResolver resolver)
specifier|public
name|StressJobFactory
parameter_list|(
name|JobSubmitter
name|submitter
parameter_list|,
name|JobStoryProducer
name|jobProducer
parameter_list|,
name|Path
name|scratch
parameter_list|,
name|Configuration
name|conf
parameter_list|,
name|CountDownLatch
name|startFlag
parameter_list|,
name|UserResolver
name|resolver
parameter_list|)
throws|throws
name|IOException
block|{
name|super
argument_list|(
name|submitter
argument_list|,
name|jobProducer
argument_list|,
name|scratch
argument_list|,
name|conf
argument_list|,
name|startFlag
argument_list|,
name|resolver
argument_list|)
expr_stmt|;
name|overloadMapTaskMapSlotRatio
operator|=
name|conf
operator|.
name|getFloat
argument_list|(
name|CONF_OVERLOAD_MAPTASK_MAPSLOT_RATIO
argument_list|,
name|OVERLOAD_MAPTASK_MAPSLOT_RATIO
argument_list|)
expr_stmt|;
name|overloadReduceTaskReduceSlotRatio
operator|=
name|conf
operator|.
name|getFloat
argument_list|(
name|CONF_OVERLOAD_REDUCETASK_REDUCESLOT_RATIO
argument_list|,
name|OVERLOAD_REDUCETASK_REDUCESLOT_RATIO
argument_list|)
expr_stmt|;
name|maxMapSlotSharePerJob
operator|=
name|conf
operator|.
name|getFloat
argument_list|(
name|CONF_MAX_MAPSLOT_SHARE_PER_JOB
argument_list|,
name|MAX_MAPSLOT_SHARE_PER_JOB
argument_list|)
expr_stmt|;
name|maxReduceSlotSharePerJob
operator|=
name|conf
operator|.
name|getFloat
argument_list|(
name|CONF_MAX_REDUCESLOT_SHARE_PER_JOB
argument_list|,
name|MAX_REDUCESLOT_SHARE_PER_JOB
argument_list|)
expr_stmt|;
name|maxJobTrackerRatio
operator|=
name|conf
operator|.
name|getFloat
argument_list|(
name|CONF_MAX_JOB_TRACKER_RATIO
argument_list|,
name|MAX_JOB_TRACKER_RATIO
argument_list|)
expr_stmt|;
block|}
DECL|method|createReaderThread ()
specifier|public
name|Thread
name|createReaderThread
parameter_list|()
block|{
return|return
operator|new
name|StressReaderThread
argument_list|(
literal|"StressJobFactory"
argument_list|)
return|;
block|}
comment|/*   * Worker thread responsible for reading descriptions, assigning sequence   * numbers, and normalizing time.   */
DECL|class|StressReaderThread
specifier|private
class|class
name|StressReaderThread
extends|extends
name|Thread
block|{
DECL|method|StressReaderThread (String name)
specifier|public
name|StressReaderThread
parameter_list|(
name|String
name|name
parameter_list|)
block|{
name|super
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
comment|/**      * STRESS: Submits the job in STRESS mode.      * while(JT is overloaded) {      * wait();      * }      * If not overloaded , get number of slots available.      * Keep submitting the jobs till ,total jobs  is sufficient to      * load the JT.      * That is submit  (Sigma(no of maps/Job))> (2 * no of slots available)      */
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
try|try
block|{
name|startFlag
operator|.
name|await
argument_list|()
expr_stmt|;
if|if
condition|(
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|isInterrupted
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"[STRESS] Interrupted before start!. Exiting.."
argument_list|)
expr_stmt|;
return|return;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"START STRESS @ "
operator|+
name|System
operator|.
name|currentTimeMillis
argument_list|()
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|isInterrupted
argument_list|()
condition|)
block|{
try|try
block|{
while|while
condition|(
name|loadStatus
operator|.
name|overloaded
argument_list|()
condition|)
block|{
comment|// update the overload status
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Updating the overload status."
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|checkLoadAndGetSlotsToBackfill
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"[STRESS] Check failed!"
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// if the cluster is still overloaded, then sleep
if|if
condition|(
name|loadStatus
operator|.
name|overloaded
argument_list|()
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"[STRESS] Cluster overloaded in run! Sleeping..."
argument_list|)
expr_stmt|;
block|}
comment|// sleep
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"[STRESS] Interrupted while sleeping! Exiting."
argument_list|,
name|ie
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
while|while
condition|(
operator|!
name|loadStatus
operator|.
name|overloaded
argument_list|()
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"[STRESS] Cluster underloaded in run! Stressing..."
argument_list|)
expr_stmt|;
block|}
try|try
block|{
comment|//TODO This in-line read can block submission for large jobs.
specifier|final
name|JobStory
name|job
init|=
name|getNextJobFiltered
argument_list|()
decl_stmt|;
if|if
condition|(
literal|null
operator|==
name|job
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"[STRESS] Finished consuming the input trace. "
operator|+
literal|"Exiting.."
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Job Selected: "
operator|+
name|job
operator|.
name|getJobID
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|UserGroupInformation
name|ugi
init|=
name|UserGroupInformation
operator|.
name|createRemoteUser
argument_list|(
name|job
operator|.
name|getUser
argument_list|()
argument_list|)
decl_stmt|;
name|UserGroupInformation
name|tgtUgi
init|=
name|userResolver
operator|.
name|getTargetUgi
argument_list|(
name|ugi
argument_list|)
decl_stmt|;
name|GridmixJob
name|tJob
init|=
name|jobCreator
operator|.
name|createGridmixJob
argument_list|(
name|conf
argument_list|,
literal|0L
argument_list|,
name|job
argument_list|,
name|scratch
argument_list|,
name|tgtUgi
argument_list|,
name|sequence
operator|.
name|getAndIncrement
argument_list|()
argument_list|)
decl_stmt|;
comment|// submit the job
name|submitter
operator|.
name|add
argument_list|(
name|tJob
argument_list|)
expr_stmt|;
comment|// TODO: We need to take care of scenario when one map/reduce
comment|// takes more than 1 slot.
comment|// Lock the loadjob as we are making updates
name|int
name|incompleteMapTasks
init|=
operator|(
name|int
operator|)
name|calcEffectiveIncompleteMapTasks
argument_list|(
name|loadStatus
operator|.
name|getMapCapacity
argument_list|()
argument_list|,
name|job
operator|.
name|getNumberMaps
argument_list|()
argument_list|,
literal|0.0f
argument_list|)
decl_stmt|;
name|loadStatus
operator|.
name|decrementMapLoad
argument_list|(
name|incompleteMapTasks
argument_list|)
expr_stmt|;
name|int
name|incompleteReduceTasks
init|=
operator|(
name|int
operator|)
name|calcEffectiveIncompleteReduceTasks
argument_list|(
name|loadStatus
operator|.
name|getReduceCapacity
argument_list|()
argument_list|,
name|job
operator|.
name|getNumberReduces
argument_list|()
argument_list|,
literal|0.0f
argument_list|)
decl_stmt|;
name|loadStatus
operator|.
name|decrementReduceLoad
argument_list|(
name|incompleteReduceTasks
argument_list|)
expr_stmt|;
name|loadStatus
operator|.
name|decrementJobLoad
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"[STRESS] Error while submitting the job "
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|error
operator|=
name|e
expr_stmt|;
return|return;
block|}
block|}
block|}
finally|finally
block|{
comment|// do nothing
block|}
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"[STRESS] Interrupted in the main block!"
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return;
block|}
finally|finally
block|{
name|IOUtils
operator|.
name|cleanup
argument_list|(
literal|null
argument_list|,
name|jobProducer
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * STRESS Once you get the notification from StatsCollector.Collect the    * clustermetrics. Update current loadStatus with new load status of JT.    *    * @param item    */
annotation|@
name|Override
DECL|method|update (Statistics.ClusterStats item)
specifier|public
name|void
name|update
parameter_list|(
name|Statistics
operator|.
name|ClusterStats
name|item
parameter_list|)
block|{
name|ClusterStatus
name|clusterStatus
init|=
name|item
operator|.
name|getStatus
argument_list|()
decl_stmt|;
try|try
block|{
comment|// update the max cluster map/reduce task capacity
name|loadStatus
operator|.
name|updateMapCapacity
argument_list|(
name|clusterStatus
operator|.
name|getMaxMapTasks
argument_list|()
argument_list|)
expr_stmt|;
name|loadStatus
operator|.
name|updateReduceCapacity
argument_list|(
name|clusterStatus
operator|.
name|getMaxReduceTasks
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|numTrackers
init|=
name|clusterStatus
operator|.
name|getTaskTrackers
argument_list|()
decl_stmt|;
name|int
name|jobLoad
init|=
call|(
name|int
call|)
argument_list|(
name|maxJobTrackerRatio
operator|*
name|numTrackers
argument_list|)
operator|-
name|item
operator|.
name|getNumRunningJob
argument_list|()
decl_stmt|;
name|loadStatus
operator|.
name|updateJobLoad
argument_list|(
name|jobLoad
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Couldn't get the new Status"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|calcEffectiveIncompleteMapTasks (int mapSlotCapacity, int numMaps, float mapProgress)
name|float
name|calcEffectiveIncompleteMapTasks
parameter_list|(
name|int
name|mapSlotCapacity
parameter_list|,
name|int
name|numMaps
parameter_list|,
name|float
name|mapProgress
parameter_list|)
block|{
name|float
name|maxEffIncompleteMapTasks
init|=
name|Math
operator|.
name|max
argument_list|(
literal|1.0f
argument_list|,
name|mapSlotCapacity
operator|*
name|maxMapSlotSharePerJob
argument_list|)
decl_stmt|;
name|float
name|mapProgressAdjusted
init|=
name|Math
operator|.
name|max
argument_list|(
name|Math
operator|.
name|min
argument_list|(
name|mapProgress
argument_list|,
literal|1.0f
argument_list|)
argument_list|,
literal|0.0f
argument_list|)
decl_stmt|;
return|return
name|Math
operator|.
name|min
argument_list|(
name|maxEffIncompleteMapTasks
argument_list|,
name|numMaps
operator|*
operator|(
literal|1.0f
operator|-
name|mapProgressAdjusted
operator|)
argument_list|)
return|;
block|}
DECL|method|calcEffectiveIncompleteReduceTasks (int reduceSlotCapacity, int numReduces, float reduceProgress)
name|float
name|calcEffectiveIncompleteReduceTasks
parameter_list|(
name|int
name|reduceSlotCapacity
parameter_list|,
name|int
name|numReduces
parameter_list|,
name|float
name|reduceProgress
parameter_list|)
block|{
name|float
name|maxEffIncompleteReduceTasks
init|=
name|Math
operator|.
name|max
argument_list|(
literal|1.0f
argument_list|,
name|reduceSlotCapacity
operator|*
name|maxReduceSlotSharePerJob
argument_list|)
decl_stmt|;
name|float
name|reduceProgressAdjusted
init|=
name|Math
operator|.
name|max
argument_list|(
name|Math
operator|.
name|min
argument_list|(
name|reduceProgress
argument_list|,
literal|1.0f
argument_list|)
argument_list|,
literal|0.0f
argument_list|)
decl_stmt|;
return|return
name|Math
operator|.
name|min
argument_list|(
name|maxEffIncompleteReduceTasks
argument_list|,
name|numReduces
operator|*
operator|(
literal|1.0f
operator|-
name|reduceProgressAdjusted
operator|)
argument_list|)
return|;
block|}
comment|/**    * We try to use some light-weight mechanism to determine cluster load.    *    * @throws java.io.IOException    */
DECL|method|checkLoadAndGetSlotsToBackfill ()
specifier|protected
name|void
name|checkLoadAndGetSlotsToBackfill
parameter_list|()
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
if|if
condition|(
name|loadStatus
operator|.
name|getJobLoad
argument_list|()
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|+
literal|" [JobLoad] Overloaded is "
operator|+
name|Boolean
operator|.
name|TRUE
operator|.
name|toString
argument_list|()
operator|+
literal|" NumJobsBackfill is "
operator|+
name|loadStatus
operator|.
name|getJobLoad
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return;
comment|// stop calculation because we know it is overloaded.
block|}
name|int
name|mapCapacity
init|=
name|loadStatus
operator|.
name|getMapCapacity
argument_list|()
decl_stmt|;
name|int
name|reduceCapacity
init|=
name|loadStatus
operator|.
name|getReduceCapacity
argument_list|()
decl_stmt|;
comment|// return if the cluster status is not set
if|if
condition|(
name|mapCapacity
operator|<
literal|0
operator|||
name|reduceCapacity
operator|<
literal|0
condition|)
block|{
comment|// note that, by default, the overload status is true
comment|// missing cluster status will result into blocking of job submission
return|return;
block|}
comment|// Determine the max permissible map& reduce task load
name|int
name|maxMapLoad
init|=
call|(
name|int
call|)
argument_list|(
name|overloadMapTaskMapSlotRatio
operator|*
name|mapCapacity
argument_list|)
decl_stmt|;
name|int
name|maxReduceLoad
init|=
call|(
name|int
call|)
argument_list|(
name|overloadReduceTaskReduceSlotRatio
operator|*
name|reduceCapacity
argument_list|)
decl_stmt|;
comment|// compute the total number of map& reduce tasks submitted
name|int
name|totalMapTasks
init|=
name|ClusterStats
operator|.
name|getSubmittedMapTasks
argument_list|()
decl_stmt|;
name|int
name|totalReduceTasks
init|=
name|ClusterStats
operator|.
name|getSubmittedReduceTasks
argument_list|()
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Total submitted map tasks: "
operator|+
name|totalMapTasks
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Total submitted reduce tasks: "
operator|+
name|totalReduceTasks
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Max map load: "
operator|+
name|maxMapLoad
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Max reduce load: "
operator|+
name|maxReduceLoad
argument_list|)
expr_stmt|;
block|}
comment|// generate a pessimistic bound on the max running+pending map tasks
comment|// this check is to avoid the heavy-duty actual map load calculation
name|int
name|mapSlotsBackFill
init|=
call|(
name|int
call|)
argument_list|(
name|maxMapLoad
operator|-
name|totalMapTasks
argument_list|)
decl_stmt|;
comment|// generate a pessimistic bound on the max running+pending reduce tasks
comment|// this check is to avoid the heavy-duty actual reduce load calculation
name|int
name|reduceSlotsBackFill
init|=
call|(
name|int
call|)
argument_list|(
name|maxReduceLoad
operator|-
name|totalReduceTasks
argument_list|)
decl_stmt|;
comment|// maintain a list of seen job ids
name|Set
argument_list|<
name|JobID
argument_list|>
name|seenJobIDs
init|=
operator|new
name|HashSet
argument_list|<
name|JobID
argument_list|>
argument_list|()
decl_stmt|;
comment|// check if the total number of submitted map/reduce tasks exceeds the
comment|// permissible limit
if|if
condition|(
name|totalMapTasks
operator|>
name|maxMapLoad
operator|||
name|totalReduceTasks
operator|>
name|maxReduceLoad
condition|)
block|{
comment|// if yes, calculate the real load
name|float
name|incompleteMapTasks
init|=
literal|0
decl_stmt|;
comment|// include pending& running map tasks.
name|float
name|incompleteReduceTasks
init|=
literal|0
decl_stmt|;
comment|// include pending& running reduce tasks
for|for
control|(
name|JobStats
name|job
range|:
name|ClusterStats
operator|.
name|getRunningJobStats
argument_list|()
control|)
block|{
name|JobID
name|id
init|=
name|job
operator|.
name|getJob
argument_list|()
operator|.
name|getJobID
argument_list|()
decl_stmt|;
name|seenJobIDs
operator|.
name|add
argument_list|(
name|id
argument_list|)
expr_stmt|;
comment|// Note that this is a hack! Ideally, ClusterStats.getRunningJobStats()
comment|// should be smart enough to take care of completed jobs.
if|if
condition|(
name|blacklistedJobs
operator|.
name|contains
argument_list|(
name|id
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Ignoring blacklisted job: "
operator|+
name|id
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|int
name|noOfMaps
init|=
name|job
operator|.
name|getNoOfMaps
argument_list|()
decl_stmt|;
name|int
name|noOfReduces
init|=
name|job
operator|.
name|getNoOfReds
argument_list|()
decl_stmt|;
comment|// consider polling for jobs where maps>0 and reds>0
comment|// TODO: What about setup/cleanup tasks for cases where m=0 and r=0
comment|//       What otherwise?
if|if
condition|(
name|noOfMaps
operator|>
literal|0
operator|||
name|noOfReduces
operator|>
literal|0
condition|)
block|{
comment|// get the job's status
name|JobStatus
name|status
init|=
name|job
operator|.
name|getJobStatus
argument_list|()
decl_stmt|;
comment|// blacklist completed jobs and continue
if|if
condition|(
name|status
operator|!=
literal|null
operator|&&
name|status
operator|.
name|isJobComplete
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Blacklisting completed job: "
operator|+
name|id
argument_list|)
expr_stmt|;
name|blacklistedJobs
operator|.
name|add
argument_list|(
name|id
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|// get the map and reduce tasks' progress
name|float
name|mapProgress
init|=
literal|0f
decl_stmt|;
name|float
name|reduceProgress
init|=
literal|0f
decl_stmt|;
comment|// check if the status is missing (this can happen for unpolled jobs)
if|if
condition|(
name|status
operator|!=
literal|null
condition|)
block|{
name|mapProgress
operator|=
name|status
operator|.
name|getMapProgress
argument_list|()
expr_stmt|;
name|reduceProgress
operator|=
name|status
operator|.
name|getReduceProgress
argument_list|()
expr_stmt|;
block|}
name|incompleteMapTasks
operator|+=
name|calcEffectiveIncompleteMapTasks
argument_list|(
name|mapCapacity
argument_list|,
name|noOfMaps
argument_list|,
name|mapProgress
argument_list|)
expr_stmt|;
comment|// bail out early
name|int
name|currentMapSlotsBackFill
init|=
call|(
name|int
call|)
argument_list|(
name|maxMapLoad
operator|-
name|incompleteMapTasks
argument_list|)
decl_stmt|;
if|if
condition|(
name|currentMapSlotsBackFill
operator|<=
literal|0
condition|)
block|{
comment|// reset the reduce task load since we are bailing out
name|incompleteReduceTasks
operator|=
name|totalReduceTasks
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Terminating overload check due to high map load."
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
comment|// compute the real reduce load
if|if
condition|(
name|noOfReduces
operator|>
literal|0
condition|)
block|{
name|incompleteReduceTasks
operator|+=
name|calcEffectiveIncompleteReduceTasks
argument_list|(
name|reduceCapacity
argument_list|,
name|noOfReduces
argument_list|,
name|reduceProgress
argument_list|)
expr_stmt|;
block|}
comment|// bail out early
name|int
name|currentReduceSlotsBackFill
init|=
call|(
name|int
call|)
argument_list|(
name|maxReduceLoad
operator|-
name|incompleteReduceTasks
argument_list|)
decl_stmt|;
if|if
condition|(
name|currentReduceSlotsBackFill
operator|<=
literal|0
condition|)
block|{
comment|// reset the map task load since we are bailing out
name|incompleteMapTasks
operator|=
name|totalMapTasks
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Terminating overload check due to high reduce load."
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
else|else
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Blacklisting empty job: "
operator|+
name|id
argument_list|)
expr_stmt|;
name|blacklistedJobs
operator|.
name|add
argument_list|(
name|id
argument_list|)
expr_stmt|;
block|}
block|}
comment|// calculate the real map load on the cluster
name|mapSlotsBackFill
operator|=
call|(
name|int
call|)
argument_list|(
name|maxMapLoad
operator|-
name|incompleteMapTasks
argument_list|)
expr_stmt|;
comment|// calculate the real reduce load on the cluster
name|reduceSlotsBackFill
operator|=
call|(
name|int
call|)
argument_list|(
name|maxReduceLoad
operator|-
name|incompleteReduceTasks
argument_list|)
expr_stmt|;
comment|// clean up the backlisted set to keep the memory footprint minimal
comment|// retain only the jobs that are seen in this cycle
name|blacklistedJobs
operator|.
name|retainAll
argument_list|(
name|seenJobIDs
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
operator|&&
name|blacklistedJobs
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Blacklisted jobs count: "
operator|+
name|blacklistedJobs
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|// update
name|loadStatus
operator|.
name|updateMapLoad
argument_list|(
name|mapSlotsBackFill
argument_list|)
expr_stmt|;
name|loadStatus
operator|.
name|updateReduceLoad
argument_list|(
name|reduceSlotsBackFill
argument_list|)
expr_stmt|;
if|if
condition|(
name|loadStatus
operator|.
name|getMapLoad
argument_list|()
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|+
literal|" [MAP-LOAD] Overloaded is "
operator|+
name|Boolean
operator|.
name|TRUE
operator|.
name|toString
argument_list|()
operator|+
literal|" MapSlotsBackfill is "
operator|+
name|loadStatus
operator|.
name|getMapLoad
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return;
comment|// stop calculation because we know it is overloaded.
block|}
if|if
condition|(
name|loadStatus
operator|.
name|getReduceLoad
argument_list|()
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|+
literal|" [REDUCE-LOAD] Overloaded is "
operator|+
name|Boolean
operator|.
name|TRUE
operator|.
name|toString
argument_list|()
operator|+
literal|" ReduceSlotsBackfill is "
operator|+
name|loadStatus
operator|.
name|getReduceLoad
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return;
comment|// stop calculation because we know it is overloaded.
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|+
literal|" [OVERALL] Overloaded is "
operator|+
name|Boolean
operator|.
name|FALSE
operator|.
name|toString
argument_list|()
operator|+
literal|"Current load Status is "
operator|+
name|loadStatus
argument_list|)
expr_stmt|;
block|}
block|}
DECL|class|LoadStatus
specifier|static
class|class
name|LoadStatus
block|{
comment|/**      * Additional number of map slots that can be requested before      * declaring (by Gridmix STRESS mode) the cluster as overloaded.       */
DECL|field|mapSlotsBackfill
specifier|private
specifier|volatile
name|int
name|mapSlotsBackfill
decl_stmt|;
comment|/**      * Determines the total map slot capacity of the cluster.      */
DECL|field|mapSlotCapacity
specifier|private
specifier|volatile
name|int
name|mapSlotCapacity
decl_stmt|;
comment|/**      * Additional number of reduce slots that can be requested before      * declaring (by Gridmix STRESS mode) the cluster as overloaded.      */
DECL|field|reduceSlotsBackfill
specifier|private
specifier|volatile
name|int
name|reduceSlotsBackfill
decl_stmt|;
comment|/**      * Determines the total reduce slot capacity of the cluster.      */
DECL|field|reduceSlotCapacity
specifier|private
specifier|volatile
name|int
name|reduceSlotCapacity
decl_stmt|;
comment|/**      * Determines the max count of running jobs in the cluster.      */
DECL|field|numJobsBackfill
specifier|private
specifier|volatile
name|int
name|numJobsBackfill
decl_stmt|;
comment|// set the default to true
DECL|field|overloaded
specifier|private
name|AtomicBoolean
name|overloaded
init|=
operator|new
name|AtomicBoolean
argument_list|(
literal|true
argument_list|)
decl_stmt|;
comment|/**      * Construct the LoadStatus in an unknown state - assuming the cluster is      * overloaded by setting numSlotsBackfill=0.      */
DECL|method|LoadStatus ()
name|LoadStatus
parameter_list|()
block|{
name|mapSlotsBackfill
operator|=
literal|0
expr_stmt|;
name|reduceSlotsBackfill
operator|=
literal|0
expr_stmt|;
name|numJobsBackfill
operator|=
literal|0
expr_stmt|;
name|mapSlotCapacity
operator|=
operator|-
literal|1
expr_stmt|;
name|reduceSlotCapacity
operator|=
operator|-
literal|1
expr_stmt|;
block|}
DECL|method|getMapLoad ()
specifier|public
specifier|synchronized
name|int
name|getMapLoad
parameter_list|()
block|{
return|return
name|mapSlotsBackfill
return|;
block|}
DECL|method|getMapCapacity ()
specifier|public
specifier|synchronized
name|int
name|getMapCapacity
parameter_list|()
block|{
return|return
name|mapSlotCapacity
return|;
block|}
DECL|method|getReduceLoad ()
specifier|public
specifier|synchronized
name|int
name|getReduceLoad
parameter_list|()
block|{
return|return
name|reduceSlotsBackfill
return|;
block|}
DECL|method|getReduceCapacity ()
specifier|public
specifier|synchronized
name|int
name|getReduceCapacity
parameter_list|()
block|{
return|return
name|reduceSlotCapacity
return|;
block|}
DECL|method|getJobLoad ()
specifier|public
specifier|synchronized
name|int
name|getJobLoad
parameter_list|()
block|{
return|return
name|numJobsBackfill
return|;
block|}
DECL|method|decrementMapLoad (int mapSlotsConsumed)
specifier|public
specifier|synchronized
name|void
name|decrementMapLoad
parameter_list|(
name|int
name|mapSlotsConsumed
parameter_list|)
block|{
name|this
operator|.
name|mapSlotsBackfill
operator|-=
name|mapSlotsConsumed
expr_stmt|;
name|updateOverloadStatus
argument_list|()
expr_stmt|;
block|}
DECL|method|decrementReduceLoad (int reduceSlotsConsumed)
specifier|public
specifier|synchronized
name|void
name|decrementReduceLoad
parameter_list|(
name|int
name|reduceSlotsConsumed
parameter_list|)
block|{
name|this
operator|.
name|reduceSlotsBackfill
operator|-=
name|reduceSlotsConsumed
expr_stmt|;
name|updateOverloadStatus
argument_list|()
expr_stmt|;
block|}
DECL|method|decrementJobLoad (int numJobsConsumed)
specifier|public
specifier|synchronized
name|void
name|decrementJobLoad
parameter_list|(
name|int
name|numJobsConsumed
parameter_list|)
block|{
name|this
operator|.
name|numJobsBackfill
operator|-=
name|numJobsConsumed
expr_stmt|;
name|updateOverloadStatus
argument_list|()
expr_stmt|;
block|}
DECL|method|updateMapCapacity (int mapSlotsCapacity)
specifier|public
specifier|synchronized
name|void
name|updateMapCapacity
parameter_list|(
name|int
name|mapSlotsCapacity
parameter_list|)
block|{
name|this
operator|.
name|mapSlotCapacity
operator|=
name|mapSlotsCapacity
expr_stmt|;
name|updateOverloadStatus
argument_list|()
expr_stmt|;
block|}
DECL|method|updateReduceCapacity (int reduceSlotsCapacity)
specifier|public
specifier|synchronized
name|void
name|updateReduceCapacity
parameter_list|(
name|int
name|reduceSlotsCapacity
parameter_list|)
block|{
name|this
operator|.
name|reduceSlotCapacity
operator|=
name|reduceSlotsCapacity
expr_stmt|;
name|updateOverloadStatus
argument_list|()
expr_stmt|;
block|}
DECL|method|updateMapLoad (int mapSlotsBackfill)
specifier|public
specifier|synchronized
name|void
name|updateMapLoad
parameter_list|(
name|int
name|mapSlotsBackfill
parameter_list|)
block|{
name|this
operator|.
name|mapSlotsBackfill
operator|=
name|mapSlotsBackfill
expr_stmt|;
name|updateOverloadStatus
argument_list|()
expr_stmt|;
block|}
DECL|method|updateReduceLoad (int reduceSlotsBackfill)
specifier|public
specifier|synchronized
name|void
name|updateReduceLoad
parameter_list|(
name|int
name|reduceSlotsBackfill
parameter_list|)
block|{
name|this
operator|.
name|reduceSlotsBackfill
operator|=
name|reduceSlotsBackfill
expr_stmt|;
name|updateOverloadStatus
argument_list|()
expr_stmt|;
block|}
DECL|method|updateJobLoad (int numJobsBackfill)
specifier|public
specifier|synchronized
name|void
name|updateJobLoad
parameter_list|(
name|int
name|numJobsBackfill
parameter_list|)
block|{
name|this
operator|.
name|numJobsBackfill
operator|=
name|numJobsBackfill
expr_stmt|;
name|updateOverloadStatus
argument_list|()
expr_stmt|;
block|}
DECL|method|updateOverloadStatus ()
specifier|private
specifier|synchronized
name|void
name|updateOverloadStatus
parameter_list|()
block|{
name|overloaded
operator|.
name|set
argument_list|(
operator|(
name|mapSlotsBackfill
operator|<=
literal|0
operator|)
operator|||
operator|(
name|reduceSlotsBackfill
operator|<=
literal|0
operator|)
operator|||
operator|(
name|numJobsBackfill
operator|<=
literal|0
operator|)
argument_list|)
expr_stmt|;
block|}
DECL|method|overloaded ()
specifier|public
name|boolean
name|overloaded
parameter_list|()
block|{
return|return
name|overloaded
operator|.
name|get
argument_list|()
return|;
block|}
DECL|method|toString ()
specifier|public
specifier|synchronized
name|String
name|toString
parameter_list|()
block|{
comment|// TODO Use StringBuilder instead
return|return
literal|" Overloaded = "
operator|+
name|overloaded
argument_list|()
operator|+
literal|", MapSlotBackfill = "
operator|+
name|mapSlotsBackfill
operator|+
literal|", MapSlotCapacity = "
operator|+
name|mapSlotCapacity
operator|+
literal|", ReduceSlotBackfill = "
operator|+
name|reduceSlotsBackfill
operator|+
literal|", ReduceSlotCapacity = "
operator|+
name|reduceSlotCapacity
operator|+
literal|", NumJobsBackfill = "
operator|+
name|numJobsBackfill
return|;
block|}
block|}
comment|/**    * Start the reader thread, wait for latch if necessary.    */
annotation|@
name|Override
DECL|method|start ()
specifier|public
name|void
name|start
parameter_list|()
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|" Starting Stress submission "
argument_list|)
expr_stmt|;
name|this
operator|.
name|rThread
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
block|}
end_class

end_unit

