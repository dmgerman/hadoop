begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.streaming
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|streaming
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Properties
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|JobConf
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|Reporter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|OutputCollector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|streaming
operator|.
name|io
operator|.
name|InputWriter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|streaming
operator|.
name|io
operator|.
name|OutputReader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|streaming
operator|.
name|io
operator|.
name|TextInputWriter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|streaming
operator|.
name|io
operator|.
name|TextOutputReader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|LineReader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|ReflectionUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|Text
import|;
end_import

begin_comment
comment|/** Shared functionality for PipeMapper, PipeReducer.  */
end_comment

begin_class
DECL|class|PipeMapRed
specifier|public
specifier|abstract
class|class
name|PipeMapRed
block|{
DECL|field|LOG
specifier|protected
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|PipeMapRed
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
comment|/**    * Returns the Configuration.    */
DECL|method|getConfiguration ()
specifier|public
name|Configuration
name|getConfiguration
parameter_list|()
block|{
return|return
name|job_
return|;
block|}
comment|/**    * Returns the DataOutput to which the client input is written.    */
DECL|method|getClientOutput ()
specifier|public
name|DataOutput
name|getClientOutput
parameter_list|()
block|{
return|return
name|clientOut_
return|;
block|}
comment|/**    * Returns the DataInput from which the client output is read.    */
DECL|method|getClientInput ()
specifier|public
name|DataInput
name|getClientInput
parameter_list|()
block|{
return|return
name|clientIn_
return|;
block|}
comment|/**    * Returns the input separator to be used.    */
DECL|method|getInputSeparator ()
specifier|public
specifier|abstract
name|byte
index|[]
name|getInputSeparator
parameter_list|()
function_decl|;
comment|/**    * Returns the field separator to be used.    */
DECL|method|getFieldSeparator ()
specifier|public
specifier|abstract
name|byte
index|[]
name|getFieldSeparator
parameter_list|()
function_decl|;
comment|/**    * Returns the number of key fields.    */
DECL|method|getNumOfKeyFields ()
specifier|public
specifier|abstract
name|int
name|getNumOfKeyFields
parameter_list|()
function_decl|;
comment|/**     * Returns the command to be spawned as a subprocess.    * Mapper/Reducer operations will delegate to it    */
DECL|method|getPipeCommand (JobConf job)
specifier|abstract
name|String
name|getPipeCommand
parameter_list|(
name|JobConf
name|job
parameter_list|)
function_decl|;
DECL|method|getDoPipe ()
specifier|abstract
name|boolean
name|getDoPipe
parameter_list|()
function_decl|;
DECL|field|OUTSIDE
specifier|final
specifier|static
name|int
name|OUTSIDE
init|=
literal|1
decl_stmt|;
DECL|field|SINGLEQ
specifier|final
specifier|static
name|int
name|SINGLEQ
init|=
literal|2
decl_stmt|;
DECL|field|DOUBLEQ
specifier|final
specifier|static
name|int
name|DOUBLEQ
init|=
literal|3
decl_stmt|;
DECL|field|BUFFER_SIZE
specifier|private
specifier|final
specifier|static
name|int
name|BUFFER_SIZE
init|=
literal|128
operator|*
literal|1024
decl_stmt|;
DECL|method|splitArgs (String args)
specifier|static
name|String
index|[]
name|splitArgs
parameter_list|(
name|String
name|args
parameter_list|)
block|{
name|ArrayList
name|argList
init|=
operator|new
name|ArrayList
argument_list|()
decl_stmt|;
name|char
index|[]
name|ch
init|=
name|args
operator|.
name|toCharArray
argument_list|()
decl_stmt|;
name|int
name|clen
init|=
name|ch
operator|.
name|length
decl_stmt|;
name|int
name|state
init|=
name|OUTSIDE
decl_stmt|;
name|int
name|argstart
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|c
init|=
literal|0
init|;
name|c
operator|<=
name|clen
condition|;
name|c
operator|++
control|)
block|{
name|boolean
name|last
init|=
operator|(
name|c
operator|==
name|clen
operator|)
decl_stmt|;
name|int
name|lastState
init|=
name|state
decl_stmt|;
name|boolean
name|endToken
init|=
literal|false
decl_stmt|;
if|if
condition|(
operator|!
name|last
condition|)
block|{
if|if
condition|(
name|ch
index|[
name|c
index|]
operator|==
literal|'\''
condition|)
block|{
if|if
condition|(
name|state
operator|==
name|OUTSIDE
condition|)
block|{
name|state
operator|=
name|SINGLEQ
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|state
operator|==
name|SINGLEQ
condition|)
block|{
name|state
operator|=
name|OUTSIDE
expr_stmt|;
block|}
name|endToken
operator|=
operator|(
name|state
operator|!=
name|lastState
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
index|[
name|c
index|]
operator|==
literal|'"'
condition|)
block|{
if|if
condition|(
name|state
operator|==
name|OUTSIDE
condition|)
block|{
name|state
operator|=
name|DOUBLEQ
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|state
operator|==
name|DOUBLEQ
condition|)
block|{
name|state
operator|=
name|OUTSIDE
expr_stmt|;
block|}
name|endToken
operator|=
operator|(
name|state
operator|!=
name|lastState
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
index|[
name|c
index|]
operator|==
literal|' '
condition|)
block|{
if|if
condition|(
name|state
operator|==
name|OUTSIDE
condition|)
block|{
name|endToken
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|last
operator|||
name|endToken
condition|)
block|{
if|if
condition|(
name|c
operator|==
name|argstart
condition|)
block|{
comment|// unquoted space
block|}
else|else
block|{
name|String
name|a
decl_stmt|;
name|a
operator|=
name|args
operator|.
name|substring
argument_list|(
name|argstart
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|argList
operator|.
name|add
argument_list|(
name|a
argument_list|)
expr_stmt|;
block|}
name|argstart
operator|=
name|c
operator|+
literal|1
expr_stmt|;
name|lastState
operator|=
name|state
expr_stmt|;
block|}
block|}
return|return
operator|(
name|String
index|[]
operator|)
name|argList
operator|.
name|toArray
argument_list|(
operator|new
name|String
index|[
literal|0
index|]
argument_list|)
return|;
block|}
DECL|method|configure (JobConf job)
specifier|public
name|void
name|configure
parameter_list|(
name|JobConf
name|job
parameter_list|)
block|{
try|try
block|{
name|String
name|argv
init|=
name|getPipeCommand
argument_list|(
name|job
argument_list|)
decl_stmt|;
name|joinDelay_
operator|=
name|job
operator|.
name|getLong
argument_list|(
literal|"stream.joindelay.milli"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|job_
operator|=
name|job
expr_stmt|;
name|mapInputWriterClass_
operator|=
name|job_
operator|.
name|getClass
argument_list|(
literal|"stream.map.input.writer.class"
argument_list|,
name|TextInputWriter
operator|.
name|class
argument_list|,
name|InputWriter
operator|.
name|class
argument_list|)
expr_stmt|;
name|mapOutputReaderClass_
operator|=
name|job_
operator|.
name|getClass
argument_list|(
literal|"stream.map.output.reader.class"
argument_list|,
name|TextOutputReader
operator|.
name|class
argument_list|,
name|OutputReader
operator|.
name|class
argument_list|)
expr_stmt|;
name|reduceInputWriterClass_
operator|=
name|job_
operator|.
name|getClass
argument_list|(
literal|"stream.reduce.input.writer.class"
argument_list|,
name|TextInputWriter
operator|.
name|class
argument_list|,
name|InputWriter
operator|.
name|class
argument_list|)
expr_stmt|;
name|reduceOutputReaderClass_
operator|=
name|job_
operator|.
name|getClass
argument_list|(
literal|"stream.reduce.output.reader.class"
argument_list|,
name|TextOutputReader
operator|.
name|class
argument_list|,
name|OutputReader
operator|.
name|class
argument_list|)
expr_stmt|;
name|nonZeroExitIsFailure_
operator|=
name|job_
operator|.
name|getBoolean
argument_list|(
literal|"stream.non.zero.exit.is.failure"
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|doPipe_
operator|=
name|getDoPipe
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|doPipe_
condition|)
return|return;
name|setStreamJobDetails
argument_list|(
name|job
argument_list|)
expr_stmt|;
name|String
index|[]
name|argvSplit
init|=
name|splitArgs
argument_list|(
name|argv
argument_list|)
decl_stmt|;
name|String
name|prog
init|=
name|argvSplit
index|[
literal|0
index|]
decl_stmt|;
name|File
name|currentDir
init|=
operator|new
name|File
argument_list|(
literal|"."
argument_list|)
operator|.
name|getAbsoluteFile
argument_list|()
decl_stmt|;
if|if
condition|(
operator|new
name|File
argument_list|(
name|prog
argument_list|)
operator|.
name|isAbsolute
argument_list|()
condition|)
block|{
comment|// we don't own it. Hope it is executable
block|}
else|else
block|{
name|FileUtil
operator|.
name|chmod
argument_list|(
operator|new
name|File
argument_list|(
name|currentDir
argument_list|,
name|prog
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|,
literal|"a+x"
argument_list|)
expr_stmt|;
block|}
comment|//
comment|// argvSplit[0]:
comment|// An absolute path should be a preexisting valid path on all TaskTrackers
comment|// A relative path is converted into an absolute pathname by looking
comment|// up the PATH env variable. If it still fails, look it up in the
comment|// tasktracker's local working directory
comment|//
if|if
condition|(
operator|!
operator|new
name|File
argument_list|(
name|argvSplit
index|[
literal|0
index|]
argument_list|)
operator|.
name|isAbsolute
argument_list|()
condition|)
block|{
name|PathFinder
name|finder
init|=
operator|new
name|PathFinder
argument_list|(
literal|"PATH"
argument_list|)
decl_stmt|;
name|finder
operator|.
name|prependPathComponent
argument_list|(
name|currentDir
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|File
name|f
init|=
name|finder
operator|.
name|getAbsolutePath
argument_list|(
name|argvSplit
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|f
operator|!=
literal|null
condition|)
block|{
name|argvSplit
index|[
literal|0
index|]
operator|=
name|f
operator|.
name|getAbsolutePath
argument_list|()
expr_stmt|;
block|}
name|f
operator|=
literal|null
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"PipeMapRed exec "
operator|+
name|Arrays
operator|.
name|asList
argument_list|(
name|argvSplit
argument_list|)
argument_list|)
expr_stmt|;
name|Environment
name|childEnv
init|=
operator|(
name|Environment
operator|)
name|StreamUtil
operator|.
name|env
argument_list|()
operator|.
name|clone
argument_list|()
decl_stmt|;
name|addJobConfToEnvironment
argument_list|(
name|job_
argument_list|,
name|childEnv
argument_list|)
expr_stmt|;
name|addEnvironment
argument_list|(
name|childEnv
argument_list|,
name|job_
operator|.
name|get
argument_list|(
literal|"stream.addenvironment"
argument_list|)
argument_list|)
expr_stmt|;
comment|// add TMPDIR environment variable with the value of java.io.tmpdir
name|envPut
argument_list|(
name|childEnv
argument_list|,
literal|"TMPDIR"
argument_list|,
name|System
operator|.
name|getProperty
argument_list|(
literal|"java.io.tmpdir"
argument_list|)
argument_list|)
expr_stmt|;
comment|// Start the process
name|ProcessBuilder
name|builder
init|=
operator|new
name|ProcessBuilder
argument_list|(
name|argvSplit
argument_list|)
decl_stmt|;
name|builder
operator|.
name|environment
argument_list|()
operator|.
name|putAll
argument_list|(
name|childEnv
operator|.
name|toMap
argument_list|()
argument_list|)
expr_stmt|;
name|sim
operator|=
name|builder
operator|.
name|start
argument_list|()
expr_stmt|;
name|clientOut_
operator|=
operator|new
name|DataOutputStream
argument_list|(
operator|new
name|BufferedOutputStream
argument_list|(
name|sim
operator|.
name|getOutputStream
argument_list|()
argument_list|,
name|BUFFER_SIZE
argument_list|)
argument_list|)
expr_stmt|;
name|clientIn_
operator|=
operator|new
name|DataInputStream
argument_list|(
operator|new
name|BufferedInputStream
argument_list|(
name|sim
operator|.
name|getInputStream
argument_list|()
argument_list|,
name|BUFFER_SIZE
argument_list|)
argument_list|)
expr_stmt|;
name|clientErr_
operator|=
operator|new
name|DataInputStream
argument_list|(
operator|new
name|BufferedInputStream
argument_list|(
name|sim
operator|.
name|getErrorStream
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|startTime_
operator|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"configuration exception"
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"configuration exception"
argument_list|,
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"configuration exception"
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"configuration exception"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
DECL|method|setStreamJobDetails (JobConf job)
name|void
name|setStreamJobDetails
parameter_list|(
name|JobConf
name|job
parameter_list|)
block|{
name|String
name|s
init|=
name|job
operator|.
name|get
argument_list|(
literal|"stream.minRecWrittenToEnableSkip_"
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
operator|!=
literal|null
condition|)
block|{
name|minRecWrittenToEnableSkip_
operator|=
name|Long
operator|.
name|parseLong
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"JobConf set minRecWrittenToEnableSkip_ ="
operator|+
name|minRecWrittenToEnableSkip_
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|addJobConfToEnvironment (JobConf conf, Properties env)
name|void
name|addJobConfToEnvironment
parameter_list|(
name|JobConf
name|conf
parameter_list|,
name|Properties
name|env
parameter_list|)
block|{
name|Iterator
name|it
init|=
name|conf
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Map
operator|.
name|Entry
name|en
init|=
operator|(
name|Map
operator|.
name|Entry
operator|)
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|String
name|name
init|=
operator|(
name|String
operator|)
name|en
operator|.
name|getKey
argument_list|()
decl_stmt|;
comment|//String value = (String)en.getValue(); // does not apply variable expansion
name|String
name|value
init|=
name|conf
operator|.
name|get
argument_list|(
name|name
argument_list|)
decl_stmt|;
comment|// does variable expansion
name|name
operator|=
name|safeEnvVarName
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|envPut
argument_list|(
name|env
argument_list|,
name|name
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|safeEnvVarName (String var)
name|String
name|safeEnvVarName
parameter_list|(
name|String
name|var
parameter_list|)
block|{
name|StringBuffer
name|safe
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
name|int
name|len
init|=
name|var
operator|.
name|length
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|char
name|c
init|=
name|var
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|char
name|s
decl_stmt|;
if|if
condition|(
operator|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
operator|)
operator|||
operator|(
name|c
operator|>=
literal|'A'
operator|&&
name|c
operator|<=
literal|'Z'
operator|)
operator|||
operator|(
name|c
operator|>=
literal|'a'
operator|&&
name|c
operator|<=
literal|'z'
operator|)
condition|)
block|{
name|s
operator|=
name|c
expr_stmt|;
block|}
else|else
block|{
name|s
operator|=
literal|'_'
expr_stmt|;
block|}
name|safe
operator|.
name|append
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
return|return
name|safe
operator|.
name|toString
argument_list|()
return|;
block|}
DECL|method|addEnvironment (Properties env, String nameVals)
name|void
name|addEnvironment
parameter_list|(
name|Properties
name|env
parameter_list|,
name|String
name|nameVals
parameter_list|)
block|{
comment|// encoding "a=b c=d" from StreamJob
if|if
condition|(
name|nameVals
operator|==
literal|null
condition|)
return|return;
name|String
index|[]
name|nv
init|=
name|nameVals
operator|.
name|split
argument_list|(
literal|" "
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nv
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|String
index|[]
name|pair
init|=
name|nv
index|[
name|i
index|]
operator|.
name|split
argument_list|(
literal|"="
argument_list|,
literal|2
argument_list|)
decl_stmt|;
if|if
condition|(
name|pair
operator|.
name|length
operator|!=
literal|2
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Skip env entry:"
operator|+
name|nv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|envPut
argument_list|(
name|env
argument_list|,
name|pair
index|[
literal|0
index|]
argument_list|,
name|pair
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|envPut (Properties env, String name, String value)
name|void
name|envPut
parameter_list|(
name|Properties
name|env
parameter_list|,
name|String
name|name
parameter_list|,
name|String
name|value
parameter_list|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Add  env entry:"
operator|+
name|name
operator|+
literal|"="
operator|+
name|value
argument_list|)
expr_stmt|;
block|}
name|env
operator|.
name|put
argument_list|(
name|name
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
DECL|method|startOutputThreads (OutputCollector output, Reporter reporter)
name|void
name|startOutputThreads
parameter_list|(
name|OutputCollector
name|output
parameter_list|,
name|Reporter
name|reporter
parameter_list|)
throws|throws
name|IOException
block|{
name|inWriter_
operator|=
name|createInputWriter
argument_list|()
expr_stmt|;
name|outReader_
operator|=
name|createOutputReader
argument_list|()
expr_stmt|;
name|outThread_
operator|=
operator|new
name|MROutputThread
argument_list|(
name|outReader_
argument_list|,
name|output
argument_list|,
name|reporter
argument_list|)
expr_stmt|;
name|outThread_
operator|.
name|start
argument_list|()
expr_stmt|;
name|errThread_
operator|=
operator|new
name|MRErrorThread
argument_list|()
expr_stmt|;
name|errThread_
operator|.
name|setReporter
argument_list|(
name|reporter
argument_list|)
expr_stmt|;
name|errThread_
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
DECL|method|waitOutputThreads ()
name|void
name|waitOutputThreads
parameter_list|()
throws|throws
name|IOException
block|{
try|try
block|{
if|if
condition|(
name|outThread_
operator|==
literal|null
condition|)
block|{
comment|// This happens only when reducer has empty input(So reduce() is not
comment|// called at all in this task). If reducer still generates output,
comment|// which is very uncommon and we may not have to support this case.
comment|// So we don't write this output to HDFS, but we consume/collect
comment|// this output just to avoid reducer hanging forever.
name|OutputCollector
name|collector
init|=
operator|new
name|OutputCollector
argument_list|()
block|{
specifier|public
name|void
name|collect
parameter_list|(
name|Object
name|key
parameter_list|,
name|Object
name|value
parameter_list|)
throws|throws
name|IOException
block|{
comment|//just consume it, no need to write the record anywhere
block|}
block|}
decl_stmt|;
name|Reporter
name|reporter
init|=
name|Reporter
operator|.
name|NULL
decl_stmt|;
comment|//dummy reporter
name|startOutputThreads
argument_list|(
name|collector
argument_list|,
name|reporter
argument_list|)
expr_stmt|;
block|}
name|int
name|exitVal
init|=
name|sim
operator|.
name|waitFor
argument_list|()
decl_stmt|;
comment|// how'd it go?
if|if
condition|(
name|exitVal
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|nonZeroExitIsFailure_
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"PipeMapRed.waitOutputThreads(): subprocess failed with code "
operator|+
name|exitVal
argument_list|)
throw|;
block|}
else|else
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"PipeMapRed.waitOutputThreads(): subprocess exited with "
operator|+
literal|"code "
operator|+
name|exitVal
operator|+
literal|" in "
operator|+
name|PipeMapRed
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|outThread_
operator|!=
literal|null
condition|)
block|{
name|outThread_
operator|.
name|join
argument_list|(
name|joinDelay_
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|errThread_
operator|!=
literal|null
condition|)
block|{
name|errThread_
operator|.
name|join
argument_list|(
name|joinDelay_
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|outerrThreadsThrowable
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|outerrThreadsThrowable
argument_list|)
throw|;
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
comment|//ignore
block|}
block|}
DECL|method|createInputWriter ()
specifier|abstract
name|InputWriter
name|createInputWriter
parameter_list|()
throws|throws
name|IOException
function_decl|;
DECL|method|createInputWriter (Class<? extends InputWriter> inputWriterClass)
name|InputWriter
name|createInputWriter
parameter_list|(
name|Class
argument_list|<
name|?
extends|extends
name|InputWriter
argument_list|>
name|inputWriterClass
parameter_list|)
throws|throws
name|IOException
block|{
name|InputWriter
name|inputWriter
init|=
name|ReflectionUtils
operator|.
name|newInstance
argument_list|(
name|inputWriterClass
argument_list|,
name|job_
argument_list|)
decl_stmt|;
name|inputWriter
operator|.
name|initialize
argument_list|(
name|this
argument_list|)
expr_stmt|;
return|return
name|inputWriter
return|;
block|}
DECL|method|createOutputReader ()
specifier|abstract
name|OutputReader
name|createOutputReader
parameter_list|()
throws|throws
name|IOException
function_decl|;
DECL|method|createOutputReader (Class<? extends OutputReader> outputReaderClass)
name|OutputReader
name|createOutputReader
parameter_list|(
name|Class
argument_list|<
name|?
extends|extends
name|OutputReader
argument_list|>
name|outputReaderClass
parameter_list|)
throws|throws
name|IOException
block|{
name|OutputReader
name|outputReader
init|=
name|ReflectionUtils
operator|.
name|newInstance
argument_list|(
name|outputReaderClass
argument_list|,
name|job_
argument_list|)
decl_stmt|;
name|outputReader
operator|.
name|initialize
argument_list|(
name|this
argument_list|)
expr_stmt|;
return|return
name|outputReader
return|;
block|}
DECL|class|MROutputThread
class|class
name|MROutputThread
extends|extends
name|Thread
block|{
DECL|method|MROutputThread (OutputReader outReader, OutputCollector outCollector, Reporter reporter)
name|MROutputThread
parameter_list|(
name|OutputReader
name|outReader
parameter_list|,
name|OutputCollector
name|outCollector
parameter_list|,
name|Reporter
name|reporter
parameter_list|)
block|{
name|setDaemon
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|this
operator|.
name|outReader
operator|=
name|outReader
expr_stmt|;
name|this
operator|.
name|outCollector
operator|=
name|outCollector
expr_stmt|;
name|this
operator|.
name|reporter
operator|=
name|reporter
expr_stmt|;
block|}
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
try|try
block|{
comment|// 3/4 Tool to Hadoop
while|while
condition|(
name|outReader
operator|.
name|readKeyValue
argument_list|()
condition|)
block|{
name|Object
name|key
init|=
name|outReader
operator|.
name|getCurrentKey
argument_list|()
decl_stmt|;
name|Object
name|value
init|=
name|outReader
operator|.
name|getCurrentValue
argument_list|()
decl_stmt|;
name|outCollector
operator|.
name|collect
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|numRecWritten_
operator|++
expr_stmt|;
name|long
name|now
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
if|if
condition|(
name|now
operator|-
name|lastStdoutReport
operator|>
name|reporterOutDelay_
condition|)
block|{
name|lastStdoutReport
operator|=
name|now
expr_stmt|;
name|String
name|hline
init|=
literal|"Records R/W="
operator|+
name|numRecRead_
operator|+
literal|"/"
operator|+
name|numRecWritten_
decl_stmt|;
if|if
condition|(
operator|!
name|processProvidedStatus_
condition|)
block|{
name|reporter
operator|.
name|setStatus
argument_list|(
name|hline
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|reporter
operator|.
name|progress
argument_list|()
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
name|hline
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|th
parameter_list|)
block|{
name|outerrThreadsThrowable
operator|=
name|th
expr_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
name|th
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
try|try
block|{
if|if
condition|(
name|clientIn_
operator|!=
literal|null
condition|)
block|{
name|clientIn_
operator|.
name|close
argument_list|()
expr_stmt|;
name|clientIn_
operator|=
literal|null
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|io
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
name|io
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|field|outReader
name|OutputReader
name|outReader
init|=
literal|null
decl_stmt|;
DECL|field|outCollector
name|OutputCollector
name|outCollector
init|=
literal|null
decl_stmt|;
DECL|field|reporter
name|Reporter
name|reporter
init|=
literal|null
decl_stmt|;
DECL|field|lastStdoutReport
name|long
name|lastStdoutReport
init|=
literal|0
decl_stmt|;
block|}
DECL|class|MRErrorThread
class|class
name|MRErrorThread
extends|extends
name|Thread
block|{
DECL|method|MRErrorThread ()
specifier|public
name|MRErrorThread
parameter_list|()
block|{
name|this
operator|.
name|reporterPrefix
operator|=
name|job_
operator|.
name|get
argument_list|(
literal|"stream.stderr.reporter.prefix"
argument_list|,
literal|"reporter:"
argument_list|)
expr_stmt|;
name|this
operator|.
name|counterPrefix
operator|=
name|reporterPrefix
operator|+
literal|"counter:"
expr_stmt|;
name|this
operator|.
name|statusPrefix
operator|=
name|reporterPrefix
operator|+
literal|"status:"
expr_stmt|;
name|setDaemon
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
DECL|method|setReporter (Reporter reporter)
specifier|public
name|void
name|setReporter
parameter_list|(
name|Reporter
name|reporter
parameter_list|)
block|{
name|this
operator|.
name|reporter
operator|=
name|reporter
expr_stmt|;
block|}
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
name|Text
name|line
init|=
operator|new
name|Text
argument_list|()
decl_stmt|;
name|LineReader
name|lineReader
init|=
literal|null
decl_stmt|;
try|try
block|{
name|lineReader
operator|=
operator|new
name|LineReader
argument_list|(
operator|(
name|InputStream
operator|)
name|clientErr_
argument_list|,
name|job_
argument_list|)
expr_stmt|;
while|while
condition|(
name|lineReader
operator|.
name|readLine
argument_list|(
name|line
argument_list|)
operator|>
literal|0
condition|)
block|{
name|String
name|lineStr
init|=
name|line
operator|.
name|toString
argument_list|()
decl_stmt|;
if|if
condition|(
name|matchesReporter
argument_list|(
name|lineStr
argument_list|)
condition|)
block|{
if|if
condition|(
name|matchesCounter
argument_list|(
name|lineStr
argument_list|)
condition|)
block|{
name|incrCounter
argument_list|(
name|lineStr
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|matchesStatus
argument_list|(
name|lineStr
argument_list|)
condition|)
block|{
name|processProvidedStatus_
operator|=
literal|true
expr_stmt|;
name|setStatus
argument_list|(
name|lineStr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Cannot parse reporter line: "
operator|+
name|lineStr
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
name|lineStr
argument_list|)
expr_stmt|;
block|}
name|long
name|now
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
if|if
condition|(
name|reporter
operator|!=
literal|null
operator|&&
name|now
operator|-
name|lastStderrReport
operator|>
name|reporterErrDelay_
condition|)
block|{
name|lastStderrReport
operator|=
name|now
expr_stmt|;
name|reporter
operator|.
name|progress
argument_list|()
expr_stmt|;
block|}
name|line
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|lineReader
operator|!=
literal|null
condition|)
block|{
name|lineReader
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|clientErr_
operator|!=
literal|null
condition|)
block|{
name|clientErr_
operator|.
name|close
argument_list|()
expr_stmt|;
name|clientErr_
operator|=
literal|null
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"MRErrorThread done"
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|th
parameter_list|)
block|{
name|outerrThreadsThrowable
operator|=
name|th
expr_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
name|th
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
name|lineReader
operator|!=
literal|null
condition|)
block|{
name|lineReader
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|clientErr_
operator|!=
literal|null
condition|)
block|{
name|clientErr_
operator|.
name|close
argument_list|()
expr_stmt|;
name|clientErr_
operator|=
literal|null
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|io
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
name|io
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|matchesReporter (String line)
specifier|private
name|boolean
name|matchesReporter
parameter_list|(
name|String
name|line
parameter_list|)
block|{
return|return
name|line
operator|.
name|startsWith
argument_list|(
name|reporterPrefix
argument_list|)
return|;
block|}
DECL|method|matchesCounter (String line)
specifier|private
name|boolean
name|matchesCounter
parameter_list|(
name|String
name|line
parameter_list|)
block|{
return|return
name|line
operator|.
name|startsWith
argument_list|(
name|counterPrefix
argument_list|)
return|;
block|}
DECL|method|matchesStatus (String line)
specifier|private
name|boolean
name|matchesStatus
parameter_list|(
name|String
name|line
parameter_list|)
block|{
return|return
name|line
operator|.
name|startsWith
argument_list|(
name|statusPrefix
argument_list|)
return|;
block|}
DECL|method|incrCounter (String line)
specifier|private
name|void
name|incrCounter
parameter_list|(
name|String
name|line
parameter_list|)
block|{
name|String
name|trimmedLine
init|=
name|line
operator|.
name|substring
argument_list|(
name|counterPrefix
operator|.
name|length
argument_list|()
argument_list|)
operator|.
name|trim
argument_list|()
decl_stmt|;
name|String
index|[]
name|columns
init|=
name|trimmedLine
operator|.
name|split
argument_list|(
literal|","
argument_list|)
decl_stmt|;
if|if
condition|(
name|columns
operator|.
name|length
operator|==
literal|3
condition|)
block|{
try|try
block|{
name|reporter
operator|.
name|incrCounter
argument_list|(
name|columns
index|[
literal|0
index|]
argument_list|,
name|columns
index|[
literal|1
index|]
argument_list|,
name|Long
operator|.
name|parseLong
argument_list|(
name|columns
index|[
literal|2
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Cannot parse counter increment '"
operator|+
name|columns
index|[
literal|2
index|]
operator|+
literal|"' from line: "
operator|+
name|line
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Cannot parse counter line: "
operator|+
name|line
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|setStatus (String line)
specifier|private
name|void
name|setStatus
parameter_list|(
name|String
name|line
parameter_list|)
block|{
name|reporter
operator|.
name|setStatus
argument_list|(
name|line
operator|.
name|substring
argument_list|(
name|statusPrefix
operator|.
name|length
argument_list|()
argument_list|)
operator|.
name|trim
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|field|lastStderrReport
name|long
name|lastStderrReport
init|=
literal|0
decl_stmt|;
DECL|field|reporter
specifier|volatile
name|Reporter
name|reporter
decl_stmt|;
DECL|field|reporterPrefix
specifier|private
specifier|final
name|String
name|reporterPrefix
decl_stmt|;
DECL|field|counterPrefix
specifier|private
specifier|final
name|String
name|counterPrefix
decl_stmt|;
DECL|field|statusPrefix
specifier|private
specifier|final
name|String
name|statusPrefix
decl_stmt|;
block|}
DECL|method|mapRedFinished ()
specifier|public
name|void
name|mapRedFinished
parameter_list|()
block|{
try|try
block|{
if|if
condition|(
operator|!
name|doPipe_
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"mapRedFinished"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|clientOut_
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|clientOut_
operator|.
name|flush
argument_list|()
expr_stmt|;
name|clientOut_
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|io
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|io
argument_list|)
expr_stmt|;
block|}
block|}
try|try
block|{
name|waitOutputThreads
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|io
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|io
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sim
operator|!=
literal|null
condition|)
name|sim
operator|.
name|destroy
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"mapRedFinished"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RuntimeException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"PipeMapRed failed!"
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
DECL|method|maybeLogRecord ()
name|void
name|maybeLogRecord
parameter_list|()
block|{
if|if
condition|(
name|numRecRead_
operator|>=
name|nextRecReadLog_
condition|)
block|{
name|String
name|info
init|=
name|numRecInfo
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|nextRecReadLog_
operator|<
literal|100000
condition|)
block|{
name|nextRecReadLog_
operator|*=
literal|10
expr_stmt|;
block|}
else|else
block|{
name|nextRecReadLog_
operator|+=
literal|100000
expr_stmt|;
block|}
block|}
block|}
DECL|method|getContext ()
specifier|public
name|String
name|getContext
parameter_list|()
block|{
name|String
name|s
init|=
name|numRecInfo
argument_list|()
operator|+
literal|"\n"
decl_stmt|;
name|s
operator|+=
literal|"minRecWrittenToEnableSkip_="
operator|+
name|minRecWrittenToEnableSkip_
operator|+
literal|" "
expr_stmt|;
name|s
operator|+=
name|envline
argument_list|(
literal|"HOST"
argument_list|)
expr_stmt|;
name|s
operator|+=
name|envline
argument_list|(
literal|"USER"
argument_list|)
expr_stmt|;
name|s
operator|+=
name|envline
argument_list|(
literal|"HADOOP_USER"
argument_list|)
expr_stmt|;
if|if
condition|(
name|outThread_
operator|!=
literal|null
condition|)
block|{
name|s
operator|+=
literal|"last tool output: |"
operator|+
name|outReader_
operator|.
name|getLastOutput
argument_list|()
operator|+
literal|"|\n"
expr_stmt|;
block|}
return|return
name|s
return|;
block|}
DECL|method|envline (String var)
name|String
name|envline
parameter_list|(
name|String
name|var
parameter_list|)
block|{
return|return
name|var
operator|+
literal|"="
operator|+
name|StreamUtil
operator|.
name|env
argument_list|()
operator|.
name|get
argument_list|(
name|var
argument_list|)
operator|+
literal|"\n"
return|;
block|}
DECL|method|numRecInfo ()
name|String
name|numRecInfo
parameter_list|()
block|{
name|long
name|elapsed
init|=
operator|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|startTime_
operator|)
operator|/
literal|1000
decl_stmt|;
return|return
literal|"R/W/S="
operator|+
name|numRecRead_
operator|+
literal|"/"
operator|+
name|numRecWritten_
operator|+
literal|"/"
operator|+
name|numRecSkipped_
operator|+
literal|" in:"
operator|+
name|safeDiv
argument_list|(
name|numRecRead_
argument_list|,
name|elapsed
argument_list|)
operator|+
literal|" [rec/s]"
operator|+
literal|" out:"
operator|+
name|safeDiv
argument_list|(
name|numRecWritten_
argument_list|,
name|elapsed
argument_list|)
operator|+
literal|" [rec/s]"
return|;
block|}
DECL|method|safeDiv (long n, long d)
name|String
name|safeDiv
parameter_list|(
name|long
name|n
parameter_list|,
name|long
name|d
parameter_list|)
block|{
return|return
operator|(
name|d
operator|==
literal|0
operator|)
condition|?
literal|"NA"
else|:
literal|""
operator|+
name|n
operator|/
name|d
operator|+
literal|"="
operator|+
name|n
operator|+
literal|"/"
operator|+
name|d
return|;
block|}
DECL|field|startTime_
name|long
name|startTime_
decl_stmt|;
DECL|field|numRecRead_
name|long
name|numRecRead_
init|=
literal|0
decl_stmt|;
DECL|field|numRecWritten_
name|long
name|numRecWritten_
init|=
literal|0
decl_stmt|;
DECL|field|numRecSkipped_
name|long
name|numRecSkipped_
init|=
literal|0
decl_stmt|;
DECL|field|nextRecReadLog_
name|long
name|nextRecReadLog_
init|=
literal|1
decl_stmt|;
DECL|field|minRecWrittenToEnableSkip_
name|long
name|minRecWrittenToEnableSkip_
init|=
name|Long
operator|.
name|MAX_VALUE
decl_stmt|;
DECL|field|reporterOutDelay_
name|long
name|reporterOutDelay_
init|=
literal|10
operator|*
literal|1000L
decl_stmt|;
DECL|field|reporterErrDelay_
name|long
name|reporterErrDelay_
init|=
literal|10
operator|*
literal|1000L
decl_stmt|;
DECL|field|joinDelay_
name|long
name|joinDelay_
decl_stmt|;
DECL|field|job_
name|JobConf
name|job_
decl_stmt|;
DECL|field|doPipe_
name|boolean
name|doPipe_
decl_stmt|;
DECL|field|mapInputWriterClass_
name|Class
argument_list|<
name|?
extends|extends
name|InputWriter
argument_list|>
name|mapInputWriterClass_
decl_stmt|;
DECL|field|mapOutputReaderClass_
name|Class
argument_list|<
name|?
extends|extends
name|OutputReader
argument_list|>
name|mapOutputReaderClass_
decl_stmt|;
DECL|field|reduceInputWriterClass_
name|Class
argument_list|<
name|?
extends|extends
name|InputWriter
argument_list|>
name|reduceInputWriterClass_
decl_stmt|;
DECL|field|reduceOutputReaderClass_
name|Class
argument_list|<
name|?
extends|extends
name|OutputReader
argument_list|>
name|reduceOutputReaderClass_
decl_stmt|;
DECL|field|nonZeroExitIsFailure_
name|boolean
name|nonZeroExitIsFailure_
decl_stmt|;
DECL|field|sim
name|Process
name|sim
decl_stmt|;
DECL|field|inWriter_
name|InputWriter
name|inWriter_
decl_stmt|;
DECL|field|outReader_
name|OutputReader
name|outReader_
decl_stmt|;
DECL|field|outThread_
name|MROutputThread
name|outThread_
decl_stmt|;
DECL|field|errThread_
name|MRErrorThread
name|errThread_
decl_stmt|;
DECL|field|clientOut_
name|DataOutputStream
name|clientOut_
decl_stmt|;
DECL|field|clientErr_
name|DataInputStream
name|clientErr_
decl_stmt|;
DECL|field|clientIn_
name|DataInputStream
name|clientIn_
decl_stmt|;
comment|// set in PipeMapper/PipeReducer subclasses
DECL|field|numExceptions_
name|int
name|numExceptions_
decl_stmt|;
DECL|field|outerrThreadsThrowable
specifier|protected
specifier|volatile
name|Throwable
name|outerrThreadsThrowable
decl_stmt|;
DECL|field|processProvidedStatus_
specifier|volatile
name|boolean
name|processProvidedStatus_
init|=
literal|false
decl_stmt|;
block|}
end_class

end_unit

